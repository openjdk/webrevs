{"files":[{"patch":"@@ -1728,1 +1728,1 @@\n-%% This notice is provided with respect to Little CMS 2.12, which may be\n+%% This notice is provided with respect to Little CMS 2.16, which may be\n@@ -1733,2 +1733,1 @@\n-Little CMS\n-Copyright (c) 1998-2020 Marti Maria Saguer\n+MIT License\n@@ -1736,6 +1735,1 @@\n-Permission is hereby granted, free of charge, to any person obtaining a copy\n-of this software and associated documentation files (the \"Software\"), to deal\n-in the Software without restriction, including without limitation the rights\n-to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n-copies of the Software, and to permit persons to whom the Software is\n-furnished to do so, subject to the following conditions:\n+Copyright (C) 1998-2023 Marti Maria Saguer\n@@ -1743,2 +1737,6 @@\n-The above copyright notice and this permission notice shall be included in all\n-copies or substantial portions of the Software.\n+Permission is hereby granted, free of charge, to any person obtaining\n+a copy of this software and associated documentation files (the \"Software\"),\n+to deal in the Software without restriction, including without limitation\n+the rights to use, copy, modify, merge, publish, distribute, sublicense,\n+and\/or sell copies of the Software, and to permit persons to whom the Software\n+is furnished to do so, subject to the following conditions:\n@@ -1746,7 +1744,82 @@\n-THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n-SOFTWARE.\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO\n+THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+\n+---------------------------------\n+The below license applies to the following files:\n+liblcms\/cmssm.c\n+\n+Copyright 2001, softSurfer (www.softsurfer.com)\n+\n+This code may be freely used and modified for any purpose\n+providing that this copyright notice is included with it.\n+SoftSurfer makes no warranty for this code, and cannot be held\n+liable for any real or imagined damage resulting from its use.\n+Users of this code must verify correctness for their application.\n+\n+AUTHORS File Information:\n+\n+Main Author\n+------------\n+Marti Maria\n+\n+\n+Contributors\n+------------\n+Bob Friesenhahn\n+Kai-Uwe Behrmann\n+Stuart Nixon\n+Jordi Vilar\n+Richard Hughes\n+Auke Nauta\n+Chris Evans (Google)\n+Lorenzo Ridolfi\n+Robin Watts (Artifex)\n+Shawn Pedersen\n+Andrew Brygin\n+Samuli Suominen\n+Florian Hˆch\n+Aurelien Jarno\n+Claudiu Cebuc\n+Michael Vhrel (Artifex)\n+Michal Cihar\n+Daniel Kaneider\n+Mateusz Jurczyk (Google)\n+Paul Miller\n+SÈbastien LÈon\n+Christian Schmitz\n+XhmikosR\n+Stanislav Brabec (SuSe)\n+Leonhard Gruenschloss (Google)\n+Patrick Noffke\n+Christopher James Halse Rogers\n+John Hein\n+Thomas Weber (Debian)\n+Mark Allen\n+Noel Carboni\n+Sergei Trofimovic\n+Philipp Knechtges\n+Amyspark\n+Lovell Fuller\n+Eli Schwartz\n+Diogo Teles Sant'Anna\n+\n+Special Thanks\n+--------------\n+Artifex software\n+AlienSkin software\n+libVIPS\n+Jan Morovic\n+Jos Vernon (WebSupergoo)\n+Harald Schneider (Maxon)\n+Christian Albrecht\n+Dimitrios Anastassakis\n+Lemke Software\n+Tim Zaman\n","filename":"THIRD_PARTY_README","additions":91,"deletions":18,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -0,0 +1,23 @@\n+# Tips and tasks when updating LittleCMS sources to a newer version.\n+\n+Download and unzip latest release from https:\/\/sourceforge.net\/projects\/lcms\/files\/\n+Replace files in jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms with files from unzipped src and include folders\n+Replace is important because the lcms sources here are just the subset needed by JDK.\n+This is deliberate, so when updating be sure to import only the same files.\n+If a file has been removed from upstream you will notice it during the copy.\n+It should then be removed from the JDK sources.\n+If a new file is needed then the build will fail. Manually copy that in.\n+\n+Some re-editing of these updated files will be needed.\n+Use \"expand\" and \"sed\" to remove tabs and trailing white space from the imported files.\n+Re-apply the GPL headers used by the JDK. If done correctly these should then not\n+show up in the PR diff.\n+\n+Update THIRD_PARTY_README per the current license\/copyrights\/attributions etc.\n+\n+Build on all platforms.\n+If there are compiler warnings causing build failures, update the disabled warnings in\n+jdk\/make\/lib\/Awt2dLibraries.gmk \n+Run all automated client tests on all platforms.\n+Also run J2Ddemo and pay particular attention to the \"color\" tab.\n+Visually verify the color transforms against the same with the current\/previous JDK\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/UPDATING.txt","additions":23,"deletions":0,"binary":false,"changes":23,"status":"added"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -223,1 +223,1 @@\n-    *(cmsUInt8Number*)dst = _cmsQuickSaturateByte(n * 255.0f);\n+    *(cmsUInt8Number*)dst = _cmsQuickSaturateByte(n * 255.0);\n@@ -230,1 +230,1 @@\n-    *(cmsUInt16Number*)dst = _cmsQuickSaturateWord(n * 65535.0f);\n+    *(cmsUInt16Number*)dst = _cmsQuickSaturateWord(n * 65535.0);\n@@ -237,1 +237,1 @@\n-    cmsUInt16Number i = _cmsQuickSaturateWord(n * 65535.0f);\n+    cmsUInt16Number i = _cmsQuickSaturateWord(n * 65535.0);\n@@ -275,1 +275,1 @@\n-       *(cmsUInt8Number*)dst = _cmsQuickSaturateByte(n * 255.0f);\n+       *(cmsUInt8Number*)dst = _cmsQuickSaturateByte(n * 255.0);\n@@ -288,1 +288,1 @@\n-       *(cmsUInt16Number*)dst = _cmsQuickSaturateWord(n * 65535.0f);\n+       *(cmsUInt16Number*)dst = _cmsQuickSaturateWord(n * 65535.0);\n@@ -300,1 +300,1 @@\n-    cmsUInt16Number i = _cmsQuickSaturateWord(n * 65535.0f);\n+    cmsUInt16Number i = _cmsQuickSaturateWord(n * 65535.0);\n@@ -434,1 +434,1 @@\n-void ComputeIncrementsForChunky(cmsUInt32Number Format,\n+cmsBool ComputeIncrementsForChunky(cmsUInt32Number Format,\n@@ -446,3 +446,3 @@\n-           \/\/ Sanity check\n-           if (total_chans <= 0 || total_chans >= cmsMAXCHANNELS)\n-                   return;\n+       \/\/ Sanity check\n+       if (total_chans <= 0 || total_chans >= cmsMAXCHANNELS)\n+           return FALSE;\n@@ -485,0 +485,2 @@\n+\n+       return TRUE;\n@@ -491,1 +493,1 @@\n-void ComputeIncrementsForPlanar(cmsUInt32Number Format,\n+cmsBool ComputeIncrementsForPlanar(cmsUInt32Number Format,\n@@ -505,1 +507,1 @@\n-           return;\n+           return FALSE;\n@@ -541,0 +543,2 @@\n+\n+       return TRUE;\n@@ -547,1 +551,1 @@\n-void  ComputeComponentIncrements(cmsUInt32Number Format,\n+cmsBool ComputeComponentIncrements(cmsUInt32Number Format,\n@@ -554,1 +558,1 @@\n-              ComputeIncrementsForPlanar(Format,  BytesPerPlane, ComponentStartingOrder, ComponentPointerIncrements);\n+              return ComputeIncrementsForPlanar(Format,  BytesPerPlane, ComponentStartingOrder, ComponentPointerIncrements);\n@@ -557,1 +561,1 @@\n-              ComputeIncrementsForChunky(Format,  ComponentStartingOrder, ComponentPointerIncrements);\n+              return ComputeIncrementsForChunky(Format,  ComponentStartingOrder, ComponentPointerIncrements);\n@@ -562,2 +566,0 @@\n-\n-\n@@ -598,2 +600,4 @@\n-    ComputeComponentIncrements(p->InputFormat, Stride->BytesPerPlaneIn, SourceStartingOrder, SourceIncrements);\n-    ComputeComponentIncrements(p->OutputFormat, Stride->BytesPerPlaneOut, DestStartingOrder, DestIncrements);\n+    if (!ComputeComponentIncrements(p->InputFormat, Stride->BytesPerPlaneIn, SourceStartingOrder, SourceIncrements))\n+        return;\n+    if (!ComputeComponentIncrements(p->OutputFormat, Stride->BytesPerPlaneOut, DestStartingOrder, DestIncrements))\n+        return;\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsalpha.c","additions":24,"deletions":20,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -356,1 +356,1 @@\n-    M[8] = (( 0.0030 *  0.201908) + (0.0136 * 0.000008) + 0.9834);;\n+    M[8] = (( 0.0030 *  0.201908) + (0.0136 * 0.000008) + 0.9834);\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmscam02.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -90,1 +90,1 @@\n-        \/\/ Keywords\n+        \/\/ IT8 symbols\n@@ -98,1 +98,13 @@\n-        SINCLUDE\n+        SINCLUDE,\n+\n+        \/\/ Cube symbols\n+\n+        SDOMAIN_MAX,\n+        SDOMAIN_MIN,\n+        S_LUT1D_SIZE,\n+        S_LUT1D_INPUT_RANGE,\n+        S_LUT3D_SIZE,\n+        S_LUT3D_INPUT_RANGE,\n+        S_LUT_IN_VIDEO_RANGE,\n+        S_LUT_OUT_VIDEO_RANGE,\n+        STITLE\n@@ -165,1 +177,1 @@\n-\/\/ This struct hold all information about an open IT8 handler.\n+\/\/Very simple string\n@@ -168,0 +180,9 @@\n+        struct struct_it8* it8;\n+        cmsInt32Number max;\n+        cmsInt32Number len;\n+        char* begin;\n+    } string;\n+\n+\n+\/\/ This struct hold all information about an open IT8 handler.\n+typedef struct struct_it8 {\n@@ -172,0 +193,4 @@\n+        \/\/ Partser type\n+        cmsBool        IsCUBE;\n+\n+        \/\/ Tables\n@@ -185,2 +210,2 @@\n-        char           id[MAXID];             \/\/ identifier\n-        char           str[MAXSTR];           \/\/ string\n+        string*        id;            \/\/ identifier\n+        string*        str;           \/\/ string\n@@ -231,2 +256,2 @@\n-\/\/ The keyword->symbol translation table. Sorting is required.\n-static const KEYWORD TabKeys[] = {\n+\/\/ The keyword->symbol translation tables. Sorting is required.\n+static const KEYWORD TabKeysIT8[] = {\n@@ -245,1 +270,19 @@\n-#define NUMKEYS (sizeof(TabKeys)\/sizeof(KEYWORD))\n+#define NUMKEYS_IT8 (sizeof(TabKeysIT8)\/sizeof(KEYWORD))\n+\n+static const KEYWORD TabKeysCUBE[] = {\n+\n+        {\"DOMAIN_MAX\",             SDOMAIN_MAX },\n+        {\"DOMAIN_MIN\",             SDOMAIN_MIN },\n+        {\"LUT_1D_SIZE\",            S_LUT1D_SIZE },\n+        {\"LUT_1D_INPUT_RANGE\",     S_LUT1D_INPUT_RANGE },\n+        {\"LUT_3D_SIZE\",            S_LUT3D_SIZE },\n+        {\"LUT_3D_INPUT_RANGE\",     S_LUT3D_INPUT_RANGE },\n+        {\"LUT_IN_VIDEO_RANGE\",     S_LUT_IN_VIDEO_RANGE },\n+        {\"LUT_OUT_VIDEO_RANGE\",    S_LUT_OUT_VIDEO_RANGE },\n+        {\"TITLE\",                  STITLE }\n+\n+};\n+\n+#define NUMKEYS_CUBE (sizeof(TabKeysCUBE)\/sizeof(KEYWORD))\n+\n+\n@@ -271,1 +314,1 @@\n-                                                  \/\/ physical targets only (i.e . IT8.7\/1 a nd IT8.7\/2).\n+                                                  \/\/ physical targets only (i.e . IT8.7\/1 and IT8.7\/2).\n@@ -386,0 +429,59 @@\n+static\n+string* StringAlloc(cmsIT8* it8, int max)\n+{\n+    string* s = (string*) AllocChunk(it8, sizeof(string));\n+    if (s == NULL) return NULL;\n+\n+    s->it8 = it8;\n+    s->max = max;\n+    s->len = 0;\n+    s->begin = (char*) AllocChunk(it8, s->max);\n+\n+    return s;\n+}\n+\n+static\n+void StringClear(string* s)\n+{\n+    s->len = 0;\n+}\n+\n+static\n+void StringAppend(string* s, char c)\n+{\n+    if (s->len + 1 >= s->max)\n+    {\n+        char* new_ptr;\n+\n+        s->max *= 10;\n+        new_ptr = (char*) AllocChunk(s->it8, s->max);\n+        if (new_ptr != NULL && s->begin != NULL)\n+            memcpy(new_ptr, s->begin, s->len);\n+\n+        s->begin = new_ptr;\n+    }\n+\n+    if (s->begin != NULL)\n+    {\n+        s->begin[s->len++] = c;\n+        s->begin[s->len] = 0;\n+    }\n+}\n+\n+static\n+char* StringPtr(string* s)\n+{\n+    return s->begin;\n+}\n+\n+static\n+void StringCat(string* s, const char* c)\n+{\n+    while (*c)\n+    {\n+        StringAppend(s, *c);\n+        c++;\n+    }\n+}\n+\n+\n@@ -390,1 +492,1 @@\n-    return (c == ' ') || (c == '\\t') ;\n+    return (c == ' ') || (c == '\\t');\n@@ -411,1 +513,1 @@\n-     return !isdigit(c) && ismiddle(c);\n+     return c != '-' && !isdigit(c) && ismiddle(c);\n@@ -450,1 +552,1 @@\n-        strncpy(buffer, relPath, MaxLen);\n+        memcpy(buffer, relPath, MaxLen);\n@@ -456,1 +558,1 @@\n-    strncpy(buffer, basePath, MaxLen);\n+    memcpy(buffer, basePath, MaxLen);\n@@ -538,1 +640,1 @@\n-SYMBOL BinSrchKey(const char *id)\n+SYMBOL BinSrchKey(const char *id, int NumKeys, const KEYWORD* TabKeys)\n@@ -541,1 +643,1 @@\n-    int r = NUMKEYS;\n+    int r = NumKeys;\n@@ -711,0 +813,33 @@\n+\/\/ Reads a string, special case to avoid infinite recursion on .include\n+static\n+void InStringSymbol(cmsIT8* it8)\n+{\n+    while (isseparator(it8->ch))\n+        NextCh(it8);\n+\n+    if (it8->ch == '\\'' || it8->ch == '\\\"')\n+    {\n+        int sng;\n+\n+        sng = it8->ch;\n+        StringClear(it8->str);\n+\n+        NextCh(it8);\n+\n+        while (it8->ch != sng) {\n+\n+            if (it8->ch == '\\n' || it8->ch == '\\r' || it8->ch == 0) break;\n+            else {\n+                StringAppend(it8->str, (char)it8->ch);\n+                NextCh(it8);\n+            }\n+        }\n+\n+        it8->sy = SSTRING;\n+        NextCh(it8);\n+    }\n+    else\n+        SynError(it8, \"String expected\");\n+\n+}\n+\n@@ -715,2 +850,0 @@\n-    CMSREGISTER char *idptr;\n-    CMSREGISTER int k;\n@@ -718,1 +851,0 @@\n-    int sng;\n@@ -727,2 +859,1 @@\n-            k = 0;\n-            idptr = it8->id;\n+            StringClear(it8->id);\n@@ -732,1 +863,1 @@\n-                if (++k < MAXID) *idptr++ = (char) it8->ch;\n+                StringAppend(it8->id, (char) it8->ch);\n@@ -738,1 +869,0 @@\n-            *idptr = '\\0';\n@@ -740,2 +870,3 @@\n-\n-            key = BinSrchKey(it8->id);\n+            key = BinSrchKey(StringPtr(it8->id),\n+                    it8->IsCUBE ? NUMKEYS_CUBE : NUMKEYS_IT8,\n+                    it8->IsCUBE ? TabKeysCUBE : TabKeysIT8);\n@@ -776,0 +907,1 @@\n+                                it8->sy = SEOF;\n@@ -797,0 +929,1 @@\n+                                it8->sy = SEOF;\n@@ -837,0 +970,2 @@\n+                    char buffer[127];\n+\n@@ -839,1 +974,1 @@\n-                        snprintf(it8->id, 127, \"%d\", it8->inum);\n+                        snprintf(buffer, sizeof(buffer), \"%d\", it8->inum);\n@@ -843,1 +978,1 @@\n-                        snprintf(it8->id, 127, it8 ->DoubleFormatter, it8->dnum);\n+                        snprintf(buffer, sizeof(buffer), it8 ->DoubleFormatter, it8->dnum);\n@@ -846,2 +981,3 @@\n-                    k = (int) strlen(it8 ->id);\n-                    idptr = it8 ->id + k;\n+                    StringClear(it8->id);\n+                    StringCat(it8->id, buffer);\n+\n@@ -850,1 +986,1 @@\n-                        if (++k < MAXID) *idptr++ = (char) it8->ch;\n+                        StringAppend(it8->id, (char) it8->ch);\n@@ -856,1 +992,0 @@\n-                    *idptr = '\\0';\n@@ -865,5 +1000,0 @@\n-        \/\/ EOF marker -- ignore it\n-        case '\\x1a':\n-            NextCh(it8);\n-            break;\n-\n@@ -871,0 +1001,1 @@\n+        case '\\x1a':\n@@ -880,1 +1011,1 @@\n-            if (it8 ->ch == '\\n')\n+            if (it8->ch == '\\n')\n@@ -904,18 +1035,1 @@\n-            idptr = it8->str;\n-            sng = it8->ch;\n-            k = 0;\n-            NextCh(it8);\n-\n-            while (k < (MAXSTR-1) && it8->ch != sng) {\n-\n-                if (it8->ch == '\\n'|| it8->ch == '\\r') k = MAXSTR+1;\n-                else {\n-                    *idptr++ = (char) it8->ch;\n-                    NextCh(it8);\n-                    k++;\n-                }\n-            }\n-\n-            it8->sy = SSTRING;\n-            *idptr = '\\0';\n-            NextCh(it8);\n+            InStringSymbol(it8);\n@@ -927,0 +1041,1 @@\n+            it8->sy = SEOF;\n@@ -941,0 +1056,1 @@\n+                    it8->sy = SEOF;\n@@ -944,2 +1060,6 @@\n-                InSymbol(it8);\n-                if (!Check(it8, SSTRING, \"Filename expected\")) return;\n+                InStringSymbol(it8);\n+                if (!Check(it8, SSTRING, \"Filename expected\"))\n+                {\n+                    it8->sy = SEOF;\n+                    return;\n+                }\n@@ -951,2 +1071,5 @@\n-                    \/\/if(FileNest == NULL)\n-                    \/\/  TODO: how to manage out-of-memory conditions?\n+                    if (FileNest == NULL) {\n+                        SynError(it8, \"Out of memory\");\n+                        it8->sy = SEOF;\n+                        return;\n+                    }\n@@ -955,1 +1078,1 @@\n-                if (BuildAbsolutePath(it8->str,\n+                if (BuildAbsolutePath(StringPtr(it8->str),\n@@ -959,0 +1082,1 @@\n+                    it8->sy = SEOF;\n@@ -966,0 +1090,1 @@\n+                        it8->sy = SEOF;\n@@ -1016,1 +1141,1 @@\n-    case SIDENT:  strncpy(Buffer, it8->id, max);\n+    case SIDENT:  strncpy(Buffer, StringPtr(it8->id), max);\n@@ -1021,1 +1146,1 @@\n-    case SSTRING: strncpy(Buffer, it8->str, max);\n+    case SSTRING: strncpy(Buffer, StringPtr(it8->str), max);\n@@ -1126,1 +1251,1 @@\n-        it8 ->Allocator.Block = (cmsUInt8Number*)  AllocBigBlock(it8, it8 ->Allocator.BlockSize);\n+        it8 ->Allocator.Block = (cmsUInt8Number*) AllocBigBlock(it8, it8 ->Allocator.BlockSize);\n@@ -1129,0 +1254,3 @@\n+    if (it8->Allocator.Block == NULL)\n+        return NULL;\n+\n@@ -1146,1 +1274,1 @@\n-    if (ptr) strncpy (ptr, str, Size-1);\n+    if (ptr) memcpy(ptr, str, Size-1);\n@@ -1204,1 +1332,6 @@\n-        \/\/     return SynError(it8, \"duplicate key <%s>\", Key);\n+        if (cmsstrcasecmp(Key, \"NUMBER_OF_FIELDS\") == 0 ||\n+            cmsstrcasecmp(Key, \"NUMBER_OF_SETS\") == 0) {\n+\n+            SynError(it8, \"duplicate key <%s>\", Key);\n+            return NULL;\n+        }\n@@ -1325,0 +1458,2 @@\n+    it8->IsCUBE = FALSE;\n+\n@@ -1345,0 +1480,3 @@\n+    it8->id = StringAlloc(it8, MAXSTR);\n+    it8->str = StringAlloc(it8, MAXSTR);\n+\n@@ -1466,0 +1604,15 @@\n+\/\/ A safe atoi that returns 0 when NULL input is given\n+static\n+cmsInt32Number satoi(const char* b)\n+{\n+    int n;\n+\n+    if (b == NULL) return 0;\n+\n+    n = atoi(b);\n+    if (n > 0x7fffffffL) return 0x7fffffffL;\n+    if (n < -0x7ffffffeL) return -0x7ffffffeL;\n+\n+    return (cmsInt32Number)n;\n+}\n+\n@@ -1468,1 +1621,1 @@\n-void AllocateDataFormat(cmsIT8* it8)\n+cmsBool AllocateDataFormat(cmsIT8* it8)\n@@ -1472,1 +1625,1 @@\n-    if (t -> DataFormat) return;    \/\/ Already allocated\n+    if (t -> DataFormat) return TRUE;    \/\/ Already allocated\n@@ -1474,1 +1627,1 @@\n-    t -> nSamples  = (int) cmsIT8GetPropertyDbl(it8, \"NUMBER_OF_FIELDS\");\n+    t -> nSamples  = satoi(cmsIT8GetProperty(it8, \"NUMBER_OF_FIELDS\"));\n@@ -1479,1 +1632,1 @@\n-        t -> nSamples = 10;\n+        return FALSE;\n@@ -1486,0 +1639,1 @@\n+        return FALSE;\n@@ -1488,0 +1642,1 @@\n+    return TRUE;\n@@ -1506,2 +1661,5 @@\n-    if (!t->DataFormat)\n-        AllocateDataFormat(it8);\n+    if (!t->DataFormat) {\n+\n+        if (!AllocateDataFormat(it8))\n+            return FALSE;\n+    }\n@@ -1516,0 +1674,1 @@\n+        if (t->DataFormat[n] == NULL) return FALSE;\n@@ -1528,1 +1687,1 @@\n-\/\/ A safe atoi that returns 0 when NULL input is given\n+\/\/ Convert to binary\n@@ -1530,1 +1689,1 @@\n-cmsInt32Number satoi(const char* b)\n+const char* satob(const char* v)\n@@ -1532,2 +1691,12 @@\n-    if (b == NULL) return 0;\n-    return atoi(b);\n+    cmsUInt32Number x;\n+    static char buf[33];\n+    char *s = buf + 33;\n+\n+    if (v == NULL) return \"0\";\n+\n+    x = atoi(v);\n+    *--s = 0;\n+    if (!x) *--s = '0';\n+    for (; x; x \/= 2) *--s = '0' + x%2;\n+\n+    return s;\n@@ -1536,0 +1705,1 @@\n+\n@@ -1537,1 +1707,1 @@\n-void AllocateDataSet(cmsIT8* it8)\n+cmsBool AllocateDataSet(cmsIT8* it8)\n@@ -1541,1 +1711,1 @@\n-    if (t -> Data) return;    \/\/ Already allocated\n+    if (t -> Data) return TRUE;    \/\/ Already allocated\n@@ -1549,0 +1719,1 @@\n+        return FALSE;\n@@ -1556,0 +1727,1 @@\n+            return FALSE;\n@@ -1559,0 +1731,1 @@\n+    return TRUE;\n@@ -1568,1 +1741,1 @@\n-    if (nSet >= nPatches || nField >= nSamples)\n+    if (nSet < 0 || nSet >= nPatches || nField < 0 || nField >= nSamples)\n@@ -1580,2 +1753,3 @@\n-    if (!t->Data)\n-        AllocateDataSet(it8);\n+    if (!t->Data) {\n+        if (!AllocateDataSet(it8)) return FALSE;\n+    }\n@@ -1721,1 +1895,1 @@\n-                    Writef(fp, \"\\t0x%B\", satoi(p ->Value));\n+                    Writef(fp, \"\\t0b%s\", satob(p ->Value));\n@@ -1752,1 +1926,3 @@\n-       for (i = 0; i < nSamples; i++) {\n+       if (nSamples <= t->nSamples) {\n+\n+           for (i = 0; i < nSamples; i++) {\n@@ -1754,3 +1930,4 @@\n-              WriteStr(fp, t->DataFormat[i]);\n-              WriteStr(fp, ((i == (nSamples-1)) ? \"\\n\" : \"\\t\"));\n-          }\n+               WriteStr(fp, t->DataFormat[i]);\n+               WriteStr(fp, ((i == (nSamples - 1)) ? \"\\n\" : \"\\t\"));\n+           }\n+       }\n@@ -1766,1 +1943,1 @@\n-       int  i, j;\n+       int  i, j, nPatches;\n@@ -1773,1 +1950,1 @@\n-       t->nPatches = satoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n+       nPatches = satoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n@@ -1775,1 +1952,1 @@\n-       for (i = 0; i < t-> nPatches; i++) {\n+       if (nPatches <= t->nPatches) {\n@@ -1777,1 +1954,1 @@\n-              WriteStr(fp, \" \");\n+           for (i = 0; i < nPatches; i++) {\n@@ -1779,1 +1956,1 @@\n-              for (j = 0; j < t->nSamples; j++) {\n+               WriteStr(fp, \" \");\n@@ -1781,1 +1958,1 @@\n-                     char *ptr = t->Data[i*t->nSamples+j];\n+               for (j = 0; j < t->nSamples; j++) {\n@@ -1783,3 +1960,1 @@\n-                     if (ptr == NULL) WriteStr(fp, \"\\\"\\\"\");\n-                     else {\n-                         \/\/ If value contains whitespace, enclose within quote\n+                   char* ptr = t->Data[i * t->nSamples + j];\n@@ -1787,1 +1962,3 @@\n-                         if (strchr(ptr, ' ') != NULL) {\n+                   if (ptr == NULL) WriteStr(fp, \"\\\"\\\"\");\n+                   else {\n+                       \/\/ If value contains whitespace, enclose within quote\n@@ -1789,7 +1966,1 @@\n-                             WriteStr(fp, \"\\\"\");\n-                             WriteStr(fp, ptr);\n-                             WriteStr(fp, \"\\\"\");\n-                         }\n-                         else\n-                            WriteStr(fp, ptr);\n-                     }\n+                       if (strchr(ptr, ' ') != NULL) {\n@@ -1797,2 +1968,11 @@\n-                     WriteStr(fp, ((j == (t->nSamples-1)) ? \"\\n\" : \"\\t\"));\n-              }\n+                           WriteStr(fp, \"\\\"\");\n+                           WriteStr(fp, ptr);\n+                           WriteStr(fp, \"\\\"\");\n+                       }\n+                       else\n+                           WriteStr(fp, ptr);\n+                   }\n+\n+                   WriteStr(fp, ((j == (t->nSamples - 1)) ? \"\\n\" : \"\\t\"));\n+               }\n+           }\n@@ -1819,4 +1999,14 @@\n-            cmsIT8SetTable(hIT8, i);\n-            WriteHeader(it8, &sd);\n-            WriteDataFormat(&sd, it8);\n-            WriteData(&sd, it8);\n+        TABLE* t;\n+\n+        if (cmsIT8SetTable(hIT8, i) < 0) goto Error;\n+\n+        \/**\n+        * Check for wrong data\n+        *\/\n+        t = GetTable(it8);\n+        if (t->Data == NULL) goto Error;\n+        if (t->DataFormat == NULL) goto Error;\n+\n+        WriteHeader(it8, &sd);\n+        WriteDataFormat(&sd, it8);\n+        WriteData(&sd, it8);\n@@ -1826,1 +2016,0 @@\n-\n@@ -1828,0 +2017,5 @@\n+\n+Error:\n+    fclose(sd.stream);\n+    return FALSE;\n+\n@@ -1841,1 +2035,1 @@\n-    sd.Base   = (cmsUInt8Number*)  MemPtr;\n+    sd.Base   = (cmsUInt8Number*) MemPtr;\n@@ -1846,2 +2040,4 @@\n-    if (sd.Base)\n-        sd.Max  = *BytesNeeded;     \/\/ Write to memory?\n+    if (sd.Base && (*BytesNeeded > 0)) {\n+\n+        sd.Max = (*BytesNeeded) - 1;     \/\/ Write to memory?\n+    }\n@@ -1891,1 +2087,1 @@\n-            if (!SetDataFormat(it8, iField, it8->id)) return FALSE;\n+            if (!SetDataFormat(it8, iField, StringPtr(it8->id))) return FALSE;\n@@ -1924,2 +2120,3 @@\n-    if (!t->Data)\n-        AllocateDataSet(it8);\n+    if (!t->Data) {\n+        if (!AllocateDataSet(it8)) return FALSE;\n+    }\n@@ -1937,0 +2134,16 @@\n+            switch (it8->sy)\n+            {\n+\n+            \/\/ To keep very long data\n+            case SIDENT:\n+                if (!SetData(it8, iSet, iField, StringPtr(it8->id)))\n+                    return FALSE;\n+                break;\n+\n+            case SSTRING:\n+                if (!SetData(it8, iSet, iField, StringPtr(it8->str)))\n+                    return FALSE;\n+                break;\n+\n+            default:\n+\n@@ -1942,0 +2155,1 @@\n+            }\n@@ -1997,1 +2211,1 @@\n-            strncpy(VarName, it8->id, MAXID - 1);\n+            strncpy(VarName, StringPtr(it8->id), MAXID - 1);\n@@ -2141,1 +2355,1 @@\n-                                         cmsIT8SetSheetType(it8, it8 ->id);\n+                                         cmsIT8SetSheetType(it8, StringPtr(it8 ->id));\n@@ -2153,1 +2367,1 @@\n-                                        cmsIT8SetSheetType(it8, it8 ->str);\n+                                        cmsIT8SetSheetType(it8, StringPtr(it8 ->str));\n@@ -2184,1 +2398,1 @@\n-    cmsUInt32Number nOldTable = it8 ->nTable;\n+    cmsUInt32Number nOldTable = it8->nTable;\n@@ -2186,1 +2400,1 @@\n-    for (j=0; j < it8 ->TablesCount; j++) {\n+    for (j = 0; j < it8->TablesCount; j++) {\n@@ -2188,1 +2402,1 @@\n-    TABLE* t = it8 ->Tab + j;\n+        TABLE* t = it8->Tab + j;\n@@ -2190,2 +2404,2 @@\n-    t -> SampleID = 0;\n-    it8 ->nTable = j;\n+        t->SampleID = 0;\n+        it8->nTable = j;\n@@ -2193,6 +2407,6 @@\n-    for (idField = 0; idField < t -> nSamples; idField++)\n-    {\n-        if (t ->DataFormat == NULL){\n-            SynError(it8, \"Undefined DATA_FORMAT\");\n-            return;\n-        }\n+        for (idField = 0; idField < t->nSamples; idField++)\n+        {\n+            if (t->DataFormat == NULL) {\n+                SynError(it8, \"Undefined DATA_FORMAT\");\n+                return;\n+            }\n@@ -2200,2 +2414,2 @@\n-        Fld = t->DataFormat[idField];\n-        if (!Fld) continue;\n+            Fld = t->DataFormat[idField];\n+            if (!Fld) continue;\n@@ -2204,1 +2418,1 @@\n-        if (cmsstrcasecmp(Fld, \"SAMPLE_ID\") == 0) {\n+            if (cmsstrcasecmp(Fld, \"SAMPLE_ID\") == 0) {\n@@ -2206,2 +2420,2 @@\n-            t -> SampleID = idField;\n-        }\n+                t->SampleID = idField;\n+            }\n@@ -2209,1 +2423,1 @@\n-        \/\/ \"LABEL\" is an extension. It keeps references to forward tables\n+            \/\/ \"LABEL\" is an extension. It keeps references to forward tables\n@@ -2211,1 +2425,1 @@\n-        if ((cmsstrcasecmp(Fld, \"LABEL\") == 0) || Fld[0] == '$') {\n+            if ((cmsstrcasecmp(Fld, \"LABEL\") == 0) || Fld[0] == '$') {\n@@ -2213,2 +2427,2 @@\n-            \/\/ Search for table references...\n-            for (i = 0; i < t->nPatches; i++) {\n+                \/\/ Search for table references...\n+                for (i = 0; i < t->nPatches; i++) {\n@@ -2216,1 +2430,1 @@\n-                char* Label = GetData(it8, i, idField);\n+                    char* Label = GetData(it8, i, idField);\n@@ -2218,1 +2432,1 @@\n-                if (Label) {\n+                    if (Label) {\n@@ -2220,1 +2434,1 @@\n-                    cmsUInt32Number k;\n+                        cmsUInt32Number k;\n@@ -2222,2 +2436,2 @@\n-                    \/\/ This is the label, search for a table containing\n-                    \/\/ this property\n+                        \/\/ This is the label, search for a table containing\n+                        \/\/ this property\n@@ -2225,1 +2439,1 @@\n-                    for (k = 0; k < it8->TablesCount; k++) {\n+                        for (k = 0; k < it8->TablesCount; k++) {\n@@ -2227,2 +2441,2 @@\n-                        TABLE* Table = it8->Tab + k;\n-                        KEYVALUE* p;\n+                            TABLE* Table = it8->Tab + k;\n+                            KEYVALUE* p;\n@@ -2230,1 +2444,1 @@\n-                        if (IsAvailableOnList(Table->HeaderList, Label, NULL, &p)) {\n+                            if (IsAvailableOnList(Table->HeaderList, Label, NULL, &p)) {\n@@ -2232,2 +2446,2 @@\n-                            \/\/ Available, keep type and table\n-                            char Buffer[256];\n+                                \/\/ Available, keep type and table\n+                                char Buffer[256];\n@@ -2235,2 +2449,2 @@\n-                            char* Type = p->Value;\n-                            int  nTable = (int)k;\n+                                char* Type = p->Value;\n+                                int  nTable = (int)k;\n@@ -2238,1 +2452,1 @@\n-                            snprintf(Buffer, 255, \"%s %d %s\", Label, nTable, Type);\n+                                snprintf(Buffer, 255, \"%s %d %s\", Label, nTable, Type);\n@@ -2240,1 +2454,2 @@\n-                            SetData(it8, i, idField, Buffer);\n+                                SetData(it8, i, idField, Buffer);\n+                            }\n@@ -2243,2 +2458,0 @@\n-\n-\n@@ -2246,1 +2459,0 @@\n-\n@@ -2248,2 +2460,0 @@\n-\n-\n@@ -2251,2 +2461,0 @@\n-\n-    }\n@@ -2255,1 +2463,1 @@\n-    it8 ->nTable = nOldTable;\n+    it8->nTable = nOldTable;\n@@ -2346,1 +2554,1 @@\n-        return FALSE;\n+        return NULL;\n@@ -2358,1 +2566,1 @@\n-        return FALSE;\n+        return NULL;\n@@ -2455,1 +2663,2 @@\n-    Props = (char **) AllocChunk(it8, sizeof(char *) * n);\n+    Props = (char**)AllocChunk(it8, sizeof(char*) * n);\n+    if (Props != NULL) {\n@@ -2457,5 +2666,5 @@\n-    \/\/ Pass#2 - Fill pointers\n-    n = 0;\n-    for (p = t -> HeaderList;  p != NULL; p = p->Next) {\n-        Props[n++] = p -> Keyword;\n-    }\n+        \/\/ Pass#2 - Fill pointers\n+        n = 0;\n+        for (p = t->HeaderList; p != NULL; p = p->Next) {\n+            Props[n++] = p->Keyword;\n+        }\n@@ -2463,0 +2672,1 @@\n+    }\n@@ -2464,0 +2674,1 @@\n+\n@@ -2495,0 +2706,1 @@\n+    if (Props != NULL) {\n@@ -2496,5 +2708,6 @@\n-    \/\/ Pass#2 - Fill pointers\n-    n = 0;\n-    for (tmp = p;  tmp != NULL; tmp = tmp->NextSubkey) {\n-        if(tmp->Subkey != NULL)\n-            Props[n++] = p ->Subkey;\n+        \/\/ Pass#2 - Fill pointers\n+        n = 0;\n+        for (tmp = p; tmp != NULL; tmp = tmp->NextSubkey) {\n+            if (tmp->Subkey != NULL)\n+                Props[n++] = p->Subkey;\n+        }\n@@ -2676,2 +2889,6 @@\n-        AllocateDataFormat(it8);\n-        AllocateDataSet(it8);\n+        if (!AllocateDataFormat(it8))\n+            return FALSE;\n+\n+        if (!AllocateDataSet(it8))\n+            return FALSE;\n+\n@@ -2816,0 +3033,233 @@\n+\n+static\n+cmsBool ReadNumbers(cmsIT8* cube, int n, cmsFloat64Number* arr)\n+{\n+    int i;\n+\n+    for (i = 0; i < n; i++) {\n+\n+        if (cube->sy == SINUM)\n+            arr[i] = cube->inum;\n+        else\n+            if (cube->sy == SDNUM)\n+                arr[i] = cube->dnum;\n+            else\n+                return SynError(cube, \"Number expected\");\n+\n+        InSymbol(cube);\n+    }\n+\n+    return CheckEOLN(cube);\n+}\n+\n+static\n+cmsBool ParseCube(cmsIT8* cube, cmsStage** Shaper, cmsStage** CLUT, char title[])\n+{\n+    cmsFloat64Number domain_min[3] = { 0, 0, 0 };\n+    cmsFloat64Number domain_max[3] = { 1.0, 1.0, 1.0 };\n+    cmsFloat64Number check_0_1[2] = { 0, 1.0 };\n+    int shaper_size = 0;\n+    int lut_size = 0;\n+    int i;\n+\n+    InSymbol(cube);\n+\n+    while (cube->sy != SEOF) {\n+        switch (cube->sy)\n+        {\n+        \/\/ Set profile description\n+        case STITLE:\n+            InSymbol(cube);\n+            if (!Check(cube, SSTRING, \"Title string expected\")) return FALSE;\n+            memcpy(title, StringPtr(cube->str), MAXSTR);\n+            title[MAXSTR - 1] = 0;\n+            InSymbol(cube);\n+            break;\n+\n+        \/\/ Define domain\n+        case SDOMAIN_MIN:\n+            InSymbol(cube);\n+            if (!ReadNumbers(cube, 3, domain_min)) return FALSE;\n+            break;\n+\n+        case SDOMAIN_MAX:\n+            InSymbol(cube);\n+            if (!ReadNumbers(cube, 3, domain_max)) return FALSE;\n+            break;\n+\n+        \/\/ Define shaper\n+        case S_LUT1D_SIZE:\n+            InSymbol(cube);\n+            if (!Check(cube, SINUM, \"Shaper size expected\")) return FALSE;\n+            shaper_size = cube->inum;\n+            InSymbol(cube);\n+            break;\n+\n+        \/\/ Deefine CLUT\n+        case S_LUT3D_SIZE:\n+            InSymbol(cube);\n+            if (!Check(cube, SINUM, \"LUT size expected\")) return FALSE;\n+            lut_size = cube->inum;\n+            InSymbol(cube);\n+            break;\n+\n+        \/\/ Range. If present, has to be 0..1.0\n+        case S_LUT1D_INPUT_RANGE:\n+        case S_LUT3D_INPUT_RANGE:\n+            InSymbol(cube);\n+            if (!ReadNumbers(cube, 2, check_0_1)) return FALSE;\n+            if (check_0_1[0] != 0 || check_0_1[1] != 1.0) {\n+                return SynError(cube, \"Unsupported format\");\n+            }\n+            break;\n+\n+        case SEOLN:\n+            InSymbol(cube);\n+            break;\n+\n+        default:\n+        case S_LUT_IN_VIDEO_RANGE:\n+        case S_LUT_OUT_VIDEO_RANGE:\n+            return SynError(cube, \"Unsupported format\");\n+\n+            \/\/ Read and create tables\n+        case SINUM:\n+        case SDNUM:\n+\n+            if (shaper_size > 0) {\n+\n+                cmsToneCurve* curves[3];\n+                cmsFloat32Number* shapers = (cmsFloat32Number*)_cmsMalloc(cube->ContextID, 3 * shaper_size * sizeof(cmsFloat32Number));\n+                if (shapers == NULL) return FALSE;\n+\n+                for (i = 0; i < shaper_size; i++) {\n+\n+                    cmsFloat64Number nums[3];\n+\n+                    if (!ReadNumbers(cube, 3, nums)) return FALSE;\n+\n+                    shapers[i + 0]               = (cmsFloat32Number) ((nums[0] - domain_min[0]) \/ (domain_max[0] - domain_min[0]));\n+                    shapers[i + 1 * shaper_size] = (cmsFloat32Number) ((nums[1] - domain_min[1]) \/ (domain_max[1] - domain_min[1]));\n+                    shapers[i + 2 * shaper_size] = (cmsFloat32Number) ((nums[2] - domain_min[2]) \/ (domain_max[2] - domain_min[2]));\n+                }\n+\n+                for (i = 0; i < 3; i++) {\n+\n+                    curves[i] = cmsBuildTabulatedToneCurveFloat(cube->ContextID, shaper_size,\n+                        &shapers[i * shaper_size]);\n+                    if (curves[i] == NULL) return FALSE;\n+                }\n+\n+                *Shaper = cmsStageAllocToneCurves(cube->ContextID, 3, curves);\n+\n+                cmsFreeToneCurveTriple(curves);\n+            }\n+\n+            if (lut_size > 0) {\n+\n+                int nodes = lut_size * lut_size * lut_size;\n+\n+                cmsFloat32Number* lut_table = _cmsMalloc(cube->ContextID, nodes * 3 * sizeof(cmsFloat32Number));\n+                if (lut_table == NULL) return FALSE;\n+\n+                for (i = 0; i < nodes; i++) {\n+\n+                    cmsFloat64Number nums[3];\n+\n+                    if (!ReadNumbers(cube, 3, nums)) return FALSE;\n+\n+                    lut_table[i * 3 + 2] = (cmsFloat32Number) ((nums[0] - domain_min[0]) \/ (domain_max[0] - domain_min[0]));\n+                    lut_table[i * 3 + 1] = (cmsFloat32Number) ((nums[1] - domain_min[1]) \/ (domain_max[1] - domain_min[1]));\n+                    lut_table[i * 3 + 0] = (cmsFloat32Number) ((nums[2] - domain_min[2]) \/ (domain_max[2] - domain_min[2]));\n+                }\n+\n+                *CLUT = cmsStageAllocCLutFloat(cube->ContextID, lut_size, 3, 3, lut_table);\n+                _cmsFree(cube->ContextID, lut_table);\n+            }\n+\n+            if (!Check(cube, SEOF, \"Extra symbols found in file\")) return FALSE;\n+        }\n+    }\n+\n+    return TRUE;\n+}\n+\n+\/\/ Share the parser to read .cube format and create RGB devicelink profiles\n+cmsHPROFILE CMSEXPORT cmsCreateDeviceLinkFromCubeFileTHR(cmsContext ContextID, const char* cFileName)\n+{\n+    cmsHPROFILE hProfile = NULL;\n+    cmsIT8* cube = NULL;\n+    cmsPipeline* Pipeline = NULL;\n+    cmsStage* CLUT = NULL;\n+    cmsStage* Shaper = NULL;\n+    cmsMLU* DescriptionMLU = NULL;\n+    char title[MAXSTR];\n+\n+    _cmsAssert(cFileName != NULL);\n+\n+    cube = (cmsIT8*) cmsIT8Alloc(ContextID);\n+    if (!cube) return NULL;\n+\n+    cube->IsCUBE = TRUE;\n+    cube->FileStack[0]->Stream = fopen(cFileName, \"rt\");\n+\n+    if (!cube->FileStack[0]->Stream) goto Done;\n+\n+    strncpy(cube->FileStack[0]->FileName, cFileName, cmsMAX_PATH - 1);\n+    cube->FileStack[0]->FileName[cmsMAX_PATH - 1] = 0;\n+\n+    if (!ParseCube(cube, &Shaper, &CLUT, title)) goto Done;\n+\n+    \/\/ Success on parsing, let's create the profile\n+    hProfile = cmsCreateProfilePlaceholder(ContextID);\n+    if (!hProfile) goto Done;\n+\n+    cmsSetProfileVersion(hProfile, 4.4);\n+\n+    cmsSetDeviceClass(hProfile, cmsSigLinkClass);\n+    cmsSetColorSpace(hProfile,  cmsSigRgbData);\n+    cmsSetPCS(hProfile,         cmsSigRgbData);\n+\n+    cmsSetHeaderRenderingIntent(hProfile, INTENT_PERCEPTUAL);\n+\n+    \/\/ Creates a Pipeline to hold CLUT and shaper\n+    Pipeline = cmsPipelineAlloc(ContextID, 3, 3);\n+    if (Pipeline == NULL) goto Done;\n+\n+    \/\/ Populates the pipeline\n+    if (Shaper != NULL) {\n+        if (!cmsPipelineInsertStage(Pipeline, cmsAT_BEGIN, Shaper))\n+            goto Done;\n+    }\n+\n+    if (CLUT != NULL) {\n+        if (!cmsPipelineInsertStage(Pipeline, cmsAT_END, CLUT))\n+            goto Done;\n+    }\n+\n+    \/\/ Propagate the description. We put no copyright because we know\n+    \/\/ nothing on the copyrighted state of the .cube\n+    DescriptionMLU = cmsMLUalloc(ContextID, 1);\n+    if (!cmsMLUsetUTF8(DescriptionMLU, cmsNoLanguage, cmsNoCountry, title)) goto Done;\n+\n+    \/\/ Flush the tags\n+    if (!cmsWriteTag(hProfile, cmsSigProfileDescriptionTag, DescriptionMLU)) goto Done;\n+    if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, (void*)Pipeline)) goto Done;\n+\n+Done:\n+\n+    if (DescriptionMLU != NULL)\n+        cmsMLUfree(DescriptionMLU);\n+\n+    if (Pipeline != NULL)\n+        cmsPipelineFree(Pipeline);\n+\n+    cmsIT8Free((cmsHANDLE) cube);\n+\n+    return hProfile;\n+}\n+\n+cmsHPROFILE CMSEXPORT cmsCreateDeviceLinkFromCubeFile(const char* cFileName)\n+{\n+    return cmsCreateDeviceLinkFromCubeFileTHR(NULL, cFileName);\n+}\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmscgats.c","additions":626,"deletions":176,"binary":false,"changes":802,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -266,1 +266,1 @@\n-    void Temp2CHAD(cmsMAT3* Chad, cmsFloat64Number Temp)\n+void Temp2CHAD(cmsMAT3* Chad, cmsFloat64Number Temp)\n@@ -402,2 +402,2 @@\n-        _cmsReadMediaWhitePoint(&WhitePointIn,  hProfiles[i-1]);\n-        _cmsReadCHAD(&ChromaticAdaptationMatrixIn, hProfiles[i-1]);\n+        if (!_cmsReadMediaWhitePoint(&WhitePointIn, hProfiles[i - 1])) return FALSE;\n+        if (!_cmsReadCHAD(&ChromaticAdaptationMatrixIn, hProfiles[i - 1])) return FALSE;\n@@ -405,2 +405,2 @@\n-        _cmsReadMediaWhitePoint(&WhitePointOut,  hProfiles[i]);\n-        _cmsReadCHAD(&ChromaticAdaptationMatrixOut, hProfiles[i]);\n+        if (!_cmsReadMediaWhitePoint(&WhitePointOut, hProfiles[i])) return FALSE;\n+        if (!_cmsReadCHAD(&ChromaticAdaptationMatrixOut, hProfiles[i])) return FALSE;\n@@ -418,1 +418,1 @@\n-            cmsCIEXYZ BlackPointIn, BlackPointOut;\n+            cmsCIEXYZ BlackPointIn = { 0, 0, 0}, BlackPointOut = { 0, 0, 0 };\n@@ -662,1 +662,1 @@\n-                  cmsStage* clip = _cmsStageClipNegatives(Result->ContextID, cmsChannelsOf(ColorSpaceOut));\n+                  cmsStage* clip = _cmsStageClipNegatives(Result->ContextID, cmsChannelsOfColorSpace(ColorSpaceOut));\n@@ -747,0 +747,10 @@\n+\n+\/\/ Check whatever the profile is a CMYK->CMYK devicelink\n+static\n+cmsBool is_cmyk_devicelink(cmsHPROFILE hProfile)\n+{\n+    return cmsGetDeviceClass(hProfile) == cmsSigLinkClass &&\n+            cmsGetColorSpace(hProfile) == cmsSigCmykData &&\n+            cmsGetColorSpace(hProfile) == cmsSigCmykData;\n+}\n+\n@@ -779,1 +789,2 @@\n-    while (lastProfilePos > 1)\n+    \/\/ Skip CMYK->CMYK devicelinks on ending\n+    while (is_cmyk_devicelink(hLastProfile))\n@@ -781,3 +792,1 @@\n-        hLastProfile = hProfiles[--lastProfilePos];\n-        if (cmsGetColorSpace(hLastProfile) != cmsSigCmykData ||\n-            cmsGetDeviceClass(hLastProfile) != cmsSigLinkClass)\n+        if (lastProfilePos < 2)\n@@ -785,0 +794,2 @@\n+\n+        hLastProfile = hProfiles[--lastProfilePos];\n@@ -787,0 +798,1 @@\n+\n@@ -803,1 +815,1 @@\n-                                     preservationProfilesCount,\n+        preservationProfilesCount,\n@@ -815,1 +827,1 @@\n-                                    preservationProfilesCount,\n+        preservationProfilesCount,\n@@ -1005,1 +1017,2 @@\n-    while (lastProfilePos > 1)\n+    \/\/ Skip CMYK->CMYK devicelinks on ending\n+    while (is_cmyk_devicelink(hLastProfile))\n@@ -1007,3 +1020,1 @@\n-        hLastProfile = hProfiles[--lastProfilePos];\n-        if (cmsGetColorSpace(hLastProfile) != cmsSigCmykData ||\n-            cmsGetDeviceClass(hLastProfile) != cmsSigLinkClass)\n+        if (lastProfilePos < 2)\n@@ -1011,0 +1022,2 @@\n+\n+        hLastProfile = hProfiles[--lastProfilePos];\n@@ -1180,2 +1193,1 @@\n-\n-    for (nIntents=0, pt = ctx->Intents; pt != NULL; pt = pt -> Next)\n+    for (nIntents=0, pt = DefaultIntents; pt != NULL; pt = pt -> Next)\n@@ -1194,1 +1206,1 @@\n-    for (nIntents=0, pt = DefaultIntents; pt != NULL; pt = pt -> Next)\n+    for (pt = ctx->Intents; pt != NULL; pt = pt -> Next)\n@@ -1206,0 +1218,1 @@\n+\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmscnvrt.c","additions":34,"deletions":21,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -104,1 +104,1 @@\n-\/\/ amount of memoy that can be reclaimed. This is mostly as a safety feature to prevent\n+\/\/ amount of memory that can be reclaimed. This is mostly as a safety feature to prevent\n@@ -111,1 +111,1 @@\n-\/\/ is up to the plug-in writter to keep in the safe side. There are only three functions\n+\/\/ is up to the plug-in writer to keep in the safe side. There are only three functions\n@@ -124,1 +124,2 @@\n-    if (size > MAX_MEMORY_FOR_ALLOC) return NULL;  \/\/ Never allow over maximum\n+    \/\/ Never allow 0 or over maximum\n+    if (size == 0 || size > MAX_MEMORY_FOR_ALLOC) return NULL;\n@@ -266,1 +267,1 @@\n-    \/\/ context internal data should be malloce'd by using those functions.\n+    \/\/ context internal data should be malloc'ed by using those functions.\n@@ -340,1 +341,1 @@\n-\/\/ I prefer this method over realloc due to the big inpact on xput realloc may have if\n+\/\/ I prefer this method over realloc due to the big impact on xput realloc may have if\n@@ -645,1 +646,0 @@\n-\n@@ -693,0 +693,44 @@\n+\n+\/\/ The global Context0 storage for parallelization plug-in\n+ _cmsParallelizationPluginChunkType _cmsParallelizationPluginChunk = { 0 };\n+\n+\/\/ Allocate parallelization container.\n+void _cmsAllocParallelizationPluginChunk(struct _cmsContext_struct* ctx,\n+                                         const struct _cmsContext_struct* src)\n+{\n+    if (src != NULL) {\n+        void* from = src->chunks[ParallelizationPlugin];\n+        ctx->chunks[ParallelizationPlugin] = _cmsSubAllocDup(ctx->MemPool, from, sizeof(_cmsParallelizationPluginChunkType));\n+    }\n+    else {\n+        _cmsParallelizationPluginChunkType ParallelizationPluginChunk = { 0 };\n+        ctx->chunks[ParallelizationPlugin] = _cmsSubAllocDup(ctx->MemPool, &ParallelizationPluginChunk, sizeof(_cmsParallelizationPluginChunkType));\n+    }\n+}\n+\n+\/\/ Register parallel processing\n+cmsBool _cmsRegisterParallelizationPlugin(cmsContext ContextID, cmsPluginBase* Data)\n+{\n+    cmsPluginParalellization* Plugin = (cmsPluginParalellization*)Data;\n+    _cmsParallelizationPluginChunkType* ctx = (_cmsParallelizationPluginChunkType*)_cmsContextGetClientChunk(ContextID, ParallelizationPlugin);\n+\n+    if (Data == NULL) {\n+\n+        \/\/ No parallelization routines\n+        ctx->MaxWorkers = 0;\n+        ctx->WorkerFlags = 0;\n+        ctx->SchedulerFn = NULL;\n+        return TRUE;\n+    }\n+\n+    \/\/ callback is required\n+    if (Plugin->SchedulerFn == NULL) return FALSE;\n+\n+    ctx->MaxWorkers = Plugin->MaxWorkers;\n+    ctx->WorkerFlags = Plugin->WorkerFlags;\n+    ctx->SchedulerFn = Plugin->SchedulerFn;\n+\n+    \/\/ All is ok\n+    return TRUE;\n+}\n+\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmserr.c","additions":51,"deletions":7,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -239,1 +239,1 @@\n-\/\/ no optimation curve is computed. nSegments may also be zero in the inverse case, where only the\n+\/\/ no optimization curve is computed. nSegments may also be zero in the inverse case, where only the\n@@ -332,0 +332,4 @@\n+    for (i=0; i < nSegments; i++) {\n+        if (p ->Segments && p ->Segments[i].SampledPoints) _cmsFree(ContextID, p ->Segments[i].SampledPoints);\n+        if (p ->SegInterp && p ->SegInterp[i]) _cmsFree(ContextID, p ->SegInterp[i]);\n+    }\n@@ -459,2 +463,2 @@\n-    \/\/ Y = (aX + b)^Gamma | X <= -b\/a\n-    \/\/ Y = c              | else\n+    \/\/ Y = (aX + b)^Gamma + c | X <= -b\/a\n+    \/\/ Y = c                  | else\n@@ -494,1 +498,2 @@\n-        if (fabs(Params[1]) < MATRIX_DET_TOLERANCE)\n+        if (fabs(Params[0]) < MATRIX_DET_TOLERANCE ||\n+            fabs(Params[1]) < MATRIX_DET_TOLERANCE)\n@@ -539,6 +544,4 @@\n-        if (fabs(Params[0]) < MATRIX_DET_TOLERANCE ||\n-            fabs(Params[1]) < MATRIX_DET_TOLERANCE ||\n-            fabs(Params[3]) < MATRIX_DET_TOLERANCE)\n-        {\n-            Val = 0;\n-        }\n+\n+        e = Params[1] * Params[4] + Params[2];\n+        if (e < 0)\n+            disc = 0;\n@@ -546,6 +549,1 @@\n-        {\n-            e = Params[1] * Params[4] + Params[2];\n-            if (e < 0)\n-                disc = 0;\n-            else\n-                disc = pow(e, Params[0]);\n+            disc = pow(e, Params[0]);\n@@ -553,1 +551,1 @@\n-            if (R >= disc) {\n+        if (R >= disc) {\n@@ -555,0 +553,6 @@\n+            if (fabs(Params[0]) < MATRIX_DET_TOLERANCE ||\n+                fabs(Params[1]) < MATRIX_DET_TOLERANCE)\n+\n+                Val = 0;\n+\n+            else\n@@ -556,2 +560,6 @@\n-            }\n-            else {\n+        }\n+        else {\n+\n+            if (fabs(Params[3]) < MATRIX_DET_TOLERANCE)\n+                Val = 0;\n+            else\n@@ -559,1 +567,0 @@\n-            }\n@@ -561,0 +568,1 @@\n+\n@@ -587,9 +595,10 @@\n-        if (fabs(Params[1]) < MATRIX_DET_TOLERANCE ||\n-            fabs(Params[3]) < MATRIX_DET_TOLERANCE)\n-        {\n-            Val = 0;\n-        }\n-        else\n-        {\n-            disc = Params[3] * Params[4] + Params[6];\n-            if (R >= disc) {\n+        disc = Params[3] * Params[4] + Params[6];\n+        if (R >= disc) {\n+\n+            e = R - Params[5];\n+            if (e < 0)\n+                Val = 0;\n+            else\n+            {\n+                if (fabs(Params[0]) < MATRIX_DET_TOLERANCE ||\n+                    fabs(Params[1]) < MATRIX_DET_TOLERANCE)\n@@ -597,2 +606,0 @@\n-                e = R - Params[5];\n-                if (e < 0)\n@@ -603,1 +610,5 @@\n-            else {\n+        }\n+        else {\n+            if (fabs(Params[3]) < MATRIX_DET_TOLERANCE)\n+                Val = 0;\n+            else\n@@ -605,1 +616,0 @@\n-            }\n@@ -607,0 +617,1 @@\n+\n@@ -618,4 +629,10 @@\n-        if (e < 0)\n-            Val = Params[3];\n-        else\n-            Val = pow(e, Params[0]) + Params[3];\n+        \/\/ On gamma 1.0, don't clamp\n+        if (Params[0] == 1.0) {\n+            Val = e + Params[3];\n+        }\n+        else {\n+            if (e < 0)\n+                Val = Params[3];\n+            else\n+                Val = pow(e, Params[0]) + Params[3];\n+        }\n@@ -627,1 +644,2 @@\n-        if (fabs(Params[1]) < MATRIX_DET_TOLERANCE)\n+        if (fabs(Params[0]) < MATRIX_DET_TOLERANCE ||\n+            fabs(Params[1]) < MATRIX_DET_TOLERANCE)\n@@ -847,0 +865,4 @@\n+    \/\/ Do some housekeeping\n+    if (nEntries == 0 || values == NULL)\n+        return NULL;\n+\n@@ -1499,0 +1521,3 @@\n+    \/\/ We need enough valid samples\n+    if (n <= 1) return -1.0;\n+\n@@ -1508,0 +1533,1 @@\n+\/\/ Retrieve segments on tone curves\n@@ -1509,3 +1535,1 @@\n-\/\/ Retrieve parameters on one-segment tone curves\n-\n-cmsFloat64Number* CMSEXPORT cmsGetToneCurveParams(const cmsToneCurve* t)\n+const cmsCurveSegment* CMSEXPORT cmsGetToneCurveSegment(cmsInt32Number n, const cmsToneCurve* t)\n@@ -1515,2 +1539,2 @@\n-    if (t->nSegments != 1) return NULL;\n-    return t->Segments[0].Params;\n+    if (n < 0 || n >= (cmsInt32Number) t->nSegments) return NULL;\n+    return t->Segments + n;\n@@ -1518,0 +1542,1 @@\n+\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsgamma.c","additions":69,"deletions":44,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2021 Marti Maria Saguer\n@@ -231,1 +231,1 @@\n-    cmsFloat64Number Thereshold;        \/\/ The thereshold after which is considered out of gamut\n+    cmsFloat64Number Threshold;         \/\/ The threshold after which is considered out of gamut\n@@ -236,1 +236,1 @@\n-\/\/ values with a transform going back and forth. Values above ERR_THERESHOLD\n+\/\/ values with a transform going back and forth. Values above ERR_THRESHOLD\n@@ -239,1 +239,1 @@\n-#define ERR_THERESHOLD      5\n+#define ERR_THRESHOLD      5\n@@ -251,1 +251,1 @@\n-    \/\/ Assume in-gamut by default.\n+    \/\/ Assume in-gamut by default. NEVER READ, USED FOR DEBUG PURPOSES.\n@@ -278,1 +278,1 @@\n-    if (dE1 < t->Thereshold && dE2 < t->Thereshold)\n+    if (dE1 < t->Threshold && dE2 < t->Threshold)\n@@ -283,1 +283,1 @@\n-        if (dE1 < t->Thereshold && dE2 > t->Thereshold)\n+        if (dE1 < t->Threshold && dE2 > t->Threshold)\n@@ -287,2 +287,2 @@\n-            if (dE1 > t->Thereshold && dE2 < t->Thereshold)\n-                Out[0] = (cmsUInt16Number) _cmsQuickFloor((dE1 - t->Thereshold) + .5);\n+            if (dE1 > t->Threshold && dE2 < t->Threshold)\n+                Out[0] = (cmsUInt16Number) _cmsQuickFloor((dE1 - t->Threshold) + .5);\n@@ -298,2 +298,2 @@\n-                if (ErrorRatio > t->Thereshold)\n-                    Out[0] = (cmsUInt16Number)  _cmsQuickFloor((ErrorRatio - t->Thereshold) + .5);\n+                if (ErrorRatio > t->Threshold)\n+                    Out[0] = (cmsUInt16Number)  _cmsQuickFloor((ErrorRatio - t->Threshold) + .5);\n@@ -329,1 +329,2 @@\n-    cmsUInt32Number nChannels, nGridpoints;\n+    cmsUInt32Number nGridpoints;\n+    cmsInt32Number nChannels;\n@@ -355,1 +356,1 @@\n-        Chain.Thereshold = 1.0;\n+        Chain.Threshold = 1.0;\n@@ -358,1 +359,1 @@\n-        Chain.Thereshold = ERR_THERESHOLD;\n+        Chain.Threshold = ERR_THRESHOLD;\n@@ -378,2 +379,1 @@\n-\n-    nChannels   = cmsChannelsOf(ColorSpace);\n+    nChannels   = cmsChannelsOfColorSpace(ColorSpace);\n@@ -504,0 +504,3 @@\n+    \/\/ Unsupported color space?\n+    if (dwFormatter == 0) return 0;\n+\n@@ -620,0 +623,66 @@\n+\n+\/\/ Detect whatever a given ICC profile works in linear (gamma 1.0) space\n+\/\/ Actually, doing that \"well\" is quite hard, since every component may behave completely different.\n+\/\/ Since the true point of this function is to detect suitable optimizations, I am imposing some requirements\n+\/\/ that simplifies things: only RGB, and only profiles that can got in both directions.\n+\/\/ The algorithm obtains Y from a synthetical gray R=G=B. Then least squares fitting is used to estimate gamma.\n+\/\/ For gamma close to 1.0, RGB is linear. On profiles not supported, -1 is returned.\n+\n+cmsFloat64Number CMSEXPORT cmsDetectRGBProfileGamma(cmsHPROFILE hProfile, cmsFloat64Number threshold)\n+{\n+    cmsContext ContextID;\n+    cmsHPROFILE hXYZ;\n+    cmsHTRANSFORM xform;\n+    cmsToneCurve* Y_curve;\n+    cmsUInt16Number rgb[256][3];\n+    cmsCIEXYZ XYZ[256];\n+    cmsFloat32Number Y_normalized[256];\n+    cmsFloat64Number gamma;\n+    cmsProfileClassSignature cl;\n+    int i;\n+\n+    if (cmsGetColorSpace(hProfile) != cmsSigRgbData)\n+        return -1;\n+\n+    cl = cmsGetDeviceClass(hProfile);\n+    if (cl != cmsSigInputClass && cl != cmsSigDisplayClass &&\n+        cl != cmsSigOutputClass && cl != cmsSigColorSpaceClass)\n+        return -1;\n+\n+    ContextID = cmsGetProfileContextID(hProfile);\n+    hXYZ = cmsCreateXYZProfileTHR(ContextID);\n+    if (hXYZ == NULL)\n+        return -1;\n+    xform = cmsCreateTransformTHR(ContextID, hProfile, TYPE_RGB_16, hXYZ, TYPE_XYZ_DBL,\n+                                    INTENT_RELATIVE_COLORIMETRIC, cmsFLAGS_NOOPTIMIZE);\n+\n+    if (xform == NULL) { \/\/ If not RGB or forward direction is not supported, regret with the previous error\n+\n+        cmsCloseProfile(hXYZ);\n+        return -1;\n+    }\n+\n+    for (i = 0; i < 256; i++) {\n+        rgb[i][0] = rgb[i][1] = rgb[i][2] = FROM_8_TO_16(i);\n+    }\n+\n+    cmsDoTransform(xform, rgb, XYZ, 256);\n+\n+    cmsDeleteTransform(xform);\n+    cmsCloseProfile(hXYZ);\n+\n+    for (i = 0; i < 256; i++) {\n+        Y_normalized[i] = (cmsFloat32Number) XYZ[i].Y;\n+    }\n+\n+    Y_curve = cmsBuildTabulatedToneCurveFloat(ContextID, 256, Y_normalized);\n+    if (Y_curve == NULL)\n+        return -1;\n+\n+    gamma = cmsEstimateGamma(Y_curve, threshold);\n+\n+    cmsFreeToneCurve(Y_curve);\n+\n+    return gamma;\n+}\n+\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsgmt.c","additions":85,"deletions":16,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -409,1 +409,1 @@\n-static cmsUInt16Number Offset[64] = {\n+static const cmsUInt16Number Offset[64] = {\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmshalf.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -232,2 +232,2 @@\n-    \/\/ if last value...\n-    if (Value[0] == 0xffff) {\n+    \/\/ if last value or just one point\n+    if (Value[0] == 0xffff || p->Domain[0] == 0) {\n@@ -272,1 +272,1 @@\n-       if (val2 == 1.0) {\n+       if (val2 == 1.0 || p->Domain[0] == 0) {\n@@ -306,2 +306,0 @@\n-       v = Input[0] * p16 -> Domain[0];\n-       fk = _cmsToFixedDomain(v);\n@@ -309,2 +307,17 @@\n-       k0 = FIXED_TO_INT(fk);\n-       rk = (cmsUInt16Number) FIXED_REST_TO_INT(fk);\n+       \/\/ if last value...\n+       if (Input[0] == 0xffff || p16->Domain[0] == 0) {\n+\n+           cmsUInt32Number y0 = p16->Domain[0] * p16->opta[0];\n+\n+           for (OutChan = 0; OutChan < p16->nOutputs; OutChan++) {\n+               Output[OutChan] = LutTable[y0 + OutChan];\n+           }\n+       }\n+       else\n+       {\n+\n+           v = Input[0] * p16->Domain[0];\n+           fk = _cmsToFixedDomain(v);\n+\n+           k0 = FIXED_TO_INT(fk);\n+           rk = (cmsUInt16Number)FIXED_REST_TO_INT(fk);\n@@ -312,1 +325,1 @@\n-       k1 = k0 + (Input[0] != 0xFFFFU ? 1 : 0);\n+           k1 = k0 + (Input[0] != 0xFFFFU ? 1 : 0);\n@@ -314,2 +327,2 @@\n-       K0 = p16 -> opta[0] * k0;\n-       K1 = p16 -> opta[0] * k1;\n+           K0 = p16->opta[0] * k0;\n+           K1 = p16->opta[0] * k1;\n@@ -317,1 +330,1 @@\n-       for (OutChan=0; OutChan < p16->nOutputs; OutChan++) {\n+           for (OutChan = 0; OutChan < p16->nOutputs; OutChan++) {\n@@ -319,1 +332,2 @@\n-           Output[OutChan] = LinearInterp(rk, LutTable[K0+OutChan], LutTable[K1+OutChan]);\n+               Output[OutChan] = LinearInterp(rk, LutTable[K0 + OutChan], LutTable[K1 + OutChan]);\n+           }\n@@ -340,1 +354,1 @@\n-    if (val2 == 1.0) {\n+    if (val2 == 1.0 || p->Domain[0] == 0) {\n@@ -342,1 +356,1 @@\n-        y0 = LutTable[p->Domain[0]];\n+        cmsUInt32Number start = p->Domain[0] * p->opta[0];\n@@ -345,1 +359,1 @@\n-            Output[OutChan] = y0;\n+            Output[OutChan] = LutTable[start + OutChan];\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsintrp.c","additions":30,"deletions":16,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -407,0 +407,1 @@\n+    char mode[4] = { 0,0,0,0 };\n@@ -414,1 +415,34 @@\n-    switch (*AccessMode) {\n+    \/\/ Validate access mode\n+    while (*AccessMode) {\n+\n+        switch (*AccessMode)\n+        {\n+        case 'r':\n+        case 'w':\n+\n+            if (mode[0] == 0) {\n+                mode[0] = *AccessMode;\n+                mode[1] = 'b';\n+            }\n+            else {\n+                _cmsFree(ContextID, iohandler);\n+                cmsSignalError(ContextID, cmsERROR_FILE, \"Access mode already specified '%c'\", *AccessMode);\n+                return NULL;\n+            }\n+            break;\n+\n+        \/\/ Close on exec. Not all runtime supports that. Up to the caller to decide.\n+        case 'e':\n+            mode[2] = 'e';\n+            break;\n+\n+        default:\n+            _cmsFree(ContextID, iohandler);\n+            cmsSignalError(ContextID, cmsERROR_FILE, \"Wrong access mode '%c'\", *AccessMode);\n+            return NULL;\n+        }\n+\n+        AccessMode++;\n+    }\n+\n+    switch (mode[0]) {\n@@ -417,1 +451,1 @@\n-        fm = fopen(FileName, \"rb\");\n+        fm = fopen(FileName, mode);\n@@ -423,1 +457,1 @@\n-        fileLen = cmsfilelength(fm);\n+        fileLen = (cmsInt32Number)cmsfilelength(fm);\n@@ -431,1 +465,0 @@\n-\n@@ -436,1 +469,1 @@\n-        fm = fopen(FileName, \"wb\");\n+        fm = fopen(FileName, mode);\n@@ -446,2 +479,1 @@\n-        _cmsFree(ContextID, iohandler);\n-         cmsSignalError(ContextID, cmsERROR_FILE, \"Unknown access mode '%c'\", *AccessMode);\n+        _cmsFree(ContextID, iohandler);   \/\/ Would never reach\n@@ -474,1 +506,1 @@\n-    fileSize = cmsfilelength(Stream);\n+    fileSize = (cmsInt32Number)cmsfilelength(Stream);\n@@ -511,1 +543,1 @@\n-        _cmsICCPROFILE* Icc = (_cmsICCPROFILE*)hProfile;\n+    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*)hProfile;\n@@ -513,2 +545,2 @@\n-        if (Icc == NULL) return NULL;\n-        return Icc->IOhandler;\n+    if (Icc == NULL) return NULL;\n+    return Icc->IOhandler;\n@@ -520,1 +552,0 @@\n-    time_t now = time(NULL);\n@@ -532,0 +563,17 @@\n+    \/\/ Set default CMM (that's me!)\n+    Icc ->CMM = lcmsSignature;\n+\n+    \/\/ Set default creator\n+    \/\/ Created by LittleCMS (that's me!)\n+    Icc ->creator = lcmsSignature;\n+\n+    \/\/ Set default platform\n+#ifdef CMS_IS_WINDOWS_\n+    Icc ->platform = cmsSigMicrosoft;\n+#else\n+    Icc ->platform = cmsSigMacintosh;\n+#endif\n+\n+    \/\/ Set default device class\n+    Icc->DeviceClass = cmsSigDisplayClass;\n+\n@@ -533,1 +581,2 @@\n-    memmove(&Icc ->Created, gmtime(&now), sizeof(Icc ->Created));\n+    if (!_cmsGetTime(&Icc->Created))\n+        goto Error;\n@@ -540,0 +589,4 @@\n+\n+Error:\n+    _cmsFree(ContextID, Icc);\n+    return NULL;\n@@ -685,0 +738,21 @@\n+\n+\n+\/\/ Checks for link compatibility\n+static\n+cmsBool CompatibleTypes(const cmsTagDescriptor* desc1, const cmsTagDescriptor* desc2)\n+{\n+    cmsUInt32Number i;\n+\n+    if (desc1 == NULL || desc2 == NULL) return FALSE;\n+\n+    if (desc1->nSupportedTypes != desc2->nSupportedTypes) return FALSE;\n+    if (desc1->ElemCount != desc2->ElemCount) return FALSE;\n+\n+    for (i = 0; i < desc1->nSupportedTypes; i++)\n+    {\n+        if (desc1->SupportedTypes[i] != desc2->SupportedTypes[i]) return FALSE;\n+    }\n+\n+    return TRUE;\n+}\n+\n@@ -710,0 +784,23 @@\n+\/\/ Check device class\n+static\n+cmsBool validDeviceClass(cmsProfileClassSignature cl)\n+{\n+    if ((int)cl == 0) return TRUE; \/\/ We allow zero because older lcms versions defaulted to that.\n+\n+    switch (cl)\n+    {\n+    case cmsSigInputClass:\n+    case cmsSigDisplayClass:\n+    case cmsSigOutputClass:\n+    case cmsSigLinkClass:\n+    case cmsSigAbstractClass:\n+    case cmsSigColorSpaceClass:\n+    case cmsSigNamedColorClass:\n+        return TRUE;\n+\n+    default:\n+        return FALSE;\n+    }\n+\n+}\n+\n@@ -733,0 +830,1 @@\n+    Icc -> CMM             = _cmsAdjustEndianess32(Header.cmmId);\n@@ -738,0 +836,1 @@\n+    Icc -> platform        = (cmsPlatformSignature)_cmsAdjustEndianess32(Header.platform);\n@@ -746,0 +845,10 @@\n+    if (Icc->Version > 0x5000000) {\n+        cmsSignalError(Icc->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported profile version '0x%x'\", Icc->Version);\n+        return FALSE;\n+    }\n+\n+    if (!validDeviceClass(Icc->DeviceClass)) {\n+        cmsSignalError(Icc->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported device class '0x%x'\", Icc->DeviceClass);\n+        return FALSE;\n+    }\n+\n@@ -779,0 +888,1 @@\n+        if (Tag.size == 0 || Tag.offset == 0) continue;\n@@ -793,1 +903,6 @@\n-                Icc ->TagLinked[Icc ->TagCount] = Icc ->TagNames[j];\n+                \/\/ Check types.\n+                if (CompatibleTypes(_cmsGetTagDescriptor(Icc->ContextID, Icc->TagNames[j]),\n+                                    _cmsGetTagDescriptor(Icc->ContextID, Tag.sig))) {\n+\n+                    Icc->TagLinked[Icc->TagCount] = Icc->TagNames[j];\n+                }\n@@ -801,0 +916,13 @@\n+\n+    for (i = 0; i < Icc->TagCount; i++) {\n+        for (j = 0; j < Icc->TagCount; j++) {\n+\n+            \/\/ Tags cannot be duplicate\n+            if ((i != j) && (Icc->TagNames[i] == Icc->TagNames[j])) {\n+                cmsSignalError(Icc->ContextID, cmsERROR_RANGE, \"Duplicate tag found\");\n+                return FALSE;\n+            }\n+\n+        }\n+    }\n+\n@@ -813,1 +941,1 @@\n-    Header.cmmId       = _cmsAdjustEndianess32(lcmsSignature);\n+    Header.cmmId       = _cmsAdjustEndianess32(Icc ->CMM);\n@@ -825,5 +953,1 @@\n-#ifdef CMS_IS_WINDOWS_\n-    Header.platform    = (cmsPlatformSignature) _cmsAdjustEndianess32(cmsSigMicrosoft);\n-#else\n-    Header.platform    = (cmsPlatformSignature) _cmsAdjustEndianess32(cmsSigMacintosh);\n-#endif\n+    Header.platform    = (cmsPlatformSignature) _cmsAdjustEndianess32(Icc -> platform);\n@@ -845,2 +969,1 @@\n-    \/\/ Created by LittleCMS (that's me!)\n-    Header.creator      = _cmsAdjustEndianess32(lcmsSignature);\n+    Header.creator      = _cmsAdjustEndianess32(Icc ->creator);\n@@ -1462,0 +1585,7 @@\n+\/\/ Free one tag contents\n+static\n+void freeOneTag(_cmsICCPROFILE* Icc, cmsUInt32Number i)\n+{\n+    if (Icc->TagPtrs[i]) {\n+\n+        cmsTagTypeHandler* TypeHandler = Icc->TagTypeHandlers[i];\n@@ -1463,0 +1593,11 @@\n+        if (TypeHandler != NULL) {\n+            cmsTagTypeHandler LocalTypeHandler = *TypeHandler;\n+\n+            LocalTypeHandler.ContextID = Icc->ContextID;\n+            LocalTypeHandler.ICCVersion = Icc->Version;\n+            LocalTypeHandler.FreePtr(&LocalTypeHandler, Icc->TagPtrs[i]);\n+        }\n+        else\n+            _cmsFree(Icc->ContextID, Icc->TagPtrs[i]);\n+    }\n+}\n@@ -1482,14 +1623,1 @@\n-        if (Icc -> TagPtrs[i]) {\n-\n-            cmsTagTypeHandler* TypeHandler = Icc ->TagTypeHandlers[i];\n-\n-            if (TypeHandler != NULL) {\n-                cmsTagTypeHandler LocalTypeHandler = *TypeHandler;\n-\n-                LocalTypeHandler.ContextID = Icc ->ContextID;              \/\/ As an additional parameters\n-                LocalTypeHandler.ICCVersion = Icc ->Version;\n-                LocalTypeHandler.FreePtr(&LocalTypeHandler, Icc -> TagPtrs[i]);\n-            }\n-            else\n-                _cmsFree(Icc ->ContextID, Icc ->TagPtrs[i]);\n-        }\n+        freeOneTag(Icc, i);\n@@ -1547,2 +1675,6 @@\n-    if (n < 0) goto Error;               \/\/ Not found, return NULL\n-\n+    if (n < 0)\n+    {\n+        \/\/ Not found, return NULL\n+        _cmsUnlockMutex(Icc->ContextID, Icc->UsrMutex);\n+        return NULL;\n+    }\n@@ -1576,0 +1708,6 @@\n+    if (io == NULL) { \/\/ This is a built-in profile that has been manipulated, abort early\n+\n+        cmsSignalError(Icc->ContextID, cmsERROR_CORRUPTION_DETECTED, \"Corrupted built-in profile.\");\n+        goto Error;\n+    }\n+\n@@ -1643,1 +1781,1 @@\n-    \/\/ Return error and unlock tha data\n+    \/\/ Return error and unlock the data\n@@ -1645,0 +1783,4 @@\n+\n+    freeOneTag(Icc, n);\n+    Icc->TagPtrs[n] = NULL;\n+\n@@ -1783,5 +1925,3 @@\n-\/\/ Read and write raw data. The only way those function would work and keep consistence with normal read and write\n-\/\/ is to do an additional step of serialization. That means, readRaw would issue a normal read and then convert the obtained\n-\/\/ data to raw bytes by using the \"write\" serialization logic. And vice-versa. I know this may end in situations where\n-\/\/ raw data written does not exactly correspond with the raw data proposed to cmsWriteRaw data, but this approach allows\n-\/\/ to write a tag as raw data and the read it as handled.\n+\/\/ Read and write raw data. Read\/Write Raw\/cooked pairs try to maintain consistency within the pair. Some sequences\n+\/\/ raw\/cooked would work, but at a cost. Data \"cooked\" may be converted to \"raw\" by using the \"write\" serialization logic.\n+\/\/ In general it is better to avoid mixing pairs.\n@@ -1801,0 +1941,3 @@\n+    \/\/ Sanity check\n+    if (data != NULL && BufferSize == 0) return 0;\n+\n@@ -1804,0 +1947,1 @@\n+\n@@ -1810,1 +1954,1 @@\n-        \/\/ No yet, get original position\n+        \/\/ Not yet, get original position\n@@ -1815,0 +1959,1 @@\n+\n@@ -1831,1 +1976,1 @@\n-    \/\/ The data has been already read, or written. But wait!, maybe the user chose to save as\n+    \/\/ The data has been already read, or written. But wait!, maybe the user choose to save as\n@@ -1833,0 +1978,1 @@\n+\n@@ -1852,1 +1998,1 @@\n-    \/\/ data to raw in order to maintain consistency.\n+    \/\/ data to raw to get something that makes sense\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsio0.c","additions":194,"deletions":48,"binary":false,"changes":242,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -292,1 +292,1 @@\n-\/\/ Read the DToAX tag, adjusting the encoding of Lab or XYZ if neded\n+\/\/ Read the DToAX tag, adjusting the encoding of Lab or XYZ if needed\n@@ -354,2 +354,1 @@\n-        if (Lut == NULL) {\n-            cmsFreeNamedColorList(nc);\n+        if (Lut == NULL)\n@@ -357,1 +356,0 @@\n-        }\n@@ -568,1 +566,1 @@\n-\/\/ Read the DToAX tag, adjusting the encoding of Lab or XYZ if neded\n+\/\/ Read the DToAX tag, adjusting the encoding of Lab or XYZ if needed\n@@ -612,1 +610,1 @@\n-\/\/ Create an output MPE LUT from agiven profile. Version mismatches are handled here\n+\/\/ Create an output MPE LUT from a given profile. Version mismatches are handled here\n@@ -693,1 +691,1 @@\n-\/\/ Read the AToD0 tag, adjusting the encoding of Lab or XYZ if neded\n+\/\/ Read the AToD0 tag, adjusting the encoding of Lab or XYZ if needed\n@@ -772,1 +770,0 @@\n-        cmsFreeNamedColorList(nc);\n@@ -886,0 +883,4 @@\n+    \/\/ Extended intents are not strictly CLUT-based\n+    if (Intent > INTENT_ABSOLUTE_COLORIMETRIC)\n+        return FALSE;\n+\n@@ -1058,0 +1059,10 @@\n+\n+cmsUInt32Number  CMSEXPORT cmsGetProfileInfoUTF8(cmsHPROFILE hProfile, cmsInfoType Info,\n+                                                          const char LanguageCode[3], const char CountryCode[3],\n+                                                          char* Buffer, cmsUInt32Number BufferSize)\n+{\n+    const cmsMLU* mlu = GetInfo(hProfile, Info);\n+    if (mlu == NULL) return 0;\n+\n+    return cmsMLUgetUTF8(mlu, LanguageCode, CountryCode, Buffer, BufferSize);\n+}\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsio1.c","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -499,1 +499,1 @@\n-        if (dim == 0) return 0;  \/\/ Error\n+        if (dim <= 1) return 0;  \/\/ Error\n@@ -507,0 +507,3 @@\n+    \/\/ Again, prevent overflow\n+    if (rv > UINT_MAX \/ 15) return 0;\n+\n@@ -846,1 +849,7 @@\n-    _cmsStageCLutData* clut = (_cmsStageCLutData*) mpe->Data;\n+    _cmsStageCLutData* clut;\n+\n+    if (mpe == NULL) return FALSE;\n+\n+    clut = (_cmsStageCLutData*)mpe->Data;\n+\n+    if (clut == NULL) return FALSE;\n@@ -1258,0 +1267,5 @@\n+cmsContext CMSEXPORT cmsGetStageContextID(const cmsStage* mpe)\n+{\n+    return mpe -> ContextID;\n+}\n+\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmslut.c","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsmd5.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsmtrx.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -232,0 +232,13 @@\n+}\n+\n+\n+\/\/ Convert from UTF8 to wchar, returns len.\n+static\n+cmsUInt32Number decodeUTF8(wchar_t* out, const char* in)\n+{\n+    cmsUInt32Number codepoint = 0;\n+    cmsUInt32Number size = 0;\n+\n+    while (*in)\n+    {\n+        cmsUInt8Number ch = (cmsUInt8Number) *in;\n@@ -233,0 +246,115 @@\n+        if (ch <= 0x7f)\n+        {\n+            codepoint = ch;\n+        }\n+        else if (ch <= 0xbf)\n+        {\n+            codepoint = (codepoint << 6) | (ch & 0x3f);\n+        }\n+        else if (ch <= 0xdf)\n+        {\n+            codepoint = ch & 0x1f;\n+        }\n+        else if (ch <= 0xef)\n+        {\n+            codepoint = ch & 0x0f;\n+        }\n+        else\n+        {\n+            codepoint = ch & 0x07;\n+        }\n+\n+        in++;\n+\n+        if (((*in & 0xc0) != 0x80) && (codepoint <= 0x10ffff))\n+        {\n+            if (sizeof(wchar_t) > 2)\n+            {\n+                if (out) *out++ = (wchar_t) codepoint;\n+                size++;\n+            }\n+            else\n+                if (codepoint > 0xffff)\n+                {\n+                    if (out)\n+                    {\n+                        *out++ = (wchar_t)(0xd800 + (codepoint >> 10));\n+                        *out++ = (wchar_t)(0xdc00 + (codepoint & 0x03ff));\n+                        size += 2;\n+                    }\n+                }\n+                else\n+                    if (codepoint < 0xd800 || codepoint >= 0xe000)\n+                    {\n+                        if (out) *out++ = (wchar_t) codepoint;\n+                        size++;\n+                    }\n+        }\n+    }\n+\n+    return size;\n+}\n+\n+\/\/ Convert from wchar_t to UTF8\n+static\n+cmsUInt32Number encodeUTF8(char* out, const wchar_t* in, cmsUInt32Number max_wchars, cmsUInt32Number max_chars)\n+{\n+    cmsUInt32Number codepoint = 0;\n+    cmsUInt32Number size = 0;\n+    cmsUInt32Number len_w = 0;\n+\n+    while (*in && len_w < max_wchars)\n+    {\n+        if (*in >= 0xd800 && *in <= 0xdbff)\n+            codepoint = ((*in - 0xd800) << 10) + 0x10000;\n+        else\n+        {\n+            if (*in >= 0xdc00 && *in <= 0xdfff)\n+                codepoint |= *in - 0xdc00;\n+            else\n+                codepoint = *in;\n+\n+            if (codepoint <= 0x7f)\n+            {\n+                if (out && (size + 1 < max_chars)) *out++ = (char)codepoint;\n+                size++;\n+            }\n+\n+            else if (codepoint <= 0x7ff)\n+            {\n+                if (out && (max_chars > 0) && (size + 2 < max_chars))\n+                {\n+                    *out++ = (char)(cmsUInt32Number)(0xc0 | ((codepoint >> 6) & 0x1f));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | (codepoint & 0x3f));\n+                }\n+                size += 2;\n+            }\n+            else if (codepoint <= 0xffff)\n+            {\n+                if (out && (max_chars > 0) && (size + 3 < max_chars))\n+                {\n+                    *out++ = (char)(cmsUInt32Number)(0xe0 | ((codepoint >> 12) & 0x0f));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | ((codepoint >> 6) & 0x3f));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | (codepoint & 0x3f));\n+                }\n+                size += 3;\n+            }\n+            else\n+            {\n+                if (out && (max_chars > 0) && (size + 4 < max_chars))\n+                {\n+                    *out++ = (char)(cmsUInt32Number)(0xf0 | ((codepoint >> 18) & 0x07));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | ((codepoint >> 12) & 0x3f));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | ((codepoint >> 6) & 0x3f));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | (codepoint & 0x3f));\n+                }\n+                size += 4;\n+            }\n+\n+            codepoint = 0;\n+        }\n+\n+        in++; len_w++;\n+    }\n+\n+    return size;\n@@ -236,1 +364,1 @@\n-\/\/ In the case the user explicitely sets an empty string, we force a \\0\n+\/\/ In the case the user explicitly sets an empty string, we force a \\0\n@@ -239,1 +367,1 @@\n-    cmsUInt32Number i, len = (cmsUInt32Number) strlen(ASCIIString);\n+    cmsUInt32Number i, len = (cmsUInt32Number)strlen(ASCIIString);\n@@ -242,1 +370,1 @@\n-    cmsUInt16Number Lang  = strTo16(LanguageCode);\n+    cmsUInt16Number Lang = strTo16(LanguageCode);\n@@ -250,1 +378,2 @@\n-        len = 1;\n+        wchar_t empty = 0;\n+        return AddMLUBlock(mlu, sizeof(wchar_t), &empty, Lang, Cntry);\n@@ -253,1 +382,1 @@\n-    WStr = (wchar_t*) _cmsCalloc(mlu ->ContextID, len,  sizeof(wchar_t));\n+    WStr = (wchar_t*)_cmsCalloc(mlu->ContextID, len, sizeof(wchar_t));\n@@ -256,2 +385,2 @@\n-    for (i=0; i < len; i++)\n-        WStr[i] = (wchar_t) ASCIIString[i];\n+    for (i = 0; i < len; i++)\n+        WStr[i] = (wchar_t)ASCIIString[i];\n@@ -259,1 +388,1 @@\n-    rc = AddMLUBlock(mlu, len  * sizeof(wchar_t), WStr, Lang, Cntry);\n+    rc = AddMLUBlock(mlu, len * sizeof(wchar_t), WStr, Lang, Cntry);\n@@ -261,1 +390,1 @@\n-    _cmsFree(mlu ->ContextID, WStr);\n+    _cmsFree(mlu->ContextID, WStr);\n@@ -266,0 +395,33 @@\n+\/\/ Add an UTF8 entry. Do not add any \\0 termination (ICC1v43_2010-12.pdf page 61)\n+\/\/ In the case the user explicitly sets an empty string, we force a \\0\n+cmsBool CMSEXPORT cmsMLUsetUTF8(cmsMLU* mlu, const char LanguageCode[3], const char CountryCode[3], const char* UTF8String)\n+{\n+    cmsUInt32Number UTF8len;\n+    wchar_t* WStr;\n+    cmsBool  rc;\n+    cmsUInt16Number Lang  = strTo16(LanguageCode);\n+    cmsUInt16Number Cntry = strTo16(CountryCode);\n+\n+    if (mlu == NULL) return FALSE;\n+\n+    if (*UTF8String == '\\0')\n+    {\n+        wchar_t empty = 0;\n+        return AddMLUBlock(mlu, sizeof(wchar_t), &empty, Lang, Cntry);\n+    }\n+\n+    \/\/ Len excluding terminator 0\n+    UTF8len = decodeUTF8(NULL, UTF8String);\n+\n+    \/\/ Get space for dest\n+    WStr = (wchar_t*) _cmsCalloc(mlu ->ContextID, UTF8len,  sizeof(wchar_t));\n+    if (WStr == NULL) return FALSE;\n+\n+    decodeUTF8(WStr, UTF8String);\n+\n+    rc = AddMLUBlock(mlu, UTF8len  * sizeof(wchar_t), WStr, Lang, Cntry);\n+\n+    _cmsFree(mlu ->ContextID, WStr);\n+    return rc;\n+}\n+\n@@ -402,1 +564,3 @@\n-    return(wchar_t*) ((cmsUInt8Number*) mlu ->MemPool + v ->StrW);\n+    if (v->StrW + v->Len > mlu->PoolSize) return NULL;\n+\n+    return (wchar_t*) ((cmsUInt8Number*) mlu ->MemPool + v ->StrW);\n@@ -440,2 +604,4 @@\n-        if (Wide[i] == 0)\n-            Buffer[i] = 0;\n+        wchar_t wc = Wide[i];\n+\n+        if (wc < 0xff)\n+            Buffer[i] = (char)wc;\n@@ -443,1 +609,1 @@\n-            Buffer[i] = (char) Wide[i];\n+            Buffer[i] = '?';\n@@ -451,0 +617,40 @@\n+\n+\/\/ Obtain a UTF8 representation of the wide string. Setting buffer to NULL returns the len\n+cmsUInt32Number CMSEXPORT cmsMLUgetUTF8(const cmsMLU* mlu,\n+                                       const char LanguageCode[3], const char CountryCode[3],\n+                                       char* Buffer, cmsUInt32Number BufferSize)\n+{\n+    const wchar_t *Wide;\n+    cmsUInt32Number  StrLen = 0;\n+    cmsUInt32Number UTF8len;\n+\n+    cmsUInt16Number Lang  = strTo16(LanguageCode);\n+    cmsUInt16Number Cntry = strTo16(CountryCode);\n+\n+    \/\/ Sanitize\n+    if (mlu == NULL) return 0;\n+\n+    \/\/ Get WideChar\n+    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);\n+    if (Wide == NULL) return 0;\n+\n+    UTF8len = encodeUTF8(NULL, Wide, StrLen \/ sizeof(wchar_t), BufferSize);\n+\n+    \/\/ Maybe we want only to know the len?\n+    if (Buffer == NULL) return UTF8len + 1; \/\/ Note the zero at the end\n+\n+    \/\/ No buffer size means no data\n+    if (BufferSize <= 0) return 0;\n+\n+    \/\/ Some clipping may be required\n+    if (BufferSize < UTF8len + 1)\n+        UTF8len = BufferSize - 1;\n+\n+    \/\/ Process it\n+    encodeUTF8(Buffer, Wide, StrLen \/ sizeof(wchar_t), BufferSize);\n+\n+    \/\/ We put a termination \"\\0\"\n+    Buffer[UTF8len] = 0;\n+    return UTF8len + 1;\n+}\n+\n@@ -471,2 +677,2 @@\n-  \/\/ No buffer size means no data\n-    if (BufferSize <= 0) return 0;\n+    \/\/ Invalid buffer size means no data\n+    if (BufferSize < sizeof(wchar_t)) return 0;\n@@ -476,1 +682,1 @@\n-        StrLen = BufferSize - + sizeof(wchar_t);\n+        StrLen = BufferSize - sizeof(wchar_t);\n@@ -574,1 +780,1 @@\n-    cmsNAMEDCOLORLIST* v = (cmsNAMEDCOLORLIST*) _cmsMallocZero(ContextID, sizeof(cmsNAMEDCOLORLIST));\n+    cmsNAMEDCOLORLIST* v;\n@@ -576,0 +782,4 @@\n+    if (ColorantCount > cmsMAXCHANNELS)\n+        return NULL;\n+\n+    v = (cmsNAMEDCOLORLIST*)_cmsMallocZero(ContextID, sizeof(cmsNAMEDCOLORLIST));\n@@ -673,1 +883,1 @@\n-\/\/ Info aboout a given color\n+\/\/ Info about a given color\n@@ -789,1 +999,7 @@\n-    cmsStage* mpe  = v ->Lut->Elements;\n+    cmsStage* mpe;\n+\n+    if (v == NULL) return NULL;\n+    if (v->Lut == NULL) return NULL;\n+\n+    mpe = v->Lut->Elements;\n+    if (mpe == NULL) return NULL;\n@@ -834,4 +1050,11 @@\n-    for (i=0; i < pseq ->n; i++) {\n-        if (pseq ->seq[i].Manufacturer != NULL) cmsMLUfree(pseq ->seq[i].Manufacturer);\n-        if (pseq ->seq[i].Model != NULL) cmsMLUfree(pseq ->seq[i].Model);\n-        if (pseq ->seq[i].Description != NULL) cmsMLUfree(pseq ->seq[i].Description);\n+    if (pseq == NULL)\n+        return;\n+\n+    if (pseq ->seq != NULL) {\n+        for (i=0; i < pseq ->n; i++) {\n+            if (pseq ->seq[i].Manufacturer != NULL) cmsMLUfree(pseq ->seq[i].Manufacturer);\n+            if (pseq ->seq[i].Model != NULL) cmsMLUfree(pseq ->seq[i].Model);\n+            if (pseq ->seq[i].Description != NULL) cmsMLUfree(pseq ->seq[i].Description);\n+        }\n+\n+        _cmsFree(pseq ->ContextID, pseq ->seq);\n@@ -840,1 +1063,0 @@\n-    if (pseq ->seq != NULL) _cmsFree(pseq ->ContextID, pseq ->seq);\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsnamed.c","additions":247,"deletions":25,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -215,0 +215,1 @@\n+\n@@ -679,1 +680,0 @@\n-    cmsStage* mpe;\n@@ -701,1 +701,1 @@\n-    nGridPoints      = _cmsReasonableGridpointsByColorspace(ColorSpace, *dwFlags);\n+    nGridPoints = _cmsReasonableGridpointsByColorspace(ColorSpace, *dwFlags);\n@@ -709,7 +709,0 @@\n-    \/\/ Named color pipelines cannot be optimized either\n-    for (mpe = cmsPipelineGetPtrToFirstStage(Src);\n-        mpe != NULL;\n-        mpe = cmsStageNext(mpe)) {\n-            if (cmsStageType(mpe) == cmsSigNamedColorElemType) return FALSE;\n-    }\n-\n@@ -1083,1 +1076,0 @@\n-    cmsStage* mpe;\n@@ -1105,7 +1097,0 @@\n-   \/\/ Named color pipelines cannot be optimized either\n-   for (mpe = cmsPipelineGetPtrToFirstStage(OriginalLut);\n-         mpe != NULL;\n-         mpe = cmsStageNext(mpe)) {\n-            if (cmsStageType(mpe) == cmsSigNamedColorElemType) return FALSE;\n-    }\n-\n@@ -1161,1 +1146,4 @@\n-            Trans[t] ->Table16[i] = _cmsQuickSaturateWord(Out[t] * 65535.0);\n+        {\n+            if (Trans[t]->Table16 != NULL)\n+                Trans[t] ->Table16[i] = _cmsQuickSaturateWord(Out[t] * 65535.0);\n+        }\n@@ -1168,1 +1156,1 @@\n-    \/\/ Check for validity\n+    \/\/ Check for validity. lIsLinear is here for debug purposes\n@@ -1565,1 +1553,1 @@\n-\/\/ A fast matrix-shaper evaluator for 8 bits. This is a bit ticky since I'm using 1.14 signed fixed point\n+\/\/ A fast matrix-shaper evaluator for 8 bits. This is a bit tricky since I'm using 1.14 signed fixed point\n@@ -1568,1 +1556,1 @@\n-static\n+static CMS_NO_SANITIZE\n@@ -1743,0 +1731,4 @@\n+              \/\/ Only RGB to RGB\n+              if (Matrix1->InputChannels != 3 || Matrix1->OutputChannels != 3 ||\n+                  Matrix2->InputChannels != 3 || Matrix2->OutputChannels != 3) return FALSE;\n+\n@@ -1768,0 +1760,2 @@\n+                     if (Matrix1->InputChannels != 3 || Matrix1->OutputChannels != 3) return FALSE;\n+\n@@ -1812,1 +1806,1 @@\n-        \/\/ the cache that with the pixel handling\n+        \/\/ the cache than with the pixel handling\n@@ -1950,0 +1944,1 @@\n+    cmsStage* mpe;\n@@ -1964,0 +1959,7 @@\n+    \/\/ Named color pipelines cannot be optimized\n+    for (mpe = cmsPipelineGetPtrToFirstStage(*PtrLut);\n+        mpe != NULL;\n+        mpe = cmsStageNext(mpe)) {\n+            if (cmsStageType(mpe) == cmsSigNamedColorElemType) return FALSE;\n+    }\n+\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsopt.c","additions":25,"deletions":23,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -111,0 +111,1 @@\n+#define ANYPREMUL       PREMUL_SH(1)\n@@ -134,0 +135,2 @@\n+    cmsUInt32Number Premul     = T_PREMUL(info->InputFormat);\n+\n@@ -135,1 +138,1 @@\n-    cmsUInt16Number v;\n+    cmsUInt32Number v;\n@@ -137,0 +140,1 @@\n+    cmsUInt32Number alpha_factor = 1;\n@@ -139,0 +143,4 @@\n+\n+        if (Premul && Extra)\n+            alpha_factor = _cmsToFixedDomain(FROM_8_TO_16(accum[0]));\n+\n@@ -141,0 +149,5 @@\n+    else\n+    {\n+        if (Premul && Extra)\n+            alpha_factor = _cmsToFixedDomain(FROM_8_TO_16(accum[nChan]));\n+    }\n@@ -143,0 +156,1 @@\n+\n@@ -147,1 +161,8 @@\n-        wIn[index] = v;\n+\n+        if (Premul && alpha_factor > 0)\n+        {\n+            v = ((cmsUInt32Number)((cmsUInt32Number)v << 16) \/ alpha_factor);\n+            if (v > 0xffff) v = 0xffff;\n+        }\n+\n+        wIn[index] = (cmsUInt16Number) v;\n@@ -169,0 +190,1 @@\n+\n@@ -181,0 +203,3 @@\n+    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n+    cmsUInt32Number Extra = T_EXTRA(info->InputFormat);\n+    cmsUInt32Number Premul = T_PREMUL(info->InputFormat);\n@@ -182,0 +207,1 @@\n+    cmsUInt32Number alpha_factor = 1;\n@@ -183,2 +209,12 @@\n-    if (DoSwap ^ SwapFirst) {\n-        accum += T_EXTRA(info -> InputFormat) * Stride;\n+    if (ExtraFirst) {\n+\n+        if (Premul && Extra)\n+            alpha_factor = _cmsToFixedDomain(FROM_8_TO_16(accum[0]));\n+\n+\n+        accum += Extra * Stride;\n+    }\n+    else\n+    {\n+        if (Premul && Extra)\n+            alpha_factor = _cmsToFixedDomain(FROM_8_TO_16(accum[(nChan) * Stride]));\n@@ -190,1 +226,1 @@\n-        cmsUInt16Number v = FROM_8_TO_16(*accum);\n+        cmsUInt32Number v = FROM_8_TO_16(*accum);\n@@ -192,1 +228,9 @@\n-        wIn[index] = Reverse ? REVERSE_FLAVOR_16(v) : v;\n+        v = Reverse ? REVERSE_FLAVOR_16(v) : v;\n+\n+        if (Premul && alpha_factor > 0)\n+        {\n+            v = ((cmsUInt32Number)((cmsUInt32Number)v << 16) \/ alpha_factor);\n+            if (v > 0xffff) v = 0xffff;\n+        }\n+\n+        wIn[index] = (cmsUInt16Number) v;\n@@ -199,0 +243,1 @@\n+\n@@ -549,0 +594,52 @@\n+\n+static\n+cmsUInt8Number* UnrollAnyWordsPremul(CMSREGISTER _cmsTRANSFORM* info,\n+                                     CMSREGISTER cmsUInt16Number wIn[],\n+                                     CMSREGISTER cmsUInt8Number* accum,\n+                                     CMSREGISTER cmsUInt32Number Stride)\n+{\n+   cmsUInt32Number nChan       = T_CHANNELS(info -> InputFormat);\n+   cmsUInt32Number SwapEndian  = T_ENDIAN16(info -> InputFormat);\n+   cmsUInt32Number DoSwap      = T_DOSWAP(info ->InputFormat);\n+   cmsUInt32Number Reverse     = T_FLAVOR(info ->InputFormat);\n+   cmsUInt32Number SwapFirst   = T_SWAPFIRST(info -> InputFormat);\n+   cmsUInt32Number ExtraFirst  = DoSwap ^ SwapFirst;\n+   cmsUInt32Number i;\n+\n+   cmsUInt16Number alpha = (ExtraFirst ? accum[0] : accum[nChan - 1]);\n+   cmsUInt32Number alpha_factor = _cmsToFixedDomain(FROM_8_TO_16(alpha));\n+\n+    if (ExtraFirst) {\n+        accum += sizeof(cmsUInt16Number);\n+    }\n+\n+    for (i=0; i < nChan; i++) {\n+\n+        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n+        cmsUInt32Number v = *(cmsUInt16Number*) accum;\n+\n+        if (SwapEndian)\n+            v = CHANGE_ENDIAN(v);\n+\n+        if (alpha_factor > 0) {\n+\n+            v = (v << 16) \/ alpha_factor;\n+            if (v > 0xffff) v = 0xffff;\n+        }\n+\n+        wIn[index] = (cmsUInt16Number) (Reverse ? REVERSE_FLAVOR_16(v) : v);\n+\n+        accum += sizeof(cmsUInt16Number);\n+    }\n+\n+    if (!ExtraFirst) {\n+        accum += sizeof(cmsUInt16Number);\n+    }\n+\n+    return accum;\n+\n+    cmsUNUSED_PARAMETER(Stride);\n+}\n+\n+\n+\n@@ -582,0 +679,43 @@\n+static\n+cmsUInt8Number* UnrollPlanarWordsPremul(CMSREGISTER _cmsTRANSFORM* info,\n+                                        CMSREGISTER cmsUInt16Number wIn[],\n+                                        CMSREGISTER cmsUInt8Number* accum,\n+                                        CMSREGISTER cmsUInt32Number Stride)\n+{\n+    cmsUInt32Number nChan = T_CHANNELS(info -> InputFormat);\n+    cmsUInt32Number DoSwap= T_DOSWAP(info ->InputFormat);\n+    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->InputFormat);\n+    cmsUInt32Number Reverse= T_FLAVOR(info ->InputFormat);\n+    cmsUInt32Number SwapEndian = T_ENDIAN16(info -> InputFormat);\n+    cmsUInt32Number i;\n+    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n+    cmsUInt8Number* Init = accum;\n+\n+    cmsUInt16Number  alpha = (ExtraFirst ? accum[0] : accum[(nChan - 1) * Stride]);\n+    cmsUInt32Number alpha_factor = _cmsToFixedDomain(FROM_8_TO_16(alpha));\n+\n+    if (ExtraFirst) {\n+        accum += Stride;\n+    }\n+\n+    for (i=0; i < nChan; i++) {\n+\n+        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n+        cmsUInt32Number v = (cmsUInt32Number) *(cmsUInt16Number*) accum;\n+\n+        if (SwapEndian)\n+            v = CHANGE_ENDIAN(v);\n+\n+        if (alpha_factor > 0) {\n+\n+            v = (v << 16) \/ alpha_factor;\n+            if (v > 0xffff) v = 0xffff;\n+        }\n+\n+        wIn[index] = (cmsUInt16Number) (Reverse ? REVERSE_FLAVOR_16(v) : v);\n+\n+        accum +=  Stride;\n+    }\n+\n+    return (Init + sizeof(cmsUInt16Number));\n+}\n@@ -1119,0 +1259,104 @@\n+\/\/ For anything going from cmsUInt8Number\n+static\n+cmsUInt8Number* Unroll8ToFloat(_cmsTRANSFORM* info,\n+                               cmsFloat32Number wIn[],\n+                               cmsUInt8Number* accum,\n+                               cmsUInt32Number Stride)\n+{\n+\n+    cmsUInt32Number nChan = T_CHANNELS(info->InputFormat);\n+    cmsUInt32Number DoSwap = T_DOSWAP(info->InputFormat);\n+    cmsUInt32Number Reverse = T_FLAVOR(info->InputFormat);\n+    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->InputFormat);\n+    cmsUInt32Number Extra = T_EXTRA(info->InputFormat);\n+    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n+    cmsUInt32Number Planar = T_PLANAR(info->InputFormat);\n+    cmsFloat32Number v;\n+    cmsUInt32Number i, start = 0;\n+\n+    Stride \/= PixelSize(info->InputFormat);\n+\n+    if (ExtraFirst)\n+        start = Extra;\n+\n+    for (i = 0; i < nChan; i++) {\n+\n+        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n+\n+        if (Planar)\n+            v = (cmsFloat32Number) ((cmsUInt8Number *)accum)[(i + start) * Stride];\n+        else\n+            v = (cmsFloat32Number) ((cmsUInt8Number *)accum)[i + start];\n+\n+        v \/= 255.0F;\n+\n+        wIn[index] = Reverse ? 1 - v : v;\n+    }\n+\n+\n+    if (Extra == 0 && SwapFirst) {\n+        cmsFloat32Number tmp = wIn[0];\n+\n+        memmove(&wIn[0], &wIn[1], (nChan - 1) * sizeof(cmsFloat32Number));\n+        wIn[nChan - 1] = tmp;\n+    }\n+\n+    if (T_PLANAR(info->InputFormat))\n+        return accum + sizeof(cmsUInt8Number);\n+    else\n+        return accum + (nChan + Extra) * sizeof(cmsUInt8Number);\n+}\n+\n+\n+\/\/ For anything going from cmsUInt16Number\n+static\n+cmsUInt8Number* Unroll16ToFloat(_cmsTRANSFORM* info,\n+                                cmsFloat32Number wIn[],\n+                                cmsUInt8Number* accum,\n+                                cmsUInt32Number Stride)\n+{\n+\n+    cmsUInt32Number nChan = T_CHANNELS(info->InputFormat);\n+    cmsUInt32Number DoSwap = T_DOSWAP(info->InputFormat);\n+    cmsUInt32Number Reverse = T_FLAVOR(info->InputFormat);\n+    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->InputFormat);\n+    cmsUInt32Number Extra = T_EXTRA(info->InputFormat);\n+    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n+    cmsUInt32Number Planar = T_PLANAR(info->InputFormat);\n+    cmsFloat32Number v;\n+    cmsUInt32Number i, start = 0;\n+\n+    Stride \/= PixelSize(info->InputFormat);\n+\n+    if (ExtraFirst)\n+        start = Extra;\n+\n+    for (i = 0; i < nChan; i++) {\n+\n+        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n+\n+        if (Planar)\n+            v = (cmsFloat32Number)((cmsUInt16Number*)accum)[(i + start) * Stride];\n+        else\n+            v = (cmsFloat32Number)((cmsUInt16Number*)accum)[i + start];\n+\n+        v \/= 65535.0F;\n+\n+        wIn[index] = Reverse ? 1 - v : v;\n+    }\n+\n+\n+    if (Extra == 0 && SwapFirst) {\n+        cmsFloat32Number tmp = wIn[0];\n+\n+        memmove(&wIn[0], &wIn[1], (nChan - 1) * sizeof(cmsFloat32Number));\n+        wIn[nChan - 1] = tmp;\n+    }\n+\n+    if (T_PLANAR(info->InputFormat))\n+        return accum + sizeof(cmsUInt16Number);\n+    else\n+        return accum + (nChan + Extra) * sizeof(cmsUInt16Number);\n+}\n+\n+\n@@ -1127,5 +1371,5 @@\n-    cmsUInt32Number nChan  = T_CHANNELS(info -> InputFormat);\n-    cmsUInt32Number DoSwap   = T_DOSWAP(info ->InputFormat);\n-    cmsUInt32Number Reverse    = T_FLAVOR(info ->InputFormat);\n-    cmsUInt32Number SwapFirst  = T_SWAPFIRST(info -> InputFormat);\n-    cmsUInt32Number Extra   = T_EXTRA(info -> InputFormat);\n+    cmsUInt32Number nChan = T_CHANNELS(info->InputFormat);\n+    cmsUInt32Number DoSwap = T_DOSWAP(info->InputFormat);\n+    cmsUInt32Number Reverse = T_FLAVOR(info->InputFormat);\n+    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->InputFormat);\n+    cmsUInt32Number Extra = T_EXTRA(info->InputFormat);\n@@ -1133,1 +1377,2 @@\n-    cmsUInt32Number Planar     = T_PLANAR(info -> InputFormat);\n+    cmsUInt32Number Planar = T_PLANAR(info->InputFormat);\n+    cmsUInt32Number Premul = T_PREMUL(info->InputFormat);\n@@ -1136,1 +1381,3 @@\n-    cmsFloat32Number maximum = IsInkSpace(info ->InputFormat) ? 100.0F : 1.0F;\n+    cmsFloat32Number maximum = IsInkSpace(info->InputFormat) ? 100.0F : 1.0F;\n+    cmsFloat32Number alpha_factor = 1.0f;\n+    cmsFloat32Number* ptr = (cmsFloat32Number*)accum;\n@@ -1140,0 +1387,8 @@\n+    if (Premul && Extra)\n+    {\n+        if (Planar)\n+            alpha_factor = (ExtraFirst ? ptr[0] : ptr[nChan * Stride]) \/ maximum;\n+        else\n+            alpha_factor = (ExtraFirst ? ptr[0] : ptr[nChan]) \/ maximum;\n+    }\n+\n@@ -1148,1 +1403,1 @@\n-            v = (cmsFloat32Number) ((cmsFloat32Number*) accum)[(i + start) * Stride];\n+            v = ptr[(i + start) * Stride];\n@@ -1150,1 +1405,4 @@\n-            v = (cmsFloat32Number) ((cmsFloat32Number*) accum)[i + start];\n+            v = ptr[i + start];\n+\n+        if (Premul && alpha_factor > 0)\n+            v \/= alpha_factor;\n@@ -1180,5 +1438,5 @@\n-    cmsUInt32Number nChan  = T_CHANNELS(info -> InputFormat);\n-    cmsUInt32Number DoSwap   = T_DOSWAP(info ->InputFormat);\n-    cmsUInt32Number Reverse    = T_FLAVOR(info ->InputFormat);\n-    cmsUInt32Number SwapFirst  = T_SWAPFIRST(info -> InputFormat);\n-    cmsUInt32Number Extra   = T_EXTRA(info -> InputFormat);\n+    cmsUInt32Number nChan = T_CHANNELS(info->InputFormat);\n+    cmsUInt32Number DoSwap = T_DOSWAP(info->InputFormat);\n+    cmsUInt32Number Reverse = T_FLAVOR(info->InputFormat);\n+    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->InputFormat);\n+    cmsUInt32Number Extra = T_EXTRA(info->InputFormat);\n@@ -1186,1 +1444,2 @@\n-    cmsUInt32Number Planar     = T_PLANAR(info -> InputFormat);\n+    cmsUInt32Number Planar = T_PLANAR(info->InputFormat);\n+    cmsUInt32Number Premul = T_PREMUL(info->InputFormat);\n@@ -1190,0 +1449,2 @@\n+    cmsFloat64Number alpha_factor = 1.0;\n+    cmsFloat64Number* ptr = (cmsFloat64Number*)accum;\n@@ -1193,0 +1454,8 @@\n+    if (Premul && Extra)\n+    {\n+        if (Planar)\n+            alpha_factor = (ExtraFirst ? ptr[0] : ptr[(nChan) * Stride]) \/ maximum;\n+        else\n+            alpha_factor = (ExtraFirst ? ptr[0] : ptr[nChan]) \/ maximum;\n+    }\n+\n@@ -1205,0 +1474,4 @@\n+\n+        if (Premul && alpha_factor > 0)\n+            v \/= alpha_factor;\n+\n@@ -1286,2 +1559,0 @@\n-\n-\n@@ -1348,0 +1619,73 @@\n+cmsINLINE void lab4toFloat(cmsFloat32Number wIn[], cmsUInt16Number lab4[3])\n+{\n+    cmsFloat32Number L = (cmsFloat32Number) lab4[0] \/ 655.35F;\n+    cmsFloat32Number a = ((cmsFloat32Number) lab4[1] \/ 257.0F) - 128.0F;\n+    cmsFloat32Number b = ((cmsFloat32Number) lab4[2] \/ 257.0F) - 128.0F;\n+\n+    wIn[0] = (L \/ 100.0F);                    \/\/ from 0..100 to 0..1\n+    wIn[1] = ((a + 128.0F) \/ 255.0F);         \/\/ form -128..+127 to 0..1\n+    wIn[2] = ((b + 128.0F) \/ 255.0F);\n+\n+}\n+\n+static\n+cmsUInt8Number* UnrollLabV2_8ToFloat(_cmsTRANSFORM* info,\n+                                      cmsFloat32Number wIn[],\n+                                      cmsUInt8Number* accum,\n+                                      cmsUInt32Number Stride)\n+{\n+    cmsUInt16Number lab4[3];\n+\n+    lab4[0] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     \/\/ L\n+    lab4[1] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     \/\/ a\n+    lab4[2] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     \/\/ b\n+\n+    lab4toFloat(wIn, lab4);\n+\n+    return accum;\n+\n+    cmsUNUSED_PARAMETER(info);\n+    cmsUNUSED_PARAMETER(Stride);\n+}\n+\n+static\n+cmsUInt8Number* UnrollALabV2_8ToFloat(_cmsTRANSFORM* info,\n+                                      cmsFloat32Number wIn[],\n+                                      cmsUInt8Number* accum,\n+                                      cmsUInt32Number Stride)\n+{\n+    cmsUInt16Number lab4[3];\n+\n+    accum++;  \/\/ A\n+    lab4[0] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     \/\/ L\n+    lab4[1] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     \/\/ a\n+    lab4[2] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     \/\/ b\n+\n+    lab4toFloat(wIn, lab4);\n+\n+    return accum;\n+\n+    cmsUNUSED_PARAMETER(info);\n+    cmsUNUSED_PARAMETER(Stride);\n+}\n+\n+static\n+cmsUInt8Number* UnrollLabV2_16ToFloat(_cmsTRANSFORM* info,\n+                                      cmsFloat32Number wIn[],\n+                                      cmsUInt8Number* accum,\n+                                      cmsUInt32Number Stride)\n+{\n+    cmsUInt16Number lab4[3];\n+\n+    lab4[0] = FomLabV2ToLabV4(*(cmsUInt16Number*) accum); accum += 2;     \/\/ L\n+    lab4[1] = FomLabV2ToLabV4(*(cmsUInt16Number*) accum); accum += 2;     \/\/ a\n+    lab4[2] = FomLabV2ToLabV4(*(cmsUInt16Number*) accum); accum += 2;     \/\/ b\n+\n+    lab4toFloat(wIn, lab4);\n+\n+    return accum;\n+\n+    cmsUNUSED_PARAMETER(info);\n+    cmsUNUSED_PARAMETER(Stride);\n+}\n+\n@@ -1353,1 +1697,0 @@\n-\n@@ -1355,4 +1698,4 @@\n-cmsUInt8Number* PackAnyBytes(CMSREGISTER _cmsTRANSFORM* info,\n-                             CMSREGISTER cmsUInt16Number wOut[],\n-                             CMSREGISTER cmsUInt8Number* output,\n-                             CMSREGISTER cmsUInt32Number Stride)\n+cmsUInt8Number* PackChunkyBytes(CMSREGISTER _cmsTRANSFORM* info,\n+                                CMSREGISTER cmsUInt16Number wOut[],\n+                                CMSREGISTER cmsUInt8Number* output,\n+                                CMSREGISTER cmsUInt32Number Stride)\n@@ -1360,5 +1703,6 @@\n-    cmsUInt32Number nChan  = T_CHANNELS(info -> OutputFormat);\n-    cmsUInt32Number DoSwap   = T_DOSWAP(info ->OutputFormat);\n-    cmsUInt32Number Reverse    = T_FLAVOR(info ->OutputFormat);\n-    cmsUInt32Number Extra   = T_EXTRA(info -> OutputFormat);\n-    cmsUInt32Number SwapFirst  = T_SWAPFIRST(info -> OutputFormat);\n+    cmsUInt32Number nChan = T_CHANNELS(info->OutputFormat);\n+    cmsUInt32Number DoSwap = T_DOSWAP(info->OutputFormat);\n+    cmsUInt32Number Reverse = T_FLAVOR(info->OutputFormat);\n+    cmsUInt32Number Extra = T_EXTRA(info->OutputFormat);\n+    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->OutputFormat);\n+    cmsUInt32Number Premul = T_PREMUL(info->OutputFormat);\n@@ -1367,1 +1711,1 @@\n-    cmsUInt8Number v = 0;\n+    cmsUInt16Number v = 0;\n@@ -1369,0 +1713,1 @@\n+    cmsUInt32Number alpha_factor = 0;\n@@ -1373,0 +1718,4 @@\n+\n+        if (Premul && Extra)\n+            alpha_factor = _cmsToFixedDomain(FROM_8_TO_16(output[0]));\n+\n@@ -1375,0 +1724,5 @@\n+    else\n+    {\n+        if (Premul && Extra)\n+            alpha_factor = _cmsToFixedDomain(FROM_8_TO_16(output[nChan]));\n+    }\n@@ -1380,1 +1734,1 @@\n-        v = FROM_16_TO_8(wOut[index]);\n+        v = wOut[index];\n@@ -1383,1 +1737,1 @@\n-            v = REVERSE_FLAVOR_8(v);\n+            v = REVERSE_FLAVOR_16(v);\n@@ -1385,1 +1739,6 @@\n-        *output++ = v;\n+        if (Premul)\n+        {\n+            v = (cmsUInt16Number)((cmsUInt32Number)((cmsUInt32Number)v * alpha_factor + 0x8000) >> 16);\n+        }\n+\n+        *output++ = FROM_16_TO_8(v);\n@@ -1395,1 +1754,1 @@\n-        *swap1 = v;\n+        *swap1 = FROM_16_TO_8(v);\n@@ -1398,1 +1757,0 @@\n-\n@@ -1404,2 +1762,0 @@\n-\n-\n@@ -1407,4 +1763,4 @@\n-cmsUInt8Number* PackAnyWords(CMSREGISTER _cmsTRANSFORM* info,\n-                             CMSREGISTER cmsUInt16Number wOut[],\n-                             CMSREGISTER cmsUInt8Number* output,\n-                             CMSREGISTER cmsUInt32Number Stride)\n+cmsUInt8Number* PackChunkyWords(CMSREGISTER _cmsTRANSFORM* info,\n+                                CMSREGISTER cmsUInt16Number wOut[],\n+                                CMSREGISTER cmsUInt8Number* output,\n+                                CMSREGISTER cmsUInt32Number Stride)\n@@ -1412,6 +1768,7 @@\n-    cmsUInt32Number nChan  = T_CHANNELS(info -> OutputFormat);\n-    cmsUInt32Number SwapEndian = T_ENDIAN16(info -> OutputFormat);\n-    cmsUInt32Number DoSwap   = T_DOSWAP(info ->OutputFormat);\n-    cmsUInt32Number Reverse    = T_FLAVOR(info ->OutputFormat);\n-    cmsUInt32Number Extra   = T_EXTRA(info -> OutputFormat);\n-    cmsUInt32Number SwapFirst  = T_SWAPFIRST(info -> OutputFormat);\n+    cmsUInt32Number nChan = T_CHANNELS(info->OutputFormat);\n+    cmsUInt32Number SwapEndian = T_ENDIAN16(info->OutputFormat);\n+    cmsUInt32Number DoSwap = T_DOSWAP(info->OutputFormat);\n+    cmsUInt32Number Reverse = T_FLAVOR(info->OutputFormat);\n+    cmsUInt32Number Extra = T_EXTRA(info->OutputFormat);\n+    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->OutputFormat);\n+    cmsUInt32Number Premul = T_PREMUL(info->OutputFormat);\n@@ -1422,0 +1779,1 @@\n+    cmsUInt32Number alpha_factor = 0;\n@@ -1426,0 +1784,4 @@\n+\n+        if (Premul && Extra)\n+            alpha_factor = _cmsToFixedDomain(*(cmsUInt16Number*) output);\n+\n@@ -1428,0 +1790,5 @@\n+    else\n+    {\n+        if (Premul && Extra)\n+            alpha_factor = _cmsToFixedDomain(((cmsUInt16Number*) output)[nChan]);\n+    }\n@@ -1441,0 +1808,5 @@\n+        if (Premul)\n+        {\n+            v = (cmsUInt16Number)((cmsUInt32Number)((cmsUInt32Number)v * alpha_factor + 0x8000) >> 16);\n+        }\n+\n@@ -1456,1 +1828,0 @@\n-\n@@ -1463,0 +1834,1 @@\n+\n@@ -1469,4 +1841,7 @@\n-    cmsUInt32Number nChan     = T_CHANNELS(info -> OutputFormat);\n-    cmsUInt32Number DoSwap    = T_DOSWAP(info ->OutputFormat);\n-    cmsUInt32Number SwapFirst = T_SWAPFIRST(info ->OutputFormat);\n-    cmsUInt32Number Reverse   = T_FLAVOR(info ->OutputFormat);\n+    cmsUInt32Number nChan = T_CHANNELS(info->OutputFormat);\n+    cmsUInt32Number DoSwap = T_DOSWAP(info->OutputFormat);\n+    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->OutputFormat);\n+    cmsUInt32Number Reverse = T_FLAVOR(info->OutputFormat);\n+    cmsUInt32Number Extra = T_EXTRA(info->OutputFormat);\n+    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n+    cmsUInt32Number Premul = T_PREMUL(info->OutputFormat);\n@@ -1475,0 +1850,4 @@\n+    cmsUInt32Number alpha_factor = 0;\n+\n+\n+    if (ExtraFirst) {\n@@ -1476,0 +1855,2 @@\n+        if (Premul && Extra)\n+            alpha_factor = _cmsToFixedDomain(FROM_8_TO_16(output[0]));\n@@ -1477,2 +1858,6 @@\n-    if (DoSwap ^ SwapFirst) {\n-        output += T_EXTRA(info -> OutputFormat) * Stride;\n+        output += Extra * Stride;\n+    }\n+    else\n+    {\n+        if (Premul && Extra)\n+            alpha_factor = _cmsToFixedDomain(FROM_8_TO_16(output[nChan * Stride]));\n@@ -1485,1 +1870,11 @@\n-        cmsUInt8Number v = FROM_16_TO_8(wOut[index]);\n+        cmsUInt16Number v = wOut[index];\n+\n+        if (Reverse)\n+            v = REVERSE_FLAVOR_16(v);\n+\n+        if (Premul)\n+        {\n+            v = (cmsUInt16Number)((cmsUInt32Number)((cmsUInt32Number)v * alpha_factor + 0x8000) >> 16);\n+        }\n+\n+        *(cmsUInt8Number*)output = FROM_16_TO_8(v);\n@@ -1487,1 +1882,0 @@\n-        *(cmsUInt8Number*)  output = (cmsUInt8Number) (Reverse ? REVERSE_FLAVOR_8(v) : v);\n@@ -1503,4 +1897,8 @@\n-    cmsUInt32Number nChan      = T_CHANNELS(info -> OutputFormat);\n-    cmsUInt32Number DoSwap     = T_DOSWAP(info ->OutputFormat);\n-    cmsUInt32Number Reverse    = T_FLAVOR(info ->OutputFormat);\n-    cmsUInt32Number SwapEndian = T_ENDIAN16(info -> OutputFormat);\n+    cmsUInt32Number nChan = T_CHANNELS(info->OutputFormat);\n+    cmsUInt32Number DoSwap = T_DOSWAP(info->OutputFormat);\n+    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->OutputFormat);\n+    cmsUInt32Number Reverse = T_FLAVOR(info->OutputFormat);\n+    cmsUInt32Number Extra = T_EXTRA(info->OutputFormat);\n+    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n+    cmsUInt32Number Premul = T_PREMUL(info->OutputFormat);\n+    cmsUInt32Number SwapEndian = T_ENDIAN16(info->OutputFormat);\n@@ -1510,0 +1908,1 @@\n+    cmsUInt32Number alpha_factor = 0;\n@@ -1511,2 +1910,11 @@\n-    if (DoSwap) {\n-        output += T_EXTRA(info -> OutputFormat) * Stride;\n+    if (ExtraFirst) {\n+\n+        if (Premul && Extra)\n+            alpha_factor = _cmsToFixedDomain(((cmsUInt16Number*) output)[0]);\n+\n+        output += Extra * Stride;\n+    }\n+    else\n+    {\n+        if (Premul && Extra)\n+            alpha_factor = _cmsToFixedDomain(((cmsUInt16Number*)output)[nChan * Stride]);\n@@ -1527,0 +1935,5 @@\n+        if (Premul)\n+        {\n+            v = (cmsUInt16Number)((cmsUInt32Number)((cmsUInt32Number)v * alpha_factor + 0x8000) >> 16);\n+        }\n+\n@@ -2570,0 +2983,102 @@\n+static\n+cmsUInt8Number* PackBytesFromFloat(_cmsTRANSFORM* info,\n+                                    cmsFloat32Number wOut[],\n+                                    cmsUInt8Number* output,\n+                                    cmsUInt32Number Stride)\n+{\n+    cmsUInt32Number nChan = T_CHANNELS(info->OutputFormat);\n+    cmsUInt32Number DoSwap = T_DOSWAP(info->OutputFormat);\n+    cmsUInt32Number Reverse = T_FLAVOR(info->OutputFormat);\n+    cmsUInt32Number Extra = T_EXTRA(info->OutputFormat);\n+    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->OutputFormat);\n+    cmsUInt32Number Planar = T_PLANAR(info->OutputFormat);\n+    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n+    cmsUInt8Number* swap1 = (cmsUInt8Number*)output;\n+    cmsFloat64Number v = 0;\n+    cmsUInt8Number vv = 0;\n+    cmsUInt32Number i, start = 0;\n+\n+    if (ExtraFirst)\n+        start = Extra;\n+\n+    for (i = 0; i < nChan; i++) {\n+\n+        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n+\n+        v = wOut[index] * 65535.0;\n+\n+        if (Reverse)\n+            v = 65535.0 - v;\n+\n+        vv =  FROM_16_TO_8(_cmsQuickSaturateWord(v));\n+\n+        if (Planar)\n+            ((cmsUInt8Number*)output)[(i + start) * Stride] = vv;\n+        else\n+            ((cmsUInt8Number*)output)[i + start] = vv;\n+    }\n+\n+\n+    if (Extra == 0 && SwapFirst) {\n+\n+        memmove(swap1 + 1, swap1, (nChan - 1) * sizeof(cmsUInt8Number));\n+        *swap1 = vv;\n+    }\n+\n+    if (T_PLANAR(info->OutputFormat))\n+        return output + sizeof(cmsUInt8Number);\n+    else\n+        return output + (nChan + Extra) * sizeof(cmsUInt8Number);\n+}\n+\n+static\n+cmsUInt8Number* PackWordsFromFloat(_cmsTRANSFORM* info,\n+                                    cmsFloat32Number wOut[],\n+                                    cmsUInt8Number* output,\n+                                    cmsUInt32Number Stride)\n+{\n+    cmsUInt32Number nChan = T_CHANNELS(info->OutputFormat);\n+    cmsUInt32Number DoSwap = T_DOSWAP(info->OutputFormat);\n+    cmsUInt32Number Reverse = T_FLAVOR(info->OutputFormat);\n+    cmsUInt32Number Extra = T_EXTRA(info->OutputFormat);\n+    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->OutputFormat);\n+    cmsUInt32Number Planar = T_PLANAR(info->OutputFormat);\n+    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n+    cmsUInt16Number* swap1 = (cmsUInt16Number*)output;\n+    cmsFloat64Number v = 0;\n+    cmsUInt16Number vv = 0;\n+    cmsUInt32Number i, start = 0;\n+\n+    if (ExtraFirst)\n+        start = Extra;\n+\n+    for (i = 0; i < nChan; i++) {\n+\n+        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n+\n+        v = wOut[index] * 65535.0;\n+\n+        if (Reverse)\n+            v = 65535.0 - v;\n+\n+        vv = _cmsQuickSaturateWord(v);\n+\n+        if (Planar)\n+            ((cmsUInt16Number*)output)[(i + start) * Stride] = vv;\n+        else\n+            ((cmsUInt16Number*)output)[i + start] = vv;\n+    }\n+\n+    if (Extra == 0 && SwapFirst) {\n+\n+        memmove(swap1 + 1, swap1, (nChan - 1) * sizeof(cmsUInt16Number));\n+        *swap1 = vv;\n+    }\n+\n+    if (T_PLANAR(info->OutputFormat))\n+        return output + sizeof(cmsUInt16Number);\n+    else\n+        return output + (nChan + Extra) * sizeof(cmsUInt16Number);\n+}\n+\n+\n@@ -2673,4 +3188,0 @@\n-\n-\n-\n-\n@@ -2737,0 +3248,71 @@\n+static\n+cmsUInt8Number* PackEncodedBytesLabV2FromFloat(_cmsTRANSFORM* Info,\n+                                           cmsFloat32Number wOut[],\n+                                           cmsUInt8Number* output,\n+                                           cmsUInt32Number Stride)\n+{\n+    cmsCIELab Lab;\n+    cmsUInt16Number wlab[3];\n+\n+    Lab.L = (cmsFloat64Number)(wOut[0] * 100.0);\n+    Lab.a = (cmsFloat64Number)(wOut[1] * 255.0 - 128.0);\n+    Lab.b = (cmsFloat64Number)(wOut[2] * 255.0 - 128.0);\n+\n+    cmsFloat2LabEncoded(wlab, &Lab);\n+\n+    if (T_PLANAR(Info -> OutputFormat)) {\n+\n+        Stride \/= PixelSize(Info->OutputFormat);\n+\n+        output[0]        = wlab[0] >> 8;\n+        output[Stride]   = wlab[1] >> 8;\n+        output[Stride*2] = wlab[2] >> 8;\n+\n+        return output + 1;\n+    }\n+    else {\n+\n+        output[0] = wlab[0] >> 8;\n+        output[1] = wlab[1] >> 8;\n+        output[2] = wlab[2] >> 8;\n+\n+        return output + (3 + T_EXTRA(Info ->OutputFormat));\n+    }\n+}\n+\n+static\n+cmsUInt8Number* PackEncodedWordsLabV2FromFloat(_cmsTRANSFORM* Info,\n+                                           cmsFloat32Number wOut[],\n+                                           cmsUInt8Number* output,\n+                                           cmsUInt32Number Stride)\n+{\n+    cmsCIELab Lab;\n+    cmsUInt16Number wlab[3];\n+\n+    Lab.L = (cmsFloat64Number)(wOut[0] * 100.0);\n+    Lab.a = (cmsFloat64Number)(wOut[1] * 255.0 - 128.0);\n+    Lab.b = (cmsFloat64Number)(wOut[2] * 255.0 - 128.0);\n+\n+    cmsFloat2LabEncodedV2(wlab, &Lab);\n+\n+    if (T_PLANAR(Info -> OutputFormat)) {\n+\n+        Stride \/= PixelSize(Info->OutputFormat);\n+\n+        ((cmsUInt16Number*) output)[0]        = wlab[0];\n+        ((cmsUInt16Number*) output)[Stride]   = wlab[1];\n+        ((cmsUInt16Number*) output)[Stride*2] = wlab[2];\n+\n+        return output + sizeof(cmsUInt16Number);\n+    }\n+    else {\n+\n+         ((cmsUInt16Number*) output)[0] = wlab[0];\n+         ((cmsUInt16Number*) output)[1] = wlab[1];\n+         ((cmsUInt16Number*) output)[2] = wlab[2];\n+\n+        return output + (3 + T_EXTRA(Info ->OutputFormat)) * sizeof(cmsUInt16Number);\n+    }\n+}\n+\n+\n@@ -3061,1 +3643,1 @@\n-    { BYTES_SH(1)|PLANAR_SH(1), ANYFLAVOR|ANYSWAPFIRST|\n+    { BYTES_SH(1)|PLANAR_SH(1), ANYFLAVOR|ANYSWAPFIRST|ANYPREMUL|\n@@ -3064,1 +3646,1 @@\n-    { BYTES_SH(1),    ANYFLAVOR|ANYSWAPFIRST|ANYSWAP|\n+    { BYTES_SH(1),    ANYFLAVOR|ANYSWAPFIRST|ANYSWAP|ANYPREMUL|\n@@ -3086,0 +3668,4 @@\n+\n+    { BYTES_SH(2)|PLANAR_SH(1),  ANYFLAVOR|ANYSWAP|ANYENDIAN|ANYEXTRA|ANYCHANNELS|ANYSPACE|PREMUL_SH(1),  UnrollPlanarWordsPremul},\n+    { BYTES_SH(2),  ANYFLAVOR|ANYSWAPFIRST|ANYSWAP|ANYENDIAN|ANYEXTRA|ANYCHANNELS|ANYSPACE|PREMUL_SH(1),  UnrollAnyWordsPremul}\n+\n@@ -3101,1 +3687,1 @@\n-                                                      ANYCHANNELS|ANYSPACE,  UnrollFloatsToFloat},\n+                                            ANYPREMUL|ANYCHANNELS|ANYSPACE,  UnrollFloatsToFloat},\n@@ -3104,1 +3690,11 @@\n-                                                        ANYCHANNELS|ANYSPACE,  UnrollDoublesToFloat},\n+                                              ANYCHANNELS|ANYSPACE|ANYPREMUL, UnrollDoublesToFloat},\n+\n+    {     TYPE_LabV2_8,                                                   0,  UnrollLabV2_8ToFloat },\n+    {     TYPE_ALabV2_8,                                                  0,  UnrollALabV2_8ToFloat },\n+    {     TYPE_LabV2_16,                                                  0,  UnrollLabV2_16ToFloat },\n+\n+    {     BYTES_SH(1),              ANYPLANAR|ANYSWAPFIRST|ANYSWAP|ANYEXTRA|\n+                                                        ANYCHANNELS|ANYSPACE, Unroll8ToFloat},\n+\n+    {     BYTES_SH(2),              ANYPLANAR|ANYSWAPFIRST|ANYSWAP|ANYEXTRA|\n+                                                        ANYCHANNELS|ANYSPACE, Unroll16ToFloat},\n@@ -3107,1 +3703,1 @@\n-                                                        ANYCHANNELS|ANYSPACE,  UnrollHalfToFloat},\n+                                                        ANYCHANNELS|ANYSPACE, UnrollHalfToFloat},\n@@ -3201,2 +3797,0 @@\n-    { CHANNELS_SH(6)|BYTES_SH(1),                                  ANYSPACE,  Pack6Bytes},\n-    { CHANNELS_SH(6)|BYTES_SH(1)|DOSWAP_SH(1),                     ANYSPACE,  Pack6BytesSwap},\n@@ -3208,0 +3802,8 @@\n+    { CHANNELS_SH(6)|BYTES_SH(1),                                  ANYSPACE,  Pack6Bytes},\n+    { CHANNELS_SH(6)|BYTES_SH(1)|DOSWAP_SH(1),                     ANYSPACE,  Pack6BytesSwap},\n+\n+    { BYTES_SH(1),    ANYFLAVOR|ANYSWAPFIRST|ANYSWAP|ANYEXTRA|ANYCHANNELS|\n+                                                          ANYSPACE|ANYPREMUL, PackChunkyBytes},\n+\n+    { BYTES_SH(1)|PLANAR_SH(1),    ANYFLAVOR|ANYSWAPFIRST|ANYSWAP|ANYEXTRA|\n+                                              ANYCHANNELS|ANYSPACE|ANYPREMUL, PackPlanarBytes},\n@@ -3209,2 +3811,0 @@\n-    { BYTES_SH(1),                 ANYFLAVOR|ANYSWAPFIRST|ANYSWAP|ANYEXTRA|ANYCHANNELS|ANYSPACE, PackAnyBytes},\n-    { BYTES_SH(1)|PLANAR_SH(1),    ANYFLAVOR|ANYSWAPFIRST|ANYSWAP|ANYEXTRA|ANYCHANNELS|ANYSPACE, PackPlanarBytes},\n@@ -3235,2 +3835,4 @@\n-    { BYTES_SH(2)|PLANAR_SH(1),     ANYFLAVOR|ANYENDIAN|ANYSWAP|ANYEXTRA|ANYCHANNELS|ANYSPACE, PackPlanarWords},\n-    { BYTES_SH(2),                  ANYFLAVOR|ANYSWAPFIRST|ANYSWAP|ANYENDIAN|ANYEXTRA|ANYCHANNELS|ANYSPACE, PackAnyWords}\n+    { BYTES_SH(2),                  ANYFLAVOR|ANYSWAPFIRST|ANYSWAP|ANYENDIAN|\n+                                     ANYEXTRA|ANYCHANNELS|ANYSPACE|ANYPREMUL, PackChunkyWords},\n+    { BYTES_SH(2)|PLANAR_SH(1),     ANYFLAVOR|ANYENDIAN|ANYSWAP|ANYEXTRA|\n+                                     ANYCHANNELS|ANYSPACE|ANYPREMUL,          PackPlanarWords}\n@@ -3250,0 +3852,3 @@\n+    {     TYPE_LabV2_8,                                                ANYPLANAR|ANYEXTRA,   PackEncodedBytesLabV2FromFloat},\n+    {     TYPE_LabV2_16,                                               ANYPLANAR|ANYEXTRA,   PackEncodedWordsLabV2FromFloat},\n+\n@@ -3254,0 +3859,7 @@\n+\n+    {     BYTES_SH(2), ANYPLANAR|\n+                             ANYFLAVOR|ANYSWAPFIRST|ANYSWAP|ANYEXTRA|ANYCHANNELS|ANYSPACE,   PackWordsFromFloat },\n+\n+    {     BYTES_SH(1), ANYPLANAR|\n+                             ANYFLAVOR|ANYSWAPFIRST|ANYSWAP|ANYEXTRA|ANYCHANNELS|ANYSPACE,   PackBytesFromFloat },\n+\n@@ -3408,0 +4020,5 @@\n+    if (T_CHANNELS(Type) == 0) {\n+        static const cmsFormatter nullFormatter = { 0 };\n+        return nullFormatter;\n+    }\n+\n@@ -3442,1 +4059,1 @@\n-    cmsUInt32Number        nOutputChans    = cmsChannelsOf(ColorSpace);\n+    cmsInt32Number         nOutputChans    = cmsChannelsOfColorSpace(ColorSpace);\n@@ -3445,0 +4062,3 @@\n+    \/\/ Unsupported color space?\n+    if (nOutputChans < 0) return 0;\n+\n@@ -3456,1 +4076,1 @@\n-    cmsUInt32Number nOutputChans = cmsChannelsOf(ColorSpace);\n+    cmsInt32Number  nOutputChans = cmsChannelsOfColorSpace(ColorSpace);\n@@ -3459,0 +4079,3 @@\n+    \/\/ Unsupported color space?\n+    if (nOutputChans < 0) return 0;\n+\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmspack.c","additions":707,"deletions":84,"binary":false,"changes":791,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -906,1 +906,1 @@\n-cmsUInt32Number CMSEXPORT cmsChannelsOf(cmsColorSpaceSignature ColorSpace)\n+cmsInt32Number CMSEXPORT cmsChannelsOfColorSpace(cmsColorSpaceSignature ColorSpace)\n@@ -967,1 +967,1 @@\n-    default: return 3;\n+    default: return -1;\n@@ -970,0 +970,10 @@\n+\n+\/**\n+* DEPRECATED: Provided for compatibility only\n+*\/\n+cmsUInt32Number CMSEXPORT cmsChannelsOf(cmsColorSpaceSignature ColorSpace)\n+{\n+    int n = cmsChannelsOfColorSpace(ColorSpace);\n+    if (n < 0) return 3;\n+    return (cmsUInt32Number)n;\n+}\n\\ No newline at end of file\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmspcs.c","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -200,1 +200,4 @@\n-    cmsUInt32Number tmp;\n+    union typeConverter {\n+        cmsUInt32Number integer;\n+        cmsFloat32Number floating_point;\n+    } tmp;\n@@ -204,1 +207,1 @@\n-    if (io->Read(io, &tmp, sizeof(cmsUInt32Number), 1) != 1)\n+    if (io->Read(io, &tmp.integer, sizeof(cmsUInt32Number), 1) != 1)\n@@ -209,2 +212,2 @@\n-        tmp = _cmsAdjustEndianess32(tmp);\n-        *n = *(cmsFloat32Number*)(void*)&tmp;\n+        tmp.integer = _cmsAdjustEndianess32(tmp.integer);\n+        *n = tmp.floating_point;\n@@ -337,7 +340,8 @@\n-    cmsUInt32Number tmp;\n-\n-    _cmsAssert(io != NULL);\n-\n-    tmp = *(cmsUInt32Number*) (void*) &n;\n-    tmp = _cmsAdjustEndianess32(tmp);\n-    if (io -> Write(io, sizeof(cmsUInt32Number), &tmp) != 1)\n+    union typeConverter {\n+        cmsUInt32Number integer;\n+        cmsFloat32Number floating_point;\n+    } tmp;\n+\n+    tmp.floating_point = n;\n+    tmp.integer = _cmsAdjustEndianess32(tmp.integer);\n+    if (io -> Write(io, sizeof(cmsUInt32Number), &tmp.integer) != 1)\n@@ -392,6 +396,1 @@\n-       cmsUInt8Number  msb, lsb;\n-\n-       lsb = (cmsUInt8Number) (fixed8 & 0xff);\n-       msb = (cmsUInt8Number) (((cmsUInt16Number) fixed8 >> 8) & 0xff);\n-\n-       return (cmsFloat64Number) ((cmsFloat64Number) msb + ((cmsFloat64Number) lsb \/ 256.0));\n+    return fixed8 \/ 256.0;\n@@ -409,13 +408,1 @@\n-    cmsFloat64Number floater, sign, mid;\n-    int Whole, FracPart;\n-\n-    sign  = (fix32 < 0 ? -1 : 1);\n-    fix32 = abs(fix32);\n-\n-    Whole     = (cmsUInt16Number)(fix32 >> 16) & 0xffff;\n-    FracPart  = (cmsUInt16Number)(fix32 & 0xffff);\n-\n-    mid     = (cmsFloat64Number) FracPart \/ 65536.0;\n-    floater = (cmsFloat64Number) Whole + mid;\n-\n-    return sign * floater;\n+    return fix32 \/ 65536.0;\n@@ -653,0 +640,4 @@\n+                case cmsPluginParalellizationSig:\n+                    if (!_cmsRegisterParallelizationPlugin(id, Plugin)) return FALSE;\n+                    break;\n+\n@@ -675,2 +666,2 @@\n-    NULL,                              \/\/ Not in the linked list\n-    NULL,                              \/\/ No suballocator\n+    NULL,                                \/\/ Not in the linked list\n+    NULL,                                \/\/ No suballocator\n@@ -678,15 +669,16 @@\n-        NULL,                          \/\/  UserPtr,\n-        &_cmsLogErrorChunk,            \/\/  Logger,\n-        &_cmsAlarmCodesChunk,          \/\/  AlarmCodes,\n-        &_cmsAdaptationStateChunk,     \/\/  AdaptationState,\n-        &_cmsMemPluginChunk,           \/\/  MemPlugin,\n-        &_cmsInterpPluginChunk,        \/\/  InterpPlugin,\n-        &_cmsCurvesPluginChunk,        \/\/  CurvesPlugin,\n-        &_cmsFormattersPluginChunk,    \/\/  FormattersPlugin,\n-        &_cmsTagTypePluginChunk,       \/\/  TagTypePlugin,\n-        &_cmsTagPluginChunk,           \/\/  TagPlugin,\n-        &_cmsIntentsPluginChunk,       \/\/  IntentPlugin,\n-        &_cmsMPETypePluginChunk,       \/\/  MPEPlugin,\n-        &_cmsOptimizationPluginChunk,  \/\/  OptimizationPlugin,\n-        &_cmsTransformPluginChunk,     \/\/  TransformPlugin,\n-        &_cmsMutexPluginChunk          \/\/  MutexPlugin\n+        NULL,                            \/\/  UserPtr,\n+        &_cmsLogErrorChunk,              \/\/  Logger,\n+        &_cmsAlarmCodesChunk,            \/\/  AlarmCodes,\n+        &_cmsAdaptationStateChunk,       \/\/  AdaptationState,\n+        &_cmsMemPluginChunk,             \/\/  MemPlugin,\n+        &_cmsInterpPluginChunk,          \/\/  InterpPlugin,\n+        &_cmsCurvesPluginChunk,          \/\/  CurvesPlugin,\n+        &_cmsFormattersPluginChunk,      \/\/  FormattersPlugin,\n+        &_cmsTagTypePluginChunk,         \/\/  TagTypePlugin,\n+        &_cmsTagPluginChunk,             \/\/  TagPlugin,\n+        &_cmsIntentsPluginChunk,         \/\/  IntentPlugin,\n+        &_cmsMPETypePluginChunk,         \/\/  MPEPlugin,\n+        &_cmsOptimizationPluginChunk,    \/\/  OptimizationPlugin,\n+        &_cmsTransformPluginChunk,       \/\/  TransformPlugin,\n+        &_cmsMutexPluginChunk,           \/\/  MutexPlugin,\n+        &_cmsParallelizationPluginChunk  \/\/  ParallelizationPlugin\n@@ -703,0 +695,47 @@\n+\n+\/\/ Make sure context is initialized (needed on windows)\n+static\n+cmsBool InitContextMutex(void)\n+{\n+    \/\/ See the comments regarding locking in lcms2_internal.h\n+    \/\/ for an explanation of why we need the following code.\n+#ifndef CMS_NO_PTHREADS\n+#ifdef CMS_IS_WINDOWS_\n+#ifndef CMS_RELY_ON_WINDOWS_STATIC_MUTEX_INIT\n+\n+    static cmsBool already_initialized = FALSE;\n+\n+    if (!already_initialized)\n+    {\n+        static HANDLE _cmsWindowsInitMutex = NULL;\n+        static volatile HANDLE* mutex = &_cmsWindowsInitMutex;\n+\n+        if (*mutex == NULL)\n+        {\n+            HANDLE p = CreateMutex(NULL, FALSE, NULL);\n+            if (p && InterlockedCompareExchangePointer((void**)mutex, (void*)p, NULL) != NULL)\n+                CloseHandle(p);\n+        }\n+        if (*mutex == NULL || WaitForSingleObject(*mutex, INFINITE) == WAIT_FAILED)\n+        {\n+            cmsSignalError(0, cmsERROR_INTERNAL, \"Mutex lock failed\");\n+            return FALSE;\n+        }\n+        if (((void**)&_cmsContextPoolHeadMutex)[0] == NULL)\n+            InitializeCriticalSection(&_cmsContextPoolHeadMutex);\n+        if (*mutex == NULL || !ReleaseMutex(*mutex))\n+        {\n+            cmsSignalError(0, cmsERROR_INTERNAL, \"Mutex unlock failed\");\n+            return FALSE;\n+        }\n+        already_initialized = TRUE;\n+    }\n+#endif\n+#endif\n+#endif\n+\n+    return TRUE;\n+}\n+\n+\n+\n@@ -709,1 +748,0 @@\n-\n@@ -714,0 +752,2 @@\n+    InitContextMutex();\n+\n@@ -782,0 +822,2 @@\n+    _cmsRegisterParallelizationPlugin(ContextID, NULL);\n+\n@@ -816,25 +858,1 @@\n-    \/\/ See the comments regarding locking in lcms2_internal.h\n-    \/\/ for an explanation of why we need the following code.\n-#ifndef CMS_NO_PTHREADS\n-#ifdef CMS_IS_WINDOWS_\n-#ifndef CMS_RELY_ON_WINDOWS_STATIC_MUTEX_INIT\n-    {\n-        static HANDLE _cmsWindowsInitMutex = NULL;\n-        static volatile HANDLE* mutex = &_cmsWindowsInitMutex;\n-\n-        if (*mutex == NULL)\n-        {\n-            HANDLE p = CreateMutex(NULL, FALSE, NULL);\n-            if (p && InterlockedCompareExchangePointer((void **)mutex, (void*)p, NULL) != NULL)\n-                CloseHandle(p);\n-        }\n-        if (*mutex == NULL || WaitForSingleObject(*mutex, INFINITE) == WAIT_FAILED)\n-            return NULL;\n-        if (((void **)&_cmsContextPoolHeadMutex)[0] == NULL)\n-            InitializeCriticalSection(&_cmsContextPoolHeadMutex);\n-        if (*mutex == NULL || !ReleaseMutex(*mutex))\n-            return NULL;\n-    }\n-#endif\n-#endif\n-#endif\n+    if (!InitContextMutex()) return NULL;\n@@ -889,0 +907,1 @@\n+    _cmsAllocParallelizationPluginChunk(ctx, NULL);\n@@ -916,0 +935,2 @@\n+    if (!InitContextMutex()) return NULL;\n+\n@@ -950,0 +971,1 @@\n+    _cmsAllocParallelizationPluginChunk(ctx, src);\n@@ -969,1 +991,8 @@\n-    if (ContextID != NULL) {\n+    if (ContextID == NULL) {\n+\n+        cmsUnregisterPlugins();\n+        if (globalContext.MemPool != NULL)\n+            _cmsSubAllocDestroy(globalContext.MemPool);\n+        globalContext.MemPool = NULL;\n+    }\n+    else {\n@@ -975,0 +1004,3 @@\n+\n+        InitContextMutex();\n+\n@@ -1021,0 +1053,29 @@\n+\/\/ Use context mutex to provide thread-safe time\n+cmsBool _cmsGetTime(struct tm* ptr_time)\n+{\n+    struct tm* t;\n+#if defined(HAVE_GMTIME_R) || defined(HAVE_GMTIME_S)\n+    struct tm tm;\n+#endif\n+\n+    time_t now = time(NULL);\n+\n+#ifdef HAVE_GMTIME_R\n+    t = gmtime_r(&now, &tm);\n+#elif defined(HAVE_GMTIME_S)\n+    t = gmtime_s(&tm, &now) == 0 ? &tm : NULL;\n+#else\n+    if (!InitContextMutex()) return FALSE;\n+\n+    _cmsEnterCriticalSectionPrimitive(&_cmsContextPoolHeadMutex);\n+    t = gmtime(&now);\n+    _cmsLeaveCriticalSectionPrimitive(&_cmsContextPoolHeadMutex);\n+#endif\n+\n+    if (t == NULL)\n+        return FALSE;\n+    else {\n+        *ptr_time = *t;\n+        return TRUE;\n+    }\n+}\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsplugin.c","additions":136,"deletions":75,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -463,6 +463,0 @@\n-static\n-void EmitSafeGuardBegin(cmsIOHANDLER* m, const char* name)\n-{\n-    _cmsIOPrintf(m, \"%%LCMS2: Save previous definition of %s on the operand stack\\n\", name);\n-    _cmsIOPrintf(m, \"currentdict \/%s known { \/%s load } { null } ifelse\\n\", name, name);\n-}\n@@ -470,10 +464,0 @@\n-static\n-void EmitSafeGuardEnd(cmsIOHANDLER* m, const char* name, int depth)\n-{\n-    _cmsIOPrintf(m, \"%%LCMS2: Restore previous definition of %s\\n\", name);\n-    if (depth > 1) {\n-        \/\/ cycle topmost items on the stack to bring the previous definition to the front\n-        _cmsIOPrintf(m, \"%d -1 roll \", depth);\n-    }\n-    _cmsIOPrintf(m, \"dup null eq { pop currentdict \/%s undef } { \/%s exch def } ifelse\\n\", name, name);\n-}\n@@ -484,1 +468,1 @@\n-void Emit1Gamma(cmsIOHANDLER* m, cmsToneCurve* Table, const char* name)\n+void Emit1Gamma(cmsIOHANDLER* m, cmsToneCurve* Table)\n@@ -489,1 +473,6 @@\n-    if (Table == NULL) return; \/\/ Error\n+    \/**\n+    * On error, empty tables or lienar assume gamma 1.0\n+    *\/\n+    if (Table == NULL ||\n+        Table->nEntries <= 0 ||\n+        cmsIsToneCurveLinear(Table)) {\n@@ -491,1 +480,3 @@\n-    if (Table ->nEntries <= 0) return;  \/\/ Empty table\n+        _cmsIOPrintf(m, \"{ 1 } bind \");\n+        return;\n+    }\n@@ -493,2 +484,0 @@\n-    \/\/ Suppress whole if identity\n-    if (cmsIsToneCurveLinear(Table)) return;\n@@ -499,1 +488,1 @@\n-            _cmsIOPrintf(m, \"\/%s { %g exp } bind def\\n\", name, gamma);\n+            _cmsIOPrintf(m, \"{ %g exp } bind \", gamma);\n@@ -503,2 +492,11 @@\n-    EmitSafeGuardBegin(m, \"lcms2gammatable\");\n-    _cmsIOPrintf(m, \"\/lcms2gammatable [\");\n+    _cmsIOPrintf(m, \"{ \");\n+\n+    \/\/ Bounds check\n+    EmitRangeCheck(m);\n+\n+    \/\/ Emit intepolation code\n+\n+    \/\/ PostScript code                      Stack\n+    \/\/ ===============                      ========================\n+                                            \/\/ v\n+    _cmsIOPrintf(m, \" [\");\n@@ -507,1 +505,1 @@\n-        if (i % 10 == 0)\n+    if (i % 10 == 0)\n@@ -512,1 +510,1 @@\n-    _cmsIOPrintf(m, \"] def\\n\");\n+    _cmsIOPrintf(m, \"] \");                        \/\/ v tab\n@@ -514,12 +512,0 @@\n-\n-    \/\/ Emit interpolation code\n-\n-    \/\/ PostScript code                            Stack\n-    \/\/ ===============                            ========================\n-                                                  \/\/ v\n-    _cmsIOPrintf(m, \"\/%s {\\n  \", name);\n-\n-    \/\/ Bounds check\n-    EmitRangeCheck(m);\n-\n-    _cmsIOPrintf(m, \"\\n  \/\/lcms2gammatable \");    \/\/ v tab\n@@ -552,3 +538,1 @@\n-    _cmsIOPrintf(m, \"} bind def\\n\");\n-\n-    EmitSafeGuardEnd(m, \"lcms2gammatable\", 1);\n+    _cmsIOPrintf(m, \" } bind \");\n@@ -571,1 +555,1 @@\n-void EmitNGamma(cmsIOHANDLER* m, cmsUInt32Number n, cmsToneCurve* g[], const char* nameprefix)\n+void EmitNGamma(cmsIOHANDLER* m, cmsUInt32Number n, cmsToneCurve* g[])\n@@ -574,1 +558,1 @@\n-    static char buffer[2048];\n+\n@@ -582,1 +566,1 @@\n-            _cmsIOPrintf(m, \"\/%s%d \/%s%d load def\\n\", nameprefix, i, nameprefix, i-1);\n+            _cmsIOPrintf(m, \"dup \");\n@@ -585,3 +569,1 @@\n-            snprintf(buffer, sizeof(buffer), \"%s%d\", nameprefix, (int) i);\n-            buffer[sizeof(buffer)-1] = '\\0';\n-            Emit1Gamma(m, g[i], buffer);\n+            Emit1Gamma(m, g[i]);\n@@ -711,1 +693,1 @@\n-    _cmsIOPrintf(m, \"[\");\n+    if (sc.Pipeline != NULL && sc.Pipeline->Params != NULL) {\n@@ -713,2 +695,1 @@\n-    for (i=0; i < sc.Pipeline->Params->nInputs; i++)\n-        _cmsIOPrintf(m, \" %d \", sc.Pipeline->Params->nSamples[i]);\n+        _cmsIOPrintf(m, \"[\");\n@@ -716,1 +697,2 @@\n-    _cmsIOPrintf(m, \" [\\n\");\n+        for (i = 0; i < sc.Pipeline->Params->nInputs; i++)\n+            _cmsIOPrintf(m, \" %d \", sc.Pipeline->Params->nSamples[i]);\n@@ -718,1 +700,1 @@\n-    cmsStageSampleCLut16bit(mpe, OutputValueSampler, (void*) &sc, SAMPLER_INSPECT);\n+        _cmsIOPrintf(m, \" [\\n\");\n@@ -720,3 +702,6 @@\n-    _cmsIOPrintf(m, PostMin);\n-    _cmsIOPrintf(m, PostMaj);\n-    _cmsIOPrintf(m, \"] \");\n+        cmsStageSampleCLut16bit(mpe, OutputValueSampler, (void*)&sc, SAMPLER_INSPECT);\n+\n+        _cmsIOPrintf(m, PostMin);\n+        _cmsIOPrintf(m, PostMaj);\n+        _cmsIOPrintf(m, \"] \");\n+    }\n@@ -736,2 +721,3 @@\n-    EmitSafeGuardBegin(m, \"lcms2gammaproc\");\n-    Emit1Gamma(m, Curve, \"lcms2gammaproc\");\n+    _cmsIOPrintf(m, \"\/DecodeA \");\n+\n+    Emit1Gamma(m, Curve);\n@@ -739,2 +725,1 @@\n-    _cmsIOPrintf(m, \"\/DecodeA \/lcms2gammaproc load\\n\");\n-    EmitSafeGuardEnd(m, \"lcms2gammaproc\", 3);\n+    _cmsIOPrintf(m, \" \\n\");\n@@ -764,0 +749,3 @@\n+    _cmsIOPrintf(m, \"\/DecodeABC [ \");\n+\n+    EmitNGamma(m, 3, CurveSet);\n@@ -765,8 +753,0 @@\n-    EmitSafeGuardBegin(m, \"lcms2gammaproc0\");\n-    EmitSafeGuardBegin(m, \"lcms2gammaproc1\");\n-    EmitSafeGuardBegin(m, \"lcms2gammaproc2\");\n-    EmitNGamma(m, 3, CurveSet, \"lcms2gammaproc\");\n-    _cmsIOPrintf(m, \"\/DecodeABC [\\n\");\n-    _cmsIOPrintf(m, \"   \/lcms2gammaproc0 load\\n\");\n-    _cmsIOPrintf(m, \"   \/lcms2gammaproc1 load\\n\");\n-    _cmsIOPrintf(m, \"   \/lcms2gammaproc2 load\\n\");\n@@ -774,3 +754,0 @@\n-    EmitSafeGuardEnd(m, \"lcms2gammaproc2\", 3);\n-    EmitSafeGuardEnd(m, \"lcms2gammaproc1\", 3);\n-    EmitSafeGuardEnd(m, \"lcms2gammaproc0\", 3);\n@@ -808,1 +785,1 @@\n-    const char* PreMin, * PostMin;\n+    const char* PreMin, *PostMin;\n@@ -810,2 +787,0 @@\n-    int i, numchans;\n-    static char buffer[2048];\n@@ -840,13 +815,2 @@\n-        numchans = (int) cmsStageOutputChannels(mpe);\n-        for (i = 0; i < numchans; ++i) {\n-            snprintf(buffer, sizeof(buffer), \"lcms2gammaproc%d\", i);\n-            buffer[sizeof(buffer) - 1] = '\\0';\n-            EmitSafeGuardBegin(m, buffer);\n-        }\n-        EmitNGamma(m, cmsStageOutputChannels(mpe), _cmsStageGetPtrToCurveSet(mpe), \"lcms2gammaproc\");\n-        _cmsIOPrintf(m, \"\/DecodeDEF [\\n\");\n-        for (i = 0; i < numchans; ++i) {\n-            snprintf(buffer, sizeof(buffer), \"  \/lcms2gammaproc%d load\\n\", i);\n-            buffer[sizeof(buffer) - 1] = '\\0';\n-            _cmsIOPrintf(m, buffer);\n-        }\n+        _cmsIOPrintf(m, \"\/DecodeDEF [ \");\n+        EmitNGamma(m, cmsStageOutputChannels(mpe), _cmsStageGetPtrToCurveSet(mpe));\n@@ -854,5 +818,0 @@\n-        for (i = numchans - 1; i >= 0; --i) {\n-            snprintf(buffer, sizeof(buffer), \"lcms2gammaproc%d\", i);\n-            buffer[sizeof(buffer) - 1] = '\\0';\n-            EmitSafeGuardEnd(m, buffer, 3);\n-        }\n@@ -860,1 +819,1 @@\n-        mpe = mpe->Next;\n+        mpe = mpe ->Next;\n@@ -865,3 +824,3 @@\n-        _cmsIOPrintf(m, \"\/Table \");\n-        WriteCLUT(m, mpe, PreMaj, PostMaj, PreMin, PostMin, FALSE, (cmsColorSpaceSignature)0);\n-        _cmsIOPrintf(m, \"]\\n\");\n+            _cmsIOPrintf(m, \"\/Table \");\n+            WriteCLUT(m, mpe, PreMaj, PostMaj, PreMin, PostMin, FALSE, (cmsColorSpaceSignature) 0);\n+            _cmsIOPrintf(m, \"]\\n\");\n@@ -1027,3 +986,3 @@\n-            rc = EmitCIEBasedABC(m, (cmsFloat64Number *)&Mat,\n-                _cmsStageGetPtrToCurveSet(Shaper),\n-                &BlackPointAdaptedToD50);\n+            rc = EmitCIEBasedABC(m,  (cmsFloat64Number *) &Mat,\n+                                _cmsStageGetPtrToCurveSet(Shaper),\n+                                 &BlackPointAdaptedToD50);\n@@ -1056,0 +1015,2 @@\n+    cmsCloseProfile(hLab);\n+\n@@ -1059,1 +1020,4 @@\n-    if (NamedColorList == NULL) return 0;\n+    if (NamedColorList == NULL) {\n+        cmsDeleteTransform(xform);\n+        return 0;\n+    }\n@@ -1068,1 +1032,0 @@\n-\n@@ -1083,2 +1046,0 @@\n-\n-\n@@ -1088,1 +1049,0 @@\n-    cmsCloseProfile(hLab);\n@@ -1342,1 +1302,1 @@\n-\n+    cmsStage* first;\n@@ -1369,1 +1329,0 @@\n-\n@@ -1377,2 +1336,4 @@\n-    if (DeviceLink == NULL) return 0;\n-\n+    if (DeviceLink == NULL) {\n+        cmsDeleteTransform(xform);\n+        return 0;\n+    }\n@@ -1380,1 +1341,1 @@\n-    \/\/ We need a CLUT\n+     \/\/ We need a CLUT\n@@ -1407,2 +1368,4 @@\n-\n-    WriteCLUT(m, cmsPipelineGetPtrToFirstStage(DeviceLink), \"<\", \">\\n\", \"\", \"\", lFixWhite, ColorSpace);\n+    first = cmsPipelineGetPtrToFirstStage(DeviceLink);\n+    if (first != NULL) {\n+        WriteCLUT(m, first, \"<\", \">\\n\", \"\", \"\", lFixWhite, ColorSpace);\n+    }\n@@ -1417,1 +1380,0 @@\n-\n@@ -1480,1 +1442,4 @@\n-    if (NamedColorList == NULL) return 0;\n+    if (NamedColorList == NULL) {\n+        cmsDeleteTransform(xform);\n+        return 0;\n+    }\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsps2.c","additions":78,"deletions":113,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -155,1 +155,1 @@\n-    \/\/ Force it to be neutral, clip to max. L* of 50\n+    \/\/ Force it to be neutral, check for inconsistencies\n@@ -157,1 +157,1 @@\n-    if (Lab.L > 50) Lab.L = 50;\n+    if (Lab.L > 50 || Lab.L < 0) Lab.L = 0;\n@@ -354,0 +354,1 @@\n+        if (fabs(b) < 1.0E-10) return 0;\n@@ -364,1 +365,5 @@\n-             double rt = (-b + sqrt(d)) \/ (2.0 * a);\n+             double rt;\n+\n+             if (fabs(a) < 1.0E-10) return 0;\n+\n+             rt = (-b + sqrt(d)) \/ (2.0 * a);\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmssamp.c","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmssm.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -125,1 +125,1 @@\n-\/\/ Return handler for a given type or NULL if not found. Shared between normal types and MPE. It first tries the additons\n+\/\/ Return handler for a given type or NULL if not found. Shared between normal types and MPE. It first tries the additions\n@@ -166,0 +166,41 @@\n+\/\/ Try to promote correctly to wchar_t when 32 bits\n+cmsINLINE cmsBool is_surrogate(cmsUInt32Number uc) { return (uc - 0xd800u) < 2048u; }\n+cmsINLINE cmsBool is_high_surrogate(cmsUInt32Number uc) { return (uc & 0xfffffc00) == 0xd800; }\n+cmsINLINE cmsBool is_low_surrogate(cmsUInt32Number uc)  { return (uc & 0xfffffc00) == 0xdc00; }\n+\n+cmsINLINE cmsUInt32Number surrogate_to_utf32(cmsUInt32Number high, cmsUInt32Number low)\n+{\n+    return (high << 10) + low - 0x35fdc00;\n+}\n+\n+cmsINLINE cmsBool convert_utf16_to_utf32(cmsIOHANDLER* io, cmsInt32Number n, wchar_t* output)\n+{\n+    cmsUInt16Number uc;\n+\n+    while (n > 0)\n+    {\n+        if (!_cmsReadUInt16Number(io, &uc)) return FALSE;\n+        n--;\n+\n+        if (!is_surrogate(uc))\n+        {\n+            *output++ = (wchar_t)uc;\n+        }\n+        else {\n+\n+            cmsUInt16Number low;\n+\n+            if (!_cmsReadUInt16Number(io, &low)) return FALSE;\n+            n--;\n+\n+            if (is_high_surrogate(uc) && is_low_surrogate(low))\n+                *output++ = (wchar_t)surrogate_to_utf32(uc, low);\n+            else\n+                return FALSE;   \/\/ Corrupted string, just ignore\n+        }\n+    }\n+\n+    return TRUE;\n+}\n+\n+\n@@ -172,0 +213,1 @@\n+    cmsBool is32 = sizeof(wchar_t) > sizeof(cmsUInt16Number);\n@@ -175,0 +217,5 @@\n+    if (is32 && Array != NULL)\n+    {\n+        return convert_utf16_to_utf32(io, n, Array);\n+    }\n+\n@@ -910,0 +957,1 @@\n+    wchar_t* UnicodeString = NULL;\n@@ -929,1 +977,1 @@\n-    mlu = cmsMLUalloc(self ->ContextID, 1);\n+    mlu = cmsMLUalloc(self ->ContextID, 2);\n@@ -954,1 +1002,4 @@\n-    if (SizeOfTag < UnicodeCount*sizeof(cmsUInt16Number)) goto Done;\n+    if (UnicodeCount == 0 || SizeOfTag < UnicodeCount*sizeof(cmsUInt16Number)) goto Done;\n+\n+    UnicodeString = (wchar_t*)_cmsMallocZero(self->ContextID, (UnicodeCount + 1) * sizeof(wchar_t));\n+    if (UnicodeString == NULL) goto Done;\n@@ -956,2 +1007,3 @@\n-    for (i=0; i < UnicodeCount; i++) {\n-        if (!io ->Read(io, &Dummy, sizeof(cmsUInt16Number), 1)) goto Done;\n+    if (!_cmsReadWCharArray(io, UnicodeCount, UnicodeString)) {\n+        _cmsFree(self->ContextID, (void*)UnicodeString);\n+        goto Done;\n@@ -959,0 +1011,11 @@\n+\n+    UnicodeString[UnicodeCount] = 0;\n+\n+    if (!cmsMLUsetWide(mlu, cmsV2Unicode, cmsV2Unicode, UnicodeString)) {\n+        _cmsFree(self->ContextID, (void*)UnicodeString);\n+        goto Done;\n+    }\n+\n+    _cmsFree(self->ContextID, (void*)UnicodeString);\n+    UnicodeString = NULL;\n+\n@@ -962,1 +1025,1 @@\n-    \/\/ data that stricttly required. We need to skip it as this type may come\n+    \/\/ data that strictly required. We need to skip it as this type may come\n@@ -982,0 +1045,1 @@\n+    if (UnicodeString)  _cmsFree(self->ContextID, (void*)UnicodeString);\n@@ -1034,1 +1098,1 @@\n-        cmsMLUgetWide(mlu,  cmsNoLanguage, cmsNoCountry,  Wide, len * sizeof(wchar_t));\n+        cmsMLUgetWide(mlu,  cmsV2Unicode,  cmsV2Unicode,  Wide, len * sizeof(wchar_t));\n@@ -1339,1 +1403,1 @@\n-\/\/ time to UTC when setting these values. Programmes that display these values may show\n+\/\/ time to UTC when setting these values. Programs that display these values may show\n@@ -1505,0 +1569,6 @@\n+        \/\/ Offset MUST be even because it indexes a block of utf16 chars.\n+        \/\/ Tricky profiles that uses odd positions will not work anyway\n+        \/\/ because the whole utf16 block is previously converted to wchar_t\n+        \/\/ and sizeof this type may be of 4 bytes. On Linux systems, for example.\n+        if (Offset & 1) goto Error;\n+\n@@ -1527,2 +1597,0 @@\n-        NumOfWchar = 0;\n-\n@@ -1532,1 +1600,4 @@\n-        Block = (wchar_t*) _cmsMalloc(self ->ContextID, SizeOfTag);\n+        \/\/ Make sure this is an even utf16 size.\n+        if (SizeOfTag & 1) goto Error;\n+\n+        Block = (wchar_t*) _cmsCalloc(self ->ContextID, 1, SizeOfTag);\n@@ -1534,0 +1605,1 @@\n+\n@@ -1535,1 +1607,4 @@\n-        if (!_cmsReadWCharArray(io, NumOfWchar, Block)) goto Error;\n+        if (!_cmsReadWCharArray(io, NumOfWchar, Block)) {\n+            _cmsFree(self->ContextID, Block);\n+            goto Error;\n+        }\n@@ -1778,1 +1853,1 @@\n-\/\/ 8 bit lut may be scaled easely to v4 PCS, but we need also to properly adjust\n+\/\/ 8 bit lut may be scaled easily to v4 PCS, but we need also to properly adjust\n@@ -1883,1 +1958,1 @@\n-cmsBool  Type_LUT8_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n+cmsBool Type_LUT8_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n@@ -1885,1 +1960,1 @@\n-    cmsUInt32Number j, nTabSize, i, n;\n+    cmsUInt32Number j, nTabSize, i;\n@@ -1896,0 +1971,6 @@\n+\n+    if (mpe == NULL) {  \/\/ Should never be empty. Corrupted?\n+        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"empty LUT8 is not supported\");\n+        return FALSE;\n+    }\n+\n@@ -1920,1 +2001,1 @@\n-        cmsSignalError(mpe->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"LUT is not suitable to be saved as LUT8\");\n+        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"LUT is not suitable to be saved as LUT8\");\n@@ -1926,2 +2007,10 @@\n-    else\n-        clutPoints    = clut->Params->nSamples[0];\n+    else {\n+        \/\/ Lut8 only allows same CLUT points in all dimensions\n+        clutPoints = clut->Params->nSamples[0];\n+        for (i = 1; i < cmsPipelineInputChannels(NewLUT); i++) {\n+            if (clut->Params->nSamples[i] != clutPoints) {\n+                cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"LUT with different samples per dimension not suitable to be saved as LUT16\");\n+                return FALSE;\n+            }\n+        }\n+    }\n@@ -1929,2 +2018,2 @@\n-    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) NewLUT ->InputChannels)) return FALSE;\n-    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) NewLUT ->OutputChannels)) return FALSE;\n+    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number)cmsPipelineInputChannels(NewLUT))) return FALSE;\n+    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number)cmsPipelineOutputChannels(NewLUT))) return FALSE;\n@@ -1934,2 +2023,0 @@\n-        n = NewLUT->InputChannels * NewLUT->OutputChannels;\n-\n@@ -1938,4 +2025,4 @@\n-                for (i = 0; i < 9; i++)\n-                {\n-                        if (!_cmsWrite15Fixed16Number(io, MatMPE->Double[i])) return FALSE;\n-                }\n+        for (i = 0; i < 9; i++)\n+        {\n+            if (!_cmsWrite15Fixed16Number(io, MatMPE->Double[i])) return FALSE;\n+        }\n@@ -2059,2 +2146,0 @@\n-    nEntries = Tables->TheCurves[0]->nEntries;\n-\n@@ -2063,0 +2148,2 @@\n+        nEntries = Tables->TheCurves[i]->nEntries;\n+\n@@ -2205,1 +2292,1 @@\n-        cmsSignalError(mpe->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"LUT is not suitable to be saved as LUT16\");\n+        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"LUT is not suitable to be saved as LUT16\");\n@@ -2214,2 +2301,10 @@\n-    else\n-        clutPoints    = clut->Params->nSamples[0];\n+    else {\n+        \/\/ Lut16 only allows same CLUT points in all dimensions\n+        clutPoints = clut->Params->nSamples[0];\n+        for (i = 1; i < InputChannels; i++) {\n+            if (clut->Params->nSamples[i] != clutPoints) {\n+                cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"LUT with different samples per dimension not suitable to be saved as LUT16\");\n+                return FALSE;\n+            }\n+        }\n+    }\n@@ -2224,4 +2319,4 @@\n-                for (i = 0; i < 9; i++)\n-                {\n-                        if (!_cmsWrite15Fixed16Number(io, MatMPE->Double[i])) return FALSE;\n-                }\n+        for (i = 0; i < 9; i++)\n+        {\n+            if (!_cmsWrite15Fixed16Number(io, MatMPE->Double[i])) return FALSE;\n+        }\n@@ -2573,1 +2668,1 @@\n-        cmsUInt32Number i, n;\n+    cmsUInt32Number i, n;\n@@ -2577,1 +2672,1 @@\n-        n = mpe->InputChannels * mpe->OutputChannels;\n+    n = mpe->InputChannels * mpe->OutputChannels;\n@@ -2579,5 +2674,5 @@\n-        \/\/ Write the Matrix\n-        for (i = 0; i < n; i++)\n-        {\n-                if (!_cmsWrite15Fixed16Number(io, m->Double[i])) return FALSE;\n-        }\n+    \/\/ Write the Matrix\n+    for (i = 0; i < n; i++)\n+    {\n+        if (!_cmsWrite15Fixed16Number(io, m->Double[i])) return FALSE;\n+    }\n@@ -2585,1 +2680,1 @@\n-        if (m->Offset != NULL) {\n+    if (m->Offset != NULL) {\n@@ -2587,4 +2682,3 @@\n-                for (i = 0; i < mpe->OutputChannels; i++)\n-                {\n-                        if (!_cmsWrite15Fixed16Number(io, m->Offset[i])) return FALSE;\n-                }\n+        for (i = 0; i < mpe->OutputChannels; i++)\n+        {\n+            if (!_cmsWrite15Fixed16Number(io, m->Offset[i])) return FALSE;\n@@ -2592,5 +2686,5 @@\n-        else {\n-                for (i = 0; i < mpe->OutputChannels; i++)\n-                {\n-                        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n-                }\n+    }\n+    else {\n+        for (i = 0; i < mpe->OutputChannels; i++)\n+        {\n+            if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n@@ -2598,0 +2692,1 @@\n+    }\n@@ -2623,2 +2718,2 @@\n-        if ((Curves[i] ->nSegments == 0)||\n-            ((Curves[i]->nSegments == 2) && (Curves[i] ->Segments[1].Type == 0)) )\n+        if ((Curves[i] ->nSegments == 0) ||                                         \/\/ 16 bits tabulated\n+            ((Curves[i]->nSegments == 3) && (Curves[i] ->Segments[1].Type == 0)) )  \/\/ Floating-point tabulated\n@@ -3128,1 +3223,0 @@\n-\n@@ -3200,2 +3294,2 @@\n-    strncpy(prefix, (const char*) NamedColorList->Prefix, 32);\n-    strncpy(suffix, (const char*) NamedColorList->Suffix, 32);\n+    memcpy(prefix, (const char*) NamedColorList->Prefix, sizeof(prefix));\n+    memcpy(suffix, (const char*) NamedColorList->Suffix, sizeof(suffix));\n@@ -3214,0 +3308,4 @@\n+       memset(Root, 0, sizeof(Root));\n+       memset(PCS, 0, sizeof(PCS));\n+       memset(Colorant, 0, sizeof(Colorant));\n+\n@@ -3454,1 +3552,0 @@\n-    SizeOfTag -= sizeof(cmsUInt32Number);\n@@ -3472,0 +3569,1 @@\n+    cmsUNUSED_PARAMETER(SizeOfTag);\n@@ -3547,0 +3645,1 @@\n+    cmsInt32Number SignedSizeOfTag = (cmsInt32Number)SizeOfTag;\n@@ -3553,0 +3652,2 @@\n+\n+    if (SignedSizeOfTag < (cmsInt32Number) sizeof(cmsUInt32Number)) return NULL;\n@@ -3554,2 +3655,1 @@\n-    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;\n-    SizeOfTag -= sizeof(cmsUInt32Number);\n+    SignedSizeOfTag -= sizeof(cmsUInt32Number);\n@@ -3558,1 +3658,1 @@\n-    if (n ->Ucr == NULL) return NULL;\n+    if (n ->Ucr == NULL) goto error;\n@@ -3560,3 +3660,4 @@\n-    if (!_cmsReadUInt16Array(io, CountUcr, n ->Ucr->Table16)) return NULL;\n-    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;\n-    SizeOfTag -= CountUcr * sizeof(cmsUInt16Number);\n+    if (SignedSizeOfTag < (cmsInt32Number)(CountUcr * sizeof(cmsUInt16Number))) goto error;\n+    if (!_cmsReadUInt16Array(io, CountUcr, n ->Ucr->Table16)) goto error;\n+\n+    SignedSizeOfTag -= CountUcr * sizeof(cmsUInt16Number);\n@@ -3565,3 +3666,4 @@\n-    if (!_cmsReadUInt32Number(io, &CountBg)) return NULL;\n-    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;\n-    SizeOfTag -= sizeof(cmsUInt32Number);\n+\n+    if (SignedSizeOfTag < (cmsInt32Number)sizeof(cmsUInt32Number)) goto error;\n+    if (!_cmsReadUInt32Number(io, &CountBg)) goto error;\n+    SignedSizeOfTag -= sizeof(cmsUInt32Number);\n@@ -3570,5 +3672,7 @@\n-    if (n ->Bg == NULL) return NULL;\n-    if (!_cmsReadUInt16Array(io, CountBg, n ->Bg->Table16)) return NULL;\n-    if (SizeOfTag < CountBg * sizeof(cmsUInt16Number)) return NULL;\n-    SizeOfTag -= CountBg * sizeof(cmsUInt16Number);\n-    if (SizeOfTag == UINT_MAX) return NULL;\n+    if (n ->Bg == NULL) goto error;\n+\n+    if (SignedSizeOfTag < (cmsInt32Number) (CountBg * sizeof(cmsUInt16Number))) goto error;\n+    if (!_cmsReadUInt16Array(io, CountBg, n ->Bg->Table16)) goto error;\n+    SignedSizeOfTag -= CountBg * sizeof(cmsUInt16Number);\n+\n+    if (SignedSizeOfTag < 0 || SignedSizeOfTag > 32000) goto error;\n@@ -3578,1 +3682,1 @@\n-    if (n ->Desc == NULL) return NULL;\n+    if (n ->Desc == NULL) goto error;\n@@ -3580,3 +3684,8 @@\n-    ASCIIString = (char*) _cmsMalloc(self ->ContextID, SizeOfTag + 1);\n-    if (io ->Read(io, ASCIIString, sizeof(char), SizeOfTag) != SizeOfTag) return NULL;\n-    ASCIIString[SizeOfTag] = 0;\n+    ASCIIString = (char*) _cmsMalloc(self ->ContextID, SignedSizeOfTag + 1);\n+    if (io->Read(io, ASCIIString, sizeof(char), SignedSizeOfTag) != (cmsUInt32Number)SignedSizeOfTag)\n+    {\n+        _cmsFree(self->ContextID, ASCIIString);\n+        goto error;\n+    }\n+\n+    ASCIIString[SignedSizeOfTag] = 0;\n@@ -3588,0 +3697,10 @@\n+\n+error:\n+\n+    if (n->Ucr) cmsFreeToneCurve(n->Ucr);\n+    if (n->Bg) cmsFreeToneCurve(n->Bg);\n+    if (n->Desc) cmsMLUfree(n->Desc);\n+    _cmsFree(self->ContextID, n);\n+    *nItems = 0;\n+    return NULL;\n+\n@@ -3668,1 +3787,1 @@\n-cmsBool  ReadCountAndSting(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsMLU* mlu, cmsUInt32Number* SizeOfTag, const char* Section)\n+cmsBool  ReadCountAndString(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsMLU* mlu, cmsUInt32Number* SizeOfTag, const char* Section)\n@@ -3698,1 +3817,1 @@\n-cmsBool  WriteCountAndSting(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsMLU* mlu, const char* Section)\n+cmsBool  WriteCountAndString(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsMLU* mlu, const char* Section)\n@@ -3722,5 +3841,5 @@\n-    if (!ReadCountAndSting(self, io, mlu, &SizeOfTag, \"nm\")) goto Error;\n-    if (!ReadCountAndSting(self, io, mlu, &SizeOfTag, \"#0\")) goto Error;\n-    if (!ReadCountAndSting(self, io, mlu, &SizeOfTag, \"#1\")) goto Error;\n-    if (!ReadCountAndSting(self, io, mlu, &SizeOfTag, \"#2\")) goto Error;\n-    if (!ReadCountAndSting(self, io, mlu, &SizeOfTag, \"#3\")) goto Error;\n+    if (!ReadCountAndString(self, io, mlu, &SizeOfTag, \"nm\")) goto Error;\n+    if (!ReadCountAndString(self, io, mlu, &SizeOfTag, \"#0\")) goto Error;\n+    if (!ReadCountAndString(self, io, mlu, &SizeOfTag, \"#1\")) goto Error;\n+    if (!ReadCountAndString(self, io, mlu, &SizeOfTag, \"#2\")) goto Error;\n+    if (!ReadCountAndString(self, io, mlu, &SizeOfTag, \"#3\")) goto Error;\n@@ -3743,5 +3862,5 @@\n-    if (!WriteCountAndSting(self, io, mlu, \"nm\")) goto Error;\n-    if (!WriteCountAndSting(self, io, mlu, \"#0\")) goto Error;\n-    if (!WriteCountAndSting(self, io, mlu, \"#1\")) goto Error;\n-    if (!WriteCountAndSting(self, io, mlu, \"#2\")) goto Error;\n-    if (!WriteCountAndSting(self, io, mlu, \"#3\")) goto Error;\n+    if (!WriteCountAndString(self, io, mlu, \"nm\")) goto Error;\n+    if (!WriteCountAndString(self, io, mlu, \"#0\")) goto Error;\n+    if (!WriteCountAndString(self, io, mlu, \"#1\")) goto Error;\n+    if (!WriteCountAndString(self, io, mlu, \"#2\")) goto Error;\n+    if (!WriteCountAndString(self, io, mlu, \"#3\")) goto Error;\n@@ -4001,1 +4120,1 @@\n-            case cmsSigFormulaCurveSeg: {\n+           case cmsSigFormulaCurveSeg: {\n@@ -4003,2 +4122,2 @@\n-                cmsUInt16Number Type;\n-                cmsUInt32Number ParamsByType[] = {4, 5, 5 };\n+               cmsUInt16Number Type;\n+               cmsUInt32Number ParamsByType[] = { 4, 5, 5 };\n@@ -4006,2 +4125,2 @@\n-                if (!_cmsReadUInt16Number(io, &Type)) goto Error;\n-                if (!_cmsReadUInt16Number(io, NULL)) goto Error;\n+               if (!_cmsReadUInt16Number(io, &Type)) goto Error;\n+               if (!_cmsReadUInt16Number(io, NULL)) goto Error;\n@@ -4009,2 +4128,2 @@\n-                Segments[i].Type = Type + 6;\n-                if (Type > 2) goto Error;\n+               Segments[i].Type = Type + 6;\n+               if (Type > 2) goto Error;\n@@ -4012,1 +4131,1 @@\n-                for (j=0; j < ParamsByType[Type]; j++) {\n+               for (j = 0; j < ParamsByType[Type]; j++) {\n@@ -4014,6 +4133,6 @@\n-                    cmsFloat32Number f;\n-                    if (!_cmsReadFloat32Number(io, &f)) goto Error;\n-                    Segments[i].Params[j] = f;\n-                }\n-                }\n-                break;\n+                   cmsFloat32Number f;\n+                   if (!_cmsReadFloat32Number(io, &f)) goto Error;\n+                   Segments[i].Params[j] = f;\n+               }\n+           }\n+           break;\n@@ -4022,2 +4141,2 @@\n-            case cmsSigSampledCurveSeg: {\n-                cmsUInt32Number Count;\n+           case cmsSigSampledCurveSeg: {\n+               cmsUInt32Number Count;\n@@ -4025,1 +4144,1 @@\n-                if (!_cmsReadUInt32Number(io, &Count)) goto Error;\n+               if (!_cmsReadUInt32Number(io, &Count)) goto Error;\n@@ -4027,3 +4146,5 @@\n-                Segments[i].nGridPoints = Count;\n-                Segments[i].SampledPoints = (cmsFloat32Number*) _cmsCalloc(self ->ContextID, Count, sizeof(cmsFloat32Number));\n-                if (Segments[i].SampledPoints == NULL) goto Error;\n+               \/\/ The first point is implicit in the last stage, we allocate an extra note to be populated latter on\n+               Count++;\n+               Segments[i].nGridPoints = Count;\n+               Segments[i].SampledPoints = (cmsFloat32Number*)_cmsCalloc(self->ContextID, Count, sizeof(cmsFloat32Number));\n+               if (Segments[i].SampledPoints == NULL) goto Error;\n@@ -4031,5 +4152,6 @@\n-                for (j=0; j < Count; j++) {\n-                    if (!_cmsReadFloat32Number(io, &Segments[i].SampledPoints[j])) goto Error;\n-                }\n-                }\n-                break;\n+               Segments[i].SampledPoints[0] = 0;\n+               for (j = 1; j < Count; j++) {\n+                   if (!_cmsReadFloat32Number(io, &Segments[i].SampledPoints[j])) goto Error;\n+               }\n+           }\n+           break;\n@@ -4055,0 +4177,11 @@\n+\n+     \/\/ Explore for missing implicit points\n+     for (i = 0; i < nSegments; i++) {\n+\n+         \/\/ If sampled curve, fix it\n+         if (Curve->Segments[i].Type == 0) {\n+\n+             Curve->Segments[i].SampledPoints[0] = cmsEvalToneCurveFloat(Curve, Curve->Segments[i].x0);\n+         }\n+     }\n+\n@@ -4149,1 +4282,1 @@\n-            \/\/ This is a sampled curve\n+            \/\/ This is a sampled curve. First point is implicit in the ICC format, but not in our representation\n@@ -4152,1 +4285,1 @@\n-            if (!_cmsWriteUInt32Number(io, ActualSeg -> nGridPoints)) goto Error;\n+            if (!_cmsWriteUInt32Number(io, ActualSeg -> nGridPoints - 1)) goto Error;\n@@ -4154,1 +4287,1 @@\n-            for (j=0; j < g ->Segments[i].nGridPoints; j++) {\n+            for (j=1; j < g ->Segments[i].nGridPoints; j++) {\n@@ -4350,2 +4483,2 @@\n-    if (InputChans == 0) goto Error;\n-    if (OutputChans == 0) goto Error;\n+    if (InputChans == 0 || InputChans >= cmsMAXCHANNELS) goto Error;\n+    if (OutputChans == 0 || OutputChans >= cmsMAXCHANNELS) goto Error;\n@@ -4531,1 +4664,1 @@\n-\/\/ This one is a liitle bit more complex, so we don't use position tables this time.\n+\/\/ This one is a little bit more complex, so we don't use position tables this time.\n@@ -4963,1 +5096,1 @@\n-    \/\/ An offset of zero has special meaning and shal be preserved\n+    \/\/ An offset of zero has special meaning and shall be preserved\n@@ -4971,1 +5104,3 @@\n-cmsBool ReadOffsetArray(cmsIOHANDLER* io,  _cmsDICarray* a, cmsUInt32Number Count, cmsUInt32Number Length, cmsUInt32Number BaseOffset)\n+cmsBool ReadOffsetArray(cmsIOHANDLER* io,  _cmsDICarray* a,\n+                        cmsUInt32Number Count, cmsUInt32Number Length, cmsUInt32Number BaseOffset,\n+                        cmsInt32Number* SignedSizeOfTagPtr)\n@@ -4974,0 +5109,1 @@\n+    cmsInt32Number SignedSizeOfTag = *SignedSizeOfTagPtr;\n@@ -4978,0 +5114,3 @@\n+        if (SignedSizeOfTag < 4 * (cmsInt32Number) sizeof(cmsUInt32Number)) return FALSE;\n+        SignedSizeOfTag -= 4 * sizeof(cmsUInt32Number);\n+\n@@ -4983,0 +5122,3 @@\n+            if (SignedSizeOfTag < 2 * (cmsInt32Number) sizeof(cmsUInt32Number)) return FALSE;\n+            SignedSizeOfTag -= 2 * sizeof(cmsUInt32Number);\n+\n@@ -4989,0 +5131,3 @@\n+            if (SignedSizeOfTag < 2 * (cmsInt32Number) sizeof(cmsUInt32Number)) return FALSE;\n+            SignedSizeOfTag -= 2 * (cmsInt32Number) sizeof(cmsUInt32Number);\n+\n@@ -4992,0 +5137,2 @@\n+\n+    *SignedSizeOfTagPtr = SignedSizeOfTag;\n@@ -5127,1 +5274,2 @@\n-    e ->Offsets[i] = Before - BaseOffset;\n+    if (e->Offsets != NULL)\n+        e ->Offsets[i] = Before - BaseOffset;\n@@ -5131,1 +5279,2 @@\n-    e ->Sizes[i] = io ->Tell(io) - Before;\n+    if (e->Sizes != NULL)\n+        e ->Sizes[i] = io ->Tell(io) - Before;\n@@ -5139,1 +5288,1 @@\n-   cmsHANDLE hDict;\n+   cmsHANDLE hDict = NULL;\n@@ -5146,0 +5295,1 @@\n+   cmsInt32Number SignedSizeOfTag = (cmsInt32Number)SizeOfTag;\n@@ -5148,0 +5298,1 @@\n+    memset(&a, 0, sizeof(a));\n@@ -5153,0 +5304,2 @@\n+    SignedSizeOfTag -= sizeof(cmsUInt32Number);\n+    if (SignedSizeOfTag < 0) goto Error;\n@@ -5154,1 +5307,0 @@\n-    SizeOfTag -= sizeof(cmsUInt32Number);\n@@ -5157,0 +5309,2 @@\n+    SignedSizeOfTag -= sizeof(cmsUInt32Number);\n+    if (SignedSizeOfTag < 0) goto Error;\n@@ -5158,1 +5312,1 @@\n-    SizeOfTag -= sizeof(cmsUInt32Number);\n+\n@@ -5174,1 +5328,1 @@\n-    if (!ReadOffsetArray(io, &a, Count, Length, BaseOffset)) goto Error;\n+    if (!ReadOffsetArray(io, &a, Count, Length, BaseOffset, &SignedSizeOfTag)) goto Error;\n@@ -5214,1 +5368,1 @@\n-   cmsDictFree(hDict);\n+   if (hDict != NULL) cmsDictFree(hDict);\n@@ -5312,0 +5466,268 @@\n+\/\/ cicp VideoSignalType\n+\n+static\n+void* Type_VideoSignal_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n+{\n+    cmsVideoSignalType* cicp = NULL;\n+\n+    if (SizeOfTag != 8) return NULL;\n+\n+    if (!_cmsReadUInt32Number(io, NULL)) return NULL;\n+\n+    cicp = (cmsVideoSignalType*)_cmsCalloc(self->ContextID, 1, sizeof(cmsVideoSignalType));\n+    if (cicp == NULL) return NULL;\n+\n+    if (!_cmsReadUInt8Number(io, &cicp->ColourPrimaries)) goto Error;\n+    if (!_cmsReadUInt8Number(io, &cicp->TransferCharacteristics)) goto Error;\n+    if (!_cmsReadUInt8Number(io, &cicp->MatrixCoefficients)) goto Error;\n+    if (!_cmsReadUInt8Number(io, &cicp->VideoFullRangeFlag)) goto Error;\n+\n+    \/\/ Success\n+    *nItems = 1;\n+    return cicp;\n+\n+Error:\n+    if (cicp != NULL) _cmsFree(self->ContextID, cicp);\n+    return NULL;\n+}\n+\n+static\n+cmsBool Type_VideoSignal_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n+{\n+    cmsVideoSignalType* cicp = (cmsVideoSignalType*)Ptr;\n+\n+    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n+    if (!_cmsWriteUInt8Number(io, cicp->ColourPrimaries)) return FALSE;\n+    if (!_cmsWriteUInt8Number(io, cicp->TransferCharacteristics)) return FALSE;\n+    if (!_cmsWriteUInt8Number(io, cicp->MatrixCoefficients)) return FALSE;\n+    if (!_cmsWriteUInt8Number(io, cicp->VideoFullRangeFlag)) return FALSE;\n+\n+    return TRUE;\n+\n+    cmsUNUSED_PARAMETER(self);\n+    cmsUNUSED_PARAMETER(nItems);\n+}\n+\n+void* Type_VideoSignal_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)\n+{\n+    return _cmsDupMem(self->ContextID, Ptr, sizeof(cmsVideoSignalType));\n+\n+    cmsUNUSED_PARAMETER(n);\n+}\n+\n+\n+static\n+void Type_VideoSignal_Free(struct _cms_typehandler_struct* self, void* Ptr)\n+{\n+    _cmsFree(self->ContextID, Ptr);\n+}\n+\n+\n+\/\/ ********************************************************************************\n+\/\/ Microsoft's MHC2 Type support\n+\/\/ ********************************************************************************\n+\n+static\n+void SetIdentity(cmsFloat64Number XYZ2XYZmatrix[3][4])\n+{\n+    XYZ2XYZmatrix[0][0] = 1.0; XYZ2XYZmatrix[0][1] = 0.0; XYZ2XYZmatrix[0][2] = 0.0; XYZ2XYZmatrix[0][3] = 0.0;\n+    XYZ2XYZmatrix[1][0] = 0.0; XYZ2XYZmatrix[1][1] = 1.0; XYZ2XYZmatrix[1][2] = 0.0; XYZ2XYZmatrix[1][3] = 0.0;\n+    XYZ2XYZmatrix[2][0] = 0.0; XYZ2XYZmatrix[2][1] = 0.0; XYZ2XYZmatrix[2][2] = 1.0; XYZ2XYZmatrix[2][3] = 0.0;\n+}\n+\n+static\n+cmsBool CloseEnough(cmsFloat64Number a, cmsFloat64Number b)\n+{\n+    return fabs(b - a) < (1.0 \/ 65535.0);\n+}\n+\n+cmsBool IsIdentity(cmsFloat64Number XYZ2XYZmatrix[3][4])\n+{\n+    cmsFloat64Number Identity[3][4];\n+    int i, j;\n+\n+    SetIdentity(Identity);\n+\n+    for (i = 0; i < 3; i++)\n+        for (j = 0; j < 4; j++)\n+            if (!CloseEnough(XYZ2XYZmatrix[i][j], Identity[i][j])) return FALSE;\n+\n+    return TRUE;\n+}\n+\n+static\n+void Type_MHC2_Free(struct _cms_typehandler_struct* self, void* Ptr)\n+{\n+    cmsMHC2Type* mhc2 = (cmsMHC2Type*)Ptr;\n+\n+    if (mhc2->RedCurve != NULL) _cmsFree(self->ContextID, mhc2->RedCurve);\n+    if (mhc2->GreenCurve != NULL) _cmsFree(self->ContextID, mhc2->GreenCurve);\n+    if (mhc2->BlueCurve != NULL) _cmsFree(self->ContextID, mhc2->BlueCurve);\n+\n+    _cmsFree(self->ContextID, Ptr);\n+}\n+\n+void* Type_MHC2_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)\n+{\n+    cmsMHC2Type* mhc2 = _cmsDupMem(self->ContextID, Ptr, sizeof(cmsMHC2Type));\n+\n+    mhc2->RedCurve = _cmsDupMem(self->ContextID,   mhc2->RedCurve, mhc2->CurveEntries*sizeof(cmsFloat64Number));\n+    mhc2->GreenCurve = _cmsDupMem(self->ContextID, mhc2->GreenCurve, mhc2->CurveEntries * sizeof(cmsFloat64Number));\n+    mhc2->BlueCurve = _cmsDupMem(self->ContextID,  mhc2->BlueCurve, mhc2->CurveEntries * sizeof(cmsFloat64Number));\n+\n+    if (mhc2->RedCurve == NULL ||\n+        mhc2->GreenCurve == NULL ||\n+        mhc2->BlueCurve == NULL) {\n+\n+        Type_MHC2_Free(self, mhc2);\n+        return NULL;\n+    }\n+\n+    return mhc2;\n+\n+    cmsUNUSED_PARAMETER(n);\n+}\n+\n+\n+static\n+cmsBool WriteDoubles(cmsIOHANDLER* io, cmsUInt32Number n, cmsFloat64Number* Values)\n+{\n+    cmsUInt32Number i;\n+\n+    for (i = 0; i < n; i++) {\n+\n+        if (!_cmsWrite15Fixed16Number(io, *Values++)) return FALSE;\n+    }\n+\n+    return TRUE;\n+}\n+\n+static\n+cmsBool Type_MHC2_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n+{\n+    cmsMHC2Type* mhc2 = (cmsMHC2Type*)Ptr;\n+    cmsUInt32Number BaseOffset = io->Tell(io) - sizeof(_cmsTagBase);\n+    cmsUInt32Number TablesOffsetPos;\n+    cmsUInt32Number MatrixOffset;\n+    cmsUInt32Number OffsetRedTable, OffsetGreenTable, OffsetBlueTable;\n+\n+    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n+    if (!_cmsWriteUInt32Number(io, mhc2->CurveEntries)) return FALSE;\n+\n+    if (!_cmsWrite15Fixed16Number(io, mhc2->MinLuminance)) return FALSE;\n+    if (!_cmsWrite15Fixed16Number(io, mhc2->PeakLuminance)) return FALSE;\n+\n+    TablesOffsetPos = io->Tell(io);\n+\n+    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;    \/\/ Matrix\n+    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;    \/\/ Curve R\n+    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;    \/\/ Curve G\n+    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;    \/\/ Curve B\n+\n+\n+    if (IsIdentity(mhc2->XYZ2XYZmatrix))\n+    {\n+        MatrixOffset = 0;\n+    }\n+    else\n+    {\n+        MatrixOffset = io->Tell(io) - BaseOffset;\n+        if (!WriteDoubles(io, 3 * 4, &mhc2->XYZ2XYZmatrix[0][0])) return FALSE;\n+    }\n+\n+    OffsetRedTable = io->Tell(io) - BaseOffset;\n+    if (!WriteDoubles(io, mhc2->CurveEntries, mhc2->RedCurve)) return FALSE;\n+    OffsetGreenTable = io->Tell(io) - BaseOffset;\n+    if (!WriteDoubles(io, mhc2->CurveEntries, mhc2->GreenCurve)) return FALSE;\n+    OffsetBlueTable = io->Tell(io) - BaseOffset;\n+    if (!WriteDoubles(io, mhc2->CurveEntries, mhc2->BlueCurve)) return FALSE;\n+\n+    if (!io->Seek(io, TablesOffsetPos)) return FALSE;\n+\n+    if (!_cmsWriteUInt32Number(io, MatrixOffset)) return FALSE;\n+    if (!_cmsWriteUInt32Number(io, OffsetRedTable)) return FALSE;\n+    if (!_cmsWriteUInt32Number(io, OffsetGreenTable)) return FALSE;\n+    if (!_cmsWriteUInt32Number(io, OffsetBlueTable)) return FALSE;\n+\n+    return TRUE;\n+\n+    cmsUNUSED_PARAMETER(self);\n+    cmsUNUSED_PARAMETER(nItems);\n+}\n+\n+\n+static\n+cmsBool ReadDoublesAt(cmsIOHANDLER* io, cmsUInt32Number At, cmsUInt32Number n, cmsFloat64Number* Values)\n+{\n+    cmsUInt32Number CurrentPos = io->Tell(io);\n+    cmsUInt32Number i;\n+\n+    if (!io->Seek(io, At)) return FALSE;\n+\n+    for (i = 0; i < n; i++) {\n+\n+        if (!_cmsRead15Fixed16Number(io, Values++)) return FALSE;\n+    }\n+\n+    if (!io->Seek(io, CurrentPos)) return FALSE;\n+\n+    return TRUE;\n+}\n+\n+static\n+void* Type_MHC2_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n+{\n+    cmsMHC2Type* mhc2 = NULL;\n+\n+    cmsUInt32Number BaseOffset = io->Tell(io) - sizeof(_cmsTagBase);\n+    cmsUInt32Number MatrixOffset;\n+    cmsUInt32Number OffsetRedTable, OffsetGreenTable, OffsetBlueTable;\n+\n+    if (!_cmsReadUInt32Number(io, NULL)) return NULL;\n+\n+    mhc2 = (cmsMHC2Type*)_cmsCalloc(self->ContextID, 1, sizeof(cmsMHC2Type));\n+    if (mhc2 == NULL) return NULL;\n+\n+    if (!_cmsReadUInt32Number(io,    &mhc2->CurveEntries)) goto Error;\n+\n+    if (mhc2->CurveEntries > 4096) goto Error;\n+\n+    mhc2->RedCurve = (cmsFloat64Number*)_cmsCalloc(self->ContextID, mhc2->CurveEntries, sizeof(cmsFloat64Number));\n+    mhc2->GreenCurve = (cmsFloat64Number*)_cmsCalloc(self->ContextID, mhc2->CurveEntries, sizeof(cmsFloat64Number));\n+    mhc2->BlueCurve = (cmsFloat64Number*)_cmsCalloc(self->ContextID, mhc2->CurveEntries, sizeof(cmsFloat64Number));\n+\n+    if (mhc2->RedCurve == NULL ||\n+        mhc2->GreenCurve == NULL ||\n+        mhc2->BlueCurve == NULL)  goto Error;\n+\n+    if (!_cmsRead15Fixed16Number(io, &mhc2->MinLuminance)) goto Error;\n+    if (!_cmsRead15Fixed16Number(io, &mhc2->PeakLuminance)) goto Error;\n+\n+    if (!_cmsReadUInt32Number(io, &MatrixOffset)) goto Error;\n+    if (!_cmsReadUInt32Number(io, &OffsetRedTable)) goto Error;\n+    if (!_cmsReadUInt32Number(io, &OffsetGreenTable)) goto Error;\n+    if (!_cmsReadUInt32Number(io, &OffsetBlueTable)) goto Error;\n+\n+    if (MatrixOffset == 0)\n+        SetIdentity(mhc2->XYZ2XYZmatrix);\n+    else\n+    {\n+        if (!ReadDoublesAt(io, BaseOffset + MatrixOffset, 3*4, &mhc2->XYZ2XYZmatrix[0][0])) goto Error;\n+    }\n+\n+    if (!ReadDoublesAt(io, BaseOffset + OffsetRedTable, mhc2->CurveEntries, mhc2->RedCurve)) goto Error;\n+    if (!ReadDoublesAt(io, BaseOffset + OffsetGreenTable, mhc2->CurveEntries, mhc2->GreenCurve)) goto Error;\n+    if (!ReadDoublesAt(io, BaseOffset + OffsetBlueTable, mhc2->CurveEntries, mhc2->BlueCurve)) goto Error;\n+\n+    \/\/ Success\n+    *nItems = 1;\n+    return mhc2;\n+\n+Error:\n+    Type_MHC2_Free(self, mhc2);\n+    return NULL;\n+\n+    cmsUNUSED_PARAMETER(SizeOfTag);\n+}\n+\n+\n@@ -5351,1 +5773,3 @@\n-{TYPE_HANDLER(cmsSigVcgtType,                  vcgt),                NULL }\n+{TYPE_HANDLER(cmsSigcicpType,                  VideoSignal),        (_cmsTagTypeLinkedList*) &SupportedTagTypes[31] },\n+{TYPE_HANDLER(cmsSigVcgtType,                  vcgt),               (_cmsTagTypeLinkedList*) &SupportedTagTypes[32] },\n+{TYPE_HANDLER(cmsSigMHC2Type,                  MHC2),                NULL }\n@@ -5545,1 +5969,4 @@\n-    { cmsSigArgyllArtsTag,          { 9, 1, { cmsSigS15Fixed16ArrayType},    NULL}, NULL}\n+    { cmsSigcicpTag,                { 1, 1, { cmsSigcicpType},               NULL },   &SupportedTags[64]},\n+\n+    { cmsSigArgyllArtsTag,          { 9, 1, { cmsSigS15Fixed16ArrayType},    NULL}, &SupportedTags[65]},\n+    { cmsSigMHC2Tag,                { 1, 1, { cmsSigMHC2Type },              NULL}, NULL}\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmstypes.c","additions":558,"deletions":131,"binary":false,"changes":689,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -146,1 +146,1 @@\n-    cmsSetProfileVersion(hICC, 4.3);\n+    cmsSetProfileVersion(hICC, 4.4);\n@@ -267,1 +267,1 @@\n-    cmsSetProfileVersion(hICC, 4.3);\n+    cmsSetProfileVersion(hICC, 4.4);\n@@ -323,1 +323,1 @@\n-    cmsUInt32Number nChannels;\n+    cmsInt32Number nChannels;\n@@ -329,1 +329,1 @@\n-    cmsSetProfileVersion(hICC, 4.3);\n+    cmsSetProfileVersion(hICC, 4.4);\n@@ -338,1 +338,1 @@\n-    nChannels = cmsChannelsOf(ColorSpace);\n+    nChannels = cmsChannelsOfColorSpace(ColorSpace);\n@@ -400,1 +400,1 @@\n-    SumCMY   = In[0]  + In[1] + In[2];\n+    SumCMY   = (cmsFloat64Number) In[0]  + In[1] + In[2];\n@@ -429,1 +429,1 @@\n-    cmsUInt32Number nChannels;\n+    cmsInt32Number nChannels;\n@@ -438,2 +438,2 @@\n-        cmsSignalError(ContextID, cmsERROR_RANGE, \"InkLimiting: Limit should be between 0..400\");\n-        if (Limit < 0) Limit = 0;\n+        cmsSignalError(ContextID, cmsERROR_RANGE, \"InkLimiting: Limit should be between 1..400\");\n+        if (Limit < 1) Limit = 1;\n@@ -441,1 +441,0 @@\n-\n@@ -448,1 +447,1 @@\n-    cmsSetProfileVersion(hICC, 4.3);\n+    cmsSetProfileVersion(hICC, 4.4);\n@@ -558,1 +557,1 @@\n-    cmsSetProfileVersion(hProfile, 4.3);\n+    cmsSetProfileVersion(hProfile, 4.4);\n@@ -604,1 +603,1 @@\n-    cmsSetProfileVersion(hProfile, 4.3);\n+    cmsSetProfileVersion(hProfile, 4.4);\n@@ -704,0 +703,121 @@\n+\/**\n+* Oklab colorspace profile (experimental)\n+*\n+* This virtual profile cannot be saved as an ICC file\n+*\/\n+cmsHPROFILE cmsCreate_OkLabProfile(cmsContext ctx)\n+{\n+    cmsStage* XYZPCS = _cmsStageNormalizeFromXyzFloat(ctx);\n+    cmsStage* PCSXYZ = _cmsStageNormalizeToXyzFloat(ctx);\n+\n+    const double M_D65_D50[] =\n+    {\n+       1.047886, 0.022919, -0.050216,\n+       0.029582, 0.990484, -0.017079,\n+      -0.009252, 0.015073,  0.751678\n+    };\n+\n+    const double M_D50_D65[] =\n+    {\n+         0.955512609517083, -0.023073214184645,  0.063308961782107,\n+        -0.028324949364887,  1.009942432477107,  0.021054814890112,\n+         0.012328875695483, -0.020535835374141,  1.330713916450354\n+    };\n+\n+    cmsStage* D65toD50 = cmsStageAllocMatrix(ctx, 3, 3, M_D65_D50, NULL);\n+    cmsStage* D50toD65 = cmsStageAllocMatrix(ctx, 3, 3, M_D50_D65, NULL);\n+\n+    const double M_D65_LMS[] =\n+    {\n+        0.8189330101, 0.3618667424, -0.1288597137,\n+        0.0329845436, 0.9293118715,  0.0361456387,\n+        0.0482003018, 0.2643662691,  0.6338517070\n+    };\n+\n+    const double M_LMS_D65[] =\n+    {\n+        1.227013851103521, -0.557799980651822,  0.281256148966468,\n+       -0.040580178423281,  1.112256869616830, -0.071676678665601,\n+       -0.076381284505707, -0.421481978418013,  1.586163220440795\n+    };\n+\n+    cmsStage* D65toLMS = cmsStageAllocMatrix(ctx, 3, 3, M_D65_LMS, NULL);\n+    cmsStage* LMStoD65 = cmsStageAllocMatrix(ctx, 3, 3, M_LMS_D65, NULL);\n+\n+    cmsToneCurve* CubeRoot = cmsBuildGamma(ctx, 1.0 \/ 3.0);\n+    cmsToneCurve* Cube     = cmsBuildGamma(ctx,  3.0);\n+\n+    cmsToneCurve* Roots[3] = { CubeRoot, CubeRoot, CubeRoot };\n+    cmsToneCurve* Cubes[3] = { Cube, Cube, Cube };\n+\n+    cmsStage* NonLinearityFw = cmsStageAllocToneCurves(ctx, 3, Roots);\n+    cmsStage* NonLinearityRv = cmsStageAllocToneCurves(ctx, 3, Cubes);\n+\n+    const double M_LMSprime_OkLab[] =\n+    {\n+        0.2104542553,  0.7936177850, -0.0040720468,\n+        1.9779984951, -2.4285922050,  0.4505937099,\n+        0.0259040371,  0.7827717662, -0.8086757660\n+    };\n+\n+    const double M_OkLab_LMSprime[] =\n+    {\n+        0.999999998450520,  0.396337792173768,  0.215803758060759,\n+        1.000000008881761, -0.105561342323656, -0.063854174771706,\n+        1.000000054672411, -0.089484182094966, -1.291485537864092\n+    };\n+\n+    cmsStage* LMSprime_OkLab = cmsStageAllocMatrix(ctx, 3, 3, M_LMSprime_OkLab, NULL);\n+    cmsStage* OkLab_LMSprime = cmsStageAllocMatrix(ctx, 3, 3, M_OkLab_LMSprime, NULL);\n+\n+    cmsPipeline* AToB = cmsPipelineAlloc(ctx, 3, 3);\n+    cmsPipeline* BToA = cmsPipelineAlloc(ctx, 3, 3);\n+\n+    cmsHPROFILE hProfile = cmsCreateProfilePlaceholder(ctx);\n+\n+    cmsSetProfileVersion(hProfile, 4.4);\n+\n+    cmsSetDeviceClass(hProfile, cmsSigColorSpaceClass);\n+    cmsSetColorSpace(hProfile, cmsSig3colorData);\n+    cmsSetPCS(hProfile, cmsSigXYZData);\n+\n+    cmsSetHeaderRenderingIntent(hProfile, INTENT_RELATIVE_COLORIMETRIC);\n+\n+    \/**\n+    * Conversion PCS (XYZ\/D50) to OkLab\n+    *\/\n+    if (!cmsPipelineInsertStage(BToA, cmsAT_END, PCSXYZ)) goto error;\n+    if (!cmsPipelineInsertStage(BToA, cmsAT_END, D50toD65)) goto error;\n+    if (!cmsPipelineInsertStage(BToA, cmsAT_END, D65toLMS)) goto error;\n+    if (!cmsPipelineInsertStage(BToA, cmsAT_END, NonLinearityFw)) goto error;\n+    if (!cmsPipelineInsertStage(BToA, cmsAT_END, LMSprime_OkLab)) goto error;\n+\n+    if (!cmsWriteTag(hProfile, cmsSigBToA0Tag, BToA)) goto error;\n+\n+    if (!cmsPipelineInsertStage(AToB, cmsAT_END, OkLab_LMSprime)) goto error;\n+    if (!cmsPipelineInsertStage(AToB, cmsAT_END, NonLinearityRv)) goto error;\n+    if (!cmsPipelineInsertStage(AToB, cmsAT_END, LMStoD65)) goto error;\n+    if (!cmsPipelineInsertStage(AToB, cmsAT_END, D65toD50)) goto error;\n+    if (!cmsPipelineInsertStage(AToB, cmsAT_END, XYZPCS)) goto error;\n+\n+    if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, AToB)) goto error;\n+\n+    cmsPipelineFree(BToA);\n+    cmsPipelineFree(AToB);\n+\n+    cmsFreeToneCurve(CubeRoot);\n+    cmsFreeToneCurve(Cube);\n+\n+    return hProfile;\n+\n+error:\n+    cmsPipelineFree(BToA);\n+    cmsPipelineFree(AToB);\n+\n+    cmsFreeToneCurve(CubeRoot);\n+    cmsFreeToneCurve(Cube);\n+    cmsCloseProfile(hProfile);\n+\n+    return NULL;\n+\n+}\n@@ -871,1 +991,1 @@\n-    cmsSetProfileVersion(hProfile, 4.3);\n+    cmsSetProfileVersion(hProfile, 4.4);\n@@ -1006,1 +1126,1 @@\n-        | BYTES_SH(2) | CHANNELS_SH(cmsChannelsOf(v ->ExitColorSpace)));\n+        | BYTES_SH(2) | CHANNELS_SH(cmsChannelsOfColorSpace(v ->ExitColorSpace)));\n@@ -1063,1 +1183,1 @@\n-        if (n > Tab ->nTypes) return FALSE;\n+        if (n >= Tab ->nTypes) return FALSE;\n@@ -1094,1 +1214,2 @@\n-    cmsUInt32Number FrmIn, FrmOut, ChansIn, ChansOut;\n+    cmsUInt32Number FrmIn, FrmOut;\n+    cmsInt32Number ChansIn, ChansOut;\n@@ -1106,0 +1227,3 @@\n+    \/\/ Check if the pipeline holding is valid\n+    if (xform -> Lut == NULL) return NULL;\n+\n@@ -1146,2 +1270,2 @@\n-    ChansIn  = cmsChannelsOf(xform -> EntryColorSpace);\n-    ChansOut = cmsChannelsOf(xform -> ExitColorSpace);\n+    ChansIn  = cmsChannelsOfColorSpace(xform -> EntryColorSpace);\n+    ChansOut = cmsChannelsOfColorSpace(xform -> ExitColorSpace);\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsvirt.c","additions":144,"deletions":20,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -247,0 +247,4 @@\n+    if ((fabs(ConeSourceRGB.n[0]) < MATRIX_DET_TOLERANCE) ||\n+        (fabs(ConeSourceRGB.n[1]) < MATRIX_DET_TOLERANCE) ||\n+        (fabs(ConeSourceRGB.n[2]) < MATRIX_DET_TOLERANCE)) return FALSE;\n+\n@@ -252,1 +256,0 @@\n-\n@@ -296,1 +299,1 @@\n-\/\/ aspects of the RGB to XYZ process, and assumming that the gamma correction\n+\/\/ aspects of the RGB to XYZ process, and assuming that the gamma correction\n@@ -299,1 +302,1 @@\n-\/\/ the alghoritm:\n+\/\/ the algorithm:\n@@ -304,2 +307,2 @@\n-\/\/              obtaining the coeficients of the transformation\n-\/\/            - Then, I apply these coeficients to the original matrix\n+\/\/              obtaining the coefficients of the transformation\n+\/\/            - Then, I apply these coefficients to the original matrix\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmswtpnt.c","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -316,1 +316,1 @@\n-            \/\/ Any gamut chack to do?\n+            \/\/ Any gamut check to do?\n@@ -813,0 +813,67 @@\n+\/\/ Returns the worker callback for parallelization plug-ins\n+_cmsTransform2Fn CMSEXPORT _cmsGetTransformWorker(struct _cmstransform_struct* CMMcargo)\n+{\n+    _cmsAssert(CMMcargo != NULL);\n+    return CMMcargo->Worker;\n+}\n+\n+\/\/ This field holds maximum number of workers or -1 to auto\n+cmsInt32Number CMSEXPORT _cmsGetTransformMaxWorkers(struct _cmstransform_struct* CMMcargo)\n+{\n+    _cmsAssert(CMMcargo != NULL);\n+    return CMMcargo->MaxWorkers;\n+}\n+\n+\/\/ This field is actually unused and reserved\n+cmsUInt32Number CMSEXPORT _cmsGetTransformWorkerFlags(struct _cmstransform_struct* CMMcargo)\n+{\n+    _cmsAssert(CMMcargo != NULL);\n+    return CMMcargo->WorkerFlags;\n+}\n+\n+\/\/ In the case there is a parallelization plug-in, let it to do its job\n+static\n+void ParalellizeIfSuitable(_cmsTRANSFORM* p)\n+{\n+    _cmsParallelizationPluginChunkType* ctx = (_cmsParallelizationPluginChunkType*)_cmsContextGetClientChunk(p->ContextID, ParallelizationPlugin);\n+\n+    _cmsAssert(p != NULL);\n+    if (ctx != NULL && ctx->SchedulerFn != NULL) {\n+\n+        p->Worker = p->xform;\n+        p->xform = ctx->SchedulerFn;\n+        p->MaxWorkers = ctx->MaxWorkers;\n+        p->WorkerFlags = ctx->WorkerFlags;\n+    }\n+}\n+\n+\n+\/**\n+* An empty unroll to avoid a check with NULL on cmsDoTransform()\n+*\/\n+static\n+cmsUInt8Number* UnrollNothing(CMSREGISTER _cmsTRANSFORM* info,\n+                              CMSREGISTER cmsUInt16Number wIn[],\n+                              CMSREGISTER cmsUInt8Number* accum,\n+                              CMSREGISTER cmsUInt32Number Stride)\n+{\n+    return accum;\n+\n+    cmsUNUSED_PARAMETER(info);\n+    cmsUNUSED_PARAMETER(wIn);\n+    cmsUNUSED_PARAMETER(Stride);\n+}\n+\n+static\n+cmsUInt8Number* PackNothing(CMSREGISTER _cmsTRANSFORM* info,\n+                           CMSREGISTER cmsUInt16Number wOut[],\n+                           CMSREGISTER cmsUInt8Number* output,\n+                           CMSREGISTER cmsUInt32Number Stride)\n+{\n+    return output;\n+\n+    cmsUNUSED_PARAMETER(info);\n+    cmsUNUSED_PARAMETER(wOut);\n+    cmsUNUSED_PARAMETER(Stride);\n+}\n+\n@@ -868,0 +935,1 @@\n+                       ParalellizeIfSuitable(p);\n@@ -878,1 +946,1 @@\n-    if (_cmsFormatterIsFloat(*InputFormat) && _cmsFormatterIsFloat(*OutputFormat)) {\n+    if (_cmsFormatterIsFloat(*InputFormat) || _cmsFormatterIsFloat(*OutputFormat)) {\n@@ -904,0 +972,1 @@\n+        \/\/ Formats are intended to be changed before use\n@@ -905,1 +974,2 @@\n-            p ->FromInput = p ->ToOutput = NULL;\n+            p->FromInput = UnrollNothing;\n+            p->ToOutput = PackNothing;\n@@ -922,1 +992,1 @@\n-            BytesPerPixelInput = T_BYTES(p ->InputFormat);\n+            BytesPerPixelInput = T_BYTES(*InputFormat);\n@@ -951,0 +1021,13 @@\n+    \/**\n+    * Check consistency for alpha channel copy\n+    *\/\n+    if (*dwFlags & cmsFLAGS_COPY_ALPHA)\n+    {\n+        if (T_EXTRA(*InputFormat) != T_EXTRA(*OutputFormat))\n+        {\n+            cmsSignalError(ContextID, cmsERROR_NOT_SUITABLE, \"Mismatched alpha channels\");\n+            cmsDeleteTransform(p);\n+            return NULL;\n+        }\n+    }\n+\n@@ -956,0 +1039,1 @@\n+    ParalellizeIfSuitable(p);\n@@ -1113,0 +1197,9 @@\n+    \/\/ Check whatever the transform is 16 bits and involves linear RGB in first profile. If so, disable optimizations\n+    if (EntryColorSpace == cmsSigRgbData && T_BYTES(InputFormat) == 2 && !(dwFlags & cmsFLAGS_NOOPTIMIZE))\n+    {\n+        cmsFloat64Number gamma = cmsDetectRGBProfileGamma(hProfiles[0], 0.1);\n+\n+        if (gamma > 0 && gamma < 1.6)\n+            dwFlags |= cmsFLAGS_NOOPTIMIZE;\n+    }\n+\n@@ -1121,2 +1214,2 @@\n-    if ((cmsChannelsOf(EntryColorSpace) != cmsPipelineInputChannels(Lut)) ||\n-        (cmsChannelsOf(ExitColorSpace)  != cmsPipelineOutputChannels(Lut))) {\n+    if ((cmsChannelsOfColorSpace(EntryColorSpace) != (cmsInt32Number) cmsPipelineInputChannels(Lut)) ||\n+        (cmsChannelsOfColorSpace(ExitColorSpace)  != (cmsInt32Number) cmsPipelineOutputChannels(Lut))) {\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsxform.c","additions":100,"deletions":7,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2021 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -55,1 +55,1 @@\n-\/\/ Version 2.12\n+\/\/ Version 2.16\n@@ -108,0 +108,3 @@\n+#       if __cplusplus >= 201703L\n+#            define CMS_NO_REGISTER_KEYWORD 1\n+#       endif\n@@ -113,1 +116,1 @@\n-#define LCMS_VERSION        2120\n+#define LCMS_VERSION        2160\n@@ -184,1 +187,1 @@\n-#if defined(CMS_NO_REGISTER_KEYWORD) && !defined(CMS_DLL) && !defined(CMS_DLL_BUILD)\n+#if defined(CMS_NO_REGISTER_KEYWORD)\n@@ -259,1 +262,1 @@\n-#ifdef CMS_IS_WINDOWS_\n+#if defined(CMS_IS_WINDOWS_) && !defined(__GNUC__)\n@@ -322,0 +325,1 @@\n+    cmsSigcicpType                          = 0x63696370,  \/\/ 'cicp'\n@@ -356,1 +360,2 @@\n-    cmsSigXYZType                           = 0x58595A20   \/\/ 'XYZ '\n+    cmsSigXYZType                           = 0x58595A20,  \/\/ 'XYZ '\n+    cmsSigMHC2Type                          = 0x4D484332   \/\/ 'MHC2'\n@@ -433,1 +438,3 @@\n-    cmsSigArgyllArtsTag                     = 0x61727473   \/\/ 'arts'\n+    cmsSigcicpTag                           = 0x63696370,  \/\/ 'cicp'\n+    cmsSigArgyllArtsTag                     = 0x61727473,  \/\/ 'arts'\n+    cmsSigMHC2Tag                           = 0x4D484332   \/\/ 'MHC2'\n@@ -698,2 +705,2 @@\n-\/\/                          3 2 10987 6 5 4 3 2 1 098 7654 321\n-\/\/                          A O TTTTT U Y F P X S EEE CCCC BBB\n+\/\/                        4 3 2 10987 6 5 4 3 2 1 098 7654 321\n+\/\/                        M A O TTTTT U Y F P X S EEE CCCC BBB\n@@ -701,0 +708,1 @@\n+\/\/            M: Premultiplied alpha (only works when extra samples is 1)\n@@ -713,0 +721,1 @@\n+#define PREMUL_SH(m)           ((m) << 23)\n@@ -726,0 +735,1 @@\n+#define T_PREMUL(m)           (((m)>>23)&1)\n@@ -754,1 +764,0 @@\n-\n@@ -770,1 +779,0 @@\n-\n@@ -784,0 +792,1 @@\n+#define TYPE_GRAYA_8_PREMUL    (COLORSPACE_SH(PT_GRAY)|EXTRA_SH(1)|CHANNELS_SH(1)|BYTES_SH(1)|PREMUL_SH(1))\n@@ -785,0 +794,1 @@\n+#define TYPE_GRAYA_16_PREMUL   (COLORSPACE_SH(PT_GRAY)|EXTRA_SH(1)|CHANNELS_SH(1)|BYTES_SH(2)|PREMUL_SH(1))\n@@ -801,0 +811,1 @@\n+#define TYPE_RGBA_8_PREMUL     (COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(1)|PREMUL_SH(1))\n@@ -803,0 +814,1 @@\n+#define TYPE_RGBA_16_PREMUL    (COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(2)|PREMUL_SH(1))\n@@ -807,0 +819,1 @@\n+#define TYPE_ARGB_8_PREMUL     (COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(1)|SWAPFIRST_SH(1)|PREMUL_SH(1))\n@@ -809,0 +822,1 @@\n+#define TYPE_ARGB_16_PREMUL    (COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(2)|SWAPFIRST_SH(1)|PREMUL_SH(1))\n@@ -811,0 +825,1 @@\n+#define TYPE_ABGR_8_PREMUL     (COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(1)|DOSWAP_SH(1)|PREMUL_SH(1))\n@@ -813,0 +828,1 @@\n+#define TYPE_ABGR_16_PREMUL    (COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(2)|DOSWAP_SH(1)|PREMUL_SH(1))\n@@ -817,0 +833,1 @@\n+#define TYPE_BGRA_8_PREMUL     (COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(1)|DOSWAP_SH(1)|SWAPFIRST_SH(1)|PREMUL_SH(1))\n@@ -819,0 +836,1 @@\n+#define TYPE_BGRA_16_PREMUL    (COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(2)|DOSWAP_SH(1)|SWAPFIRST_SH(1)|PREMUL_SH(1))\n@@ -935,1 +953,1 @@\n-\/\/ Named color index. Only 16 bits allowed (don't check colorspace)\n+\/\/ Named color index. Only 16 bits is allowed (don't check colorspace)\n@@ -943,0 +961,2 @@\n+#define TYPE_GRAYA_FLT        (FLOAT_SH(1)|COLORSPACE_SH(PT_GRAY)|CHANNELS_SH(1)|BYTES_SH(4)|EXTRA_SH(1))\n+#define TYPE_GRAYA_FLT_PREMUL (FLOAT_SH(1)|COLORSPACE_SH(PT_GRAY)|CHANNELS_SH(1)|BYTES_SH(4)|EXTRA_SH(1)|PREMUL_SH(1))\n@@ -946,0 +966,1 @@\n+#define TYPE_RGBA_FLT_PREMUL  (FLOAT_SH(1)|COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(4)|PREMUL_SH(1))\n@@ -947,0 +968,1 @@\n+#define TYPE_ARGB_FLT_PREMUL  (FLOAT_SH(1)|COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(4)|SWAPFIRST_SH(1)|PREMUL_SH(1))\n@@ -949,0 +971,1 @@\n+#define TYPE_BGRA_FLT_PREMUL  (FLOAT_SH(1)|COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(4)|DOSWAP_SH(1)|SWAPFIRST_SH(1)|PREMUL_SH(1))\n@@ -950,0 +973,1 @@\n+#define TYPE_ABGR_FLT_PREMUL  (FLOAT_SH(1)|COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(4)|DOSWAP_SH(1)|PREMUL_SH(1))\n@@ -961,0 +985,1 @@\n+#define TYPE_OKLAB_DBL        (FLOAT_SH(1)|COLORSPACE_SH(PT_MCH3)|CHANNELS_SH(3)|BYTES_SH(0))\n@@ -1053,0 +1078,23 @@\n+typedef struct {\n+    cmsUInt8Number  ColourPrimaries;            \/\/ Recommendation ITU-T H.273\n+    cmsUInt8Number  TransferCharacteristics;    \/\/  (ISO\/IEC 23091-2)\n+    cmsUInt8Number  MatrixCoefficients;\n+    cmsUInt8Number  VideoFullRangeFlag;\n+\n+} cmsVideoSignalType;\n+\n+typedef struct {\n+    cmsUInt32Number   CurveEntries;\n+    cmsFloat64Number* RedCurve;\n+    cmsFloat64Number* GreenCurve;\n+    cmsFloat64Number* BlueCurve;\n+\n+    cmsFloat64Number  MinLuminance;         \/\/ ST.2086 min luminance in nits\n+    cmsFloat64Number  PeakLuminance;        \/\/ ST.2086 peak luminance in nits\n+\n+    cmsFloat64Number XYZ2XYZmatrix[3][4];\n+\n+} cmsMHC2Type;\n+\n+\n+\n@@ -1223,1 +1271,2 @@\n-CMSAPI cmsFloat64Number* CMSEXPORT cmsGetToneCurveParams(const cmsToneCurve* t);\n+\n+CMSAPI const cmsCurveSegment* CMSEXPORT cmsGetToneCurveSegment(cmsInt32Number n, const cmsToneCurve* t);\n@@ -1288,0 +1337,1 @@\n+CMSAPI cmsContext        CMSEXPORT cmsGetStageContextID(const cmsStage* mpe);\n@@ -1316,2 +1366,5 @@\n-#define  cmsNoLanguage \"\\0\\0\"\n-#define  cmsNoCountry  \"\\0\\0\"\n+#define  cmsNoLanguage    \"\\0\\0\"\n+#define  cmsNoCountry     \"\\0\\0\"\n+\n+\/\/ Special language\/country to retrieve unicode field for description in V2 profiles. Use with care.\n+#define  cmsV2Unicode     \"\\xff\\xff\"\n@@ -1329,0 +1382,3 @@\n+CMSAPI cmsBool           CMSEXPORT cmsMLUsetUTF8(cmsMLU* mlu,\n+                                                  const char LanguageCode[3], const char CountryCode[3],\n+                                                  const char* UTF8String);\n@@ -1337,0 +1393,4 @@\n+CMSAPI cmsUInt32Number   CMSEXPORT cmsMLUgetUTF8(const cmsMLU* mlu,\n+                                                 const char LanguageCode[3], const char CountryCode[3],\n+                                                 char* Buffer, cmsUInt32Number BufferSize);\n+\n@@ -1534,0 +1594,1 @@\n+\/\/ Deprecated, use cmsChannelsOfColorSpace instead\n@@ -1536,0 +1597,3 @@\n+\/\/ Get number of channels of color space or -1 if color space is not listed\/supported\n+CMSAPI cmsInt32Number CMSEXPORT cmsChannelsOfColorSpace(cmsColorSpaceSignature ColorSpace);\n+\n@@ -1557,0 +1621,4 @@\n+CMSAPI cmsUInt32Number  CMSEXPORT cmsGetProfileInfoUTF8(cmsHPROFILE hProfile, cmsInfoType Info,\n+                                                            const char LanguageCode[3], const char CountryCode[3],\n+                                                            char* Buffer, cmsUInt32Number BufferSize);\n+\n@@ -1619,0 +1687,3 @@\n+CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateDeviceLinkFromCubeFile(const char* cFileName);\n+\n+CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateDeviceLinkFromCubeFileTHR(cmsContext ContextID, const char* cFileName);\n@@ -1631,0 +1702,2 @@\n+CMSAPI cmsHPROFILE      CMSEXPORT cmsCreate_OkLabProfile(cmsContext ctx);\n+\n@@ -1938,0 +2011,2 @@\n+\/\/ Estimate gamma space, always positive. Returns -1 on error.\n+CMSAPI cmsFloat64Number CMSEXPORT cmsDetectRGBProfileGamma(cmsHPROFILE hProfile, cmsFloat64Number threshold);\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/lcms2.h","additions":90,"deletions":15,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-\n@@ -33,1 +32,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -292,0 +291,1 @@\n+#          pragma warning(disable : 4127)\n@@ -315,2 +315,2 @@\n-        EnterCriticalSection(m);\n-        return 0;\n+    EnterCriticalSection(m);\n+    return 0;\n@@ -321,2 +321,2 @@\n-        LeaveCriticalSection(m);\n-        return 0;\n+    LeaveCriticalSection(m);\n+    return 0;\n@@ -327,2 +327,2 @@\n-        InitializeCriticalSection(m);\n-        return 0;\n+    InitializeCriticalSection(m);\n+    return 0;\n@@ -333,2 +333,2 @@\n-        DeleteCriticalSection(m);\n-        return 0;\n+    DeleteCriticalSection(m);\n+    return 0;\n@@ -339,2 +339,2 @@\n-        EnterCriticalSection(m);\n-        return 0;\n+    EnterCriticalSection(m);\n+    return 0;\n@@ -345,2 +345,2 @@\n-        LeaveCriticalSection(m);\n-        return 0;\n+    LeaveCriticalSection(m);\n+    return 0;\n@@ -360,1 +360,1 @@\n-        return pthread_mutex_lock(m);\n+    return pthread_mutex_lock(m);\n@@ -365,1 +365,1 @@\n-        return pthread_mutex_unlock(m);\n+    return pthread_mutex_unlock(m);\n@@ -370,1 +370,1 @@\n-        return pthread_mutex_init(m, NULL);\n+    return pthread_mutex_init(m, NULL);\n@@ -375,1 +375,1 @@\n-        return pthread_mutex_destroy(m);\n+    return pthread_mutex_destroy(m);\n@@ -380,1 +380,1 @@\n-        return pthread_mutex_lock(m);\n+    return pthread_mutex_lock(m);\n@@ -385,1 +385,1 @@\n-        return pthread_mutex_unlock(m);\n+    return pthread_mutex_unlock(m);\n@@ -398,1 +398,1 @@\n-        return 0;\n+    return 0;\n@@ -404,1 +404,1 @@\n-        return 0;\n+    return 0;\n@@ -410,1 +410,1 @@\n-        return 0;\n+    return 0;\n@@ -416,1 +416,1 @@\n-        return 0;\n+    return 0;\n@@ -422,1 +422,1 @@\n-        return 0;\n+    return 0;\n@@ -428,1 +428,1 @@\n-        return 0;\n+    return 0;\n@@ -470,0 +470,3 @@\n+\/\/ Paralellization\n+cmsBool _cmsRegisterParallelizationPlugin(cmsContext ContextID, cmsPluginBase* Plugin);\n+\n@@ -517,0 +520,1 @@\n+    ParallelizationPlugin,\n@@ -545,1 +549,1 @@\n-    void* chunks[MemoryClientMax];    \/\/ array of pointers to client chunks. Memory itself is hold in the suballocator.\n+    void* chunks[MemoryClientMax];    \/\/ array of pointers to client chunks. Memory itself is held in the suballocator.\n@@ -752,0 +756,18 @@\n+\/\/ Container for parallelization plug-in\n+typedef struct {\n+\n+    cmsInt32Number      MaxWorkers;       \/\/ Number of workers to do as maximum\n+    cmsInt32Number      WorkerFlags;      \/\/ reserved\n+    _cmsTransform2Fn    SchedulerFn;      \/\/ callback to setup functions\n+\n+} _cmsParallelizationPluginChunkType;\n+\n+\/\/ The global Context0 storage for parallelization plug-in\n+extern  _cmsParallelizationPluginChunkType _cmsParallelizationPluginChunk;\n+\n+\/\/ Allocate parallelization container.\n+void _cmsAllocParallelizationPluginChunk(struct _cmsContext_struct* ctx,\n+                                         const struct _cmsContext_struct* src);\n+\n+\n+\n@@ -821,0 +843,3 @@\n+    \/\/ Color management module identification\n+    cmsUInt32Number          CMM;\n+\n@@ -828,0 +853,1 @@\n+    cmsPlatformSignature     platform;\n@@ -1113,0 +1139,5 @@\n+    \/\/ A one-worker transform entry for parallelization\n+    _cmsTransform2Fn Worker;\n+    cmsInt32Number   MaxWorkers;\n+    cmsUInt32Number  WorkerFlags;\n+\n@@ -1150,0 +1181,3 @@\n+\/\/ thread-safe gettime\n+cmsBool _cmsGetTime(struct tm* ptr_time);\n+\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/lcms2_internal.h","additions":61,"deletions":27,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2020 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -56,1 +56,1 @@\n-\/\/ It is provided for plug-in writters that may want to access the support\n+\/\/ It is provided for plug-in writers that may want to access the support\n@@ -241,0 +241,1 @@\n+#define cmsPluginParalellizationSig          0x70726C48     \/\/ 'prlH\n@@ -628,1 +629,1 @@\n-                                     cmsUInt32Number Stride);                 \/\/ Stride in bytes to the next plana in planar formats\n+                                     cmsUInt32Number Stride);                 \/\/ Stride in bytes to the next plane in planar formats\n@@ -701,0 +702,19 @@\n+\/\/----------------------------------------------------------------------------------------------------------\n+\/\/ Parallelization\n+\n+CMSAPI _cmsTransform2Fn CMSEXPORT _cmsGetTransformWorker(struct _cmstransform_struct* CMMcargo);\n+CMSAPI cmsInt32Number   CMSEXPORT _cmsGetTransformMaxWorkers(struct _cmstransform_struct* CMMcargo);\n+CMSAPI cmsUInt32Number  CMSEXPORT _cmsGetTransformWorkerFlags(struct _cmstransform_struct* CMMcargo);\n+\n+\/\/ Let's plug-in to guess the best number of workers\n+#define CMS_GUESS_MAX_WORKERS -1\n+\n+typedef struct {\n+    cmsPluginBase       base;\n+\n+    cmsInt32Number      MaxWorkers;       \/\/ Number of starts to do as maximum\n+    cmsUInt32Number     WorkerFlags;      \/\/ Reserved\n+    _cmsTransform2Fn    SchedulerFn;      \/\/ callback to setup functions\n+\n+}  cmsPluginParalellization;\n+\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/lcms2_plugin.h","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"}]}