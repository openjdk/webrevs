{"files":[{"patch":"@@ -156,0 +156,1 @@\n+  compiler\/8009761\/Test8009761.java \\\n","filename":"hotspot\/test\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -24,0 +24,7 @@\n+import com.sun.management.HotSpotDiagnosticMXBean;\n+import com.sun.management.VMOption;\n+import sun.hotspot.WhiteBox;\n+import sun.management.ManagementFactoryHelper;\n+\n+import java.lang.reflect.Method;\n+\n@@ -27,0 +34,1 @@\n+ * @library \/testlibrary \/testlibrary\/whitebox\n@@ -28,2 +36,3 @@\n- * @run main\/othervm -XX:CompileCommand=exclude,Test8009761::m2 -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -Xss512K Test8009761\n- *\n+ * @build Test8009761\n+ * @run main ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:CompileCommand=exclude,Test8009761::m2 -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -Xss512K Test8009761\n@@ -34,3 +43,3 @@\n-    static class UnloadedClass {\n-        volatile int i;\n-    }\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    private static int COMP_LEVEL_FULL_OPTIMIZATION = 4;\n+    private static Method m3 = null;\n@@ -145,3 +154,5 @@\n-            UnloadedClass res = new UnloadedClass(); \/\/ sufficient to force deopt with c2 but not c1\n-            res.i = 0; \/\/ forces deopt with c1\n-            return res;\n+            \/\/ Force deoptimization of m3\n+            WHITE_BOX.deoptimizeMethod(m3);\n+            if(WHITE_BOX.isMethodCompiled(m3)) {\n+                throw new RuntimeException(m3 + \" not deoptimized\");\n+            }\n@@ -228,0 +239,12 @@\n+        \/\/ Make sure background compilation is disabled\n+        if (backgroundCompilationEnabled()) {\n+            throw new RuntimeException(\"Background compilation enabled\");\n+        }\n+\n+        try {\n+            \/\/ Get Method object for m3\n+            m3 = Test8009761.class.getDeclaredMethod(\"m3\", boolean.class, boolean.class);\n+        } catch (NoSuchMethodException | SecurityException ex) {\n+            throw new RuntimeException(\"Failed to retrieve method m3\");\n+        }\n+\n@@ -235,0 +258,1 @@\n+\n@@ -236,2 +260,4 @@\n-        for (int i = 0; i < 20000; i++) {\n-            m3(false, false);\n+        WHITE_BOX.enqueueMethodForCompilation(m3, COMP_LEVEL_FULL_OPTIMIZATION);\n+        \/\/ Because background compilation is disabled, method should now be compiled\n+        if(!WHITE_BOX.isMethodCompiled(m3)) {\n+            throw new RuntimeException(m3 + \" not compiled\");\n@@ -239,0 +265,1 @@\n+\n@@ -248,3 +275,3 @@\n-        if (c1 != count) {\n-            System.out.println(\"Failed: init recursive calls: \" + c1 + \". After deopt \" + count);\n-            System.exit(97);\n+        \/\/ Allow number of recursive calls to vary by 1\n+        if ((c1 < (count - 1)) || (c1 > (count + 1))) {\n+            throw new RuntimeException(\"Failed: init recursive calls: \" + c1 + \". After deopt \" + count);\n@@ -255,0 +282,15 @@\n+\n+    \/**\n+     * Checks if background compilation (-XX:+BackgroundCompilation) is enabled.\n+     * @return True if background compilation is enabled, false otherwise\n+     *\/\n+    private static boolean backgroundCompilationEnabled() {\n+      HotSpotDiagnosticMXBean diagnostic = ManagementFactoryHelper.getDiagnosticMXBean();\n+      VMOption backgroundCompilation;\n+      try {\n+          backgroundCompilation = diagnostic.getVMOption(\"BackgroundCompilation\");\n+      } catch (IllegalArgumentException e) {\n+          return false;\n+      }\n+      return Boolean.valueOf(backgroundCompilation.getValue());\n+    }\n","filename":"hotspot\/test\/compiler\/8009761\/Test8009761.java","additions":55,"deletions":13,"binary":false,"changes":68,"status":"modified"}]}