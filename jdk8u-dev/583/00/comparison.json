{"files":[{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8196770\n+ * @summary Verify capability to add a new entry to the directory using the\n+ *          ADD operation.\n+ * @library ..\/..\/lib\/\n+ * @build LDAPServer LDAPTestUtils\n+ * @run main\/othervm AddNewEntry\n+ *\/\n+\n+import javax.naming.NamingEnumeration;\n+import javax.naming.directory.Attribute;\n+import javax.naming.directory.Attributes;\n+import javax.naming.directory.BasicAttribute;\n+import javax.naming.directory.BasicAttributes;\n+import javax.naming.directory.DirContext;\n+import javax.naming.directory.InitialDirContext;\n+import javax.naming.directory.SearchControls;\n+import java.net.ServerSocket;\n+import java.util.Hashtable;\n+\n+public class AddNewEntry {\n+\n+    public static void main(String[] args) throws Exception {\n+        ServerSocket serverSocket = new ServerSocket(0);\n+\n+        Hashtable<Object, Object> env;\n+\n+        \/\/ initialize test\n+        env = LDAPTestUtils\n+                .initEnv(serverSocket, AddNewEntry.class.getName(), args, true);\n+\n+        \/* Build attribute set *\/\n+        String[] ids = { \"objectClass\", \"sn\", \"cn\", \"telephoneNumber\", \"mail\",\n+                \"description\", \"uid\" };\n+        Attribute objectClass = new BasicAttribute(ids[0]);\n+        objectClass.add(\"top\");\n+        objectClass.add(\"person\");\n+        objectClass.add(\"organizationalPerson\");\n+        objectClass.add(\"inetOrgPerson\");\n+\n+        Attribute sn = new BasicAttribute(ids[1], \"Powers\");\n+        Attribute cn = new BasicAttribute(ids[2],\n+                \"Austin \\\\\\\"Danger\\\\\\\" Powers\");\n+        Attribute telephoneNumber = new BasicAttribute(ids[3], \"+44 582 10101\");\n+        Attribute mail = new BasicAttribute(ids[4], \"secret_agent_man@imc.org\");\n+        Attribute description = new BasicAttribute(ids[5], \"Yea Baby!!\");\n+        description.add(\"Behave!\");\n+        Attribute uid = new BasicAttribute(ids[6], \"secret_agent_man\");\n+\n+        Attributes attrs = new BasicAttributes();\n+        attrs.put(objectClass);\n+        attrs.put(sn);\n+        attrs.put(cn);\n+        attrs.put(telephoneNumber);\n+        attrs.put(mail);\n+        attrs.put(description);\n+        attrs.put(uid);\n+\n+        DirContext ctx = null;\n+        String[] bases = new String[] { (String) env.get(\"client\"),\n+                (String) env.get(\"vendor\"), \"Add\" };\n+        String baseDN = LDAPTestUtils.buildDN(bases, (String) env.get(\"root\"));\n+        String entryDN = \"cn=Austin Powers,\" + baseDN;\n+        String expect = \"\"; \/\/ relative name\n+\n+        try {\n+            \/\/ connect to server\n+            ctx = new InitialDirContext(env);\n+\n+            \/\/ add entry\n+            ctx.createSubcontext(entryDN, attrs);\n+\n+            \/\/ specify base search\n+            SearchControls constraints = new SearchControls();\n+            constraints.setSearchScope(SearchControls.OBJECT_SCOPE);\n+\n+            NamingEnumeration results = ctx\n+                    .search(entryDN, \"(objectclass=*)\", constraints);\n+\n+            int found = LDAPTestUtils.checkResult(results, expect);\n+\n+            if (found != 1) {\n+                throw new RuntimeException(\n+                        \"Check result failed, expect found 1 but actual is \"\n+                                + found);\n+            }\n+\n+        } finally {\n+            LDAPTestUtils.cleanupSubcontext(ctx, entryDN);\n+            LDAPTestUtils.cleanup(ctx);\n+        }\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jndi\/ldap\/blits\/AddTests\/AddNewEntry.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+#\n+# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+################################################################################\n+# Capture file for AddNewEntry.java\n+#\n+# NOTE: This hexadecimal dump of LDAP protocol messages was generated by\n+#       running the AddNewEntry application program against a real LDAP\n+#       server and setting the JNDI\/LDAP environment property:\n+#       com.sun.jndi.ldap.trace.ber to activate LDAP message tracing.\n+#\n+################################################################################\n+\n+\n+# LDAP BindRequest\n+\n+0000: 30 27 02 01 01 60 22 02   01 03 04 13 63 6E 3D 61  0'...`\".....cn=a\n+0010: 64 6D 69 6E 2C 6F 3D 49   4D 43 2C 63 3D 55 53 80  dmin,o=IMC,c=US.\n+0020: 08 73 65 63 72 65 74 39   39                       .secret99\n+\n+\n+# LDAP BindResponse\n+\n+0000: 30 0C 02 01 01 61 07 0A   01 00 04 00 04 00        0....a........\n+\n+\n+# LDAP AddRequest\n+\n+0000: 30 82 01 5F 02 01 02 68   82 01 3B 04 38 63 6E 3D  0.._...h..;.8cn=\n+0010: 41 75 73 74 69 6E 20 50   6F 77 65 72 73 2C 6F 75  Austin Powers,ou\n+0020: 3D 43 6C 69 65 6E 74 31   2C 6F 75 3D 56 65 6E 64  =Client1,ou=Vend\n+0030: 6F 72 31 2C 6F 75 3D 41   64 64 2C 6F 3D 49 4D 43  or1,ou=Add,o=IMC\n+0040: 2C 63 3D 55 53 30 81 FE   30 41 04 0B 6F 62 6A 65  ,c=US0..0A..obje\n+0050: 63 74 43 6C 61 73 73 31   32 04 03 74 6F 70 04 06  ctClass12..top..\n+0060: 70 65 72 73 6F 6E 04 14   6F 72 67 61 6E 69 7A 61  person..organiza\n+0070: 74 69 6F 6E 61 6C 50 65   72 73 6F 6E 04 0D 69 6E  tionalPerson..in\n+0080: 65 74 4F 72 67 50 65 72   73 6F 6E 30 22 04 04 6D  etOrgPerson0\"..m\n+0090: 61 69 6C 31 1A 04 18 73   65 63 72 65 74 5F 61 67  ail1...secret_ag\n+00A0: 65 6E 74 5F 6D 61 6E 40   69 6D 63 2E 6F 72 67 30  ent_man@imc.org0\n+00B0: 19 04 03 75 69 64 31 12   04 10 73 65 63 72 65 74  ...uid1...secret\n+00C0: 5F 61 67 65 6E 74 5F 6D   61 6E 30 24 04 0B 64 65  _agent_man0$..de\n+00D0: 73 63 72 69 70 74 69 6F   6E 31 15 04 0A 59 65 61  scription1...Yea\n+00E0: 20 42 61 62 79 21 21 04   07 42 65 68 61 76 65 21   Baby!!..Behave!\n+00F0: 30 0E 04 02 73 6E 31 08   04 06 50 6F 77 65 72 73  0...sn1...Powers\n+0100: 30 22 04 0F 74 65 6C 65   70 68 6F 6E 65 4E 75 6D  0\"..telephoneNum\n+0110: 62 65 72 31 0F 04 0D 2B   34 34 20 35 38 32 20 31  ber1...+44 582 1\n+0120: 30 31 30 31 30 20 04 02   63 6E 31 1A 04 18 41 75  01010 ..cn1...Au\n+0130: 73 74 69 6E 20 5C 22 44   61 6E 67 65 72 5C 22 20  stin \\\"Danger\\\" \n+0140: 50 6F 77 65 72 73 A0 1B   30 19 04 17 32 2E 31 36  Powers..0...2.16\n+0150: 2E 38 34 30 2E 31 2E 31   31 33 37 33 30 2E 33 2E  .840.1.113730.3.\n+0160: 34 2E 32                                           4.2\n+\n+\n+# LDAP AddResponse\n+\n+0000: 30 0C 02 01 02 69 07 0A   01 00 04 00 04 00        0....i........\n+\n+\n+# LDAP SearchRequest\n+\n+0000: 30 7A 02 01 03 63 58 04   38 63 6E 3D 41 75 73 74  0z...cX.8cn=Aust\n+0010: 69 6E 20 50 6F 77 65 72   73 2C 6F 75 3D 43 6C 69  in Powers,ou=Cli\n+0020: 65 6E 74 31 2C 6F 75 3D   56 65 6E 64 6F 72 31 2C  ent1,ou=Vendor1,\n+0030: 6F 75 3D 41 64 64 2C 6F   3D 49 4D 43 2C 63 3D 55  ou=Add,o=IMC,c=U\n+0040: 53 0A 01 00 0A 01 03 02   01 00 02 01 00 01 01 00  S...............\n+0050: 87 0B 6F 62 6A 65 63 74   63 6C 61 73 73 30 00 A0  ..objectclass0..\n+0060: 1B 30 19 04 17 32 2E 31   36 2E 38 34 30 2E 31 2E  .0...2.16.840.1.\n+0070: 31 31 33 37 33 30 2E 33   2E 34 2E 32              113730.3.4.2\n+\n+\n+# LDAP SearchResultEntry\n+\n+0000: 30 82 01 52 02 01 03 64   82 01 4B 04 38 63 6E 3D  0..R...d..K.8cn=\n+0010: 41 75 73 74 69 6E 20 50   6F 77 65 72 73 2C 6F 75  Austin Powers,ou\n+0020: 3D 43 6C 69 65 6E 74 31   2C 6F 75 3D 56 65 6E 64  =Client1,ou=Vend\n+0030: 6F 72 31 2C 6F 75 3D 41   64 64 2C 6F 3D 49 4D 43  or1,ou=Add,o=IMC\n+0040: 2C 63 3D 55 53 30 82 01   0D 30 41 04 0B 6F 62 6A  ,c=US0...0A..obj\n+0050: 65 63 74 43 6C 61 73 73   31 32 04 03 74 6F 70 04  ectClass12..top.\n+0060: 06 70 65 72 73 6F 6E 04   14 6F 72 67 61 6E 69 7A  .person..organiz\n+0070: 61 74 69 6F 6E 61 6C 50   65 72 73 6F 6E 04 0D 69  ationalPerson..i\n+0080: 6E 65 74 4F 72 67 50 65   72 73 6F 6E 30 22 04 04  netOrgPerson0\"..\n+0090: 6D 61 69 6C 31 1A 04 18   73 65 63 72 65 74 5F 61  mail1...secret_a\n+00A0: 67 65 6E 74 5F 6D 61 6E   40 69 6D 63 2E 6F 72 67  gent_man@imc.org\n+00B0: 30 19 04 03 75 69 64 31   12 04 10 73 65 63 72 65  0...uid1...secre\n+00C0: 74 5F 61 67 65 6E 74 5F   6D 61 6E 30 24 04 0B 64  t_agent_man0$..d\n+00D0: 65 73 63 72 69 70 74 69   6F 6E 31 15 04 0A 59 65  escription1...Ye\n+00E0: 61 20 42 61 62 79 21 21   04 07 42 65 68 61 76 65  a Baby!!..Behave\n+00F0: 21 30 0E 04 02 73 6E 31   08 04 06 50 6F 77 65 72  !0...sn1...Power\n+0100: 73 30 22 04 0F 74 65 6C   65 70 68 6F 6E 65 4E 75  s0\"..telephoneNu\n+0110: 6D 62 65 72 31 0F 04 0D   2B 34 34 20 35 38 32 20  mber1...+44 582 \n+0120: 31 30 31 30 31 30 2F 04   02 63 6E 31 29 04 18 41  101010\/..cn1)..A\n+0130: 75 73 74 69 6E 20 5C 22   44 61 6E 67 65 72 5C 22  ustin \\\"Danger\\\"\n+0140: 20 50 6F 77 65 72 73 04   0D 41 75 73 74 69 6E 20   Powers..Austin \n+0150: 50 6F 77 65 72 73                                  Powers\n+\n+\n+# LDAP SearchResultDone\n+\n+0000: 30 0C 02 01 03 65 07 0A   01 00 04 00 04 00        0....e........\n+\n+\n+# LDAP DeleteRequest\n+\n+0000: 30 5A 02 01 04 4A 38 63   6E 3D 41 75 73 74 69 6E  0Z...J8cn=Austin\n+0010: 20 50 6F 77 65 72 73 2C   6F 75 3D 43 6C 69 65 6E   Powers,ou=Clien\n+0020: 74 31 2C 6F 75 3D 56 65   6E 64 6F 72 31 2C 6F 75  t1,ou=Vendor1,ou\n+0030: 3D 41 64 64 2C 6F 3D 49   4D 43 2C 63 3D 55 53 A0  =Add,o=IMC,c=US.\n+0040: 1B 30 19 04 17 32 2E 31   36 2E 38 34 30 2E 31 2E  .0...2.16.840.1.\n+0050: 31 31 33 37 33 30 2E 33   2E 34 2E 32              113730.3.4.2\n+\n+\n+# LDAP DeleteResponse\n+\n+0000: 30 0C 02 01 04 6B 07 0A   01 00 04 00 04 00        0....k........\n+\n","filename":"jdk\/test\/com\/sun\/jndi\/ldap\/blits\/AddTests\/AddNewEntry.ldap","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,296 @@\n+\/*\n+ * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test;\n+\n+import java.io.*;\n+import java.nio.file.*;\n+import java.math.BigInteger;\n+import java.net.*;\n+import java.util.*;\n+import java.util.regex.*;\n+\n+\/*\n+ * A dummy LDAP server.\n+ *\n+ * Loads a sequence of LDAP messages from a capture file into its cache.\n+ * It listens for LDAP requests, finds a match in its cache and sends the\n+ * corresponding LDAP responses.\n+ *\n+ * The capture file contains an LDAP protocol exchange in the hexadecimal\n+ * dump format emitted by sun.misc.HexDumpEncoder:\n+ *\n+ * xxxx: 00 11 22 33 44 55 66 77   88 99 aa bb cc dd ee ff  ................\n+ *\n+ * Typically, LDAP protocol exchange is generated by running the LDAP client\n+ * application program against a real LDAP server and setting the JNDI\/LDAP\n+ * environment property: com.sun.jndi.ldap.trace.ber to activate LDAP message\n+ * tracing.\n+ *\/\n+public class LDAPServer {\n+\n+    \/*\n+     * A cache of LDAP requests and responses.\n+     * Messages with the same ID are stored in a list.\n+     * The first element in the list is the LDAP request,\n+     * the remaining elements are the LDAP responses.\n+     *\/\n+    private final Map<Integer,List<byte[]>> cache = new HashMap<>();\n+\n+    public LDAPServer(ServerSocket serverSocket, String filename)\n+        throws Exception {\n+\n+        System.out.println(\"LDAPServer: Loading LDAP cache from: \" + filename);\n+        loadCaptureFile(filename);\n+\n+        System.out.println(\"LDAPServer: listening on port \" +\n+            serverSocket.getLocalPort());\n+\n+        try (Socket clientSocket = serverSocket.accept();\n+            OutputStream out = clientSocket.getOutputStream();\n+            InputStream in = clientSocket.getInputStream();) {\n+\n+            byte[] inBuffer = new byte[8192];\n+            int count;\n+\n+            while ((count = in.read(inBuffer)) > 0) {\n+                byte[] request = Arrays.copyOf(inBuffer, count);\n+                int[] ids = getIDs(request);\n+                int messageID = ids[0];\n+                String operation = getOperation(ids[1]);\n+                System.out.println(\"\\nLDAPServer: received LDAP \" + operation +\n+                    \"  [message ID \" + messageID + \"]\");\n+\n+                List<byte[]> encodings = cache.get(messageID);\n+                if (encodings == null ||\n+                    (!Arrays.equals(request, encodings.get(0)))) {\n+                    throw new Exception(\n+                        \"LDAPServer: ERROR: received an LDAP \" + operation +\n+                        \" (ID=\" + messageID + \") not present in cache\");\n+                }\n+\n+                for (int i = 1; i < encodings.size(); i++) {\n+                    \/\/ skip the request (at index 0)\n+                    byte[] response = encodings.get(i);\n+                    out.write(response, 0, response.length);\n+                    ids = getIDs(response);\n+                    System.out.println(\"\\nLDAPServer: Sent LDAP \" +\n+                        getOperation(ids[1]) + \"  [message ID \" + ids[0] + \"]\");\n+                }\n+            }\n+        } catch (IOException e) {\n+            System.out.println(\"LDAPServer: ERROR: \" + e);\n+            throw e;\n+        }\n+\n+        System.out.println(\"\\n[LDAP server exited normally]\");\n+    }\n+\n+    \/*\n+     * Load a capture file containing an LDAP protocol exchange in the\n+     * hexadecimal dump format emitted by sun.misc.HexDumpEncoder:\n+     *\n+     * xxxx: 00 11 22 33 44 55 66 77   88 99 aa bb cc dd ee ff  ................\n+     *\/\n+    private void loadCaptureFile(String filename) throws IOException {\n+        StringBuilder hexString = new StringBuilder();\n+        String pattern = \"(....): (..) (..) (..) (..) (..) (..) (..) (..)   (..) (..) (..) (..) (..) (..) (..) (..).*\";\n+\n+        try (Scanner fileScanner =  new Scanner(Paths.get(filename))) {\n+            while (fileScanner.hasNextLine()){\n+\n+                try (Scanner lineScanner =\n+                    new Scanner(fileScanner.nextLine())) {\n+                    if (lineScanner.findInLine(pattern) == null) {\n+                        continue;\n+                    }\n+                    MatchResult result = lineScanner.match();\n+                    for (int i = 1; i <= result.groupCount(); i++) {\n+                        String digits = result.group(i);\n+                        if (digits.length() == 4) {\n+                            if (digits.equals(\"0000\")) { \/\/ start-of-message\n+                                if (hexString.length() > 0) {\n+                                    addToCache(hexString.toString());\n+                                    hexString = new StringBuilder();\n+                                }\n+                            }\n+                            continue;\n+                        } else if (digits.equals(\"  \")) { \/\/ short message\n+                            continue;\n+                        }\n+                        hexString.append(digits);\n+                    }\n+                }\n+            }\n+        }\n+        addToCache(hexString.toString());\n+    }\n+\n+    \/*\n+     * Add an LDAP encoding to the cache (by messageID key).\n+     *\/\n+    private void addToCache(String hexString) throws IOException {\n+        byte[] encoding = parseHexBinary(hexString);\n+        int[] ids = getIDs(encoding);\n+        int messageID = ids[0];\n+        List<byte[]> encodings = cache.get(messageID);\n+        if (encodings == null) {\n+            encodings = new ArrayList<>();\n+        }\n+        System.out.println(\"    adding LDAP \" + getOperation(ids[1]) +\n+            \" with message ID \" + messageID + \" to the cache\");\n+        encodings.add(encoding);\n+        cache.put(messageID, encodings);\n+    }\n+\n+    \/*\n+     * Extracts the message ID and operation ID from an LDAP protocol encoding\n+     * and returns them in a 2-element array of integers.\n+     *\/\n+    private static int[] getIDs(byte[] encoding) throws IOException {\n+        if (encoding[0] != 0x30) {\n+            throw new IOException(\"Error: bad LDAP encoding in capture file: \" +\n+                \"expected ASN.1 SEQUENCE tag (0x30), encountered \" +\n+                encoding[0]);\n+        }\n+\n+        int index = 2;\n+        if ((encoding[1] & 0x80) == 0x80) {\n+            index += (encoding[1] & 0x0F);\n+        }\n+\n+        if (encoding[index] != 0x02) {\n+            throw new IOException(\"Error: bad LDAP encoding in capture file: \" +\n+                \"expected ASN.1 INTEGER tag (0x02), encountered \" +\n+                encoding[index]);\n+        }\n+        int length = encoding[index + 1];\n+        index += 2;\n+        int messageID =\n+            new BigInteger(1,\n+                Arrays.copyOfRange(encoding, index, index + length)).intValue();\n+        index += length;\n+        int operationID = encoding[index];\n+\n+        return new int[]{messageID, operationID};\n+    }\n+\n+    \/*\n+     * Maps an LDAP operation ID to a string description\n+     *\/\n+    private static String getOperation(int operationID) {\n+        switch (operationID) {\n+        case 0x60:\n+            return \"BindRequest\";       \/\/ [APPLICATION 0]\n+        case 0x61:\n+            return \"BindResponse\";      \/\/ [APPLICATION 1]\n+        case 0x42:\n+            return \"UnbindRequest\";     \/\/ [APPLICATION 2]\n+        case 0x63:\n+            return \"SearchRequest\";     \/\/ [APPLICATION 3]\n+        case 0x64:\n+            return \"SearchResultEntry\"; \/\/ [APPLICATION 4]\n+        case 0x65:\n+            return \"SearchResultDone\";  \/\/ [APPLICATION 5]\n+        case 0x66:\n+            return \"ModifyRequest\";     \/\/ [APPLICATION 6]\n+        case 0x67:\n+            return \"ModifyResponse\";    \/\/ [APPLICATION 7]\n+        case 0x68:\n+            return \"AddRequest\";        \/\/ [APPLICATION 8]\n+        case 0x69:\n+            return \"AddResponse\";       \/\/ [APPLICATION 9]\n+        case 0x4A:\n+            return \"DeleteRequest\";     \/\/ [APPLICATION 10]\n+        case 0x6B:\n+            return \"DeleteResponse\";    \/\/ [APPLICATION 11]\n+        case 0x6C:\n+            return \"ModifyDNRequest\";   \/\/ [APPLICATION 12]\n+        case 0x6D:\n+            return \"ModifyDNResponse\";  \/\/ [APPLICATION 13]\n+        case 0x6E:\n+            return \"CompareRequest\";    \/\/ [APPLICATION 14]\n+        case 0x6F:\n+            return \"CompareResponse\";   \/\/ [APPLICATION 15]\n+        case 0x50:\n+            return \"AbandonRequest\";    \/\/ [APPLICATION 16]\n+        case 0x73:\n+            return \"SearchResultReference\";  \/\/ [APPLICATION 19]\n+        case 0x77:\n+            return \"ExtendedRequest\";   \/\/ [APPLICATION 23]\n+        case 0x78:\n+            return \"ExtendedResponse\";  \/\/ [APPLICATION 24]\n+        case 0x79:\n+            return \"IntermediateResponse\";  \/\/ [APPLICATION 25]\n+        default:\n+            return \"Unknown\";\n+        }\n+    }\n+\n+    public static  byte[] parseHexBinary(String s) {\n+\n+        final int len = s.length();\n+\n+        \/\/ \"111\" is not a valid hex encoding.\n+        if (len % 2 != 0) {\n+            throw new IllegalArgumentException(\"hexBinary needs to be even-length: \" + s);\n+        }\n+\n+        byte[] out = new byte[len \/ 2];\n+\n+        for (int i = 0; i < len; i += 2) {\n+            int h = hexToBin(s.charAt(i));\n+            int l = hexToBin(s.charAt(i + 1));\n+            if (h == -1 || l == -1) {\n+                throw new IllegalArgumentException(\"contains illegal character for hexBinary: \" + s);\n+            }\n+\n+            out[i \/ 2] = (byte) (h * 16 + l);\n+        }\n+\n+        return out;\n+    }\n+\n+    private static int hexToBin(char ch) {\n+        if ('0' <= ch && ch <= '9') {\n+            return ch - '0';\n+        }\n+        if ('A' <= ch && ch <= 'F') {\n+            return ch - 'A' + 10;\n+        }\n+        if ('a' <= ch && ch <= 'f') {\n+            return ch - 'a' + 10;\n+        }\n+        return -1;\n+    }\n+    private static final char[] hexCode = \"0123456789ABCDEF\".toCharArray();\n+\n+    public static String printHexBinary(byte[] data) {\n+        StringBuilder r = new StringBuilder(data.length * 2);\n+        for (byte b : data) {\n+            r.append(hexCode[(b >> 4) & 0xF]);\n+            r.append(hexCode[(b & 0xF)]);\n+        }\n+        return r.toString();\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jndi\/ldap\/lib\/LDAPServer.java","additions":296,"deletions":0,"binary":false,"changes":296,"status":"added"},{"patch":"@@ -0,0 +1,358 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.sun.jndi.ldap.LdapURL;\n+\n+import javax.naming.Context;\n+import javax.naming.NamingEnumeration;\n+import javax.naming.NamingException;\n+import javax.naming.directory.Attribute;\n+import javax.naming.directory.Attributes;\n+import javax.naming.directory.DirContext;\n+import javax.naming.directory.SearchResult;\n+import java.io.FileNotFoundException;\n+import java.io.PrintStream;\n+import java.net.ServerSocket;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Enumeration;\n+import java.util.Hashtable;\n+import java.util.Vector;\n+\n+public class LDAPTestUtils {\n+    public static final String TEST_LDAP_SERVER_THREAD = \"test.ldap.server.thread\";\n+    public static final int CERTS_LOOKUP_MAX_DEPTH = 4;\n+\n+    protected static boolean debug = true;\n+\n+    \/*\n+     * Process command line arguments and return properties in a Hashtable.\n+     *\/\n+    public static Hashtable<Object, Object> initEnv(String testname,\n+            String[] args) {\n+        return initEnv(null, testname, args, false);\n+    }\n+\n+    public static Hashtable<Object, Object> initEnv(ServerSocket socket,\n+            String testname, String[] args, boolean authInfo) {\n+\n+        Hashtable<Object, Object> env = new Hashtable<>();\n+        String root = \"o=IMC,c=US\";\n+        String vendor = \"Vendor1\";\n+        String client = \"Client1\";\n+        String realm = \"\";\n+        Vector<String> refs = new Vector<>();\n+\n+        \/\/ set defaults for some JNDI properties\n+        env.put(Context.INITIAL_CONTEXT_FACTORY,\n+                \"com.sun.jndi.ldap.LdapCtxFactory\");\n+\n+        if (authInfo) {\n+            env.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n+            env.put(Context.SECURITY_PRINCIPAL, \"cn=admin,o=IMC,c=US\");\n+            env.put(Context.SECURITY_CREDENTIALS, \"secret99\");\n+        }\n+\n+        env.put(\"root\", root);\n+        env.put(\"vendor\", vendor);\n+        env.put(\"client\", client);\n+\n+        boolean traceEnable = false;\n+        for (int i = 0; i < args.length; i++) {\n+            if (args[i].equals(\"-D\") && (args.length > i + 1)) {\n+                extractProperty(args[++i], env);\n+            } else if (args[i].startsWith(\"-D\")) {\n+                extractProperty(args[i].substring(2), env);\n+            } else if (args[i].equals(\"-referral\") && (args.length > i + 1)) {\n+                refs.addElement(args[++i]);\n+            } else if (args[i].equals(\"-trace\")) {\n+                traceEnable = true;\n+            }\n+        }\n+\n+        env.put(\"disabled.realm\", realm);\n+\n+        if (refs.size() > 0) {\n+            env.put(\"referrals\", refs);\n+        }\n+\n+        if (traceEnable) {\n+            enableLDAPTrace(env, testname);\n+        } else {\n+            if (socket != null) {\n+                env.put(TEST_LDAP_SERVER_THREAD,\n+                        startLDAPServer(socket, getCaptureFile(testname)));\n+                env.put(\"java.naming.provider.url\",\n+                        \"ldap:\/\/localhost:\" + socket.getLocalPort());\n+            } else {\n+                \/\/ for tests which run against remote server or no server\n+                \/\/ required\n+                debug(\"Skip local LDAP Server creation \"\n+                        + \"since ServerSocket is null\");\n+            }\n+        }\n+\n+        return env;\n+    }\n+\n+    \/*\n+     * Clean-up the directory context.\n+     *\/\n+    public static void cleanup(DirContext ctx) {\n+        if (ctx != null) {\n+            try {\n+                ctx.close();\n+            } catch (NamingException e) {\n+                \/\/ ignore\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Clean-up the sub context.\n+     *\/\n+    public static void cleanupSubcontext(DirContext ctx, String name) {\n+        if (ctx != null) {\n+            try {\n+                ctx.destroySubcontext(name);\n+            } catch (NamingException ne) {\n+                \/\/ ignore\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Assemble a distinguished name from the base components and the\n+     * namespace root.\n+     *\n+     * The components are prefixed with 'dc=' if the root is a DC-style name.\n+     * Otherwise they are prefixed with 'ou='.\n+     *\/\n+    public static String buildDN(String[] bases, String root) {\n+\n+        StringBuilder dn = new StringBuilder();\n+        String prefix;\n+\n+        if (!root.contains(\"dc=\")) {\n+            prefix = \"ou=\";\n+        } else {\n+            prefix = \"dc=\";\n+        }\n+\n+        for (String base : bases) {\n+            dn.append(prefix).append(base).append(\",\");\n+        }\n+\n+        return dn.append(root).toString();\n+    }\n+\n+    \/*\n+     * Scan the results to confirm that the expected name is present.\n+     *\/\n+    public static int checkResult(NamingEnumeration results, String name)\n+            throws NamingException {\n+\n+        return checkResult(results, new String[] { name }, null);\n+    }\n+\n+    \/*\n+     * Scan the results to confirm that the expected names and attributes\n+     * are present.\n+     *\/\n+    public static int checkResult(NamingEnumeration results, String[] names,\n+            Attributes attrs) throws NamingException {\n+\n+        int found = 0;\n+\n+        while (results != null && results.hasMore()) {\n+\n+            SearchResult entry = (SearchResult) results.next();\n+            String entryDN = entry.getName();\n+\n+            debug(\">>> received: \" + entryDN);\n+\n+            if (entry.isRelative()) {\n+                entryDN = entryDN.toLowerCase(); \/\/ normalize\n+            } else {\n+                LdapURL url = new LdapURL(entryDN); \/\/ extract DN\n+                entryDN = url.getDN().toLowerCase(); \/\/ normalize\n+            }\n+\n+            for (String name : names) {\n+                if ((entryDN.contains(name.toLowerCase())) || (entryDN\n+                        .equalsIgnoreCase(name))) {\n+\n+                    debug(\">>> checked results: found '\" + name + \"'\");\n+\n+                    if (attrs == null || foundAttributes(entry, attrs)) {\n+                        found++;\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        debug(\">>> checked results: found \" + found\n+                + \" entries that meet the criteria.\");\n+\n+        return found;\n+    }\n+\n+    \/*\n+     * Confirm that the attributes are present in the entry.\n+     *\/\n+    public static boolean foundAttributes(SearchResult entry, Attributes attrs)\n+            throws NamingException {\n+\n+        Attributes eattrs = entry.getAttributes();\n+        int found = 0;\n+\n+        if ((eattrs == null) || (attrs == null)) {\n+            return false;\n+        }\n+\n+        for (NamingEnumeration ne = attrs.getAll(); ne.hasMoreElements(); ) {\n+\n+            Attribute attr = (Attribute) ne.next();\n+\n+            if (equalsIgnoreCase(eattrs.get(attr.getID()), attr)) {\n+                found++;\n+            } else {\n+                debug(\">>> foundAttributes: no match for \" + attr.getID());\n+            }\n+        }\n+        debug(\">>> foundAttributes: found \" + found + \" attributes\");\n+        return (found == attrs.size());\n+    }\n+\n+    public static Thread startLDAPServer(ServerSocket serverSocket,\n+            String fileName) {\n+        if (serverSocket == null) {\n+            throw new RuntimeException(\"Error: failed to create LDAPServer \"\n+                    + \"since ServerSocket is null\");\n+        }\n+\n+        if (!Files.exists(Paths.get(fileName))) {\n+            throw new RuntimeException(\n+                    \"Error: failed to create LDAPServer, not found ldap \"\n+                            + \"cache file \" + fileName);\n+        }\n+\n+        Thread thread = new Thread(() -> {\n+            try {\n+                new test.LDAPServer(serverSocket, fileName);\n+            } catch (Exception e) {\n+                System.out.println(\"Warning: LDAP server running with issue\");\n+                e.printStackTrace();\n+            }\n+        });\n+\n+        thread.start();\n+        return thread;\n+    }\n+\n+    private static boolean equalsIgnoreCase(Attribute received,\n+            Attribute expected) {\n+\n+        if (received == null || !received.getID()\n+                .equalsIgnoreCase(expected.getID())) {\n+            return false;\n+        }\n+\n+        try {\n+\n+            Enumeration expectedVals = expected.getAll();\n+            Object obj;\n+            while (expectedVals.hasMoreElements()) {\n+                obj = expectedVals.nextElement();\n+                if (!received.contains(obj)) {\n+                    if (!(obj instanceof String)) {\n+                        return false;\n+                    }\n+                    if (!received.contains(((String) obj).toLowerCase())) {\n+                        return false;\n+                    }\n+                }\n+            }\n+\n+        } catch (NamingException e) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    private static void extractProperty(String propString,\n+            Hashtable<Object, Object> env) {\n+        int index;\n+\n+        if ((index = propString.indexOf('=')) > 0) {\n+            env.put(propString.substring(0, index),\n+                    propString.substring(index + 1));\n+        } else {\n+            throw new RuntimeException(\n+                    \"Failed to extract test args property from \" + propString);\n+        }\n+    }\n+\n+    private static void enableLDAPTrace(Hashtable<Object, Object> env,\n+            String testname) {\n+        try {\n+            PrintStream outStream = new PrintStream(getCaptureFile(testname));\n+            env.put(\"com.sun.jndi.ldap.trace.ber\", outStream);\n+        } catch (FileNotFoundException e) {\n+            throw new RuntimeException(\n+                    \"Error: failed to enable ldap trace: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    private static String getCaptureFile(String testname) {\n+        return Paths.get(System.getProperty(\"test.src\"))\n+                .resolve(testname + \".ldap\").toString();\n+    }\n+\n+    public static void debug(Object object) {\n+        if (debug) {\n+            System.out.println(object);\n+        }\n+    }\n+\n+    public static String findCertsHome(int depth) {\n+        Path path = Paths.get(System.getProperty(\"test.src\", \".\"))\n+                .toAbsolutePath();\n+        for (int i = depth; i >= 0; i--) {\n+            Path homePath = path.resolve(\"certs\");\n+            if (Files.exists(homePath) && Files.isDirectory(homePath)) {\n+                return homePath.toString();\n+            }\n+\n+            path = path.getParent();\n+            if (path == null) {\n+                break;\n+            }\n+        }\n+\n+        return System.getProperty(\"test.src\", \".\");\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jndi\/ldap\/lib\/LDAPTestUtils.java","additions":358,"deletions":0,"binary":false,"changes":358,"status":"added"}]}