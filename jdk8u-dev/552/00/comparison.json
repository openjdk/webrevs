{"files":[{"patch":"@@ -2543,1 +2543,1 @@\n-      } else { \/\/ exclude unsafe ops\n+      } else {\n@@ -2558,3 +2558,3 @@\n-          assert(field != NULL, \"missing field\");\n-          BasicType basic_elem_type = field->layout_type();\n-          _is_ptr_to_narrowoop = UseCompressedOops && (basic_elem_type == T_OBJECT ||\n+          if (field != NULL) {\n+            BasicType basic_elem_type = field->layout_type();\n+            _is_ptr_to_narrowoop = UseCompressedOops && (basic_elem_type == T_OBJECT ||\n@@ -2562,0 +2562,4 @@\n+          } else {\n+            \/\/ unsafe access\n+            _is_ptr_to_narrowoop = UseCompressedOops;\n+          }\n","filename":"hotspot\/src\/share\/vm\/opto\/type.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (C) 2020 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8250825\n+ * @summary \"assert(field != __null) failed: missing field\" in TypeOopPtr::TypeOopPt(...) with misaligned unsafe accesses\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm -XX:-TieredCompilation -Xcomp\n+ *                   -XX:CompileCommand=compileonly,TestMisalignedUnsafeAccess::test* TestMisalignedUnsafeAccess\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import jdk.internal.misc.Unsafe;\n+import jdk.test.lib.Asserts;\n+\n+public class TestMisalignedUnsafeAccess {\n+\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();;\n+\n+    private static short onHeapStaticMemory; \/\/ For static field testing\n+    private static final Object onHeapStaticMemoryBase;\n+    private static final long onHeapStaticMemoryOffset;\n+\n+    private short onHeapInstanceMemory; \/\/ For instance field testing\n+    private static final long onHeapInstanceMemoryOffset;\n+\n+    static {\n+        try {\n+            Field staticField = TestMisalignedUnsafeAccess.class.getDeclaredField(\"onHeapStaticMemory\");\n+            onHeapStaticMemoryBase = UNSAFE.staticFieldBase(staticField);\n+            onHeapStaticMemoryOffset = UNSAFE.staticFieldOffset(staticField);\n+\n+            Field instanceField = TestMisalignedUnsafeAccess.class.getDeclaredField(\"onHeapInstanceMemory\");\n+            onHeapInstanceMemoryOffset = UNSAFE.objectFieldOffset(instanceField);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static void testStaticField() {\n+        byte b1 = 0x01;\n+        byte b2 = 0x02;\n+\n+        UNSAFE.putByte(onHeapStaticMemoryBase, onHeapStaticMemoryOffset, b1);\n+        UNSAFE.putByte(onHeapStaticMemoryBase, onHeapStaticMemoryOffset + 1, b2);\n+\n+        Asserts.assertEquals(b1, UNSAFE.getByte(onHeapStaticMemoryBase, onHeapStaticMemoryOffset));\n+        Asserts.assertEquals(b2, UNSAFE.getByte(onHeapStaticMemoryBase, onHeapStaticMemoryOffset + 1));\n+    }\n+\n+    public static void testInstanceField() {\n+        byte b1 = 0x03;\n+        byte b2 = 0x04;\n+        TestMisalignedUnsafeAccess obj = new TestMisalignedUnsafeAccess();\n+\n+        UNSAFE.putByte(obj, onHeapInstanceMemoryOffset, b1);\n+        UNSAFE.putByte(obj, onHeapInstanceMemoryOffset + 1, b2);\n+\n+        Asserts.assertEquals(b1, UNSAFE.getByte(obj, onHeapInstanceMemoryOffset));\n+        Asserts.assertEquals(b2, UNSAFE.getByte(obj, onHeapInstanceMemoryOffset + 1));\n+    }\n+\n+    public static void main(String[] args) {\n+        testStaticField();\n+        testInstanceField();\n+    }\n+}\n","filename":"hotspot\/test\/compiler\/unsafe\/TestMisalignedUnsafeAccess.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"}]}