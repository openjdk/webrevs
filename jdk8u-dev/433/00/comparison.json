{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -258,0 +258,2 @@\n+         } else if (f.isUIntx() || f.isUint64t()) {\n+            return parseUnsignedLong(f.getValue(), 10);\n@@ -302,0 +304,57 @@\n+\n+   \/** This is an alternative to Long.parseUnsignedLong(String s, int radix)\n+       Required to build with the boot JDK7.\n+       Backporting JDK-8217850 requires this method. *\/\n+   private long parseUnsignedLong(String s, int radix)\n+         throws NumberFormatException {\n+      if (s == null)  {\n+         throw new NumberFormatException(\"null\");\n+      }\n+\n+      int len = s.length();\n+      if (len > 0) {\n+         char firstChar = s.charAt(0);\n+         if (firstChar == '-') {\n+            throw new\n+               NumberFormatException(String.format(\"Illegal leading minus sign \" +\n+                                                   \"on unsigned string %s.\", s));\n+         } else {\n+            if (len <= 12 || \/\/ Long.MAX_VALUE in Character.MAX_RADIX is 13 digits\n+               (radix == 10 && len <= 18) ) { \/\/ Long.MAX_VALUE in base 10 is 19 digits\n+               return Long.parseLong(s, radix);\n+            }\n+\n+            \/\/ No need for range checks on len due to testing above.\n+            long first = Long.parseLong(s.substring(0, len - 1), radix);\n+            int second = Character.digit(s.charAt(len - 1), radix);\n+            if (second < 0) {\n+               throw new NumberFormatException(\"Bad digit at end of \" + s);\n+            }\n+            long result = first * radix + second;\n+            \/* Replace compareUnsigned(long x, long y) with its implementation *\/\n+            if (Long.compare(result + Long.MIN_VALUE, first + Long.MIN_VALUE) < 0) {\n+               \/*\n+               * The maximum unsigned value, (2^64)-1, takes at\n+               * most one more digit to represent than the\n+               * maximum signed value, (2^63)-1.  Therefore,\n+               * parsing (len - 1) digits will be appropriately\n+               * in-range of the signed parsing.  In other\n+               * words, if parsing (len -1) digits overflows\n+               * signed parsing, parsing len digits will\n+               * certainly overflow unsigned parsing.\n+               *\n+               * The compareUnsigned check above catches\n+               * situations where an unsigned overflow occurs\n+               * incorporating the contribution of the final\n+               * digit.\n+               *\/\n+               throw new NumberFormatException(String.format(\"String value %s exceeds \" +\n+                                                             \"range of unsigned long.\", s));\n+            }\n+            return result;\n+         }\n+      } else {\n+         \/* Replace NumberFormatException.forInputString(s) with its implementation *\/\n+         throw new NumberFormatException(\"For input string: \\\"\" + s + \"\\\"\");\n+      }\n+   }\n","filename":"hotspot\/agent\/src\/share\/classes\/sun\/jvm\/hotspot\/tools\/HeapSummary.java","additions":60,"deletions":1,"binary":false,"changes":61,"status":"modified"}]}