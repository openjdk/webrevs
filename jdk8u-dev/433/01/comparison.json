{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,0 +127,1 @@\n+  private static Type uint64tType;\n@@ -195,0 +196,44 @@\n+     public boolean isCcstr() {\n+        return type.equals(\"ccstr\");\n+     }\n+\n+     public String getCcstr() {\n+        if (Assert.ASSERTS_ENABLED) {\n+           Assert.that(isCcstr(), \"not a ccstr flag!\");\n+        }\n+        return CStringUtilities.getString(addr.getAddressAt(0));\n+     }\n+\n+     public boolean isCcstrlist() {\n+        return type.equals(\"ccstrlist\");\n+     }\n+\n+     public String getCcstrlist() {\n+        if (Assert.ASSERTS_ENABLED) {\n+           Assert.that(isCcstrlist(), \"not a ccstrlist flag!\");\n+        }\n+        return CStringUtilities.getString(addr.getAddressAt(0));\n+     }\n+\n+     public boolean isDouble() {\n+        return type.equals(\"double\");\n+     }\n+\n+     public double getDouble() {\n+        if (Assert.ASSERTS_ENABLED) {\n+           Assert.that(isDouble(), \"not a double flag!\");\n+        }\n+        return addr.getJDoubleAt(0);\n+     }\n+\n+     public boolean isUint64t() {\n+        return type.equals(\"uint64_t\");\n+     }\n+\n+     public long getUint64t() {\n+        if (Assert.ASSERTS_ENABLED) {\n+           Assert.that(isUint64t(), \"not an uint64_t flag!\");\n+        }\n+        return addr.getCIntegerAt(0, uint64tType.getSize(), true);\n+     }\n+\n@@ -201,1 +246,27 @@\n-           return new Long(getUIntx()).toString();\n+           return longToUnsignedString(getUIntx());\n+        } else if (isCcstr()) {\n+           String str = getCcstr();\n+           if (str != null) {\n+              str = \"\\\"\" + str + \"\\\"\";\n+           }\n+           return str;\n+        } else if (isCcstrlist()) {\n+           String str = getCcstrlist();\n+           if (str != null) {\n+              str = \"\\\"\" + str + \"\\\"\";\n+           }\n+           return str;\n+        } else if (isDouble()) {\n+           return new Double(getDouble()).toString();\n+        } else if (isUint64t()) {\n+           return longToUnsignedString(getUint64t());\n+        } else {\n+           throw new WrongTypeException(\"Unknown type: \" + type + \" (\" + name + \")\");\n+        }\n+     }\n+\n+     \/** This is an alternative to Long.toUnsignedString(long i)\n+         Required to build with the boot JDK7. *\/\n+     private String longToUnsignedString(long i) {\n+        if (i >= 0) {\n+           return Long.toString(i);\n@@ -203,1 +274,3 @@\n-           return null;\n+           long quot = (i >>> 1) \/ 5;\n+           long rem = i - quot * 10;\n+           return Long.toString(quot) + rem;\n@@ -328,0 +401,1 @@\n+    uint64tType = db.lookupType(\"uint64_t\");\n","filename":"hotspot\/agent\/src\/share\/classes\/sun\/jvm\/hotspot\/runtime\/VM.java","additions":77,"deletions":3,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -258,0 +258,2 @@\n+         } else if (f.isUIntx() || f.isUint64t()) {\n+            return parseUnsignedLong(f.getValue(), 10);\n@@ -302,0 +304,57 @@\n+\n+   \/** This is an alternative to Long.parseUnsignedLong(String s, int radix)\n+       Required to build with the boot JDK7.\n+       Backporting JDK-8217850 requires this method. *\/\n+   private long parseUnsignedLong(String s, int radix)\n+         throws NumberFormatException {\n+      if (s == null)  {\n+         throw new NumberFormatException(\"null\");\n+      }\n+\n+      int len = s.length();\n+      if (len > 0) {\n+         char firstChar = s.charAt(0);\n+         if (firstChar == '-') {\n+            throw new\n+               NumberFormatException(String.format(\"Illegal leading minus sign \" +\n+                                                   \"on unsigned string %s.\", s));\n+         } else {\n+            if (len <= 12 || \/\/ Long.MAX_VALUE in Character.MAX_RADIX is 13 digits\n+               (radix == 10 && len <= 18) ) { \/\/ Long.MAX_VALUE in base 10 is 19 digits\n+               return Long.parseLong(s, radix);\n+            }\n+\n+            \/\/ No need for range checks on len due to testing above.\n+            long first = Long.parseLong(s.substring(0, len - 1), radix);\n+            int second = Character.digit(s.charAt(len - 1), radix);\n+            if (second < 0) {\n+               throw new NumberFormatException(\"Bad digit at end of \" + s);\n+            }\n+            long result = first * radix + second;\n+            \/* Replace compareUnsigned(long x, long y) with its implementation *\/\n+            if (Long.compare(result + Long.MIN_VALUE, first + Long.MIN_VALUE) < 0) {\n+               \/*\n+               * The maximum unsigned value, (2^64)-1, takes at\n+               * most one more digit to represent than the\n+               * maximum signed value, (2^63)-1.  Therefore,\n+               * parsing (len - 1) digits will be appropriately\n+               * in-range of the signed parsing.  In other\n+               * words, if parsing (len -1) digits overflows\n+               * signed parsing, parsing len digits will\n+               * certainly overflow unsigned parsing.\n+               *\n+               * The compareUnsigned check above catches\n+               * situations where an unsigned overflow occurs\n+               * incorporating the contribution of the final\n+               * digit.\n+               *\/\n+               throw new NumberFormatException(String.format(\"String value %s exceeds \" +\n+                                                             \"range of unsigned long.\", s));\n+            }\n+            return result;\n+         }\n+      } else {\n+         \/* Replace NumberFormatException.forInputString(s) with its implementation *\/\n+         throw new NumberFormatException(\"For input string: \\\"\" + s + \"\\\"\");\n+      }\n+   }\n","filename":"hotspot\/agent\/src\/share\/classes\/sun\/jvm\/hotspot\/tools\/HeapSummary.java","additions":60,"deletions":1,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -456,2 +456,2 @@\n-\/\/ bool, intx, uintx, ccstr.\n-\/\/ The type \"ccstr\" is an alias for \"const char*\" and is used\n+\/\/ bool, intx, uintx, ccstr, ccstrlist, double, or uint64_t.\n+\/\/ The type \"ccstr\" and \"ccstrlist\" are an alias for \"const char*\" and is used\n","filename":"hotspot\/src\/share\/vm\/runtime\/globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * @bug 8190198\n+ * @bug 8217612\n+ * @summary Test clhsdb flags command\n+ * @requires vm.hasSA\n+ * @library \/test\/lib\n+ * @run main\/othervm ClhsdbFlags\n+ *\/\n+\n+public class ClhsdbFlags {\n+\n+    public static void runBasicTest() throws Exception {\n+        System.out.println(\"Starting ClhsdbFlags basic test\");\n+\n+        LingeredApp theApp = null;\n+        try {\n+            ClhsdbLauncher test = new ClhsdbLauncher();\n+            List<String> vmArgs = new ArrayList<String>();\n+            vmArgs.add(\"-XX:+UnlockExperimentalVMOptions\");\n+            vmArgs.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+            vmArgs.add(\"-XX:-MaxFDLimit\");\n+            vmArgs.addAll(Utils.getVmOptions());\n+            theApp = LingeredApp.startApp(vmArgs);\n+            System.out.println(\"Started LingeredApp with pid \" + theApp.getPid());\n+\n+            List<String> cmds = List.of(\n+                    \"flags\", \"flags -nd\",\n+                    \"flags UnlockDiagnosticVMOptions\", \"flags MaxFDLimit\",\n+                    \"flags MaxJavaStackTraceDepth\");\n+\n+            Map<String, List<String>> expStrMap = new HashMap<>();\n+            expStrMap.put(\"flags\", List.of(\n+                    \"UnlockDiagnosticVMOptions = true\",\n+                    \"MaxFDLimit = false\",\n+                    \"MaxJavaStackTraceDepth = 1024\",\n+                    \"VerifyMergedCPBytecodes\",\n+                    \"ConcGCThreads\", \"UseThreadPriorities\",\n+                    \"ShowHiddenFrames\"));\n+            expStrMap.put(\"flags -nd\", List.of(\n+                    \"UnlockDiagnosticVMOptions = true\",\n+                    \"MaxFDLimit = false\",\n+                    \"InitialHeapSize\",\n+                    \"MaxHeapSize\"));\n+            expStrMap.put(\"flags UnlockDiagnosticVMOptions\", List.of(\n+                    \"UnlockDiagnosticVMOptions = true\"));\n+            expStrMap.put(\"flags MaxFDLimit\", List.of(\n+                    \"MaxFDLimit = false\"));\n+            expStrMap.put(\"flags MaxJavaStackTraceDepth\", List.of(\n+                    \"MaxJavaStackTraceDepth = 1024\"));\n+\n+            test.run(theApp.getPid(), cmds, expStrMap, null);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(\"Test ERROR \" + ex, ex);\n+        } finally {\n+            LingeredApp.stopApp(theApp);\n+        }\n+        System.out.println(\"Test PASSED\");\n+    }\n+\n+    public static void runAllTypesTest() throws Exception {\n+        System.out.println(\"Starting ClhsdbFlags all types test\");\n+\n+        LingeredApp theApp = null;\n+        try {\n+            ClhsdbLauncher test = new ClhsdbLauncher();\n+            List<String> vmArgs = new ArrayList<String>();\n+            vmArgs.add(\"-XX:+UnlockDiagnosticVMOptions\");   \/\/ bool\n+            vmArgs.add(\"-XX:ActiveProcessorCount=1\");       \/\/ int\n+            vmArgs.add(\"-XX:ParallelGCThreads=1\");          \/\/ uint\n+            vmArgs.add(\"-XX:MaxJavaStackTraceDepth=1024\");  \/\/ intx\n+            vmArgs.add(\"-XX:LogEventsBufferEntries=10\");    \/\/ uintx\n+            vmArgs.add(\"-XX:HeapSizePerGCThread=32m\");      \/\/ size_t\n+            vmArgs.add(\"-XX:NativeMemoryTracking=off\");     \/\/ ccstr\n+            vmArgs.add(\"-XX:OnError='echo error'\");         \/\/ ccstrlist\n+            vmArgs.add(\"-XX:CompileThresholdScaling=1.0\");  \/\/ double\n+            vmArgs.add(\"-XX:ErrorLogTimeout=120\");          \/\/ uint64_t\n+            vmArgs.addAll(Utils.getVmOptions());\n+            theApp = LingeredApp.startApp(vmArgs);\n+            System.out.println(\"Started LingeredApp with pid \" + theApp.getPid());\n+\n+            List<String> cmds = List.of(\"flags\");\n+\n+            Map<String, List<String>> expStrMap = new HashMap<>();\n+            expStrMap.put(\"flags\", List.of(\n+                    \"UnlockDiagnosticVMOptions = true\",\n+                    \"ActiveProcessorCount = 1\",\n+                    \"ParallelGCThreads = 1\",\n+                    \"MaxJavaStackTraceDepth = 1024\",\n+                    \"LogEventsBufferEntries = 10\",\n+                    \"HeapSizePerGCThread = 3\",\n+                    \"NativeMemoryTracking = \\\"off\\\"\",\n+                    \"OnError = \\\"'echo error'\\\"\",\n+                    \"CompileThresholdScaling = 1.0\",\n+                    \"ErrorLogTimeout = 120\"));\n+\n+            test.run(theApp.getPid(), cmds, expStrMap, null);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(\"Test ERROR \" + ex, ex);\n+        } finally {\n+            LingeredApp.stopApp(theApp);\n+        }\n+        System.out.println(\"Test PASSED\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        runBasicTest();\n+        runAllTypesTest();\n+    }\n+}\n","filename":"hotspot\/test\/serviceability\/sa\/ClhsdbFlags.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"}]}