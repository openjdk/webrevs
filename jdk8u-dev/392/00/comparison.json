{"files":[{"patch":"@@ -84,0 +84,1 @@\n+Mutex*   MonitoringSupport_lock       = NULL;\n@@ -211,0 +212,2 @@\n+\n+    def(MonitoringSupport_lock     , Mutex  , leaf,        true );      \/\/ used for serviceability monitoring support\n","filename":"hotspot\/src\/share\/vm\/runtime\/mutexLocker.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,0 +104,1 @@\n+extern Mutex*   MonitoringSupport_lock;          \/\/ Protects updates to the serviceability memory pools and allocated memory high water mark.\n","filename":"hotspot\/src\/share\/vm\/runtime\/mutexLocker.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -221,1 +221,2 @@\n-  void*        reserved1;\n+  jlong        (JNICALL *GetTotalThreadAllocatedMemory)\n+                                                 (JNIEnv *env);\n","filename":"hotspot\/src\/share\/vm\/services\/jmm.h","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -431,2 +432,0 @@\n-#endif \/\/ INCLUDE_MANAGEMENT\n-\n@@ -448,2 +447,0 @@\n-#if INCLUDE_MANAGEMENT\n-\n@@ -2233,1 +2230,33 @@\n-#endif \/\/ INCLUDE_MANAGEMENT\n+\n+\/\/ Gets the amount of memory allocated on the Java heap since JVM launch.\n+JVM_ENTRY(jlong, jmm_GetTotalThreadAllocatedMemory(JNIEnv *env))\n+    \/\/ We keep a high water mark to ensure monotonicity\n+    static jlong high_water_result = 0;\n+    static jlong prev_result = 0;\n+\n+    jlong result;\n+    if (Threads_lock->try_lock()) {\n+      result = ThreadService::exited_allocated_bytes();\n+      for (JavaThread* tp = Threads::first(); tp != NULL; tp = tp->next()) {\n+        jlong size = thread->cooked_allocated_bytes();\n+        result += size;\n+      }\n+      Threads_lock->unlock();\n+    } else {\n+      \/\/ Return the previous result if Threads_lock is locked\n+      result = prev_result;\n+    }\n+\n+    {\n+      MutexLockerEx ml(MonitoringSupport_lock, Mutex::_no_safepoint_check_flag);\n+      if (result < high_water_result) {\n+        \/\/ Result wrapped to a negative value, in which case it's\n+        \/\/ pegged at the last positive value.\n+        result = high_water_result;\n+      } else {\n+        high_water_result = result;\n+      }\n+      prev_result = result;\n+    }\n+    return result;\n+JVM_END\n@@ -2371,3 +2400,0 @@\n-\n-\n-#if INCLUDE_MANAGEMENT\n@@ -2375,1 +2401,1 @@\n-  NULL,\n+  jmm_GetTotalThreadAllocatedMemory,\n","filename":"hotspot\/src\/share\/vm\/services\/management.cpp","additions":35,"deletions":9,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+volatile jlong ThreadService::_exited_allocated_bytes = 0;\n+\n@@ -122,0 +124,3 @@\n+  \/\/ Include hidden thread allcations in exited_allocated_bytes\n+  ThreadService::incr_exited_allocated_bytes(thread->cooked_allocated_bytes());\n+\n","filename":"hotspot\/src\/share\/vm\/services\/threadService.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+  static volatile jlong _exited_allocated_bytes;\n+\n@@ -98,0 +100,8 @@\n+  static jlong exited_allocated_bytes()       { return Atomic::load(&_exited_allocated_bytes); }\n+  static void incr_exited_allocated_bytes(jlong size) {\n+    \/\/ No need for an atomic add because called under the Threads_lock,\n+    \/\/ but because _exited_allocated_bytes is read concurrently, need\n+    \/\/ atomic store to avoid readers seeing a partial update.\n+    Atomic::store(_exited_allocated_bytes + size, &_exited_allocated_bytes);\n+  }\n+\n","filename":"hotspot\/src\/share\/vm\/services\/threadService.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+            Java_sun_management_ThreadImpl_getTotalThreadAllocatedMemory;\n","filename":"jdk\/make\/mapfiles\/libmanagement\/mapfile-vers","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -112,0 +112,36 @@\n+    \/**\n+     * Returns an approximation of the total amount of memory, in bytes, allocated\n+     * in heap memory by all threads since the Java virtual machine started.\n+     * The returned value is an approximation because some Java virtual machine\n+     * implementations may use object allocation mechanisms that result in a\n+     * delay between the time an object is allocated and the time its size is\n+     * recorded.\n+     *\n+     * @implSpec The default implementation throws {@code UnsupportedOperationException}\n+     * if the Java virtual machine implementation does not support thread\n+     * memory allocation measurement, and otherwise acts as though thread\n+     * memory allocation measurement is disabled.\n+     *\n+     * @return an approximation of the total memory allocated, in bytes, in\n+     * heap memory since the Java virtual machine was started,\n+     * if thread memory allocation measurement is enabled;\n+     * {@code -1} otherwise.\n+     *\n+     * @throws UnsupportedOperationException if the Java virtual\n+     *         machine implementation does not support thread memory allocation\n+     *         measurement.\n+     *\n+     * @see #isThreadAllocatedMemorySupported\n+     * @see #isThreadAllocatedMemoryEnabled\n+     * @see #setThreadAllocatedMemoryEnabled\n+     *\n+     * @since 8u412\n+     *\/\n+    public default long getTotalThreadAllocatedBytes() {\n+        if (!isThreadAllocatedMemorySupported()) {\n+            throw new UnsupportedOperationException(\n+                \"Thread allocated memory measurement is not supported.\");\n+        }\n+        return -1;\n+    }\n+\n","filename":"jdk\/src\/share\/classes\/com\/sun\/management\/ThreadMXBean.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -334,0 +334,7 @@\n+    public long getTotalThreadAllocatedBytes() {\n+        if (isThreadAllocatedMemoryEnabled()) {\n+            return getTotalThreadAllocatedMemory();\n+        }\n+        return -1;\n+    }\n+\n@@ -510,0 +517,1 @@\n+    private static native long getTotalThreadAllocatedMemory();\n","filename":"jdk\/src\/share\/classes\/sun\/management\/ThreadImpl.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -221,1 +221,2 @@\n-  void*        reserved1;\n+  jlong        (JNICALL *GetTotalThreadAllocatedMemory)\n+                                                 (JNIEnv *env);\n","filename":"jdk\/src\/share\/javavm\/export\/jmm.h","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,1 @@\n-  return jmm_interface->GetOneThreadAllocatedMemory(env, tid);\n+    return jmm_interface->GetOneThreadAllocatedMemory(env, tid);\n@@ -111,0 +111,7 @@\n+JNIEXPORT jlong JNICALL\n+Java_sun_management_ThreadImpl_getTotalThreadAllocatedMemory\n+  (JNIEnv *env, jclass cls)\n+{\n+    return jmm_interface->GetTotalThreadAllocatedMemory(env);\n+}\n+\n","filename":"jdk\/src\/share\/native\/sun\/management\/ThreadImpl.c","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug     6173675 8231209\n+ * @bug     6173675 8231209 8304074\n@@ -36,0 +36,1 @@\n+    private static boolean testFailed = false;\n@@ -58,0 +59,7 @@\n+        \/\/ Test cumulative Java thread allocation since JVM launch\n+        testGetTotalThreadAllocatedBytes();\n+\n+        if (testFailed) {\n+            throw new RuntimeException(\"TEST FAILED\");\n+        }\n+\n@@ -95,0 +103,2 @@\n+        Thread curThread = Thread.currentThread();\n+\n@@ -96,1 +106,1 @@\n-        ensureValidSize(size);\n+        ensureValidSize(curThread, size);\n@@ -101,1 +111,1 @@\n-        checkResult(Thread.currentThread(), size,\n+        checkResult(curThread, size,\n@@ -110,1 +120,1 @@\n-        ensureValidSize(size);\n+        ensureValidSize(curThread, size);\n@@ -122,1 +132,2 @@\n-        done = false; done1 = false;\n+        done = false;\n+        done1 = false;\n@@ -131,1 +142,1 @@\n-        ensureValidSize(size);\n+        ensureValidSize(curThread, size);\n@@ -155,2 +166,1 @@\n-            System.out.println(\"Unexpected exception is thrown.\");\n-            e.printStackTrace(System.out);\n+            reportUnexpected(e, \"during join\");\n@@ -164,1 +174,2 @@\n-        done = false; done1 = false;\n+        done = false;\n+        done1 = false;\n@@ -175,1 +186,1 @@\n-            ensureValidSize(sizes[i]);\n+            ensureValidSize(threads[i], sizes[i]);\n@@ -204,2 +215,1 @@\n-                System.out.println(\"Unexpected exception is thrown.\");\n-                e.printStackTrace(System.out);\n+                reportUnexpected(e, \"during join\");\n@@ -211,1 +221,61 @@\n-    private static void ensureValidSize(long size) {\n+    private static void testGetTotalThreadAllocatedBytes()\n+        throws Exception {\n+\n+        \/\/ baseline should be positive\n+        Thread curThread = Thread.currentThread();\n+        long cumulativeSize = mbean.getTotalThreadAllocatedBytes();\n+        if (cumulativeSize <= 0) {\n+            throw new RuntimeException(\n+                \"Invalid allocated bytes returned for \" + curThread.getName() + \" = \" + cumulativeSize);\n+        }\n+\n+        \/\/ start threads\n+        done = false;\n+        done1 = false;\n+        for (int i = 0; i < NUM_THREADS; i++) {\n+            threads[i] = new MyThread(\"MyThread-\" + i);\n+            threads[i].start();\n+        }\n+\n+        \/\/ wait for threads to block after doing some allocation\n+        waitUntilThreadsBlocked();\n+\n+        \/\/ check after threads are blocked\n+        cumulativeSize = checkResult(curThread, cumulativeSize, mbean.getTotalThreadAllocatedBytes());\n+\n+        \/\/ let threads go to do some more allocation\n+        synchronized (obj) {\n+            done = true;\n+            obj.notifyAll();\n+        }\n+\n+        \/\/ wait for threads to get going again. we don't care if we\n+        \/\/ catch them in mid-execution or if some of them haven't\n+        \/\/ restarted after we're done sleeping.\n+        goSleep(400);\n+\n+        System.out.println(\"Done sleeping\");\n+\n+        \/\/ check while threads are running\n+        cumulativeSize = checkResult(curThread, cumulativeSize, mbean.getTotalThreadAllocatedBytes());\n+\n+        \/\/ let threads exit\n+        synchronized (obj) {\n+            done1 = true;\n+            obj.notifyAll();\n+        }\n+\n+        for (int i = 0; i < NUM_THREADS; i++) {\n+            try {\n+                threads[i].join();\n+            } catch (InterruptedException e) {\n+                reportUnexpected(e, \"during join\");\n+                break;\n+            }\n+        }\n+\n+        \/\/ check after threads exit\n+        checkResult(curThread, cumulativeSize, mbean.getTotalThreadAllocatedBytes());\n+    }\n+\n+    private static void ensureValidSize(Thread curThread, long size) {\n@@ -216,1 +286,2 @@\n-                \"Invalid allocated bytes returned = \" + size);\n+                \"Invalid allocated bytes returned for thread \" +\n+                curThread.getName() + \" = \" + size);\n@@ -220,6 +291,2 @@\n-    private static void checkResult(Thread curThread,\n-                                    long prev_size, long curr_size) {\n-        if (curr_size < prev_size) {\n-            throw new RuntimeException(\"Allocated bytes \" + curr_size +\n-                                       \" expected >= \" + prev_size);\n-        }\n+    private static long checkResult(Thread curThread,\n+                                    long prevSize, long currSize) {\n@@ -227,2 +294,15 @@\n-                           \" Previous allocated bytes = \" + prev_size +\n-                           \" Current allocated bytes = \" + curr_size);\n+                           \" Previous allocated bytes = \" + prevSize +\n+                           \" Current allocated bytes = \" + currSize);\n+        if (currSize < prevSize) {\n+            throw new RuntimeException(\"TEST FAILED: \" +\n+                                       curThread.getName() +\n+                                       \" previous allocated bytes = \" + prevSize +\n+                                       \" > current allocated bytes = \" + currSize);\n+        }\n+        return currSize;\n+    }\n+\n+    private static void reportUnexpected(Exception e, String when) {\n+        System.out.println(\"Unexpected exception thrown \" + when + \".\");\n+        e.printStackTrace(System.out);\n+        testFailed = true;\n@@ -235,1 +315,0 @@\n-            System.out.println(\"Unexpected exception is thrown.\");\n@@ -290,2 +369,1 @@\n-                        System.out.println(\"Unexpected exception is thrown.\");\n-                        e.printStackTrace(System.out);\n+                        reportUnexpected(e, \"while !done\");\n@@ -297,1 +375,1 @@\n-            long size1 = mbean.getThreadAllocatedBytes(getId());\n+            long prevSize = mbean.getThreadAllocatedBytes(getId());\n@@ -299,11 +377,2 @@\n-            long size2 = mbean.getThreadAllocatedBytes(getId());\n-\n-            System.out.println(getName() + \": \" +\n-                \"ThreadAllocatedBytes  = \" + size1 +\n-                \" ThreadAllocatedBytes  = \" + size2);\n-\n-            if (size1 > size2) {\n-                throw new RuntimeException(getName() +\n-                    \" ThreadAllocatedBytes = \" + size1 +\n-                    \" > ThreadAllocatedBytes = \" + size2);\n-            }\n+            long currSize = mbean.getThreadAllocatedBytes(getId());\n+            checkResult(this, prevSize, currSize);\n@@ -316,2 +385,1 @@\n-                        System.out.println(\"Unexpected exception is thrown.\");\n-                        e.printStackTrace(System.out);\n+                        reportUnexpected(e, \"while !done1\");\n","filename":"jdk\/test\/com\/sun\/management\/ThreadMXBean\/ThreadAllocatedMemory.java","additions":108,"deletions":40,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n-\n@@ -62,1 +61,0 @@\n-\n@@ -120,2 +118,1 @@\n-        long[] sizes1 = mbean.getThreadAllocatedBytes(ids);\n-\n+        long[] afterSizes = mbean.getThreadAllocatedBytes(ids);\n@@ -123,10 +120,1 @@\n-            long newSize = sizes1[i];\n-            if (sizes[i] > newSize) {\n-                throw new RuntimeException(\"TEST FAILED: \" +\n-                    threads[i].getName() +\n-                    \" previous allocated bytes = \" + sizes[i] +\n-                    \" > current allocated bytes = \" + newSize);\n-            }\n-            System.out.println(threads[i].getName() +\n-                \" Previous allocated bytes = \" + sizes[i] +\n-                \" Current allocated bytes = \" + newSize);\n+            checkResult(threads[i], sizes[i], afterSizes[i]);\n@@ -150,1 +138,0 @@\n-\n@@ -161,3 +148,1 @@\n-                System.out.println(\"Unexpected exception is thrown.\");\n-                e.printStackTrace(System.out);\n-                testFailed = true;\n+                reportUnexpected(e, \"during join\");\n@@ -176,0 +161,20 @@\n+    private static void checkResult(Thread curThread,\n+                                    long prevSize, long currSize) {\n+        System.out.println(curThread.getName() +\n+                           \" Previous allocated bytes = \" + prevSize +\n+                           \" Current allocated bytes = \" + currSize);\n+        if (currSize < prevSize) {\n+            throw new RuntimeException(\"TEST FAILED: \" +\n+                                       curThread.getName() +\n+                                       \" previous allocated bytes = \" + prevSize +\n+                                       \" > current allocated bytes = \" + currSize);\n+\n+        }\n+    }\n+\n+    private static void reportUnexpected(Exception e, String when) {\n+        System.out.println(\"Unexpected exception thrown \" + when + \".\");\n+        e.printStackTrace(System.out);\n+        testFailed = true;\n+    }\n+\n@@ -180,1 +185,0 @@\n-            System.out.println(\"Unexpected exception is thrown.\");\n@@ -224,3 +228,1 @@\n-                        System.out.println(\"Unexpected exception is thrown.\");\n-                        e.printStackTrace(System.out);\n-                        testFailed = true;\n+                        reportUnexpected(e, \"while !done\");\n@@ -239,3 +241,1 @@\n-                        System.out.println(\"Unexpected exception is thrown.\");\n-                        e.printStackTrace(System.out);\n-                        testFailed = true;\n+                        reportUnexpected(e, \"while !done\");\n","filename":"jdk\/test\/com\/sun\/management\/ThreadMXBean\/ThreadAllocatedMemoryArray.java","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"}]}