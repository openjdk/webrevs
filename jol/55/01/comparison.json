{"files":[{"patch":"@@ -44,8 +44,10 @@\n-    Available modes:\n-             estimates: Simulate the class layout in different VM modes.\n-             externals: Show the object externals: the objects reachable from a given instance.\n-             footprint: Estimate the footprint of all objects reachable from a given instance\n-         heapdumpstats: Consume the heap dump and print the most frequent instances.\n-             internals: Show the object internals: field layout and default contents, object header\n-                shapes: Dump the object shapes present in JAR files or heap dumps.\n-       string-compress: Consume the heap dumps and figures out the savings attainable with compressed strings.\n+    Available operations:\n+                 externals: Show object externals: objects reachable from a given instance\n+                 footprint: Show the footprint of all objects reachable from a sample instance\n+            heapdump-boxes: Read a heap dump and look for duplicate primitive boxes\n+       heapdump-duplicates: Read a heap dump and look for probable duplicates\n+        heapdump-estimates: Read a heap dump and estimate footprint in different VM modes\n+            heapdump-stats: Read a heap dump and print simple statistics\n+          heapdump-strings: Read a heap dump and look for duplicate Strings\n+                 internals: Show object internals: field layout, default contents, object header\n+       internals-estimates: Same as 'internals', but simulate class layout in different VM modes\n@@ -60,6 +62,8 @@\n-    # Running 64-bit HotSpot VM.\n-    # Using compressed oop with 3-bit shift.\n-    # Using compressed klass with 3-bit shift.\n-    # Objects are 8 bytes aligned.\n-    # Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\n-    # Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\n+    # VM mode: 64 bits\n+    # Compressed references (oops): 3-bit shift\n+    # Compressed class pointers: 3-bit shift\n+    # Object alignment: 8 bytes\n+    #                       ref, bool, byte, char, shrt,  int,  flt,  lng,  dbl\n+    # Field sizes:            4,    1,    1,    2,    2,    4,    4,    8,    8\n+    # Array element sizes:    4,    1,    1,    2,    2,    4,    4,    8,    8\n+    # Array base offsets:    16,   16,   16,   16,   16,   16,   16,   16,   16\n@@ -71,2 +75,2 @@\n-      0   8                            (object header: mark)     0x0000000000000005 (biasable; age: 0)\n-      8   4                            (object header: class)    0x00019828\n+      0   8                            (object header: mark)     0x0000000000000001 (non-biasable; age: 0)\n+      8   4                            (object header: class)    0x000afde8\n@@ -85,0 +89,53 @@\n+#### \"internals-estimates\"\n+\n+This is like `internals`, but simulate the layout in different VM modes. The tools would group similar layouts together,\n+and sort by instance size, descending.\n+\n+    % java -jar jol-cli\/target\/jol-cli.jar internals-estimates java.lang.Integer\n+    # VM mode: 64 bits\n+    # Compressed references (oops): 3-bit shift\n+    # Compressed class pointers: 3-bit shift\n+    # Object alignment: 8 bytes\n+    #                       ref, bool, byte, char, shrt,  int,  flt,  lng,  dbl\n+    # Field sizes:            4,    1,    1,    2,    2,    4,    4,    8,    8\n+    # Array element sizes:    4,    1,    1,    2,    2,    4,    4,    8,    8\n+    # Array base offsets:    16,   16,   16,   16,   16,   16,   16,   16,   16\n+\n+    ***** Hotspot Layout Simulation (JDK 8, 64-bit model, NO compressed references, NO compressed classes, 8-byte aligned)\n+    ***** Hotspot Layout Simulation (JDK 15, 64-bit model, NO compressed references, NO compressed classes, 8-byte aligned)\n+\n+    java.lang.Integer object internals:\n+    OFF  SZ   TYPE DESCRIPTION               VALUE\n+      0   8        (object header: mark)     N\/A\n+      8   8        (object header: class)    N\/A\n+     16   4    int Integer.value             N\/A\n+     20   4        (object alignment gap)\n+    Instance size: 24 bytes\n+    Space losses: 0 bytes internal + 4 bytes external = 4 bytes total\n+\n+    ***** Hotspot Layout Simulation (JDK 8, 64-bit model, compressed references, compressed classes, 8-byte aligned)\n+    ***** Hotspot Layout Simulation (JDK 8, 64-bit model, compressed references, compressed classes, 16-byte aligned)\n+    ***** Hotspot Layout Simulation (JDK 15, 64-bit model, compressed references, compressed classes, 8-byte aligned)\n+    ***** Hotspot Layout Simulation (JDK 15, 64-bit model, compressed references, compressed classes, 16-byte aligned)\n+    ***** Hotspot Layout Simulation (JDK 15, 64-bit model, NO compressed references, compressed classes, 8-byte aligned)\n+    ***** Hotspot Layout Simulation (JDK 15, 64-bit model, NO compressed references, compressed classes, 16-byte aligned)\n+\n+    java.lang.Integer object internals:\n+    OFF  SZ   TYPE DESCRIPTION               VALUE\n+      0   8        (object header: mark)     N\/A\n+      8   4        (object header: class)    N\/A\n+     12   4    int Integer.value             N\/A\n+    Instance size: 16 bytes\n+    Space losses: 0 bytes internal + 0 bytes external = 0 bytes total\n+\n+    ***** Hotspot Layout Simulation (JDK 99, 64-bit model, Lilliput (ultimate target), NO compressed references, compressed classes, 8-byte aligned)\n+    ***** Hotspot Layout Simulation (JDK 99, 64-bit model, Lilliput (ultimate target), compressed references, compressed classes, 8-byte aligned)\n+\n+    java.lang.Integer object internals:\n+    OFF  SZ   TYPE DESCRIPTION               VALUE\n+      0   1        (object header: mark)     N\/A\n+      1   3        (object header: class)    N\/A\n+      4   4    int Integer.value             N\/A\n+    Instance size: 8 bytes\n+    Space losses: 0 bytes internal + 0 bytes external = 0 bytes total\n+\n@@ -92,6 +149,8 @@\n-    # Running 64-bit HotSpot VM.\n-    # Using compressed oop with 3-bit shift.\n-    # Using compressed klass with 3-bit shift.\n-    # Objects are 8 bytes aligned.\n-    # Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\n-    # Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\n+    # VM mode: 64 bits\n+    # Compressed references (oops): 3-bit shift\n+    # Compressed class pointers: 3-bit shift\n+    # Object alignment: 8 bytes\n+    #                       ref, bool, byte, char, shrt,  int,  flt,  lng,  dbl\n+    # Field sizes:            4,    1,    1,    2,    2,    4,    4,    8,    8\n+    # Array element sizes:    4,    1,    1,    2,    2,    4,    4,    8,    8\n+    # Array base offsets:    16,   16,   16,   16,   16,   16,   16,   16,   16\n@@ -101,5 +160,5 @@\n-    java.lang.String@64cee07d object externals:\n-         ADDRESS       SIZE TYPE             PATH                           VALUE\n-       58010a600         16 [C               .value                         []\n-       58010a610    8923824 (something else) (somewhere else)               (something else)\n-       58098d0c0         24 java.lang.String                                (object)\n+    java.lang.String@61f8bee4d object externals:\n+              ADDRESS       SIZE TYPE             PATH                           VALUE\n+            61fa01280         24 java.lang.String                                (object)\n+            61fa01298 8055156072 (something else) (somewhere else)               (something else)\n+            7ffc00000         16 byte[]           .value                         []\n@@ -113,7 +172,9 @@\n-    $ java -jar jol-cli\/target\/jol-cli.jar footprint java.lang.Thread\n-    # Running 64-bit HotSpot VM.\n-    # Using compressed oop with 3-bit shift.\n-    # Using compressed klass with 3-bit shift.\n-    # Objects are 8 bytes aligned.\n-    # Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\n-    # Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\n+    $ java -jar jol-cli.jar footprint java.security.SecureRandom\n+    # VM mode: 64 bits\n+    # Compressed references (oops): 3-bit shift\n+    # Compressed class pointers: 3-bit shift\n+    # Object alignment: 8 bytes\n+    #                       ref, bool, byte, char, shrt,  int,  flt,  lng,  dbl\n+    # Field sizes:            4,    1,    1,    2,    2,    4,    4,    8,    8\n+    # Array element sizes:    4,    1,    1,    2,    2,    4,    4,    8,    8\n+    # Array base offsets:    16,   16,   16,   16,   16,   16,   16,   16,   16\n@@ -123,12 +184,375 @@\n-    java.lang.Thread@64cee07d footprint:\n-    COUNT       AVG       SUM   DESCRIPTION\n-       13        84      1104   [B\n-      496        67     33400   [C\n-      139        23      3272   [Ljava.lang.Class;\n-       17        89      1520   [Ljava.lang.Object;\n-     ...\n-        1        24        24   sun.reflect.generics.tree.ClassSignature\n-        3        16        48   sun.reflect.generics.tree.ClassTypeSignature\n-        2        24        48   sun.reflect.generics.tree.FormalTypeParameter\n-        3        24        72   sun.reflect.generics.tree.SimpleClassTypeSignature\n-     2849              200416   (total)\n+    java.security.SecureRandom@7fac631bd footprint:\n+\n+    Table is sorted by \"SUM\".\n+    Printing first 30 lines. Use -DprintFirst=# to override.\n+\n+               COUNT             AVG             SUM    DESCRIPTION\n+    ------------------------------------------------------------------------------------------------\n+                 488              46          22.504    byte[]\n+                 488              24          11.712    java.lang.String\n+                 318              32          10.176    java.util.concurrent.ConcurrentHashMap.Node\n+                  53              64           3.392    java.security.Provider.Service\n+                  41              80           3.280    java.util.HashMap.Node[]\n+                   2           1.552           3.104    java.util.concurrent.ConcurrentHashMap.Node[]\n+                 124              24           2.976    java.security.Provider.ServiceKey\n+                  66              32           2.112    java.util.HashMap.Node\n+                  40              48           1.920    java.util.HashMap\n+                  66              24           1.584    java.security.Provider.UString\n+                  26              28             752    java.lang.Object[]\n+                  40              16             640    java.util.HashMap.EntrySet\n+                  26              24             624    java.util.ArrayList\n+                  14              32             448    java.security.Provider.EngineDescription\n+                   5              72             360    java.lang.reflect.Field\n+                   4              72             288    java.lang.reflect.Constructor\n+                   2             128             256    java.lang.Class\n+                   5              40             200    java.util.LinkedHashMap.Entry\n+                   1             144             144    java.lang.ClassValue.Entry[]\n+                   2              64             128    java.lang.Class.ReflectionData\n+                   2              64             128    java.util.concurrent.ConcurrentHashMap\n+                   1             104             104    sun.security.provider.Sun\n+                   1              80              80    java.util.WeakHashMap.Entry[]\n+                   2              40              80    java.lang.ref.SoftReference\n+                   1              64              64    java.lang.ClassValue.ClassValueMap\n+                   2              32              64    java.lang.ClassValue.Entry\n+                   1              64              64    java.security.SecureRandom\n+                   2              28              56    java.lang.reflect.Field[]\n+                   1              56              56    java.lang.Module\n+                   1              56              56    java.util.LinkedHashMap\n+                 ...             ...             ...    ...\n+                  16             320             360    <other>\n+    ------------------------------------------------------------------------------------------------\n+               1.841           3.454          67.712    <total>\n+\n+#### \"heapdump-stats\"\n+\n+Read the heap dump and look into high-level stats for it. The tool runs on heap dump in single pass,\n+and takes only a little additional memory. This allows processing huge heap dumps on small machines.\n+\n+    $ java -jar jol-cli.jar heapdump-stats sample-clion.hprof.gz\n+    Heap Dump: sample-clion.hprof.gz\n+    Read progress: 269M... 538M... 808M... 1077M... 1346M... 1616M... DONE\n+\n+    Hotspot Layout Simulation (JDK 17, Current VM: 12-byte object headers, 4-byte references, 8-byte aligned objects, 8-byte aligned array bases)\n+\n+    === Class Histogram\n+\n+    Table is sorted by \"SUM SIZE\".\n+    Printing first 30 lines. Use -DprintFirst=# to override.\n+\n+           INSTANCES            SIZE        SUM SIZE    CLASS\n+    ------------------------------------------------------------------------------------------------\n+               2.091          65.560     137.085.960    java.lang.Object[16385]\n+           1.533.042              40      61.321.680    java.util.WeakHashMap$Entry\n+           1.595.624              24      38.294.976    java.lang.String\n+               4.627           8.216      38.015.432    java.lang.Object[2049]\n+           1.074.313              32      34.378.016    java.util.HashMap$Node\n+             758.446              40      30.337.840    com.jetbrains.cidr.lang.symbols.cpp.OCMacroSymbol\n+             816.693              32      26.134.176    java.util.concurrent.ConcurrentHashMap$Node\n+             591.407              40      23.656.280    com.intellij.util.containers.ConcurrentWeakKeySoftValueHashMap$WeakKey\n+             828.635              24      19.887.240    java.util.ArrayList\n+             612.098              32      19.587.136    com.jetbrains.cidr.lang.types.OCReferenceTypeSimple\n+             598.784              32      19.161.088    com.jetbrains.cidr.lang.symbols.OCSymbolReference$GlobalReference\n+             591.328              32      18.922.496    com.intellij.util.containers.ConcurrentWeakKeyWeakValueHashMap$WeakValue\n+             203.545              80      16.283.600    com.jetbrains.cidr.lang.symbols.cpp.OCDeclaratorSymbolImpl\n+             223.655              72      16.103.160    com.jetbrains.cidr.lang.symbols.cpp.OCFunctionSymbol\n+                   1      12.217.040      12.217.040    byte[12217024]\n+             234.724              40       9.388.960    com.jetbrains.cidr.lang.types.OCFunctionType\n+               1.132           8.208       9.291.456    java.util.WeakHashMap$Entry[2048]\n+             229.218              40       9.168.720    com.jetbrains.cidr.lang.types.OCPointerType\n+              53.663             152       8.156.776    java.lang.Object[33]\n+             143.195              56       8.018.920    java.lang.Object[10]\n+               1.612           4.120       6.641.440    java.lang.Object[1025]\n+             249.059              24       5.977.416    com.jetbrains.cidr.lang.symbols.OCQualifiedName\n+                 160          32.784       5.245.440    byte[32768]\n+                 817           6.160       5.032.720    int[1536]\n+             194.279              24       4.662.696    java.lang.Object[1]\n+               1.081           4.112       4.445.072    java.util.HashMap$Node[1024]\n+                   2       2.097.168       4.194.336    java.util.concurrent.ConcurrentHashMap$Node[524288]\n+                   1       4.194.320       4.194.320    byte[4194304]\n+              65.486              56       3.667.216    com.intellij.psi.impl.source.tree.CompositeElement\n+              33.534             104       3.487.536    com.jetbrains.cidr.lang.symbols.cpp.OCStructSymbol\n+                 ...             ...             ...    ...\n+           6.783.781      42.772.496     339.519.840    <other>\n+    ------------------------------------------------------------------------------------------------\n+          17.426.033      61.411.160     942.478.984    <total>\n+\n+\n+#### \"heapdump-estimates\"\n+\n+Read the heap dump and project the footprint in different VM modes. The tool runs on heap dump in single pass,\n+and takes only a little additional memory. This allows processing huge heap dumps on small machines. It is useful\n+to explore if compressed references would pay off with larger alignments, if experimental features like Lilliput\n+expect to bring a benefit to workload, or if the upgrade to newer JDK or downgrade lower bitness JDK would make sense.\n+\n+    $ java -jar jol-cli.jar heapdump-estimates sample-clion.hprof.gz\n+    Heap Dump: sample-clion.hprof.gz\n+\n+    'Overhead' comes from additional metadata, representation and alignment losses.\n+    'JVM mode' is the relative footprint change compared to the best JVM mode in this JDK.\n+    'Upgrade From' is the relative footprint change against the same mode in other JDKs.\n+\n+    Read progress: 269M... 538M... 808M... 1077M... 1346M... 1616M... DONE\n+\n+    === Overall Statistics\n+\n+       17426K,     Total objects\n+         682M,     Total data size\n+        39,15,     Average data per object\n+\n+    === Stock 32-bit OpenJDK\n+\n+    Footprint,   Overhead,     Description\n+         897M,     +31,6%,     32-bit (<4 GB heap)\n+\n+    === Stock 64-bit OpenJDK (JDK < 15)\n+\n+    Footprint,   Overhead,   JVM Mode,     Description\n+        1526M,    +123,8%,     +61,9%,     64-bit, no comp refs (>32 GB heap, default align)\n+         942M,     +38,2%,         0%,     64-bit, comp refs (<32 GB heap, default align)\n+        1026M,     +50,5%,      +8,9%,     64-bit, comp refs with large align (   32..64GB heap,  16-byte align)\n+        1133M,     +66,2%,     +20,2%,     64-bit, comp refs with large align (  64..128GB heap,  32-byte align)\n+        1499M,    +119,8%,     +59,0%,     64-bit, comp refs with large align ( 128..256GB heap,  64-byte align)\n+        2556M,    +274,7%,    +171,1%,     64-bit, comp refs with large align ( 256..512GB heap, 128-byte align)\n+        4768M,    +599,1%,    +405,7%,     64-bit, comp refs with large align (512..1024GB heap, 256-byte align)\n+\n+    === Stock 64-bit OpenJDK (JDK >= 15)\n+\n+                                         Upgrade From:\n+    Footprint,   Overhead,   JVM Mode,   JDK < 15,     Description\n+        1423M,    +108,6%,     +51,0%,      -6,8%,     64-bit, no comp refs, but comp classes (>32 GB heap, default align)\n+         942M,     +38,2%,         0%,        ~0%,     64-bit, comp refs (<32 GB heap, default align)\n+        1026M,     +50,4%,      +8,9%,        ~0%,     64-bit, comp refs with large align (   32..64GB heap,  16-byte align)\n+        1132M,     +66,0%,     +20,1%,      -0,1%,     64-bit, comp refs with large align (  64..128GB heap,  32-byte align)\n+        1498M,    +119,6%,     +59,0%,        ~0%,     64-bit, comp refs with large align ( 128..256GB heap,  64-byte align)\n+        2556M,    +274,7%,    +171,2%,        ~0%,     64-bit, comp refs with large align ( 256..512GB heap, 128-byte align)\n+        4768M,    +599,1%,    +406,0%,         0%,     64-bit, comp refs with large align (512..1024GB heap, 256-byte align)\n+\n+    === Experimental 64-bit OpenJDK: Lilliput, 64-bit headers\n+\n+                                         Upgrade From:\n+    Footprint,   Overhead,   JVM Mode,   JDK < 15,  JDK >= 15,     Description\n+        1373M,    +101,3%,     +51,9%,     -10,0%,      -3,5%,     64-bit, no comp refs, but comp classes (>32 GB heap, default align)\n+         904M,     +32,6%,         0%,      -4,1%,      -4,0%,     64-bit, comp refs (<32 GB heap, default align)\n+        1001M,     +46,8%,     +10,7%,      -2,5%,      -2,4%,     64-bit, comp refs with large align (   32..64GB heap,  16-byte align)\n+        1116M,     +63,6%,     +23,4%,      -1,5%,      -1,4%,     64-bit, comp refs with large align (  64..128GB heap,  32-byte align)\n+        1496M,    +119,3%,     +65,4%,      -0,2%,      -0,1%,     64-bit, comp refs with large align ( 128..256GB heap,  64-byte align)\n+        2556M,    +274,7%,    +182,6%,        ~0%,        ~0%,     64-bit, comp refs with large align ( 256..512GB heap, 128-byte align)\n+        4768M,    +599,1%,    +427,3%,         0%,         0%,     64-bit, comp refs with large align (512..1024GB heap, 256-byte align)\n+\n+    === Experimental 64-bit OpenJDK: Lilliput, 32-bit headers\n+\n+                                         Upgrade From:\n+    Footprint,   Overhead,   JVM Mode,   JDK < 15,  JDK >= 15,    Lill-64,      Description\n+        1283M,     +88,2%,     +59,8%,     -15,9%,      -9,8%,      -6,5%,      64-bit, no comp refs, but comp classes (>32 GB heap, default align)\n+         803M,     +17,7%,         0%,     -14,8%,     -14,8%,     -11,2%,      64-bit, comp refs (<32 GB heap, default align)\n+         858M,     +25,9%,      +6,9%,     -16,4%,     -16,3%,     -14,2%,      64-bit, comp refs with large align (   32..64GB heap,  16-byte align)\n+         972M,     +42,5%,     +21,0%,     -14,2%,     -14,1%,     -12,9%,      64-bit, comp refs with large align (  64..128GB heap,  32-byte align)\n+        1477M,    +116,5%,     +83,9%,      -1,5%,      -1,4%,      -1,3%,      64-bit, comp refs with large align ( 128..256GB heap,  64-byte align)\n+        2554M,    +274,5%,    +218,1%,     -46,4%,        ~0%,        ~0%,      64-bit, comp refs with large align ( 256..512GB heap, 128-byte align)\n+        4768M,    +599,0%,    +493,8%,        ~0%,        ~0%,        ~0%,      64-bit, comp refs with large align (512..1024GB heap, 256-byte align)\n+\n+\n+#### \"heapdump-duplicates\"\n+\n+Reads the heap dump and tries to identify the objects that have the same contents. These objects might be de-duplicated,\n+if possible. It would print both the summary report, and more verbose report per class. The tool runs on heap dump in single pass,\n+and takes some memory to store hashes for duplicate objects. This allows processing huge heap dumps without having lots\n+of memory. Bump the heap size for the tool if heap dump does not fit.\n+\n+    $ java -jar jol-cli.jar heapdump-duplicates sample-clion.hprof.gz\n+    Heap Dump: sample-clion.hprof.gz\n+    Read progress: 269M... 538M... 808M... 1077M... 1346M... 1616M... DONE\n+\n+    Hotspot Layout Simulation (JDK 17, Current VM: 12-byte object headers, 4-byte references, 8-byte aligned objects, 8-byte aligned array bases)\n+\n+    Heap dump contains 17.426.033 objects, 942.478.984 bytes in total.\n+\n+    === Potential Duplication Candidates\n+\n+    Table is sorted by \"SUM SIZE\".\n+    Printing first 30 lines. Use -DprintFirst=# to override.\n+\n+                DUPS        SUM SIZE    CLASS\n+    ------------------------------------------------------------------------------------------------\n+             449.993     124.302.944    Object[]\n+             656.318      31.629.792    byte[]\n+             661.645      26.465.800    com.jetbrains.cidr.lang.symbols.cpp.OCMacroSymbol\n+             610.393      19.532.576    java.util.HashMap$Node\n+             177.670       6.566.216    int[]\n+             273.211       6.557.064    java.util.ArrayList\n+              93.361       2.987.552    java.util.concurrent.ConcurrentHashMap$Node\n+              59.492       1.903.744    com.jetbrains.cidr.lang.types.OCReferenceTypeSimple\n+              39.348       1.573.920    com.jetbrains.cidr.lang.types.OCPointerType\n+              62.699       1.504.776    java.lang.String\n+              32.250       1.290.000    org.languagetool.rules.patterns.PatternToken\n+              50.661       1.215.864    com.intellij.openapi.util.Pair\n+               7.536       1.033.872    long[]\n+              25.407       1.016.280    com.jetbrains.cidr.lang.types.OCIntType\n+              63.268       1.012.288    java.util.concurrent.atomic.AtomicReference\n+              29.521         944.672    com.intellij.openapi.vfs.newvfs.impl.VirtualFileImpl\n+              56.675         906.800    java.lang.Integer\n+              21.845         699.040    com.jetbrains.cidr.lang.symbols.OCSymbolReference$GlobalReference\n+              42.183         674.928    java.lang.Object\n+              27.481         659.544    com.intellij.util.keyFMap.OneElementFMap\n+              19.553         625.696    com.jetbrains.cidr.lang.symbols.ComplexTextRange\n+              14.071         562.840    com.intellij.reference.SoftReference\n+               7.288         524.736    java.lang.reflect.Field\n+              21.370         512.880    com.jetbrains.cidr.lang.symbols.OCQualifiedName\n+              12.625         505.000    java.lang.ref.SoftReference\n+              10.224         490.752    java.util.HashMap\n+               2.362         481.664    boolean[]\n+               9.355         449.040    com.jetbrains.cidr.lang.preprocessor.OCMacroForeignLeafType\n+              17.707         424.968    com.jetbrains.cidr.lang.symbols.cpp.OCIncludeSymbol$IncludePath\n+              10.533         421.320    com.jetbrains.cidr.lang.preprocessor.OCMacroReferenceTokenType\n+                 ...             ...    ...\n+             307.252       9.288.760    <other>\n+    ------------------------------------------------------------------------------------------------\n+           3.873.297     246.765.328    <total>\n+\n+    ...\n+\n+    === com.jetbrains.cidr.lang.symbols.cpp.OCMacroSymbol Potential Duplicates\n+      DUPS: Number of instances with same data\n+      SIZE: Total size taken by duplicate instances\n+\n+    Table is sorted by \"SIZE\".\n+    Printing first 30 lines. Use -DprintFirst=# to override.\n+\n+                DUPS            SIZE    VALUE\n+    ------------------------------------------------------------------------------------------------\n+               1.044          41.760    (hash: b3d7653a1b45cdc7)\n+               1.044          41.760    (hash: dba02bbacfe63eb7)\n+               1.044          41.760    (hash: 31921ef6e494ca97)\n+               1.044          41.760    (hash: c2b4fb34818eb9ed)\n+               1.044          41.760    (hash: 31f79d3ace1161ca)\n+               1.044          41.760    (hash: 13f841d0438614c5)\n+               1.044          41.760    (hash: d45cdf077af876ad)\n+               1.044          41.760    (hash: 1b27a7c37cafc70e)\n+    ...\n+\n+#### \"heapdump-boxes\"\n+\n+Similar to `heapdump-duplicates`, but concentrates on primitive boxes. It gives a bit more detailed idea\n+what are the ranges of primitive boxes the workload deals with, and what deduplication\/caching strategies\n+might apply. The tool runs on heap dump in single pass, and takes some memory to store values for duplicate\n+boxes. This allows processing huge heap dumps without having lots of memory. Bump the heap size for the tool\n+if heap dump does not fit.\n+\n+    % java -jar jol-cli.jar heapdump-boxes java_pid92614.hprof\n+    Heap Dump: java_pid92614.hprof\n+    Read progress: DONE\n+\n+    Hotspot Layout Simulation (JDK 17, Current VM: 12-byte object headers, 4-byte references, 8-byte aligned objects, 8-byte aligned array bases)\n+\n+    Heap dump contains 74.750 objects, 3.214.360 bytes in total.\n+\n+    === java.lang.Integer boxes:\n+\n+    Table is sorted by \"VALUE\".\n+\n+                DUPS       SUM BYTES    VALUE\n+    ------------------------------------------------------------------------------------------------\n+                 999          15.984    1000\n+                   5              80    1024\n+    ------------------------------------------------------------------------------------------------\n+\n+    === java.lang.Integer, savings with manual cache, or non-default AutoBoxCacheMax:\n+\n+     SAVED INSTANCES     SAVED BYTES    CACHE SHAPE\n+    ------------------------------------------------------------------------------------------------\n+                   0            -512    Integer[256]\n+                   0          -1.536    Integer[512]\n+                 999          12.400    Integer[1024]\n+               1.004           8.384    Integer[2048]\n+               1.004             192    Integer[4096]\n+               1.004         -16.192    Integer[8192]\n+               1.004         -48.960    Integer[16384]\n+               1.004        -114.496    Integer[32768]\n+               1.004        -245.568    Integer[65536]\n+               1.004        -507.712    Integer[131072]\n+                 ...             ...    ...\n+    ------------------------------------------------------------------------------------------------\n+\n+    === java.lang.Integer, savings with manual cache:\n+\n+     SAVED INSTANCES     SAVED BYTES    CACHE SHAPE\n+    ------------------------------------------------------------------------------------------------\n+              16.064          15.952    HashMap<Integer, Integer>(256)\n+              16.064          15.952    HashMap<Integer, Integer>(512)\n+              16.064          15.952    HashMap<Integer, Integer>(1024)\n+              16.064          15.952    HashMap<Integer, Integer>(2048)\n+              16.064          15.952    HashMap<Integer, Integer>(4096)\n+              16.064          15.952    HashMap<Integer, Integer>(8192)\n+              16.064          15.952    HashMap<Integer, Integer>(16384)\n+              16.064          15.952    HashMap<Integer, Integer>(32768)\n+              16.064          15.952    HashMap<Integer, Integer>(65536)\n+              16.064          15.952    HashMap<Integer, Integer>(131072)\n+              16.064          15.952    HashMap<Integer, Integer>(262144)\n+                 ...             ...    ...\n+    ------------------------------------------------------------------------------------------------\n+\n+#### \"heapdump-strings\"\n+\n+Similar to `heapdump-duplicates`, but concentrates on Strings. It gives a bit more detailed idea\n+how many duplicate Strings are in workload, and what deduplication\/caching strategies might apply. The tool runs\n+on the heap dump in two passes, and takes some memory to store values for duplicate Strings. This allows processing\n+huge heap dumps without having lots of memory. Bump the heap size for the tool if heap dump does not fit.\n+\n+    % java -jar jol-cli.jar heapdump-strings sample-clion.hprof.gz\n+    Heap Dump: sample-clion.hprof.gz\n+\n+    Discovering String objects...\n+    Read progress: 269M... 538M... 808M... 1077M... 1346M... 1616M... DONE\n+\n+    Discovering String contents...\n+    Read progress: 269M... 538M... 808M... 1077M... 1346M... 1616M... DONE\n+\n+    Hotspot Layout Simulation (JDK 17, Current VM: 12-byte object headers, 4-byte references, 8-byte aligned objects, 8-byte aligned array bases)\n+\n+    Heap dump contains 17.426.033 objects, 942.478.984 bytes in total.\n+\n+    === Duplicate Strings\n+      DUPS: Number of duplicated String instances\n+      SIZE (V): Savings due to String.value dedup (automatic by GC)\n+      SIZE (S+V): Savings due to entire String dedup (manual)\n+\n+    Table is sorted by \"SIZE (S+V)\".\n+    Printing first 30 lines. Use -DprintFirst=# to override.\n+\n+                DUPS        SIZE (V)      SIZE (S+V)    VALUE\n+    ------------------------------------------------------------------------------------------------\n+               5.530         575.120         707.840    \/Users\/shipilev\/Work\/shipilev-li... (85 chars)\n+               2.135         307.440         358.680    -I\/Users\/shipilev\/Work\/shipilev-... (123 chars)\n+               2.135         290.360         341.600    -I\/Users\/shipilev\/Work\/shipilev-... (115 chars)\n+               1.937         278.928         325.416    -I\/Users\/shipilev\/Work\/shipilev-... (126 chars)\n+               1.902         273.888         319.536    \/Applications\/Xcode.app\/Contents... (124 chars)\n+               1.937         263.432         309.920    -I\/Users\/shipilev\/Work\/shipilev-... (119 chars)\n+               2.278         236.912         291.584    \/Users\/shipilev\/Work\/shipilev-li... (85 chars)\n+               1.351         248.584         281.008     <a href=\"#insp... (162 chars)\n+               1.903         228.360         274.032    \/Applications\/Xcode.app\/Contents... (98 chars)\n+               2.135         204.960         256.200    -I\/Users\/shipilev\/Work\/shipilev-... (78 chars)\n+               2.135         187.880         239.120    -I\/Users\/shipilev\/Work\/shipilev-... (68 chars)\n+               2.135         187.880         239.120    -I\/Users\/shipilev\/Work\/shipilev-... (65 chars)\n+               2.135         187.880         239.120    -I\/Users\/shipilev\/Work\/shipilev-... (71 chars)\n+               2.135         187.880         239.120    -I\/Users\/shipilev\/Work\/shipilev-... (66 chars)\n+               1.937         185.952         232.440    -I\/Users\/shipilev\/Work\/shipilev-... (76 chars)\n+               1.937         185.952         232.440    -I\/Users\/shipilev\/Work\/shipilev-... (73 chars)\n+                  47         209.808         210.936    {\"Checks\":\"-*,bugprone-argument-... (4447 chars)\n+               1.045         175.560         200.640    \/Users\/shipilev\/Work\/shipilev-li... (150 chars)\n+                   4         192.352         192.448    #define __llvm__ 1 define __cla... (48066 chars)\n+               1.903         106.568         152.240    -DMAC_OS_X_VERSION_MIN_REQUIRED=... (38 chars)\n+               1.091         113.464         139.648    -I\/Users\/shipilev\/Work\/shipilev-... (84 chars)\n+               1.903          91.344         137.016    -mmacosx-version-min=11.00.00\n+               1.902          91.296         136.944    -fno-delete-null-pointer-checks\n+               1.902          91.296         136.944    -Wno-unknown-warning-option\n+               1.085         104.160         130.200    -I\/Users\/shipilev\/Work\/shipilev-... (77 chars)\n+               1.004         104.416         128.512    -I\/Users\/shipilev\/Work\/shipilev-... (81 chars)\n+               1.003         104.312         128.384    -I\/Users\/shipilev\/Work\/shipilev-... (82 chars)\n+               2.250          72.000         126.000    LOCAL_VARIABLE\n+               1.902          76.080         121.728    -Woverloaded-virtual\n+               1.902          76.080         121.728    -Wunused-function\n+               ...             ...             ...    ...\n+             597.115      24.285.016      38.615.776    <other>\n+    ------------------------------------------------------------------------------------------------\n+             651.715      29.925.160      45.566.320    <total>\n+\n@@ -145,2 +569,0 @@\n-If you don't have the access to JDK Bug System, submit the bug report at [Issues](https:\/\/github.com\/openjdk\/jol\/issues) here, and wait for maintainers to pick that up.\n-\n","filename":"README.md","additions":470,"deletions":48,"binary":false,"changes":518,"status":"modified"},{"patch":"@@ -45,0 +45,3 @@\n+        registerOperation(new HeapDumpDuplicates());\n+        registerOperation(new HeapDumpBoxes());\n+        registerOperation(new HeapDumpStrings());\n","filename":"jol-cli\/src\/main\/java\/org\/openjdk\/jol\/Main.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,296 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jol.operations;\n+\n+import org.openjdk.jol.Operation;\n+import org.openjdk.jol.datamodel.ModelVM;\n+import org.openjdk.jol.heap.HeapDumpReader;\n+import org.openjdk.jol.info.ClassData;\n+import org.openjdk.jol.info.ClassLayout;\n+import org.openjdk.jol.info.GraphLayout;\n+import org.openjdk.jol.layouters.HotSpotLayouter;\n+import org.openjdk.jol.layouters.Layouter;\n+import org.openjdk.jol.util.ASCIITable;\n+import org.openjdk.jol.util.ClassUtils;\n+import org.openjdk.jol.util.Multiset;\n+\n+import java.io.*;\n+import java.nio.ByteBuffer;\n+import java.util.*;\n+\n+import static java.lang.System.out;\n+\n+\/**\n+ * @author Aleksey Shipilev\n+ *\/\n+public class HeapDumpBoxes implements Operation {\n+\n+    static final Class<?>[] PRIMITIVE_CLASSES = {\n+            Boolean.class,\n+            Byte.class,\n+            Short.class,\n+            Character.class,\n+            Integer.class,\n+            Float.class,\n+            Long.class,\n+            Double.class\n+    };\n+\n+    @Override\n+    public String label() {\n+        return \"heapdump-boxes\";\n+    }\n+\n+    @Override\n+    public String description() {\n+        return \"Read a heap dump and look for duplicate primitive boxes\";\n+    }\n+\n+    private int getVMVersion() {\n+        try {\n+            return Integer.parseInt(System.getProperty(\"java.specification.version\"));\n+        } catch (Exception e) {\n+            return 8;\n+        }\n+    }\n+\n+    private long manualMarginalCost;\n+    private long arrayMarginalCost;\n+\n+    public void computeMarginalCosts() {\n+        final int base = 1_234_567;\n+        final int size = 1_000_000;\n+        HashMap<Integer, Integer> empty = new HashMap<>();\n+        empty.put(base, base);\n+        empty.remove(base);\n+\n+        HashMap<Integer, Integer> full = new HashMap<>();\n+        for (int i = base; i < base + size; i++) {\n+            full.put(i, i);\n+        }\n+\n+        long intSize = ClassLayout.parseClass(Integer.class).instanceSize();\n+        long emptySize = GraphLayout.parseInstance(empty).totalSize();\n+        long fullSize = GraphLayout.parseInstance(full).totalSize();\n+\n+        manualMarginalCost = (fullSize - emptySize) \/ size - intSize;\n+\n+        long arraySize = ClassLayout.parseInstance(new Integer[size]).instanceSize();\n+        arrayMarginalCost = arraySize \/ size;\n+    }\n+\n+    public void run(String... args) throws Exception {\n+        if (args.length == 0) {\n+            System.err.println(\"Expected a hprof file name.\");\n+            return;\n+        }\n+        String path = args[0];\n+\n+        Layouter layouter = new HotSpotLayouter(new ModelVM(), getVMVersion());\n+\n+        computeMarginalCosts();\n+\n+        out.println(\"Heap Dump: \" + path);\n+\n+        HeapDumpReader.MultiplexingVisitor mv = new HeapDumpReader.MultiplexingVisitor();\n+\n+        Map<Class<?>, BoxVisitor> visitors = new HashMap<>();\n+        for (Class<?> cl : PRIMITIVE_CLASSES) {\n+            BoxVisitor v = new BoxVisitor(cl);\n+            visitors.put(cl, v);\n+            mv.add(v);\n+        }\n+\n+        HeapDumpReader reader = new HeapDumpReader(new File(path), out, mv);\n+        Multiset<ClassData> data = reader.parse();\n+\n+        out.println();\n+        out.println(layouter);\n+        out.println();\n+\n+        long totalSize = 0;\n+        long totalCount = 0;\n+        for (ClassData cd : data.keys()) {\n+            totalSize += layouter.layout(cd).instanceSize() * data.count(cd);\n+            totalCount += data.count(cd);\n+        }\n+\n+        out.printf(\"Heap dump contains %,d objects, %,d bytes in total.%n\", totalCount, totalSize);\n+        out.println();\n+\n+        for (Class<?> cl : PRIMITIVE_CLASSES) {\n+            BoxVisitor v = visitors.get(cl);\n+            v.printOut(out);\n+        }\n+    }\n+\n+    public class BoxVisitor extends HeapDumpReader.Visitor {\n+        private final Multiset<Number> values = new Multiset<>();\n+        private final String clName;\n+        private final Class<?> cl;\n+\n+        public BoxVisitor(Class<?> cl) {\n+            this.clName = ClassUtils.humanReadableName(cl);\n+            this.cl = cl;\n+        }\n+\n+        @Override\n+        public void visitInstance(long id, long klassID, byte[] bytes, String name) {\n+            if (name.equals(clName)) {\n+                switch (clName) {\n+                    case \"java.lang.Byte\":\n+                    case \"java.lang.Boolean\":\n+                        values.add(ByteBuffer.wrap(bytes).get());\n+                        break;\n+                    case \"java.lang.Character\":\n+                    case \"java.lang.Short\":\n+                        values.add(ByteBuffer.wrap(bytes).getShort());\n+                        break;\n+                    case \"java.lang.Integer\":\n+                        values.add(ByteBuffer.wrap(bytes).getInt());\n+                        break;\n+                    case \"java.lang.Float\":\n+                        values.add(ByteBuffer.wrap(bytes).getFloat());\n+                        break;\n+                    case \"java.lang.Long\":\n+                        values.add(ByteBuffer.wrap(bytes).getLong());\n+                        break;\n+                    case \"java.lang.Double\":\n+                        values.add(ByteBuffer.wrap(bytes).getDouble());\n+                        break;\n+                    default:\n+                        throw new IllegalStateException(\"Unknown class: \" + clName);\n+                }\n+            }\n+        }\n+\n+        public void printOut(PrintStream ps) {\n+            boolean hasEntries = false;\n+            for (Number v : values.keys()) {\n+                long count = values.count(v) - 1;\n+                if (count > 0) {\n+                    hasEntries = true;\n+                    break;\n+                }\n+            }\n+\n+            if (!hasEntries) {\n+                \/\/ Empty, nothing to print.\n+                return;\n+            }\n+\n+            long instanceSize = ClassLayout.parseClass(cl).instanceSize();\n+\n+            ASCIITable boxesTable = new ASCIITable(\n+                    false,\n+                    Integer.MAX_VALUE,\n+                    \"=== \" + clName + \" boxes:\",\n+                    \"DUPS\", \"SUM BYTES\", \"VALUE\");\n+\n+            Multiset<Integer> autoBoxCountWins = new Multiset<>();\n+            Multiset<Integer> autoBoxSizeWins = new Multiset<>();\n+\n+            List<Integer> limits = new ArrayList<>();\n+            for (long i = 256; i <= 1024 * 1024 * 1024; i *= 2) {\n+                limits.add((int) i);\n+            }\n+\n+            for (Number v : values.keys()) {\n+                long count = values.count(v) - 1;\n+\n+                if (count > 0) {\n+                    long size = count * instanceSize;\n+                    boxesTable.addLine((Comparable) v, count, size);\n+\n+                    for (int limit : limits) {\n+                        if (-128 <= v.longValue() && v.longValue() < limit) {\n+                            autoBoxCountWins.add(limit, count);\n+                            autoBoxSizeWins.add(limit, size);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            boxesTable.print(ps, 2);\n+\n+            ASCIITable arrayTable = new ASCIITable(\n+                    false,\n+                    Integer.MAX_VALUE,\n+                    (cl.equals(Integer.class) ?\n+                            \"=== \" + clName + \", savings with manual cache, or non-default AutoBoxCacheMax:\" :\n+                            \"=== \" + clName + \", savings with manual cache:\"),\n+                    \"SAVED INSTANCES\", \"SAVED BYTES\", \"CACHE SHAPE\");\n+\n+            for (int limit : limits) {\n+                \/\/ Subtract the overhead for larger holding array\n+                long sizes = autoBoxSizeWins.count(limit) - arrayMarginalCost*(limit - 128);\n+                arrayTable.addLine(cl.getSimpleName() + \"[\" + limit + \"]\", autoBoxCountWins.count(limit), sizes);\n+            }\n+\n+            arrayTable.print(ps, -1);\n+\n+            Multiset<Integer> manualCachePopulation = new Multiset<>();\n+            Multiset<Integer> manualCacheCountWins = new Multiset<>();\n+            Multiset<Integer> manualCacheSizeWins = new Multiset<>();\n+\n+            List<Number> sortedByCount = new ArrayList<>(values.keys());\n+            sortedByCount.sort((c1, c2) -> Long.compare(values.count(c2), values.count(c1)));\n+\n+            int n = 0;\n+            for (Number v : sortedByCount) {\n+                long count = values.count(v) - 1;\n+\n+                if (count > 0) {\n+                    long size = count * instanceSize;\n+\n+                    for (int limit : limits) {\n+                        if (n < limit) {\n+                            manualCacheCountWins.add(limit, count);\n+                            manualCacheSizeWins.add(limit, size);\n+                            manualCachePopulation.add(limit);\n+                        }\n+                    }\n+                    n++;\n+                }\n+            }\n+\n+            String mapName = \"HashMap<\" + cl.getSimpleName() + \", \" + cl.getSimpleName() + \">\";\n+            ASCIITable manualTable = new ASCIITable(\n+                    false,\n+                    Integer.MAX_VALUE,\n+                    \"=== \" + clName + \", savings with manual cache:\",\n+                    \"SAVED INSTANCES\", \"SAVED BYTES\", \"CACHE SHAPE\");\n+\n+            for (int limit : limits) {\n+                long sizes = manualCacheSizeWins.count(limit) - manualMarginalCost*manualCachePopulation.count(limit);\n+                manualTable.addLine(mapName + \"(\" + limit + \")\", manualCacheSizeWins.count(limit), sizes);\n+            }\n+\n+            manualTable.print(ps, -1);\n+        }\n+\n+    }\n+\n+}\n","filename":"jol-cli\/src\/main\/java\/org\/openjdk\/jol\/operations\/HeapDumpBoxes.java","additions":296,"deletions":0,"binary":false,"changes":296,"status":"added"},{"patch":"@@ -0,0 +1,487 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jol.operations;\n+\n+import org.openjdk.jol.Operation;\n+import org.openjdk.jol.datamodel.ModelVM;\n+import org.openjdk.jol.heap.HeapDumpReader;\n+import org.openjdk.jol.info.ClassData;\n+import org.openjdk.jol.layouters.HotSpotLayouter;\n+import org.openjdk.jol.layouters.Layouter;\n+import org.openjdk.jol.util.ASCIITable;\n+import org.openjdk.jol.util.Multiset;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import static java.lang.System.out;\n+\n+\/**\n+ * @author Aleksey Shipilev\n+ *\/\n+public class HeapDumpDuplicates implements Operation {\n+\n+    @Override\n+    public String label() {\n+        return \"heapdump-duplicates\";\n+    }\n+\n+    @Override\n+    public String description() {\n+        return \"Read a heap dump and look for probable duplicates\";\n+    }\n+\n+    private int getVMVersion() {\n+        try {\n+            return Integer.parseInt(System.getProperty(\"java.specification.version\"));\n+        } catch (Exception e) {\n+            return 8;\n+        }\n+    }\n+\n+    public void run(String... args) throws Exception {\n+        if (args.length == 0) {\n+            System.err.println(\"Expected a hprof file name.\");\n+            return;\n+        }\n+        String path = args[0];\n+\n+        Layouter layouter = new HotSpotLayouter(new ModelVM(), getVMVersion());\n+\n+        out.println(\"Heap Dump: \" + path);\n+\n+        HeapDumpReader.MultiplexingVisitor mv = new HeapDumpReader.MultiplexingVisitor();\n+\n+        InstanceVisitor iv = new InstanceVisitor();\n+        mv.add(iv);\n+\n+        ArrayContentsVisitor av = new ArrayContentsVisitor();\n+        mv.add(av);\n+\n+        HeapDumpReader reader = new HeapDumpReader(new File(path), out, mv);\n+        Multiset<ClassData> data = reader.parse();\n+\n+        out.println();\n+        out.println(layouter);\n+        out.println();\n+\n+        long totalSize = 0;\n+        long totalCount = 0;\n+        for (ClassData cd : data.keys()) {\n+            totalSize += layouter.layout(cd).instanceSize() * data.count(cd);\n+            totalCount += data.count(cd);\n+        }\n+\n+        out.printf(\"Heap dump contains %,d objects, %,d bytes in total.%n\", totalCount, totalSize);\n+        out.println();\n+\n+        List<ExcessRow> excesses = new ArrayList<>();\n+        excesses.addAll(iv.compute(layouter));\n+        excesses.addAll(av.compute(layouter));\n+        excesses.sort((c1, c2) -> Long.compare(c2.excessV, c1.excessV));\n+\n+        ASCIITable table = new ASCIITable(\n+                true,\n+                \"=== Potential Duplication Candidates\",\n+                \"DUPS\", \"SUM SIZE\", \"CLASS\");\n+\n+        for (ExcessRow s : excesses) {\n+            table.addLine(s.name, s.excessC, s.excessV);\n+        }\n+        table.print(out, 1);\n+\n+        for (ExcessRow s : excesses) {\n+            out.println(s.fullTable);\n+        }\n+    }\n+\n+    public static class InstanceContents {\n+        private final long contents;\n+        private final boolean contentsIsHash;\n+        private final boolean contentsIsZero;\n+        private final byte contentsLen;\n+\n+        public InstanceContents(byte[] contents) {\n+            if (contents.length <= 8) {\n+                this.contents = bytePrefixToLong(contents);\n+                this.contentsIsZero = byteArrayZero(contents);\n+                this.contentsIsHash = false;\n+                this.contentsLen = (byte) contents.length;\n+            } else {\n+                this.contents = byteArrayHashCode(contents);\n+                this.contentsIsZero = byteArrayZero(contents);\n+                this.contentsIsHash = true;\n+                this.contentsLen = -1;\n+            }\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            InstanceContents that = (InstanceContents) o;\n+            return contents == that.contents && contentsIsHash == that.contentsIsHash;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (int) ((contents >> 32) ^ (contents));\n+        }\n+\n+        public String value() {\n+            if (contentsIsHash) {\n+                if (contentsIsZero) {\n+                    return \"{ 0 }\";\n+                } else {\n+                    return \"(hash: \" + Long.toHexString(contents) + \")\";\n+                }\n+            }\n+\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"{ \");\n+            switch (contentsLen) {\n+                case 1:\n+                    sb.append(contents & 0xFFL);\n+                    break;\n+                case 2:\n+                    sb.append(contents & 0xFFFFL);\n+                    break;\n+                case 4:\n+                    sb.append(contents & 0xFFFF_FFFFL);\n+                    break;\n+                case 8:\n+                    sb.append(contents);\n+                    break;\n+            }\n+            sb.append(\" }\");\n+\n+            return sb.toString();\n+        }\n+    }\n+\n+    public static class HashedArrayContents {\n+        private final int length;\n+        private final String componentType;\n+        private final long contents;\n+        private final boolean contentsIsHash;\n+        private final boolean contentsIsZero;\n+\n+        public HashedArrayContents(int length, String componentType, byte[] contents) {\n+            this.length = length;\n+            this.componentType = componentType;\n+            if (contents.length <= 8) {\n+                this.contents = bytePrefixToLong(contents);\n+                this.contentsIsHash = false;\n+                this.contentsIsZero = byteArrayZero(contents);\n+            } else {\n+                this.contents = byteArrayHashCode(contents);\n+                this.contentsIsHash = true;\n+                this.contentsIsZero = byteArrayZero(contents);\n+            }\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            HashedArrayContents that = (HashedArrayContents) o;\n+            return length == that.length && contents == that.contents && contentsIsHash == that.contentsIsHash && componentType.equals(that.componentType);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (int) ((contents >> 32) ^ (contents));\n+        }\n+\n+        private int unitSize() {\n+            switch (componentType) {\n+                case \"boolean\":\n+                case \"byte\":\n+                    return 1;\n+                case \"short\":\n+                case \"char\":\n+                    return 2;\n+                case \"int\":\n+                case \"float\":\n+                    return 4;\n+                case \"double\":\n+                case \"long\":\n+                    return 8;\n+                default:\n+                    return 4;\n+            }\n+        }\n+\n+        public String value() {\n+            if (contentsIsHash) {\n+                if (contentsIsZero) {\n+                    return componentType + \"[\" + length + \"] { 0, ..., 0 }\";\n+                } else {\n+                    return componentType + \"[\" + length + \"] (hash: \" + Long.toHexString(contents) + \")\";\n+                }\n+            }\n+\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(componentType);\n+            sb.append(\"[\");\n+            sb.append(length);\n+            sb.append(\"] { \");\n+            switch (unitSize()) {\n+                case 1:\n+                    switch (length) {\n+                        case 8:\n+                            sb.append((contents >> 56) & 0xFF);\n+                            sb.append(\", \");\n+                            sb.append((contents >> 48) & 0xFF);\n+                            sb.append(\", \");\n+                            sb.append((contents >> 40) & 0xFF);\n+                            sb.append(\", \");\n+                            sb.append((contents >> 32) & 0xFF);\n+                            sb.append(\", \");\n+                        case 4:\n+                            sb.append((contents >> 24) & 0xFF);\n+                            sb.append(\", \");\n+                            sb.append((contents >> 16) & 0xFF);\n+                            sb.append(\", \");\n+                        case 2:\n+                            sb.append((contents >> 8) & 0xFF);\n+                            sb.append(\", \");\n+                        case 1:\n+                            sb.append((contents >> 0) & 0xFF);\n+                    }\n+                    break;\n+                case 2:\n+                    switch (length) {\n+                        case 4:\n+                            sb.append((contents >> 48) & 0xFFFF);\n+                            sb.append(\", \");\n+                            sb.append((contents >> 32) & 0xFFFF);\n+                            sb.append(\", \");\n+                        case 2:\n+                            sb.append((contents >> 16) & 0xFFFF);\n+                            sb.append(\", \");\n+                        case 1:\n+                            sb.append((contents >> 0) & 0xFFFF);\n+                    }\n+                    break;\n+                case 4:\n+                    switch (length) {\n+                        case 2:\n+                            sb.append((contents >> 32) & 0xFFFF_FFFFL);\n+                            sb.append(\", \");\n+                        case 1:\n+                            sb.append((contents >> 0) & 0xFFFF_FFFFL);\n+                    }\n+                    break;\n+                case 8:\n+                    sb.append(contents);\n+                    break;\n+            }\n+            sb.append(\" }\");\n+\n+            return sb.toString();\n+        }\n+    }\n+\n+    private static long bytePrefixToLong(byte[] src) {\n+        int limit = Math.min(src.length, 8);\n+        long res = 0;\n+        for (int c = 0; c < limit; c++) {\n+            res = (res << 8) + (src[c] & 0xFF);\n+        }\n+        return res;\n+    }\n+\n+    public static long byteArrayHashCode(byte[] src) {\n+        long result = 1;\n+        for (byte e : src) {\n+            result = 31 * result + e;\n+        }\n+        return result;\n+    }\n+\n+    public static boolean byteArrayZero(byte[] src) {\n+        for (byte e : src) {\n+            if (e != 0) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public static class InstanceVisitor extends HeapDumpReader.Visitor {\n+        private final Map<String, Multiset<InstanceContents>> contents = new HashMap<>();\n+        private final Map<String, ClassData> classDatas = new HashMap<>();\n+\n+        @Override\n+        public void visitInstance(long id, long klassID, byte[] bytes, String name) {\n+            Multiset<InstanceContents> conts = contents.get(name);\n+            if (conts == null) {\n+                conts = new Multiset<>();\n+                contents.put(name, conts);\n+            } else {\n+                conts.pruneForSize(1_000_000);\n+            }\n+            conts.add(new InstanceContents(bytes));\n+        }\n+\n+        @Override\n+        public void visitClassData(String name, ClassData cd) {\n+            classDatas.put(name, cd);\n+        }\n+\n+        public List<ExcessRow> compute(Layouter layouter) {\n+            List<ExcessRow> excesses = new ArrayList<>();\n+            for (String name : contents.keySet()) {\n+                Multiset<InstanceContents> ics = contents.get(name);\n+\n+                boolean hasExcess = false;\n+                for (InstanceContents ba : ics.keys()) {\n+                    long count = ics.count(ba);\n+                    if (count > 1) {\n+                        hasExcess = true;\n+                        break;\n+                    }\n+                }\n+\n+                if (!hasExcess) {\n+                    continue;\n+                }\n+\n+                ClassData cd = classDatas.get(name);\n+                if (cd == null) {\n+                    throw new IllegalStateException(\"Internal error: no class data for \" + name);\n+                }\n+\n+                long intSize = layouter.layout(cd).instanceSize();\n+\n+                ASCIITable table = new ASCIITable(\n+                        true,\n+                        \"=== \" + cd.name() + \" Potential Duplicates\\n\" +\n+                        \"  DUPS: Number of instances with same data\\n\" +\n+                        \"  SIZE: Total size taken by duplicate instances\",\n+                        \"DUPS\", \"SIZE\", \"VALUE\");\n+\n+                long excessV = 0;\n+                long excessC = 0;\n+\n+                for (InstanceContents ic : ics.keys()) {\n+                    long count = ics.count(ic) - 1;\n+                    if (count > 0) {\n+                        long sumV = count * intSize;\n+                        table.addLine(ic.value(), count, sumV);\n+                        excessV += sumV;\n+                        excessC += count;\n+                    }\n+                }\n+\n+                StringWriter sw = new StringWriter();\n+                PrintWriter pw = new PrintWriter(sw);\n+                table.print(pw, 1);\n+                excesses.add(new ExcessRow(excessC, excessV, cd.name(), sw.toString()));\n+            }\n+            return excesses;\n+        }\n+    }\n+\n+    public static class ArrayContentsVisitor extends HeapDumpReader.Visitor {\n+        private final Map<String, Multiset<HashedArrayContents>> arrayContents = new HashMap<>();\n+\n+        @Override\n+        public void visitArray(long id, String componentType, int count, byte[] bytes) {\n+            Multiset<HashedArrayContents> conts = arrayContents.get(componentType);\n+            if (conts == null) {\n+                conts = new Multiset<>();\n+                arrayContents.put(componentType, conts);\n+            } else {\n+                conts.pruneForSize(1_000_000);\n+            }\n+            conts.add(new HashedArrayContents(count, componentType, bytes));\n+        }\n+\n+        public List<ExcessRow> compute(Layouter layouter) {\n+            List<ExcessRow> excesses = new ArrayList<>();\n+            for (String componentType : arrayContents.keySet()) {\n+                Multiset<HashedArrayContents> hacs = arrayContents.get(componentType);\n+\n+                boolean hasExcess = false;\n+                for (HashedArrayContents ba : hacs.keys()) {\n+                    long count = hacs.count(ba);\n+                    if (count > 1) {\n+                        hasExcess = true;\n+                        break;\n+                    }\n+                }\n+\n+                if (!hasExcess) {\n+                    continue;\n+                }\n+\n+                ASCIITable table = new ASCIITable(\n+                        true,\n+                        \"=== \" + componentType + \"[] Potential Duplicates\\n\" +\n+                        \"  DUPS: Number of instances with same data\\n\" +\n+                        \"  SIZE: Total size taken by duplicate instances\",\n+                        \"DUPS\", \"SIZE\", \"VALUE\");\n+\n+                long excessV = 0;\n+                long excessC = 0;\n+                for (HashedArrayContents hac : hacs.keys()) {\n+                    long count = hacs.count(hac) - 1;\n+                    if (count > 0) {\n+                        ClassData cd = new ClassData(componentType + \"[]\", componentType, hac.length);\n+                        long intSize = layouter.layout(cd).instanceSize();\n+                        long sumV = count * intSize;\n+                        table.addLine(hac.value(), count, sumV);\n+                        excessV += sumV;\n+                        excessC += count;\n+                    }\n+                }\n+\n+                StringWriter sw = new StringWriter();\n+                PrintWriter pw = new PrintWriter(sw);\n+                table.print(pw, 1);\n+                excesses.add(new ExcessRow(excessC, excessV, componentType + \"[]\", sw.toString()));\n+            }\n+            return excesses;\n+        }\n+\n+    }\n+\n+    private static class ExcessRow {\n+        final long excessC;\n+        final long excessV;\n+        final String name;\n+        final String fullTable;\n+\n+        public ExcessRow(long excessC, long excessV, String name, String fullTable) {\n+            this.excessC = excessC;\n+            this.excessV = excessV;\n+            this.name = name;\n+            this.fullTable = fullTable;\n+        }\n+    }\n+\n+}\n","filename":"jol-cli\/src\/main\/java\/org\/openjdk\/jol\/operations\/HeapDumpDuplicates.java","additions":487,"deletions":0,"binary":false,"changes":487,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+import org.openjdk.jol.util.ASCIITable;\n@@ -74,22 +75,0 @@\n-        final int printFirst = Integer.getInteger(\"printFirst\", 30);\n-        final String sortBy = System.getProperty(\"sort\", \"sum-size\");\n-\n-        final Multiset<String> counts = new Multiset<>();\n-        final Multiset<String> sizes = new Multiset<>();\n-\n-        Comparator<String> sorter;\n-        switch (sortBy) {\n-            case \"sum-size\":\n-                sorter = (o1, o2) -> Long.compare(sizes.count(o2), sizes.count(o1));\n-                break;\n-            case \"avg-size\":\n-                sorter = (o1, o2) -> Double.compare(1D * sizes.count(o2) \/ counts.count(o2),\n-                                                    1D * sizes.count(o1) \/ counts.count(o1));\n-                break;\n-            case \"instances\":\n-                sorter = (o1, o2) -> Long.compare(counts.count(o2), counts.count(o1));\n-                break;\n-            default:\n-                throw new IllegalArgumentException(\"Cannot parse: \" + sortBy);\n-        }\n-\n@@ -101,9 +80,0 @@\n-        for (ClassData cd : data.keys()) {\n-            long size = layouter.layout(cd).instanceSize();\n-            counts.add(cd.name(), data.count(cd));\n-            sizes.add(cd.name(),  data.count(cd) * size);\n-        }\n-\n-        List<String> sorted = new ArrayList<>(sizes.keys());\n-        sorted.sort(sorter);\n-\n@@ -113,4 +83,0 @@\n-        out.println(\"Sorting by \" + sortBy + \". Use -Dsort={sum-size,avg-size,instances} to override.\");\n-        out.println();\n-        out.println(\"Printing first \" + printFirst + \" lines. Use -DprintFirst=# to override.\");\n-        out.println();\n@@ -118,15 +84,11 @@\n-        int idx = 0;\n-        long printedCnt = 0;\n-        long printedSize = 0;\n-        out.printf(\" %13s %13s %13s   %s%n\", \"INSTANCES\", \"SUM SIZE\", \"AVG SIZE\", \"CLASS\");\n-        out.println(\"------------------------------------------------------------------------------------------------\");\n-        for (String name : sorted) {\n-            if (++idx > printFirst) break;\n-            long cnt = counts.count(name);\n-            long size = sizes.count(name);\n-            out.printf(\" %13d %13d %13d   %s%n\", cnt, size, size \/ cnt, name);\n-            printedCnt += cnt;\n-            printedSize += size;\n-        }\n-        if (sorted.size() > printFirst) {\n-            out.printf(\" %13d %13d %13s   %s%n\", counts.size() - printedCnt, sizes.size() - printedSize, \"\", \"(other)\");\n+        ASCIITable table = new ASCIITable(\n+                true,\n+                \"=== Class Histogram\",\n+                \"INSTANCES\", \"SIZE\", \"SUM SIZE\", \"CLASS\");\n+\n+        for (ClassData cd : data.keys()) {\n+            long cnt = data.count(cd);\n+            if (cnt > 0) {\n+                long instanceSize = layouter.layout(cd).instanceSize();\n+                table.addLine(cd.prettyName(), cnt, instanceSize, cnt * instanceSize);\n+            }\n@@ -134,2 +96,4 @@\n-        out.println(\"------------------------------------------------------------------------------------------------\");\n-        out.printf(\" %13d %13d %13s   %s%n\", counts.size(), sizes.size(), \"\", \"(total)\");\n+\n+        table.print(out, 0);\n+        table.print(out, 1);\n+        table.print(out, 2);\n","filename":"jol-cli\/src\/main\/java\/org\/openjdk\/jol\/operations\/HeapDumpStats.java","additions":16,"deletions":52,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -0,0 +1,245 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jol.operations;\n+\n+import org.openjdk.jol.Operation;\n+import org.openjdk.jol.datamodel.ModelVM;\n+import org.openjdk.jol.heap.HeapDumpReader;\n+import org.openjdk.jol.info.ClassData;\n+import org.openjdk.jol.layouters.HotSpotLayouter;\n+import org.openjdk.jol.layouters.Layouter;\n+import org.openjdk.jol.util.ASCIITable;\n+import org.openjdk.jol.util.Multimap;\n+import org.openjdk.jol.util.Multiset;\n+\n+import java.io.File;\n+import java.io.PrintStream;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.*;\n+\n+import static java.lang.System.out;\n+\n+\/**\n+ * @author Aleksey Shipilev\n+ *\/\n+public class HeapDumpStrings implements Operation {\n+\n+    @Override\n+    public String label() {\n+        return \"heapdump-strings\";\n+    }\n+\n+    @Override\n+    public String description() {\n+        return \"Read a heap dump and look for duplicate Strings\";\n+    }\n+\n+    private int getVMVersion() {\n+        try {\n+            return Integer.parseInt(System.getProperty(\"java.specification.version\"));\n+        } catch (Exception e) {\n+            return 8;\n+        }\n+    }\n+\n+    public void run(String... args) throws Exception {\n+        if (args.length == 0) {\n+            System.err.println(\"Expected a hprof file name.\");\n+            return;\n+        }\n+        String path = args[0];\n+\n+        Layouter layouter = new HotSpotLayouter(new ModelVM(), getVMVersion());\n+\n+        out.println(\"Heap Dump: \" + path);\n+\n+        out.println();\n+        out.println(\"Discovering String objects...\");\n+        StringVisitor sv = new StringVisitor();\n+        HeapDumpReader stringReader = new HeapDumpReader(new File(path), out, sv);\n+        stringReader.parse();\n+\n+        out.println();\n+        out.println(\"Discovering String contents...\");\n+        StringValueVisitor svv = new StringValueVisitor(sv.valuesToStrings());\n+        HeapDumpReader stringValueReader = new HeapDumpReader(new File(path), out, svv);\n+        Multiset<ClassData> data = stringValueReader.parse();\n+\n+        out.println();\n+        out.println(layouter);\n+        out.println();\n+\n+        long totalSize = 0;\n+        long totalCount = 0;\n+        for (ClassData cd : data.keys()) {\n+            totalSize += layouter.layout(cd).instanceSize() * data.count(cd);\n+            totalCount += data.count(cd);\n+        }\n+\n+        out.printf(\"Heap dump contains %,d objects, %,d bytes in total.%n\", totalCount, totalSize);\n+        out.println();\n+\n+        svv.computeDuplicates(out, layouter);\n+        out.println();\n+    }\n+\n+    public static class StringContents {\n+        private final int length;\n+        private final String componentType;\n+        private final byte[] contents;\n+        private final long hash;\n+\n+        public StringContents(int length, String componentType, byte[] contents) {\n+            this.length = length;\n+            this.componentType = componentType;\n+            this.contents = Arrays.copyOf(contents, Math.min(contents.length, 32));\n+            this.hash = byteArrayHashCode(contents);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            StringContents that = (StringContents) o;\n+            return length == that.length && hash == that.hash && componentType.equals(that.componentType);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (int) ((hash >> 32) ^ (hash));\n+        }\n+\n+        public Object value() {\n+            if (componentType.equals(\"byte\")) {\n+                \/\/ Boldly assume Latin1 encoding\n+                return new String(contents, StandardCharsets.ISO_8859_1);\n+            } else if (componentType.equals(\"char\")) {\n+                return new String(contents, StandardCharsets.UTF_16);\n+            } else {\n+                return \"N\/A\";\n+            }\n+        }\n+    }\n+\n+    public static long byteArrayHashCode(byte[] src) {\n+        long result = 1;\n+        for (byte e : src) {\n+            result = 31 * result + e;\n+        }\n+        return result;\n+    }\n+\n+    public static class StringVisitor extends HeapDumpReader.Visitor {\n+        private final Multimap<Long, Long> valuesToStrings = new Multimap<>();\n+\n+        private long stringID;\n+        private int stringValueOffset;\n+        private int stringValueSize;\n+\n+        @Override\n+        public void visitInstance(long id, long klassID, byte[] bytes, String name) {\n+            if (klassID == stringID) {\n+                ByteBuffer bb = ByteBuffer.wrap(bytes);\n+                long valueId;\n+                switch (stringValueSize) {\n+                    case 4:\n+                        valueId = bb.getInt(stringValueOffset);\n+                        break;\n+                    case 8:\n+                        valueId = bb.getLong(stringValueOffset);\n+                        break;\n+                    default:\n+                        throw new IllegalStateException(\"Cannot handle string value size: \" + stringValueSize);\n+                }\n+                valuesToStrings.put(valueId, id);\n+            }\n+        }\n+\n+        @Override\n+        public void visitClass(long id, String name, List<Integer> oopIdx, int oopSize) {\n+            if (name.equals(\"java.lang.String\")) {\n+                stringID = id;\n+                if (oopIdx.size() == 1) {\n+                    stringValueOffset = oopIdx.get(0);\n+                    stringValueSize = oopSize;\n+                } else {\n+                    throw new IllegalStateException(\"String has more than one reference field\");\n+                }\n+            }\n+        }\n+\n+        public Multimap<Long, Long> valuesToStrings() {\n+            return valuesToStrings;\n+        }\n+    }\n+\n+    public static class StringValueVisitor extends HeapDumpReader.Visitor {\n+        private final Multimap<Long, Long> valuesToStrings;\n+        private final Multiset<StringContents> contents = new Multiset<>();\n+\n+        public StringValueVisitor(Multimap<Long, Long> valuesToStrings) {\n+            this.valuesToStrings = valuesToStrings;\n+        }\n+\n+        @Override\n+        public void visitArray(long id, String componentType, int count, byte[] bytes) {\n+            if (valuesToStrings.contains(id)) {\n+                contents.add(new StringContents(count, componentType, bytes));\n+            }\n+        }\n+\n+        public void computeDuplicates(PrintStream ps, Layouter layouter) {\n+            long stringSize = layouter.layout(ClassData.parseClass(String.class)).instanceSize();\n+\n+            ASCIITable table = new ASCIITable(\n+                    false,\n+                    \"=== Duplicate Strings\\n\" +\n+                    \"  DUPS: Number of duplicated String instances\\n\" +\n+                    \"  SIZE (V): Savings due to String.value dedup (automatic by GC)\\n\" +\n+                    \"  SIZE (S+V): Savings due to entire String dedup (manual)\",\n+                    \"DUPS\", \"SIZE (V)\", \"SIZE (S+V)\", \"VALUE\");\n+\n+            for (StringContents sc : contents.keys()) {\n+                long count = contents.count(sc) - 1;\n+                if (count > 0) {\n+                    ClassData cd = new ClassData(sc.componentType + \"[]\", sc.componentType, sc.length);\n+                    long size = layouter.layout(cd).instanceSize();\n+                    table.addLine(\n+                            sc.value() + ((sc.length > 32) ? \"... (\" + sc.length + \" chars)\" : \"\"),\n+                            count,\n+                            count * size,\n+                            count * (size + stringSize)\n+                    );\n+                }\n+            }\n+\n+            table.print(ps, 0);\n+            table.print(ps, 1);\n+            table.print(ps, 2);\n+        }\n+    }\n+\n+}\n","filename":"jol-cli\/src\/main\/java\/org\/openjdk\/jol\/operations\/HeapDumpStrings.java","additions":245,"deletions":0,"binary":false,"changes":245,"status":"added"},{"patch":"@@ -35,4 +35,1 @@\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n+import java.util.*;\n@@ -48,2 +45,2 @@\n-    private static final int GZIP_BUF_SIZE =       512 * 1024;\n-    private static final int READ_BUF_SIZE =  4 * 1024 * 1024;\n+    private static final int GZIP_BUF_SIZE = 16 * 1024 * 1024;\n+    private static final int READ_BUF_SIZE = 16 * 1024 * 1024;\n@@ -70,0 +67,23 @@\n+    private static class SrcDstTypes {\n+        final ClassData src;\n+        final ClassData dst;\n+\n+        private SrcDstTypes(ClassData src, ClassData dst) {\n+            this.src = src;\n+            this.dst = dst;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            SrcDstTypes that = (SrcDstTypes) o;\n+            return src.equals(that.src) && dst.equals(that.dst);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(src, dst);\n+        }\n+    }\n+\n@@ -75,1 +95,1 @@\n-            this.is = new BufferedInputStream(new GZIPInputStream(new FileInputStream(file), GZIP_BUF_SIZE), READ_BUF_SIZE);\n+            this.is = new UnsyncBufferedInputStream(new GZIPInputStream(new FileInputStream(file), GZIP_BUF_SIZE), READ_BUF_SIZE);\n@@ -77,1 +97,1 @@\n-            this.is = new BufferedInputStream(new FileInputStream(file), READ_BUF_SIZE);\n+            this.is = new UnsyncBufferedInputStream(new FileInputStream(file), READ_BUF_SIZE);\n@@ -186,1 +206,2 @@\n-            ClassData cd = new ClassData(classNames.get(klassId));\n+            String name = classNames.get(klassId);\n+            ClassData cd = new ClassData(name);\n@@ -197,0 +218,3 @@\n+            if (visitor != null) {\n+                visitor.visitClassData(name, cd);\n+            }\n@@ -289,1 +313,2 @@\n-        arrayCounts.add(new ClassData(typeString + \"[]\", typeString, elements));\n+        ClassData thisCD = new ClassData(typeString + \"[]\", typeString, elements);\n+        arrayCounts.add(thisCD);\n@@ -291,1 +316,1 @@\n-        int len = elements * getSize(typeClass);\n+        long len = (long) elements * getSize(typeClass);\n@@ -294,1 +319,1 @@\n-            visitor.visitPrimArray(id, typeString, elements, bytes);\n+            visitor.visitArray(id, typeString, elements, bytes);\n@@ -301,1 +326,1 @@\n-        read_ID(); \/\/ array id\n+        long id = read_ID(); \/\/ array id\n@@ -305,1 +330,0 @@\n-        skipContents((long) elements * idSize);\n@@ -311,0 +335,1 @@\n+        ClassData thisCD = new ClassData(name, \"Object\", elements);\n@@ -312,0 +337,8 @@\n+\n+        long len = (long) elements * idSize;\n+        if (visitor != null) {\n+            byte[] bytes = readContents(len);\n+            visitor.visitArray(id, \"Object\", elements, bytes);\n+        } else {\n+            skipContents(len);\n+        }\n@@ -325,1 +358,2 @@\n-            visitor.visitInstance(id, klassID, bytes);\n+            String name = classNames.get(klassID);\n+            visitor.visitInstance(id, klassID, bytes, name);\n@@ -449,0 +483,8 @@\n+        if (type == 2) {\n+            return \"Object\"; \/\/ TODO: Read the exact type;\n+        }\n+\n+        return getPrimitiveTypeString(type);\n+    }\n+\n+    private String getPrimitiveTypeString(int type) throws HeapDumpException {\n@@ -450,2 +492,0 @@\n-            case 2:\n-                return \"Object\"; \/\/ TODO: Read the exact type;\n@@ -567,4 +607,67 @@\n-    public interface Visitor {\n-        void visitInstance(long id, long klassID, byte[] bytes);\n-        void visitClass(long id, String name, List<Integer> oopIdx, int oopSize);\n-        void visitPrimArray(long id, String componentType, int count, byte[] bytes);\n+    public static class Visitor {\n+        public void visitInstance(long id, long klassID, byte[] bytes, String name) {\n+            \/\/ Do nothing.\n+        }\n+\n+        public void visitClass(long id, String name, List<Integer> oopIdx, int oopSize) {\n+            \/\/ Do nothing.\n+        }\n+\n+        public void visitArray(long id, String componentType, int count, byte[] bytes) {\n+            \/\/ Do nothing.\n+        }\n+\n+        public void visitClassData(String name, ClassData cd) {\n+            \/\/ Do nothing.\n+        }\n+    }\n+\n+    public static class MultiplexingVisitor extends Visitor {\n+        private final List<Visitor> visitors = new ArrayList<>();\n+        public void add(Visitor v) {\n+            visitors.add(v);\n+        }\n+\n+        @Override\n+        public void visitInstance(long id, long klassID, byte[] bytes, String name) {\n+            for (Visitor v : visitors) {\n+                v.visitInstance(id, klassID, bytes, name);\n+            }\n+        }\n+\n+        @Override\n+        public void visitClass(long id, String name, List<Integer> oopIdx, int oopSize) {\n+            for (Visitor v : visitors) {\n+                v.visitClass(id, name, oopIdx, oopSize);\n+            }\n+        }\n+\n+        @Override\n+        public void visitArray(long id, String componentType, int count, byte[] bytes) {\n+            for (HeapDumpReader.Visitor v : visitors) {\n+                v.visitArray(id, componentType, count, bytes);\n+            }\n+        }\n+\n+        @Override\n+        public void visitClassData(String name, ClassData cd) {\n+            for (HeapDumpReader.Visitor v : visitors) {\n+                v.visitClassData(name, cd);\n+            }\n+        }\n+    }\n+\n+\n+    static class UnsyncBufferedInputStream extends BufferedInputStream {\n+        public UnsyncBufferedInputStream(InputStream in, int bufSize) {\n+            super(in, bufSize);\n+        }\n+\n+        @Override\n+        public int read() throws IOException {\n+            if (pos >= count) {\n+                \/\/ Let superclass handle buffers\n+                return super.read();\n+            }\n+            return buf[pos++] & 0xFF;\n+        }\n","filename":"jol-core\/src\/main\/java\/org\/openjdk\/jol\/heap\/HeapDumpReader.java","additions":124,"deletions":21,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -312,0 +312,8 @@\n+    public String prettyName() {\n+        if (isArray) {\n+            return name.substring(0, name.length() - 1) + length + \"]\";\n+        } else {\n+            return name;\n+        }\n+    }\n+\n@@ -377,7 +385,2 @@\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n@@ -385,21 +388,7 @@\n-\n-        if (isArray != classData.isArray) {\n-            return false;\n-        }\n-        if (length != classData.length) {\n-            return false;\n-        }\n-        if (!Objects.equals(arrayComponentKlass, classData.arrayComponentKlass)) {\n-            return false;\n-        }\n-        if (!Objects.equals(arrayKlass, classData.arrayKlass)) {\n-            return false;\n-        }\n-        if (!Objects.equals(classNames, classData.classNames)) {\n-            return false;\n-        }\n-        if (!Objects.equals(fields, classData.fields)) {\n-            return false;\n-        }\n-\n-        return true;\n+        return length == classData.length &&\n+                isArray == classData.isArray &&\n+                name.equals(classData.name) &&\n+                Objects.equals(fields, classData.fields) &&\n+                Objects.equals(classNames, classData.classNames) &&\n+                Objects.equals(arrayKlass, classData.arrayKlass) &&\n+                Objects.equals(arrayComponentKlass, classData.arrayComponentKlass);\n@@ -410,7 +399,1 @@\n-        int result = fields != null ? fields.hashCode() : 0;\n-        result = 31 * result + (classNames != null ? classNames.hashCode() : 0);\n-        result = 31 * result + (arrayKlass != null ? arrayKlass.hashCode() : 0);\n-        result = 31 * result + (arrayComponentKlass != null ? arrayComponentKlass.hashCode() : 0);\n-        result = 31 * result + (int) (length ^ (length >>> 32));\n-        result = 31 * result + (isArray ? 1 : 0);\n-        return result;\n+        return Objects.hash(name, length);\n@@ -425,0 +408,7 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"ClassData{\" +\n+                \"name='\" + name + '\\'' +\n+                '}';\n+    }\n","filename":"jol-core\/src\/main\/java\/org\/openjdk\/jol\/info\/ClassData.java","additions":25,"deletions":35,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import org.openjdk.jol.util.ASCIITable;\n@@ -335,4 +336,4 @@\n-        StringWriter sw = new StringWriter();\n-        PrintWriter pw = new PrintWriter(sw);\n-        pw.println(description + \" footprint:\");\n-        pw.printf(\" %9s %9s %9s   %s%n\", \"COUNT\", \"AVG\", \"SUM\", \"DESCRIPTION\");\n+        ASCIITable table = new ASCIITable(\n+                true,\n+                description + \" footprint:\",\n+                \"COUNT\", \"AVG\", \"SUM\", \"DESCRIPTION\");\n@@ -342,1 +343,1 @@\n-            pw.printf(\" %9d %9d %9d   %s%n\", count, size \/ count, size, ClassUtils.humanReadableName(key));\n+            table.addLine(ClassUtils.humanReadableName(key), count, size \/ count, size);\n@@ -344,1 +345,3 @@\n-        pw.printf(\" %9d %9s %9d   %s%n\", totalCount(), \"\", totalSize(), \"(total)\");\n+        StringWriter sw = new StringWriter();\n+        PrintWriter pw = new PrintWriter(sw);\n+        table.print(pw, 2);\n","filename":"jol-core\/src\/main\/java\/org\/openjdk\/jol\/info\/GraphLayout.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jol.util;\n+\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+public class ASCIITable {\n+\n+    private final boolean summary;\n+    private final int printFirst;\n+    private final String header;\n+    private final int numberColumns;\n+    private final String[] columns;\n+\n+    private final List<Line> lines;\n+\n+    public ASCIITable(boolean summary, String header, String... columns) {\n+        this(summary, Integer.getInteger(\"printFirst\", 30), header, columns);\n+    }\n+\n+    public ASCIITable(boolean summary, int printFirst, String header, String... columns) {\n+        this.summary = summary;\n+        this.printFirst = printFirst;\n+        this.header = header;\n+        this.columns = columns;\n+        this.numberColumns = columns.length - 1;\n+        this.lines = new ArrayList<>();\n+    }\n+\n+    private static class Line {\n+        private final Long[] numbers;\n+        private final Comparable value;\n+\n+        public Line(Comparable value, Long[] numbers) {\n+            this.numbers = numbers;\n+            this.value = value;\n+        }\n+    }\n+\n+    public void addLine(Comparable value, Long... numbers) {\n+        lines.add(new Line(value, numbers));\n+    }\n+\n+    public void print(PrintStream ps, int sortColumn) {\n+        PrintWriter pw = new PrintWriter(ps);\n+        print(pw, sortColumn);\n+        pw.flush();\n+    }\n+\n+    public void print(PrintWriter pw, int sortColumn) {\n+        pw.println(header);\n+        pw.println();\n+\n+        if (sortColumn == numberColumns) {\n+            lines.sort(Comparator.comparing((Line l) -> l.value));\n+            pw.println(\"Table is sorted by \\\"\" + columns[numberColumns] + \"\\\".\");\n+        } else if (sortColumn >= 0) {\n+            lines.sort(Comparator.comparing((Line l) -> l.numbers[sortColumn]).reversed());\n+            pw.println(\"Table is sorted by \\\"\" + columns[sortColumn] + \"\\\".\");\n+        }\n+        if (printFirst != Integer.MAX_VALUE) {\n+            pw.println(\"Printing first \" + printFirst + \" lines. Use -DprintFirst=# to override.\");\n+        }\n+        pw.println();\n+\n+        for (int c = 0; c < numberColumns; c++) {\n+            pw.printf(\" %15s\", columns[c]);\n+        }\n+        pw.println(\"    \" + columns[numberColumns]);\n+        pw.println(\"------------------------------------------------------------------------------------------------\");\n+\n+\n+        long[] tops = new long[numberColumns];\n+        long[] sums = new long[numberColumns];\n+\n+        int current = 0;\n+\n+        for (Line l : lines) {\n+            if (current < printFirst) {\n+                for (int c = 0; c < numberColumns; c++) {\n+                    pw.printf(\" %,15d\", l.numbers[c]);\n+                    tops[c] += l.numbers[c];\n+                    sums[c] += l.numbers[c];\n+                }\n+                pw.printf(\"    %s%n\", l.value);\n+            } else {\n+                for (int c = 0; c < numberColumns; c++) {\n+                    sums[c] += l.numbers[c];\n+                }\n+            }\n+            current++;\n+        }\n+\n+        if (current > printFirst) {\n+            for (int c = 0; c < numberColumns; c++) {\n+                pw.printf(\" %15s\", \"...\");\n+            }\n+            pw.printf(\"    %s%n\", \"...\");\n+            for (int c = 0; c < numberColumns; c++) {\n+                pw.printf(\" %,15d\", sums[c] - tops[c]);\n+            }\n+            pw.printf(\"    %s%n\", \"<other>\");\n+        }\n+        pw.println(\"------------------------------------------------------------------------------------------------\");\n+        if (summary) {\n+            for (int c = 0; c < numberColumns; c++) {\n+                pw.printf(\" %,15d\", sums[c]);\n+            }\n+            pw.printf(\"    %s%n\", \"<total>\");\n+        }\n+        pw.println();\n+    }\n+\n+}\n","filename":"jol-core\/src\/main\/java\/org\/openjdk\/jol\/util\/ASCIITable.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -68,0 +68,7 @@\n+    public List<V> remove(K k) {\n+        return map.remove(k);\n+    }\n+\n+    public boolean contains(K k) {\n+        return map.containsKey(k);\n+    }\n","filename":"jol-core\/src\/main\/java\/org\/openjdk\/jol\/util\/Multimap.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,3 +27,1 @@\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.*;\n@@ -39,1 +37,1 @@\n-    private final Map<T, Long> map = new HashMap<>();\n+    private final Map<T, Cell> map = new HashMap<>();\n@@ -46,3 +44,4 @@\n-        Long v = map.get(key);\n-        if (v == null) {\n-            v = 0L;\n+        Cell cell = map.get(key);\n+        if (cell == null) {\n+            cell = new Cell();\n+            map.put(key, cell);\n@@ -50,2 +49,1 @@\n-        v += count;\n-        map.put(key, v);\n+        cell.v += count;\n@@ -55,2 +53,2 @@\n-        Long v = map.get(key);\n-        return (v == null) ? 0 : v;\n+        Cell c = map.get(key);\n+        return (c == null) ? 0 : c.v;\n@@ -76,0 +74,27 @@\n+\n+    public void pruneForSize(int targetSize) {\n+        if (map.size() < targetSize) {\n+            return;\n+        }\n+\n+        long min = Long.MAX_VALUE;\n+        for (Cell c : map.values()) {\n+            min = Math.min(min, c.v);\n+        }\n+        long limit = min;\n+\n+        while (map.size()*2 > targetSize) {\n+            Iterator<Map.Entry<T, Cell>> it = map.entrySet().iterator();\n+            while (it.hasNext()) {\n+                Map.Entry<T, Cell> e = it.next();\n+                if (e.getValue().v < limit) {\n+                    it.remove();\n+                }\n+            }\n+            limit *= 2;\n+        }\n+    }\n+\n+    private static class Cell {\n+        long v;\n+    }\n","filename":"jol-core\/src\/main\/java\/org\/openjdk\/jol\/util\/Multiset.java","additions":36,"deletions":11,"binary":false,"changes":47,"status":"modified"}]}