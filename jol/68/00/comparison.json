{"files":[{"patch":"@@ -45,0 +45,1 @@\n+    private static final int      BUF_SIZE =       128 * 1024;\n@@ -82,1 +83,1 @@\n-        this.buf = new byte[32*1024];\n+        this.buf = new byte[BUF_SIZE];\n@@ -100,0 +101,10 @@\n+    private int read_byte() throws HeapDumpException {\n+        try {\n+            int read = is.read();\n+            readBytes += (read < 0) ? 0 : 1;\n+            return read;\n+        } catch (IOException e) {\n+            throw new HeapDumpException(errorMessage(e.getMessage()));\n+        }\n+    }\n+\n@@ -110,0 +121,10 @@\n+    private int skip(int skip) throws HeapDumpException {\n+        try {\n+            long r = is.skip(skip);\n+            readBytes += r;\n+            return (int)r;\n+        } catch (IOException e) {\n+            throw new HeapDumpException(errorMessage(e.getMessage()));\n+        }\n+    }\n+\n@@ -119,1 +140,3 @@\n-        final long printEach = 256L * 1024 * 1024;\n+        final long printEach = 1024L * 1024 * 1024;\n+\n+        long start = System.nanoTime();\n@@ -122,1 +145,1 @@\n-            verboseOut.print(\"Read progress: \");\n+            verboseOut.print(\"Reading: \");\n@@ -128,1 +151,1 @@\n-                verboseOut.print(readBytes \/ 1000 \/ 1000 + \"M... \");\n+                verboseOut.print(\".\");\n@@ -141,1 +164,1 @@\n-            read_U4(); \/\/ relative time\n+            skipContents(4); \/\/ relative time\n@@ -224,1 +247,5 @@\n-            verboseOut.println(\"DONE\");\n+            long end = System.nanoTime();\n+            verboseOut.printf(\" done %d MB in %.3f seconds at %.0f MB\/sec%n\",\n+                    readBytes \/ 1024 \/ 1024,\n+                    1D * (end - start) \/ 1000 \/ 1000 \/ 1000,\n+                    1000D * readBytes \/ (end - start));\n@@ -234,2 +261,1 @@\n-                read_ID();\n-                read_ID();\n+                skipContents(2 * idSize);\n@@ -238,4 +264,0 @@\n-                read_ID();\n-                read_U4();\n-                read_U4();\n-                return;\n@@ -243,3 +265,2 @@\n-                read_ID();\n-                read_U4();\n-                read_U4();\n+            case 0x08:\n+                skipContents(idSize + 2*4);\n@@ -248,6 +269,0 @@\n-                read_ID();\n-                read_U4();\n-                return;\n-            case 0x05:\n-                read_ID();\n-                return;\n@@ -255,2 +270,1 @@\n-                read_ID();\n-                read_U4();\n+                skipContents(idSize + 1*4);\n@@ -258,0 +272,1 @@\n+            case 0x05:\n@@ -259,6 +274,1 @@\n-                read_ID();\n-                return;\n-            case 0x08:\n-                read_ID();\n-                read_U4();\n-                read_U4();\n+                skipContents(idSize);\n@@ -285,1 +295,1 @@\n-        read_U4(); \/\/ stack trace\n+        skipContents(4); \/\/ stack trace, ignore\n@@ -290,2 +300,2 @@\n-        ClassData thisCD = new ClassData(typeString + \"[]\", typeString, elements);\n-        arrayCounts.add(thisCD);\n+        String typeArrayString = getTypeArrayString(typeClass);\n+        arrayCounts.add(new ClassData(typeArrayString, typeString, elements));\n@@ -304,1 +314,1 @@\n-        read_U4(); \/\/ stack trace\n+        skipContents(4); \/\/ stack trace, ignore\n@@ -312,1 +322,0 @@\n-        ClassData thisCD = new ClassData(name, \"Object\", elements);\n@@ -326,1 +335,1 @@\n-        read_U4(); \/\/ stack trace\n+        skipContents(4); \/\/ stack trace, ignore\n@@ -328,0 +337,1 @@\n+        int instanceBytes = (int) read_U4(); \/\/ always fits\n@@ -331,2 +341,0 @@\n-        int instanceBytes = (int) read_U4(); \/\/ always fits\n-\n@@ -347,1 +355,1 @@\n-        read_U4(); \/\/ stack trace\n+        skipContents(4); \/\/ stack trace, ignore\n@@ -460,8 +468,0 @@\n-        if (type == 2) {\n-            return \"Object\"; \/\/ TODO: Read the exact type;\n-        }\n-\n-        return getPrimitiveTypeString(type);\n-    }\n-\n-    private String getPrimitiveTypeString(int type) throws HeapDumpException {\n@@ -469,0 +469,2 @@\n+            case 2:\n+                return \"Object\"; \/\/ TODO: Read the exact type;\n@@ -490,0 +492,25 @@\n+    private String getTypeArrayString(int type) throws HeapDumpException {\n+        switch (type) {\n+            case 2:\n+                return \"Object[]\"; \/\/ TODO: Read the exact type;\n+            case 4:\n+                return \"boolean[]\";\n+            case 8:\n+                return \"byte[]\";\n+            case 9:\n+                return \"short[]\";\n+            case 5:\n+                return \"char[]\";\n+            case 10:\n+                return \"int[]\";\n+            case 6:\n+                return \"float[]\";\n+            case 7:\n+                return \"double[]\";\n+            case 11:\n+                return \"long[]\";\n+            default:\n+                throw new HeapDumpException(\"Unknown type: \" + type);\n+        }\n+    }\n+\n@@ -506,1 +533,4 @@\n-            read = read(buf, toRead);\n+            read = skip(toRead);\n+            if (read == 0) {\n+                read = read(buf, toRead);\n+            }\n@@ -573,3 +603,3 @@\n-        int read = read(buf, 1);\n-        if (read == 1) {\n-            return ((int)wrapBuf.get(0) & 0xFF);\n+        int read = read_byte();\n+        if (read < 0) {\n+            throw new HeapDumpException(errorMessage(\"Unable to read 1 bytes\"));\n@@ -577,1 +607,1 @@\n-        throw new HeapDumpException(errorMessage(\"Unable to read 1 bytes\"));\n+        return (int)(read & 0xFF);\n@@ -651,0 +681,21 @@\n+\n+        @Override\n+        public int read(byte[] b, int off, int len) throws IOException {\n+            if (pos + len >= count) {\n+                \/\/ Let superclass handle buffers\n+                return super.read(b, off, len);\n+            }\n+            System.arraycopy(buf, pos, b, off, len);\n+            pos += len;\n+            return len;\n+        }\n+\n+        @Override\n+        public long skip(long skip) throws IOException {\n+            if (pos + skip >= count || skip > 1024*1024) {\n+                \/\/ Let superclass handle buffers\n+                return super.skip(skip);\n+            }\n+            pos += (int)skip;\n+            return skip;\n+        }\n","filename":"jol-core\/src\/main\/java\/org\/openjdk\/jol\/heap\/HeapDumpReader.java","additions":102,"deletions":51,"binary":false,"changes":153,"status":"modified"}]}