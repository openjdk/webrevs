{"files":[{"patch":"@@ -122,0 +122,24 @@\n+Users should exercise caution when filtering symbols, as it is relatively easy to filter out a declaration that is depended on by one or more declarations:\n+\n+```c\n+\/\/ test.h\n+struct A {\n+   int x;\n+}\n+struct A aVar;\n+```\n+\n+Here, we could run `jextract` and filter out `A`, like so:\n+\n+```\n+jextract --include-var aVar test.h\n+```\n+\n+However, doing so would lead to broken generated code, as the layout of the global variable `aVar` depends on the layout of the excluded struct `A`.\n+\n+In such cases, `jextract` will report the missing dependency and terminate without generating any bindings:\n+\n+```\n+ERROR: aVar depends on A which has been excluded\n+```\n+\n","filename":"README.md","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import org.openjdk.jextract.impl.Logger;\n@@ -48,1 +49,0 @@\n-import java.text.MessageFormat;\n@@ -54,1 +54,0 @@\n-import java.util.Locale;\n@@ -56,1 +55,0 @@\n-import java.util.ResourceBundle;\n@@ -68,6 +66,0 @@\n-    private static final String MESSAGES_RESOURCE = \"org.openjdk.jextract.impl.resources.Messages\";\n-\n-    private static final ResourceBundle MESSAGES_BUNDLE;\n-    static {\n-        MESSAGES_BUNDLE = ResourceBundle.getBundle(MESSAGES_RESOURCE, Locale.getDefault());\n-    }\n@@ -76,1 +68,0 @@\n-    public static final Optional<Path> PLATFORM_INCLUDE_PATH = inferPlatformIncludePath();\n@@ -80,8 +71,6 @@\n-    private static final int OPTION_ERROR  = 1;\n-    private static final int INPUT_ERROR   = 2;\n-    private static final int CLANG_ERROR   = 3;\n-    private static final int RUNTIME_ERROR = 4;\n-    private static final int OUTPUT_ERROR  = 5;\n-\n-    private final PrintWriter out;\n-    private final PrintWriter err;\n+    private static final int FAILURE       = 1;\n+    private static final int OPTION_ERROR  = 2;\n+    private static final int INPUT_ERROR   = 3;\n+    private static final int CLANG_ERROR   = 4;\n+    private static final int FATAL_ERROR   = 5;\n+    private static final int OUTPUT_ERROR  = 6;\n@@ -89,3 +78,1 @@\n-    private static String format(String msgId, Object... args) {\n-        return new MessageFormat(MESSAGES_BUNDLE.getString(msgId)).format(args);\n-    }\n+    private final Logger logger;\n@@ -93,3 +80,2 @@\n-    private JextractTool(PrintWriter out, PrintWriter err) {\n-        this.out = out;\n-        this.err = err;\n+    private JextractTool(Logger logger) {\n+        this.logger = logger;\n@@ -118,0 +104,3 @@\n+        return parseInternal(Logger.DEFAULT, headers, parserOptions);\n+    }\n+    private static Declaration.Scoped parseInternal(Logger logger, List<Path> headers, String... parserOptions) {\n@@ -119,1 +108,2 @@\n-        return new Parser().parse(source, Stream.of(parserOptions).collect(Collectors.toList()));\n+        return new Parser(logger)\n+                .parse(source, Stream.of(parserOptions).collect(Collectors.toList()));\n@@ -124,2 +114,3 @@\n-                                                boolean useSystemLoadLibrary, PrintWriter errStream) {\n-        return List.of(generate(decl, headerName, targetPkg, new IncludeHelper(), libs, useSystemLoadLibrary, errStream));\n+                                                boolean useSystemLoadLibrary) {\n+        return generateInternal(decl, headerName, targetPkg, new IncludeHelper(),\n+                libs, useSystemLoadLibrary, Logger.DEFAULT);\n@@ -131,8 +122,1 @@\n-                                                         PrintWriter errStream) {\n-        return List.of(generate(decl, headerName, targetPkg, includeHelper, libs, useSystemLoadLibrary, errStream));\n-    }\n-\n-    private static JavaSourceFile[] generate(Declaration.Scoped decl, String headerName,\n-                                             String targetPkg, IncludeHelper includeHelper,\n-                                             List<Options.Library> libs, boolean useSystemLoadLibrary,\n-                                             PrintWriter errStream) {\n+                                                         Logger logger) {\n@@ -140,1 +124,1 @@\n-                .map(new IncludeFilter(includeHelper)::scan)\n+                .map(new IncludeFilter(includeHelper, logger)::scan)\n@@ -143,1 +127,1 @@\n-                .map(new UnsupportedFilter(errStream)::scan)\n+                .map(new UnsupportedFilter(logger)::scan)\n@@ -145,1 +129,3 @@\n-        return OutputFactory.generateWrapped(transformedDecl, targetPkg, libs, useSystemLoadLibrary);\n+        return logger.hasErrors() ?\n+                List.of() :\n+                List.of(OutputFactory.generateWrapped(transformedDecl, targetPkg, libs, useSystemLoadLibrary));\n@@ -188,1 +174,1 @@\n-        err.println(format(\"jextract.usage\"));\n+        logger.info(\"jextract.usage\");\n@@ -192,8 +178,0 @@\n-\n-    private void printOptionError(Throwable throwable) {\n-        printOptionError(throwable.getMessage());\n-        if (DEBUG) {\n-            throwable.printStackTrace(err);\n-        }\n-    }\n-\n@@ -201,3 +179,1 @@\n-        err.println(\"OPTION ERROR: \" + message);\n-        err.println(\"Usage: jextract <options> <header file>\");\n-        err.println(\"Use --help for a list of possible options\");\n+        logger.err(\"jextract.opt.error\", message);\n@@ -212,6 +188,1 @@\n-        if (args.length == 0) {\n-            System.err.println(\"Expected a header file\");\n-            return;\n-        }\n-\n-        JextractTool m = new JextractTool(new PrintWriter(System.out, true), new PrintWriter(System.err, true));\n+        JextractTool m = new JextractTool(Logger.DEFAULT);\n@@ -372,4 +343,1 @@\n-            err.println(format(\"argfile.read.error\", ioexp));\n-            if (JextractTool.DEBUG) {\n-                ioexp.printStackTrace(err);\n-            }\n+            logger.fatal(ioexp, \"argfile.read.error\", ioexp);\n@@ -380,2 +348,2 @@\n-        parser.accepts(\"-D\", List.of(\"--define-macro\"), format(\"help.D\"), true);\n-        parser.accepts(\"--dump-includes\", format(\"help.dump-includes\"), true);\n+        parser.accepts(\"-D\", List.of(\"--define-macro\"), \"help.D\", true);\n+        parser.accepts(\"--dump-includes\", \"help.dump-includes\", true);\n@@ -383,1 +351,1 @@\n-            parser.accepts(\"--\" + includeKind.optionName(), format(\"help.\" + includeKind.optionName()), true);\n+            parser.accepts(\"--\" + includeKind.optionName(), \"help.\" + includeKind.optionName(), true);\n@@ -385,8 +353,8 @@\n-        parser.accepts(\"-h\", List.of(\"-?\", \"--help\"), format(\"help.h\"), false);\n-        parser.accepts(\"--header-class-name\", format(\"help.header-class-name\"), true);\n-        parser.accepts(\"-I\", List.of(\"--include-dir\"), format(\"help.I\"), true);\n-        parser.accepts(\"-l\", List.of(\"--library\"), format(\"help.l\"), true);\n-        parser.accepts(\"--use-system-load-library\", format(\"help.use.system.load.library\"), false);\n-        parser.accepts(\"--output\", format(\"help.output\"), true);\n-        parser.accepts(\"-t\", List.of(\"--target-package\"), format(\"help.t\"), true);\n-        parser.accepts(\"--version\", format(\"help.version\"), false);\n+        parser.accepts(\"-h\", List.of(\"-?\", \"--help\"), \"help.h\", false);\n+        parser.accepts(\"--header-class-name\", \"help.header-class-name\", true);\n+        parser.accepts(\"-I\", List.of(\"--include-dir\"), \"help.I\", true);\n+        parser.accepts(\"-l\", List.of(\"--library\"), \"help.l\", true);\n+        parser.accepts(\"--use-system-load-library\", \"help.use.system.load.library\", false);\n+        parser.accepts(\"--output\", \"help.output\", true);\n+        parser.accepts(\"-t\", List.of(\"--target-package\"), \"help.t\", true);\n+        parser.accepts(\"--version\", \"help.version\", false);\n@@ -398,1 +366,1 @@\n-            printOptionError(oe);\n+            printOptionError(oe.getMessage());\n@@ -404,3 +372,4 @@\n-            err.printf(\"%s %s\\n\", \"jextract\", version.get());\n-            err.printf(\"%s %s\\n\", \"JDK version\", System.getProperty(\"java.runtime.version\"));\n-            err.printf(\"%s\\n\", LibClang.version());\n+            logger.info(\"jextract.version\",\n+                    version.get(),\n+                    System.getProperty(\"java.runtime.version\"),\n+                    LibClang.version());\n@@ -415,1 +384,1 @@\n-            printOptionError(\"Expected 1 header file, not \" + optionSet.nonOptionArguments().size());\n+            printOptionError(logger.format(\"expected.one.header\", optionSet.nonOptionArguments().size()));\n@@ -426,4 +395,1 @@\n-                err.println(\"compile_flags.txt reading failed \" + ioExp);\n-                if (JextractTool.DEBUG) {\n-                    ioExp.printStackTrace(err);\n-                }\n+                logger.fatal(ioExp, \"jextract.bad.compile.flags\", ioExp.getMessage());\n@@ -447,1 +413,1 @@\n-        PLATFORM_INCLUDE_PATH.ifPresent(platformPath -> {\n+        inferPlatformIncludePath().ifPresent(platformPath -> {\n@@ -490,1 +456,1 @@\n-                        err.println(format(\"l.option.value.absolute.path\", lib));\n+                        logger.err(\"l.option.value.absolute.path\", lib);\n@@ -493,1 +459,1 @@\n-                    err.println(format(\"l.option.value.invalid\", lib));\n+                    logger.err(\"l.option.value.invalid\", lib);\n@@ -506,1 +472,1 @@\n-            err.println(format(\"cannot.read.header.file\", header));\n+            logger.err(\"cannot.read.header.file\", header);\n@@ -510,1 +476,1 @@\n-            err.println(format(\"not.a.file\", header));\n+            logger.err(\"not.a.file\", header);\n@@ -516,1 +482,1 @@\n-            Declaration.Scoped toplevel = parse(List.of(header), options.clangArgs.toArray(new String[0]));\n+            Declaration.Scoped toplevel = parseInternal(logger, List.of(header), options.clangArgs.toArray(new String[0]));\n@@ -528,1 +494,1 @@\n-                options.targetPackage, options.includeHelper, options.libraries, options.useSystemLoadLibrary, err);\n+                options.targetPackage, options.includeHelper, options.libraries, options.useSystemLoadLibrary, logger);\n@@ -530,1 +496,1 @@\n-            err.println(ce.getMessage());\n+            logger.err(\"jextract.clang.error\", ce.getMessage());\n@@ -532,1 +498,1 @@\n-                ce.printStackTrace(err);\n+                logger.printStackTrace(ce);\n@@ -536,5 +502,2 @@\n-            err.println(re.getMessage());\n-            if (JextractTool.DEBUG) {\n-                re.printStackTrace(err);\n-            }\n-            return RUNTIME_ERROR;\n+            logger.fatal(re);\n+            return FATAL_ERROR;\n@@ -551,4 +514,1 @@\n-                    err.println(e.getMessage());\n-                    if (JextractTool.DEBUG) {\n-                        e.printStackTrace(err);\n-                    }\n+                    logger.fatal(e);\n@@ -559,5 +519,2 @@\n-            err.println(re.getMessage());\n-            if (JextractTool.DEBUG) {\n-                re.printStackTrace(err);\n-            }\n-            return RUNTIME_ERROR;\n+            logger.fatal(re);\n+            return FATAL_ERROR;\n@@ -566,1 +523,3 @@\n-        return SUCCESS;\n+        return logger.hasErrors() ?\n+                FAILURE :\n+                SUCCESS;\n@@ -582,1 +541,1 @@\n-            JextractTool instance = new JextractTool(out, err);\n+            JextractTool instance = new JextractTool(new Logger(out, err));\n@@ -587,1 +546,1 @@\n-    private static Optional<Path> inferPlatformIncludePath() {\n+    private Optional<Path> inferPlatformIncludePath() {\n@@ -601,1 +560,1 @@\n-                    ioExp.printStackTrace(System.err);\n+                    logger.printStackTrace(ioExp);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/JextractTool.java","additions":66,"deletions":107,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import org.openjdk.jextract.Type;\n+import org.openjdk.jextract.Type.Delegated;\n@@ -35,0 +37,1 @@\n+    private final Logger logger;\n@@ -36,1 +39,1 @@\n-    public IncludeFilter(IncludeHelper includeHelper) {\n+    public IncludeFilter(IncludeHelper includeHelper, Logger logger) {\n@@ -38,0 +41,1 @@\n+        this.logger = logger;\n@@ -63,0 +67,2 @@\n+        warnMissingDep(funcTree, funcTree.type().returnType());\n+        funcTree.type().argumentTypes().forEach(p -> warnMissingDep(funcTree, p));\n@@ -87,0 +93,1 @@\n+        warnMissingDep(tree, tree.type());\n@@ -96,0 +103,1 @@\n+        warnMissingDep(parent != null ? parent : tree, tree.type());\n@@ -103,0 +111,14 @@\n+\n+    void warnMissingDep(Declaration decl, Type type) {\n+        if (type instanceof Type.Declared declared) {\n+            \/\/ we only have to check for missing structs because (a) pointers to missing structs can still lead\n+            \/\/ to valid code and (b) missing typedefs to existing structs are resolved correctly, as typedefs are never\n+            \/\/ referred to by name in the generated code (because of libclang limitations).\n+            if (Skip.isPresent(declared.tree())) {\n+                logger.err(\"jextract.bad.include\", decl.name(), declared.tree().name());\n+            }\n+        } else if (type instanceof Type.Delegated delegated &&\n+                        delegated.kind() == Delegated.Kind.TYPEDEF) {\n+            warnMissingDep(decl, delegated.type());\n+        }\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/IncludeFilter.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2024 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+import org.openjdk.jextract.JextractTool;\n+\n+import java.io.PrintWriter;\n+import java.text.MessageFormat;\n+import java.util.Locale;\n+import java.util.ResourceBundle;\n+\n+\/**\n+ * Minimal utility class to print jextract warning\/errors.\n+ *\/\n+public class Logger {\n+\n+    private static final ResourceBundle MESSAGES_BUNDLE =\n+            ResourceBundle.getBundle(\"org.openjdk.jextract.impl.resources.Messages\", Locale.getDefault());\n+\n+    final PrintWriter outWriter;\n+    final PrintWriter errWriter;\n+    private int nWarnings;\n+    private int nErrors;\n+\n+    public Logger(PrintWriter outWriter, PrintWriter errStream) {\n+        this.outWriter = outWriter;\n+        this.errWriter = errStream;\n+    }\n+\n+    public void err(String key, Object... args) {\n+        errWriter.println(STR.\"ERROR: \\{format(key, args)}\");\n+        nErrors++;\n+    }\n+\n+    public void warn(String key, Object... args) {\n+        errWriter.println(STR.\"WARNING: \\{format(key, args)}\");\n+        nWarnings++;\n+    }\n+\n+    public void info(String key, Object... args) {\n+        errWriter.println(format(key, args));\n+        nWarnings++;\n+    }\n+\n+    public void printStackTrace(Throwable t) {\n+        t.printStackTrace(errWriter);\n+    }\n+\n+    public void fatal(Throwable t, String msg, Object... args) {\n+        errWriter.println(STR.\"FATAL: \\{format(msg, args)}\");\n+        if (JextractTool.DEBUG) {\n+            printStackTrace(t);\n+        }\n+    }\n+\n+    public void fatal(Throwable t) {\n+        fatal(t, \"jextract.crash\", t);\n+    }\n+\n+    public boolean hasErrors() {\n+        return nErrors > 0;\n+    }\n+\n+    public boolean hasWarnings() {\n+        return nWarnings > 0;\n+    }\n+\n+    public String format(String key, Object... args) {\n+        return new MessageFormat(MESSAGES_BUNDLE.getString(key)).format(args);\n+    }\n+\n+    public static Logger DEFAULT = new Logger(\n+            new PrintWriter(System.out, true),\n+            new PrintWriter(System.err, true));\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Logger.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -57,0 +57,1 @@\n+    final Logger logger;\n@@ -58,1 +59,1 @@\n-    private MacroParserImpl(ClangReparser reparser, TreeMaker treeMaker) {\n+    private MacroParserImpl(ClangReparser reparser, TreeMaker treeMaker, Logger logger) {\n@@ -62,0 +63,1 @@\n+        this.logger = logger;\n@@ -64,1 +66,1 @@\n-    static MacroParserImpl make(TreeMaker treeMaker, TranslationUnit tu, Collection<String> args) {\n+    static MacroParserImpl make(TreeMaker treeMaker, Logger logger, TranslationUnit tu, Collection<String> args) {\n@@ -67,1 +69,1 @@\n-            reparser = new ClangReparser(tu, args);\n+            reparser = new ClangReparser(tu, args, logger);\n@@ -72,1 +74,1 @@\n-        return new MacroParserImpl(reparser, treeMaker);\n+        return new MacroParserImpl(reparser, treeMaker, logger);\n@@ -113,0 +115,1 @@\n+        final Logger logger;\n@@ -114,1 +117,1 @@\n-        public ClangReparser(TranslationUnit tu, Collection<String> args) throws IOException, Index.ParsingFailedException {\n+        public ClangReparser(TranslationUnit tu, Collection<String> args, Logger logger) throws IOException, Index.ParsingFailedException {\n@@ -118,0 +121,1 @@\n+            this.logger = logger;\n@@ -136,1 +140,1 @@\n-                System.err.println(\"Error while processing macro: \" + diag.spelling());\n+                logger.info(\"jextract.debug.macro.error\", diag.spelling());\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/MacroParserImpl.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -67,5 +67,1 @@\n-        try {\n-            tree.accept(this, null);\n-        } catch (Exception ex) {\n-            ex.printStackTrace();\n-        }\n+        tree.accept(this, null);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+    private final Logger logger;\n@@ -47,1 +48,1 @@\n-    public Parser() {\n+    public Parser(Logger logger) {\n@@ -49,0 +50,1 @@\n+        this.logger = logger;\n@@ -60,1 +62,1 @@\n-            MacroParserImpl macroParser = MacroParserImpl.make(treeMaker, tu, args)) {\n+            MacroParserImpl macroParser = MacroParserImpl.make(treeMaker, logger, tu, args)) {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Parser.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-                if (cursorString.matches(\".*\\\\(unnamed (struct|union|enum) at.*\")) {\n+                if (cursorString.matches(\".*\\\\((unnamed|anonymous) (struct|union|enum) at.*\")) {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeMaker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    private final PrintWriter errStream;\n+    private final Logger logger;\n@@ -58,2 +58,2 @@\n-    public UnsupportedFilter(PrintWriter errStream) {\n-        this.errStream = errStream;\n+    public UnsupportedFilter(Logger logger) {\n+        this.logger = logger;\n@@ -78,1 +78,1 @@\n-            warnSkip(funcTree.name(), STR.\"unsupported type usage: \\{unsupportedType}\");\n+            warnSkip(funcTree.name(), unsupportedType(unsupportedType));\n@@ -114,1 +114,1 @@\n-            warnSkip(name, STR.\"unsupported type usage: \\{unsupportedType}\");\n+            warnSkip(name, unsupportedType(unsupportedType));\n@@ -132,1 +132,1 @@\n-            warnSkip(scoped.name(), STR.\"unsupported type usage: \\{unsupportedType}\");\n+            warnSkip(scoped.name(), unsupportedType(unsupportedType));\n@@ -140,1 +140,1 @@\n-                    warnSkip(fieldName(firstNamedParent, bitField), \"type is bitfield\");\n+                    warnSkip(fieldName(firstNamedParent, bitField), unsupportedBitfield());\n@@ -164,1 +164,1 @@\n-            warnSkip(typedefTree.name(), STR.\"unsupported type usage: \\{unsupportedType}\");\n+            warnSkip(typedefTree.name(), unsupportedType(unsupportedType));\n@@ -181,1 +181,1 @@\n-            warnSkip(name, STR.\"unsupported type usage: \\{unsupportedType}\");\n+            warnSkip(name, unsupportedType(unsupportedType));\n@@ -197,1 +197,1 @@\n-            warnSkip(nameOfSkipped, STR.\"unsupported type usage: \\{unsupportedType}\");\n+            warnSkip(nameOfSkipped, unsupportedType(unsupportedType));\n@@ -202,1 +202,1 @@\n-            warnSkip(nameOfSkipped, \"varargs in callbacks is not supported: \" + decl.name());\n+            warnSkip(nameOfSkipped, unsupportedVariadicCallback(decl.name()));\n@@ -278,1 +278,1 @@\n-        warn(STR.\"skipping \\{treeName}: \\{message}\");\n+        logger.warn(\"jextract.skip.unsupported\", treeName, message);\n@@ -281,2 +281,10 @@\n-    private void warn(String msg) {\n-        errStream.println(\"WARNING: \" + msg);\n+    private String unsupportedType(Type type) {\n+        return logger.format(\"unsupported.type\", type);\n+    }\n+\n+    private String unsupportedVariadicCallback(String name) {\n+        return logger.format(\"unsupported.variadic.callback\", name);\n+    }\n+\n+    private String unsupportedBitfield() {\n+        return logger.format(\"unsupported.bitfields\");\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnsupportedFilter.java","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -85,0 +85,40 @@\n+\n+jextract.version=\\\n+jextract {0}\\n\\\n+JDK version {1}\\n\\\n+LibClang version {2}\n+\n+jextract.opt.error=\\\n+{0}\\n\\\n+Usage: jextract <options> <header file>\\n\\\n+Use --help for a list of possible options\n+\n+expected.one.header=\\\n+  Expected one header file, not {0}\n+\n+jextract.clang.error=\\\n+{0}\n+\n+jextract.crash=\\\n+Unexpected exception {0} occurred\n+\n+jextract.bad.compile.flags=\\\n+Unexpected exception {0} while reading compile_flags.txt\n+\n+jextract.skip.unsupported=\\\n+Skipping {0} ({1})\n+\n+unsupported.type=\\\n+type {0} is not supported\n+\n+unsupported.variadic.callback=\\\n+variadic callback {0} is not supported\n+\n+unsupported.bitfields=\\\n+bitfields are not supported\n+\n+jextract.bad.include=\\\n+{0} depends on {1} which has been excluded\n+\n+jextract.debug.macro.error=\\\n+Error occurred while processing macro: {0}\n\\ No newline at end of file\n","filename":"src\/main\/resources\/org\/openjdk\/jextract\/impl\/resources\/Messages.properties","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -70,5 +70,6 @@\n-    protected static final int OPTION_ERROR  = 1;\n-    protected static final int INPUT_ERROR   = 2;\n-    protected static final int CLANG_ERROR   = 3;\n-    protected static final int RUNTIME_ERROR = 4;\n-    protected static final int OUTPUT_ERROR  = 5;\n+    protected static final int FAILURE       = 1;\n+    protected static final int OPTION_ERROR  = 2;\n+    protected static final int INPUT_ERROR   = 3;\n+    protected static final int CLANG_ERROR   = 4;\n+    protected static final int RUNTIME_ERROR = 5;\n+    protected static final int OUTPUT_ERROR  = 6;\n","filename":"test\/lib\/testlib\/JextractToolRunner.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.toolprovider.includeDeps;\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import testlib.JextractToolRunner;\n+\n+import java.nio.file.Path;\n+\n+public class TestBadIncludes extends JextractToolRunner {\n+\n+    JextractResult result;\n+\n+    @BeforeClass\n+    public void before() {\n+        Path output = getOutputFilePath(\"TestBadIncludes-badIncludes.h\");\n+        Path outputH = getInputFilePath(\"bad_includes.h\");\n+        result = run(output,\n+        \"--include-struct\", \"B\",\n+                \"--include-function\", \"m\",\n+                \"--include-typedef\", \"T\",\n+                \"--include-struct\", \"C\",\n+                \"--include-function\", \"n\",\n+                outputH.toString());\n+        result.checkFailure(FAILURE);\n+    }\n+\n+    @Test(dataProvider = \"cases\")\n+    public void testBadIncludes(String badDeclName, String missingDepName) {\n+        result.checkContainsOutput(\"ERROR: \" + badDeclName + \" depends on \" + missingDepName);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] cases() {\n+        return new Object[][]{\n+            {\"B\",   \"A\" },\n+            {\"m\",   \"A\" },\n+            {\"T\",   \"A\" },\n+            {\"a\",   \"A\" }\n+        };\n+    }\n+}\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/includeDeps\/TestBadIncludes.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -24,2 +24,5 @@\n-void f(int n, ...);\n-void F(int n, ...);\n\\ No newline at end of file\n+struct A { int x; };\n+struct B { struct A a; };\n+void m(struct A a);\n+typedef struct A T;\n+struct A a;\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/includeDeps\/bad_includes.h","additions":5,"deletions":2,"binary":false,"changes":7,"previous_filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/variadicNames\/variadic_names.h","status":"copied"},{"patch":"@@ -45,1 +45,1 @@\n-        result.checkContainsOutput(\"WARNING: skipping \" + skippedName + \": \" + reason);\n+        result.checkContainsOutput(\"WARNING: Skipping \" + skippedName + \" (\" + reason);\n@@ -48,2 +48,2 @@\n-    private static final String REASON_UNSUPPORTED_TYPE = \"unsupported type usage\";\n-    private static final String REASON_VARARGS_CALLBACK = \"varargs in callbacks is not supported\";\n+    private static final String REASON_UNSUPPORTED_TYPE = \"type\";\n+    private static final String REASON_VARARGS_CALLBACK = \"variadic callback\";\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/unsupported\/TestUnsupportedTypes.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}