{"files":[{"patch":"@@ -24,1 +24,1 @@\n-            JAVA22_HOME: \/tmp\/deps\/jdk-22\n+            TOOLCHAIN_JAVA_HOME: \/tmp\/deps\/jdk-toolchain\n@@ -27,1 +27,1 @@\n-            JAVA22_HOME: \/tmp\/deps\/jdk-22\/jdk-22.jdk\/Contents\/Home\n+            TOOLCHAIN_JAVA_HOME: \/tmp\/deps\/jdk-toolchain\/jdk-22.jdk\/Contents\/Home\n@@ -31,1 +31,1 @@\n-      uses: actions\/checkout@v2\n+      uses: actions\/checkout@v4.1.1\n@@ -41,2 +41,2 @@\n-    - name: 'Download JDK 22'\n-      id: download_jdk_22\n+    - name: 'Download toolchain JDK'\n+      id: download_toolchain_jdk\n@@ -49,1 +49,1 @@\n-    - name: 'Extract JDK 22'\n+    - name: 'Extract Toolchain JDK'\n@@ -52,3 +52,3 @@\n-        mkdir -p \/tmp\/deps\/jdk-22\n-        tar --strip-components=1 -xvf ${{ steps.download_jdk_22.outputs.archive }} -C \/tmp\/deps\/jdk-22\n-        ls -lah \/tmp\/deps\/jdk-22\n+        mkdir -p \/tmp\/deps\/jdk-toolchain\n+        tar --strip-components=1 -xvf ${{ steps.download_toolchain_jdk.outputs.archive }} -C \/tmp\/deps\/jdk-toolchain\n+        ls -lah \/tmp\/deps\/jdk-toolchain\n@@ -56,1 +56,1 @@\n-    - name: 'Check Java 22 version'\n+    - name: 'Check toolchain Java version'\n@@ -59,1 +59,1 @@\n-        ${{ matrix.JAVA22_HOME }}\/bin\/java --version\n+        ${{ matrix.TOOLCHAIN_JAVA_HOME }}\/bin\/java --version\n@@ -62,1 +62,1 @@\n-      uses: oracle-actions\/setup-java@v1.1.1\n+      uses: oracle-actions\/setup-java@v1.3.2\n@@ -83,1 +83,1 @@\n-        sh .\/gradlew -Pjdk22_home=${{ matrix.JAVA22_HOME }} -Pllvm_home=\/tmp\/deps\/clang_llvm clean verify        \n+        sh .\/gradlew -Pjdk22_home=${{ matrix.TOOLCHAIN_JAVA_HOME }} -Pllvm_home=\/tmp\/deps\/clang_llvm clean verify        \n@@ -86,1 +86,1 @@\n-      uses: actions\/checkout@v2\n+      uses: actions\/checkout@v4.1.1\n@@ -89,1 +89,1 @@\n-        ref: 'jtreg-6.2+1'\n+        ref: 'jtreg-7.3.1+1'\n@@ -103,1 +103,1 @@\n-        sh .\/gradlew -Pjdk22_home=${{ matrix.JAVA22_HOME }} -Pllvm_home=\/tmp\/deps\/clang_llvm -Pjtreg_home=.\/deps\/jtreg\/build\/images\/jtreg jtreg\n+        sh .\/gradlew -Pjdk22_home=${{ matrix.TOOLCHAIN_JAVA_HOME }} -Pllvm_home=\/tmp\/deps\/clang_llvm -Pjtreg_home=.\/deps\/jtreg\/build\/images\/jtreg jtreg\n","filename":".github\/workflows\/test.yml","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-`jextract` is a tool which mechanically generates Java bindings from a native library headers. This tools leverages the [clang C API](https:\/\/clang.llvm.org\/doxygen\/group__CINDEX.html) in order to parse the headers associated with a given native library, and the generated Java bindings build upon the [Foreign Function & Memory API](https:\/\/openjdk.java.net\/jeps\/424). The `jextract` tool was originally developed in the context of [Project Panama](https:\/\/openjdk.java.net\/projects\/panama\/) (and then made available in the Project Panama [Early Access binaries](https:\/\/jdk.java.net\/panama\/)).\n+`jextract` is a tool which mechanically generates Java bindings from a native library headers. This tools leverages the [clang C API](https:\/\/clang.llvm.org\/doxygen\/group__CINDEX.html) in order to parse the headers associated with a given native library, and the generated Java bindings build upon the [Foreign Function & Memory API](https:\/\/openjdk.java.net\/jeps\/454). The `jextract` tool was originally developed in the context of [Project Panama](https:\/\/openjdk.java.net\/projects\/panama\/) (and then made available in the Project Panama [Early Access binaries](https:\/\/jdk.java.net\/panama\/)).\n@@ -5,1 +5,1 @@\n-### Getting started\n+### Getting jextract\n@@ -7,1 +7,1 @@\n-`jextract` depends on the [C libclang API](https:\/\/clang.llvm.org\/doxygen\/group__CINDEX.html). To build the jextract sources, the easiest option is to download LLVM binaries for your platform, which can be found [here](https:\/\/releases.llvm.org\/download.html) (a version >= 9 is required). Both the `jextract` tool and the bindings it generates depend heavily on the [Foreign Function & Memory API](https:\/\/openjdk.java.net\/jeps\/424), so a suitable build of the [panama\/foreign repository](https:\/\/github.com\/openjdk\/panama-foreign) is also required.\n+Pre-built binaries for jextract are periodically released [here](https:\/\/jdk.java.net\/jextract). These binaries are built from the `master` branch of this repo, and target the foreign memory access and function API in the latest mainline JDK (for which binaries can be found [here](https:\/\/jdk.java.net)).\n@@ -9,20 +9,1 @@\n-> <details><summary><strong>Building older jextract versions<\/strong><\/summary>\n-> \n-> The `master` branch always tracks the latest version of the JDK. If you wish to build an older version of jextract, which targets an earlier version of the JDK you can do so by chercking out the appropriate branch.\n-> For example, to build a jextract tool which works against JDK 18:\n-> \n-> `git checkout jdk18`\n-> \n-> Over time, new branches will be added, each targeting a specific JDK version.\n-> <\/details>\n-\n-`jextract` can be built using `gradle`, as follows (on Windows, `gradlew.bat` should be used instead).\n-\n-(**Note**: Run the Gradle build with a Java version appropriate for the Gradle version. For example, Gradle 7.5.1\n-supports JDK 18. Please checkout the [Gradle compatibility matrix](https:\/\/docs.gradle.org\/current\/userguide\/compatibility.html#java) for the appropate JDK version needed for builds)\n-\n-\n-\n-```sh\n-$ sh .\/gradlew -Pjdk22_home=<jdk22_home_dir> -Pllvm_home=<libclang_dir> clean verify\n-```\n+Alternatively, to build jextract from the latest sources (which include all the latest updates and fixes) please refer to the [building](#building) section below.\n@@ -30,29 +11,1 @@\n-\n-> <details><summary><strong>Using a local installation of LLVM<\/strong><\/summary>\n-> \n-> While the recommended way is to use a [release from the LLVM project](https:\/\/releases.llvm.org\/download.html),\n-> extract it then make `llvm_home` point to this directory, it may be possible to use a local installation instead.\n->\n-> E.g. on macOs the `llvm_home` can also be set as one of these locations :\n-> \n-> * `\/Library\/Developer\/CommandLineTools\/usr\/` if using Command Line Tools\n-> * `\/Applications\/Xcode.app\/Contents\/Developer\/Toolchains\/XcodeDefault.xctoolchain\/usr\/` if using XCode\n-> * `$(brew --prefix llvm)` if using the [LLVM install from Homebrew](https:\/\/formulae.brew.sh\/formula\/llvm#default)\n-> \n-> <\/details>\n-\n-After building, there should be a new `jextract` folder under `build`.\n-To run the `jextract` tool, simply run the `jextract` command in the `bin` folder:\n-\n-```sh\n-$ build\/jextract\/bin\/jextract\n-Expected a header file\n-```\n-\n-The repository also contains a comprehensive set of tests, written using the [jtreg](https:\/\/openjdk.java.net\/jtreg\/) test framework, which can be run as follows (again, on Windows, `gradlew.bat` should be used instead):\n-\n-```sh\n-$ sh .\/gradlew -Pjdk22_home=<jdk22_home_dir> -Pllvm_home=<libclang_dir> -Pjtreg_home=<jtreg_home> jtreg\n-```\n-\n-Note however that running `jtreg` task requires `cmake` to be available on the `PATH`.\n+---\n@@ -77,1 +30,1 @@\n-jextract --source -t org.jextract point.h\n+jextract -t org.jextract point.h\n@@ -90,3 +43,3 @@\n-           MemorySegment point = arena.allocate(Point2d.$LAYOUT());\n-           Point2d.x$set(point, 3d);\n-           Point2d.y$set(point, 4d);\n+           MemorySegment point = Point2d.allocate(arena);\n+           Point2d.x(point, 3d);\n+           Point2d.y(point, 4d);\n@@ -99,1 +52,1 @@\n-As we can see, the `jextract` tool generated a `Point2d` class, modelling the C struct, and a `point_h` class which contains static native function wrappers, such as `distance`. If we look inside the generated code for `distance` we can find the following:\n+As we can see, the `jextract` tool generated a `Point2d` class, modelling the C struct, and a `point_h` class which contains static native function wrappers, such as `distance`. If we look inside the generated code for `distance` we can find the following (for clarity, some details have been omitted):\n@@ -102,9 +55,3 @@\n-static final FunctionDescriptor distance$FUNC = FunctionDescriptor.of(Constants$root.C_DOUBLE$LAYOUT,\n-    MemoryLayout.structLayout(\n-         Constants$root.C_DOUBLE$LAYOUT.withName(\"x\"),\n-         Constants$root.C_DOUBLE$LAYOUT.withName(\"y\")\n-    ).withName(\"Point2d\")\n-);\n-static final MethodHandle distance$MH = RuntimeHelper.downcallHandle(\n-    \"distance\",\n-    constants$0.distance$FUNC\n+static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+        foo_h.C_DOUBLE,\n+        Point2d.$LAYOUT()\n@@ -113,10 +60,6 @@\n-public static MethodHandle distance$MH() {\n-    return RuntimeHelper.requireNonNull(constants$0.distance$MH,\"distance\");\n-}\n-public static double distance ( MemorySegment x0) {\n-    var mh$ = distance$MH();\n-    try {\n-        return (double)mh$.invokeExact(x0);\n-    } catch (Throwable ex$) {\n-        throw new AssertionError(\"should not reach here\", ex$);\n-    }\n+static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+        foo_h.findOrThrow(\"distance\"),\n+        DESC);\n+\n+public static double distance(MemorySegment x0) {\n+    return (double) mh$.invokeExact(x0);\n@@ -137,1 +80,1 @@\n-| `-D --define-macro <macro>=<value>`                          | define <macro> to <value> (or 1 if <value> omitted)          |\n+| `-D --define-macro <macro>=<value>`                          | define `<macro>` to `<value>` (or 1 if `<value>` omitted)          |\n@@ -141,1 +84,2 @@\n-| `-l, --library <name \\| path>`                               | specify a library by platform-independent name (e.g. \"GL\") or by absolute path (\"\/usr\/lib\/libGL.so\") that will be loaded by the generated class. |\n+| `-l, --library <name \\| path>`                               | specify a shared library that should be loaded by the generated header class. If <libspec> starts with `:`, then what follows is interpreted as a library path. Otherwise, `<libspec>` denotes a library name. Examples: <br>`-l GL`<br>`-l :libGL.so.1`<br>`-l :\/usr\/lib\/libGL.so.1`|\n+| `--use-system-load-library`                                  | libraries specified using `-l` are loaded in the loader symbol lookup (using either `System::loadLibrary`, or `System::load`). Useful if the libraries must be loaded from one of the paths in `java.library.path`.| \n@@ -143,1 +87,0 @@\n-| `--source`                                                   | generate java sources instead of classfiles                  |\n@@ -174,1 +117,1 @@\n-jextract -t org.jextract --source @includes.txt point.h\n+jextract -t org.jextract @includes.txt point.h\n@@ -179,0 +122,92 @@\n+#### Tracing support\n+\n+It is sometimes useful to inspect the parameters passed to a native call, especially when diagnosing application\n+bugs and\/or crashes. The code generated by the `jextract` tool supports *tracing* of native calls, that is, parameters\n+passed to native calls can be printed on the standard output.\n+\n+To enable the tracing support, just pass the `-Djextract.trace.downcalls=true` flag to the launcher used to start the application.\n+Below we show an excerpt of the output when running the [OpenGL example](samples\/opengl) with tracing support enabled:\n+\n+```\n+glutInit(MemorySegment{ address: 0x7fa6b03d6400, byteSize: 4 }, MemorySegment{ address: 0x7fa6b03d6400, byteSize: 4 })\n+glutInitDisplayMode(18)\n+glutInitWindowSize(900, 900)\n+glutCreateWindow(MemorySegment{ address: 0x7fa6b03f8e70, byteSize: 14 })\n+glClearColor(0.0, 0.0, 0.0, 0.0)\n+glShadeModel(7425)\n+glLightfv(16384, 4611, MemorySegment{ address: 0x7fa6b03de8d0, byteSize: 16 })\n+glLightfv(16384, 4608, MemorySegment{ address: 0x7fa6b0634840, byteSize: 16 })\n+glLightfv(16384, 4609, MemorySegment{ address: 0x7fa6b0634840, byteSize: 16 })\n+glLightfv(16384, 4610, MemorySegment{ address: 0x7fa6b0634840, byteSize: 16 })\n+glMaterialfv(1028, 5633, MemorySegment{ address: 0x7fa6b0634860, byteSize: 4 })\n+glEnable(2896)\n+glEnable(16384)\n+glEnable(2929)\n+glutDisplayFunc(MemorySegment{ address: 0x7fa6a002e820, byteSize: 0 })\n+glutIdleFunc(MemorySegment{ address: 0x7fa6a015a620, byteSize: 0 })\n+glutMainLoop()\n+glClear(16640)\n+glPushMatrix()\n+glRotatef(-20.0, 1.0, 1.0, 0.0)\n+glRotatef(0.0, 0.0, 1.0, 0.0)\n+glutSolidTeapot(0.5)\n+```\n+\n+---\n+\n+### Building\n+\n+`jextract` depends on the [C libclang API](https:\/\/clang.llvm.org\/doxygen\/group__CINDEX.html). To build the jextract sources, the easiest option is to download LLVM binaries for your platform, which can be found [here](https:\/\/releases.llvm.org\/download.html) (version >= 9 is required). Both the `jextract` tool and the bindings it generates depend heavily on the [Foreign Function & Memory API](https:\/\/openjdk.java.net\/jeps\/434), so a suitable [jdk 22 distribution](https:\/\/jdk.java.net\/22\/) is also required.\n+\n+> <details><summary><strong>Building older jextract versions<\/strong><\/summary>\n+>\n+> The `master` branch always tracks the latest version of the JDK. If you wish to build an older version of jextract, which targets an earlier version of the JDK you can do so by checking out the appropriate branch.\n+> For example, to build a jextract tool which works against JDK 21:\n+>\n+> `git checkout jdk21`\n+>\n+> Over time, new branches will be added, each targeting a specific JDK version.\n+> <\/details>\n+\n+`jextract` can be built using `gradle`, as follows (on Windows, `gradlew.bat` should be used instead).\n+\n+(**Note**: Run the Gradle build with a Java version appropriate for the Gradle version. For example, Gradle 7.5.1\n+supports JDK 21. Please checkout the [Gradle compatibility matrix](https:\/\/docs.gradle.org\/current\/userguide\/compatibility.html#java) for the appropate JDK version needed for builds)\n+\n+\n+\n+```sh\n+$ sh .\/gradlew -Pjdk21_home=<jdk21_home_dir> -Pllvm_home=<libclang_dir> clean verify\n+```\n+\n+\n+> <details><summary><strong>Using a local installation of LLVM<\/strong><\/summary>\n+>\n+> While the recommended way is to use a [release from the LLVM project](https:\/\/releases.llvm.org\/download.html),\n+> extract it then make `llvm_home` point to this directory, it may be possible to use a local installation instead.\n+>\n+> E.g. on macOs the `llvm_home` can also be set as one of these locations :\n+>\n+> * `\/Library\/Developer\/CommandLineTools\/usr\/` if using Command Line Tools\n+> * `\/Applications\/Xcode.app\/Contents\/Developer\/Toolchains\/XcodeDefault.xctoolchain\/usr\/` if using XCode\n+> * `$(brew --prefix llvm)` if using the [LLVM install from Homebrew](https:\/\/formulae.brew.sh\/formula\/llvm#default)\n+>\n+> <\/details>\n+\n+After building, there should be a new `jextract` folder under `build`.\n+To run the `jextract` tool, simply run the `jextract` command in the `bin` folder:\n+\n+```sh\n+$ build\/jextract\/bin\/jextract\n+Expected a header file\n+```\n+\n+### Testing\n+\n+The repository also contains a comprehensive set of tests, written using the [jtreg](https:\/\/openjdk.java.net\/jtreg\/) test framework, which can be run as follows (again, on Windows, `gradlew.bat` should be used instead):\n+\n+```sh\n+$ sh .\/gradlew -Pjdk21_home=<jdk21_home_dir> -Pllvm_home=<libclang_dir> -Pjtreg_home=<jtreg_home> jtreg\n+```\n+\n+Note: running `jtreg` task requires `cmake` to be available on the `PATH`.\n","filename":"README.md","additions":115,"deletions":80,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -9,0 +9,15 @@\n+sourceSets {\n+    test {\n+        java {\n+            srcDirs = ['test\/jtreg', file(\"test\/jtreg\/generator\").listFiles(), 'test\/lib', 'test\/testng']\n+            \/\/ exclude all test files from compilation. Jtreg compiles these for us when tests run\n+            exclude \"**\/*\"\n+        }\n+    }\n+}\n+\n+dependencies {\n+    \/\/ add jtreg jars as dependencies of tests\n+    testImplementation fileTree(dir: findProperty(\"jtreg_home\") + \"\/lib\/\", include: \"*.jar\")\n+}\n+\n@@ -28,2 +43,1 @@\n-def jextract_jmod_libs_dir = \"$buildDir\/jextract_jmod_libs\"\n-def jextract_jmod_conf_dir = \"$buildDir\/jextract_jmod_conf\";\n+def jextract_jmod_inputs = \"$buildDir\/jmod_inputs\"\n@@ -44,0 +58,1 @@\n+    options.compilerArgs << \"--enable-preview\"\n@@ -53,8 +68,2 @@\n-task copyLibClang(type: Copy) {\n-    dependsOn jar\n-\n-    def dir_prefix_len = \"$buildDir\".length()\n-    def libs_dir = jextract_jmod_libs_dir.substring(dir_prefix_len)\n-    def conf_dir = jextract_jmod_conf_dir.substring(dir_prefix_len)\n-\n-    into(\"$buildDir\")\n+task copyLibClang(type: Sync) {\n+    into(\"$buildDir\/jmod_inputs\")\n@@ -65,1 +74,2 @@\n-        into(libs_dir)\n+        exclude(\"clang.exe\")\n+        into(\"libs\")\n@@ -70,1 +80,1 @@\n-        into(conf_dir + \"\/jextract\")\n+        into(\"conf\/jextract\")\n@@ -75,1 +85,1 @@\n-    dependsOn copyLibClang\n+    dependsOn jar, copyLibClang\n@@ -79,0 +89,1 @@\n+    inputs.dir(\"$jextract_jmod_inputs\")\n@@ -90,2 +101,2 @@\n-          \"--libs=$jextract_jmod_libs_dir\",\n-          \"--conf=$jextract_jmod_conf_dir\",\n+          \"--libs=$jextract_jmod_inputs\/libs\",\n+          \"--conf=$jextract_jmod_inputs\/conf\",\n@@ -100,1 +111,1 @@\n-    inputs.file(jar.archiveFile.get())\n+    inputs.file(\"$jextract_jmod_file\")\n@@ -104,2 +115,2 @@\n-        '\\\\\"--enable-native-access=org.openjdk.jextract\\\\\"' :\n-        '\"--enable-native-access=org.openjdk.jextract\"'\n+        '\\\\\"--enable-native-access=org.openjdk.jextract\\\\\" \\\\\"--enable-preview\\\"\"' :\n+        '\"--enable-native-access=org.openjdk.jextract\" \"--enable-preview\"'\n@@ -114,1 +125,1 @@\n-         \"--add-modules=org.openjdk.jextract,jdk.compiler,jdk.zipfs\",\n+         \"--add-modules=org.openjdk.jextract\",\n@@ -117,0 +128,1 @@\n+         \"--strip-debug\", \"--no-man-pages\", \"--no-header-files\",\n@@ -135,1 +147,1 @@\n-    dependsOn verify\n+    dependsOn createJextractJmod\n@@ -140,1 +152,1 @@\n-    inputs.file(jar.archiveFile.get())\n+    inputs.file(\"$jextract_jmod_file\")\n@@ -177,3 +189,3 @@\n-\/\/ run jtreg tests. Note: needs jtreg_home variable set to point to the jtreg\n-task jtreg(type: JavaExec) {\n-    dependsOn createRuntimeImageForTest,cmakeBuild\n+void createJtregTask(String name, boolean coverage, String os_lib_dir) {\n+    tasks.register(name, JavaExec) {\n+        dependsOn createRuntimeImageForTest,cmakeBuild\n@@ -181,1 +193,0 @@\n-    doFirst {\n@@ -185,0 +196,26 @@\n+        \/\/ e.g.: <jacoco repo>\/org.jacoco.agent\/target\/classes\/jacocoagent.jar\n+        if (coverage && findProperty(\"jacoco_agent\") == null) {\n+            throw new GradleException(\"jacoco_agent is not defined\")\n+        }\n+\n+        workingDir = \"$buildDir\"\n+\n+        classpath = files(findProperty(\"jtreg_home\") + \"\/lib\/jtreg.jar\")\n+\n+        args = [\n+                \"-jdk\", \"$buildDir\/jextract-jdk-test-image\",\n+                \"-nativepath:$buildDir\/testlib-install\/${os_lib_dir}\",\n+                \"-javaoption:--enable-preview\",\n+                \"-javaoption:--enable-native-access=org.openjdk.jextract,ALL-UNNAMED\",\n+                \"-avm\", \"-conc:auto\", \"-verbose:summary,fail,error\",\n+                \"-retain:fail,error\",\n+        ]\n+\n+        if (coverage) {\n+            String jacocoAgent = findProperty(\"jacoco_agent\")\n+            String coverageFile = \"$buildDir\/jacoco-run\/jextract.exec\"\n+            String includes = \"org.openjdk.jextract.*\"\n+            args += \"-javaoption:-javaagent:$jacocoAgent=destfile=$coverageFile,includes=$includes\"\n+        }\n+\n+        args += \"..\/test\"\n@@ -186,0 +223,4 @@\n+}\n+\n+createJtregTask(\"jtreg\", false, os_lib_dir)\n+createJtregTask(\"jtregWithCoverage\", true, os_lib_dir)\n@@ -187,1 +228,7 @@\n-    workingDir = \"$buildDir\"\n+tasks.register(\"coverage\", JavaExec) {\n+    dependsOn jtregWithCoverage\n+\n+    \/\/ e.g.: <jacoco repo>\/org.jacoco.cli\/target\/org.jacoco.cli-0.8.12-SNAPSHOT-nodeps.jar\n+    if (findProperty(\"jacoco_cli\") == null) {\n+        throw new GradleException(\"jacoco_cli is not defined\")\n+    }\n@@ -189,1 +236,1 @@\n-    classpath = files(findProperty(\"jtreg_home\") + \"\/lib\/jtreg.jar\")\n+    classpath = files(findProperty(\"jacoco_cli\"))\n@@ -192,5 +239,5 @@\n-            \"-jdk\", \"$buildDir\/jextract-jdk-test-image\",\n-            \"-nativepath:$buildDir\/testlib-install\/${os_lib_dir}\",\n-            \"-javaoption:--enable-native-access=org.openjdk.jextract,ALL-UNNAMED\",\n-            \"-avm\", \"-conc:auto\", \"-verbose:summary\",\n-            \"..\/test\"\n+            \"report\",\n+            \"$buildDir\/jacoco-run\/jextract.exec\",\n+            \"--classfiles\", \"$buildDir\/classes\/java\/main\",\n+            \"--sourcefiles\", \"$projectDir\/src\/main\/java\",\n+            \"--html\", \"$buildDir\/jacoco-report\"\n","filename":"build.gradle","additions":79,"deletions":32,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -1,3 +0,0 @@\n-jextract -D FORCE_OPENBLAS_COMPLEX_STRUCT \\\n-  -l openblas -t blas \/usr\/local\/opt\/openblas\/include\/cblas.h\n-\n","filename":"samples\/cblas\/compile.sh","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -7,0 +7,1 @@\n+  --output src `\r\n@@ -11,0 +12,2 @@\n+\r\n+javac -d classes (ls -r src\/*.java)\r\n","filename":"samples\/cblas\/compile_windows.ps1","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-jextract --source -D FORCE_OPENBLAS_COMPLEX_STRUCT \\\n+jextract --output src -D FORCE_OPENBLAS_COMPLEX_STRUCT \\\n@@ -4,1 +4,1 @@\n-javac --enable-preview --source=22 blas\/*.java\n+javac --source=22 -d . src\/blas\/*.java\n","filename":"samples\/cblas\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-time java --enable-native-access=ALL-UNNAMED --enable-preview --source=22 \\\n+java --enable-native-access=ALL-UNNAMED \\\n","filename":"samples\/cblas\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12,0 +12,1 @@\n+  -cp classes `\r\n@@ -13,1 +14,0 @@\n-  --enable-preview --source=22 `\r\n","filename":"samples\/cblas\/run_windows.ps1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+rm -rf src\n@@ -6,0 +7,1 @@\n+rm -rf src\n@@ -10,0 +12,1 @@\n+rm -rf src\n@@ -14,0 +17,1 @@\n+rm -rf src\n@@ -18,0 +22,1 @@\n+rm -rf src\n@@ -21,0 +26,1 @@\n+rm -rf src\n@@ -24,0 +30,1 @@\n+rm -rf src\n@@ -27,0 +34,2 @@\n+rm -rf src\n+rm -rf frame*.ppm\n@@ -33,0 +42,1 @@\n+rm -rf src\n@@ -36,0 +46,1 @@\n+rm -rf src\n@@ -39,0 +50,1 @@\n+rm -rf src\n@@ -42,0 +54,1 @@\n+rm -rf src\n@@ -45,0 +58,1 @@\n+rm -rf src\n@@ -48,0 +62,1 @@\n+rm -rf src\n@@ -51,0 +66,1 @@\n+rm -rf src\n@@ -54,0 +70,1 @@\n+rm -rf src\n@@ -58,0 +75,1 @@\n+rm -rf src\n@@ -61,0 +79,1 @@\n+rm -rf src\n@@ -64,0 +83,1 @@\n+rm -rf src\n@@ -67,0 +87,1 @@\n+rm -rf src\n","filename":"samples\/cleanall.sh","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1,85 +0,0 @@\n-sh .\/cleanall.sh\n-echo \"compiling cblas\"\n-cd cblas\n-sh .\/compile.sh\n-cd ..\n-echo \"compiling dlopen\"\n-cd dlopen\n-sh .\/compile.sh\n-cd ..\n-echo \"compiling go\"\n-cd go\n-sh .\/compile.sh\n-cd ..\n-echo \"compiling helloworld\"\n-cd helloworld\n-sh .\/compile.sh\n-cd ..\n-echo \"compiling lapack\"\n-cd lapack\n-sh .\/compile.sh\n-cd ..\n-echo \"compiling libclang\"\n-cd libclang\n-sh .\/compile.sh\n-cd ..\n-echo \"compiling libcurl\"\n-cd libcurl\n-sh .\/compile.sh\n-cd ..\n-echo \"compiling libffmpeg\"\n-cd libffmpeg\n-sh .\/compile.sh\n-cd ..\n-echo \"compiling libjimage\"\n-cd libjimage\n-sh .\/compile.sh\n-cd ..\n-echo \"compiling libgit2\"\n-cd libgit2\n-sh .\/compile.sh\n-cd ..\n-echo \"compiling libproc\"\n-cd libproc\n-sh .\/compile.sh\n-cd ..\n-echo \"compiling lp_solve\"\n-cd lp_solve\n-sh .\/compile.sh\n-cd ..\n-echo \"compiling opengl\"\n-cd opengl\n-sh .\/compile.sh\n-cd ..\n-echo \"compiling pcre2\"\n-cd pcre2\n-sh .\/compile.sh\n-cd ..\n-echo \"compiling python3\"\n-cd python3\n-sh .\/compile.sh\n-cd ..\n-echo \"compiling readline\"\n-cd readline\n-sh .\/compile.sh\n-cd ..\n-echo \"compiling sqlite\"\n-cd sqlite\n-sh .\/compile.sh\n-cd ..\n-echo \"compiling tcl\"\n-cd tcl\n-sh .\/compile.sh\n-cd ..\n-echo \"compiling tensorflow\"\n-cd tensorflow\n-sh .\/compile.sh\n-cd ..\n-echo \"compiling time\"\n-cd time\n-sh .\/compile.sh\n-cd ..\n-echo \"compiling libzstd\"\n-cd libzstd\n-sh .\/compile.sh\n-cd ..\n","filename":"samples\/compileall.sh","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -1,4 +0,0 @@\n-cc --shared -o libhello.dylib hello.c\n-\n-jextract -t org.unix \\\n-  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/dlfcn.h\n","filename":"samples\/dlopen\/compile.sh","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -3,1 +3,1 @@\n-jextract --source -t org.unix \\\n+jextract --output src -t org.unix \\\n@@ -6,1 +6,1 @@\n-javac --enable-preview --source=22 org\/unix\/*.java\n+javac --source=22 -d . src\/org\/unix\/*.java\n","filename":"samples\/dlopen\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,0 @@\n-   --enable-preview --source=22 \\\n","filename":"samples\/dlopen\/run.sh","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-go build -o libhello.dylib  -buildmode=c-shared\n-jextract -l hello -t org.golang libhello.h\n","filename":"samples\/go\/compile.sh","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -2,2 +2,2 @@\n-jextract --source -l hello -t org.golang libhello.h\n-javac --enable-preview --source=22 org\/golang\/*.java\n+jextract -l hello -t org.golang libhello.h\n+javac --source=22 org\/golang\/*.java\n","filename":"samples\/go\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-java --enable-preview --source=22 --enable-native-access=ALL-UNNAMED Main.java\n+java --enable-native-access=ALL-UNNAMED Main.java\n","filename":"samples\/go\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-cc -shared -o libhelloworld.dylib helloworld.c\n-jextract -t org.hello -lhelloworld helloworld.h\n","filename":"samples\/helloworld\/compile.sh","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -2,2 +2,2 @@\n-jextract --source -t org.hello -lhelloworld helloworld.h\n-javac --enable-preview --source=22 org\/hello\/*.java\n+jextract --output src -t org.hello -lhelloworld helloworld.h\n+javac --source=22 -d . src\/org\/hello\/*.java\n","filename":"samples\/helloworld\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-java --enable-native-access=ALL-UNNAMED --enable-preview --source=22 HelloWorld.java\n+java --enable-native-access=ALL-UNNAMED HelloWorld.java\n","filename":"samples\/helloworld\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,3 +0,0 @@\n-jextract \\\n-   -l lapacke -t lapack \\\n-   \/usr\/local\/opt\/lapack\/include\/lapacke.h \n","filename":"samples\/lapack\/compile.sh","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -7,0 +7,1 @@\n+  --output src `\r\n@@ -11,0 +12,2 @@\n+\r\n+javac -d classes (ls -r src\/*.java)\r\n","filename":"samples\/lapack\/compile_windows.ps1","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-jextract --source \\\n+jextract --output src \\\n@@ -5,1 +5,1 @@\n-javac --enable-preview --source=22 lapack\/*.java\n+javac --source=22 -d . src\/lapack\/*.java\n","filename":"samples\/lapack\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-java --enable-native-access=ALL-UNNAMED --enable-preview --source=22 \\\n+java --enable-native-access=ALL-UNNAMED \\\n","filename":"samples\/lapack\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12,0 +12,1 @@\n+  -cp classes `\r\n@@ -13,1 +14,0 @@\n-  --enable-preview --source=22 `\r\n","filename":"samples\/lapack\/run_windows.ps1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-                if (CXType.kind$get(type) != CXType_Invalid()) {\n+                if (CXType.kind(type) != CXType_Invalid()) {\n","filename":"samples\/libclang\/ASTPrinter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,4 +0,0 @@\n-jextract -t org.llvm.clang -lclang \\\n-  -I ${LIBCLANG_HOME}\/include\/ \\\n-  -I ${LIBCLANG_HOME}\/include\/clang-c \\\n-  ${LIBCLANG_HOME}\/include\/clang-c\/Index.h\n","filename":"samples\/libclang\/compile.sh","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -7,0 +7,1 @@\n+  --output src `\r\n@@ -12,0 +13,2 @@\n+\r\n+javac -d classes (ls -r src\/*.java)\r\n","filename":"samples\/libclang\/compile_windows.ps1","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-jextract --source -t org.llvm.clang -lclang \\\n+jextract --output src -t org.llvm.clang -lclang \\\n@@ -5,1 +5,1 @@\n-javac --enable-preview --source=22 org\/llvm\/clang\/*.java\n+javac --source=22 -d . src\/org\/llvm\/clang\/*.java\n","filename":"samples\/libclang\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,0 @@\n-    --enable-preview --source=22 \\\n","filename":"samples\/libclang\/run.sh","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -7,0 +7,1 @@\n+  -cp classes `\r\n@@ -8,1 +9,0 @@\n-  --enable-preview --source=22 `\r\n@@ -10,1 +10,1 @@\n-  ASTPrinter.java hello.c\n\\ No newline at end of file\n+  ASTPrinter.java hello.c\r\n","filename":"samples\/libclang\/run_windows.ps1","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-               curl_easy_setopt(curl, CURLOPT_URL(), url.address());\n+               curl_easy_setopt.invoke(curl, CURLOPT_URL(), url.address());\n","filename":"samples\/libcurl\/CurlMain.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-jextract -t org.jextract -lcurl \\\n-  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/curl\/curl.h\n","filename":"samples\/libcurl\/compile.sh","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -12,1 +12,1 @@\n-Select-String -Path 'includes_all.conf' -Pattern 'curl' | %{ $_.Line } | Out-File -FilePath 'includes_filtered.conf' -Encoding ascii\r\n+Select-String -Path 'includes_all.conf' -Pattern '(curl|sockaddr )' | %{ $_.Line } | Out-File -FilePath 'includes_filtered.conf' -Encoding ascii\r\n@@ -15,0 +15,1 @@\n+  --output src `\r\n@@ -21,0 +22,2 @@\n+\r\n+javac -d classes (ls -r src\/*.java)\r\n","filename":"samples\/libcurl\/compile_windows.ps1","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-jextract --source -t org.jextract -lcurl \\\n+jextract --output src -t org.jextract -lcurl \\\n@@ -4,1 +4,1 @@\n-javac --enable-preview --source=22 org\/jextract\/*.java\n+javac --source=22 -d . src\/org\/jextract\/*.java\n","filename":"samples\/libcurl\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,0 @@\n-    --enable-preview --source=22 \\\n","filename":"samples\/libcurl\/run.sh","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -9,0 +9,1 @@\n+  -cp classes `\r\n@@ -10,1 +11,0 @@\n-  --enable-preview --source=22 `\r\n","filename":"samples\/libcurl\/run_windows.ps1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,1 @@\n-                int nb_streams = AVFormatContext.nb_streams$get(pFormatCtx);\n+                int nb_streams = AVFormatContext.nb_streams(pFormatCtx);\n@@ -111,1 +111,1 @@\n-                var pStreams = AVFormatContext.streams$get(pFormatCtx);\n+                var pStreams = AVFormatContext.streams(pFormatCtx);\n@@ -121,2 +121,2 @@\n-                    pCodecCtx = AVStream.codec$get(pStream);\n-                    if (AVCodecContext.codec_type$get(pCodecCtx) == AVMEDIA_TYPE_VIDEO()) {\n+                    pCodecCtx = AVStream.codec(pStream);\n+                    if (AVCodecContext.codec_type(pCodecCtx) == AVMEDIA_TYPE_VIDEO()) {\n@@ -126,1 +126,1 @@\n-                        pCodec = avcodec_find_decoder(AVCodecContext.codec_id$get(pCodecCtx));\n+                        pCodec = avcodec_find_decoder(AVCodecContext.codec_id(pCodecCtx));\n@@ -163,2 +163,2 @@\n-                int width = AVCodecContext.width$get(pCodecCtx);\n-                int height = AVCodecContext.height$get(pCodecCtx);\n+                int width = AVCodecContext.width(pCodecCtx);\n+                int height = AVCodecContext.height(pCodecCtx);\n@@ -185,1 +185,1 @@\n-                int pix_fmt = AVCodecContext.pix_fmt$get(pCodecCtx);\n+                int pix_fmt = AVCodecContext.pix_fmt(pCodecCtx);\n@@ -198,1 +198,1 @@\n-                    if (AVPacket.stream_index$get(packet) == videoStream) {\n+                    if (AVPacket.stream_index(packet) == videoStream) {\n@@ -206,3 +206,3 @@\n-                            sws_scale(sws_ctx, AVFrame.data$slice(pFrame),\n-                                    AVFrame.linesize$slice(pFrame), 0, height,\n-                                    AVFrame.data$slice(pFrameRGB), AVFrame.linesize$slice(pFrameRGB));\n+                            sws_scale(sws_ctx, AVFrame.data(pFrame),\n+                                    AVFrame.linesize(pFrame), 0, height,\n+                                    AVFrame.data(pFrameRGB), AVFrame.linesize(pFrameRGB));\n@@ -269,1 +269,1 @@\n-            var data = AVFrame.data$slice(frameRGB);\n+            var data = AVFrame.data(frameRGB);\n@@ -273,1 +273,1 @@\n-            var linesize = AVFrame.linesize$slice(frameRGB).get(C_INT, 0);\n+            var linesize = AVFrame.linesize(frameRGB).get(C_INT, 0);\n","filename":"samples\/libffmpeg\/LibffmpegMain.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1,9 +0,0 @@\n-jextract -t libffmpeg \\\n-  -I \/usr\/local\/Cellar\/ffmpeg@4\/4.4.4\/include \\\n-  -l avcodec \\\n-  -l avformat \\\n-  -l avutil \\\n-  -l swscale \\\n-  --header-class-name Libffmpeg \\\n-  libffmpeg.h\n-\n","filename":"samples\/libffmpeg\/compile.sh","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,2 +1,2 @@\n-jextract --source -t libffmpeg \\\n-  -I \/usr\/local\/Cellar\/ffmpeg@4\/4.4.4\/include \\\n+jextract --output src -t libffmpeg \\\n+  -I \/usr\/local\/Cellar\/ffmpeg@4\/4.4.4_4\/include \\\n@@ -10,1 +10,1 @@\n-javac --enable-preview --source=22 libffmpeg\/*.java\n+javac --source=22 -d . src\/libffmpeg\/*.java\n","filename":"samples\/libffmpeg\/compilesource.sh","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n-   --enable-preview --source=22 \\\n-   -Djava.library.path=\/usr\/local\/Cellar\/ffmpeg@4\/4.4.4\/lib LibffmpegMain.java $*\n+   -Djava.library.path=\/usr\/local\/Cellar\/ffmpeg@4\/4.4.4_4\/lib LibffmpegMain.java $*\n","filename":"samples\/libffmpeg\/run.sh","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,5 +0,0 @@\n-jextract -t com.github -lgit2 \\\n-  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n-  -I ${LIBGIT2_HOME}\/include\/ \\\n-  -I ${LIBGIT2_HOME}\/include\/git2 \\\n-  ${LIBGIT2_HOME}\/include\/git2.h\n","filename":"samples\/libgit2\/compile.sh","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -7,0 +7,1 @@\n+  --output src `\r\n@@ -11,0 +12,2 @@\n+\r\n+javac -d classes (ls -r src\/*.java)\r\n","filename":"samples\/libgit2\/compile_windows.ps1","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-jextract --source -t com.github -lgit2 \\\n+jextract --output src -t com.github -lgit2 \\\n@@ -7,1 +7,1 @@\n-javac --enable-preview --source=22 com\/github\/*.java\n+javac --source=22 -d . src\/com\/github\/*.java\n","filename":"samples\/libgit2\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -11,0 +11,1 @@\n+  -cp classes `\r\n@@ -12,1 +13,0 @@\n-  --enable-preview --source=22 `\r\n","filename":"samples\/libgit2\/run_windows.ps1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-javac -d build --enable-preview --source=22 org\/openjdk\/*.java\n","filename":"samples\/libjimage\/compile.sh","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -1,1 +1,1 @@\n-javac -d build --enable-preview --source=22 org\/openjdk\/*.java\n+javac -d build --source=22 org\/openjdk\/*.java\n","filename":"samples\/libjimage\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n-  --source \\\n","filename":"samples\/libjimage\/extract.sh","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/\/ Generated by jextract\n+\n+package org.openjdk;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * JImageResourceVisitor_t visitor\n+ * }\n+ *\/\n+public class JIMAGE_ResourceIterator$visitor {\n+\n+    public interface Function {\n+        int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6);\n+    }\n+\n+    private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+        jimage_h.C_INT,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER\n+    );\n+\n+    public static FunctionDescriptor descriptor() {\n+        return $DESC;\n+    }\n+\n+    private static final MethodHandle UP$MH = jimage_h.upcallHandle(JIMAGE_ResourceIterator$visitor.Function.class, \"apply\", $DESC);\n+\n+    public static MemorySegment allocate(JIMAGE_ResourceIterator$visitor.Function fi, Arena scope) {\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n+    }\n+\n+    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+    public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6) {\n+        try {\n+            return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+}\n+\n","filename":"samples\/libjimage\/org\/openjdk\/JIMAGE_ResourceIterator$visitor.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -5,3 +5,1 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n+import java.lang.invoke.*;\n@@ -9,0 +7,5 @@\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n@@ -10,0 +13,2 @@\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n@@ -11,2 +16,2 @@\n- * {@snippet :\n- * void (*JImageClose_t)(struct JImageFile* jimage);\n+ * {@snippet lang=c :\n+ * typedef void (*JImageClose_t)(JImageFile *)\n@@ -15,1 +20,1 @@\n-public interface JImageClose_t {\n+public class JImageClose_t {\n@@ -17,3 +22,2 @@\n-    void apply(java.lang.foreign.MemorySegment jimage);\n-    static MemorySegment allocate(JImageClose_t fi, Arena scope) {\n-        return RuntimeHelper.upcallStub(constants$1.const$0, fi, constants$0.const$4, scope);\n+    public interface Function {\n+        void apply(MemorySegment jimage);\n@@ -21,9 +25,7 @@\n-    static JImageClose_t ofAddress(MemorySegment addr, Arena arena) {\n-        MemorySegment symbol = addr.reinterpret(arena, null);\n-        return (java.lang.foreign.MemorySegment _jimage) -> {\n-            try {\n-                constants$1.const$1.invokeExact(symbol, _jimage);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        };\n+\n+    private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+        jimage_h.C_POINTER\n+    );\n+\n+    public static FunctionDescriptor descriptor() {\n+        return $DESC;\n@@ -31,1 +33,0 @@\n-}\n@@ -33,0 +34,16 @@\n+    private static final MethodHandle UP$MH = jimage_h.upcallHandle(JImageClose_t.Function.class, \"apply\", $DESC);\n+\n+    public static MemorySegment allocate(JImageClose_t.Function fi, Arena scope) {\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n+    }\n+\n+    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+    public static void invoke(MemorySegment funcPtr,MemorySegment jimage) {\n+        try {\n+             DOWN$MH.invokeExact(funcPtr, jimage);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+}\n","filename":"samples\/libjimage\/org\/openjdk\/JImageClose_t.java","additions":36,"deletions":19,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -5,3 +5,1 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n+import java.lang.invoke.*;\n@@ -9,0 +7,5 @@\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n@@ -10,0 +13,2 @@\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n@@ -11,2 +16,2 @@\n- * {@snippet :\n- * long long (*JImageFindResource_t)(struct JImageFile* jimage,char* module_name,char* version,char* name,long long* size);\n+ * {@snippet lang=c :\n+ * typedef JImageLocationRef (*JImageFindResource_t)(JImageFile *, const char *, const char *, const char *, jlong *)\n@@ -15,1 +20,1 @@\n-public interface JImageFindResource_t {\n+public class JImageFindResource_t {\n@@ -17,3 +22,2 @@\n-    long apply(java.lang.foreign.MemorySegment jimage, java.lang.foreign.MemorySegment module_name, java.lang.foreign.MemorySegment version, java.lang.foreign.MemorySegment name, java.lang.foreign.MemorySegment size);\n-    static MemorySegment allocate(JImageFindResource_t fi, Arena scope) {\n-        return RuntimeHelper.upcallStub(constants$2.const$0, fi, constants$1.const$4, scope);\n+    public interface Function {\n+        long apply(MemorySegment jimage, MemorySegment module_name, MemorySegment version, MemorySegment name, MemorySegment size);\n@@ -21,9 +25,12 @@\n-    static JImageFindResource_t ofAddress(MemorySegment addr, Arena arena) {\n-        MemorySegment symbol = addr.reinterpret(arena, null);\n-        return (java.lang.foreign.MemorySegment _jimage, java.lang.foreign.MemorySegment _module_name, java.lang.foreign.MemorySegment _version, java.lang.foreign.MemorySegment _name, java.lang.foreign.MemorySegment _size) -> {\n-            try {\n-                return (long)constants$2.const$1.invokeExact(symbol, _jimage, _module_name, _version, _name, _size);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        };\n+\n+    private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+        jimage_h.C_LONG_LONG,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER\n+    );\n+\n+    public static FunctionDescriptor descriptor() {\n+        return $DESC;\n@@ -31,1 +38,0 @@\n-}\n@@ -33,0 +39,16 @@\n+    private static final MethodHandle UP$MH = jimage_h.upcallHandle(JImageFindResource_t.Function.class, \"apply\", $DESC);\n+\n+    public static MemorySegment allocate(JImageFindResource_t.Function fi, Arena scope) {\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n+    }\n+\n+    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+    public static long invoke(MemorySegment funcPtr,MemorySegment jimage, MemorySegment module_name, MemorySegment version, MemorySegment name, MemorySegment size) {\n+        try {\n+            return (long) DOWN$MH.invokeExact(funcPtr, jimage, module_name, version, name, size);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+}\n","filename":"samples\/libjimage\/org\/openjdk\/JImageFindResource_t.java","additions":41,"deletions":19,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -5,3 +5,1 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n+import java.lang.invoke.*;\n@@ -9,0 +7,5 @@\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n@@ -10,0 +13,2 @@\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n@@ -11,2 +16,2 @@\n- * {@snippet :\n- * long long (*JImageGetResource_t)(struct JImageFile* jimage,long long location,char* buffer,long long size);\n+ * {@snippet lang=c :\n+ * typedef jlong (*JImageGetResource_t)(JImageFile *, JImageLocationRef, char *, jlong)\n@@ -15,1 +20,1 @@\n-public interface JImageGetResource_t {\n+public class JImageGetResource_t {\n@@ -17,3 +22,2 @@\n-    long apply(java.lang.foreign.MemorySegment jimage, long location, java.lang.foreign.MemorySegment buffer, long size);\n-    static MemorySegment allocate(JImageGetResource_t fi, Arena scope) {\n-        return RuntimeHelper.upcallStub(constants$2.const$4, fi, constants$2.const$2, scope);\n+    public interface Function {\n+        long apply(MemorySegment jimage, long location, MemorySegment buffer, long size);\n@@ -21,9 +25,11 @@\n-    static JImageGetResource_t ofAddress(MemorySegment addr, Arena arena) {\n-        MemorySegment symbol = addr.reinterpret(arena, null);\n-        return (java.lang.foreign.MemorySegment _jimage, long _location, java.lang.foreign.MemorySegment _buffer, long _size) -> {\n-            try {\n-                return (long)constants$2.const$5.invokeExact(symbol, _jimage, _location, _buffer, _size);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        };\n+\n+    private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+        jimage_h.C_LONG_LONG,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_LONG_LONG,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_LONG_LONG\n+    );\n+\n+    public static FunctionDescriptor descriptor() {\n+        return $DESC;\n@@ -31,1 +37,0 @@\n-}\n@@ -33,0 +38,16 @@\n+    private static final MethodHandle UP$MH = jimage_h.upcallHandle(JImageGetResource_t.Function.class, \"apply\", $DESC);\n+\n+    public static MemorySegment allocate(JImageGetResource_t.Function fi, Arena scope) {\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n+    }\n+\n+    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+    public static long invoke(MemorySegment funcPtr,MemorySegment jimage, long location, MemorySegment buffer, long size) {\n+        try {\n+            return (long) DOWN$MH.invokeExact(funcPtr, jimage, location, buffer, size);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+}\n","filename":"samples\/libjimage\/org\/openjdk\/JImageGetResource_t.java","additions":40,"deletions":19,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -5,3 +5,1 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n+import java.lang.invoke.*;\n@@ -9,0 +7,5 @@\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n@@ -10,0 +13,2 @@\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n@@ -11,2 +16,2 @@\n- * {@snippet :\n- * struct JImageFile* (*JImageOpen_t)(char* name,int* error);\n+ * {@snippet lang=c :\n+ * typedef JImageFile *(*JImageOpen_t)(const char *, jint *)\n@@ -15,1 +20,1 @@\n-public interface JImageOpen_t {\n+public class JImageOpen_t {\n@@ -17,3 +22,2 @@\n-    java.lang.foreign.MemorySegment apply(java.lang.foreign.MemorySegment jimage, java.lang.foreign.MemorySegment package_name);\n-    static MemorySegment allocate(JImageOpen_t fi, Arena scope) {\n-        return RuntimeHelper.upcallStub(constants$0.const$2, fi, constants$0.const$0, scope);\n+    public interface Function {\n+        MemorySegment apply(MemorySegment name, MemorySegment error);\n@@ -21,9 +25,9 @@\n-    static JImageOpen_t ofAddress(MemorySegment addr, Arena arena) {\n-        MemorySegment symbol = addr.reinterpret(arena, null);\n-        return (java.lang.foreign.MemorySegment _jimage, java.lang.foreign.MemorySegment _package_name) -> {\n-            try {\n-                return (java.lang.foreign.MemorySegment)constants$0.const$3.invokeExact(symbol, _jimage, _package_name);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        };\n+\n+    private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER\n+    );\n+\n+    public static FunctionDescriptor descriptor() {\n+        return $DESC;\n@@ -31,1 +35,0 @@\n-}\n@@ -33,0 +36,16 @@\n+    private static final MethodHandle UP$MH = jimage_h.upcallHandle(JImageOpen_t.Function.class, \"apply\", $DESC);\n+\n+    public static MemorySegment allocate(JImageOpen_t.Function fi, Arena scope) {\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n+    }\n+\n+    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+    public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment name, MemorySegment error) {\n+        try {\n+            return (MemorySegment) DOWN$MH.invokeExact(funcPtr, name, error);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+}\n","filename":"samples\/libjimage\/org\/openjdk\/JImageOpen_t.java","additions":38,"deletions":19,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -5,3 +5,1 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n+import java.lang.invoke.*;\n@@ -9,0 +7,5 @@\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n@@ -10,0 +13,2 @@\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n@@ -11,2 +16,2 @@\n- * {@snippet :\n- * char* (*JImagePackageToModule_t)(struct JImageFile* jimage,char* package_name);\n+ * {@snippet lang=c :\n+ * typedef const char *(*JImagePackageToModule_t)(JImageFile *, const char *)\n@@ -15,1 +20,1 @@\n-public interface JImagePackageToModule_t {\n+public class JImagePackageToModule_t {\n@@ -17,3 +22,2 @@\n-    java.lang.foreign.MemorySegment apply(java.lang.foreign.MemorySegment jimage, java.lang.foreign.MemorySegment package_name);\n-    static MemorySegment allocate(JImagePackageToModule_t fi, Arena scope) {\n-        return RuntimeHelper.upcallStub(constants$1.const$3, fi, constants$0.const$0, scope);\n+    public interface Function {\n+        MemorySegment apply(MemorySegment jimage, MemorySegment package_name);\n@@ -21,9 +25,9 @@\n-    static JImagePackageToModule_t ofAddress(MemorySegment addr, Arena arena) {\n-        MemorySegment symbol = addr.reinterpret(arena, null);\n-        return (java.lang.foreign.MemorySegment _jimage, java.lang.foreign.MemorySegment _package_name) -> {\n-            try {\n-                return (java.lang.foreign.MemorySegment)constants$0.const$3.invokeExact(symbol, _jimage, _package_name);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        };\n+\n+    private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER\n+    );\n+\n+    public static FunctionDescriptor descriptor() {\n+        return $DESC;\n@@ -31,1 +35,0 @@\n-}\n@@ -33,0 +36,16 @@\n+    private static final MethodHandle UP$MH = jimage_h.upcallHandle(JImagePackageToModule_t.Function.class, \"apply\", $DESC);\n+\n+    public static MemorySegment allocate(JImagePackageToModule_t.Function fi, Arena scope) {\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n+    }\n+\n+    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+    public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment jimage, MemorySegment package_name) {\n+        try {\n+            return (MemorySegment) DOWN$MH.invokeExact(funcPtr, jimage, package_name);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+}\n","filename":"samples\/libjimage\/org\/openjdk\/JImagePackageToModule_t.java","additions":38,"deletions":19,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -5,3 +5,1 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n+import java.lang.invoke.*;\n@@ -9,0 +7,5 @@\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n@@ -10,0 +13,2 @@\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n@@ -11,2 +16,2 @@\n- * {@snippet :\n- * void (*JImageResourceIterator_t)(struct JImageFile* jimage,int (*visitor)(struct JImageFile*,char*,char*,char*,char*,char*,void*),void* arg);\n+ * {@snippet lang=c :\n+ * typedef void (*JImageResourceIterator_t)(JImageFile *, JImageResourceVisitor_t, void *)\n@@ -15,1 +20,1 @@\n-public interface JImageResourceIterator_t {\n+public class JImageResourceIterator_t {\n@@ -17,3 +22,2 @@\n-    void apply(java.lang.foreign.MemorySegment jimage, java.lang.foreign.MemorySegment visitor, java.lang.foreign.MemorySegment arg);\n-    static MemorySegment allocate(JImageResourceIterator_t fi, Arena scope) {\n-        return RuntimeHelper.upcallStub(constants$3.const$5, fi, constants$3.const$3, scope);\n+    public interface Function {\n+        void apply(MemorySegment jimage, MemorySegment visitor, MemorySegment arg);\n@@ -21,9 +25,9 @@\n-    static JImageResourceIterator_t ofAddress(MemorySegment addr, Arena arena) {\n-        MemorySegment symbol = addr.reinterpret(arena, null);\n-        return (java.lang.foreign.MemorySegment _jimage, java.lang.foreign.MemorySegment _visitor, java.lang.foreign.MemorySegment _arg) -> {\n-            try {\n-                constants$4.const$0.invokeExact(symbol, _jimage, _visitor, _arg);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        };\n+\n+    private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER\n+    );\n+\n+    public static FunctionDescriptor descriptor() {\n+        return $DESC;\n@@ -31,1 +35,0 @@\n-}\n@@ -33,0 +36,16 @@\n+    private static final MethodHandle UP$MH = jimage_h.upcallHandle(JImageResourceIterator_t.Function.class, \"apply\", $DESC);\n+\n+    public static MemorySegment allocate(JImageResourceIterator_t.Function fi, Arena scope) {\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n+    }\n+\n+    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+    public static void invoke(MemorySegment funcPtr,MemorySegment jimage, MemorySegment visitor, MemorySegment arg) {\n+        try {\n+             DOWN$MH.invokeExact(funcPtr, jimage, visitor, arg);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+}\n","filename":"samples\/libjimage\/org\/openjdk\/JImageResourceIterator_t.java","additions":38,"deletions":19,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -5,3 +5,1 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n+import java.lang.invoke.*;\n@@ -9,0 +7,5 @@\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n@@ -10,0 +13,2 @@\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n@@ -11,2 +16,2 @@\n- * {@snippet :\n- * int (*JImageResourceVisitor_t)(struct JImageFile* jimage,char* module_name,char* version,char* package,char* name,char* extension,void* arg);\n+ * {@snippet lang=c :\n+ * typedef int (*JImageResourceVisitor_t)(JImageFile *, const char *, const char *, const char *, const char *, const char *, void *)\n@@ -15,1 +20,1 @@\n-public interface JImageResourceVisitor_t {\n+public class JImageResourceVisitor_t {\n@@ -17,3 +22,2 @@\n-    int apply(java.lang.foreign.MemorySegment jimage, java.lang.foreign.MemorySegment module_name, java.lang.foreign.MemorySegment version, java.lang.foreign.MemorySegment package_, java.lang.foreign.MemorySegment name, java.lang.foreign.MemorySegment extension, java.lang.foreign.MemorySegment arg);\n-    static MemorySegment allocate(JImageResourceVisitor_t fi, Arena scope) {\n-        return RuntimeHelper.upcallStub(constants$3.const$1, fi, constants$3.const$0, scope);\n+    public interface Function {\n+        int apply(MemorySegment jimage, MemorySegment module_name, MemorySegment version, MemorySegment package_, MemorySegment name, MemorySegment extension, MemorySegment arg);\n@@ -21,9 +25,14 @@\n-    static JImageResourceVisitor_t ofAddress(MemorySegment addr, Arena arena) {\n-        MemorySegment symbol = addr.reinterpret(arena, null);\n-        return (java.lang.foreign.MemorySegment _jimage, java.lang.foreign.MemorySegment _module_name, java.lang.foreign.MemorySegment _version, java.lang.foreign.MemorySegment _package_, java.lang.foreign.MemorySegment _name, java.lang.foreign.MemorySegment _extension, java.lang.foreign.MemorySegment _arg) -> {\n-            try {\n-                return (int)constants$3.const$2.invokeExact(symbol, _jimage, _module_name, _version, _package_, _name, _extension, _arg);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        };\n+\n+    private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+        jimage_h.C_INT,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER\n+    );\n+\n+    public static FunctionDescriptor descriptor() {\n+        return $DESC;\n@@ -31,1 +40,0 @@\n-}\n@@ -33,0 +41,16 @@\n+    private static final MethodHandle UP$MH = jimage_h.upcallHandle(JImageResourceVisitor_t.Function.class, \"apply\", $DESC);\n+\n+    public static MemorySegment allocate(JImageResourceVisitor_t.Function fi, Arena scope) {\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n+    }\n+\n+    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+    public static int invoke(MemorySegment funcPtr,MemorySegment jimage, MemorySegment module_name, MemorySegment version, MemorySegment package_, MemorySegment name, MemorySegment extension, MemorySegment arg) {\n+        try {\n+            return (int) DOWN$MH.invokeExact(funcPtr, jimage, module_name, version, package_, name, extension, arg);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+}\n","filename":"samples\/libjimage\/org\/openjdk\/JImageResourceVisitor_t.java","additions":43,"deletions":19,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -1,255 +0,0 @@\n-package org.openjdk;\n-\/\/ Generated by jextract\n-\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.SymbolLookup;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.io.File;\n-import java.nio.file.Path;\n-import java.nio.charset.StandardCharsets;\n-import java.util.Arrays;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-import java.lang.foreign.AddressLayout;\n-import java.lang.foreign.MemoryLayout;\n-\n-import static java.lang.foreign.Linker.*;\n-import static java.lang.foreign.ValueLayout.*;\n-import static java.lang.Long.MAX_VALUE;\n-\n-final class RuntimeHelper {\n-\n-    private static final Linker LINKER = Linker.nativeLinker();\n-    private static final ClassLoader LOADER = RuntimeHelper.class.getClassLoader();\n-    private static final MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();\n-    private static final SymbolLookup SYMBOL_LOOKUP;\n-    private static final SegmentAllocator THROWING_ALLOCATOR = (x, y) -> { throw new AssertionError(\"should not reach here\"); };\n-    static final AddressLayout POINTER = ValueLayout.ADDRESS.withTargetLayout(MemoryLayout.sequenceLayout(MAX_VALUE, JAVA_BYTE));\n-\n-    final static SegmentAllocator CONSTANT_ALLOCATOR =\n-            (size, align) -> Arena.ofAuto().allocate(size, align);\n-\n-    static {\n-        \/\/ manual change\n-        var libPath = System.getProperty(\"java.home\");\n-        var OS = System.getProperty(\"os.name\");\n-        if (OS.contains(\"Mac OS X\")) {\n-            libPath += \"\/lib\/libjimage.dylib\";\n-        } else if (OS.contains(\"Windows\")) {\n-            libPath = \"\/bin\/jimage.dll\";\n-        } else {\n-            libPath = \"\/lib\/libjimage.so\"; \/\/ some Unix\n-        }\n-        SymbolLookup loaderLookup = SymbolLookup.libraryLookup(libPath, Arena.global());\n-        SYMBOL_LOOKUP = name -> loaderLookup.find(name).or(() -> LINKER.defaultLookup().find(name));\n-    }\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private RuntimeHelper() {}\n-\n-    static <T> T requireNonNull(T obj, String symbolName) {\n-        if (obj == null) {\n-            throw new UnsatisfiedLinkError(\"unresolved symbol: \" + symbolName);\n-        }\n-        return obj;\n-    }\n-\n-    static MemorySegment lookupGlobalVariable(String name, MemoryLayout layout) {\n-        return SYMBOL_LOOKUP.find(name)\n-                .map(s -> s.reinterpret(layout.byteSize()))\n-                .orElse(null);\n-    }\n-\n-    static MethodHandle downcallHandle(String name, FunctionDescriptor fdesc) {\n-        return SYMBOL_LOOKUP.find(name).\n-                map(addr -> LINKER.downcallHandle(addr, fdesc)).\n-                orElse(null);\n-    }\n-\n-    static MethodHandle downcallHandle(FunctionDescriptor fdesc) {\n-        return LINKER.downcallHandle(fdesc);\n-    }\n-\n-    static MethodHandle downcallHandleVariadic(String name, FunctionDescriptor fdesc) {\n-        return SYMBOL_LOOKUP.find(name).\n-                map(addr -> VarargsInvoker.make(addr, fdesc)).\n-                orElse(null);\n-    }\n-\n-    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n-        try {\n-            return MH_LOOKUP.findVirtual(fi, name, fdesc.toMethodType());\n-        } catch (Throwable ex) {\n-            throw new AssertionError(ex);\n-        }\n-    }\n-\n-    static <Z> MemorySegment upcallStub(MethodHandle fiHandle, Z z, FunctionDescriptor fdesc, Arena scope) {\n-        try {\n-            fiHandle = fiHandle.bindTo(z);\n-            return LINKER.upcallStub(fiHandle, fdesc, scope);\n-        } catch (Throwable ex) {\n-            throw new AssertionError(ex);\n-        }\n-    }\n-\n-    static MemorySegment asArray(MemorySegment addr, MemoryLayout layout, int numElements, Arena arena) {\n-         return addr.reinterpret(numElements * layout.byteSize(), arena, null);\n-    }\n-\n-    \/\/ Internals only below this point\n-\n-    private static final class VarargsInvoker {\n-        private static final MethodHandle INVOKE_MH;\n-        private final MemorySegment symbol;\n-        private final FunctionDescriptor function;\n-\n-        private VarargsInvoker(MemorySegment symbol, FunctionDescriptor function) {\n-            this.symbol = symbol;\n-            this.function = function;\n-        }\n-\n-        static {\n-            try {\n-                INVOKE_MH = MethodHandles.lookup().findVirtual(VarargsInvoker.class, \"invoke\", MethodType.methodType(Object.class, SegmentAllocator.class, Object[].class));\n-            } catch (ReflectiveOperationException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        static MethodHandle make(MemorySegment symbol, FunctionDescriptor function) {\n-            VarargsInvoker invoker = new VarargsInvoker(symbol, function);\n-            MethodHandle handle = INVOKE_MH.bindTo(invoker).asCollector(Object[].class, function.argumentLayouts().size() + 1);\n-            MethodType mtype = MethodType.methodType(function.returnLayout().isPresent() ? carrier(function.returnLayout().get(), true) : void.class);\n-            for (MemoryLayout layout : function.argumentLayouts()) {\n-                mtype = mtype.appendParameterTypes(carrier(layout, false));\n-            }\n-            mtype = mtype.appendParameterTypes(Object[].class);\n-            boolean needsAllocator = function.returnLayout().isPresent() &&\n-                                function.returnLayout().get() instanceof GroupLayout;\n-            if (needsAllocator) {\n-                mtype = mtype.insertParameterTypes(0, SegmentAllocator.class);\n-            } else {\n-                handle = MethodHandles.insertArguments(handle, 0, THROWING_ALLOCATOR);\n-            }\n-            return handle.asType(mtype);\n-        }\n-\n-        static Class<?> carrier(MemoryLayout layout, boolean ret) {\n-            if (layout instanceof ValueLayout valueLayout) {\n-                return valueLayout.carrier();\n-            } else if (layout instanceof GroupLayout) {\n-                return MemorySegment.class;\n-            } else {\n-                throw new AssertionError(\"Cannot get here!\");\n-            }\n-        }\n-\n-        private Object invoke(SegmentAllocator allocator, Object[] args) throws Throwable {\n-            \/\/ one trailing Object[]\n-            int nNamedArgs = function.argumentLayouts().size();\n-            assert(args.length == nNamedArgs + 1);\n-            \/\/ The last argument is the array of vararg collector\n-            Object[] unnamedArgs = (Object[]) args[args.length - 1];\n-\n-            int argsCount = nNamedArgs + unnamedArgs.length;\n-            Class<?>[] argTypes = new Class<?>[argsCount];\n-            MemoryLayout[] argLayouts = new MemoryLayout[nNamedArgs + unnamedArgs.length];\n-\n-            int pos = 0;\n-            for (pos = 0; pos < nNamedArgs; pos++) {\n-                argLayouts[pos] = function.argumentLayouts().get(pos);\n-            }\n-\n-            assert pos == nNamedArgs;\n-            for (Object o: unnamedArgs) {\n-                argLayouts[pos] = variadicLayout(normalize(o.getClass()));\n-                pos++;\n-            }\n-            assert pos == argsCount;\n-\n-            FunctionDescriptor f = (function.returnLayout().isEmpty()) ?\n-                    FunctionDescriptor.ofVoid(argLayouts) :\n-                    FunctionDescriptor.of(function.returnLayout().get(), argLayouts);\n-            MethodHandle mh = LINKER.downcallHandle(symbol, f);\n-            boolean needsAllocator = function.returnLayout().isPresent() &&\n-                                            function.returnLayout().get() instanceof GroupLayout;\n-            if (needsAllocator) {\n-                mh = mh.bindTo(allocator);\n-            }\n-            \/\/ flatten argument list so that it can be passed to an asSpreader MH\n-            Object[] allArgs = new Object[nNamedArgs + unnamedArgs.length];\n-            System.arraycopy(args, 0, allArgs, 0, nNamedArgs);\n-            System.arraycopy(unnamedArgs, 0, allArgs, nNamedArgs, unnamedArgs.length);\n-\n-            return mh.asSpreader(Object[].class, argsCount).invoke(allArgs);\n-        }\n-\n-        private static Class<?> unboxIfNeeded(Class<?> clazz) {\n-            if (clazz == Boolean.class) {\n-                return boolean.class;\n-            } else if (clazz == Void.class) {\n-                return void.class;\n-            } else if (clazz == Byte.class) {\n-                return byte.class;\n-            } else if (clazz == Character.class) {\n-                return char.class;\n-            } else if (clazz == Short.class) {\n-                return short.class;\n-            } else if (clazz == Integer.class) {\n-                return int.class;\n-            } else if (clazz == Long.class) {\n-                return long.class;\n-            } else if (clazz == Float.class) {\n-                return float.class;\n-            } else if (clazz == Double.class) {\n-                return double.class;\n-            } else {\n-                return clazz;\n-            }\n-        }\n-\n-        private Class<?> promote(Class<?> c) {\n-            if (c == byte.class || c == char.class || c == short.class || c == int.class) {\n-                return long.class;\n-            } else if (c == float.class) {\n-                return double.class;\n-            } else {\n-                return c;\n-            }\n-        }\n-\n-        private Class<?> normalize(Class<?> c) {\n-            c = unboxIfNeeded(c);\n-            if (c.isPrimitive()) {\n-                return promote(c);\n-            }\n-            if (c == MemorySegment.class) {\n-                return MemorySegment.class;\n-            }\n-            throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n-        }\n-\n-        private MemoryLayout variadicLayout(Class<?> c) {\n-            if (c == long.class) {\n-                return JAVA_LONG;\n-            } else if (c == double.class) {\n-                return JAVA_DOUBLE;\n-            } else if (c == MemorySegment.class) {\n-                return ADDRESS;\n-            } else {\n-                throw new IllegalArgumentException(\"Unhandled variadic argument class: \" + c);\n-            }\n-        }\n-    }\n-}\n","filename":"samples\/libjimage\/org\/openjdk\/RuntimeHelper.java","additions":0,"deletions":255,"binary":false,"changes":255,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/\/ Generated by jextract\n-\n-package org.openjdk;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$0 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$0() {}\n-    static final FunctionDescriptor const$0 = FunctionDescriptor.of(RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER\n-    );\n-    static final MethodHandle const$1 = RuntimeHelper.downcallHandle(\n-        \"JIMAGE_Open\",\n-        constants$0.const$0\n-    );\n-    static final MethodHandle const$2 = RuntimeHelper.upcallHandle(JImageOpen_t.class, \"apply\", constants$0.const$0);\n-    static final MethodHandle const$3 = RuntimeHelper.downcallHandle(\n-        constants$0.const$0\n-    );\n-    static final FunctionDescriptor const$4 = FunctionDescriptor.ofVoid(\n-        RuntimeHelper.POINTER\n-    );\n-    static final MethodHandle const$5 = RuntimeHelper.downcallHandle(\n-        \"JIMAGE_Close\",\n-        constants$0.const$4\n-    );\n-}\n-\n-\n","filename":"samples\/libjimage\/org\/openjdk\/constants$0.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/\/ Generated by jextract\n-\n-package org.openjdk;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$1 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$1() {}\n-    static final MethodHandle const$0 = RuntimeHelper.upcallHandle(JImageClose_t.class, \"apply\", constants$0.const$4);\n-    static final MethodHandle const$1 = RuntimeHelper.downcallHandle(\n-        constants$0.const$4\n-    );\n-    static final MethodHandle const$2 = RuntimeHelper.downcallHandle(\n-        \"JIMAGE_PackageToModule\",\n-        constants$0.const$0\n-    );\n-    static final MethodHandle const$3 = RuntimeHelper.upcallHandle(JImagePackageToModule_t.class, \"apply\", constants$0.const$0);\n-    static final FunctionDescriptor const$4 = FunctionDescriptor.of(JAVA_LONG,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER\n-    );\n-    static final MethodHandle const$5 = RuntimeHelper.downcallHandle(\n-        \"JIMAGE_FindResource\",\n-        constants$1.const$4\n-    );\n-}\n-\n-\n","filename":"samples\/libjimage\/org\/openjdk\/constants$1.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/\/ Generated by jextract\n-\n-package org.openjdk;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$2 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$2() {}\n-    static final MethodHandle const$0 = RuntimeHelper.upcallHandle(JImageFindResource_t.class, \"apply\", constants$1.const$4);\n-    static final MethodHandle const$1 = RuntimeHelper.downcallHandle(\n-        constants$1.const$4\n-    );\n-    static final FunctionDescriptor const$2 = FunctionDescriptor.of(JAVA_LONG,\n-        RuntimeHelper.POINTER,\n-        JAVA_LONG,\n-        RuntimeHelper.POINTER,\n-        JAVA_LONG\n-    );\n-    static final MethodHandle const$3 = RuntimeHelper.downcallHandle(\n-        \"JIMAGE_GetResource\",\n-        constants$2.const$2\n-    );\n-    static final MethodHandle const$4 = RuntimeHelper.upcallHandle(JImageGetResource_t.class, \"apply\", constants$2.const$2);\n-    static final MethodHandle const$5 = RuntimeHelper.downcallHandle(\n-        constants$2.const$2\n-    );\n-}\n-\n-\n","filename":"samples\/libjimage\/org\/openjdk\/constants$2.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/\/ Generated by jextract\n-\n-package org.openjdk;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$3 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$3() {}\n-    static final FunctionDescriptor const$0 = FunctionDescriptor.of(JAVA_INT,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER\n-    );\n-    static final MethodHandle const$1 = RuntimeHelper.upcallHandle(JImageResourceVisitor_t.class, \"apply\", constants$3.const$0);\n-    static final MethodHandle const$2 = RuntimeHelper.downcallHandle(\n-        constants$3.const$0\n-    );\n-    static final FunctionDescriptor const$3 = FunctionDescriptor.ofVoid(\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER\n-    );\n-    static final MethodHandle const$4 = RuntimeHelper.downcallHandle(\n-        \"JIMAGE_ResourceIterator\",\n-        constants$3.const$3\n-    );\n-    static final MethodHandle const$5 = RuntimeHelper.upcallHandle(JImageResourceIterator_t.class, \"apply\", constants$3.const$3);\n-}\n-\n-\n","filename":"samples\/libjimage\/org\/openjdk\/constants$3.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,19 +0,0 @@\n-\/\/ Generated by jextract\n-\n-package org.openjdk;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$4 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$4() {}\n-    static final MethodHandle const$0 = RuntimeHelper.downcallHandle(\n-        constants$3.const$3\n-    );\n-}\n-\n-\n","filename":"samples\/libjimage\/org\/openjdk\/constants$4.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"deleted"},{"patch":"@@ -5,3 +5,1 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n+import java.lang.invoke.*;\n@@ -9,0 +7,5 @@\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n@@ -10,10 +13,93 @@\n-public class jimage_h  {\n-\n-    public static final OfByte C_CHAR = JAVA_BYTE;\n-    public static final OfShort C_SHORT = JAVA_SHORT;\n-    public static final OfInt C_INT = JAVA_INT;\n-    public static final OfLong C_LONG = JAVA_LONG;\n-    public static final OfLong C_LONG_LONG = JAVA_LONG;\n-    public static final OfFloat C_FLOAT = JAVA_FLOAT;\n-    public static final OfDouble C_DOUBLE = JAVA_DOUBLE;\n-    public static final AddressLayout C_POINTER = RuntimeHelper.POINTER;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+public class jimage_h {\n+\n+    static final SymbolLookup SYMBOL_LOOKUP;\n+    \/\/ manual change\n+    static {\n+        var libPath = System.getProperty(\"java.home\");\n+        var OS = System.getProperty(\"os.name\");\n+        if (OS.contains(\"Mac OS X\")) {\n+            libPath += \"\/lib\/libjimage.dylib\";\n+        } else if (OS.contains(\"Windows\")) {\n+            libPath = \"\/bin\/jimage.dll\";\n+        } else {\n+            libPath = \"\/lib\/libjimage.so\"; \/\/ some Unix\n+        }\n+        SymbolLookup loaderLookup = SymbolLookup.libraryLookup(libPath, Arena.global());\n+        SYMBOL_LOOKUP = name -> loaderLookup.find(name).or(() -> Linker.nativeLinker().defaultLookup().find(name));\n+    }\n+\n+    jimage_h() {\n+        \/\/ Suppresses public default constructor, ensuring non-instantiability,\n+        \/\/ but allows generated subclasses in same package.\n+    }\n+\n+    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n+    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n+    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n+    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n+    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS\n+            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));\n+    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;\n+\n+    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean(\"jextract.trace.downcalls\");\n+\n+    static void traceDowncall(String name, Object... args) {\n+         String traceArgs = Arrays.stream(args)\n+                       .map(Object::toString)\n+                       .collect(Collectors.joining(\", \"));\n+         System.out.printf(\"%s(%s)\\n\", name, traceArgs);\n+    }\n+\n+    static MemorySegment findOrThrow(String symbol) {\n+        return SYMBOL_LOOKUP.find(symbol)\n+            .orElseThrow(() -> new UnsatisfiedLinkError(\"unresolved symbol: \" + symbol));\n+    }\n+\n+    static MemoryLayout[] inferVariadicLayouts(Object[] varargs) {\n+        MemoryLayout[] result = new MemoryLayout[varargs.length];\n+        for (int i = 0; i < varargs.length; i++) {\n+            result[i] = variadicLayout(varargs[i].getClass());\n+        }\n+        return result;\n+    }\n+\n+    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n+        try {\n+            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static MethodHandle downcallHandleVariadic(String name, FunctionDescriptor baseDesc, MemoryLayout[] variadicLayouts) {\n+        FunctionDescriptor variadicDesc = baseDesc.appendArgumentLayouts(variadicLayouts);\n+        Linker.Option fva = Linker.Option.firstVariadicArg(baseDesc.argumentLayouts().size());\n+        return SYMBOL_LOOKUP.find(name)\n+                .map(addr -> Linker.nativeLinker().downcallHandle(addr, variadicDesc, fva)\n+                        .asSpreader(Object[].class, variadicLayouts.length))\n+                .orElse(null);\n+    }\n+\n+    \/\/ Internals only below this point\n+\n+    private static MemoryLayout variadicLayout(Class<?> c) {\n+        \/\/ apply default argument promotions per C spec\n+        \/\/ note that all primitives are boxed, since they are passed through an Object[]\n+        if (c == Boolean.class || c == Byte.class || c == Character.class || c == Short.class || c == Integer.class) {\n+            return JAVA_INT;\n+        } else if (c == Long.class) {\n+            return JAVA_LONG;\n+        } else if (c == Float.class || c == Double.class) {\n+            return JAVA_DOUBLE;\n+        } else if (MemorySegment.class.isAssignableFrom(c)) {\n+            return ADDRESS;\n+        }\n+        throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n+    }\n+    private static final int JIMAGE_MAX_PATH = (int)4096L;\n+\n@@ -21,1 +107,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -26,1 +112,1 @@\n-        return (int)4096L;\n+        return JIMAGE_MAX_PATH;\n@@ -29,2 +115,2 @@\n-     * {@snippet :\n-     * typedef long long jlong;\n+     * {@snippet lang=c :\n+     * typedef long long jlong\n@@ -33,1 +119,1 @@\n-    public static final OfLong jlong = JAVA_LONG;\n+    public static final OfLong jlong = jimage_h.C_LONG_LONG;\n@@ -35,2 +121,2 @@\n-     * {@snippet :\n-     * typedef int jint;\n+     * {@snippet lang=c :\n+     * typedef int jint\n@@ -39,1 +125,1 @@\n-    public static final OfInt jint = JAVA_INT;\n+    public static final OfInt jint = jimage_h.C_INT;\n@@ -41,2 +127,2 @@\n-     * {@snippet :\n-     * typedef long long JImageLocationRef;\n+     * {@snippet lang=c :\n+     * typedef jlong JImageLocationRef\n@@ -45,1 +131,2 @@\n-    public static final OfLong JImageLocationRef = JAVA_LONG;\n+    public static final OfLong JImageLocationRef = jimage_h.C_LONG_LONG;\n+\n@@ -47,1 +134,12 @@\n-        return RuntimeHelper.requireNonNull(constants$0.const$1,\"JIMAGE_Open\");\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                jimage_h.C_POINTER,\n+                jimage_h.C_POINTER,\n+                jimage_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    jimage_h.findOrThrow(\"JIMAGE_Open\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n@@ -49,0 +147,1 @@\n+\n@@ -50,2 +149,2 @@\n-     * {@snippet :\n-     * JImageFile* JIMAGE_Open(char* name, jint* error);\n+     * {@snippet lang=c :\n+     * JImageFile *JIMAGE_Open(const char *name, jint *error)\n@@ -57,1 +156,4 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(name, error);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"JIMAGE_Open\", name, error);\n+            }\n+            return (MemorySegment) mh$.invokeExact(name, error);\n@@ -59,1 +161,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -62,0 +164,1 @@\n+\n@@ -63,1 +166,10 @@\n-        return RuntimeHelper.requireNonNull(constants$0.const$5,\"JIMAGE_Close\");\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+                jimage_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    jimage_h.findOrThrow(\"JIMAGE_Close\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n@@ -65,0 +177,1 @@\n+\n@@ -66,2 +179,2 @@\n-     * {@snippet :\n-     * void JIMAGE_Close(JImageFile* jimage);\n+     * {@snippet lang=c :\n+     * void JIMAGE_Close(JImageFile *jimage)\n@@ -73,0 +186,3 @@\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"JIMAGE_Close\", jimage);\n+            }\n@@ -75,1 +191,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -78,0 +194,1 @@\n+\n@@ -79,1 +196,12 @@\n-        return RuntimeHelper.requireNonNull(constants$1.const$2,\"JIMAGE_PackageToModule\");\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                jimage_h.C_POINTER,\n+                jimage_h.C_POINTER,\n+                jimage_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    jimage_h.findOrThrow(\"JIMAGE_PackageToModule\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n@@ -81,0 +209,1 @@\n+\n@@ -82,2 +211,2 @@\n-     * {@snippet :\n-     * char* JIMAGE_PackageToModule(JImageFile* jimage, char* package_name);\n+     * {@snippet lang=c :\n+     * const char *JIMAGE_PackageToModule(JImageFile *jimage, const char *package_name)\n@@ -89,1 +218,4 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(jimage, package_name);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"JIMAGE_PackageToModule\", jimage, package_name);\n+            }\n+            return (MemorySegment) mh$.invokeExact(jimage, package_name);\n@@ -91,1 +223,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -94,0 +226,1 @@\n+\n@@ -95,1 +228,15 @@\n-        return RuntimeHelper.requireNonNull(constants$1.const$5,\"JIMAGE_FindResource\");\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                jimage_h.C_LONG_LONG,\n+                jimage_h.C_POINTER,\n+                jimage_h.C_POINTER,\n+                jimage_h.C_POINTER,\n+                jimage_h.C_POINTER,\n+                jimage_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    jimage_h.findOrThrow(\"JIMAGE_FindResource\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n@@ -97,0 +244,1 @@\n+\n@@ -98,2 +246,2 @@\n-     * {@snippet :\n-     * JImageLocationRef JIMAGE_FindResource(JImageFile* jimage, char* module_name, char* version, char* name, jlong* size);\n+     * {@snippet lang=c :\n+     * JImageLocationRef JIMAGE_FindResource(JImageFile *jimage, const char *module_name, const char *version, const char *name, jlong *size)\n@@ -105,1 +253,4 @@\n-            return (long)mh$.invokeExact(jimage, module_name, version, name, size);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"JIMAGE_FindResource\", jimage, module_name, version, name, size);\n+            }\n+            return (long) mh$.invokeExact(jimage, module_name, version, name, size);\n@@ -107,1 +258,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -110,0 +261,1 @@\n+\n@@ -111,1 +263,14 @@\n-        return RuntimeHelper.requireNonNull(constants$2.const$3,\"JIMAGE_GetResource\");\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                jimage_h.C_LONG_LONG,\n+                jimage_h.C_POINTER,\n+                jimage_h.C_LONG_LONG,\n+                jimage_h.C_POINTER,\n+                jimage_h.C_LONG_LONG\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    jimage_h.findOrThrow(\"JIMAGE_GetResource\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n@@ -113,0 +278,1 @@\n+\n@@ -114,2 +280,2 @@\n-     * {@snippet :\n-     * jlong JIMAGE_GetResource(JImageFile* jimage, JImageLocationRef location, char* buffer, jlong size);\n+     * {@snippet lang=c :\n+     * jlong JIMAGE_GetResource(JImageFile *jimage, JImageLocationRef location, char *buffer, jlong size)\n@@ -121,1 +287,4 @@\n-            return (long)mh$.invokeExact(jimage, location, buffer, size);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"JIMAGE_GetResource\", jimage, location, buffer, size);\n+            }\n+            return (long) mh$.invokeExact(jimage, location, buffer, size);\n@@ -123,1 +292,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -126,0 +295,1 @@\n+\n@@ -127,1 +297,12 @@\n-        return RuntimeHelper.requireNonNull(constants$3.const$4,\"JIMAGE_ResourceIterator\");\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+                jimage_h.C_POINTER,\n+                jimage_h.C_POINTER,\n+                jimage_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    jimage_h.findOrThrow(\"JIMAGE_ResourceIterator\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n@@ -129,0 +310,1 @@\n+\n@@ -130,2 +312,2 @@\n-     * {@snippet :\n-     * void JIMAGE_ResourceIterator(JImageFile* jimage, JImageResourceVisitor_t visitor, void* arg);\n+     * {@snippet lang=c :\n+     * void JIMAGE_ResourceIterator(JImageFile *jimage, JImageResourceVisitor_t visitor, void *arg)\n@@ -137,0 +319,3 @@\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"JIMAGE_ResourceIterator\", jimage, visitor, arg);\n+            }\n@@ -139,1 +324,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -142,0 +327,2 @@\n+    private static final int JIMAGE_NOT_FOUND = (int)0L;\n+\n@@ -143,1 +330,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -148,1 +335,1 @@\n-        return (int)0L;\n+        return JIMAGE_NOT_FOUND;\n@@ -150,0 +337,2 @@\n+    private static final int JIMAGE_BAD_MAGIC = (int)-1L;\n+\n@@ -151,1 +340,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -156,1 +345,1 @@\n-        return (int)-1L;\n+        return JIMAGE_BAD_MAGIC;\n@@ -158,0 +347,2 @@\n+    private static final int JIMAGE_BAD_VERSION = (int)-2L;\n+\n@@ -159,1 +350,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -164,1 +355,1 @@\n-        return (int)-2L;\n+        return JIMAGE_BAD_VERSION;\n@@ -166,0 +357,2 @@\n+    private static final int JIMAGE_CORRUPTED = (int)-3L;\n+\n@@ -167,1 +360,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -172,1 +365,1 @@\n-        return (int)-3L;\n+        return JIMAGE_CORRUPTED;\n@@ -176,1 +369,0 @@\n-\n","filename":"samples\/libjimage\/org\/openjdk\/jimage_h.java","additions":253,"deletions":61,"binary":false,"changes":314,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n-   --enable-preview --source=22 \\\n","filename":"samples\/libjimage\/run.sh","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-jextract -t org.unix \\\n-  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/libproc.h\n","filename":"samples\/libproc\/compile.sh","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,1 +1,1 @@\n-jextract --source -t org.unix \\\n+jextract --output src -t org.unix \\\n@@ -4,1 +4,1 @@\n-javac --enable-preview --source=22 org\/unix\/*.java\n+javac --source=22 -d . src\/org\/unix\/*.java\n","filename":"samples\/libproc\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,0 @@\n-   --enable-preview --source=22 \\\n","filename":"samples\/libproc\/run.sh","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,6 +0,0 @@\n-jextract -t libzstd \\\n-  -I \/usr\/local\/Cellar\/zstd\/1.5.5\/include \\\n-  -l zstd \\\n-  --header-class-name Libzstd \\\n-    \/usr\/local\/Cellar\/zstd\/1.5.5\/include\/zstd.h\n-\n","filename":"samples\/libzstd\/compile.sh","additions":0,"deletions":6,"binary":false,"changes":6,"status":"deleted"},{"patch":"@@ -1,1 +1,1 @@\n-jextract --source -t libzstd \\\n+jextract --output src -t libzstd \\\n@@ -7,1 +7,1 @@\n-javac --enable-preview --source=22 libzstd\/*.java\n+javac --source=22 -d . src\/libzstd\/*.java\n","filename":"samples\/libzstd\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,0 @@\n-   --enable-preview --source=22 \\\n","filename":"samples\/libzstd\/run.sh","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,7 +0,0 @@\n-# on Mac, lp_solve can be installed using\n-# brew install lp_solve\n- \n-jextract \\\n-  -t net.sourceforge.lpsolve \\\n-  -l lpsolve55 \\\n-  \/usr\/local\/Cellar\/lp_solve\/5.5.2.11\/include\/lp_lib.h\n","filename":"samples\/lp_solve\/compile.sh","additions":0,"deletions":7,"binary":false,"changes":7,"status":"deleted"},{"patch":"@@ -5,1 +5,1 @@\n-  --source \\\n+  --output src \\\n@@ -10,1 +10,1 @@\n-javac --enable-preview --source=22 net\/sourceforge\/lpsolve\/*.java\n+javac --source=22 -d . src\/net\/sourceforge\/lpsolve\/*.java\n","filename":"samples\/lp_solve\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,0 @@\n-   --source=22 --enable-preview \\\n","filename":"samples\/lp_solve\/run.sh","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -7,0 +7,1 @@\n+  --output src `\r\n@@ -13,0 +14,5 @@\n+\r\n+# Too many sources for command line. Put them into separate file\r\n+ls -r src\/*.java | %{ $_.FullName } | Out-File sources.txt\r\n+javac -d classes '@sources.txt'\r\n+\r\n","filename":"samples\/opengl\/compile_windows.ps1","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7,0 +7,1 @@\n+  -cp classes `\r\n@@ -8,1 +9,0 @@\n-  --enable-preview --source=22 `\r\n","filename":"samples\/opengl\/run_windows.ps1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,6 +0,0 @@\n-jextract -t org.pcre \\\n-  -I \/usr\/local\/opt\/pcre2\/include \\\n-  -DPCRE2_CODE_UNIT_WIDTH=8 \\\n-  --header-class-name Pcre \\\n-  --library pcre2-8 \\\n-  \/usr\/local\/opt\/pcre2\/include\/pcre2.h\n","filename":"samples\/pcre2\/compile.sh","additions":0,"deletions":6,"binary":false,"changes":6,"status":"deleted"},{"patch":"@@ -1,1 +1,1 @@\n-jextract -t org.pcre \\\n+jextract --output src -t org.pcre \\\n@@ -6,1 +6,0 @@\n-  --source \\\n@@ -9,1 +8,1 @@\n-javac --enable-preview --source=22 org\/pcre\/*.java\n+javac --source=22 -d . src\/org\/pcre\/*.java\n","filename":"samples\/pcre2\/compilesource.sh","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,0 @@\n-    --enable-preview --source=22 \\\n","filename":"samples\/pcre2\/run.sh","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,6 +0,0 @@\n-ANACONDA3_HOME=\/opt\/anaconda3\n-\n-jextract -l python3.8 \\\n-  -I ${ANACONDA3_HOME}\/include\/python3.8 \\\n-  -t org.python \\\n-  ${ANACONDA3_HOME}\/include\/python3.8\/Python.h\n","filename":"samples\/python3\/compile.sh","additions":0,"deletions":6,"binary":false,"changes":6,"status":"deleted"},{"patch":"@@ -9,0 +9,1 @@\n+  --output src `\r\n@@ -12,1 +13,3 @@\n-  \"$pythonPath\\include\\Python.h\"\n\\ No newline at end of file\n+  \"$pythonPath\\include\\Python.h\"\r\n+\r\n+javac -d classes (ls -r src\/*.java)\r\n","filename":"samples\/python3\/compile_windows.ps1","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,1 +1,3 @@\n-ANACONDA3_HOME=\/opt\/anaconda3\n+if [[ -z \"${ANACONDA3_HOME}\" ]]; then\n+    ANACONDA3_HOME=\/opt\/anaconda3\n+fi\n@@ -3,2 +5,2 @@\n-jextract --source -l python3.8 \\\n-  -I ${ANACONDA3_HOME}\/include\/python3.8 \\\n+jextract --output src -l python3.11 \\\n+  -I ${ANACONDA3_HOME}\/include\/python3.11 \\\n@@ -6,1 +8,1 @@\n-  ${ANACONDA3_HOME}\/include\/python3.8\/Python.h\n+  ${ANACONDA3_HOME}\/include\/python3.11\/Python.h\n@@ -8,1 +10,1 @@\n-javac --enable-preview --source=22 org\/python\/*.java\n+javac --source=22 -d . src\/org\/python\/*.java\n","filename":"samples\/python3\/compilesource.sh","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,1 +1,3 @@\n-ANACONDA3_HOME=\/opt\/anaconda3\n+if [[ -z \"${ANACONDA3_HOME}\" ]]; then\n+    ANACONDA3_HOME=\/opt\/anaconda3\n+fi\n@@ -4,1 +6,0 @@\n-    --enable-preview --source=22 \\\n","filename":"samples\/python3\/run.sh","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -7,0 +7,1 @@\n+  -cp classes `\r\n@@ -8,1 +9,0 @@\n-  --enable-preview --source=22 `\r\n","filename":"samples\/python3\/run_windows.ps1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,5 +0,0 @@\n-jextract -l readline -t org.unix \\\n-  --header-class-name readline_h \\\n-  --include-function readline \\\n-  --include-function free \\\n-  myreadline.h\n","filename":"samples\/readline\/compile.sh","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -1,1 +1,1 @@\n-jextract --source -l readline -t org.unix \\\n+jextract --output src -l readline -t org.unix \\\n@@ -7,1 +7,1 @@\n-javac --enable-preview --source=22 org\/unix\/*.java\n+javac --source=22 -d . src\/org\/unix\/*.java\n","filename":"samples\/readline\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n-    --enable-preview --source=22 \\\n","filename":"samples\/readline\/run.sh","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,3 +0,0 @@\n-jextract \\\n-  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/sqlite3.h \\\n-  -t org.sqlite -lsqlite3 \n","filename":"samples\/sqlite\/compile.sh","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,1 +1,1 @@\n-jextract --source \\\n+jextract --output src \\\n@@ -5,1 +5,1 @@\n-javac --enable-preview --source=22 org\/sqlite\/*.java\n+javac --source=22 -d . src\/org\/sqlite\/*.java\n","filename":"samples\/sqlite\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-jextract -l tcl -t org.tcl \\\n-   \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/tcl.h\n","filename":"samples\/tcl\/compile.sh","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,1 +1,1 @@\n-jextract --source -l tcl -t org.tcl \\\n+jextract --output src -l tcl -t org.tcl \\\n@@ -4,1 +4,1 @@\n-javac --enable-preview --source=22 org\/tcl\/*.java\n+javac --source=22 -d . src\/org\/tcl\/*.java\n","filename":"samples\/tcl\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,5 +0,0 @@\n-jextract \\\n-  -t org.tensorflow \\\n-  -I ${LIBTENSORFLOW_HOME}\/include \\\n-  -l ${LIBTENSORFLOW_HOME}\/lib\/libtensorflow.dylib \\\n-  ${LIBTENSORFLOW_HOME}\/include\/tensorflow\/c\/c_api.h\n","filename":"samples\/tensorflow\/compile.sh","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -7,0 +7,1 @@\n+  --output src `\r\n@@ -11,0 +12,2 @@\n+\r\n+javac -d classes (ls -r src\/*.java)\r\n","filename":"samples\/tensorflow\/compile_windows.ps1","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-jextract --source \\\n+jextract --output src \\\n@@ -7,1 +7,1 @@\n-javac --enable-preview --source=22 org\/tensorflow\/*.java\n+javac --source=22 -d . src\/org\/tensorflow\/*.java\n","filename":"samples\/tensorflow\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,0 @@\n-   --enable-preview --source=22 \\\n","filename":"samples\/tensorflow\/loadsavedmodel.sh","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -7,0 +7,1 @@\n+  -cp classes `\r\n@@ -8,1 +9,0 @@\n-  --enable-preview --source=22 `\r\n","filename":"samples\/tensorflow\/run_windows.ps1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-            System.err.printf(\"Time = %d:%02d\\n\", tm.tm_hour$get(time), tm.tm_min$get(time));\n+            System.err.printf(\"Time = %d:%02d\\n\", tm.tm_hour(time), tm.tm_min(time));\n","filename":"samples\/time\/PanamaTime.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-jextract -t org.unix \\\n-   \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/time.h\n","filename":"samples\/time\/compile.sh","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,1 +1,1 @@\n-jextract --source -t org.unix \\\n+jextract --output src -t org.unix \\\n@@ -4,1 +4,1 @@\n-javac --enable-preview --source=22 org\/unix\/*.java\n+javac --source=22 -d . src\/org\/unix\/*.java\n","filename":"samples\/time\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n-    --enable-preview --source=22 \\\n","filename":"samples\/time\/run.sh","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.constant.Constable;\n+import java.util.Collection;\n@@ -31,0 +31,1 @@\n+import java.util.Map;\n@@ -32,2 +33,1 @@\n-import java.util.Set;\n-import java.lang.foreign.MemoryLayout;\n+\n@@ -56,30 +56,0 @@\n-    \/**\n-     * Get a declaration with specified attribute.\n-     * Set the values to the specified attribute while other attributes remains unchanged. If the specified attribute\n-     * already exist, the new values are replacing the old ones. By not specifying any value, the attribute will become\n-     * empty as {@link #getAttribute(String) getAttribute(name).isEmpty()} will return true.\n-     * @param name The attribute name\n-     * @param values More attribute values\n-     * @return the Declaration with attributes\n-     *\/\n-    Declaration withAttribute(String name, Constable... values);\n-\n-    \/**\n-     * Get a declaration without current attributes\n-     * @return the Declatation without any attributes\n-     *\/\n-    Declaration stripAttributes();\n-\n-    \/**\n-     * The values of the specified attribute.\n-     * @param name The attribute to retrieve\n-     * @return The list of values associate with this attribute\n-     *\/\n-    Optional<List<Constable>> getAttribute(String name);\n-\n-    \/**\n-     * The attributes associated with this declaration\n-     * @return The attributes associated with this declaration\n-     *\/\n-    Set<String> attributeNames();\n-\n@@ -113,0 +83,20 @@\n+    \/**\n+     * {@return the attributes associated with this declaration}\n+     *\/\n+    Collection<Record> attributes();\n+\n+    \/**\n+     * Obtains an attribute from this declaration.\n+     * @param attributeClass the class of the attribute to be obtained.\n+     * @param <R> the attribute's type.\n+     * @return the attribute (if any).\n+     *\/\n+    <R extends Record> Optional<R> getAttribute(Class<R> attributeClass);\n+\n+    \/**\n+     * Adds a new attribute to this declaration.\n+     * @param attribute the attribute to be added.\n+     * @param <R> the attribute's type.\n+     *\/\n+    <R extends Record> void addAttribute(R attribute);\n+\n@@ -141,8 +131,0 @@\n-            \/**\n-             * Namespace declaration.\n-             *\/\n-            NAMESPACE,\n-            \/**\n-             * Class declaration.\n-             *\/\n-            CLASS,\n@@ -177,10 +159,0 @@\n-        \/**\n-         * The (optional) layout associated with this scoped declaration.\n-         * @return The (optional) layout associated with this scoped declaration.\n-         *\n-         * @implSpec a layout is present if the scoped declaration kind is one of {@link Kind#STRUCT}, {@link Kind#UNION},\n-         * {@link Kind#ENUM}, {@link Kind#BITFIELDS}, {@link Kind#CLASS} <em>and<\/em> if this declaration models an entity in the foreign\n-         * language that is associated with a <em>definition<\/em>.\n-         *\/\n-        Optional<MemoryLayout> layout();\n-\n@@ -249,4 +221,0 @@\n-        \/**\n-         * {@return The bitfield offset (relative to the enclosing container)}\n-         *\/\n-        long offset();\n@@ -371,2 +339,0 @@\n-     * @param offset the offset of the bitfield (relative to the enclosing container).\n-     * @param width the bitfield width.\n@@ -375,2 +341,2 @@\n-    static Declaration.Variable bitfield(Position pos, String name, Type type, long offset, long width) {\n-        return new DeclarationImpl.BitfieldImpl(type, offset, width, name, pos);\n+    static Declaration.Variable bitfield(Position pos, String name, long width, Type type) {\n+        return new DeclarationImpl.BitfieldImpl(type, width, name, pos);\n@@ -413,12 +379,0 @@\n-    \/**\n-     * Creates a new namespace declaration with given name and member declarations.\n-     * @param pos the namespace declaration position.\n-     * @param name the namespace declaration name.\n-     * @param decls the namespace declaration member declarations.\n-     * @return a new namespace declaration with given name and member declarations.\n-     *\/\n-    static Declaration.Scoped namespace(Position pos, String name, Declaration... decls) {\n-        List<Declaration> declList = List.of(decls);\n-        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.NAMESPACE, declList, name, pos);\n-    }\n-\n@@ -448,13 +402,0 @@\n-    \/**\n-     * Creates a new struct declaration with given name, layout and member declarations.\n-     * @param pos the struct declaration position.\n-     * @param name the struct declaration name.\n-     * @param layout the struct declaration layout.\n-     * @param decls the struct declaration member declarations.\n-     * @return a new struct declaration with given name, layout and member declarations.\n-     *\/\n-    static Declaration.Scoped struct(Position pos, String name, MemoryLayout layout, Declaration... decls) {\n-        List<Declaration> declList = List.of(decls);\n-        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.STRUCT, layout, declList, name, pos);\n-    }\n-\n@@ -473,38 +414,0 @@\n-    \/**\n-     * Creates a new union declaration with given name, layout and member declarations.\n-     * @param pos the union declaration position.\n-     * @param name the union declaration name.\n-     * @param layout the union declaration layout.\n-     * @param decls the union declaration member declarations.\n-     * @return a new union declaration with given name, layout and member declarations.\n-     *\/\n-    static Declaration.Scoped union(Position pos, String name, MemoryLayout layout, Declaration... decls) {\n-        List<Declaration> declList = List.of(decls);\n-        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.UNION, layout, declList, name, pos);\n-    }\n-\n-    \/**\n-     * Creates a new class declaration with given name and member declarations.\n-     * @param pos the class declaration position.\n-     * @param name the class declaration name.\n-     * @param decls the class declaration member declarations.\n-     * @return a new class declaration with given name and member declarations.\n-     *\/\n-    static Declaration.Scoped class_(Position pos, String name, Declaration... decls) {\n-        List<Declaration> declList = List.of(decls);\n-        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.CLASS, declList, name, pos);\n-    }\n-\n-    \/**\n-     * Creates a new class declaration with given name, layout and member declarations.\n-     * @param pos the class declaration position.\n-     * @param name the class declaration name.\n-     * @param layout the class declaration layout.\n-     * @param decls the class declaration member declarations.\n-     * @return a new class declaration with given name, layout and member declarations.\n-     *\/\n-    static Declaration.Scoped class_(Position pos, String name, MemoryLayout layout, Declaration... decls) {\n-        List<Declaration> declList = List.of(decls);\n-        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.CLASS, layout, declList, name, pos);\n-    }\n-\n@@ -523,13 +426,0 @@\n-    \/**\n-     * Creates a new enum declaration with given name, layout and member declarations.\n-     * @param pos the enum declaration position.\n-     * @param name the enum declaration name.\n-     * @param layout the enum declaration layout.\n-     * @param decls the enum declaration member declarations.\n-     * @return a new enum declaration with given name, layout and member declarations.\n-     *\/\n-    static Declaration.Scoped enum_(Position pos, String name, MemoryLayout layout, Declaration... decls) {\n-        List<Declaration> declList = List.of(decls);\n-        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.ENUM, layout, declList, name, pos);\n-    }\n-\n@@ -549,14 +439,0 @@\n-    \/**\n-     * Creates a new scoped declaration with given kind, name, layout and member declarations.\n-     * @param kind the kind of the scoped declaration.\n-     * @param pos the scoped declaration position.\n-     * @param name the scoped declaration name.\n-     * @param layout the scoped declaration layout.\n-     * @param decls the scoped declaration member declarations.\n-     * @return a new scoped declaration with given kind, name, layout and member declarations.\n-     *\/\n-    static Declaration.Scoped scoped(Scoped.Kind kind, Position pos, String name, MemoryLayout layout, Declaration... decls) {\n-        List<Declaration> declList = List.of(decls);\n-        return new DeclarationImpl.ScopedImpl(kind, layout, declList, name, pos);\n-    }\n-\n@@ -584,1 +460,1 @@\n-        return new DeclarationImpl.TypedefImpl(type, name, pos, null);\n+        return new DeclarationImpl.TypedefImpl(type, name, pos);\n@@ -586,0 +462,6 @@\n+\n+    \/**\n+     * A record used to capture clang attributes attached to a declaration.\n+     * @param attributes a map from attribute name to attribute values.\n+     *\/\n+    record ClangAttributes(Map<String, List<String>> attributes) { }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Declaration.java","additions":32,"deletions":150,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract;\n+\n+\/**\n+ * A class representing a Java source file.\n+ *\n+ * @param className the name of the top-level public class in this source file.\n+ * @param packageName the name of the package the top-level class in this source file resides in.\n+ * @param contents the contents of the source file.\n+ *\/\n+public record JavaSourceFile(String className, String packageName, String contents) {\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/JavaSourceFile.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import org.openjdk.jextract.impl.DuplicateFilter;\n+import org.openjdk.jextract.impl.IncludeFilter;\n@@ -32,1 +34,3 @@\n-import org.openjdk.jextract.impl.CodeGenerator;\n+import org.openjdk.jextract.impl.NameMangler;\n+import org.openjdk.jextract.impl.Options.Library;\n+import org.openjdk.jextract.impl.OutputFactory;\n@@ -35,1 +39,1 @@\n-import org.openjdk.jextract.impl.Writer;\n+import org.openjdk.jextract.impl.UnsupportedFilter;\n@@ -37,2 +41,0 @@\n-import javax.tools.JavaFileObject;\n-import java.io.File;\n@@ -42,0 +44,1 @@\n+import java.nio.file.FileAlreadyExistsException;\n@@ -119,3 +122,4 @@\n-    public static List<JavaFileObject> generate(Declaration.Scoped decl, String headerName,\n-                                                String targetPkg, List<String> libNames) {\n-        return List.of(CodeGenerator.generate(decl, headerName, targetPkg, new IncludeHelper(), libNames));\n+    public static List<JavaSourceFile> generate(Declaration.Scoped decl, String headerName,\n+                                                String targetPkg, List<Options.Library> libs,\n+                                                boolean useSystemLoadLibrary, PrintWriter errStream) {\n+        return List.of(generate(decl, headerName, targetPkg, new IncludeHelper(), libs, useSystemLoadLibrary, errStream));\n@@ -124,3 +128,18 @@\n-    private static List<JavaFileObject> generateInternal(Declaration.Scoped decl, String headerName,\n-                                                String targetPkg, IncludeHelper includeHelper, List<String> libNames) {\n-        return List.of(CodeGenerator.generate(decl, headerName, targetPkg, includeHelper, libNames));\n+    private static List<JavaSourceFile> generateInternal(Declaration.Scoped decl, String headerName,\n+                                                         String targetPkg, IncludeHelper includeHelper,\n+                                                         List<Options.Library> libs, boolean useSystemLoadLibrary,\n+                                                         PrintWriter errStream) {\n+        return List.of(generate(decl, headerName, targetPkg, includeHelper, libs, useSystemLoadLibrary, errStream));\n+    }\n+\n+    private static JavaSourceFile[] generate(Declaration.Scoped decl, String headerName,\n+                                             String targetPkg, IncludeHelper includeHelper,\n+                                             List<Options.Library> libs, boolean useSystemLoadLibrary,\n+                                             PrintWriter errStream) {\n+        var transformedDecl = Stream.of(decl)\n+                .map(new IncludeFilter(includeHelper)::scan)\n+                .map(new DuplicateFilter()::scan)\n+                .map(new NameMangler(headerName)::scan)\n+                .map(new UnsupportedFilter(errStream)::scan)\n+                .findFirst().get();\n+        return OutputFactory.generateWrapped(transformedDecl, targetPkg, libs, useSystemLoadLibrary);\n@@ -130,1 +149,1 @@\n-     * Write resulting {@link JavaFileObject} instances into specified destination path.\n+     * Write resulting {@link JavaSourceFile} instances into specified destination path.\n@@ -132,2 +151,1 @@\n-     * @param compileSources whether to compile .java sources or not\n-     * @param files the {@link JavaFileObject} instances to be written.\n+     * @param files the {@link JavaSourceFile} instances to be written.\n@@ -135,5 +153,30 @@\n-    public static void write(Path dest, boolean compileSources, List<JavaFileObject> files) throws UncheckedIOException {\n-        try {\n-            new Writer(dest, files).writeAll(compileSources);\n-        } catch (IOException ex) {\n-            throw new UncheckedIOException(ex);\n+    public static void write(Path dest, List<JavaSourceFile> files) throws IOException {\n+        Path destDir = createOutputDir(dest);\n+        for (var entry : files) {\n+            String packagePath = packageNameToPath(entry.packageName());\n+            Path fullPath = destDir.resolve(packagePath, entry.className() + \".java\").normalize();\n+            Path dir = fullPath.getParent();\n+            \/\/ In case the folder exist and is a link to a folder, this should be OK\n+            \/\/ Case in point, \/tmp on MacOS link to \/private\/tmp\n+            if (Files.exists(dir)) {\n+                if (!Files.isDirectory(dir)) {\n+                    throw new FileAlreadyExistsException(dir.toAbsolutePath().toString());\n+                }\n+            } else {\n+                Files.createDirectories(fullPath.getParent());\n+            }\n+            Files.write(fullPath, List.of(entry.contents()));\n+        }\n+    }\n+\n+    private static String packageNameToPath(String packageName) {\n+        return packageName.isEmpty() ? \"\" : packageName.replaceAll(\"\\\\.\", \"\/\") + \"\/\";\n+    }\n+\n+    private static Path createOutputDir(Path dest) throws IOException {\n+        Path absDest = dest.toAbsolutePath();\n+        if (!Files.exists(absDest)) {\n+            Files.createDirectories(absDest);\n+        }\n+        if (!Files.isDirectory(absDest)) {\n+            throw new IOException(\"Not a directory: \" + dest);\n@@ -141,0 +184,1 @@\n+        return absDest;\n@@ -345,0 +389,1 @@\n+        parser.accepts(\"--use-system-load-library\", format(\"help.use.system.load.library\"), false);\n@@ -346,1 +391,0 @@\n-        parser.accepts(\"--source\", format(\"help.source\"), false);\n@@ -429,2 +473,3 @@\n-        if (optionSet.has(\"--source\")) {\n-            builder.setGenerateSource();\n+        boolean useSystemLoadLibrary = optionSet.has(\"--use-system-load-library\");\n+        if (useSystemLoadLibrary) {\n+            builder.setUseSystemLoadLibrary(true);\n@@ -432,0 +477,1 @@\n+\n@@ -435,6 +481,7 @@\n-                if (lib.indexOf(File.separatorChar) == -1) {\n-                    builder.addLibraryName(lib);\n-                } else {\n-                    Path libPath = Paths.get(lib);\n-                    if (libPath.isAbsolute() && Files.isRegularFile(libPath)) {\n-                        builder.addLibraryName(lib);\n+                try {\n+                    Library library = Options.Library.parse(lib);\n+                    Path libPath = Paths.get(library.libSpec());\n+                    if (!useSystemLoadLibrary ||\n+                            library.specKind() == Library.SpecKind.NAME ||\n+                            (libPath.isAbsolute() && Files.isRegularFile(libPath))) {\n+                        builder.addLibrary(library);\n@@ -442,2 +489,2 @@\n-                        err.println(format(\"l.option.value.invalid\", lib));\n-                        return OPTION_ERROR;\n+                        \/\/ not an absolute path, but--use-system-load-library was specified\n+                        err.println(format(\"l.option.value.absolute.path\", lib));\n@@ -445,0 +492,3 @@\n+                } catch (IllegalArgumentException ex) {\n+                    err.println(format(\"l.option.value.invalid\", lib));\n+                    return OPTION_ERROR;\n@@ -464,1 +514,1 @@\n-        List<JavaFileObject> files = null;\n+        List<JavaSourceFile> files;\n@@ -478,1 +528,1 @@\n-                options.targetPackage, options.includeHelper, options.libraryNames);\n+                options.targetPackage, options.includeHelper, options.libraries, options.useSystemLoadLibrary, err);\n@@ -498,6 +548,9 @@\n-                write(output, !options.source, files);\n-            }\n-        } catch (UncheckedIOException uioe) {\n-            err.println(uioe.getMessage());\n-            if (JextractTool.DEBUG) {\n-                uioe.printStackTrace(err);\n+                try {\n+                    write(output, files);\n+                } catch (IOException e) {\n+                    err.println(e.getMessage());\n+                    if (JextractTool.DEBUG) {\n+                        e.printStackTrace(err);\n+                    }\n+                    return OUTPUT_ERROR;\n+                }\n@@ -505,1 +558,0 @@\n-            return OUTPUT_ERROR;\n@@ -556,0 +608,1 @@\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/JextractTool.java","additions":92,"deletions":39,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -29,3 +29,0 @@\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.ValueLayout;\n@@ -33,1 +30,1 @@\n-import org.openjdk.jextract.impl.UnsupportedLayouts;\n+import org.openjdk.jextract.impl.TypeImpl.ErronrousTypeImpl;\n@@ -94,1 +91,1 @@\n-            Void(\"void\", null),\n+            Void(\"void\"),\n@@ -98,1 +95,1 @@\n-            Bool(\"_Bool\", ValueLayout.JAVA_BOOLEAN),\n+            Bool(\"_Bool\"),\n@@ -102,1 +99,1 @@\n-            Char(\"char\", ValueLayout.JAVA_BYTE),\n+            Char(\"char\"),\n@@ -106,1 +103,1 @@\n-            Char16(\"char16\", UnsupportedLayouts.CHAR16),\n+            Char16(\"char16\"),\n@@ -110,1 +107,1 @@\n-            Short(\"short\", ValueLayout.JAVA_SHORT),\n+            Short(\"short\"),\n@@ -114,1 +111,1 @@\n-            Int(\"int\", ValueLayout.JAVA_INT),\n+            Int(\"int\"),\n@@ -118,3 +115,1 @@\n-            Long(\"long\", TypeImpl.IS_WINDOWS ?\n-                ValueLayout.JAVA_INT :\n-                ValueLayout.JAVA_LONG),\n+            Long(\"long\"),\n@@ -124,1 +119,1 @@\n-            LongLong(\"long long\", ValueLayout.JAVA_LONG),\n+            LongLong(\"long long\"),\n@@ -128,1 +123,1 @@\n-            Int128(\"__int128\", UnsupportedLayouts.__INT128),\n+            Int128(\"__int128\"),\n@@ -132,1 +127,1 @@\n-            Float(\"float\", ValueLayout.JAVA_FLOAT),\n+            Float(\"float\"),\n@@ -136,1 +131,1 @@\n-            Double(\"double\", ValueLayout.JAVA_DOUBLE),\n+            Double(\"double\"),\n@@ -140,3 +135,1 @@\n-            LongDouble(\"long double\", TypeImpl.IS_WINDOWS ?\n-                    ValueLayout.JAVA_DOUBLE :\n-                    UnsupportedLayouts.LONG_DOUBLE),\n+            LongDouble(\"long double\"),\n@@ -146,1 +139,1 @@\n-            Float128(\"float128\", UnsupportedLayouts._FLOAT128),\n+            Float128(\"float128\"),\n@@ -150,1 +143,1 @@\n-            HalfFloat(\"__fp16\", UnsupportedLayouts.__FP16),\n+            HalfFloat(\"__fp16\"),\n@@ -154,1 +147,1 @@\n-            WChar(\"wchar_t\", UnsupportedLayouts.WCHAR_T);\n+            WChar(\"wchar_t\");\n@@ -157,1 +150,0 @@\n-            private final MemoryLayout layout;\n@@ -159,1 +151,1 @@\n-            Kind(String typeName, MemoryLayout layout) {\n+            Kind(String typeName) {\n@@ -161,1 +153,0 @@\n-                this.layout = layout;\n@@ -167,8 +158,0 @@\n-\n-            \/**\n-             * The primitive type (optional) layout.\n-             * @return The primitive type (optional) layout.\n-             *\/\n-            public Optional<MemoryLayout> layout() {\n-                return Optional.ofNullable(layout);\n-            }\n@@ -394,18 +377,0 @@\n-    \/**\n-     * Compute the layout for a given type.\n-     * @param t the type.\n-     * @return the layout for given type.\n-     *\/\n-    static Optional<MemoryLayout> layoutFor(Type t) {\n-        return TypeImpl.getLayout(t);\n-    }\n-\n-    \/**\n-     * Compute the function descriptor for a given function type.\n-     * @param function the function type.\n-     * @return the function descriptor for given function type.\n-     *\/\n-    static Optional<FunctionDescriptor> descriptorFor(Function function) {\n-        return TypeImpl.getDescriptor(function);\n-    }\n-\n@@ -525,2 +490,2 @@\n-     * Creates an erroneous type.\n-     * @return an erroneous type.\n+     * Creates an erroneous type with the given name.\n+     * @return an erroneous type with the given name.\n@@ -528,2 +493,2 @@\n-    static Type error() {\n-        return TypeImpl.ERROR;\n+    static Type error(String erroneousName) {\n+        return new ErronrousTypeImpl(erroneousName);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Type.java","additions":21,"deletions":56,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+\n+import org.openjdk.jextract.clang.libclang.CXCursor;\n@@ -34,0 +36,2 @@\n+import java.lang.foreign.SegmentAllocator;\n+import java.util.Objects;\n@@ -35,0 +39,3 @@\n+import java.util.function.Predicate;\n+\n+import static org.openjdk.jextract.clang.libclang.Index_h.C_CHAR;\n@@ -197,0 +204,4 @@\n+    public void forEachShortCircuit(Predicate<Cursor> action) {\n+        CursorChildren.forEachShortCircuit(this, action);\n+    }\n+\n@@ -207,1 +218,1 @@\n-            private final Consumer<Cursor> action;\n+            private final Predicate<Cursor> action;\n@@ -211,1 +222,1 @@\n-            Context(Consumer<Cursor> action, ClangDisposable owner) {\n+            Context(Predicate<Cursor> action, ClangDisposable owner) {\n@@ -223,2 +234,1 @@\n-                    action.accept(new Cursor(segment, owner));\n-                    return true;\n+                    return action.test(new Cursor(segment, owner));\n@@ -249,1 +259,8 @@\n-        synchronized static void forEach(Cursor c, Consumer<Cursor> op) {\n+        static void forEach(Cursor c, Consumer<Cursor> op) {\n+            forEachShortCircuit(c, decl -> {\n+                op.accept(decl);\n+                return true;\n+            });\n+        }\n+\n+        synchronized static void forEachShortCircuit(Cursor c, Predicate<Cursor> op) {\n@@ -279,7 +296,2 @@\n-    @Override\n-    public boolean equals(Object other) {\n-        if (this == other) {\n-            return true;\n-        }\n-        return other instanceof Cursor otherCursor &&\n-                (Index_h.clang_equalCursors(segment, otherCursor.segment) != 0);\n+    public Key toKey() {\n+        return new Key(this);\n@@ -288,3 +300,39 @@\n-    @Override\n-    public int hashCode() {\n-        return spelling().hashCode();\n+    \/**\n+     * A key that can be used for cursor comparisons. This avoids the problem of comparing cursors\n+     * which are already closed, and also optimizes the use of the underlying 'clang_equalCursors' function,\n+     * to avoid unnecessary off-heap allocation. This is required by the deduplication logic in TreeMaker.\n+     *\/\n+    public static class Key {\n+\n+        final String spelling;\n+        final CursorKind kind;\n+        final MemorySegment payload;\n+\n+        private Key(Cursor cursor) {\n+            spelling = cursor.spelling();\n+            kind = cursor.kind();\n+            payload = MemorySegment.ofArray(new byte[(int)CXCursor.sizeof()]);\n+            payload.copyFrom(cursor.segment);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!(obj instanceof Key key)) return false;\n+            if (kind != key.kind) return false;\n+            if (!spelling.equals(key.spelling)) return false;\n+            \/\/ slow path\n+            SegmentAllocator allocator = SegmentAllocator.slicingAllocator(COMPARISON_SEGMENT);\n+            return Index_h.clang_equalCursors(toSegment(allocator), key.toSegment(allocator)) != 0;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(kind, spelling);\n+        }\n+\n+        private MemorySegment toSegment(SegmentAllocator allocator) {\n+            return allocator.allocateFrom(C_CHAR, payload,\n+                                          C_CHAR, 0, CXCursor.sizeof());\n+        }\n+\n+        private static final MemorySegment COMPARISON_SEGMENT = Arena.ofAuto().allocate(CXCursor.layout(), 2);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/Cursor.java","additions":63,"deletions":15,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -77,3 +77,3 @@\n-    static long FILENAME_OFFSET = CXUnsavedFile.$LAYOUT().byteOffset(MemoryLayout.PathElement.groupElement(\"Filename\"));\n-    static long CONTENTS_OFFSET = CXUnsavedFile.$LAYOUT().byteOffset(MemoryLayout.PathElement.groupElement(\"Contents\"));\n-    static long LENGTH_OFFSET = CXUnsavedFile.$LAYOUT().byteOffset(MemoryLayout.PathElement.groupElement(\"Length\"));\n+    static long FILENAME_OFFSET = CXUnsavedFile.layout().byteOffset(MemoryLayout.PathElement.groupElement(\"Filename\"));\n+    static long CONTENTS_OFFSET = CXUnsavedFile.layout().byteOffset(MemoryLayout.PathElement.groupElement(\"Contents\"));\n+    static long LENGTH_OFFSET = CXUnsavedFile.layout().byteOffset(MemoryLayout.PathElement.groupElement(\"Length\"));\n@@ -85,1 +85,1 @@\n-                    arena.allocate(CXUnsavedFile.$LAYOUT(), inMemoryFiles.length);\n+                    arena.allocate(CXUnsavedFile.layout(), inMemoryFiles.length);\n@@ -87,1 +87,1 @@\n-                MemorySegment start = files.asSlice(i * CXUnsavedFile.$LAYOUT().byteSize());\n+                MemorySegment start = files.asSlice(i * CXUnsavedFile.sizeof());\n@@ -137,1 +137,1 @@\n-            super(addr, size * CXToken.$LAYOUT().byteSize(),\n+            super(addr, size * CXToken.sizeof(),\n@@ -147,1 +147,1 @@\n-            return ptr.asSlice(idx * CXToken.$LAYOUT().byteSize());\n+            return ptr.asSlice(idx * CXToken.sizeof());\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/TranslationUnit.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -101,0 +101,4 @@\n+    public Type getValueType() {\n+        var valueType = Index_h.clang_Type_getValueType(owner, segment);\n+        return new Type(valueType, owner);\n+    }\n@@ -160,1 +164,1 @@\n-        return CXType.kind$get(segment);\n+        return CXType.kind(segment);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/Type.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,277 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * struct {\n+ *     enum CXCursorKind kind;\n+ *     int xdata;\n+ *     const void *data[3];\n+ * }\n+ * }\n+ *\/\n+public class CXCursor {\n+\n+    CXCursor() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        Index_h.C_INT.withName(\"kind\"),\n+        Index_h.C_INT.withName(\"xdata\"),\n+        MemoryLayout.sequenceLayout(3, Index_h.C_POINTER).withName(\"data\")\n+    ).withName(\"$anon$2706:9\");\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n+    }\n+\n+    private static final OfInt kind$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"kind\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * enum CXCursorKind kind\n+     * }\n+     *\/\n+    public static final OfInt kind$layout() {\n+        return kind$LAYOUT;\n+    }\n+\n+    private static final long kind$OFFSET = 0;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * enum CXCursorKind kind\n+     * }\n+     *\/\n+    public static final long kind$offset() {\n+        return kind$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * enum CXCursorKind kind\n+     * }\n+     *\/\n+    public static int kind(MemorySegment struct) {\n+        return struct.get(kind$LAYOUT, kind$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * enum CXCursorKind kind\n+     * }\n+     *\/\n+    public static void kind(MemorySegment struct, int fieldValue) {\n+        struct.set(kind$LAYOUT, kind$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt xdata$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"xdata\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int xdata\n+     * }\n+     *\/\n+    public static final OfInt xdata$layout() {\n+        return xdata$LAYOUT;\n+    }\n+\n+    private static final long xdata$OFFSET = 4;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int xdata\n+     * }\n+     *\/\n+    public static final long xdata$offset() {\n+        return xdata$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int xdata\n+     * }\n+     *\/\n+    public static int xdata(MemorySegment struct) {\n+        return struct.get(xdata$LAYOUT, xdata$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int xdata\n+     * }\n+     *\/\n+    public static void xdata(MemorySegment struct, int fieldValue) {\n+        struct.set(xdata$LAYOUT, xdata$OFFSET, fieldValue);\n+    }\n+\n+    private static final SequenceLayout data$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement(\"data\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const void *data[3]\n+     * }\n+     *\/\n+    public static final SequenceLayout data$layout() {\n+        return data$LAYOUT;\n+    }\n+\n+    private static final long data$OFFSET = 8;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * const void *data[3]\n+     * }\n+     *\/\n+    public static final long data$offset() {\n+        return data$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const void *data[3]\n+     * }\n+     *\/\n+    public static MemorySegment data(MemorySegment struct) {\n+        return struct.asSlice(data$OFFSET, data$LAYOUT.byteSize());\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * const void *data[3]\n+     * }\n+     *\/\n+    public static void data(MemorySegment struct, MemorySegment fieldValue) {\n+        MemorySegment.copy(fieldValue, 0L, struct, data$OFFSET, data$LAYOUT.byteSize());\n+    }\n+\n+    private static long[] data$DIMS = { 3 };\n+\n+    \/**\n+     * Dimensions for array field:\n+     * {@snippet lang=c :\n+     * const void *data[3]\n+     * }\n+     *\/\n+    public static long[] data$dimensions() {\n+        return data$DIMS;\n+    }\n+    private static final VarHandle data$ELEM_HANDLE = data$LAYOUT.varHandle(sequenceElement());\n+\n+    \/**\n+     * Indexed getter for field:\n+     * {@snippet lang=c :\n+     * const void *data[3]\n+     * }\n+     *\/\n+    public static MemorySegment data(MemorySegment struct, long index0) {\n+        return (MemorySegment)data$ELEM_HANDLE.get(struct, 0L, index0);\n+    }\n+\n+    \/**\n+     * Indexed setter for field:\n+     * {@snippet lang=c :\n+     * const void *data[3]\n+     * }\n+     *\/\n+    public static void data(MemorySegment struct, long index0, MemorySegment fieldValue) {\n+        data$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);\n+    }\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n+    }\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n+    }\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+    }\n+}\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXCursor.java","additions":277,"deletions":0,"binary":false,"changes":277,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,1 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n+import java.lang.invoke.*;\n@@ -34,0 +32,5 @@\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n@@ -35,0 +38,2 @@\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n@@ -36,2 +41,6 @@\n- * {@snippet :\n- * enum CXChildVisitResult (*CXCursorVisitor)(struct  cursor,struct  parent,void* client_data);\n+ * {@snippet lang=c :\n+ * typedef enum CXChildVisitResult {\n+ *     CXChildVisit_Break,\n+ *     CXChildVisit_Continue,\n+ *     CXChildVisit_Recurse\n+ * } (*CXCursorVisitor)(CXCursor, CXCursor, CXClientData)\n@@ -40,1 +49,1 @@\n-public interface CXCursorVisitor {\n+public class CXCursorVisitor {\n@@ -42,3 +51,5 @@\n-    int apply(java.lang.foreign.MemorySegment cursor, java.lang.foreign.MemorySegment parent, java.lang.foreign.MemorySegment client_data);\n-    static MemorySegment allocate(CXCursorVisitor fi, Arena scope) {\n-        return RuntimeHelper.upcallStub(CXCursorVisitor.class, fi, constants$13.CXCursorVisitor$FUNC, scope);\n+    \/**\n+     * The function pointer signature, expressed as a functional interface\n+     *\/\n+    public interface Function {\n+        int apply(MemorySegment cursor, MemorySegment parent, MemorySegment client_data);\n@@ -46,9 +57,13 @@\n-    static CXCursorVisitor ofAddress(MemorySegment addr, Arena arena) {\n-        MemorySegment symbol = addr.reinterpret(arena, null);\n-        return (java.lang.foreign.MemorySegment _cursor, java.lang.foreign.MemorySegment _parent, java.lang.foreign.MemorySegment _client_data) -> {\n-            try {\n-                return (int)constants$13.CXCursorVisitor$MH.invokeExact(symbol, _cursor, _parent, _client_data);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        };\n+\n+    private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+        Index_h.C_INT,\n+        CXCursor.layout(),\n+        CXCursor.layout(),\n+        Index_h.C_POINTER\n+    );\n+\n+    \/**\n+     * The descriptor of this function pointer\n+     *\/\n+    public static FunctionDescriptor descriptor() {\n+        return $DESC;\n@@ -56,1 +71,0 @@\n-}\n@@ -58,0 +72,23 @@\n+    private static final MethodHandle UP$MH = Index_h.upcallHandle(CXCursorVisitor.Function.class, \"apply\", $DESC);\n+\n+    \/**\n+     * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+     * The lifetime of the returned segment is managed by {@code arena}\n+     *\/\n+    public static MemorySegment allocate(CXCursorVisitor.Function fi, Arena arena) {\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+    }\n+\n+    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+    \/**\n+     * Invoke the upcall stub {@code funcPtr}, with given parameters\n+     *\/\n+    public static int invoke(MemorySegment funcPtr,MemorySegment cursor, MemorySegment parent, MemorySegment client_data) {\n+        try {\n+            return (int) DOWN$MH.invokeExact(funcPtr, cursor, parent, client_data);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXCursorVisitor.java","additions":57,"deletions":20,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * struct {\n+ *     const void *ptr_data[2];\n+ *     unsigned int int_data;\n+ * }\n+ * }\n+ *\/\n+public class CXSourceLocation {\n+\n+    CXSourceLocation() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, Index_h.C_POINTER).withName(\"ptr_data\"),\n+        Index_h.C_INT.withName(\"int_data\"),\n+        MemoryLayout.paddingLayout(4)\n+    ).withName(\"$anon$456:9\");\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n+    }\n+\n+    private static final SequenceLayout ptr_data$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement(\"ptr_data\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const void *ptr_data[2]\n+     * }\n+     *\/\n+    public static final SequenceLayout ptr_data$layout() {\n+        return ptr_data$LAYOUT;\n+    }\n+\n+    private static final long ptr_data$OFFSET = 0;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * const void *ptr_data[2]\n+     * }\n+     *\/\n+    public static final long ptr_data$offset() {\n+        return ptr_data$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const void *ptr_data[2]\n+     * }\n+     *\/\n+    public static MemorySegment ptr_data(MemorySegment struct) {\n+        return struct.asSlice(ptr_data$OFFSET, ptr_data$LAYOUT.byteSize());\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * const void *ptr_data[2]\n+     * }\n+     *\/\n+    public static void ptr_data(MemorySegment struct, MemorySegment fieldValue) {\n+        MemorySegment.copy(fieldValue, 0L, struct, ptr_data$OFFSET, ptr_data$LAYOUT.byteSize());\n+    }\n+\n+    private static long[] ptr_data$DIMS = { 2 };\n+\n+    \/**\n+     * Dimensions for array field:\n+     * {@snippet lang=c :\n+     * const void *ptr_data[2]\n+     * }\n+     *\/\n+    public static long[] ptr_data$dimensions() {\n+        return ptr_data$DIMS;\n+    }\n+    private static final VarHandle ptr_data$ELEM_HANDLE = ptr_data$LAYOUT.varHandle(sequenceElement());\n+\n+    \/**\n+     * Indexed getter for field:\n+     * {@snippet lang=c :\n+     * const void *ptr_data[2]\n+     * }\n+     *\/\n+    public static MemorySegment ptr_data(MemorySegment struct, long index0) {\n+        return (MemorySegment)ptr_data$ELEM_HANDLE.get(struct, 0L, index0);\n+    }\n+\n+    \/**\n+     * Indexed setter for field:\n+     * {@snippet lang=c :\n+     * const void *ptr_data[2]\n+     * }\n+     *\/\n+    public static void ptr_data(MemorySegment struct, long index0, MemorySegment fieldValue) {\n+        ptr_data$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);\n+    }\n+\n+    private static final OfInt int_data$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"int_data\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * unsigned int int_data\n+     * }\n+     *\/\n+    public static final OfInt int_data$layout() {\n+        return int_data$LAYOUT;\n+    }\n+\n+    private static final long int_data$OFFSET = 16;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * unsigned int int_data\n+     * }\n+     *\/\n+    public static final long int_data$offset() {\n+        return int_data$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * unsigned int int_data\n+     * }\n+     *\/\n+    public static int int_data(MemorySegment struct) {\n+        return struct.get(int_data$LAYOUT, int_data$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * unsigned int int_data\n+     * }\n+     *\/\n+    public static void int_data(MemorySegment struct, int fieldValue) {\n+        struct.set(int_data$LAYOUT, int_data$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n+    }\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n+    }\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+    }\n+}\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXSourceLocation.java","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"},{"patch":"@@ -0,0 +1,277 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * struct {\n+ *     const void *ptr_data[2];\n+ *     unsigned int begin_int_data;\n+ *     unsigned int end_int_data;\n+ * }\n+ * }\n+ *\/\n+public class CXSourceRange {\n+\n+    CXSourceRange() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, Index_h.C_POINTER).withName(\"ptr_data\"),\n+        Index_h.C_INT.withName(\"begin_int_data\"),\n+        Index_h.C_INT.withName(\"end_int_data\")\n+    ).withName(\"$anon$467:9\");\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n+    }\n+\n+    private static final SequenceLayout ptr_data$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement(\"ptr_data\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const void *ptr_data[2]\n+     * }\n+     *\/\n+    public static final SequenceLayout ptr_data$layout() {\n+        return ptr_data$LAYOUT;\n+    }\n+\n+    private static final long ptr_data$OFFSET = 0;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * const void *ptr_data[2]\n+     * }\n+     *\/\n+    public static final long ptr_data$offset() {\n+        return ptr_data$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const void *ptr_data[2]\n+     * }\n+     *\/\n+    public static MemorySegment ptr_data(MemorySegment struct) {\n+        return struct.asSlice(ptr_data$OFFSET, ptr_data$LAYOUT.byteSize());\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * const void *ptr_data[2]\n+     * }\n+     *\/\n+    public static void ptr_data(MemorySegment struct, MemorySegment fieldValue) {\n+        MemorySegment.copy(fieldValue, 0L, struct, ptr_data$OFFSET, ptr_data$LAYOUT.byteSize());\n+    }\n+\n+    private static long[] ptr_data$DIMS = { 2 };\n+\n+    \/**\n+     * Dimensions for array field:\n+     * {@snippet lang=c :\n+     * const void *ptr_data[2]\n+     * }\n+     *\/\n+    public static long[] ptr_data$dimensions() {\n+        return ptr_data$DIMS;\n+    }\n+    private static final VarHandle ptr_data$ELEM_HANDLE = ptr_data$LAYOUT.varHandle(sequenceElement());\n+\n+    \/**\n+     * Indexed getter for field:\n+     * {@snippet lang=c :\n+     * const void *ptr_data[2]\n+     * }\n+     *\/\n+    public static MemorySegment ptr_data(MemorySegment struct, long index0) {\n+        return (MemorySegment)ptr_data$ELEM_HANDLE.get(struct, 0L, index0);\n+    }\n+\n+    \/**\n+     * Indexed setter for field:\n+     * {@snippet lang=c :\n+     * const void *ptr_data[2]\n+     * }\n+     *\/\n+    public static void ptr_data(MemorySegment struct, long index0, MemorySegment fieldValue) {\n+        ptr_data$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);\n+    }\n+\n+    private static final OfInt begin_int_data$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"begin_int_data\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * unsigned int begin_int_data\n+     * }\n+     *\/\n+    public static final OfInt begin_int_data$layout() {\n+        return begin_int_data$LAYOUT;\n+    }\n+\n+    private static final long begin_int_data$OFFSET = 16;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * unsigned int begin_int_data\n+     * }\n+     *\/\n+    public static final long begin_int_data$offset() {\n+        return begin_int_data$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * unsigned int begin_int_data\n+     * }\n+     *\/\n+    public static int begin_int_data(MemorySegment struct) {\n+        return struct.get(begin_int_data$LAYOUT, begin_int_data$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * unsigned int begin_int_data\n+     * }\n+     *\/\n+    public static void begin_int_data(MemorySegment struct, int fieldValue) {\n+        struct.set(begin_int_data$LAYOUT, begin_int_data$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt end_int_data$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"end_int_data\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * unsigned int end_int_data\n+     * }\n+     *\/\n+    public static final OfInt end_int_data$layout() {\n+        return end_int_data$LAYOUT;\n+    }\n+\n+    private static final long end_int_data$OFFSET = 20;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * unsigned int end_int_data\n+     * }\n+     *\/\n+    public static final long end_int_data$offset() {\n+        return end_int_data$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * unsigned int end_int_data\n+     * }\n+     *\/\n+    public static int end_int_data(MemorySegment struct) {\n+        return struct.get(end_int_data$LAYOUT, end_int_data$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * unsigned int end_int_data\n+     * }\n+     *\/\n+    public static void end_int_data(MemorySegment struct, int fieldValue) {\n+        struct.set(end_int_data$LAYOUT, end_int_data$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n+    }\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n+    }\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+    }\n+}\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXSourceRange.java","additions":277,"deletions":0,"binary":false,"changes":277,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,1 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n+import java.lang.invoke.*;\n@@ -34,0 +32,5 @@\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n@@ -35,0 +38,2 @@\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n@@ -36,1 +41,1 @@\n- * {@snippet :\n+ * {@snippet lang=c :\n@@ -38,1 +43,1 @@\n- *     void* data;\n+ *     const void *data;\n@@ -40,1 +45,1 @@\n- * };\n+ * }\n@@ -45,3 +50,7 @@\n-    static final StructLayout $struct$LAYOUT = MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n+    CXString() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        Index_h.C_POINTER.withName(\"data\"),\n+        Index_h.C_INT.withName(\"private_flags\"),\n@@ -49,3 +58,7 @@\n-    );\n-    public static MemoryLayout $LAYOUT() {\n-        return CXString.$struct$LAYOUT;\n+    ).withName(\"$anon$37:9\");\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n@@ -53,3 +66,11 @@\n-    static final VarHandle data$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"data\"));\n-    public static VarHandle data$VH() {\n-        return CXString.data$VH;\n+\n+    private static final AddressLayout data$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"data\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const void *data\n+     * }\n+     *\/\n+    public static final AddressLayout data$layout() {\n+        return data$LAYOUT;\n@@ -57,0 +78,13 @@\n+\n+    private static final long data$OFFSET = 0;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * const void *data\n+     * }\n+     *\/\n+    public static final long data$offset() {\n+        return data$OFFSET;\n+    }\n+\n@@ -59,2 +93,2 @@\n-     * {@snippet :\n-     * void* data;\n+     * {@snippet lang=c :\n+     * const void *data\n@@ -63,2 +97,2 @@\n-    public static MemorySegment data$get(MemorySegment seg) {\n-        return (java.lang.foreign.MemorySegment)CXString.data$VH.get(seg, 0L);\n+    public static MemorySegment data(MemorySegment struct) {\n+        return struct.get(data$LAYOUT, data$OFFSET);\n@@ -66,0 +100,1 @@\n+\n@@ -68,2 +103,2 @@\n-     * {@snippet :\n-     * void* data;\n+     * {@snippet lang=c :\n+     * const void *data\n@@ -72,5 +107,2 @@\n-    public static void data$set(MemorySegment seg, MemorySegment x) {\n-        CXString.data$VH.set(seg, 0L, x);\n-    }\n-    public static MemorySegment data$get(MemorySegment seg, long index) {\n-        return (java.lang.foreign.MemorySegment)CXString.data$VH.get(seg.asSlice(index*sizeof()));\n+    public static void data(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(data$LAYOUT, data$OFFSET, fieldValue);\n@@ -78,2 +110,11 @@\n-    public static void data$set(MemorySegment seg, long index, MemorySegment x) {\n-        CXString.data$VH.set(seg.asSlice(index*sizeof()), x);\n+\n+    private static final OfInt private_flags$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"private_flags\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * unsigned int private_flags\n+     * }\n+     *\/\n+    public static final OfInt private_flags$layout() {\n+        return private_flags$LAYOUT;\n@@ -81,3 +122,11 @@\n-    static final VarHandle private_flags$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"private_flags\"));\n-    public static VarHandle private_flags$VH() {\n-        return CXString.private_flags$VH;\n+\n+    private static final long private_flags$OFFSET = 8;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * unsigned int private_flags\n+     * }\n+     *\/\n+    public static final long private_flags$offset() {\n+        return private_flags$OFFSET;\n@@ -85,0 +134,1 @@\n+\n@@ -87,2 +137,2 @@\n-     * {@snippet :\n-     * unsigned int private_flags;\n+     * {@snippet lang=c :\n+     * unsigned int private_flags\n@@ -91,2 +141,2 @@\n-    public static int private_flags$get(MemorySegment seg) {\n-        return (int)CXString.private_flags$VH.get(seg, 0L);\n+    public static int private_flags(MemorySegment struct) {\n+        return struct.get(private_flags$LAYOUT, private_flags$OFFSET);\n@@ -94,0 +144,1 @@\n+\n@@ -96,2 +147,2 @@\n-     * {@snippet :\n-     * unsigned int private_flags;\n+     * {@snippet lang=c :\n+     * unsigned int private_flags\n@@ -100,2 +151,22 @@\n-    public static void private_flags$set(MemorySegment seg, int x) {\n-        CXString.private_flags$VH.set(seg, 0L, x);\n+    public static void private_flags(MemorySegment struct, int fieldValue) {\n+        struct.set(private_flags$LAYOUT, private_flags$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n+    }\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n@@ -103,2 +174,7 @@\n-    public static int private_flags$get(MemorySegment seg, long index) {\n-        return (int)CXString.private_flags$VH.get(seg.asSlice(index*sizeof()));\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n@@ -106,2 +182,7 @@\n-    public static void private_flags$set(MemorySegment seg, long index, int x) {\n-        CXString.private_flags$VH.set(seg.asSlice(index*sizeof()), x);\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n@@ -109,4 +190,7 @@\n-    public static long sizeof() { return $LAYOUT().byteSize(); }\n-    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }\n-    public static MemorySegment allocateArray(long len, SegmentAllocator allocator) {\n-        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n@@ -114,1 +198,0 @@\n-    public static MemorySegment ofAddress(MemorySegment addr, Arena scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }\n@@ -117,1 +200,0 @@\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXString.java","additions":132,"deletions":50,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,1 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n+import java.lang.invoke.*;\n@@ -34,0 +32,5 @@\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n@@ -35,0 +38,2 @@\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n@@ -36,1 +41,1 @@\n- * {@snippet :\n+ * {@snippet lang=c :\n@@ -39,2 +44,2 @@\n- *     void* ptr_data;\n- * };\n+ *     void *ptr_data;\n+ * }\n@@ -45,6 +50,2 @@\n-    static final StructLayout $struct$LAYOUT = MemoryLayout.structLayout(\n-        MemoryLayout.sequenceLayout(4, Constants$root.C_INT$LAYOUT).withName(\"int_data\"),\n-        Constants$root.C_POINTER$LAYOUT.withName(\"ptr_data\")\n-    );\n-    public static MemoryLayout $LAYOUT() {\n-        return CXToken.$struct$LAYOUT;\n+    CXToken() {\n+        \/\/ Should not be called directly\n@@ -52,2 +53,11 @@\n-    public static MemorySegment int_data$slice(MemorySegment seg) {\n-        return seg.asSlice(0, 16);\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(4, Index_h.C_INT).withName(\"int_data\"),\n+        Index_h.C_POINTER.withName(\"ptr_data\")\n+    ).withName(\"$anon$4996:9\");\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n@@ -55,3 +65,23 @@\n-    static final VarHandle ptr_data$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"ptr_data\"));\n-    public static VarHandle ptr_data$VH() {\n-        return CXToken.ptr_data$VH;\n+\n+    private static final SequenceLayout int_data$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement(\"int_data\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * unsigned int int_data[4]\n+     * }\n+     *\/\n+    public static final SequenceLayout int_data$layout() {\n+        return int_data$LAYOUT;\n+    }\n+\n+    private static final long int_data$OFFSET = 0;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * unsigned int int_data[4]\n+     * }\n+     *\/\n+    public static final long int_data$offset() {\n+        return int_data$OFFSET;\n@@ -59,0 +89,1 @@\n+\n@@ -61,2 +92,2 @@\n-     * {@snippet :\n-     * void* ptr_data;\n+     * {@snippet lang=c :\n+     * unsigned int int_data[4]\n@@ -65,2 +96,2 @@\n-    public static MemorySegment ptr_data$get(MemorySegment seg) {\n-        return (java.lang.foreign.MemorySegment)CXToken.ptr_data$VH.get(seg, 0L);\n+    public static MemorySegment int_data(MemorySegment struct) {\n+        return struct.asSlice(int_data$OFFSET, int_data$LAYOUT.byteSize());\n@@ -68,0 +99,1 @@\n+\n@@ -70,2 +102,2 @@\n-     * {@snippet :\n-     * void* ptr_data;\n+     * {@snippet lang=c :\n+     * unsigned int int_data[4]\n@@ -74,2 +106,2 @@\n-    public static void ptr_data$set(MemorySegment seg, MemorySegment x) {\n-        CXToken.ptr_data$VH.set(seg, 0L, x);\n+    public static void int_data(MemorySegment struct, MemorySegment fieldValue) {\n+        MemorySegment.copy(fieldValue, 0L, struct, int_data$OFFSET, int_data$LAYOUT.byteSize());\n@@ -77,2 +109,11 @@\n-    public static MemorySegment ptr_data$get(MemorySegment seg, long index) {\n-        return (java.lang.foreign.MemorySegment)CXToken.ptr_data$VH.get(seg.asSlice(index*sizeof()));\n+\n+    private static long[] int_data$DIMS = { 4 };\n+\n+    \/**\n+     * Dimensions for array field:\n+     * {@snippet lang=c :\n+     * unsigned int int_data[4]\n+     * }\n+     *\/\n+    public static long[] int_data$dimensions() {\n+        return int_data$DIMS;\n@@ -80,2 +121,10 @@\n-    public static void ptr_data$set(MemorySegment seg, long index, MemorySegment x) {\n-        CXToken.ptr_data$VH.set(seg.asSlice(index*sizeof()), x);\n+    private static final VarHandle int_data$ELEM_HANDLE = int_data$LAYOUT.varHandle(sequenceElement());\n+\n+    \/**\n+     * Indexed getter for field:\n+     * {@snippet lang=c :\n+     * unsigned int int_data[4]\n+     * }\n+     *\/\n+    public static int int_data(MemorySegment struct, long index0) {\n+        return (int)int_data$ELEM_HANDLE.get(struct, 0L, index0);\n@@ -83,4 +132,21 @@\n-    public static long sizeof() { return $LAYOUT().byteSize(); }\n-    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }\n-    public static MemorySegment allocateArray(long len, SegmentAllocator allocator) {\n-        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));\n+\n+    \/**\n+     * Indexed setter for field:\n+     * {@snippet lang=c :\n+     * unsigned int int_data[4]\n+     * }\n+     *\/\n+    public static void int_data(MemorySegment struct, long index0, int fieldValue) {\n+        int_data$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);\n+    }\n+\n+    private static final AddressLayout ptr_data$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ptr_data\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void *ptr_data\n+     * }\n+     *\/\n+    public static final AddressLayout ptr_data$layout() {\n+        return ptr_data$LAYOUT;\n@@ -88,2 +154,0 @@\n-    public static MemorySegment ofAddress(MemorySegment addr, Arena scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }\n-}\n@@ -91,0 +155,76 @@\n+    private static final long ptr_data$OFFSET = 16;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void *ptr_data\n+     * }\n+     *\/\n+    public static final long ptr_data$offset() {\n+        return ptr_data$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void *ptr_data\n+     * }\n+     *\/\n+    public static MemorySegment ptr_data(MemorySegment struct) {\n+        return struct.get(ptr_data$LAYOUT, ptr_data$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void *ptr_data\n+     * }\n+     *\/\n+    public static void ptr_data(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ptr_data$LAYOUT, ptr_data$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n+    }\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n+    }\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXToken.java","additions":176,"deletions":36,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,1 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n+import java.lang.invoke.*;\n@@ -34,0 +32,5 @@\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n@@ -35,0 +38,2 @@\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n@@ -36,1 +41,1 @@\n- * {@snippet :\n+ * {@snippet lang=c :\n@@ -39,2 +44,2 @@\n- *     void* data[2];\n- * };\n+ *     void *data[2];\n+ * }\n@@ -45,2 +50,6 @@\n-    static final StructLayout $struct$LAYOUT = MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n+    CXType() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        Index_h.C_INT.withName(\"kind\"),\n@@ -48,4 +57,8 @@\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    );\n-    public static MemoryLayout $LAYOUT() {\n-        return CXType.$struct$LAYOUT;\n+        MemoryLayout.sequenceLayout(2, Index_h.C_POINTER).withName(\"data\")\n+    ).withName(\"$anon$3431:9\");\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n@@ -53,3 +66,23 @@\n-    static final VarHandle kind$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"kind\"));\n-    public static VarHandle kind$VH() {\n-        return CXType.kind$VH;\n+\n+    private static final OfInt kind$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"kind\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * enum CXTypeKind kind\n+     * }\n+     *\/\n+    public static final OfInt kind$layout() {\n+        return kind$LAYOUT;\n+    }\n+\n+    private static final long kind$OFFSET = 0;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * enum CXTypeKind kind\n+     * }\n+     *\/\n+    public static final long kind$offset() {\n+        return kind$OFFSET;\n@@ -57,0 +90,1 @@\n+\n@@ -59,2 +93,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind kind;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind kind\n@@ -63,2 +97,2 @@\n-    public static int kind$get(MemorySegment seg) {\n-        return (int)CXType.kind$VH.get(seg, 0L);\n+    public static int kind(MemorySegment struct) {\n+        return struct.get(kind$LAYOUT, kind$OFFSET);\n@@ -66,0 +100,1 @@\n+\n@@ -68,2 +103,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind kind;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind kind\n@@ -72,2 +107,2 @@\n-    public static void kind$set(MemorySegment seg, int x) {\n-        CXType.kind$VH.set(seg, 0L, x);\n+    public static void kind(MemorySegment struct, int fieldValue) {\n+        struct.set(kind$LAYOUT, kind$OFFSET, fieldValue);\n@@ -75,2 +110,11 @@\n-    public static int kind$get(MemorySegment seg, long index) {\n-        return (int)CXType.kind$VH.get(seg.asSlice(index*sizeof()));\n+\n+    private static final SequenceLayout data$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement(\"data\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void *data[2]\n+     * }\n+     *\/\n+    public static final SequenceLayout data$layout() {\n+        return data$LAYOUT;\n@@ -78,2 +122,11 @@\n-    public static void kind$set(MemorySegment seg, long index, int x) {\n-        CXType.kind$VH.set(seg.asSlice(index*sizeof()), x);\n+\n+    private static final long data$OFFSET = 8;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void *data[2]\n+     * }\n+     *\/\n+    public static final long data$offset() {\n+        return data$OFFSET;\n@@ -81,2 +134,9 @@\n-    public static MemorySegment data$slice(MemorySegment seg) {\n-        return seg.asSlice(8, 16);\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void *data[2]\n+     * }\n+     *\/\n+    public static MemorySegment data(MemorySegment struct) {\n+        return struct.asSlice(data$OFFSET, data$LAYOUT.byteSize());\n@@ -84,4 +144,9 @@\n-    public static long sizeof() { return $LAYOUT().byteSize(); }\n-    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }\n-    public static MemorySegment allocateArray(long len, SegmentAllocator allocator) {\n-        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void *data[2]\n+     * }\n+     *\/\n+    public static void data(MemorySegment struct, MemorySegment fieldValue) {\n+        MemorySegment.copy(fieldValue, 0L, struct, data$OFFSET, data$LAYOUT.byteSize());\n@@ -89,2 +154,0 @@\n-    public static MemorySegment ofAddress(MemorySegment addr, Arena scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }\n-}\n@@ -92,0 +155,77 @@\n+    private static long[] data$DIMS = { 2 };\n+\n+    \/**\n+     * Dimensions for array field:\n+     * {@snippet lang=c :\n+     * void *data[2]\n+     * }\n+     *\/\n+    public static long[] data$dimensions() {\n+        return data$DIMS;\n+    }\n+    private static final VarHandle data$ELEM_HANDLE = data$LAYOUT.varHandle(sequenceElement());\n+\n+    \/**\n+     * Indexed getter for field:\n+     * {@snippet lang=c :\n+     * void *data[2]\n+     * }\n+     *\/\n+    public static MemorySegment data(MemorySegment struct, long index0) {\n+        return (MemorySegment)data$ELEM_HANDLE.get(struct, 0L, index0);\n+    }\n+\n+    \/**\n+     * Indexed setter for field:\n+     * {@snippet lang=c :\n+     * void *data[2]\n+     * }\n+     *\/\n+    public static void data(MemorySegment struct, long index0, MemorySegment fieldValue) {\n+        data$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);\n+    }\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n+    }\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n+    }\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXType.java","additions":176,"deletions":36,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,1 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n+import java.lang.invoke.*;\n@@ -34,0 +32,5 @@\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n@@ -35,0 +38,2 @@\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n@@ -36,1 +41,1 @@\n- * {@snippet :\n+ * {@snippet lang=c :\n@@ -38,2 +43,2 @@\n- *     char* Filename;\n- *     char* Contents;\n+ *     const char *Filename;\n+ *     const char *Contents;\n@@ -41,1 +46,1 @@\n- * };\n+ * }\n@@ -46,4 +51,8 @@\n-    static final StructLayout $struct$LAYOUT = MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"Filename\"),\n-        Constants$root.C_POINTER$LAYOUT.withName(\"Contents\"),\n-        Constants$root.C_LONG_LONG$LAYOUT.withName(\"Length\")\n+    CXUnsavedFile() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        Index_h.C_POINTER.withName(\"Filename\"),\n+        Index_h.C_POINTER.withName(\"Contents\"),\n+        Index_h.C_LONG.withName(\"Length\")\n@@ -51,2 +60,6 @@\n-    public static MemoryLayout $LAYOUT() {\n-        return CXUnsavedFile.$struct$LAYOUT;\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n@@ -54,3 +67,11 @@\n-    static final VarHandle Filename$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"Filename\"));\n-    public static VarHandle Filename$VH() {\n-        return CXUnsavedFile.Filename$VH;\n+\n+    private static final AddressLayout Filename$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Filename\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const char *Filename\n+     * }\n+     *\/\n+    public static final AddressLayout Filename$layout() {\n+        return Filename$LAYOUT;\n@@ -58,0 +79,13 @@\n+\n+    private static final long Filename$OFFSET = 0;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * const char *Filename\n+     * }\n+     *\/\n+    public static final long Filename$offset() {\n+        return Filename$OFFSET;\n+    }\n+\n@@ -60,2 +94,2 @@\n-     * {@snippet :\n-     * char* Filename;\n+     * {@snippet lang=c :\n+     * const char *Filename\n@@ -64,2 +98,2 @@\n-    public static MemorySegment Filename$get(MemorySegment seg) {\n-        return (java.lang.foreign.MemorySegment)CXUnsavedFile.Filename$VH.get(seg, 0L);\n+    public static MemorySegment Filename(MemorySegment struct) {\n+        return struct.get(Filename$LAYOUT, Filename$OFFSET);\n@@ -67,0 +101,1 @@\n+\n@@ -69,2 +104,2 @@\n-     * {@snippet :\n-     * char* Filename;\n+     * {@snippet lang=c :\n+     * const char *Filename\n@@ -73,2 +108,2 @@\n-    public static void Filename$set(MemorySegment seg, MemorySegment x) {\n-        CXUnsavedFile.Filename$VH.set(seg, 0L, x);\n+    public static void Filename(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Filename$LAYOUT, Filename$OFFSET, fieldValue);\n@@ -76,5 +111,11 @@\n-    public static MemorySegment Filename$get(MemorySegment seg, long index) {\n-        return (java.lang.foreign.MemorySegment)CXUnsavedFile.Filename$VH.get(seg.asSlice(index*sizeof()));\n-    }\n-    public static void Filename$set(MemorySegment seg, long index, MemorySegment x) {\n-        CXUnsavedFile.Filename$VH.set(seg.asSlice(index*sizeof()), x);\n+\n+    private static final AddressLayout Contents$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Contents\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const char *Contents\n+     * }\n+     *\/\n+    public static final AddressLayout Contents$layout() {\n+        return Contents$LAYOUT;\n@@ -82,3 +123,11 @@\n-    static final VarHandle Contents$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"Contents\"));\n-    public static VarHandle Contents$VH() {\n-        return CXUnsavedFile.Contents$VH;\n+\n+    private static final long Contents$OFFSET = 8;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * const char *Contents\n+     * }\n+     *\/\n+    public static final long Contents$offset() {\n+        return Contents$OFFSET;\n@@ -86,0 +135,1 @@\n+\n@@ -88,2 +138,2 @@\n-     * {@snippet :\n-     * char* Contents;\n+     * {@snippet lang=c :\n+     * const char *Contents\n@@ -92,2 +142,2 @@\n-    public static MemorySegment Contents$get(MemorySegment seg) {\n-        return (java.lang.foreign.MemorySegment)CXUnsavedFile.Contents$VH.get(seg, 0L);\n+    public static MemorySegment Contents(MemorySegment struct) {\n+        return struct.get(Contents$LAYOUT, Contents$OFFSET);\n@@ -95,0 +145,1 @@\n+\n@@ -97,2 +148,2 @@\n-     * {@snippet :\n-     * char* Contents;\n+     * {@snippet lang=c :\n+     * const char *Contents\n@@ -101,5 +152,2 @@\n-    public static void Contents$set(MemorySegment seg, MemorySegment x) {\n-        CXUnsavedFile.Contents$VH.set(seg, 0L, x);\n-    }\n-    public static MemorySegment Contents$get(MemorySegment seg, long index) {\n-        return (java.lang.foreign.MemorySegment)CXUnsavedFile.Contents$VH.get(seg.asSlice(index*sizeof()));\n+    public static void Contents(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Contents$LAYOUT, Contents$OFFSET, fieldValue);\n@@ -107,2 +155,11 @@\n-    public static void Contents$set(MemorySegment seg, long index, MemorySegment x) {\n-        CXUnsavedFile.Contents$VH.set(seg.asSlice(index*sizeof()), x);\n+\n+    private static final OfLong Length$LAYOUT = (OfLong)$LAYOUT.select(groupElement(\"Length\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * unsigned long Length\n+     * }\n+     *\/\n+    public static final OfLong Length$layout() {\n+        return Length$LAYOUT;\n@@ -110,3 +167,11 @@\n-    static final VarHandle Length$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"Length\"));\n-    public static VarHandle Length$VH() {\n-        return CXUnsavedFile.Length$VH;\n+\n+    private static final long Length$OFFSET = 16;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * unsigned long Length\n+     * }\n+     *\/\n+    public static final long Length$offset() {\n+        return Length$OFFSET;\n@@ -114,0 +179,1 @@\n+\n@@ -116,2 +182,2 @@\n-     * {@snippet :\n-     * unsigned long Length;\n+     * {@snippet lang=c :\n+     * unsigned long Length\n@@ -120,2 +186,2 @@\n-    public static long Length$get(MemorySegment seg) {\n-        return (long)CXUnsavedFile.Length$VH.get(seg, 0L);\n+    public static long Length(MemorySegment struct) {\n+        return struct.get(Length$LAYOUT, Length$OFFSET);\n@@ -123,0 +189,1 @@\n+\n@@ -125,2 +192,2 @@\n-     * {@snippet :\n-     * unsigned long Length;\n+     * {@snippet lang=c :\n+     * unsigned long Length\n@@ -129,2 +196,2 @@\n-    public static void Length$set(MemorySegment seg, long x) {\n-        CXUnsavedFile.Length$VH.set(seg, 0L, x);\n+    public static void Length(MemorySegment struct, long fieldValue) {\n+        struct.set(Length$LAYOUT, Length$OFFSET, fieldValue);\n@@ -132,2 +199,7 @@\n-    public static long Length$get(MemorySegment seg, long index) {\n-        return (long)CXUnsavedFile.Length$VH.get(seg.asSlice(index*sizeof()));\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n@@ -135,2 +207,11 @@\n-    public static void Length$set(MemorySegment seg, long index, long x) {\n-        CXUnsavedFile.Length$VH.set(seg.asSlice(index*sizeof()), x);\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n@@ -138,4 +219,7 @@\n-    public static long sizeof() { return $LAYOUT().byteSize(); }\n-    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }\n-    public static MemorySegment allocateArray(long len, SegmentAllocator allocator) {\n-        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n@@ -143,2 +227,0 @@\n-    public static MemorySegment ofAddress(MemorySegment addr, Arena scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }\n-}\n@@ -146,0 +228,16 @@\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXUnsavedFile.java","additions":165,"deletions":67,"binary":false,"changes":232,"status":"modified"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class Constants$root {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private Constants$root() {}\n-    static final OfBoolean C_BOOL$LAYOUT = JAVA_BOOLEAN;\n-    static final OfByte C_CHAR$LAYOUT = JAVA_BYTE;\n-    static final OfShort C_SHORT$LAYOUT = JAVA_SHORT;\n-    static final OfInt C_INT$LAYOUT = JAVA_INT;\n-    static final OfLong C_LONG$LAYOUT = JAVA_LONG;\n-    static final OfLong C_LONG_LONG$LAYOUT = JAVA_LONG;\n-    static final OfFloat C_FLOAT$LAYOUT = JAVA_FLOAT;\n-    static final OfDouble C_DOUBLE$LAYOUT = JAVA_DOUBLE;\n-    static final AddressLayout C_POINTER$LAYOUT = ADDRESS\n-            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, C_CHAR$LAYOUT));\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/Constants$root.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,1 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n+import java.lang.invoke.*;\n@@ -34,0 +32,5 @@\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n@@ -35,1 +38,1 @@\n-public class Index_h  {\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n@@ -37,11 +40,85 @@\n-    public static final OfByte C_CHAR = Constants$root.C_CHAR$LAYOUT;\n-    public static final OfShort C_SHORT = Constants$root.C_SHORT$LAYOUT;\n-    public static final OfInt C_INT = Constants$root.C_INT$LAYOUT;\n-    public static final OfLong C_LONG = Constants$root.C_LONG_LONG$LAYOUT;\n-    public static final OfLong C_LONG_LONG = Constants$root.C_LONG_LONG$LAYOUT;\n-    public static final OfFloat C_FLOAT = Constants$root.C_FLOAT$LAYOUT;\n-    public static final OfDouble C_DOUBLE = Constants$root.C_DOUBLE$LAYOUT;\n-    public static final AddressLayout C_POINTER = Constants$root.C_POINTER$LAYOUT;\n-    \/**\n-     * {@snippet :\n-     * enum CXErrorCode.CXError_Success = 0;\n+public class Index_h {\n+\n+    Index_h() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    static final Arena LIBRARY_ARENA = Arena.ofAuto();\n+    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean(\"jextract.trace.downcalls\");\n+\n+    static void traceDowncall(String name, Object... args) {\n+         String traceArgs = Arrays.stream(args)\n+                       .map(Object::toString)\n+                       .collect(Collectors.joining(\", \"));\n+         System.out.printf(\"%s(%s)\\n\", name, traceArgs);\n+    }\n+\n+    static MemorySegment findOrThrow(String symbol) {\n+        return SYMBOL_LOOKUP.find(symbol)\n+            .orElseThrow(() -> new UnsatisfiedLinkError(\"unresolved symbol: \" + symbol));\n+    }\n+\n+    static MemoryLayout[] inferVariadicLayouts(Object[] varargs) {\n+        MemoryLayout[] result = new MemoryLayout[varargs.length];\n+        for (int i = 0; i < varargs.length; i++) {\n+            result[i] = variadicLayout(varargs[i].getClass());\n+        }\n+        return result;\n+    }\n+\n+    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n+        try {\n+            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static MethodHandle downcallHandleVariadic(String name, FunctionDescriptor baseDesc, MemoryLayout[] variadicLayouts) {\n+        FunctionDescriptor variadicDesc = baseDesc.appendArgumentLayouts(variadicLayouts);\n+        Linker.Option fva = Linker.Option.firstVariadicArg(baseDesc.argumentLayouts().size());\n+        return SYMBOL_LOOKUP.find(name)\n+                .map(addr -> Linker.nativeLinker().downcallHandle(addr, variadicDesc, fva)\n+                        .asSpreader(Object[].class, variadicLayouts.length))\n+                .orElse(null);\n+    }\n+\n+    \/\/ Internals only below this point\n+\n+    private static MemoryLayout variadicLayout(Class<?> c) {\n+        \/\/ apply default argument promotions per C spec\n+        \/\/ note that all primitives are boxed, since they are passed through an Object[]\n+        if (c == Boolean.class || c == Byte.class || c == Character.class || c == Short.class || c == Integer.class) {\n+            return JAVA_INT;\n+        } else if (c == Long.class) {\n+            return JAVA_LONG;\n+        } else if (c == Float.class || c == Double.class) {\n+            return JAVA_DOUBLE;\n+        } else if (MemorySegment.class.isAssignableFrom(c)) {\n+            return ADDRESS;\n+        }\n+        throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n+    }\n+\n+    static {\n+        String libName = System.getProperty(\"os.name\").startsWith(\"Windows\") ? \"libclang\" : \"clang\";\n+        System.loadLibrary(libName);\n+    }\n+\n+    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()\n+            .or(Linker.nativeLinker().defaultLookup());\n+\n+    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n+    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n+    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n+    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n+    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS\n+            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));\n+    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;\n+    private static final int CXError_Success = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXErrorCode.CXError_Success = 0\n@@ -51,1 +128,1 @@\n-        return (int)0L;\n+        return CXError_Success;\n@@ -53,0 +130,1 @@\n+    private static final int CXError_Failure = (int)1L;\n@@ -54,2 +132,2 @@\n-     * {@snippet :\n-     * enum CXErrorCode.CXError_Failure = 1;\n+     * {@snippet lang=c :\n+     * enum CXErrorCode.CXError_Failure = 1\n@@ -59,1 +137,1 @@\n-        return (int)1L;\n+        return CXError_Failure;\n@@ -61,0 +139,1 @@\n+    private static final int CXError_Crashed = (int)2L;\n@@ -62,2 +141,2 @@\n-     * {@snippet :\n-     * enum CXErrorCode.CXError_Crashed = 2;\n+     * {@snippet lang=c :\n+     * enum CXErrorCode.CXError_Crashed = 2\n@@ -67,1 +146,1 @@\n-        return (int)2L;\n+        return CXError_Crashed;\n@@ -69,0 +148,1 @@\n+    private static final int CXError_InvalidArguments = (int)3L;\n@@ -70,2 +150,2 @@\n-     * {@snippet :\n-     * enum CXErrorCode.CXError_InvalidArguments = 3;\n+     * {@snippet lang=c :\n+     * enum CXErrorCode.CXError_InvalidArguments = 3\n@@ -75,1 +155,1 @@\n-        return (int)3L;\n+        return CXError_InvalidArguments;\n@@ -77,0 +157,1 @@\n+    private static final int CXError_ASTReadError = (int)4L;\n@@ -78,2 +159,2 @@\n-     * {@snippet :\n-     * enum CXErrorCode.CXError_ASTReadError = 4;\n+     * {@snippet lang=c :\n+     * enum CXErrorCode.CXError_ASTReadError = 4\n@@ -83,1 +164,22 @@\n-        return (int)4L;\n+        return CXError_ASTReadError;\n+    }\n+\n+    private static class clang_getCString$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_POINTER,\n+            CXString.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCString\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * const char *clang_getCString(CXString string)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_getCString$descriptor() {\n+        return clang_getCString$constants.DESC;\n@@ -85,2 +187,9 @@\n-    public static MethodHandle clang_getCString$MH() {\n-        return RuntimeHelper.requireNonNull(constants$0.clang_getCString$MH,\"clang_getCString\");\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * const char *clang_getCString(CXString string)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getCString$handle() {\n+        return clang_getCString$constants.HANDLE;\n@@ -89,2 +198,2 @@\n-     * {@snippet :\n-     * char* clang_getCString(CXString string);\n+     * {@snippet lang=c :\n+     * const char *clang_getCString(CXString string)\n@@ -94,1 +203,1 @@\n-        var mh$ = clang_getCString$MH();\n+        var mh$ = clang_getCString$constants.HANDLE;\n@@ -96,1 +205,4 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(string);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getCString\", string);\n+            }\n+            return (MemorySegment)mh$.invokeExact(string);\n@@ -98,1 +210,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -101,2 +213,29 @@\n-    public static MethodHandle clang_disposeString$MH() {\n-        return RuntimeHelper.requireNonNull(constants$0.clang_disposeString$MH,\"clang_disposeString\");\n+\n+    private static class clang_disposeString$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            CXString.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_disposeString\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void clang_disposeString(CXString string)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_disposeString$descriptor() {\n+        return clang_disposeString$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void clang_disposeString(CXString string)\n+     * }\n+     *\/\n+    public static MethodHandle clang_disposeString$handle() {\n+        return clang_disposeString$constants.HANDLE;\n@@ -105,2 +244,2 @@\n-     * {@snippet :\n-     * void clang_disposeString(CXString string);\n+     * {@snippet lang=c :\n+     * void clang_disposeString(CXString string)\n@@ -110,1 +249,1 @@\n-        var mh$ = clang_disposeString$MH();\n+        var mh$ = clang_disposeString$constants.HANDLE;\n@@ -112,0 +251,3 @@\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_disposeString\", string);\n+            }\n@@ -114,1 +256,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -118,2 +260,2 @@\n-     * {@snippet :\n-     * typedef void* CXIndex;\n+     * {@snippet lang=c :\n+     * typedef void *CXIndex\n@@ -122,1 +264,1 @@\n-    public static final AddressLayout CXIndex = Constants$root.C_POINTER$LAYOUT;\n+    public static final AddressLayout CXIndex = Index_h.C_POINTER;\n@@ -124,2 +266,2 @@\n-     * {@snippet :\n-     * typedef struct CXTranslationUnitImpl* CXTranslationUnit;\n+     * {@snippet lang=c :\n+     * typedef struct CXTranslationUnitImpl *CXTranslationUnit\n@@ -128,1 +270,2 @@\n-    public static final AddressLayout CXTranslationUnit = Constants$root.C_POINTER$LAYOUT;\n+    public static final AddressLayout CXTranslationUnit = Index_h.C_POINTER;\n+    private static final int CXCursor_ExceptionSpecificationKind_None = (int)0L;\n@@ -130,2 +273,2 @@\n-     * {@snippet :\n-     * enum CXCursor_ExceptionSpecificationKind.CXCursor_ExceptionSpecificationKind_None = 0;\n+     * {@snippet lang=c :\n+     * enum CXCursor_ExceptionSpecificationKind.CXCursor_ExceptionSpecificationKind_None = 0\n@@ -135,1 +278,1 @@\n-        return (int)0L;\n+        return CXCursor_ExceptionSpecificationKind_None;\n@@ -137,0 +280,1 @@\n+    private static final int CXCursor_ExceptionSpecificationKind_DynamicNone = (int)1L;\n@@ -138,2 +282,2 @@\n-     * {@snippet :\n-     * enum CXCursor_ExceptionSpecificationKind.CXCursor_ExceptionSpecificationKind_DynamicNone = 1;\n+     * {@snippet lang=c :\n+     * enum CXCursor_ExceptionSpecificationKind.CXCursor_ExceptionSpecificationKind_DynamicNone = 1\n@@ -143,1 +287,1 @@\n-        return (int)1L;\n+        return CXCursor_ExceptionSpecificationKind_DynamicNone;\n@@ -145,0 +289,1 @@\n+    private static final int CXCursor_ExceptionSpecificationKind_Dynamic = (int)2L;\n@@ -146,2 +291,2 @@\n-     * {@snippet :\n-     * enum CXCursor_ExceptionSpecificationKind.CXCursor_ExceptionSpecificationKind_Dynamic = 2;\n+     * {@snippet lang=c :\n+     * enum CXCursor_ExceptionSpecificationKind.CXCursor_ExceptionSpecificationKind_Dynamic = 2\n@@ -151,1 +296,1 @@\n-        return (int)2L;\n+        return CXCursor_ExceptionSpecificationKind_Dynamic;\n@@ -153,0 +298,1 @@\n+    private static final int CXCursor_ExceptionSpecificationKind_MSAny = (int)3L;\n@@ -154,2 +300,2 @@\n-     * {@snippet :\n-     * enum CXCursor_ExceptionSpecificationKind.CXCursor_ExceptionSpecificationKind_MSAny = 3;\n+     * {@snippet lang=c :\n+     * enum CXCursor_ExceptionSpecificationKind.CXCursor_ExceptionSpecificationKind_MSAny = 3\n@@ -159,1 +305,1 @@\n-        return (int)3L;\n+        return CXCursor_ExceptionSpecificationKind_MSAny;\n@@ -161,0 +307,1 @@\n+    private static final int CXCursor_ExceptionSpecificationKind_BasicNoexcept = (int)4L;\n@@ -162,2 +309,2 @@\n-     * {@snippet :\n-     * enum CXCursor_ExceptionSpecificationKind.CXCursor_ExceptionSpecificationKind_BasicNoexcept = 4;\n+     * {@snippet lang=c :\n+     * enum CXCursor_ExceptionSpecificationKind.CXCursor_ExceptionSpecificationKind_BasicNoexcept = 4\n@@ -167,1 +314,1 @@\n-        return (int)4L;\n+        return CXCursor_ExceptionSpecificationKind_BasicNoexcept;\n@@ -169,0 +316,1 @@\n+    private static final int CXCursor_ExceptionSpecificationKind_ComputedNoexcept = (int)5L;\n@@ -170,2 +318,2 @@\n-     * {@snippet :\n-     * enum CXCursor_ExceptionSpecificationKind.CXCursor_ExceptionSpecificationKind_ComputedNoexcept = 5;\n+     * {@snippet lang=c :\n+     * enum CXCursor_ExceptionSpecificationKind.CXCursor_ExceptionSpecificationKind_ComputedNoexcept = 5\n@@ -175,1 +323,1 @@\n-        return (int)5L;\n+        return CXCursor_ExceptionSpecificationKind_ComputedNoexcept;\n@@ -177,0 +325,1 @@\n+    private static final int CXCursor_ExceptionSpecificationKind_Unevaluated = (int)6L;\n@@ -178,2 +327,2 @@\n-     * {@snippet :\n-     * enum CXCursor_ExceptionSpecificationKind.CXCursor_ExceptionSpecificationKind_Unevaluated = 6;\n+     * {@snippet lang=c :\n+     * enum CXCursor_ExceptionSpecificationKind.CXCursor_ExceptionSpecificationKind_Unevaluated = 6\n@@ -183,1 +332,1 @@\n-        return (int)6L;\n+        return CXCursor_ExceptionSpecificationKind_Unevaluated;\n@@ -185,0 +334,1 @@\n+    private static final int CXCursor_ExceptionSpecificationKind_Uninstantiated = (int)7L;\n@@ -186,2 +336,2 @@\n-     * {@snippet :\n-     * enum CXCursor_ExceptionSpecificationKind.CXCursor_ExceptionSpecificationKind_Uninstantiated = 7;\n+     * {@snippet lang=c :\n+     * enum CXCursor_ExceptionSpecificationKind.CXCursor_ExceptionSpecificationKind_Uninstantiated = 7\n@@ -191,1 +341,1 @@\n-        return (int)7L;\n+        return CXCursor_ExceptionSpecificationKind_Uninstantiated;\n@@ -193,0 +343,1 @@\n+    private static final int CXCursor_ExceptionSpecificationKind_Unparsed = (int)8L;\n@@ -194,2 +345,2 @@\n-     * {@snippet :\n-     * enum CXCursor_ExceptionSpecificationKind.CXCursor_ExceptionSpecificationKind_Unparsed = 8;\n+     * {@snippet lang=c :\n+     * enum CXCursor_ExceptionSpecificationKind.CXCursor_ExceptionSpecificationKind_Unparsed = 8\n@@ -199,1 +350,1 @@\n-        return (int)8L;\n+        return CXCursor_ExceptionSpecificationKind_Unparsed;\n@@ -201,0 +352,1 @@\n+    private static final int CXCursor_ExceptionSpecificationKind_NoThrow = (int)9L;\n@@ -202,2 +354,2 @@\n-     * {@snippet :\n-     * enum CXCursor_ExceptionSpecificationKind.CXCursor_ExceptionSpecificationKind_NoThrow = 9;\n+     * {@snippet lang=c :\n+     * enum CXCursor_ExceptionSpecificationKind.CXCursor_ExceptionSpecificationKind_NoThrow = 9\n@@ -207,1 +359,1 @@\n-        return (int)9L;\n+        return CXCursor_ExceptionSpecificationKind_NoThrow;\n@@ -209,2 +361,11 @@\n-    public static MethodHandle clang_createIndex$MH() {\n-        return RuntimeHelper.requireNonNull(constants$0.clang_createIndex$MH,\"clang_createIndex\");\n+\n+    private static class clang_createIndex$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_POINTER,\n+            Index_h.C_INT,\n+            Index_h.C_INT\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_createIndex\"),\n+                    DESC);\n@@ -212,0 +373,1 @@\n+\n@@ -213,2 +375,3 @@\n-     * {@snippet :\n-     * CXIndex clang_createIndex(int excludeDeclarationsFromPCH, int displayDiagnostics);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXIndex clang_createIndex(int excludeDeclarationsFromPCH, int displayDiagnostics)\n@@ -217,10 +380,2 @@\n-    public static MemorySegment clang_createIndex(int excludeDeclarationsFromPCH, int displayDiagnostics) {\n-        var mh$ = clang_createIndex$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(excludeDeclarationsFromPCH, displayDiagnostics);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_disposeIndex$MH() {\n-        return RuntimeHelper.requireNonNull(constants$0.clang_disposeIndex$MH,\"clang_disposeIndex\");\n+    public static FunctionDescriptor clang_createIndex$descriptor() {\n+        return clang_createIndex$constants.DESC;\n@@ -228,0 +383,1 @@\n+\n@@ -229,2 +385,3 @@\n-     * {@snippet :\n-     * void clang_disposeIndex(CXIndex index);\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXIndex clang_createIndex(int excludeDeclarationsFromPCH, int displayDiagnostics)\n@@ -233,10 +390,2 @@\n-    public static void clang_disposeIndex(MemorySegment index) {\n-        var mh$ = clang_disposeIndex$MH();\n-        try {\n-            mh$.invokeExact(index);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_getFileName$MH() {\n-        return RuntimeHelper.requireNonNull(constants$0.clang_getFileName$MH,\"clang_getFileName\");\n+    public static MethodHandle clang_createIndex$handle() {\n+        return clang_createIndex$constants.HANDLE;\n@@ -245,2 +394,2 @@\n-     * {@snippet :\n-     * CXString clang_getFileName(CXFile SFile);\n+     * {@snippet lang=c :\n+     * CXIndex clang_createIndex(int excludeDeclarationsFromPCH, int displayDiagnostics)\n@@ -249,2 +398,2 @@\n-    public static MemorySegment clang_getFileName(SegmentAllocator allocator, MemorySegment SFile) {\n-        var mh$ = clang_getFileName$MH();\n+    public static MemorySegment clang_createIndex(int excludeDeclarationsFromPCH, int displayDiagnostics) {\n+        var mh$ = clang_createIndex$constants.HANDLE;\n@@ -252,1 +401,4 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, SFile);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_createIndex\", excludeDeclarationsFromPCH, displayDiagnostics);\n+            }\n+            return (MemorySegment)mh$.invokeExact(excludeDeclarationsFromPCH, displayDiagnostics);\n@@ -254,1 +406,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -257,2 +409,9 @@\n-    public static MethodHandle clang_getNullLocation$MH() {\n-        return RuntimeHelper.requireNonNull(constants$0.clang_getNullLocation$MH,\"clang_getNullLocation\");\n+\n+    private static class clang_disposeIndex$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_disposeIndex\"),\n+                    DESC);\n@@ -260,0 +419,1 @@\n+\n@@ -261,2 +421,3 @@\n-     * {@snippet :\n-     * CXSourceLocation clang_getNullLocation();\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void clang_disposeIndex(CXIndex index)\n@@ -265,10 +426,2 @@\n-    public static MemorySegment clang_getNullLocation(SegmentAllocator allocator) {\n-        var mh$ = clang_getNullLocation$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_equalLocations$MH() {\n-        return RuntimeHelper.requireNonNull(constants$1.clang_equalLocations$MH,\"clang_equalLocations\");\n+    public static FunctionDescriptor clang_disposeIndex$descriptor() {\n+        return clang_disposeIndex$constants.DESC;\n@@ -276,0 +429,1 @@\n+\n@@ -277,2 +431,3 @@\n-     * {@snippet :\n-     * unsigned int clang_equalLocations(CXSourceLocation loc1, CXSourceLocation loc2);\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void clang_disposeIndex(CXIndex index)\n@@ -281,10 +436,2 @@\n-    public static int clang_equalLocations(MemorySegment loc1, MemorySegment loc2) {\n-        var mh$ = clang_equalLocations$MH();\n-        try {\n-            return (int)mh$.invokeExact(loc1, loc2);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_getLocation$MH() {\n-        return RuntimeHelper.requireNonNull(constants$1.clang_getLocation$MH,\"clang_getLocation\");\n+    public static MethodHandle clang_disposeIndex$handle() {\n+        return clang_disposeIndex$constants.HANDLE;\n@@ -293,2 +440,2 @@\n-     * {@snippet :\n-     * CXSourceLocation clang_getLocation(CXTranslationUnit tu, CXFile file, unsigned int line, unsigned int column);\n+     * {@snippet lang=c :\n+     * void clang_disposeIndex(CXIndex index)\n@@ -297,2 +444,2 @@\n-    public static MemorySegment clang_getLocation(SegmentAllocator allocator, MemorySegment tu, MemorySegment file, int line, int column) {\n-        var mh$ = clang_getLocation$MH();\n+    public static void clang_disposeIndex(MemorySegment index) {\n+        var mh$ = clang_disposeIndex$constants.HANDLE;\n@@ -300,1 +447,4 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, tu, file, line, column);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_disposeIndex\", index);\n+            }\n+            mh$.invokeExact(index);\n@@ -302,1 +452,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -305,2 +455,10 @@\n-    public static MethodHandle clang_getLocationForOffset$MH() {\n-        return RuntimeHelper.requireNonNull(constants$1.clang_getLocationForOffset$MH,\"clang_getLocationForOffset\");\n+\n+    private static class clang_getFileName$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXString.layout(),\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getFileName\"),\n+                    DESC);\n@@ -308,0 +466,1 @@\n+\n@@ -309,2 +468,3 @@\n-     * {@snippet :\n-     * CXSourceLocation clang_getLocationForOffset(CXTranslationUnit tu, CXFile file, unsigned int offset);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXString clang_getFileName(CXFile SFile)\n@@ -313,10 +473,2 @@\n-    public static MemorySegment clang_getLocationForOffset(SegmentAllocator allocator, MemorySegment tu, MemorySegment file, int offset) {\n-        var mh$ = clang_getLocationForOffset$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, tu, file, offset);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_Location_isInSystemHeader$MH() {\n-        return RuntimeHelper.requireNonNull(constants$1.clang_Location_isInSystemHeader$MH,\"clang_Location_isInSystemHeader\");\n+    public static FunctionDescriptor clang_getFileName$descriptor() {\n+        return clang_getFileName$constants.DESC;\n@@ -324,0 +476,1 @@\n+\n@@ -325,2 +478,3 @@\n-     * {@snippet :\n-     * int clang_Location_isInSystemHeader(CXSourceLocation location);\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXString clang_getFileName(CXFile SFile)\n@@ -329,10 +483,2 @@\n-    public static int clang_Location_isInSystemHeader(MemorySegment location) {\n-        var mh$ = clang_Location_isInSystemHeader$MH();\n-        try {\n-            return (int)mh$.invokeExact(location);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_Location_isFromMainFile$MH() {\n-        return RuntimeHelper.requireNonNull(constants$1.clang_Location_isFromMainFile$MH,\"clang_Location_isFromMainFile\");\n+    public static MethodHandle clang_getFileName$handle() {\n+        return clang_getFileName$constants.HANDLE;\n@@ -341,2 +487,2 @@\n-     * {@snippet :\n-     * int clang_Location_isFromMainFile(CXSourceLocation location);\n+     * {@snippet lang=c :\n+     * CXString clang_getFileName(CXFile SFile)\n@@ -345,2 +491,2 @@\n-    public static int clang_Location_isFromMainFile(MemorySegment location) {\n-        var mh$ = clang_Location_isFromMainFile$MH();\n+    public static MemorySegment clang_getFileName(SegmentAllocator allocator, MemorySegment SFile) {\n+        var mh$ = clang_getFileName$constants.HANDLE;\n@@ -348,1 +494,4 @@\n-            return (int)mh$.invokeExact(location);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getFileName\", allocator, SFile);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, SFile);\n@@ -350,1 +499,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -353,2 +502,8 @@\n-    public static MethodHandle clang_Range_isNull$MH() {\n-        return RuntimeHelper.requireNonNull(constants$1.clang_Range_isNull$MH,\"clang_Range_isNull\");\n+\n+    private static class clang_getNullLocation$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXSourceLocation.layout()    );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getNullLocation\"),\n+                    DESC);\n@@ -356,0 +511,1 @@\n+\n@@ -357,2 +513,3 @@\n-     * {@snippet :\n-     * int clang_Range_isNull(CXSourceRange range);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getNullLocation()\n@@ -361,7 +518,2 @@\n-    public static int clang_Range_isNull(MemorySegment range) {\n-        var mh$ = clang_Range_isNull$MH();\n-        try {\n-            return (int)mh$.invokeExact(range);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static FunctionDescriptor clang_getNullLocation$descriptor() {\n+        return clang_getNullLocation$constants.DESC;\n@@ -369,2 +521,9 @@\n-    public static MethodHandle clang_getExpansionLocation$MH() {\n-        return RuntimeHelper.requireNonNull(constants$2.clang_getExpansionLocation$MH,\"clang_getExpansionLocation\");\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getNullLocation()\n+     * }\n+     *\/\n+    public static MethodHandle clang_getNullLocation$handle() {\n+        return clang_getNullLocation$constants.HANDLE;\n@@ -373,2 +532,2 @@\n-     * {@snippet :\n-     * void clang_getExpansionLocation(CXSourceLocation location, CXFile* file, unsigned int* line, unsigned int* column, unsigned int* offset);\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getNullLocation()\n@@ -377,2 +536,2 @@\n-    public static void clang_getExpansionLocation(MemorySegment location, MemorySegment file, MemorySegment line, MemorySegment column, MemorySegment offset) {\n-        var mh$ = clang_getExpansionLocation$MH();\n+    public static MemorySegment clang_getNullLocation(SegmentAllocator allocator) {\n+        var mh$ = clang_getNullLocation$constants.HANDLE;\n@@ -380,1 +539,4 @@\n-            mh$.invokeExact(location, file, line, column, offset);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getNullLocation\", allocator);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator);\n@@ -382,1 +544,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -385,2 +547,11 @@\n-    public static MethodHandle clang_getSpellingLocation$MH() {\n-        return RuntimeHelper.requireNonNull(constants$2.clang_getSpellingLocation$MH,\"clang_getSpellingLocation\");\n+\n+    private static class clang_equalLocations$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXSourceLocation.layout(),\n+            CXSourceLocation.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_equalLocations\"),\n+                    DESC);\n@@ -388,0 +559,1 @@\n+\n@@ -389,2 +561,3 @@\n-     * {@snippet :\n-     * void clang_getSpellingLocation(CXSourceLocation location, CXFile* file, unsigned int* line, unsigned int* column, unsigned int* offset);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_equalLocations(CXSourceLocation loc1, CXSourceLocation loc2)\n@@ -393,7 +566,2 @@\n-    public static void clang_getSpellingLocation(MemorySegment location, MemorySegment file, MemorySegment line, MemorySegment column, MemorySegment offset) {\n-        var mh$ = clang_getSpellingLocation$MH();\n-        try {\n-            mh$.invokeExact(location, file, line, column, offset);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static FunctionDescriptor clang_equalLocations$descriptor() {\n+        return clang_equalLocations$constants.DESC;\n@@ -401,2 +569,9 @@\n-    public static MethodHandle clang_getFileLocation$MH() {\n-        return RuntimeHelper.requireNonNull(constants$2.clang_getFileLocation$MH,\"clang_getFileLocation\");\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_equalLocations(CXSourceLocation loc1, CXSourceLocation loc2)\n+     * }\n+     *\/\n+    public static MethodHandle clang_equalLocations$handle() {\n+        return clang_equalLocations$constants.HANDLE;\n@@ -405,2 +580,2 @@\n-     * {@snippet :\n-     * void clang_getFileLocation(CXSourceLocation location, CXFile* file, unsigned int* line, unsigned int* column, unsigned int* offset);\n+     * {@snippet lang=c :\n+     * unsigned int clang_equalLocations(CXSourceLocation loc1, CXSourceLocation loc2)\n@@ -409,2 +584,2 @@\n-    public static void clang_getFileLocation(MemorySegment location, MemorySegment file, MemorySegment line, MemorySegment column, MemorySegment offset) {\n-        var mh$ = clang_getFileLocation$MH();\n+    public static int clang_equalLocations(MemorySegment loc1, MemorySegment loc2) {\n+        var mh$ = clang_equalLocations$constants.HANDLE;\n@@ -412,1 +587,4 @@\n-            mh$.invokeExact(location, file, line, column, offset);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_equalLocations\", loc1, loc2);\n+            }\n+            return (int)mh$.invokeExact(loc1, loc2);\n@@ -414,1 +592,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -417,2 +595,13 @@\n-    public static MethodHandle clang_getRangeStart$MH() {\n-        return RuntimeHelper.requireNonNull(constants$2.clang_getRangeStart$MH,\"clang_getRangeStart\");\n+\n+    private static class clang_getLocation$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXSourceLocation.layout(),\n+            Index_h.C_POINTER,\n+            Index_h.C_POINTER,\n+            Index_h.C_INT,\n+            Index_h.C_INT\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getLocation\"),\n+                    DESC);\n@@ -420,0 +609,1 @@\n+\n@@ -421,2 +611,3 @@\n-     * {@snippet :\n-     * CXSourceLocation clang_getRangeStart(CXSourceRange range);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getLocation(CXTranslationUnit tu, CXFile file, unsigned int line, unsigned int column)\n@@ -425,7 +616,2 @@\n-    public static MemorySegment clang_getRangeStart(SegmentAllocator allocator, MemorySegment range) {\n-        var mh$ = clang_getRangeStart$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, range);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static FunctionDescriptor clang_getLocation$descriptor() {\n+        return clang_getLocation$constants.DESC;\n@@ -433,2 +619,9 @@\n-    public static MethodHandle clang_getRangeEnd$MH() {\n-        return RuntimeHelper.requireNonNull(constants$2.clang_getRangeEnd$MH,\"clang_getRangeEnd\");\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getLocation(CXTranslationUnit tu, CXFile file, unsigned int line, unsigned int column)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getLocation$handle() {\n+        return clang_getLocation$constants.HANDLE;\n@@ -437,2 +630,2 @@\n-     * {@snippet :\n-     * CXSourceLocation clang_getRangeEnd(CXSourceRange range);\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getLocation(CXTranslationUnit tu, CXFile file, unsigned int line, unsigned int column)\n@@ -441,2 +634,2 @@\n-    public static MemorySegment clang_getRangeEnd(SegmentAllocator allocator, MemorySegment range) {\n-        var mh$ = clang_getRangeEnd$MH();\n+    public static MemorySegment clang_getLocation(SegmentAllocator allocator, MemorySegment tu, MemorySegment file, int line, int column) {\n+        var mh$ = clang_getLocation$constants.HANDLE;\n@@ -444,1 +637,4 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, range);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getLocation\", allocator, tu, file, line, column);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, tu, file, line, column);\n@@ -446,1 +642,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -449,0 +645,14 @@\n+\n+    private static class clang_getLocationForOffset$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXSourceLocation.layout(),\n+            Index_h.C_POINTER,\n+            Index_h.C_POINTER,\n+            Index_h.C_INT\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getLocationForOffset\"),\n+                    DESC);\n+    }\n+\n@@ -450,2 +660,3 @@\n-     * {@snippet :\n-     * enum CXDiagnosticSeverity.CXDiagnostic_Ignored = 0;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getLocationForOffset(CXTranslationUnit tu, CXFile file, unsigned int offset)\n@@ -454,2 +665,2 @@\n-    public static int CXDiagnostic_Ignored() {\n-        return (int)0L;\n+    public static FunctionDescriptor clang_getLocationForOffset$descriptor() {\n+        return clang_getLocationForOffset$constants.DESC;\n@@ -457,0 +668,1 @@\n+\n@@ -458,2 +670,3 @@\n-     * {@snippet :\n-     * enum CXDiagnosticSeverity.CXDiagnostic_Note = 1;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getLocationForOffset(CXTranslationUnit tu, CXFile file, unsigned int offset)\n@@ -462,2 +675,2 @@\n-    public static int CXDiagnostic_Note() {\n-        return (int)1L;\n+    public static MethodHandle clang_getLocationForOffset$handle() {\n+        return clang_getLocationForOffset$constants.HANDLE;\n@@ -466,2 +679,2 @@\n-     * {@snippet :\n-     * enum CXDiagnosticSeverity.CXDiagnostic_Warning = 2;\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getLocationForOffset(CXTranslationUnit tu, CXFile file, unsigned int offset)\n@@ -470,2 +683,21 @@\n-    public static int CXDiagnostic_Warning() {\n-        return (int)2L;\n+    public static MemorySegment clang_getLocationForOffset(SegmentAllocator allocator, MemorySegment tu, MemorySegment file, int offset) {\n+        var mh$ = clang_getLocationForOffset$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getLocationForOffset\", allocator, tu, file, offset);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, tu, file, offset);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_Location_isInSystemHeader$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXSourceLocation.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Location_isInSystemHeader\"),\n+                    DESC);\n@@ -473,0 +705,1 @@\n+\n@@ -474,2 +707,3 @@\n-     * {@snippet :\n-     * enum CXDiagnosticSeverity.CXDiagnostic_Error = 3;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * int clang_Location_isInSystemHeader(CXSourceLocation location)\n@@ -478,2 +712,2 @@\n-    public static int CXDiagnostic_Error() {\n-        return (int)3L;\n+    public static FunctionDescriptor clang_Location_isInSystemHeader$descriptor() {\n+        return clang_Location_isInSystemHeader$constants.DESC;\n@@ -481,0 +715,1 @@\n+\n@@ -482,2 +717,3 @@\n-     * {@snippet :\n-     * enum CXDiagnosticSeverity.CXDiagnostic_Fatal = 4;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * int clang_Location_isInSystemHeader(CXSourceLocation location)\n@@ -486,5 +722,2 @@\n-    public static int CXDiagnostic_Fatal() {\n-        return (int)4L;\n-    }\n-    public static MethodHandle clang_getChildDiagnostics$MH() {\n-        return RuntimeHelper.requireNonNull(constants$2.clang_getChildDiagnostics$MH,\"clang_getChildDiagnostics\");\n+    public static MethodHandle clang_Location_isInSystemHeader$handle() {\n+        return clang_Location_isInSystemHeader$constants.HANDLE;\n@@ -493,2 +726,2 @@\n-     * {@snippet :\n-     * CXDiagnosticSet clang_getChildDiagnostics(CXDiagnostic D);\n+     * {@snippet lang=c :\n+     * int clang_Location_isInSystemHeader(CXSourceLocation location)\n@@ -497,2 +730,2 @@\n-    public static MemorySegment clang_getChildDiagnostics(MemorySegment D) {\n-        var mh$ = clang_getChildDiagnostics$MH();\n+    public static int clang_Location_isInSystemHeader(MemorySegment location) {\n+        var mh$ = clang_Location_isInSystemHeader$constants.HANDLE;\n@@ -500,1 +733,4 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(D);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_Location_isInSystemHeader\", location);\n+            }\n+            return (int)mh$.invokeExact(location);\n@@ -502,1 +738,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -505,2 +741,10 @@\n-    public static MethodHandle clang_getNumDiagnostics$MH() {\n-        return RuntimeHelper.requireNonNull(constants$3.clang_getNumDiagnostics$MH,\"clang_getNumDiagnostics\");\n+\n+    private static class clang_Location_isFromMainFile$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXSourceLocation.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Location_isFromMainFile\"),\n+                    DESC);\n@@ -508,0 +752,1 @@\n+\n@@ -509,2 +754,3 @@\n-     * {@snippet :\n-     * unsigned int clang_getNumDiagnostics(CXTranslationUnit Unit);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * int clang_Location_isFromMainFile(CXSourceLocation location)\n@@ -513,10 +759,2 @@\n-    public static int clang_getNumDiagnostics(MemorySegment Unit) {\n-        var mh$ = clang_getNumDiagnostics$MH();\n-        try {\n-            return (int)mh$.invokeExact(Unit);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_getDiagnostic$MH() {\n-        return RuntimeHelper.requireNonNull(constants$3.clang_getDiagnostic$MH,\"clang_getDiagnostic\");\n+    public static FunctionDescriptor clang_Location_isFromMainFile$descriptor() {\n+        return clang_Location_isFromMainFile$constants.DESC;\n@@ -524,0 +762,1 @@\n+\n@@ -525,2 +764,3 @@\n-     * {@snippet :\n-     * CXDiagnostic clang_getDiagnostic(CXTranslationUnit Unit, unsigned int Index);\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * int clang_Location_isFromMainFile(CXSourceLocation location)\n@@ -529,10 +769,2 @@\n-    public static MemorySegment clang_getDiagnostic(MemorySegment Unit, int Index) {\n-        var mh$ = clang_getDiagnostic$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(Unit, Index);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_disposeDiagnostic$MH() {\n-        return RuntimeHelper.requireNonNull(constants$3.clang_disposeDiagnostic$MH,\"clang_disposeDiagnostic\");\n+    public static MethodHandle clang_Location_isFromMainFile$handle() {\n+        return clang_Location_isFromMainFile$constants.HANDLE;\n@@ -541,2 +773,2 @@\n-     * {@snippet :\n-     * void clang_disposeDiagnostic(CXDiagnostic Diagnostic);\n+     * {@snippet lang=c :\n+     * int clang_Location_isFromMainFile(CXSourceLocation location)\n@@ -545,2 +777,2 @@\n-    public static void clang_disposeDiagnostic(MemorySegment Diagnostic) {\n-        var mh$ = clang_disposeDiagnostic$MH();\n+    public static int clang_Location_isFromMainFile(MemorySegment location) {\n+        var mh$ = clang_Location_isFromMainFile$constants.HANDLE;\n@@ -548,1 +780,4 @@\n-            mh$.invokeExact(Diagnostic);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_Location_isFromMainFile\", location);\n+            }\n+            return (int)mh$.invokeExact(location);\n@@ -550,1 +785,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -553,7 +788,10 @@\n-    \/**\n-     * {@snippet :\n-     * enum CXDiagnosticDisplayOptions.CXDiagnostic_DisplaySourceLocation = 1;\n-     * }\n-     *\/\n-    public static int CXDiagnostic_DisplaySourceLocation() {\n-        return (int)1L;\n+\n+    private static class clang_Range_isNull$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXSourceRange.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Range_isNull\"),\n+                    DESC);\n@@ -561,0 +799,1 @@\n+\n@@ -562,2 +801,3 @@\n-     * {@snippet :\n-     * enum CXDiagnosticDisplayOptions.CXDiagnostic_DisplayColumn = 2;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * int clang_Range_isNull(CXSourceRange range)\n@@ -566,2 +806,2 @@\n-    public static int CXDiagnostic_DisplayColumn() {\n-        return (int)2L;\n+    public static FunctionDescriptor clang_Range_isNull$descriptor() {\n+        return clang_Range_isNull$constants.DESC;\n@@ -569,0 +809,1 @@\n+\n@@ -570,2 +811,3 @@\n-     * {@snippet :\n-     * enum CXDiagnosticDisplayOptions.CXDiagnostic_DisplaySourceRanges = 4;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * int clang_Range_isNull(CXSourceRange range)\n@@ -574,2 +816,2 @@\n-    public static int CXDiagnostic_DisplaySourceRanges() {\n-        return (int)4L;\n+    public static MethodHandle clang_Range_isNull$handle() {\n+        return clang_Range_isNull$constants.HANDLE;\n@@ -578,2 +820,2 @@\n-     * {@snippet :\n-     * enum CXDiagnosticDisplayOptions.CXDiagnostic_DisplayOption = 8;\n+     * {@snippet lang=c :\n+     * int clang_Range_isNull(CXSourceRange range)\n@@ -582,2 +824,24 @@\n-    public static int CXDiagnostic_DisplayOption() {\n-        return (int)8L;\n+    public static int clang_Range_isNull(MemorySegment range) {\n+        var mh$ = clang_Range_isNull$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_Range_isNull\", range);\n+            }\n+            return (int)mh$.invokeExact(range);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getExpansionLocation$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            CXSourceLocation.layout(),\n+            Index_h.C_POINTER,\n+            Index_h.C_POINTER,\n+            Index_h.C_POINTER,\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getExpansionLocation\"),\n+                    DESC);\n@@ -585,0 +849,1 @@\n+\n@@ -586,2 +851,3 @@\n-     * {@snippet :\n-     * enum CXDiagnosticDisplayOptions.CXDiagnostic_DisplayCategoryId = 16;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void clang_getExpansionLocation(CXSourceLocation location, CXFile *file, unsigned int *line, unsigned int *column, unsigned int *offset)\n@@ -590,2 +856,2 @@\n-    public static int CXDiagnostic_DisplayCategoryId() {\n-        return (int)16L;\n+    public static FunctionDescriptor clang_getExpansionLocation$descriptor() {\n+        return clang_getExpansionLocation$constants.DESC;\n@@ -593,0 +859,1 @@\n+\n@@ -594,2 +861,3 @@\n-     * {@snippet :\n-     * enum CXDiagnosticDisplayOptions.CXDiagnostic_DisplayCategoryName = 32;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void clang_getExpansionLocation(CXSourceLocation location, CXFile *file, unsigned int *line, unsigned int *column, unsigned int *offset)\n@@ -598,5 +866,2 @@\n-    public static int CXDiagnostic_DisplayCategoryName() {\n-        return (int)32L;\n-    }\n-    public static MethodHandle clang_formatDiagnostic$MH() {\n-        return RuntimeHelper.requireNonNull(constants$3.clang_formatDiagnostic$MH,\"clang_formatDiagnostic\");\n+    public static MethodHandle clang_getExpansionLocation$handle() {\n+        return clang_getExpansionLocation$constants.HANDLE;\n@@ -605,2 +870,2 @@\n-     * {@snippet :\n-     * CXString clang_formatDiagnostic(CXDiagnostic Diagnostic, unsigned int Options);\n+     * {@snippet lang=c :\n+     * void clang_getExpansionLocation(CXSourceLocation location, CXFile *file, unsigned int *line, unsigned int *column, unsigned int *offset)\n@@ -609,2 +874,2 @@\n-    public static MemorySegment clang_formatDiagnostic(SegmentAllocator allocator, MemorySegment Diagnostic, int Options) {\n-        var mh$ = clang_formatDiagnostic$MH();\n+    public static void clang_getExpansionLocation(MemorySegment location, MemorySegment file, MemorySegment line, MemorySegment column, MemorySegment offset) {\n+        var mh$ = clang_getExpansionLocation$constants.HANDLE;\n@@ -612,1 +877,4 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, Diagnostic, Options);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getExpansionLocation\", location, file, line, column, offset);\n+            }\n+            mh$.invokeExact(location, file, line, column, offset);\n@@ -614,1 +882,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -617,2 +885,13 @@\n-    public static MethodHandle clang_defaultDiagnosticDisplayOptions$MH() {\n-        return RuntimeHelper.requireNonNull(constants$3.clang_defaultDiagnosticDisplayOptions$MH,\"clang_defaultDiagnosticDisplayOptions\");\n+\n+    private static class clang_getSpellingLocation$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            CXSourceLocation.layout(),\n+            Index_h.C_POINTER,\n+            Index_h.C_POINTER,\n+            Index_h.C_POINTER,\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getSpellingLocation\"),\n+                    DESC);\n@@ -620,0 +899,1 @@\n+\n@@ -621,2 +901,3 @@\n-     * {@snippet :\n-     * unsigned int clang_defaultDiagnosticDisplayOptions();\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void clang_getSpellingLocation(CXSourceLocation location, CXFile *file, unsigned int *line, unsigned int *column, unsigned int *offset)\n@@ -625,7 +906,2 @@\n-    public static int clang_defaultDiagnosticDisplayOptions() {\n-        var mh$ = clang_defaultDiagnosticDisplayOptions$MH();\n-        try {\n-            return (int)mh$.invokeExact();\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static FunctionDescriptor clang_getSpellingLocation$descriptor() {\n+        return clang_getSpellingLocation$constants.DESC;\n@@ -633,2 +909,9 @@\n-    public static MethodHandle clang_getDiagnosticSeverity$MH() {\n-        return RuntimeHelper.requireNonNull(constants$3.clang_getDiagnosticSeverity$MH,\"clang_getDiagnosticSeverity\");\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void clang_getSpellingLocation(CXSourceLocation location, CXFile *file, unsigned int *line, unsigned int *column, unsigned int *offset)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getSpellingLocation$handle() {\n+        return clang_getSpellingLocation$constants.HANDLE;\n@@ -637,2 +920,2 @@\n-     * {@snippet :\n-     * enum CXDiagnosticSeverity clang_getDiagnosticSeverity(CXDiagnostic);\n+     * {@snippet lang=c :\n+     * void clang_getSpellingLocation(CXSourceLocation location, CXFile *file, unsigned int *line, unsigned int *column, unsigned int *offset)\n@@ -641,2 +924,2 @@\n-    public static int clang_getDiagnosticSeverity(MemorySegment x0) {\n-        var mh$ = clang_getDiagnosticSeverity$MH();\n+    public static void clang_getSpellingLocation(MemorySegment location, MemorySegment file, MemorySegment line, MemorySegment column, MemorySegment offset) {\n+        var mh$ = clang_getSpellingLocation$constants.HANDLE;\n@@ -644,1 +927,4 @@\n-            return (int)mh$.invokeExact(x0);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getSpellingLocation\", location, file, line, column, offset);\n+            }\n+            mh$.invokeExact(location, file, line, column, offset);\n@@ -646,1 +932,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -649,2 +935,13 @@\n-    public static MethodHandle clang_getDiagnosticLocation$MH() {\n-        return RuntimeHelper.requireNonNull(constants$4.clang_getDiagnosticLocation$MH,\"clang_getDiagnosticLocation\");\n+\n+    private static class clang_getFileLocation$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            CXSourceLocation.layout(),\n+            Index_h.C_POINTER,\n+            Index_h.C_POINTER,\n+            Index_h.C_POINTER,\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getFileLocation\"),\n+                    DESC);\n@@ -652,0 +949,1 @@\n+\n@@ -653,2 +951,3 @@\n-     * {@snippet :\n-     * CXSourceLocation clang_getDiagnosticLocation(CXDiagnostic);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void clang_getFileLocation(CXSourceLocation location, CXFile *file, unsigned int *line, unsigned int *column, unsigned int *offset)\n@@ -657,7 +956,2 @@\n-    public static MemorySegment clang_getDiagnosticLocation(SegmentAllocator allocator, MemorySegment x1) {\n-        var mh$ = clang_getDiagnosticLocation$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static FunctionDescriptor clang_getFileLocation$descriptor() {\n+        return clang_getFileLocation$constants.DESC;\n@@ -665,2 +959,9 @@\n-    public static MethodHandle clang_getDiagnosticSpelling$MH() {\n-        return RuntimeHelper.requireNonNull(constants$4.clang_getDiagnosticSpelling$MH,\"clang_getDiagnosticSpelling\");\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void clang_getFileLocation(CXSourceLocation location, CXFile *file, unsigned int *line, unsigned int *column, unsigned int *offset)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getFileLocation$handle() {\n+        return clang_getFileLocation$constants.HANDLE;\n@@ -669,2 +970,2 @@\n-     * {@snippet :\n-     * CXString clang_getDiagnosticSpelling(CXDiagnostic);\n+     * {@snippet lang=c :\n+     * void clang_getFileLocation(CXSourceLocation location, CXFile *file, unsigned int *line, unsigned int *column, unsigned int *offset)\n@@ -673,2 +974,2 @@\n-    public static MemorySegment clang_getDiagnosticSpelling(SegmentAllocator allocator, MemorySegment x1) {\n-        var mh$ = clang_getDiagnosticSpelling$MH();\n+    public static void clang_getFileLocation(MemorySegment location, MemorySegment file, MemorySegment line, MemorySegment column, MemorySegment offset) {\n+        var mh$ = clang_getFileLocation$constants.HANDLE;\n@@ -676,1 +977,4 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getFileLocation\", location, file, line, column, offset);\n+            }\n+            mh$.invokeExact(location, file, line, column, offset);\n@@ -678,1 +982,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -681,7 +985,10 @@\n-    \/**\n-     * {@snippet :\n-     * enum CXTranslationUnit_Flags.CXTranslationUnit_None = 0;\n-     * }\n-     *\/\n-    public static int CXTranslationUnit_None() {\n-        return (int)0L;\n+\n+    private static class clang_getRangeStart$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXSourceLocation.layout(),\n+            CXSourceRange.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getRangeStart\"),\n+                    DESC);\n@@ -689,0 +996,1 @@\n+\n@@ -690,2 +998,3 @@\n-     * {@snippet :\n-     * enum CXTranslationUnit_Flags.CXTranslationUnit_DetailedPreprocessingRecord = 1;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getRangeStart(CXSourceRange range)\n@@ -694,2 +1003,2 @@\n-    public static int CXTranslationUnit_DetailedPreprocessingRecord() {\n-        return (int)1L;\n+    public static FunctionDescriptor clang_getRangeStart$descriptor() {\n+        return clang_getRangeStart$constants.DESC;\n@@ -697,0 +1006,1 @@\n+\n@@ -698,2 +1008,3 @@\n-     * {@snippet :\n-     * enum CXTranslationUnit_Flags.CXTranslationUnit_Incomplete = 2;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getRangeStart(CXSourceRange range)\n@@ -702,2 +1013,2 @@\n-    public static int CXTranslationUnit_Incomplete() {\n-        return (int)2L;\n+    public static MethodHandle clang_getRangeStart$handle() {\n+        return clang_getRangeStart$constants.HANDLE;\n@@ -706,2 +1017,2 @@\n-     * {@snippet :\n-     * enum CXTranslationUnit_Flags.CXTranslationUnit_PrecompiledPreamble = 4;\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getRangeStart(CXSourceRange range)\n@@ -710,2 +1021,21 @@\n-    public static int CXTranslationUnit_PrecompiledPreamble() {\n-        return (int)4L;\n+    public static MemorySegment clang_getRangeStart(SegmentAllocator allocator, MemorySegment range) {\n+        var mh$ = clang_getRangeStart$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getRangeStart\", allocator, range);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, range);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getRangeEnd$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXSourceLocation.layout(),\n+            CXSourceRange.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getRangeEnd\"),\n+                    DESC);\n@@ -713,0 +1043,1 @@\n+\n@@ -714,2 +1045,3 @@\n-     * {@snippet :\n-     * enum CXTranslationUnit_Flags.CXTranslationUnit_CacheCompletionResults = 8;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getRangeEnd(CXSourceRange range)\n@@ -718,2 +1050,2 @@\n-    public static int CXTranslationUnit_CacheCompletionResults() {\n-        return (int)8L;\n+    public static FunctionDescriptor clang_getRangeEnd$descriptor() {\n+        return clang_getRangeEnd$constants.DESC;\n@@ -721,0 +1053,1 @@\n+\n@@ -722,2 +1055,3 @@\n-     * {@snippet :\n-     * enum CXTranslationUnit_Flags.CXTranslationUnit_ForSerialization = 16;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getRangeEnd(CXSourceRange range)\n@@ -726,2 +1060,2 @@\n-    public static int CXTranslationUnit_ForSerialization() {\n-        return (int)16L;\n+    public static MethodHandle clang_getRangeEnd$handle() {\n+        return clang_getRangeEnd$constants.HANDLE;\n@@ -730,2 +1064,2 @@\n-     * {@snippet :\n-     * enum CXTranslationUnit_Flags.CXTranslationUnit_CXXChainedPCH = 32;\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getRangeEnd(CXSourceRange range)\n@@ -734,2 +1068,10 @@\n-    public static int CXTranslationUnit_CXXChainedPCH() {\n-        return (int)32L;\n+    public static MemorySegment clang_getRangeEnd(SegmentAllocator allocator, MemorySegment range) {\n+        var mh$ = clang_getRangeEnd$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getRangeEnd\", allocator, range);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, range);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n@@ -737,0 +1079,1 @@\n+    private static final int CXDiagnostic_Ignored = (int)0L;\n@@ -738,2 +1081,2 @@\n-     * {@snippet :\n-     * enum CXTranslationUnit_Flags.CXTranslationUnit_SkipFunctionBodies = 64;\n+     * {@snippet lang=c :\n+     * enum CXDiagnosticSeverity.CXDiagnostic_Ignored = 0\n@@ -742,2 +1085,2 @@\n-    public static int CXTranslationUnit_SkipFunctionBodies() {\n-        return (int)64L;\n+    public static int CXDiagnostic_Ignored() {\n+        return CXDiagnostic_Ignored;\n@@ -745,0 +1088,1 @@\n+    private static final int CXDiagnostic_Note = (int)1L;\n@@ -746,2 +1090,2 @@\n-     * {@snippet :\n-     * enum CXTranslationUnit_Flags.CXTranslationUnit_IncludeBriefCommentsInCodeCompletion = 128;\n+     * {@snippet lang=c :\n+     * enum CXDiagnosticSeverity.CXDiagnostic_Note = 1\n@@ -750,2 +1094,2 @@\n-    public static int CXTranslationUnit_IncludeBriefCommentsInCodeCompletion() {\n-        return (int)128L;\n+    public static int CXDiagnostic_Note() {\n+        return CXDiagnostic_Note;\n@@ -753,0 +1097,1 @@\n+    private static final int CXDiagnostic_Warning = (int)2L;\n@@ -754,2 +1099,2 @@\n-     * {@snippet :\n-     * enum CXTranslationUnit_Flags.CXTranslationUnit_CreatePreambleOnFirstParse = 256;\n+     * {@snippet lang=c :\n+     * enum CXDiagnosticSeverity.CXDiagnostic_Warning = 2\n@@ -758,2 +1103,2 @@\n-    public static int CXTranslationUnit_CreatePreambleOnFirstParse() {\n-        return (int)256L;\n+    public static int CXDiagnostic_Warning() {\n+        return CXDiagnostic_Warning;\n@@ -761,0 +1106,1 @@\n+    private static final int CXDiagnostic_Error = (int)3L;\n@@ -762,2 +1108,2 @@\n-     * {@snippet :\n-     * enum CXTranslationUnit_Flags.CXTranslationUnit_KeepGoing = 512;\n+     * {@snippet lang=c :\n+     * enum CXDiagnosticSeverity.CXDiagnostic_Error = 3\n@@ -766,2 +1112,2 @@\n-    public static int CXTranslationUnit_KeepGoing() {\n-        return (int)512L;\n+    public static int CXDiagnostic_Error() {\n+        return CXDiagnostic_Error;\n@@ -769,0 +1115,1 @@\n+    private static final int CXDiagnostic_Fatal = (int)4L;\n@@ -770,2 +1117,2 @@\n-     * {@snippet :\n-     * enum CXTranslationUnit_Flags.CXTranslationUnit_SingleFileParse = 1024;\n+     * {@snippet lang=c :\n+     * enum CXDiagnosticSeverity.CXDiagnostic_Fatal = 4\n@@ -774,2 +1121,13 @@\n-    public static int CXTranslationUnit_SingleFileParse() {\n-        return (int)1024L;\n+    public static int CXDiagnostic_Fatal() {\n+        return CXDiagnostic_Fatal;\n+    }\n+\n+    private static class clang_getChildDiagnostics$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_POINTER,\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getChildDiagnostics\"),\n+                    DESC);\n@@ -777,0 +1135,1 @@\n+\n@@ -778,2 +1137,3 @@\n-     * {@snippet :\n-     * enum CXTranslationUnit_Flags.CXTranslationUnit_LimitSkipFunctionBodiesToPreamble = 2048;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXDiagnosticSet clang_getChildDiagnostics(CXDiagnostic D)\n@@ -782,2 +1142,2 @@\n-    public static int CXTranslationUnit_LimitSkipFunctionBodiesToPreamble() {\n-        return (int)2048L;\n+    public static FunctionDescriptor clang_getChildDiagnostics$descriptor() {\n+        return clang_getChildDiagnostics$constants.DESC;\n@@ -785,0 +1145,1 @@\n+\n@@ -786,2 +1147,3 @@\n-     * {@snippet :\n-     * enum CXTranslationUnit_Flags.CXTranslationUnit_IncludeAttributedTypes = 4096;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXDiagnosticSet clang_getChildDiagnostics(CXDiagnostic D)\n@@ -790,2 +1152,2 @@\n-    public static int CXTranslationUnit_IncludeAttributedTypes() {\n-        return (int)4096L;\n+    public static MethodHandle clang_getChildDiagnostics$handle() {\n+        return clang_getChildDiagnostics$constants.HANDLE;\n@@ -794,2 +1156,2 @@\n-     * {@snippet :\n-     * enum CXTranslationUnit_Flags.CXTranslationUnit_VisitImplicitAttributes = 8192;\n+     * {@snippet lang=c :\n+     * CXDiagnosticSet clang_getChildDiagnostics(CXDiagnostic D)\n@@ -798,2 +1160,21 @@\n-    public static int CXTranslationUnit_VisitImplicitAttributes() {\n-        return (int)8192L;\n+    public static MemorySegment clang_getChildDiagnostics(MemorySegment D) {\n+        var mh$ = clang_getChildDiagnostics$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getChildDiagnostics\", D);\n+            }\n+            return (MemorySegment)mh$.invokeExact(D);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getNumDiagnostics$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getNumDiagnostics\"),\n+                    DESC);\n@@ -801,0 +1182,1 @@\n+\n@@ -802,2 +1184,3 @@\n-     * {@snippet :\n-     * enum CXTranslationUnit_Flags.CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles = 16384;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_getNumDiagnostics(CXTranslationUnit Unit)\n@@ -806,2 +1189,2 @@\n-    public static int CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles() {\n-        return (int)16384L;\n+    public static FunctionDescriptor clang_getNumDiagnostics$descriptor() {\n+        return clang_getNumDiagnostics$constants.DESC;\n@@ -809,0 +1192,1 @@\n+\n@@ -810,2 +1194,3 @@\n-     * {@snippet :\n-     * enum CXTranslationUnit_Flags.CXTranslationUnit_RetainExcludedConditionalBlocks = 32768;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_getNumDiagnostics(CXTranslationUnit Unit)\n@@ -814,5 +1199,2 @@\n-    public static int CXTranslationUnit_RetainExcludedConditionalBlocks() {\n-        return (int)32768L;\n-    }\n-    public static MethodHandle clang_parseTranslationUnit$MH() {\n-        return RuntimeHelper.requireNonNull(constants$4.clang_parseTranslationUnit$MH,\"clang_parseTranslationUnit\");\n+    public static MethodHandle clang_getNumDiagnostics$handle() {\n+        return clang_getNumDiagnostics$constants.HANDLE;\n@@ -821,2 +1203,2 @@\n-     * {@snippet :\n-     * CXTranslationUnit clang_parseTranslationUnit(CXIndex CIdx, char* source_filename, char** command_line_args, int num_command_line_args, struct CXUnsavedFile* unsaved_files, unsigned int num_unsaved_files, unsigned int options);\n+     * {@snippet lang=c :\n+     * unsigned int clang_getNumDiagnostics(CXTranslationUnit Unit)\n@@ -825,2 +1207,2 @@\n-    public static MemorySegment clang_parseTranslationUnit(MemorySegment CIdx, MemorySegment source_filename, MemorySegment command_line_args, int num_command_line_args, MemorySegment unsaved_files, int num_unsaved_files, int options) {\n-        var mh$ = clang_parseTranslationUnit$MH();\n+    public static int clang_getNumDiagnostics(MemorySegment Unit) {\n+        var mh$ = clang_getNumDiagnostics$constants.HANDLE;\n@@ -828,1 +1210,4 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(CIdx, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, options);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getNumDiagnostics\", Unit);\n+            }\n+            return (int)mh$.invokeExact(Unit);\n@@ -830,1 +1215,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -833,2 +1218,11 @@\n-    public static MethodHandle clang_parseTranslationUnit2$MH() {\n-        return RuntimeHelper.requireNonNull(constants$4.clang_parseTranslationUnit2$MH,\"clang_parseTranslationUnit2\");\n+\n+    private static class clang_getDiagnostic$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_POINTER,\n+            Index_h.C_POINTER,\n+            Index_h.C_INT\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getDiagnostic\"),\n+                    DESC);\n@@ -836,0 +1230,1 @@\n+\n@@ -837,2 +1232,3 @@\n-     * {@snippet :\n-     * enum CXErrorCode clang_parseTranslationUnit2(CXIndex CIdx, char* source_filename, char** command_line_args, int num_command_line_args, struct CXUnsavedFile* unsaved_files, unsigned int num_unsaved_files, unsigned int options, CXTranslationUnit* out_TU);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXDiagnostic clang_getDiagnostic(CXTranslationUnit Unit, unsigned int Index)\n@@ -841,7 +1237,2 @@\n-    public static int clang_parseTranslationUnit2(MemorySegment CIdx, MemorySegment source_filename, MemorySegment command_line_args, int num_command_line_args, MemorySegment unsaved_files, int num_unsaved_files, int options, MemorySegment out_TU) {\n-        var mh$ = clang_parseTranslationUnit2$MH();\n-        try {\n-            return (int)mh$.invokeExact(CIdx, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, options, out_TU);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static FunctionDescriptor clang_getDiagnostic$descriptor() {\n+        return clang_getDiagnostic$constants.DESC;\n@@ -849,0 +1240,1 @@\n+\n@@ -850,2 +1242,3 @@\n-     * {@snippet :\n-     * enum CXSaveTranslationUnit_Flags.CXSaveTranslationUnit_None = 0;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXDiagnostic clang_getDiagnostic(CXTranslationUnit Unit, unsigned int Index)\n@@ -854,2 +1247,2 @@\n-    public static int CXSaveTranslationUnit_None() {\n-        return (int)0L;\n+    public static MethodHandle clang_getDiagnostic$handle() {\n+        return clang_getDiagnostic$constants.HANDLE;\n@@ -858,2 +1251,2 @@\n-     * {@snippet :\n-     * enum CXSaveError.CXSaveError_None = 0;\n+     * {@snippet lang=c :\n+     * CXDiagnostic clang_getDiagnostic(CXTranslationUnit Unit, unsigned int Index)\n@@ -862,2 +1255,10 @@\n-    public static int CXSaveError_None() {\n-        return (int)0L;\n+    public static MemorySegment clang_getDiagnostic(MemorySegment Unit, int Index) {\n+        var mh$ = clang_getDiagnostic$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getDiagnostic\", Unit, Index);\n+            }\n+            return (MemorySegment)mh$.invokeExact(Unit, Index);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n@@ -865,7 +1266,9 @@\n-    \/**\n-     * {@snippet :\n-     * enum CXSaveError.CXSaveError_Unknown = 1;\n-     * }\n-     *\/\n-    public static int CXSaveError_Unknown() {\n-        return (int)1L;\n+\n+    private static class clang_disposeDiagnostic$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_disposeDiagnostic\"),\n+                    DESC);\n@@ -873,0 +1276,1 @@\n+\n@@ -874,2 +1278,3 @@\n-     * {@snippet :\n-     * enum CXSaveError.CXSaveError_TranslationErrors = 2;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void clang_disposeDiagnostic(CXDiagnostic Diagnostic)\n@@ -878,2 +1283,2 @@\n-    public static int CXSaveError_TranslationErrors() {\n-        return (int)2L;\n+    public static FunctionDescriptor clang_disposeDiagnostic$descriptor() {\n+        return clang_disposeDiagnostic$constants.DESC;\n@@ -881,0 +1286,1 @@\n+\n@@ -882,2 +1288,3 @@\n-     * {@snippet :\n-     * enum CXSaveError.CXSaveError_InvalidTU = 3;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void clang_disposeDiagnostic(CXDiagnostic Diagnostic)\n@@ -886,5 +1293,2 @@\n-    public static int CXSaveError_InvalidTU() {\n-        return (int)3L;\n-    }\n-    public static MethodHandle clang_saveTranslationUnit$MH() {\n-        return RuntimeHelper.requireNonNull(constants$4.clang_saveTranslationUnit$MH,\"clang_saveTranslationUnit\");\n+    public static MethodHandle clang_disposeDiagnostic$handle() {\n+        return clang_disposeDiagnostic$constants.HANDLE;\n@@ -893,2 +1297,2 @@\n-     * {@snippet :\n-     * int clang_saveTranslationUnit(CXTranslationUnit TU, char* FileName, unsigned int options);\n+     * {@snippet lang=c :\n+     * void clang_disposeDiagnostic(CXDiagnostic Diagnostic)\n@@ -897,2 +1301,2 @@\n-    public static int clang_saveTranslationUnit(MemorySegment TU, MemorySegment FileName, int options) {\n-        var mh$ = clang_saveTranslationUnit$MH();\n+    public static void clang_disposeDiagnostic(MemorySegment Diagnostic) {\n+        var mh$ = clang_disposeDiagnostic$constants.HANDLE;\n@@ -900,1 +1304,4 @@\n-            return (int)mh$.invokeExact(TU, FileName, options);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_disposeDiagnostic\", Diagnostic);\n+            }\n+            mh$.invokeExact(Diagnostic);\n@@ -902,1 +1309,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -905,3 +1312,1 @@\n-    public static MethodHandle clang_disposeTranslationUnit$MH() {\n-        return RuntimeHelper.requireNonNull(constants$4.clang_disposeTranslationUnit$MH,\"clang_disposeTranslationUnit\");\n-    }\n+    private static final int CXDiagnostic_DisplaySourceLocation = (int)1L;\n@@ -909,2 +1314,2 @@\n-     * {@snippet :\n-     * void clang_disposeTranslationUnit(CXTranslationUnit);\n+     * {@snippet lang=c :\n+     * enum CXDiagnosticDisplayOptions.CXDiagnostic_DisplaySourceLocation = 1\n@@ -913,7 +1318,2 @@\n-    public static void clang_disposeTranslationUnit(MemorySegment x0) {\n-        var mh$ = clang_disposeTranslationUnit$MH();\n-        try {\n-            mh$.invokeExact(x0);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static int CXDiagnostic_DisplaySourceLocation() {\n+        return CXDiagnostic_DisplaySourceLocation;\n@@ -921,0 +1321,1 @@\n+    private static final int CXDiagnostic_DisplayColumn = (int)2L;\n@@ -922,2 +1323,2 @@\n-     * {@snippet :\n-     * enum CXReparse_Flags.CXReparse_None = 0;\n+     * {@snippet lang=c :\n+     * enum CXDiagnosticDisplayOptions.CXDiagnostic_DisplayColumn = 2\n@@ -926,5 +1327,2 @@\n-    public static int CXReparse_None() {\n-        return (int)0L;\n-    }\n-    public static MethodHandle clang_defaultReparseOptions$MH() {\n-        return RuntimeHelper.requireNonNull(constants$5.clang_defaultReparseOptions$MH,\"clang_defaultReparseOptions\");\n+    public static int CXDiagnostic_DisplayColumn() {\n+        return CXDiagnostic_DisplayColumn;\n@@ -932,0 +1330,1 @@\n+    private static final int CXDiagnostic_DisplaySourceRanges = (int)4L;\n@@ -933,2 +1332,2 @@\n-     * {@snippet :\n-     * unsigned int clang_defaultReparseOptions(CXTranslationUnit TU);\n+     * {@snippet lang=c :\n+     * enum CXDiagnosticDisplayOptions.CXDiagnostic_DisplaySourceRanges = 4\n@@ -937,10 +1336,2 @@\n-    public static int clang_defaultReparseOptions(MemorySegment TU) {\n-        var mh$ = clang_defaultReparseOptions$MH();\n-        try {\n-            return (int)mh$.invokeExact(TU);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_reparseTranslationUnit$MH() {\n-        return RuntimeHelper.requireNonNull(constants$5.clang_reparseTranslationUnit$MH,\"clang_reparseTranslationUnit\");\n+    public static int CXDiagnostic_DisplaySourceRanges() {\n+        return CXDiagnostic_DisplaySourceRanges;\n@@ -948,0 +1339,1 @@\n+    private static final int CXDiagnostic_DisplayOption = (int)8L;\n@@ -949,2 +1341,2 @@\n-     * {@snippet :\n-     * int clang_reparseTranslationUnit(CXTranslationUnit TU, unsigned int num_unsaved_files, struct CXUnsavedFile* unsaved_files, unsigned int options);\n+     * {@snippet lang=c :\n+     * enum CXDiagnosticDisplayOptions.CXDiagnostic_DisplayOption = 8\n@@ -953,7 +1345,2 @@\n-    public static int clang_reparseTranslationUnit(MemorySegment TU, int num_unsaved_files, MemorySegment unsaved_files, int options) {\n-        var mh$ = clang_reparseTranslationUnit$MH();\n-        try {\n-            return (int)mh$.invokeExact(TU, num_unsaved_files, unsaved_files, options);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static int CXDiagnostic_DisplayOption() {\n+        return CXDiagnostic_DisplayOption;\n@@ -961,0 +1348,1 @@\n+    private static final int CXDiagnostic_DisplayCategoryId = (int)16L;\n@@ -962,2 +1350,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_UnexposedDecl = 1;\n+     * {@snippet lang=c :\n+     * enum CXDiagnosticDisplayOptions.CXDiagnostic_DisplayCategoryId = 16\n@@ -966,2 +1354,2 @@\n-    public static int CXCursor_UnexposedDecl() {\n-        return (int)1L;\n+    public static int CXDiagnostic_DisplayCategoryId() {\n+        return CXDiagnostic_DisplayCategoryId;\n@@ -969,0 +1357,1 @@\n+    private static final int CXDiagnostic_DisplayCategoryName = (int)32L;\n@@ -970,2 +1359,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_StructDecl = 2;\n+     * {@snippet lang=c :\n+     * enum CXDiagnosticDisplayOptions.CXDiagnostic_DisplayCategoryName = 32\n@@ -974,2 +1363,14 @@\n-    public static int CXCursor_StructDecl() {\n-        return (int)2L;\n+    public static int CXDiagnostic_DisplayCategoryName() {\n+        return CXDiagnostic_DisplayCategoryName;\n+    }\n+\n+    private static class clang_formatDiagnostic$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXString.layout(),\n+            Index_h.C_POINTER,\n+            Index_h.C_INT\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_formatDiagnostic\"),\n+                    DESC);\n@@ -977,0 +1378,1 @@\n+\n@@ -978,2 +1380,3 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_UnionDecl = 3;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXString clang_formatDiagnostic(CXDiagnostic Diagnostic, unsigned int Options)\n@@ -982,2 +1385,2 @@\n-    public static int CXCursor_UnionDecl() {\n-        return (int)3L;\n+    public static FunctionDescriptor clang_formatDiagnostic$descriptor() {\n+        return clang_formatDiagnostic$constants.DESC;\n@@ -985,0 +1388,1 @@\n+\n@@ -986,2 +1390,3 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ClassDecl = 4;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXString clang_formatDiagnostic(CXDiagnostic Diagnostic, unsigned int Options)\n@@ -990,2 +1395,2 @@\n-    public static int CXCursor_ClassDecl() {\n-        return (int)4L;\n+    public static MethodHandle clang_formatDiagnostic$handle() {\n+        return clang_formatDiagnostic$constants.HANDLE;\n@@ -994,2 +1399,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_EnumDecl = 5;\n+     * {@snippet lang=c :\n+     * CXString clang_formatDiagnostic(CXDiagnostic Diagnostic, unsigned int Options)\n@@ -998,2 +1403,19 @@\n-    public static int CXCursor_EnumDecl() {\n-        return (int)5L;\n+    public static MemorySegment clang_formatDiagnostic(SegmentAllocator allocator, MemorySegment Diagnostic, int Options) {\n+        var mh$ = clang_formatDiagnostic$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_formatDiagnostic\", allocator, Diagnostic, Options);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, Diagnostic, Options);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_defaultDiagnosticDisplayOptions$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT    );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_defaultDiagnosticDisplayOptions\"),\n+                    DESC);\n@@ -1001,0 +1423,1 @@\n+\n@@ -1002,2 +1425,3 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_FieldDecl = 6;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_defaultDiagnosticDisplayOptions()\n@@ -1006,2 +1430,2 @@\n-    public static int CXCursor_FieldDecl() {\n-        return (int)6L;\n+    public static FunctionDescriptor clang_defaultDiagnosticDisplayOptions$descriptor() {\n+        return clang_defaultDiagnosticDisplayOptions$constants.DESC;\n@@ -1009,0 +1433,1 @@\n+\n@@ -1010,2 +1435,3 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_EnumConstantDecl = 7;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_defaultDiagnosticDisplayOptions()\n@@ -1014,2 +1440,2 @@\n-    public static int CXCursor_EnumConstantDecl() {\n-        return (int)7L;\n+    public static MethodHandle clang_defaultDiagnosticDisplayOptions$handle() {\n+        return clang_defaultDiagnosticDisplayOptions$constants.HANDLE;\n@@ -1018,2 +1444,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_FunctionDecl = 8;\n+     * {@snippet lang=c :\n+     * unsigned int clang_defaultDiagnosticDisplayOptions()\n@@ -1022,2 +1448,10 @@\n-    public static int CXCursor_FunctionDecl() {\n-        return (int)8L;\n+    public static int clang_defaultDiagnosticDisplayOptions() {\n+        var mh$ = clang_defaultDiagnosticDisplayOptions$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_defaultDiagnosticDisplayOptions\");\n+            }\n+            return (int)mh$.invokeExact();\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n@@ -1025,0 +1459,12 @@\n+\n+    private static class clang_getDiagnosticSeverity$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getDiagnosticSeverity\"),\n+                    DESC);\n+    }\n+\n@@ -1026,2 +1472,3 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_VarDecl = 9;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * enum CXDiagnosticSeverity clang_getDiagnosticSeverity(CXDiagnostic)\n@@ -1030,2 +1477,2 @@\n-    public static int CXCursor_VarDecl() {\n-        return (int)9L;\n+    public static FunctionDescriptor clang_getDiagnosticSeverity$descriptor() {\n+        return clang_getDiagnosticSeverity$constants.DESC;\n@@ -1033,0 +1480,1 @@\n+\n@@ -1034,2 +1482,3 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ParmDecl = 10;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * enum CXDiagnosticSeverity clang_getDiagnosticSeverity(CXDiagnostic)\n@@ -1038,2 +1487,2 @@\n-    public static int CXCursor_ParmDecl() {\n-        return (int)10L;\n+    public static MethodHandle clang_getDiagnosticSeverity$handle() {\n+        return clang_getDiagnosticSeverity$constants.HANDLE;\n@@ -1042,2 +1491,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCInterfaceDecl = 11;\n+     * {@snippet lang=c :\n+     * enum CXDiagnosticSeverity clang_getDiagnosticSeverity(CXDiagnostic)\n@@ -1046,2 +1495,21 @@\n-    public static int CXCursor_ObjCInterfaceDecl() {\n-        return (int)11L;\n+    public static int clang_getDiagnosticSeverity(MemorySegment x0) {\n+        var mh$ = clang_getDiagnosticSeverity$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getDiagnosticSeverity\", x0);\n+            }\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getDiagnosticLocation$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXSourceLocation.layout(),\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getDiagnosticLocation\"),\n+                    DESC);\n@@ -1049,0 +1517,1 @@\n+\n@@ -1050,2 +1519,3 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCCategoryDecl = 12;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getDiagnosticLocation(CXDiagnostic)\n@@ -1054,2 +1524,2 @@\n-    public static int CXCursor_ObjCCategoryDecl() {\n-        return (int)12L;\n+    public static FunctionDescriptor clang_getDiagnosticLocation$descriptor() {\n+        return clang_getDiagnosticLocation$constants.DESC;\n@@ -1057,0 +1527,1 @@\n+\n@@ -1058,2 +1529,3 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCProtocolDecl = 13;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getDiagnosticLocation(CXDiagnostic)\n@@ -1062,2 +1534,2 @@\n-    public static int CXCursor_ObjCProtocolDecl() {\n-        return (int)13L;\n+    public static MethodHandle clang_getDiagnosticLocation$handle() {\n+        return clang_getDiagnosticLocation$constants.HANDLE;\n@@ -1066,2 +1538,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCPropertyDecl = 14;\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getDiagnosticLocation(CXDiagnostic)\n@@ -1070,2 +1542,10 @@\n-    public static int CXCursor_ObjCPropertyDecl() {\n-        return (int)14L;\n+    public static MemorySegment clang_getDiagnosticLocation(SegmentAllocator allocator, MemorySegment x0) {\n+        var mh$ = clang_getDiagnosticLocation$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getDiagnosticLocation\", allocator, x0);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, x0);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n@@ -1073,0 +1553,12 @@\n+\n+    private static class clang_getDiagnosticSpelling$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXString.layout(),\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getDiagnosticSpelling\"),\n+                    DESC);\n+    }\n+\n@@ -1074,2 +1566,3 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCIvarDecl = 15;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXString clang_getDiagnosticSpelling(CXDiagnostic)\n@@ -1078,2 +1571,2 @@\n-    public static int CXCursor_ObjCIvarDecl() {\n-        return (int)15L;\n+    public static FunctionDescriptor clang_getDiagnosticSpelling$descriptor() {\n+        return clang_getDiagnosticSpelling$constants.DESC;\n@@ -1081,0 +1574,1 @@\n+\n@@ -1082,2 +1576,3 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCInstanceMethodDecl = 16;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXString clang_getDiagnosticSpelling(CXDiagnostic)\n@@ -1086,2 +1581,2 @@\n-    public static int CXCursor_ObjCInstanceMethodDecl() {\n-        return (int)16L;\n+    public static MethodHandle clang_getDiagnosticSpelling$handle() {\n+        return clang_getDiagnosticSpelling$constants.HANDLE;\n@@ -1090,2 +1585,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCClassMethodDecl = 17;\n+     * {@snippet lang=c :\n+     * CXString clang_getDiagnosticSpelling(CXDiagnostic)\n@@ -1094,2 +1589,10 @@\n-    public static int CXCursor_ObjCClassMethodDecl() {\n-        return (int)17L;\n+    public static MemorySegment clang_getDiagnosticSpelling(SegmentAllocator allocator, MemorySegment x0) {\n+        var mh$ = clang_getDiagnosticSpelling$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getDiagnosticSpelling\", allocator, x0);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, x0);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n@@ -1097,0 +1600,1 @@\n+    private static final int CXTranslationUnit_None = (int)0L;\n@@ -1098,2 +1602,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCImplementationDecl = 18;\n+     * {@snippet lang=c :\n+     * enum CXTranslationUnit_Flags.CXTranslationUnit_None = 0\n@@ -1102,2 +1606,2 @@\n-    public static int CXCursor_ObjCImplementationDecl() {\n-        return (int)18L;\n+    public static int CXTranslationUnit_None() {\n+        return CXTranslationUnit_None;\n@@ -1105,0 +1609,1 @@\n+    private static final int CXTranslationUnit_DetailedPreprocessingRecord = (int)1L;\n@@ -1106,2 +1611,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCCategoryImplDecl = 19;\n+     * {@snippet lang=c :\n+     * enum CXTranslationUnit_Flags.CXTranslationUnit_DetailedPreprocessingRecord = 1\n@@ -1110,2 +1615,2 @@\n-    public static int CXCursor_ObjCCategoryImplDecl() {\n-        return (int)19L;\n+    public static int CXTranslationUnit_DetailedPreprocessingRecord() {\n+        return CXTranslationUnit_DetailedPreprocessingRecord;\n@@ -1113,0 +1618,1 @@\n+    private static final int CXTranslationUnit_Incomplete = (int)2L;\n@@ -1114,2 +1620,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_TypedefDecl = 20;\n+     * {@snippet lang=c :\n+     * enum CXTranslationUnit_Flags.CXTranslationUnit_Incomplete = 2\n@@ -1118,2 +1624,2 @@\n-    public static int CXCursor_TypedefDecl() {\n-        return (int)20L;\n+    public static int CXTranslationUnit_Incomplete() {\n+        return CXTranslationUnit_Incomplete;\n@@ -1121,0 +1627,1 @@\n+    private static final int CXTranslationUnit_PrecompiledPreamble = (int)4L;\n@@ -1122,2 +1629,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CXXMethod = 21;\n+     * {@snippet lang=c :\n+     * enum CXTranslationUnit_Flags.CXTranslationUnit_PrecompiledPreamble = 4\n@@ -1126,2 +1633,2 @@\n-    public static int CXCursor_CXXMethod() {\n-        return (int)21L;\n+    public static int CXTranslationUnit_PrecompiledPreamble() {\n+        return CXTranslationUnit_PrecompiledPreamble;\n@@ -1129,0 +1636,1 @@\n+    private static final int CXTranslationUnit_CacheCompletionResults = (int)8L;\n@@ -1130,2 +1638,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_Namespace = 22;\n+     * {@snippet lang=c :\n+     * enum CXTranslationUnit_Flags.CXTranslationUnit_CacheCompletionResults = 8\n@@ -1134,2 +1642,2 @@\n-    public static int CXCursor_Namespace() {\n-        return (int)22L;\n+    public static int CXTranslationUnit_CacheCompletionResults() {\n+        return CXTranslationUnit_CacheCompletionResults;\n@@ -1137,0 +1645,1 @@\n+    private static final int CXTranslationUnit_ForSerialization = (int)16L;\n@@ -1138,2 +1647,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_LinkageSpec = 23;\n+     * {@snippet lang=c :\n+     * enum CXTranslationUnit_Flags.CXTranslationUnit_ForSerialization = 16\n@@ -1142,2 +1651,2 @@\n-    public static int CXCursor_LinkageSpec() {\n-        return (int)23L;\n+    public static int CXTranslationUnit_ForSerialization() {\n+        return CXTranslationUnit_ForSerialization;\n@@ -1145,0 +1654,1 @@\n+    private static final int CXTranslationUnit_CXXChainedPCH = (int)32L;\n@@ -1146,2 +1656,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_Constructor = 24;\n+     * {@snippet lang=c :\n+     * enum CXTranslationUnit_Flags.CXTranslationUnit_CXXChainedPCH = 32\n@@ -1150,2 +1660,2 @@\n-    public static int CXCursor_Constructor() {\n-        return (int)24L;\n+    public static int CXTranslationUnit_CXXChainedPCH() {\n+        return CXTranslationUnit_CXXChainedPCH;\n@@ -1153,0 +1663,1 @@\n+    private static final int CXTranslationUnit_SkipFunctionBodies = (int)64L;\n@@ -1154,2 +1665,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_Destructor = 25;\n+     * {@snippet lang=c :\n+     * enum CXTranslationUnit_Flags.CXTranslationUnit_SkipFunctionBodies = 64\n@@ -1158,2 +1669,2 @@\n-    public static int CXCursor_Destructor() {\n-        return (int)25L;\n+    public static int CXTranslationUnit_SkipFunctionBodies() {\n+        return CXTranslationUnit_SkipFunctionBodies;\n@@ -1161,0 +1672,1 @@\n+    private static final int CXTranslationUnit_IncludeBriefCommentsInCodeCompletion = (int)128L;\n@@ -1162,2 +1674,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ConversionFunction = 26;\n+     * {@snippet lang=c :\n+     * enum CXTranslationUnit_Flags.CXTranslationUnit_IncludeBriefCommentsInCodeCompletion = 128\n@@ -1166,2 +1678,2 @@\n-    public static int CXCursor_ConversionFunction() {\n-        return (int)26L;\n+    public static int CXTranslationUnit_IncludeBriefCommentsInCodeCompletion() {\n+        return CXTranslationUnit_IncludeBriefCommentsInCodeCompletion;\n@@ -1169,0 +1681,1 @@\n+    private static final int CXTranslationUnit_CreatePreambleOnFirstParse = (int)256L;\n@@ -1170,2 +1683,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_TemplateTypeParameter = 27;\n+     * {@snippet lang=c :\n+     * enum CXTranslationUnit_Flags.CXTranslationUnit_CreatePreambleOnFirstParse = 256\n@@ -1174,2 +1687,2 @@\n-    public static int CXCursor_TemplateTypeParameter() {\n-        return (int)27L;\n+    public static int CXTranslationUnit_CreatePreambleOnFirstParse() {\n+        return CXTranslationUnit_CreatePreambleOnFirstParse;\n@@ -1177,0 +1690,1 @@\n+    private static final int CXTranslationUnit_KeepGoing = (int)512L;\n@@ -1178,2 +1692,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_NonTypeTemplateParameter = 28;\n+     * {@snippet lang=c :\n+     * enum CXTranslationUnit_Flags.CXTranslationUnit_KeepGoing = 512\n@@ -1182,2 +1696,2 @@\n-    public static int CXCursor_NonTypeTemplateParameter() {\n-        return (int)28L;\n+    public static int CXTranslationUnit_KeepGoing() {\n+        return CXTranslationUnit_KeepGoing;\n@@ -1185,0 +1699,1 @@\n+    private static final int CXTranslationUnit_SingleFileParse = (int)1024L;\n@@ -1186,2 +1701,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_TemplateTemplateParameter = 29;\n+     * {@snippet lang=c :\n+     * enum CXTranslationUnit_Flags.CXTranslationUnit_SingleFileParse = 1024\n@@ -1190,2 +1705,2 @@\n-    public static int CXCursor_TemplateTemplateParameter() {\n-        return (int)29L;\n+    public static int CXTranslationUnit_SingleFileParse() {\n+        return CXTranslationUnit_SingleFileParse;\n@@ -1193,0 +1708,1 @@\n+    private static final int CXTranslationUnit_LimitSkipFunctionBodiesToPreamble = (int)2048L;\n@@ -1194,2 +1710,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_FunctionTemplate = 30;\n+     * {@snippet lang=c :\n+     * enum CXTranslationUnit_Flags.CXTranslationUnit_LimitSkipFunctionBodiesToPreamble = 2048\n@@ -1198,2 +1714,2 @@\n-    public static int CXCursor_FunctionTemplate() {\n-        return (int)30L;\n+    public static int CXTranslationUnit_LimitSkipFunctionBodiesToPreamble() {\n+        return CXTranslationUnit_LimitSkipFunctionBodiesToPreamble;\n@@ -1201,0 +1717,1 @@\n+    private static final int CXTranslationUnit_IncludeAttributedTypes = (int)4096L;\n@@ -1202,2 +1719,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ClassTemplate = 31;\n+     * {@snippet lang=c :\n+     * enum CXTranslationUnit_Flags.CXTranslationUnit_IncludeAttributedTypes = 4096\n@@ -1206,2 +1723,2 @@\n-    public static int CXCursor_ClassTemplate() {\n-        return (int)31L;\n+    public static int CXTranslationUnit_IncludeAttributedTypes() {\n+        return CXTranslationUnit_IncludeAttributedTypes;\n@@ -1209,0 +1726,1 @@\n+    private static final int CXTranslationUnit_VisitImplicitAttributes = (int)8192L;\n@@ -1210,2 +1728,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ClassTemplatePartialSpecialization = 32;\n+     * {@snippet lang=c :\n+     * enum CXTranslationUnit_Flags.CXTranslationUnit_VisitImplicitAttributes = 8192\n@@ -1214,2 +1732,2 @@\n-    public static int CXCursor_ClassTemplatePartialSpecialization() {\n-        return (int)32L;\n+    public static int CXTranslationUnit_VisitImplicitAttributes() {\n+        return CXTranslationUnit_VisitImplicitAttributes;\n@@ -1217,0 +1735,1 @@\n+    private static final int CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles = (int)16384L;\n@@ -1218,2 +1737,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_NamespaceAlias = 33;\n+     * {@snippet lang=c :\n+     * enum CXTranslationUnit_Flags.CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles = 16384\n@@ -1222,2 +1741,2 @@\n-    public static int CXCursor_NamespaceAlias() {\n-        return (int)33L;\n+    public static int CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles() {\n+        return CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles;\n@@ -1225,0 +1744,1 @@\n+    private static final int CXTranslationUnit_RetainExcludedConditionalBlocks = (int)32768L;\n@@ -1226,2 +1746,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_UsingDirective = 34;\n+     * {@snippet lang=c :\n+     * enum CXTranslationUnit_Flags.CXTranslationUnit_RetainExcludedConditionalBlocks = 32768\n@@ -1230,2 +1750,19 @@\n-    public static int CXCursor_UsingDirective() {\n-        return (int)34L;\n+    public static int CXTranslationUnit_RetainExcludedConditionalBlocks() {\n+        return CXTranslationUnit_RetainExcludedConditionalBlocks;\n+    }\n+\n+    private static class clang_parseTranslationUnit$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_POINTER,\n+            Index_h.C_POINTER,\n+            Index_h.C_POINTER,\n+            Index_h.C_POINTER,\n+            Index_h.C_INT,\n+            Index_h.C_POINTER,\n+            Index_h.C_INT,\n+            Index_h.C_INT\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_parseTranslationUnit\"),\n+                    DESC);\n@@ -1233,0 +1770,1 @@\n+\n@@ -1234,2 +1772,3 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_UsingDeclaration = 35;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXTranslationUnit clang_parseTranslationUnit(CXIndex CIdx, const char *source_filename, const char *const *command_line_args, int num_command_line_args, struct CXUnsavedFile *unsaved_files, unsigned int num_unsaved_files, unsigned int options)\n@@ -1238,2 +1777,2 @@\n-    public static int CXCursor_UsingDeclaration() {\n-        return (int)35L;\n+    public static FunctionDescriptor clang_parseTranslationUnit$descriptor() {\n+        return clang_parseTranslationUnit$constants.DESC;\n@@ -1241,0 +1780,1 @@\n+\n@@ -1242,2 +1782,3 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_TypeAliasDecl = 36;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXTranslationUnit clang_parseTranslationUnit(CXIndex CIdx, const char *source_filename, const char *const *command_line_args, int num_command_line_args, struct CXUnsavedFile *unsaved_files, unsigned int num_unsaved_files, unsigned int options)\n@@ -1246,2 +1787,2 @@\n-    public static int CXCursor_TypeAliasDecl() {\n-        return (int)36L;\n+    public static MethodHandle clang_parseTranslationUnit$handle() {\n+        return clang_parseTranslationUnit$constants.HANDLE;\n@@ -1250,2 +1791,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCSynthesizeDecl = 37;\n+     * {@snippet lang=c :\n+     * CXTranslationUnit clang_parseTranslationUnit(CXIndex CIdx, const char *source_filename, const char *const *command_line_args, int num_command_line_args, struct CXUnsavedFile *unsaved_files, unsigned int num_unsaved_files, unsigned int options)\n@@ -1254,2 +1795,28 @@\n-    public static int CXCursor_ObjCSynthesizeDecl() {\n-        return (int)37L;\n+    public static MemorySegment clang_parseTranslationUnit(MemorySegment CIdx, MemorySegment source_filename, MemorySegment command_line_args, int num_command_line_args, MemorySegment unsaved_files, int num_unsaved_files, int options) {\n+        var mh$ = clang_parseTranslationUnit$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_parseTranslationUnit\", CIdx, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, options);\n+            }\n+            return (MemorySegment)mh$.invokeExact(CIdx, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, options);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_parseTranslationUnit2$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            Index_h.C_POINTER,\n+            Index_h.C_POINTER,\n+            Index_h.C_POINTER,\n+            Index_h.C_INT,\n+            Index_h.C_POINTER,\n+            Index_h.C_INT,\n+            Index_h.C_INT,\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_parseTranslationUnit2\"),\n+                    DESC);\n@@ -1257,0 +1824,1 @@\n+\n@@ -1258,2 +1826,3 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCDynamicDecl = 38;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * enum CXErrorCode clang_parseTranslationUnit2(CXIndex CIdx, const char *source_filename, const char *const *command_line_args, int num_command_line_args, struct CXUnsavedFile *unsaved_files, unsigned int num_unsaved_files, unsigned int options, CXTranslationUnit *out_TU)\n@@ -1262,2 +1831,2 @@\n-    public static int CXCursor_ObjCDynamicDecl() {\n-        return (int)38L;\n+    public static FunctionDescriptor clang_parseTranslationUnit2$descriptor() {\n+        return clang_parseTranslationUnit2$constants.DESC;\n@@ -1265,0 +1834,1 @@\n+\n@@ -1266,2 +1836,3 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CXXAccessSpecifier = 39;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * enum CXErrorCode clang_parseTranslationUnit2(CXIndex CIdx, const char *source_filename, const char *const *command_line_args, int num_command_line_args, struct CXUnsavedFile *unsaved_files, unsigned int num_unsaved_files, unsigned int options, CXTranslationUnit *out_TU)\n@@ -1270,2 +1841,2 @@\n-    public static int CXCursor_CXXAccessSpecifier() {\n-        return (int)39L;\n+    public static MethodHandle clang_parseTranslationUnit2$handle() {\n+        return clang_parseTranslationUnit2$constants.HANDLE;\n@@ -1274,2 +1845,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_FirstDecl = 1;\n+     * {@snippet lang=c :\n+     * enum CXErrorCode clang_parseTranslationUnit2(CXIndex CIdx, const char *source_filename, const char *const *command_line_args, int num_command_line_args, struct CXUnsavedFile *unsaved_files, unsigned int num_unsaved_files, unsigned int options, CXTranslationUnit *out_TU)\n@@ -1278,2 +1849,10 @@\n-    public static int CXCursor_FirstDecl() {\n-        return (int)1L;\n+    public static int clang_parseTranslationUnit2(MemorySegment CIdx, MemorySegment source_filename, MemorySegment command_line_args, int num_command_line_args, MemorySegment unsaved_files, int num_unsaved_files, int options, MemorySegment out_TU) {\n+        var mh$ = clang_parseTranslationUnit2$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_parseTranslationUnit2\", CIdx, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, options, out_TU);\n+            }\n+            return (int)mh$.invokeExact(CIdx, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, options, out_TU);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n@@ -1281,0 +1860,1 @@\n+    private static final int CXSaveTranslationUnit_None = (int)0L;\n@@ -1282,2 +1862,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_LastDecl = 39;\n+     * {@snippet lang=c :\n+     * enum CXSaveTranslationUnit_Flags.CXSaveTranslationUnit_None = 0\n@@ -1286,2 +1866,2 @@\n-    public static int CXCursor_LastDecl() {\n-        return (int)39L;\n+    public static int CXSaveTranslationUnit_None() {\n+        return CXSaveTranslationUnit_None;\n@@ -1289,0 +1869,1 @@\n+    private static final int CXSaveError_None = (int)0L;\n@@ -1290,2 +1871,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_FirstRef = 40;\n+     * {@snippet lang=c :\n+     * enum CXSaveError.CXSaveError_None = 0\n@@ -1294,2 +1875,2 @@\n-    public static int CXCursor_FirstRef() {\n-        return (int)40L;\n+    public static int CXSaveError_None() {\n+        return CXSaveError_None;\n@@ -1297,0 +1878,1 @@\n+    private static final int CXSaveError_Unknown = (int)1L;\n@@ -1298,2 +1880,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCSuperClassRef = 40;\n+     * {@snippet lang=c :\n+     * enum CXSaveError.CXSaveError_Unknown = 1\n@@ -1302,2 +1884,2 @@\n-    public static int CXCursor_ObjCSuperClassRef() {\n-        return (int)40L;\n+    public static int CXSaveError_Unknown() {\n+        return CXSaveError_Unknown;\n@@ -1305,0 +1887,1 @@\n+    private static final int CXSaveError_TranslationErrors = (int)2L;\n@@ -1306,2 +1889,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCProtocolRef = 41;\n+     * {@snippet lang=c :\n+     * enum CXSaveError.CXSaveError_TranslationErrors = 2\n@@ -1310,2 +1893,2 @@\n-    public static int CXCursor_ObjCProtocolRef() {\n-        return (int)41L;\n+    public static int CXSaveError_TranslationErrors() {\n+        return CXSaveError_TranslationErrors;\n@@ -1313,0 +1896,1 @@\n+    private static final int CXSaveError_InvalidTU = (int)3L;\n@@ -1314,2 +1898,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCClassRef = 42;\n+     * {@snippet lang=c :\n+     * enum CXSaveError.CXSaveError_InvalidTU = 3\n@@ -1318,2 +1902,2 @@\n-    public static int CXCursor_ObjCClassRef() {\n-        return (int)42L;\n+    public static int CXSaveError_InvalidTU() {\n+        return CXSaveError_InvalidTU;\n@@ -1321,0 +1905,14 @@\n+\n+    private static class clang_saveTranslationUnit$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            Index_h.C_POINTER,\n+            Index_h.C_POINTER,\n+            Index_h.C_INT\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_saveTranslationUnit\"),\n+                    DESC);\n+    }\n+\n@@ -1322,2 +1920,3 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_TypeRef = 43;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * int clang_saveTranslationUnit(CXTranslationUnit TU, const char *FileName, unsigned int options)\n@@ -1326,2 +1925,2 @@\n-    public static int CXCursor_TypeRef() {\n-        return (int)43L;\n+    public static FunctionDescriptor clang_saveTranslationUnit$descriptor() {\n+        return clang_saveTranslationUnit$constants.DESC;\n@@ -1329,0 +1928,1 @@\n+\n@@ -1330,2 +1930,3 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CXXBaseSpecifier = 44;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * int clang_saveTranslationUnit(CXTranslationUnit TU, const char *FileName, unsigned int options)\n@@ -1334,2 +1935,2 @@\n-    public static int CXCursor_CXXBaseSpecifier() {\n-        return (int)44L;\n+    public static MethodHandle clang_saveTranslationUnit$handle() {\n+        return clang_saveTranslationUnit$constants.HANDLE;\n@@ -1338,2 +1939,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_TemplateRef = 45;\n+     * {@snippet lang=c :\n+     * int clang_saveTranslationUnit(CXTranslationUnit TU, const char *FileName, unsigned int options)\n@@ -1342,2 +1943,20 @@\n-    public static int CXCursor_TemplateRef() {\n-        return (int)45L;\n+    public static int clang_saveTranslationUnit(MemorySegment TU, MemorySegment FileName, int options) {\n+        var mh$ = clang_saveTranslationUnit$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_saveTranslationUnit\", TU, FileName, options);\n+            }\n+            return (int)mh$.invokeExact(TU, FileName, options);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_disposeTranslationUnit$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_disposeTranslationUnit\"),\n+                    DESC);\n@@ -1345,0 +1964,1 @@\n+\n@@ -1346,2 +1966,3 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_NamespaceRef = 46;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void clang_disposeTranslationUnit(CXTranslationUnit)\n@@ -1350,2 +1971,2 @@\n-    public static int CXCursor_NamespaceRef() {\n-        return (int)46L;\n+    public static FunctionDescriptor clang_disposeTranslationUnit$descriptor() {\n+        return clang_disposeTranslationUnit$constants.DESC;\n@@ -1353,0 +1974,1 @@\n+\n@@ -1354,2 +1976,3 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_MemberRef = 47;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void clang_disposeTranslationUnit(CXTranslationUnit)\n@@ -1358,2 +1981,2 @@\n-    public static int CXCursor_MemberRef() {\n-        return (int)47L;\n+    public static MethodHandle clang_disposeTranslationUnit$handle() {\n+        return clang_disposeTranslationUnit$constants.HANDLE;\n@@ -1362,2 +1985,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_LabelRef = 48;\n+     * {@snippet lang=c :\n+     * void clang_disposeTranslationUnit(CXTranslationUnit)\n@@ -1366,2 +1989,10 @@\n-    public static int CXCursor_LabelRef() {\n-        return (int)48L;\n+    public static void clang_disposeTranslationUnit(MemorySegment x0) {\n+        var mh$ = clang_disposeTranslationUnit$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_disposeTranslationUnit\", x0);\n+            }\n+            mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n@@ -1369,0 +2000,1 @@\n+    private static final int CXReparse_None = (int)0L;\n@@ -1370,2 +2002,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OverloadedDeclRef = 49;\n+     * {@snippet lang=c :\n+     * enum CXReparse_Flags.CXReparse_None = 0\n@@ -1374,2 +2006,2 @@\n-    public static int CXCursor_OverloadedDeclRef() {\n-        return (int)49L;\n+    public static int CXReparse_None() {\n+        return CXReparse_None;\n@@ -1377,0 +2009,12 @@\n+\n+    private static class clang_defaultReparseOptions$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_defaultReparseOptions\"),\n+                    DESC);\n+    }\n+\n@@ -1378,2 +2022,3 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_VariableRef = 50;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_defaultReparseOptions(CXTranslationUnit TU)\n@@ -1382,2 +2027,2 @@\n-    public static int CXCursor_VariableRef() {\n-        return (int)50L;\n+    public static FunctionDescriptor clang_defaultReparseOptions$descriptor() {\n+        return clang_defaultReparseOptions$constants.DESC;\n@@ -1385,0 +2030,1 @@\n+\n@@ -1386,2 +2032,3 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_LastRef = 50;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_defaultReparseOptions(CXTranslationUnit TU)\n@@ -1390,2 +2037,2 @@\n-    public static int CXCursor_LastRef() {\n-        return (int)50L;\n+    public static MethodHandle clang_defaultReparseOptions$handle() {\n+        return clang_defaultReparseOptions$constants.HANDLE;\n@@ -1394,2 +2041,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_FirstInvalid = 70;\n+     * {@snippet lang=c :\n+     * unsigned int clang_defaultReparseOptions(CXTranslationUnit TU)\n@@ -1398,2 +2045,24 @@\n-    public static int CXCursor_FirstInvalid() {\n-        return (int)70L;\n+    public static int clang_defaultReparseOptions(MemorySegment TU) {\n+        var mh$ = clang_defaultReparseOptions$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_defaultReparseOptions\", TU);\n+            }\n+            return (int)mh$.invokeExact(TU);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_reparseTranslationUnit$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            Index_h.C_POINTER,\n+            Index_h.C_INT,\n+            Index_h.C_POINTER,\n+            Index_h.C_INT\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_reparseTranslationUnit\"),\n+                    DESC);\n@@ -1401,0 +2070,1 @@\n+\n@@ -1402,2 +2072,3 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_InvalidFile = 70;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * int clang_reparseTranslationUnit(CXTranslationUnit TU, unsigned int num_unsaved_files, struct CXUnsavedFile *unsaved_files, unsigned int options)\n@@ -1406,2 +2077,2 @@\n-    public static int CXCursor_InvalidFile() {\n-        return (int)70L;\n+    public static FunctionDescriptor clang_reparseTranslationUnit$descriptor() {\n+        return clang_reparseTranslationUnit$constants.DESC;\n@@ -1409,0 +2080,1 @@\n+\n@@ -1410,2 +2082,3 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_NoDeclFound = 71;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * int clang_reparseTranslationUnit(CXTranslationUnit TU, unsigned int num_unsaved_files, struct CXUnsavedFile *unsaved_files, unsigned int options)\n@@ -1414,2 +2087,2 @@\n-    public static int CXCursor_NoDeclFound() {\n-        return (int)71L;\n+    public static MethodHandle clang_reparseTranslationUnit$handle() {\n+        return clang_reparseTranslationUnit$constants.HANDLE;\n@@ -1418,2 +2091,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_NotImplemented = 72;\n+     * {@snippet lang=c :\n+     * int clang_reparseTranslationUnit(CXTranslationUnit TU, unsigned int num_unsaved_files, struct CXUnsavedFile *unsaved_files, unsigned int options)\n@@ -1422,2 +2095,10 @@\n-    public static int CXCursor_NotImplemented() {\n-        return (int)72L;\n+    public static int clang_reparseTranslationUnit(MemorySegment TU, int num_unsaved_files, MemorySegment unsaved_files, int options) {\n+        var mh$ = clang_reparseTranslationUnit$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_reparseTranslationUnit\", TU, num_unsaved_files, unsaved_files, options);\n+            }\n+            return (int)mh$.invokeExact(TU, num_unsaved_files, unsaved_files, options);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n@@ -1425,0 +2106,1 @@\n+    private static final int CXCursor_UnexposedDecl = (int)1L;\n@@ -1426,2 +2108,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_InvalidCode = 73;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_UnexposedDecl = 1\n@@ -1430,2 +2112,2 @@\n-    public static int CXCursor_InvalidCode() {\n-        return (int)73L;\n+    public static int CXCursor_UnexposedDecl() {\n+        return CXCursor_UnexposedDecl;\n@@ -1433,0 +2115,1 @@\n+    private static final int CXCursor_StructDecl = (int)2L;\n@@ -1434,2 +2117,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_LastInvalid = 73;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_StructDecl = 2\n@@ -1438,2 +2121,2 @@\n-    public static int CXCursor_LastInvalid() {\n-        return (int)73L;\n+    public static int CXCursor_StructDecl() {\n+        return CXCursor_StructDecl;\n@@ -1441,0 +2124,1 @@\n+    private static final int CXCursor_UnionDecl = (int)3L;\n@@ -1442,2 +2126,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_FirstExpr = 100;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_UnionDecl = 3\n@@ -1446,2 +2130,2 @@\n-    public static int CXCursor_FirstExpr() {\n-        return (int)100L;\n+    public static int CXCursor_UnionDecl() {\n+        return CXCursor_UnionDecl;\n@@ -1449,0 +2133,1 @@\n+    private static final int CXCursor_ClassDecl = (int)4L;\n@@ -1450,2 +2135,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_UnexposedExpr = 100;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ClassDecl = 4\n@@ -1454,2 +2139,2 @@\n-    public static int CXCursor_UnexposedExpr() {\n-        return (int)100L;\n+    public static int CXCursor_ClassDecl() {\n+        return CXCursor_ClassDecl;\n@@ -1457,0 +2142,1 @@\n+    private static final int CXCursor_EnumDecl = (int)5L;\n@@ -1458,2 +2144,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_DeclRefExpr = 101;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_EnumDecl = 5\n@@ -1462,2 +2148,2 @@\n-    public static int CXCursor_DeclRefExpr() {\n-        return (int)101L;\n+    public static int CXCursor_EnumDecl() {\n+        return CXCursor_EnumDecl;\n@@ -1465,0 +2151,1 @@\n+    private static final int CXCursor_FieldDecl = (int)6L;\n@@ -1466,2 +2153,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_MemberRefExpr = 102;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_FieldDecl = 6\n@@ -1470,2 +2157,2 @@\n-    public static int CXCursor_MemberRefExpr() {\n-        return (int)102L;\n+    public static int CXCursor_FieldDecl() {\n+        return CXCursor_FieldDecl;\n@@ -1473,0 +2160,1 @@\n+    private static final int CXCursor_EnumConstantDecl = (int)7L;\n@@ -1474,2 +2162,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CallExpr = 103;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_EnumConstantDecl = 7\n@@ -1478,2 +2166,2 @@\n-    public static int CXCursor_CallExpr() {\n-        return (int)103L;\n+    public static int CXCursor_EnumConstantDecl() {\n+        return CXCursor_EnumConstantDecl;\n@@ -1481,0 +2169,1 @@\n+    private static final int CXCursor_FunctionDecl = (int)8L;\n@@ -1482,2 +2171,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCMessageExpr = 104;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_FunctionDecl = 8\n@@ -1486,2 +2175,2 @@\n-    public static int CXCursor_ObjCMessageExpr() {\n-        return (int)104L;\n+    public static int CXCursor_FunctionDecl() {\n+        return CXCursor_FunctionDecl;\n@@ -1489,0 +2178,1 @@\n+    private static final int CXCursor_VarDecl = (int)9L;\n@@ -1490,2 +2180,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_BlockExpr = 105;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_VarDecl = 9\n@@ -1494,2 +2184,2 @@\n-    public static int CXCursor_BlockExpr() {\n-        return (int)105L;\n+    public static int CXCursor_VarDecl() {\n+        return CXCursor_VarDecl;\n@@ -1497,0 +2187,1 @@\n+    private static final int CXCursor_ParmDecl = (int)10L;\n@@ -1498,2 +2189,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_IntegerLiteral = 106;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ParmDecl = 10\n@@ -1502,2 +2193,2 @@\n-    public static int CXCursor_IntegerLiteral() {\n-        return (int)106L;\n+    public static int CXCursor_ParmDecl() {\n+        return CXCursor_ParmDecl;\n@@ -1505,0 +2196,1 @@\n+    private static final int CXCursor_ObjCInterfaceDecl = (int)11L;\n@@ -1506,2 +2198,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_FloatingLiteral = 107;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCInterfaceDecl = 11\n@@ -1510,2 +2202,2 @@\n-    public static int CXCursor_FloatingLiteral() {\n-        return (int)107L;\n+    public static int CXCursor_ObjCInterfaceDecl() {\n+        return CXCursor_ObjCInterfaceDecl;\n@@ -1513,0 +2205,1 @@\n+    private static final int CXCursor_ObjCCategoryDecl = (int)12L;\n@@ -1514,2 +2207,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ImaginaryLiteral = 108;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCCategoryDecl = 12\n@@ -1518,2 +2211,2 @@\n-    public static int CXCursor_ImaginaryLiteral() {\n-        return (int)108L;\n+    public static int CXCursor_ObjCCategoryDecl() {\n+        return CXCursor_ObjCCategoryDecl;\n@@ -1521,0 +2214,1 @@\n+    private static final int CXCursor_ObjCProtocolDecl = (int)13L;\n@@ -1522,2 +2216,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_StringLiteral = 109;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCProtocolDecl = 13\n@@ -1526,2 +2220,2 @@\n-    public static int CXCursor_StringLiteral() {\n-        return (int)109L;\n+    public static int CXCursor_ObjCProtocolDecl() {\n+        return CXCursor_ObjCProtocolDecl;\n@@ -1529,0 +2223,1 @@\n+    private static final int CXCursor_ObjCPropertyDecl = (int)14L;\n@@ -1530,2 +2225,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CharacterLiteral = 110;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCPropertyDecl = 14\n@@ -1534,2 +2229,2 @@\n-    public static int CXCursor_CharacterLiteral() {\n-        return (int)110L;\n+    public static int CXCursor_ObjCPropertyDecl() {\n+        return CXCursor_ObjCPropertyDecl;\n@@ -1537,0 +2232,1 @@\n+    private static final int CXCursor_ObjCIvarDecl = (int)15L;\n@@ -1538,2 +2234,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ParenExpr = 111;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCIvarDecl = 15\n@@ -1542,2 +2238,2 @@\n-    public static int CXCursor_ParenExpr() {\n-        return (int)111L;\n+    public static int CXCursor_ObjCIvarDecl() {\n+        return CXCursor_ObjCIvarDecl;\n@@ -1545,0 +2241,1 @@\n+    private static final int CXCursor_ObjCInstanceMethodDecl = (int)16L;\n@@ -1546,2 +2243,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_UnaryOperator = 112;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCInstanceMethodDecl = 16\n@@ -1550,2 +2247,2 @@\n-    public static int CXCursor_UnaryOperator() {\n-        return (int)112L;\n+    public static int CXCursor_ObjCInstanceMethodDecl() {\n+        return CXCursor_ObjCInstanceMethodDecl;\n@@ -1553,0 +2250,1 @@\n+    private static final int CXCursor_ObjCClassMethodDecl = (int)17L;\n@@ -1554,2 +2252,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ArraySubscriptExpr = 113;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCClassMethodDecl = 17\n@@ -1558,2 +2256,2 @@\n-    public static int CXCursor_ArraySubscriptExpr() {\n-        return (int)113L;\n+    public static int CXCursor_ObjCClassMethodDecl() {\n+        return CXCursor_ObjCClassMethodDecl;\n@@ -1561,0 +2259,1 @@\n+    private static final int CXCursor_ObjCImplementationDecl = (int)18L;\n@@ -1562,2 +2261,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_BinaryOperator = 114;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCImplementationDecl = 18\n@@ -1566,2 +2265,2 @@\n-    public static int CXCursor_BinaryOperator() {\n-        return (int)114L;\n+    public static int CXCursor_ObjCImplementationDecl() {\n+        return CXCursor_ObjCImplementationDecl;\n@@ -1569,0 +2268,1 @@\n+    private static final int CXCursor_ObjCCategoryImplDecl = (int)19L;\n@@ -1570,2 +2270,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CompoundAssignOperator = 115;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCCategoryImplDecl = 19\n@@ -1574,2 +2274,2 @@\n-    public static int CXCursor_CompoundAssignOperator() {\n-        return (int)115L;\n+    public static int CXCursor_ObjCCategoryImplDecl() {\n+        return CXCursor_ObjCCategoryImplDecl;\n@@ -1577,0 +2277,1 @@\n+    private static final int CXCursor_TypedefDecl = (int)20L;\n@@ -1578,2 +2279,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ConditionalOperator = 116;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_TypedefDecl = 20\n@@ -1582,2 +2283,2 @@\n-    public static int CXCursor_ConditionalOperator() {\n-        return (int)116L;\n+    public static int CXCursor_TypedefDecl() {\n+        return CXCursor_TypedefDecl;\n@@ -1585,0 +2286,1 @@\n+    private static final int CXCursor_CXXMethod = (int)21L;\n@@ -1586,2 +2288,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CStyleCastExpr = 117;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CXXMethod = 21\n@@ -1590,2 +2292,2 @@\n-    public static int CXCursor_CStyleCastExpr() {\n-        return (int)117L;\n+    public static int CXCursor_CXXMethod() {\n+        return CXCursor_CXXMethod;\n@@ -1593,0 +2295,1 @@\n+    private static final int CXCursor_Namespace = (int)22L;\n@@ -1594,2 +2297,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CompoundLiteralExpr = 118;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_Namespace = 22\n@@ -1598,2 +2301,2 @@\n-    public static int CXCursor_CompoundLiteralExpr() {\n-        return (int)118L;\n+    public static int CXCursor_Namespace() {\n+        return CXCursor_Namespace;\n@@ -1601,0 +2304,1 @@\n+    private static final int CXCursor_LinkageSpec = (int)23L;\n@@ -1602,2 +2306,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_InitListExpr = 119;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_LinkageSpec = 23\n@@ -1606,2 +2310,2 @@\n-    public static int CXCursor_InitListExpr() {\n-        return (int)119L;\n+    public static int CXCursor_LinkageSpec() {\n+        return CXCursor_LinkageSpec;\n@@ -1609,0 +2313,1 @@\n+    private static final int CXCursor_Constructor = (int)24L;\n@@ -1610,2 +2315,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_AddrLabelExpr = 120;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_Constructor = 24\n@@ -1614,2 +2319,2 @@\n-    public static int CXCursor_AddrLabelExpr() {\n-        return (int)120L;\n+    public static int CXCursor_Constructor() {\n+        return CXCursor_Constructor;\n@@ -1617,0 +2322,1 @@\n+    private static final int CXCursor_Destructor = (int)25L;\n@@ -1618,2 +2324,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_StmtExpr = 121;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_Destructor = 25\n@@ -1622,2 +2328,2 @@\n-    public static int CXCursor_StmtExpr() {\n-        return (int)121L;\n+    public static int CXCursor_Destructor() {\n+        return CXCursor_Destructor;\n@@ -1625,0 +2331,1 @@\n+    private static final int CXCursor_ConversionFunction = (int)26L;\n@@ -1626,2 +2333,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_GenericSelectionExpr = 122;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ConversionFunction = 26\n@@ -1630,2 +2337,2 @@\n-    public static int CXCursor_GenericSelectionExpr() {\n-        return (int)122L;\n+    public static int CXCursor_ConversionFunction() {\n+        return CXCursor_ConversionFunction;\n@@ -1633,0 +2340,1 @@\n+    private static final int CXCursor_TemplateTypeParameter = (int)27L;\n@@ -1634,2 +2342,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_GNUNullExpr = 123;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_TemplateTypeParameter = 27\n@@ -1638,2 +2346,2 @@\n-    public static int CXCursor_GNUNullExpr() {\n-        return (int)123L;\n+    public static int CXCursor_TemplateTypeParameter() {\n+        return CXCursor_TemplateTypeParameter;\n@@ -1641,0 +2349,1 @@\n+    private static final int CXCursor_NonTypeTemplateParameter = (int)28L;\n@@ -1642,2 +2351,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CXXStaticCastExpr = 124;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_NonTypeTemplateParameter = 28\n@@ -1646,2 +2355,2 @@\n-    public static int CXCursor_CXXStaticCastExpr() {\n-        return (int)124L;\n+    public static int CXCursor_NonTypeTemplateParameter() {\n+        return CXCursor_NonTypeTemplateParameter;\n@@ -1649,0 +2358,1 @@\n+    private static final int CXCursor_TemplateTemplateParameter = (int)29L;\n@@ -1650,2 +2360,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CXXDynamicCastExpr = 125;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_TemplateTemplateParameter = 29\n@@ -1654,2 +2364,2 @@\n-    public static int CXCursor_CXXDynamicCastExpr() {\n-        return (int)125L;\n+    public static int CXCursor_TemplateTemplateParameter() {\n+        return CXCursor_TemplateTemplateParameter;\n@@ -1657,0 +2367,1 @@\n+    private static final int CXCursor_FunctionTemplate = (int)30L;\n@@ -1658,2 +2369,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CXXReinterpretCastExpr = 126;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_FunctionTemplate = 30\n@@ -1662,2 +2373,2 @@\n-    public static int CXCursor_CXXReinterpretCastExpr() {\n-        return (int)126L;\n+    public static int CXCursor_FunctionTemplate() {\n+        return CXCursor_FunctionTemplate;\n@@ -1665,0 +2376,1 @@\n+    private static final int CXCursor_ClassTemplate = (int)31L;\n@@ -1666,2 +2378,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CXXConstCastExpr = 127;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ClassTemplate = 31\n@@ -1670,2 +2382,2 @@\n-    public static int CXCursor_CXXConstCastExpr() {\n-        return (int)127L;\n+    public static int CXCursor_ClassTemplate() {\n+        return CXCursor_ClassTemplate;\n@@ -1673,0 +2385,1 @@\n+    private static final int CXCursor_ClassTemplatePartialSpecialization = (int)32L;\n@@ -1674,2 +2387,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CXXFunctionalCastExpr = 128;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ClassTemplatePartialSpecialization = 32\n@@ -1678,2 +2391,2 @@\n-    public static int CXCursor_CXXFunctionalCastExpr() {\n-        return (int)128L;\n+    public static int CXCursor_ClassTemplatePartialSpecialization() {\n+        return CXCursor_ClassTemplatePartialSpecialization;\n@@ -1681,0 +2394,1 @@\n+    private static final int CXCursor_NamespaceAlias = (int)33L;\n@@ -1682,2 +2396,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CXXTypeidExpr = 129;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_NamespaceAlias = 33\n@@ -1686,2 +2400,2 @@\n-    public static int CXCursor_CXXTypeidExpr() {\n-        return (int)129L;\n+    public static int CXCursor_NamespaceAlias() {\n+        return CXCursor_NamespaceAlias;\n@@ -1689,0 +2403,1 @@\n+    private static final int CXCursor_UsingDirective = (int)34L;\n@@ -1690,2 +2405,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CXXBoolLiteralExpr = 130;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_UsingDirective = 34\n@@ -1694,2 +2409,2 @@\n-    public static int CXCursor_CXXBoolLiteralExpr() {\n-        return (int)130L;\n+    public static int CXCursor_UsingDirective() {\n+        return CXCursor_UsingDirective;\n@@ -1697,0 +2412,1 @@\n+    private static final int CXCursor_UsingDeclaration = (int)35L;\n@@ -1698,2 +2414,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CXXNullPtrLiteralExpr = 131;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_UsingDeclaration = 35\n@@ -1702,2 +2418,2 @@\n-    public static int CXCursor_CXXNullPtrLiteralExpr() {\n-        return (int)131L;\n+    public static int CXCursor_UsingDeclaration() {\n+        return CXCursor_UsingDeclaration;\n@@ -1705,0 +2421,1 @@\n+    private static final int CXCursor_TypeAliasDecl = (int)36L;\n@@ -1706,2 +2423,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CXXThisExpr = 132;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_TypeAliasDecl = 36\n@@ -1710,2 +2427,2 @@\n-    public static int CXCursor_CXXThisExpr() {\n-        return (int)132L;\n+    public static int CXCursor_TypeAliasDecl() {\n+        return CXCursor_TypeAliasDecl;\n@@ -1713,0 +2430,1 @@\n+    private static final int CXCursor_ObjCSynthesizeDecl = (int)37L;\n@@ -1714,2 +2432,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CXXThrowExpr = 133;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCSynthesizeDecl = 37\n@@ -1718,2 +2436,2 @@\n-    public static int CXCursor_CXXThrowExpr() {\n-        return (int)133L;\n+    public static int CXCursor_ObjCSynthesizeDecl() {\n+        return CXCursor_ObjCSynthesizeDecl;\n@@ -1721,0 +2439,1 @@\n+    private static final int CXCursor_ObjCDynamicDecl = (int)38L;\n@@ -1722,2 +2441,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CXXNewExpr = 134;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCDynamicDecl = 38\n@@ -1726,2 +2445,2 @@\n-    public static int CXCursor_CXXNewExpr() {\n-        return (int)134L;\n+    public static int CXCursor_ObjCDynamicDecl() {\n+        return CXCursor_ObjCDynamicDecl;\n@@ -1729,0 +2448,1 @@\n+    private static final int CXCursor_CXXAccessSpecifier = (int)39L;\n@@ -1730,2 +2450,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CXXDeleteExpr = 135;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CXXAccessSpecifier = 39\n@@ -1734,2 +2454,2 @@\n-    public static int CXCursor_CXXDeleteExpr() {\n-        return (int)135L;\n+    public static int CXCursor_CXXAccessSpecifier() {\n+        return CXCursor_CXXAccessSpecifier;\n@@ -1737,0 +2457,1 @@\n+    private static final int CXCursor_FirstDecl = (int)1L;\n@@ -1738,2 +2459,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_UnaryExpr = 136;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_FirstDecl = 1\n@@ -1742,2 +2463,2 @@\n-    public static int CXCursor_UnaryExpr() {\n-        return (int)136L;\n+    public static int CXCursor_FirstDecl() {\n+        return CXCursor_FirstDecl;\n@@ -1745,0 +2466,1 @@\n+    private static final int CXCursor_LastDecl = (int)39L;\n@@ -1746,2 +2468,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCStringLiteral = 137;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_LastDecl = 39\n@@ -1750,2 +2472,2 @@\n-    public static int CXCursor_ObjCStringLiteral() {\n-        return (int)137L;\n+    public static int CXCursor_LastDecl() {\n+        return CXCursor_LastDecl;\n@@ -1753,0 +2475,1 @@\n+    private static final int CXCursor_FirstRef = (int)40L;\n@@ -1754,2 +2477,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCEncodeExpr = 138;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_FirstRef = 40\n@@ -1758,2 +2481,2 @@\n-    public static int CXCursor_ObjCEncodeExpr() {\n-        return (int)138L;\n+    public static int CXCursor_FirstRef() {\n+        return CXCursor_FirstRef;\n@@ -1761,0 +2484,1 @@\n+    private static final int CXCursor_ObjCSuperClassRef = (int)40L;\n@@ -1762,2 +2486,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCSelectorExpr = 139;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCSuperClassRef = 40\n@@ -1766,2 +2490,2 @@\n-    public static int CXCursor_ObjCSelectorExpr() {\n-        return (int)139L;\n+    public static int CXCursor_ObjCSuperClassRef() {\n+        return CXCursor_ObjCSuperClassRef;\n@@ -1769,0 +2493,1 @@\n+    private static final int CXCursor_ObjCProtocolRef = (int)41L;\n@@ -1770,2 +2495,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCProtocolExpr = 140;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCProtocolRef = 41\n@@ -1774,2 +2499,2 @@\n-    public static int CXCursor_ObjCProtocolExpr() {\n-        return (int)140L;\n+    public static int CXCursor_ObjCProtocolRef() {\n+        return CXCursor_ObjCProtocolRef;\n@@ -1777,0 +2502,1 @@\n+    private static final int CXCursor_ObjCClassRef = (int)42L;\n@@ -1778,2 +2504,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCBridgedCastExpr = 141;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCClassRef = 42\n@@ -1782,2 +2508,2 @@\n-    public static int CXCursor_ObjCBridgedCastExpr() {\n-        return (int)141L;\n+    public static int CXCursor_ObjCClassRef() {\n+        return CXCursor_ObjCClassRef;\n@@ -1785,0 +2511,1 @@\n+    private static final int CXCursor_TypeRef = (int)43L;\n@@ -1786,2 +2513,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_PackExpansionExpr = 142;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_TypeRef = 43\n@@ -1790,2 +2517,2 @@\n-    public static int CXCursor_PackExpansionExpr() {\n-        return (int)142L;\n+    public static int CXCursor_TypeRef() {\n+        return CXCursor_TypeRef;\n@@ -1793,0 +2520,1 @@\n+    private static final int CXCursor_CXXBaseSpecifier = (int)44L;\n@@ -1794,2 +2522,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_SizeOfPackExpr = 143;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CXXBaseSpecifier = 44\n@@ -1798,2 +2526,2 @@\n-    public static int CXCursor_SizeOfPackExpr() {\n-        return (int)143L;\n+    public static int CXCursor_CXXBaseSpecifier() {\n+        return CXCursor_CXXBaseSpecifier;\n@@ -1801,0 +2529,1 @@\n+    private static final int CXCursor_TemplateRef = (int)45L;\n@@ -1802,2 +2531,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_LambdaExpr = 144;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_TemplateRef = 45\n@@ -1806,2 +2535,2 @@\n-    public static int CXCursor_LambdaExpr() {\n-        return (int)144L;\n+    public static int CXCursor_TemplateRef() {\n+        return CXCursor_TemplateRef;\n@@ -1809,0 +2538,1 @@\n+    private static final int CXCursor_NamespaceRef = (int)46L;\n@@ -1810,2 +2540,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCBoolLiteralExpr = 145;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_NamespaceRef = 46\n@@ -1814,2 +2544,2 @@\n-    public static int CXCursor_ObjCBoolLiteralExpr() {\n-        return (int)145L;\n+    public static int CXCursor_NamespaceRef() {\n+        return CXCursor_NamespaceRef;\n@@ -1817,0 +2547,1 @@\n+    private static final int CXCursor_MemberRef = (int)47L;\n@@ -1818,2 +2549,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCSelfExpr = 146;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_MemberRef = 47\n@@ -1822,2 +2553,2 @@\n-    public static int CXCursor_ObjCSelfExpr() {\n-        return (int)146L;\n+    public static int CXCursor_MemberRef() {\n+        return CXCursor_MemberRef;\n@@ -1825,0 +2556,1 @@\n+    private static final int CXCursor_LabelRef = (int)48L;\n@@ -1826,2 +2558,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPArraySectionExpr = 147;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_LabelRef = 48\n@@ -1830,2 +2562,2 @@\n-    public static int CXCursor_OMPArraySectionExpr() {\n-        return (int)147L;\n+    public static int CXCursor_LabelRef() {\n+        return CXCursor_LabelRef;\n@@ -1833,0 +2565,1 @@\n+    private static final int CXCursor_OverloadedDeclRef = (int)49L;\n@@ -1834,2 +2567,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCAvailabilityCheckExpr = 148;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OverloadedDeclRef = 49\n@@ -1838,2 +2571,2 @@\n-    public static int CXCursor_ObjCAvailabilityCheckExpr() {\n-        return (int)148L;\n+    public static int CXCursor_OverloadedDeclRef() {\n+        return CXCursor_OverloadedDeclRef;\n@@ -1841,0 +2574,1 @@\n+    private static final int CXCursor_VariableRef = (int)50L;\n@@ -1842,2 +2576,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_FixedPointLiteral = 149;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_VariableRef = 50\n@@ -1846,2 +2580,2 @@\n-    public static int CXCursor_FixedPointLiteral() {\n-        return (int)149L;\n+    public static int CXCursor_VariableRef() {\n+        return CXCursor_VariableRef;\n@@ -1849,0 +2583,1 @@\n+    private static final int CXCursor_LastRef = (int)50L;\n@@ -1850,2 +2585,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_LastExpr = 152;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_LastRef = 50\n@@ -1854,2 +2589,2 @@\n-    public static int CXCursor_LastExpr() {\n-        return (int)152L;\n+    public static int CXCursor_LastRef() {\n+        return CXCursor_LastRef;\n@@ -1857,0 +2592,1 @@\n+    private static final int CXCursor_FirstInvalid = (int)70L;\n@@ -1858,2 +2594,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_FirstStmt = 200;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_FirstInvalid = 70\n@@ -1862,2 +2598,2 @@\n-    public static int CXCursor_FirstStmt() {\n-        return (int)200L;\n+    public static int CXCursor_FirstInvalid() {\n+        return CXCursor_FirstInvalid;\n@@ -1865,0 +2601,1 @@\n+    private static final int CXCursor_InvalidFile = (int)70L;\n@@ -1866,2 +2603,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_UnexposedStmt = 200;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_InvalidFile = 70\n@@ -1870,2 +2607,2 @@\n-    public static int CXCursor_UnexposedStmt() {\n-        return (int)200L;\n+    public static int CXCursor_InvalidFile() {\n+        return CXCursor_InvalidFile;\n@@ -1873,0 +2610,1 @@\n+    private static final int CXCursor_NoDeclFound = (int)71L;\n@@ -1874,2 +2612,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_LabelStmt = 201;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_NoDeclFound = 71\n@@ -1878,2 +2616,2 @@\n-    public static int CXCursor_LabelStmt() {\n-        return (int)201L;\n+    public static int CXCursor_NoDeclFound() {\n+        return CXCursor_NoDeclFound;\n@@ -1881,0 +2619,1 @@\n+    private static final int CXCursor_NotImplemented = (int)72L;\n@@ -1882,2 +2621,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CompoundStmt = 202;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_NotImplemented = 72\n@@ -1886,2 +2625,2 @@\n-    public static int CXCursor_CompoundStmt() {\n-        return (int)202L;\n+    public static int CXCursor_NotImplemented() {\n+        return CXCursor_NotImplemented;\n@@ -1889,0 +2628,1 @@\n+    private static final int CXCursor_InvalidCode = (int)73L;\n@@ -1890,2 +2630,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CaseStmt = 203;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_InvalidCode = 73\n@@ -1894,2 +2634,2 @@\n-    public static int CXCursor_CaseStmt() {\n-        return (int)203L;\n+    public static int CXCursor_InvalidCode() {\n+        return CXCursor_InvalidCode;\n@@ -1897,0 +2637,1 @@\n+    private static final int CXCursor_LastInvalid = (int)73L;\n@@ -1898,2 +2639,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_DefaultStmt = 204;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_LastInvalid = 73\n@@ -1902,2 +2643,2 @@\n-    public static int CXCursor_DefaultStmt() {\n-        return (int)204L;\n+    public static int CXCursor_LastInvalid() {\n+        return CXCursor_LastInvalid;\n@@ -1905,0 +2646,1 @@\n+    private static final int CXCursor_FirstExpr = (int)100L;\n@@ -1906,2 +2648,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_IfStmt = 205;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_FirstExpr = 100\n@@ -1910,2 +2652,2 @@\n-    public static int CXCursor_IfStmt() {\n-        return (int)205L;\n+    public static int CXCursor_FirstExpr() {\n+        return CXCursor_FirstExpr;\n@@ -1913,0 +2655,1 @@\n+    private static final int CXCursor_UnexposedExpr = (int)100L;\n@@ -1914,2 +2657,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_SwitchStmt = 206;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_UnexposedExpr = 100\n@@ -1918,2 +2661,2 @@\n-    public static int CXCursor_SwitchStmt() {\n-        return (int)206L;\n+    public static int CXCursor_UnexposedExpr() {\n+        return CXCursor_UnexposedExpr;\n@@ -1921,0 +2664,1 @@\n+    private static final int CXCursor_DeclRefExpr = (int)101L;\n@@ -1922,2 +2666,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_WhileStmt = 207;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_DeclRefExpr = 101\n@@ -1926,2 +2670,2 @@\n-    public static int CXCursor_WhileStmt() {\n-        return (int)207L;\n+    public static int CXCursor_DeclRefExpr() {\n+        return CXCursor_DeclRefExpr;\n@@ -1929,0 +2673,1 @@\n+    private static final int CXCursor_MemberRefExpr = (int)102L;\n@@ -1930,2 +2675,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_DoStmt = 208;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_MemberRefExpr = 102\n@@ -1934,2 +2679,2 @@\n-    public static int CXCursor_DoStmt() {\n-        return (int)208L;\n+    public static int CXCursor_MemberRefExpr() {\n+        return CXCursor_MemberRefExpr;\n@@ -1937,0 +2682,1 @@\n+    private static final int CXCursor_CallExpr = (int)103L;\n@@ -1938,2 +2684,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ForStmt = 209;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CallExpr = 103\n@@ -1942,2 +2688,2 @@\n-    public static int CXCursor_ForStmt() {\n-        return (int)209L;\n+    public static int CXCursor_CallExpr() {\n+        return CXCursor_CallExpr;\n@@ -1945,0 +2691,1 @@\n+    private static final int CXCursor_ObjCMessageExpr = (int)104L;\n@@ -1946,2 +2693,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_GotoStmt = 210;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCMessageExpr = 104\n@@ -1950,2 +2697,2 @@\n-    public static int CXCursor_GotoStmt() {\n-        return (int)210L;\n+    public static int CXCursor_ObjCMessageExpr() {\n+        return CXCursor_ObjCMessageExpr;\n@@ -1953,0 +2700,1 @@\n+    private static final int CXCursor_BlockExpr = (int)105L;\n@@ -1954,2 +2702,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_IndirectGotoStmt = 211;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_BlockExpr = 105\n@@ -1958,2 +2706,2 @@\n-    public static int CXCursor_IndirectGotoStmt() {\n-        return (int)211L;\n+    public static int CXCursor_BlockExpr() {\n+        return CXCursor_BlockExpr;\n@@ -1961,0 +2709,1 @@\n+    private static final int CXCursor_IntegerLiteral = (int)106L;\n@@ -1962,2 +2711,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ContinueStmt = 212;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_IntegerLiteral = 106\n@@ -1966,2 +2715,2 @@\n-    public static int CXCursor_ContinueStmt() {\n-        return (int)212L;\n+    public static int CXCursor_IntegerLiteral() {\n+        return CXCursor_IntegerLiteral;\n@@ -1969,0 +2718,1 @@\n+    private static final int CXCursor_FloatingLiteral = (int)107L;\n@@ -1970,2 +2720,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_BreakStmt = 213;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_FloatingLiteral = 107\n@@ -1974,2 +2724,2 @@\n-    public static int CXCursor_BreakStmt() {\n-        return (int)213L;\n+    public static int CXCursor_FloatingLiteral() {\n+        return CXCursor_FloatingLiteral;\n@@ -1977,0 +2727,1 @@\n+    private static final int CXCursor_ImaginaryLiteral = (int)108L;\n@@ -1978,2 +2729,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ReturnStmt = 214;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ImaginaryLiteral = 108\n@@ -1982,2 +2733,2 @@\n-    public static int CXCursor_ReturnStmt() {\n-        return (int)214L;\n+    public static int CXCursor_ImaginaryLiteral() {\n+        return CXCursor_ImaginaryLiteral;\n@@ -1985,0 +2736,1 @@\n+    private static final int CXCursor_StringLiteral = (int)109L;\n@@ -1986,2 +2738,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_GCCAsmStmt = 215;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_StringLiteral = 109\n@@ -1990,2 +2742,2 @@\n-    public static int CXCursor_GCCAsmStmt() {\n-        return (int)215L;\n+    public static int CXCursor_StringLiteral() {\n+        return CXCursor_StringLiteral;\n@@ -1993,0 +2745,1 @@\n+    private static final int CXCursor_CharacterLiteral = (int)110L;\n@@ -1994,2 +2747,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_AsmStmt = 215;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CharacterLiteral = 110\n@@ -1998,2 +2751,2 @@\n-    public static int CXCursor_AsmStmt() {\n-        return (int)215L;\n+    public static int CXCursor_CharacterLiteral() {\n+        return CXCursor_CharacterLiteral;\n@@ -2001,0 +2754,1 @@\n+    private static final int CXCursor_ParenExpr = (int)111L;\n@@ -2002,2 +2756,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCAtTryStmt = 216;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ParenExpr = 111\n@@ -2006,2 +2760,2 @@\n-    public static int CXCursor_ObjCAtTryStmt() {\n-        return (int)216L;\n+    public static int CXCursor_ParenExpr() {\n+        return CXCursor_ParenExpr;\n@@ -2009,0 +2763,1 @@\n+    private static final int CXCursor_UnaryOperator = (int)112L;\n@@ -2010,2 +2765,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCAtCatchStmt = 217;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_UnaryOperator = 112\n@@ -2014,2 +2769,2 @@\n-    public static int CXCursor_ObjCAtCatchStmt() {\n-        return (int)217L;\n+    public static int CXCursor_UnaryOperator() {\n+        return CXCursor_UnaryOperator;\n@@ -2017,0 +2772,1 @@\n+    private static final int CXCursor_ArraySubscriptExpr = (int)113L;\n@@ -2018,2 +2774,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCAtFinallyStmt = 218;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ArraySubscriptExpr = 113\n@@ -2022,2 +2778,2 @@\n-    public static int CXCursor_ObjCAtFinallyStmt() {\n-        return (int)218L;\n+    public static int CXCursor_ArraySubscriptExpr() {\n+        return CXCursor_ArraySubscriptExpr;\n@@ -2025,0 +2781,1 @@\n+    private static final int CXCursor_BinaryOperator = (int)114L;\n@@ -2026,2 +2783,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCAtThrowStmt = 219;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_BinaryOperator = 114\n@@ -2030,2 +2787,2 @@\n-    public static int CXCursor_ObjCAtThrowStmt() {\n-        return (int)219L;\n+    public static int CXCursor_BinaryOperator() {\n+        return CXCursor_BinaryOperator;\n@@ -2033,0 +2790,1 @@\n+    private static final int CXCursor_CompoundAssignOperator = (int)115L;\n@@ -2034,2 +2792,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCAtSynchronizedStmt = 220;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CompoundAssignOperator = 115\n@@ -2038,2 +2796,2 @@\n-    public static int CXCursor_ObjCAtSynchronizedStmt() {\n-        return (int)220L;\n+    public static int CXCursor_CompoundAssignOperator() {\n+        return CXCursor_CompoundAssignOperator;\n@@ -2041,0 +2799,1 @@\n+    private static final int CXCursor_ConditionalOperator = (int)116L;\n@@ -2042,2 +2801,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCAutoreleasePoolStmt = 221;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ConditionalOperator = 116\n@@ -2046,2 +2805,2 @@\n-    public static int CXCursor_ObjCAutoreleasePoolStmt() {\n-        return (int)221L;\n+    public static int CXCursor_ConditionalOperator() {\n+        return CXCursor_ConditionalOperator;\n@@ -2049,0 +2808,1 @@\n+    private static final int CXCursor_CStyleCastExpr = (int)117L;\n@@ -2050,2 +2810,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCForCollectionStmt = 222;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CStyleCastExpr = 117\n@@ -2054,2 +2814,2 @@\n-    public static int CXCursor_ObjCForCollectionStmt() {\n-        return (int)222L;\n+    public static int CXCursor_CStyleCastExpr() {\n+        return CXCursor_CStyleCastExpr;\n@@ -2057,0 +2817,1 @@\n+    private static final int CXCursor_CompoundLiteralExpr = (int)118L;\n@@ -2058,2 +2819,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CXXCatchStmt = 223;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CompoundLiteralExpr = 118\n@@ -2062,2 +2823,2 @@\n-    public static int CXCursor_CXXCatchStmt() {\n-        return (int)223L;\n+    public static int CXCursor_CompoundLiteralExpr() {\n+        return CXCursor_CompoundLiteralExpr;\n@@ -2065,0 +2826,1 @@\n+    private static final int CXCursor_InitListExpr = (int)119L;\n@@ -2066,2 +2828,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CXXTryStmt = 224;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_InitListExpr = 119\n@@ -2070,2 +2832,2 @@\n-    public static int CXCursor_CXXTryStmt() {\n-        return (int)224L;\n+    public static int CXCursor_InitListExpr() {\n+        return CXCursor_InitListExpr;\n@@ -2073,0 +2835,1 @@\n+    private static final int CXCursor_AddrLabelExpr = (int)120L;\n@@ -2074,2 +2837,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CXXForRangeStmt = 225;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_AddrLabelExpr = 120\n@@ -2078,2 +2841,2 @@\n-    public static int CXCursor_CXXForRangeStmt() {\n-        return (int)225L;\n+    public static int CXCursor_AddrLabelExpr() {\n+        return CXCursor_AddrLabelExpr;\n@@ -2081,0 +2844,1 @@\n+    private static final int CXCursor_StmtExpr = (int)121L;\n@@ -2082,2 +2846,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_SEHTryStmt = 226;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_StmtExpr = 121\n@@ -2086,2 +2850,2 @@\n-    public static int CXCursor_SEHTryStmt() {\n-        return (int)226L;\n+    public static int CXCursor_StmtExpr() {\n+        return CXCursor_StmtExpr;\n@@ -2089,0 +2853,1 @@\n+    private static final int CXCursor_GenericSelectionExpr = (int)122L;\n@@ -2090,2 +2855,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_SEHExceptStmt = 227;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_GenericSelectionExpr = 122\n@@ -2094,2 +2859,2 @@\n-    public static int CXCursor_SEHExceptStmt() {\n-        return (int)227L;\n+    public static int CXCursor_GenericSelectionExpr() {\n+        return CXCursor_GenericSelectionExpr;\n@@ -2097,0 +2862,1 @@\n+    private static final int CXCursor_GNUNullExpr = (int)123L;\n@@ -2098,2 +2864,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_SEHFinallyStmt = 228;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_GNUNullExpr = 123\n@@ -2102,2 +2868,2 @@\n-    public static int CXCursor_SEHFinallyStmt() {\n-        return (int)228L;\n+    public static int CXCursor_GNUNullExpr() {\n+        return CXCursor_GNUNullExpr;\n@@ -2105,0 +2871,1 @@\n+    private static final int CXCursor_CXXStaticCastExpr = (int)124L;\n@@ -2106,2 +2873,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_MSAsmStmt = 229;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CXXStaticCastExpr = 124\n@@ -2110,2 +2877,2 @@\n-    public static int CXCursor_MSAsmStmt() {\n-        return (int)229L;\n+    public static int CXCursor_CXXStaticCastExpr() {\n+        return CXCursor_CXXStaticCastExpr;\n@@ -2113,0 +2880,1 @@\n+    private static final int CXCursor_CXXDynamicCastExpr = (int)125L;\n@@ -2114,2 +2882,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_NullStmt = 230;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CXXDynamicCastExpr = 125\n@@ -2118,2 +2886,2 @@\n-    public static int CXCursor_NullStmt() {\n-        return (int)230L;\n+    public static int CXCursor_CXXDynamicCastExpr() {\n+        return CXCursor_CXXDynamicCastExpr;\n@@ -2121,0 +2889,1 @@\n+    private static final int CXCursor_CXXReinterpretCastExpr = (int)126L;\n@@ -2122,2 +2891,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_DeclStmt = 231;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CXXReinterpretCastExpr = 126\n@@ -2126,2 +2895,2 @@\n-    public static int CXCursor_DeclStmt() {\n-        return (int)231L;\n+    public static int CXCursor_CXXReinterpretCastExpr() {\n+        return CXCursor_CXXReinterpretCastExpr;\n@@ -2129,0 +2898,1 @@\n+    private static final int CXCursor_CXXConstCastExpr = (int)127L;\n@@ -2130,2 +2900,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPParallelDirective = 232;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CXXConstCastExpr = 127\n@@ -2134,2 +2904,2 @@\n-    public static int CXCursor_OMPParallelDirective() {\n-        return (int)232L;\n+    public static int CXCursor_CXXConstCastExpr() {\n+        return CXCursor_CXXConstCastExpr;\n@@ -2137,0 +2907,1 @@\n+    private static final int CXCursor_CXXFunctionalCastExpr = (int)128L;\n@@ -2138,2 +2909,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPSimdDirective = 233;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CXXFunctionalCastExpr = 128\n@@ -2142,2 +2913,2 @@\n-    public static int CXCursor_OMPSimdDirective() {\n-        return (int)233L;\n+    public static int CXCursor_CXXFunctionalCastExpr() {\n+        return CXCursor_CXXFunctionalCastExpr;\n@@ -2145,0 +2916,1 @@\n+    private static final int CXCursor_CXXTypeidExpr = (int)129L;\n@@ -2146,2 +2918,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPForDirective = 234;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CXXTypeidExpr = 129\n@@ -2150,2 +2922,2 @@\n-    public static int CXCursor_OMPForDirective() {\n-        return (int)234L;\n+    public static int CXCursor_CXXTypeidExpr() {\n+        return CXCursor_CXXTypeidExpr;\n@@ -2153,0 +2925,1 @@\n+    private static final int CXCursor_CXXBoolLiteralExpr = (int)130L;\n@@ -2154,2 +2927,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPSectionsDirective = 235;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CXXBoolLiteralExpr = 130\n@@ -2158,2 +2931,2 @@\n-    public static int CXCursor_OMPSectionsDirective() {\n-        return (int)235L;\n+    public static int CXCursor_CXXBoolLiteralExpr() {\n+        return CXCursor_CXXBoolLiteralExpr;\n@@ -2161,0 +2934,1 @@\n+    private static final int CXCursor_CXXNullPtrLiteralExpr = (int)131L;\n@@ -2162,2 +2936,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPSectionDirective = 236;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CXXNullPtrLiteralExpr = 131\n@@ -2166,2 +2940,2 @@\n-    public static int CXCursor_OMPSectionDirective() {\n-        return (int)236L;\n+    public static int CXCursor_CXXNullPtrLiteralExpr() {\n+        return CXCursor_CXXNullPtrLiteralExpr;\n@@ -2169,0 +2943,1 @@\n+    private static final int CXCursor_CXXThisExpr = (int)132L;\n@@ -2170,2 +2945,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPSingleDirective = 237;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CXXThisExpr = 132\n@@ -2174,2 +2949,2 @@\n-    public static int CXCursor_OMPSingleDirective() {\n-        return (int)237L;\n+    public static int CXCursor_CXXThisExpr() {\n+        return CXCursor_CXXThisExpr;\n@@ -2177,0 +2952,1 @@\n+    private static final int CXCursor_CXXThrowExpr = (int)133L;\n@@ -2178,2 +2954,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPParallelForDirective = 238;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CXXThrowExpr = 133\n@@ -2182,2 +2958,2 @@\n-    public static int CXCursor_OMPParallelForDirective() {\n-        return (int)238L;\n+    public static int CXCursor_CXXThrowExpr() {\n+        return CXCursor_CXXThrowExpr;\n@@ -2185,0 +2961,1 @@\n+    private static final int CXCursor_CXXNewExpr = (int)134L;\n@@ -2186,2 +2963,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPParallelSectionsDirective = 239;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CXXNewExpr = 134\n@@ -2190,2 +2967,2 @@\n-    public static int CXCursor_OMPParallelSectionsDirective() {\n-        return (int)239L;\n+    public static int CXCursor_CXXNewExpr() {\n+        return CXCursor_CXXNewExpr;\n@@ -2193,0 +2970,1 @@\n+    private static final int CXCursor_CXXDeleteExpr = (int)135L;\n@@ -2194,2 +2972,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTaskDirective = 240;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CXXDeleteExpr = 135\n@@ -2198,2 +2976,2 @@\n-    public static int CXCursor_OMPTaskDirective() {\n-        return (int)240L;\n+    public static int CXCursor_CXXDeleteExpr() {\n+        return CXCursor_CXXDeleteExpr;\n@@ -2201,0 +2979,1 @@\n+    private static final int CXCursor_UnaryExpr = (int)136L;\n@@ -2202,2 +2981,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPMasterDirective = 241;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_UnaryExpr = 136\n@@ -2206,2 +2985,2 @@\n-    public static int CXCursor_OMPMasterDirective() {\n-        return (int)241L;\n+    public static int CXCursor_UnaryExpr() {\n+        return CXCursor_UnaryExpr;\n@@ -2209,0 +2988,1 @@\n+    private static final int CXCursor_ObjCStringLiteral = (int)137L;\n@@ -2210,2 +2990,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPCriticalDirective = 242;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCStringLiteral = 137\n@@ -2214,2 +2994,2 @@\n-    public static int CXCursor_OMPCriticalDirective() {\n-        return (int)242L;\n+    public static int CXCursor_ObjCStringLiteral() {\n+        return CXCursor_ObjCStringLiteral;\n@@ -2217,0 +2997,1 @@\n+    private static final int CXCursor_ObjCEncodeExpr = (int)138L;\n@@ -2218,2 +2999,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTaskyieldDirective = 243;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCEncodeExpr = 138\n@@ -2222,2 +3003,2 @@\n-    public static int CXCursor_OMPTaskyieldDirective() {\n-        return (int)243L;\n+    public static int CXCursor_ObjCEncodeExpr() {\n+        return CXCursor_ObjCEncodeExpr;\n@@ -2225,0 +3006,1 @@\n+    private static final int CXCursor_ObjCSelectorExpr = (int)139L;\n@@ -2226,2 +3008,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPBarrierDirective = 244;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCSelectorExpr = 139\n@@ -2230,2 +3012,2 @@\n-    public static int CXCursor_OMPBarrierDirective() {\n-        return (int)244L;\n+    public static int CXCursor_ObjCSelectorExpr() {\n+        return CXCursor_ObjCSelectorExpr;\n@@ -2233,0 +3015,1 @@\n+    private static final int CXCursor_ObjCProtocolExpr = (int)140L;\n@@ -2234,2 +3017,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTaskwaitDirective = 245;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCProtocolExpr = 140\n@@ -2238,2 +3021,2 @@\n-    public static int CXCursor_OMPTaskwaitDirective() {\n-        return (int)245L;\n+    public static int CXCursor_ObjCProtocolExpr() {\n+        return CXCursor_ObjCProtocolExpr;\n@@ -2241,0 +3024,1 @@\n+    private static final int CXCursor_ObjCBridgedCastExpr = (int)141L;\n@@ -2242,2 +3026,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPFlushDirective = 246;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCBridgedCastExpr = 141\n@@ -2246,2 +3030,2 @@\n-    public static int CXCursor_OMPFlushDirective() {\n-        return (int)246L;\n+    public static int CXCursor_ObjCBridgedCastExpr() {\n+        return CXCursor_ObjCBridgedCastExpr;\n@@ -2249,0 +3033,1 @@\n+    private static final int CXCursor_PackExpansionExpr = (int)142L;\n@@ -2250,2 +3035,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_SEHLeaveStmt = 247;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_PackExpansionExpr = 142\n@@ -2254,2 +3039,2 @@\n-    public static int CXCursor_SEHLeaveStmt() {\n-        return (int)247L;\n+    public static int CXCursor_PackExpansionExpr() {\n+        return CXCursor_PackExpansionExpr;\n@@ -2257,0 +3042,1 @@\n+    private static final int CXCursor_SizeOfPackExpr = (int)143L;\n@@ -2258,2 +3044,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPOrderedDirective = 248;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_SizeOfPackExpr = 143\n@@ -2262,2 +3048,2 @@\n-    public static int CXCursor_OMPOrderedDirective() {\n-        return (int)248L;\n+    public static int CXCursor_SizeOfPackExpr() {\n+        return CXCursor_SizeOfPackExpr;\n@@ -2265,0 +3051,1 @@\n+    private static final int CXCursor_LambdaExpr = (int)144L;\n@@ -2266,2 +3053,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPAtomicDirective = 249;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_LambdaExpr = 144\n@@ -2270,2 +3057,2 @@\n-    public static int CXCursor_OMPAtomicDirective() {\n-        return (int)249L;\n+    public static int CXCursor_LambdaExpr() {\n+        return CXCursor_LambdaExpr;\n@@ -2273,0 +3060,1 @@\n+    private static final int CXCursor_ObjCBoolLiteralExpr = (int)145L;\n@@ -2274,2 +3062,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPForSimdDirective = 250;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCBoolLiteralExpr = 145\n@@ -2278,2 +3066,2 @@\n-    public static int CXCursor_OMPForSimdDirective() {\n-        return (int)250L;\n+    public static int CXCursor_ObjCBoolLiteralExpr() {\n+        return CXCursor_ObjCBoolLiteralExpr;\n@@ -2281,0 +3069,1 @@\n+    private static final int CXCursor_ObjCSelfExpr = (int)146L;\n@@ -2282,2 +3071,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPParallelForSimdDirective = 251;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCSelfExpr = 146\n@@ -2286,2 +3075,2 @@\n-    public static int CXCursor_OMPParallelForSimdDirective() {\n-        return (int)251L;\n+    public static int CXCursor_ObjCSelfExpr() {\n+        return CXCursor_ObjCSelfExpr;\n@@ -2289,0 +3078,1 @@\n+    private static final int CXCursor_OMPArraySectionExpr = (int)147L;\n@@ -2290,2 +3080,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTargetDirective = 252;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPArraySectionExpr = 147\n@@ -2294,2 +3084,2 @@\n-    public static int CXCursor_OMPTargetDirective() {\n-        return (int)252L;\n+    public static int CXCursor_OMPArraySectionExpr() {\n+        return CXCursor_OMPArraySectionExpr;\n@@ -2297,0 +3087,1 @@\n+    private static final int CXCursor_ObjCAvailabilityCheckExpr = (int)148L;\n@@ -2298,2 +3089,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTeamsDirective = 253;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCAvailabilityCheckExpr = 148\n@@ -2302,2 +3093,2 @@\n-    public static int CXCursor_OMPTeamsDirective() {\n-        return (int)253L;\n+    public static int CXCursor_ObjCAvailabilityCheckExpr() {\n+        return CXCursor_ObjCAvailabilityCheckExpr;\n@@ -2305,0 +3096,1 @@\n+    private static final int CXCursor_FixedPointLiteral = (int)149L;\n@@ -2306,2 +3098,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTaskgroupDirective = 254;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_FixedPointLiteral = 149\n@@ -2310,2 +3102,2 @@\n-    public static int CXCursor_OMPTaskgroupDirective() {\n-        return (int)254L;\n+    public static int CXCursor_FixedPointLiteral() {\n+        return CXCursor_FixedPointLiteral;\n@@ -2313,0 +3105,1 @@\n+    private static final int CXCursor_LastExpr = (int)152L;\n@@ -2314,2 +3107,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPCancellationPointDirective = 255;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_LastExpr = 152\n@@ -2318,2 +3111,2 @@\n-    public static int CXCursor_OMPCancellationPointDirective() {\n-        return (int)255L;\n+    public static int CXCursor_LastExpr() {\n+        return CXCursor_LastExpr;\n@@ -2321,0 +3114,1 @@\n+    private static final int CXCursor_FirstStmt = (int)200L;\n@@ -2322,2 +3116,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPCancelDirective = 256;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_FirstStmt = 200\n@@ -2326,2 +3120,2 @@\n-    public static int CXCursor_OMPCancelDirective() {\n-        return (int)256L;\n+    public static int CXCursor_FirstStmt() {\n+        return CXCursor_FirstStmt;\n@@ -2329,0 +3123,1 @@\n+    private static final int CXCursor_UnexposedStmt = (int)200L;\n@@ -2330,2 +3125,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTargetDataDirective = 257;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_UnexposedStmt = 200\n@@ -2334,2 +3129,2 @@\n-    public static int CXCursor_OMPTargetDataDirective() {\n-        return (int)257L;\n+    public static int CXCursor_UnexposedStmt() {\n+        return CXCursor_UnexposedStmt;\n@@ -2337,0 +3132,1 @@\n+    private static final int CXCursor_LabelStmt = (int)201L;\n@@ -2338,2 +3134,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTaskLoopDirective = 258;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_LabelStmt = 201\n@@ -2342,2 +3138,2 @@\n-    public static int CXCursor_OMPTaskLoopDirective() {\n-        return (int)258L;\n+    public static int CXCursor_LabelStmt() {\n+        return CXCursor_LabelStmt;\n@@ -2345,0 +3141,1 @@\n+    private static final int CXCursor_CompoundStmt = (int)202L;\n@@ -2346,2 +3143,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTaskLoopSimdDirective = 259;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CompoundStmt = 202\n@@ -2350,2 +3147,2 @@\n-    public static int CXCursor_OMPTaskLoopSimdDirective() {\n-        return (int)259L;\n+    public static int CXCursor_CompoundStmt() {\n+        return CXCursor_CompoundStmt;\n@@ -2353,0 +3150,1 @@\n+    private static final int CXCursor_CaseStmt = (int)203L;\n@@ -2354,2 +3152,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPDistributeDirective = 260;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CaseStmt = 203\n@@ -2358,2 +3156,2 @@\n-    public static int CXCursor_OMPDistributeDirective() {\n-        return (int)260L;\n+    public static int CXCursor_CaseStmt() {\n+        return CXCursor_CaseStmt;\n@@ -2361,0 +3159,1 @@\n+    private static final int CXCursor_DefaultStmt = (int)204L;\n@@ -2362,2 +3161,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTargetEnterDataDirective = 261;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_DefaultStmt = 204\n@@ -2366,2 +3165,2 @@\n-    public static int CXCursor_OMPTargetEnterDataDirective() {\n-        return (int)261L;\n+    public static int CXCursor_DefaultStmt() {\n+        return CXCursor_DefaultStmt;\n@@ -2369,0 +3168,1 @@\n+    private static final int CXCursor_IfStmt = (int)205L;\n@@ -2370,2 +3170,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTargetExitDataDirective = 262;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_IfStmt = 205\n@@ -2374,2 +3174,2 @@\n-    public static int CXCursor_OMPTargetExitDataDirective() {\n-        return (int)262L;\n+    public static int CXCursor_IfStmt() {\n+        return CXCursor_IfStmt;\n@@ -2377,0 +3177,1 @@\n+    private static final int CXCursor_SwitchStmt = (int)206L;\n@@ -2378,2 +3179,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTargetParallelDirective = 263;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_SwitchStmt = 206\n@@ -2382,2 +3183,2 @@\n-    public static int CXCursor_OMPTargetParallelDirective() {\n-        return (int)263L;\n+    public static int CXCursor_SwitchStmt() {\n+        return CXCursor_SwitchStmt;\n@@ -2385,0 +3186,1 @@\n+    private static final int CXCursor_WhileStmt = (int)207L;\n@@ -2386,2 +3188,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTargetParallelForDirective = 264;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_WhileStmt = 207\n@@ -2390,2 +3192,2 @@\n-    public static int CXCursor_OMPTargetParallelForDirective() {\n-        return (int)264L;\n+    public static int CXCursor_WhileStmt() {\n+        return CXCursor_WhileStmt;\n@@ -2393,0 +3195,1 @@\n+    private static final int CXCursor_DoStmt = (int)208L;\n@@ -2394,2 +3197,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTargetUpdateDirective = 265;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_DoStmt = 208\n@@ -2398,2 +3201,2 @@\n-    public static int CXCursor_OMPTargetUpdateDirective() {\n-        return (int)265L;\n+    public static int CXCursor_DoStmt() {\n+        return CXCursor_DoStmt;\n@@ -2401,0 +3204,1 @@\n+    private static final int CXCursor_ForStmt = (int)209L;\n@@ -2402,2 +3206,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPDistributeParallelForDirective = 266;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ForStmt = 209\n@@ -2406,2 +3210,2 @@\n-    public static int CXCursor_OMPDistributeParallelForDirective() {\n-        return (int)266L;\n+    public static int CXCursor_ForStmt() {\n+        return CXCursor_ForStmt;\n@@ -2409,0 +3213,1 @@\n+    private static final int CXCursor_GotoStmt = (int)210L;\n@@ -2410,2 +3215,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPDistributeParallelForSimdDirective = 267;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_GotoStmt = 210\n@@ -2414,2 +3219,2 @@\n-    public static int CXCursor_OMPDistributeParallelForSimdDirective() {\n-        return (int)267L;\n+    public static int CXCursor_GotoStmt() {\n+        return CXCursor_GotoStmt;\n@@ -2417,0 +3222,1 @@\n+    private static final int CXCursor_IndirectGotoStmt = (int)211L;\n@@ -2418,2 +3224,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPDistributeSimdDirective = 268;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_IndirectGotoStmt = 211\n@@ -2422,2 +3228,2 @@\n-    public static int CXCursor_OMPDistributeSimdDirective() {\n-        return (int)268L;\n+    public static int CXCursor_IndirectGotoStmt() {\n+        return CXCursor_IndirectGotoStmt;\n@@ -2425,0 +3231,1 @@\n+    private static final int CXCursor_ContinueStmt = (int)212L;\n@@ -2426,2 +3233,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTargetParallelForSimdDirective = 269;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ContinueStmt = 212\n@@ -2430,2 +3237,2 @@\n-    public static int CXCursor_OMPTargetParallelForSimdDirective() {\n-        return (int)269L;\n+    public static int CXCursor_ContinueStmt() {\n+        return CXCursor_ContinueStmt;\n@@ -2433,0 +3240,1 @@\n+    private static final int CXCursor_BreakStmt = (int)213L;\n@@ -2434,2 +3242,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTargetSimdDirective = 270;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_BreakStmt = 213\n@@ -2438,2 +3246,2 @@\n-    public static int CXCursor_OMPTargetSimdDirective() {\n-        return (int)270L;\n+    public static int CXCursor_BreakStmt() {\n+        return CXCursor_BreakStmt;\n@@ -2441,0 +3249,1 @@\n+    private static final int CXCursor_ReturnStmt = (int)214L;\n@@ -2442,2 +3251,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTeamsDistributeDirective = 271;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ReturnStmt = 214\n@@ -2446,2 +3255,2 @@\n-    public static int CXCursor_OMPTeamsDistributeDirective() {\n-        return (int)271L;\n+    public static int CXCursor_ReturnStmt() {\n+        return CXCursor_ReturnStmt;\n@@ -2449,0 +3258,1 @@\n+    private static final int CXCursor_GCCAsmStmt = (int)215L;\n@@ -2450,2 +3260,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTeamsDistributeSimdDirective = 272;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_GCCAsmStmt = 215\n@@ -2454,2 +3264,2 @@\n-    public static int CXCursor_OMPTeamsDistributeSimdDirective() {\n-        return (int)272L;\n+    public static int CXCursor_GCCAsmStmt() {\n+        return CXCursor_GCCAsmStmt;\n@@ -2457,0 +3267,1 @@\n+    private static final int CXCursor_AsmStmt = (int)215L;\n@@ -2458,2 +3269,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTeamsDistributeParallelForSimdDirective = 273;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_AsmStmt = 215\n@@ -2462,2 +3273,2 @@\n-    public static int CXCursor_OMPTeamsDistributeParallelForSimdDirective() {\n-        return (int)273L;\n+    public static int CXCursor_AsmStmt() {\n+        return CXCursor_AsmStmt;\n@@ -2465,0 +3276,1 @@\n+    private static final int CXCursor_ObjCAtTryStmt = (int)216L;\n@@ -2466,2 +3278,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTeamsDistributeParallelForDirective = 274;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCAtTryStmt = 216\n@@ -2470,2 +3282,2 @@\n-    public static int CXCursor_OMPTeamsDistributeParallelForDirective() {\n-        return (int)274L;\n+    public static int CXCursor_ObjCAtTryStmt() {\n+        return CXCursor_ObjCAtTryStmt;\n@@ -2473,0 +3285,1 @@\n+    private static final int CXCursor_ObjCAtCatchStmt = (int)217L;\n@@ -2474,2 +3287,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTargetTeamsDirective = 275;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCAtCatchStmt = 217\n@@ -2478,2 +3291,2 @@\n-    public static int CXCursor_OMPTargetTeamsDirective() {\n-        return (int)275L;\n+    public static int CXCursor_ObjCAtCatchStmt() {\n+        return CXCursor_ObjCAtCatchStmt;\n@@ -2481,0 +3294,1 @@\n+    private static final int CXCursor_ObjCAtFinallyStmt = (int)218L;\n@@ -2482,2 +3296,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTargetTeamsDistributeDirective = 276;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCAtFinallyStmt = 218\n@@ -2486,2 +3300,2 @@\n-    public static int CXCursor_OMPTargetTeamsDistributeDirective() {\n-        return (int)276L;\n+    public static int CXCursor_ObjCAtFinallyStmt() {\n+        return CXCursor_ObjCAtFinallyStmt;\n@@ -2489,0 +3303,1 @@\n+    private static final int CXCursor_ObjCAtThrowStmt = (int)219L;\n@@ -2490,2 +3305,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTargetTeamsDistributeParallelForDirective = 277;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCAtThrowStmt = 219\n@@ -2494,2 +3309,2 @@\n-    public static int CXCursor_OMPTargetTeamsDistributeParallelForDirective() {\n-        return (int)277L;\n+    public static int CXCursor_ObjCAtThrowStmt() {\n+        return CXCursor_ObjCAtThrowStmt;\n@@ -2497,0 +3312,1 @@\n+    private static final int CXCursor_ObjCAtSynchronizedStmt = (int)220L;\n@@ -2498,2 +3314,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective = 278;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCAtSynchronizedStmt = 220\n@@ -2502,2 +3318,2 @@\n-    public static int CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective() {\n-        return (int)278L;\n+    public static int CXCursor_ObjCAtSynchronizedStmt() {\n+        return CXCursor_ObjCAtSynchronizedStmt;\n@@ -2505,0 +3321,1 @@\n+    private static final int CXCursor_ObjCAutoreleasePoolStmt = (int)221L;\n@@ -2506,2 +3323,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPTargetTeamsDistributeSimdDirective = 279;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCAutoreleasePoolStmt = 221\n@@ -2510,2 +3327,2 @@\n-    public static int CXCursor_OMPTargetTeamsDistributeSimdDirective() {\n-        return (int)279L;\n+    public static int CXCursor_ObjCAutoreleasePoolStmt() {\n+        return CXCursor_ObjCAutoreleasePoolStmt;\n@@ -2513,0 +3330,1 @@\n+    private static final int CXCursor_ObjCForCollectionStmt = (int)222L;\n@@ -2514,2 +3332,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_BuiltinBitCastExpr = 280;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCForCollectionStmt = 222\n@@ -2518,2 +3336,2 @@\n-    public static int CXCursor_BuiltinBitCastExpr() {\n-        return (int)280L;\n+    public static int CXCursor_ObjCForCollectionStmt() {\n+        return CXCursor_ObjCForCollectionStmt;\n@@ -2521,0 +3339,1 @@\n+    private static final int CXCursor_CXXCatchStmt = (int)223L;\n@@ -2522,2 +3341,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPMasterTaskLoopDirective = 281;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CXXCatchStmt = 223\n@@ -2526,2 +3345,2 @@\n-    public static int CXCursor_OMPMasterTaskLoopDirective() {\n-        return (int)281L;\n+    public static int CXCursor_CXXCatchStmt() {\n+        return CXCursor_CXXCatchStmt;\n@@ -2529,0 +3348,1 @@\n+    private static final int CXCursor_CXXTryStmt = (int)224L;\n@@ -2530,2 +3350,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPParallelMasterTaskLoopDirective = 282;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CXXTryStmt = 224\n@@ -2534,2 +3354,2 @@\n-    public static int CXCursor_OMPParallelMasterTaskLoopDirective() {\n-        return (int)282L;\n+    public static int CXCursor_CXXTryStmt() {\n+        return CXCursor_CXXTryStmt;\n@@ -2537,0 +3357,1 @@\n+    private static final int CXCursor_CXXForRangeStmt = (int)225L;\n@@ -2538,2 +3359,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPMasterTaskLoopSimdDirective = 283;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CXXForRangeStmt = 225\n@@ -2542,2 +3363,2 @@\n-    public static int CXCursor_OMPMasterTaskLoopSimdDirective() {\n-        return (int)283L;\n+    public static int CXCursor_CXXForRangeStmt() {\n+        return CXCursor_CXXForRangeStmt;\n@@ -2545,0 +3366,1 @@\n+    private static final int CXCursor_SEHTryStmt = (int)226L;\n@@ -2546,2 +3368,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OMPParallelMasterTaskLoopSimdDirective = 284;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_SEHTryStmt = 226\n@@ -2550,2 +3372,2 @@\n-    public static int CXCursor_OMPParallelMasterTaskLoopSimdDirective() {\n-        return (int)284L;\n+    public static int CXCursor_SEHTryStmt() {\n+        return CXCursor_SEHTryStmt;\n@@ -2553,0 +3375,1 @@\n+    private static final int CXCursor_SEHExceptStmt = (int)227L;\n@@ -2554,2 +3377,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_LastStmt = 293;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_SEHExceptStmt = 227\n@@ -2558,2 +3381,2 @@\n-    public static int CXCursor_LastStmt() {\n-        return (int)293L;\n+    public static int CXCursor_SEHExceptStmt() {\n+        return CXCursor_SEHExceptStmt;\n@@ -2561,0 +3384,1 @@\n+    private static final int CXCursor_SEHFinallyStmt = (int)228L;\n@@ -2562,2 +3386,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_TranslationUnit = 300;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_SEHFinallyStmt = 228\n@@ -2566,2 +3390,2 @@\n-    public static int CXCursor_TranslationUnit() {\n-        return (int)300L;\n+    public static int CXCursor_SEHFinallyStmt() {\n+        return CXCursor_SEHFinallyStmt;\n@@ -2569,0 +3393,1 @@\n+    private static final int CXCursor_MSAsmStmt = (int)229L;\n@@ -2570,2 +3395,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_FirstAttr = 400;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_MSAsmStmt = 229\n@@ -2574,2 +3399,2 @@\n-    public static int CXCursor_FirstAttr() {\n-        return (int)400L;\n+    public static int CXCursor_MSAsmStmt() {\n+        return CXCursor_MSAsmStmt;\n@@ -2577,0 +3402,1 @@\n+    private static final int CXCursor_NullStmt = (int)230L;\n@@ -2578,2 +3404,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_UnexposedAttr = 400;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_NullStmt = 230\n@@ -2582,2 +3408,2 @@\n-    public static int CXCursor_UnexposedAttr() {\n-        return (int)400L;\n+    public static int CXCursor_NullStmt() {\n+        return CXCursor_NullStmt;\n@@ -2585,0 +3411,1 @@\n+    private static final int CXCursor_DeclStmt = (int)231L;\n@@ -2586,2 +3413,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_IBActionAttr = 401;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_DeclStmt = 231\n@@ -2590,2 +3417,2 @@\n-    public static int CXCursor_IBActionAttr() {\n-        return (int)401L;\n+    public static int CXCursor_DeclStmt() {\n+        return CXCursor_DeclStmt;\n@@ -2593,0 +3420,1 @@\n+    private static final int CXCursor_OMPParallelDirective = (int)232L;\n@@ -2594,2 +3422,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_IBOutletAttr = 402;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPParallelDirective = 232\n@@ -2598,2 +3426,2 @@\n-    public static int CXCursor_IBOutletAttr() {\n-        return (int)402L;\n+    public static int CXCursor_OMPParallelDirective() {\n+        return CXCursor_OMPParallelDirective;\n@@ -2601,0 +3429,1 @@\n+    private static final int CXCursor_OMPSimdDirective = (int)233L;\n@@ -2602,2 +3431,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_IBOutletCollectionAttr = 403;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPSimdDirective = 233\n@@ -2606,2 +3435,2 @@\n-    public static int CXCursor_IBOutletCollectionAttr() {\n-        return (int)403L;\n+    public static int CXCursor_OMPSimdDirective() {\n+        return CXCursor_OMPSimdDirective;\n@@ -2609,0 +3438,1 @@\n+    private static final int CXCursor_OMPForDirective = (int)234L;\n@@ -2610,2 +3440,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CXXFinalAttr = 404;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPForDirective = 234\n@@ -2614,2 +3444,2 @@\n-    public static int CXCursor_CXXFinalAttr() {\n-        return (int)404L;\n+    public static int CXCursor_OMPForDirective() {\n+        return CXCursor_OMPForDirective;\n@@ -2617,0 +3447,1 @@\n+    private static final int CXCursor_OMPSectionsDirective = (int)235L;\n@@ -2618,2 +3449,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CXXOverrideAttr = 405;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPSectionsDirective = 235\n@@ -2622,2 +3453,2 @@\n-    public static int CXCursor_CXXOverrideAttr() {\n-        return (int)405L;\n+    public static int CXCursor_OMPSectionsDirective() {\n+        return CXCursor_OMPSectionsDirective;\n@@ -2625,0 +3456,1 @@\n+    private static final int CXCursor_OMPSectionDirective = (int)236L;\n@@ -2626,2 +3458,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_AnnotateAttr = 406;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPSectionDirective = 236\n@@ -2630,2 +3462,2 @@\n-    public static int CXCursor_AnnotateAttr() {\n-        return (int)406L;\n+    public static int CXCursor_OMPSectionDirective() {\n+        return CXCursor_OMPSectionDirective;\n@@ -2633,0 +3465,1 @@\n+    private static final int CXCursor_OMPSingleDirective = (int)237L;\n@@ -2634,2 +3467,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_AsmLabelAttr = 407;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPSingleDirective = 237\n@@ -2638,2 +3471,2 @@\n-    public static int CXCursor_AsmLabelAttr() {\n-        return (int)407L;\n+    public static int CXCursor_OMPSingleDirective() {\n+        return CXCursor_OMPSingleDirective;\n@@ -2641,0 +3474,1 @@\n+    private static final int CXCursor_OMPParallelForDirective = (int)238L;\n@@ -2642,2 +3476,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_PackedAttr = 408;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPParallelForDirective = 238\n@@ -2646,2 +3480,2 @@\n-    public static int CXCursor_PackedAttr() {\n-        return (int)408L;\n+    public static int CXCursor_OMPParallelForDirective() {\n+        return CXCursor_OMPParallelForDirective;\n@@ -2649,0 +3483,1 @@\n+    private static final int CXCursor_OMPParallelSectionsDirective = (int)239L;\n@@ -2650,2 +3485,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_PureAttr = 409;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPParallelSectionsDirective = 239\n@@ -2654,2 +3489,2 @@\n-    public static int CXCursor_PureAttr() {\n-        return (int)409L;\n+    public static int CXCursor_OMPParallelSectionsDirective() {\n+        return CXCursor_OMPParallelSectionsDirective;\n@@ -2657,0 +3492,1 @@\n+    private static final int CXCursor_OMPTaskDirective = (int)240L;\n@@ -2658,2 +3494,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ConstAttr = 410;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTaskDirective = 240\n@@ -2662,2 +3498,2 @@\n-    public static int CXCursor_ConstAttr() {\n-        return (int)410L;\n+    public static int CXCursor_OMPTaskDirective() {\n+        return CXCursor_OMPTaskDirective;\n@@ -2665,0 +3501,1 @@\n+    private static final int CXCursor_OMPMasterDirective = (int)241L;\n@@ -2666,2 +3503,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_NoDuplicateAttr = 411;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPMasterDirective = 241\n@@ -2670,2 +3507,2 @@\n-    public static int CXCursor_NoDuplicateAttr() {\n-        return (int)411L;\n+    public static int CXCursor_OMPMasterDirective() {\n+        return CXCursor_OMPMasterDirective;\n@@ -2673,0 +3510,1 @@\n+    private static final int CXCursor_OMPCriticalDirective = (int)242L;\n@@ -2674,2 +3512,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CUDAConstantAttr = 412;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPCriticalDirective = 242\n@@ -2678,2 +3516,2 @@\n-    public static int CXCursor_CUDAConstantAttr() {\n-        return (int)412L;\n+    public static int CXCursor_OMPCriticalDirective() {\n+        return CXCursor_OMPCriticalDirective;\n@@ -2681,0 +3519,1 @@\n+    private static final int CXCursor_OMPTaskyieldDirective = (int)243L;\n@@ -2682,2 +3521,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CUDADeviceAttr = 413;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTaskyieldDirective = 243\n@@ -2686,2 +3525,2 @@\n-    public static int CXCursor_CUDADeviceAttr() {\n-        return (int)413L;\n+    public static int CXCursor_OMPTaskyieldDirective() {\n+        return CXCursor_OMPTaskyieldDirective;\n@@ -2689,0 +3528,1 @@\n+    private static final int CXCursor_OMPBarrierDirective = (int)244L;\n@@ -2690,2 +3530,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CUDAGlobalAttr = 414;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPBarrierDirective = 244\n@@ -2694,2 +3534,2 @@\n-    public static int CXCursor_CUDAGlobalAttr() {\n-        return (int)414L;\n+    public static int CXCursor_OMPBarrierDirective() {\n+        return CXCursor_OMPBarrierDirective;\n@@ -2697,0 +3537,1 @@\n+    private static final int CXCursor_OMPTaskwaitDirective = (int)245L;\n@@ -2698,2 +3539,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CUDAHostAttr = 415;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTaskwaitDirective = 245\n@@ -2702,2 +3543,2 @@\n-    public static int CXCursor_CUDAHostAttr() {\n-        return (int)415L;\n+    public static int CXCursor_OMPTaskwaitDirective() {\n+        return CXCursor_OMPTaskwaitDirective;\n@@ -2705,0 +3546,1 @@\n+    private static final int CXCursor_OMPFlushDirective = (int)246L;\n@@ -2706,2 +3548,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_CUDASharedAttr = 416;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPFlushDirective = 246\n@@ -2710,2 +3552,2 @@\n-    public static int CXCursor_CUDASharedAttr() {\n-        return (int)416L;\n+    public static int CXCursor_OMPFlushDirective() {\n+        return CXCursor_OMPFlushDirective;\n@@ -2713,0 +3555,1 @@\n+    private static final int CXCursor_SEHLeaveStmt = (int)247L;\n@@ -2714,2 +3557,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_VisibilityAttr = 417;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_SEHLeaveStmt = 247\n@@ -2718,2 +3561,2 @@\n-    public static int CXCursor_VisibilityAttr() {\n-        return (int)417L;\n+    public static int CXCursor_SEHLeaveStmt() {\n+        return CXCursor_SEHLeaveStmt;\n@@ -2721,0 +3564,1 @@\n+    private static final int CXCursor_OMPOrderedDirective = (int)248L;\n@@ -2722,2 +3566,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_DLLExport = 418;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPOrderedDirective = 248\n@@ -2726,2 +3570,2 @@\n-    public static int CXCursor_DLLExport() {\n-        return (int)418L;\n+    public static int CXCursor_OMPOrderedDirective() {\n+        return CXCursor_OMPOrderedDirective;\n@@ -2729,0 +3573,1 @@\n+    private static final int CXCursor_OMPAtomicDirective = (int)249L;\n@@ -2730,2 +3575,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_DLLImport = 419;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPAtomicDirective = 249\n@@ -2734,2 +3579,2 @@\n-    public static int CXCursor_DLLImport() {\n-        return (int)419L;\n+    public static int CXCursor_OMPAtomicDirective() {\n+        return CXCursor_OMPAtomicDirective;\n@@ -2737,0 +3582,1 @@\n+    private static final int CXCursor_OMPForSimdDirective = (int)250L;\n@@ -2738,2 +3584,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_NSReturnsRetained = 420;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPForSimdDirective = 250\n@@ -2742,2 +3588,2 @@\n-    public static int CXCursor_NSReturnsRetained() {\n-        return (int)420L;\n+    public static int CXCursor_OMPForSimdDirective() {\n+        return CXCursor_OMPForSimdDirective;\n@@ -2745,0 +3591,1 @@\n+    private static final int CXCursor_OMPParallelForSimdDirective = (int)251L;\n@@ -2746,2 +3593,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_NSReturnsNotRetained = 421;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPParallelForSimdDirective = 251\n@@ -2750,2 +3597,2 @@\n-    public static int CXCursor_NSReturnsNotRetained() {\n-        return (int)421L;\n+    public static int CXCursor_OMPParallelForSimdDirective() {\n+        return CXCursor_OMPParallelForSimdDirective;\n@@ -2753,0 +3600,1 @@\n+    private static final int CXCursor_OMPTargetDirective = (int)252L;\n@@ -2754,2 +3602,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_NSReturnsAutoreleased = 422;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTargetDirective = 252\n@@ -2758,2 +3606,2 @@\n-    public static int CXCursor_NSReturnsAutoreleased() {\n-        return (int)422L;\n+    public static int CXCursor_OMPTargetDirective() {\n+        return CXCursor_OMPTargetDirective;\n@@ -2761,0 +3609,1 @@\n+    private static final int CXCursor_OMPTeamsDirective = (int)253L;\n@@ -2762,2 +3611,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_NSConsumesSelf = 423;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTeamsDirective = 253\n@@ -2766,2 +3615,2 @@\n-    public static int CXCursor_NSConsumesSelf() {\n-        return (int)423L;\n+    public static int CXCursor_OMPTeamsDirective() {\n+        return CXCursor_OMPTeamsDirective;\n@@ -2769,0 +3618,1 @@\n+    private static final int CXCursor_OMPTaskgroupDirective = (int)254L;\n@@ -2770,2 +3620,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_NSConsumed = 424;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTaskgroupDirective = 254\n@@ -2774,2 +3624,2 @@\n-    public static int CXCursor_NSConsumed() {\n-        return (int)424L;\n+    public static int CXCursor_OMPTaskgroupDirective() {\n+        return CXCursor_OMPTaskgroupDirective;\n@@ -2777,0 +3627,1 @@\n+    private static final int CXCursor_OMPCancellationPointDirective = (int)255L;\n@@ -2778,2 +3629,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCException = 425;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPCancellationPointDirective = 255\n@@ -2782,2 +3633,2 @@\n-    public static int CXCursor_ObjCException() {\n-        return (int)425L;\n+    public static int CXCursor_OMPCancellationPointDirective() {\n+        return CXCursor_OMPCancellationPointDirective;\n@@ -2785,0 +3636,1 @@\n+    private static final int CXCursor_OMPCancelDirective = (int)256L;\n@@ -2786,2 +3638,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCNSObject = 426;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPCancelDirective = 256\n@@ -2790,2 +3642,2 @@\n-    public static int CXCursor_ObjCNSObject() {\n-        return (int)426L;\n+    public static int CXCursor_OMPCancelDirective() {\n+        return CXCursor_OMPCancelDirective;\n@@ -2793,0 +3645,1 @@\n+    private static final int CXCursor_OMPTargetDataDirective = (int)257L;\n@@ -2794,2 +3647,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCIndependentClass = 427;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTargetDataDirective = 257\n@@ -2798,2 +3651,2 @@\n-    public static int CXCursor_ObjCIndependentClass() {\n-        return (int)427L;\n+    public static int CXCursor_OMPTargetDataDirective() {\n+        return CXCursor_OMPTargetDataDirective;\n@@ -2801,0 +3654,1 @@\n+    private static final int CXCursor_OMPTaskLoopDirective = (int)258L;\n@@ -2802,2 +3656,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCPreciseLifetime = 428;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTaskLoopDirective = 258\n@@ -2806,2 +3660,2 @@\n-    public static int CXCursor_ObjCPreciseLifetime() {\n-        return (int)428L;\n+    public static int CXCursor_OMPTaskLoopDirective() {\n+        return CXCursor_OMPTaskLoopDirective;\n@@ -2809,0 +3663,1 @@\n+    private static final int CXCursor_OMPTaskLoopSimdDirective = (int)259L;\n@@ -2810,2 +3665,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCReturnsInnerPointer = 429;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTaskLoopSimdDirective = 259\n@@ -2814,2 +3669,2 @@\n-    public static int CXCursor_ObjCReturnsInnerPointer() {\n-        return (int)429L;\n+    public static int CXCursor_OMPTaskLoopSimdDirective() {\n+        return CXCursor_OMPTaskLoopSimdDirective;\n@@ -2817,0 +3672,1 @@\n+    private static final int CXCursor_OMPDistributeDirective = (int)260L;\n@@ -2818,2 +3674,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCRequiresSuper = 430;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPDistributeDirective = 260\n@@ -2822,2 +3678,2 @@\n-    public static int CXCursor_ObjCRequiresSuper() {\n-        return (int)430L;\n+    public static int CXCursor_OMPDistributeDirective() {\n+        return CXCursor_OMPDistributeDirective;\n@@ -2825,0 +3681,1 @@\n+    private static final int CXCursor_OMPTargetEnterDataDirective = (int)261L;\n@@ -2826,2 +3683,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCRootClass = 431;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTargetEnterDataDirective = 261\n@@ -2830,2 +3687,2 @@\n-    public static int CXCursor_ObjCRootClass() {\n-        return (int)431L;\n+    public static int CXCursor_OMPTargetEnterDataDirective() {\n+        return CXCursor_OMPTargetEnterDataDirective;\n@@ -2833,0 +3690,1 @@\n+    private static final int CXCursor_OMPTargetExitDataDirective = (int)262L;\n@@ -2834,2 +3692,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCSubclassingRestricted = 432;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTargetExitDataDirective = 262\n@@ -2838,2 +3696,2 @@\n-    public static int CXCursor_ObjCSubclassingRestricted() {\n-        return (int)432L;\n+    public static int CXCursor_OMPTargetExitDataDirective() {\n+        return CXCursor_OMPTargetExitDataDirective;\n@@ -2841,0 +3699,1 @@\n+    private static final int CXCursor_OMPTargetParallelDirective = (int)263L;\n@@ -2842,2 +3701,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCExplicitProtocolImpl = 433;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTargetParallelDirective = 263\n@@ -2846,2 +3705,2 @@\n-    public static int CXCursor_ObjCExplicitProtocolImpl() {\n-        return (int)433L;\n+    public static int CXCursor_OMPTargetParallelDirective() {\n+        return CXCursor_OMPTargetParallelDirective;\n@@ -2849,0 +3708,1 @@\n+    private static final int CXCursor_OMPTargetParallelForDirective = (int)264L;\n@@ -2850,2 +3710,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCDesignatedInitializer = 434;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTargetParallelForDirective = 264\n@@ -2854,2 +3714,2 @@\n-    public static int CXCursor_ObjCDesignatedInitializer() {\n-        return (int)434L;\n+    public static int CXCursor_OMPTargetParallelForDirective() {\n+        return CXCursor_OMPTargetParallelForDirective;\n@@ -2857,0 +3717,1 @@\n+    private static final int CXCursor_OMPTargetUpdateDirective = (int)265L;\n@@ -2858,2 +3719,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCRuntimeVisible = 435;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTargetUpdateDirective = 265\n@@ -2862,2 +3723,2 @@\n-    public static int CXCursor_ObjCRuntimeVisible() {\n-        return (int)435L;\n+    public static int CXCursor_OMPTargetUpdateDirective() {\n+        return CXCursor_OMPTargetUpdateDirective;\n@@ -2865,0 +3726,1 @@\n+    private static final int CXCursor_OMPDistributeParallelForDirective = (int)266L;\n@@ -2866,2 +3728,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ObjCBoxable = 436;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPDistributeParallelForDirective = 266\n@@ -2870,2 +3732,2 @@\n-    public static int CXCursor_ObjCBoxable() {\n-        return (int)436L;\n+    public static int CXCursor_OMPDistributeParallelForDirective() {\n+        return CXCursor_OMPDistributeParallelForDirective;\n@@ -2873,0 +3735,1 @@\n+    private static final int CXCursor_OMPDistributeParallelForSimdDirective = (int)267L;\n@@ -2874,2 +3737,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_FlagEnum = 437;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPDistributeParallelForSimdDirective = 267\n@@ -2878,2 +3741,2 @@\n-    public static int CXCursor_FlagEnum() {\n-        return (int)437L;\n+    public static int CXCursor_OMPDistributeParallelForSimdDirective() {\n+        return CXCursor_OMPDistributeParallelForSimdDirective;\n@@ -2881,0 +3744,1 @@\n+    private static final int CXCursor_OMPDistributeSimdDirective = (int)268L;\n@@ -2882,2 +3746,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ConvergentAttr = 438;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPDistributeSimdDirective = 268\n@@ -2886,2 +3750,2 @@\n-    public static int CXCursor_ConvergentAttr() {\n-        return (int)438L;\n+    public static int CXCursor_OMPDistributeSimdDirective() {\n+        return CXCursor_OMPDistributeSimdDirective;\n@@ -2889,0 +3753,1 @@\n+    private static final int CXCursor_OMPTargetParallelForSimdDirective = (int)269L;\n@@ -2890,2 +3755,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_WarnUnusedAttr = 439;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTargetParallelForSimdDirective = 269\n@@ -2894,2 +3759,2 @@\n-    public static int CXCursor_WarnUnusedAttr() {\n-        return (int)439L;\n+    public static int CXCursor_OMPTargetParallelForSimdDirective() {\n+        return CXCursor_OMPTargetParallelForSimdDirective;\n@@ -2897,0 +3762,1 @@\n+    private static final int CXCursor_OMPTargetSimdDirective = (int)270L;\n@@ -2898,2 +3764,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_WarnUnusedResultAttr = 440;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTargetSimdDirective = 270\n@@ -2902,2 +3768,2 @@\n-    public static int CXCursor_WarnUnusedResultAttr() {\n-        return (int)440L;\n+    public static int CXCursor_OMPTargetSimdDirective() {\n+        return CXCursor_OMPTargetSimdDirective;\n@@ -2905,0 +3771,1 @@\n+    private static final int CXCursor_OMPTeamsDistributeDirective = (int)271L;\n@@ -2906,2 +3773,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_AlignedAttr = 441;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTeamsDistributeDirective = 271\n@@ -2910,2 +3777,2 @@\n-    public static int CXCursor_AlignedAttr() {\n-        return (int)441L;\n+    public static int CXCursor_OMPTeamsDistributeDirective() {\n+        return CXCursor_OMPTeamsDistributeDirective;\n@@ -2913,0 +3780,1 @@\n+    private static final int CXCursor_OMPTeamsDistributeSimdDirective = (int)272L;\n@@ -2914,2 +3782,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_LastAttr = 441;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTeamsDistributeSimdDirective = 272\n@@ -2918,2 +3786,2 @@\n-    public static int CXCursor_LastAttr() {\n-        return (int)441L;\n+    public static int CXCursor_OMPTeamsDistributeSimdDirective() {\n+        return CXCursor_OMPTeamsDistributeSimdDirective;\n@@ -2921,0 +3789,1 @@\n+    private static final int CXCursor_OMPTeamsDistributeParallelForSimdDirective = (int)273L;\n@@ -2922,2 +3791,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_PreprocessingDirective = 500;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTeamsDistributeParallelForSimdDirective = 273\n@@ -2926,2 +3795,2 @@\n-    public static int CXCursor_PreprocessingDirective() {\n-        return (int)500L;\n+    public static int CXCursor_OMPTeamsDistributeParallelForSimdDirective() {\n+        return CXCursor_OMPTeamsDistributeParallelForSimdDirective;\n@@ -2929,0 +3798,1 @@\n+    private static final int CXCursor_OMPTeamsDistributeParallelForDirective = (int)274L;\n@@ -2930,2 +3800,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_MacroDefinition = 501;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTeamsDistributeParallelForDirective = 274\n@@ -2934,2 +3804,2 @@\n-    public static int CXCursor_MacroDefinition() {\n-        return (int)501L;\n+    public static int CXCursor_OMPTeamsDistributeParallelForDirective() {\n+        return CXCursor_OMPTeamsDistributeParallelForDirective;\n@@ -2937,0 +3807,1 @@\n+    private static final int CXCursor_OMPTargetTeamsDirective = (int)275L;\n@@ -2938,2 +3809,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_MacroExpansion = 502;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTargetTeamsDirective = 275\n@@ -2942,2 +3813,2 @@\n-    public static int CXCursor_MacroExpansion() {\n-        return (int)502L;\n+    public static int CXCursor_OMPTargetTeamsDirective() {\n+        return CXCursor_OMPTargetTeamsDirective;\n@@ -2945,0 +3816,1 @@\n+    private static final int CXCursor_OMPTargetTeamsDistributeDirective = (int)276L;\n@@ -2946,2 +3818,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_MacroInstantiation = 502;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTargetTeamsDistributeDirective = 276\n@@ -2950,2 +3822,2 @@\n-    public static int CXCursor_MacroInstantiation() {\n-        return (int)502L;\n+    public static int CXCursor_OMPTargetTeamsDistributeDirective() {\n+        return CXCursor_OMPTargetTeamsDistributeDirective;\n@@ -2953,0 +3825,1 @@\n+    private static final int CXCursor_OMPTargetTeamsDistributeParallelForDirective = (int)277L;\n@@ -2954,2 +3827,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_InclusionDirective = 503;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTargetTeamsDistributeParallelForDirective = 277\n@@ -2958,2 +3831,2 @@\n-    public static int CXCursor_InclusionDirective() {\n-        return (int)503L;\n+    public static int CXCursor_OMPTargetTeamsDistributeParallelForDirective() {\n+        return CXCursor_OMPTargetTeamsDistributeParallelForDirective;\n@@ -2961,0 +3834,1 @@\n+    private static final int CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective = (int)278L;\n@@ -2962,2 +3836,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_FirstPreprocessing = 500;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective = 278\n@@ -2966,2 +3840,2 @@\n-    public static int CXCursor_FirstPreprocessing() {\n-        return (int)500L;\n+    public static int CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective() {\n+        return CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective;\n@@ -2969,0 +3843,1 @@\n+    private static final int CXCursor_OMPTargetTeamsDistributeSimdDirective = (int)279L;\n@@ -2970,2 +3845,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_LastPreprocessing = 503;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPTargetTeamsDistributeSimdDirective = 279\n@@ -2974,2 +3849,2 @@\n-    public static int CXCursor_LastPreprocessing() {\n-        return (int)503L;\n+    public static int CXCursor_OMPTargetTeamsDistributeSimdDirective() {\n+        return CXCursor_OMPTargetTeamsDistributeSimdDirective;\n@@ -2977,0 +3852,1 @@\n+    private static final int CXCursor_BuiltinBitCastExpr = (int)280L;\n@@ -2978,2 +3854,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_ModuleImportDecl = 600;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_BuiltinBitCastExpr = 280\n@@ -2982,2 +3858,2 @@\n-    public static int CXCursor_ModuleImportDecl() {\n-        return (int)600L;\n+    public static int CXCursor_BuiltinBitCastExpr() {\n+        return CXCursor_BuiltinBitCastExpr;\n@@ -2985,0 +3861,1 @@\n+    private static final int CXCursor_OMPMasterTaskLoopDirective = (int)281L;\n@@ -2986,2 +3863,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_TypeAliasTemplateDecl = 601;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPMasterTaskLoopDirective = 281\n@@ -2990,2 +3867,2 @@\n-    public static int CXCursor_TypeAliasTemplateDecl() {\n-        return (int)601L;\n+    public static int CXCursor_OMPMasterTaskLoopDirective() {\n+        return CXCursor_OMPMasterTaskLoopDirective;\n@@ -2993,0 +3870,1 @@\n+    private static final int CXCursor_OMPParallelMasterTaskLoopDirective = (int)282L;\n@@ -2994,2 +3872,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_StaticAssert = 602;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPParallelMasterTaskLoopDirective = 282\n@@ -2998,2 +3876,2 @@\n-    public static int CXCursor_StaticAssert() {\n-        return (int)602L;\n+    public static int CXCursor_OMPParallelMasterTaskLoopDirective() {\n+        return CXCursor_OMPParallelMasterTaskLoopDirective;\n@@ -3001,0 +3879,1 @@\n+    private static final int CXCursor_OMPMasterTaskLoopSimdDirective = (int)283L;\n@@ -3002,2 +3881,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_FriendDecl = 603;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPMasterTaskLoopSimdDirective = 283\n@@ -3006,2 +3885,2 @@\n-    public static int CXCursor_FriendDecl() {\n-        return (int)603L;\n+    public static int CXCursor_OMPMasterTaskLoopSimdDirective() {\n+        return CXCursor_OMPMasterTaskLoopSimdDirective;\n@@ -3009,0 +3888,1 @@\n+    private static final int CXCursor_OMPParallelMasterTaskLoopSimdDirective = (int)284L;\n@@ -3010,2 +3890,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_FirstExtraDecl = 600;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OMPParallelMasterTaskLoopSimdDirective = 284\n@@ -3014,2 +3894,2 @@\n-    public static int CXCursor_FirstExtraDecl() {\n-        return (int)600L;\n+    public static int CXCursor_OMPParallelMasterTaskLoopSimdDirective() {\n+        return CXCursor_OMPParallelMasterTaskLoopSimdDirective;\n@@ -3017,0 +3897,1 @@\n+    private static final int CXCursor_LastStmt = (int)293L;\n@@ -3018,2 +3899,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_LastExtraDecl = 603;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_LastStmt = 293\n@@ -3022,2 +3903,2 @@\n-    public static int CXCursor_LastExtraDecl() {\n-        return (int)603L;\n+    public static int CXCursor_LastStmt() {\n+        return CXCursor_LastStmt;\n@@ -3025,0 +3906,1 @@\n+    private static final int CXCursor_TranslationUnit = (int)300L;\n@@ -3026,2 +3908,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind.CXCursor_OverloadCandidate = 700;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_TranslationUnit = 300\n@@ -3030,5 +3912,2 @@\n-    public static int CXCursor_OverloadCandidate() {\n-        return (int)700L;\n-    }\n-    public static MethodHandle clang_getNullCursor$MH() {\n-        return RuntimeHelper.requireNonNull(constants$5.clang_getNullCursor$MH,\"clang_getNullCursor\");\n+    public static int CXCursor_TranslationUnit() {\n+        return CXCursor_TranslationUnit;\n@@ -3036,0 +3915,1 @@\n+    private static final int CXCursor_FirstAttr = (int)400L;\n@@ -3037,2 +3917,2 @@\n-     * {@snippet :\n-     * CXCursor clang_getNullCursor();\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_FirstAttr = 400\n@@ -3041,10 +3921,2 @@\n-    public static MemorySegment clang_getNullCursor(SegmentAllocator allocator) {\n-        var mh$ = clang_getNullCursor$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_getTranslationUnitCursor$MH() {\n-        return RuntimeHelper.requireNonNull(constants$5.clang_getTranslationUnitCursor$MH,\"clang_getTranslationUnitCursor\");\n+    public static int CXCursor_FirstAttr() {\n+        return CXCursor_FirstAttr;\n@@ -3052,0 +3924,1 @@\n+    private static final int CXCursor_UnexposedAttr = (int)400L;\n@@ -3053,2 +3926,2 @@\n-     * {@snippet :\n-     * CXCursor clang_getTranslationUnitCursor(CXTranslationUnit);\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_UnexposedAttr = 400\n@@ -3057,10 +3930,2 @@\n-    public static MemorySegment clang_getTranslationUnitCursor(SegmentAllocator allocator, MemorySegment x1) {\n-        var mh$ = clang_getTranslationUnitCursor$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_equalCursors$MH() {\n-        return RuntimeHelper.requireNonNull(constants$5.clang_equalCursors$MH,\"clang_equalCursors\");\n+    public static int CXCursor_UnexposedAttr() {\n+        return CXCursor_UnexposedAttr;\n@@ -3068,0 +3933,1 @@\n+    private static final int CXCursor_IBActionAttr = (int)401L;\n@@ -3069,2 +3935,2 @@\n-     * {@snippet :\n-     * unsigned int clang_equalCursors(CXCursor, CXCursor);\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_IBActionAttr = 401\n@@ -3073,10 +3939,2 @@\n-    public static int clang_equalCursors(MemorySegment x0, MemorySegment x1) {\n-        var mh$ = clang_equalCursors$MH();\n-        try {\n-            return (int)mh$.invokeExact(x0, x1);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_Cursor_isNull$MH() {\n-        return RuntimeHelper.requireNonNull(constants$5.clang_Cursor_isNull$MH,\"clang_Cursor_isNull\");\n+    public static int CXCursor_IBActionAttr() {\n+        return CXCursor_IBActionAttr;\n@@ -3084,0 +3942,1 @@\n+    private static final int CXCursor_IBOutletAttr = (int)402L;\n@@ -3085,2 +3944,2 @@\n-     * {@snippet :\n-     * int clang_Cursor_isNull(CXCursor cursor);\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_IBOutletAttr = 402\n@@ -3089,10 +3948,2 @@\n-    public static int clang_Cursor_isNull(MemorySegment cursor) {\n-        var mh$ = clang_Cursor_isNull$MH();\n-        try {\n-            return (int)mh$.invokeExact(cursor);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_getCursorKind$MH() {\n-        return RuntimeHelper.requireNonNull(constants$6.clang_getCursorKind$MH,\"clang_getCursorKind\");\n+    public static int CXCursor_IBOutletAttr() {\n+        return CXCursor_IBOutletAttr;\n@@ -3100,0 +3951,1 @@\n+    private static final int CXCursor_IBOutletCollectionAttr = (int)403L;\n@@ -3101,2 +3953,2 @@\n-     * {@snippet :\n-     * enum CXCursorKind clang_getCursorKind(CXCursor);\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_IBOutletCollectionAttr = 403\n@@ -3105,10 +3957,2 @@\n-    public static int clang_getCursorKind(MemorySegment x0) {\n-        var mh$ = clang_getCursorKind$MH();\n-        try {\n-            return (int)mh$.invokeExact(x0);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_isDeclaration$MH() {\n-        return RuntimeHelper.requireNonNull(constants$6.clang_isDeclaration$MH,\"clang_isDeclaration\");\n+    public static int CXCursor_IBOutletCollectionAttr() {\n+        return CXCursor_IBOutletCollectionAttr;\n@@ -3116,0 +3960,1 @@\n+    private static final int CXCursor_CXXFinalAttr = (int)404L;\n@@ -3117,2 +3962,2 @@\n-     * {@snippet :\n-     * unsigned int clang_isDeclaration(enum CXCursorKind);\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CXXFinalAttr = 404\n@@ -3121,10 +3966,2 @@\n-    public static int clang_isDeclaration(int x0) {\n-        var mh$ = clang_isDeclaration$MH();\n-        try {\n-            return (int)mh$.invokeExact(x0);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_isAttribute$MH() {\n-        return RuntimeHelper.requireNonNull(constants$6.clang_isAttribute$MH,\"clang_isAttribute\");\n+    public static int CXCursor_CXXFinalAttr() {\n+        return CXCursor_CXXFinalAttr;\n@@ -3132,0 +3969,1 @@\n+    private static final int CXCursor_CXXOverrideAttr = (int)405L;\n@@ -3133,2 +3971,2 @@\n-     * {@snippet :\n-     * unsigned int clang_isAttribute(enum CXCursorKind);\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CXXOverrideAttr = 405\n@@ -3137,10 +3975,2 @@\n-    public static int clang_isAttribute(int x0) {\n-        var mh$ = clang_isAttribute$MH();\n-        try {\n-            return (int)mh$.invokeExact(x0);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_isInvalid$MH() {\n-        return RuntimeHelper.requireNonNull(constants$6.clang_isInvalid$MH,\"clang_isInvalid\");\n+    public static int CXCursor_CXXOverrideAttr() {\n+        return CXCursor_CXXOverrideAttr;\n@@ -3148,0 +3978,1 @@\n+    private static final int CXCursor_AnnotateAttr = (int)406L;\n@@ -3149,2 +3980,2 @@\n-     * {@snippet :\n-     * unsigned int clang_isInvalid(enum CXCursorKind);\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_AnnotateAttr = 406\n@@ -3153,10 +3984,2 @@\n-    public static int clang_isInvalid(int x0) {\n-        var mh$ = clang_isInvalid$MH();\n-        try {\n-            return (int)mh$.invokeExact(x0);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_isPreprocessing$MH() {\n-        return RuntimeHelper.requireNonNull(constants$6.clang_isPreprocessing$MH,\"clang_isPreprocessing\");\n+    public static int CXCursor_AnnotateAttr() {\n+        return CXCursor_AnnotateAttr;\n@@ -3164,0 +3987,1 @@\n+    private static final int CXCursor_AsmLabelAttr = (int)407L;\n@@ -3165,2 +3989,2 @@\n-     * {@snippet :\n-     * unsigned int clang_isPreprocessing(enum CXCursorKind);\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_AsmLabelAttr = 407\n@@ -3169,7 +3993,2 @@\n-    public static int clang_isPreprocessing(int x0) {\n-        var mh$ = clang_isPreprocessing$MH();\n-        try {\n-            return (int)mh$.invokeExact(x0);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static int CXCursor_AsmLabelAttr() {\n+        return CXCursor_AsmLabelAttr;\n@@ -3177,0 +3996,1 @@\n+    private static final int CXCursor_PackedAttr = (int)408L;\n@@ -3178,2 +3998,2 @@\n-     * {@snippet :\n-     * enum CXLinkageKind.CXLinkage_Invalid = 0;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_PackedAttr = 408\n@@ -3182,2 +4002,2 @@\n-    public static int CXLinkage_Invalid() {\n-        return (int)0L;\n+    public static int CXCursor_PackedAttr() {\n+        return CXCursor_PackedAttr;\n@@ -3185,0 +4005,1 @@\n+    private static final int CXCursor_PureAttr = (int)409L;\n@@ -3186,2 +4007,2 @@\n-     * {@snippet :\n-     * enum CXLinkageKind.CXLinkage_NoLinkage = 1;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_PureAttr = 409\n@@ -3190,2 +4011,2 @@\n-    public static int CXLinkage_NoLinkage() {\n-        return (int)1L;\n+    public static int CXCursor_PureAttr() {\n+        return CXCursor_PureAttr;\n@@ -3193,0 +4014,1 @@\n+    private static final int CXCursor_ConstAttr = (int)410L;\n@@ -3194,2 +4016,2 @@\n-     * {@snippet :\n-     * enum CXLinkageKind.CXLinkage_Internal = 2;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ConstAttr = 410\n@@ -3198,2 +4020,2 @@\n-    public static int CXLinkage_Internal() {\n-        return (int)2L;\n+    public static int CXCursor_ConstAttr() {\n+        return CXCursor_ConstAttr;\n@@ -3201,0 +4023,1 @@\n+    private static final int CXCursor_NoDuplicateAttr = (int)411L;\n@@ -3202,2 +4025,2 @@\n-     * {@snippet :\n-     * enum CXLinkageKind.CXLinkage_UniqueExternal = 3;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_NoDuplicateAttr = 411\n@@ -3206,2 +4029,2 @@\n-    public static int CXLinkage_UniqueExternal() {\n-        return (int)3L;\n+    public static int CXCursor_NoDuplicateAttr() {\n+        return CXCursor_NoDuplicateAttr;\n@@ -3209,0 +4032,1 @@\n+    private static final int CXCursor_CUDAConstantAttr = (int)412L;\n@@ -3210,2 +4034,2 @@\n-     * {@snippet :\n-     * enum CXLinkageKind.CXLinkage_External = 4;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CUDAConstantAttr = 412\n@@ -3214,2 +4038,2 @@\n-    public static int CXLinkage_External() {\n-        return (int)4L;\n+    public static int CXCursor_CUDAConstantAttr() {\n+        return CXCursor_CUDAConstantAttr;\n@@ -3217,2 +4041,8 @@\n-    public static MethodHandle clang_getCursorLinkage$MH() {\n-        return RuntimeHelper.requireNonNull(constants$6.clang_getCursorLinkage$MH,\"clang_getCursorLinkage\");\n+    private static final int CXCursor_CUDADeviceAttr = (int)413L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CUDADeviceAttr = 413\n+     * }\n+     *\/\n+    public static int CXCursor_CUDADeviceAttr() {\n+        return CXCursor_CUDADeviceAttr;\n@@ -3220,0 +4050,1 @@\n+    private static final int CXCursor_CUDAGlobalAttr = (int)414L;\n@@ -3221,2 +4052,2 @@\n-     * {@snippet :\n-     * enum CXLinkageKind clang_getCursorLinkage(CXCursor cursor);\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CUDAGlobalAttr = 414\n@@ -3225,7 +4056,2 @@\n-    public static int clang_getCursorLinkage(MemorySegment cursor) {\n-        var mh$ = clang_getCursorLinkage$MH();\n-        try {\n-            return (int)mh$.invokeExact(cursor);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static int CXCursor_CUDAGlobalAttr() {\n+        return CXCursor_CUDAGlobalAttr;\n@@ -3233,0 +4059,1 @@\n+    private static final int CXCursor_CUDAHostAttr = (int)415L;\n@@ -3234,2 +4061,2 @@\n-     * {@snippet :\n-     * enum CXLanguageKind.CXLanguage_Invalid = 0;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CUDAHostAttr = 415\n@@ -3238,2 +4065,2 @@\n-    public static int CXLanguage_Invalid() {\n-        return (int)0L;\n+    public static int CXCursor_CUDAHostAttr() {\n+        return CXCursor_CUDAHostAttr;\n@@ -3241,0 +4068,1 @@\n+    private static final int CXCursor_CUDASharedAttr = (int)416L;\n@@ -3242,2 +4070,2 @@\n-     * {@snippet :\n-     * enum CXLanguageKind.CXLanguage_C = 1;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_CUDASharedAttr = 416\n@@ -3246,2 +4074,2 @@\n-    public static int CXLanguage_C() {\n-        return (int)1L;\n+    public static int CXCursor_CUDASharedAttr() {\n+        return CXCursor_CUDASharedAttr;\n@@ -3249,0 +4077,1 @@\n+    private static final int CXCursor_VisibilityAttr = (int)417L;\n@@ -3250,2 +4079,2 @@\n-     * {@snippet :\n-     * enum CXLanguageKind.CXLanguage_ObjC = 2;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_VisibilityAttr = 417\n@@ -3254,2 +4083,2 @@\n-    public static int CXLanguage_ObjC() {\n-        return (int)2L;\n+    public static int CXCursor_VisibilityAttr() {\n+        return CXCursor_VisibilityAttr;\n@@ -3257,0 +4086,1 @@\n+    private static final int CXCursor_DLLExport = (int)418L;\n@@ -3258,2 +4088,2 @@\n-     * {@snippet :\n-     * enum CXLanguageKind.CXLanguage_CPlusPlus = 3;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_DLLExport = 418\n@@ -3262,5 +4092,2 @@\n-    public static int CXLanguage_CPlusPlus() {\n-        return (int)3L;\n-    }\n-    public static MethodHandle clang_getCursorLanguage$MH() {\n-        return RuntimeHelper.requireNonNull(constants$7.clang_getCursorLanguage$MH,\"clang_getCursorLanguage\");\n+    public static int CXCursor_DLLExport() {\n+        return CXCursor_DLLExport;\n@@ -3268,0 +4095,1 @@\n+    private static final int CXCursor_DLLImport = (int)419L;\n@@ -3269,2 +4097,2 @@\n-     * {@snippet :\n-     * enum CXLanguageKind clang_getCursorLanguage(CXCursor cursor);\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_DLLImport = 419\n@@ -3273,10 +4101,2 @@\n-    public static int clang_getCursorLanguage(MemorySegment cursor) {\n-        var mh$ = clang_getCursorLanguage$MH();\n-        try {\n-            return (int)mh$.invokeExact(cursor);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_Cursor_getTranslationUnit$MH() {\n-        return RuntimeHelper.requireNonNull(constants$7.clang_Cursor_getTranslationUnit$MH,\"clang_Cursor_getTranslationUnit\");\n+    public static int CXCursor_DLLImport() {\n+        return CXCursor_DLLImport;\n@@ -3284,0 +4104,1 @@\n+    private static final int CXCursor_NSReturnsRetained = (int)420L;\n@@ -3285,2 +4106,2 @@\n-     * {@snippet :\n-     * CXTranslationUnit clang_Cursor_getTranslationUnit(CXCursor);\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_NSReturnsRetained = 420\n@@ -3289,10 +4110,2 @@\n-    public static MemorySegment clang_Cursor_getTranslationUnit(MemorySegment x0) {\n-        var mh$ = clang_Cursor_getTranslationUnit$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(x0);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_getCursorLocation$MH() {\n-        return RuntimeHelper.requireNonNull(constants$7.clang_getCursorLocation$MH,\"clang_getCursorLocation\");\n+    public static int CXCursor_NSReturnsRetained() {\n+        return CXCursor_NSReturnsRetained;\n@@ -3300,0 +4113,1 @@\n+    private static final int CXCursor_NSReturnsNotRetained = (int)421L;\n@@ -3301,2 +4115,2 @@\n-     * {@snippet :\n-     * CXSourceLocation clang_getCursorLocation(CXCursor);\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_NSReturnsNotRetained = 421\n@@ -3305,10 +4119,2 @@\n-    public static MemorySegment clang_getCursorLocation(SegmentAllocator allocator, MemorySegment x1) {\n-        var mh$ = clang_getCursorLocation$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_getCursorExtent$MH() {\n-        return RuntimeHelper.requireNonNull(constants$7.clang_getCursorExtent$MH,\"clang_getCursorExtent\");\n+    public static int CXCursor_NSReturnsNotRetained() {\n+        return CXCursor_NSReturnsNotRetained;\n@@ -3316,0 +4122,1 @@\n+    private static final int CXCursor_NSReturnsAutoreleased = (int)422L;\n@@ -3317,2 +4124,2 @@\n-     * {@snippet :\n-     * CXSourceRange clang_getCursorExtent(CXCursor);\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_NSReturnsAutoreleased = 422\n@@ -3321,7 +4128,2 @@\n-    public static MemorySegment clang_getCursorExtent(SegmentAllocator allocator, MemorySegment x1) {\n-        var mh$ = clang_getCursorExtent$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static int CXCursor_NSReturnsAutoreleased() {\n+        return CXCursor_NSReturnsAutoreleased;\n@@ -3329,0 +4131,1 @@\n+    private static final int CXCursor_NSConsumesSelf = (int)423L;\n@@ -3330,2 +4133,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Invalid = 0;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_NSConsumesSelf = 423\n@@ -3334,2 +4137,2 @@\n-    public static int CXType_Invalid() {\n-        return (int)0L;\n+    public static int CXCursor_NSConsumesSelf() {\n+        return CXCursor_NSConsumesSelf;\n@@ -3337,0 +4140,1 @@\n+    private static final int CXCursor_NSConsumed = (int)424L;\n@@ -3338,2 +4142,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Unexposed = 1;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_NSConsumed = 424\n@@ -3342,2 +4146,2 @@\n-    public static int CXType_Unexposed() {\n-        return (int)1L;\n+    public static int CXCursor_NSConsumed() {\n+        return CXCursor_NSConsumed;\n@@ -3345,0 +4149,1 @@\n+    private static final int CXCursor_ObjCException = (int)425L;\n@@ -3346,2 +4151,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Void = 2;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCException = 425\n@@ -3350,2 +4155,2 @@\n-    public static int CXType_Void() {\n-        return (int)2L;\n+    public static int CXCursor_ObjCException() {\n+        return CXCursor_ObjCException;\n@@ -3353,0 +4158,1 @@\n+    private static final int CXCursor_ObjCNSObject = (int)426L;\n@@ -3354,2 +4160,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Bool = 3;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCNSObject = 426\n@@ -3358,2 +4164,2 @@\n-    public static int CXType_Bool() {\n-        return (int)3L;\n+    public static int CXCursor_ObjCNSObject() {\n+        return CXCursor_ObjCNSObject;\n@@ -3361,0 +4167,1 @@\n+    private static final int CXCursor_ObjCIndependentClass = (int)427L;\n@@ -3362,2 +4169,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Char_U = 4;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCIndependentClass = 427\n@@ -3366,2 +4173,2 @@\n-    public static int CXType_Char_U() {\n-        return (int)4L;\n+    public static int CXCursor_ObjCIndependentClass() {\n+        return CXCursor_ObjCIndependentClass;\n@@ -3369,0 +4176,1 @@\n+    private static final int CXCursor_ObjCPreciseLifetime = (int)428L;\n@@ -3370,2 +4178,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_UChar = 5;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCPreciseLifetime = 428\n@@ -3374,2 +4182,2 @@\n-    public static int CXType_UChar() {\n-        return (int)5L;\n+    public static int CXCursor_ObjCPreciseLifetime() {\n+        return CXCursor_ObjCPreciseLifetime;\n@@ -3377,0 +4185,1 @@\n+    private static final int CXCursor_ObjCReturnsInnerPointer = (int)429L;\n@@ -3378,2 +4187,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Char16 = 6;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCReturnsInnerPointer = 429\n@@ -3382,2 +4191,2 @@\n-    public static int CXType_Char16() {\n-        return (int)6L;\n+    public static int CXCursor_ObjCReturnsInnerPointer() {\n+        return CXCursor_ObjCReturnsInnerPointer;\n@@ -3385,0 +4194,1 @@\n+    private static final int CXCursor_ObjCRequiresSuper = (int)430L;\n@@ -3386,2 +4196,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Char32 = 7;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCRequiresSuper = 430\n@@ -3390,2 +4200,2 @@\n-    public static int CXType_Char32() {\n-        return (int)7L;\n+    public static int CXCursor_ObjCRequiresSuper() {\n+        return CXCursor_ObjCRequiresSuper;\n@@ -3393,0 +4203,1 @@\n+    private static final int CXCursor_ObjCRootClass = (int)431L;\n@@ -3394,2 +4205,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_UShort = 8;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCRootClass = 431\n@@ -3398,2 +4209,2 @@\n-    public static int CXType_UShort() {\n-        return (int)8L;\n+    public static int CXCursor_ObjCRootClass() {\n+        return CXCursor_ObjCRootClass;\n@@ -3401,0 +4212,1 @@\n+    private static final int CXCursor_ObjCSubclassingRestricted = (int)432L;\n@@ -3402,2 +4214,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_UInt = 9;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCSubclassingRestricted = 432\n@@ -3406,2 +4218,2 @@\n-    public static int CXType_UInt() {\n-        return (int)9L;\n+    public static int CXCursor_ObjCSubclassingRestricted() {\n+        return CXCursor_ObjCSubclassingRestricted;\n@@ -3409,0 +4221,1 @@\n+    private static final int CXCursor_ObjCExplicitProtocolImpl = (int)433L;\n@@ -3410,2 +4223,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_ULong = 10;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCExplicitProtocolImpl = 433\n@@ -3414,2 +4227,2 @@\n-    public static int CXType_ULong() {\n-        return (int)10L;\n+    public static int CXCursor_ObjCExplicitProtocolImpl() {\n+        return CXCursor_ObjCExplicitProtocolImpl;\n@@ -3417,0 +4230,1 @@\n+    private static final int CXCursor_ObjCDesignatedInitializer = (int)434L;\n@@ -3418,2 +4232,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_ULongLong = 11;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCDesignatedInitializer = 434\n@@ -3422,2 +4236,2 @@\n-    public static int CXType_ULongLong() {\n-        return (int)11L;\n+    public static int CXCursor_ObjCDesignatedInitializer() {\n+        return CXCursor_ObjCDesignatedInitializer;\n@@ -3425,0 +4239,1 @@\n+    private static final int CXCursor_ObjCRuntimeVisible = (int)435L;\n@@ -3426,2 +4241,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_UInt128 = 12;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCRuntimeVisible = 435\n@@ -3430,2 +4245,2 @@\n-    public static int CXType_UInt128() {\n-        return (int)12L;\n+    public static int CXCursor_ObjCRuntimeVisible() {\n+        return CXCursor_ObjCRuntimeVisible;\n@@ -3433,0 +4248,1 @@\n+    private static final int CXCursor_ObjCBoxable = (int)436L;\n@@ -3434,2 +4250,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Char_S = 13;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ObjCBoxable = 436\n@@ -3438,2 +4254,2 @@\n-    public static int CXType_Char_S() {\n-        return (int)13L;\n+    public static int CXCursor_ObjCBoxable() {\n+        return CXCursor_ObjCBoxable;\n@@ -3441,0 +4257,1 @@\n+    private static final int CXCursor_FlagEnum = (int)437L;\n@@ -3442,2 +4259,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_SChar = 14;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_FlagEnum = 437\n@@ -3446,2 +4263,2 @@\n-    public static int CXType_SChar() {\n-        return (int)14L;\n+    public static int CXCursor_FlagEnum() {\n+        return CXCursor_FlagEnum;\n@@ -3449,0 +4266,1 @@\n+    private static final int CXCursor_ConvergentAttr = (int)438L;\n@@ -3450,2 +4268,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_WChar = 15;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ConvergentAttr = 438\n@@ -3454,2 +4272,2 @@\n-    public static int CXType_WChar() {\n-        return (int)15L;\n+    public static int CXCursor_ConvergentAttr() {\n+        return CXCursor_ConvergentAttr;\n@@ -3457,0 +4275,1 @@\n+    private static final int CXCursor_WarnUnusedAttr = (int)439L;\n@@ -3458,2 +4277,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Short = 16;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_WarnUnusedAttr = 439\n@@ -3462,2 +4281,2 @@\n-    public static int CXType_Short() {\n-        return (int)16L;\n+    public static int CXCursor_WarnUnusedAttr() {\n+        return CXCursor_WarnUnusedAttr;\n@@ -3465,0 +4284,1 @@\n+    private static final int CXCursor_WarnUnusedResultAttr = (int)440L;\n@@ -3466,2 +4286,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Int = 17;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_WarnUnusedResultAttr = 440\n@@ -3470,2 +4290,2 @@\n-    public static int CXType_Int() {\n-        return (int)17L;\n+    public static int CXCursor_WarnUnusedResultAttr() {\n+        return CXCursor_WarnUnusedResultAttr;\n@@ -3473,0 +4293,1 @@\n+    private static final int CXCursor_AlignedAttr = (int)441L;\n@@ -3474,2 +4295,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Long = 18;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_AlignedAttr = 441\n@@ -3478,2 +4299,2 @@\n-    public static int CXType_Long() {\n-        return (int)18L;\n+    public static int CXCursor_AlignedAttr() {\n+        return CXCursor_AlignedAttr;\n@@ -3481,0 +4302,1 @@\n+    private static final int CXCursor_LastAttr = (int)441L;\n@@ -3482,2 +4304,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_LongLong = 19;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_LastAttr = 441\n@@ -3486,2 +4308,2 @@\n-    public static int CXType_LongLong() {\n-        return (int)19L;\n+    public static int CXCursor_LastAttr() {\n+        return CXCursor_LastAttr;\n@@ -3489,0 +4311,1 @@\n+    private static final int CXCursor_PreprocessingDirective = (int)500L;\n@@ -3490,2 +4313,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Int128 = 20;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_PreprocessingDirective = 500\n@@ -3494,2 +4317,2 @@\n-    public static int CXType_Int128() {\n-        return (int)20L;\n+    public static int CXCursor_PreprocessingDirective() {\n+        return CXCursor_PreprocessingDirective;\n@@ -3497,0 +4320,1 @@\n+    private static final int CXCursor_MacroDefinition = (int)501L;\n@@ -3498,2 +4322,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Float = 21;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_MacroDefinition = 501\n@@ -3502,2 +4326,2 @@\n-    public static int CXType_Float() {\n-        return (int)21L;\n+    public static int CXCursor_MacroDefinition() {\n+        return CXCursor_MacroDefinition;\n@@ -3505,0 +4329,1 @@\n+    private static final int CXCursor_MacroExpansion = (int)502L;\n@@ -3506,2 +4331,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Double = 22;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_MacroExpansion = 502\n@@ -3510,2 +4335,2 @@\n-    public static int CXType_Double() {\n-        return (int)22L;\n+    public static int CXCursor_MacroExpansion() {\n+        return CXCursor_MacroExpansion;\n@@ -3513,0 +4338,1 @@\n+    private static final int CXCursor_MacroInstantiation = (int)502L;\n@@ -3514,2 +4340,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_LongDouble = 23;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_MacroInstantiation = 502\n@@ -3518,2 +4344,2 @@\n-    public static int CXType_LongDouble() {\n-        return (int)23L;\n+    public static int CXCursor_MacroInstantiation() {\n+        return CXCursor_MacroInstantiation;\n@@ -3521,0 +4347,1 @@\n+    private static final int CXCursor_InclusionDirective = (int)503L;\n@@ -3522,2 +4349,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_NullPtr = 24;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_InclusionDirective = 503\n@@ -3526,2 +4353,2 @@\n-    public static int CXType_NullPtr() {\n-        return (int)24L;\n+    public static int CXCursor_InclusionDirective() {\n+        return CXCursor_InclusionDirective;\n@@ -3529,0 +4356,1 @@\n+    private static final int CXCursor_FirstPreprocessing = (int)500L;\n@@ -3530,2 +4358,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Overload = 25;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_FirstPreprocessing = 500\n@@ -3534,2 +4362,2 @@\n-    public static int CXType_Overload() {\n-        return (int)25L;\n+    public static int CXCursor_FirstPreprocessing() {\n+        return CXCursor_FirstPreprocessing;\n@@ -3537,0 +4365,1 @@\n+    private static final int CXCursor_LastPreprocessing = (int)503L;\n@@ -3538,2 +4367,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Dependent = 26;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_LastPreprocessing = 503\n@@ -3542,2 +4371,2 @@\n-    public static int CXType_Dependent() {\n-        return (int)26L;\n+    public static int CXCursor_LastPreprocessing() {\n+        return CXCursor_LastPreprocessing;\n@@ -3545,0 +4374,1 @@\n+    private static final int CXCursor_ModuleImportDecl = (int)600L;\n@@ -3546,2 +4376,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_ObjCId = 27;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_ModuleImportDecl = 600\n@@ -3550,2 +4380,2 @@\n-    public static int CXType_ObjCId() {\n-        return (int)27L;\n+    public static int CXCursor_ModuleImportDecl() {\n+        return CXCursor_ModuleImportDecl;\n@@ -3553,0 +4383,1 @@\n+    private static final int CXCursor_TypeAliasTemplateDecl = (int)601L;\n@@ -3554,2 +4385,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_ObjCClass = 28;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_TypeAliasTemplateDecl = 601\n@@ -3558,2 +4389,2 @@\n-    public static int CXType_ObjCClass() {\n-        return (int)28L;\n+    public static int CXCursor_TypeAliasTemplateDecl() {\n+        return CXCursor_TypeAliasTemplateDecl;\n@@ -3561,0 +4392,1 @@\n+    private static final int CXCursor_StaticAssert = (int)602L;\n@@ -3562,2 +4394,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_ObjCSel = 29;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_StaticAssert = 602\n@@ -3566,2 +4398,2 @@\n-    public static int CXType_ObjCSel() {\n-        return (int)29L;\n+    public static int CXCursor_StaticAssert() {\n+        return CXCursor_StaticAssert;\n@@ -3569,0 +4401,1 @@\n+    private static final int CXCursor_FriendDecl = (int)603L;\n@@ -3570,2 +4403,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Float128 = 30;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_FriendDecl = 603\n@@ -3574,2 +4407,2 @@\n-    public static int CXType_Float128() {\n-        return (int)30L;\n+    public static int CXCursor_FriendDecl() {\n+        return CXCursor_FriendDecl;\n@@ -3577,0 +4410,1 @@\n+    private static final int CXCursor_FirstExtraDecl = (int)600L;\n@@ -3578,2 +4412,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Half = 31;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_FirstExtraDecl = 600\n@@ -3582,2 +4416,2 @@\n-    public static int CXType_Half() {\n-        return (int)31L;\n+    public static int CXCursor_FirstExtraDecl() {\n+        return CXCursor_FirstExtraDecl;\n@@ -3585,0 +4419,1 @@\n+    private static final int CXCursor_LastExtraDecl = (int)603L;\n@@ -3586,2 +4421,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Float16 = 32;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_LastExtraDecl = 603\n@@ -3590,2 +4425,2 @@\n-    public static int CXType_Float16() {\n-        return (int)32L;\n+    public static int CXCursor_LastExtraDecl() {\n+        return CXCursor_LastExtraDecl;\n@@ -3593,0 +4428,1 @@\n+    private static final int CXCursor_OverloadCandidate = (int)700L;\n@@ -3594,2 +4430,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_ShortAccum = 33;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind.CXCursor_OverloadCandidate = 700\n@@ -3598,2 +4434,11 @@\n-    public static int CXType_ShortAccum() {\n-        return (int)33L;\n+    public static int CXCursor_OverloadCandidate() {\n+        return CXCursor_OverloadCandidate;\n+    }\n+\n+    private static class clang_getNullCursor$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXCursor.layout()    );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getNullCursor\"),\n+                    DESC);\n@@ -3601,0 +4446,1 @@\n+\n@@ -3602,2 +4448,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Accum = 34;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXCursor clang_getNullCursor()\n@@ -3606,2 +4453,2 @@\n-    public static int CXType_Accum() {\n-        return (int)34L;\n+    public static FunctionDescriptor clang_getNullCursor$descriptor() {\n+        return clang_getNullCursor$constants.DESC;\n@@ -3609,0 +4456,1 @@\n+\n@@ -3610,2 +4458,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_LongAccum = 35;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXCursor clang_getNullCursor()\n@@ -3614,2 +4463,2 @@\n-    public static int CXType_LongAccum() {\n-        return (int)35L;\n+    public static MethodHandle clang_getNullCursor$handle() {\n+        return clang_getNullCursor$constants.HANDLE;\n@@ -3618,2 +4467,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_UShortAccum = 36;\n+     * {@snippet lang=c :\n+     * CXCursor clang_getNullCursor()\n@@ -3622,2 +4471,21 @@\n-    public static int CXType_UShortAccum() {\n-        return (int)36L;\n+    public static MemorySegment clang_getNullCursor(SegmentAllocator allocator) {\n+        var mh$ = clang_getNullCursor$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getNullCursor\", allocator);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getTranslationUnitCursor$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXCursor.layout(),\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getTranslationUnitCursor\"),\n+                    DESC);\n@@ -3625,0 +4493,1 @@\n+\n@@ -3626,2 +4495,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_UAccum = 37;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXCursor clang_getTranslationUnitCursor(CXTranslationUnit)\n@@ -3630,2 +4500,2 @@\n-    public static int CXType_UAccum() {\n-        return (int)37L;\n+    public static FunctionDescriptor clang_getTranslationUnitCursor$descriptor() {\n+        return clang_getTranslationUnitCursor$constants.DESC;\n@@ -3633,0 +4503,1 @@\n+\n@@ -3634,2 +4505,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_ULongAccum = 38;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXCursor clang_getTranslationUnitCursor(CXTranslationUnit)\n@@ -3638,2 +4510,2 @@\n-    public static int CXType_ULongAccum() {\n-        return (int)38L;\n+    public static MethodHandle clang_getTranslationUnitCursor$handle() {\n+        return clang_getTranslationUnitCursor$constants.HANDLE;\n@@ -3642,2 +4514,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_FirstBuiltin = 2;\n+     * {@snippet lang=c :\n+     * CXCursor clang_getTranslationUnitCursor(CXTranslationUnit)\n@@ -3646,2 +4518,22 @@\n-    public static int CXType_FirstBuiltin() {\n-        return (int)2L;\n+    public static MemorySegment clang_getTranslationUnitCursor(SegmentAllocator allocator, MemorySegment x0) {\n+        var mh$ = clang_getTranslationUnitCursor$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getTranslationUnitCursor\", allocator, x0);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, x0);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_equalCursors$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXCursor.layout(),\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_equalCursors\"),\n+                    DESC);\n@@ -3649,0 +4541,1 @@\n+\n@@ -3650,2 +4543,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_LastBuiltin = 39;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_equalCursors(CXCursor, CXCursor)\n@@ -3654,2 +4548,2 @@\n-    public static int CXType_LastBuiltin() {\n-        return (int)39L;\n+    public static FunctionDescriptor clang_equalCursors$descriptor() {\n+        return clang_equalCursors$constants.DESC;\n@@ -3657,0 +4551,1 @@\n+\n@@ -3658,2 +4553,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Complex = 100;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_equalCursors(CXCursor, CXCursor)\n@@ -3662,2 +4558,2 @@\n-    public static int CXType_Complex() {\n-        return (int)100L;\n+    public static MethodHandle clang_equalCursors$handle() {\n+        return clang_equalCursors$constants.HANDLE;\n@@ -3666,2 +4562,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Pointer = 101;\n+     * {@snippet lang=c :\n+     * unsigned int clang_equalCursors(CXCursor, CXCursor)\n@@ -3670,2 +4566,21 @@\n-    public static int CXType_Pointer() {\n-        return (int)101L;\n+    public static int clang_equalCursors(MemorySegment x0, MemorySegment x1) {\n+        var mh$ = clang_equalCursors$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_equalCursors\", x0, x1);\n+            }\n+            return (int)mh$.invokeExact(x0, x1);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_Cursor_isNull$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_isNull\"),\n+                    DESC);\n@@ -3673,0 +4588,1 @@\n+\n@@ -3674,2 +4590,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_BlockPointer = 102;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * int clang_Cursor_isNull(CXCursor cursor)\n@@ -3678,2 +4595,2 @@\n-    public static int CXType_BlockPointer() {\n-        return (int)102L;\n+    public static FunctionDescriptor clang_Cursor_isNull$descriptor() {\n+        return clang_Cursor_isNull$constants.DESC;\n@@ -3681,0 +4598,1 @@\n+\n@@ -3682,2 +4600,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_LValueReference = 103;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * int clang_Cursor_isNull(CXCursor cursor)\n@@ -3686,2 +4605,2 @@\n-    public static int CXType_LValueReference() {\n-        return (int)103L;\n+    public static MethodHandle clang_Cursor_isNull$handle() {\n+        return clang_Cursor_isNull$constants.HANDLE;\n@@ -3690,2 +4609,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_RValueReference = 104;\n+     * {@snippet lang=c :\n+     * int clang_Cursor_isNull(CXCursor cursor)\n@@ -3694,2 +4613,10 @@\n-    public static int CXType_RValueReference() {\n-        return (int)104L;\n+    public static int clang_Cursor_isNull(MemorySegment cursor) {\n+        var mh$ = clang_Cursor_isNull$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_Cursor_isNull\", cursor);\n+            }\n+            return (int)mh$.invokeExact(cursor);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n@@ -3697,0 +4624,12 @@\n+\n+    private static class clang_getCursorKind$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorKind\"),\n+                    DESC);\n+    }\n+\n@@ -3698,2 +4637,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Record = 105;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * enum CXCursorKind clang_getCursorKind(CXCursor)\n@@ -3702,2 +4642,2 @@\n-    public static int CXType_Record() {\n-        return (int)105L;\n+    public static FunctionDescriptor clang_getCursorKind$descriptor() {\n+        return clang_getCursorKind$constants.DESC;\n@@ -3705,0 +4645,1 @@\n+\n@@ -3706,2 +4647,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Enum = 106;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * enum CXCursorKind clang_getCursorKind(CXCursor)\n@@ -3710,2 +4652,2 @@\n-    public static int CXType_Enum() {\n-        return (int)106L;\n+    public static MethodHandle clang_getCursorKind$handle() {\n+        return clang_getCursorKind$constants.HANDLE;\n@@ -3714,2 +4656,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Typedef = 107;\n+     * {@snippet lang=c :\n+     * enum CXCursorKind clang_getCursorKind(CXCursor)\n@@ -3718,2 +4660,21 @@\n-    public static int CXType_Typedef() {\n-        return (int)107L;\n+    public static int clang_getCursorKind(MemorySegment x0) {\n+        var mh$ = clang_getCursorKind$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getCursorKind\", x0);\n+            }\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_isDeclaration$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            Index_h.C_INT\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_isDeclaration\"),\n+                    DESC);\n@@ -3721,0 +4682,1 @@\n+\n@@ -3722,2 +4684,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_ObjCInterface = 108;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_isDeclaration(enum CXCursorKind)\n@@ -3726,2 +4689,2 @@\n-    public static int CXType_ObjCInterface() {\n-        return (int)108L;\n+    public static FunctionDescriptor clang_isDeclaration$descriptor() {\n+        return clang_isDeclaration$constants.DESC;\n@@ -3729,0 +4692,1 @@\n+\n@@ -3730,2 +4694,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_ObjCObjectPointer = 109;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_isDeclaration(enum CXCursorKind)\n@@ -3734,2 +4699,2 @@\n-    public static int CXType_ObjCObjectPointer() {\n-        return (int)109L;\n+    public static MethodHandle clang_isDeclaration$handle() {\n+        return clang_isDeclaration$constants.HANDLE;\n@@ -3738,2 +4703,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_FunctionNoProto = 110;\n+     * {@snippet lang=c :\n+     * unsigned int clang_isDeclaration(enum CXCursorKind)\n@@ -3742,2 +4707,21 @@\n-    public static int CXType_FunctionNoProto() {\n-        return (int)110L;\n+    public static int clang_isDeclaration(int x0) {\n+        var mh$ = clang_isDeclaration$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_isDeclaration\", x0);\n+            }\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_isAttribute$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            Index_h.C_INT\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_isAttribute\"),\n+                    DESC);\n@@ -3745,0 +4729,1 @@\n+\n@@ -3746,2 +4731,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_FunctionProto = 111;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_isAttribute(enum CXCursorKind)\n@@ -3750,2 +4736,2 @@\n-    public static int CXType_FunctionProto() {\n-        return (int)111L;\n+    public static FunctionDescriptor clang_isAttribute$descriptor() {\n+        return clang_isAttribute$constants.DESC;\n@@ -3753,0 +4739,1 @@\n+\n@@ -3754,2 +4741,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_ConstantArray = 112;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_isAttribute(enum CXCursorKind)\n@@ -3758,2 +4746,2 @@\n-    public static int CXType_ConstantArray() {\n-        return (int)112L;\n+    public static MethodHandle clang_isAttribute$handle() {\n+        return clang_isAttribute$constants.HANDLE;\n@@ -3762,2 +4750,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Vector = 113;\n+     * {@snippet lang=c :\n+     * unsigned int clang_isAttribute(enum CXCursorKind)\n@@ -3766,2 +4754,21 @@\n-    public static int CXType_Vector() {\n-        return (int)113L;\n+    public static int clang_isAttribute(int x0) {\n+        var mh$ = clang_isAttribute$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_isAttribute\", x0);\n+            }\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_isInvalid$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            Index_h.C_INT\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_isInvalid\"),\n+                    DESC);\n@@ -3769,0 +4776,1 @@\n+\n@@ -3770,2 +4778,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_IncompleteArray = 114;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_isInvalid(enum CXCursorKind)\n@@ -3774,2 +4783,2 @@\n-    public static int CXType_IncompleteArray() {\n-        return (int)114L;\n+    public static FunctionDescriptor clang_isInvalid$descriptor() {\n+        return clang_isInvalid$constants.DESC;\n@@ -3777,0 +4786,1 @@\n+\n@@ -3778,2 +4788,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_VariableArray = 115;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_isInvalid(enum CXCursorKind)\n@@ -3782,2 +4793,2 @@\n-    public static int CXType_VariableArray() {\n-        return (int)115L;\n+    public static MethodHandle clang_isInvalid$handle() {\n+        return clang_isInvalid$constants.HANDLE;\n@@ -3786,2 +4797,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_DependentSizedArray = 116;\n+     * {@snippet lang=c :\n+     * unsigned int clang_isInvalid(enum CXCursorKind)\n@@ -3790,2 +4801,10 @@\n-    public static int CXType_DependentSizedArray() {\n-        return (int)116L;\n+    public static int clang_isInvalid(int x0) {\n+        var mh$ = clang_isInvalid$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_isInvalid\", x0);\n+            }\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n@@ -3793,0 +4812,12 @@\n+\n+    private static class clang_isPreprocessing$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            Index_h.C_INT\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_isPreprocessing\"),\n+                    DESC);\n+    }\n+\n@@ -3794,2 +4825,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_MemberPointer = 117;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_isPreprocessing(enum CXCursorKind)\n@@ -3798,2 +4830,2 @@\n-    public static int CXType_MemberPointer() {\n-        return (int)117L;\n+    public static FunctionDescriptor clang_isPreprocessing$descriptor() {\n+        return clang_isPreprocessing$constants.DESC;\n@@ -3801,0 +4833,1 @@\n+\n@@ -3802,2 +4835,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Auto = 118;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_isPreprocessing(enum CXCursorKind)\n@@ -3806,2 +4840,2 @@\n-    public static int CXType_Auto() {\n-        return (int)118L;\n+    public static MethodHandle clang_isPreprocessing$handle() {\n+        return clang_isPreprocessing$constants.HANDLE;\n@@ -3810,2 +4844,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Elaborated = 119;\n+     * {@snippet lang=c :\n+     * unsigned int clang_isPreprocessing(enum CXCursorKind)\n@@ -3814,2 +4848,10 @@\n-    public static int CXType_Elaborated() {\n-        return (int)119L;\n+    public static int clang_isPreprocessing(int x0) {\n+        var mh$ = clang_isPreprocessing$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_isPreprocessing\", x0);\n+            }\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n@@ -3817,0 +4859,1 @@\n+    private static final int CXLinkage_Invalid = (int)0L;\n@@ -3818,2 +4861,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Pipe = 120;\n+     * {@snippet lang=c :\n+     * enum CXLinkageKind.CXLinkage_Invalid = 0\n@@ -3822,2 +4865,2 @@\n-    public static int CXType_Pipe() {\n-        return (int)120L;\n+    public static int CXLinkage_Invalid() {\n+        return CXLinkage_Invalid;\n@@ -3825,0 +4868,1 @@\n+    private static final int CXLinkage_NoLinkage = (int)1L;\n@@ -3826,2 +4870,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage1dRO = 121;\n+     * {@snippet lang=c :\n+     * enum CXLinkageKind.CXLinkage_NoLinkage = 1\n@@ -3830,2 +4874,2 @@\n-    public static int CXType_OCLImage1dRO() {\n-        return (int)121L;\n+    public static int CXLinkage_NoLinkage() {\n+        return CXLinkage_NoLinkage;\n@@ -3833,0 +4877,1 @@\n+    private static final int CXLinkage_Internal = (int)2L;\n@@ -3834,2 +4879,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage1dArrayRO = 122;\n+     * {@snippet lang=c :\n+     * enum CXLinkageKind.CXLinkage_Internal = 2\n@@ -3838,2 +4883,2 @@\n-    public static int CXType_OCLImage1dArrayRO() {\n-        return (int)122L;\n+    public static int CXLinkage_Internal() {\n+        return CXLinkage_Internal;\n@@ -3841,0 +4886,1 @@\n+    private static final int CXLinkage_UniqueExternal = (int)3L;\n@@ -3842,2 +4888,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage1dBufferRO = 123;\n+     * {@snippet lang=c :\n+     * enum CXLinkageKind.CXLinkage_UniqueExternal = 3\n@@ -3846,2 +4892,2 @@\n-    public static int CXType_OCLImage1dBufferRO() {\n-        return (int)123L;\n+    public static int CXLinkage_UniqueExternal() {\n+        return CXLinkage_UniqueExternal;\n@@ -3849,0 +4895,1 @@\n+    private static final int CXLinkage_External = (int)4L;\n@@ -3850,2 +4897,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dRO = 124;\n+     * {@snippet lang=c :\n+     * enum CXLinkageKind.CXLinkage_External = 4\n@@ -3854,2 +4901,13 @@\n-    public static int CXType_OCLImage2dRO() {\n-        return (int)124L;\n+    public static int CXLinkage_External() {\n+        return CXLinkage_External;\n+    }\n+\n+    private static class clang_getCursorLinkage$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorLinkage\"),\n+                    DESC);\n@@ -3857,0 +4915,1 @@\n+\n@@ -3858,2 +4917,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dArrayRO = 125;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * enum CXLinkageKind clang_getCursorLinkage(CXCursor cursor)\n@@ -3862,2 +4922,2 @@\n-    public static int CXType_OCLImage2dArrayRO() {\n-        return (int)125L;\n+    public static FunctionDescriptor clang_getCursorLinkage$descriptor() {\n+        return clang_getCursorLinkage$constants.DESC;\n@@ -3865,0 +4925,1 @@\n+\n@@ -3866,2 +4927,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dDepthRO = 126;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * enum CXLinkageKind clang_getCursorLinkage(CXCursor cursor)\n@@ -3870,2 +4932,2 @@\n-    public static int CXType_OCLImage2dDepthRO() {\n-        return (int)126L;\n+    public static MethodHandle clang_getCursorLinkage$handle() {\n+        return clang_getCursorLinkage$constants.HANDLE;\n@@ -3874,2 +4936,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dArrayDepthRO = 127;\n+     * {@snippet lang=c :\n+     * enum CXLinkageKind clang_getCursorLinkage(CXCursor cursor)\n@@ -3878,2 +4940,10 @@\n-    public static int CXType_OCLImage2dArrayDepthRO() {\n-        return (int)127L;\n+    public static int clang_getCursorLinkage(MemorySegment cursor) {\n+        var mh$ = clang_getCursorLinkage$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getCursorLinkage\", cursor);\n+            }\n+            return (int)mh$.invokeExact(cursor);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n@@ -3881,0 +4951,1 @@\n+    private static final int CXLanguage_Invalid = (int)0L;\n@@ -3882,2 +4953,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dMSAARO = 128;\n+     * {@snippet lang=c :\n+     * enum CXLanguageKind.CXLanguage_Invalid = 0\n@@ -3886,2 +4957,2 @@\n-    public static int CXType_OCLImage2dMSAARO() {\n-        return (int)128L;\n+    public static int CXLanguage_Invalid() {\n+        return CXLanguage_Invalid;\n@@ -3889,0 +4960,1 @@\n+    private static final int CXLanguage_C = (int)1L;\n@@ -3890,2 +4962,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dArrayMSAARO = 129;\n+     * {@snippet lang=c :\n+     * enum CXLanguageKind.CXLanguage_C = 1\n@@ -3894,2 +4966,2 @@\n-    public static int CXType_OCLImage2dArrayMSAARO() {\n-        return (int)129L;\n+    public static int CXLanguage_C() {\n+        return CXLanguage_C;\n@@ -3897,0 +4969,1 @@\n+    private static final int CXLanguage_ObjC = (int)2L;\n@@ -3898,2 +4971,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dMSAADepthRO = 130;\n+     * {@snippet lang=c :\n+     * enum CXLanguageKind.CXLanguage_ObjC = 2\n@@ -3902,2 +4975,2 @@\n-    public static int CXType_OCLImage2dMSAADepthRO() {\n-        return (int)130L;\n+    public static int CXLanguage_ObjC() {\n+        return CXLanguage_ObjC;\n@@ -3905,0 +4978,1 @@\n+    private static final int CXLanguage_CPlusPlus = (int)3L;\n@@ -3906,2 +4980,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dArrayMSAADepthRO = 131;\n+     * {@snippet lang=c :\n+     * enum CXLanguageKind.CXLanguage_CPlusPlus = 3\n@@ -3910,2 +4984,2 @@\n-    public static int CXType_OCLImage2dArrayMSAADepthRO() {\n-        return (int)131L;\n+    public static int CXLanguage_CPlusPlus() {\n+        return CXLanguage_CPlusPlus;\n@@ -3913,0 +4987,12 @@\n+\n+    private static class clang_getCursorLanguage$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorLanguage\"),\n+                    DESC);\n+    }\n+\n@@ -3914,2 +5000,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage3dRO = 132;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * enum CXLanguageKind clang_getCursorLanguage(CXCursor cursor)\n@@ -3918,2 +5005,2 @@\n-    public static int CXType_OCLImage3dRO() {\n-        return (int)132L;\n+    public static FunctionDescriptor clang_getCursorLanguage$descriptor() {\n+        return clang_getCursorLanguage$constants.DESC;\n@@ -3921,0 +5008,1 @@\n+\n@@ -3922,2 +5010,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage1dWO = 133;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * enum CXLanguageKind clang_getCursorLanguage(CXCursor cursor)\n@@ -3926,2 +5015,2 @@\n-    public static int CXType_OCLImage1dWO() {\n-        return (int)133L;\n+    public static MethodHandle clang_getCursorLanguage$handle() {\n+        return clang_getCursorLanguage$constants.HANDLE;\n@@ -3930,2 +5019,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage1dArrayWO = 134;\n+     * {@snippet lang=c :\n+     * enum CXLanguageKind clang_getCursorLanguage(CXCursor cursor)\n@@ -3934,2 +5023,21 @@\n-    public static int CXType_OCLImage1dArrayWO() {\n-        return (int)134L;\n+    public static int clang_getCursorLanguage(MemorySegment cursor) {\n+        var mh$ = clang_getCursorLanguage$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getCursorLanguage\", cursor);\n+            }\n+            return (int)mh$.invokeExact(cursor);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_Cursor_getTranslationUnit$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_POINTER,\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_getTranslationUnit\"),\n+                    DESC);\n@@ -3937,0 +5045,1 @@\n+\n@@ -3938,2 +5047,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage1dBufferWO = 135;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXTranslationUnit clang_Cursor_getTranslationUnit(CXCursor)\n@@ -3942,2 +5052,2 @@\n-    public static int CXType_OCLImage1dBufferWO() {\n-        return (int)135L;\n+    public static FunctionDescriptor clang_Cursor_getTranslationUnit$descriptor() {\n+        return clang_Cursor_getTranslationUnit$constants.DESC;\n@@ -3945,0 +5055,1 @@\n+\n@@ -3946,2 +5057,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dWO = 136;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXTranslationUnit clang_Cursor_getTranslationUnit(CXCursor)\n@@ -3950,2 +5062,2 @@\n-    public static int CXType_OCLImage2dWO() {\n-        return (int)136L;\n+    public static MethodHandle clang_Cursor_getTranslationUnit$handle() {\n+        return clang_Cursor_getTranslationUnit$constants.HANDLE;\n@@ -3954,2 +5066,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dArrayWO = 137;\n+     * {@snippet lang=c :\n+     * CXTranslationUnit clang_Cursor_getTranslationUnit(CXCursor)\n@@ -3958,2 +5070,21 @@\n-    public static int CXType_OCLImage2dArrayWO() {\n-        return (int)137L;\n+    public static MemorySegment clang_Cursor_getTranslationUnit(MemorySegment x0) {\n+        var mh$ = clang_Cursor_getTranslationUnit$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_Cursor_getTranslationUnit\", x0);\n+            }\n+            return (MemorySegment)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getCursorLocation$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXSourceLocation.layout(),\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorLocation\"),\n+                    DESC);\n@@ -3961,0 +5092,1 @@\n+\n@@ -3962,2 +5094,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dDepthWO = 138;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getCursorLocation(CXCursor)\n@@ -3966,2 +5099,2 @@\n-    public static int CXType_OCLImage2dDepthWO() {\n-        return (int)138L;\n+    public static FunctionDescriptor clang_getCursorLocation$descriptor() {\n+        return clang_getCursorLocation$constants.DESC;\n@@ -3969,0 +5102,1 @@\n+\n@@ -3970,2 +5104,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dArrayDepthWO = 139;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getCursorLocation(CXCursor)\n@@ -3974,2 +5109,2 @@\n-    public static int CXType_OCLImage2dArrayDepthWO() {\n-        return (int)139L;\n+    public static MethodHandle clang_getCursorLocation$handle() {\n+        return clang_getCursorLocation$constants.HANDLE;\n@@ -3978,2 +5113,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dMSAAWO = 140;\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getCursorLocation(CXCursor)\n@@ -3982,2 +5117,10 @@\n-    public static int CXType_OCLImage2dMSAAWO() {\n-        return (int)140L;\n+    public static MemorySegment clang_getCursorLocation(SegmentAllocator allocator, MemorySegment x0) {\n+        var mh$ = clang_getCursorLocation$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getCursorLocation\", allocator, x0);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, x0);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n@@ -3985,0 +5128,12 @@\n+\n+    private static class clang_getCursorExtent$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXSourceRange.layout(),\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorExtent\"),\n+                    DESC);\n+    }\n+\n@@ -3986,2 +5141,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dArrayMSAAWO = 141;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXSourceRange clang_getCursorExtent(CXCursor)\n@@ -3990,2 +5146,2 @@\n-    public static int CXType_OCLImage2dArrayMSAAWO() {\n-        return (int)141L;\n+    public static FunctionDescriptor clang_getCursorExtent$descriptor() {\n+        return clang_getCursorExtent$constants.DESC;\n@@ -3993,0 +5149,1 @@\n+\n@@ -3994,2 +5151,3 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dMSAADepthWO = 142;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXSourceRange clang_getCursorExtent(CXCursor)\n@@ -3998,2 +5156,2 @@\n-    public static int CXType_OCLImage2dMSAADepthWO() {\n-        return (int)142L;\n+    public static MethodHandle clang_getCursorExtent$handle() {\n+        return clang_getCursorExtent$constants.HANDLE;\n@@ -4002,2 +5160,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dArrayMSAADepthWO = 143;\n+     * {@snippet lang=c :\n+     * CXSourceRange clang_getCursorExtent(CXCursor)\n@@ -4006,2 +5164,10 @@\n-    public static int CXType_OCLImage2dArrayMSAADepthWO() {\n-        return (int)143L;\n+    public static MemorySegment clang_getCursorExtent(SegmentAllocator allocator, MemorySegment x0) {\n+        var mh$ = clang_getCursorExtent$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getCursorExtent\", allocator, x0);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, x0);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n@@ -4009,0 +5175,1 @@\n+    private static final int CXType_Invalid = (int)0L;\n@@ -4010,2 +5177,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage3dWO = 144;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Invalid = 0\n@@ -4014,2 +5181,2 @@\n-    public static int CXType_OCLImage3dWO() {\n-        return (int)144L;\n+    public static int CXType_Invalid() {\n+        return CXType_Invalid;\n@@ -4017,0 +5184,1 @@\n+    private static final int CXType_Unexposed = (int)1L;\n@@ -4018,2 +5186,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage1dRW = 145;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Unexposed = 1\n@@ -4022,2 +5190,2 @@\n-    public static int CXType_OCLImage1dRW() {\n-        return (int)145L;\n+    public static int CXType_Unexposed() {\n+        return CXType_Unexposed;\n@@ -4025,0 +5193,1 @@\n+    private static final int CXType_Void = (int)2L;\n@@ -4026,2 +5195,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage1dArrayRW = 146;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Void = 2\n@@ -4030,2 +5199,2 @@\n-    public static int CXType_OCLImage1dArrayRW() {\n-        return (int)146L;\n+    public static int CXType_Void() {\n+        return CXType_Void;\n@@ -4033,0 +5202,1 @@\n+    private static final int CXType_Bool = (int)3L;\n@@ -4034,2 +5204,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage1dBufferRW = 147;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Bool = 3\n@@ -4038,2 +5208,2 @@\n-    public static int CXType_OCLImage1dBufferRW() {\n-        return (int)147L;\n+    public static int CXType_Bool() {\n+        return CXType_Bool;\n@@ -4041,0 +5211,1 @@\n+    private static final int CXType_Char_U = (int)4L;\n@@ -4042,2 +5213,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dRW = 148;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Char_U = 4\n@@ -4046,2 +5217,2 @@\n-    public static int CXType_OCLImage2dRW() {\n-        return (int)148L;\n+    public static int CXType_Char_U() {\n+        return CXType_Char_U;\n@@ -4049,0 +5220,1 @@\n+    private static final int CXType_UChar = (int)5L;\n@@ -4050,2 +5222,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dArrayRW = 149;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_UChar = 5\n@@ -4054,2 +5226,2 @@\n-    public static int CXType_OCLImage2dArrayRW() {\n-        return (int)149L;\n+    public static int CXType_UChar() {\n+        return CXType_UChar;\n@@ -4057,0 +5229,1 @@\n+    private static final int CXType_Char16 = (int)6L;\n@@ -4058,2 +5231,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dDepthRW = 150;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Char16 = 6\n@@ -4062,2 +5235,2 @@\n-    public static int CXType_OCLImage2dDepthRW() {\n-        return (int)150L;\n+    public static int CXType_Char16() {\n+        return CXType_Char16;\n@@ -4065,0 +5238,1 @@\n+    private static final int CXType_Char32 = (int)7L;\n@@ -4066,2 +5240,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dArrayDepthRW = 151;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Char32 = 7\n@@ -4070,2 +5244,2 @@\n-    public static int CXType_OCLImage2dArrayDepthRW() {\n-        return (int)151L;\n+    public static int CXType_Char32() {\n+        return CXType_Char32;\n@@ -4073,0 +5247,1 @@\n+    private static final int CXType_UShort = (int)8L;\n@@ -4074,2 +5249,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dMSAARW = 152;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_UShort = 8\n@@ -4078,2 +5253,2 @@\n-    public static int CXType_OCLImage2dMSAARW() {\n-        return (int)152L;\n+    public static int CXType_UShort() {\n+        return CXType_UShort;\n@@ -4081,0 +5256,1 @@\n+    private static final int CXType_UInt = (int)9L;\n@@ -4082,2 +5258,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dArrayMSAARW = 153;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_UInt = 9\n@@ -4086,2 +5262,2 @@\n-    public static int CXType_OCLImage2dArrayMSAARW() {\n-        return (int)153L;\n+    public static int CXType_UInt() {\n+        return CXType_UInt;\n@@ -4089,0 +5265,1 @@\n+    private static final int CXType_ULong = (int)10L;\n@@ -4090,2 +5267,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dMSAADepthRW = 154;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_ULong = 10\n@@ -4094,2 +5271,2 @@\n-    public static int CXType_OCLImage2dMSAADepthRW() {\n-        return (int)154L;\n+    public static int CXType_ULong() {\n+        return CXType_ULong;\n@@ -4097,0 +5274,1 @@\n+    private static final int CXType_ULongLong = (int)11L;\n@@ -4098,2 +5276,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage2dArrayMSAADepthRW = 155;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_ULongLong = 11\n@@ -4102,2 +5280,2 @@\n-    public static int CXType_OCLImage2dArrayMSAADepthRW() {\n-        return (int)155L;\n+    public static int CXType_ULongLong() {\n+        return CXType_ULongLong;\n@@ -4105,0 +5283,1 @@\n+    private static final int CXType_UInt128 = (int)12L;\n@@ -4106,2 +5285,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLImage3dRW = 156;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_UInt128 = 12\n@@ -4110,2 +5289,2 @@\n-    public static int CXType_OCLImage3dRW() {\n-        return (int)156L;\n+    public static int CXType_UInt128() {\n+        return CXType_UInt128;\n@@ -4113,0 +5292,1 @@\n+    private static final int CXType_Char_S = (int)13L;\n@@ -4114,2 +5294,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLSampler = 157;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Char_S = 13\n@@ -4118,2 +5298,2 @@\n-    public static int CXType_OCLSampler() {\n-        return (int)157L;\n+    public static int CXType_Char_S() {\n+        return CXType_Char_S;\n@@ -4121,0 +5301,1 @@\n+    private static final int CXType_SChar = (int)14L;\n@@ -4122,2 +5303,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLEvent = 158;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_SChar = 14\n@@ -4126,2 +5307,2 @@\n-    public static int CXType_OCLEvent() {\n-        return (int)158L;\n+    public static int CXType_SChar() {\n+        return CXType_SChar;\n@@ -4129,0 +5310,1 @@\n+    private static final int CXType_WChar = (int)15L;\n@@ -4130,2 +5312,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLQueue = 159;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_WChar = 15\n@@ -4134,2 +5316,2 @@\n-    public static int CXType_OCLQueue() {\n-        return (int)159L;\n+    public static int CXType_WChar() {\n+        return CXType_WChar;\n@@ -4137,0 +5319,1 @@\n+    private static final int CXType_Short = (int)16L;\n@@ -4138,2 +5321,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLReserveID = 160;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Short = 16\n@@ -4142,2 +5325,2 @@\n-    public static int CXType_OCLReserveID() {\n-        return (int)160L;\n+    public static int CXType_Short() {\n+        return CXType_Short;\n@@ -4145,0 +5328,1 @@\n+    private static final int CXType_Int = (int)17L;\n@@ -4146,2 +5330,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_ObjCObject = 161;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Int = 17\n@@ -4150,2 +5334,2 @@\n-    public static int CXType_ObjCObject() {\n-        return (int)161L;\n+    public static int CXType_Int() {\n+        return CXType_Int;\n@@ -4153,0 +5337,1 @@\n+    private static final int CXType_Long = (int)18L;\n@@ -4154,2 +5339,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_ObjCTypeParam = 162;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Long = 18\n@@ -4158,2 +5343,2 @@\n-    public static int CXType_ObjCTypeParam() {\n-        return (int)162L;\n+    public static int CXType_Long() {\n+        return CXType_Long;\n@@ -4161,0 +5346,1 @@\n+    private static final int CXType_LongLong = (int)19L;\n@@ -4162,2 +5348,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_Attributed = 163;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_LongLong = 19\n@@ -4166,2 +5352,2 @@\n-    public static int CXType_Attributed() {\n-        return (int)163L;\n+    public static int CXType_LongLong() {\n+        return CXType_LongLong;\n@@ -4169,0 +5355,1 @@\n+    private static final int CXType_Int128 = (int)20L;\n@@ -4170,2 +5357,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCMcePayload = 164;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Int128 = 20\n@@ -4174,2 +5361,2 @@\n-    public static int CXType_OCLIntelSubgroupAVCMcePayload() {\n-        return (int)164L;\n+    public static int CXType_Int128() {\n+        return CXType_Int128;\n@@ -4177,0 +5364,1 @@\n+    private static final int CXType_Float = (int)21L;\n@@ -4178,2 +5366,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCImePayload = 165;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Float = 21\n@@ -4182,2 +5370,2 @@\n-    public static int CXType_OCLIntelSubgroupAVCImePayload() {\n-        return (int)165L;\n+    public static int CXType_Float() {\n+        return CXType_Float;\n@@ -4185,0 +5373,1 @@\n+    private static final int CXType_Double = (int)22L;\n@@ -4186,2 +5375,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCRefPayload = 166;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Double = 22\n@@ -4190,2 +5379,2 @@\n-    public static int CXType_OCLIntelSubgroupAVCRefPayload() {\n-        return (int)166L;\n+    public static int CXType_Double() {\n+        return CXType_Double;\n@@ -4193,0 +5382,1 @@\n+    private static final int CXType_LongDouble = (int)23L;\n@@ -4194,2 +5384,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCSicPayload = 167;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_LongDouble = 23\n@@ -4198,2 +5388,2 @@\n-    public static int CXType_OCLIntelSubgroupAVCSicPayload() {\n-        return (int)167L;\n+    public static int CXType_LongDouble() {\n+        return CXType_LongDouble;\n@@ -4201,0 +5391,1 @@\n+    private static final int CXType_NullPtr = (int)24L;\n@@ -4202,2 +5393,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCMceResult = 168;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_NullPtr = 24\n@@ -4206,2 +5397,2 @@\n-    public static int CXType_OCLIntelSubgroupAVCMceResult() {\n-        return (int)168L;\n+    public static int CXType_NullPtr() {\n+        return CXType_NullPtr;\n@@ -4209,0 +5400,1 @@\n+    private static final int CXType_Overload = (int)25L;\n@@ -4210,2 +5402,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCImeResult = 169;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Overload = 25\n@@ -4214,2 +5406,2 @@\n-    public static int CXType_OCLIntelSubgroupAVCImeResult() {\n-        return (int)169L;\n+    public static int CXType_Overload() {\n+        return CXType_Overload;\n@@ -4217,0 +5409,1 @@\n+    private static final int CXType_Dependent = (int)26L;\n@@ -4218,2 +5411,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCRefResult = 170;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Dependent = 26\n@@ -4222,2 +5415,2 @@\n-    public static int CXType_OCLIntelSubgroupAVCRefResult() {\n-        return (int)170L;\n+    public static int CXType_Dependent() {\n+        return CXType_Dependent;\n@@ -4225,0 +5418,1 @@\n+    private static final int CXType_ObjCId = (int)27L;\n@@ -4226,2 +5420,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCSicResult = 171;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_ObjCId = 27\n@@ -4230,2 +5424,2 @@\n-    public static int CXType_OCLIntelSubgroupAVCSicResult() {\n-        return (int)171L;\n+    public static int CXType_ObjCId() {\n+        return CXType_ObjCId;\n@@ -4233,0 +5427,1 @@\n+    private static final int CXType_ObjCClass = (int)28L;\n@@ -4234,2 +5429,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout = 172;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_ObjCClass = 28\n@@ -4238,2 +5433,2 @@\n-    public static int CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout() {\n-        return (int)172L;\n+    public static int CXType_ObjCClass() {\n+        return CXType_ObjCClass;\n@@ -4241,0 +5436,1 @@\n+    private static final int CXType_ObjCSel = (int)29L;\n@@ -4242,2 +5438,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout = 173;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_ObjCSel = 29\n@@ -4246,2 +5442,2 @@\n-    public static int CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout() {\n-        return (int)173L;\n+    public static int CXType_ObjCSel() {\n+        return CXType_ObjCSel;\n@@ -4249,0 +5445,1 @@\n+    private static final int CXType_Float128 = (int)30L;\n@@ -4250,2 +5447,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCImeSingleRefStreamin = 174;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Float128 = 30\n@@ -4254,2 +5451,2 @@\n-    public static int CXType_OCLIntelSubgroupAVCImeSingleRefStreamin() {\n-        return (int)174L;\n+    public static int CXType_Float128() {\n+        return CXType_Float128;\n@@ -4257,0 +5454,1 @@\n+    private static final int CXType_Half = (int)31L;\n@@ -4258,2 +5456,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCImeDualRefStreamin = 175;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Half = 31\n@@ -4262,2 +5460,2 @@\n-    public static int CXType_OCLIntelSubgroupAVCImeDualRefStreamin() {\n-        return (int)175L;\n+    public static int CXType_Half() {\n+        return CXType_Half;\n@@ -4265,0 +5463,1 @@\n+    private static final int CXType_Float16 = (int)32L;\n@@ -4266,2 +5465,2 @@\n-     * {@snippet :\n-     * enum CXTypeKind.CXType_ExtVector = 176;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Float16 = 32\n@@ -4270,2 +5469,2 @@\n-    public static int CXType_ExtVector() {\n-        return (int)176L;\n+    public static int CXType_Float16() {\n+        return CXType_Float16;\n@@ -4273,0 +5472,1 @@\n+    private static final int CXType_ShortAccum = (int)33L;\n@@ -4274,2 +5474,2 @@\n-     * {@snippet :\n-     * enum CXCallingConv.CXCallingConv_Default = 0;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_ShortAccum = 33\n@@ -4278,2 +5478,2 @@\n-    public static int CXCallingConv_Default() {\n-        return (int)0L;\n+    public static int CXType_ShortAccum() {\n+        return CXType_ShortAccum;\n@@ -4281,0 +5481,1 @@\n+    private static final int CXType_Accum = (int)34L;\n@@ -4282,2 +5483,2 @@\n-     * {@snippet :\n-     * enum CXCallingConv.CXCallingConv_C = 1;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Accum = 34\n@@ -4286,2 +5487,2 @@\n-    public static int CXCallingConv_C() {\n-        return (int)1L;\n+    public static int CXType_Accum() {\n+        return CXType_Accum;\n@@ -4289,0 +5490,1 @@\n+    private static final int CXType_LongAccum = (int)35L;\n@@ -4290,2 +5492,2 @@\n-     * {@snippet :\n-     * enum CXCallingConv.CXCallingConv_X86StdCall = 2;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_LongAccum = 35\n@@ -4294,2 +5496,2 @@\n-    public static int CXCallingConv_X86StdCall() {\n-        return (int)2L;\n+    public static int CXType_LongAccum() {\n+        return CXType_LongAccum;\n@@ -4297,0 +5499,1 @@\n+    private static final int CXType_UShortAccum = (int)36L;\n@@ -4298,2 +5501,2 @@\n-     * {@snippet :\n-     * enum CXCallingConv.CXCallingConv_X86FastCall = 3;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_UShortAccum = 36\n@@ -4302,2 +5505,2 @@\n-    public static int CXCallingConv_X86FastCall() {\n-        return (int)3L;\n+    public static int CXType_UShortAccum() {\n+        return CXType_UShortAccum;\n@@ -4305,0 +5508,1 @@\n+    private static final int CXType_UAccum = (int)37L;\n@@ -4306,2 +5510,2 @@\n-     * {@snippet :\n-     * enum CXCallingConv.CXCallingConv_X86ThisCall = 4;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_UAccum = 37\n@@ -4310,2 +5514,2 @@\n-    public static int CXCallingConv_X86ThisCall() {\n-        return (int)4L;\n+    public static int CXType_UAccum() {\n+        return CXType_UAccum;\n@@ -4313,0 +5517,1 @@\n+    private static final int CXType_ULongAccum = (int)38L;\n@@ -4314,2 +5519,2 @@\n-     * {@snippet :\n-     * enum CXCallingConv.CXCallingConv_X86Pascal = 5;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_ULongAccum = 38\n@@ -4318,2 +5523,2 @@\n-    public static int CXCallingConv_X86Pascal() {\n-        return (int)5L;\n+    public static int CXType_ULongAccum() {\n+        return CXType_ULongAccum;\n@@ -4321,0 +5526,1 @@\n+    private static final int CXType_FirstBuiltin = (int)2L;\n@@ -4322,2 +5528,2 @@\n-     * {@snippet :\n-     * enum CXCallingConv.CXCallingConv_AAPCS = 6;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_FirstBuiltin = 2\n@@ -4326,2 +5532,2 @@\n-    public static int CXCallingConv_AAPCS() {\n-        return (int)6L;\n+    public static int CXType_FirstBuiltin() {\n+        return CXType_FirstBuiltin;\n@@ -4329,0 +5535,1 @@\n+    private static final int CXType_LastBuiltin = (int)39L;\n@@ -4330,2 +5537,2 @@\n-     * {@snippet :\n-     * enum CXCallingConv.CXCallingConv_AAPCS_VFP = 7;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_LastBuiltin = 39\n@@ -4334,2 +5541,2 @@\n-    public static int CXCallingConv_AAPCS_VFP() {\n-        return (int)7L;\n+    public static int CXType_LastBuiltin() {\n+        return CXType_LastBuiltin;\n@@ -4337,0 +5544,1 @@\n+    private static final int CXType_Complex = (int)100L;\n@@ -4338,2 +5546,2 @@\n-     * {@snippet :\n-     * enum CXCallingConv.CXCallingConv_X86RegCall = 8;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Complex = 100\n@@ -4342,2 +5550,2 @@\n-    public static int CXCallingConv_X86RegCall() {\n-        return (int)8L;\n+    public static int CXType_Complex() {\n+        return CXType_Complex;\n@@ -4345,0 +5553,1 @@\n+    private static final int CXType_Pointer = (int)101L;\n@@ -4346,2 +5555,2 @@\n-     * {@snippet :\n-     * enum CXCallingConv.CXCallingConv_IntelOclBicc = 9;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Pointer = 101\n@@ -4350,2 +5559,2 @@\n-    public static int CXCallingConv_IntelOclBicc() {\n-        return (int)9L;\n+    public static int CXType_Pointer() {\n+        return CXType_Pointer;\n@@ -4353,0 +5562,1 @@\n+    private static final int CXType_BlockPointer = (int)102L;\n@@ -4354,2 +5564,2 @@\n-     * {@snippet :\n-     * enum CXCallingConv.CXCallingConv_Win64 = 10;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_BlockPointer = 102\n@@ -4358,2 +5568,2 @@\n-    public static int CXCallingConv_Win64() {\n-        return (int)10L;\n+    public static int CXType_BlockPointer() {\n+        return CXType_BlockPointer;\n@@ -4361,0 +5571,1 @@\n+    private static final int CXType_LValueReference = (int)103L;\n@@ -4362,2 +5573,2 @@\n-     * {@snippet :\n-     * enum CXCallingConv.CXCallingConv_X86_64Win64 = 10;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_LValueReference = 103\n@@ -4366,2 +5577,2 @@\n-    public static int CXCallingConv_X86_64Win64() {\n-        return (int)10L;\n+    public static int CXType_LValueReference() {\n+        return CXType_LValueReference;\n@@ -4369,0 +5580,1 @@\n+    private static final int CXType_RValueReference = (int)104L;\n@@ -4370,2 +5582,2 @@\n-     * {@snippet :\n-     * enum CXCallingConv.CXCallingConv_X86_64SysV = 11;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_RValueReference = 104\n@@ -4374,2 +5586,2 @@\n-    public static int CXCallingConv_X86_64SysV() {\n-        return (int)11L;\n+    public static int CXType_RValueReference() {\n+        return CXType_RValueReference;\n@@ -4377,0 +5589,1 @@\n+    private static final int CXType_Record = (int)105L;\n@@ -4378,2 +5591,2 @@\n-     * {@snippet :\n-     * enum CXCallingConv.CXCallingConv_X86VectorCall = 12;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Record = 105\n@@ -4382,2 +5595,2 @@\n-    public static int CXCallingConv_X86VectorCall() {\n-        return (int)12L;\n+    public static int CXType_Record() {\n+        return CXType_Record;\n@@ -4385,0 +5598,1 @@\n+    private static final int CXType_Enum = (int)106L;\n@@ -4386,2 +5600,2 @@\n-     * {@snippet :\n-     * enum CXCallingConv.CXCallingConv_Swift = 13;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Enum = 106\n@@ -4390,2 +5604,2 @@\n-    public static int CXCallingConv_Swift() {\n-        return (int)13L;\n+    public static int CXType_Enum() {\n+        return CXType_Enum;\n@@ -4393,0 +5607,1 @@\n+    private static final int CXType_Typedef = (int)107L;\n@@ -4394,2 +5609,2 @@\n-     * {@snippet :\n-     * enum CXCallingConv.CXCallingConv_PreserveMost = 14;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Typedef = 107\n@@ -4398,2 +5613,2 @@\n-    public static int CXCallingConv_PreserveMost() {\n-        return (int)14L;\n+    public static int CXType_Typedef() {\n+        return CXType_Typedef;\n@@ -4401,0 +5616,1 @@\n+    private static final int CXType_ObjCInterface = (int)108L;\n@@ -4402,2 +5618,2 @@\n-     * {@snippet :\n-     * enum CXCallingConv.CXCallingConv_PreserveAll = 15;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_ObjCInterface = 108\n@@ -4406,2 +5622,2 @@\n-    public static int CXCallingConv_PreserveAll() {\n-        return (int)15L;\n+    public static int CXType_ObjCInterface() {\n+        return CXType_ObjCInterface;\n@@ -4409,0 +5625,1 @@\n+    private static final int CXType_ObjCObjectPointer = (int)109L;\n@@ -4410,2 +5627,2 @@\n-     * {@snippet :\n-     * enum CXCallingConv.CXCallingConv_AArch64VectorCall = 16;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_ObjCObjectPointer = 109\n@@ -4414,2 +5631,2 @@\n-    public static int CXCallingConv_AArch64VectorCall() {\n-        return (int)16L;\n+    public static int CXType_ObjCObjectPointer() {\n+        return CXType_ObjCObjectPointer;\n@@ -4417,0 +5634,1 @@\n+    private static final int CXType_FunctionNoProto = (int)110L;\n@@ -4418,2 +5636,2 @@\n-     * {@snippet :\n-     * enum CXCallingConv.CXCallingConv_Invalid = 100;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_FunctionNoProto = 110\n@@ -4422,2 +5640,2 @@\n-    public static int CXCallingConv_Invalid() {\n-        return (int)100L;\n+    public static int CXType_FunctionNoProto() {\n+        return CXType_FunctionNoProto;\n@@ -4425,0 +5643,1 @@\n+    private static final int CXType_FunctionProto = (int)111L;\n@@ -4426,2 +5645,2 @@\n-     * {@snippet :\n-     * enum CXCallingConv.CXCallingConv_Unexposed = 200;\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_FunctionProto = 111\n@@ -4430,5 +5649,2 @@\n-    public static int CXCallingConv_Unexposed() {\n-        return (int)200L;\n-    }\n-    public static MethodHandle clang_getCursorType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$7.clang_getCursorType$MH,\"clang_getCursorType\");\n+    public static int CXType_FunctionProto() {\n+        return CXType_FunctionProto;\n@@ -4436,0 +5652,1 @@\n+    private static final int CXType_ConstantArray = (int)112L;\n@@ -4437,2 +5654,2 @@\n-     * {@snippet :\n-     * CXType clang_getCursorType(CXCursor C);\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_ConstantArray = 112\n@@ -4441,10 +5658,2 @@\n-    public static MemorySegment clang_getCursorType(SegmentAllocator allocator, MemorySegment C) {\n-        var mh$ = clang_getCursorType$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, C);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_getTypeSpelling$MH() {\n-        return RuntimeHelper.requireNonNull(constants$7.clang_getTypeSpelling$MH,\"clang_getTypeSpelling\");\n+    public static int CXType_ConstantArray() {\n+        return CXType_ConstantArray;\n@@ -4452,0 +5661,1 @@\n+    private static final int CXType_Vector = (int)113L;\n@@ -4453,2 +5663,2 @@\n-     * {@snippet :\n-     * CXString clang_getTypeSpelling(CXType CT);\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Vector = 113\n@@ -4457,10 +5667,2 @@\n-    public static MemorySegment clang_getTypeSpelling(SegmentAllocator allocator, MemorySegment CT) {\n-        var mh$ = clang_getTypeSpelling$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, CT);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_getTypedefDeclUnderlyingType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$8.clang_getTypedefDeclUnderlyingType$MH,\"clang_getTypedefDeclUnderlyingType\");\n+    public static int CXType_Vector() {\n+        return CXType_Vector;\n@@ -4468,0 +5670,1 @@\n+    private static final int CXType_IncompleteArray = (int)114L;\n@@ -4469,2 +5672,2 @@\n-     * {@snippet :\n-     * CXType clang_getTypedefDeclUnderlyingType(CXCursor C);\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_IncompleteArray = 114\n@@ -4473,10 +5676,2 @@\n-    public static MemorySegment clang_getTypedefDeclUnderlyingType(SegmentAllocator allocator, MemorySegment C) {\n-        var mh$ = clang_getTypedefDeclUnderlyingType$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, C);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_getEnumDeclIntegerType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$8.clang_getEnumDeclIntegerType$MH,\"clang_getEnumDeclIntegerType\");\n+    public static int CXType_IncompleteArray() {\n+        return CXType_IncompleteArray;\n@@ -4484,0 +5679,1 @@\n+    private static final int CXType_VariableArray = (int)115L;\n@@ -4485,2 +5681,2 @@\n-     * {@snippet :\n-     * CXType clang_getEnumDeclIntegerType(CXCursor C);\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_VariableArray = 115\n@@ -4489,10 +5685,2 @@\n-    public static MemorySegment clang_getEnumDeclIntegerType(SegmentAllocator allocator, MemorySegment C) {\n-        var mh$ = clang_getEnumDeclIntegerType$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, C);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_getEnumConstantDeclValue$MH() {\n-        return RuntimeHelper.requireNonNull(constants$8.clang_getEnumConstantDeclValue$MH,\"clang_getEnumConstantDeclValue\");\n+    public static int CXType_VariableArray() {\n+        return CXType_VariableArray;\n@@ -4500,0 +5688,1 @@\n+    private static final int CXType_DependentSizedArray = (int)116L;\n@@ -4501,2 +5690,2 @@\n-     * {@snippet :\n-     * long long clang_getEnumConstantDeclValue(CXCursor C);\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_DependentSizedArray = 116\n@@ -4505,10 +5694,2 @@\n-    public static long clang_getEnumConstantDeclValue(MemorySegment C) {\n-        var mh$ = clang_getEnumConstantDeclValue$MH();\n-        try {\n-            return (long)mh$.invokeExact(C);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_getEnumConstantDeclUnsignedValue$MH() {\n-        return RuntimeHelper.requireNonNull(constants$8.clang_getEnumConstantDeclUnsignedValue$MH,\"clang_getEnumConstantDeclUnsignedValue\");\n+    public static int CXType_DependentSizedArray() {\n+        return CXType_DependentSizedArray;\n@@ -4516,0 +5697,1 @@\n+    private static final int CXType_MemberPointer = (int)117L;\n@@ -4517,2 +5699,2 @@\n-     * {@snippet :\n-     * unsigned long long clang_getEnumConstantDeclUnsignedValue(CXCursor C);\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_MemberPointer = 117\n@@ -4521,10 +5703,2 @@\n-    public static long clang_getEnumConstantDeclUnsignedValue(MemorySegment C) {\n-        var mh$ = clang_getEnumConstantDeclUnsignedValue$MH();\n-        try {\n-            return (long)mh$.invokeExact(C);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_getFieldDeclBitWidth$MH() {\n-        return RuntimeHelper.requireNonNull(constants$8.clang_getFieldDeclBitWidth$MH,\"clang_getFieldDeclBitWidth\");\n+    public static int CXType_MemberPointer() {\n+        return CXType_MemberPointer;\n@@ -4532,0 +5706,1 @@\n+    private static final int CXType_Auto = (int)118L;\n@@ -4533,2 +5708,2 @@\n-     * {@snippet :\n-     * int clang_getFieldDeclBitWidth(CXCursor C);\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Auto = 118\n@@ -4537,10 +5712,2 @@\n-    public static int clang_getFieldDeclBitWidth(MemorySegment C) {\n-        var mh$ = clang_getFieldDeclBitWidth$MH();\n-        try {\n-            return (int)mh$.invokeExact(C);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_Cursor_getNumArguments$MH() {\n-        return RuntimeHelper.requireNonNull(constants$8.clang_Cursor_getNumArguments$MH,\"clang_Cursor_getNumArguments\");\n+    public static int CXType_Auto() {\n+        return CXType_Auto;\n@@ -4548,0 +5715,1 @@\n+    private static final int CXType_Elaborated = (int)119L;\n@@ -4549,2 +5717,2 @@\n-     * {@snippet :\n-     * int clang_Cursor_getNumArguments(CXCursor C);\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Elaborated = 119\n@@ -4553,10 +5721,2 @@\n-    public static int clang_Cursor_getNumArguments(MemorySegment C) {\n-        var mh$ = clang_Cursor_getNumArguments$MH();\n-        try {\n-            return (int)mh$.invokeExact(C);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_Cursor_getArgument$MH() {\n-        return RuntimeHelper.requireNonNull(constants$9.clang_Cursor_getArgument$MH,\"clang_Cursor_getArgument\");\n+    public static int CXType_Elaborated() {\n+        return CXType_Elaborated;\n@@ -4564,0 +5724,1 @@\n+    private static final int CXType_Pipe = (int)120L;\n@@ -4565,2 +5726,2 @@\n-     * {@snippet :\n-     * CXCursor clang_Cursor_getArgument(CXCursor C, unsigned int i);\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Pipe = 120\n@@ -4569,10 +5730,2 @@\n-    public static MemorySegment clang_Cursor_getArgument(SegmentAllocator allocator, MemorySegment C, int i) {\n-        var mh$ = clang_Cursor_getArgument$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, C, i);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_equalTypes$MH() {\n-        return RuntimeHelper.requireNonNull(constants$9.clang_equalTypes$MH,\"clang_equalTypes\");\n+    public static int CXType_Pipe() {\n+        return CXType_Pipe;\n@@ -4580,0 +5733,1 @@\n+    private static final int CXType_OCLImage1dRO = (int)121L;\n@@ -4581,2 +5735,2 @@\n-     * {@snippet :\n-     * unsigned int clang_equalTypes(CXType A, CXType B);\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage1dRO = 121\n@@ -4585,10 +5739,2 @@\n-    public static int clang_equalTypes(MemorySegment A, MemorySegment B) {\n-        var mh$ = clang_equalTypes$MH();\n-        try {\n-            return (int)mh$.invokeExact(A, B);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_getCanonicalType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$9.clang_getCanonicalType$MH,\"clang_getCanonicalType\");\n+    public static int CXType_OCLImage1dRO() {\n+        return CXType_OCLImage1dRO;\n@@ -4596,0 +5742,1 @@\n+    private static final int CXType_OCLImage1dArrayRO = (int)122L;\n@@ -4597,2 +5744,2 @@\n-     * {@snippet :\n-     * CXType clang_getCanonicalType(CXType T);\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage1dArrayRO = 122\n@@ -4601,10 +5748,2 @@\n-    public static MemorySegment clang_getCanonicalType(SegmentAllocator allocator, MemorySegment T) {\n-        var mh$ = clang_getCanonicalType$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_isConstQualifiedType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$9.clang_isConstQualifiedType$MH,\"clang_isConstQualifiedType\");\n+    public static int CXType_OCLImage1dArrayRO() {\n+        return CXType_OCLImage1dArrayRO;\n@@ -4612,0 +5751,1 @@\n+    private static final int CXType_OCLImage1dBufferRO = (int)123L;\n@@ -4613,2 +5753,2 @@\n-     * {@snippet :\n-     * unsigned int clang_isConstQualifiedType(CXType T);\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage1dBufferRO = 123\n@@ -4617,10 +5757,2 @@\n-    public static int clang_isConstQualifiedType(MemorySegment T) {\n-        var mh$ = clang_isConstQualifiedType$MH();\n-        try {\n-            return (int)mh$.invokeExact(T);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_Cursor_isMacroFunctionLike$MH() {\n-        return RuntimeHelper.requireNonNull(constants$9.clang_Cursor_isMacroFunctionLike$MH,\"clang_Cursor_isMacroFunctionLike\");\n+    public static int CXType_OCLImage1dBufferRO() {\n+        return CXType_OCLImage1dBufferRO;\n@@ -4628,0 +5760,1 @@\n+    private static final int CXType_OCLImage2dRO = (int)124L;\n@@ -4629,2 +5762,2 @@\n-     * {@snippet :\n-     * unsigned int clang_Cursor_isMacroFunctionLike(CXCursor C);\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dRO = 124\n@@ -4633,10 +5766,2 @@\n-    public static int clang_Cursor_isMacroFunctionLike(MemorySegment C) {\n-        var mh$ = clang_Cursor_isMacroFunctionLike$MH();\n-        try {\n-            return (int)mh$.invokeExact(C);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_Cursor_isFunctionInlined$MH() {\n-        return RuntimeHelper.requireNonNull(constants$9.clang_Cursor_isFunctionInlined$MH,\"clang_Cursor_isFunctionInlined\");\n+    public static int CXType_OCLImage2dRO() {\n+        return CXType_OCLImage2dRO;\n@@ -4644,0 +5769,1 @@\n+    private static final int CXType_OCLImage2dArrayRO = (int)125L;\n@@ -4645,2 +5771,2 @@\n-     * {@snippet :\n-     * unsigned int clang_Cursor_isFunctionInlined(CXCursor C);\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dArrayRO = 125\n@@ -4649,10 +5775,2 @@\n-    public static int clang_Cursor_isFunctionInlined(MemorySegment C) {\n-        var mh$ = clang_Cursor_isFunctionInlined$MH();\n-        try {\n-            return (int)mh$.invokeExact(C);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_isVolatileQualifiedType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$10.clang_isVolatileQualifiedType$MH,\"clang_isVolatileQualifiedType\");\n+    public static int CXType_OCLImage2dArrayRO() {\n+        return CXType_OCLImage2dArrayRO;\n@@ -4660,0 +5778,1 @@\n+    private static final int CXType_OCLImage2dDepthRO = (int)126L;\n@@ -4661,2 +5780,2 @@\n-     * {@snippet :\n-     * unsigned int clang_isVolatileQualifiedType(CXType T);\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dDepthRO = 126\n@@ -4665,10 +5784,2 @@\n-    public static int clang_isVolatileQualifiedType(MemorySegment T) {\n-        var mh$ = clang_isVolatileQualifiedType$MH();\n-        try {\n-            return (int)mh$.invokeExact(T);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_getTypedefName$MH() {\n-        return RuntimeHelper.requireNonNull(constants$10.clang_getTypedefName$MH,\"clang_getTypedefName\");\n+    public static int CXType_OCLImage2dDepthRO() {\n+        return CXType_OCLImage2dDepthRO;\n@@ -4676,0 +5787,1 @@\n+    private static final int CXType_OCLImage2dArrayDepthRO = (int)127L;\n@@ -4677,2 +5789,2 @@\n-     * {@snippet :\n-     * CXString clang_getTypedefName(CXType CT);\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dArrayDepthRO = 127\n@@ -4681,10 +5793,2 @@\n-    public static MemorySegment clang_getTypedefName(SegmentAllocator allocator, MemorySegment CT) {\n-        var mh$ = clang_getTypedefName$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, CT);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_getPointeeType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$10.clang_getPointeeType$MH,\"clang_getPointeeType\");\n+    public static int CXType_OCLImage2dArrayDepthRO() {\n+        return CXType_OCLImage2dArrayDepthRO;\n@@ -4692,0 +5796,1 @@\n+    private static final int CXType_OCLImage2dMSAARO = (int)128L;\n@@ -4693,2 +5798,2 @@\n-     * {@snippet :\n-     * CXType clang_getPointeeType(CXType T);\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dMSAARO = 128\n@@ -4697,7 +5802,2 @@\n-    public static MemorySegment clang_getPointeeType(SegmentAllocator allocator, MemorySegment T) {\n-        var mh$ = clang_getPointeeType$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static int CXType_OCLImage2dMSAARO() {\n+        return CXType_OCLImage2dMSAARO;\n@@ -4705,2 +5805,2504 @@\n-    public static MethodHandle clang_getTypeDeclaration$MH() {\n-        return RuntimeHelper.requireNonNull(constants$10.clang_getTypeDeclaration$MH,\"clang_getTypeDeclaration\");\n+    private static final int CXType_OCLImage2dArrayMSAARO = (int)129L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dArrayMSAARO = 129\n+     * }\n+     *\/\n+    public static int CXType_OCLImage2dArrayMSAARO() {\n+        return CXType_OCLImage2dArrayMSAARO;\n+    }\n+    private static final int CXType_OCLImage2dMSAADepthRO = (int)130L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dMSAADepthRO = 130\n+     * }\n+     *\/\n+    public static int CXType_OCLImage2dMSAADepthRO() {\n+        return CXType_OCLImage2dMSAADepthRO;\n+    }\n+    private static final int CXType_OCLImage2dArrayMSAADepthRO = (int)131L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dArrayMSAADepthRO = 131\n+     * }\n+     *\/\n+    public static int CXType_OCLImage2dArrayMSAADepthRO() {\n+        return CXType_OCLImage2dArrayMSAADepthRO;\n+    }\n+    private static final int CXType_OCLImage3dRO = (int)132L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage3dRO = 132\n+     * }\n+     *\/\n+    public static int CXType_OCLImage3dRO() {\n+        return CXType_OCLImage3dRO;\n+    }\n+    private static final int CXType_OCLImage1dWO = (int)133L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage1dWO = 133\n+     * }\n+     *\/\n+    public static int CXType_OCLImage1dWO() {\n+        return CXType_OCLImage1dWO;\n+    }\n+    private static final int CXType_OCLImage1dArrayWO = (int)134L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage1dArrayWO = 134\n+     * }\n+     *\/\n+    public static int CXType_OCLImage1dArrayWO() {\n+        return CXType_OCLImage1dArrayWO;\n+    }\n+    private static final int CXType_OCLImage1dBufferWO = (int)135L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage1dBufferWO = 135\n+     * }\n+     *\/\n+    public static int CXType_OCLImage1dBufferWO() {\n+        return CXType_OCLImage1dBufferWO;\n+    }\n+    private static final int CXType_OCLImage2dWO = (int)136L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dWO = 136\n+     * }\n+     *\/\n+    public static int CXType_OCLImage2dWO() {\n+        return CXType_OCLImage2dWO;\n+    }\n+    private static final int CXType_OCLImage2dArrayWO = (int)137L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dArrayWO = 137\n+     * }\n+     *\/\n+    public static int CXType_OCLImage2dArrayWO() {\n+        return CXType_OCLImage2dArrayWO;\n+    }\n+    private static final int CXType_OCLImage2dDepthWO = (int)138L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dDepthWO = 138\n+     * }\n+     *\/\n+    public static int CXType_OCLImage2dDepthWO() {\n+        return CXType_OCLImage2dDepthWO;\n+    }\n+    private static final int CXType_OCLImage2dArrayDepthWO = (int)139L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dArrayDepthWO = 139\n+     * }\n+     *\/\n+    public static int CXType_OCLImage2dArrayDepthWO() {\n+        return CXType_OCLImage2dArrayDepthWO;\n+    }\n+    private static final int CXType_OCLImage2dMSAAWO = (int)140L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dMSAAWO = 140\n+     * }\n+     *\/\n+    public static int CXType_OCLImage2dMSAAWO() {\n+        return CXType_OCLImage2dMSAAWO;\n+    }\n+    private static final int CXType_OCLImage2dArrayMSAAWO = (int)141L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dArrayMSAAWO = 141\n+     * }\n+     *\/\n+    public static int CXType_OCLImage2dArrayMSAAWO() {\n+        return CXType_OCLImage2dArrayMSAAWO;\n+    }\n+    private static final int CXType_OCLImage2dMSAADepthWO = (int)142L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dMSAADepthWO = 142\n+     * }\n+     *\/\n+    public static int CXType_OCLImage2dMSAADepthWO() {\n+        return CXType_OCLImage2dMSAADepthWO;\n+    }\n+    private static final int CXType_OCLImage2dArrayMSAADepthWO = (int)143L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dArrayMSAADepthWO = 143\n+     * }\n+     *\/\n+    public static int CXType_OCLImage2dArrayMSAADepthWO() {\n+        return CXType_OCLImage2dArrayMSAADepthWO;\n+    }\n+    private static final int CXType_OCLImage3dWO = (int)144L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage3dWO = 144\n+     * }\n+     *\/\n+    public static int CXType_OCLImage3dWO() {\n+        return CXType_OCLImage3dWO;\n+    }\n+    private static final int CXType_OCLImage1dRW = (int)145L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage1dRW = 145\n+     * }\n+     *\/\n+    public static int CXType_OCLImage1dRW() {\n+        return CXType_OCLImage1dRW;\n+    }\n+    private static final int CXType_OCLImage1dArrayRW = (int)146L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage1dArrayRW = 146\n+     * }\n+     *\/\n+    public static int CXType_OCLImage1dArrayRW() {\n+        return CXType_OCLImage1dArrayRW;\n+    }\n+    private static final int CXType_OCLImage1dBufferRW = (int)147L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage1dBufferRW = 147\n+     * }\n+     *\/\n+    public static int CXType_OCLImage1dBufferRW() {\n+        return CXType_OCLImage1dBufferRW;\n+    }\n+    private static final int CXType_OCLImage2dRW = (int)148L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dRW = 148\n+     * }\n+     *\/\n+    public static int CXType_OCLImage2dRW() {\n+        return CXType_OCLImage2dRW;\n+    }\n+    private static final int CXType_OCLImage2dArrayRW = (int)149L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dArrayRW = 149\n+     * }\n+     *\/\n+    public static int CXType_OCLImage2dArrayRW() {\n+        return CXType_OCLImage2dArrayRW;\n+    }\n+    private static final int CXType_OCLImage2dDepthRW = (int)150L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dDepthRW = 150\n+     * }\n+     *\/\n+    public static int CXType_OCLImage2dDepthRW() {\n+        return CXType_OCLImage2dDepthRW;\n+    }\n+    private static final int CXType_OCLImage2dArrayDepthRW = (int)151L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dArrayDepthRW = 151\n+     * }\n+     *\/\n+    public static int CXType_OCLImage2dArrayDepthRW() {\n+        return CXType_OCLImage2dArrayDepthRW;\n+    }\n+    private static final int CXType_OCLImage2dMSAARW = (int)152L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dMSAARW = 152\n+     * }\n+     *\/\n+    public static int CXType_OCLImage2dMSAARW() {\n+        return CXType_OCLImage2dMSAARW;\n+    }\n+    private static final int CXType_OCLImage2dArrayMSAARW = (int)153L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dArrayMSAARW = 153\n+     * }\n+     *\/\n+    public static int CXType_OCLImage2dArrayMSAARW() {\n+        return CXType_OCLImage2dArrayMSAARW;\n+    }\n+    private static final int CXType_OCLImage2dMSAADepthRW = (int)154L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dMSAADepthRW = 154\n+     * }\n+     *\/\n+    public static int CXType_OCLImage2dMSAADepthRW() {\n+        return CXType_OCLImage2dMSAADepthRW;\n+    }\n+    private static final int CXType_OCLImage2dArrayMSAADepthRW = (int)155L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage2dArrayMSAADepthRW = 155\n+     * }\n+     *\/\n+    public static int CXType_OCLImage2dArrayMSAADepthRW() {\n+        return CXType_OCLImage2dArrayMSAADepthRW;\n+    }\n+    private static final int CXType_OCLImage3dRW = (int)156L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLImage3dRW = 156\n+     * }\n+     *\/\n+    public static int CXType_OCLImage3dRW() {\n+        return CXType_OCLImage3dRW;\n+    }\n+    private static final int CXType_OCLSampler = (int)157L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLSampler = 157\n+     * }\n+     *\/\n+    public static int CXType_OCLSampler() {\n+        return CXType_OCLSampler;\n+    }\n+    private static final int CXType_OCLEvent = (int)158L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLEvent = 158\n+     * }\n+     *\/\n+    public static int CXType_OCLEvent() {\n+        return CXType_OCLEvent;\n+    }\n+    private static final int CXType_OCLQueue = (int)159L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLQueue = 159\n+     * }\n+     *\/\n+    public static int CXType_OCLQueue() {\n+        return CXType_OCLQueue;\n+    }\n+    private static final int CXType_OCLReserveID = (int)160L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLReserveID = 160\n+     * }\n+     *\/\n+    public static int CXType_OCLReserveID() {\n+        return CXType_OCLReserveID;\n+    }\n+    private static final int CXType_ObjCObject = (int)161L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_ObjCObject = 161\n+     * }\n+     *\/\n+    public static int CXType_ObjCObject() {\n+        return CXType_ObjCObject;\n+    }\n+    private static final int CXType_ObjCTypeParam = (int)162L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_ObjCTypeParam = 162\n+     * }\n+     *\/\n+    public static int CXType_ObjCTypeParam() {\n+        return CXType_ObjCTypeParam;\n+    }\n+    private static final int CXType_Attributed = (int)163L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_Attributed = 163\n+     * }\n+     *\/\n+    public static int CXType_Attributed() {\n+        return CXType_Attributed;\n+    }\n+    private static final int CXType_OCLIntelSubgroupAVCMcePayload = (int)164L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCMcePayload = 164\n+     * }\n+     *\/\n+    public static int CXType_OCLIntelSubgroupAVCMcePayload() {\n+        return CXType_OCLIntelSubgroupAVCMcePayload;\n+    }\n+    private static final int CXType_OCLIntelSubgroupAVCImePayload = (int)165L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCImePayload = 165\n+     * }\n+     *\/\n+    public static int CXType_OCLIntelSubgroupAVCImePayload() {\n+        return CXType_OCLIntelSubgroupAVCImePayload;\n+    }\n+    private static final int CXType_OCLIntelSubgroupAVCRefPayload = (int)166L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCRefPayload = 166\n+     * }\n+     *\/\n+    public static int CXType_OCLIntelSubgroupAVCRefPayload() {\n+        return CXType_OCLIntelSubgroupAVCRefPayload;\n+    }\n+    private static final int CXType_OCLIntelSubgroupAVCSicPayload = (int)167L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCSicPayload = 167\n+     * }\n+     *\/\n+    public static int CXType_OCLIntelSubgroupAVCSicPayload() {\n+        return CXType_OCLIntelSubgroupAVCSicPayload;\n+    }\n+    private static final int CXType_OCLIntelSubgroupAVCMceResult = (int)168L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCMceResult = 168\n+     * }\n+     *\/\n+    public static int CXType_OCLIntelSubgroupAVCMceResult() {\n+        return CXType_OCLIntelSubgroupAVCMceResult;\n+    }\n+    private static final int CXType_OCLIntelSubgroupAVCImeResult = (int)169L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCImeResult = 169\n+     * }\n+     *\/\n+    public static int CXType_OCLIntelSubgroupAVCImeResult() {\n+        return CXType_OCLIntelSubgroupAVCImeResult;\n+    }\n+    private static final int CXType_OCLIntelSubgroupAVCRefResult = (int)170L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCRefResult = 170\n+     * }\n+     *\/\n+    public static int CXType_OCLIntelSubgroupAVCRefResult() {\n+        return CXType_OCLIntelSubgroupAVCRefResult;\n+    }\n+    private static final int CXType_OCLIntelSubgroupAVCSicResult = (int)171L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCSicResult = 171\n+     * }\n+     *\/\n+    public static int CXType_OCLIntelSubgroupAVCSicResult() {\n+        return CXType_OCLIntelSubgroupAVCSicResult;\n+    }\n+    private static final int CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout = (int)172L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout = 172\n+     * }\n+     *\/\n+    public static int CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout() {\n+        return CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout;\n+    }\n+    private static final int CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout = (int)173L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout = 173\n+     * }\n+     *\/\n+    public static int CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout() {\n+        return CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout;\n+    }\n+    private static final int CXType_OCLIntelSubgroupAVCImeSingleRefStreamin = (int)174L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCImeSingleRefStreamin = 174\n+     * }\n+     *\/\n+    public static int CXType_OCLIntelSubgroupAVCImeSingleRefStreamin() {\n+        return CXType_OCLIntelSubgroupAVCImeSingleRefStreamin;\n+    }\n+    private static final int CXType_OCLIntelSubgroupAVCImeDualRefStreamin = (int)175L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_OCLIntelSubgroupAVCImeDualRefStreamin = 175\n+     * }\n+     *\/\n+    public static int CXType_OCLIntelSubgroupAVCImeDualRefStreamin() {\n+        return CXType_OCLIntelSubgroupAVCImeDualRefStreamin;\n+    }\n+    private static final int CXType_ExtVector = (int)176L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeKind.CXType_ExtVector = 176\n+     * }\n+     *\/\n+    public static int CXType_ExtVector() {\n+        return CXType_ExtVector;\n+    }\n+    private static final int CXCallingConv_Default = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXCallingConv.CXCallingConv_Default = 0\n+     * }\n+     *\/\n+    public static int CXCallingConv_Default() {\n+        return CXCallingConv_Default;\n+    }\n+    private static final int CXCallingConv_C = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXCallingConv.CXCallingConv_C = 1\n+     * }\n+     *\/\n+    public static int CXCallingConv_C() {\n+        return CXCallingConv_C;\n+    }\n+    private static final int CXCallingConv_X86StdCall = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXCallingConv.CXCallingConv_X86StdCall = 2\n+     * }\n+     *\/\n+    public static int CXCallingConv_X86StdCall() {\n+        return CXCallingConv_X86StdCall;\n+    }\n+    private static final int CXCallingConv_X86FastCall = (int)3L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXCallingConv.CXCallingConv_X86FastCall = 3\n+     * }\n+     *\/\n+    public static int CXCallingConv_X86FastCall() {\n+        return CXCallingConv_X86FastCall;\n+    }\n+    private static final int CXCallingConv_X86ThisCall = (int)4L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXCallingConv.CXCallingConv_X86ThisCall = 4\n+     * }\n+     *\/\n+    public static int CXCallingConv_X86ThisCall() {\n+        return CXCallingConv_X86ThisCall;\n+    }\n+    private static final int CXCallingConv_X86Pascal = (int)5L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXCallingConv.CXCallingConv_X86Pascal = 5\n+     * }\n+     *\/\n+    public static int CXCallingConv_X86Pascal() {\n+        return CXCallingConv_X86Pascal;\n+    }\n+    private static final int CXCallingConv_AAPCS = (int)6L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXCallingConv.CXCallingConv_AAPCS = 6\n+     * }\n+     *\/\n+    public static int CXCallingConv_AAPCS() {\n+        return CXCallingConv_AAPCS;\n+    }\n+    private static final int CXCallingConv_AAPCS_VFP = (int)7L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXCallingConv.CXCallingConv_AAPCS_VFP = 7\n+     * }\n+     *\/\n+    public static int CXCallingConv_AAPCS_VFP() {\n+        return CXCallingConv_AAPCS_VFP;\n+    }\n+    private static final int CXCallingConv_X86RegCall = (int)8L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXCallingConv.CXCallingConv_X86RegCall = 8\n+     * }\n+     *\/\n+    public static int CXCallingConv_X86RegCall() {\n+        return CXCallingConv_X86RegCall;\n+    }\n+    private static final int CXCallingConv_IntelOclBicc = (int)9L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXCallingConv.CXCallingConv_IntelOclBicc = 9\n+     * }\n+     *\/\n+    public static int CXCallingConv_IntelOclBicc() {\n+        return CXCallingConv_IntelOclBicc;\n+    }\n+    private static final int CXCallingConv_Win64 = (int)10L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXCallingConv.CXCallingConv_Win64 = 10\n+     * }\n+     *\/\n+    public static int CXCallingConv_Win64() {\n+        return CXCallingConv_Win64;\n+    }\n+    private static final int CXCallingConv_X86_64Win64 = (int)10L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXCallingConv.CXCallingConv_X86_64Win64 = 10\n+     * }\n+     *\/\n+    public static int CXCallingConv_X86_64Win64() {\n+        return CXCallingConv_X86_64Win64;\n+    }\n+    private static final int CXCallingConv_X86_64SysV = (int)11L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXCallingConv.CXCallingConv_X86_64SysV = 11\n+     * }\n+     *\/\n+    public static int CXCallingConv_X86_64SysV() {\n+        return CXCallingConv_X86_64SysV;\n+    }\n+    private static final int CXCallingConv_X86VectorCall = (int)12L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXCallingConv.CXCallingConv_X86VectorCall = 12\n+     * }\n+     *\/\n+    public static int CXCallingConv_X86VectorCall() {\n+        return CXCallingConv_X86VectorCall;\n+    }\n+    private static final int CXCallingConv_Swift = (int)13L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXCallingConv.CXCallingConv_Swift = 13\n+     * }\n+     *\/\n+    public static int CXCallingConv_Swift() {\n+        return CXCallingConv_Swift;\n+    }\n+    private static final int CXCallingConv_PreserveMost = (int)14L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXCallingConv.CXCallingConv_PreserveMost = 14\n+     * }\n+     *\/\n+    public static int CXCallingConv_PreserveMost() {\n+        return CXCallingConv_PreserveMost;\n+    }\n+    private static final int CXCallingConv_PreserveAll = (int)15L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXCallingConv.CXCallingConv_PreserveAll = 15\n+     * }\n+     *\/\n+    public static int CXCallingConv_PreserveAll() {\n+        return CXCallingConv_PreserveAll;\n+    }\n+    private static final int CXCallingConv_AArch64VectorCall = (int)16L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXCallingConv.CXCallingConv_AArch64VectorCall = 16\n+     * }\n+     *\/\n+    public static int CXCallingConv_AArch64VectorCall() {\n+        return CXCallingConv_AArch64VectorCall;\n+    }\n+    private static final int CXCallingConv_Invalid = (int)100L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXCallingConv.CXCallingConv_Invalid = 100\n+     * }\n+     *\/\n+    public static int CXCallingConv_Invalid() {\n+        return CXCallingConv_Invalid;\n+    }\n+    private static final int CXCallingConv_Unexposed = (int)200L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXCallingConv.CXCallingConv_Unexposed = 200\n+     * }\n+     *\/\n+    public static int CXCallingConv_Unexposed() {\n+        return CXCallingConv_Unexposed;\n+    }\n+\n+    private static class clang_getCursorType$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXType.layout(),\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorType\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXType clang_getCursorType(CXCursor C)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_getCursorType$descriptor() {\n+        return clang_getCursorType$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXType clang_getCursorType(CXCursor C)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getCursorType$handle() {\n+        return clang_getCursorType$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * CXType clang_getCursorType(CXCursor C)\n+     * }\n+     *\/\n+    public static MemorySegment clang_getCursorType(SegmentAllocator allocator, MemorySegment C) {\n+        var mh$ = clang_getCursorType$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getCursorType\", allocator, C);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, C);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getTypeSpelling$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXString.layout(),\n+            CXType.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getTypeSpelling\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXString clang_getTypeSpelling(CXType CT)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_getTypeSpelling$descriptor() {\n+        return clang_getTypeSpelling$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXString clang_getTypeSpelling(CXType CT)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getTypeSpelling$handle() {\n+        return clang_getTypeSpelling$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * CXString clang_getTypeSpelling(CXType CT)\n+     * }\n+     *\/\n+    public static MemorySegment clang_getTypeSpelling(SegmentAllocator allocator, MemorySegment CT) {\n+        var mh$ = clang_getTypeSpelling$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getTypeSpelling\", allocator, CT);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, CT);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getTypedefDeclUnderlyingType$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXType.layout(),\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getTypedefDeclUnderlyingType\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXType clang_getTypedefDeclUnderlyingType(CXCursor C)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_getTypedefDeclUnderlyingType$descriptor() {\n+        return clang_getTypedefDeclUnderlyingType$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXType clang_getTypedefDeclUnderlyingType(CXCursor C)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getTypedefDeclUnderlyingType$handle() {\n+        return clang_getTypedefDeclUnderlyingType$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * CXType clang_getTypedefDeclUnderlyingType(CXCursor C)\n+     * }\n+     *\/\n+    public static MemorySegment clang_getTypedefDeclUnderlyingType(SegmentAllocator allocator, MemorySegment C) {\n+        var mh$ = clang_getTypedefDeclUnderlyingType$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getTypedefDeclUnderlyingType\", allocator, C);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, C);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getEnumDeclIntegerType$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXType.layout(),\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getEnumDeclIntegerType\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXType clang_getEnumDeclIntegerType(CXCursor C)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_getEnumDeclIntegerType$descriptor() {\n+        return clang_getEnumDeclIntegerType$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXType clang_getEnumDeclIntegerType(CXCursor C)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getEnumDeclIntegerType$handle() {\n+        return clang_getEnumDeclIntegerType$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * CXType clang_getEnumDeclIntegerType(CXCursor C)\n+     * }\n+     *\/\n+    public static MemorySegment clang_getEnumDeclIntegerType(SegmentAllocator allocator, MemorySegment C) {\n+        var mh$ = clang_getEnumDeclIntegerType$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getEnumDeclIntegerType\", allocator, C);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, C);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getEnumConstantDeclValue$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_LONG_LONG,\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getEnumConstantDeclValue\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * long long clang_getEnumConstantDeclValue(CXCursor C)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_getEnumConstantDeclValue$descriptor() {\n+        return clang_getEnumConstantDeclValue$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * long long clang_getEnumConstantDeclValue(CXCursor C)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getEnumConstantDeclValue$handle() {\n+        return clang_getEnumConstantDeclValue$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * long long clang_getEnumConstantDeclValue(CXCursor C)\n+     * }\n+     *\/\n+    public static long clang_getEnumConstantDeclValue(MemorySegment C) {\n+        var mh$ = clang_getEnumConstantDeclValue$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getEnumConstantDeclValue\", C);\n+            }\n+            return (long)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getEnumConstantDeclUnsignedValue$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_LONG_LONG,\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getEnumConstantDeclUnsignedValue\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned long long clang_getEnumConstantDeclUnsignedValue(CXCursor C)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_getEnumConstantDeclUnsignedValue$descriptor() {\n+        return clang_getEnumConstantDeclUnsignedValue$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned long long clang_getEnumConstantDeclUnsignedValue(CXCursor C)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getEnumConstantDeclUnsignedValue$handle() {\n+        return clang_getEnumConstantDeclUnsignedValue$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * unsigned long long clang_getEnumConstantDeclUnsignedValue(CXCursor C)\n+     * }\n+     *\/\n+    public static long clang_getEnumConstantDeclUnsignedValue(MemorySegment C) {\n+        var mh$ = clang_getEnumConstantDeclUnsignedValue$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getEnumConstantDeclUnsignedValue\", C);\n+            }\n+            return (long)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getFieldDeclBitWidth$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getFieldDeclBitWidth\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * int clang_getFieldDeclBitWidth(CXCursor C)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_getFieldDeclBitWidth$descriptor() {\n+        return clang_getFieldDeclBitWidth$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * int clang_getFieldDeclBitWidth(CXCursor C)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getFieldDeclBitWidth$handle() {\n+        return clang_getFieldDeclBitWidth$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * int clang_getFieldDeclBitWidth(CXCursor C)\n+     * }\n+     *\/\n+    public static int clang_getFieldDeclBitWidth(MemorySegment C) {\n+        var mh$ = clang_getFieldDeclBitWidth$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getFieldDeclBitWidth\", C);\n+            }\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_Cursor_getNumArguments$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_getNumArguments\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * int clang_Cursor_getNumArguments(CXCursor C)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_Cursor_getNumArguments$descriptor() {\n+        return clang_Cursor_getNumArguments$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * int clang_Cursor_getNumArguments(CXCursor C)\n+     * }\n+     *\/\n+    public static MethodHandle clang_Cursor_getNumArguments$handle() {\n+        return clang_Cursor_getNumArguments$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * int clang_Cursor_getNumArguments(CXCursor C)\n+     * }\n+     *\/\n+    public static int clang_Cursor_getNumArguments(MemorySegment C) {\n+        var mh$ = clang_Cursor_getNumArguments$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_Cursor_getNumArguments\", C);\n+            }\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_Cursor_getArgument$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXCursor.layout(),\n+            CXCursor.layout(),\n+            Index_h.C_INT\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_getArgument\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXCursor clang_Cursor_getArgument(CXCursor C, unsigned int i)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_Cursor_getArgument$descriptor() {\n+        return clang_Cursor_getArgument$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXCursor clang_Cursor_getArgument(CXCursor C, unsigned int i)\n+     * }\n+     *\/\n+    public static MethodHandle clang_Cursor_getArgument$handle() {\n+        return clang_Cursor_getArgument$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * CXCursor clang_Cursor_getArgument(CXCursor C, unsigned int i)\n+     * }\n+     *\/\n+    public static MemorySegment clang_Cursor_getArgument(SegmentAllocator allocator, MemorySegment C, int i) {\n+        var mh$ = clang_Cursor_getArgument$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_Cursor_getArgument\", allocator, C, i);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, C, i);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_equalTypes$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXType.layout(),\n+            CXType.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_equalTypes\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_equalTypes(CXType A, CXType B)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_equalTypes$descriptor() {\n+        return clang_equalTypes$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_equalTypes(CXType A, CXType B)\n+     * }\n+     *\/\n+    public static MethodHandle clang_equalTypes$handle() {\n+        return clang_equalTypes$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * unsigned int clang_equalTypes(CXType A, CXType B)\n+     * }\n+     *\/\n+    public static int clang_equalTypes(MemorySegment A, MemorySegment B) {\n+        var mh$ = clang_equalTypes$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_equalTypes\", A, B);\n+            }\n+            return (int)mh$.invokeExact(A, B);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getCanonicalType$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXType.layout(),\n+            CXType.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCanonicalType\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXType clang_getCanonicalType(CXType T)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_getCanonicalType$descriptor() {\n+        return clang_getCanonicalType$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXType clang_getCanonicalType(CXType T)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getCanonicalType$handle() {\n+        return clang_getCanonicalType$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * CXType clang_getCanonicalType(CXType T)\n+     * }\n+     *\/\n+    public static MemorySegment clang_getCanonicalType(SegmentAllocator allocator, MemorySegment T) {\n+        var mh$ = clang_getCanonicalType$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getCanonicalType\", allocator, T);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, T);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_isConstQualifiedType$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXType.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_isConstQualifiedType\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_isConstQualifiedType(CXType T)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_isConstQualifiedType$descriptor() {\n+        return clang_isConstQualifiedType$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_isConstQualifiedType(CXType T)\n+     * }\n+     *\/\n+    public static MethodHandle clang_isConstQualifiedType$handle() {\n+        return clang_isConstQualifiedType$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * unsigned int clang_isConstQualifiedType(CXType T)\n+     * }\n+     *\/\n+    public static int clang_isConstQualifiedType(MemorySegment T) {\n+        var mh$ = clang_isConstQualifiedType$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_isConstQualifiedType\", T);\n+            }\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_Cursor_isMacroFunctionLike$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_isMacroFunctionLike\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_Cursor_isMacroFunctionLike(CXCursor C)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_Cursor_isMacroFunctionLike$descriptor() {\n+        return clang_Cursor_isMacroFunctionLike$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_Cursor_isMacroFunctionLike(CXCursor C)\n+     * }\n+     *\/\n+    public static MethodHandle clang_Cursor_isMacroFunctionLike$handle() {\n+        return clang_Cursor_isMacroFunctionLike$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * unsigned int clang_Cursor_isMacroFunctionLike(CXCursor C)\n+     * }\n+     *\/\n+    public static int clang_Cursor_isMacroFunctionLike(MemorySegment C) {\n+        var mh$ = clang_Cursor_isMacroFunctionLike$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_Cursor_isMacroFunctionLike\", C);\n+            }\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_Cursor_isFunctionInlined$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_isFunctionInlined\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_Cursor_isFunctionInlined(CXCursor C)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_Cursor_isFunctionInlined$descriptor() {\n+        return clang_Cursor_isFunctionInlined$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_Cursor_isFunctionInlined(CXCursor C)\n+     * }\n+     *\/\n+    public static MethodHandle clang_Cursor_isFunctionInlined$handle() {\n+        return clang_Cursor_isFunctionInlined$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * unsigned int clang_Cursor_isFunctionInlined(CXCursor C)\n+     * }\n+     *\/\n+    public static int clang_Cursor_isFunctionInlined(MemorySegment C) {\n+        var mh$ = clang_Cursor_isFunctionInlined$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_Cursor_isFunctionInlined\", C);\n+            }\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_isVolatileQualifiedType$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXType.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_isVolatileQualifiedType\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_isVolatileQualifiedType(CXType T)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_isVolatileQualifiedType$descriptor() {\n+        return clang_isVolatileQualifiedType$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_isVolatileQualifiedType(CXType T)\n+     * }\n+     *\/\n+    public static MethodHandle clang_isVolatileQualifiedType$handle() {\n+        return clang_isVolatileQualifiedType$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * unsigned int clang_isVolatileQualifiedType(CXType T)\n+     * }\n+     *\/\n+    public static int clang_isVolatileQualifiedType(MemorySegment T) {\n+        var mh$ = clang_isVolatileQualifiedType$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_isVolatileQualifiedType\", T);\n+            }\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getTypedefName$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXString.layout(),\n+            CXType.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getTypedefName\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXString clang_getTypedefName(CXType CT)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_getTypedefName$descriptor() {\n+        return clang_getTypedefName$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXString clang_getTypedefName(CXType CT)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getTypedefName$handle() {\n+        return clang_getTypedefName$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * CXString clang_getTypedefName(CXType CT)\n+     * }\n+     *\/\n+    public static MemorySegment clang_getTypedefName(SegmentAllocator allocator, MemorySegment CT) {\n+        var mh$ = clang_getTypedefName$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getTypedefName\", allocator, CT);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, CT);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getPointeeType$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXType.layout(),\n+            CXType.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getPointeeType\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXType clang_getPointeeType(CXType T)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_getPointeeType$descriptor() {\n+        return clang_getPointeeType$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXType clang_getPointeeType(CXType T)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getPointeeType$handle() {\n+        return clang_getPointeeType$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * CXType clang_getPointeeType(CXType T)\n+     * }\n+     *\/\n+    public static MemorySegment clang_getPointeeType(SegmentAllocator allocator, MemorySegment T) {\n+        var mh$ = clang_getPointeeType$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getPointeeType\", allocator, T);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, T);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getTypeDeclaration$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXCursor.layout(),\n+            CXType.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getTypeDeclaration\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXCursor clang_getTypeDeclaration(CXType T)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_getTypeDeclaration$descriptor() {\n+        return clang_getTypeDeclaration$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXCursor clang_getTypeDeclaration(CXType T)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getTypeDeclaration$handle() {\n+        return clang_getTypeDeclaration$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * CXCursor clang_getTypeDeclaration(CXType T)\n+     * }\n+     *\/\n+    public static MemorySegment clang_getTypeDeclaration(SegmentAllocator allocator, MemorySegment T) {\n+        var mh$ = clang_getTypeDeclaration$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getTypeDeclaration\", allocator, T);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, T);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getTypeKindSpelling$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXString.layout(),\n+            Index_h.C_INT\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getTypeKindSpelling\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXString clang_getTypeKindSpelling(enum CXTypeKind K)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_getTypeKindSpelling$descriptor() {\n+        return clang_getTypeKindSpelling$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXString clang_getTypeKindSpelling(enum CXTypeKind K)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getTypeKindSpelling$handle() {\n+        return clang_getTypeKindSpelling$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * CXString clang_getTypeKindSpelling(enum CXTypeKind K)\n+     * }\n+     *\/\n+    public static MemorySegment clang_getTypeKindSpelling(SegmentAllocator allocator, int K) {\n+        var mh$ = clang_getTypeKindSpelling$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getTypeKindSpelling\", allocator, K);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, K);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getFunctionTypeCallingConv$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXType.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getFunctionTypeCallingConv\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * enum CXCallingConv clang_getFunctionTypeCallingConv(CXType T)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_getFunctionTypeCallingConv$descriptor() {\n+        return clang_getFunctionTypeCallingConv$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * enum CXCallingConv clang_getFunctionTypeCallingConv(CXType T)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getFunctionTypeCallingConv$handle() {\n+        return clang_getFunctionTypeCallingConv$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXCallingConv clang_getFunctionTypeCallingConv(CXType T)\n+     * }\n+     *\/\n+    public static int clang_getFunctionTypeCallingConv(MemorySegment T) {\n+        var mh$ = clang_getFunctionTypeCallingConv$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getFunctionTypeCallingConv\", T);\n+            }\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getResultType$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXType.layout(),\n+            CXType.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getResultType\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXType clang_getResultType(CXType T)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_getResultType$descriptor() {\n+        return clang_getResultType$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXType clang_getResultType(CXType T)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getResultType$handle() {\n+        return clang_getResultType$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * CXType clang_getResultType(CXType T)\n+     * }\n+     *\/\n+    public static MemorySegment clang_getResultType(SegmentAllocator allocator, MemorySegment T) {\n+        var mh$ = clang_getResultType$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getResultType\", allocator, T);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, T);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getNumArgTypes$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXType.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getNumArgTypes\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * int clang_getNumArgTypes(CXType T)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_getNumArgTypes$descriptor() {\n+        return clang_getNumArgTypes$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * int clang_getNumArgTypes(CXType T)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getNumArgTypes$handle() {\n+        return clang_getNumArgTypes$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * int clang_getNumArgTypes(CXType T)\n+     * }\n+     *\/\n+    public static int clang_getNumArgTypes(MemorySegment T) {\n+        var mh$ = clang_getNumArgTypes$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getNumArgTypes\", T);\n+            }\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getArgType$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXType.layout(),\n+            CXType.layout(),\n+            Index_h.C_INT\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getArgType\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXType clang_getArgType(CXType T, unsigned int i)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_getArgType$descriptor() {\n+        return clang_getArgType$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXType clang_getArgType(CXType T, unsigned int i)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getArgType$handle() {\n+        return clang_getArgType$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * CXType clang_getArgType(CXType T, unsigned int i)\n+     * }\n+     *\/\n+    public static MemorySegment clang_getArgType(SegmentAllocator allocator, MemorySegment T, int i) {\n+        var mh$ = clang_getArgType$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getArgType\", allocator, T, i);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, T, i);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_isFunctionTypeVariadic$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXType.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_isFunctionTypeVariadic\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_isFunctionTypeVariadic(CXType T)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_isFunctionTypeVariadic$descriptor() {\n+        return clang_isFunctionTypeVariadic$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_isFunctionTypeVariadic(CXType T)\n+     * }\n+     *\/\n+    public static MethodHandle clang_isFunctionTypeVariadic$handle() {\n+        return clang_isFunctionTypeVariadic$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * unsigned int clang_isFunctionTypeVariadic(CXType T)\n+     * }\n+     *\/\n+    public static int clang_isFunctionTypeVariadic(MemorySegment T) {\n+        var mh$ = clang_isFunctionTypeVariadic$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_isFunctionTypeVariadic\", T);\n+            }\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getCursorResultType$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXType.layout(),\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorResultType\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXType clang_getCursorResultType(CXCursor C)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_getCursorResultType$descriptor() {\n+        return clang_getCursorResultType$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXType clang_getCursorResultType(CXCursor C)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getCursorResultType$handle() {\n+        return clang_getCursorResultType$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * CXType clang_getCursorResultType(CXCursor C)\n+     * }\n+     *\/\n+    public static MemorySegment clang_getCursorResultType(SegmentAllocator allocator, MemorySegment C) {\n+        var mh$ = clang_getCursorResultType$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getCursorResultType\", allocator, C);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, C);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getElementType$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXType.layout(),\n+            CXType.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getElementType\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXType clang_getElementType(CXType T)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_getElementType$descriptor() {\n+        return clang_getElementType$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXType clang_getElementType(CXType T)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getElementType$handle() {\n+        return clang_getElementType$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * CXType clang_getElementType(CXType T)\n+     * }\n+     *\/\n+    public static MemorySegment clang_getElementType(SegmentAllocator allocator, MemorySegment T) {\n+        var mh$ = clang_getElementType$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getElementType\", allocator, T);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, T);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getNumElements$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_LONG_LONG,\n+            CXType.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getNumElements\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * long long clang_getNumElements(CXType T)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_getNumElements$descriptor() {\n+        return clang_getNumElements$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * long long clang_getNumElements(CXType T)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getNumElements$handle() {\n+        return clang_getNumElements$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * long long clang_getNumElements(CXType T)\n+     * }\n+     *\/\n+    public static long clang_getNumElements(MemorySegment T) {\n+        var mh$ = clang_getNumElements$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getNumElements\", T);\n+            }\n+            return (long)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getArrayElementType$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXType.layout(),\n+            CXType.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getArrayElementType\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXType clang_getArrayElementType(CXType T)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_getArrayElementType$descriptor() {\n+        return clang_getArrayElementType$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXType clang_getArrayElementType(CXType T)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getArrayElementType$handle() {\n+        return clang_getArrayElementType$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * CXType clang_getArrayElementType(CXType T)\n+     * }\n+     *\/\n+    public static MemorySegment clang_getArrayElementType(SegmentAllocator allocator, MemorySegment T) {\n+        var mh$ = clang_getArrayElementType$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getArrayElementType\", allocator, T);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, T);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getArraySize$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_LONG_LONG,\n+            CXType.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getArraySize\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * long long clang_getArraySize(CXType T)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_getArraySize$descriptor() {\n+        return clang_getArraySize$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * long long clang_getArraySize(CXType T)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getArraySize$handle() {\n+        return clang_getArraySize$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * long long clang_getArraySize(CXType T)\n+     * }\n+     *\/\n+    public static long clang_getArraySize(MemorySegment T) {\n+        var mh$ = clang_getArraySize$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getArraySize\", T);\n+            }\n+            return (long)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    private static final int CXTypeNullability_NonNull = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeNullabilityKind.CXTypeNullability_NonNull = 0\n+     * }\n+     *\/\n+    public static int CXTypeNullability_NonNull() {\n+        return CXTypeNullability_NonNull;\n+    }\n+    private static final int CXTypeNullability_Nullable = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeNullabilityKind.CXTypeNullability_Nullable = 1\n+     * }\n+     *\/\n+    public static int CXTypeNullability_Nullable() {\n+        return CXTypeNullability_Nullable;\n+    }\n+    private static final int CXTypeNullability_Unspecified = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeNullabilityKind.CXTypeNullability_Unspecified = 2\n+     * }\n+     *\/\n+    public static int CXTypeNullability_Unspecified() {\n+        return CXTypeNullability_Unspecified;\n+    }\n+    private static final int CXTypeNullability_Invalid = (int)3L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeNullabilityKind.CXTypeNullability_Invalid = 3\n+     * }\n+     *\/\n+    public static int CXTypeNullability_Invalid() {\n+        return CXTypeNullability_Invalid;\n+    }\n+    private static final int CXTypeLayoutError_Invalid = (int)-1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeLayoutError.CXTypeLayoutError_Invalid = -1\n+     * }\n+     *\/\n+    public static int CXTypeLayoutError_Invalid() {\n+        return CXTypeLayoutError_Invalid;\n+    }\n+    private static final int CXTypeLayoutError_Incomplete = (int)-2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeLayoutError.CXTypeLayoutError_Incomplete = -2\n+     * }\n+     *\/\n+    public static int CXTypeLayoutError_Incomplete() {\n+        return CXTypeLayoutError_Incomplete;\n+    }\n+    private static final int CXTypeLayoutError_Dependent = (int)-3L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeLayoutError.CXTypeLayoutError_Dependent = -3\n+     * }\n+     *\/\n+    public static int CXTypeLayoutError_Dependent() {\n+        return CXTypeLayoutError_Dependent;\n+    }\n+    private static final int CXTypeLayoutError_NotConstantSize = (int)-4L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeLayoutError.CXTypeLayoutError_NotConstantSize = -4\n+     * }\n+     *\/\n+    public static int CXTypeLayoutError_NotConstantSize() {\n+        return CXTypeLayoutError_NotConstantSize;\n+    }\n+    private static final int CXTypeLayoutError_InvalidFieldName = (int)-5L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeLayoutError.CXTypeLayoutError_InvalidFieldName = -5\n+     * }\n+     *\/\n+    public static int CXTypeLayoutError_InvalidFieldName() {\n+        return CXTypeLayoutError_InvalidFieldName;\n+    }\n+    private static final int CXTypeLayoutError_Undeduced = (int)-6L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXTypeLayoutError.CXTypeLayoutError_Undeduced = -6\n+     * }\n+     *\/\n+    public static int CXTypeLayoutError_Undeduced() {\n+        return CXTypeLayoutError_Undeduced;\n+    }\n+\n+    private static class clang_Type_getAlignOf$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_LONG_LONG,\n+            CXType.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Type_getAlignOf\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * long long clang_Type_getAlignOf(CXType T)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_Type_getAlignOf$descriptor() {\n+        return clang_Type_getAlignOf$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * long long clang_Type_getAlignOf(CXType T)\n+     * }\n+     *\/\n+    public static MethodHandle clang_Type_getAlignOf$handle() {\n+        return clang_Type_getAlignOf$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * long long clang_Type_getAlignOf(CXType T)\n+     * }\n+     *\/\n+    public static long clang_Type_getAlignOf(MemorySegment T) {\n+        var mh$ = clang_Type_getAlignOf$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_Type_getAlignOf\", T);\n+            }\n+            return (long)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_Type_getSizeOf$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_LONG_LONG,\n+            CXType.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Type_getSizeOf\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * long long clang_Type_getSizeOf(CXType T)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_Type_getSizeOf$descriptor() {\n+        return clang_Type_getSizeOf$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * long long clang_Type_getSizeOf(CXType T)\n+     * }\n+     *\/\n+    public static MethodHandle clang_Type_getSizeOf$handle() {\n+        return clang_Type_getSizeOf$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * long long clang_Type_getSizeOf(CXType T)\n+     * }\n+     *\/\n+    public static long clang_Type_getSizeOf(MemorySegment T) {\n+        var mh$ = clang_Type_getSizeOf$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_Type_getSizeOf\", T);\n+            }\n+            return (long)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_Type_getOffsetOf$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_LONG_LONG,\n+            CXType.layout(),\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Type_getOffsetOf\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * long long clang_Type_getOffsetOf(CXType T, const char *S)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_Type_getOffsetOf$descriptor() {\n+        return clang_Type_getOffsetOf$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * long long clang_Type_getOffsetOf(CXType T, const char *S)\n+     * }\n+     *\/\n+    public static MethodHandle clang_Type_getOffsetOf$handle() {\n+        return clang_Type_getOffsetOf$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * long long clang_Type_getOffsetOf(CXType T, const char *S)\n+     * }\n+     *\/\n+    public static long clang_Type_getOffsetOf(MemorySegment T, MemorySegment S) {\n+        var mh$ = clang_Type_getOffsetOf$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_Type_getOffsetOf\", T, S);\n+            }\n+            return (long)mh$.invokeExact(T, S);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_Type_getValueType$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXType.layout(),\n+            CXType.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Type_getValueType\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXType clang_Type_getValueType(CXType CT)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_Type_getValueType$descriptor() {\n+        return clang_Type_getValueType$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXType clang_Type_getValueType(CXType CT)\n+     * }\n+     *\/\n+    public static MethodHandle clang_Type_getValueType$handle() {\n+        return clang_Type_getValueType$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * CXType clang_Type_getValueType(CXType CT)\n+     * }\n+     *\/\n+    public static MemorySegment clang_Type_getValueType(SegmentAllocator allocator, MemorySegment CT) {\n+        var mh$ = clang_Type_getValueType$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_Type_getValueType\", allocator, CT);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, CT);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_Cursor_isAnonymous$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_isAnonymous\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_Cursor_isAnonymous(CXCursor C)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_Cursor_isAnonymous$descriptor() {\n+        return clang_Cursor_isAnonymous$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_Cursor_isAnonymous(CXCursor C)\n+     * }\n+     *\/\n+    public static MethodHandle clang_Cursor_isAnonymous$handle() {\n+        return clang_Cursor_isAnonymous$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * unsigned int clang_Cursor_isAnonymous(CXCursor C)\n+     * }\n+     *\/\n+    public static int clang_Cursor_isAnonymous(MemorySegment C) {\n+        var mh$ = clang_Cursor_isAnonymous$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_Cursor_isAnonymous\", C);\n+            }\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_Cursor_isAnonymousRecordDecl$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_isAnonymousRecordDecl\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_Cursor_isAnonymousRecordDecl(CXCursor C)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_Cursor_isAnonymousRecordDecl$descriptor() {\n+        return clang_Cursor_isAnonymousRecordDecl$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_Cursor_isAnonymousRecordDecl(CXCursor C)\n+     * }\n+     *\/\n+    public static MethodHandle clang_Cursor_isAnonymousRecordDecl$handle() {\n+        return clang_Cursor_isAnonymousRecordDecl$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * unsigned int clang_Cursor_isAnonymousRecordDecl(CXCursor C)\n+     * }\n+     *\/\n+    public static int clang_Cursor_isAnonymousRecordDecl(MemorySegment C) {\n+        var mh$ = clang_Cursor_isAnonymousRecordDecl$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_Cursor_isAnonymousRecordDecl\", C);\n+            }\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_Cursor_isBitField$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_isBitField\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_Cursor_isBitField(CXCursor C)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_Cursor_isBitField$descriptor() {\n+        return clang_Cursor_isBitField$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_Cursor_isBitField(CXCursor C)\n+     * }\n+     *\/\n+    public static MethodHandle clang_Cursor_isBitField$handle() {\n+        return clang_Cursor_isBitField$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * unsigned int clang_Cursor_isBitField(CXCursor C)\n+     * }\n+     *\/\n+    public static int clang_Cursor_isBitField(MemorySegment C) {\n+        var mh$ = clang_Cursor_isBitField$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_Cursor_isBitField\", C);\n+            }\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    private static final int CXChildVisit_Break = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXChildVisitResult.CXChildVisit_Break = 0\n+     * }\n+     *\/\n+    public static int CXChildVisit_Break() {\n+        return CXChildVisit_Break;\n+    }\n+    private static final int CXChildVisit_Continue = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXChildVisitResult.CXChildVisit_Continue = 1\n+     * }\n+     *\/\n+    public static int CXChildVisit_Continue() {\n+        return CXChildVisit_Continue;\n+    }\n+    private static final int CXChildVisit_Recurse = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXChildVisitResult.CXChildVisit_Recurse = 2\n+     * }\n+     *\/\n+    public static int CXChildVisit_Recurse() {\n+        return CXChildVisit_Recurse;\n+    }\n+\n+    private static class clang_visitChildren$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXCursor.layout(),\n+            Index_h.C_POINTER,\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_visitChildren\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_visitChildren(CXCursor parent, CXCursorVisitor visitor, CXClientData client_data)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_visitChildren$descriptor() {\n+        return clang_visitChildren$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_visitChildren(CXCursor parent, CXCursorVisitor visitor, CXClientData client_data)\n+     * }\n+     *\/\n+    public static MethodHandle clang_visitChildren$handle() {\n+        return clang_visitChildren$constants.HANDLE;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * unsigned int clang_visitChildren(CXCursor parent, CXCursorVisitor visitor, CXClientData client_data)\n+     * }\n+     *\/\n+    public static int clang_visitChildren(MemorySegment parent, MemorySegment visitor, MemorySegment client_data) {\n+        var mh$ = clang_visitChildren$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_visitChildren\", parent, visitor, client_data);\n+            }\n+            return (int)mh$.invokeExact(parent, visitor, client_data);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getCursorUSR$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXString.layout(),\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorUSR\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXString clang_getCursorUSR(CXCursor)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_getCursorUSR$descriptor() {\n+        return clang_getCursorUSR$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXString clang_getCursorUSR(CXCursor)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getCursorUSR$handle() {\n+        return clang_getCursorUSR$constants.HANDLE;\n@@ -4709,2 +8311,2 @@\n-     * {@snippet :\n-     * CXCursor clang_getTypeDeclaration(CXType T);\n+     * {@snippet lang=c :\n+     * CXString clang_getCursorUSR(CXCursor)\n@@ -4713,2 +8315,2 @@\n-    public static MemorySegment clang_getTypeDeclaration(SegmentAllocator allocator, MemorySegment T) {\n-        var mh$ = clang_getTypeDeclaration$MH();\n+    public static MemorySegment clang_getCursorUSR(SegmentAllocator allocator, MemorySegment x0) {\n+        var mh$ = clang_getCursorUSR$constants.HANDLE;\n@@ -4716,1 +8318,4 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getCursorUSR\", allocator, x0);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, x0);\n@@ -4718,1 +8323,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4721,2 +8326,10 @@\n-    public static MethodHandle clang_getTypeKindSpelling$MH() {\n-        return RuntimeHelper.requireNonNull(constants$10.clang_getTypeKindSpelling$MH,\"clang_getTypeKindSpelling\");\n+\n+    private static class clang_getCursorSpelling$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXString.layout(),\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorSpelling\"),\n+                    DESC);\n@@ -4724,0 +8337,1 @@\n+\n@@ -4725,2 +8339,3 @@\n-     * {@snippet :\n-     * CXString clang_getTypeKindSpelling(enum CXTypeKind K);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXString clang_getCursorSpelling(CXCursor)\n@@ -4729,7 +8344,2 @@\n-    public static MemorySegment clang_getTypeKindSpelling(SegmentAllocator allocator, int K) {\n-        var mh$ = clang_getTypeKindSpelling$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, K);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static FunctionDescriptor clang_getCursorSpelling$descriptor() {\n+        return clang_getCursorSpelling$constants.DESC;\n@@ -4737,2 +8347,9 @@\n-    public static MethodHandle clang_getFunctionTypeCallingConv$MH() {\n-        return RuntimeHelper.requireNonNull(constants$10.clang_getFunctionTypeCallingConv$MH,\"clang_getFunctionTypeCallingConv\");\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXString clang_getCursorSpelling(CXCursor)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getCursorSpelling$handle() {\n+        return clang_getCursorSpelling$constants.HANDLE;\n@@ -4741,2 +8358,2 @@\n-     * {@snippet :\n-     * enum CXCallingConv clang_getFunctionTypeCallingConv(CXType T);\n+     * {@snippet lang=c :\n+     * CXString clang_getCursorSpelling(CXCursor)\n@@ -4745,2 +8362,2 @@\n-    public static int clang_getFunctionTypeCallingConv(MemorySegment T) {\n-        var mh$ = clang_getFunctionTypeCallingConv$MH();\n+    public static MemorySegment clang_getCursorSpelling(SegmentAllocator allocator, MemorySegment x0) {\n+        var mh$ = clang_getCursorSpelling$constants.HANDLE;\n@@ -4748,1 +8365,4 @@\n-            return (int)mh$.invokeExact(T);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getCursorSpelling\", allocator, x0);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, x0);\n@@ -4750,1 +8370,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4753,2 +8373,8 @@\n-    public static MethodHandle clang_getResultType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$11.clang_getResultType$MH,\"clang_getResultType\");\n+    private static final int CXPrintingPolicy_Indentation = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_Indentation = 0\n+     * }\n+     *\/\n+    public static int CXPrintingPolicy_Indentation() {\n+        return CXPrintingPolicy_Indentation;\n@@ -4756,0 +8382,1 @@\n+    private static final int CXPrintingPolicy_SuppressSpecifiers = (int)1L;\n@@ -4757,2 +8384,2 @@\n-     * {@snippet :\n-     * CXType clang_getResultType(CXType T);\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_SuppressSpecifiers = 1\n@@ -4761,7 +8388,2 @@\n-    public static MemorySegment clang_getResultType(SegmentAllocator allocator, MemorySegment T) {\n-        var mh$ = clang_getResultType$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static int CXPrintingPolicy_SuppressSpecifiers() {\n+        return CXPrintingPolicy_SuppressSpecifiers;\n@@ -4769,2 +8391,8 @@\n-    public static MethodHandle clang_getNumArgTypes$MH() {\n-        return RuntimeHelper.requireNonNull(constants$11.clang_getNumArgTypes$MH,\"clang_getNumArgTypes\");\n+    private static final int CXPrintingPolicy_SuppressTagKeyword = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_SuppressTagKeyword = 2\n+     * }\n+     *\/\n+    public static int CXPrintingPolicy_SuppressTagKeyword() {\n+        return CXPrintingPolicy_SuppressTagKeyword;\n@@ -4772,0 +8400,1 @@\n+    private static final int CXPrintingPolicy_IncludeTagDefinition = (int)3L;\n@@ -4773,2 +8402,2 @@\n-     * {@snippet :\n-     * int clang_getNumArgTypes(CXType T);\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_IncludeTagDefinition = 3\n@@ -4777,7 +8406,2 @@\n-    public static int clang_getNumArgTypes(MemorySegment T) {\n-        var mh$ = clang_getNumArgTypes$MH();\n-        try {\n-            return (int)mh$.invokeExact(T);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static int CXPrintingPolicy_IncludeTagDefinition() {\n+        return CXPrintingPolicy_IncludeTagDefinition;\n@@ -4785,2 +8409,8 @@\n-    public static MethodHandle clang_getArgType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$11.clang_getArgType$MH,\"clang_getArgType\");\n+    private static final int CXPrintingPolicy_SuppressScope = (int)4L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_SuppressScope = 4\n+     * }\n+     *\/\n+    public static int CXPrintingPolicy_SuppressScope() {\n+        return CXPrintingPolicy_SuppressScope;\n@@ -4788,0 +8418,1 @@\n+    private static final int CXPrintingPolicy_SuppressUnwrittenScope = (int)5L;\n@@ -4789,2 +8420,2 @@\n-     * {@snippet :\n-     * CXType clang_getArgType(CXType T, unsigned int i);\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_SuppressUnwrittenScope = 5\n@@ -4793,7 +8424,2 @@\n-    public static MemorySegment clang_getArgType(SegmentAllocator allocator, MemorySegment T, int i) {\n-        var mh$ = clang_getArgType$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, T, i);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static int CXPrintingPolicy_SuppressUnwrittenScope() {\n+        return CXPrintingPolicy_SuppressUnwrittenScope;\n@@ -4801,2 +8427,8 @@\n-    public static MethodHandle clang_isFunctionTypeVariadic$MH() {\n-        return RuntimeHelper.requireNonNull(constants$11.clang_isFunctionTypeVariadic$MH,\"clang_isFunctionTypeVariadic\");\n+    private static final int CXPrintingPolicy_SuppressInitializers = (int)6L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_SuppressInitializers = 6\n+     * }\n+     *\/\n+    public static int CXPrintingPolicy_SuppressInitializers() {\n+        return CXPrintingPolicy_SuppressInitializers;\n@@ -4804,0 +8436,1 @@\n+    private static final int CXPrintingPolicy_ConstantArraySizeAsWritten = (int)7L;\n@@ -4805,2 +8438,2 @@\n-     * {@snippet :\n-     * unsigned int clang_isFunctionTypeVariadic(CXType T);\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_ConstantArraySizeAsWritten = 7\n@@ -4809,7 +8442,2 @@\n-    public static int clang_isFunctionTypeVariadic(MemorySegment T) {\n-        var mh$ = clang_isFunctionTypeVariadic$MH();\n-        try {\n-            return (int)mh$.invokeExact(T);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static int CXPrintingPolicy_ConstantArraySizeAsWritten() {\n+        return CXPrintingPolicy_ConstantArraySizeAsWritten;\n@@ -4817,2 +8445,8 @@\n-    public static MethodHandle clang_getCursorResultType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$11.clang_getCursorResultType$MH,\"clang_getCursorResultType\");\n+    private static final int CXPrintingPolicy_AnonymousTagLocations = (int)8L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_AnonymousTagLocations = 8\n+     * }\n+     *\/\n+    public static int CXPrintingPolicy_AnonymousTagLocations() {\n+        return CXPrintingPolicy_AnonymousTagLocations;\n@@ -4820,0 +8454,1 @@\n+    private static final int CXPrintingPolicy_SuppressStrongLifetime = (int)9L;\n@@ -4821,2 +8456,2 @@\n-     * {@snippet :\n-     * CXType clang_getCursorResultType(CXCursor C);\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_SuppressStrongLifetime = 9\n@@ -4825,7 +8460,2 @@\n-    public static MemorySegment clang_getCursorResultType(SegmentAllocator allocator, MemorySegment C) {\n-        var mh$ = clang_getCursorResultType$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, C);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static int CXPrintingPolicy_SuppressStrongLifetime() {\n+        return CXPrintingPolicy_SuppressStrongLifetime;\n@@ -4833,2 +8463,8 @@\n-    public static MethodHandle clang_getElementType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$11.clang_getElementType$MH,\"clang_getElementType\");\n+    private static final int CXPrintingPolicy_SuppressLifetimeQualifiers = (int)10L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_SuppressLifetimeQualifiers = 10\n+     * }\n+     *\/\n+    public static int CXPrintingPolicy_SuppressLifetimeQualifiers() {\n+        return CXPrintingPolicy_SuppressLifetimeQualifiers;\n@@ -4836,0 +8472,1 @@\n+    private static final int CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors = (int)11L;\n@@ -4837,2 +8474,2 @@\n-     * {@snippet :\n-     * CXType clang_getElementType(CXType T);\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors = 11\n@@ -4841,7 +8478,2 @@\n-    public static MemorySegment clang_getElementType(SegmentAllocator allocator, MemorySegment T) {\n-        var mh$ = clang_getElementType$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static int CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors() {\n+        return CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors;\n@@ -4849,2 +8481,8 @@\n-    public static MethodHandle clang_getNumElements$MH() {\n-        return RuntimeHelper.requireNonNull(constants$12.clang_getNumElements$MH,\"clang_getNumElements\");\n+    private static final int CXPrintingPolicy_Bool = (int)12L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_Bool = 12\n+     * }\n+     *\/\n+    public static int CXPrintingPolicy_Bool() {\n+        return CXPrintingPolicy_Bool;\n@@ -4852,0 +8490,1 @@\n+    private static final int CXPrintingPolicy_Restrict = (int)13L;\n@@ -4853,2 +8492,2 @@\n-     * {@snippet :\n-     * long long clang_getNumElements(CXType T);\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_Restrict = 13\n@@ -4857,7 +8496,2 @@\n-    public static long clang_getNumElements(MemorySegment T) {\n-        var mh$ = clang_getNumElements$MH();\n-        try {\n-            return (long)mh$.invokeExact(T);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static int CXPrintingPolicy_Restrict() {\n+        return CXPrintingPolicy_Restrict;\n@@ -4865,2 +8499,8 @@\n-    public static MethodHandle clang_getArrayElementType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$12.clang_getArrayElementType$MH,\"clang_getArrayElementType\");\n+    private static final int CXPrintingPolicy_Alignof = (int)14L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_Alignof = 14\n+     * }\n+     *\/\n+    public static int CXPrintingPolicy_Alignof() {\n+        return CXPrintingPolicy_Alignof;\n@@ -4868,0 +8508,1 @@\n+    private static final int CXPrintingPolicy_UnderscoreAlignof = (int)15L;\n@@ -4869,2 +8510,2 @@\n-     * {@snippet :\n-     * CXType clang_getArrayElementType(CXType T);\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_UnderscoreAlignof = 15\n@@ -4873,7 +8514,2 @@\n-    public static MemorySegment clang_getArrayElementType(SegmentAllocator allocator, MemorySegment T) {\n-        var mh$ = clang_getArrayElementType$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static int CXPrintingPolicy_UnderscoreAlignof() {\n+        return CXPrintingPolicy_UnderscoreAlignof;\n@@ -4881,2 +8517,8 @@\n-    public static MethodHandle clang_getArraySize$MH() {\n-        return RuntimeHelper.requireNonNull(constants$12.clang_getArraySize$MH,\"clang_getArraySize\");\n+    private static final int CXPrintingPolicy_UseVoidForZeroParams = (int)16L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_UseVoidForZeroParams = 16\n+     * }\n+     *\/\n+    public static int CXPrintingPolicy_UseVoidForZeroParams() {\n+        return CXPrintingPolicy_UseVoidForZeroParams;\n@@ -4884,0 +8526,1 @@\n+    private static final int CXPrintingPolicy_TerseOutput = (int)17L;\n@@ -4885,2 +8528,2 @@\n-     * {@snippet :\n-     * long long clang_getArraySize(CXType T);\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_TerseOutput = 17\n@@ -4889,7 +8532,2 @@\n-    public static long clang_getArraySize(MemorySegment T) {\n-        var mh$ = clang_getArraySize$MH();\n-        try {\n-            return (long)mh$.invokeExact(T);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static int CXPrintingPolicy_TerseOutput() {\n+        return CXPrintingPolicy_TerseOutput;\n@@ -4897,0 +8535,1 @@\n+    private static final int CXPrintingPolicy_PolishForDeclaration = (int)18L;\n@@ -4898,2 +8537,2 @@\n-     * {@snippet :\n-     * enum CXTypeNullabilityKind.CXTypeNullability_NonNull = 0;\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_PolishForDeclaration = 18\n@@ -4902,2 +8541,2 @@\n-    public static int CXTypeNullability_NonNull() {\n-        return (int)0L;\n+    public static int CXPrintingPolicy_PolishForDeclaration() {\n+        return CXPrintingPolicy_PolishForDeclaration;\n@@ -4905,0 +8544,1 @@\n+    private static final int CXPrintingPolicy_Half = (int)19L;\n@@ -4906,2 +8546,2 @@\n-     * {@snippet :\n-     * enum CXTypeNullabilityKind.CXTypeNullability_Nullable = 1;\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_Half = 19\n@@ -4910,2 +8550,2 @@\n-    public static int CXTypeNullability_Nullable() {\n-        return (int)1L;\n+    public static int CXPrintingPolicy_Half() {\n+        return CXPrintingPolicy_Half;\n@@ -4913,0 +8553,1 @@\n+    private static final int CXPrintingPolicy_MSWChar = (int)20L;\n@@ -4914,2 +8555,2 @@\n-     * {@snippet :\n-     * enum CXTypeNullabilityKind.CXTypeNullability_Unspecified = 2;\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_MSWChar = 20\n@@ -4918,2 +8559,2 @@\n-    public static int CXTypeNullability_Unspecified() {\n-        return (int)2L;\n+    public static int CXPrintingPolicy_MSWChar() {\n+        return CXPrintingPolicy_MSWChar;\n@@ -4921,0 +8562,1 @@\n+    private static final int CXPrintingPolicy_IncludeNewlines = (int)21L;\n@@ -4922,2 +8564,2 @@\n-     * {@snippet :\n-     * enum CXTypeNullabilityKind.CXTypeNullability_Invalid = 3;\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_IncludeNewlines = 21\n@@ -4926,2 +8568,2 @@\n-    public static int CXTypeNullability_Invalid() {\n-        return (int)3L;\n+    public static int CXPrintingPolicy_IncludeNewlines() {\n+        return CXPrintingPolicy_IncludeNewlines;\n@@ -4929,0 +8571,1 @@\n+    private static final int CXPrintingPolicy_MSVCFormatting = (int)22L;\n@@ -4930,2 +8573,2 @@\n-     * {@snippet :\n-     * enum CXTypeLayoutError.CXTypeLayoutError_Invalid = -1;\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_MSVCFormatting = 22\n@@ -4934,2 +8577,2 @@\n-    public static int CXTypeLayoutError_Invalid() {\n-        return (int)-1L;\n+    public static int CXPrintingPolicy_MSVCFormatting() {\n+        return CXPrintingPolicy_MSVCFormatting;\n@@ -4937,0 +8580,1 @@\n+    private static final int CXPrintingPolicy_ConstantsAsWritten = (int)23L;\n@@ -4938,2 +8582,2 @@\n-     * {@snippet :\n-     * enum CXTypeLayoutError.CXTypeLayoutError_Incomplete = -2;\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_ConstantsAsWritten = 23\n@@ -4942,2 +8586,2 @@\n-    public static int CXTypeLayoutError_Incomplete() {\n-        return (int)-2L;\n+    public static int CXPrintingPolicy_ConstantsAsWritten() {\n+        return CXPrintingPolicy_ConstantsAsWritten;\n@@ -4945,0 +8589,1 @@\n+    private static final int CXPrintingPolicy_SuppressImplicitBase = (int)24L;\n@@ -4946,2 +8591,2 @@\n-     * {@snippet :\n-     * enum CXTypeLayoutError.CXTypeLayoutError_Dependent = -3;\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_SuppressImplicitBase = 24\n@@ -4950,2 +8595,2 @@\n-    public static int CXTypeLayoutError_Dependent() {\n-        return (int)-3L;\n+    public static int CXPrintingPolicy_SuppressImplicitBase() {\n+        return CXPrintingPolicy_SuppressImplicitBase;\n@@ -4953,0 +8598,1 @@\n+    private static final int CXPrintingPolicy_FullyQualifiedName = (int)25L;\n@@ -4954,2 +8600,2 @@\n-     * {@snippet :\n-     * enum CXTypeLayoutError.CXTypeLayoutError_NotConstantSize = -4;\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_FullyQualifiedName = 25\n@@ -4958,2 +8604,2 @@\n-    public static int CXTypeLayoutError_NotConstantSize() {\n-        return (int)-4L;\n+    public static int CXPrintingPolicy_FullyQualifiedName() {\n+        return CXPrintingPolicy_FullyQualifiedName;\n@@ -4961,0 +8607,1 @@\n+    private static final int CXPrintingPolicy_LastProperty = (int)25L;\n@@ -4962,2 +8609,2 @@\n-     * {@snippet :\n-     * enum CXTypeLayoutError.CXTypeLayoutError_InvalidFieldName = -5;\n+     * {@snippet lang=c :\n+     * enum CXPrintingPolicyProperty.CXPrintingPolicy_LastProperty = 25\n@@ -4966,2 +8613,2 @@\n-    public static int CXTypeLayoutError_InvalidFieldName() {\n-        return (int)-5L;\n+    public static int CXPrintingPolicy_LastProperty() {\n+        return CXPrintingPolicy_LastProperty;\n@@ -4969,0 +8616,13 @@\n+\n+    private static class clang_PrintingPolicy_getProperty$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            Index_h.C_POINTER,\n+            Index_h.C_INT\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_PrintingPolicy_getProperty\"),\n+                    DESC);\n+    }\n+\n@@ -4970,2 +8630,3 @@\n-     * {@snippet :\n-     * enum CXTypeLayoutError.CXTypeLayoutError_Undeduced = -6;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_PrintingPolicy_getProperty(CXPrintingPolicy Policy, enum CXPrintingPolicyProperty Property)\n@@ -4974,2 +8635,2 @@\n-    public static int CXTypeLayoutError_Undeduced() {\n-        return (int)-6L;\n+    public static FunctionDescriptor clang_PrintingPolicy_getProperty$descriptor() {\n+        return clang_PrintingPolicy_getProperty$constants.DESC;\n@@ -4977,2 +8638,9 @@\n-    public static MethodHandle clang_Type_getSizeOf$MH() {\n-        return RuntimeHelper.requireNonNull(constants$12.clang_Type_getSizeOf$MH,\"clang_Type_getSizeOf\");\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_PrintingPolicy_getProperty(CXPrintingPolicy Policy, enum CXPrintingPolicyProperty Property)\n+     * }\n+     *\/\n+    public static MethodHandle clang_PrintingPolicy_getProperty$handle() {\n+        return clang_PrintingPolicy_getProperty$constants.HANDLE;\n@@ -4981,2 +8649,2 @@\n-     * {@snippet :\n-     * long long clang_Type_getSizeOf(CXType T);\n+     * {@snippet lang=c :\n+     * unsigned int clang_PrintingPolicy_getProperty(CXPrintingPolicy Policy, enum CXPrintingPolicyProperty Property)\n@@ -4985,2 +8653,2 @@\n-    public static long clang_Type_getSizeOf(MemorySegment T) {\n-        var mh$ = clang_Type_getSizeOf$MH();\n+    public static int clang_PrintingPolicy_getProperty(MemorySegment Policy, int Property) {\n+        var mh$ = clang_PrintingPolicy_getProperty$constants.HANDLE;\n@@ -4988,1 +8656,4 @@\n-            return (long)mh$.invokeExact(T);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_PrintingPolicy_getProperty\", Policy, Property);\n+            }\n+            return (int)mh$.invokeExact(Policy, Property);\n@@ -4990,1 +8661,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4993,2 +8664,11 @@\n-    public static MethodHandle clang_Type_getAlignOf$MH() {\n-        return RuntimeHelper.requireNonNull(constants$12.clang_Type_getAlignOf$MH,\"clang_Type_getAlignOf\");\n+\n+    private static class clang_PrintingPolicy_setProperty$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            Index_h.C_POINTER,\n+            Index_h.C_INT,\n+            Index_h.C_INT\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_PrintingPolicy_setProperty\"),\n+                    DESC);\n@@ -4996,0 +8676,1 @@\n+\n@@ -4997,2 +8678,3 @@\n-     * {@snippet :\n-     * long long clang_Type_getAlignOf(CXType T);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void clang_PrintingPolicy_setProperty(CXPrintingPolicy Policy, enum CXPrintingPolicyProperty Property, unsigned int Value)\n@@ -5001,7 +8683,2 @@\n-    public static long clang_Type_getAlignOf(MemorySegment T) {\n-        var mh$ = clang_Type_getAlignOf$MH();\n-        try {\n-            return (long)mh$.invokeExact(T);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static FunctionDescriptor clang_PrintingPolicy_setProperty$descriptor() {\n+        return clang_PrintingPolicy_setProperty$constants.DESC;\n@@ -5009,2 +8686,9 @@\n-    public static MethodHandle clang_Type_getOffsetOf$MH() {\n-        return RuntimeHelper.requireNonNull(constants$12.clang_Type_getOffsetOf$MH,\"clang_Type_getOffsetOf\");\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void clang_PrintingPolicy_setProperty(CXPrintingPolicy Policy, enum CXPrintingPolicyProperty Property, unsigned int Value)\n+     * }\n+     *\/\n+    public static MethodHandle clang_PrintingPolicy_setProperty$handle() {\n+        return clang_PrintingPolicy_setProperty$constants.HANDLE;\n@@ -5013,2 +8697,2 @@\n-     * {@snippet :\n-     * long long clang_Type_getOffsetOf(CXType T, char* S);\n+     * {@snippet lang=c :\n+     * void clang_PrintingPolicy_setProperty(CXPrintingPolicy Policy, enum CXPrintingPolicyProperty Property, unsigned int Value)\n@@ -5017,2 +8701,2 @@\n-    public static long clang_Type_getOffsetOf(MemorySegment T, MemorySegment S) {\n-        var mh$ = clang_Type_getOffsetOf$MH();\n+    public static void clang_PrintingPolicy_setProperty(MemorySegment Policy, int Property, int Value) {\n+        var mh$ = clang_PrintingPolicy_setProperty$constants.HANDLE;\n@@ -5020,1 +8704,4 @@\n-            return (long)mh$.invokeExact(T, S);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_PrintingPolicy_setProperty\", Policy, Property, Value);\n+            }\n+            mh$.invokeExact(Policy, Property, Value);\n@@ -5022,1 +8709,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5025,2 +8712,10 @@\n-    public static MethodHandle clang_Cursor_isAnonymous$MH() {\n-        return RuntimeHelper.requireNonNull(constants$12.clang_Cursor_isAnonymous$MH,\"clang_Cursor_isAnonymous\");\n+\n+    private static class clang_getCursorPrintingPolicy$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_POINTER,\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorPrintingPolicy\"),\n+                    DESC);\n@@ -5028,0 +8723,1 @@\n+\n@@ -5029,2 +8725,3 @@\n-     * {@snippet :\n-     * unsigned int clang_Cursor_isAnonymous(CXCursor C);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXPrintingPolicy clang_getCursorPrintingPolicy(CXCursor)\n@@ -5033,7 +8730,2 @@\n-    public static int clang_Cursor_isAnonymous(MemorySegment C) {\n-        var mh$ = clang_Cursor_isAnonymous$MH();\n-        try {\n-            return (int)mh$.invokeExact(C);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static FunctionDescriptor clang_getCursorPrintingPolicy$descriptor() {\n+        return clang_getCursorPrintingPolicy$constants.DESC;\n@@ -5041,2 +8733,9 @@\n-    public static MethodHandle clang_Cursor_isAnonymousRecordDecl$MH() {\n-        return RuntimeHelper.requireNonNull(constants$13.clang_Cursor_isAnonymousRecordDecl$MH,\"clang_Cursor_isAnonymousRecordDecl\");\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXPrintingPolicy clang_getCursorPrintingPolicy(CXCursor)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getCursorPrintingPolicy$handle() {\n+        return clang_getCursorPrintingPolicy$constants.HANDLE;\n@@ -5045,2 +8744,2 @@\n-     * {@snippet :\n-     * unsigned int clang_Cursor_isAnonymousRecordDecl(CXCursor C);\n+     * {@snippet lang=c :\n+     * CXPrintingPolicy clang_getCursorPrintingPolicy(CXCursor)\n@@ -5049,2 +8748,2 @@\n-    public static int clang_Cursor_isAnonymousRecordDecl(MemorySegment C) {\n-        var mh$ = clang_Cursor_isAnonymousRecordDecl$MH();\n+    public static MemorySegment clang_getCursorPrintingPolicy(MemorySegment x0) {\n+        var mh$ = clang_getCursorPrintingPolicy$constants.HANDLE;\n@@ -5052,1 +8751,4 @@\n-            return (int)mh$.invokeExact(C);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getCursorPrintingPolicy\", x0);\n+            }\n+            return (MemorySegment)mh$.invokeExact(x0);\n@@ -5054,1 +8756,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5057,2 +8759,9 @@\n-    public static MethodHandle clang_Cursor_isBitField$MH() {\n-        return RuntimeHelper.requireNonNull(constants$13.clang_Cursor_isBitField$MH,\"clang_Cursor_isBitField\");\n+\n+    private static class clang_PrintingPolicy_dispose$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_PrintingPolicy_dispose\"),\n+                    DESC);\n@@ -5060,0 +8769,1 @@\n+\n@@ -5061,2 +8771,3 @@\n-     * {@snippet :\n-     * unsigned int clang_Cursor_isBitField(CXCursor C);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void clang_PrintingPolicy_dispose(CXPrintingPolicy Policy)\n@@ -5065,7 +8776,2 @@\n-    public static int clang_Cursor_isBitField(MemorySegment C) {\n-        var mh$ = clang_Cursor_isBitField$MH();\n-        try {\n-            return (int)mh$.invokeExact(C);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static FunctionDescriptor clang_PrintingPolicy_dispose$descriptor() {\n+        return clang_PrintingPolicy_dispose$constants.DESC;\n@@ -5073,0 +8779,1 @@\n+\n@@ -5074,2 +8781,3 @@\n-     * {@snippet :\n-     * enum CXChildVisitResult.CXChildVisit_Break = 0;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void clang_PrintingPolicy_dispose(CXPrintingPolicy Policy)\n@@ -5078,2 +8786,2 @@\n-    public static int CXChildVisit_Break() {\n-        return (int)0L;\n+    public static MethodHandle clang_PrintingPolicy_dispose$handle() {\n+        return clang_PrintingPolicy_dispose$constants.HANDLE;\n@@ -5082,2 +8790,2 @@\n-     * {@snippet :\n-     * enum CXChildVisitResult.CXChildVisit_Continue = 1;\n+     * {@snippet lang=c :\n+     * void clang_PrintingPolicy_dispose(CXPrintingPolicy Policy)\n@@ -5086,2 +8794,10 @@\n-    public static int CXChildVisit_Continue() {\n-        return (int)1L;\n+    public static void clang_PrintingPolicy_dispose(MemorySegment Policy) {\n+        var mh$ = clang_PrintingPolicy_dispose$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_PrintingPolicy_dispose\", Policy);\n+            }\n+            mh$.invokeExact(Policy);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n@@ -5089,0 +8805,13 @@\n+\n+    private static class clang_getCursorPrettyPrinted$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXString.layout(),\n+            CXCursor.layout(),\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorPrettyPrinted\"),\n+                    DESC);\n+    }\n+\n@@ -5090,2 +8819,3 @@\n-     * {@snippet :\n-     * enum CXChildVisitResult.CXChildVisit_Recurse = 2;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXString clang_getCursorPrettyPrinted(CXCursor Cursor, CXPrintingPolicy Policy)\n@@ -5094,2 +8824,2 @@\n-    public static int CXChildVisit_Recurse() {\n-        return (int)2L;\n+    public static FunctionDescriptor clang_getCursorPrettyPrinted$descriptor() {\n+        return clang_getCursorPrettyPrinted$constants.DESC;\n@@ -5097,2 +8827,9 @@\n-    public static MethodHandle clang_visitChildren$MH() {\n-        return RuntimeHelper.requireNonNull(constants$13.clang_visitChildren$MH,\"clang_visitChildren\");\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXString clang_getCursorPrettyPrinted(CXCursor Cursor, CXPrintingPolicy Policy)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getCursorPrettyPrinted$handle() {\n+        return clang_getCursorPrettyPrinted$constants.HANDLE;\n@@ -5101,2 +8838,2 @@\n-     * {@snippet :\n-     * unsigned int clang_visitChildren(CXCursor parent, CXCursorVisitor visitor, CXClientData client_data);\n+     * {@snippet lang=c :\n+     * CXString clang_getCursorPrettyPrinted(CXCursor Cursor, CXPrintingPolicy Policy)\n@@ -5105,2 +8842,2 @@\n-    public static int clang_visitChildren(MemorySegment parent, MemorySegment visitor, MemorySegment client_data) {\n-        var mh$ = clang_visitChildren$MH();\n+    public static MemorySegment clang_getCursorPrettyPrinted(SegmentAllocator allocator, MemorySegment Cursor, MemorySegment Policy) {\n+        var mh$ = clang_getCursorPrettyPrinted$constants.HANDLE;\n@@ -5108,1 +8845,4 @@\n-            return (int)mh$.invokeExact(parent, visitor, client_data);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getCursorPrettyPrinted\", allocator, Cursor, Policy);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, Cursor, Policy);\n@@ -5110,1 +8850,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5113,2 +8853,10 @@\n-    public static MethodHandle clang_getCursorUSR$MH() {\n-        return RuntimeHelper.requireNonNull(constants$13.clang_getCursorUSR$MH,\"clang_getCursorUSR\");\n+\n+    private static class clang_getCursorDisplayName$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXString.layout(),\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorDisplayName\"),\n+                    DESC);\n@@ -5116,0 +8864,1 @@\n+\n@@ -5117,2 +8866,3 @@\n-     * {@snippet :\n-     * CXString clang_getCursorUSR(CXCursor);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXString clang_getCursorDisplayName(CXCursor)\n@@ -5121,7 +8871,2 @@\n-    public static MemorySegment clang_getCursorUSR(SegmentAllocator allocator, MemorySegment x1) {\n-        var mh$ = clang_getCursorUSR$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static FunctionDescriptor clang_getCursorDisplayName$descriptor() {\n+        return clang_getCursorDisplayName$constants.DESC;\n@@ -5129,2 +8874,9 @@\n-    public static MethodHandle clang_getCursorSpelling$MH() {\n-        return RuntimeHelper.requireNonNull(constants$14.clang_getCursorSpelling$MH,\"clang_getCursorSpelling\");\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXString clang_getCursorDisplayName(CXCursor)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getCursorDisplayName$handle() {\n+        return clang_getCursorDisplayName$constants.HANDLE;\n@@ -5133,2 +8885,2 @@\n-     * {@snippet :\n-     * CXString clang_getCursorSpelling(CXCursor);\n+     * {@snippet lang=c :\n+     * CXString clang_getCursorDisplayName(CXCursor)\n@@ -5137,2 +8889,2 @@\n-    public static MemorySegment clang_getCursorSpelling(SegmentAllocator allocator, MemorySegment x1) {\n-        var mh$ = clang_getCursorSpelling$MH();\n+    public static MemorySegment clang_getCursorDisplayName(SegmentAllocator allocator, MemorySegment x0) {\n+        var mh$ = clang_getCursorDisplayName$constants.HANDLE;\n@@ -5140,1 +8892,4 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getCursorDisplayName\", allocator, x0);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, x0);\n@@ -5142,1 +8897,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5145,7 +8900,10 @@\n-    \/**\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_Indentation = 0;\n-     * }\n-     *\/\n-    public static int CXPrintingPolicy_Indentation() {\n-        return (int)0L;\n+\n+    private static class clang_getCursorReferenced$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXCursor.layout(),\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorReferenced\"),\n+                    DESC);\n@@ -5153,0 +8911,1 @@\n+\n@@ -5154,2 +8913,3 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_SuppressSpecifiers = 1;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXCursor clang_getCursorReferenced(CXCursor)\n@@ -5158,2 +8918,2 @@\n-    public static int CXPrintingPolicy_SuppressSpecifiers() {\n-        return (int)1L;\n+    public static FunctionDescriptor clang_getCursorReferenced$descriptor() {\n+        return clang_getCursorReferenced$constants.DESC;\n@@ -5161,0 +8921,1 @@\n+\n@@ -5162,2 +8923,3 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_SuppressTagKeyword = 2;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXCursor clang_getCursorReferenced(CXCursor)\n@@ -5166,2 +8928,2 @@\n-    public static int CXPrintingPolicy_SuppressTagKeyword() {\n-        return (int)2L;\n+    public static MethodHandle clang_getCursorReferenced$handle() {\n+        return clang_getCursorReferenced$constants.HANDLE;\n@@ -5170,2 +8932,2 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_IncludeTagDefinition = 3;\n+     * {@snippet lang=c :\n+     * CXCursor clang_getCursorReferenced(CXCursor)\n@@ -5174,2 +8936,10 @@\n-    public static int CXPrintingPolicy_IncludeTagDefinition() {\n-        return (int)3L;\n+    public static MemorySegment clang_getCursorReferenced(SegmentAllocator allocator, MemorySegment x0) {\n+        var mh$ = clang_getCursorReferenced$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getCursorReferenced\", allocator, x0);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, x0);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n@@ -5177,0 +8947,12 @@\n+\n+    private static class clang_getCursorDefinition$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXCursor.layout(),\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorDefinition\"),\n+                    DESC);\n+    }\n+\n@@ -5178,2 +8960,3 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_SuppressScope = 4;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXCursor clang_getCursorDefinition(CXCursor)\n@@ -5182,2 +8965,2 @@\n-    public static int CXPrintingPolicy_SuppressScope() {\n-        return (int)4L;\n+    public static FunctionDescriptor clang_getCursorDefinition$descriptor() {\n+        return clang_getCursorDefinition$constants.DESC;\n@@ -5185,0 +8968,1 @@\n+\n@@ -5186,2 +8970,3 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_SuppressUnwrittenScope = 5;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXCursor clang_getCursorDefinition(CXCursor)\n@@ -5190,2 +8975,2 @@\n-    public static int CXPrintingPolicy_SuppressUnwrittenScope() {\n-        return (int)5L;\n+    public static MethodHandle clang_getCursorDefinition$handle() {\n+        return clang_getCursorDefinition$constants.HANDLE;\n@@ -5194,2 +8979,2 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_SuppressInitializers = 6;\n+     * {@snippet lang=c :\n+     * CXCursor clang_getCursorDefinition(CXCursor)\n@@ -5198,2 +8983,21 @@\n-    public static int CXPrintingPolicy_SuppressInitializers() {\n-        return (int)6L;\n+    public static MemorySegment clang_getCursorDefinition(SegmentAllocator allocator, MemorySegment x0) {\n+        var mh$ = clang_getCursorDefinition$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getCursorDefinition\", allocator, x0);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, x0);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_isCursorDefinition$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_isCursorDefinition\"),\n+                    DESC);\n@@ -5201,0 +9005,1 @@\n+\n@@ -5202,2 +9007,3 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_ConstantArraySizeAsWritten = 7;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_isCursorDefinition(CXCursor)\n@@ -5206,2 +9012,2 @@\n-    public static int CXPrintingPolicy_ConstantArraySizeAsWritten() {\n-        return (int)7L;\n+    public static FunctionDescriptor clang_isCursorDefinition$descriptor() {\n+        return clang_isCursorDefinition$constants.DESC;\n@@ -5209,0 +9015,1 @@\n+\n@@ -5210,2 +9017,3 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_AnonymousTagLocations = 8;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_isCursorDefinition(CXCursor)\n@@ -5214,2 +9022,2 @@\n-    public static int CXPrintingPolicy_AnonymousTagLocations() {\n-        return (int)8L;\n+    public static MethodHandle clang_isCursorDefinition$handle() {\n+        return clang_isCursorDefinition$constants.HANDLE;\n@@ -5218,2 +9026,2 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_SuppressStrongLifetime = 9;\n+     * {@snippet lang=c :\n+     * unsigned int clang_isCursorDefinition(CXCursor)\n@@ -5222,2 +9030,10 @@\n-    public static int CXPrintingPolicy_SuppressStrongLifetime() {\n-        return (int)9L;\n+    public static int clang_isCursorDefinition(MemorySegment x0) {\n+        var mh$ = clang_isCursorDefinition$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_isCursorDefinition\", x0);\n+            }\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n@@ -5225,0 +9041,12 @@\n+\n+    private static class clang_Cursor_isVariadic$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_isVariadic\"),\n+                    DESC);\n+    }\n+\n@@ -5226,2 +9054,3 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_SuppressLifetimeQualifiers = 10;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_Cursor_isVariadic(CXCursor C)\n@@ -5230,2 +9059,2 @@\n-    public static int CXPrintingPolicy_SuppressLifetimeQualifiers() {\n-        return (int)10L;\n+    public static FunctionDescriptor clang_Cursor_isVariadic$descriptor() {\n+        return clang_Cursor_isVariadic$constants.DESC;\n@@ -5233,0 +9062,1 @@\n+\n@@ -5234,2 +9064,3 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors = 11;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_Cursor_isVariadic(CXCursor C)\n@@ -5238,2 +9069,2 @@\n-    public static int CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors() {\n-        return (int)11L;\n+    public static MethodHandle clang_Cursor_isVariadic$handle() {\n+        return clang_Cursor_isVariadic$constants.HANDLE;\n@@ -5242,2 +9073,2 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_Bool = 12;\n+     * {@snippet lang=c :\n+     * unsigned int clang_Cursor_isVariadic(CXCursor C)\n@@ -5246,2 +9077,21 @@\n-    public static int CXPrintingPolicy_Bool() {\n-        return (int)12L;\n+    public static int clang_Cursor_isVariadic(MemorySegment C) {\n+        var mh$ = clang_Cursor_isVariadic$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_Cursor_isVariadic\", C);\n+            }\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_Cursor_getMangling$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXString.layout(),\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_getMangling\"),\n+                    DESC);\n@@ -5249,0 +9099,1 @@\n+\n@@ -5250,2 +9101,3 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_Restrict = 13;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXString clang_Cursor_getMangling(CXCursor)\n@@ -5254,2 +9106,2 @@\n-    public static int CXPrintingPolicy_Restrict() {\n-        return (int)13L;\n+    public static FunctionDescriptor clang_Cursor_getMangling$descriptor() {\n+        return clang_Cursor_getMangling$constants.DESC;\n@@ -5257,0 +9109,1 @@\n+\n@@ -5258,2 +9111,3 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_Alignof = 14;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXString clang_Cursor_getMangling(CXCursor)\n@@ -5262,2 +9116,2 @@\n-    public static int CXPrintingPolicy_Alignof() {\n-        return (int)14L;\n+    public static MethodHandle clang_Cursor_getMangling$handle() {\n+        return clang_Cursor_getMangling$constants.HANDLE;\n@@ -5266,2 +9120,2 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_UnderscoreAlignof = 15;\n+     * {@snippet lang=c :\n+     * CXString clang_Cursor_getMangling(CXCursor)\n@@ -5270,2 +9124,10 @@\n-    public static int CXPrintingPolicy_UnderscoreAlignof() {\n-        return (int)15L;\n+    public static MemorySegment clang_Cursor_getMangling(SegmentAllocator allocator, MemorySegment x0) {\n+        var mh$ = clang_Cursor_getMangling$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_Cursor_getMangling\", allocator, x0);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, x0);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n@@ -5273,0 +9135,1 @@\n+    private static final int CXToken_Punctuation = (int)0L;\n@@ -5274,2 +9137,2 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_UseVoidForZeroParams = 16;\n+     * {@snippet lang=c :\n+     * enum CXTokenKind.CXToken_Punctuation = 0\n@@ -5278,2 +9141,2 @@\n-    public static int CXPrintingPolicy_UseVoidForZeroParams() {\n-        return (int)16L;\n+    public static int CXToken_Punctuation() {\n+        return CXToken_Punctuation;\n@@ -5281,0 +9144,1 @@\n+    private static final int CXToken_Keyword = (int)1L;\n@@ -5282,2 +9146,2 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_TerseOutput = 17;\n+     * {@snippet lang=c :\n+     * enum CXTokenKind.CXToken_Keyword = 1\n@@ -5286,2 +9150,2 @@\n-    public static int CXPrintingPolicy_TerseOutput() {\n-        return (int)17L;\n+    public static int CXToken_Keyword() {\n+        return CXToken_Keyword;\n@@ -5289,0 +9153,1 @@\n+    private static final int CXToken_Identifier = (int)2L;\n@@ -5290,2 +9155,2 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_PolishForDeclaration = 18;\n+     * {@snippet lang=c :\n+     * enum CXTokenKind.CXToken_Identifier = 2\n@@ -5294,2 +9159,2 @@\n-    public static int CXPrintingPolicy_PolishForDeclaration() {\n-        return (int)18L;\n+    public static int CXToken_Identifier() {\n+        return CXToken_Identifier;\n@@ -5297,0 +9162,1 @@\n+    private static final int CXToken_Literal = (int)3L;\n@@ -5298,2 +9164,2 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_Half = 19;\n+     * {@snippet lang=c :\n+     * enum CXTokenKind.CXToken_Literal = 3\n@@ -5302,2 +9168,2 @@\n-    public static int CXPrintingPolicy_Half() {\n-        return (int)19L;\n+    public static int CXToken_Literal() {\n+        return CXToken_Literal;\n@@ -5305,0 +9171,1 @@\n+    private static final int CXToken_Comment = (int)4L;\n@@ -5306,2 +9173,2 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_MSWChar = 20;\n+     * {@snippet lang=c :\n+     * enum CXTokenKind.CXToken_Comment = 4\n@@ -5310,2 +9177,2 @@\n-    public static int CXPrintingPolicy_MSWChar() {\n-        return (int)20L;\n+    public static int CXToken_Comment() {\n+        return CXToken_Comment;\n@@ -5313,7 +9180,10 @@\n-    \/**\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_IncludeNewlines = 21;\n-     * }\n-     *\/\n-    public static int CXPrintingPolicy_IncludeNewlines() {\n-        return (int)21L;\n+\n+    private static class clang_getTokenKind$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            CXToken.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getTokenKind\"),\n+                    DESC);\n@@ -5321,0 +9191,1 @@\n+\n@@ -5322,2 +9193,3 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_MSVCFormatting = 22;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXTokenKind clang_getTokenKind(CXToken)\n@@ -5326,2 +9198,2 @@\n-    public static int CXPrintingPolicy_MSVCFormatting() {\n-        return (int)22L;\n+    public static FunctionDescriptor clang_getTokenKind$descriptor() {\n+        return clang_getTokenKind$constants.DESC;\n@@ -5329,0 +9201,1 @@\n+\n@@ -5330,2 +9203,3 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_ConstantsAsWritten = 23;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXTokenKind clang_getTokenKind(CXToken)\n@@ -5334,2 +9208,2 @@\n-    public static int CXPrintingPolicy_ConstantsAsWritten() {\n-        return (int)23L;\n+    public static MethodHandle clang_getTokenKind$handle() {\n+        return clang_getTokenKind$constants.HANDLE;\n@@ -5338,2 +9212,2 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_SuppressImplicitBase = 24;\n+     * {@snippet lang=c :\n+     * CXTokenKind clang_getTokenKind(CXToken)\n@@ -5342,2 +9216,22 @@\n-    public static int CXPrintingPolicy_SuppressImplicitBase() {\n-        return (int)24L;\n+    public static int clang_getTokenKind(MemorySegment x0) {\n+        var mh$ = clang_getTokenKind$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getTokenKind\", x0);\n+            }\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_getTokenSpelling$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXString.layout(),\n+            Index_h.C_POINTER,\n+            CXToken.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getTokenSpelling\"),\n+                    DESC);\n@@ -5345,0 +9239,1 @@\n+\n@@ -5346,2 +9241,3 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_FullyQualifiedName = 25;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXString clang_getTokenSpelling(CXTranslationUnit, CXToken)\n@@ -5350,2 +9246,2 @@\n-    public static int CXPrintingPolicy_FullyQualifiedName() {\n-        return (int)25L;\n+    public static FunctionDescriptor clang_getTokenSpelling$descriptor() {\n+        return clang_getTokenSpelling$constants.DESC;\n@@ -5353,0 +9249,1 @@\n+\n@@ -5354,2 +9251,3 @@\n-     * {@snippet :\n-     * enum CXPrintingPolicyProperty.CXPrintingPolicy_LastProperty = 25;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXString clang_getTokenSpelling(CXTranslationUnit, CXToken)\n@@ -5358,5 +9256,2 @@\n-    public static int CXPrintingPolicy_LastProperty() {\n-        return (int)25L;\n-    }\n-    public static MethodHandle clang_PrintingPolicy_getProperty$MH() {\n-        return RuntimeHelper.requireNonNull(constants$14.clang_PrintingPolicy_getProperty$MH,\"clang_PrintingPolicy_getProperty\");\n+    public static MethodHandle clang_getTokenSpelling$handle() {\n+        return clang_getTokenSpelling$constants.HANDLE;\n@@ -5365,2 +9260,2 @@\n-     * {@snippet :\n-     * unsigned int clang_PrintingPolicy_getProperty(CXPrintingPolicy Policy, enum CXPrintingPolicyProperty Property);\n+     * {@snippet lang=c :\n+     * CXString clang_getTokenSpelling(CXTranslationUnit, CXToken)\n@@ -5369,2 +9264,2 @@\n-    public static int clang_PrintingPolicy_getProperty(MemorySegment Policy, int Property) {\n-        var mh$ = clang_PrintingPolicy_getProperty$MH();\n+    public static MemorySegment clang_getTokenSpelling(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1) {\n+        var mh$ = clang_getTokenSpelling$constants.HANDLE;\n@@ -5372,1 +9267,4 @@\n-            return (int)mh$.invokeExact(Policy, Property);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getTokenSpelling\", allocator, x0, x1);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);\n@@ -5374,1 +9272,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5377,2 +9275,11 @@\n-    public static MethodHandle clang_PrintingPolicy_setProperty$MH() {\n-        return RuntimeHelper.requireNonNull(constants$14.clang_PrintingPolicy_setProperty$MH,\"clang_PrintingPolicy_setProperty\");\n+\n+    private static class clang_getTokenLocation$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXSourceLocation.layout(),\n+            Index_h.C_POINTER,\n+            CXToken.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getTokenLocation\"),\n+                    DESC);\n@@ -5380,0 +9287,1 @@\n+\n@@ -5381,2 +9289,3 @@\n-     * {@snippet :\n-     * void clang_PrintingPolicy_setProperty(CXPrintingPolicy Policy, enum CXPrintingPolicyProperty Property, unsigned int Value);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getTokenLocation(CXTranslationUnit, CXToken)\n@@ -5385,7 +9294,2 @@\n-    public static void clang_PrintingPolicy_setProperty(MemorySegment Policy, int Property, int Value) {\n-        var mh$ = clang_PrintingPolicy_setProperty$MH();\n-        try {\n-            mh$.invokeExact(Policy, Property, Value);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static FunctionDescriptor clang_getTokenLocation$descriptor() {\n+        return clang_getTokenLocation$constants.DESC;\n@@ -5393,2 +9297,9 @@\n-    public static MethodHandle clang_getCursorPrintingPolicy$MH() {\n-        return RuntimeHelper.requireNonNull(constants$14.clang_getCursorPrintingPolicy$MH,\"clang_getCursorPrintingPolicy\");\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getTokenLocation(CXTranslationUnit, CXToken)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getTokenLocation$handle() {\n+        return clang_getTokenLocation$constants.HANDLE;\n@@ -5397,2 +9308,2 @@\n-     * {@snippet :\n-     * CXPrintingPolicy clang_getCursorPrintingPolicy(CXCursor);\n+     * {@snippet lang=c :\n+     * CXSourceLocation clang_getTokenLocation(CXTranslationUnit, CXToken)\n@@ -5401,2 +9312,2 @@\n-    public static MemorySegment clang_getCursorPrintingPolicy(MemorySegment x0) {\n-        var mh$ = clang_getCursorPrintingPolicy$MH();\n+    public static MemorySegment clang_getTokenLocation(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1) {\n+        var mh$ = clang_getTokenLocation$constants.HANDLE;\n@@ -5404,1 +9315,4 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(x0);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getTokenLocation\", allocator, x0, x1);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);\n@@ -5406,1 +9320,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5409,2 +9323,11 @@\n-    public static MethodHandle clang_PrintingPolicy_dispose$MH() {\n-        return RuntimeHelper.requireNonNull(constants$14.clang_PrintingPolicy_dispose$MH,\"clang_PrintingPolicy_dispose\");\n+\n+    private static class clang_getTokenExtent$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXSourceRange.layout(),\n+            Index_h.C_POINTER,\n+            CXToken.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getTokenExtent\"),\n+                    DESC);\n@@ -5412,0 +9335,1 @@\n+\n@@ -5413,2 +9337,3 @@\n-     * {@snippet :\n-     * void clang_PrintingPolicy_dispose(CXPrintingPolicy Policy);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXSourceRange clang_getTokenExtent(CXTranslationUnit, CXToken)\n@@ -5417,7 +9342,2 @@\n-    public static void clang_PrintingPolicy_dispose(MemorySegment Policy) {\n-        var mh$ = clang_PrintingPolicy_dispose$MH();\n-        try {\n-            mh$.invokeExact(Policy);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static FunctionDescriptor clang_getTokenExtent$descriptor() {\n+        return clang_getTokenExtent$constants.DESC;\n@@ -5425,2 +9345,9 @@\n-    public static MethodHandle clang_getCursorPrettyPrinted$MH() {\n-        return RuntimeHelper.requireNonNull(constants$14.clang_getCursorPrettyPrinted$MH,\"clang_getCursorPrettyPrinted\");\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXSourceRange clang_getTokenExtent(CXTranslationUnit, CXToken)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getTokenExtent$handle() {\n+        return clang_getTokenExtent$constants.HANDLE;\n@@ -5429,2 +9356,2 @@\n-     * {@snippet :\n-     * CXString clang_getCursorPrettyPrinted(CXCursor Cursor, CXPrintingPolicy Policy);\n+     * {@snippet lang=c :\n+     * CXSourceRange clang_getTokenExtent(CXTranslationUnit, CXToken)\n@@ -5433,2 +9360,2 @@\n-    public static MemorySegment clang_getCursorPrettyPrinted(SegmentAllocator allocator, MemorySegment Cursor, MemorySegment Policy) {\n-        var mh$ = clang_getCursorPrettyPrinted$MH();\n+    public static MemorySegment clang_getTokenExtent(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1) {\n+        var mh$ = clang_getTokenExtent$constants.HANDLE;\n@@ -5436,1 +9363,4 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, Cursor, Policy);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getTokenExtent\", allocator, x0, x1);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);\n@@ -5438,1 +9368,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5441,2 +9371,12 @@\n-    public static MethodHandle clang_getCursorDisplayName$MH() {\n-        return RuntimeHelper.requireNonNull(constants$15.clang_getCursorDisplayName$MH,\"clang_getCursorDisplayName\");\n+\n+    private static class clang_tokenize$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            Index_h.C_POINTER,\n+            CXSourceRange.layout(),\n+            Index_h.C_POINTER,\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_tokenize\"),\n+                    DESC);\n@@ -5444,0 +9384,1 @@\n+\n@@ -5445,2 +9386,3 @@\n-     * {@snippet :\n-     * CXString clang_getCursorDisplayName(CXCursor);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void clang_tokenize(CXTranslationUnit TU, CXSourceRange Range, CXToken **Tokens, unsigned int *NumTokens)\n@@ -5449,7 +9391,2 @@\n-    public static MemorySegment clang_getCursorDisplayName(SegmentAllocator allocator, MemorySegment x1) {\n-        var mh$ = clang_getCursorDisplayName$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static FunctionDescriptor clang_tokenize$descriptor() {\n+        return clang_tokenize$constants.DESC;\n@@ -5457,2 +9394,9 @@\n-    public static MethodHandle clang_getCursorReferenced$MH() {\n-        return RuntimeHelper.requireNonNull(constants$15.clang_getCursorReferenced$MH,\"clang_getCursorReferenced\");\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void clang_tokenize(CXTranslationUnit TU, CXSourceRange Range, CXToken **Tokens, unsigned int *NumTokens)\n+     * }\n+     *\/\n+    public static MethodHandle clang_tokenize$handle() {\n+        return clang_tokenize$constants.HANDLE;\n@@ -5461,2 +9405,2 @@\n-     * {@snippet :\n-     * CXCursor clang_getCursorReferenced(CXCursor);\n+     * {@snippet lang=c :\n+     * void clang_tokenize(CXTranslationUnit TU, CXSourceRange Range, CXToken **Tokens, unsigned int *NumTokens)\n@@ -5465,2 +9409,2 @@\n-    public static MemorySegment clang_getCursorReferenced(SegmentAllocator allocator, MemorySegment x1) {\n-        var mh$ = clang_getCursorReferenced$MH();\n+    public static void clang_tokenize(MemorySegment TU, MemorySegment Range, MemorySegment Tokens, MemorySegment NumTokens) {\n+        var mh$ = clang_tokenize$constants.HANDLE;\n@@ -5468,1 +9412,4 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_tokenize\", TU, Range, Tokens, NumTokens);\n+            }\n+            mh$.invokeExact(TU, Range, Tokens, NumTokens);\n@@ -5470,1 +9417,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5473,2 +9420,11 @@\n-    public static MethodHandle clang_getCursorDefinition$MH() {\n-        return RuntimeHelper.requireNonNull(constants$15.clang_getCursorDefinition$MH,\"clang_getCursorDefinition\");\n+\n+    private static class clang_disposeTokens$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            Index_h.C_POINTER,\n+            Index_h.C_POINTER,\n+            Index_h.C_INT\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_disposeTokens\"),\n+                    DESC);\n@@ -5476,0 +9432,1 @@\n+\n@@ -5477,2 +9434,3 @@\n-     * {@snippet :\n-     * CXCursor clang_getCursorDefinition(CXCursor);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void clang_disposeTokens(CXTranslationUnit TU, CXToken *Tokens, unsigned int NumTokens)\n@@ -5481,7 +9439,2 @@\n-    public static MemorySegment clang_getCursorDefinition(SegmentAllocator allocator, MemorySegment x1) {\n-        var mh$ = clang_getCursorDefinition$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static FunctionDescriptor clang_disposeTokens$descriptor() {\n+        return clang_disposeTokens$constants.DESC;\n@@ -5489,2 +9442,9 @@\n-    public static MethodHandle clang_isCursorDefinition$MH() {\n-        return RuntimeHelper.requireNonNull(constants$15.clang_isCursorDefinition$MH,\"clang_isCursorDefinition\");\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void clang_disposeTokens(CXTranslationUnit TU, CXToken *Tokens, unsigned int NumTokens)\n+     * }\n+     *\/\n+    public static MethodHandle clang_disposeTokens$handle() {\n+        return clang_disposeTokens$constants.HANDLE;\n@@ -5493,2 +9453,2 @@\n-     * {@snippet :\n-     * unsigned int clang_isCursorDefinition(CXCursor);\n+     * {@snippet lang=c :\n+     * void clang_disposeTokens(CXTranslationUnit TU, CXToken *Tokens, unsigned int NumTokens)\n@@ -5497,2 +9457,2 @@\n-    public static int clang_isCursorDefinition(MemorySegment x0) {\n-        var mh$ = clang_isCursorDefinition$MH();\n+    public static void clang_disposeTokens(MemorySegment TU, MemorySegment Tokens, int NumTokens) {\n+        var mh$ = clang_disposeTokens$constants.HANDLE;\n@@ -5500,1 +9460,4 @@\n-            return (int)mh$.invokeExact(x0);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_disposeTokens\", TU, Tokens, NumTokens);\n+            }\n+            mh$.invokeExact(TU, Tokens, NumTokens);\n@@ -5502,1 +9465,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5505,2 +9468,10 @@\n-    public static MethodHandle clang_Cursor_isVariadic$MH() {\n-        return RuntimeHelper.requireNonNull(constants$15.clang_Cursor_isVariadic$MH,\"clang_Cursor_isVariadic\");\n+\n+    private static class clang_getCursorKindSpelling$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXString.layout(),\n+            Index_h.C_INT\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorKindSpelling\"),\n+                    DESC);\n@@ -5508,0 +9479,1 @@\n+\n@@ -5509,2 +9481,3 @@\n-     * {@snippet :\n-     * unsigned int clang_Cursor_isVariadic(CXCursor C);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXString clang_getCursorKindSpelling(enum CXCursorKind Kind)\n@@ -5513,7 +9486,2 @@\n-    public static int clang_Cursor_isVariadic(MemorySegment C) {\n-        var mh$ = clang_Cursor_isVariadic$MH();\n-        try {\n-            return (int)mh$.invokeExact(C);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static FunctionDescriptor clang_getCursorKindSpelling$descriptor() {\n+        return clang_getCursorKindSpelling$constants.DESC;\n@@ -5521,2 +9489,9 @@\n-    public static MethodHandle clang_Cursor_getMangling$MH() {\n-        return RuntimeHelper.requireNonNull(constants$15.clang_Cursor_getMangling$MH,\"clang_Cursor_getMangling\");\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXString clang_getCursorKindSpelling(enum CXCursorKind Kind)\n+     * }\n+     *\/\n+    public static MethodHandle clang_getCursorKindSpelling$handle() {\n+        return clang_getCursorKindSpelling$constants.HANDLE;\n@@ -5525,2 +9500,2 @@\n-     * {@snippet :\n-     * CXString clang_Cursor_getMangling(CXCursor);\n+     * {@snippet lang=c :\n+     * CXString clang_getCursorKindSpelling(enum CXCursorKind Kind)\n@@ -5529,2 +9504,2 @@\n-    public static MemorySegment clang_Cursor_getMangling(SegmentAllocator allocator, MemorySegment x1) {\n-        var mh$ = clang_Cursor_getMangling$MH();\n+    public static MemorySegment clang_getCursorKindSpelling(SegmentAllocator allocator, int Kind) {\n+        var mh$ = clang_getCursorKindSpelling$constants.HANDLE;\n@@ -5532,1 +9507,4 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getCursorKindSpelling\", allocator, Kind);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator, Kind);\n@@ -5534,1 +9512,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5537,0 +9515,10 @@\n+\n+    private static class clang_getClangVersion$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            CXString.layout()    );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getClangVersion\"),\n+                    DESC);\n+    }\n+\n@@ -5538,2 +9526,3 @@\n-     * {@snippet :\n-     * enum CXTokenKind.CXToken_Punctuation = 0;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXString clang_getClangVersion()\n@@ -5542,2 +9531,2 @@\n-    public static int CXToken_Punctuation() {\n-        return (int)0L;\n+    public static FunctionDescriptor clang_getClangVersion$descriptor() {\n+        return clang_getClangVersion$constants.DESC;\n@@ -5545,0 +9534,1 @@\n+\n@@ -5546,2 +9536,3 @@\n-     * {@snippet :\n-     * enum CXTokenKind.CXToken_Keyword = 1;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXString clang_getClangVersion()\n@@ -5550,2 +9541,2 @@\n-    public static int CXToken_Keyword() {\n-        return (int)1L;\n+    public static MethodHandle clang_getClangVersion$handle() {\n+        return clang_getClangVersion$constants.HANDLE;\n@@ -5554,2 +9545,2 @@\n-     * {@snippet :\n-     * enum CXTokenKind.CXToken_Identifier = 2;\n+     * {@snippet lang=c :\n+     * CXString clang_getClangVersion()\n@@ -5558,2 +9549,20 @@\n-    public static int CXToken_Identifier() {\n-        return (int)2L;\n+    public static MemorySegment clang_getClangVersion(SegmentAllocator allocator) {\n+        var mh$ = clang_getClangVersion$constants.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_getClangVersion\", allocator);\n+            }\n+            return (MemorySegment)mh$.invokeExact(allocator);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class clang_toggleCrashRecovery$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            Index_h.C_INT\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_toggleCrashRecovery\"),\n+                    DESC);\n@@ -5561,0 +9570,1 @@\n+\n@@ -5562,2 +9572,3 @@\n-     * {@snippet :\n-     * enum CXTokenKind.CXToken_Literal = 3;\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void clang_toggleCrashRecovery(unsigned int isEnabled)\n@@ -5566,2 +9577,2 @@\n-    public static int CXToken_Literal() {\n-        return (int)3L;\n+    public static FunctionDescriptor clang_toggleCrashRecovery$descriptor() {\n+        return clang_toggleCrashRecovery$constants.DESC;\n@@ -5569,0 +9580,1 @@\n+\n@@ -5570,2 +9582,3 @@\n-     * {@snippet :\n-     * enum CXTokenKind.CXToken_Comment = 4;\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void clang_toggleCrashRecovery(unsigned int isEnabled)\n@@ -5574,5 +9587,2 @@\n-    public static int CXToken_Comment() {\n-        return (int)4L;\n-    }\n-    public static MethodHandle clang_getTokenKind$MH() {\n-        return RuntimeHelper.requireNonNull(constants$16.clang_getTokenKind$MH,\"clang_getTokenKind\");\n+    public static MethodHandle clang_toggleCrashRecovery$handle() {\n+        return clang_toggleCrashRecovery$constants.HANDLE;\n@@ -5581,2 +9591,2 @@\n-     * {@snippet :\n-     * CXTokenKind clang_getTokenKind(CXToken);\n+     * {@snippet lang=c :\n+     * void clang_toggleCrashRecovery(unsigned int isEnabled)\n@@ -5585,2 +9595,2 @@\n-    public static int clang_getTokenKind(MemorySegment x0) {\n-        var mh$ = clang_getTokenKind$MH();\n+    public static void clang_toggleCrashRecovery(int isEnabled) {\n+        var mh$ = clang_toggleCrashRecovery$constants.HANDLE;\n@@ -5588,1 +9598,4 @@\n-            return (int)mh$.invokeExact(x0);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_toggleCrashRecovery\", isEnabled);\n+            }\n+            mh$.invokeExact(isEnabled);\n@@ -5590,1 +9603,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5593,2 +9606,10 @@\n-    public static MethodHandle clang_getTokenSpelling$MH() {\n-        return RuntimeHelper.requireNonNull(constants$16.clang_getTokenSpelling$MH,\"clang_getTokenSpelling\");\n+\n+    private static class clang_Cursor_Evaluate$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_POINTER,\n+            CXCursor.layout()\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_Evaluate\"),\n+                    DESC);\n@@ -5596,0 +9617,1 @@\n+\n@@ -5597,2 +9619,3 @@\n-     * {@snippet :\n-     * CXString clang_getTokenSpelling(CXTranslationUnit, CXToken);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXEvalResult clang_Cursor_Evaluate(CXCursor C)\n@@ -5601,7 +9624,2 @@\n-    public static MemorySegment clang_getTokenSpelling(SegmentAllocator allocator, MemorySegment x1, MemorySegment x2) {\n-        var mh$ = clang_getTokenSpelling$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1, x2);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static FunctionDescriptor clang_Cursor_Evaluate$descriptor() {\n+        return clang_Cursor_Evaluate$constants.DESC;\n@@ -5609,2 +9627,9 @@\n-    public static MethodHandle clang_getTokenLocation$MH() {\n-        return RuntimeHelper.requireNonNull(constants$16.clang_getTokenLocation$MH,\"clang_getTokenLocation\");\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXEvalResult clang_Cursor_Evaluate(CXCursor C)\n+     * }\n+     *\/\n+    public static MethodHandle clang_Cursor_Evaluate$handle() {\n+        return clang_Cursor_Evaluate$constants.HANDLE;\n@@ -5613,2 +9638,2 @@\n-     * {@snippet :\n-     * CXSourceLocation clang_getTokenLocation(CXTranslationUnit, CXToken);\n+     * {@snippet lang=c :\n+     * CXEvalResult clang_Cursor_Evaluate(CXCursor C)\n@@ -5617,2 +9642,2 @@\n-    public static MemorySegment clang_getTokenLocation(SegmentAllocator allocator, MemorySegment x1, MemorySegment x2) {\n-        var mh$ = clang_getTokenLocation$MH();\n+    public static MemorySegment clang_Cursor_Evaluate(MemorySegment C) {\n+        var mh$ = clang_Cursor_Evaluate$constants.HANDLE;\n@@ -5620,1 +9645,4 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1, x2);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_Cursor_Evaluate\", C);\n+            }\n+            return (MemorySegment)mh$.invokeExact(C);\n@@ -5622,1 +9650,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5625,2 +9653,10 @@\n-    public static MethodHandle clang_getTokenExtent$MH() {\n-        return RuntimeHelper.requireNonNull(constants$16.clang_getTokenExtent$MH,\"clang_getTokenExtent\");\n+\n+    private static class clang_EvalResult_getKind$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_EvalResult_getKind\"),\n+                    DESC);\n@@ -5628,0 +9664,1 @@\n+\n@@ -5629,2 +9666,3 @@\n-     * {@snippet :\n-     * CXSourceRange clang_getTokenExtent(CXTranslationUnit, CXToken);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * CXEvalResultKind clang_EvalResult_getKind(CXEvalResult E)\n@@ -5633,7 +9671,2 @@\n-    public static MemorySegment clang_getTokenExtent(SegmentAllocator allocator, MemorySegment x1, MemorySegment x2) {\n-        var mh$ = clang_getTokenExtent$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1, x2);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static FunctionDescriptor clang_EvalResult_getKind$descriptor() {\n+        return clang_EvalResult_getKind$constants.DESC;\n@@ -5641,2 +9674,9 @@\n-    public static MethodHandle clang_tokenize$MH() {\n-        return RuntimeHelper.requireNonNull(constants$16.clang_tokenize$MH,\"clang_tokenize\");\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * CXEvalResultKind clang_EvalResult_getKind(CXEvalResult E)\n+     * }\n+     *\/\n+    public static MethodHandle clang_EvalResult_getKind$handle() {\n+        return clang_EvalResult_getKind$constants.HANDLE;\n@@ -5645,2 +9685,2 @@\n-     * {@snippet :\n-     * void clang_tokenize(CXTranslationUnit TU, CXSourceRange Range, CXToken** Tokens, unsigned int* NumTokens);\n+     * {@snippet lang=c :\n+     * CXEvalResultKind clang_EvalResult_getKind(CXEvalResult E)\n@@ -5649,2 +9689,2 @@\n-    public static void clang_tokenize(MemorySegment TU, MemorySegment Range, MemorySegment Tokens, MemorySegment NumTokens) {\n-        var mh$ = clang_tokenize$MH();\n+    public static int clang_EvalResult_getKind(MemorySegment E) {\n+        var mh$ = clang_EvalResult_getKind$constants.HANDLE;\n@@ -5652,1 +9692,4 @@\n-            mh$.invokeExact(TU, Range, Tokens, NumTokens);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_EvalResult_getKind\", E);\n+            }\n+            return (int)mh$.invokeExact(E);\n@@ -5654,1 +9697,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5657,2 +9700,10 @@\n-    public static MethodHandle clang_disposeTokens$MH() {\n-        return RuntimeHelper.requireNonNull(constants$16.clang_disposeTokens$MH,\"clang_disposeTokens\");\n+\n+    private static class clang_EvalResult_getAsInt$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_EvalResult_getAsInt\"),\n+                    DESC);\n@@ -5660,0 +9711,1 @@\n+\n@@ -5661,2 +9713,3 @@\n-     * {@snippet :\n-     * void clang_disposeTokens(CXTranslationUnit TU, CXToken* Tokens, unsigned int NumTokens);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * int clang_EvalResult_getAsInt(CXEvalResult E)\n@@ -5665,7 +9718,2 @@\n-    public static void clang_disposeTokens(MemorySegment TU, MemorySegment Tokens, int NumTokens) {\n-        var mh$ = clang_disposeTokens$MH();\n-        try {\n-            mh$.invokeExact(TU, Tokens, NumTokens);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static FunctionDescriptor clang_EvalResult_getAsInt$descriptor() {\n+        return clang_EvalResult_getAsInt$constants.DESC;\n@@ -5673,2 +9721,9 @@\n-    public static MethodHandle clang_getCursorKindSpelling$MH() {\n-        return RuntimeHelper.requireNonNull(constants$17.clang_getCursorKindSpelling$MH,\"clang_getCursorKindSpelling\");\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * int clang_EvalResult_getAsInt(CXEvalResult E)\n+     * }\n+     *\/\n+    public static MethodHandle clang_EvalResult_getAsInt$handle() {\n+        return clang_EvalResult_getAsInt$constants.HANDLE;\n@@ -5677,2 +9732,2 @@\n-     * {@snippet :\n-     * CXString clang_getCursorKindSpelling(enum CXCursorKind Kind);\n+     * {@snippet lang=c :\n+     * int clang_EvalResult_getAsInt(CXEvalResult E)\n@@ -5681,2 +9736,2 @@\n-    public static MemorySegment clang_getCursorKindSpelling(SegmentAllocator allocator, int Kind) {\n-        var mh$ = clang_getCursorKindSpelling$MH();\n+    public static int clang_EvalResult_getAsInt(MemorySegment E) {\n+        var mh$ = clang_EvalResult_getAsInt$constants.HANDLE;\n@@ -5684,1 +9739,4 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, Kind);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_EvalResult_getAsInt\", E);\n+            }\n+            return (int)mh$.invokeExact(E);\n@@ -5686,1 +9744,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5689,2 +9747,10 @@\n-    public static MethodHandle clang_getClangVersion$MH() {\n-        return RuntimeHelper.requireNonNull(constants$17.clang_getClangVersion$MH,\"clang_getClangVersion\");\n+\n+    private static class clang_EvalResult_getAsLongLong$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_LONG_LONG,\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_EvalResult_getAsLongLong\"),\n+                    DESC);\n@@ -5692,0 +9758,1 @@\n+\n@@ -5693,2 +9760,3 @@\n-     * {@snippet :\n-     * CXString clang_getClangVersion();\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * long long clang_EvalResult_getAsLongLong(CXEvalResult E)\n@@ -5697,7 +9765,2 @@\n-    public static MemorySegment clang_getClangVersion(SegmentAllocator allocator) {\n-        var mh$ = clang_getClangVersion$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static FunctionDescriptor clang_EvalResult_getAsLongLong$descriptor() {\n+        return clang_EvalResult_getAsLongLong$constants.DESC;\n@@ -5705,2 +9768,9 @@\n-    public static MethodHandle clang_toggleCrashRecovery$MH() {\n-        return RuntimeHelper.requireNonNull(constants$17.clang_toggleCrashRecovery$MH,\"clang_toggleCrashRecovery\");\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * long long clang_EvalResult_getAsLongLong(CXEvalResult E)\n+     * }\n+     *\/\n+    public static MethodHandle clang_EvalResult_getAsLongLong$handle() {\n+        return clang_EvalResult_getAsLongLong$constants.HANDLE;\n@@ -5709,2 +9779,2 @@\n-     * {@snippet :\n-     * void clang_toggleCrashRecovery(unsigned int isEnabled);\n+     * {@snippet lang=c :\n+     * long long clang_EvalResult_getAsLongLong(CXEvalResult E)\n@@ -5713,2 +9783,2 @@\n-    public static void clang_toggleCrashRecovery(int isEnabled) {\n-        var mh$ = clang_toggleCrashRecovery$MH();\n+    public static long clang_EvalResult_getAsLongLong(MemorySegment E) {\n+        var mh$ = clang_EvalResult_getAsLongLong$constants.HANDLE;\n@@ -5716,1 +9786,4 @@\n-            mh$.invokeExact(isEnabled);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_EvalResult_getAsLongLong\", E);\n+            }\n+            return (long)mh$.invokeExact(E);\n@@ -5718,1 +9791,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5721,2 +9794,10 @@\n-    public static MethodHandle clang_Cursor_Evaluate$MH() {\n-        return RuntimeHelper.requireNonNull(constants$17.clang_Cursor_Evaluate$MH,\"clang_Cursor_Evaluate\");\n+\n+    private static class clang_EvalResult_isUnsignedInt$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_INT,\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_EvalResult_isUnsignedInt\"),\n+                    DESC);\n@@ -5724,0 +9805,1 @@\n+\n@@ -5725,2 +9807,3 @@\n-     * {@snippet :\n-     * CXEvalResult clang_Cursor_Evaluate(CXCursor C);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_EvalResult_isUnsignedInt(CXEvalResult E)\n@@ -5729,7 +9812,2 @@\n-    public static MemorySegment clang_Cursor_Evaluate(MemorySegment C) {\n-        var mh$ = clang_Cursor_Evaluate$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(C);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static FunctionDescriptor clang_EvalResult_isUnsignedInt$descriptor() {\n+        return clang_EvalResult_isUnsignedInt$constants.DESC;\n@@ -5737,2 +9815,9 @@\n-    public static MethodHandle clang_EvalResult_getKind$MH() {\n-        return RuntimeHelper.requireNonNull(constants$17.clang_EvalResult_getKind$MH,\"clang_EvalResult_getKind\");\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned int clang_EvalResult_isUnsignedInt(CXEvalResult E)\n+     * }\n+     *\/\n+    public static MethodHandle clang_EvalResult_isUnsignedInt$handle() {\n+        return clang_EvalResult_isUnsignedInt$constants.HANDLE;\n@@ -5741,2 +9826,2 @@\n-     * {@snippet :\n-     * CXEvalResultKind clang_EvalResult_getKind(CXEvalResult E);\n+     * {@snippet lang=c :\n+     * unsigned int clang_EvalResult_isUnsignedInt(CXEvalResult E)\n@@ -5745,2 +9830,2 @@\n-    public static int clang_EvalResult_getKind(MemorySegment E) {\n-        var mh$ = clang_EvalResult_getKind$MH();\n+    public static int clang_EvalResult_isUnsignedInt(MemorySegment E) {\n+        var mh$ = clang_EvalResult_isUnsignedInt$constants.HANDLE;\n@@ -5748,0 +9833,3 @@\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_EvalResult_isUnsignedInt\", E);\n+            }\n@@ -5750,1 +9838,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5753,2 +9841,10 @@\n-    public static MethodHandle clang_EvalResult_getAsInt$MH() {\n-        return RuntimeHelper.requireNonNull(constants$17.clang_EvalResult_getAsInt$MH,\"clang_EvalResult_getAsInt\");\n+\n+    private static class clang_EvalResult_getAsUnsigned$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_LONG_LONG,\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_EvalResult_getAsUnsigned\"),\n+                    DESC);\n@@ -5756,0 +9852,1 @@\n+\n@@ -5757,2 +9854,3 @@\n-     * {@snippet :\n-     * int clang_EvalResult_getAsInt(CXEvalResult E);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * unsigned long long clang_EvalResult_getAsUnsigned(CXEvalResult E)\n@@ -5761,7 +9859,2 @@\n-    public static int clang_EvalResult_getAsInt(MemorySegment E) {\n-        var mh$ = clang_EvalResult_getAsInt$MH();\n-        try {\n-            return (int)mh$.invokeExact(E);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n+    public static FunctionDescriptor clang_EvalResult_getAsUnsigned$descriptor() {\n+        return clang_EvalResult_getAsUnsigned$constants.DESC;\n@@ -5769,2 +9862,9 @@\n-    public static MethodHandle clang_EvalResult_getAsLongLong$MH() {\n-        return RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_getAsLongLong$MH,\"clang_EvalResult_getAsLongLong\");\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * unsigned long long clang_EvalResult_getAsUnsigned(CXEvalResult E)\n+     * }\n+     *\/\n+    public static MethodHandle clang_EvalResult_getAsUnsigned$handle() {\n+        return clang_EvalResult_getAsUnsigned$constants.HANDLE;\n@@ -5773,2 +9873,2 @@\n-     * {@snippet :\n-     * long long clang_EvalResult_getAsLongLong(CXEvalResult E);\n+     * {@snippet lang=c :\n+     * unsigned long long clang_EvalResult_getAsUnsigned(CXEvalResult E)\n@@ -5777,2 +9877,2 @@\n-    public static long clang_EvalResult_getAsLongLong(MemorySegment E) {\n-        var mh$ = clang_EvalResult_getAsLongLong$MH();\n+    public static long clang_EvalResult_getAsUnsigned(MemorySegment E) {\n+        var mh$ = clang_EvalResult_getAsUnsigned$constants.HANDLE;\n@@ -5780,0 +9880,3 @@\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_EvalResult_getAsUnsigned\", E);\n+            }\n@@ -5782,1 +9885,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5785,2 +9888,10 @@\n-    public static MethodHandle clang_EvalResult_isUnsignedInt$MH() {\n-        return RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_isUnsignedInt$MH,\"clang_EvalResult_isUnsignedInt\");\n+\n+    private static class clang_EvalResult_getAsDouble$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_DOUBLE,\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_EvalResult_getAsDouble\"),\n+                    DESC);\n@@ -5788,0 +9899,1 @@\n+\n@@ -5789,2 +9901,3 @@\n-     * {@snippet :\n-     * unsigned int clang_EvalResult_isUnsignedInt(CXEvalResult E);\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * double clang_EvalResult_getAsDouble(CXEvalResult E)\n@@ -5793,10 +9906,2 @@\n-    public static int clang_EvalResult_isUnsignedInt(MemorySegment E) {\n-        var mh$ = clang_EvalResult_isUnsignedInt$MH();\n-        try {\n-            return (int)mh$.invokeExact(E);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_EvalResult_getAsUnsigned$MH() {\n-        return RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_getAsUnsigned$MH,\"clang_EvalResult_getAsUnsigned\");\n+    public static FunctionDescriptor clang_EvalResult_getAsDouble$descriptor() {\n+        return clang_EvalResult_getAsDouble$constants.DESC;\n@@ -5804,0 +9909,1 @@\n+\n@@ -5805,2 +9911,3 @@\n-     * {@snippet :\n-     * unsigned long long clang_EvalResult_getAsUnsigned(CXEvalResult E);\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * double clang_EvalResult_getAsDouble(CXEvalResult E)\n@@ -5809,10 +9916,2 @@\n-    public static long clang_EvalResult_getAsUnsigned(MemorySegment E) {\n-        var mh$ = clang_EvalResult_getAsUnsigned$MH();\n-        try {\n-            return (long)mh$.invokeExact(E);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    public static MethodHandle clang_EvalResult_getAsDouble$MH() {\n-        return RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_getAsDouble$MH,\"clang_EvalResult_getAsDouble\");\n+    public static MethodHandle clang_EvalResult_getAsDouble$handle() {\n+        return clang_EvalResult_getAsDouble$constants.HANDLE;\n@@ -5821,2 +9920,2 @@\n-     * {@snippet :\n-     * double clang_EvalResult_getAsDouble(CXEvalResult E);\n+     * {@snippet lang=c :\n+     * double clang_EvalResult_getAsDouble(CXEvalResult E)\n@@ -5826,1 +9925,1 @@\n-        var mh$ = clang_EvalResult_getAsDouble$MH();\n+        var mh$ = clang_EvalResult_getAsDouble$constants.HANDLE;\n@@ -5828,0 +9927,3 @@\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_EvalResult_getAsDouble\", E);\n+            }\n@@ -5830,1 +9932,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5833,2 +9935,30 @@\n-    public static MethodHandle clang_EvalResult_getAsStr$MH() {\n-        return RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_getAsStr$MH,\"clang_EvalResult_getAsStr\");\n+\n+    private static class clang_EvalResult_getAsStr$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            Index_h.C_POINTER,\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_EvalResult_getAsStr\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * const char *clang_EvalResult_getAsStr(CXEvalResult E)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_EvalResult_getAsStr$descriptor() {\n+        return clang_EvalResult_getAsStr$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * const char *clang_EvalResult_getAsStr(CXEvalResult E)\n+     * }\n+     *\/\n+    public static MethodHandle clang_EvalResult_getAsStr$handle() {\n+        return clang_EvalResult_getAsStr$constants.HANDLE;\n@@ -5837,2 +9967,2 @@\n-     * {@snippet :\n-     * char* clang_EvalResult_getAsStr(CXEvalResult E);\n+     * {@snippet lang=c :\n+     * const char *clang_EvalResult_getAsStr(CXEvalResult E)\n@@ -5842,1 +9972,1 @@\n-        var mh$ = clang_EvalResult_getAsStr$MH();\n+        var mh$ = clang_EvalResult_getAsStr$constants.HANDLE;\n@@ -5844,1 +9974,4 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(E);\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_EvalResult_getAsStr\", E);\n+            }\n+            return (MemorySegment)mh$.invokeExact(E);\n@@ -5846,1 +9979,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5849,2 +9982,29 @@\n-    public static MethodHandle clang_EvalResult_dispose$MH() {\n-        return RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_dispose$MH,\"clang_EvalResult_dispose\");\n+\n+    private static class clang_EvalResult_dispose$constants {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            Index_h.C_POINTER\n+        );\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_EvalResult_dispose\"),\n+                    DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void clang_EvalResult_dispose(CXEvalResult E)\n+     * }\n+     *\/\n+    public static FunctionDescriptor clang_EvalResult_dispose$descriptor() {\n+        return clang_EvalResult_dispose$constants.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void clang_EvalResult_dispose(CXEvalResult E)\n+     * }\n+     *\/\n+    public static MethodHandle clang_EvalResult_dispose$handle() {\n+        return clang_EvalResult_dispose$constants.HANDLE;\n@@ -5853,2 +10013,2 @@\n-     * {@snippet :\n-     * void clang_EvalResult_dispose(CXEvalResult E);\n+     * {@snippet lang=c :\n+     * void clang_EvalResult_dispose(CXEvalResult E)\n@@ -5858,1 +10018,1 @@\n-        var mh$ = clang_EvalResult_dispose$MH();\n+        var mh$ = clang_EvalResult_dispose$constants.HANDLE;\n@@ -5860,0 +10020,3 @@\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"clang_EvalResult_dispose\", E);\n+            }\n@@ -5862,1 +10025,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5865,0 +10028,1 @@\n+    private static final int CXResult_Success = (int)0L;\n@@ -5866,2 +10030,2 @@\n-     * {@snippet :\n-     * enum .CXResult_Success = 0;\n+     * {@snippet lang=c :\n+     * enum <anonymous>.CXResult_Success = 0\n@@ -5871,1 +10035,1 @@\n-        return (int)0L;\n+        return CXResult_Success;\n@@ -5873,0 +10037,1 @@\n+    private static final int CXResult_Invalid = (int)1L;\n@@ -5874,2 +10039,2 @@\n-     * {@snippet :\n-     * enum .CXResult_Invalid = 1;\n+     * {@snippet lang=c :\n+     * enum <anonymous>.CXResult_Invalid = 1\n@@ -5879,1 +10044,1 @@\n-        return (int)1L;\n+        return CXResult_Invalid;\n@@ -5881,0 +10046,1 @@\n+    private static final int CXResult_VisitBreak = (int)2L;\n@@ -5882,2 +10048,2 @@\n-     * {@snippet :\n-     * enum .CXResult_VisitBreak = 2;\n+     * {@snippet lang=c :\n+     * enum <anonymous>.CXResult_VisitBreak = 2\n@@ -5887,1 +10053,1 @@\n-        return (int)2L;\n+        return CXResult_VisitBreak;\n@@ -5891,1 +10057,0 @@\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/Index_h.java","additions":7363,"deletions":3198,"binary":false,"changes":10561,"status":"modified"},{"patch":"@@ -1,262 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-package org.openjdk.jextract.clang.libclang;\n-\/\/ Generated by jextract\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.SymbolLookup;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.io.File;\n-import java.nio.file.Path;\n-import java.nio.charset.StandardCharsets;\n-import java.util.Arrays;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-import static java.lang.foreign.Linker.*;\n-import static java.lang.foreign.ValueLayout.*;\n-\n-final class RuntimeHelper {\n-\n-    private static final Linker LINKER = Linker.nativeLinker();\n-    private static final ClassLoader LOADER = RuntimeHelper.class.getClassLoader();\n-    private static final MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();\n-    private static final SymbolLookup SYMBOL_LOOKUP;\n-    private static final SegmentAllocator THROWING_ALLOCATOR = (x, y) -> { throw new AssertionError(\"should not reach here\"); };\n-\n-    final static SegmentAllocator CONSTANT_ALLOCATOR =\n-            (size, align) -> Arena.ofAuto().allocate(size, align);\n-\n-    static {\n-        \/\/ Manual change to handle platform specific library name difference\n-        String libName = System.getProperty(\"os.name\").startsWith(\"Windows\")? \"libclang\" : \"clang\";\n-        System.loadLibrary(libName);\n-\n-        SymbolLookup loaderLookup = SymbolLookup.loaderLookup();\n-        SYMBOL_LOOKUP = name -> loaderLookup.find(name).or(() -> LINKER.defaultLookup().find(name));\n-    }\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private RuntimeHelper() {}\n-\n-    static <T> T requireNonNull(T obj, String symbolName) {\n-        if (obj == null) {\n-            throw new UnsatisfiedLinkError(\"unresolved symbol: \" + symbolName);\n-        }\n-        return obj;\n-    }\n-\n-    static MemorySegment lookupGlobalVariable(String name, MemoryLayout layout) {\n-        return SYMBOL_LOOKUP.find(name)\n-                .map(s -> s.reinterpret(layout.byteSize()))\n-                .orElse(null);\n-    }\n-\n-    static MethodHandle downcallHandle(String name, FunctionDescriptor fdesc) {\n-        return SYMBOL_LOOKUP.find(name).\n-                map(addr -> LINKER.downcallHandle(addr, fdesc)).\n-                orElse(null);\n-    }\n-\n-    static MethodHandle downcallHandle(FunctionDescriptor fdesc) {\n-        return LINKER.downcallHandle(fdesc);\n-    }\n-\n-    static MethodHandle downcallHandleVariadic(String name, FunctionDescriptor fdesc) {\n-        return SYMBOL_LOOKUP.find(name).\n-                map(addr -> VarargsInvoker.make(addr, fdesc)).\n-                orElse(null);\n-    }\n-\n-    static <Z> MemorySegment upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, Arena scope) {\n-        try {\n-            MethodHandle handle = MH_LOOKUP.findVirtual(fi, \"apply\", fdesc.toMethodType());\n-            handle = handle.bindTo(z);\n-            return LINKER.upcallStub(handle, fdesc, scope);\n-        } catch (Throwable ex) {\n-            throw new AssertionError(ex);\n-        }\n-    }\n-\n-    static MemorySegment asArray(MemorySegment addr, MemoryLayout layout, int numElements, Arena arena) {\n-         return addr.reinterpret(numElements * layout.byteSize(), arena, null);\n-    }\n-\n-    \/\/ Internals only below this point\n-\n-    private static final class VarargsInvoker {\n-        private static final MethodHandle INVOKE_MH;\n-        private final MemorySegment symbol;\n-        private final FunctionDescriptor function;\n-\n-        private VarargsInvoker(MemorySegment symbol, FunctionDescriptor function) {\n-            this.symbol = symbol;\n-            this.function = function;\n-        }\n-\n-        static {\n-            try {\n-                INVOKE_MH = MethodHandles.lookup().findVirtual(VarargsInvoker.class, \"invoke\", MethodType.methodType(Object.class, SegmentAllocator.class, Object[].class));\n-            } catch (ReflectiveOperationException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        static MethodHandle make(MemorySegment symbol, FunctionDescriptor function) {\n-            VarargsInvoker invoker = new VarargsInvoker(symbol, function);\n-            MethodHandle handle = INVOKE_MH.bindTo(invoker).asCollector(Object[].class, function.argumentLayouts().size() + 1);\n-            MethodType mtype = MethodType.methodType(function.returnLayout().isPresent() ? carrier(function.returnLayout().get(), true) : void.class);\n-            for (MemoryLayout layout : function.argumentLayouts()) {\n-                mtype = mtype.appendParameterTypes(carrier(layout, false));\n-            }\n-            mtype = mtype.appendParameterTypes(Object[].class);\n-            boolean needsAllocator = function.returnLayout().isPresent() &&\n-                                function.returnLayout().get() instanceof GroupLayout;\n-            if (needsAllocator) {\n-                mtype = mtype.insertParameterTypes(0, SegmentAllocator.class);\n-            } else {\n-                handle = MethodHandles.insertArguments(handle, 0, THROWING_ALLOCATOR);\n-            }\n-            return handle.asType(mtype);\n-        }\n-\n-        static Class<?> carrier(MemoryLayout layout, boolean ret) {\n-            if (layout instanceof ValueLayout valueLayout) {\n-                return valueLayout.carrier();\n-            } else if (layout instanceof GroupLayout) {\n-                return MemorySegment.class;\n-            } else {\n-                throw new AssertionError(\"Cannot get here!\");\n-            }\n-        }\n-\n-        private Object invoke(SegmentAllocator allocator, Object[] args) throws Throwable {\n-            \/\/ one trailing Object[]\n-            int nNamedArgs = function.argumentLayouts().size();\n-            assert(args.length == nNamedArgs + 1);\n-            \/\/ The last argument is the array of vararg collector\n-            Object[] unnamedArgs = (Object[]) args[args.length - 1];\n-\n-            int argsCount = nNamedArgs + unnamedArgs.length;\n-            Class<?>[] argTypes = new Class<?>[argsCount];\n-            MemoryLayout[] argLayouts = new MemoryLayout[nNamedArgs + unnamedArgs.length];\n-\n-            int pos = 0;\n-            for (pos = 0; pos < nNamedArgs; pos++) {\n-                argLayouts[pos] = function.argumentLayouts().get(pos);\n-            }\n-\n-            assert pos == nNamedArgs;\n-            for (Object o: unnamedArgs) {\n-                argLayouts[pos] = variadicLayout(normalize(o.getClass()));\n-                pos++;\n-            }\n-            assert pos == argsCount;\n-\n-            FunctionDescriptor f = (function.returnLayout().isEmpty()) ?\n-                    FunctionDescriptor.ofVoid(argLayouts) :\n-                    FunctionDescriptor.of(function.returnLayout().get(), argLayouts);\n-            MethodHandle mh = LINKER.downcallHandle(symbol, f);\n-            boolean needsAllocator = function.returnLayout().isPresent() &&\n-                                            function.returnLayout().get() instanceof GroupLayout;\n-            if (needsAllocator) {\n-                mh = mh.bindTo(allocator);\n-            }\n-            \/\/ flatten argument list so that it can be passed to an asSpreader MH\n-            Object[] allArgs = new Object[nNamedArgs + unnamedArgs.length];\n-            System.arraycopy(args, 0, allArgs, 0, nNamedArgs);\n-            System.arraycopy(unnamedArgs, 0, allArgs, nNamedArgs, unnamedArgs.length);\n-\n-            return mh.asSpreader(Object[].class, argsCount).invoke(allArgs);\n-        }\n-\n-        private static Class<?> unboxIfNeeded(Class<?> clazz) {\n-            if (clazz == Boolean.class) {\n-                return boolean.class;\n-            } else if (clazz == Void.class) {\n-                return void.class;\n-            } else if (clazz == Byte.class) {\n-                return byte.class;\n-            } else if (clazz == Character.class) {\n-                return char.class;\n-            } else if (clazz == Short.class) {\n-                return short.class;\n-            } else if (clazz == Integer.class) {\n-                return int.class;\n-            } else if (clazz == Long.class) {\n-                return long.class;\n-            } else if (clazz == Float.class) {\n-                return float.class;\n-            } else if (clazz == Double.class) {\n-                return double.class;\n-            } else {\n-                return clazz;\n-            }\n-        }\n-\n-        private Class<?> promote(Class<?> c) {\n-            if (c == byte.class || c == char.class || c == short.class || c == int.class) {\n-                return long.class;\n-            } else if (c == float.class) {\n-                return double.class;\n-            } else {\n-                return c;\n-            }\n-        }\n-\n-        private Class<?> normalize(Class<?> c) {\n-            c = unboxIfNeeded(c);\n-            if (c.isPrimitive()) {\n-                return promote(c);\n-            }\n-            if (c == MemorySegment.class) {\n-                return MemorySegment.class;\n-            }\n-            throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n-        }\n-\n-        private MemoryLayout variadicLayout(Class<?> c) {\n-            if (c == long.class) {\n-                return JAVA_LONG;\n-            } else if (c == double.class) {\n-                return JAVA_DOUBLE;\n-            } else if (c == MemorySegment.class) {\n-                return ADDRESS;\n-            } else {\n-                throw new IllegalArgumentException(\"Unhandled variadic argument class: \" + c);\n-            }\n-        }\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/RuntimeHelper.java","additions":0,"deletions":262,"binary":false,"changes":262,"status":"deleted"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$0 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$0() {}\n-    static final FunctionDescriptor clang_getCString$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-            MemoryLayout.paddingLayout(4)\n-        )\n-    );\n-    static final MethodHandle clang_getCString$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCString\",\n-        constants$0.clang_getCString$FUNC\n-    );\n-    static final FunctionDescriptor clang_disposeString$FUNC = FunctionDescriptor.ofVoid(\n-        MemoryLayout.structLayout(\n-            Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-            MemoryLayout.paddingLayout(4)\n-        )\n-    );\n-    static final MethodHandle clang_disposeString$MH = RuntimeHelper.downcallHandle(\n-        \"clang_disposeString\",\n-        constants$0.clang_disposeString$FUNC\n-    );\n-    static final FunctionDescriptor clang_createIndex$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_createIndex$MH = RuntimeHelper.downcallHandle(\n-        \"clang_createIndex\",\n-        constants$0.clang_createIndex$FUNC\n-    );\n-    static final FunctionDescriptor clang_disposeIndex$FUNC = FunctionDescriptor.ofVoid(\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_disposeIndex$MH = RuntimeHelper.downcallHandle(\n-        \"clang_disposeIndex\",\n-        constants$0.clang_disposeIndex$FUNC\n-    );\n-    static final FunctionDescriptor clang_getFileName$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_getFileName$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getFileName\",\n-        constants$0.clang_getFileName$FUNC\n-    );\n-    static final FunctionDescriptor clang_getNullLocation$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-        MemoryLayout.paddingLayout(4)\n-    ));\n-    static final MethodHandle clang_getNullLocation$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getNullLocation\",\n-        constants$0.clang_getNullLocation$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$0.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$1 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$1() {}\n-    static final FunctionDescriptor clang_equalLocations$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-            MemoryLayout.paddingLayout(4)\n-        ),\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-            MemoryLayout.paddingLayout(4)\n-        )\n-    );\n-    static final MethodHandle clang_equalLocations$MH = RuntimeHelper.downcallHandle(\n-        \"clang_equalLocations\",\n-        constants$1.clang_equalLocations$FUNC\n-    );\n-    static final FunctionDescriptor clang_getLocation$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_getLocation$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getLocation\",\n-        constants$1.clang_getLocation$FUNC\n-    );\n-    static final FunctionDescriptor clang_getLocationForOffset$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_getLocationForOffset$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getLocationForOffset\",\n-        constants$1.clang_getLocationForOffset$FUNC\n-    );\n-    static final FunctionDescriptor clang_Location_isInSystemHeader$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-            MemoryLayout.paddingLayout(4)\n-        )\n-    );\n-    static final MethodHandle clang_Location_isInSystemHeader$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Location_isInSystemHeader\",\n-        constants$1.clang_Location_isInSystemHeader$FUNC\n-    );\n-    static final FunctionDescriptor clang_Location_isFromMainFile$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-            MemoryLayout.paddingLayout(4)\n-        )\n-    );\n-    static final MethodHandle clang_Location_isFromMainFile$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Location_isFromMainFile\",\n-        constants$1.clang_Location_isFromMainFile$FUNC\n-    );\n-    static final FunctionDescriptor clang_Range_isNull$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"begin_int_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"end_int_data\")\n-        )\n-    );\n-    static final MethodHandle clang_Range_isNull$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Range_isNull\",\n-        constants$1.clang_Range_isNull$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$1.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$10 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$10() {}\n-    static final FunctionDescriptor clang_isVolatileQualifiedType$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_isVolatileQualifiedType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_isVolatileQualifiedType\",\n-        constants$10.clang_isVolatileQualifiedType$FUNC\n-    );\n-    static final FunctionDescriptor clang_getTypedefName$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getTypedefName$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getTypedefName\",\n-        constants$10.clang_getTypedefName$FUNC\n-    );\n-    static final FunctionDescriptor clang_getPointeeType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        MemoryLayout.paddingLayout(4),\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getPointeeType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getPointeeType\",\n-        constants$10.clang_getPointeeType$FUNC\n-    );\n-    static final FunctionDescriptor clang_getTypeDeclaration$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-        MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getTypeDeclaration$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getTypeDeclaration\",\n-        constants$10.clang_getTypeDeclaration$FUNC\n-    );\n-    static final FunctionDescriptor clang_getTypeKindSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_getTypeKindSpelling$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getTypeKindSpelling\",\n-        constants$10.clang_getTypeKindSpelling$FUNC\n-    );\n-    static final FunctionDescriptor clang_getFunctionTypeCallingConv$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getFunctionTypeCallingConv$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getFunctionTypeCallingConv\",\n-        constants$10.clang_getFunctionTypeCallingConv$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$10.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -1,124 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$11 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$11() {}\n-    static final FunctionDescriptor clang_getResultType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        MemoryLayout.paddingLayout(4),\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getResultType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getResultType\",\n-        constants$11.clang_getResultType$FUNC\n-    );\n-    static final FunctionDescriptor clang_getNumArgTypes$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getNumArgTypes$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getNumArgTypes\",\n-        constants$11.clang_getNumArgTypes$FUNC\n-    );\n-    static final FunctionDescriptor clang_getArgType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        MemoryLayout.paddingLayout(4),\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        ),\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_getArgType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getArgType\",\n-        constants$11.clang_getArgType$FUNC\n-    );\n-    static final FunctionDescriptor clang_isFunctionTypeVariadic$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_isFunctionTypeVariadic$MH = RuntimeHelper.downcallHandle(\n-        \"clang_isFunctionTypeVariadic\",\n-        constants$11.clang_isFunctionTypeVariadic$FUNC\n-    );\n-    static final FunctionDescriptor clang_getCursorResultType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        MemoryLayout.paddingLayout(4),\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorResultType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorResultType\",\n-        constants$11.clang_getCursorResultType$FUNC\n-    );\n-    static final FunctionDescriptor clang_getElementType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        MemoryLayout.paddingLayout(4),\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getElementType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getElementType\",\n-        constants$11.clang_getElementType$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$11.java","additions":0,"deletions":124,"binary":false,"changes":124,"status":"deleted"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$12 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$12() {}\n-    static final FunctionDescriptor clang_getNumElements$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getNumElements$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getNumElements\",\n-        constants$12.clang_getNumElements$FUNC\n-    );\n-    static final FunctionDescriptor clang_getArrayElementType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        MemoryLayout.paddingLayout(4),\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getArrayElementType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getArrayElementType\",\n-        constants$12.clang_getArrayElementType$FUNC\n-    );\n-    static final FunctionDescriptor clang_getArraySize$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getArraySize$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getArraySize\",\n-        constants$12.clang_getArraySize$FUNC\n-    );\n-    static final FunctionDescriptor clang_Type_getSizeOf$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Type_getSizeOf$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Type_getSizeOf\",\n-        constants$12.clang_Type_getSizeOf$FUNC\n-    );\n-    static final FunctionDescriptor clang_Type_getAlignOf$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,\n-            MemoryLayout.structLayout(\n-                    Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-                    MemoryLayout.paddingLayout(4),\n-                    MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-            )\n-    );\n-    static final MethodHandle clang_Type_getAlignOf$MH = RuntimeHelper.downcallHandle(\n-            \"clang_Type_getAlignOf\",\n-            constants$12.clang_Type_getAlignOf$FUNC\n-    );\n-    static final FunctionDescriptor clang_Type_getOffsetOf$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        ),\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_Type_getOffsetOf$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Type_getOffsetOf\",\n-        constants$12.clang_Type_getOffsetOf$FUNC\n-    );\n-    static final FunctionDescriptor clang_Cursor_isAnonymous$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Cursor_isAnonymous$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_isAnonymous\",\n-        constants$12.clang_Cursor_isAnonymous$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$12.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$13 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$13() {}\n-    static final FunctionDescriptor clang_Cursor_isAnonymousRecordDecl$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Cursor_isAnonymousRecordDecl$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_isAnonymousRecordDecl\",\n-        constants$13.clang_Cursor_isAnonymousRecordDecl$FUNC\n-    );\n-    static final FunctionDescriptor clang_Cursor_isBitField$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Cursor_isBitField$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_isBitField\",\n-        constants$13.clang_Cursor_isBitField$FUNC\n-    );\n-    static final FunctionDescriptor CXCursorVisitor$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        ),\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle CXCursorVisitor$MH = RuntimeHelper.downcallHandle(\n-        constants$13.CXCursorVisitor$FUNC\n-    );\n-    static final FunctionDescriptor clang_visitChildren$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        ),\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_visitChildren$MH = RuntimeHelper.downcallHandle(\n-        \"clang_visitChildren\",\n-        constants$13.clang_visitChildren$FUNC\n-    );\n-    static final FunctionDescriptor clang_getCursorUSR$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorUSR$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorUSR\",\n-        constants$13.clang_getCursorUSR$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$13.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$14 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$14() {}\n-    static final FunctionDescriptor clang_getCursorSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorSpelling$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorSpelling\",\n-        constants$14.clang_getCursorSpelling$FUNC\n-    );\n-    static final FunctionDescriptor clang_PrintingPolicy_getProperty$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_PrintingPolicy_getProperty$MH = RuntimeHelper.downcallHandle(\n-        \"clang_PrintingPolicy_getProperty\",\n-        constants$14.clang_PrintingPolicy_getProperty$FUNC\n-    );\n-    static final FunctionDescriptor clang_PrintingPolicy_setProperty$FUNC = FunctionDescriptor.ofVoid(\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_PrintingPolicy_setProperty$MH = RuntimeHelper.downcallHandle(\n-        \"clang_PrintingPolicy_setProperty\",\n-        constants$14.clang_PrintingPolicy_setProperty$FUNC\n-    );\n-    static final FunctionDescriptor clang_getCursorPrintingPolicy$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorPrintingPolicy$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorPrintingPolicy\",\n-        constants$14.clang_getCursorPrintingPolicy$FUNC\n-    );\n-    static final FunctionDescriptor clang_PrintingPolicy_dispose$FUNC = FunctionDescriptor.ofVoid(\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_PrintingPolicy_dispose$MH = RuntimeHelper.downcallHandle(\n-        \"clang_PrintingPolicy_dispose\",\n-        constants$14.clang_PrintingPolicy_dispose$FUNC\n-    );\n-    static final FunctionDescriptor clang_getCursorPrettyPrinted$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        ),\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_getCursorPrettyPrinted$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorPrettyPrinted\",\n-        constants$14.clang_getCursorPrettyPrinted$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$14.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$15 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$15() {}\n-    static final FunctionDescriptor clang_getCursorDisplayName$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorDisplayName$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorDisplayName\",\n-        constants$15.clang_getCursorDisplayName$FUNC\n-    );\n-    static final FunctionDescriptor clang_getCursorReferenced$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-        MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorReferenced$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorReferenced\",\n-        constants$15.clang_getCursorReferenced$FUNC\n-    );\n-    static final FunctionDescriptor clang_getCursorDefinition$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-        MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorDefinition$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorDefinition\",\n-        constants$15.clang_getCursorDefinition$FUNC\n-    );\n-    static final FunctionDescriptor clang_isCursorDefinition$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_isCursorDefinition$MH = RuntimeHelper.downcallHandle(\n-        \"clang_isCursorDefinition\",\n-        constants$15.clang_isCursorDefinition$FUNC\n-    );\n-    static final FunctionDescriptor clang_Cursor_isVariadic$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Cursor_isVariadic$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_isVariadic\",\n-        constants$15.clang_Cursor_isVariadic$FUNC\n-    );\n-    static final FunctionDescriptor clang_Cursor_getMangling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Cursor_getMangling$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_getMangling\",\n-        constants$15.clang_Cursor_getMangling$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$15.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$16 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$16() {}\n-    static final FunctionDescriptor clang_getTokenKind$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(4, Constants$root.C_INT$LAYOUT).withName(\"int_data\"),\n-            Constants$root.C_POINTER$LAYOUT.withName(\"ptr_data\")\n-        )\n-    );\n-    static final MethodHandle clang_getTokenKind$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getTokenKind\",\n-        constants$16.clang_getTokenKind$FUNC\n-    );\n-    static final FunctionDescriptor clang_getTokenSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        Constants$root.C_POINTER$LAYOUT,\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(4, Constants$root.C_INT$LAYOUT).withName(\"int_data\"),\n-            Constants$root.C_POINTER$LAYOUT.withName(\"ptr_data\")\n-        )\n-    );\n-    static final MethodHandle clang_getTokenSpelling$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getTokenSpelling\",\n-        constants$16.clang_getTokenSpelling$FUNC\n-    );\n-    static final FunctionDescriptor clang_getTokenLocation$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        Constants$root.C_POINTER$LAYOUT,\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(4, Constants$root.C_INT$LAYOUT).withName(\"int_data\"),\n-            Constants$root.C_POINTER$LAYOUT.withName(\"ptr_data\")\n-        )\n-    );\n-    static final MethodHandle clang_getTokenLocation$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getTokenLocation\",\n-        constants$16.clang_getTokenLocation$FUNC\n-    );\n-    static final FunctionDescriptor clang_getTokenExtent$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"begin_int_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"end_int_data\")\n-    ),\n-        Constants$root.C_POINTER$LAYOUT,\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(4, Constants$root.C_INT$LAYOUT).withName(\"int_data\"),\n-            Constants$root.C_POINTER$LAYOUT.withName(\"ptr_data\")\n-        )\n-    );\n-    static final MethodHandle clang_getTokenExtent$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getTokenExtent\",\n-        constants$16.clang_getTokenExtent$FUNC\n-    );\n-    static final FunctionDescriptor clang_tokenize$FUNC = FunctionDescriptor.ofVoid(\n-        Constants$root.C_POINTER$LAYOUT,\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"begin_int_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"end_int_data\")\n-        ),\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_tokenize$MH = RuntimeHelper.downcallHandle(\n-        \"clang_tokenize\",\n-        constants$16.clang_tokenize$FUNC\n-    );\n-    static final FunctionDescriptor clang_disposeTokens$FUNC = FunctionDescriptor.ofVoid(\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_disposeTokens$MH = RuntimeHelper.downcallHandle(\n-        \"clang_disposeTokens\",\n-        constants$16.clang_disposeTokens$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$16.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$17 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$17() {}\n-    static final FunctionDescriptor clang_getCursorKindSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_getCursorKindSpelling$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorKindSpelling\",\n-        constants$17.clang_getCursorKindSpelling$FUNC\n-    );\n-    static final FunctionDescriptor clang_getClangVersion$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ));\n-    static final MethodHandle clang_getClangVersion$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getClangVersion\",\n-        constants$17.clang_getClangVersion$FUNC\n-    );\n-    static final FunctionDescriptor clang_toggleCrashRecovery$FUNC = FunctionDescriptor.ofVoid(\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_toggleCrashRecovery$MH = RuntimeHelper.downcallHandle(\n-        \"clang_toggleCrashRecovery\",\n-        constants$17.clang_toggleCrashRecovery$FUNC\n-    );\n-    static final FunctionDescriptor clang_Cursor_Evaluate$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Cursor_Evaluate$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_Evaluate\",\n-        constants$17.clang_Cursor_Evaluate$FUNC\n-    );\n-    static final FunctionDescriptor clang_EvalResult_getKind$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_EvalResult_getKind$MH = RuntimeHelper.downcallHandle(\n-        \"clang_EvalResult_getKind\",\n-        constants$17.clang_EvalResult_getKind$FUNC\n-    );\n-    static final FunctionDescriptor clang_EvalResult_getAsInt$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_EvalResult_getAsInt$MH = RuntimeHelper.downcallHandle(\n-        \"clang_EvalResult_getAsInt\",\n-        constants$17.clang_EvalResult_getAsInt$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$17.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$18 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$18() {}\n-    static final FunctionDescriptor clang_EvalResult_getAsLongLong$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_EvalResult_getAsLongLong$MH = RuntimeHelper.downcallHandle(\n-        \"clang_EvalResult_getAsLongLong\",\n-        constants$18.clang_EvalResult_getAsLongLong$FUNC\n-    );\n-    static final FunctionDescriptor clang_EvalResult_isUnsignedInt$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_EvalResult_isUnsignedInt$MH = RuntimeHelper.downcallHandle(\n-        \"clang_EvalResult_isUnsignedInt\",\n-        constants$18.clang_EvalResult_isUnsignedInt$FUNC\n-    );\n-    static final FunctionDescriptor clang_EvalResult_getAsUnsigned$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_EvalResult_getAsUnsigned$MH = RuntimeHelper.downcallHandle(\n-        \"clang_EvalResult_getAsUnsigned\",\n-        constants$18.clang_EvalResult_getAsUnsigned$FUNC\n-    );\n-    static final FunctionDescriptor clang_EvalResult_getAsDouble$FUNC = FunctionDescriptor.of(Constants$root.C_DOUBLE$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_EvalResult_getAsDouble$MH = RuntimeHelper.downcallHandle(\n-        \"clang_EvalResult_getAsDouble\",\n-        constants$18.clang_EvalResult_getAsDouble$FUNC\n-    );\n-    static final FunctionDescriptor clang_EvalResult_getAsStr$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_EvalResult_getAsStr$MH = RuntimeHelper.downcallHandle(\n-        \"clang_EvalResult_getAsStr\",\n-        constants$18.clang_EvalResult_getAsStr$FUNC\n-    );\n-    static final FunctionDescriptor clang_EvalResult_dispose$FUNC = FunctionDescriptor.ofVoid(\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_EvalResult_dispose$MH = RuntimeHelper.downcallHandle(\n-        \"clang_EvalResult_dispose\",\n-        constants$18.clang_EvalResult_dispose$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$18.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$2 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$2() {}\n-    static final FunctionDescriptor clang_getExpansionLocation$FUNC = FunctionDescriptor.ofVoid(\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-            MemoryLayout.paddingLayout(4)\n-        ),\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_getExpansionLocation$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getExpansionLocation\",\n-        constants$2.clang_getExpansionLocation$FUNC\n-    );\n-    static final FunctionDescriptor clang_getSpellingLocation$FUNC = FunctionDescriptor.ofVoid(\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-            MemoryLayout.paddingLayout(4)\n-        ),\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_getSpellingLocation$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getSpellingLocation\",\n-        constants$2.clang_getSpellingLocation$FUNC\n-    );\n-    static final FunctionDescriptor clang_getFileLocation$FUNC = FunctionDescriptor.ofVoid(\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-            MemoryLayout.paddingLayout(4)\n-        ),\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_getFileLocation$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getFileLocation\",\n-        constants$2.clang_getFileLocation$FUNC\n-    );\n-    static final FunctionDescriptor clang_getRangeStart$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"begin_int_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"end_int_data\")\n-        )\n-    );\n-    static final MethodHandle clang_getRangeStart$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getRangeStart\",\n-        constants$2.clang_getRangeStart$FUNC\n-    );\n-    static final FunctionDescriptor clang_getRangeEnd$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"begin_int_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"end_int_data\")\n-        )\n-    );\n-    static final MethodHandle clang_getRangeEnd$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getRangeEnd\",\n-        constants$2.clang_getRangeEnd$FUNC\n-    );\n-    static final FunctionDescriptor clang_getChildDiagnostics$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_getChildDiagnostics$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getChildDiagnostics\",\n-        constants$2.clang_getChildDiagnostics$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$2.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$3 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$3() {}\n-    static final FunctionDescriptor clang_getNumDiagnostics$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_getNumDiagnostics$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getNumDiagnostics\",\n-        constants$3.clang_getNumDiagnostics$FUNC\n-    );\n-    static final FunctionDescriptor clang_getDiagnostic$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_getDiagnostic$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getDiagnostic\",\n-        constants$3.clang_getDiagnostic$FUNC\n-    );\n-    static final FunctionDescriptor clang_disposeDiagnostic$FUNC = FunctionDescriptor.ofVoid(\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_disposeDiagnostic$MH = RuntimeHelper.downcallHandle(\n-        \"clang_disposeDiagnostic\",\n-        constants$3.clang_disposeDiagnostic$FUNC\n-    );\n-    static final FunctionDescriptor clang_formatDiagnostic$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_formatDiagnostic$MH = RuntimeHelper.downcallHandle(\n-        \"clang_formatDiagnostic\",\n-        constants$3.clang_formatDiagnostic$FUNC\n-    );\n-    static final FunctionDescriptor clang_defaultDiagnosticDisplayOptions$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT);\n-    static final MethodHandle clang_defaultDiagnosticDisplayOptions$MH = RuntimeHelper.downcallHandle(\n-        \"clang_defaultDiagnosticDisplayOptions\",\n-        constants$3.clang_defaultDiagnosticDisplayOptions$FUNC\n-    );\n-    static final FunctionDescriptor clang_getDiagnosticSeverity$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_getDiagnosticSeverity$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getDiagnosticSeverity\",\n-        constants$3.clang_getDiagnosticSeverity$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$3.java","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -1,106 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$4 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$4() {}\n-    static final FunctionDescriptor clang_getDiagnosticLocation$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_getDiagnosticLocation$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getDiagnosticLocation\",\n-        constants$4.clang_getDiagnosticLocation$FUNC\n-    );\n-    static final FunctionDescriptor clang_getDiagnosticSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_getDiagnosticSpelling$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getDiagnosticSpelling\",\n-        constants$4.clang_getDiagnosticSpelling$FUNC\n-    );\n-    static final FunctionDescriptor clang_parseTranslationUnit$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_parseTranslationUnit$MH = RuntimeHelper.downcallHandle(\n-        \"clang_parseTranslationUnit\",\n-        constants$4.clang_parseTranslationUnit$FUNC\n-    );\n-    static final FunctionDescriptor clang_parseTranslationUnit2$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_parseTranslationUnit2$MH = RuntimeHelper.downcallHandle(\n-        \"clang_parseTranslationUnit2\",\n-        constants$4.clang_parseTranslationUnit2$FUNC\n-    );\n-    static final FunctionDescriptor clang_saveTranslationUnit$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_saveTranslationUnit$MH = RuntimeHelper.downcallHandle(\n-        \"clang_saveTranslationUnit\",\n-        constants$4.clang_saveTranslationUnit$FUNC\n-    );\n-    static final FunctionDescriptor clang_disposeTranslationUnit$FUNC = FunctionDescriptor.ofVoid(\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_disposeTranslationUnit$MH = RuntimeHelper.downcallHandle(\n-        \"clang_disposeTranslationUnit\",\n-        constants$4.clang_disposeTranslationUnit$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$4.java","additions":0,"deletions":106,"binary":false,"changes":106,"status":"deleted"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$5 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$5() {}\n-    static final FunctionDescriptor clang_defaultReparseOptions$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_defaultReparseOptions$MH = RuntimeHelper.downcallHandle(\n-        \"clang_defaultReparseOptions\",\n-        constants$5.clang_defaultReparseOptions$FUNC\n-    );\n-    static final FunctionDescriptor clang_reparseTranslationUnit$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_reparseTranslationUnit$MH = RuntimeHelper.downcallHandle(\n-        \"clang_reparseTranslationUnit\",\n-        constants$5.clang_reparseTranslationUnit$FUNC\n-    );\n-    static final FunctionDescriptor clang_getNullCursor$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-        MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ));\n-    static final MethodHandle clang_getNullCursor$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getNullCursor\",\n-        constants$5.clang_getNullCursor$FUNC\n-    );\n-    static final FunctionDescriptor clang_getTranslationUnitCursor$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-        MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_getTranslationUnitCursor$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getTranslationUnitCursor\",\n-        constants$5.clang_getTranslationUnitCursor$FUNC\n-    );\n-    static final FunctionDescriptor clang_equalCursors$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_equalCursors$MH = RuntimeHelper.downcallHandle(\n-        \"clang_equalCursors\",\n-        constants$5.clang_equalCursors$FUNC\n-    );\n-    static final FunctionDescriptor clang_Cursor_isNull$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Cursor_isNull$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_isNull\",\n-        constants$5.clang_Cursor_isNull$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$5.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$6 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$6() {}\n-    static final FunctionDescriptor clang_getCursorKind$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorKind$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorKind\",\n-        constants$6.clang_getCursorKind$FUNC\n-    );\n-    static final FunctionDescriptor clang_isDeclaration$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_isDeclaration$MH = RuntimeHelper.downcallHandle(\n-        \"clang_isDeclaration\",\n-        constants$6.clang_isDeclaration$FUNC\n-    );\n-    static final FunctionDescriptor clang_isAttribute$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_isAttribute$MH = RuntimeHelper.downcallHandle(\n-        \"clang_isAttribute\",\n-        constants$6.clang_isAttribute$FUNC\n-    );\n-    static final FunctionDescriptor clang_isInvalid$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_isInvalid$MH = RuntimeHelper.downcallHandle(\n-        \"clang_isInvalid\",\n-        constants$6.clang_isInvalid$FUNC\n-    );\n-    static final FunctionDescriptor clang_isPreprocessing$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_isPreprocessing$MH = RuntimeHelper.downcallHandle(\n-        \"clang_isPreprocessing\",\n-        constants$6.clang_isPreprocessing$FUNC\n-    );\n-    static final FunctionDescriptor clang_getCursorLinkage$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorLinkage$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorLinkage\",\n-        constants$6.clang_getCursorLinkage$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$6.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$7 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$7() {}\n-    static final FunctionDescriptor clang_getCursorLanguage$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorLanguage$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorLanguage\",\n-        constants$7.clang_getCursorLanguage$FUNC\n-    );\n-    static final FunctionDescriptor clang_Cursor_getTranslationUnit$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Cursor_getTranslationUnit$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_getTranslationUnit\",\n-        constants$7.clang_Cursor_getTranslationUnit$FUNC\n-    );\n-    static final FunctionDescriptor clang_getCursorLocation$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorLocation$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorLocation\",\n-        constants$7.clang_getCursorLocation$FUNC\n-    );\n-    static final FunctionDescriptor clang_getCursorExtent$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"begin_int_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"end_int_data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorExtent$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorExtent\",\n-        constants$7.clang_getCursorExtent$FUNC\n-    );\n-    static final FunctionDescriptor clang_getCursorType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        MemoryLayout.paddingLayout(4),\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorType\",\n-        constants$7.clang_getCursorType$FUNC\n-    );\n-    static final FunctionDescriptor clang_getTypeSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getTypeSpelling$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getTypeSpelling\",\n-        constants$7.clang_getTypeSpelling$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$7.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -1,115 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$8 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$8() {}\n-    static final FunctionDescriptor clang_getTypedefDeclUnderlyingType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        MemoryLayout.paddingLayout(4),\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getTypedefDeclUnderlyingType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getTypedefDeclUnderlyingType\",\n-        constants$8.clang_getTypedefDeclUnderlyingType$FUNC\n-    );\n-    static final FunctionDescriptor clang_getEnumDeclIntegerType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        MemoryLayout.paddingLayout(4),\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getEnumDeclIntegerType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getEnumDeclIntegerType\",\n-        constants$8.clang_getEnumDeclIntegerType$FUNC\n-    );\n-    static final FunctionDescriptor clang_getEnumConstantDeclValue$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getEnumConstantDeclValue$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getEnumConstantDeclValue\",\n-        constants$8.clang_getEnumConstantDeclValue$FUNC\n-    );\n-    static final FunctionDescriptor clang_getEnumConstantDeclUnsignedValue$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getEnumConstantDeclUnsignedValue$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getEnumConstantDeclUnsignedValue\",\n-        constants$8.clang_getEnumConstantDeclUnsignedValue$FUNC\n-    );\n-    static final FunctionDescriptor clang_getFieldDeclBitWidth$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getFieldDeclBitWidth$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getFieldDeclBitWidth\",\n-        constants$8.clang_getFieldDeclBitWidth$FUNC\n-    );\n-    static final FunctionDescriptor clang_Cursor_getNumArguments$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Cursor_getNumArguments$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_getNumArguments\",\n-        constants$8.clang_Cursor_getNumArguments$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$8.java","additions":0,"deletions":115,"binary":false,"changes":115,"status":"deleted"},{"patch":"@@ -1,121 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$9 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$9() {}\n-    static final FunctionDescriptor clang_Cursor_getArgument$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-        MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        ),\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_Cursor_getArgument$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_getArgument\",\n-        constants$9.clang_Cursor_getArgument$FUNC\n-    );\n-    static final FunctionDescriptor clang_equalTypes$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_equalTypes$MH = RuntimeHelper.downcallHandle(\n-        \"clang_equalTypes\",\n-        constants$9.clang_equalTypes$FUNC\n-    );\n-    static final FunctionDescriptor clang_getCanonicalType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        MemoryLayout.paddingLayout(4),\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCanonicalType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCanonicalType\",\n-        constants$9.clang_getCanonicalType$FUNC\n-    );\n-    static final FunctionDescriptor clang_isConstQualifiedType$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_isConstQualifiedType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_isConstQualifiedType\",\n-        constants$9.clang_isConstQualifiedType$FUNC\n-    );\n-    static final FunctionDescriptor clang_Cursor_isMacroFunctionLike$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Cursor_isMacroFunctionLike$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_isMacroFunctionLike\",\n-        constants$9.clang_Cursor_isMacroFunctionLike$FUNC\n-    );\n-    static final FunctionDescriptor clang_Cursor_isFunctionInlined$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Cursor_isFunctionInlined$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_isFunctionInlined\",\n-        constants$9.clang_Cursor_isFunctionInlined$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$9.java","additions":0,"deletions":121,"binary":false,"changes":121,"status":"deleted"},{"patch":"@@ -1,290 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package org.openjdk.jextract.impl;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-import org.openjdk.jextract.Declaration;\n-import org.openjdk.jextract.Type;\n-\n-final class CDeclarationPrinter implements Declaration.Visitor<Void, Void> {\n-    private static String SPACES = \" \".repeat(92);\n-    private int align = 0;\n-    private String prefix;\n-\n-    private void incr() {\n-        align += 4;\n-    }\n-\n-    private void decr() {\n-        align -= 4;\n-    }\n-\n-    private CDeclarationPrinter(String prefix) {\n-        this.prefix = prefix;\n-    }\n-\n-    private void indent() {\n-        builder.append(prefix);\n-        builder.append(SPACES.substring(0, align));\n-    }\n-\n-    private final StringBuilder builder = new StringBuilder();\n-\n-    private String print(Declaration decl) {\n-        decl.accept(this, null);\n-        return builder.toString();\n-    }\n-\n-    \/\/ Return C source style signature for the given declaration.\n-    \/\/ The prefix is emitted for every line. This can be used\n-    \/\/ to prefix per line comment character \"*\" in generated javadoc.\n-    static String declaration(Declaration decl, String prefix) {\n-        Objects.requireNonNull(decl);\n-        Objects.requireNonNull(prefix);\n-        return new CDeclarationPrinter(prefix).print(decl);\n-    }\n-\n-    static String declaration(Type.Function funcType, String name) {\n-        return nameAndType(funcType, \"*\" + name);\n-    }\n-\n-    @Override\n-    public Void visitScoped(Declaration.Scoped d, Void ignored) {\n-        indent();\n-        var tag = typeTag(d);\n-        if (!tag.isEmpty()) {\n-            builder.append(tag);\n-            if (!d.name().isEmpty()) {\n-                builder.append(\" \" + d.name());\n-            }\n-            builder.append(\" {\");\n-            builder.append(\"\\n\");\n-            incr();\n-        }\n-        d.members().forEach(m -> m.accept(this, null));\n-        if (!tag.isEmpty()) {\n-            decr();\n-            indent();\n-            builder.append(\"};\\n\");\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitFunction(Declaration.Function d, Void ignored) {\n-        indent();\n-\n-        \/\/ name and args part of the function\n-        StringBuilder buf = new StringBuilder();\n-        buf.append(d.name());\n-        buf.append('(');\n-        buf.append(\n-            d.parameters().\n-                stream().\n-                map(p -> nameAndType(p.type(), p.name())).\n-                collect(Collectors.joining(\", \"))\n-        );\n-        if (d.type().varargs()) {\n-            buf.append(\",...\");\n-        }\n-        buf.append(')');\n-\n-        \/\/ The return type is handled later to take care of\n-        \/\/ pointer to function return type like signal from signal.h\n-        \/\/ void (*signal(int sig, void (*func)(int)))(int)\n-\n-        String funcNameAndArgs = buf.toString();\n-        Type returnType = d.type().returnType();\n-        builder.append(nameAndType(returnType, funcNameAndArgs));\n-        builder.append(\";\\n\");\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitVariable(Declaration.Variable d, Void ignored) {\n-        indent();\n-        builder.append(nameAndType(d.type(), d.name()));\n-        builder.append(\";\\n\");\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitConstant(Declaration.Constant d, Void ignored) {\n-        indent();\n-        Optional<String> enumName = EnumConstantLifter.enumName(d);\n-        if (enumName.isPresent()) {\n-            builder.append(\"enum \" + enumName.get() + \".\" + d.name());\n-            builder.append(\" = \");\n-            builder.append(d.value());\n-            builder.append(\";\\n\");\n-        } else {\n-            builder.append(\"#define \");\n-            builder.append(d.name());\n-            Object value = d.value();\n-            builder.append(\" \");\n-            if (value instanceof String str) {\n-                builder.append(\"\\\"\" + Utils.quote(str) + \"\\\"\");\n-            } else {\n-                builder.append(value);\n-            }\n-            builder.append(\"\\n\");\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitTypedef(Declaration.Typedef d, Void ignored) {\n-        indent();\n-        builder.append(\"typedef \");\n-        builder.append(nameAndType(d.type(), d.name()));\n-        builder.append(\";\\n\");\n-        return null;\n-    }\n-\n-    \/\/ In few cases, C type signature 'embeds' name.\n-    \/\/ Examples:\n-    \/\/     int a[3]; \/\/ 'a' in between int and []\n-    \/\/     int (*func)(int); \/\/ 'func' is inside paren after '*'\n-    \/\/ TypeVisitor accepts name and includes it in the appropriate\n-    \/\/ place as needed. If not included, boolean flag is set to false\n-    \/\/ in the result.\n-\n-    private static String nameAndType(Type type, String name) {\n-        var result = type.accept(typeVisitor, name);\n-        var typeStr = result.typeStr();\n-        return result.nameIncluded() || name.isEmpty() ?\n-            typeStr : (typeStr + \" \" + name);\n-    }\n-\n-    \/\/ result type for Type.Visitor\n-    private record TypeVisitorResult(boolean nameIncluded, String typeStr) {}\n-\n-    private static Type.Visitor<TypeVisitorResult, String> typeVisitor = new Type.Visitor<>() {\n-        \/\/ context argument in this visitor usually starts with a name. But it may pick up\n-        \/\/ \"*\" prefixes for pointer type. [] suffix for array types. For pointer to function\n-        \/\/ return type, the context is name of the function + argument types as in declaration.\n-\n-        @Override\n-        public TypeVisitorResult visitPrimitive(Type.Primitive t, String context) {\n-            return new TypeVisitorResult(false, t.kind().typeName());\n-        }\n-\n-        private TypeVisitorResult prefixedType(String prefix, Type.Delegated delegated) {\n-            return new TypeVisitorResult(false,\n-                    prefix + \" \" + delegated.type().accept(this, \"\").typeStr());\n-        }\n-\n-        @Override\n-        public TypeVisitorResult visitDelegated(Type.Delegated t, String context) {\n-            switch (t.kind()) {\n-                case POINTER: {\n-                    var result = t.type().accept(this, \"*\" + context);\n-                    if (result.nameIncluded()) {\n-                        return new TypeVisitorResult(true, result.typeStr());\n-                    } else {\n-                        return new TypeVisitorResult(false, result.typeStr() + \"*\");\n-                    }\n-                }\n-                case UNSIGNED:\n-                    return prefixedType(\"unsigned\", t);\n-                case SIGNED:\n-                    return prefixedType(\"signed\", t);\n-                case VOLATILE:\n-                    return prefixedType(\"volatile\", t);\n-                case COMPLEX:\n-                    return prefixedType(\"complex\", t);\n-            }\n-            \/\/ defensive. If no name is present, we don't want to crash\n-            return new TypeVisitorResult(false, t.name().orElse(defaultName(t)));\n-        }\n-\n-        @Override\n-        public TypeVisitorResult visitFunction(Type.Function t, String context) {\n-            String argsStr;\n-            \/\/ Function type may optionally have parameter names.\n-            \/\/ Include parameter names if available.\n-            var optParameterNames = t.parameterNames();\n-            if (optParameterNames.isPresent()) {\n-                List<Type> argTypes = t.argumentTypes();\n-                List<String> argNames = optParameterNames.get();\n-                int numArgs = argTypes.size();\n-                List<String> args = new ArrayList<>(numArgs);\n-                for (int i = 0; i < numArgs; i++) {\n-                    args.add(nameAndType(argTypes.get(i), argNames.get(i)));\n-                }\n-                argsStr = args.stream()\n-                    .collect(Collectors.joining(\",\", \"(\", \")\"));\n-            } else {\n-                argsStr = t.argumentTypes().stream()\n-                    .map(a -> a.accept(this, \"\").typeStr())\n-                    .collect(Collectors.joining(\",\", \"(\", \")\"));\n-            }\n-            String res = t.returnType().accept(this, \"\").typeStr();\n-            return new TypeVisitorResult(true, res + \" (\" + context + \")\" + argsStr);\n-        }\n-\n-        @Override\n-        public TypeVisitorResult visitDeclared(Type.Declared t, String context) {\n-            Declaration.Scoped scoped = t.tree();\n-            return new TypeVisitorResult(false, typeTag(scoped) + \" \" + scoped.name());\n-        }\n-\n-        @Override\n-        public TypeVisitorResult visitArray(Type.Array t, String context) {\n-            String brackets = String.format(\" %s[%s]\", context,\n-                t.elementCount().isPresent() ? t.elementCount().getAsLong() : \"\");\n-            var result = t.elementType().accept(this, brackets);\n-            if (result.nameIncluded()) {\n-                return new TypeVisitorResult(true, result.typeStr());\n-            } else {\n-                return new TypeVisitorResult(true, result.typeStr() + brackets);\n-            }\n-        }\n-\n-        @Override\n-        public TypeVisitorResult visitType(Type t, String context) {\n-            return new TypeVisitorResult(false, defaultName(t));\n-        }\n-\n-        private String defaultName(Type t) {\n-            return t.toString();\n-        }\n-    };\n-\n-    private static String typeTag(Declaration.Scoped scoped) {\n-        return switch (scoped.kind()) {\n-            case STRUCT -> \"struct\";\n-            case UNION -> \"union\";\n-            case ENUM -> \"enum\";\n-            default -> \"\";\n-        };\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/CDeclarationPrinter.java","additions":0,"deletions":290,"binary":false,"changes":290,"status":"deleted"},{"patch":"@@ -27,4 +27,0 @@\n-import javax.tools.JavaFileObject;\n-import java.lang.constant.ClassDesc;\n-import java.util.List;\n-\n@@ -32,0 +28,1 @@\n+import org.openjdk.jextract.Declaration.Constant;\n@@ -33,1 +30,17 @@\n-import org.openjdk.jextract.impl.Constants.Constant;\n+import org.openjdk.jextract.Type.Array;\n+import org.openjdk.jextract.Type.Declared;\n+import org.openjdk.jextract.Type.Delegated;\n+import org.openjdk.jextract.Type.Function;\n+import org.openjdk.jextract.Type.Primitive;\n+import org.openjdk.jextract.impl.DeclarationImpl.DeclarationString;\n+import org.openjdk.jextract.impl.DeclarationImpl.JavaName;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n@@ -38,4 +51,1 @@\n-abstract class ClassSourceBuilder extends JavaSourceBuilder {\n-\n-    private static final boolean SHOW_GENERATING_CLASS = Boolean.getBoolean(\"jextract.showGeneratingClass\");\n-\n+abstract class ClassSourceBuilder {\n@@ -53,13 +63,12 @@\n-    final Kind kind;\n-    final ClassDesc desc;\n-    protected final JavaSourceBuilder enclosing;\n-\n-    \/\/ code buffer\n-    private StringBuilder sb = new StringBuilder();\n-    \/\/ current line alignment (number of 4-spaces)\n-    private int align;\n-\n-    ClassSourceBuilder(JavaSourceBuilder enclosing, Kind kind, String name) {\n-        this.enclosing = enclosing;\n-        this.align = (enclosing instanceof ClassSourceBuilder classSourceBuilder)\n-                ? classSourceBuilder.align : 0;\n+    private final SourceFileBuilder sb;\n+    private final String modifiers;\n+    private final Kind kind;\n+    private final String className;\n+    private final String superName;\n+    private final ClassSourceBuilder enclosing;\n+    private final String runtimeHelperName;\n+\n+    ClassSourceBuilder(SourceFileBuilder builder, String modifiers, Kind kind, String className, String superName,\n+                       ClassSourceBuilder enclosing, String runtimeHelperName) {\n+        this.sb = builder;\n+        this.modifiers = modifiers;\n@@ -67,1 +76,4 @@\n-        this.desc = ClassDesc.of(enclosing.packageName(), name);\n+        this.className = className;\n+        this.superName = superName;\n+        this.enclosing = enclosing;\n+        this.runtimeHelperName = runtimeHelperName;\n@@ -70,2 +82,3 @@\n-    boolean isNested() {\n-        return enclosing instanceof ClassSourceBuilder;\n+    final String className() {\n+        \/\/ for a (nested) class 'com.foo.package.A.B.C' this will return 'C'\n+        return className;\n@@ -74,2 +87,2 @@\n-    String className() {\n-        return desc.displayName();\n+    final String runtimeHelperName() {\n+        return runtimeHelperName;\n@@ -78,4 +91,3 @@\n-    String fullName() {\n-        return isNested() ?\n-                ((ClassSourceBuilder)enclosing).className() + \".\" + className() :\n-                className();\n+    \/\/ is the name enclosed by a class of the same name?\n+    protected final boolean isEnclosedBySameName(String name) {\n+        return className().equals(name) || (isNested() && enclosing.isEnclosedBySameName(name));\n@@ -84,3 +96,2 @@\n-    @Override\n-    public final String packageName() {\n-        return desc.packageName();\n+    protected final boolean isNested() {\n+        return enclosing != null;\n@@ -89,2 +100,2 @@\n-    String superClass() {\n-        return null;\n+    final SourceFileBuilder sourceFileBuilder() {\n+        return sb;\n@@ -93,3 +104,4 @@\n-    String mods() {\n-        if (kind == Kind.INTERFACE) {\n-            return \"public \";\n+    final void classBegin() {\n+        String extendsExpr = \"\";\n+        if (superName != null) {\n+            extendsExpr = \" extends \" + superName;\n@@ -97,2 +109,3 @@\n-        return (isNested() ? \"public static \" : \"public \") +\n-                (isClassFinal() ? \"final \" : \"\");\n+        appendLines(STR.\"\"\"\n+            \\{modifiers} \\{kind.kindName} \\{className}\\{extendsExpr} {\n+            \"\"\");\n@@ -101,2 +114,4 @@\n-    boolean isClassFinal() {\n-        return true;\n+    final void classEnd() {\n+        appendLines(\"\"\"\n+            }\n+            \"\"\");\n@@ -105,20 +120,1 @@\n-    void classBegin() {\n-        if (isNested()) {\n-            incrAlign();\n-        }\n-        emitPackagePrefix();\n-        emitImportSection();\n-\n-        classDeclBegin();\n-        indent();\n-        append(mods());\n-        append(kind.kindName + \" \" + className());\n-        if (superClass() != null) {\n-            append(\" extends \");\n-            append(superClass());\n-        }\n-        append(\" {\\n\\n\");\n-        if (kind != Kind.INTERFACE) {\n-            emitConstructor();\n-        }\n-    }\n+    \/\/ Internal generation helpers (used by other builders)\n@@ -126,12 +122,2 @@\n-    void classDeclBegin() {}\n-\n-    void emitConstructor() {\n-        incrAlign();\n-        indent();\n-        append(\"\/\/ Suppresses default constructor, ensuring non-instantiability.\\n\");\n-        indent();\n-        append(\"private \");\n-        append(className());\n-        append(\"() {}\");\n-        append('\\n');\n-        decrAlign();\n+    final void incrAlign() {\n+        sb.incrAlign();\n@@ -140,9 +126,2 @@\n-    JavaSourceBuilder classEnd() {\n-        indent();\n-        append(\"}\\n\\n\");\n-        if (isNested()) {\n-            decrAlign();\n-            ((ClassSourceBuilder)enclosing).append(build());\n-            sb = null;\n-        }\n-        return enclosing;\n+    final void decrAlign() {\n+        sb.decrAlign();\n@@ -151,8 +130,3 @@\n-    @Override\n-    public List<JavaFileObject> toFiles() {\n-        if (isNested()) {\n-            throw new UnsupportedOperationException(\"Nested builder!\");\n-        }\n-        String res = build();\n-        sb = null;\n-        return List.of(Utils.fileFromString(packageName(), className(), res));\n+    \/\/ append multiple lines (indentation is added automatically)\n+    void appendLines(String s) {\n+        sb.appendLines(s);\n@@ -161,4 +135,2 @@\n-    \/\/ Internal generation helpers (used by other builders)\n-\n-    void append(Object o) {\n-        sb.append(o);\n+    void appendBlankLine() {\n+        appendLines(\"\\n\");\n@@ -167,2 +139,4 @@\n-    void append(String s) {\n-        sb.append(s);\n+    \/\/ increase indentation before appending lines\n+    \/\/ decrease afterwards\n+    void appendIndentedLines(String s) {\n+        sb.appendIndentedLines(s);\n@@ -171,3 +145,2 @@\n-    void append(char c) {\n-        sb.append(c);\n-    }\n+    final void emitDefaultConstructor() {\n+        appendIndentedLines(STR.\"\"\"\n@@ -175,2 +148,4 @@\n-    void append(boolean b) {\n-        sb.append(b);\n+            \\{className}() {\n+                \/\/ Should not be called directly\n+            }\n+            \"\"\");\n@@ -179,2 +154,2 @@\n-    void append(long l) {\n-        sb.append(l);\n+    final void emitDocComment(Declaration decl) {\n+        emitDocComment(decl, \"\");\n@@ -183,4 +158,9 @@\n-    void indent() {\n-        for (int i = 0; i < align; i++) {\n-            append(\"    \");\n-        }\n+    final void emitDocComment(Declaration decl, String header) {\n+        appendLines(STR.\"\"\"\n+            \/**\n+            \\{!header.isEmpty() ? STR.\" * \\{header}\\n\" : \"\"}\\\n+             * {@snippet lang=c :\n+            \\{declarationComment(decl)}\n+             * }\n+             *\/\n+            \"\"\");\n@@ -189,2 +169,2 @@\n-    void incrAlign() {\n-        align++;\n+    public String mangleName(String javaName, Class<?> type) {\n+        return javaName + nameSuffix(type);\n@@ -193,2 +173,11 @@\n-    void decrAlign() {\n-        align--;\n+    String nameSuffix(Class<?> type) {\n+        if (type.equals(MemorySegment.class)) {\n+            return \"$SEGMENT\";\n+        } else if (type.equals(MemoryLayout.class)) {\n+            return \"$LAYOUT\";\n+        } else if (type.equals(MethodHandle.class)) {\n+            return \"$MH\";\n+        } else if (type.equals(VarHandle.class)) {\n+            return \"$VH\";\n+        }\n+        throw new IllegalArgumentException(\"Not handled: \" + type);\n@@ -197,3 +186,2 @@\n-    String build() {\n-        String s = sb.toString();\n-        return s;\n+    String layoutString(Type type) {\n+        return layoutString(type, Long.MAX_VALUE);\n@@ -202,2 +190,11 @@\n-    void emitDocComment(Declaration decl) {\n-        emitDocComment(decl, \"\");\n+    String layoutString(Type type, long align) {\n+        return switch (type) {\n+            case Primitive p -> primitiveLayoutString(p, align);\n+            case Declared d when Utils.isEnum(d) -> layoutString(((Constant)d.tree().members().get(0)).type(), align);\n+            case Declared d when Utils.isStructOrUnion(d) -> STR.\"\\{JavaName.getFullNameOrThrow(d.tree())}.layout()\";\n+            case Delegated d when d.kind() == Delegated.Kind.POINTER -> STR.\"\\{runtimeHelperName()}.C_POINTER\";\n+            case Delegated d -> layoutString(d.type(), align);\n+            case Function _ -> STR.\"\\{runtimeHelperName()}.C_POINTER\";\n+            case Array a -> STR.\"MemoryLayout.sequenceLayout(\\{a.elementCount().orElse(0L)}, \\{layoutString(a.elementType(), align)})\";\n+            default -> throw new UnsupportedOperationException();\n+        };\n@@ -206,8 +203,13 @@\n-    void emitDocComment(Declaration decl, String header) {\n-        indent();\n-        append(\"\/**\\n\");\n-        if (!header.isEmpty()) {\n-            indent();\n-            append(\" * \");\n-            append(header);\n-            append(\"\\n\");\n+    String functionDescriptorString(int textBoxIndent, Type.Function functionType) {\n+        final MethodType type = Utils.methodTypeFor(functionType);\n+        boolean noArgs = type.parameterCount() == 0;\n+        StringBuilder builder = new StringBuilder();\n+        if (!type.returnType().equals(void.class)) {\n+            builder.append(\"FunctionDescriptor.of(\");\n+            builder.append(\"\\n\");\n+            builder.append(STR.\"\\{indentString(textBoxIndent + 1)}\\{layoutString(functionType.returnType())}\");\n+            if (!noArgs) {\n+                builder.append(\",\");\n+            }\n+        } else {\n+            builder.append(\"FunctionDescriptor.ofVoid(\");\n@@ -215,7 +217,12 @@\n-        indent();\n-        append(\" * {@snippet :\\n\");\n-        append(CDeclarationPrinter.declaration(decl, \" \".repeat(align*4) + \" * \"));\n-        indent();\n-        append(\" * }\\n\");\n-        indent();\n-        append(\" *\/\\n\");\n+        if (!noArgs) {\n+            builder.append(\"\\n\");\n+            String delim = \"\";\n+            for (Type arg : functionType.argumentTypes()) {\n+                builder.append(delim);\n+                builder.append(STR.\"\\{indentString(textBoxIndent + 1)}\\{layoutString(arg)}\");\n+                delim = \",\\n\";\n+            }\n+            builder.append(\"\\n\");\n+        }\n+        builder.append(STR.\"\\{indentString(textBoxIndent)})\");\n+        return builder.toString();\n@@ -224,12 +231,2 @@\n-    void emitDocComment(Type.Function funcType, String name) {\n-        indent();\n-        append(\"\/**\\n\");\n-        indent();\n-        append(\" * {@snippet :\\n\");\n-        append(\" * \");\n-        append(CDeclarationPrinter.declaration(funcType, name));\n-        append(\";\\n\");\n-        indent();\n-        append(\" * }\\n\");\n-        indent();\n-        append(\" *\/\\n\");\n+    String indentString(int size) {\n+        return \" \".repeat(size * 4);\n@@ -238,4 +235,17 @@\n-    \/\/ is the name enclosed enclosed by a class of the same name?\n-    boolean isEnclosedBySameName(String name) {\n-        return className().equals(name) ||\n-                (isNested() && enclosing.isEnclosedBySameName(name));\n+    private String primitiveLayoutString(Primitive primitiveType, long align) {\n+        return switch (primitiveType.kind()) {\n+            case Bool -> STR.\"\\{runtimeHelperName()}.C_BOOL\";\n+            case Char -> STR.\"\\{runtimeHelperName()}.C_CHAR\";\n+            case Short -> alignIfNeeded(STR.\"\\{runtimeHelperName()}.C_SHORT\", 2, align);\n+            case Int -> alignIfNeeded(STR.\"\\{runtimeHelperName()}.C_INT\", 4, align);\n+            case Long -> alignIfNeeded(STR.\"\\{runtimeHelperName()}.C_LONG\", TypeImpl.IS_WINDOWS ? 4 : 8, align);\n+            case LongLong -> alignIfNeeded(STR.\"\\{runtimeHelperName()}.C_LONG_LONG\", 8, align);\n+            case Float -> alignIfNeeded(STR.\"\\{runtimeHelperName()}.C_FLOAT\", 4, align);\n+            case Double -> alignIfNeeded(STR.\"\\{runtimeHelperName()}.C_DOUBLE\", 8, align);\n+            case LongDouble -> TypeImpl.IS_WINDOWS ?\n+                    alignIfNeeded(STR.\"\\{runtimeHelperName()}.C_LONG_DOUBLE\", 8, align) :\n+                    paddingLayoutString(8, 0);\n+            case HalfFloat, Char16, WChar -> paddingLayoutString(2, 0); \/\/ unsupported\n+            case Float128, Int128 -> paddingLayoutString(16, 0); \/\/ unsupported\n+            default -> throw new UnsupportedOperationException(primitiveType.toString());\n+        };\n@@ -244,16 +254,4 @@\n-    protected void emitPackagePrefix() {\n-        if (!isNested()) {\n-            assert packageName().indexOf('\/') == -1 : \"package name invalid: \" + packageName();\n-            append(\"\/\/ Generated by jextract\");\n-            if (SHOW_GENERATING_CLASS) {\n-                append(\" (via \");\n-                append(getClass().getName());\n-                append(\")\");\n-            }\n-            append(\"\\n\\n\");\n-            if (!packageName().isEmpty()) {\n-                append(\"package \");\n-                append(packageName());\n-                append(\";\\n\\n\");\n-            }\n-        }\n+    private String alignIfNeeded(String layoutPrefix, long align, long expectedAlign) {\n+        return align > expectedAlign ?\n+                STR.\"\\{layoutPrefix}.withByteAlignment(\\{expectedAlign})\" :\n+                layoutPrefix;\n@@ -262,8 +260,2 @@\n-    protected void emitImportSection() {\n-        if (!isNested()) {\n-            append(\"import java.lang.invoke.MethodHandle;\\n\");\n-            append(\"import java.lang.invoke.VarHandle;\\n\");\n-            append(\"import java.nio.ByteOrder;\\n\");\n-            append(\"import java.lang.foreign.*;\\n\");\n-            append(\"import static java.lang.foreign.ValueLayout.*;\\n\");\n-        }\n+    String paddingLayoutString(long size, int indent) {\n+        return STR.\"\\{indentString(indent)}MemoryLayout.paddingLayout(\\{size})\";\n@@ -272,21 +264,6 @@\n-    void emitConstantGetter(String mods, String getterName, boolean nullCheck, String symbolName, Constant constant) {\n-        incrAlign();\n-        indent();\n-        append(mods + \" \" + constant.type().getSimpleName() + \" \" + getterName + \"() {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return \");\n-        if (nullCheck) {\n-            append(\"RuntimeHelper.requireNonNull(\");\n-        }\n-        append(constant.accessExpression());\n-        if (nullCheck) {\n-            append(\",\\\"\");\n-            append(symbolName);\n-            append(\"\\\")\");\n-        }\n-        append(\";\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+    \/\/ Return C source style signature for the given declaration.\n+    \/\/ A \" * \" prefix is emitted for every line.\n+    static String declarationComment(Declaration decl) {\n+        Objects.requireNonNull(decl);\n+        String declString = DeclarationString.getOrThrow(decl);\n+        return declString.lines().collect(Collectors.joining(\"\\n * \", \" * \", \"\"));\n@@ -295,3 +272,10 @@\n-    @Override\n-    protected Constants constants() {\n-        return enclosing.constants();\n+    record IndexList(String decl, String use) {\n+        static IndexList of(int dims) {\n+            List<String> indexNames = IntStream.range(0, dims).mapToObj(i -> \"index\" + i).toList();\n+            String indexDecls = indexNames.stream()\n+                    .map(i -> \"long \" + i)\n+                    .collect(Collectors.joining(\", \"));\n+            String indexUses = indexNames.stream()\n+                    .collect(Collectors.joining(\", \"));\n+            return new IndexList(indexDecls, indexUses);\n+        }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ClassSourceBuilder.java","additions":181,"deletions":197,"binary":false,"changes":378,"status":"modified"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.jextract.impl;\n-\n-import org.openjdk.jextract.Declaration;\n-import java.util.List;\n-import java.util.stream.Stream;\n-import javax.tools.JavaFileObject;\n-\n-public final class CodeGenerator {\n-    private CodeGenerator() {}\n-\n-    public static JavaFileObject[] generate(Declaration.Scoped decl, String headerName,\n-                    String targetPkg, IncludeHelper includeHelper,\n-                    List<String> libNames) {\n-        var nameMangler = new NameMangler(headerName);\n-        var transformedDecl = Stream.of(decl).\n-            map(new IncludeFilter(includeHelper)::transform).\n-            map(new EnumConstantLifter()::transform).\n-            map(new DuplicateFilter()::transform).\n-            map(nameMangler::scan).\n-            findFirst().get();\n-        return OutputFactory.generateWrapped(transformedDecl, targetPkg, libNames, nameMangler);\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/CodeGenerator.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,547 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.jextract.impl;\n-\n-import org.openjdk.jextract.Type;\n-\n-import javax.tools.JavaFileObject;\n-import java.lang.foreign.AddressLayout;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.StructLayout;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.function.Function;\n-\n-public class Constants {\n-\n-    private final Map<Object, Constant> cache = new HashMap<>();\n-\n-    List<Builder> constantBuilders = new ArrayList<>();\n-    Builder currentBuilder;\n-\n-    public Constants(JavaSourceBuilder enclosing) {\n-        currentBuilder = new Builder(enclosing, 0);\n-        constantBuilders.add(currentBuilder);\n-        currentBuilder.classBegin();\n-        \/\/ prime the cache with basic primitive\/pointer (immediate) layouts\n-        for (Type.Primitive.Kind kind : Type.Primitive.Kind.values()) {\n-            kind.layout().ifPresent(layout -> {\n-                if (layout instanceof ValueLayout valueLayout) {\n-                    cache.put(valueLayout, ImmediateConstant.ofPrimitiveLayout(valueLayout));\n-                }\n-            });\n-        }\n-        AddressLayout pointerLayout = ValueLayout.ADDRESS.withTargetLayout(\n-                MemoryLayout.sequenceLayout(Long.MAX_VALUE, ValueLayout.JAVA_BYTE));\n-        cache.put(pointerLayout, ImmediateConstant.ofPrimitiveLayout(pointerLayout));\n-    }\n-\n-    static final int CONSTANTS_PER_CLASS = Integer.getInteger(\"jextract.constants.per.class\", 5);\n-\n-    private Builder builder() {\n-        if (currentBuilder.constantIndex > CONSTANTS_PER_CLASS || currentBuilder == null) {\n-            if (currentBuilder != null) {\n-                currentBuilder.classEnd();\n-            }\n-            currentBuilder = new Builder(currentBuilder.enclosing, constantBuilders.size());\n-            constantBuilders.add(currentBuilder);\n-            currentBuilder.classBegin();\n-        }\n-        return currentBuilder;\n-    }\n-\n-    static sealed abstract class Constant permits Builder.NamedConstant, ImmediateConstant {\n-\n-        final Class<?> type;\n-\n-        public Constant(Class<?> type) {\n-            this.type = type;\n-        }\n-\n-        Class<?> type() {\n-            return type;\n-        }\n-\n-        String getterName(String javaName) {\n-            return javaName + nameSuffix();\n-        }\n-\n-        Constant emitGetter(ClassSourceBuilder builder, String mods, String javaName) {\n-            return emitGetter(builder, mods, c -> c.getterName(javaName));\n-        }\n-\n-        Constant emitGetter(ClassSourceBuilder builder, String mods, String javaName, String symbolName) {\n-            return emitGetter(builder, mods, symbolName, c -> c.getterName(javaName));\n-        }\n-\n-        Constant emitGetter(ClassSourceBuilder builder, String mods, Function<Constant, String> getterNameFunc) {\n-            builder.emitConstantGetter(mods, getterNameFunc.apply(this), false, null, this);\n-            return this;\n-        }\n-\n-        Constant emitGetter(ClassSourceBuilder builder, String mods, String symbolName, Function<Constant, String> getterNameFunc) {\n-            builder.emitConstantGetter(mods, getterNameFunc.apply(this), true, symbolName, this);\n-            return this;\n-        }\n-\n-        String nameSuffix() {\n-            if (type.equals(MemorySegment.class)) {\n-                return \"$SEGMENT\";\n-            } else if (type.equals(MemoryLayout.class)) {\n-                return \"$LAYOUT\";\n-            } else if (type.equals(MethodHandle.class)) {\n-                return \"$MH\";\n-            } else if (type.equals(VarHandle.class)) {\n-                return \"$VH\";\n-            } else if (type.equals(FunctionDescriptor.class)) {\n-                return \"$DESC\";\n-            } else {\n-                return \"\";\n-            }\n-        }\n-\n-        abstract String accessExpression();\n-    }\n-\n-    final static class ImmediateConstant extends Constant {\n-        final String value;\n-\n-        ImmediateConstant(Class<?> type, String value) {\n-            super(type);\n-            this.value = value;\n-        }\n-\n-        @Override\n-        String accessExpression() {\n-            return value;\n-        }\n-\n-        static ImmediateConstant ofPrimitiveLayout(ValueLayout vl) {\n-            final String layoutStr;\n-            if (vl.carrier() == boolean.class) {\n-                layoutStr = \"JAVA_BOOLEAN\";\n-            } else if (vl.carrier() == char.class) {\n-                layoutStr = \"JAVA_CHAR\";\n-            } else if (vl.carrier() == byte.class) {\n-                layoutStr = \"JAVA_BYTE\";\n-            } else if (vl.carrier() == short.class) {\n-                layoutStr = \"JAVA_SHORT\";\n-            } else if (vl.carrier() == int.class) {\n-                layoutStr = \"JAVA_INT\";\n-            } else if (vl.carrier() == float.class) {\n-                layoutStr = \"JAVA_FLOAT\";\n-            } else if (vl.carrier() == long.class) {\n-                layoutStr = \"JAVA_LONG\";\n-            } else if (vl.carrier() == double.class) {\n-                layoutStr = \"JAVA_DOUBLE\";\n-            } else if (vl.carrier() == MemorySegment.class) {\n-                layoutStr = \"RuntimeHelper.POINTER\";\n-            } else {\n-                throw new UnsupportedOperationException(\"Unsupported layout: \" + vl);\n-            }\n-            return new ImmediateConstant(MemoryLayout.class, layoutStr);\n-        }\n-\n-        static Constant ofLiteral(Class<?> type, Object value) {\n-            StringBuilder buf = new StringBuilder();\n-            if (type == float.class) {\n-                float f = ((Number)value).floatValue();\n-                if (Float.isFinite(f)) {\n-                    buf.append(value);\n-                    buf.append(\"f\");\n-                } else {\n-                    buf.append(\"Float.valueOf(\\\"\");\n-                    buf.append(value);\n-                    buf.append(\"\\\")\");\n-                }\n-            } else if (type == long.class) {\n-                buf.append(value.toString());\n-                buf.append(\"L\");\n-            } else if (type == double.class) {\n-                double d = ((Number)value).doubleValue();\n-                if (Double.isFinite(d)) {\n-                    buf.append(value);\n-                    buf.append(\"d\");\n-                } else {\n-                    buf.append(\"Double.valueOf(\\\"\");\n-                    buf.append(value);\n-                    buf.append(\"\\\")\");\n-                }\n-            } else if (type == boolean.class) {\n-                boolean booleanValue = ((Number)value).byteValue() != 0;\n-                buf.append(booleanValue);\n-            } else {\n-                buf.append(\"(\" + type.getName() + \")\");\n-                buf.append(value + \"L\");\n-            }\n-            return new ImmediateConstant(type, buf.toString());\n-        }\n-    }\n-\n-    public List<JavaFileObject> toFiles() {\n-        currentBuilder.classEnd();\n-        List<JavaFileObject> files = new ArrayList<>();\n-        files.addAll(constantBuilders.stream()\n-                .flatMap(b -> b.toFiles().stream()).toList());\n-        return files;\n-    }\n-\n-    class Builder extends ClassSourceBuilder {\n-\n-        Builder(JavaSourceBuilder encl, int id) {\n-            super(encl, Kind.CLASS, \"constants$\" + id);\n-        }\n-\n-        String memberMods() {\n-            return kind == ClassSourceBuilder.Kind.CLASS ?\n-                    \"static final \" : \"\";\n-        }\n-\n-        @Override\n-        String mods() {\n-            return \"final \"; \/\/ constants package-private!\n-        }\n-\n-        int constantIndex = 0;\n-\n-        final class NamedConstant extends Constant {\n-            final String constantName;\n-\n-            NamedConstant(Class<?> type) {\n-                super(type);\n-                this.constantName = newConstantName();\n-            }\n-\n-            String constantName() {\n-                return constantName;\n-            }\n-\n-            @Override\n-            String accessExpression() {\n-                return className() + \".\" + constantName;\n-            }\n-        }\n-\n-        private Constant emitDowncallMethodHandleField(String nativeName, FunctionDescriptor descriptor, boolean isVarargs, boolean virtual) {\n-            Constant functionDesc = addFunctionDesc(descriptor);\n-            incrAlign();\n-            NamedConstant mhConst = new NamedConstant(MethodHandle.class);\n-            indent();\n-            append(memberMods() + \"MethodHandle \");\n-            append(mhConst.constantName + \" = RuntimeHelper.\");\n-            if (isVarargs) {\n-                append(\"downcallHandleVariadic\");\n-            } else {\n-                append(\"downcallHandle\");\n-            }\n-            append(\"(\\n\");\n-            incrAlign();\n-            indent();\n-            if (!virtual) {\n-                append(\"\\\"\" + nativeName + \"\\\"\");\n-                append(\",\\n\");\n-                indent();\n-            }\n-            append(functionDesc.accessExpression());\n-            append(\"\\n\");\n-            decrAlign();\n-            indent();\n-            append(\");\\n\");\n-            decrAlign();\n-            return mhConst;\n-        }\n-\n-        private Constant emitUpcallMethodHandleField(String className, String methodName, FunctionDescriptor descriptor) {\n-            Constant functionDesc = addFunctionDesc(descriptor);\n-            incrAlign();\n-            NamedConstant mhConst = new NamedConstant(MethodHandle.class);\n-            indent();\n-            append(memberMods() + \"MethodHandle \");\n-            append(mhConst.constantName + \" = RuntimeHelper.upcallHandle(\");\n-            append(className + \".class, \");\n-            append(\"\\\"\" + methodName + \"\\\", \");\n-            append(functionDesc.accessExpression());\n-            append(\");\\n\");\n-            decrAlign();\n-            return mhConst;\n-        }\n-\n-        private Constant emitVarHandle(ValueLayout valueLayout) {\n-            Constant layoutConstant = addLayout(valueLayout);\n-            incrAlign();\n-            indent();\n-            NamedConstant vhConst = new NamedConstant(VarHandle.class);\n-            append(memberMods() + \"VarHandle \" + vhConst.constantName + \" = \");\n-            append(layoutConstant.accessExpression());\n-            append(\".varHandle();\\n\");\n-            decrAlign();\n-            return vhConst;\n-        }\n-\n-        private Constant emitFieldVarHandle(String nativeName, GroupLayout parentLayout, List<String> prefixElementNames) {\n-            Constant layoutConstant = addLayout(parentLayout);\n-            incrAlign();\n-            indent();\n-            NamedConstant vhConst = new NamedConstant(VarHandle.class);\n-            append(memberMods() + \"VarHandle \" + vhConst.constantName + \" = \");\n-            append(layoutConstant.accessExpression());\n-            append(\".varHandle(\");\n-            String prefix = \"\";\n-            for (String prefixElementName : prefixElementNames) {\n-                append(prefix + \"MemoryLayout.PathElement.groupElement(\\\"\" + prefixElementName + \"\\\")\");\n-                prefix = \", \";\n-            }\n-            append(prefix + \"MemoryLayout.PathElement.groupElement(\\\"\" + nativeName + \"\\\")\");\n-            append(\")\");\n-            append(\";\\n\");\n-            decrAlign();\n-            return vhConst;\n-        }\n-\n-        private Constant emitLayoutField(MemoryLayout layout) {\n-            NamedConstant layoutConst = new NamedConstant(MemoryLayout.class);\n-            incrAlign();\n-            indent();\n-            String layoutClassName = Utils.layoutDeclarationType(layout).getSimpleName();\n-            append(memberMods() + layoutClassName + \" \" + layoutConst.constantName + \" = \");\n-            emitLayoutString(layout);\n-            append(\";\\n\");\n-            decrAlign();\n-            return layoutConst;\n-        }\n-\n-        private void emitLayoutString(MemoryLayout l) {\n-            if (l instanceof ValueLayout val) {\n-                append(ImmediateConstant.ofPrimitiveLayout(val).accessExpression());\n-                if (l.byteAlignment() != l.byteSize()) {\n-                    append(\".withByteAlignment(\");\n-                    append(l.byteAlignment());\n-                    append(\")\");\n-                }\n-            } else if (l instanceof SequenceLayout seq) {\n-                append(\"MemoryLayout.sequenceLayout(\");\n-                append(seq.elementCount() + \", \");\n-                emitLayoutString(seq.elementLayout());\n-                append(\")\");\n-            } else if (l instanceof GroupLayout group) {\n-                if (group instanceof StructLayout) {\n-                    append(\"MemoryLayout.structLayout(\\n\");\n-                } else {\n-                    append(\"MemoryLayout.unionLayout(\\n\");\n-                }\n-                incrAlign();\n-                String delim = \"\";\n-                for (MemoryLayout e : group.memberLayouts()) {\n-                    append(delim);\n-                    indent();\n-                    emitLayoutString(e);\n-                    delim = \",\\n\";\n-                }\n-                append(\"\\n\");\n-                decrAlign();\n-                indent();\n-                append(\")\");\n-            } else {\n-                \/\/ padding (or unsupported)\n-                append(\"MemoryLayout.paddingLayout(\" + l.byteSize() + \")\");\n-            }\n-            if (l.name().isPresent()) {\n-                append(\".withName(\\\"\" +  l.name().get() + \"\\\")\");\n-            }\n-        }\n-\n-        private Constant emitFunctionDescField(FunctionDescriptor desc) {\n-            incrAlign();\n-            indent();\n-            final boolean noArgs = desc.argumentLayouts().isEmpty();\n-            append(memberMods());\n-            append(\"FunctionDescriptor \");\n-            NamedConstant descConstant = new NamedConstant(FunctionDescriptor.class);\n-            append(descConstant.constantName);\n-            append(\" = \");\n-            if (desc.returnLayout().isPresent()) {\n-                append(\"FunctionDescriptor.of(\");\n-                emitLayoutString(desc.returnLayout().get());\n-                if (!noArgs) {\n-                    append(\",\");\n-                }\n-            } else {\n-                append(\"FunctionDescriptor.ofVoid(\");\n-            }\n-            if (!noArgs) {\n-                append(\"\\n\");\n-                incrAlign();\n-                String delim = \"\";\n-                for (MemoryLayout e : desc.argumentLayouts()) {\n-                    append(delim);\n-                    indent();\n-                    emitLayoutString(e);\n-                    delim = \",\\n\";\n-                }\n-                append(\"\\n\");\n-                decrAlign();\n-                indent();\n-            }\n-            append(\");\\n\");\n-            decrAlign();\n-            return descConstant;\n-        }\n-\n-        private Constant emitConstantString(Object value) {\n-            incrAlign();\n-            indent();\n-            append(memberMods());\n-            append(\"MemorySegment \");\n-            NamedConstant segConstant = new NamedConstant(MemorySegment.class);\n-            append(segConstant.constantName);\n-            append(\" = RuntimeHelper.CONSTANT_ALLOCATOR.allocateFrom(\\\"\");\n-            append(Utils.quote(Objects.toString(value)));\n-            append(\"\\\");\\n\");\n-            decrAlign();\n-            return segConstant;\n-        }\n-\n-        private Constant emitConstantAddress(Object value) {\n-            incrAlign();\n-            indent();\n-            append(memberMods());\n-            append(\"MemorySegment \");\n-            NamedConstant segConstant = new NamedConstant(MemorySegment.class);\n-            append(segConstant.constantName);\n-            append(\" = MemorySegment.ofAddress(\");\n-            append(((Number)value).longValue());\n-            append(\"L);\\n\");\n-            decrAlign();\n-            return segConstant;\n-        }\n-\n-        private Constant emitSegmentField(String nativeName, MemoryLayout layout) {\n-            Constant layoutConstant = addLayout(layout);\n-            incrAlign();\n-            indent();\n-            append(memberMods());\n-            append(\"MemorySegment \");\n-            NamedConstant segConstant = new NamedConstant(MemorySegment.class);\n-            append(segConstant.constantName);\n-            append(\" = \");\n-            append(\"RuntimeHelper.lookupGlobalVariable(\");\n-            append(\"\\\"\" + nativeName + \"\\\", \");\n-            append(layoutConstant.accessExpression());\n-            append(\");\\n\");\n-            decrAlign();\n-            return segConstant;\n-        }\n-\n-        String newConstantName() {\n-            return \"const$\" + constantIndex++;\n-        }\n-    }\n-\n-    \/\/ public API\n-\n-    public Constant addLayout(MemoryLayout layout) {\n-        Constant constant = cache.get(layout);\n-        if (constant == null) {\n-            constant = builder().emitLayoutField(layout);\n-            cache.put(layout, constant);\n-        }\n-        return constant;\n-    }\n-\n-    public Constant addFieldVarHandle(String nativeName, GroupLayout parentLayout, List<String> prefixElementNames) {\n-        return builder().emitFieldVarHandle(nativeName, parentLayout, prefixElementNames);\n-    }\n-\n-    public Constant addGlobalVarHandle(ValueLayout valueLayout) {\n-        record VarHandleKey(ValueLayout valueLayout) { }\n-        VarHandleKey key = new VarHandleKey(valueLayout.withoutName());\n-        Constant constant = cache.get(key);\n-        if (constant == null) {\n-            constant = builder().emitVarHandle(valueLayout);\n-            cache.put(key, constant);\n-        }\n-        return constant;\n-    }\n-\n-    public Constant addDowncallMethodHandle(String nativeName, FunctionDescriptor descriptor, boolean isVarargs) {\n-        return builder().emitDowncallMethodHandleField(nativeName, descriptor, isVarargs, false);\n-    }\n-\n-    public Constant addVirtualDowncallMethodHandle(FunctionDescriptor descriptor) {\n-        record DowncallKey(FunctionDescriptor desc) { }\n-        DowncallKey downcallKey = new DowncallKey(descriptor);\n-        Constant constant = cache.get(downcallKey);\n-        if (constant == null) {\n-            constant = builder().emitDowncallMethodHandleField(null, descriptor, false, true);\n-            cache.put(downcallKey, constant);\n-        }\n-        return constant;\n-    }\n-\n-    public Constant addUpcallMethodHandle(String className, String name, FunctionDescriptor descriptor) {\n-        return builder().emitUpcallMethodHandleField(className, name, descriptor);\n-    }\n-\n-    public Constant addSegment(String nativeName, MemoryLayout layout) {\n-        return builder().emitSegmentField(nativeName, layout);\n-    }\n-\n-    public Constant addFunctionDesc(FunctionDescriptor desc) {\n-        Constant constant = cache.get(desc);\n-        if (constant == null) {\n-            constant = builder().emitFunctionDescField(desc);\n-            cache.put(desc, constant);\n-        }\n-        return constant;\n-    }\n-\n-    public Constant addConstantDesc(Class<?> type, Object value) {\n-        record ConstantKey(Class<?> type, Object value) { }\n-        var key = new ConstantKey(type, value);\n-        Constant constant = cache.get(key);\n-        if (constant == null) {\n-            if (value instanceof String) {\n-                constant = builder().emitConstantString(value);\n-            } else if (type == MemorySegment.class) {\n-                constant = builder().emitConstantAddress(value);\n-            } else {\n-                constant = ImmediateConstant.ofLiteral(type, value);\n-            }\n-            cache.put(key, constant);\n-        }\n-        return constant;\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Constants.java","additions":0,"deletions":547,"binary":false,"changes":547,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,1 @@\n-import java.lang.constant.Constable;\n-import java.util.Collections;\n+import java.util.Collection;\n@@ -36,2 +35,2 @@\n-import java.util.Set;\n-import java.lang.foreign.MemoryLayout;\n+import java.util.OptionalLong;\n+\n@@ -46,1 +45,1 @@\n-    private final Optional<Map<String, List<Constable>>> attributes;\n+    private final Map<Class<?>, Record> attributes = new HashMap<>();\n@@ -48,1 +47,1 @@\n-    public DeclarationImpl(String name, Position pos, Map<String, List<Constable>> attrs) {\n+    DeclarationImpl(String name, Position pos) {\n@@ -51,1 +50,0 @@\n-        this.attributes = Optional.ofNullable(attrs);\n@@ -68,2 +66,7 @@\n-    public Optional<List<Constable>> getAttribute(String name) {\n-        return attributes.map(attrs -> attrs.get(name));\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        return o instanceof Declaration decl &&\n+                name().equals(decl.name()) &&\n+                attributes.equals(decl.attributes());\n@@ -73,2 +76,2 @@\n-    public Set<String> attributeNames() { return Collections.unmodifiableSet(\n-            attributes.map(Map::keySet).orElse(Collections.emptySet()));\n+    public int hashCode() {\n+        return Objects.hash(name, attributes);\n@@ -78,7 +81,2 @@\n-    public Declaration withAttribute(String name, Constable... values) {\n-        if (values == null || values.length == 0) {\n-            return withAttributes(null);\n-        }\n-        var attrs = attributes.map(HashMap::new).orElseGet(HashMap::new);\n-        attrs.put(name, List.of(values));\n-        return withAttributes(attrs);\n+    public Collection<Record> attributes() {\n+        return attributes.values();\n@@ -87,2 +85,0 @@\n-    abstract protected Declaration withAttributes(Map<String, List<Constable>> attrs);\n-\n@@ -90,5 +86,3 @@\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        return o instanceof Declaration decl && name().equals(decl.name());\n+    @SuppressWarnings(\"unchecked\")\n+    public <R extends Record> Optional<R> getAttribute(Class<R> attributeClass) {\n+        return Optional.ofNullable((R)attributes.get(attributeClass));\n@@ -98,2 +92,6 @@\n-    public int hashCode() {\n-        return Objects.hash(name);\n+    public <R extends Record> void addAttribute(R attribute) {\n+        Record attr = attributes.get(attribute.getClass());\n+        if (attr != null && !attr.equals(attribute)) {\n+            throw new IllegalStateException(\"Attribute already exists: \" + attribute.getClass().getSimpleName());\n+        }\n+        attributes.put(attribute.getClass(), attribute);\n@@ -105,2 +103,2 @@\n-        public TypedefImpl(Type type, String name, Position pos, Map<String, List<Constable>> attrs) {\n-            super(name, pos, attrs);\n+        public TypedefImpl(Type type, String name, Position pos) {\n+            super(name, pos);\n@@ -120,10 +118,0 @@\n-        @Override\n-        public Typedef withAttributes(Map<String, List<Constable>> attrs) {\n-            return new TypedefImpl(type, name(), pos(), attrs);\n-        }\n-\n-        @Override\n-        public Typedef stripAttributes() {\n-            return new TypedefImpl(type, name(), pos(), null);\n-        }\n-\n@@ -134,1 +122,1 @@\n-                    name().equals(other.name()) &&\n+                    super.equals(other) &&\n@@ -148,1 +136,0 @@\n-        final Optional<MemoryLayout> layout;\n@@ -150,2 +137,2 @@\n-        private VariableImpl(Type type, Optional<MemoryLayout> layout, Variable.Kind kind, String name, Position pos, Map<String, List<Constable>> attrs) {\n-            super(name, pos, attrs);\n+        public VariableImpl(Type type, Variable.Kind kind, String name, Position pos) {\n+            super(name, pos);\n@@ -154,9 +141,0 @@\n-            this.layout = Objects.requireNonNull(layout);\n-        }\n-\n-        public VariableImpl(Type type, Variable.Kind kind, String name, Position pos) {\n-            this(type, TypeImpl.getLayout(type), kind, name, pos, null);\n-        }\n-\n-        public VariableImpl(Type type, MemoryLayout layout, Variable.Kind kind, String name, Position pos) {\n-            this(type, Optional.of(layout), kind, name, pos, null);\n@@ -180,10 +158,0 @@\n-        @Override\n-        public Variable withAttributes(Map<String, List<Constable>> attrs) {\n-            return new VariableImpl(type, layout, kind, name(), pos(), attrs);\n-        }\n-\n-        @Override\n-        public Variable stripAttributes() {\n-            return new VariableImpl(type, layout, kind, name(), pos(), null);\n-        }\n-\n@@ -193,3 +161,3 @@\n-            if (!(o instanceof Declaration.Variable variable)) return false;\n-            if (!super.equals(o)) return false;\n-            return kind == variable.kind() &&\n+            return o instanceof Declaration.Variable variable &&\n+                    super.equals(o) &&\n+                    kind == variable.kind() &&\n@@ -207,1 +175,0 @@\n-        final long offset;\n@@ -210,3 +177,2 @@\n-        private BitfieldImpl(Type type, long offset, long width, String name, Position pos, Map<String, List<Constable>> attrs) {\n-            super(type, Optional.<MemoryLayout>empty(), Kind.BITFIELD, name, pos, attrs);\n-            this.offset = offset;\n+        public BitfieldImpl(Type type, long width, String name, Position pos) {\n+            super(type, Kind.BITFIELD, name, pos);\n@@ -216,9 +182,0 @@\n-        public BitfieldImpl(Type type, long offset, long width, String name, Position pos) {\n-            this(type, offset, width, name, pos, null);\n-        }\n-\n-        @Override\n-        public long offset() {\n-            return offset;\n-        }\n-\n@@ -230,10 +187,0 @@\n-        @Override\n-        public Variable withAttributes(Map<String, List<Constable>> attrs) {\n-            return new BitfieldImpl(type, offset, width, name(), pos(), attrs);\n-        }\n-\n-        @Override\n-        public Variable stripAttributes() {\n-            return new BitfieldImpl(type, offset, width, name(), pos(), null);\n-        }\n-\n@@ -243,4 +190,3 @@\n-            if (!(o instanceof BitfieldImpl bitfield)) return false;\n-            if (!super.equals(o)) return false;\n-            return offset == bitfield.offset &&\n-                    width == bitfield.width;\n+            return o instanceof Declaration.Bitfield bitfield &&\n+                    super.equals(o) &&\n+                    width == bitfield.width();\n@@ -251,1 +197,1 @@\n-            return Objects.hash(super.hashCode(), offset, width);\n+            return Objects.hash(super.hashCode(), width);\n@@ -261,5 +207,1 @@\n-            this(type, params, name, pos, null);\n-        }\n-\n-        public FunctionImpl(Type.Function type, List<Variable> params, String name, Position pos, Map<String, List<Constable>> attrs) {\n-            super(name, pos, attrs);\n+            super(name, pos);\n@@ -285,10 +227,0 @@\n-        @Override\n-        public Function withAttributes(Map<String, List<Constable>> attrs) {\n-            return new FunctionImpl(type, params, name(), pos(), attrs);\n-        }\n-\n-        @Override\n-        public Function stripAttributes() {\n-            return new FunctionImpl(type, params, name(), pos(), null);\n-        }\n-\n@@ -298,3 +230,4 @@\n-            if (!(o instanceof Declaration.Function function)) return false;\n-            if (!super.equals(o)) return false;\n-            return type.equals(function.type());\n+            return o instanceof Declaration.Function function &&\n+                    super.equals(o) &&\n+                    params.equals(function.parameters()) &&\n+                    type.equals(function.type());\n@@ -305,1 +238,1 @@\n-            return Objects.hash(super.hashCode(), type);\n+            return Objects.hash(super.hashCode(), params, type);\n@@ -313,5 +246,0 @@\n-        private final Optional<MemoryLayout> optLayout;\n-\n-        public ScopedImpl(Kind kind, MemoryLayout layout, List<Declaration> declarations, String name, Position pos) {\n-            this(kind, Optional.of(layout), declarations, name, pos, null);\n-        }\n@@ -320,6 +248,1 @@\n-            this(kind, Optional.empty(), declarations, name, pos, null);\n-        }\n-\n-        ScopedImpl(Kind kind, Optional<MemoryLayout> optLayout, List<Declaration> declarations,\n-                String name, Position pos, Map<String, List<Constable>> attrs) {\n-            super(name, pos, attrs);\n+            super(name, pos);\n@@ -328,1 +251,0 @@\n-            this.optLayout = Objects.requireNonNull(optLayout);\n@@ -341,5 +263,0 @@\n-        @Override\n-        public Optional<MemoryLayout> layout() {\n-            return optLayout;\n-        }\n-\n@@ -351,10 +268,0 @@\n-        @Override\n-        public Scoped withAttributes(Map<String, List<Constable>> attrs) {\n-            return new ScopedImpl(kind, optLayout, declarations, name(), pos(), attrs);\n-        }\n-\n-        @Override\n-        public Scoped stripAttributes() {\n-            return new ScopedImpl(kind, optLayout, declarations, name(), pos(), null);\n-        }\n-\n@@ -364,3 +271,3 @@\n-            if (!(o instanceof Declaration.Scoped scoped)) return false;\n-            if (!super.equals(o)) return false;\n-            return kind == scoped.kind() &&\n+            return o instanceof Declaration.Scoped scoped &&\n+                    super.equals(o) &&\n+                    kind == scoped.kind() &&\n@@ -382,5 +289,1 @@\n-            this(type, value, name, pos, null);\n-        }\n-\n-        public ConstantImpl(Type type, Object value, String name, Position pos, Map<String, List<Constable>> attrs) {\n-            super(name, pos, attrs);\n+            super(name, pos);\n@@ -406,10 +309,0 @@\n-        @Override\n-        public Constant withAttributes(Map<String, List<Constable>> attrs) {\n-            return new ConstantImpl(type, value, name(), pos(), attrs);\n-        }\n-\n-        @Override\n-        public Constant stripAttributes() {\n-            return new ConstantImpl(type, value, name(), pos(), null);\n-        }\n-\n@@ -419,3 +312,3 @@\n-            if (!(o instanceof Declaration.Constant constant)) return false;\n-            if (!super.equals(o)) return false;\n-            return value.equals(constant.value()) &&\n+            return o instanceof Declaration.Constant constant &&\n+                    super.equals(o) &&\n+                    value == constant.value() &&\n@@ -430,0 +323,168 @@\n+\n+    \/\/ attributes\n+\n+    \/**\n+     * An attribute to mark anonymous struct declarations.\n+     *\/\n+    record AnonymousStruct(OptionalLong offset) {\n+        public static void with(Scoped scoped, OptionalLong offset) {\n+            scoped.addAttribute(new AnonymousStruct(offset));\n+        }\n+\n+        public static AnonymousStruct getOrThrow(Scoped scoped) {\n+            return scoped.getAttribute(AnonymousStruct.class).orElseThrow();\n+        }\n+\n+        public static boolean isPresent(Scoped scoped) {\n+            return scoped.getAttribute(AnonymousStruct.class).isPresent();\n+        }\n+\n+        public static String anonName(Scoped scoped) {\n+            return \"$anon$\" + scoped.pos().line() + \":\" + scoped.pos().col();\n+        }\n+    }\n+\n+    \/**\n+     * An attribute to mark enum constants, with a link to the name of their parent enum.\n+     *\/\n+    record EnumConstant(String get) {\n+        public static void with(Constant constant, String enumName) {\n+            constant.addAttribute(new EnumConstant(enumName));\n+        }\n+\n+        public static Optional<String> get(Constant constant) {\n+            return constant.getAttribute(EnumConstant.class)\n+                    .map(EnumConstant::get);\n+        }\n+    }\n+\n+    \/**\n+     * An attribute to mark declaration for which no code should be generated.\n+     *\/\n+    record Skip() {\n+        private static final Skip INSTANCE = new Skip();\n+\n+        public static void with(Declaration declaration) {\n+            declaration.addAttribute(INSTANCE);\n+        }\n+\n+        public static boolean isPresent(Declaration declaration) {\n+            return declaration.getAttribute(Skip.class).isPresent();\n+        }\n+    }\n+\n+    \/**\n+     * An attribute to attach a Java name to a C declaration.\n+     *\/\n+    record JavaName(List<String> names) {\n+        public static void with(Declaration declaration, List<String> names) {\n+            declaration.addAttribute(new JavaName(names));\n+        }\n+\n+        public static String getOrThrow(Declaration declaration) {\n+            return declaration.getAttribute(JavaName.class)\n+                    .map(javaName -> javaName.names.getLast()).get();\n+        }\n+\n+        public static String getFullNameOrThrow(Declaration declaration) {\n+            return declaration.getAttribute(JavaName.class)\n+                    .map(javaName -> String.join(\".\", javaName.names)).get();\n+        }\n+\n+        public static boolean isPresent(Declaration declaration) {\n+            return declaration.getAttribute(JavaName.class).isPresent();\n+        }\n+    }\n+\n+    \/**\n+     * An attribute to attach a Java functional interface name to a C declaration.\n+     *\/\n+    record JavaFunctionalInterfaceName(String fiName) {\n+        public static void with(Declaration declaration, String fiName) {\n+            declaration.addAttribute(new JavaFunctionalInterfaceName(fiName));\n+        }\n+\n+        public static String getOrThrow(Declaration declaration) {\n+            return declaration.getAttribute(JavaFunctionalInterfaceName.class)\n+                    .map(JavaFunctionalInterfaceName::fiName).get();\n+        }\n+    }\n+\n+    record ClangAlignOf(long align) {\n+        public static void with(Declaration declaration, long align) {\n+            declaration.addAttribute(new ClangAlignOf(align));\n+        }\n+\n+        public static OptionalLong get(Declaration declaration) {\n+            return declaration.getAttribute(ClangAlignOf.class)\n+                    .stream().mapToLong(ClangAlignOf::align).findFirst();\n+        }\n+\n+        public static long getOrThrow(Declaration declaration) {\n+            return declaration.getAttribute(ClangAlignOf.class)\n+                    .stream().mapToLong(ClangAlignOf::align).findFirst().getAsLong();\n+        }\n+    }\n+\n+    record ClangSizeOf(long size) {\n+        public static void with(Declaration declaration, long size) {\n+            declaration.addAttribute(new ClangSizeOf(size));\n+        }\n+\n+        public static OptionalLong get(Declaration declaration) {\n+            return declaration.getAttribute(ClangSizeOf.class)\n+                    .stream().mapToLong(ClangSizeOf::size).findFirst();\n+        }\n+\n+        public static long getOrThrow(Declaration declaration) {\n+            return declaration.getAttribute(ClangSizeOf.class)\n+                    .stream().mapToLong(ClangSizeOf::size).findFirst().getAsLong();\n+        }\n+    }\n+\n+    record ClangOffsetOf(long offset) {\n+        public static void with(Declaration declaration, long size) {\n+            declaration.addAttribute(new ClangOffsetOf(size));\n+        }\n+\n+        public static OptionalLong get(Declaration declaration) {\n+            return declaration.getAttribute(ClangOffsetOf.class)\n+                    .stream().mapToLong(ClangOffsetOf::offset).findFirst();\n+        }\n+\n+        public static long getOrThrow(Declaration declaration) {\n+            return declaration.getAttribute(ClangOffsetOf.class)\n+                    .stream().mapToLong(ClangOffsetOf::offset).findFirst().getAsLong();\n+        }\n+    }\n+\n+    \/**\n+     * An attribute to attach nested struct\/union\/enum declarations to other declarations.\n+     *\/\n+    record NestedDeclarations(List<Scoped> nestedDeclarations) {\n+\n+        public static void with(Declaration declaration, List<Scoped> nestedDeclarations) {\n+            declaration.addAttribute(new NestedDeclarations(nestedDeclarations));\n+        }\n+\n+        public static Optional<List<Scoped>> get(Declaration declaration) {\n+            return declaration.getAttribute(NestedDeclarations.class)\n+                    .stream().map(NestedDeclarations::nestedDeclarations).findFirst();\n+        }\n+    }\n+\n+    record DeclarationString(String declString) {\n+        public static void with(Declaration declaration, String declString) {\n+            declaration.addAttribute(new DeclarationString(declString));\n+        }\n+\n+        public static Optional<String> get(Declaration declaration) {\n+            return declaration.getAttribute(DeclarationString.class)\n+                    .stream().map(DeclarationString::declString).findFirst();\n+        }\n+\n+        public static String getOrThrow(Declaration declaration) {\n+            return declaration.getAttribute(DeclarationString.class)\n+                    .stream().map(DeclarationString::declString).findFirst().get();\n+        }\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/DeclarationImpl.java","additions":222,"deletions":161,"binary":false,"changes":383,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.Skip;\n+\n@@ -36,1 +38,1 @@\n-final class DuplicateFilter implements TreeTransformer, Declaration.Visitor<Void, Void> {\n+public final class DuplicateFilter implements Declaration.Visitor<Void, Void> {\n@@ -40,3 +42,2 @@\n-    private final Set<Declaration.Typedef> typedefs = new HashSet<>();\n-    private final Set<Declaration.Function> functions = new HashSet<>();\n-    private final List<Declaration> decls = new ArrayList<>();\n+    private final Set<String> typedefs = new HashSet<>();\n+    private final Set<String> functions = new HashSet<>();\n@@ -56,1 +57,1 @@\n-        return !functions.add(tree);\n+        return !functions.add(tree.name());\n@@ -61,1 +62,1 @@\n-        return !typedefs.add(tree);\n+        return !typedefs.add(tree.name());\n@@ -64,1 +65,1 @@\n-    DuplicateFilter() {\n+    public DuplicateFilter() {\n@@ -67,2 +68,1 @@\n-    @Override\n-    public Declaration.Scoped transform(Declaration.Scoped header) {\n+    public Declaration.Scoped scan(Declaration.Scoped header) {\n@@ -73,1 +73,1 @@\n-        return createHeader(header, decls);\n+        return header;\n@@ -80,1 +80,1 @@\n-            return null;\n+            Skip.with(constant);\n@@ -82,2 +82,0 @@\n-\n-        decls.add(constant);\n@@ -91,1 +89,1 @@\n-            return null;\n+            Skip.with(funcTree);\n@@ -93,2 +91,0 @@\n-\n-        decls.add(funcTree);\n@@ -102,1 +98,1 @@\n-            return null;\n+            Skip.with(tree);\n@@ -104,2 +100,0 @@\n-\n-        decls.add(tree);\n@@ -113,1 +107,1 @@\n-            return null;\n+            Skip.with(tree);\n@@ -115,0 +109,2 @@\n+        return null;\n+    }\n@@ -116,1 +112,6 @@\n-        decls.add(tree);\n+    @java.lang.Override\n+    public Void visitScoped(Declaration.Scoped d, Void aVoid) {\n+        if (Utils.isEnum(d)) {\n+            \/\/ enum constants might clash with macro constants with same name\n+            d.members().forEach(m -> m.accept(this, null));\n+        }\n@@ -122,1 +123,0 @@\n-        decls.add(decl);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/DuplicateFilter.java","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.jextract.impl;\n-\n-import org.openjdk.jextract.Declaration;\n-import org.openjdk.jextract.Type;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-\n-\/*\n- * This visitor lifts enum constants to the top level and removes enum Trees.\n- *\/\n-final class EnumConstantLifter implements TreeTransformer, Declaration.Visitor<Void, Void> {\n-    private static final String ENUM_NAME = \"enum-name\";\n-\n-    private final List<Declaration> decls = new ArrayList<>();\n-    EnumConstantLifter() {\n-    }\n-\n-    static Optional<String> enumName(Declaration.Constant constant) {\n-        return constant.getAttribute(ENUM_NAME).map(attrs -> attrs.get(0).toString());\n-    }\n-\n-    @Override\n-    public Declaration.Scoped transform(Declaration.Scoped header) {\n-        \/\/ Process all header declarations are collect potential\n-        \/\/ declarations that will go into transformed HeaderTree\n-        \/\/ into the this.decls field.\n-        header.members().forEach(fieldTree -> fieldTree.accept(this, null));\n-        return createHeader(header, decls);\n-    }\n-\n-    @Override\n-    public Void visitScoped(Declaration.Scoped scoped, Void ignored) {\n-        if (liftEnumConstants(scoped)) {\n-            return null;\n-        }\n-        decls.add(scoped);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitTypedef(Declaration.Typedef tree, Void ignored) {\n-        Type type = tree.type();\n-        if (type instanceof Type.Declared declared) {\n-            if (liftEnumConstants(declared.tree())) {\n-                return null;\n-            }\n-        }\n-        decls.add(tree);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitDeclaration(Declaration decl, Void ignored) {\n-        decls.add(decl);\n-        return null;\n-    }\n-\n-    private boolean liftEnumConstants(Declaration.Scoped scoped) {\n-        boolean isEnum = scoped.kind() == Declaration.Scoped.Kind.ENUM;\n-        if (isEnum) {\n-            \/\/ add the name of the enum as an attribute.\n-            scoped.members().forEach(fieldTree -> fieldTree\n-                .withAttribute(ENUM_NAME, scoped.name())\n-                .accept(this, null));\n-        }\n-        return isEnum;\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/EnumConstantLifter.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,1 @@\n-import java.lang.foreign.*;\n-\n-import org.openjdk.jextract.impl.Constants.Constant;\n+import org.openjdk.jextract.Declaration;\n@@ -39,3 +37,1 @@\n-public class FunctionalInterfaceBuilder extends ClassSourceBuilder {\n-\n-    private static final String MEMBER_MODS = \"static\";\n+final class FunctionalInterfaceBuilder extends ClassSourceBuilder {\n@@ -44,3 +40,1 @@\n-    private final MethodType fiType;\n-    private final MethodType downcallType;\n-    private final FunctionDescriptor fiDesc;\n+    private final MethodType methodType;\n@@ -49,3 +43,4 @@\n-    FunctionalInterfaceBuilder(JavaSourceBuilder enclosing, Type.Function funcType, String className,\n-                               FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n-        super(enclosing, Kind.INTERFACE, className);\n+    private FunctionalInterfaceBuilder(SourceFileBuilder builder, String className, ClassSourceBuilder enclosing,\n+                                       String runtimeHelperName, Type.Function funcType) {\n+        super(builder, \"public\", Kind.CLASS, className, null, enclosing, runtimeHelperName);\n+        this.parameterNames = funcType.parameterNames().map(NameMangler::javaSafeIdentifiers);\n@@ -53,4 +48,1 @@\n-        this.fiType = descriptor.toMethodType();\n-        this.downcallType = descriptor.toMethodType();\n-        this.fiDesc = descriptor;\n-        this.parameterNames = parameterNames;\n+        this.methodType = Utils.methodTypeFor(funcType);\n@@ -59,3 +51,12 @@\n-    @Override\n-    void classDeclBegin() {\n-        emitDocComment(funcType, className());\n+    public static void generate(SourceFileBuilder builder, String className, ClassSourceBuilder enclosing, String runtimeHelperName,\n+                                Declaration parentDecl, Type.Function funcType) {\n+        FunctionalInterfaceBuilder fib = new FunctionalInterfaceBuilder(builder, className,\n+                enclosing, runtimeHelperName, funcType);\n+        fib.appendBlankLine();\n+        fib.emitDocComment(parentDecl);\n+        fib.classBegin();\n+        fib.emitFunctionalInterface();\n+        fib.emitDescriptorDecl();\n+        fib.emitFunctionalFactory();\n+        fib.emitInvoke();\n+        fib.classEnd();\n@@ -64,6 +65,47 @@\n-    @Override\n-    JavaSourceBuilder classEnd() {\n-        emitFunctionalInterfaceMethod();\n-        emitFunctionalFactories();\n-        emitFunctionalFactoryForPointer();\n-        return super.classEnd();\n+    private void emitFunctionalInterface() {\n+        appendIndentedLines(STR.\"\"\"\n+\n+            \/**\n+             * The function pointer signature, expressed as a functional interface\n+             *\/\n+            public interface Function {\n+                \\{methodType.returnType().getSimpleName()} apply(\\{paramExprs()});\n+            }\n+            \"\"\");\n+    }\n+\n+    private void emitFunctionalFactory() {\n+        appendIndentedLines(STR.\"\"\"\n+\n+            private static final MethodHandle UP$MH = \\{runtimeHelperName()}.upcallHandle(\\{className()}.Function.class, \"apply\", $DESC);\n+\n+            \/**\n+             * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+             * The lifetime of the returned segment is managed by {@code arena}\n+             *\/\n+            public static MemorySegment allocate(\\{className()}.Function fi, Arena arena) {\n+                return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+            }\n+            \"\"\");\n+    }\n+\n+    private void emitInvoke() {\n+        boolean needsAllocator = Utils.isStructOrUnion(funcType.returnType());\n+        String allocParam = needsAllocator ? \", SegmentAllocator alloc\" : \"\";\n+        String allocArg = needsAllocator ? \", alloc\" : \"\";\n+        String paramStr = methodType.parameterCount() != 0 ? STR.\",\\{paramExprs()}\" : \"\";\n+        appendIndentedLines(STR.\"\"\"\n+\n+            private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+            \/**\n+             * Invoke the upcall stub {@code funcPtr}, with given parameters\n+             *\/\n+            public static \\{methodType.returnType().getSimpleName()} invoke(MemorySegment funcPtr\\{allocParam}\\{paramStr}) {\n+                try {\n+                    \\{retExpr()} DOWN$MH.invokeExact(funcPtr\\{allocArg}\\{otherArgExprs()});\n+                } catch (Throwable ex$) {\n+                    throw new AssertionError(\"should not reach here\", ex$);\n+                }\n+            }\n+            \"\"\");\n@@ -81,4 +123,2 @@\n-    private void emitFunctionalInterfaceMethod() {\n-        incrAlign();\n-        indent();\n-        append(fiType.returnType().getName() + \" apply(\");\n+    private String paramExprs() {\n+        StringBuilder result = new StringBuilder();\n@@ -86,4 +126,4 @@\n-        for (int i = 0 ; i < fiType.parameterCount(); i++) {\n-            append(delim + fiType.parameterType(i).getName());\n-            append(\" \");\n-            append(parameterName(i));\n+        for (int i = 0 ; i < methodType.parameterCount(); i++) {\n+            result.append(delim).append(methodType.parameterType(i).getSimpleName());\n+            result.append(\" \");\n+            result.append(parameterName(i));\n@@ -92,2 +132,1 @@\n-        append(\");\\n\");\n-        decrAlign();\n+        return result.toString();\n@@ -96,14 +135,6 @@\n-    private void emitFunctionalFactories() {\n-        Constant functionDesc = constants().addFunctionDesc(fiDesc);\n-        Constant upcallHandle = constants().addUpcallMethodHandle(fullName(), \"apply\", fiDesc);\n-        incrAlign();\n-        indent();\n-        append(MEMBER_MODS + \" MemorySegment allocate(\" + className() + \" fi, Arena scope) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return RuntimeHelper.upcallStub(\" +\n-            upcallHandle.accessExpression() + \", fi, \" + functionDesc.accessExpression() + \", scope);\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+    private String retExpr() {\n+        String retExpr = \"\";\n+        if (!methodType.returnType().equals(void.class)) {\n+            retExpr = STR.\"return (\\{methodType.returnType().getSimpleName()})\";\n+        }\n+        return retExpr;\n@@ -112,43 +143,5 @@\n-    private void emitFunctionalFactoryForPointer() {\n-        Constant mhConstant = constants().addVirtualDowncallMethodHandle(fiDesc);\n-        incrAlign();\n-        indent();\n-        append(MEMBER_MODS + \" \" + className() + \" ofAddress(MemorySegment addr, Arena arena) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"MemorySegment symbol = addr.reinterpret(\");\n-        append(\"arena, null);\\n\");\n-        indent();\n-        append(\"return (\");\n-        String delim = \"\";\n-        for (int i = 0 ; i < fiType.parameterCount(); i++) {\n-            append(delim + fiType.parameterType(i).getName());\n-            append(\" \");\n-            append(\"_\" + parameterName(i));\n-            delim = \", \";\n-        }\n-        append(\") -> {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"try {\\n\");\n-        incrAlign();\n-        indent();\n-        if (!fiType.returnType().equals(void.class)) {\n-            append(\"return (\" + fiType.returnType().getName() + \")\");\n-            if (fiType.returnType() != downcallType.returnType()) {\n-                \/\/ add cast for invokeExact\n-                append(\"(\" + downcallType.returnType().getName() + \")\");\n-            }\n-        }\n-        append(mhConstant.accessExpression() + \".invokeExact(symbol\");\n-        if (fiType.parameterCount() > 0) {\n-            String params = IntStream.range(0, fiType.parameterCount())\n-                    .mapToObj(i -> {\n-                        String paramExpr = \"_\" + parameterName(i);\n-                        if (fiType.parameterType(i) != downcallType.parameterType(i)) {\n-                            \/\/ add cast for invokeExact\n-                            return \"(\" + downcallType.parameterType(i).getName() + \")\" + paramExpr;\n-                        } else {\n-                            return paramExpr;\n-                        }\n-                    })\n+    private String otherArgExprs() {\n+        String argsExprs = \"\";\n+        if (methodType.parameterCount() > 0) {\n+            argsExprs += \", \" + IntStream.range(0, methodType.parameterCount())\n+                    .mapToObj(this::parameterName)\n@@ -156,1 +149,0 @@\n-            append(\", \" + params);\n@@ -158,17 +150,15 @@\n-        append(\");\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"} catch (Throwable ex$) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"};\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+        return argsExprs;\n+    }\n+\n+    private void emitDescriptorDecl() {\n+        appendIndentedLines(STR.\"\"\"\n+\n+            private static final FunctionDescriptor $DESC = \\{functionDescriptorString(0, funcType)};\n+\n+            \/**\n+             * The descriptor of this function pointer\n+             *\/\n+            public static FunctionDescriptor descriptor() {\n+                return $DESC;\n+            }\n+            \"\"\");\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":101,"deletions":111,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -1,115 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.jextract.impl;\n-\n-import org.openjdk.jextract.Declaration;\n-import org.openjdk.jextract.Type;\n-import java.lang.foreign.FunctionDescriptor;\n-\n-import java.util.Optional;\n-import java.util.Set;\n-\n-class FunctionalInterfaceScanner implements Declaration.Visitor<Void, Set<FunctionDescriptor>> {\n-\n-    private final Set<FunctionDescriptor> descriptors;\n-\n-    FunctionalInterfaceScanner(Set<FunctionDescriptor> descriptors) {\n-        this.descriptors = descriptors;\n-    }\n-\n-    Declaration.Scoped scan(Declaration.Scoped decl) {\n-        decl.accept(this, descriptors);\n-        return decl;\n-    }\n-\n-    void scanType(Type t, Set<FunctionDescriptor> functionDescriptors) {\n-        t.accept(new TypeScanner(), functionDescriptors);\n-    }\n-\n-    @Override\n-    public Void visitScoped(Declaration.Scoped d, Set<FunctionDescriptor> functionDescriptors) {\n-        d.members().forEach(m -> m.accept(this, functionDescriptors));\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitFunction(Declaration.Function d, Set<FunctionDescriptor> functionDescriptors) {\n-        scanType(d.type().returnType(), functionDescriptors);\n-        d.parameters().forEach(p -> p.accept(this, functionDescriptors));\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitVariable(Declaration.Variable d, Set<FunctionDescriptor> functionDescriptors) {\n-        scanType(d.type(), functionDescriptors);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitConstant(Declaration.Constant d, Set<FunctionDescriptor> functionDescriptors) {\n-        scanType(d.type(), functionDescriptors);\n-        return null;\n-    }\n-\n-    static class TypeScanner implements Type.Visitor<Void, Set<FunctionDescriptor>> {\n-\n-        @Override\n-        public Void visitPrimitive(Type.Primitive t, Set<FunctionDescriptor> functionDescriptors) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitDelegated(Type.Delegated t, Set<FunctionDescriptor> functionDescriptors) {\n-            return t.type().accept(this, functionDescriptors);\n-        }\n-\n-        @Override\n-        public Void visitFunction(Type.Function t, Set<FunctionDescriptor> functionDescriptors) {\n-            t.returnType().accept(this, functionDescriptors);\n-            t.argumentTypes().forEach(a -> a.accept(this, functionDescriptors));\n-            Optional<FunctionDescriptor> descriptor = Type.descriptorFor(t);\n-            if (descriptor.isPresent()) {\n-                functionDescriptors.add(descriptor.get());\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitDeclared(Type.Declared t, Set<FunctionDescriptor> functionDescriptors) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitArray(Type.Array t, Set<FunctionDescriptor> functionDescriptors) {\n-            return t.elementType().accept(this, functionDescriptors);\n-        }\n-\n-        @Override\n-        public Void visitType(Type t, Set<FunctionDescriptor> functionDescriptors) {\n-            throw new UnsupportedOperationException();\n-        }\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/FunctionalInterfaceScanner.java","additions":0,"deletions":115,"binary":false,"changes":115,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n@@ -30,1 +28,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -32,2 +29,1 @@\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.ValueLayout;\n+\n@@ -36,2 +32,1 @@\n-\n-import org.openjdk.jextract.impl.Constants.Constant;\n+import org.openjdk.jextract.impl.DeclarationImpl.JavaName;\n@@ -41,0 +36,1 @@\n+import java.util.HashSet;\n@@ -42,1 +38,5 @@\n-import java.util.Optional;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n@@ -49,1 +49,1 @@\n-abstract class HeaderFileBuilder extends ClassSourceBuilder {\n+class HeaderFileBuilder extends ClassSourceBuilder {\n@@ -51,1 +51,1 @@\n-    static final String MEMBER_MODS = \"public static\";\n+    private final Set<String> holderClassNames = new HashSet<>();\n@@ -53,5 +53,2 @@\n-    private final String superclass;\n-\n-    HeaderFileBuilder(ToplevelBuilder enclosing, String name, String superclass) {\n-        super(enclosing, Kind.CLASS, name);\n-        this.superclass = superclass;\n+    HeaderFileBuilder(SourceFileBuilder builder, String className, String superName, String runtimeHelperName) {\n+        super(builder, \"public\", Kind.CLASS, className, superName, null, runtimeHelperName);\n@@ -60,36 +57,12 @@\n-    @Override\n-    String superClass() {\n-        return superclass;\n-    }\n-\n-    @Override\n-    void emitDocComment(Declaration decl, String header) {\n-        incrAlign();\n-        super.emitDocComment(decl, header);\n-        decrAlign();\n-    }\n-\n-    @Override\n-    public void addVar(Declaration.Variable varTree, String javaName,\n-        MemoryLayout layout, Optional<String> fiName) {\n-        String nativeName = varTree.name();\n-        if (layout instanceof SequenceLayout || layout instanceof GroupLayout) {\n-            if (layout.byteSize() > 0) {\n-                emitDocComment(varTree);\n-                constants().addSegment(nativeName, layout)\n-                        .emitGetter(this, MEMBER_MODS, javaName, nativeName);\n-            };\n-        } else if (layout instanceof ValueLayout valueLayout) {\n-            constants().addLayout(valueLayout)\n-                    .emitGetter(this, MEMBER_MODS, javaName);\n-            Constant vhConstant = constants().addGlobalVarHandle(valueLayout)\n-                    .emitGetter(this, MEMBER_MODS, javaName);\n-            Constant segmentConstant = constants().addSegment(nativeName, valueLayout)\n-                    .emitGetter(this, MEMBER_MODS, javaName, nativeName);\n-            emitDocComment(varTree, \"Getter for variable:\");\n-            emitGlobalGetter(segmentConstant, vhConstant, javaName, nativeName, valueLayout.carrier());\n-            emitDocComment(varTree, \"Setter for variable:\");\n-            emitGlobalSetter(segmentConstant, vhConstant, javaName, nativeName, valueLayout.carrier());\n-\n-            if (fiName.isPresent()) {\n-                emitFunctionalInterfaceGetter(fiName.get(), javaName);\n+    public void addVar(Declaration.Variable varTree) {\n+        String javaName = JavaName.getOrThrow(varTree);\n+        appendBlankLine();\n+        String holderClass = emitVarHolderClass(varTree, javaName);\n+        if (Utils.isArray(varTree.type()) || Utils.isStructOrUnion(varTree.type())) {\n+            emitGlobalSegmentGetter(holderClass, javaName, varTree, \"Getter for variable:\");\n+            emitGlobalSegmentSetter(holderClass, javaName, varTree, \"Setter for variable:\");\n+            int dims = Utils.dimensions(varTree.type()).size();\n+            if (dims > 0) {\n+                IndexList indexList = IndexList.of(dims);\n+                emitGlobalArrayGetter(holderClass, indexList, javaName, varTree, \"Indexed getter for variable:\");\n+                emitGlobalArraySetter(holderClass, indexList, javaName, varTree, \"Indexed setter for variable:\");\n@@ -97,0 +70,5 @@\n+        } else if (Utils.isPointer(varTree.type()) || Utils.isPrimitive(varTree.type())) {\n+            emitGlobalGetter(holderClass, javaName, varTree, \"Getter for variable:\");\n+            emitGlobalSetter(holderClass, javaName, varTree, \"Setter for variable:\");\n+        } else {\n+            throw new IllegalArgumentException(\"Tree type not handled: \" + varTree.type());\n@@ -100,3 +78,1 @@\n-    @Override\n-    public void addFunction(Declaration.Function funcTree, FunctionDescriptor descriptor,\n-            String javaName, List<String> parameterNames) {\n+    public void addFunction(Declaration.Function funcTree) {\n@@ -105,8 +81,6 @@\n-\n-        Constant mhConstant = constants().addDowncallMethodHandle(nativeName, descriptor, isVarargs)\n-                .emitGetter(this, MEMBER_MODS, javaName, nativeName);\n-        MethodType downcallType = descriptor.toMethodType();\n-        boolean needsAllocator = descriptor.returnLayout().isPresent() &&\n-                descriptor.returnLayout().get() instanceof GroupLayout;\n-        emitDocComment(funcTree);\n-        emitFunctionWrapper(mhConstant, javaName, nativeName, downcallType, needsAllocator, isVarargs, parameterNames);\n+        boolean needsAllocator = Utils.isStructOrUnion(funcTree.type().returnType());\n+        List<String> parameterNames = funcTree.parameters().\n+                stream().\n+                map(JavaName::getOrThrow).\n+                toList();\n+        emitFunctionWrapper(JavaName.getOrThrow(funcTree), nativeName, needsAllocator, isVarargs, parameterNames, funcTree);\n@@ -115,2 +89,1 @@\n-    @Override\n-    public void addConstant(Declaration.Constant constantTree, String javaName, Class<?> javaType) {\n+    public void addConstant(Declaration.Constant constantTree) {\n@@ -118,3 +91,1 @@\n-        emitDocComment(constantTree);\n-        constants().addConstantDesc(javaType, value)\n-                    .emitGetter(this, MEMBER_MODS, c -> javaName);\n+        emitConstant(Utils.carrierFor(constantTree.type()), JavaName.getOrThrow(constantTree), value, constantTree);\n@@ -125,5 +96,3 @@\n-    private void emitFunctionWrapper(Constant mhConstant, String javaName, String nativeName, MethodType declType,\n-                                     boolean needsAllocator, boolean isVarargs, List<String> parameterNames) {\n-        incrAlign();\n-        indent();\n-        append(MEMBER_MODS + \" \");\n+    private static List<String> finalizeParameterNames(List<String> parameterNames, boolean needsAllocator, boolean isVarArg) {\n+        List<String> result = new ArrayList<>();\n+\n@@ -131,4 +100,1 @@\n-            \/\/ needs allocator parameter\n-            declType = declType.insertParameterTypes(0, SegmentAllocator.class);\n-            parameterNames = new ArrayList<>(parameterNames);\n-            parameterNames.add(0, \"allocator\");\n+            result.add(\"allocator\");\n@@ -136,13 +102,8 @@\n-        List<String> pExprs = emitFunctionWrapperDecl(javaName, declType, isVarargs, parameterNames);\n-        append(\" {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"var mh$ = \");\n-        append(mhConstant.getterName(javaName));\n-        append(\"();\\n\");\n-        indent();\n-        append(\"try {\\n\");\n-        incrAlign();\n-        indent();\n-        if (!declType.returnType().equals(void.class)) {\n-            append(\"return (\" + declType.returnType().getName() + \")\");\n+\n+        int i = 0;\n+        for (; i < parameterNames.size(); i++) {\n+            String name = parameterNames.get(i);\n+            if (name.isEmpty()) {\n+                name = \"x\" + i;\n+            }\n+            result.add(name);\n@@ -150,14 +111,6 @@\n-        append(\"mh$.invokeExact(\" + String.join(\", \", pExprs) + \");\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"} catch (Throwable ex$) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+\n+        if (isVarArg) {\n+            result.add(\"x\" + i);\n+        }\n+\n+        return result;\n@@ -166,14 +119,7 @@\n-    private List<String> emitFunctionWrapperDecl(String javaName, MethodType methodType, boolean isVarargs, List<String> paramNames) {\n-        append(methodType.returnType().getSimpleName() + \" \" + javaName + \"(\");\n-        String delim = \"\";\n-        List<String> pExprs = new ArrayList<>();\n-        final int numParams = paramNames.size();\n-        for (int i = 0 ; i < numParams; i++) {\n-            String pName = paramNames.get(i);\n-            if (pName.isEmpty()) {\n-                pName = \"x\" + i;\n-            }\n-            pExprs.add(pName);\n-            Class<?> pType = methodType.parameterType(i);\n-            append(delim + pType.getSimpleName() + \" \" + pName);\n-            delim = \", \";\n+    private static String paramExprs(MethodType type, List<String> parameterNames, boolean isVarArg) {\n+        assert parameterNames.size() >= type.parameterCount();\n+        StringJoiner sb = new StringJoiner(\", \");\n+        int i = 0;\n+        for (; i < type.parameterCount(); i++) {\n+            String pName = parameterNames.get(i);\n+            sb.add(type.parameterType(i).getSimpleName() + \" \" + pName);\n@@ -181,4 +127,3 @@\n-        if (isVarargs) {\n-            String lastArg = \"x\" + numParams;\n-            append(delim + \"Object... \" + lastArg);\n-            pExprs.add(lastArg);\n+\n+        if (isVarArg) {\n+            sb.add(\"Object... \" + parameterNames.get(i));\n@@ -186,2 +131,2 @@\n-        append(\")\");\n-        return pExprs;\n+\n+        return sb.toString();\n@@ -190,5 +135,16 @@\n-    private void emitFunctionalInterfaceGetter(String fiName, String javaName) {\n-        incrAlign();\n-        indent();\n-        append(MEMBER_MODS + \" \");\n-        append(fiName + \" \" + javaName + \" () {\\n\");\n+    private void emitFunctionWrapper(String javaName, String nativeName, boolean needsAllocator,\n+                                     boolean isVarArg, List<String> parameterNames, Declaration.Function decl) {\n+        MethodType declType = Utils.methodTypeFor(decl.type());\n+        List<String> finalParamNames = finalizeParameterNames(parameterNames, needsAllocator, isVarArg);\n+        if (needsAllocator) {\n+            declType = declType.insertParameterTypes(0, SegmentAllocator.class);\n+        }\n+\n+        String retType = declType.returnType().getSimpleName();\n+        boolean isVoid = declType.returnType().equals(void.class);\n+        String returnNoCast = isVoid ? \"\" : STR.\"return \";\n+        String returnWithCast = isVoid ? \"\" : STR.\"\\{returnNoCast}(\\{retType})\";\n+        String paramList = String.join(\", \", finalParamNames);\n+        String traceArgList = paramList.isEmpty() ?\n+                STR.\"\\\"\\{nativeName}\\\"\" :\n+                STR.\"\\\"\\{nativeName}\\\", \\{paramList}\";\n@@ -196,7 +152,3 @@\n-        indent();\n-        append(\"return \" + fiName + \".ofAddress(\" + javaName + \"$get(), Arena.global());\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n-    }\n+        if (!isVarArg) {\n+            String holderClass = newHolderClassName(javaName);\n+            appendLines(STR.\"\"\"\n@@ -204,3 +156,2 @@\n-    void emitPrimitiveTypedef(Type.Primitive primType, String name) {\n-        emitPrimitiveTypedef(null, primType, name);\n-    }\n+                private static class \\{holderClass} {\n+                    public static final FunctionDescriptor DESC = \\{functionDescriptorString(1, decl.type())};\n@@ -208,5 +159,31 @@\n-    void emitPrimitiveTypedef(Declaration.Typedef typedefTree, Type.Primitive primType, String name) {\n-        Type.Primitive.Kind kind = primType.kind();\n-        if (primitiveKindSupported(kind) && kind.layout().isPresent()) {\n-            if (typedefTree != null) {\n-                emitDocComment(typedefTree);\n+                    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n+                                \\{runtimeHelperName()}.findOrThrow(\"\\{nativeName}\"),\n+                                DESC);\n+                }\n+                \"\"\");\n+            appendBlankLine();\n+            emitDocComment(decl, \"Function descriptor for:\");\n+            appendLines(STR.\"\"\"\n+                public static FunctionDescriptor \\{javaName}$descriptor() {\n+                    return \\{holderClass}.DESC;\n+                }\n+                \"\"\");\n+            appendBlankLine();\n+            emitDocComment(decl, \"Downcall method handle for:\");\n+            appendLines(STR.\"\"\"\n+                public static MethodHandle \\{javaName}$handle() {\n+                    return \\{holderClass}.HANDLE;\n+                }\n+                \"\"\");\n+            emitDocComment(decl);\n+            appendLines(STR.\"\"\"\n+            public static \\{retType} \\{javaName}(\\{paramExprs(declType, finalParamNames, isVarArg)}) {\n+                var mh$ = \\{holderClass}.HANDLE;\n+                try {\n+                    if (TRACE_DOWNCALLS) {\n+                        traceDowncall(\\{traceArgList});\n+                    }\n+                    \\{returnWithCast}mh$.invokeExact(\\{paramList});\n+                } catch (Throwable ex$) {\n+                   throw new AssertionError(\"should not reach here\", ex$);\n+                }\n@@ -214,0 +191,21 @@\n+            \"\"\");\n+        } else {\n+            String invokerClassName = newHolderClassName(javaName);\n+            String paramExprs = paramExprs(declType, finalParamNames, isVarArg);\n+            appendBlankLine();\n+            emitDocComment(decl, \"Variadic invoker class for:\");\n+            appendLines(STR.\"\"\"\n+                public static class \\{invokerClassName} {\n+                    private static final FunctionDescriptor BASE_DESC = \\{functionDescriptorString(2, decl.type())};\n+                    private static final MemorySegment ADDR = \\{runtimeHelperName()}.findOrThrow(\"\\{nativeName}\");\n+\n+                    private final MethodHandle handle;\n+                    private final FunctionDescriptor descriptor;\n+                    private final MethodHandle spreader;\n+\n+                    private \\{invokerClassName}(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {\n+                        this.handle = handle;\n+                        this.descriptor = descriptor;\n+                        this.spreader = spreader;\n+                    }\n+                \"\"\");\n@@ -215,8 +213,11 @@\n-            indent();\n-            append(MEMBER_MODS);\n-            append(\" final\");\n-            append(\" \" + Utils.layoutDeclarationType(primType.kind().layout().orElseThrow()).getSimpleName());\n-            append(\" \" + name);\n-            append(\" = \");\n-            append(constants().addLayout(kind.layout().get()).accessExpression());\n-            append(\";\\n\");\n+            appendBlankLine();\n+            emitDocComment(decl, \"Variadic invoker factory for:\");\n+            appendLines(STR.\"\"\"\n+                public static \\{invokerClassName} makeInvoker(MemoryLayout... layouts) {\n+                    FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);\n+                    Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());\n+                    var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);\n+                    var spreader$ = mh$.asSpreader(Object[].class, layouts.length);\n+                    return new \\{invokerClassName}(mh$, desc$, spreader$);\n+                }\n+                \"\"\");\n@@ -224,0 +225,30 @@\n+            appendLines(STR.\"\"\"\n+\n+                    \/**\n+                     * {@return the specialized method handle}\n+                     *\/\n+                    public MethodHandle handle() {\n+                        return handle;\n+                    }\n+\n+                    \/**\n+                     * {@return the specialized descriptor}\n+                     *\/\n+                    public FunctionDescriptor descriptor() {\n+                        return descriptor;\n+                    }\n+\n+                    public \\{retType} apply(\\{paramExprs}) {\n+                        try {\n+                            if (TRACE_DOWNCALLS) {\n+                                traceDowncall(\\{traceArgList});\n+                            }\n+                            \\{returnWithCast}spreader.invokeExact(\\{paramList});\n+                        } catch(IllegalArgumentException | ClassCastException ex$)  {\n+                            throw ex$; \/\/ rethrow IAE from passing wrong number\/type of args\n+                        } catch (Throwable ex$) {\n+                           throw new AssertionError(\"should not reach here\", ex$);\n+                        }\n+                    }\n+                }\n+                \"\"\");\n@@ -225,0 +256,1 @@\n+        decrAlign();\n@@ -227,2 +259,2 @@\n-    void emitPointerTypedef(String name) {\n-        emitPointerTypedef(null, name);\n+    void emitPrimitiveTypedef(Declaration.Typedef typedefTree, Type.Primitive primType, String name) {\n+        emitPrimitiveTypedefLayout(name, primType, typedefTree);\n@@ -232,2 +264,28 @@\n-        if (typedefTree != null) {\n-            emitDocComment(typedefTree);\n+        emitPrimitiveTypedefLayout(name, Type.pointer(), typedefTree);\n+    }\n+\n+    void emitFirstHeaderPreamble(List<Options.Library> libraries, boolean useSystemLoadLibrary) {\n+        List<String> lookups = new ArrayList<>();\n+        \/\/ if legacy library loading is selected, load libraries (if any) into current loader\n+        if (useSystemLoadLibrary) {\n+            appendBlankLine();\n+            appendIndentedLines(\"\"\"\n+\n+                static {\n+                \"\"\");\n+            incrAlign();\n+            for (Options.Library lib : libraries) {\n+                String method = lib.specKind() == Options.Library.SpecKind.PATH ? \"load\" : \"loadLibrary\";\n+                appendIndentedLines(STR.\"System.\\{method}(\\\"\\{lib.toQuotedName()}\\\");\");\n+            }\n+            decrAlign();\n+            appendIndentedLines(\"\"\"\n+                }\n+                \"\"\");\n+        } else {\n+            \/\/ otherwise, add a library lookup per library (if any)\n+            libraries.stream() \/\/ add library lookups (if any)\n+                    .map(l -> l.specKind() == Options.Library.SpecKind.PATH ?\n+                            STR.\"SymbolLookup.libraryLookup(\\\"\\{l.toQuotedName()}\\\", LIBRARY_ARENA)\" :\n+                            STR.\"SymbolLookup.libraryLookup(System.mapLibraryName(\\\"\\{l.toQuotedName()}\\\"), LIBRARY_ARENA)\")\n+                    .collect(Collectors.toCollection(() -> lookups));\n@@ -235,0 +293,63 @@\n+\n+        lookups.add(\"SymbolLookup.loaderLookup()\"); \/\/ fallback to loader lookup\n+        lookups.add(\"Linker.nativeLinker().defaultLookup()\"); \/\/ fallback to native lookup\n+\n+        \/\/ wrap all lookups (but the first) with \".or(...)\"\n+        List<String> lookupCalls = new ArrayList<>();\n+        boolean isFirst = true;\n+        for (String lookup : lookups) {\n+            lookupCalls.add(isFirst ? lookup : STR.\".or(\\{lookup})\");\n+            isFirst = false;\n+        }\n+\n+        \/\/ chain all the calls together into a combined symbol lookup\n+        appendBlankLine();\n+        appendIndentedLines(lookupCalls.stream()\n+                .collect(Collectors.joining(STR.\"\\n\\{indentString(2)}\", \"static final SymbolLookup SYMBOL_LOOKUP = \", \";\")));\n+    }\n+\n+    void emitRuntimeHelperMethods() {\n+        appendIndentedLines(\"\"\"\n+\n+            static final Arena LIBRARY_ARENA = Arena.ofAuto();\n+            static final boolean TRACE_DOWNCALLS = Boolean.getBoolean(\"jextract.trace.downcalls\");\n+\n+            static void traceDowncall(String name, Object... args) {\n+                 String traceArgs = Arrays.stream(args)\n+                               .map(Object::toString)\n+                               .collect(Collectors.joining(\", \"));\n+                 System.out.printf(\"%s(%s)\\\\n\", name, traceArgs);\n+            }\n+\n+            static MemorySegment findOrThrow(String symbol) {\n+                return SYMBOL_LOOKUP.find(symbol)\n+                    .orElseThrow(() -> new UnsatisfiedLinkError(\"unresolved symbol: \" + symbol));\n+            }\n+\n+            static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n+                try {\n+                    return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());\n+                } catch (ReflectiveOperationException ex) {\n+                    throw new AssertionError(ex);\n+                }\n+            }\n+            \"\"\");\n+    }\n+\n+    private void emitGlobalGetter(String holderClass, String javaName,\n+                                  Declaration.Variable decl, String docHeader) {\n+        appendBlankLine();\n+        incrAlign();\n+        emitDocComment(decl, docHeader);\n+        Class<?> type = Utils.carrierFor(decl.type());\n+        appendLines(STR.\"\"\"\n+            public static \\{type.getSimpleName()} \\{javaName}() {\n+                return \\{holderClass}.SEGMENT.get(\\{holderClass}.LAYOUT, 0L);\n+            }\n+            \"\"\");\n+        decrAlign();\n+    }\n+\n+    private void emitGlobalSetter(String holderClass, String javaName,\n+                                  Declaration.Variable decl, String docHeader) {\n+        appendBlankLine();\n@@ -236,8 +357,7 @@\n-        indent();\n-        append(MEMBER_MODS);\n-        append(\" final\");\n-        append(\" AddressLayout \");\n-        append(name);\n-        append(\" = \");\n-        append(constants().addLayout(TypeImpl.PointerImpl.POINTER_LAYOUT).accessExpression());\n-        append(\";\\n\");\n+        emitDocComment(decl, docHeader);\n+        Class<?> type = Utils.carrierFor(decl.type());\n+        appendLines(STR.\"\"\"\n+            public static void \\{javaName}(\\{type.getSimpleName()} varValue) {\n+                \\{holderClass}.SEGMENT.set(\\{holderClass}.LAYOUT, 0L, varValue);\n+            }\n+            \"\"\");\n@@ -247,5 +367,11 @@\n-    private boolean primitiveKindSupported(Type.Primitive.Kind kind) {\n-        return switch(kind) {\n-            case Short, Int, Long, LongLong, Float, Double, Char -> true;\n-            default -> false;\n-        };\n+    private void emitGlobalSegmentGetter(String holderClass, String javaName,\n+                                         Declaration.Variable varTree, String docHeader) {\n+        appendBlankLine();\n+        incrAlign();\n+        emitDocComment(varTree, docHeader);\n+        appendLines(STR.\"\"\"\n+            public static MemorySegment \\{javaName}() {\n+                return \\{holderClass}.SEGMENT;\n+            }\n+            \"\"\");\n+        decrAlign();\n@@ -254,1 +380,3 @@\n-    private void emitGlobalGetter(Constant segmentConstant, Constant vhConstant, String javaName, String nativeName, Class<?> type) {\n+    private void emitGlobalSegmentSetter(String holderClass, String javaName,\n+                                         Declaration.Variable varTree, String docHeader) {\n+        appendBlankLine();\n@@ -256,2 +384,14 @@\n-        indent();\n-        append(MEMBER_MODS + \" \" + type.getSimpleName() + \" \" + javaName + \"$get() {\\n\");\n+        emitDocComment(varTree, docHeader);\n+        appendLines(STR.\"\"\"\n+            public static void \\{javaName}(MemorySegment varValue) {\n+                MemorySegment.copy(varValue, 0L, \\{holderClass}.SEGMENT, 0L, \\{holderClass}.LAYOUT.byteSize());\n+            }\n+            \"\"\");\n+        decrAlign();\n+    }\n+\n+    private void emitGlobalArrayGetter(String holderClass, IndexList indexList,\n+                                       String javaName, Declaration.Variable varTree, String docHeader) {\n+        Type elemType = Utils.typeOrElemType(varTree.type());\n+        Class<?> typeCls = Utils.carrierFor(elemType);\n+        appendBlankLine();\n@@ -259,8 +399,18 @@\n-        indent();\n-        append(\"return (\" + type.getName() + \") \");\n-        append(vhConstant.accessExpression());\n-        append(\".get(RuntimeHelper.requireNonNull(\");\n-        append(segmentConstant.accessExpression());\n-        append(\", \\\"\");\n-        append(nativeName);\n-        append(\"\\\"), 0L);\\n\");\n+        emitDocComment(varTree, docHeader);\n+        if (Utils.isStructOrUnion(elemType)) {\n+            appendLines(STR.\"\"\"\n+                public static MemorySegment \\{javaName}(\\{indexList.decl()}) {\n+                    try {\n+                        return (MemorySegment)\\{holderClass}.HANDLE.invokeExact(\\{holderClass}.SEGMENT, 0L, \\{indexList.use()});\n+                    } catch (Throwable ex$) {\n+                        throw new AssertionError(\"should not reach here\", ex$);\n+                    }\n+                }\n+                \"\"\");\n+        } else {\n+            appendLines(STR.\"\"\"\n+                public static \\{typeCls.getSimpleName()} \\{javaName}(\\{indexList.decl()}) {\n+                    return (\\{typeCls.getSimpleName()})\\{holderClass}.HANDLE.get(\\{holderClass}.SEGMENT, 0L, \\{indexList.use()});\n+                }\n+                \"\"\");\n+        }\n@@ -268,2 +418,22 @@\n-        indent();\n-        append(\"}\\n\");\n+    }\n+\n+    private void emitGlobalArraySetter(String holderClass, IndexList indexList,\n+                                       String javaName, Declaration.Variable varTree, String docHeader) {\n+        Type elemType = Utils.typeOrElemType(varTree.type());\n+        Class<?> typeCls = Utils.carrierFor(elemType);\n+        appendBlankLine();\n+        incrAlign();\n+        emitDocComment(varTree, docHeader);\n+        if (Utils.isStructOrUnion(elemType)) {\n+            appendLines(STR.\"\"\"\n+                public static void \\{javaName}(\\{indexList.decl()}, MemorySegment varValue) {\n+                    MemorySegment.copy(varValue, 0L, \\{javaName}(\\{indexList.use()}), 0L, \\{layoutString(elemType)}.byteSize());\n+                }\n+                \"\"\");\n+        } else {\n+            appendLines(STR.\"\"\"\n+                public static void \\{javaName}(\\{indexList.decl()}, \\{typeCls.getSimpleName()} varValue) {\n+                    \\{holderClass}.HANDLE.set(\\{holderClass}.SEGMENT, 0L, \\{indexList.use()}, varValue);\n+                }\n+                \"\"\");\n+        }\n@@ -273,1 +443,31 @@\n-    private void emitGlobalSetter(Constant segmentConstant, Constant vhConstant, String javaName, String nativeName, Class<?> type) {\n+    private String emitVarHolderClass(Declaration.Variable var, String javaName) {\n+        Type varType = var.type();\n+        String mangledName = newHolderClassName(STR.\"\\{javaName}$constants\");\n+        String layoutType = Utils.layoutCarrierFor(varType).getSimpleName();\n+        if (varType instanceof Type.Array) {\n+            List<Long> dimensions = Utils.dimensions(varType);\n+            String path = IntStream.range(0, dimensions.size())\n+                    .mapToObj(_ -> \"sequenceElement()\")\n+                    .collect(Collectors.joining(\", \"));\n+            Type elemType = Utils.typeOrElemType(varType);\n+            String accessHandle = Utils.isStructOrUnion(elemType) ?\n+                    STR.\"public static final MethodHandle HANDLE = LAYOUT.sliceHandle(\\{path});\" :\n+                    STR.\"public static final VarHandle HANDLE = LAYOUT.varHandle(\\{path});\\n\";\n+            String dimsString = dimensions.stream().map(d -> d.toString())\n+                    .collect(Collectors.joining(\", \"));\n+            appendIndentedLines(STR.\"\"\"\n+                private static class \\{mangledName} {\n+                    public static final \\{layoutType} LAYOUT = \\{layoutString(varType)};\n+                    public static final MemorySegment SEGMENT = \\{runtimeHelperName()}.findOrThrow(\"\\{var.name()}\").reinterpret(LAYOUT.byteSize());\n+                    \\{accessHandle}\n+                    public static final long[] DIMS = { \\{dimsString} };\n+                }\n+                \"\"\");\n+        } else {\n+            appendIndentedLines(STR.\"\"\"\n+                private static class \\{mangledName} {\n+                    public static final \\{layoutType} LAYOUT = \\{layoutString(varType)};\n+                    public static final MemorySegment SEGMENT = \\{runtimeHelperName()}.findOrThrow(\"\\{var.name()}\").reinterpret(LAYOUT.byteSize());\n+                }\n+                \"\"\");\n+        }\n@@ -275,2 +475,30 @@\n-        indent();\n-        append(MEMBER_MODS + \" void \" + javaName + \"$set(\" + type.getSimpleName() + \" x) {\\n\");\n+        appendBlankLine();\n+        emitDocComment(var, \"Layout for variable:\");\n+        appendLines(STR.\"\"\"\n+                public static \\{layoutType} \\{javaName}$layout() {\n+                    return \\{mangledName}.LAYOUT;\n+                }\n+                \"\"\");\n+        if (!Utils.isStructOrUnion(varType) && !Utils.isArray(varType)) {\n+            appendBlankLine();\n+            emitDocComment(var, \"Segment for variable:\");\n+            appendLines(STR.\"\"\"\n+                    public static MemorySegment \\{javaName}$segment() {\n+                        return \\{mangledName}.SEGMENT;\n+                    }\n+                    \"\"\");\n+        }\n+        if (varType instanceof Type.Array) {\n+            appendBlankLine();\n+            emitDocComment(var, \"Dimensions for array variable:\");\n+            appendLines(STR.\"\"\"\n+                public static long[] \\{javaName}$dimensions() {\n+                    return \\{mangledName}.DIMS;\n+                }\n+                \"\"\");\n+        }\n+        decrAlign();\n+        return mangledName;\n+    }\n+\n+    private void emitConstant(Class<?> javaType, String constantName, Object value, Declaration declaration) {\n@@ -278,7 +506,22 @@\n-        indent();\n-        append(vhConstant.accessExpression());\n-        append(\".set(RuntimeHelper.requireNonNull(\");\n-        append(segmentConstant.accessExpression());\n-        append(\", \\\"\");\n-        append(nativeName);\n-        append(\"\\\"), 0L, x);\\n\");\n+        if (value instanceof String) {\n+            emitDocComment(declaration);\n+            appendLines(STR.\"\"\"\n+                public static \\{javaType.getSimpleName()} \\{constantName}() {\n+                    class Holder {\n+                        static final \\{javaType.getSimpleName()} \\{constantName}\n+                            = \\{runtimeHelperName()}.LIBRARY_ARENA.allocateFrom(\"\\{Utils.quote(Objects.toString(value))}\");\n+                    }\n+                    return Holder.\\{constantName};\n+                }\n+                \"\"\");\n+        } else {\n+            appendLines(STR.\"\"\"\n+                private static final \\{javaType.getSimpleName()} \\{constantName} = \\{constantValue(javaType, value)};\n+                \"\"\");\n+            emitDocComment(declaration);\n+            appendLines(STR.\"\"\"\n+                public static \\{javaType.getSimpleName()} \\{constantName}() {\n+                    return \\{constantName};\n+                }\n+                \"\"\");\n+        }\n@@ -286,2 +529,49 @@\n-        indent();\n-        append(\"}\\n\");\n+    }\n+\n+    private String constantValue(Class<?> type, Object value) {\n+        if (type == MemorySegment.class) {\n+            return STR.\"MemorySegment.ofAddress(\\{((Number)value).longValue()}L)\";\n+        } else {\n+            StringBuilder buf = new StringBuilder();\n+            if (type == float.class) {\n+                float f = ((Number)value).floatValue();\n+                if (Float.isFinite(f)) {\n+                    buf.append(value);\n+                    buf.append(\"f\");\n+                } else {\n+                    buf.append(\"Float.valueOf(\\\"\");\n+                    buf.append(value);\n+                    buf.append(\"\\\")\");\n+                }\n+            } else if (type == long.class) {\n+                buf.append(value.toString());\n+                buf.append(\"L\");\n+            } else if (type == double.class) {\n+                double d = ((Number)value).doubleValue();\n+                if (Double.isFinite(d)) {\n+                    buf.append(value);\n+                    buf.append(\"d\");\n+                } else {\n+                    buf.append(\"Double.valueOf(\\\"\");\n+                    buf.append(value);\n+                    buf.append(\"\\\")\");\n+                }\n+            } else if (type == boolean.class) {\n+                boolean booleanValue = ((Number)value).byteValue() != 0;\n+                buf.append(booleanValue);\n+            } else if (value instanceof Number n) {\n+                buf.append(\"(\" + type.getName() + \")\");\n+                buf.append(n.longValue() + \"L\");\n+            } else {\n+                throw new IllegalArgumentException(STR.\"Unhandled type: \\{type}, or value: \\{value}\");\n+            }\n+            return buf.toString();\n+        }\n+    }\n+\n+    private void emitPrimitiveTypedefLayout(String javaName, Type type, Declaration declaration) {\n+        incrAlign();\n+        emitDocComment(declaration);\n+        appendLines(STR.\"\"\"\n+        public static final \\{Utils.layoutCarrierFor(type).getSimpleName()} \\{javaName} = \\{layoutString(type)};\n+        \"\"\");\n@@ -290,0 +580,8 @@\n+\n+    private String newHolderClassName(String javaName) {\n+        String holderClassName = javaName;\n+        while (!holderClassNames.add(holderClassName.toLowerCase())) {\n+            holderClassName += \"$\";\n+        }\n+        return holderClassName;\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":492,"deletions":194,"binary":false,"changes":686,"status":"modified"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package org.openjdk.jextract.impl;\n-\n-import javax.tools.FileObject;\n-import javax.tools.ForwardingJavaFileManager;\n-import javax.tools.JavaCompiler;\n-import javax.tools.JavaFileManager;\n-import javax.tools.JavaFileObject;\n-import javax.tools.SimpleJavaFileObject;\n-import javax.tools.ToolProvider;\n-import java.io.*;\n-import java.io.Writer;\n-import java.net.URI;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-final class InMemoryJavaCompiler {\n-    private InMemoryJavaCompiler() {}\n-\n-    static List<JavaFileObject> compile(List<JavaFileObject> files,\n-                                        String... options) {\n-        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n-        FileManager fileManager = new FileManager(compiler.getStandardFileManager(null, null, null));\n-\n-        Writer writer = new StringWriter();\n-        Boolean exitCode = compiler.getTask(writer, fileManager, null, Arrays.asList(options), null, files).call();\n-        if (!exitCode) {\n-            throw new CompilationFailedException(\"In memory compilation failed: \" + writer.toString());\n-        }\n-        return fileManager.getCompiledFiles();\n-    }\n-\n-    static JavaFileObject jfoFromByteArray(URI uri, byte[] bytes) {\n-        return new SimpleJavaFileObject(uri, JavaFileObject.Kind.CLASS) {\n-            @Override\n-            public InputStream openInputStream() {\n-                return new ByteArrayInputStream(bytes);\n-            }\n-        };\n-    }\n-\n-    static JavaFileObject jfoFromString(URI uri, String contents) {\n-        return new SimpleJavaFileObject(uri, JavaFileObject.Kind.SOURCE) {\n-            @Override\n-            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n-                return contents;\n-            }\n-        };\n-    }\n-\n-    \/\/ Wraper for class byte array\n-    private static class ClassFile extends SimpleJavaFileObject {\n-        private final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-\n-        protected ClassFile(String name) {\n-            super(URI.create(name.replace('.', '\/') + Kind.CLASS.extension), Kind.CLASS);\n-        }\n-\n-        @Override\n-        public ByteArrayOutputStream openOutputStream() {\n-            return this.baos;\n-        }\n-\n-        @Override\n-        public InputStream openInputStream() {\n-            return new ByteArrayInputStream(baos.toByteArray());\n-        }\n-    }\n-\n-    \/\/ File manager which spawns ClassFile instances on demand\n-    private static class FileManager extends ForwardingJavaFileManager<JavaFileManager> {\n-        private final List<JavaFileObject> compiled = new ArrayList<>();\n-\n-        protected FileManager(JavaFileManager fileManager) {\n-            super(fileManager);\n-        }\n-\n-        @Override\n-        public JavaFileObject getJavaFileForOutput(Location location, String name, JavaFileObject.Kind kind, FileObject source) throws IOException {\n-            JavaFileObject out = new ClassFile(name);\n-            compiled.add(out);\n-            return out;\n-        }\n-\n-        public List<JavaFileObject> getCompiledFiles() {\n-            return compiled;\n-        }\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/InMemoryJavaCompiler.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"},{"patch":"@@ -28,4 +28,1 @@\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n+import org.openjdk.jextract.impl.DeclarationImpl.Skip;\n@@ -34,1 +31,1 @@\n- * This visitor filters tree elements based on --include options specified.\n+ * This visitor marks declarations to be skipped, based on --include options specified.\n@@ -36,2 +33,1 @@\n-final class IncludeFilter implements TreeTransformer, Declaration.Visitor<Void, Declaration> {\n-    private List<Declaration> decls = new ArrayList<>();\n+public final class IncludeFilter implements Declaration.Visitor<Void, Declaration> {\n@@ -40,1 +36,1 @@\n-    IncludeFilter(IncludeHelper includeHelper) {\n+    public IncludeFilter(IncludeHelper includeHelper) {\n@@ -44,2 +40,1 @@\n-    @Override\n-    public Declaration.Scoped transform(Declaration.Scoped header) {\n+    public Declaration.Scoped scan(Declaration.Scoped header) {\n@@ -50,1 +45,1 @@\n-        return createHeader(header, decls);\n+        return header;\n@@ -57,1 +52,1 @@\n-            return null;\n+            Skip.with(constant);\n@@ -59,1 +54,0 @@\n-        decls.add(constant);\n@@ -66,1 +60,2 @@\n-            return null;\n+            \/\/skip\n+            Skip.with(funcTree);\n@@ -68,2 +63,0 @@\n-\n-        decls.add(funcTree);\n@@ -79,1 +72,2 @@\n-                return null;\n+                \/\/skip\n+                Skip.with(d);\n@@ -83,9 +77,1 @@\n-        List<Declaration> oldDecls = decls;\n-        this.decls = new ArrayList<>();\n-        try {\n-            d.members().forEach(fieldTree -> fieldTree.accept(this, d));\n-        } finally {\n-            var scoped = createScoped(d, decls);\n-            this.decls = oldDecls;\n-            decls.add(scoped);\n-        }\n+        d.members().forEach(fieldTree -> fieldTree.accept(this, d));\n@@ -98,1 +84,2 @@\n-            return null;\n+            \/\/skip\n+            Skip.with(tree);\n@@ -100,1 +87,0 @@\n-        decls.add(tree);\n@@ -107,1 +93,2 @@\n-            return null;\n+            \/\/skip\n+            Skip.with(tree);\n@@ -109,1 +96,0 @@\n-        decls.add(tree);\n@@ -115,1 +101,0 @@\n-        decls.add(decl);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/IncludeFilter.java","additions":16,"deletions":31,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.jextract.impl;\n-\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import org.openjdk.jextract.Declaration;\n-import org.openjdk.jextract.Type;\n-\n-import javax.tools.JavaFileObject;\n-import java.util.List;\n-import java.util.Optional;\n-\n-public abstract class JavaSourceBuilder {\n-\n-    public void addVar(Declaration.Variable varTree, String javaName,\n-        MemoryLayout layout, Optional<String> fiName) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void addFunction(Declaration.Function funcTree, FunctionDescriptor descriptor,\n-        String javaName, List<String> parameterNames) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void addConstant(Declaration.Constant constantTree, String javaName, Class<?> javaType) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void addTypedef(Declaration.Typedef typedefTree, String javaName, String superClass) {\n-        addTypedef(typedefTree, javaName, superClass, typedefTree.type());\n-    }\n-\n-    public void addTypedef(Declaration.Typedef typedefTree, String javaName,\n-        String superClass, Type type) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public StructBuilder addStruct(Declaration.Scoped structTree, boolean isNestedAnonStruct,\n-        String javaName, GroupLayout layout) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void addFunctionalInterface(Type.Function funcType, String javaName,\n-        FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    abstract public List<JavaFileObject> toFiles();\n-\n-    public abstract String packageName();\n-\n-    abstract boolean isEnclosedBySameName(String name);\n-\n-    abstract protected Constants constants();\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/JavaSourceBuilder.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -304,1 +304,0 @@\n-            treeMaker.typeMaker.resolveTypeReferences();\n@@ -311,1 +310,1 @@\n-        void updateTable(TypeMaker typeMaker, Cursor decl) {\n+        void updateTable(TreeMaker treeMaker, Cursor decl) {\n@@ -318,1 +317,1 @@\n-                        yield entry.success(typeMaker.makeType(decl.type()), value);\n+                        yield entry.success(treeMaker.toType(decl), value);\n@@ -322,1 +321,1 @@\n-                        yield entry.success(typeMaker.makeType(decl.type()), value);\n+                        yield entry.success(treeMaker.toType(decl), value);\n@@ -326,1 +325,1 @@\n-                        yield entry.success(typeMaker.makeType(decl.type()), value);\n+                        yield entry.success(treeMaker.toType(decl), value);\n@@ -330,1 +329,1 @@\n-                                null : typeMaker.makeType(decl.type());\n+                                null : treeMaker.toType(decl);\n@@ -340,0 +339,3 @@\n+            \/\/ note: cursors returned during reparsing are not comparable with existing ones.\n+            \/\/ Because of that, here we create a brand new tree maker, which means pointers to already declared types\n+            \/\/ (e.g. structs, unions, enums) will be downgraded to void*.\n@@ -341,10 +343,6 @@\n-            try {\n-                reparser.reparse(snippet).forEach(c -> {\n-                    if (c.kind() == CursorKind.VarDecl &&\n-                            c.spelling().contains(\"jextract$\")) {\n-                        updateTable(treeMaker.typeMaker, c);\n-                    }\n-                });\n-            } finally {\n-                treeMaker.typeMaker.resolveTypeReferences();\n-            }\n+            reparser.reparse(snippet).forEach(c -> {\n+                if (c.kind() == CursorKind.VarDecl &&\n+                        c.spelling().contains(\"jextract$\")) {\n+                    updateTable(treeMaker, c);\n+                }\n+            });\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/MacroParserImpl.java","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jextract.Declaration.Typedef;\n+import org.openjdk.jextract.Declaration.Variable;\n@@ -29,0 +31,8 @@\n+import org.openjdk.jextract.Type.Declared;\n+import org.openjdk.jextract.Type.Delegated;\n+import org.openjdk.jextract.Type.Function;\n+import org.openjdk.jextract.impl.DeclarationImpl.AnonymousStruct;\n+import org.openjdk.jextract.impl.DeclarationImpl.JavaFunctionalInterfaceName;\n+import org.openjdk.jextract.impl.DeclarationImpl.JavaName;\n+\n+import java.util.ArrayList;\n@@ -33,2 +43,0 @@\n-import java.util.Objects;\n-import java.util.Optional;\n@@ -39,7 +47,3 @@\n- * This visitor handles java safe names for identifiers, type names. This visitor\n- * stores java safe names in maps. Subsequent code generation steps can check for\n- * java safe names via lookup methods.\n- *\n- * NOTE: Unlike other transforming tree visitors, this visitor collects name\n- * mappings as it visits tree nodes. Subsequent code generation steps can check\n- * the collected names using getters.\n+ * This visitor handles java safe names for identifiers, type names and stores such names\n+ * in the corresponding declaration. The mangled name is later retrieved by\n+ * OutputFactory via the lookup methods provided by this class.\n@@ -47,1 +51,1 @@\n-final class NameMangler implements Declaration.Visitor<Void, Declaration> {\n+public final class NameMangler implements Declaration.Visitor<Void, Declaration> {\n@@ -50,0 +54,6 @@\n+    \/*\n+     * This map is needed because there is no way to share attributes between a typedef declaration\n+     * and the typedef type pointing to that declaration. As such, we need to store typedef names in a map\n+     * so that we can recover them later when we see a variable decl whose type is a typedef.\n+     *\/\n+    private final Map<Type, String> functionTypeDefNames = new HashMap<>();\n@@ -69,3 +79,1 @@\n-             this.className = parent != null ?\n-                  parent.uniqueNestedClassName(name) :\n-                  javaSafeIdentifier(name);\n+             this.className = javaSafeIdentifier(name);\n@@ -93,0 +101,10 @@\n+\n+         List<String> fullName() {\n+             List<String> names = new ArrayList<>();\n+             Scope current = this;\n+             while (current != null && current.isStruct) {\n+                 names.add(0, current.className);\n+                 current = current.parent;\n+             }\n+             return names;\n+         }\n@@ -97,10 +115,1 @@\n-    private static record NameAndDecl(String name, Declaration decl) {}\n-    \/\/ key is either Declaration or NameAndDecl\n-    private final Map<Object, String> declJavaNames = new HashMap<>();\n-\n-    private static record DeclPair(Declaration parent, Declaration decl) {}\n-    \/\/ key is either Declaration or NameAndDecl or DeclPair\n-    private final Map<Object, String> declFiNames = new HashMap<>();\n-    private final Map<Type.Function, List<String>> parameterNames = new HashMap<>();\n-\n-    NameMangler(String headerName) {\n+    public NameMangler(String headerName) {\n@@ -110,82 +119,0 @@\n-    \/\/ package private name lookup API\n-    String getJavaName(Declaration parent, Declaration decl) {\n-        Objects.requireNonNull(decl);\n-        if (declJavaNames.containsKey(decl)) {\n-            return Objects.requireNonNull(declJavaNames.get(decl));\n-        } else {\n-            var name = decl.name().isEmpty()? parent.name() : decl.name();\n-            var nameAndDecl = new NameAndDecl(name, decl);\n-            return Objects.requireNonNull(declJavaNames.get(nameAndDecl));\n-        }\n-    }\n-\n-    Optional<List<String>> getParameterNames(Type.Function func) {\n-        return Optional.ofNullable(parameterNames.get(func));\n-    }\n-\n-    String getFiName(Declaration.Function func, int paramNum, Declaration.Variable param) {\n-        Objects.requireNonNull(func);\n-        Objects.requireNonNull(param);\n-        var nameAndDecl = new NameAndDecl(funcParamID(func, paramNum), param);\n-        return Objects.requireNonNull(declFiNames.get(nameAndDecl));\n-    }\n-\n-    String getReturnFiName(Declaration.Function func) {\n-        Objects.requireNonNull(func);\n-        return funcReturnID(func);\n-    }\n-\n-    String getFiName(Declaration parent, Declaration decl) {\n-        Objects.requireNonNull(decl);\n-        if (declFiNames.containsKey(decl)) {\n-            return Objects.requireNonNull(declFiNames.get(decl));\n-        } else {\n-            Objects.requireNonNull(parent);\n-            var declPair = new DeclPair(parent, decl);\n-            return Objects.requireNonNull(declFiNames.get(declPair));\n-        }\n-    }\n-\n-    \/\/ Internals below this point\n-\n-    private static String funcReturnID(Declaration.Function func) {\n-        return func.name() + \"$return\";\n-    }\n-\n-    private static String funcParamID(Declaration.Function func, int paramNum) {\n-        return func.name() + \"$\" + paramNum;\n-    }\n-\n-    private void putJavaName(Declaration decl, String javaName) {\n-        assert decl != null;\n-        assert javaName != null;\n-        declJavaNames.put(decl, javaName);\n-    }\n-\n-    private void putJavaName(String name, Declaration decl, String javaName) {\n-        assert name != null;\n-        assert decl != null;\n-        assert javaName != null;\n-        declJavaNames.put(new NameAndDecl(name, decl), javaName);\n-    }\n-\n-    private void putFiName(Declaration decl, String javaName) {\n-        assert decl != null;\n-        assert javaName != null;\n-        declFiNames.put(decl, javaName);\n-    }\n-\n-    private void putFiName(Declaration parent, Declaration.Variable variable, String javaName) {\n-        assert parent != null;\n-        assert variable != null;\n-        assert javaName != null;\n-        declFiNames.put(new DeclPair(parent, variable), javaName);\n-    }\n-\n-    private void putFiName(String name, Declaration decl, String javaName) {\n-        assert name != null;\n-        assert decl != null;\n-        assert javaName != null;\n-        declFiNames.put(new NameAndDecl(name, decl), javaName);\n-    }\n-\n@@ -193,1 +120,1 @@\n-    Declaration.Scoped scan(Declaration.Scoped header) {\n+    public Declaration.Scoped scan(Declaration.Scoped header) {\n@@ -196,1 +123,1 @@\n-        putJavaName(header, javaName);\n+        JavaName.with(header, List.of(javaName));\n@@ -204,1 +131,1 @@\n-        putJavaName(constant, makeJavaName(constant));\n+        JavaName.with(constant, makeJavaName(constant));\n@@ -210,1 +137,1 @@\n-        putJavaName(func, makeJavaName(func));\n+        JavaName.with(func, makeJavaName(func));\n@@ -215,2 +142,2 @@\n-                String declFiName = func.name() + \"$\" + (param.name().isEmpty() ? \"x\" + i : param.name());\n-                putFiName(funcParamID(func, i), param, declFiName);\n+                String fiName = func.name() + \"$\" + (param.name().isEmpty() ? \"x\" + i : param.name());\n+                JavaFunctionalInterfaceName.with(param, fiName);\n@@ -219,1 +146,2 @@\n-            putJavaName(param, makeJavaName(param));\n+            JavaName.with(param, makeJavaName(param));\n+            Utils.forEachNested(param, s -> s.accept(this, func));\n@@ -222,0 +150,6 @@\n+        Type.Function returnFunc = Utils.getAsFunctionPointer(func.type().returnType());\n+        if (returnFunc != null) {\n+            JavaFunctionalInterfaceName.with(func, func.name() + \"$return\");\n+        }\n+        Utils.forEachNested(func, s -> s.accept(this, func));\n+\n@@ -227,10 +161,7 @@\n-        String name = scoped.name().isEmpty()? parent.name() : scoped.name();\n-        if (declJavaNames.containsKey(new NameAndDecl(name, scoped))) {\n-            \/\/skip struct that's seen already\n-            return null;\n-        }\n-\n-        boolean isStruct = Utils.isStructOrUnion(scoped);\n-        if (!isStruct) {\n-            return null;\n-        }\n+        if (Utils.isEnum(scoped)) {\n+            scoped.members().forEach(fieldTree -> fieldTree.accept(this, null));\n+        } else if (Utils.isStructOrUnion(scoped)) {\n+            if (JavaName.isPresent(scoped)) {\n+                \/\/skip struct that's seen already\n+                return null;\n+            }\n@@ -238,11 +169,21 @@\n-        Scope oldScope = curScope;\n-        boolean isNestedAnonStruct = scoped.name().isEmpty() &&\n-            (parent instanceof Declaration.Scoped);\n-        if (!isNestedAnonStruct) {\n-            this.curScope = Scope.newStruct(oldScope, name);\n-            putJavaName(name, scoped, curScope.className());\n-        }\n-        try {\n-            scoped.members().forEach(fieldTree -> fieldTree.accept(this, scoped));\n-        } finally {\n-            this.curScope = oldScope;\n+            Scope oldScope = curScope;\n+            if (!AnonymousStruct.isPresent(scoped)) {\n+                String name;\n+                if (parent instanceof Typedef typedef && typedef.type() instanceof Declared declared &&\n+                        declared.tree().name().isEmpty()) {\n+                    \/\/ typedef struct { ... } Foo;\n+                    \/\/ steal the name from the parent typedef (which has already been mangled)\n+                    name = JavaName.getOrThrow(parent);\n+                } else {\n+                    name = oldScope.uniqueNestedClassName(scoped.name().isEmpty() ?\n+                        fallbackNameFor(parent, scoped) :\n+                        scoped.name());\n+                }\n+                this.curScope = Scope.newStruct(oldScope, name);\n+                JavaName.with(scoped, curScope.fullName());\n+            }\n+            try {\n+                scoped.members().forEach(fieldTree -> fieldTree.accept(this, null));\n+            } finally {\n+                this.curScope = oldScope;\n+            }\n@@ -256,1 +197,1 @@\n-        if (declJavaNames.containsKey(typedef)) {\n+        if (JavaName.isPresent(typedef)) {\n@@ -261,7 +202,0 @@\n-        \/\/ handle if this typedef is of a struct\/union\/enum etc.\n-        if (typedef.type() instanceof Type.Declared declared) {\n-            declared.tree().accept(this, typedef);\n-        }\n-\n-        \/\/ We may potentially generate a class for a typedef. Make sure\n-        \/\/ class name is unique in the current nesting context.\n@@ -269,1 +203,1 @@\n-        putJavaName(typedef, javaName);\n+        JavaName.with(typedef, List.of(javaName));\n@@ -272,11 +206,2 @@\n-           var paramNamesOpt = func.parameterNames();\n-           if (paramNamesOpt.isPresent()) {\n-               parameterNames.put(func,\n-                   paramNamesOpt.\n-                      get().\n-                      stream().\n-                      map(NameMangler::javaSafeIdentifier).\n-                      toList()\n-               );\n-           }\n-           putFiName(typedef, javaName);\n+           JavaFunctionalInterfaceName.with(typedef, javaName);\n+           functionTypeDefNames.put(typedef.type(), javaName);\n@@ -284,0 +209,5 @@\n+\n+        \/\/ handle if this typedef is of a struct\/union\/enum etc.\n+        Utils.forEachNested(typedef, d -> {\n+            d.accept(this, typedef);\n+        });\n@@ -287,0 +217,27 @@\n+    private String fallbackNameFor(Declaration parent, Declaration.Scoped nested) {\n+        String nestedName = parent.name();\n+        Function func = switch (parent) {\n+            case Declaration.Function f -> f.type();\n+            case Variable v -> Utils.getAsFunctionPointer(v.type());\n+            case Typedef t -> Utils.getAsFunctionPointer(t.type());\n+            default -> null;\n+        };\n+        if (func != null) {\n+            \/\/ if this is a function pointer type def, try to use better fallback names for any\n+            \/\/ anon struct\/union that might be defined as part of this typedef\n+            String suffix = null;\n+            for (int i = 0 ; i < func.argumentTypes().size() ; i++) {\n+                if (func.argumentTypes().get(i) instanceof Type.Declared declared && declared.tree() == nested) {\n+                    \/\/ it's a function argument\n+                    suffix = \"$x\" + i;\n+                }\n+            }\n+            if (suffix == null) {\n+                \/\/ not found, assume it's the function return\n+                suffix = \"$return\";\n+            }\n+            nestedName = nestedName + suffix;\n+        }\n+        return nestedName;\n+    }\n+\n@@ -289,1 +246,1 @@\n-        putJavaName(variable, makeJavaName(variable));\n+        JavaName.with(variable, makeJavaName(variable));\n@@ -291,4 +248,0 @@\n-        if (type instanceof Type.Declared declared) {\n-            \/\/ declared type - visit declaration recursively\n-            declared.tree().accept(this, variable);\n-        }\n@@ -297,5 +250,6 @@\n-            String fiName = curScope.uniqueNestedClassName(variable.name());\n-            if (parent != null) {\n-                putFiName(parent, variable, fiName);\n-            } else {\n-                putFiName(variable, fiName);\n+            String declFiName = curScope.uniqueNestedClassName(variable.name());\n+            JavaFunctionalInterfaceName.with(variable, declFiName);\n+        } else if (variable.type() instanceof Delegated delegatedType) {\n+            String typedefName = functionTypeDefNames.get(delegatedType.type());\n+            if (typedefName != null) {\n+                JavaFunctionalInterfaceName.with(variable, typedefName);\n@@ -304,0 +258,1 @@\n+        Utils.forEachNested(variable, s -> s.accept(this, variable));\n@@ -312,8 +267,4 @@\n-    private List<String> javaSafeNameList(List<String> names) {\n-        return names.stream().\n-            map(n -> n.isEmpty()? n : javaSafeIdentifier(n)).\n-            toList();\n-    }\n-\n-    private String makeJavaName(Declaration decl) {\n-        return decl.name().isEmpty()? decl.name() : javaSafeIdentifier(decl.name());\n+    private List<String> makeJavaName(Declaration decl) {\n+        return decl.name().isEmpty() ?\n+                List.of(decl.name()) :\n+                List.of(javaSafeIdentifier(decl.name()));\n@@ -323,1 +274,1 @@\n-    private static String javaSafeIdentifier(String name) {\n+    public static String javaSafeIdentifier(String name) {\n@@ -327,0 +278,6 @@\n+    public static List<String> javaSafeIdentifiers(List<String> names) {\n+        return names.stream().\n+                map(NameMangler::javaSafeIdentifier).\n+                toList();\n+    }\n+\n@@ -371,2 +328,2 @@\n-                \"Arena\", \"NativeArena\", \"MemorySegment\", \"ValueLayout\",\n-                \"RuntimeHelper\" -> true;\n+                \"Arena\", \"NativeArena\", \"MemorySegment\", \"ValueLayout\"\n+                    -> true;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/NameMangler.java","additions":131,"deletions":174,"binary":false,"changes":305,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,3 @@\n-    public final List<String> libraryNames;\n-    public final List<String> filters;\n+    public final List<Library> libraries;\n+    \/\/ The symbol lookup kind\n+    public final boolean useSystemLoadLibrary;\n@@ -40,1 +41,0 @@\n-    public final boolean source;\n@@ -43,3 +43,2 @@\n-    private Options(List<String> clangArgs, List<String> libraryNames,\n-            List<String> filters, String targetPackage,\n-            String outputDir, boolean source, IncludeHelper includeHelper) {\n+    private Options(List<String> clangArgs, List<Library> libraries, boolean useSystemLoadLibrary,\n+                    String targetPackage, String outputDir, IncludeHelper includeHelper) {\n@@ -47,2 +46,2 @@\n-        this.libraryNames = libraryNames;\n-        this.filters = filters;\n+        this.libraries = libraries;\n+        this.useSystemLoadLibrary = useSystemLoadLibrary;\n@@ -51,1 +50,0 @@\n-        this.source = source;\n@@ -59,4 +57,0 @@\n-    public static Options createDefault() {\n-        return builder().build();\n-    }\n-\n@@ -65,2 +59,2 @@\n-        private final List<String> libraryNames;\n-        private final List<String> filters;\n+        private final List<Library> libraries;\n+        private boolean useSystemLoadLibrary;\n@@ -69,2 +63,1 @@\n-        private boolean source;\n-        private IncludeHelper includeHelper = new IncludeHelper();\n+        private final IncludeHelper includeHelper = new IncludeHelper();\n@@ -74,2 +67,1 @@\n-            this.libraryNames = new ArrayList<>();\n-            this.filters = new ArrayList<>();\n+            this.libraries = new ArrayList<>();\n@@ -78,1 +70,1 @@\n-            this.source = false;\n+            this.useSystemLoadLibrary = false;\n@@ -84,3 +76,2 @@\n-                    Collections.unmodifiableList(libraryNames),\n-                    Collections.unmodifiableList(filters),\n-                    targetPackage, outputDir, source, includeHelper\n+                    Collections.unmodifiableList(libraries),\n+                    useSystemLoadLibrary, targetPackage, outputDir, includeHelper\n@@ -94,2 +85,6 @@\n-        public void addLibraryName(String name) {\n-            libraryNames.add(name);\n+        public void addLibrary(Library library) {\n+            libraries.add(library);\n+        }\n+\n+        public void setUseSystemLoadLibrary(boolean useSystemLoadLibrary) {\n+            this.useSystemLoadLibrary = useSystemLoadLibrary;\n@@ -106,8 +101,0 @@\n-        public void addFilter(String filter) {\n-            filters.add(filter);\n-        }\n-\n-        public void setGenerateSource() {\n-            source = true;\n-        }\n-\n@@ -122,0 +109,30 @@\n+\n+    \/**\n+     * A record describing a shared library.\n+     *\n+     * @param libSpec the library specification (either a name or a path, see below)\n+     * @param specKind the library specification kind (e.g. a name or a path)\n+     *\/\n+    public record Library(String libSpec, SpecKind specKind) {\n+\n+        public enum SpecKind {\n+            NAME,\n+            PATH;\n+        }\n+\n+        public static Library parse(String optionString) {\n+            SpecKind specKind = optionString.startsWith(\":\") ?\n+                    SpecKind.PATH : SpecKind.NAME;\n+            if (specKind == SpecKind.PATH && optionString.length() == 1) {\n+                \/\/ empty library specifier!\n+                throw new IllegalArgumentException();\n+            }\n+            return specKind == SpecKind.PATH ?\n+                    new Library(optionString.substring(1), specKind) :\n+                    new Library(optionString, specKind);\n+        }\n+\n+        String toQuotedName() {\n+            return libSpec().replace(\"\\\\\", \"\\\\\\\\\"); \/\/ double up slashes\n+        }\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Options.java","additions":51,"deletions":34,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.foreign.*;\n@@ -29,0 +28,1 @@\n+import org.openjdk.jextract.JavaSourceFile;\n@@ -30,0 +30,3 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.JavaName;\n+import org.openjdk.jextract.impl.DeclarationImpl.NestedDeclarations;\n+import org.openjdk.jextract.impl.DeclarationImpl.Skip;\n@@ -31,9 +34,0 @@\n-import javax.tools.JavaFileObject;\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.net.URI;\n-import java.net.URL;\n-import java.net.URISyntaxException;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n@@ -41,2 +35,0 @@\n-import java.util.HashMap;\n-import java.util.HashSet;\n@@ -44,4 +36,0 @@\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n@@ -56,30 +44,1 @@\n-    protected JavaSourceBuilder currentBuilder;\n-    private final String pkgName;\n-    private final Map<Declaration.Scoped, String> structClassNames = new HashMap<>();\n-    private final Set<Declaration.Typedef> unresolvedStructTypedefs = new HashSet<>();\n-    private final Map<Type.Delegated, String> functionTypeDefNames = new HashMap<>();\n-    private final NameMangler nameMangler;\n-\n-    private void addStructDefinition(Declaration.Scoped decl, String name) {\n-        structClassNames.put(decl, name);\n-    }\n-\n-    private boolean structDefinitionSeen(Declaration.Scoped decl) {\n-        return structClassNames.containsKey(decl);\n-    }\n-\n-    private String structDefinitionName(Declaration.Scoped decl) {\n-        return structClassNames.get(decl);\n-    }\n-\n-    private void addFunctionTypedef(Type.Delegated typedef, String name) {\n-        functionTypeDefNames.put(typedef, name);\n-    }\n-\n-    private boolean functionTypedefSeen(Type.Delegated typedef) {\n-        return functionTypeDefNames.containsKey(typedef);\n-    }\n-\n-    private String functionTypedefName(Type.Delegated decl) {\n-        return functionTypeDefNames.get(decl);\n-    }\n+    protected Builder currentBuilder;\n@@ -87,6 +46,6 @@\n-    static JavaFileObject[] generateWrapped(Declaration.Scoped decl,\n-                String pkgName, List<String> libraryNames, NameMangler nameMangler) {\n-        String clsName = nameMangler.getJavaName(null, decl);\n-        ToplevelBuilder toplevelBuilder = new ToplevelBuilder(pkgName, clsName);\n-        return new OutputFactory(pkgName, toplevelBuilder, nameMangler).\n-            generate(decl, libraryNames.toArray(new String[0]));\n+    public static JavaSourceFile[] generateWrapped(Declaration.Scoped decl,\n+                                                   String pkgName,\n+                                                   List<Options.Library> libs, boolean useSystemLoadLibrary) {\n+        String clsName = JavaName.getOrThrow(decl);\n+        ToplevelBuilder toplevelBuilder = new ToplevelBuilder(pkgName, clsName, libs, useSystemLoadLibrary);\n+        return new OutputFactory(toplevelBuilder).generate(decl);\n@@ -95,2 +54,1 @@\n-    private OutputFactory(String pkgName, ToplevelBuilder toplevelBuilder, NameMangler nameMangler) {\n-        this.pkgName = pkgName;\n+    private OutputFactory(ToplevelBuilder toplevelBuilder) {\n@@ -99,1 +57,0 @@\n-        this.nameMangler = nameMangler;\n@@ -102,1 +59,1 @@\n-    JavaFileObject[] generate(Declaration.Scoped decl, String[] libs) {\n+    JavaSourceFile[] generate(Declaration.Scoped decl) {\n@@ -105,34 +62,2 @@\n-        \/\/ check if unresolved typedefs can be resolved now!\n-        for (Declaration.Typedef td : unresolvedStructTypedefs) {\n-            Declaration.Scoped structDef = ((Type.Declared) td.type()).tree();\n-            toplevelBuilder.addTypedef(td, nameMangler.getJavaName(null, td), structDefinitionName(structDef));\n-        }\n-        try {\n-            List<JavaFileObject> files = new ArrayList<>(toplevelBuilder.toFiles());\n-            files.add(jfoFromString(pkgName,\"RuntimeHelper\", getRuntimeHelperSource(libs)));\n-            return files.toArray(new JavaFileObject[0]);\n-        } catch (IOException ex) {\n-            throw new UncheckedIOException(ex);\n-        } catch (URISyntaxException ex2) {\n-            throw new RuntimeException(ex2);\n-        }\n-    }\n-\n-    private String getRuntimeHelperSource(String[] libraries) throws URISyntaxException, IOException {\n-        URL runtimeHelper = OutputFactory.class.getResource(\"resources\/RuntimeHelper.java.template\");\n-        String template = (pkgName.isEmpty()? \"\" : \"package \" + pkgName + \";\\n\") +\n-                        String.join(\"\\n\", Files.readAllLines(Paths.get(runtimeHelper.toURI())));\n-        List<String> loadLibrariesStr = new ArrayList<>();\n-        for (String lib : libraries) {\n-            String quotedLibName = quoteLibraryName(lib);\n-            if (quotedLibName.indexOf(File.separatorChar) != -1) {\n-                loadLibrariesStr.add(\"System.load(\\\"\" + quotedLibName + \"\\\");\");\n-            } else {\n-                loadLibrariesStr.add(\"System.loadLibrary(\\\"\" + quotedLibName + \"\\\");\");\n-            }\n-        }\n-        return template.replace(\"#LOAD_LIBRARIES#\", loadLibrariesStr.stream().collect(Collectors.joining(\" \")));\n-    }\n-\n-    private String quoteLibraryName(String lib) {\n-        return lib.replace(\"\\\\\", \"\\\\\\\\\"); \/\/ double up slashes\n+        List<JavaSourceFile> files = new ArrayList<>(toplevelBuilder.toFiles());\n+        return files.toArray(JavaSourceFile[]::new);\n@@ -149,5 +74,0 @@\n-    private JavaFileObject jfoFromString(String pkgName, String clsName, String contents) {\n-        String pkgPrefix = pkgName.isEmpty() ? \"\" : pkgName.replaceAll(\"\\\\.\", \"\/\") + \"\/\";\n-        return InMemoryJavaCompiler.jfoFromString(URI.create(pkgPrefix + clsName + \".java\"), contents);\n-    }\n-\n@@ -156,6 +76,1 @@\n-        \/*\n-         * This method is called from visitVariable when it recursively visits type\n-         * When type is enum, enum constants are visited again! Checking parent to be\n-         * null to avoid duplicate generation of enum constant getter methods.\n-         *\/\n-        if (parent != null) {\n+        if (Skip.isPresent(constant)) {\n@@ -165,6 +80,1 @@\n-        Class<?> clazz = getJavaType(constant.type());\n-        if (clazz == null) {\n-            warn(\"skipping \" + constant.name() + \" because of unsupported type usage\");\n-            return null;\n-        }\n-        toplevelBuilder.addConstant(constant, nameMangler.getJavaName(parent, constant), clazz);\n+        toplevelBuilder.addConstant(constant);\n@@ -176,2 +86,1 @@\n-        if (d.layout().isEmpty() || structDefinitionSeen(d)) {\n-            \/\/skip decl\n+        if (Skip.isPresent(d)) {\n@@ -181,0 +90,1 @@\n+        Skip.with(d); \/\/ do not generate twice\n@@ -182,0 +92,1 @@\n+        Builder prevBuilder = null;\n@@ -184,15 +95,2 @@\n-            GroupLayout layout = (GroupLayout) layoutFor(d);\n-            boolean isNestedAnonStruct = d.name().isEmpty() &&\n-                (parent instanceof Declaration.Scoped);\n-            currentBuilder = structBuilder = currentBuilder.addStruct(\n-                d,\n-                isNestedAnonStruct,\n-                isNestedAnonStruct? null : nameMangler.getJavaName(parent, d),\n-                layout);\n-            structBuilder.classBegin();\n-            if (!d.name().isEmpty()) {\n-                addStructDefinition(d, structBuilder.fullName());\n-            }\n-            if (parent instanceof Declaration.Typedef) {\n-                addStructDefinition(d, structBuilder.fullName());\n-            }\n+            prevBuilder = currentBuilder;\n+            currentBuilder = structBuilder = currentBuilder.addStruct(d);\n@@ -204,1 +102,2 @@\n-                currentBuilder = structBuilder.classEnd();\n+                structBuilder.end();\n+                currentBuilder = prevBuilder;\n@@ -210,22 +109,2 @@\n-    private boolean generateFunctionalInterface(Type.Function func, String javaName) {\n-        String unsupportedType = UnsupportedLayouts.firstUnsupportedType(func);\n-        if (unsupportedType != null) {\n-            warn(\"skipping \" + javaName + \" because of unsupported type usage: \" +\n-                    unsupportedType);\n-            return false;\n-        }\n-\n-        FunctionDescriptor descriptor = Type.descriptorFor(func).orElse(null);\n-        if (descriptor == null) {\n-            return false;\n-        }\n-\n-        \/\/generate functional interface\n-        if (func.varargs() && !func.argumentTypes().isEmpty()) {\n-            warn(\"varargs in callbacks is not supported: \" + CDeclarationPrinter.declaration(func, javaName));\n-            return false;\n-        }\n-\n-        currentBuilder.addFunctionalInterface(func, javaName, descriptor,\n-            nameMangler.getParameterNames(func));\n-        return true;\n+    private void generateFunctionalInterface(Declaration parentDecl, Type.Function func) {\n+        currentBuilder.addFunctionalInterface(parentDecl, func);\n@@ -236,10 +115,1 @@\n-        \/\/generate static wrapper for function\n-        String unsupportedType = UnsupportedLayouts.firstUnsupportedType(funcTree.type());\n-        if (unsupportedType != null) {\n-            warn(\"skipping \" + funcTree.name() + \" because of unsupported type usage: \" +\n-                    unsupportedType);\n-            return null;\n-        }\n-\n-        FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).orElse(null);\n-        if (descriptor == null) {\n+        if (Skip.isPresent(funcTree)) {\n@@ -250,1 +120,0 @@\n-        int i = 0;\n@@ -252,0 +121,1 @@\n+            Utils.forEachNested(param, s -> s.accept(this, param));\n@@ -254,5 +124,1 @@\n-                String fiName = nameMangler.getFiName(funcTree, i, param);\n-                if (! generateFunctionalInterface(f, fiName)) {\n-                    return null;\n-                }\n-                i++;\n+                generateFunctionalInterface(param, f);\n@@ -262,0 +128,2 @@\n+        Utils.forEachNested(funcTree, s -> s.accept(this, funcTree));\n+\n@@ -265,3 +133,1 @@\n-             if (! generateFunctionalInterface(returnFunc, nameMangler.getReturnFiName(funcTree))) {\n-                 return null;\n-             }\n+             generateFunctionalInterface(funcTree, returnFunc);\n@@ -270,6 +136,1 @@\n-        toplevelBuilder.addFunction(funcTree, descriptor, nameMangler.getJavaName(parent, funcTree),\n-            funcTree.parameters().\n-                stream().\n-                map(param -> nameMangler.getJavaName(null, param)).\n-                toList());\n-\n+        toplevelBuilder.addFunction(funcTree);\n@@ -279,10 +140,0 @@\n-    Optional<String> getAsFunctionPointerTypedef(Type type) {\n-        if (type instanceof Type.Delegated delegated &&\n-                delegated.kind() == Type.Delegated.Kind.TYPEDEF &&\n-                functionTypedefSeen(delegated)) {\n-            return Optional.of(functionTypedefName(delegated));\n-        } else {\n-            return Optional.empty();\n-        }\n-    }\n-\n@@ -291,0 +142,3 @@\n+        if (Skip.isPresent(tree)) {\n+            return null;\n+        }\n@@ -292,33 +146,10 @@\n-        if (type instanceof Type.Declared declared) {\n-            Declaration.Scoped s = declared.tree();\n-            if (!s.name().equals(tree.name())) {\n-                switch (s.kind()) {\n-                    case STRUCT, UNION -> {\n-                        if (s.name().isEmpty()) {\n-                            visitScoped(s, tree);\n-                        } else {\n-                            \/*\n-                             * If typedef is seen after the struct\/union definition, we can generate subclass\n-                             * right away. If not, we've to save it and revisit after all the declarations are\n-                             * seen. This is to support forward declaration of typedefs.\n-                             *\n-                             * typedef struct Foo Bar;\n-                             *\n-                             * struct Foo {\n-                             *     int x, y;\n-                             * };\n-                             *\/\n-                            if (structDefinitionSeen(s)) {\n-                                String javaName = nameMangler.getJavaName(parent, tree);\n-                                toplevelBuilder.addTypedef(tree, javaName, structDefinitionName(s));\n-                            } else {\n-                                \/*\n-                                 * Definition of typedef'ed struct\/union not seen yet. May be the definition comes later.\n-                                 * Save it to visit at the end of all declarations.\n-                                 *\/\n-                                unresolvedStructTypedefs.add(tree);\n-                            }\n-                        }\n-                    }\n-                    default -> visitScoped(s, tree);\n-                }\n+        Utils.forEachNested(tree, s -> s.accept(this, null));\n+\n+        Declaration.Scoped structOrUnionDecl = Utils.structOrUnionDecl(type);\n+        if (structOrUnionDecl != null) {\n+            if (!structOrUnionDecl.name().isEmpty() ||\n+                    !NestedDeclarations.get(tree).orElse(List.of()).contains(structOrUnionDecl)) {\n+                \/\/ Only generate a typedef class if (a) struct\/union name is non-empty,\n+                \/\/ or if (b) the declaration of the struct\/union is not nested inside this typedef,\n+                \/\/ which indicates a typedef of some other typedef.\n+                toplevelBuilder.addTypedef(tree, JavaName.getFullNameOrThrow(structOrUnionDecl));\n@@ -327,1 +158,1 @@\n-            toplevelBuilder.addTypedef(tree, nameMangler.getJavaName(parent, tree), null);\n+            toplevelBuilder.addTypedef(tree, null);\n@@ -331,5 +162,1 @@\n-                String fiName = nameMangler.getFiName(parent, tree);\n-                boolean funcIntfGen = generateFunctionalInterface(func, fiName);\n-                if (funcIntfGen) {\n-                    addFunctionTypedef(Type.typedef(tree.name(), tree.type()), fiName);\n-                }\n+                generateFunctionalInterface(tree, func);\n@@ -337,1 +164,1 @@\n-                toplevelBuilder.addTypedef(tree, nameMangler.getJavaName(parent, tree), null);\n+                toplevelBuilder.addTypedef(tree, null);\n@@ -341,1 +168,1 @@\n-                    toplevelBuilder.addTypedef(tree, nameMangler.getJavaName(parent, tree), null, primitive);\n+                    toplevelBuilder.addTypedef(tree, null, primitive);\n@@ -350,10 +177,1 @@\n-        Type type = tree.type();\n-\n-        if (type instanceof Type.Declared declared) {\n-            \/\/ declared type - visit declaration recursively\n-            declared.tree().accept(this, tree);\n-        }\n-\n-        MemoryLayout layout = Type.layoutFor(type).orElse(null);\n-        if (layout == null) {\n-            \/\/no layout - abort\n+        if (Skip.isPresent(tree)) {\n@@ -362,0 +180,1 @@\n+        Type type = tree.type();\n@@ -363,5 +182,1 @@\n-        if (tree.kind() == Declaration.Variable.Kind.BITFIELD ||\n-                (layout instanceof ValueLayout && layout.byteSize() > 8)) {\n-            \/\/skip\n-            return null;\n-        }\n+        Utils.forEachNested(tree, s -> s.accept(this, tree));\n@@ -372,7 +187,3 @@\n-        String unsupportedType = UnsupportedLayouts.firstUnsupportedType(type);\n-        if (unsupportedType != null) {\n-            String name = parent != null? parent.name() + \".\" : \"\";\n-            name += fieldName;\n-            warn(\"skipping \" + name + \" because of unsupported type usage: \" +\n-                    unsupportedType);\n-            return null;\n+        Type.Function func = Utils.getAsFunctionPointer(type);\n+        if (func != null) {\n+            generateFunctionalInterface(tree, func);\n@@ -381,7 +192,3 @@\n-        Class<?> clazz = getJavaType(type);\n-        if (clazz == null) {\n-            String name = parent != null? parent.name() + \".\" : \"\";\n-            name += fieldName;\n-            warn(\"skipping \" + name + \" because of unsupported type usage\");\n-            return null;\n-        }\n+        currentBuilder.addVar(tree);\n+        return null;\n+    }\n@@ -389,0 +196,1 @@\n+    interface Builder {\n@@ -390,12 +198,2 @@\n-        Type.Function func = Utils.getAsFunctionPointer(type);\n-        String fiName = null;\n-        if (func != null) {\n-            fiName = nameMangler.getFiName(parent, tree);\n-            if (! generateFunctionalInterface(func, fiName)) {\n-                fiName = null;\n-            }\n-        } else {\n-            Optional<String> funcTypedef = getAsFunctionPointerTypedef(type);\n-            if (funcTypedef.isPresent()) {\n-                fiName = funcTypedef.get();\n-            }\n+        default void addVar(Declaration.Variable varTree) {\n+            throw new UnsupportedOperationException(\"Not implemented\");\n@@ -404,1 +202,3 @@\n-        currentBuilder.addVar(tree, nameMangler.getJavaName(parent, tree), layout, Optional.ofNullable(fiName));\n+        default void addFunction(Declaration.Function funcTree) {\n+            throw new UnsupportedOperationException(\"Not implemented\");\n+        }\n@@ -406,2 +206,3 @@\n-        return null;\n-    }\n+        default void addConstant(Declaration.Constant constantTree) {\n+            throw new UnsupportedOperationException(\"Not implemented\");\n+        }\n@@ -409,7 +210,2 @@\n-    protected static MemoryLayout layoutFor(Declaration decl) {\n-        if (decl instanceof Declaration.Typedef alias) {\n-            return Type.layoutFor(alias.type()).orElseThrow();\n-        } else if (decl instanceof Declaration.Scoped scoped) {\n-            return scoped.layout().orElseThrow();\n-        } else {\n-            throw new IllegalArgumentException(\"Unexpected parent declaration\");\n+        default void addTypedef(Declaration.Typedef typedefTree, String superClass) {\n+            addTypedef(typedefTree, superClass, typedefTree.type());\n@@ -417,2 +213,0 @@\n-        \/\/ case like `typedef struct { ... } Foo`\n-    }\n@@ -420,3 +214,3 @@\n-    static void warn(String msg) {\n-        System.err.println(\"WARNING: \" + msg);\n-    }\n+        default void addTypedef(Declaration.Typedef typedefTree, String superClass, Type type) {\n+            throw new UnsupportedOperationException(\"Not implemented\");\n+        }\n@@ -424,9 +218,6 @@\n-    private Class<?> getJavaType(Type type) {\n-        Optional<MemoryLayout> layout = Type.layoutFor(type);\n-        if (!layout.isPresent()) return null;\n-        if (layout.get() instanceof SequenceLayout || layout.get() instanceof GroupLayout) {\n-            return MemorySegment.class;\n-        } else if (layout.get() instanceof ValueLayout valueLayout) {\n-            return valueLayout.carrier();\n-        } else {\n-            return null;\n+        default StructBuilder addStruct(Declaration.Scoped structTree) {\n+            throw new UnsupportedOperationException(\"Not implemented\");\n+        }\n+\n+        default void addFunctionalInterface(Declaration parentDecl, Type.Function funcType) {\n+            throw new UnsupportedOperationException(\"Not implemented\");\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":79,"deletions":288,"binary":false,"changes":367,"status":"modified"},{"patch":"@@ -103,1 +103,0 @@\n-            treeMaker.freeze();\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Parser.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,2 +29,1 @@\n-import java.lang.constant.Constable;\n-import java.util.Set;\n+import java.util.Collection;\n@@ -32,1 +31,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -35,1 +33,0 @@\n-import org.openjdk.jextract.Declaration.Variable.Kind;\n@@ -59,14 +56,16 @@\n-        Set<String> attrs = decl.attributeNames();\n-        if (attrs.isEmpty()) {\n-            return;\n-        }\n-        incr();\n-        indent();\n-        for (String k: attrs) {\n-            builder.append(\"Attr: \");\n-            builder.append(k);\n-            builder.append(\" -> [\");\n-            builder.append(decl.getAttribute(k).get().stream()\n-                .map(Constable::toString)\n-                .collect(Collectors.joining(\", \")));\n-            builder.append(\"]\\n\");\n+        Collection<Record> attrs = decl.attributes();\n+        if (!attrs.isEmpty()) {\n+            incr();\n+            indent();\n+            builder.append(\"Attributes: \");\n+            String sep = \"\\n\";\n+            for (Record attr : attrs) {\n+                builder.append(sep);\n+                incr();\n+                indent();\n+                builder.append(attr);\n+                decr();\n+                sep = \",\\n\";\n+            }\n+            builder.append(\"\\n\");\n+            decr();\n@@ -74,1 +73,0 @@\n-        decr();\n@@ -85,2 +83,1 @@\n-        builder.append(\"Scoped: \" + d.kind() + \" \" + d.name() + d.layout().map(l -> \" layout = \" + l).orElse(\"\"));\n-        builder.append(\"\\n\");\n+        builder.append(\"Scoped: \" + d.kind() + \" \" + d.name() + \"\\n\");\n@@ -111,1 +108,1 @@\n-                    + \", offset = \" + bitfield.offset() + \", width = \" + bitfield.width());\n+                    + \", width = \" + bitfield.width());\n@@ -141,1 +138,1 @@\n-            return t.kind().toString() + t.kind().layout().map(l -> \"(layout = \" + l + \")\").orElse(\"\");\n+            return t.kind().toString();\n@@ -167,1 +164,1 @@\n-            return \"Declared(\" + t.tree().layout().map(MemoryLayout::toString).orElse(\"\") + \")\";\n+            return \"Declared(\" + t.tree().name() + \")\";\n@@ -179,1 +176,3 @@\n-            return \"Unknown type: \" + t.getClass().getName();\n+            return t.isErroneous() ?\n+                    STR.\"<error: \\{((TypeImpl.ErronrousTypeImpl)t).erroneousName}>\" :\n+                    STR.\"<unknown: \\{t.getClass().getName()}>\";\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/PrettyPrinter.java","additions":24,"deletions":25,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1,244 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package org.openjdk.jextract.impl;\n-\n-import java.lang.foreign.AddressLayout;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import org.openjdk.jextract.Declaration;\n-import org.openjdk.jextract.clang.Cursor;\n-import org.openjdk.jextract.clang.CursorKind;\n-import org.openjdk.jextract.clang.Type;\n-import org.openjdk.jextract.clang.TypeKind;\n-\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.StructLayout;\n-import java.lang.foreign.ValueLayout;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\/**\n- * Base class for C struct, union MemoryLayout computer helper classes.\n- *\/\n-abstract class RecordLayoutComputer {\n-    \/\/ enclosing struct type (or this struct type for top level structs)\n-    final Type parent;\n-    \/\/ this struct type\n-    final Type type;\n-    \/\/ cursor of this struct\n-    final Cursor cursor;\n-    final List<Declaration> fieldDecls;\n-    final List<MemoryLayout> fieldLayouts;\n-\n-    final TypeMaker typeMaker;\n-\n-    private int anonCount = 0;\n-\n-    RecordLayoutComputer(TypeMaker typeMaker, Type parent, Type type) {\n-        this.parent = parent;\n-        this.type = type;\n-        this.cursor = type.getDeclarationCursor().getDefinition();\n-        this.fieldDecls = new ArrayList<>();\n-        this.fieldLayouts = new ArrayList<>();\n-        this.typeMaker = typeMaker;\n-    }\n-\n-    static org.openjdk.jextract.Type compute(TypeMaker typeMaker, long offsetInParent, Type parent, Type type) {\n-        return computeInternal(typeMaker, offsetInParent, parent, type, null);\n-    }\n-\n-    private static org.openjdk.jextract.Type computeAnonymous(TypeMaker typeMaker, long offsetInParent, Type parent, Type type, String name) {\n-        return computeInternal(typeMaker, offsetInParent, parent, type, name);\n-    }\n-\n-    static final org.openjdk.jextract.Type.Declared ERRONEOUS = org.openjdk.jextract.Type.declared(\n-            Declaration.struct(TreeMaker.CursorPosition.NO_POSITION, \"\", MemoryLayout.paddingLayout(8)));\n-\n-    private static org.openjdk.jextract.Type computeInternal(TypeMaker typeMaker, long offsetInParent, Type parent, Type type, String name) {\n-        Cursor cursor = type.getDeclarationCursor().getDefinition();\n-        if (cursor.isInvalid()) {\n-            return ERRONEOUS;\n-        }\n-\n-        final boolean isUnion = cursor.kind() == CursorKind.UnionDecl;\n-        return isUnion? new UnionLayoutComputer(typeMaker, offsetInParent, parent, type).compute(name) :\n-                new StructLayoutComputer(typeMaker, offsetInParent, parent, type).compute(name);\n-    }\n-\n-    final org.openjdk.jextract.Type.Declared compute(String anonName) {\n-        cursor.forEach(fc -> {\n-            if (Utils.isFlattenable(fc)) {\n-                \/*\n-                 * Ignore bitfields of zero width.\n-                 *\n-                 * struct Foo {\n-                 *     int i:0;\n-                 * }\n-                 *\n-                 * And bitfields without a name.\n-                 * (padding is computed automatically)\n-                 *\/\n-                if (fc.isBitField() && (fc.getBitFieldWidth() == 0 || fc.spelling().isEmpty())) {\n-                    startBitfield();\n-                } else {\n-                    processField(fc);\n-                }\n-            }\n-        });\n-\n-        String declName = recordName();\n-        Declaration.Scoped declaration = finishRecord(anonName != null ? anonName : declName, declName);\n-        if (cursor.isAnonymousStruct()) {\n-            \/\/ record this with a declaration attribute, so we don't have to rely on the cursor again later\n-            declaration = (Declaration.Scoped)declaration.withAttribute(\"ANONYMOUS\", true);\n-        }\n-        return org.openjdk.jextract.Type.declared(declaration);\n-    }\n-\n-    abstract void startBitfield();\n-    abstract void processField(Cursor c);\n-    abstract Declaration.Scoped finishRecord(String layoutName, String declName);\n-\n-    void addField(long offset, Declaration declaration) {\n-        fieldDecls.add(declaration);\n-        MemoryLayout layout = null;\n-        if (declaration instanceof Declaration.Scoped scoped) {\n-            layout = scoped.layout().orElse(null);\n-        } else if (declaration instanceof Declaration.Variable var) {\n-            layout = org.openjdk.jextract.Type.layoutFor(var.type()).orElse(null);\n-        }\n-        if (layout != null) {\n-            fieldLayouts.add(declaration.name().isEmpty() ? layout : layout.withName(declaration.name()));\n-        }\n-    }\n-\n-    void addPadding(long bits) {\n-        fieldLayouts.add(MemoryLayout.paddingLayout(bits \/ 8));\n-    }\n-\n-    void addField(long offset, Type parent, Cursor c) {\n-        if (c.isAnonymousStruct()) {\n-            addField(offset, ((org.openjdk.jextract.Type.Declared)computeAnonymous(typeMaker, offset, parent, c.type(), nextAnonymousName())).tree());\n-        } else {\n-            addField(offset, field(offset, c));\n-        }\n-    }\n-\n-    private String nextAnonymousName() {\n-        return \"$anon$\" + anonCount++;\n-    }\n-\n-    Declaration field(long offset, Cursor c) {\n-        org.openjdk.jextract.Type type = typeMaker.makeType(c.type());\n-        String name = c.spelling();\n-        if (c.isBitField()) {\n-            return Declaration.bitfield(TreeMaker.CursorPosition.of(c), name, type, offset, c.getBitFieldWidth());\n-        } else if (c.isAnonymousStruct() && type instanceof org.openjdk.jextract.Type.Declared decl) {\n-            return decl.tree();\n-        } else {\n-            return Declaration.field(TreeMaker.CursorPosition.of(c), name, type);\n-        }\n-    }\n-\n-    long fieldSize(Cursor c) {\n-        if (c.type().kind() == TypeKind.IncompleteArray) {\n-            return 0;\n-        }\n-        return c.isBitField() ? c.getBitFieldWidth() : c.type().size() * 8;\n-    }\n-\n-    Declaration.Scoped bitfield(Declaration.Variable... declarations) {\n-        return Declaration.bitfields(declarations[0].pos(), declarations);\n-    }\n-\n-    long offsetOf(Type parent, Cursor c) {\n-        if (c.kind() == CursorKind.FieldDecl) {\n-            return parent.getOffsetOf(c.spelling());\n-        } else {\n-            List<Long> offsets = new ArrayList<>();\n-            c.forEach(child -> {\n-                if (Utils.isFlattenable(child)) {\n-                    offsets.add(offsetOf(parent, child));\n-                }\n-            });\n-            return offsets.stream().findFirst()\n-                    .orElseThrow(() -> new IllegalStateException(\n-                            \"Can not find offset of: \" + c + \", in: \" + parent));\n-        }\n-    }\n-\n-    void checkSize(GroupLayout layout) {\n-        \/\/ sanity check\n-        if (cursor.type().size() != layout.byteSize()) {\n-            throw new AssertionError(\n-                    String.format(\"Unexpected size for layout %s. Found %d ; expected %d\",\n-                            layout, layout.byteSize(), cursor.type().size()));\n-        }\n-    }\n-\n-    private String recordName() {\n-        if (cursor.isAnonymous()) {\n-            return \"\";\n-        } else {\n-            return cursor.spelling();\n-        }\n-    }\n-\n-    MemoryLayout[] alignFields() {\n-        long align = cursor.type().align();\n-        return fieldLayouts.stream()\n-                .map(l -> forceAlign(l, align))\n-                .toArray(MemoryLayout[]::new);\n-    }\n-\n-    private static MemoryLayout forceAlign(MemoryLayout layout, long align) {\n-        if (align >= layout.byteAlignment()) {\n-            return layout; \/\/ fast-path\n-        }\n-        MemoryLayout res = switch (layout) {\n-            case GroupLayout groupLayout -> {\n-                MemoryLayout[] newMembers = groupLayout.memberLayouts()\n-                        .stream().map(l -> forceAlign(l, align)).toArray(MemoryLayout[]::new);\n-                yield groupLayout instanceof StructLayout ?\n-                        MemoryLayout.structLayout(newMembers) :\n-                        MemoryLayout.unionLayout(newMembers);\n-            }\n-            case SequenceLayout sequenceLayout ->\n-                MemoryLayout.sequenceLayout(sequenceLayout.elementCount(),\n-                        forceAlign(sequenceLayout.elementLayout(), align));\n-            default -> layout.withByteAlignment(align);\n-        };\n-        \/\/ copy name and target layout, if present\n-        if (layout.name().isPresent()) {\n-            res = res.withName(layout.name().get());\n-        }\n-        if (layout instanceof AddressLayout addressLayout && addressLayout.targetLayout().isPresent()) {\n-            ((AddressLayout)res).withTargetLayout(addressLayout.targetLayout().get());\n-        }\n-        return res;\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/RecordLayoutComputer.java","additions":0,"deletions":244,"binary":false,"changes":244,"status":"deleted"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.impl;\n+\n+import org.openjdk.jextract.JavaSourceFile;\n+\n+import java.util.function.Function;\n+\n+final class SourceFileBuilder {\n+\n+    private static final boolean SHOW_GENERATING_CLASS = Boolean.getBoolean(\"jextract.showGeneratingClass\");\n+\n+    private final String packageName;\n+    private final String className;\n+\n+    \/\/ code buffer\n+    private final StringBuilder sb = new StringBuilder();\n+    \/\/ current line alignment (number of 4-spaces)\n+    private int align;\n+\n+    private SourceFileBuilder(String packageName, String className) {\n+        this.packageName = packageName;\n+        this.className = className;\n+    }\n+\n+    public String className() {\n+        return className;\n+    }\n+\n+    public static SourceFileBuilder newSourceFile(String packageName, String className) {\n+        SourceFileBuilder sfb = new SourceFileBuilder(packageName, className);\n+        sfb.emitPackagePrefix();\n+        sfb.emitImportSection();\n+        return sfb;\n+    }\n+\n+    void emitPackagePrefix() {\n+        assert packageName.indexOf('\/') == -1 : \"package name invalid: \" + packageName;\n+        appendLines(STR.\"\"\"\n+            \/\/ Generated by jextract\\{SHOW_GENERATING_CLASS ? STR.\" (via \\{getClass().getName()})\" : \"\"}\n+\n+            \"\"\");\n+        if (!packageName.isEmpty()) {\n+            appendLines(STR.\"\"\"\n+                package \\{packageName};\n+\n+                \"\"\");\n+        }\n+    }\n+\n+    void emitImportSection() {\n+        appendLines(\"\"\"\n+            import java.lang.invoke.*;\n+            import java.lang.foreign.*;\n+            import java.nio.ByteOrder;\n+            import java.util.*;\n+            import java.util.function.*;\n+            import java.util.stream.*;\n+\n+            import static java.lang.foreign.ValueLayout.*;\n+            import static java.lang.foreign.MemoryLayout.PathElement.*;\n+            \"\"\");\n+    }\n+\n+\n+    \/\/ Internal generation helpers (used by other builders)\n+\n+    void incrAlign() {\n+        align++;\n+    }\n+\n+    void decrAlign() {\n+        align--;\n+    }\n+\n+    public JavaSourceFile toFile(String suffix, Function<String, String> finisher) {\n+        return new JavaSourceFile(STR.\"\\{className}\\{suffix}\", packageName, finisher.apply(sb.toString()));\n+    }\n+\n+    public JavaSourceFile toFile(Function<String, String> finisher) {\n+        return toFile(\"\", finisher);\n+    }\n+\n+    public JavaSourceFile toFile() {\n+        return toFile(s -> s);\n+    }\n+\n+    public void appendLines(String s) {\n+        \/\/ we don't just simply use indent here, since that will also indent empty lines which adds trailing whitespace\n+        String indent = \"    \".repeat(align);\n+        s.lines().map(l -> l.isEmpty() ? \"\\n\" : indent + l + \"\\n\").forEach(sb::append);\n+    }\n+\n+    public void appendIndentedLines(String s) {\n+        incrAlign();\n+        appendLines(s);\n+        decrAlign();\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/SourceFileBuilder.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,6 +27,0 @@\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.ValueLayout;\n@@ -34,0 +28,2 @@\n+import org.openjdk.jextract.Declaration.Scoped;\n+import org.openjdk.jextract.Declaration.Variable;\n@@ -35,1 +31,8 @@\n-import org.openjdk.jextract.impl.Constants.Constant;\n+import org.openjdk.jextract.Type.Declared;\n+import org.openjdk.jextract.impl.DeclarationImpl.AnonymousStruct;\n+import org.openjdk.jextract.impl.DeclarationImpl.ClangAlignOf;\n+import org.openjdk.jextract.impl.DeclarationImpl.ClangOffsetOf;\n+import org.openjdk.jextract.impl.DeclarationImpl.ClangSizeOf;\n+import org.openjdk.jextract.impl.DeclarationImpl.JavaFunctionalInterfaceName;\n+import org.openjdk.jextract.impl.DeclarationImpl.JavaName;\n+import org.openjdk.jextract.impl.DeclarationImpl.Skip;\n@@ -39,1 +42,0 @@\n-import java.util.Collections;\n@@ -42,1 +44,2 @@\n-import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n@@ -47,3 +50,1 @@\n-class StructBuilder extends ClassSourceBuilder {\n-\n-    private static final String MEMBER_MODS = \"public static\";\n+final class StructBuilder extends ClassSourceBuilder implements OutputFactory.Builder {\n@@ -52,1 +53,0 @@\n-    private final GroupLayout structLayout;\n@@ -54,2 +54,1 @@\n-    private final Deque<String> prefixElementNames;\n-    private Constant layoutConstant;\n+    private final Deque<Declaration> nestedAnonDeclarations;\n@@ -57,3 +56,3 @@\n-    StructBuilder(JavaSourceBuilder enclosing, Declaration.Scoped structTree,\n-        String name, GroupLayout structLayout) {\n-        super(enclosing, Kind.CLASS, name);\n+    StructBuilder(SourceFileBuilder builder, String modifiers, String className,\n+                  ClassSourceBuilder enclosing, String runtimeHelperName, Declaration.Scoped structTree) {\n+        super(builder, modifiers, Kind.CLASS, className, null, enclosing, runtimeHelperName);\n@@ -61,1 +60,0 @@\n-        this.structLayout = structLayout;\n@@ -63,1 +61,1 @@\n-        prefixElementNames = new ArrayDeque<>();\n+        this.nestedAnonDeclarations = new ArrayDeque<>();\n@@ -70,6 +68,2 @@\n-    void pushPrefixElement(String prefixElementName) {\n-        prefixElementNames.push(prefixElementName);\n-    }\n-\n-    void popPrefixElement() {\n-        prefixElementNames.pop();\n+    private void pushNestedAnonDecl(Declaration anonDecl) {\n+        nestedAnonDeclarations.push(anonDecl);\n@@ -78,4 +72,2 @@\n-    private List<String> prefixNamesList() {\n-        List<String> prefixes = new ArrayList<>(prefixElementNames);\n-        Collections.reverse(prefixes);\n-        return Collections.unmodifiableList(prefixes);\n+    private void popNestedAnonDecl() {\n+        nestedAnonDeclarations.pop();\n@@ -84,11 +76,1 @@\n-    @Override\n-    void classBegin() {\n-        if (!inAnonymousNested()) {\n-            super.classBegin();\n-            layoutConstant = constants().addLayout(((Type.Declared) structType).tree().layout().orElseThrow());\n-            layoutConstant.emitGetter(this, MEMBER_MODS, Constant::nameSuffix);\n-        }\n-    }\n-\n-    @Override\n-    void classDeclBegin() {\n+    void begin() {\n@@ -96,0 +78,4 @@\n+            if (isNested()) {\n+                sourceFileBuilder().incrAlign();\n+            }\n+            appendBlankLine();\n@@ -97,0 +83,3 @@\n+            classBegin();\n+            emitDefaultConstructor();\n+            emitLayoutDecl();\n@@ -100,2 +89,1 @@\n-    @Override\n-    JavaSourceBuilder classEnd() {\n+    void end() {\n@@ -103,0 +91,1 @@\n+            emitAsSlice();\n@@ -106,2 +95,6 @@\n-            emitOfAddressScoped();\n-            return super.classEnd();\n+            emitReinterpret();\n+            classEnd();\n+            if (isNested()) {\n+                \/\/ we are nested. Decrease align\n+                sourceFileBuilder().decrAlign();\n+            }\n@@ -110,2 +103,1 @@\n-            popPrefixElement();\n-            return this;\n+            popNestedAnonDecl();\n@@ -115,2 +107,2 @@\n-    boolean inAnonymousNested() {\n-        return !prefixElementNames.isEmpty();\n+    private boolean inAnonymousNested() {\n+        return !nestedAnonDeclarations.isEmpty();\n@@ -120,3 +112,2 @@\n-    public StructBuilder addStruct(Declaration.Scoped tree, boolean isNestedAnonStruct,\n-        String name, GroupLayout layout) {\n-        if (isNestedAnonStruct) {\n+    public StructBuilder addStruct(Declaration.Scoped tree) {\n+        if (AnonymousStruct.isPresent(tree)) {\n@@ -124,2 +115,1 @@\n-            String anonName = layout.name().orElseThrow();\n-            pushPrefixElement(anonName);\n+            pushNestedAnonDecl(tree);\n@@ -128,1 +118,4 @@\n-            return new StructBuilder(this, tree, name, layout);\n+            StructBuilder builder = new StructBuilder(sourceFileBuilder(), \"public static\",\n+                    JavaName.getOrThrow(tree), this, runtimeHelperName(), tree);\n+            builder.begin();\n+            return builder;\n@@ -133,5 +126,5 @@\n-    public void addFunctionalInterface(Type.Function funcType, String javaName,\n-        FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n-        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, funcType, javaName, descriptor, parameterNames);\n-        builder.classBegin();\n-        builder.classEnd();\n+    public void addFunctionalInterface(Declaration parentDecl, Type.Function funcType) {\n+        incrAlign();\n+        FunctionalInterfaceBuilder.generate(sourceFileBuilder(), JavaFunctionalInterfaceName.getOrThrow(parentDecl),\n+                this, runtimeHelperName(), parentDecl, funcType);\n+        decrAlign();\n@@ -141,25 +134,16 @@\n-    public void addVar(Declaration.Variable varTree, String javaName,\n-        MemoryLayout layout, Optional<String> fiName) {\n-        String nativeName = varTree.name();\n-        try {\n-            structLayout.byteOffset(elementPaths(nativeName));\n-        } catch (UnsupportedOperationException uoe) {\n-            \/\/ bad layout - do nothing\n-            OutputFactory.warn(\"skipping '\" + className() + \".\" + nativeName + \"' : \" + uoe.toString());\n-            return;\n-        }\n-        if (layout instanceof SequenceLayout || layout instanceof GroupLayout) {\n-            if (layout.byteSize() > 0) {\n-                emitSegmentGetter(javaName, nativeName, layout);\n-            }\n-        } else if (layout instanceof ValueLayout valueLayout) {\n-            Constant vhConstant = constants().addFieldVarHandle(nativeName, structLayout, prefixNamesList())\n-                    .emitGetter(this, MEMBER_MODS, javaName);\n-            emitFieldDocComment(varTree, \"Getter for field:\");\n-            emitFieldGetter(vhConstant, javaName, valueLayout.carrier());\n-            emitFieldDocComment(varTree, \"Setter for field:\");\n-            emitFieldSetter(vhConstant, javaName, valueLayout.carrier());\n-            emitIndexedFieldGetter(vhConstant, javaName, valueLayout.carrier());\n-            emitIndexedFieldSetter(vhConstant, javaName, valueLayout.carrier());\n-            if (fiName.isPresent()) {\n-                emitFunctionalInterfaceGetter(fiName.get(), javaName);\n+    public void addVar(Declaration.Variable varTree) {\n+        String javaName = JavaName.getOrThrow(varTree);\n+        appendBlankLine();\n+        String layoutField = emitLayoutFieldDecl(varTree, javaName);\n+        appendBlankLine();\n+        String offsetField = emitOffsetFieldDecl(varTree, javaName);\n+        if (Utils.isArray(varTree.type()) || Utils.isStructOrUnion(varTree.type())) {\n+            emitSegmentGetter(javaName, varTree, offsetField, layoutField);\n+            emitSegmentSetter(javaName, varTree, offsetField, layoutField);\n+            int dims = Utils.dimensions(varTree.type()).size();\n+            if (dims > 0) {\n+                emitDimensionsFieldDecl(varTree, javaName);\n+                String arrayHandle = emitArrayElementHandle(javaName, varTree, layoutField, dims);\n+                IndexList indexList = IndexList.of(dims);\n+                emitFieldArrayGetter(javaName, varTree, arrayHandle, indexList);\n+                emitFieldArraySetter(javaName, varTree, arrayHandle, indexList);\n@@ -167,0 +151,20 @@\n+        } else if (Utils.isPointer(varTree.type()) || Utils.isPrimitive(varTree.type())) {\n+            emitFieldGetter(javaName, varTree, layoutField, offsetField);\n+            emitFieldSetter(javaName, varTree, layoutField, offsetField);\n+        } else {\n+            throw new IllegalArgumentException(STR.\"Type not supported: \\{varTree.type()}\");\n+        }\n+    }\n+\n+    private List<String> prefixNamesList() {\n+        return nestedAnonDeclarations.stream()\n+                .map(d -> AnonymousStruct.anonName((Declaration.Scoped)d))\n+                .toList().reversed();\n+    }\n+\n+    private String fieldElementPaths(String nativeName) {\n+        StringBuilder builder = new StringBuilder();\n+        String prefix = \"\";\n+        for (String prefixElementName : prefixNamesList()) {\n+            builder.append(prefix + \"groupElement(\\\"\" + prefixElementName + \"\\\")\");\n+            prefix = \", \";\n@@ -168,0 +172,2 @@\n+        builder.append(prefix + \"groupElement(\\\"\" + nativeName + \"\\\")\");\n+        return builder.toString();\n@@ -176,12 +182,2 @@\n-    private void emitFunctionalInterfaceGetter(String fiName, String javaName) {\n-        incrAlign();\n-        indent();\n-        append(MEMBER_MODS + \" \");\n-        append(fiName + \" \" + javaName + \"(MemorySegment segment, Arena scope) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return \" + fiName + \".ofAddress(\" + javaName + \"$get(segment), scope);\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+    private String kindName() {\n+        return structTree.kind() == Scoped.Kind.STRUCT ? \"struct\" : \"union\";\n@@ -190,13 +186,10 @@\n-    private void emitFieldGetter(Constant vhConstant, String javaName, Class<?> type) {\n-        incrAlign();\n-        indent();\n-        String seg = safeParameterName(\"seg\");\n-        append(MEMBER_MODS + \" \" + type.getSimpleName() + \" \" + javaName + \"$get(MemorySegment \" + seg + \") {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return (\" + type.getName() + \")\"\n-                + vhConstant.accessExpression() + \".get(\" + seg + \", 0L);\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+    private void emitFieldGetter(String javaName, Declaration.Variable varTree, String layoutField, String offsetField) {\n+        String segmentParam = safeParameterName(kindName());\n+        Class<?> type = Utils.carrierFor(varTree.type());\n+        appendBlankLine();\n+        emitFieldDocComment(varTree, \"Getter for field:\");\n+        appendIndentedLines(STR.\"\"\"\n+            public static \\{type.getSimpleName()} \\{javaName}(MemorySegment \\{segmentParam}) {\n+                return \\{segmentParam}.get(\\{layoutField}, \\{offsetField});\n+            }\n+            \"\"\");\n@@ -205,14 +198,34 @@\n-    private void emitFieldSetter(Constant vhConstant, String javaName, Class<?> type) {\n-        incrAlign();\n-        indent();\n-        String seg = safeParameterName(\"seg\");\n-        String x = safeParameterName(\"x\");\n-        String param = MemorySegment.class.getSimpleName() + \" \" + seg;\n-        append(MEMBER_MODS + \" void \" + javaName + \"$set(\" + param + \", \" + type.getSimpleName() + \" \" + x + \") {\\n\");\n-        incrAlign();\n-        indent();\n-        append(vhConstant.accessExpression() + \".set(\" + seg + \", 0L, \" + x + \");\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+    private void emitFieldSetter(String javaName, Declaration.Variable varTree, String layoutField, String offsetField) {\n+        String segmentParam = safeParameterName(kindName());\n+        String valueParam = safeParameterName(\"fieldValue\");\n+        Class<?> type = Utils.carrierFor(varTree.type());\n+        appendBlankLine();\n+        emitFieldDocComment(varTree, \"Setter for field:\");\n+        appendIndentedLines(STR.\"\"\"\n+            public static void \\{javaName}(MemorySegment \\{segmentParam}, \\{type.getSimpleName()} \\{valueParam}) {\n+                \\{segmentParam}.set(\\{layoutField}, \\{offsetField}, \\{valueParam});\n+            }\n+            \"\"\");\n+    }\n+\n+    private void emitSegmentGetter(String javaName, Declaration.Variable varTree, String offsetField, String layoutField) {\n+        appendBlankLine();\n+        emitFieldDocComment(varTree, \"Getter for field:\");\n+        String segmentParam = safeParameterName(kindName());\n+        appendIndentedLines(STR.\"\"\"\n+            public static MemorySegment \\{javaName}(MemorySegment \\{segmentParam}) {\n+                return \\{segmentParam}.asSlice(\\{offsetField}, \\{layoutField}.byteSize());\n+            }\n+            \"\"\");\n+    }\n+\n+    private void emitSegmentSetter(String javaName, Declaration.Variable varTree, String offsetField, String layoutField) {\n+        appendBlankLine();\n+        emitFieldDocComment(varTree, \"Setter for field:\");\n+        String segmentParam = safeParameterName(kindName());\n+        String valueParam = safeParameterName(\"fieldValue\");\n+        appendIndentedLines(STR.\"\"\"\n+            public static void \\{javaName}(MemorySegment \\{segmentParam}, MemorySegment \\{valueParam}) {\n+                MemorySegment.copy(\\{valueParam}, 0L, \\{segmentParam}, \\{offsetField}, \\{layoutField}.byteSize());\n+            }\n+            \"\"\");\n@@ -221,6 +234,14 @@\n-    private MemoryLayout.PathElement[] elementPaths(String nativeFieldName) {\n-        List<String> prefixElements = prefixNamesList();\n-        MemoryLayout.PathElement[] elems = new MemoryLayout.PathElement[prefixElements.size() + 1];\n-        int i = 0;\n-        for (; i < prefixElements.size(); i++) {\n-            elems[i] = MemoryLayout.PathElement.groupElement(prefixElements.get(i));\n+    private String emitArrayElementHandle(String javaName, Declaration.Variable varTree, String fieldLayoutName, int dims) {\n+        String arrayHandleName = STR.\"\\{javaName}$ELEM_HANDLE\";\n+        String path = IntStream.range(0, dims)\n+                .mapToObj(_ -> \"sequenceElement()\")\n+                .collect(Collectors.joining(\", \"));\n+        Type elemType = Utils.typeOrElemType(varTree.type());\n+        if (Utils.isStructOrUnion(elemType)) {\n+            appendIndentedLines(STR.\"\"\"\n+                private static final MethodHandle \\{arrayHandleName} = \\{fieldLayoutName}.sliceHandle(\\{path});\n+                \"\"\");\n+        } else {\n+            appendIndentedLines(STR.\"\"\"\n+                private static final VarHandle \\{arrayHandleName} = \\{fieldLayoutName}.varHandle(\\{path});\n+                \"\"\");\n@@ -228,2 +249,1 @@\n-        elems[i] = MemoryLayout.PathElement.groupElement(nativeFieldName);\n-        return elems;\n+        return arrayHandleName;\n@@ -232,16 +252,59 @@\n-    private void emitSegmentGetter(String javaName, String nativeName, MemoryLayout layout) {\n-        incrAlign();\n-        indent();\n-        String seg = safeParameterName(\"seg\");\n-        append(MEMBER_MODS + \" MemorySegment \" + javaName + \"$slice(MemorySegment \" + seg + \") {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return \" + seg + \".asSlice(\");\n-        append(structLayout.byteOffset(elementPaths(nativeName)));\n-        append(\", \");\n-        append(layout.byteSize());\n-        append(\");\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+    private void emitFieldArrayGetter(String javaName, Declaration.Variable varTree, String arrayElementHandle, IndexList indexList) {\n+        String segmentParam = safeParameterName(kindName());\n+        Type elemType = Utils.typeOrElemType(varTree.type());\n+        Class<?> elemTypeCls = Utils.carrierFor(elemType);\n+        appendBlankLine();\n+        emitFieldDocComment(varTree, \"Indexed getter for field:\");\n+        if (Utils.isStructOrUnion(elemType)) {\n+            appendIndentedLines(STR.\"\"\"\n+                public static MemorySegment \\{javaName}(MemorySegment \\{segmentParam}, \\{indexList.decl()}) {\n+                    try {\n+                        return (MemorySegment)\\{arrayElementHandle}.invokeExact(\\{segmentParam}, 0L, \\{indexList.use()});\n+                    } catch (Throwable ex$) {\n+                        throw new AssertionError(\"should not reach here\", ex$);\n+                    }\n+                }\n+                \"\"\");\n+        } else {\n+            appendIndentedLines(STR.\"\"\"\n+                public static \\{elemTypeCls.getSimpleName()} \\{javaName}(MemorySegment \\{segmentParam}, \\{indexList.decl()}) {\n+                    return (\\{elemTypeCls.getSimpleName()})\\{arrayElementHandle}.get(\\{segmentParam}, 0L, \\{indexList.use()});\n+                }\n+                \"\"\");\n+        }\n+    }\n+\n+    private void emitFieldArraySetter(String javaName, Declaration.Variable varTree, String arrayElementHandle, IndexList indexList) {\n+        String segmentParam = safeParameterName(kindName());\n+        String valueParam = safeParameterName(\"fieldValue\");\n+        Type elemType = Utils.typeOrElemType(varTree.type());\n+        Class<?> elemTypeCls = Utils.carrierFor(elemType);\n+        appendBlankLine();\n+        emitFieldDocComment(varTree, \"Indexed setter for field:\");\n+        if (Utils.isStructOrUnion(elemType)) {\n+            appendIndentedLines(STR.\"\"\"\n+                public static void \\{javaName}(MemorySegment \\{segmentParam}, \\{indexList.decl()}, MemorySegment \\{valueParam}) {\n+                    MemorySegment.copy(\\{valueParam}, 0L, \\{javaName}(\\{segmentParam}, \\{indexList.use()}), 0L, \\{layoutString(elemType)}.byteSize());\n+                }\n+                \"\"\");\n+        } else {\n+            appendIndentedLines(STR.\"\"\"\n+                public static void \\{javaName}(MemorySegment \\{segmentParam}, \\{indexList.decl()}, \\{elemTypeCls.getSimpleName()} \\{valueParam}) {\n+                    \\{arrayElementHandle}.set(\\{segmentParam}, 0L, \\{indexList.use()}, \\{valueParam});\n+                }\n+                \"\"\");\n+        }\n+    }\n+\n+    private void emitAsSlice() {\n+        String arrayParam = safeParameterName(\"array\");\n+        appendIndentedLines(STR.\"\"\"\n+\n+            \/**\n+             * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+             * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+             *\/\n+            public static MemorySegment asSlice(MemorySegment \\{arrayParam}, long index) {\n+                return \\{arrayParam}.asSlice(layout().byteSize() * index);\n+            }\n+            \"\"\");\n@@ -251,5 +314,7 @@\n-        incrAlign();\n-        indent();\n-        append(MEMBER_MODS);\n-        append(\" long sizeof() { return $LAYOUT().byteSize(); }\\n\");\n-        decrAlign();\n+        appendIndentedLines(STR.\"\"\"\n+\n+            \/**\n+             * The size (in bytes) of this \\{kindName()}\n+             *\/\n+            public static long sizeof() { return layout().byteSize(); }\n+            \"\"\");\n@@ -259,5 +324,10 @@\n-        incrAlign();\n-        indent();\n-        append(MEMBER_MODS);\n-        append(\" MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }\\n\");\n-        decrAlign();\n+        String allocatorParam = safeParameterName(\"allocator\");\n+        appendIndentedLines(STR.\"\"\"\n+\n+            \/**\n+             * Allocate a segment of size {@code layout().byteSize()} using {@code \\{allocatorParam}}\n+             *\/\n+            public static MemorySegment allocate(SegmentAllocator \\{allocatorParam}) {\n+                return \\{allocatorParam}.allocate(layout());\n+            }\n+            \"\"\");\n@@ -267,11 +337,12 @@\n-        incrAlign();\n-        indent();\n-        append(MEMBER_MODS);\n-        append(\" MemorySegment allocateArray(long len, SegmentAllocator allocator) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+        String allocatorParam = safeParameterName(\"allocator\");\n+        String elementCountParam = safeParameterName(\"elementCount\");\n+        appendIndentedLines(STR.\"\"\"\n+\n+            \/**\n+             * Allocate an array of size {@code \\{elementCountParam}} using {@code \\{allocatorParam}}.\n+             * The returned segment has size {@code \\{elementCountParam} * layout().byteSize()}.\n+             *\/\n+            public static MemorySegment allocateArray(long \\{elementCountParam}, SegmentAllocator \\{allocatorParam}) {\n+                return \\{allocatorParam}.allocate(MemoryLayout.sequenceLayout(\\{elementCountParam}, layout()));\n+            }\n+            \"\"\");\n@@ -280,6 +351,19 @@\n-    private void emitOfAddressScoped() {\n-        incrAlign();\n-        indent();\n-        append(MEMBER_MODS);\n-        append(\" MemorySegment ofAddress(MemorySegment addr, Arena scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }\\n\");\n-        decrAlign();\n+    private void emitReinterpret() {\n+        appendIndentedLines(\"\"\"\n+\n+            \/**\n+             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).\n+             * The returned segment has size {@code layout().byteSize()}\n+             *\/\n+            public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+                return reinterpret(addr, 1, arena, cleanup);\n+            }\n+\n+            \/**\n+             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).\n+             * The returned segment has size {@code elementCount * layout().byteSize()}\n+             *\/\n+            public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+                return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+            }\n+            \"\"\");\n@@ -288,18 +372,12 @@\n-    private void emitIndexedFieldGetter(Constant vhConstant, String javaName, Class<?> type) {\n-        incrAlign();\n-        indent();\n-        String index = safeParameterName(\"index\");\n-        String seg = safeParameterName(\"seg\");\n-        String params = MemorySegment.class.getSimpleName() + \" \" + seg + \", long \" + index;\n-        append(MEMBER_MODS + \" \" + type.getSimpleName() + \" \" + javaName + \"$get(\" + params + \") {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return (\" + type.getName() + \")\");\n-        append(vhConstant.accessExpression());\n-        append(\".get(\");\n-        append(seg + \", \");\n-        append(index + \" * sizeof());\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+    private void emitLayoutDecl() {\n+        appendIndentedLines(STR.\"\"\"\n+\n+            private static final GroupLayout $LAYOUT = \\{structOrUnionLayoutString(structType)};\n+\n+            \/**\n+             * The layout of this \\{kindName()}\n+             *\/\n+            public static final GroupLayout layout() {\n+                return $LAYOUT;\n+            }\n+            \"\"\");\n@@ -308,21 +386,123 @@\n-    private void emitIndexedFieldSetter(Constant vhConstant, String javaName, Class<?> type) {\n-        incrAlign();\n-        indent();\n-        String index = safeParameterName(\"index\");\n-        String seg = safeParameterName(\"seg\");\n-        String x = safeParameterName(\"x\");\n-        String params = MemorySegment.class.getSimpleName() + \" \" + seg +\n-            \", long \" + index + \", \" + type.getSimpleName() + \" \" + x;\n-        append(MEMBER_MODS + \" void \" + javaName + \"$set(\" + params + \") {\\n\");\n-        incrAlign();\n-        indent();\n-        append(vhConstant.accessExpression());\n-        append(\".set(\");\n-        append(seg + \", \");\n-        append(index + \" * sizeof(), \");\n-        append(x);\n-        append(\");\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+    private String emitOffsetFieldDecl(Declaration.Variable field, String javaName) {\n+        String offsetFieldName = STR.\"\\{javaName}$OFFSET\";\n+        appendIndentedLines(STR.\"\"\"\n+            private static final long \\{offsetFieldName} = \\{ClangOffsetOf.getOrThrow(field) \/ 8};\n+            \"\"\");\n+        appendBlankLine();\n+        emitFieldDocComment(field, \"Offset for field:\");\n+        appendIndentedLines(STR.\"\"\"\n+            public static final long \\{javaName}$offset() {\n+                return \\{offsetFieldName};\n+            }\n+            \"\"\");\n+        return offsetFieldName;\n+    }\n+\n+    private String emitLayoutFieldDecl(Declaration.Variable field, String javaName) {\n+        String layoutFieldName = STR.\"\\{javaName}$LAYOUT\";\n+        String layoutType = Utils.layoutCarrierFor(field.type()).getSimpleName();\n+        appendIndentedLines(STR.\"\"\"\n+            private static final \\{layoutType} \\{layoutFieldName} = (\\{layoutType})$LAYOUT.select(\\{fieldElementPaths(field.name())});\n+            \"\"\");\n+        appendBlankLine();\n+        emitFieldDocComment(field, \"Layout for field:\");\n+        appendIndentedLines(STR.\"\"\"\n+            public static final \\{layoutType} \\{javaName}$layout() {\n+                return \\{layoutFieldName};\n+            }\n+            \"\"\");\n+        return layoutFieldName;\n+    }\n+\n+    private void emitDimensionsFieldDecl(Declaration.Variable field, String javaName) {\n+        String dimsFieldName = STR.\"\\{javaName}$DIMS\";\n+        List<Long> dimensions = Utils.dimensions(field.type());\n+        String dimsString = dimensions.stream().map(d -> d.toString())\n+                .collect(Collectors.joining(\", \"));\n+        appendIndentedLines(STR.\"\"\"\n+\n+            private static long[] \\{dimsFieldName} = { \\{dimsString} };\n+            \"\"\");\n+        appendBlankLine();\n+        emitFieldDocComment(field, \"Dimensions for array field:\");\n+        appendIndentedLines(STR.\"\"\"\n+            public static long[] \\{javaName}$dimensions() {\n+                return \\{dimsFieldName};\n+            }\n+            \"\"\");\n+    }\n+\n+    private String structOrUnionLayoutString(Type type) {\n+        return switch (type) {\n+            case Declared d when Utils.isStructOrUnion(type) -> structOrUnionLayoutString(0, d.tree(), 0);\n+            default -> throw new UnsupportedOperationException(type.toString());\n+        };\n+    }\n+\n+    private static long recordMemberOffset(Declaration member) {\n+        if (member instanceof Variable) {\n+            return ClangOffsetOf.get(member).orElseThrow();\n+        } else {\n+            \/\/ anonymous struct\n+            return AnonymousStruct.getOrThrow((Scoped) member).offset().orElseThrow();\n+        }\n+    }\n+\n+    private String structOrUnionLayoutString(long base, Declaration.Scoped scoped, int indent) {\n+        List<String> memberLayouts = new ArrayList<>();\n+\n+        boolean isStruct = scoped.kind() == Scoped.Kind.STRUCT;\n+\n+        long align = ClangAlignOf.getOrThrow(scoped) \/ 8;\n+        long offset = base;\n+\n+        long size = 0L; \/\/ bits\n+        for (Declaration member : scoped.members()) {\n+            if (!Skip.isPresent(member)) {\n+                long nextOffset = recordMemberOffset(member);\n+                long delta = nextOffset - offset;\n+                if (delta > 0) {\n+                    memberLayouts.add(paddingLayoutString(delta \/ 8, indent + 1));\n+                    offset += delta;\n+                    if (isStruct) {\n+                        size += delta;\n+                    }\n+                }\n+                String memberLayout;\n+                if (member instanceof Variable var) {\n+                    memberLayout = layoutString(var.type(), align);\n+                    memberLayout = STR.\"\\{indentString(indent + 1)}\\{memberLayout}.withName(\\\"\\{member.name()}\\\")\";\n+                } else {\n+                    \/\/ anon struct\n+                    memberLayout = structOrUnionLayoutString(offset, (Scoped) member, indent + 1);\n+                }\n+                memberLayouts.add(memberLayout);\n+                \/\/ update offset and size\n+                long fieldSize = ClangSizeOf.getOrThrow(member);\n+                if (isStruct) {\n+                    offset += fieldSize;\n+                    size += fieldSize;\n+                } else {\n+                    size = Math.max(size, ClangSizeOf.getOrThrow(member));\n+                }\n+            }\n+        }\n+        long expectedSize = ClangSizeOf.getOrThrow(scoped);\n+        if (size != expectedSize) {\n+            long trailPadding = isStruct ?\n+                    (expectedSize - size) \/ 8 :\n+                    expectedSize \/ 8;\n+            memberLayouts.add(paddingLayoutString(trailPadding, indent + 1));\n+        }\n+\n+        String prefix = isStruct ?\n+                STR.\"\\{indentString(indent)}MemoryLayout.structLayout(\\n\" :\n+                STR.\"\\{indentString(indent)}MemoryLayout.unionLayout(\\n\";\n+        String suffix = STR.\"\\n\\{indentString(indent)})\";\n+        String layoutString = memberLayouts.stream()\n+                .collect(Collectors.joining(\",\\n\", prefix, suffix));\n+\n+        \/\/ the name is only useful for clients accessing the layout, jextract doesn't care about it\n+        String name = scoped.name().isEmpty() ?\n+                AnonymousStruct.anonName(scoped) : scoped.name();\n+        return STR.\"\\{layoutString}.withName(\\\"\\{name}\\\")\";\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructBuilder.java","additions":395,"deletions":215,"binary":false,"changes":610,"status":"modified"},{"patch":"@@ -1,167 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package org.openjdk.jextract.impl;\n-\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import org.openjdk.jextract.Declaration;\n-import org.openjdk.jextract.clang.Cursor;\n-import org.openjdk.jextract.clang.Type;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\/**\n- * MemoryLayout computer for C structs.\n- *\/\n-final class StructLayoutComputer extends RecordLayoutComputer {\n-    private long offset;\n-    private long actualSize = 0L;\n-    \/\/ List to collect bitfield fields to process later, may be null\n-    private List<Declaration> bitfieldDecls;\n-    private long bitfieldSize;\n-\n-    StructLayoutComputer(TypeMaker typeMaker, long offsetInParent, Type parent, Type type) {\n-        super(typeMaker, parent, type);\n-        this.offset = offsetInParent;\n-    }\n-\n-    @Override\n-    void addField(long offset, Declaration declaration) {\n-        if (bitfieldDecls != null) {\n-            bitfieldDecls.add(declaration);\n-            bitfieldSize += ((Declaration.Bitfield)declaration).width();\n-        } else {\n-            super.addField(offset, declaration);\n-        }\n-    }\n-\n-    @Override\n-    void addPadding(long bits) {\n-        if (bitfieldDecls == null) {\n-            super.addPadding(bits);\n-        } else {\n-            bitfieldSize += bits;\n-        }\n-    }\n-\n-    @Override\n-    void startBitfield() {\n-        \/*\n-         * In a struct, a bitfield field is seen after a non-bitfield.\n-         * Initialize bitfieldLayouts list to collect this and subsequent\n-         * bitfield layouts.\n-         *\/\n-        if (bitfieldDecls == null) {\n-            bitfieldDecls = new ArrayList<>();\n-            bitfieldSize = 0;\n-        }\n-    }\n-\n-    @Override\n-    void processField(Cursor c) {\n-        boolean isBitfield = c.isBitField();\n-        long expectedOffset = offsetOf(parent, c);\n-        if (offset > expectedOffset) {\n-            \/\/ out-of-order field, skip\n-            System.err.println(\"WARNING: ignoring field: \" + c.spelling() + \" in struct \" + type.spelling());\n-            return;\n-        }\n-        if (expectedOffset > offset) {\n-            addPadding(expectedOffset - offset);\n-            actualSize += (expectedOffset - offset);\n-            offset = expectedOffset;\n-        }\n-\n-        if (isBitfield) {\n-            startBitfield();\n-        } else { \/\/ !isBitfield\n-            \/*\n-             * We may be crossing from bit fields to non-bitfield field.\n-             *\n-             * struct Foo {\n-             *     int i:12;\n-             *     int j:20;\n-             *     int k; \/\/ <-- processing this\n-             *     int m;\n-             * }\n-             *\/\n-            handleBitfields();\n-        }\n-\n-        addField(offset, parent, c);\n-        long size = fieldSize(c);\n-        offset += size;\n-        actualSize += size;\n-    }\n-\n-    @Override\n-    Declaration.Scoped finishRecord(String layoutName, String declName) {\n-        \/\/ pad at the end, if any\n-        long expectedSize = type.size() * 8;\n-        if (actualSize < expectedSize) {\n-            addPadding(expectedSize - actualSize);\n-        }\n-\n-        \/*\n-         * Handle bitfields at the end, if any.\n-         *\n-         * struct Foo {\n-         *     int i,j, k;\n-         *     int f:10;\n-         *     int pad:12;\n-         * }\n-         *\/\n-        handleBitfields();\n-\n-        GroupLayout g = MemoryLayout.structLayout(alignFields());\n-        checkSize(g);\n-        g = g.withName(layoutName);\n-        Declaration.Scoped declaration = Declaration.struct(TreeMaker.CursorPosition.of(cursor), declName,\n-                g, fieldDecls.stream().toArray(Declaration[]::new));\n-        return declaration;\n-    }\n-\n-    \/\/ process bitfields if any and clear bitfield layouts\n-    private void handleBitfields() {\n-        if (bitfieldDecls != null) {\n-            List<Declaration> prevBitfieldDecls = bitfieldDecls;\n-            long prevBitfieldSize = bitfieldSize;\n-            bitfieldDecls = null;\n-            bitfieldSize = 0;\n-            if (!prevBitfieldDecls.isEmpty()) {\n-                addField(offset, bitfield(prevBitfieldDecls.toArray(new Declaration.Variable[0])));\n-            }\n-            if (prevBitfieldSize > 0) {\n-                if (prevBitfieldSize % 8 != 0) {\n-                    throw new IllegalStateException(\"Cannot get here: \" + prevBitfieldSize);\n-                }\n-                fieldLayouts.add(MemoryLayout.paddingLayout(prevBitfieldSize \/ 8));\n-            }\n-        }\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructLayoutComputer.java","additions":0,"deletions":167,"binary":false,"changes":167,"status":"deleted"},{"patch":"@@ -27,3 +27,0 @@\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n@@ -31,0 +28,1 @@\n+import org.openjdk.jextract.JavaSourceFile;\n@@ -32,0 +30,2 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.JavaFunctionalInterfaceName;\n+import org.openjdk.jextract.impl.DeclarationImpl.JavaName;\n@@ -33,1 +33,0 @@\n-import javax.tools.JavaFileObject;\n@@ -37,1 +36,0 @@\n-import java.util.Optional;\n@@ -44,1 +42,2 @@\n-class ToplevelBuilder extends JavaSourceBuilder {\n+class ToplevelBuilder implements OutputFactory.Builder {\n+    private static final int DECLS_PER_HEADER_CLASS = Integer.getInteger(\"jextract.decls.per.header\", 1000);\n@@ -47,3 +46,3 @@\n-    private final List<JavaSourceBuilder> builders = new ArrayList<>();\n-    private SplitHeader lastHeader;\n-    private int headersCount;\n+    private final List<SourceFileBuilder> headerBuilders = new ArrayList<>();\n+    private final List<SourceFileBuilder> otherBuilders = new ArrayList<>();\n+    private HeaderFileBuilder lastHeader;\n@@ -52,5 +51,2 @@\n-    Constants constants;\n-\n-    static final int DECLS_PER_HEADER_CLASS = Integer.getInteger(\"jextract.decls.per.header\", 1000);\n-\n-    ToplevelBuilder(String packageName, String headerClassName) {\n+    ToplevelBuilder(String packageName, String headerClassName,\n+                    List<Options.Library> libs, boolean useSystemLoadLibrary) {\n@@ -58,3 +54,8 @@\n-        SplitHeader first = lastHeader = new FirstHeader(headerClassName);\n-        builders.add(first);\n-        constants = new Constants(this);\n+        SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName, headerClassName);\n+        headerBuilders.add(sfb);\n+        lastHeader = createFirstHeader(sfb, libs, useSystemLoadLibrary);\n+    }\n+\n+    private static HeaderFileBuilder createFirstHeader(SourceFileBuilder sfb, List<Options.Library> libs, boolean useSystemLoadLibrary) {\n+        HeaderFileBuilder first = new HeaderFileBuilder(sfb, STR.\"\\{sfb.className()}#{SUFFIX}\", null, sfb.className());\n+        first.appendBlankLine();\n@@ -62,0 +63,23 @@\n+        first.emitDefaultConstructor();\n+        first.emitRuntimeHelperMethods();\n+        first.emitFirstHeaderPreamble(libs, useSystemLoadLibrary);\n+        \/\/ emit basic primitive types\n+        first.appendIndentedLines(STR.\"\"\"\n+\n+            public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+            public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+            public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n+            public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+            public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n+            public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n+            public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n+            public static final AddressLayout C_POINTER = ValueLayout.ADDRESS\n+                    .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));\n+            \"\"\");\n+        if (TypeImpl.IS_WINDOWS) {\n+            first.appendIndentedLines(\"public static final ValueLayout.OfInt C_LONG = ValueLayout.JAVA_INT;\");\n+            first.appendIndentedLines(\"public static final ValueLayout.OfDouble C_LONG_DOUBLE = ValueLayout.JAVA_DOUBLE;\");\n+        } else {\n+            first.appendIndentedLines(\"public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;\");\n+        }\n+        return first;\n@@ -64,1 +88,1 @@\n-    public List<JavaFileObject> toFiles() {\n+    public List<JavaSourceFile> toFiles() {\n@@ -66,4 +90,23 @@\n-        List<JavaFileObject> files = new ArrayList<>();\n-        files.addAll(builders.stream()\n-                .flatMap(b -> b.toFiles().stream()).toList());\n-        files.addAll(constants.toFiles());\n+\n+        List<JavaSourceFile> files = new ArrayList<>();\n+\n+        if (headerBuilders.size() == 1) {\n+            files.add(headerBuilders.get(0).toFile(s -> s.replace(\"#{SUFFIX}\", \"\")));\n+        } else {\n+            \/\/ adjust suffixes so that the last header class becomes the main header class,\n+            \/\/ and extends all the other header classes\n+            int suffix = headerBuilders.size() - 1;\n+            for (SourceFileBuilder header : headerBuilders) {\n+                String currentSuffix = suffix == 0 ?\n+                        \"\" : \/\/ main header class, drop the suffix\n+                        STR.\"_\\{suffix}\";\n+                String prevSuffix = STR.\"_\\{suffix + 1}\";\n+                files.add(header.toFile(currentSuffix,\n+                        s -> s.replace(\"#{SUFFIX}\", currentSuffix)\n+                              .replace(\"#{PREV_SUFFIX}\", prevSuffix)));\n+                suffix--;\n+            }\n+        }\n+        \/\/ add remaining builders\n+        files.addAll(otherBuilders.stream()\n+                .map(SourceFileBuilder::toFile).toList());\n@@ -73,1 +116,1 @@\n-    public String headerClassName() {\n+    public String mainHeaderClassName() {\n@@ -77,6 +120,0 @@\n-    @Override\n-    boolean isEnclosedBySameName(String name) {\n-        return false;\n-    }\n-\n-    @Override\n@@ -88,8 +125,2 @@\n-    protected Constants constants() {\n-        return constants;\n-    }\n-\n-    @Override\n-    public void addVar(Declaration.Variable varTree, String javaName,\n-        MemoryLayout layout, Optional<String> fiName) {\n-        nextHeader().addVar(varTree, javaName, layout, fiName);\n+    public void addVar(Declaration.Variable varTree) {\n+        nextHeader().addVar(varTree);\n@@ -99,3 +130,2 @@\n-    public void addFunction(Declaration.Function funcTree, FunctionDescriptor descriptor,\n-            String javaName, List<String> parameterNames) {\n-        nextHeader().addFunction(funcTree, descriptor, javaName, parameterNames);\n+    public void addFunction(Declaration.Function funcTree) {\n+        nextHeader().addFunction(funcTree);\n@@ -105,2 +135,2 @@\n-    public void addConstant(Declaration.Constant constantTree, String javaName, Class<?> javaType) {\n-        nextHeader().addConstant(constantTree, javaName, javaType);\n+    public void addConstant(Declaration.Constant constantTree) {\n+        nextHeader().addConstant(constantTree);\n@@ -110,2 +140,2 @@\n-    public void addTypedef(Declaration.Typedef typedefTree, String javaName,\n-        String superClass, Type type) {\n+    public void addTypedef(Declaration.Typedef typedefTree, String superClass, Type type) {\n+        String javaName = JavaName.getOrThrow(typedefTree);\n@@ -119,4 +149,3 @@\n-            TypedefBuilder builder = new TypedefBuilder(this, typedefTree, javaName, superClass);\n-            builders.add(builder);\n-            builder.classBegin();\n-            builder.classEnd();\n+            SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName(), javaName);\n+            TypedefBuilder.generate(sfb, sfb.className(), superClass, mainHeaderClassName(), typedefTree);\n+            otherBuilders.add(sfb);\n@@ -127,14 +156,5 @@\n-    public StructBuilder addStruct(Declaration.Scoped tree, boolean isNestedAnonStruct,\n-        String javaName, GroupLayout layout) {\n-        StructBuilder structBuilder = new StructBuilder(this, tree, javaName, layout) {\n-            @Override\n-            boolean isClassFinal() {\n-                return false;\n-            }\n-\n-            @Override\n-            void emitConstructor() {\n-                \/\/ None...\n-            }\n-        };\n-        builders.add(structBuilder);\n+    public StructBuilder addStruct(Declaration.Scoped tree) {\n+        SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName(), JavaName.getOrThrow(tree));\n+        otherBuilders.add(sfb);\n+        StructBuilder structBuilder = new StructBuilder(sfb, \"public\", sfb.className(), null, mainHeaderClassName(), tree);\n+        structBuilder.begin();\n@@ -145,6 +165,4 @@\n-    public void addFunctionalInterface(Type.Function funcType, String javaName,\n-        FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n-        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, funcType, javaName, descriptor, parameterNames);\n-        builders.add(builder);\n-        builder.classBegin();\n-        builder.classEnd();\n+    public void addFunctionalInterface(Declaration parentDecl, Type.Function funcType) {\n+        SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName(), JavaFunctionalInterfaceName.getOrThrow(parentDecl));\n+        otherBuilders.add(sfb);\n+        FunctionalInterfaceBuilder.generate(sfb, sfb.className(), null, mainHeaderClassName(), parentDecl, funcType);\n@@ -153,1 +171,1 @@\n-    private SplitHeader nextHeader() {\n+    private HeaderFileBuilder nextHeader() {\n@@ -155,3 +173,4 @@\n-            boolean hasSuper = !(lastHeader instanceof FirstHeader);\n-            SplitHeader headerFileBuilder = new SplitHeader(headerDesc.displayName() + \"_\" + ++headersCount,\n-                    hasSuper ? lastHeader.className() : null);\n+            SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName(), mainHeaderClassName());\n+            String className = mainHeaderClassName() + \"#{SUFFIX}\";\n+            HeaderFileBuilder headerFileBuilder = new HeaderFileBuilder(sfb, className,\n+                    mainHeaderClassName() + \"#{PREV_SUFFIX}\", mainHeaderClassName());\n@@ -159,0 +178,1 @@\n+            headerFileBuilder.appendBlankLine();\n@@ -160,1 +180,2 @@\n-            builders.add(headerFileBuilder);\n+            headerFileBuilder.emitDefaultConstructor();\n+            headerBuilders.add(sfb);\n@@ -169,45 +190,0 @@\n-\n-    class SplitHeader extends HeaderFileBuilder {\n-        SplitHeader(String name, String superclass) {\n-            super(ToplevelBuilder.this, name, superclass);\n-        }\n-\n-        @Override\n-        boolean isClassFinal() {\n-            return false;\n-        }\n-\n-        @Override\n-        void emitConstructor() {\n-            \/\/ None...\n-        }\n-    }\n-\n-    class FirstHeader extends SplitHeader {\n-\n-        FirstHeader(String name) {\n-            super(name, \"#{SUPER}\");\n-        }\n-\n-        @Override\n-        void classBegin() {\n-            super.classBegin();\n-            \/\/ emit basic primitive types\n-            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Bool), \"C_BOOL\");\n-            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Char), \"C_CHAR\");\n-            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Short), \"C_SHORT\");\n-            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Int), \"C_INT\");\n-            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Long), \"C_LONG\");\n-            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.LongLong), \"C_LONG_LONG\");\n-            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Float), \"C_FLOAT\");\n-            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Double), \"C_DOUBLE\");\n-            emitPointerTypedef(\"C_POINTER\");\n-        }\n-\n-        @Override\n-        String build() {\n-            HeaderFileBuilder last = lastHeader;\n-            return super.build().replace(\"extends #{SUPER}\",\n-                    last != this ? \"extends \" + last.className() : \"\");\n-        }\n-    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ToplevelBuilder.java","additions":94,"deletions":118,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.lang.constant.Constable;\n@@ -31,0 +30,1 @@\n+import java.util.Collections;\n@@ -35,0 +35,3 @@\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -37,1 +40,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -39,0 +41,4 @@\n+import org.openjdk.jextract.Declaration.ClangAttributes;\n+import org.openjdk.jextract.Declaration.Scoped;\n+import org.openjdk.jextract.Declaration.Typedef;\n+import org.openjdk.jextract.Declaration.Variable;\n@@ -41,0 +47,1 @@\n+import org.openjdk.jextract.Type.Declared;\n@@ -45,0 +52,2 @@\n+import org.openjdk.jextract.clang.PrintingPolicy;\n+import org.openjdk.jextract.clang.PrintingPolicyProperty;\n@@ -46,1 +55,13 @@\n-\n+import org.openjdk.jextract.clang.TypeKind;\n+import org.openjdk.jextract.impl.DeclarationImpl.AnonymousStruct;\n+import org.openjdk.jextract.impl.DeclarationImpl.ClangAlignOf;\n+import org.openjdk.jextract.impl.DeclarationImpl.ClangOffsetOf;\n+import org.openjdk.jextract.impl.DeclarationImpl.ClangSizeOf;\n+import org.openjdk.jextract.impl.DeclarationImpl.NestedDeclarations;\n+import org.openjdk.jextract.impl.DeclarationImpl.DeclarationString;\n+\n+\/**\n+ * This class turns a clang cursor into a jextract declaration. All declarations are de-duplicated,\n+ * based on the declaration position. Because of this, the tree maker's declaration cache effectively\n+ * acts as a symbol table.\n+ *\/\n@@ -48,1 +69,0 @@\n-    public TreeMaker() {}\n@@ -50,1 +70,1 @@\n-    TypeMaker typeMaker = new TypeMaker(this);\n+    private final Map<Cursor.Key, Declaration> declarationCache = new HashMap<>();\n@@ -52,3 +72,1 @@\n-    public void freeze() {\n-        typeMaker.resolveTypeReferences();\n-    }\n+    public TreeMaker() { }\n@@ -56,2 +74,3 @@\n-    Map<String, List<Constable>> collectAttributes(Cursor c) {\n-        Map<String, List<Constable>> attributeMap = new HashMap<>();\n+    Declaration addAttributes(Declaration d, Cursor c) {\n+        if (d == null) return null;\n+        Map<String, List<String>> attributes = new HashMap<>();\n@@ -60,1 +79,1 @@\n-                List<Constable> attrs = attributeMap.computeIfAbsent(child.kind().name(), _unused -> new ArrayList<>());\n+                List<String> attrs = attributes.computeIfAbsent(child.kind().name(), _unused -> new ArrayList<>());\n@@ -64,1 +83,8 @@\n-        return attributeMap;\n+        if (!attributes.isEmpty()) {\n+            d.addAttribute(new ClangAttributes(Collections.unmodifiableMap(attributes)));\n+        }\n+        return d;\n+    }\n+\n+    public Optional<Declaration> lookup(Cursor.Key key) {\n+        return Optional.ofNullable(declarationCache.get(key));\n@@ -94,1 +120,1 @@\n-        return (rv == null) ? null : rv.withAttributes(collectAttributes(c));\n+        return addAttributes(rv, c);\n@@ -98,1 +124,9 @@\n-        return switch (c.kind()) {\n+        Position pos = CursorPosition.of(c);\n+        if (pos == Position.NO_POSITION) return null; \/\/ intrinsic, skip\n+        \/\/ dedup multiple declarations that point to the same source location\n+        Cursor.Key key = c.toKey();\n+        Optional<Declaration> cachedDecl = lookup(key);\n+        if (cachedDecl.isPresent()) {\n+            return cachedDecl.get();\n+        }\n+        Declaration decl = switch (c.kind()) {\n@@ -110,0 +144,4 @@\n+        if (decl != null) {\n+            declarationCache.put(key, withDeclarationString(decl, c));\n+        }\n+        return decl;\n@@ -121,1 +159,1 @@\n-            this.path = loc.path();\n+            this.path = loc.path().toAbsolutePath();\n@@ -188,2 +226,2 @@\n-        return Declaration.function(CursorPosition.of(c), c.spelling(), (Type.Function)funcType,\n-                params.toArray(new Declaration.Variable[0]));\n+        return withNestedTypes(Declaration.function(CursorPosition.of(c), c.spelling(), (Type.Function)funcType,\n+                params.toArray(new Declaration.Variable[0])), c, true);\n@@ -193,1 +231,11 @@\n-        return Declaration.constant(pos, name, value, type);\n+        Declaration.Constant macro = Declaration.constant(pos, name, value, type);\n+        String valueString = value.toString();\n+        if (value instanceof String) {\n+            \/\/ quote string literal\n+            valueString = STR.\"\\\"\\{valueString}\\\"\";\n+        } else if (Utils.isPointer(type)) {\n+            \/\/ add pointer cast to make it look different from a numeric constant\n+            valueString = STR.\"(void*) \\{valueString}\";\n+        }\n+        DeclarationString.with(macro, STR.\"#define \\{name} \\{valueString}\");\n+        return macro;\n@@ -197,1 +245,2 @@\n-        return Declaration.constant(CursorPosition.of(c), c.spelling(), c.getEnumConstantValue(), typeMaker.makeType(c.type()));\n+        return Declaration.constant(CursorPosition.of(c), c.spelling(), c.getEnumConstantValue(),\n+                toType(c));\n@@ -201,1 +250,1 @@\n-        return Declaration.toplevel(CursorPosition.of(c), filterNestedDeclarations(decls).toArray(new Declaration[0]));\n+        return Declaration.toplevel(CursorPosition.of(c), filterHeaderDeclarations(decls).toArray(new Declaration[0]));\n@@ -205,1 +254,1 @@\n-        Type.Declared t = (Type.Declared)RecordLayoutComputer.compute(typeMaker, 0, c.type(), c.type());\n+        checkCursorAny(c, CursorKind.StructDecl, CursorKind.UnionDecl);\n@@ -207,5 +256,2 @@\n-            Declaration.Scoped scoped = t.tree();\n-            List<Declaration> decls = filterNestedDeclarations(scoped.members());\n-            \/\/just a declaration AND definition, we have a layout\n-            return Declaration.scoped(scoped.kind(), scoped.pos(), scoped.name(),\n-                                      scoped.layout().get(), decls.toArray(new Declaration[0]));\n+            Type.Declared t = recordDeclaration(c, c);\n+            return t.tree();\n@@ -221,5 +267,37 @@\n-    public Declaration.Scoped createEnum(Cursor c) {\n-        List<Declaration> allDecls = new ArrayList<>();\n-        c.forEach(child -> {\n-            if (!child.isBitField() || (child.getBitFieldWidth() != 0 && !child.spelling().isEmpty())) {\n-                allDecls.add(createTree(child));\n+    final Type.Declared recordDeclaration(Cursor parent, Cursor recordCursor) {\n+        List<Declaration> pendingFields = new ArrayList<>();\n+        List<Variable> pendingBitFields = new ArrayList<>();\n+        AtomicReference<Position> pendingBitfieldsPos = new AtomicReference<>();\n+        recordCursor.forEach(fc -> {\n+            if (Utils.isFlattenable(fc)) {\n+                if (fc.isBitField()) {\n+                    if (pendingBitfieldsPos.get() == null) {\n+                        pendingBitfieldsPos.set(CursorPosition.of(fc));\n+                    }\n+                    Type fieldType = toType(fc);\n+                    Variable bitfieldDecl = Declaration.bitfield(CursorPosition.of(fc), fc.spelling(), fc.getBitFieldWidth(), fieldType);\n+                    if (!fc.spelling().isEmpty()) {\n+                        ClangOffsetOf.with(bitfieldDecl, parent.type().getOffsetOf(fc.spelling()));\n+                    }\n+                    pendingBitFields.add(bitfieldDecl);\n+                } else {\n+                    if (!pendingBitFields.isEmpty()) {\n+                        pendingFields.add(Declaration.bitfields(pendingBitfieldsPos.get(), pendingBitFields.toArray(Variable[]::new)));\n+                        pendingBitFields.clear();\n+                        pendingBitfieldsPos.set(null);\n+                    }\n+                    if (fc.isAnonymousStruct()) {\n+                        \/\/ process struct recursively\n+                        pendingFields.add(recordDeclaration(parent, fc).tree());\n+                    } else {\n+                        Declaration fieldDecl = createTree(fc);\n+                        ClangSizeOf.with(fieldDecl, fc.type().kind() == TypeKind.IncompleteArray ?\n+                                0 : fc.type().size() * 8);\n+                        ClangOffsetOf.with(fieldDecl, parent.type().getOffsetOf(fc.spelling()));\n+                        ClangAlignOf.with(fieldDecl, fc.type().align() * 8);\n+                        pendingFields.add(fieldDecl);\n+                    }\n+                }\n+            } else {\n+                \/\/ propagate\n+                createTree(fc);\n@@ -228,7 +306,5 @@\n-        List<Declaration> decls = filterNestedDeclarations(allDecls);\n-        if (c.isDefinition()) {\n-            \/\/just a declaration AND definition, we have a layout\n-            MemoryLayout layout = TypeMaker.valueLayoutForSize(c.type().size() * 8).layout().orElseThrow();\n-            return Declaration.enum_(CursorPosition.of(c), c.spelling(), layout, decls.toArray(new Declaration[0]));\n-        } else {\n-            return null;\n+\n+        if (!pendingBitFields.isEmpty()) {\n+            pendingFields.add(Declaration.bitfields(pendingBitfieldsPos.get(), pendingBitFields.toArray(Variable[]::new)));\n+            pendingBitFields.clear();\n+            pendingBitfieldsPos.set(null);\n@@ -236,0 +312,13 @@\n+\n+        Scoped structOrUnionDecl = recordCursor.kind() == CursorKind.StructDecl ?\n+                Declaration.struct(CursorPosition.of(recordCursor), recordCursor.spelling(),\n+                        pendingFields.toArray(new Declaration[0])) :\n+                Declaration.union(CursorPosition.of(recordCursor), recordCursor.spelling(),\n+                        pendingFields.toArray(new Declaration[0]));\n+        ClangSizeOf.with(structOrUnionDecl, recordCursor.type().size() * 8);\n+        ClangAlignOf.with(structOrUnionDecl, recordCursor.type().align() * 8);\n+        if (recordCursor.isAnonymousStruct()) {\n+            AnonymousStruct.with(structOrUnionDecl, offsetOfAnonymousRecord(parent, recordCursor, recordCursor));\n+        }\n+\n+        return Type.declared(structOrUnionDecl);\n@@ -238,3 +327,39 @@\n-    private static boolean isEnum(Declaration d) {\n-        return d instanceof Declaration.Scoped scoped &&\n-                scoped.kind() == Declaration.Scoped.Kind.ENUM;\n+    \/*\n+     * For the first named field that is nested somewhere inside anonRecord, we get the offset\n+     * to outermostParent and anonRecord itself. Subtracting the latter from the former\n+     * then gives us the offset of the anonRecord within outermostParent.\n+     *\n+     * Deals with cases like this too:\n+     *\n+     * struct Foo {\n+     *     char c; \/\/ offset = 0\n+     *     struct <anon1> { \/\/ offset = 96 - 64 = 32\n+     *         int: 32;\n+     *         struct <anon2> { \/\/ offset = 96 - 32 = 64\n+     *             int: 32;\n+     *             int x; \/\/ offset(Foo) = 96, offset(anon2) = 32, offset(anon1) = 64\n+     *         };\n+     *     };\n+     * };\n+     *\/\n+    private static OptionalLong offsetOfAnonymousRecord(Cursor outermostParent, Cursor anonRecord, Cursor record) {\n+        AtomicReference<OptionalLong> result = new AtomicReference<>(OptionalLong.empty());\n+        record.forEachShortCircuit(fc -> {\n+            if (Utils.isFlattenable(fc)) {\n+                if (!fc.spelling().isEmpty()) {\n+                    long offsetToOutermost = outermostParent.type().getOffsetOf(fc.spelling());\n+                    long offsetToAnon = anonRecord.type().getOffsetOf(fc.spelling());\n+                    result.set(OptionalLong.of(offsetToOutermost - offsetToAnon));\n+                    return false;\n+                } else if (fc.isAnonymousStruct()) {\n+                    OptionalLong nestedResult = offsetOfAnonymousRecord(outermostParent, anonRecord, fc);\n+                    if (nestedResult.isPresent()) {\n+                        result.set(nestedResult);\n+                        return false;\n+                    }\n+                    return true;\n+                }\n+            }\n+            return true;\n+        });\n+        return result.get();\n@@ -243,3 +368,14 @@\n-    private static boolean isBitfield(Declaration d) {\n-        return d instanceof Declaration.Scoped scoped &&\n-                scoped.kind() == Declaration.Scoped.Kind.BITFIELDS;\n+    public Declaration.Scoped createEnum(Cursor c) {\n+        List<Declaration> decls = new ArrayList<>();\n+        c.forEach(child -> decls.add(createTree(child)));\n+        if (c.isDefinition()) {\n+            \/\/just a declaration AND definition, we have a layout\n+            decls.forEach(d -> {\n+                \/\/ append declaration string\n+                DeclarationString.with(d, enumConstantString(c.spelling(), (Declaration.Constant)d));\n+            });\n+            return Declaration.enum_(CursorPosition.of(c), c.spelling(), decls.toArray(new Declaration[0]));\n+        } else {\n+            \/\/if there's a real definition somewhere else, skip this redundant declaration\n+            return null;\n+        }\n@@ -248,2 +384,4 @@\n-    private static boolean isAnonymousStruct(Declaration declaration) {\n-        return declaration.getAttribute(\"ANONYMOUS\").isPresent();\n+    private static boolean isRedundantTypedef(Declaration d) {\n+        return d instanceof Typedef typedef &&\n+                typedef.type() instanceof Declared declaredType &&\n+                declaredType.tree().name().equals(typedef.name());\n@@ -252,1 +390,6 @@\n-    private List<Declaration> filterNestedDeclarations(List<Declaration> declarations) {\n+    \/*\n+     * This method drops anonymous structs from the resulting toplevel declaration. These structs\n+     * can appear as part of a typedef, but are presented by libclang as toplevel structs, so we\n+     * need to filter them out.\n+     *\/\n+    private List<Declaration> filterHeaderDeclarations(List<Declaration> declarations) {\n@@ -255,1 +398,1 @@\n-                .filter(d -> isEnum(d) || !d.name().isEmpty() || isAnonymousStruct(d) || isBitfield(d))\n+                .filter(d -> Utils.isEnum(d) || (!d.name().isEmpty() && !isRedundantTypedef(d)))\n@@ -262,7 +405,0 @@\n-        if (canonicalType instanceof Type.Declared declaredCanonicalType) {\n-            Declaration.Scoped s = declaredCanonicalType.tree();\n-            if (s.name().equals(c.spelling())) {\n-                \/\/ typedef record with the same name, no need to present twice\n-                return null;\n-            }\n-        }\n@@ -273,7 +409,2 @@\n-        } else if (Utils.isPointerType(canonicalType)) {\n-            Type pointeeType = null;\n-            try {\n-                pointeeType = ((Type.Delegated)canonicalType).type();\n-            } catch (NullPointerException npe) {\n-                \/\/ exception thrown for unresolved pointee type. Ignore if we hit that case.\n-            }\n+        } else if (Utils.isPointer(canonicalType)) {\n+            Type pointeeType = ((Type.Delegated)canonicalType).type();\n@@ -299,1 +430,1 @@\n-        return Declaration.typedef(CursorPosition.of(c), c.spelling(), canonicalType);\n+        return withNestedTypes(Declaration.typedef(CursorPosition.of(c), c.spelling(), canonicalType), c, false);\n@@ -314,7 +445,18 @@\n-        Type type;\n-        try {\n-            type = toType(c);\n-        } catch (TypeMaker.TypeException ex) {\n-            System.err.println(ex);\n-            System.err.println(\"WARNING: ignoring variable: \" + c.spelling());\n-            return null;\n+        Type type = toType(c);\n+        return withNestedTypes(Declaration.var(kind, CursorPosition.of(c), c.spelling(), type), c, false);\n+    }\n+\n+    \/*\n+     * Some declarations (global vars, struct\/union fields, function parameter\/return types might contain\n+     * inline nested struct\/union\/enum definitions. This method collects such definitions and\n+     * attaches them to the original declaration, using an attribute.\n+     *\/\n+    private <D extends Declaration> D withNestedTypes(D d, Cursor c, boolean ignoreNestedParams) {\n+        List<Declaration> nestedDefinitions = new ArrayList<>();\n+        collectNestedTypes(c, nestedDefinitions, ignoreNestedParams);\n+        List<Scoped> nestedDecls = nestedDefinitions.stream()\n+                .filter(m -> m instanceof Scoped)\n+                .map(Scoped.class::cast)\n+                .toList();\n+        if (!nestedDecls.isEmpty()) {\n+            NestedDeclarations.with(d, nestedDecls);\n@@ -322,1 +464,13 @@\n-        return Declaration.var(kind, CursorPosition.of(c), c.spelling(), type);\n+        return d;\n+    }\n+\n+    private void collectNestedTypes(Cursor c, List<Declaration> nestedTypes, boolean ignoreNestedParams) {\n+        c.forEach(m -> {\n+            if (m.isDefinition()) {\n+                if (m.kind() == CursorKind.ParmDecl && !ignoreNestedParams) {\n+                    collectNestedTypes(m, nestedTypes, ignoreNestedParams);\n+                } else {\n+                    nestedTypes.add(createTree(m));\n+                }\n+            }\n+        });\n@@ -325,2 +479,2 @@\n-    private Type toType(Cursor c) {\n-        return typeMaker.makeType(c.type());\n+    Type toType(Cursor c) {\n+        return TypeMaker.makeType(c.type(), this);\n@@ -344,0 +498,36 @@\n+\n+    private <D extends Declaration> D withDeclarationString(D decl, Cursor cursor) {\n+        String declString = switch (decl) {\n+            case Declaration.Constant _ -> null; \/\/ do nothing for enum constants\n+            case Typedef _ -> declarationString(cursor, true); \/\/ always expand typedefs\n+            default -> {\n+                \/\/ heuristic, try w\/o expanding first, and check if there are <anonymous> strings\n+                String cursorString = declarationString(cursor, false);\n+                if (cursorString.matches(\".*\\\\(unnamed (struct|union|enum) at.*\")) {\n+                    \/\/ the output contains anonymous definitions, fallback and expand them\n+                    cursorString = declarationString(cursor, true);\n+                }\n+                yield cursorString;\n+            }\n+        };\n+        if (declString != null) {\n+            DeclarationString.with(decl, declString);\n+        }\n+        return decl;\n+    }\n+\n+    private String declarationString(Cursor cursor, boolean expandNestedDecls) {\n+        PrintingPolicy pp = cursor.getPrintingPolicy();\n+        if (expandNestedDecls) {\n+            pp.setProperty(PrintingPolicyProperty.IncludeTagDefinition, true);\n+        }\n+        pp.setProperty(PrintingPolicyProperty.PolishForDeclaration, true);\n+        return cursor.prettyPrinted(pp);\n+    }\n+\n+    private String enumConstantString(String enumName, Declaration.Constant enumConstant) {\n+        if (enumName.isEmpty()) {\n+            enumName = \"<anonymous>\";\n+        }\n+        return STR.\"enum \\{enumName}.\\{enumConstant.name()} = \\{enumConstant.value()}\";\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeMaker.java","additions":264,"deletions":74,"binary":false,"changes":338,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserveold.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.jextract.impl;\n-\n-import java.util.List;\n-import org.openjdk.jextract.Declaration;\n-\n-interface TreeTransformer {\n-    Declaration.Scoped transform(Declaration.Scoped header);\n-\n-    default Declaration.Scoped createHeader(Declaration.Scoped old, List<Declaration> members) {\n-        return Declaration.toplevel(old.pos(), members.toArray(new Declaration[0]));\n-    }\n-\n-    default Declaration.Scoped createScoped(Declaration.Scoped old, List<Declaration> members) {\n-        var declsArray = members.toArray(new Declaration[0]);\n-        return old.layout().isEmpty() ?\n-            Declaration.scoped(old.kind(), old.pos(), old.name(), declsArray) :\n-            Declaration.scoped(old.kind(), old.pos(), old.name(), old.layout().get(), declsArray);\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeTransformer.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -36,1 +36,0 @@\n-import java.lang.foreign.FunctionDescriptor;\n@@ -60,1 +59,7 @@\n-    public static final TypeImpl ERROR = new TypeImpl() {\n+    public static class ErronrousTypeImpl extends TypeImpl {\n+        final String erroneousName;\n+\n+        public ErronrousTypeImpl(String erroneousName) {\n+            this.erroneousName = erroneousName;\n+        }\n+\n@@ -370,86 +375,0 @@\n-\n-    \/\/ Utilities to fetch layouts\/descriptor from types\n-\n-    public static Optional<MemoryLayout> getLayout(org.openjdk.jextract.Type t) {\n-        try {\n-            return Optional.of(getLayoutInternal(t));\n-        } catch (UnsupportedOperationException ex) {\n-            return Optional.empty();\n-        }\n-    }\n-\n-    public static Optional<FunctionDescriptor> getDescriptor(Function t) {\n-        try {\n-            MemoryLayout[] args = t.argumentTypes().stream()\n-                    .map(TypeImpl::getLayoutInternal)\n-                    .toArray(MemoryLayout[]::new);\n-            Type retType = t.returnType();\n-            if (isVoidType(retType)) {\n-                return Optional.of(FunctionDescriptor.ofVoid(args));\n-            } else {\n-                return Optional.of(FunctionDescriptor.of(getLayoutInternal(retType), args));\n-            }\n-        } catch (UnsupportedOperationException ex) {\n-            return Optional.empty();\n-        }\n-    }\n-\n-    private static boolean isVoidType(org.openjdk.jextract.Type type) {\n-        if (type instanceof org.openjdk.jextract.Type.Primitive pt) {\n-            return pt.kind() == org.openjdk.jextract.Type.Primitive.Kind.Void;\n-        } else if (type instanceof org.openjdk.jextract.Type.Delegated dt) {\n-            return dt.kind() == org.openjdk.jextract.Type.Delegated.Kind.TYPEDEF? isVoidType(dt.type()) : false;\n-        }\n-        return false;\n-    }\n-\n-    public static MemoryLayout getLayoutInternal(org.openjdk.jextract.Type t) {\n-        return t.accept(layoutMaker, null);\n-    }\n-\n-    private static org.openjdk.jextract.Type.Visitor<MemoryLayout, Void> layoutMaker = new org.openjdk.jextract.Type.Visitor<>() {\n-        @Override\n-        public MemoryLayout visitPrimitive(org.openjdk.jextract.Type.Primitive t, Void _ignored) {\n-            return t.kind().layout().orElseThrow(UnsupportedOperationException::new);\n-        }\n-\n-        @Override\n-        public MemoryLayout visitDelegated(org.openjdk.jextract.Type.Delegated t, Void _ignored) {\n-            if (t.kind() == org.openjdk.jextract.Type.Delegated.Kind.POINTER) {\n-                return PointerImpl.POINTER_LAYOUT;\n-            } else {\n-                return t.type().accept(this, null);\n-            }\n-        }\n-\n-        @Override\n-        public MemoryLayout visitFunction(org.openjdk.jextract.Type.Function t, Void _ignored) {\n-            \/*\n-             * \/\/ pointer to function declared as function like this\n-             *\n-             * typedef void CB(int);\n-             * void func(CB cb);\n-             *\/\n-            return PointerImpl.POINTER_LAYOUT;\n-        }\n-\n-        @Override\n-        public MemoryLayout visitDeclared(org.openjdk.jextract.Type.Declared t, Void _ignored) {\n-            return t.tree().layout().orElseThrow(UnsupportedOperationException::new);\n-        }\n-\n-        @Override\n-        public MemoryLayout visitArray(org.openjdk.jextract.Type.Array t, Void _ignored) {\n-            MemoryLayout elem = t.elementType().accept(this, null);\n-            if (t.elementCount().isPresent()) {\n-                return MemoryLayout.sequenceLayout(t.elementCount().getAsLong(), elem);\n-            } else {\n-                return MemoryLayout.sequenceLayout(0, elem);\n-            }\n-        }\n-\n-        @Override\n-        public MemoryLayout visitType(org.openjdk.jextract.Type t, Void _ignored) {\n-            throw new UnsupportedOperationException();\n-        }\n-    };\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypeImpl.java","additions":7,"deletions":88,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.nio.ByteOrder;\n@@ -31,2 +30,0 @@\n-import java.util.ConcurrentModificationException;\n-import java.util.HashMap;\n@@ -34,3 +31,1 @@\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.function.Supplier;\n+import java.util.Optional;\n@@ -38,1 +33,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -40,0 +34,2 @@\n+import org.openjdk.jextract.Declaration.Scoped;\n+import org.openjdk.jextract.Declaration.Typedef;\n@@ -46,0 +42,7 @@\n+\/**\n+ * This class turns a clang type into a jextract type. Unlike declarations, jextract types are not\n+ * de-duplicated, so relying on the identity of a jextract type is wrong. Since pointer types can\n+ * point back to declarations, we create special pointer types backed by a supplier which fetches\n+ * the correct declaration from the tree maker cache. This makes sure that situations with\n+ * mutually referring pointers are dealt with correctly (i.e. by breaking cycles).\n+ *\/\n@@ -48,74 +51,1 @@\n-    TreeMaker treeMaker;\n-    private final Map<org.openjdk.jextract.clang.Type, Type> typeCache = new HashMap<>();\n-    private List<ClangTypeReference> unresolved = new ArrayList<>();\n-\n-    private class ClangTypeReference implements Supplier<Type> {\n-        org.openjdk.jextract.clang.Type origin;\n-        Type derived;\n-\n-        private ClangTypeReference(org.openjdk.jextract.clang.Type origin) {\n-            this.origin = origin;\n-            derived = typeCache.get(origin);\n-        }\n-\n-        public boolean isUnresolved() {\n-            return null == derived;\n-        }\n-\n-        public void resolve() {\n-            derived = makeType(origin);\n-            Objects.requireNonNull(derived, \"Clang type cannot be resolved: \" + origin.spelling());\n-        }\n-\n-        public Type get() {\n-            Objects.requireNonNull(derived, \"Type is not yet resolved.\");\n-            return derived;\n-        }\n-    }\n-\n-    private ClangTypeReference reference(org.openjdk.jextract.clang.Type type) {\n-        ClangTypeReference ref = new ClangTypeReference(type);\n-        if (ref.isUnresolved()) {\n-            unresolved.add(ref);\n-        }\n-        return ref;\n-    }\n-\n-    public TypeMaker(TreeMaker treeMaker) {\n-        this.treeMaker = treeMaker;\n-    }\n-\n-    \/**\n-     * Resolve all type references. This method should be called before discard clang cursors\/types\n-     *\/\n-    void resolveTypeReferences() {\n-        List<ClangTypeReference> resolving = unresolved;\n-        unresolved = new ArrayList<>();\n-        while (! resolving.isEmpty()) {\n-            resolving.forEach(ClangTypeReference::resolve);\n-            resolving = unresolved;\n-            unresolved = new ArrayList<>();\n-        }\n-    }\n-\n-    Type makeType(org.openjdk.jextract.clang.Type t) {\n-        Type rv = typeCache.get(t);\n-        if (rv != null) {\n-            return rv;\n-        }\n-        rv = makeTypeInternal(t);\n-        if (null != rv && typeCache.put(t, rv) != null) {\n-            throw new ConcurrentModificationException();\n-        }\n-        return rv;\n-    }\n-\n-    static class TypeException extends RuntimeException {\n-        static final long serialVersionUID = 1L;\n-\n-        TypeException(String msg) {\n-            super(msg);\n-        }\n-    }\n-\n-    Type makeTypeInternal(org.openjdk.jextract.clang.Type t) {\n+    static Type makeType(org.openjdk.jextract.clang.Type t, TreeMaker treeMaker) {\n@@ -124,1 +54,1 @@\n-                return makeType(t.canonicalType());\n+                return makeType(t.canonicalType(), treeMaker);\n@@ -173,1 +103,1 @@\n-                    throw new TypeException(\"Unknown type with same canonical type: \" + t.spelling());\n+                    return Type.error(t.spelling());\n@@ -175,1 +105,1 @@\n-                return makeType(canonical);\n+                return makeType(canonical, treeMaker);\n@@ -177,1 +107,1 @@\n-                Type elem = makeType(t.getElementType());\n+                Type elem = makeType(t.getElementType(), treeMaker);\n@@ -181,1 +111,1 @@\n-                Type elem = makeType(t.getElementType());\n+                Type elem = makeType(t.getElementType(), treeMaker);\n@@ -189,1 +119,1 @@\n-                    args.add(lowerFunctionType(t.argType(i)));\n+                    args.add(lowerFunctionType(t.argType(i), treeMaker));\n@@ -191,1 +121,1 @@\n-                return Type.function(t.isVariadic(), lowerFunctionType(t.resultType()), args.toArray(new Type[0]));\n+                return Type.function(t.isVariadic(), lowerFunctionType(t.resultType(), treeMaker), args.toArray(new Type[0]));\n@@ -195,1 +125,3 @@\n-                return Type.declared((Declaration.Scoped) treeMaker.createTree(t.getDeclarationCursor()));\n+                Declaration d = treeMaker.createTree(t.getDeclarationCursor());\n+                return d != null ?\n+                        Type.declared((Declaration.Scoped)d) : Type.error(t.spelling());\n@@ -199,3 +131,4 @@\n-                \/\/ TODO: We can always erase type for macro evaluation, should we?\n-                if (t.getPointeeType().kind() == TypeKind.FunctionProto) {\n-                    return new TypeImpl.PointerImpl(makeType(t.getPointeeType()));\n+                org.openjdk.jextract.clang.Type pointee = t.getPointeeType();\n+                if (pointee.kind() == TypeKind.FunctionProto ||\n+                        pointee.getDeclarationCursor().isInvalid()) {\n+                    return Type.pointer(makeType(t.getPointeeType(), treeMaker));\n@@ -203,1 +136,16 @@\n-                    return new TypeImpl.PointerImpl(reference(t.getPointeeType()));\n+                    \/\/ struct\/union pointer - defer processing of pointee type\n+                    Cursor declCursor = pointee.getDeclarationCursor();\n+                    Cursor.Key key = declCursor.toKey();\n+                    return Type.pointer(() -> {\n+                        Optional<Declaration> decl = treeMaker.lookup(key);\n+                        if (decl.isEmpty()) {\n+                            \/\/ no declaration, maybe an opaque type, give up and downgrade to void pointer\n+                            return Type.void_();\n+                        } else {\n+                            return switch (decl.get()) {\n+                                case Scoped scoped -> Type.declared(scoped);\n+                                case Typedef typedef -> Type.typedef(typedef.name(), typedef.type());\n+                                default -> throw new UnsupportedOperationException();\n+                            };\n+                        }\n+                    });\n@@ -207,1 +155,1 @@\n-                Type __type = makeType(t.canonicalType());\n+                Type __type = makeType(t.canonicalType(), treeMaker);\n@@ -211,1 +159,1 @@\n-                Type __type = makeType(t.getElementType());\n+                Type __type = makeType(t.getElementType(), treeMaker);\n@@ -215,1 +163,1 @@\n-                Type __type = makeType(t.getElementType());\n+                Type __type = makeType(t.getElementType(), treeMaker);\n@@ -232,0 +180,4 @@\n+            case Atomic: {\n+                Type aType = makeType(t.getValueType(), treeMaker);\n+                return Type.qualified(Delegated.Kind.ATOMIC, aType);\n+            }\n@@ -233,1 +185,1 @@\n-                return TypeImpl.ERROR;\n+                return Type.error(t.spelling());\n@@ -237,2 +189,2 @@\n-    private Type lowerFunctionType(org.openjdk.jextract.clang.Type t) {\n-        Type t2 = makeType(t);\n+    private static Type lowerFunctionType(org.openjdk.jextract.clang.Type t, TreeMaker treeMaker) {\n+        Type t2 = makeType(t, treeMaker);\n@@ -242,1 +194,1 @@\n-    private Type.Visitor<Type, Void> lowerFunctionType = new Type.Visitor<>() {\n+    private static final Type.Visitor<Type, Void> lowerFunctionType = new Type.Visitor<>() {\n@@ -261,10 +213,0 @@\n-\n-    public static Primitive.Kind valueLayoutForSize(long size) {\n-        return switch ((int) size) {\n-            case 8 -> Primitive.Kind.Char;\n-            case 16 -> Primitive.Kind.Short;\n-            case 32 -> Primitive.Kind.Int;\n-            case 64 -> Primitive.Kind.LongLong;\n-            default -> throw new IllegalStateException(\"Cannot infer container layout\");\n-        };\n-    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypeMaker.java","additions":53,"deletions":111,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -30,19 +30,3 @@\n-public class TypedefBuilder extends ClassSourceBuilder {\n-    private final Declaration.Typedef typedefTree;\n-    private final String superClass;\n-\n-    public TypedefBuilder(JavaSourceBuilder enclosing,\n-        Declaration.Typedef typedefTree, String name, String superClass) {\n-        super(enclosing, Kind.CLASS, name);\n-        this.typedefTree = typedefTree;\n-        this.superClass = superClass;\n-    }\n-\n-    @Override\n-    String superClass() {\n-        return superClass;\n-    }\n-\n-    @Override\n-    void classDeclBegin() {\n-        emitDocComment(typedefTree);\n+final class TypedefBuilder extends ClassSourceBuilder {\n+    private TypedefBuilder(SourceFileBuilder builder, String className, String superClass, String runtimeHelperName) {\n+        super(builder, \"public\", Kind.CLASS, className, superClass, null, runtimeHelperName);\n@@ -51,3 +35,8 @@\n-    @Override\n-    JavaSourceBuilder classEnd() {\n-        return super.classEnd();\n+    public static void generate(SourceFileBuilder builder, String className, String superClass, String runtimeHelperName,\n+                                Declaration.Typedef typedefTree) {\n+        TypedefBuilder tdb = new TypedefBuilder(builder, className, superClass, runtimeHelperName);\n+        tdb.appendBlankLine();\n+        tdb.emitDocComment(typedefTree);\n+        tdb.classBegin();\n+        tdb.emitDefaultConstructor();\n+        tdb.classEnd();\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypedefBuilder.java","additions":11,"deletions":22,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1,101 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package org.openjdk.jextract.impl;\n-\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import org.openjdk.jextract.Declaration;\n-import org.openjdk.jextract.clang.Cursor;\n-import org.openjdk.jextract.clang.Type;\n-import org.openjdk.jextract.clang.TypeKind;\n-\n-import java.util.List;\n-\n-\/**\n- * MemoryLayout computer for C unions.\n- *\/\n-final class UnionLayoutComputer extends RecordLayoutComputer {\n-    private final long offset;\n-    private long actualSize = 0L;\n-\n-    UnionLayoutComputer(TypeMaker typeMaker, long offsetInParent, Type parent, Type type) {\n-        super(typeMaker, parent, type);\n-        this.offset = offsetInParent;\n-    }\n-\n-    @Override\n-    void processField(Cursor c) {\n-        long expectedOffset = offsetOf(parent, c);\n-        if (expectedOffset > offset) {\n-            throw new IllegalStateException(\"No padding in union elements!\");\n-        }\n-\n-        addField(offset, parent, c);\n-        actualSize = Math.max(actualSize, fieldSize(c));\n-    }\n-\n-    @Override\n-    void startBitfield() {\n-        \/\/ do nothing\n-    }\n-\n-    @Override\n-    Declaration field(long offset, Cursor c) {\n-        if (c.isBitField()) {\n-            Declaration.Variable var = (Declaration.Variable)super.field(offset, c);\n-            return bitfield(var);\n-        } else {\n-            return super.field(offset, c);\n-        }\n-    }\n-\n-    @Override\n-    long fieldSize(Cursor c) {\n-        if (c.type().kind() == TypeKind.IncompleteArray) {\n-            return 0;\n-        } else if (c.isBitField()) {\n-            return c.getBitFieldWidth();\n-        } else {\n-            return c.type().size() * 8;\n-        }\n-    }\n-\n-    @Override\n-    Declaration.Scoped finishRecord(String layoutName, String declName) {\n-        \/\/ size mismatch indicates use of bitfields in union\n-        long expectedSize = type.size() * 8;\n-        if (actualSize < expectedSize) {\n-            \/\/ emit an extra padding of expected size to make sure union layout size is computed correctly\n-            addPadding(expectedSize);\n-        }\n-\n-        GroupLayout g = MemoryLayout.unionLayout(alignFields());\n-        checkSize(g);\n-        g = g.withName(layoutName);\n-        return Declaration.union(TreeMaker.CursorPosition.of(cursor), declName, g, fieldDecls.stream().toArray(Declaration[]::new));\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnionLayoutComputer.java","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -0,0 +1,284 @@\n+\/*\n+ * Copyright (c) 2023 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Declaration.Constant;\n+import org.openjdk.jextract.Declaration.Function;\n+import org.openjdk.jextract.Declaration.Scoped;\n+import org.openjdk.jextract.Declaration.Scoped.Kind;\n+import org.openjdk.jextract.Declaration.Typedef;\n+import org.openjdk.jextract.Declaration.Variable;\n+import org.openjdk.jextract.Type;\n+import org.openjdk.jextract.Type.Declared;\n+import org.openjdk.jextract.impl.DeclarationImpl.AnonymousStruct;\n+import org.openjdk.jextract.impl.DeclarationImpl.ClangSizeOf;\n+import org.openjdk.jextract.impl.DeclarationImpl.JavaName;\n+import org.openjdk.jextract.impl.DeclarationImpl.Skip;\n+\n+import java.io.PrintWriter;\n+\n+\/*\n+ * This visitor marks a number of unsupported construct so that they are skipped by code generation.\n+ * Unsupported constructs are:\n+ * - declarations containing an unsupported type (e.g. \"long128\")\n+ * - structs\/unions.variables for which no layout exists\n+ * - functions\/function pointer for which no descriptor exists\n+ * - variadic function pointers\n+ * - bitfields struct members\n+ * - anonymous struct whose first (possibly nested) member has unknown offset\n+ *\/\n+public class UnsupportedFilter implements Declaration.Visitor<Void, Declaration> {\n+\n+    private final PrintWriter errStream;\n+\n+    public UnsupportedFilter(PrintWriter errStream) {\n+        this.errStream = errStream;\n+    }\n+\n+    static Type firstUnsupportedType(Type type, boolean allowVoid) {\n+        return type.accept(UNSUPPORTED_VISITOR, allowVoid);\n+    }\n+\n+    public Declaration.Scoped scan(Declaration.Scoped header) {\n+        header.members().forEach(fieldTree -> fieldTree.accept(this, null));\n+        return header;\n+    }\n+\n+    @Override\n+    public Void visitFunction(Function funcTree, Declaration firstNamedParent) {\n+        Utils.forEachNested(funcTree, s -> s.accept(this, firstNamedParent));\n+\n+        \/\/generate static wrapper for function\n+        Type unsupportedType = firstUnsupportedType(funcTree.type(), false);\n+        if (unsupportedType != null) {\n+            warnSkip(funcTree.name(), STR.\"unsupported type usage: \\{unsupportedType}\");\n+            Skip.with(funcTree);\n+            return null;\n+        }\n+\n+        \/\/ check function pointers in parameters and return types\n+        for (Declaration.Variable param : funcTree.parameters()) {\n+            Utils.forEachNested(param, s -> s.accept(this, firstNamedParent));\n+            Type.Function f = Utils.getAsFunctionPointer(param.type());\n+            if (f != null && !checkFunctionTypeSupported(param, f, funcTree.name())) {\n+                Skip.with(funcTree);\n+                return null;\n+            }\n+        }\n+\n+        Type.Function returnFunc = Utils.getAsFunctionPointer(funcTree.type().returnType());\n+        if (returnFunc != null && !checkFunctionTypeSupported(funcTree, returnFunc, funcTree.name())) {\n+            Skip.with(funcTree);\n+            return null;\n+        }\n+        return null;\n+    }\n+\n+    private static String fieldName(Declaration firstNamedParent, Declaration decl) {\n+        String name = firstNamedParent != null ? firstNamedParent.name() + \".\" : \"\";\n+        name += decl.name();\n+        return name;\n+    }\n+\n+    @Override\n+    public Void visitVariable(Variable varTree, Declaration firstNamedParent) {\n+        Utils.forEachNested(varTree, s -> s.accept(this, varTree));\n+\n+        Type unsupportedType = firstUnsupportedType(varTree.type(), false);\n+        String name = fieldName(firstNamedParent, varTree);\n+        if (unsupportedType != null) {\n+            warnSkip(name, STR.\"unsupported type usage: \\{unsupportedType}\");\n+            Skip.with(varTree);\n+            return null;\n+        }\n+\n+        \/\/ check\n+        Type.Function func = Utils.getAsFunctionPointer(varTree.type());\n+        if (func != null && !checkFunctionTypeSupported(varTree, func, name)) {\n+            Skip.with(varTree);\n+            return null;\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitScoped(Scoped scoped, Declaration firstNamedParent) {\n+        Type unsupportedType = firstUnsupportedType(Type.declared(scoped), false);\n+        if (unsupportedType != null) {\n+            warnSkip(scoped.name(), STR.\"unsupported type usage: \\{unsupportedType}\");\n+            Skip.with(scoped);\n+            return null;\n+        }\n+\n+        if (scoped.kind() == Kind.BITFIELDS) {\n+            for (Declaration bitField : scoped.members()) {\n+                if (!bitField.name().isEmpty()) {\n+                    warnSkip(fieldName(firstNamedParent, bitField), \"type is bitfield\");\n+                }\n+            }\n+            Skip.with(scoped);\n+            return null;\n+        }\n+\n+        \/\/ propagate\n+        Declaration newNamedParent = !scoped.name().isEmpty() ? scoped : firstNamedParent;\n+        scoped.members().forEach(fieldTree -> {\n+            fieldTree.accept(this, newNamedParent);\n+        });\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitTypedef(Typedef typedefTree, Declaration firstNamedParent) {\n+        \/\/ propagate\n+        if (typedefTree.type() instanceof Declared declared) {\n+            visitScoped(declared.tree(), null);\n+        }\n+\n+        Type unsupportedType = firstUnsupportedType(typedefTree.type(),false);\n+        if (unsupportedType != null) {\n+            warnSkip(typedefTree.name(), STR.\"unsupported type usage: \\{unsupportedType}\");\n+            Skip.with(typedefTree);\n+            return null;\n+        }\n+\n+        Type.Function func = Utils.getAsFunctionPointer(typedefTree.type());\n+        if (func != null && !checkFunctionTypeSupported(typedefTree, func, typedefTree.name())) {\n+            Skip.with(typedefTree);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitConstant(Constant d, Declaration firstNamedParent) {\n+        Type unsupportedType = firstUnsupportedType(d.type(), false);\n+        String name = fieldName(firstNamedParent, d);\n+        if (unsupportedType != null) {\n+            warnSkip(name, STR.\"unsupported type usage: \\{unsupportedType}\");\n+            Skip.with(d);\n+            return null;\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitDeclaration(Declaration d, Declaration firstNamedParent) {\n+        return null;\n+    }\n+\n+    private boolean checkFunctionTypeSupported(Declaration decl, Type.Function func, String nameOfSkipped) {\n+        Type unsupportedType = firstUnsupportedType(func, false);\n+        if (unsupportedType != null) {\n+            warnSkip(nameOfSkipped, STR.\"unsupported type usage: \\{unsupportedType}\");\n+            return false;\n+        }\n+        \/\/generate functional interface\n+        if (func.varargs() && !func.argumentTypes().isEmpty()) {\n+            warnSkip(nameOfSkipped, \"varargs in callbacks is not supported: \" + decl.name());\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private static final Type.Visitor<Type, Boolean> UNSUPPORTED_VISITOR = new Type.Visitor<>() {\n+        @Override\n+        public Type visitPrimitive(Type.Primitive t, Boolean allowVoid) {\n+            return switch (t.kind()) {\n+                case Char16, Float128, HalfFloat, Int128, WChar -> t;\n+                case LongDouble -> TypeImpl.IS_WINDOWS ? null : t;\n+                case Void -> allowVoid ? null : t;\n+                default -> null;\n+            };\n+        }\n+\n+        @Override\n+        public Type visitFunction(Type.Function t, Boolean allowVoid) {\n+            for (Type arg : t.argumentTypes()) {\n+                Type unsupported = firstUnsupportedType(arg, false);\n+                if (unsupported != null) {\n+                    return unsupported;\n+                }\n+            }\n+            Type unsupported = firstUnsupportedType(t.returnType(), true);\n+            if (unsupported != null) {\n+                return unsupported;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Type visitDeclared(Type.Declared t, Boolean allowVoid) {\n+            if (t.tree().kind() == Kind.STRUCT || t.tree().kind() == Kind.UNION) {\n+                if (!isValidStructOrUnion(t.tree())) {\n+                    return t;\n+                }\n+            }\n+            return null;\n+        }\n+\n+        private boolean isValidStructOrUnion(Scoped scoped) {\n+            if (ClangSizeOf.get(scoped).isEmpty()) {\n+                return false;\n+            }\n+            if (AnonymousStruct.isPresent(scoped) &&\n+                    AnonymousStruct.getOrThrow(scoped).offset().isEmpty()) {\n+                return false;\n+            }\n+            return true;\n+        }\n+\n+        @Override\n+        public Type visitDelegated(Type.Delegated t, Boolean allowVoid) {\n+            \/\/ Note: unsupported pointer types (e.g. *long double) are not detected, but they are not problematic\n+            \/\/ layout-wise (e.g. they are always 32- or 64-bits, depending on the platform). This policy also allows\n+            \/\/ more flexibility when it comes to opaque struct types.\n+            return t.kind() != Type.Delegated.Kind.POINTER ?\n+                    firstUnsupportedType(t.type(), allowVoid) :\n+                    null;\n+        }\n+\n+        @Override\n+        public Type visitArray(Type.Array t, Boolean allowVoid) {\n+            return firstUnsupportedType(t.elementType(), false);\n+        }\n+\n+        @Override\n+        public Type visitType(Type t, Boolean allowVoid) {\n+            return t.isErroneous() ?\n+                    t : null;\n+        }\n+    };\n+\n+    private void warnSkip(String treeName, String message) {\n+        warn(STR.\"skipping \\{treeName}: \\{message}\");\n+    }\n+\n+    private void warn(String msg) {\n+        errStream.println(\"WARNING: \" + msg);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnsupportedFilter.java","additions":284,"deletions":0,"binary":false,"changes":284,"status":"added"},{"patch":"@@ -1,120 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.jextract.impl;\n-\n-import java.lang.foreign.MemoryLayout;\n-import org.openjdk.jextract.Declaration;\n-import org.openjdk.jextract.Type;\n-\n-import java.nio.ByteOrder;\n-\n-\/*\n- * Layouts for the primitive types not supported by ABI implementations.\n- *\/\n-public final class UnsupportedLayouts {\n-    private UnsupportedLayouts() {}\n-\n-    public static final MemoryLayout __INT128 = makeUnsupportedLayout(16, \"__int128\");\n-\n-    public static final MemoryLayout LONG_DOUBLE = makeUnsupportedLayout(16, \"long double\");\n-\n-    public static final MemoryLayout _FLOAT128 = makeUnsupportedLayout(16, \"_float128\");\n-\n-    public static final MemoryLayout __FP16 = makeUnsupportedLayout(2, \"__fp16\");\n-\n-    public static final MemoryLayout CHAR16 = makeUnsupportedLayout(2, \"char16\");\n-\n-    public static final MemoryLayout WCHAR_T = makeUnsupportedLayout(2, \"wchar_t\");\n-\n-    static String firstUnsupportedType(Type type) {\n-        return type.accept(unsupportedVisitor, null);\n-    }\n-\n-    private static MemoryLayout makeUnsupportedLayout(long size, String name) {\n-        return MemoryLayout.paddingLayout(size).withByteAlignment(size).withName(name);\n-    }\n-\n-    static Type.Visitor<String, Void> unsupportedVisitor = new Type.Visitor<>() {\n-        @Override\n-        public String visitPrimitive(Type.Primitive t, Void unused) {\n-            MemoryLayout layout = t.kind().layout().orElse(MemoryLayout.paddingLayout(8));\n-            if (layout.equals(__INT128) || layout.equals(LONG_DOUBLE) || layout.equals(_FLOAT128) || layout.equals(__FP16)) {\n-                return layout.name().get();\n-            } else {\n-                return null;\n-            }\n-        }\n-\n-        @Override\n-        public String visitFunction(Type.Function t, Void unused) {\n-            for (Type arg : t.argumentTypes()) {\n-                String unsupported = firstUnsupportedType(arg);\n-                if (unsupported != null) {\n-                    return unsupported;\n-                }\n-            }\n-            String unsupported = firstUnsupportedType(t.returnType());\n-            if (unsupported != null) {\n-                return unsupported;\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public String visitDeclared(Type.Declared t, Void unused) {\n-            for (Declaration d : t.tree().members()) {\n-                if (d instanceof Declaration.Variable variable) {\n-                    String unsupported = firstUnsupportedType(variable.type());\n-                    if (unsupported != null) {\n-                        return unsupported;\n-                    }\n-                }\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public String visitDelegated(Type.Delegated t, Void unused) {\n-            return t.kind() != Type.Delegated.Kind.POINTER ?\n-                    firstUnsupportedType(t.type()) :\n-                    null;\n-            \/\/in principle we should always do this:\n-            \/\/ return firstUnsupportedType(t.type());\n-            \/\/ but if we do that, we might end up with infinite recursion (because of pointer types).\n-            \/\/ Unsupported pointer types (e.g. *long double) are not detected, but they are not problematic layout-wise\n-            \/\/ (e.g. they are always 32- or 64-bits, depending on the platform).\n-        }\n-\n-        @Override\n-        public String visitArray(Type.Array t, Void unused) {\n-            return firstUnsupportedType(t.elementType());\n-        }\n-\n-        @Override\n-        public String visitType(Type t, Void unused) {\n-            return null;\n-        }\n-    };\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnsupportedLayouts.java","additions":0,"deletions":120,"binary":false,"changes":120,"status":"deleted"},{"patch":"@@ -30,0 +30,4 @@\n+import org.openjdk.jextract.Declaration.Constant;\n+import org.openjdk.jextract.Declaration.Scoped;\n+import org.openjdk.jextract.Declaration.Typedef;\n+import org.openjdk.jextract.JavaSourceFile;\n@@ -31,0 +35,1 @@\n+import org.openjdk.jextract.Type.Declared;\n@@ -32,0 +37,1 @@\n+import org.openjdk.jextract.Type.Delegated.Kind;\n@@ -35,0 +41,1 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.NestedDeclarations;\n@@ -36,5 +43,10 @@\n-import javax.tools.JavaFileObject;\n-import javax.tools.SimpleJavaFileObject;\n-import java.lang.foreign.MemoryLayout;\n-import java.io.IOException;\n-import java.net.URI;\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n@@ -46,14 +58,0 @@\n-    private static URI fileName(String pkgName, String clsName, String extension) {\n-        String pkgPrefix = pkgName.isEmpty() ? \"\" : pkgName.replaceAll(\"\\\\.\", \"\/\") + \"\/\";\n-        return URI.create(pkgPrefix + clsName + extension);\n-    }\n-\n-    static JavaFileObject fileFromString(String pkgName, String clsName, String contents) {\n-        return new SimpleJavaFileObject(fileName(pkgName, clsName, \".java\"), JavaFileObject.Kind.SOURCE) {\n-            @Override\n-            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n-                return contents;\n-            }\n-        };\n-    }\n-\n@@ -103,19 +101,14 @@\n-    \/**\n-     * Returns the type that should be used in declarations of various\n-     * memory layout implementations.\n-     * <p>\n-     * For example, the concrete layout implementation class {@code OfLongImpl} should be\n-     * declared as {@code OfLong} and not {@code OfLongImpl}.\n-     *\n-     * @param layout to generate a declaring type string for.\n-     * @return the unqualified type\n-     *\/\n-    static Class<?> layoutDeclarationType(MemoryLayout layout) {\n-        if (!layout.getClass().isInterface()) {\n-            Class<?> ifs[] = layout.getClass().getInterfaces();\n-            if (ifs.length != 1) {\n-                throw new IllegalStateException(\"The class\" + layout.getClass() + \" does not implement exactly one interface\");\n-            }\n-            return ifs[0];\n-        }\n-        return layout.getClass();\n+    static void forEachNested(Declaration declaration, Consumer<Declaration> nestedDeclAction) {\n+        NestedDeclarations.get(declaration).ifPresent(decls ->\n+            decls.forEach(nestedDeclAction));\n+    }\n+\n+    static boolean isStructOrUnion(Declaration declaration) {\n+        return declaration instanceof Declaration.Scoped scoped &&\n+                (scoped.kind() == Declaration.Scoped.Kind.STRUCT ||\n+                 scoped.kind() == Declaration.Scoped.Kind.UNION);\n+    }\n+\n+    static boolean isEnum(Declaration declaration) {\n+        return declaration instanceof Declaration.Scoped scoped &&\n+                scoped.kind() == Declaration.Scoped.Kind.ENUM;\n@@ -124,3 +117,5 @@\n-    static boolean isStructOrUnion(Declaration.Scoped scoped) {\n-        return switch (scoped.kind()) {\n-            case STRUCT, UNION -> true;\n+    static boolean isArray(Type type) {\n+        return switch (type) {\n+            case Type.Array _ -> true;\n+            case Type.Delegated delegated when delegated.kind() == Delegated.Kind.TYPEDEF ->\n+                    isArray(delegated.type());\n@@ -131,6 +126,40 @@\n-    static boolean isPointerType(Type type) {\n-        if (type instanceof Delegated delegated) {\n-            return delegated.kind() == Delegated.Kind.POINTER;\n-        } else {\n-            return false;\n-        }\n+    static boolean isEnum(Type type) {\n+        return switch (type) {\n+            case Type.Declared declared -> isEnum(declared.tree());\n+            case Type.Delegated delegated when delegated.kind() == Delegated.Kind.TYPEDEF ->\n+                    isEnum(delegated.type());\n+            default -> false;\n+        };\n+    }\n+\n+    static boolean isStructOrUnion(Type type) {\n+        return structOrUnionDecl(type) != null;\n+    }\n+\n+    static Declaration.Scoped structOrUnionDecl(Type type) {\n+        return switch (type) {\n+            case Type.Declared declared when isStructOrUnion(declared.tree()) -> declared.tree();\n+            case Type.Delegated delegated when delegated.kind() == Delegated.Kind.TYPEDEF ->\n+                    structOrUnionDecl(delegated.type());\n+            default -> null;\n+        };\n+    }\n+\n+    static boolean isPointer(Type type) {\n+        return switch (type) {\n+            case Type.Delegated delegated when delegated.kind() == Delegated.Kind.TYPEDEF ->\n+                    isPointer(delegated.type());\n+            case Type.Delegated delegated when delegated.kind() == Delegated.Kind.POINTER ->\n+                    true;\n+            default -> false;\n+        };\n+    }\n+\n+    static boolean isPrimitive(Type type) {\n+        return switch (type) {\n+            case Type.Declared declared when declared.tree().kind() == Declaration.Scoped.Kind.ENUM ->\n+                isPrimitive(((Declaration.Constant)declared.tree().members().get(0)).type());\n+            case Type.Delegated delegated when delegated.kind() != Kind.POINTER -> isPrimitive(delegated.type());\n+            case Type.Primitive _ -> true;\n+            default -> false;\n+        };\n@@ -140,13 +169,5 @@\n-        if (type instanceof Function function) {\n-            \/*\n-             * \/\/ pointer to function declared as function like this\n-             *\n-             * typedef void CB(int);\n-             * void func(CB cb);\n-             *\/\n-            return function;\n-        } else if (isPointerType(type)) {\n-            return getAsFunctionPointer(((Delegated)type).type());\n-        } else {\n-            return null;\n-        }\n+        return switch (type) {\n+            case Type.Delegated delegated when delegated.kind() == Kind.POINTER -> getAsFunctionPointer(delegated.type());\n+            case Type.Function function -> function;\n+            default -> null;\n+        };\n@@ -167,0 +188,17 @@\n+    static List<Long> dimensions(Type type) {\n+        List<Long> dims = new ArrayList<>();\n+        while (type instanceof Type.Array array) {\n+            if (array.elementCount().isEmpty()) return List.of();\n+            dims.add(array.elementCount().getAsLong());\n+            type = array.elementType();\n+        }\n+        return dims;\n+    }\n+\n+    static Type typeOrElemType(Type type) {\n+        return switch (type) {\n+            case Type.Array array -> typeOrElemType(array.elementType());\n+            default -> type;\n+        };\n+    }\n+\n@@ -173,0 +211,70 @@\n+\n+    public static Class<?> carrierFor(Type type) {\n+        return switch (type) {\n+            case Type.Array _ -> MemorySegment.class;\n+            case Type.Primitive p -> Utils.carrierFor(p);\n+            case Type.Declared declared -> declared.tree().kind() == Declaration.Scoped.Kind.ENUM ?\n+                    carrierFor(((Declaration.Constant) declared.tree().members().get(0)).type()) :\n+                    MemorySegment.class;\n+            case Type.Delegated delegated -> delegated.kind() == Type.Delegated.Kind.POINTER ?\n+                    MemorySegment.class :\n+                    carrierFor(delegated.type());\n+            case Type.Function _ -> MemorySegment.class;\n+            default -> throw new UnsupportedOperationException(type.toString());\n+        };\n+    };\n+\n+    public static Class<?> carrierFor(Type.Primitive p) {\n+        return switch (p.kind()) {\n+            case Void -> void.class;\n+            case Bool -> boolean.class;\n+            case Char -> byte.class;\n+            case Short -> short.class;\n+            case Int -> int.class;\n+            case Long -> TypeImpl.IS_WINDOWS ? int.class : long.class;\n+            case LongLong -> long.class;\n+            case Float -> float.class;\n+            case Double -> double.class;\n+            case LongDouble -> {\n+                if (TypeImpl.IS_WINDOWS) {\n+                    yield (Class<?>) double.class;\n+                } else {\n+                    throw new UnsupportedOperationException(p.toString());\n+                }\n+            }\n+            default -> throw new UnsupportedOperationException(p.toString());\n+        };\n+    }\n+\n+    public static Class<?> layoutCarrierFor(Type t) {\n+        return switch (t) {\n+            case Type.Array _ -> SequenceLayout.class;\n+            case Delegated delegated when delegated.kind() == Kind.POINTER -> AddressLayout.class;\n+            case Delegated delegated -> layoutCarrierFor(delegated.type());\n+            case Type.Primitive primitive -> {\n+                Class<?> clazz = carrierFor(primitive);\n+                yield CARRIERS_TO_LAYOUT_CARRIERS.get(clazz);\n+            }\n+            case Type.Declared declared when isStructOrUnion(declared) -> GroupLayout.class;\n+            case Type.Declared declared when isEnum(declared) -> layoutCarrierFor(((Constant)declared.tree().members().get(0)).type());\n+            default -> throw new UnsupportedOperationException(t.toString());\n+        };\n+    }\n+\n+    static final Map<Class<?>, Class<?>> CARRIERS_TO_LAYOUT_CARRIERS = Map.of(\n+            byte.class, ValueLayout.OfByte.class,\n+            boolean.class, ValueLayout.OfBoolean.class,\n+            char.class, ValueLayout.OfChar.class,\n+            short.class, ValueLayout.OfShort.class,\n+            int.class, ValueLayout.OfInt.class,\n+            float.class, ValueLayout.OfFloat.class,\n+            long.class, ValueLayout.OfLong.class,\n+            double.class, ValueLayout.OfDouble.class\n+    );\n+\n+    public static MethodType methodTypeFor(Type.Function type) {\n+        return MethodType.methodType(\n+                carrierFor(type.returnType()),\n+                type.argumentTypes().stream().map(Utils::carrierFor).toList()\n+        );\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Utils.java","additions":168,"deletions":60,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package org.openjdk.jextract.impl;\n-\n-import javax.tools.JavaFileObject;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.file.FileAlreadyExistsException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public final class Writer {\n-    private final List<? extends JavaFileObject> files;\n-    private final Path dest;\n-\n-    public Writer(Path dest, List<? extends JavaFileObject> files) {\n-        this.files = files;\n-        this.dest = dest;\n-    }\n-\n-    private List<JavaFileObject> ensureSourcesCompiled() {\n-        List<JavaFileObject> sources = sources();\n-        if (sources.isEmpty()) {\n-            return List.of();\n-        } else {\n-            return InMemoryJavaCompiler.compile(sources,\n-                \"-d\", dest.toAbsolutePath().toString(),\n-                \"-cp\", dest.toAbsolutePath().toString());\n-        }\n-    }\n-\n-    public void writeAll(boolean compileSources) throws IOException {\n-        writeClassFiles(resources());\n-        writeClassFiles(classes());\n-        if (compileSources) {\n-            writeClassFiles(ensureSourcesCompiled());\n-        } else {\n-            writeSourceFiles();\n-        }\n-    }\n-\n-    void writeClassFiles(List<JavaFileObject> files) throws IOException {\n-        Path destDir = createOutputDir();\n-        for (var entry : files) {\n-            String path = entry.getName();\n-            Path fullPath = destDir.resolve(path).normalize();\n-            Files.createDirectories(fullPath.getParent());\n-            try (InputStream is = entry.openInputStream()) {\n-                Files.write(fullPath, is.readAllBytes());\n-            }\n-        }\n-    }\n-\n-    void writeSourceFiles() throws IOException {\n-        Path destDir = createOutputDir();\n-        for (var entry : sources()) {\n-            String srcPath = entry.getName();\n-            Path fullPath = destDir.resolve(srcPath).normalize();\n-            Path dir = fullPath.getParent();\n-            \/\/ In case the folder exist and is a link to a folder, this should be OK\n-            \/\/ Case in point, \/tmp on MacOS link to \/private\/tmp\n-            if (Files.exists(dir)) {\n-                if (!Files.isDirectory(dir)) {\n-                    throw new FileAlreadyExistsException(dir.toAbsolutePath().toString());\n-                }\n-            } else {\n-                Files.createDirectories(fullPath.getParent());\n-            }\n-            Files.write(fullPath, List.of(entry.getCharContent(false)));\n-        }\n-    }\n-\n-    private List<JavaFileObject> sources() {\n-        return files.stream()\n-                .filter(jfo -> jfo.getKind() == JavaFileObject.Kind.SOURCE)\n-                .collect(Collectors.toList());\n-    }\n-\n-    private List<JavaFileObject> classes() {\n-        return files.stream()\n-                .filter(jfo -> jfo.getKind() == JavaFileObject.Kind.CLASS)\n-                .collect(Collectors.toList());\n-    }\n-\n-    private List<JavaFileObject> resources() {\n-        return files.stream()\n-                .filter(jfo -> (jfo.getKind() == JavaFileObject.Kind.HTML || jfo.getKind() == JavaFileObject.Kind.OTHER))\n-                .collect(Collectors.toList());\n-    }\n-\n-    private Path createOutputDir() throws IOException {\n-        Path absDest = dest.toAbsolutePath();\n-        if (!Files.exists(absDest)) {\n-            Files.createDirectories(absDest);\n-        }\n-        if (!Files.isDirectory(absDest)) {\n-            throw new IOException(\"Not a directory: \" + dest);\n-        }\n-        return absDest;\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Writer.java","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -28,1 +28,2 @@\n-l.option.value.invalid=option value for -l option should be a name or an absolute path: {0}\n+l.option.value.invalid=invalid library specifier for -l option: {0}\n+l.option.value.absolute.path=when using --use-system-load-library, option value for -l option should be a name or an absolute path: {0}\n@@ -43,0 +44,1 @@\n+help.use.system.load.library=load libraries in the loader symbol lookup\n@@ -66,3 +68,11 @@\n--l, --library <name | path>        specify a library by platform-independent name (e.g. \"GL\")   \\n\\\n-\\                                   or by absolute path (\"\/usr\/lib\/libGL.so\") that will be      \\n\\\n-\\                                   loaded by the generated class.                              \\n\\\n+-l, --library <libspec>            specify a shared library that should be loaded by the        \\n\\\n+\\                                  generated header class. If <libspec> starts with ':', then   \\n\\\n+\\                                   what follows is interpreted as a library path. Otherwise,   \\n\\\n+\\                                   <libspec> denotes a library name. Examples:                 \\n\\\n+\\                                      -l GL                                                    \\n\\\n+\\                                      -l :libGL.so.1                                           \\n\\\n+\\                                      -l :\/usr\/lib\/libGL.so.1                                  \\n\\\n+--use-system-load-library          libraries specified using -l are loaded in the loader symbol \\n\\\n+                                   lookup (using either System::loadLibrary, or System::load).  \\n\\\n+                                   Useful if the libraries must be loaded from one of the paths \\n\\\n+                                   in 'java.library.path'.                                      \\n\\ \n","filename":"src\/main\/resources\/org\/openjdk\/jextract\/impl\/resources\/Messages.properties","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,245 +0,0 @@\n-\/\/ Generated by jextract\n-\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.SymbolLookup;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.io.File;\n-import java.nio.file.Path;\n-import java.nio.charset.StandardCharsets;\n-import java.util.Arrays;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-import java.lang.foreign.AddressLayout;\n-import java.lang.foreign.MemoryLayout;\n-\n-import static java.lang.foreign.Linker.*;\n-import static java.lang.foreign.ValueLayout.*;\n-import static java.lang.Long.MAX_VALUE;\n-\n-final class RuntimeHelper {\n-\n-    private static final Linker LINKER = Linker.nativeLinker();\n-    private static final ClassLoader LOADER = RuntimeHelper.class.getClassLoader();\n-    private static final MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();\n-    private static final SymbolLookup SYMBOL_LOOKUP;\n-    private static final SegmentAllocator THROWING_ALLOCATOR = (x, y) -> { throw new AssertionError(\"should not reach here\"); };\n-    static final AddressLayout POINTER = ValueLayout.ADDRESS.withTargetLayout(MemoryLayout.sequenceLayout(MAX_VALUE, JAVA_BYTE));\n-\n-    final static SegmentAllocator CONSTANT_ALLOCATOR =\n-            (size, align) -> Arena.ofAuto().allocate(size, align);\n-\n-    static {\n-        #LOAD_LIBRARIES#\n-        SymbolLookup loaderLookup = SymbolLookup.loaderLookup();\n-        SYMBOL_LOOKUP = name -> loaderLookup.find(name).or(() -> LINKER.defaultLookup().find(name));\n-    }\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private RuntimeHelper() {}\n-\n-    static <T> T requireNonNull(T obj, String symbolName) {\n-        if (obj == null) {\n-            throw new UnsatisfiedLinkError(\"unresolved symbol: \" + symbolName);\n-        }\n-        return obj;\n-    }\n-\n-    static MemorySegment lookupGlobalVariable(String name, MemoryLayout layout) {\n-        return SYMBOL_LOOKUP.find(name)\n-                .map(s -> s.reinterpret(layout.byteSize()))\n-                .orElse(null);\n-    }\n-\n-    static MethodHandle downcallHandle(String name, FunctionDescriptor fdesc) {\n-        return SYMBOL_LOOKUP.find(name).\n-                map(addr -> LINKER.downcallHandle(addr, fdesc)).\n-                orElse(null);\n-    }\n-\n-    static MethodHandle downcallHandle(FunctionDescriptor fdesc) {\n-        return LINKER.downcallHandle(fdesc);\n-    }\n-\n-    static MethodHandle downcallHandleVariadic(String name, FunctionDescriptor fdesc) {\n-        return SYMBOL_LOOKUP.find(name).\n-                map(addr -> VarargsInvoker.make(addr, fdesc)).\n-                orElse(null);\n-    }\n-\n-    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n-        try {\n-            return MH_LOOKUP.findVirtual(fi, name, fdesc.toMethodType());\n-        } catch (Throwable ex) {\n-            throw new AssertionError(ex);\n-        }\n-    }\n-\n-    static <Z> MemorySegment upcallStub(MethodHandle fiHandle, Z z, FunctionDescriptor fdesc, Arena scope) {\n-        try {\n-            fiHandle = fiHandle.bindTo(z);\n-            return LINKER.upcallStub(fiHandle, fdesc, scope);\n-        } catch (Throwable ex) {\n-            throw new AssertionError(ex);\n-        }\n-    }\n-\n-    static MemorySegment asArray(MemorySegment addr, MemoryLayout layout, int numElements, Arena arena) {\n-         return addr.reinterpret(numElements * layout.byteSize(), arena, null);\n-    }\n-\n-    \/\/ Internals only below this point\n-\n-    private static final class VarargsInvoker {\n-        private static final MethodHandle INVOKE_MH;\n-        private final MemorySegment symbol;\n-        private final FunctionDescriptor function;\n-\n-        private VarargsInvoker(MemorySegment symbol, FunctionDescriptor function) {\n-            this.symbol = symbol;\n-            this.function = function;\n-        }\n-\n-        static {\n-            try {\n-                INVOKE_MH = MethodHandles.lookup().findVirtual(VarargsInvoker.class, \"invoke\", MethodType.methodType(Object.class, SegmentAllocator.class, Object[].class));\n-            } catch (ReflectiveOperationException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        static MethodHandle make(MemorySegment symbol, FunctionDescriptor function) {\n-            VarargsInvoker invoker = new VarargsInvoker(symbol, function);\n-            MethodHandle handle = INVOKE_MH.bindTo(invoker).asCollector(Object[].class, function.argumentLayouts().size() + 1);\n-            MethodType mtype = MethodType.methodType(function.returnLayout().isPresent() ? carrier(function.returnLayout().get(), true) : void.class);\n-            for (MemoryLayout layout : function.argumentLayouts()) {\n-                mtype = mtype.appendParameterTypes(carrier(layout, false));\n-            }\n-            mtype = mtype.appendParameterTypes(Object[].class);\n-            boolean needsAllocator = function.returnLayout().isPresent() &&\n-                                function.returnLayout().get() instanceof GroupLayout;\n-            if (needsAllocator) {\n-                mtype = mtype.insertParameterTypes(0, SegmentAllocator.class);\n-            } else {\n-                handle = MethodHandles.insertArguments(handle, 0, THROWING_ALLOCATOR);\n-            }\n-            return handle.asType(mtype);\n-        }\n-\n-        static Class<?> carrier(MemoryLayout layout, boolean ret) {\n-            if (layout instanceof ValueLayout valueLayout) {\n-                return valueLayout.carrier();\n-            } else if (layout instanceof GroupLayout) {\n-                return MemorySegment.class;\n-            } else {\n-                throw new AssertionError(\"Cannot get here!\");\n-            }\n-        }\n-\n-        private Object invoke(SegmentAllocator allocator, Object[] args) throws Throwable {\n-            \/\/ one trailing Object[]\n-            int nNamedArgs = function.argumentLayouts().size();\n-            assert(args.length == nNamedArgs + 1);\n-            \/\/ The last argument is the array of vararg collector\n-            Object[] unnamedArgs = (Object[]) args[args.length - 1];\n-\n-            int argsCount = nNamedArgs + unnamedArgs.length;\n-            Class<?>[] argTypes = new Class<?>[argsCount];\n-            MemoryLayout[] argLayouts = new MemoryLayout[nNamedArgs + unnamedArgs.length];\n-\n-            int pos = 0;\n-            for (pos = 0; pos < nNamedArgs; pos++) {\n-                argLayouts[pos] = function.argumentLayouts().get(pos);\n-            }\n-\n-            assert pos == nNamedArgs;\n-            for (Object o: unnamedArgs) {\n-                argLayouts[pos] = variadicLayout(normalize(o.getClass()));\n-                pos++;\n-            }\n-            assert pos == argsCount;\n-\n-            FunctionDescriptor f = (function.returnLayout().isEmpty()) ?\n-                    FunctionDescriptor.ofVoid(argLayouts) :\n-                    FunctionDescriptor.of(function.returnLayout().get(), argLayouts);\n-            MethodHandle mh = LINKER.downcallHandle(symbol, f);\n-            boolean needsAllocator = function.returnLayout().isPresent() &&\n-                                            function.returnLayout().get() instanceof GroupLayout;\n-            if (needsAllocator) {\n-                mh = mh.bindTo(allocator);\n-            }\n-            \/\/ flatten argument list so that it can be passed to an asSpreader MH\n-            Object[] allArgs = new Object[nNamedArgs + unnamedArgs.length];\n-            System.arraycopy(args, 0, allArgs, 0, nNamedArgs);\n-            System.arraycopy(unnamedArgs, 0, allArgs, nNamedArgs, unnamedArgs.length);\n-\n-            return mh.asSpreader(Object[].class, argsCount).invoke(allArgs);\n-        }\n-\n-        private static Class<?> unboxIfNeeded(Class<?> clazz) {\n-            if (clazz == Boolean.class) {\n-                return boolean.class;\n-            } else if (clazz == Void.class) {\n-                return void.class;\n-            } else if (clazz == Byte.class) {\n-                return byte.class;\n-            } else if (clazz == Character.class) {\n-                return char.class;\n-            } else if (clazz == Short.class) {\n-                return short.class;\n-            } else if (clazz == Integer.class) {\n-                return int.class;\n-            } else if (clazz == Long.class) {\n-                return long.class;\n-            } else if (clazz == Float.class) {\n-                return float.class;\n-            } else if (clazz == Double.class) {\n-                return double.class;\n-            } else {\n-                return clazz;\n-            }\n-        }\n-\n-        private Class<?> promote(Class<?> c) {\n-            if (c == byte.class || c == char.class || c == short.class || c == int.class) {\n-                return long.class;\n-            } else if (c == float.class) {\n-                return double.class;\n-            } else {\n-                return c;\n-            }\n-        }\n-\n-        private Class<?> normalize(Class<?> c) {\n-            c = unboxIfNeeded(c);\n-            if (c.isPrimitive()) {\n-                return promote(c);\n-            }\n-            if (c == MemorySegment.class) {\n-                return MemorySegment.class;\n-            }\n-            throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n-        }\n-\n-        private MemoryLayout variadicLayout(Class<?> c) {\n-            if (c == long.class) {\n-                return JAVA_LONG;\n-            } else if (c == double.class) {\n-                return JAVA_DOUBLE;\n-            } else if (c == MemorySegment.class) {\n-                return ADDRESS;\n-            } else {\n-                throw new IllegalArgumentException(\"Unhandled variadic argument class: \" + c);\n-            }\n-        }\n-    }\n-}\n","filename":"src\/main\/resources\/org\/openjdk\/jextract\/impl\/resources\/RuntimeHelper.java.template","additions":0,"deletions":245,"binary":false,"changes":245,"status":"deleted"},{"patch":"@@ -3,1 +3,1 @@\n-int getpid();\n+int getpid(void);\n","filename":"test.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-    jtreg\/generator\/test8244959\/Test8244959.java \\\n+    jtreg\/generator\/testPrintf\/TestPrintf.java \\\n@@ -14,1 +14,1 @@\n-    jtreg\/generator\/test8253102\/LibTest8253102Test.java \\\n+    jtreg\/generator\/reinterpret\/TestReinterpret.java \\\n","filename":"test\/TEST.groups","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-        run(\"--output\", splitOutput.toString(), splitH.toString()).checkSuccess();\n+        runAndCompile(splitOutput, splitH.toString());\n","filename":"test\/jtreg\/TestSplit.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.allocCallback.*;\n+\n+import java.lang.foreign.Arena;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+\/*\n+ * @test\n+ * @bug 7903239\n+ * @summary ofAddress factory of function pointer type is wrong for struct returns\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -l AllocCallback --use-system-load-library -t test.jextract.allocCallback alloc_callback.h\n+ * @build TestAllocCallback\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestAllocCallback\n+ *\/\n+public class TestAllocCallback {\n+    @Test\n+    public void testOfAddress() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            var foo = alloc_callback_h.foo();\n+\n+            var barA = Foo.a.invoke(Foo.a(foo), arena);\n+            var barB = Foo.b.invoke(Foo.b(foo), arena, 100);\n+\n+            assertEquals(Bar.a(barA), 5);\n+            assertEquals(Bar.a(barB), 100);\n+        }\n+    }\n+}\n","filename":"test\/jtreg\/generator\/allocCallback\/TestAllocCallback.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+struct Bar { int a; };\n+\n+struct Foo {\n+    struct Bar (*a)(void);\n+    struct Bar (*b)(int);\n+};\n+\n+EXPORT struct Bar a();\n+EXPORT struct Bar b(int v);\n+EXPORT struct Foo foo;\n","filename":"test\/jtreg\/generator\/allocCallback\/alloc_callback.h","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"alloc_callback.h\"\n+\n+struct Bar a() {\n+    return (struct Bar) { 5 };\n+};\n+\n+struct Bar b(int v) {\n+    return (struct Bar) { v };\n+};\n+\n+struct Foo foo = { a, b };\n","filename":"test\/jtreg\/generator\/allocCallback\/libAllocCallback.c","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+import test.jextract.arrayaccess.*;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+\n+import static test.jextract.arrayaccess.array_access_h.*;\n+\n+\/*\n+ * @test\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -l ArrayAccess --use-system-load-library -t test.jextract.arrayaccess array_access.h\n+ * @build TestArrayAccess\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestArrayAccess\n+ *\/\n+\n+public class TestArrayAccess {\n+    @Test\n+    public void testArrayAccessStructInt1() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment foo = Foo.allocate(arena);\n+            long[] dims = Foo.ints1$dimensions();\n+            for (int i = 0 ; i < dims[0] ; i++) {\n+                Foo.ints1(foo, i, i + 1);\n+                assertEquals(Foo.ints1(foo, i), i + 1);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessStructInt2() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment foo = Foo.allocate(arena);\n+            long[] dims = Foo.ints2$dimensions();\n+            for (int i = 0 ; i < dims[0] ; i++) {\n+                for (int j = 0; j < dims[1]; j++) {\n+                    Foo.ints2(foo, i, j, i + j + 1);\n+                    assertEquals(Foo.ints2(foo, i, j), i + j + 1);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessStructInt3() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment foo = Foo.allocate(arena);\n+            long[] dims = Foo.ints3$dimensions();\n+            for (int i = 0 ; i < dims[0] ; i++) {\n+                for (int j = 0; j < dims[1]; j++) {\n+                    for (int k = 0; k < dims[2]; k++) {\n+                        Foo.ints3(foo, i, j, k, i + j + k + 1);\n+                        assertEquals(Foo.ints3(foo, i, j, k), i + j + k + 1);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessGlobalInt1() {\n+        long[] dims = ints1$dimensions();\n+        for (int i = 0 ; i < dims[0] ; i++) {\n+            ints1(i, i + 1);\n+            assertEquals(ints1(i), i + 1);\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessGlobalInt2() {\n+        long[] dims = ints2$dimensions();\n+        for (int i = 0 ; i < dims[0] ; i++) {\n+            for (int j = 0; j < dims[1]; j++) {\n+                ints2(i, j, i + j + 1);\n+                assertEquals(ints2(i, j), i + j + 1);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessGlobalInt3() {\n+        long[] dims = ints3$dimensions();\n+        for (int i = 0 ; i < dims[0] ; i++) {\n+            for (int j = 0; j < dims[1]; j++) {\n+                for (int k = 0; k < dims[2]; k++) {\n+                    ints3(i, j, k, i + j + k + 1);\n+                    assertEquals(ints3(i, j, k), i + j + k + 1);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessStructStruct1() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment foo = Foo.allocate(arena);\n+            long[] dims = Foo.points1$dimensions();\n+            for (int i = 0 ; i < dims[0] ; i++) {\n+                MemorySegment point = Point.allocate(arena);\n+                Point.x(point, i + 1);\n+                Point.y(point, i + 2);\n+                Foo.points1(foo, i, point);\n+                assertEquals(Point.x(Foo.points1(foo, i)), i + 1);\n+                assertEquals(Point.y(Foo.points1(foo, i)), i + 2);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessStructStruct2() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment foo = Foo.allocate(arena);\n+            long[] dims = Foo.points2$dimensions();\n+            for (int i = 0 ; i < dims[0] ; i++) {\n+                for (int j = 0; j < dims[1]; j++) {\n+                    MemorySegment point = Point.allocate(arena);\n+                    Point.x(point, i + j + 1);\n+                    Point.y(point, i + j + 2);\n+                    Foo.points2(foo, i, j, point);\n+                    assertEquals(Point.x(Foo.points2(foo, i, j)), i + j + 1);\n+                    assertEquals(Point.y(Foo.points2(foo, i, j)), i + j + 2);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessStructStruct3() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment foo = Foo.allocate(arena);\n+            long[] dims = Foo.points3$dimensions();\n+            for (int i = 0 ; i < dims[0] ; i++) {\n+                for (int j = 0; j < dims[1]; j++) {\n+                    for (int k = 0; k < dims[2]; k++) {\n+                        MemorySegment point = Point.allocate(arena);\n+                        Point.x(point, i + j + k + 1);\n+                        Point.y(point, i + j + k + 2);\n+                        Foo.points3(foo, i, j, k, point);\n+                        assertEquals(Point.x(Foo.points3(foo, i, j, k)), i + j + k + 1);\n+                        assertEquals(Point.y(Foo.points3(foo, i, j, k)), i + j + k + 2);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessGlobalStruct1() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            long[] dims = points1$dimensions();\n+            for (int i = 0; i < dims[0]; i++) {\n+                MemorySegment point = Point.allocate(arena);\n+                Point.x(point, i + 1);\n+                Point.y(point, i + 2);\n+                points1(i, point);\n+                assertEquals(Point.x(points1(i)), i + 1);\n+                assertEquals(Point.y(points1(i)), i + 2);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessGlobalStruct2() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            long[] dims = points2$dimensions();\n+            for (int i = 0; i < dims[0]; i++) {\n+                for (int j = 0; j < dims[1]; j++) {\n+                    MemorySegment point = Point.allocate(arena);\n+                    Point.x(point, i + j + 1);\n+                    Point.y(point, i + j + 2);\n+                    points2(i, j, point);\n+                    assertEquals(Point.x(points2(i, j)), i + j + 1);\n+                    assertEquals(Point.y(points2(i, j)), i + j + 2);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessGlobalStruct3() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            long[] dims = points3$dimensions();\n+            for (int i = 0 ; i < dims[0] ; i++) {\n+                for (int j = 0; j < dims[1]; j++) {\n+                    for (int k = 0; k < dims[2]; k++) {\n+                        MemorySegment point = Point.allocate(arena);\n+                        Point.x(point, i + j + k + 1);\n+                        Point.y(point, i + j + k + 2);\n+                        points3(i, j, k, point);\n+                        assertEquals(Point.x(points3(i, j, k)), i + j + k + 1);\n+                        assertEquals(Point.y(points3(i, j, k)), i + j + k + 2);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jtreg\/generator\/arrayAccess\/TestArrayAccess.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+struct Point {\n+    int x;\n+    int y;\n+};\n+\n+\/\/ array fields in struct\n+\n+struct Foo {\n+    struct Point points1[2];\n+    struct Point points2[2][3];\n+    struct Point points3[2][3][4];\n+\n+    int ints1[2];\n+    int ints2[2][3];\n+    int ints3[2][3][4];\n+};\n+\n+\/\/ array global vars\n+\n+EXPORT extern struct Point points1[2];\n+EXPORT extern struct Point points2[2][3];\n+EXPORT extern struct Point points3[2][3][4];\n+\n+EXPORT extern int ints1[2];\n+EXPORT extern int ints2[2][3];\n+EXPORT extern int ints3[2][3][4];\n","filename":"test\/jtreg\/generator\/arrayAccess\/array_access.h","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"array_access.h\"\n+\n+EXPORT struct Point points1[2];\n+EXPORT struct Point points2[2][3];\n+EXPORT struct Point points3[2][3][4];\n+\n+EXPORT int ints1[2];\n+EXPORT int ints2[2][3];\n+EXPORT int ints3[2][3][4];\n","filename":"test\/jtreg\/generator\/arrayAccess\/libArrayAccess.c","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/* Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+import test.jextract.clinit.*;\n+\n+import java.lang.foreign.ValueLayout;\n+\n+\/*\n+ * @test\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.clinit --library ClinitGlobal --use-system-load-library -Djextract.decls.per.header=1 clinit_global.h\n+ * @build TestGlobal\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestGlobal\n+ *\/\n+public class TestGlobal {\n+\n+    @Test\n+    public void testGlobal() {\n+        ValueLayout layout = clinit_global_h.C_INT;\n+        assertNotNull(layout);\n+        assertEquals(clinit_global_h.global1(), 1);\n+        assertEquals(clinit_global_h.global2(), 2);\n+    }\n+}\n","filename":"test\/jtreg\/generator\/clinitCycles\/TestGlobal.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/* Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.clinit.*;\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.ValueLayout;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.clinit -Djextract.decls.per.header=1 clinit_struct.h\n+ * @build TestStruct\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestStruct\n+ *\/\n+public class TestStruct {\n+\n+    @Test\n+    public void TestStruct() {\n+        ValueLayout layout = clinit_struct_h.C_INT;\n+        assertNotNull(layout);\n+        GroupLayout pointLayout = Point.layout();\n+        assertNotNull(pointLayout);\n+        assertEquals(pointLayout.memberLayouts().get(0).withoutName(), layout);\n+        assertEquals(pointLayout.memberLayouts().get(1).withoutName(), layout);\n+    }\n+}\n","filename":"test\/jtreg\/generator\/clinitCycles\/TestStruct.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/* Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+import test.jextract.clinit.*;\n+\n+import java.lang.foreign.ValueLayout;\n+\n+\/*\n+ * @test\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.clinit -Djextract.decls.per.header=1 clinit_typedef.h\n+ * @build TestTypedef\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestTypedef\n+ *\/\n+public class TestTypedef {\n+\n+    @Test\n+    public void TestTypedef() {\n+        ValueLayout layout = clinit_typedef_h.C_INT;\n+        assertNotNull(layout);\n+        assertEquals(layout, clinit_typedef_h.one);\n+        assertEquals(layout, clinit_typedef_h.two);\n+        assertEquals(layout, clinit_typedef_h.three);\n+    }\n+}\n","filename":"test\/jtreg\/generator\/clinitCycles\/TestTypedef.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT extern int global1;\n+EXPORT extern int global2;\n","filename":"test\/jtreg\/generator\/clinitCycles\/clinit_global.h","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -1,2 +1,1 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +23,3 @@\n-struct Foo {\n-    int (*Foo)();\n+struct Point {\n+   int x;\n+   int y;\n","filename":"test\/jtreg\/generator\/clinitCycles\/clinit_struct.h","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/test7903237.h","status":"copied"},{"patch":"@@ -0,0 +1,25 @@\n+\/* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef int one;\n+typedef one two;\n+typedef two three;\n","filename":"test\/jtreg\/generator\/clinitCycles\/clinit_typedef.h","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"clinit_global.h\"\n+\n+int global1 = 1;\n+int global2 = 2;\n","filename":"test\/jtreg\/generator\/clinitCycles\/libClinitGlobal.c","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+import test.jextract.dedup.*;\n+\n+import java.lang.foreign.GroupLayout;\n+\n+\/*\n+ * @test\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.dedup macro_fields.h\n+ * @build TestDedup\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestDedup\n+ *\/\n+public class TestDedup {\n+\n+    @Test\n+    public void testMacroFields() {\n+        checkLayout(PointA.layout());\n+        checkLayout(PointB.layout());\n+    }\n+\n+    void checkLayout(GroupLayout layout) {\n+        assertEquals(layout.memberLayouts().get(0), macro_fields_h.C_INT.withName(\"x\"));\n+        assertEquals(layout.memberLayouts().get(1), macro_fields_h.C_INT.withName(\"y\"));\n+    }\n+}\n","filename":"test\/jtreg\/generator\/dedup\/TestDedup.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#define FIELDS \\\n+int x; \\\n+int y;\n+\n+struct PointA {\n+   FIELDS\n+};\n+\n+struct PointB {\n+   FIELDS\n+};\n","filename":"test\/jtreg\/generator\/dedup\/macro_fields.h","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @test id=classes\n+ * @test\n@@ -38,7 +38,2 @@\n- * @run main\/othervm JtregJextract -l Func -t test.jextract.funcpointers func.h\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestFuncPointerInvokers\n- *\/\n-\/*\n- * @test id=sources\n-  * @library \/lib\n- * @run main\/othervm JtregJextract -l Func -t test.jextract.funcpointers func.h\n+ * @run main\/othervm JtregJextract -l Func --use-system-load-library -t test.jextract.funcpointers func.h\n+ * @build TestFuncPointerInvokers\n@@ -48,10 +43,0 @@\n-    @Test\n-    public void testStructFieldTypedef() {\n-        try (Arena arena = Arena.ofConfined()) {\n-            AtomicInteger val = new AtomicInteger(-1);\n-            MemorySegment bar = Bar.allocate(arena);\n-            Bar.foo$set(bar, Foo.allocate((i) -> val.set(i), arena));\n-            Bar.foo(bar, arena).apply(42);\n-            assertEquals(val.get(), 42);\n-        }\n-    }\n@@ -64,12 +49,2 @@\n-            Bar.foo$set(bar, Foo.allocate((i) -> val.set(i), arena));\n-            Foo.ofAddress(Bar.foo$get(bar), arena).apply(42);\n-            assertEquals(val.get(), 42);\n-        }\n-    }\n-\n-    @Test\n-    public void testGlobalTypedef() {\n-        try (Arena arena = Arena.ofConfined()) {\n-            AtomicInteger val = new AtomicInteger(-1);\n-            f$set(Foo.allocate((i) -> val.set(i), arena));\n-            f().apply(42);\n+            Bar.foo(bar, Foo.allocate((i) -> val.set(i), arena));\n+            Foo.invoke(Bar.foo(bar), 42);\n@@ -84,13 +59,2 @@\n-            f$set(Foo.allocate((i) -> val.set(i), arena));\n-            Foo.ofAddress(f$get(), arena).apply(42);\n-            assertEquals(val.get(), 42);\n-        }\n-    }\n-\n-    @Test\n-    public void testStructFieldFunctionPointer() {\n-        try (Arena arena = Arena.ofConfined()) {\n-            AtomicInteger val = new AtomicInteger(-1);\n-            MemorySegment baz = Baz.allocate(arena);\n-            Baz.fp$set(baz, Baz.fp.allocate((i) -> val.set(i), arena));\n-            Baz.fp(baz, arena).apply(42);\n+            f(Foo.allocate((i) -> val.set(i), arena));\n+            Foo.invoke(f(), 42);\n@@ -106,12 +70,2 @@\n-            Baz.fp$set(baz, Baz.fp.allocate((i) -> val.set(i), arena));\n-            Baz.fp.ofAddress(Baz.fp$get(baz), arena).apply(42);\n-            assertEquals(val.get(), 42);\n-        }\n-    }\n-\n-    @Test\n-    public void testGlobalFunctionPointer() {\n-        try (Arena arena = Arena.ofConfined()) {\n-            AtomicInteger val = new AtomicInteger(-1);\n-            fp$set(fp.allocate((i) -> val.set(i), arena));\n-            fp().apply(42);\n+            Baz.fp(baz, Baz.fp.allocate((i) -> val.set(i), arena));\n+            Baz.fp.invoke(Baz.fp(baz), 42);\n@@ -126,2 +80,2 @@\n-            fp$set(fp.allocate((i) -> val.set(i), arena));\n-            fp.ofAddress(fp$get(), arena).apply(42);\n+            fp(fp.allocate((i) -> val.set(i), arena));\n+            fp.invoke(fp(), 42);\n@@ -135,2 +89,2 @@\n-            fp_addr$set(fp_addr.allocate((addr) -> MemorySegment.ofAddress(addr.address() + 1), arena));\n-            assertEquals(fp_addr.ofAddress(fp_addr$get(), arena).apply(MemorySegment.ofAddress(42)), MemorySegment.ofAddress(43));\n+            fp_addr(fp_addr.allocate((addr) -> MemorySegment.ofAddress(addr.address() + 1), arena));\n+            assertEquals(fp_addr.invoke(fp_addr(), MemorySegment.ofAddress(42)), MemorySegment.ofAddress(43));\n","filename":"test\/jtreg\/generator\/funcPointerInvokers\/TestFuncPointerInvokers.java","additions":14,"deletions":60,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.nested.anon.*;\n+\n+import java.lang.foreign.GroupLayout;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.nested.anon nestedInsideAnon.h\n+ * @build TestNestedInsideAnon\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNestedInsideAnon\n+ *\/\n+public class TestNestedInsideAnon {\n+\n+    @Test\n+    public void testAnonField() {\n+        checkLayout(P.layout());\n+    }\n+\n+    void checkLayout(GroupLayout layout) {\n+        assertEquals(((GroupLayout)layout.memberLayouts().get(0)).memberLayouts().get(0).withoutName(),\n+                P.Flags.layout().withoutName());\n+    }\n+}\n","filename":"test\/jtreg\/generator\/nestedInsideAnon\/TestNestedInsideAnon.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef struct {\n+    struct {\n+        struct {\n+            char y;\n+        } Flags;\n+    };\n+} P;\n","filename":"test\/jtreg\/generator\/nestedInsideAnon\/nestedInsideAnon.h","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+import test.jextract.nested.typedef.*;\n+\n+import java.lang.foreign.GroupLayout;\n+\n+\/*\n+ * @test\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.nested.typedef nestedStructTypedef.h\n+ * @build TestNestedStructTypedef\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNestedStructTypedef\n+ *\/\n+public class TestNestedStructTypedef {\n+\n+    @Test\n+    public void testMacroFields() {\n+        checkLayout(T.layout());\n+    }\n+\n+    void checkLayout(GroupLayout layout) {\n+        assertEquals(layout.memberLayouts().get(0), nestedStructTypedef_h.C_INT.withName(\"x\"));\n+    }\n+}\n","filename":"test\/jtreg\/generator\/nestedStructTypedef\/TestNestedStructTypedef.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Outer {\n+    struct Inner { int x; } a;\n+};\n+\n+typedef struct Inner T;\n","filename":"test\/jtreg\/generator\/nestedStructTypedef\/nestedStructTypedef.h","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.SequenceLayout;\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+import test.jextract.nestedtypes.*;\n+\n+\/*\n+ * @test\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.nestedtypes nested_types.h\n+ * @build TestNestedTypes\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNestedTypes\n+ *\/\n+public class TestNestedTypes {\n+\n+    @Test\n+    public void testNestedTypes() {\n+        checkNestedLayout(NestedStructArray.layout());\n+        checkNestedLayout(NestedStructArrayTypedef.layout());\n+        checkNestedLayout(NestedStructArrayTypedefTypedef.layout());\n+    }\n+\n+    void checkNestedLayout(MemoryLayout layout) {\n+        MemoryLayout nestedLayout = ((GroupLayout)layout).memberLayouts().get(0);\n+        assertEquals(nestedLayout.name().get(), \"nested\");\n+        assertTrue(nestedLayout instanceof SequenceLayout);\n+        assertEquals(((SequenceLayout)nestedLayout).elementCount(), 1);\n+        assertEquals(((SequenceLayout)nestedLayout).elementLayout().withoutName(), ELEM_NESTED_LAYOUT);\n+    }\n+\n+    static final MemoryLayout ELEM_NESTED_LAYOUT = MemoryLayout.structLayout(nested_types_h.C_INT.withName(\"x\"));\n+}\n","filename":"test\/jtreg\/generator\/nestedTypes\/TestNestedTypes.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.nestedtypes.names.*;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.nestedtypes.names nested_types_names.h\n+ * @build TestNestedTypesNames\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNestedTypesNames\n+ *\/\n+public class TestNestedTypesNames {\n+\n+    static MemoryLayout ARG_STRUCT = MemoryLayout.structLayout(\n+        nested_types_names_h.C_INT.withName(\"y\")\n+    );\n+\n+    static MemoryLayout RET_STRUCT = MemoryLayout.structLayout(\n+        nested_types_names_h.C_INT.withName(\"x\")\n+    );\n+\n+    static FunctionDescriptor FUNC_DESC = FunctionDescriptor.of(\n+            RET_STRUCT,\n+            ARG_STRUCT\n+    );\n+\n+    @Test\n+    public void testTypeNamesAndLayouts() {\n+        \/\/ function, anonymous\n+        checkLayout(f1$return.layout(), RET_STRUCT);\n+        checkLayout(f1$x0.layout(), ARG_STRUCT);\n+        \/\/ function, explicit names\n+        checkLayout(SR_FUN.layout(), RET_STRUCT);\n+        checkLayout(SA_FUN.layout(), ARG_STRUCT);\n+        \/\/ global, anonymous\n+        checkLayout(fp1$return.layout(), RET_STRUCT);\n+        checkLayout(fp1$x0.layout(), ARG_STRUCT);\n+        checkDescriptor(fp1.descriptor(), FUNC_DESC);\n+        \/\/ global, explicit names\n+        checkLayout(SR_VAR.layout(), RET_STRUCT);\n+        checkLayout(SA_VAR.layout(), ARG_STRUCT);\n+        checkDescriptor(fp2.descriptor(), FUNC_DESC);\n+        \/\/ typedef, anonymous\n+        checkLayout(td1$return.layout(), RET_STRUCT);\n+        checkLayout(td1$x0.layout(), ARG_STRUCT);\n+        checkDescriptor(td1.descriptor(), FUNC_DESC);\n+        \/\/ typedef, explicit names\n+        checkLayout(SR_DEF.layout(), RET_STRUCT);\n+        checkLayout(SA_DEF.layout(), ARG_STRUCT);\n+        checkDescriptor(td2.descriptor(), FUNC_DESC);\n+        \/\/ struct, anonymous\n+        checkLayout(Outer.fp1$return.layout(), RET_STRUCT);\n+        checkLayout(Outer.fp1$x0.layout(), ARG_STRUCT);\n+        checkDescriptor(Outer.fp1.descriptor(), FUNC_DESC);\n+        \/\/ struct, explicit names\n+        checkLayout(Outer.SR_FLD.layout(), RET_STRUCT);\n+        checkLayout(Outer.SA_FLD.layout(), ARG_STRUCT);\n+        checkDescriptor(Outer.fp2.descriptor(), FUNC_DESC);\n+        \/\/ struct + global, anonymous\n+        checkLayout(outer_var.fp1$return.layout(), RET_STRUCT);\n+        checkLayout(outer_var.fp1$x0.layout(), ARG_STRUCT);\n+        checkDescriptor(outer_var.fp1.descriptor(), FUNC_DESC);\n+        \/\/ struct + global, explicit names\n+        checkLayout(outer_var.SR_FLD_VAR.layout(), RET_STRUCT);\n+        checkLayout(outer_var.SA_FLD_VAR.layout(), ARG_STRUCT);\n+        checkDescriptor(outer_var.fp2.descriptor(), FUNC_DESC);\n+        \/\/ struct + typedef, anonymous\n+        checkLayout(outer_td.fp1$return.layout(), RET_STRUCT);\n+        checkLayout(outer_td.fp1$x0.layout(), ARG_STRUCT);\n+        checkDescriptor(outer_td.fp1.descriptor(), FUNC_DESC);\n+        \/\/ struct + typedef, explicit names\n+        checkLayout(outer_td.SR_FLD_DEF.layout(), RET_STRUCT);\n+        checkLayout(outer_td.SA_FLD_DEF.layout(), ARG_STRUCT);\n+        checkDescriptor(outer_td.fp2.descriptor(), FUNC_DESC);\n+        \/\/ struct + func return, anonymous\n+        checkLayout(f3$return.fp1$return.layout(), RET_STRUCT);\n+        checkLayout(f3$return.fp1$x0.layout(), ARG_STRUCT);\n+        checkDescriptor(f3$return.fp1.descriptor(), FUNC_DESC);\n+        \/\/ struct + func return, explicit names\n+        checkLayout(f3$return.SR_FLD_FUN_RET.layout(), RET_STRUCT);\n+        checkLayout(f3$return.SA_FLD_FUN_RET.layout(), ARG_STRUCT);\n+        checkDescriptor(f3$return.fp2.descriptor(), FUNC_DESC);\n+        \/\/ struct + func arg, anonymous\n+        checkLayout(f4$x0.fp1$return.layout(), RET_STRUCT);\n+        checkLayout(f4$x0.fp1$x0.layout(), ARG_STRUCT);\n+        checkDescriptor(f4$x0.fp1.descriptor(), FUNC_DESC);\n+        \/\/ struct + func arg, explicit names\n+        checkLayout(f4$x0.SR_FLD_FUN_ARG.layout(), RET_STRUCT);\n+        checkLayout(f4$x0.SA_FLD_FUN_ARG.layout(), ARG_STRUCT);\n+        checkDescriptor(f4$x0.fp2.descriptor(), FUNC_DESC);\n+    }\n+\n+    void checkLayout(MemoryLayout found, MemoryLayout expected) {\n+        assertEquals(found.withoutName(), expected);\n+    }\n+\n+    void checkDescriptor(FunctionDescriptor found, FunctionDescriptor expected) {\n+        assertEquals(\n+                FunctionDescriptor.of(\n+                        found.returnLayout().get().withoutName(),\n+                        found.argumentLayouts().get(0).withoutName()),\n+                expected);\n+    }\n+}\n","filename":"test\/jtreg\/generator\/nestedTypes\/TestNestedTypesNames.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.nestedtypes.unsupported.*;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.nestedtypes.unsupported nested_types_unsupported.h\n+ * @build TestNestedTypesUnsupported\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNestedTypesUnsupported\n+ *\/\n+public class TestNestedTypesUnsupported {\n+\n+    static MemoryLayout UNDEFINED_STRUCT = MemoryLayout.structLayout(\n+            MemoryLayout.paddingLayout(nested_types_unsupported_h.C_POINTER.byteSize())\n+    );\n+\n+    @Test\n+    public void testTypeNamesAndLayouts() {\n+        checkLayout(Outer.layout(), UNDEFINED_STRUCT);\n+        checkLayout(outer_var.layout(), UNDEFINED_STRUCT);\n+        checkLayout(outer_td.layout(), UNDEFINED_STRUCT);\n+        checkLayout(f2$return.layout(), UNDEFINED_STRUCT);\n+        checkLayout(f3$x0.layout(), UNDEFINED_STRUCT);\n+    }\n+\n+    void checkLayout(MemoryLayout found, MemoryLayout expected) {\n+        assertEquals(found.withoutName(), expected);\n+    }\n+}\n","filename":"test\/jtreg\/generator\/nestedTypes\/TestNestedTypesUnsupported.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct NestedStructArray {\n+    struct {\n+        int x;\n+    } nested[1];\n+};\n+\n+typedef struct {\n+    int x;\n+} T;\n+\n+struct NestedStructArrayTypedef {\n+    T nested[1];\n+};\n+\n+typedef T U;\n+\n+struct NestedStructArrayTypedefTypedef {\n+    U nested[1];\n+};\n","filename":"test\/jtreg\/generator\/nestedTypes\/nested_types.h","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+\/\/ function declarations\n+EXPORT struct { int x; } f1(struct { int y; } p);\n+\n+EXPORT struct SR_FUN { int x; } f2(struct SA_FUN { int y; } p);\n+\n+\/\/ global variable declarations\n+\n+EXPORT struct { int x; } (*fp1)(struct { int y; } p);\n+\n+EXPORT struct SR_VAR { int x; } (*fp2)(struct SA_VAR { int y; } p);\n+\n+\/\/ typedef declarations\n+\n+typedef struct { int x; } (*td1)(struct { int y; } p);\n+\n+typedef struct SR_DEF { int x; } (*td2)(struct SA_DEF { int y; } p);\n+\n+\/\/ field declarations\n+\n+struct Outer {\n+    struct { int x; } (*fp1)(struct { int y; } p);\n+    struct SR_FLD { int x; } (*fp2)(struct SA_FLD { int y; } p);\n+};\n+\n+\/\/ field and global\n+\n+EXPORT struct {\n+    struct { int x; } (*fp1)(struct { int y; } p);\n+    struct SR_FLD_VAR { int x; } (*fp2)(struct SA_FLD_VAR { int y; } p);\n+} outer_var;\n+\n+\/\/ field and typedef\n+\n+typedef struct {\n+    struct { int x; } (*fp1)(struct { int y; } p);\n+    struct SR_FLD_DEF { int x; } (*fp2)(struct SA_FLD_DEF { int y; } p);\n+} outer_td;\n+\n+\/\/ field and function return\n+\n+EXPORT struct {\n+    struct { int x; } (*fp1)(struct { int y; } p);\n+    struct SR_FLD_FUN_RET { int x; } (*fp2)(struct SA_FLD_FUN_RET { int y; } p);\n+} f3(void);\n+\n+\/\/ field and function arg\n+EXPORT void f4(struct {\n+    struct { int x; } (*fp1)(struct { int y; } p);\n+    struct SR_FLD_FUN_ARG { int x; } (*fp2)(struct SA_FLD_FUN_ARG { int y; } p);\n+} p);\n","filename":"test\/jtreg\/generator\/nestedTypes\/nested_types_names.h","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+\/\/ function declarations\n+EXPORT struct UNSUPPORTED f1(struct UNSUPPORTED p);\n+\n+\/\/ global variable declarations\n+\n+EXPORT struct UNSUPPORTED (*fp)(struct UNSUPPORTED p);\n+\n+\/\/ typedef declarations\n+\n+typedef struct UNSUPPORTED (*td)(struct UNSUPPORTED p);\n+\n+\/\/ field declarations\n+\n+struct Outer {\n+    struct UNSUPPORTED (*fp)(struct UNSUPPORTED p);\n+};\n+\n+\/\/ field and global\n+\n+EXPORT struct {\n+    struct UNSUPPORTED (*fp)(struct UNSUPPORTED p);\n+} outer_var;\n+\n+\/\/ field and typedef\n+\n+typedef struct {\n+    struct UNSUPPORTED (*fp)(struct UNSUPPORTED p);\n+} outer_td;\n+\n+\/\/ field and function return\n+\n+EXPORT struct {\n+    struct UNSUPPORTED (*fp)(struct UNSUPPORTED p);\n+} f2(void);\n+\n+\/\/ field and function arg\n+EXPORT void f3(struct {\n+    struct UNSUPPORTED (*fp)(struct UNSUPPORTED p);\n+} p);\n","filename":"test\/jtreg\/generator\/nestedTypes\/nested_types_unsupported.h","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.out.struct.*;\n+\n+import java.lang.foreign.GroupLayout;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.out.struct out_of_order_struct.h\n+ * @build TestOutOfOrderStruct\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestOutOfOrderStruct\n+ *\/\n+public class TestOutOfOrderStruct {\n+\n+    @Test\n+    public void testFoo() {\n+        checkLayout(Foo.layout());\n+    }\n+\n+    void checkLayout(GroupLayout layout) {\n+        assertEquals(layout.memberLayouts().get(0).withoutName(),\n+                Foo.Baz.layout().withoutName());\n+    }\n+}\n","filename":"test\/jtreg\/generator\/outOfOrder\/TestOutOfOrderStruct.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.out.typedef.*;\n+\n+import java.lang.foreign.GroupLayout;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.out.typedef out_of_order_typedef.h\n+ * @build TestOutOfOrderTypedef\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestOutOfOrderTypedef\n+ *\/\n+public class TestOutOfOrderTypedef {\n+\n+    @Test\n+    public void testFoo() {\n+        checkLayout(Foo.layout());\n+    }\n+\n+    void checkLayout(GroupLayout layout) {\n+        assertEquals(layout.memberLayouts().get(0).withoutName(),\n+                Foo.Baz.layout().withoutName());\n+    }\n+}\n","filename":"test\/jtreg\/generator\/outOfOrder\/TestOutOfOrderTypedef.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Dummy {\n+    struct tagFoo *Foo;\n+};\n+\n+typedef struct tagFoo {\n+    struct Baz { int y; } bar;\n+} Foo;\n","filename":"test\/jtreg\/generator\/outOfOrder\/out_of_order_struct.h","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef struct tagFoo Foo;\n+\n+typedef struct tagFoo {\n+    struct Baz { int y; } bar;\n+} Foo;\n","filename":"test\/jtreg\/generator\/outOfOrder\/out_of_order_typedef.h","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/* Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemoryLayout.PathElement;\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+import test.jextract.packedstructs.*;\n+\n+\/*\n+ * @test\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.packedstructs packedstructs.h\n+ * @build TestPackedStructs\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestPackedStructs\n+ *\/\n+public class TestPackedStructs {\n+\n+    @Test\n+    public void testPackedStructs() {\n+        checkLayout(S1.layout());\n+        checkLayout(S2.layout());\n+        checkLayout(S3.layout());\n+        checkLayout(S4.layout());\n+        checkLayout(S5.layout());\n+        checkLayout(S6.layout());\n+        checkLayout(S7.layout());\n+        checkLayout(S8.layout());\n+    }\n+\n+    private void checkLayout(MemoryLayout layout) {\n+        layout.select(PathElement.groupElement(\"first\"));\n+        layout.select(PathElement.groupElement(\"second\"));\n+        assertEquals(((GroupLayout)layout).memberLayouts().get(1).byteAlignment(), 1);\n+    }\n+}\n","filename":"test\/jtreg\/generator\/packed\/TestPackedStructs.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"","filename":"test\/jtreg\/generator\/packed\/packedstructs.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/testng\/org\/openjdk\/jextract\/test\/api\/packedstructs.h","status":"renamed"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static test.jextract.reinterpret.reinterpret_h.*;\n+import test.jextract.reinterpret.*;\n+\n+\/*\n+ * @test\n+ * @bug 8253102 7903626\n+ * @summary jextract should emit reinterpret utility method on struct classes\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -l Reinterpret --use-system-load-library -t test.jextract.reinterpret reinterpret.h\n+ * @build TestReinterpret\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestReinterpret\n+ *\/\n+public class TestReinterpret {\n+    @Test\n+    public void testSingleStruct() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment addr = make(14, 99);\n+            MemorySegment seg = Point.reinterpret(addr, arena, reinterpret_h::freePoint);\n+            assertEquals(Point.x(seg), 14);\n+            assertEquals(Point.y(seg), 99);\n+        }\n+    }\n+\n+    @Test\n+    public void testStructArray() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            int elementCount = 10;\n+            MemorySegment addr = makeArray(elementCount);\n+            MemorySegment array = Point.reinterpret(addr, elementCount, arena, reinterpret_h::freePoint);\n+            for (int i = 0; i < elementCount; i++) {\n+                MemorySegment point = Point.asSlice(array, i);\n+                assertEquals(Point.x(point), i);\n+                assertEquals(Point.y(point), i + 1);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jtreg\/generator\/reinterpret\/TestReinterpret.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"reinterpret.h\"\n+#include <stdlib.h>\n+\n+EXPORT Point* make(int x, int y) {\n+    Point* p = (Point*)malloc(sizeof(Point));\n+    p->x = x; p->y = y;\n+    return p;\n+}\n+\n+EXPORT void freePoint(struct Point* ptr) {\n+    free(ptr);\n+}\n+\n+EXPORT Point* makeArray(int count) {\n+    Point* p = (Point*)calloc(count, sizeof(Point));\n+    for (int i = 0; i < count; i++) {\n+        p[i].x = i;\n+        p[i].y = i + 1;\n+    }\n+    return p;\n+}\n","filename":"test\/jtreg\/generator\/reinterpret\/libReinterpret.c","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+EXPORT Point* makeArray(int count);\n+\n","filename":"test\/jtreg\/generator\/reinterpret\/reinterpret.h","additions":3,"deletions":1,"binary":false,"changes":4,"previous_filename":"test\/jtreg\/generator\/test8253102\/test8253102.h","status":"renamed"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.globalaccess.*;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+\n+import static org.testng.Assert.*;\n+import static test.jextract.globalaccess.globalStructAccess_h.*;\n+\n+\/*\n+ * @test\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -l StructGlobal --use-system-load-library -t test.jextract.globalaccess globalStructAccess.h\n+ * @build TestGlobalStructAccess\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestGlobalStructAccess\n+ *\/\n+public class TestGlobalStructAccess {\n+\n+    @Test\n+    public void testGlobalStructAccess() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment gPoint = p();\n+            assertEquals(Point.x(gPoint), 1);\n+            assertEquals(Point.y(gPoint), 2);\n+\n+            MemorySegment newPoint = allocatePoint(3, 4, arena);\n+            p(newPoint);\n+            assertEquals(Point.x(gPoint), 3);\n+            assertEquals(Point.y(gPoint), 4);\n+        }\n+    }\n+\n+    static MemorySegment allocatePoint(int x, int y, Arena arena) {\n+        MemorySegment point = Point.allocate(arena);\n+        Point.x(point, x);\n+        Point.y(point, y);\n+        return point;\n+    }\n+}\n","filename":"test\/jtreg\/generator\/structAccessors\/TestGlobalStructAccess.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import test.jextract.nestedaccess.*;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+\n+\/*\n+ * @test\n+  * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.nestedaccess nestedStructAccess.h\n+ * @build TestNestedStructAccess\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNestedStructAccess\n+ *\/\n+public class TestNestedStructAccess {\n+\n+    @Test\n+    public void testNestedStructAccess() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment start = allocatePoint(1, 2, arena);\n+            MemorySegment end = allocatePoint(3, 4, arena);\n+            MemorySegment line = allocateLine(start, end, arena);\n+            checkPointEquals(Line.start(line), start);\n+            checkPointEquals(Line.end(line), end);\n+        }\n+    }\n+\n+    static MemorySegment allocatePoint(int x, int y, Arena arena) {\n+        MemorySegment point = Point.allocate(arena);\n+        Point.x(point, x);\n+        Point.y(point, y);\n+        return point;\n+    }\n+\n+    static MemorySegment allocateLine(MemorySegment start, MemorySegment end, Arena arena) {\n+        MemorySegment line = Line.allocate(arena);\n+        Line.start(line, start);\n+        Line.end(line, end);\n+        return line;\n+    }\n+\n+    static void checkPointEquals(MemorySegment found, MemorySegment expected) {\n+        assertEquals(Point.x(found), Point.x(expected));\n+        assertEquals(Point.y(found), Point.y(expected));\n+    }\n+}\n","filename":"test\/jtreg\/generator\/structAccessors\/TestNestedStructAccess.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+struct Point {\n+   int x;\n+   int y;\n+};\n+\n+EXPORT extern struct Point p;\n","filename":"test\/jtreg\/generator\/structAccessors\/globalStructAccess.h","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"globalStructAccess.h\"\n+\n+struct Point p = { 1, 2 };\n","filename":"test\/jtreg\/generator\/structAccessors\/libStructGlobal.c","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Point {\n+    int x;\n+    int y;\n+};\n+\n+struct Line {\n+   struct Point start;\n+   struct Point end;\n+};\n","filename":"test\/jtreg\/generator\/structAccessors\/nestedStructAccess.h","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @test id=classes\n+ * @test\n@@ -32,9 +32,2 @@\n- * @run main\/othervm JtregJextract --library Test7903347 -t test.jextract.test7903347 test7903347.h\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest7903347Test\n- *\/\n-\/*\n- * @test id=sources\n- * @bug 7903347\n- * @summary add long name option for all single letter options and expand help on default values for various options\n- * @library \/lib\n- * @run main\/othervm JtregJextractSources --library Test7903347 -t test.jextract.test7903347 test7903347.h\n+ * @run main\/othervm JtregJextract --library Test7903347 --use-system-load-library -t test.jextract.test7903347 test7903347.h\n+ * @build LibTest7903347Test\n","filename":"test\/jtreg\/generator\/test7903347\/LibTest7903347Test.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @test id=classes\n+ * @test\n@@ -32,10 +32,3 @@\n-  * @library \/lib\n- * @run main\/othervm JtregJextract -l Test8239918 -t test.jextract.test8239918 test8239918.h\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8239918Test\n- *\/\n-\/*\n- * @test id=sources\n- * @bug 8239918\n- * @summary jextract generates uncompilable code for no argument C function\n-  * @library \/lib\n- * @run main\/othervm JtregJextractSources -l Test8239918 -t test.jextract.test8239918 test8239918.h\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -l Test8239918 --use-system-load-library -t test.jextract.test8239918 test8239918.h\n+ * @build LibTest8239918Test\n","filename":"test\/jtreg\/generator\/test8239918\/LibTest8239918Test.java","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @test id=classes\n+ * @test\n@@ -34,0 +34,1 @@\n+ * @build Lib8240373Test\n@@ -36,11 +37,0 @@\n-\n-\/*\n- * @test id=sources\n- * @bug 8240373\n- * @summary Jextract assigns type \"Void\" to enum macros\n- * @library \/lib\n- *\n- * @run main\/othervm JtregJextractSources -t test.jextract.test8240373 test8240373.h\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED Lib8240373Test\n- *\/\n-\n","filename":"test\/jtreg\/generator\/test8240373\/Lib8240373Test.java","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @test id=classes\n+ * @test\n@@ -41,8 +41,1 @@\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8244412Test\n- *\/\n-\/*\n- * @test id=sources\n- * @library \/lib\n- * @bug 8244412\n- * @summary jextract should generate static utils class for primitive typedefs\n- * @run main\/othervm JtregJextractSources -t test.jextract.test8244412 test8244412.h\n+ * @build LibTest8244412Test\n","filename":"test\/jtreg\/generator\/test8244412\/LibTest8244412Test.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @test id=classes\n+ * @test\n@@ -36,10 +36,2 @@\n- * @run main\/othervm JtregJextract -l Test8244938 -t test.jextract.test8244938 test8244938.h\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8244938\n- *\/\n-\n-\/*\n- * @test id=sources\n- * @bug 8244938\n- * @summary Crash in foreign ABI CallArranger class when a test native function returns a nested struct\n- * @library \/lib\n- * @run main\/othervm JtregJextractSources -l Test8244938 -t test.jextract.test8244938 test8244938.h\n+ * @run main\/othervm JtregJextract -l Test8244938 --use-system-load-library -t test.jextract.test8244938 test8244938.h\n+ * @build Test8244938\n@@ -54,4 +46,4 @@\n-             assertEquals(Point.k$get(seg), 44);\n-             var point2dSeg = Point.point2d$slice(seg);\n-             assertEquals(Point2D.i$get(point2dSeg), 567);\n-             assertEquals(Point2D.j$get(point2dSeg), 33);\n+             assertEquals(Point.k(seg), 44);\n+             var point2dSeg = Point.point2d(seg);\n+             assertEquals(Point2D.i(point2dSeg), 567);\n+             assertEquals(Point2D.j(point2dSeg), 33);\n","filename":"test\/jtreg\/generator\/test8244938\/Test8244938.java","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.foreign.Arena;\n-import org.testng.annotations.Test;\n-\n-import java.lang.foreign.MemorySegment;\n-\n-import static org.testng.Assert.assertEquals;\n-import static test.jextract.printf.printf_h.*;\n-import static java.lang.foreign.Linker.*;\n-\n-\/*\n- * @test id=classes\n- * @bug 8244959\n- * @summary Jextract's VarargsInvoker fails to link functions when passing integer types other than long\n- * @library \/lib\n- * @run main\/othervm JtregJextract -t test.jextract.printf -l Printf printf.h\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8244959\n- *\/\n-\/*\n- * @test id=sources\n- * @bug 8244959\n- * @summary Jextract's VarargsInvoker fails to link functions when passing integer types other than long\n- * @library \/lib\n- * @run main\/othervm JtregJextractSources -t test.jextract.printf -l Printf printf.h\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8244959\n- *\/\n-public class Test8244959 {\n-    @Test\n-    public void testsPrintf() {\n-        try (Arena arena = Arena.ofConfined()) {\n-            MemorySegment s = arena.allocate(1024);\n-            my_sprintf(s,\n-                    arena.allocateFrom(\"%hhd %c %.2f %.2f %lld %lld %d %hd %d %d %lld %c\"), 12,\n-                    (byte) 1, 'b', -1.25f, 5.5d, -200L, Long.MAX_VALUE, (byte) -2, (short) 2, 3, (short) -4, 5L, 'a');\n-            String str = s.getString(0);\n-            assertEquals(str, \"1 b -1.25 5.50 -200 \" + Long.MAX_VALUE + \" -2 2 3 -4 5 a\");\n-        }\n-    }\n-}\n","filename":"test\/jtreg\/generator\/test8244959\/Test8244959.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @test id=classes\n+ * @test\n@@ -37,9 +37,2 @@\n- * @run main\/othervm JtregJextract -l Test8245003 -t test.jextract.test8245003 test8245003.h\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8245003\n- *\/\n-\/*\n- * @test id=sources\n- * @bug 8245003\n- * @summary jextract does not generate accessor for MemorySegement typed values\n- * @library \/lib\n- * @run main\/othervm JtregJextractSources -l Test8245003 -t test.jextract.test8245003 test8245003.h\n+ * @run main\/othervm JtregJextract -l Test8245003 --use-system-load-library -t test.jextract.test8245003 test8245003.h\n+ * @build Test8245003\n@@ -51,1 +44,1 @@\n-        var seg = special_pt$SEGMENT();\n+        var seg = special_pt();\n@@ -53,2 +46,2 @@\n-        assertEquals(Point.x$get(seg), 56);\n-        assertEquals(Point.y$get(seg), 75);\n+        assertEquals(Point.x(seg), 56);\n+        assertEquals(Point.y(seg), 75);\n@@ -56,1 +49,1 @@\n-        seg = special_pt3d$SEGMENT();\n+        seg = special_pt3d();\n@@ -58,2 +51,2 @@\n-        assertEquals(Point3D.z$get(seg), 35);\n-        var pointSeg = Point3D.p$slice(seg);\n+        assertEquals(Point3D.z(seg), 35);\n+        var pointSeg = Point3D.p(seg);\n@@ -61,2 +54,2 @@\n-        assertEquals(Point.x$get(pointSeg), 43);\n-        assertEquals(Point.y$get(pointSeg), 45);\n+        assertEquals(Point.x(pointSeg), 43);\n+        assertEquals(Point.y(pointSeg), 45);\n@@ -67,1 +60,1 @@\n-        var seg = iarr$SEGMENT();\n+        var seg = iarr();\n@@ -77,1 +70,1 @@\n-        seg = foo$SEGMENT();\n+        seg = foo();\n@@ -79,2 +72,2 @@\n-        assertEquals(Foo.count$get(seg), 37);\n-        var greeting = Foo.greeting$slice(seg);\n+        assertEquals(Foo.count(seg), 37);\n+        var greeting = Foo.greeting(seg);\n","filename":"test\/jtreg\/generator\/test8245003\/Test8245003.java","additions":16,"deletions":23,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @test id=classes\n+ * @test\n@@ -37,9 +37,2 @@\n- * @run main\/othervm JtregJextract -l Test8246341 -t test.jextract.test8246341 test8246341.h\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8246341Test\n- *\/\n-\/*\n- * @test id=sources\n- * @bug 8246341\n- * @summary jextract should generate Cpointer utilities class\n- * @library \/lib\n- * @run main\/othervm JtregJextractSources -l Test8246341 -t test.jextract.test8246341 test8246341.h\n+ * @run main\/othervm JtregJextract -l Test8246341 --use-system-load-library -t test.jextract.test8246341 test8246341.h\n+ * @build LibTest8246341Test\n","filename":"test\/jtreg\/generator\/test8246341\/LibTest8246341Test.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @test id=classes\n+ * @test\n@@ -37,1 +37,2 @@\n- * @run main\/othervm JtregJextract -l Test8246400 -t test.jextract.test8246400 test8246400.h\n+ * @run main\/othervm JtregJextract -l Test8246400 --use-system-load-library -t test.jextract.test8246400 test8246400.h\n+ * @build LibTest8246400Test\n@@ -40,8 +41,0 @@\n-\/*\n- * @test id=sources\n- * @bug 8246400\n- * @summary jextract should generate a utility to manage mutliple MemorySegments\n- * @library \/lib\n- * @run main\/othervm JtregJextractSources -l Test8246400 -t test.jextract.test8246400 test8246400.h\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8246400Test\n- *\/\n@@ -54,2 +47,2 @@\n-            Vector.x$set(v1, 1.0);\n-            Vector.y$set(v1, 0.0);\n+            Vector.x(v1, 1.0);\n+            Vector.y(v1, 0.0);\n@@ -58,2 +51,2 @@\n-            Vector.x$set(v2, 0.0);\n-            Vector.y$set(v2, 1.0);\n+            Vector.x(v2, 0.0);\n+            Vector.y(v2, 1.0);\n@@ -63,2 +56,2 @@\n-            assertEquals(Vector.x$get(sum), 1.0, 0.1);\n-            assertEquals(Vector.y$get(sum), 1.0, 0.1);\n+            assertEquals(Vector.x(sum), 1.0, 0.1);\n+            assertEquals(Vector.y(sum), 1.0, 0.1);\n@@ -67,2 +60,2 @@\n-                return (Vector.x$get(a) * Vector.x$get(b)) +\n-                    (Vector.y$get(a) * Vector.y$get(b));\n+                return (Vector.x(a) * Vector.x(b)) +\n+                    (Vector.y(a) * Vector.y(b));\n","filename":"test\/jtreg\/generator\/test8246400\/LibTest8246400Test.java","additions":12,"deletions":19,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @test id=classes\n+ * @test\n@@ -33,9 +33,2 @@\n- * @run main\/othervm JtregJextract -libpath Test8249757 -t test.jextract.test8249757 test8249757.h\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8249757Test\n- *\/\n-\/*\n- * @test id=sources\n- * @library \/lib\n- * @bug 8249757\n- * @summary jextract should expose a way to load library from a given absolute path\n- * @run main\/othervm JtregJextractSources -libpath Test8249757 -t test.jextract.test8249757 test8249757.h\n+ * @run main\/othervm JtregJextract -l Test8249757 --use-system-load-library -t test.jextract.test8249757 test8249757.h\n+ * @build LibTest8249757Test\n","filename":"test\/jtreg\/generator\/test8249757\/LibTest8249757Test.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @test id=classes\n+ * @test\n@@ -39,9 +39,2 @@\n- * @run main\/othervm JtregJextract -t test.jextract.arrayparam -l Arrayparam arrayparam.h\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8252121\n- *\/\n-\/*\n- * @test id=sources\n- * @bug 8252121\n- * @summary jextract generated code fails with ABI for typedefed array type parameters\n- * @library \/lib\n- * @run main\/othervm JtregJextractSources -t test.jextract.arrayparam -l Arrayparam arrayparam.h\n+ * @run main\/othervm JtregJextract -t test.jextract.arrayparam -l Arrayparam --use-system-load-library arrayparam.h\n+ * @build Test8252121\n","filename":"test\/jtreg\/generator\/test8252121\/Test8252121.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @test id=classes\n+ * @test\n@@ -38,8 +38,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit LibTest8252465Test\n- *\/\n-\/*\n- * @test id=sources\n- * @bug 8252465\n- * @summary jextract generates wrong layout and varhandle when different structs have same named field\n- * @library \/lib\n- * @run main\/othervm JtregJextractSources -t test.jextract.test8252465 test8252465.h\n+ * @build LibTest8252465Test\n@@ -53,2 +46,2 @@\n-            Foo.x$set(foo, 3.14f);\n-            assertEquals(Foo.x$get(foo), 3.14f, 0.001f);\n+            Foo.x(foo, 3.14f);\n+            assertEquals(Foo.x(foo), 3.14f, 0.001f);\n@@ -56,2 +49,2 @@\n-            Bar.x$set(bar, -42);\n-            assertEquals(Bar.x$get(bar), -42);\n+            Bar.x(bar, -42);\n+            assertEquals(Bar.x(bar), -42);\n","filename":"test\/jtreg\/generator\/test8252465\/LibTest8252465Test.java","additions":7,"deletions":14,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.testng.annotations.Test;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-import static test.jextract.test8253102.test8253102_h.*;\n-import test.jextract.test8253102.*;\n-\n-\/*\n- * @test id=classes\n- * @bug 8253102\n- * @summary jextract should emit address to segment utility method on struct classes\n- * @library \/lib\n- * @run main\/othervm JtregJextract -l Test8253102 -t test.jextract.test8253102 test8253102.h\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8253102Test\n- *\/\n-\/*\n- * @test id=sources\n- * @bug 8253102\n- * @summary jextract should emit address to segment utility method on struct classes\n- * @library \/lib\n- * @run main\/othervm JtregJextractSources -l Test8253102 -t test.jextract.test8253102 test8253102.h\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8253102Test\n- *\/\n-public class LibTest8253102Test {\n-    @Test\n-    public void test() {\n-        try (Arena arena = Arena.ofConfined()) {\n-            MemorySegment addr = make(14, 99);\n-            MemorySegment seg = Point.ofAddress(addr, arena);\n-            assertEquals(Point.x$get(seg), 14);\n-            assertEquals(Point.y$get(seg), 99);\n-            freePoint(addr);\n-        }\n-    }\n-}\n","filename":"test\/jtreg\/generator\/test8253102\/LibTest8253102Test.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"test8253102.h\"\n-#include <stdlib.h>\n-\n-EXPORT Point* make(int x, int y) {\n-    Point* p = (Point*)malloc(sizeof(Point));\n-    p->x = x; p->y = y;\n-    return p;\n-}\n-\n-EXPORT void freePoint(struct Point* ptr) {\n-    free(ptr);\n-}\n","filename":"test\/jtreg\/generator\/test8253102\/libTest8253102.c","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @test id=classes\n+ * @test\n@@ -34,8 +34,1 @@\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8253390Test\n- *\/\n-\/*\n- * @test id=sources\n- * @library \/lib\n- * @bug 8253390\n- * @summary jextract should quote string literals\n- * @run main\/othervm JtregJextractSources -t test.jextract.test8253390 test8253390.h\n+ * @build LibTest8253390Test\n","filename":"test\/jtreg\/generator\/test8253390\/LibTest8253390Test.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @test id=classes\n+ * @test\n@@ -38,8 +38,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit LibTest8254983Test\n- *\/\n-\/*\n- * @test id=sources\n- * @library \/lib\n- * @bug 8254983\n- * @summary jextract fails to hande layout paths nested structs\/union\n- * @run main\/othervm JtregJextractSources -t test.jextract.test8254983 test8254983.h\n+ * @build LibTest8254983Test\n@@ -52,1 +45,1 @@\n-            assertEquals(((GroupLayout)Foo._struct.$LAYOUT()).memberLayouts().size(), 1);\n+            assertEquals(((GroupLayout)Foo._struct.layout()).memberLayouts().size(), 1);\n@@ -54,2 +47,2 @@\n-            Foo._struct.x$set(str, 42);\n-            assertEquals(Foo._struct.x$get(str), 42);\n+            Foo._struct.x(str, 42);\n+            assertEquals(Foo._struct.x(str), 42);\n@@ -61,1 +54,1 @@\n-        assertEquals(((GroupLayout)Foo._union._struct.$LAYOUT()).memberLayouts().size(), 2);\n+        assertEquals(((GroupLayout)Foo._union._struct.layout()).memberLayouts().size(), 2);\n@@ -64,2 +57,2 @@\n-            Foo._union._struct.x$set(str, 42);\n-            assertEquals(Foo._union._struct.x$get(str), 42);\n+            Foo._union._struct.x(str, 42);\n+            assertEquals(Foo._union._struct.x(str), 42);\n","filename":"test\/jtreg\/generator\/test8254983\/LibTest8254983Test.java","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,2 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertNull;\n+\n+import static org.testng.Assert.*;\n@@ -40,8 +40,1 @@\n- * @test id=classes\n- * @library \/lib\n- * @run main\/othervm JtregJextract -l Unsupported -t test.jextract.unsupported unsupported.h\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibUnsupportedTest\n- *\/\n-\n-\/*\n- * @test id=sources\n+ * @test\n@@ -49,2 +42,2 @@\n- *\n- * @run main\/othervm JtregJextractSources -l Unsupported -t test.jextract.unsupported unsupported.h\n+ * @run main\/othervm JtregJextract -l Unsupported --use-system-load-library -t test.jextract.unsupported unsupported.h\n+ * @build LibUnsupportedTest\n@@ -53,1 +46,0 @@\n-\n@@ -62,4 +54,4 @@\n-            Foo.i$set(seg, 32);\n-            Foo.c$set(seg, (byte)'z');\n-            assertEquals(Foo.i$get(seg), 32);\n-            assertEquals(Foo.c$get(seg), (byte)'z');\n+            Foo.i(seg, 32);\n+            Foo.c(seg, (byte)'z');\n+            assertEquals(Foo.i(seg), 32);\n+            assertEquals(Foo.c(seg), (byte)'z');\n@@ -72,5 +64,5 @@\n-            var seg = Foo.ofAddress(getFoo(), arena);\n-            Foo.i$set(seg, 42);\n-            Foo.c$set(seg, (byte)'j');\n-            assertEquals(Foo.i$get(seg), 42);\n-            assertEquals(Foo.c$get(seg), (byte)'j');\n+            var seg = Foo.reinterpret(getFoo(), arena, null);\n+            Foo.i(seg, 42);\n+            Foo.c(seg, (byte)'j');\n+            assertEquals(Foo.i(seg), 42);\n+            assertEquals(Foo.c(seg), (byte)'j');\n@@ -86,1 +78,1 @@\n-        GroupLayout g = (GroupLayout)Foo.$LAYOUT();\n+        GroupLayout g = (GroupLayout)Foo.layout();\n@@ -92,1 +84,1 @@\n-    public void testIgnoredMethods() {\n+    public void testProblematicMethods() {\n@@ -94,1 +86,7 @@\n-            throw new SkipException(\"long double works on Windows\");\n+            assertNotNull(findMethod(unsupported_h.class, \"func\"));\n+            assertNotNull(findMethod(unsupported_h.class, \"func2\"));\n+            assertNotNull(findMethod(unsupported_h.class, \"func3\"));\n+        } else {\n+            assertNull(findMethod(unsupported_h.class, \"func\"));\n+            assertNull(findMethod(unsupported_h.class, \"func2\"));\n+            assertNull(findMethod(unsupported_h.class, \"func3\"));\n@@ -96,6 +94,3 @@\n-        assertNull(findMethod(unsupported_h.class, \"func\"));\n-        assertNull(findMethod(unsupported_h.class, \"func2\"));\n-        assertNull(findMethod(unsupported_h.class, \"func3\"));\n-        assertNull(findMethod(unsupported_h.class, \"func4\"));\n-        assertNull(findMethod(unsupported_h.class, \"makeFoo\"));\n-        assertNull(findMethod(unsupported_h.class, \"copyFoo\"));\n+        assertNotNull(findMethod(unsupported_h.class, \"func4\"));\n+        assertNotNull(findMethod(unsupported_h.class, \"makeFoo\"));\n+        assertNotNull(findMethod(unsupported_h.class, \"copyFoo\"));\n","filename":"test\/jtreg\/generator\/test8257892\/LibUnsupportedTest.java","additions":27,"deletions":32,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -44,2 +44,2 @@\n-EXPORT Foo* getFoo();\n-EXPORT Foo makeFoo();\n+EXPORT Foo* getFoo(void);\n+EXPORT Foo makeFoo(void);\n","filename":"test\/jtreg\/generator\/test8257892\/unsupported.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @test id=classes\n+ * @test\n@@ -37,9 +37,2 @@\n- * @run main\/othervm JtregJextract -l FuncParam -t test.jextract.test8258605 funcParam.h\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8258605Test\n- *\/\n-\/*\n- * @test id=sources\n- * @bug 8258605\n- * @summary regression: jextract can not handle function prototypes as function arguments\n- * @library \/lib\n- * @run main\/othervm JtregJextractSources -l FuncParam -t test.jextract.test8258605 funcParam.h\n+ * @run main\/othervm JtregJextract -l FuncParam --use-system-load-library -t test.jextract.test8258605 funcParam.h\n+ * @build LibTest8258605Test\n@@ -69,1 +62,1 @@\n-             assertFalse(Foo.bar$get(foo).equals(NULL));\n+             assertFalse(Foo.bar(foo).equals(NULL));\n","filename":"test\/jtreg\/generator\/test8258605\/LibTest8258605Test.java","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-EXPORT struct Foo getFoo();\n+EXPORT struct Foo getFoo(void);\n","filename":"test\/jtreg\/generator\/test8258605\/funcParam.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.MemorySegment;\n-import org.testng.annotations.Test;\n-import test.jextract.test8259473.*;\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-import static test.jextract.test8259473.test8259473_h.*;\n-\n-\/*\n- * @test id=classes\n- * @bug 8259473\n- * @summary jextract generated code should throw exception for unfound native symbols from calls, variable access, set immediately\n- * @library \/lib\n- * @run main\/othervm JtregJextract -t test.jextract.test8259473 test8259473.h\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8259473Test\n- *\/\n-\/*\n- * @test id=sources\n- * @bug 8259473\n- * @summary jextract generated code should throw exception for unfound native symbols from calls, variable access, set immediately\n- * @library \/lib\n- * @run main\/othervm JtregJextractSources -t test.jextract.test8259473 test8259473.h\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8259473Test\n- *\/\n-public class LibTest8259473Test {\n-    @Test\n-    public void nullChecksTest() {\n-        try {\n-            func();\n-            throw new AssertionError(\"should not reach here\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            assertTrue(ule.getMessage().contains(\"unresolved symbol: func\"));\n-        }\n-\n-        try {\n-            func$MH();\n-            throw new AssertionError(\"should not reach here\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            assertTrue(ule.getMessage().contains(\"unresolved symbol: func\"));\n-        }\n-\n-        try {\n-            x$get();\n-            throw new AssertionError(\"should not reach here\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            assertTrue(ule.getMessage().contains(\"unresolved symbol: x\"));\n-        }\n-\n-        try {\n-            x$set(1);\n-            throw new AssertionError(\"should not reach here\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            assertTrue(ule.getMessage().contains(\"unresolved symbol: x\"));\n-        }\n-\n-        try {\n-            x$SEGMENT();\n-            throw new AssertionError(\"should not reach here\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            assertTrue(ule.getMessage().contains(\"unresolved symbol: x\"));\n-        }\n-\n-        try {\n-            y$SEGMENT();\n-            throw new AssertionError(\"should not reach here\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            assertTrue(ule.getMessage().contains(\"unresolved symbol: y\"));\n-        }\n-\n-        try {\n-            pt$SEGMENT();\n-            throw new AssertionError(\"should not reach here\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            assertTrue(ule.getMessage().contains(\"unresolved symbol: pt\"));\n-        }\n-    }\n-}\n","filename":"test\/jtreg\/generator\/test8259473\/LibTest8259473Test.java","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @test id=classes\n+ * @test\n@@ -36,9 +36,2 @@\n- * @run main\/othervm JtregJextract -l Test8261511 -t test.jextract.test8261511 test8261511.h\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8261511\n- *\/\n-\/*\n- * @test id=sources\n- * @bug 8261511\n- * @summary jextract does not generate accessor for MemorySegement typed values\n- * @library \/lib\n- * @run main\/othervm JtregJextractSources -l Test8261511 -t test.jextract.test8261511 test8261511.h\n+ * @run main\/othervm JtregJextract -l Test8261511 --use-system-load-library -t test.jextract.test8261511 test8261511.h\n+ * @build Test8261511\n@@ -51,3 +44,2 @@\n-            var funcPtr = Foo.sum$get(get_foo(arena));\n-            var sumIface = Foo.sum.ofAddress(funcPtr, arena);\n-            assertEquals(sumIface.apply(15,20), 35);\n+            var funcPtr = Foo.sum(get_foo(arena));\n+            assertEquals(Foo.sum.invoke(funcPtr, 15, 20), 35);\n","filename":"test\/jtreg\/generator\/test8261511\/Test8261511.java","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-EXPORT struct Foo get_foo();\n+EXPORT struct Foo get_foo(void);\n","filename":"test\/jtreg\/generator\/test8261511\/test8261511.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @test id=sources\n+ * @test\n@@ -33,1 +33,2 @@\n- * @run main\/othervm JtregJextractSources -l Test8281764 -t test.jextract.test8281764 test8281764.h\n+ * @run main\/othervm JtregJextract -l Test8281764 --use-system-load-library -t test.jextract.test8281764 test8281764.h\n+ * @build Test8281764\n@@ -39,1 +40,1 @@\n-        var apply = func.class.getMethod(\"apply\", int.class);\n+        var apply = func.Function.class.getMethod(\"apply\", int.class);\n@@ -41,1 +42,1 @@\n-        apply = fptr.class.getMethod(\"apply\", int.class, int.class);\n+        apply = fptr.Function.class.getMethod(\"apply\", int.class, int.class);\n","filename":"test\/jtreg\/generator\/test8281764\/Test8281764.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @test id=sources\n+ * @test\n@@ -33,1 +33,2 @@\n- * @run main\/othervm JtregJextractSources -l Test8282235 -t test.jextract.test8282235 test8282235.h\n+ * @run main\/othervm JtregJextract -l Test8282235 --use-system-load-library -t test.jextract.test8282235 test8282235.h\n+ * @build Test8282235\n@@ -39,1 +40,1 @@\n-        var apply = func.class.getMethod(\"apply\", int.class);\n+        var apply = func.Function.class.getMethod(\"apply\", int.class);\n@@ -41,1 +42,1 @@\n-        apply = fptr.class.getMethod(\"apply\", int.class, int.class);\n+        apply = fptr.Function.class.getMethod(\"apply\", int.class, int.class);\n@@ -46,1 +47,0 @@\n-\n","filename":"test\/jtreg\/generator\/test8282235\/Test8282235.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,9 +32,4 @@\n- * @test id=classes\n-  * @library \/lib\n- * @run main\/othervm JtregJextract -l FuncPtr -t test.jextract.fp funcPtr.h\n- * @run testng\/othervm LibFuncPtrTest\n- *\/\n- \/*\n- * @test id=sources\n-  * @library \/lib\n- * @run main\/othervm JtregJextractSources -l FuncPtr -t test.jextract.fp funcPtr.h\n+ * @test\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -l FuncPtr --use-system-load-library -t test.jextract.fp funcPtr.h\n+ * @build LibFuncPtrTest\n","filename":"test\/jtreg\/generator\/testFunctionPointer\/LibFuncPtrTest.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @test id=classes\n+ * @test\n@@ -36,6 +36,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestGlobalRedefinition\n- *\/\n-\/*\n- * @test id=sources\n- * @library \/lib\n- * @run main\/othervm JtregJextractSources -t test.jextract.redef redef.h\n+ * @build TestGlobalRedefinition\n@@ -47,1 +42,1 @@\n-        Method mGet = redef_h.class.getMethod(\"x$get\");\n+        Method mGet = redef_h.class.getMethod(\"x\");\n@@ -50,1 +45,1 @@\n-        Method mSet = redef_h.class.getMethod(\"x$set\", int.class);\n+        Method mSet = redef_h.class.getMethod(\"x\", int.class);\n","filename":"test\/jtreg\/generator\/testGlobalRedefinition\/TestGlobalRedefinition.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.testLinkageErrors.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static test.jextract.testLinkageErrors.testLinkageErrors_h.*;\n+\n+\/*\n+ * @test\n+ * @bug 8259473\n+ * @summary jextract generated code should throw exception for unfound native symbols from calls, variable access, set immediately\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.testLinkageErrors testLinkageErrors.h\n+ * @build TestLinkageErrors\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestLinkageErrors\n+ *\/\n+public class TestLinkageErrors {\n+\n+    static void assertThrowsULE(Runnable action, String symbol) {\n+        try {\n+            action.run();\n+            throw new AssertionError(\"should not reach here\");\n+        } catch (Throwable t) {\n+            while (t.getCause() != null) {\n+                t = t.getCause();\n+            }\n+            assertTrue(t.getMessage().contains(\"unresolved symbol: \" + symbol));\n+        }\n+    }\n+\n+    @Test\n+    public void nullChecksTest() {\n+        assertThrowsULE(() -> func(), \"func\");\n+        assertThrowsULE(() -> x(), \"x\");\n+        assertThrowsULE(() -> x(1), \"x\");\n+        assertThrowsULE(() -> x(), \"x\");\n+        assertThrowsULE(() -> y(), \"y\");\n+        assertThrowsULE(() -> pt(), \"pt\");\n+    }\n+}\n","filename":"test\/jtreg\/generator\/testLinkageErrors\/TestLinkageErrors.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -34,1 +34,1 @@\n-void func();\n+void func(void);\n","filename":"test\/jtreg\/generator\/testLinkageErrors\/testLinkageErrors.h","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jtreg\/generator\/test8259473\/test8259473.h","status":"renamed"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.foreign.Arena;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.printf.printf_h.*;\n+\n+\/*\n+ * @test\n+ *\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.printf -l Printf --use-system-load-library printf.h\n+ * @build TestPrintf\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestPrintf\n+ *\/\n+public class TestPrintf {\n+\n+    @Test\n+    public void testBaseDescriptor() {\n+        my_sprintf invoker = my_sprintf.makeInvoker();\n+        assertEquals(invoker.descriptor(), FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER, C_INT));\n+    }\n+\n+    @Test(dataProvider = \"cases\")\n+    public void testsPrintfHandle(String fmt, Object[] args, String expected, MemoryLayout[] layouts) throws Throwable {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment s = arena.allocate(1024);\n+            MethodHandle handle = my_sprintf.makeInvoker(layouts).handle();\n+            Object[] fullArgs = new Object[args.length + 3];\n+            fullArgs[0] = s;\n+            fullArgs[1] = arena.allocateFrom(fmt);\n+            fullArgs[2] = args.length;\n+            System.arraycopy(args, 0, fullArgs, 3, args.length);\n+            handle.invokeWithArguments(fullArgs);\n+            String str = s.getString(0);\n+            assertEquals(str, expected);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"cases\")\n+    public void testsPrintfInvoker(String fmt, Object[] args, String expected, MemoryLayout[] layouts) {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment s = arena.allocate(1024);\n+            my_sprintf.makeInvoker(layouts)\n+                    .apply(s, arena.allocateFrom(fmt), args.length, args);\n+            String str = s.getString(0);\n+            assertEquals(str, expected);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"wrongArgsCases\", expectedExceptions = { IllegalArgumentException.class, ClassCastException.class })\n+    public void testsPrintfInvokerWrongArgs(String fmt, MemoryLayout[] layouts, Object[] args) {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment s = arena.allocate(1024);\n+            my_sprintf.makeInvoker(layouts)\n+                    .apply(s, arena.allocateFrom(fmt), args.length, args); \/\/ should throw\n+        }\n+    }\n+\n+    \/\/ linker does not except unpromoted layouts\n+    @Test(dataProvider = \"illegalLinkCases\", expectedExceptions = IllegalArgumentException.class)\n+    public void testsPrintfInvokerWrongArgs(MemoryLayout[] layouts) {\n+        my_sprintf.makeInvoker(layouts); \/\/ should throw\n+    }\n+\n+    \/\/ data providers:\n+    @DataProvider\n+    public Object[][] cases() {\n+        return new Object[][]{\n+            {\n+                \"%hhd %c %.2f %.2f %lld %lld %d %hd %d %d %lld %c\",\n+                new Object[] {(byte) 1, 'b', -1.25f, 5.5d, -200L, Long.MAX_VALUE, (byte) -2, (short) 2, 3, (short) -4, 5L, 'a' },\n+                \"1 b -1.25 5.50 -200 \" + Long.MAX_VALUE + \" -2 2 3 -4 5 a\",\n+                new MemoryLayout[] { C_INT, C_INT, C_DOUBLE, C_DOUBLE, C_LONG_LONG, C_LONG_LONG, C_INT, C_INT,\n+                        C_INT, C_INT, C_LONG_LONG, C_INT }\n+            }\n+        };\n+    }\n+\n+    @DataProvider\n+    public Object[][] wrongArgsCases() {\n+        return new Object[][] {\n+            { \"%d\", new MemoryLayout[] {C_INT}, new Object[0], \/* too few args *\/ },\n+            { \"%d\", new MemoryLayout[] {C_INT}, new Object[] { 1, 2 }, \/* too many args *\/ },\n+            { \"%.2f\", new MemoryLayout[] {C_POINTER}, new Object[] { 1 }, \/* wrong type *\/ },\n+        };\n+    }\n+\n+    @DataProvider\n+    public static Object[][] illegalLinkCases() {\n+        return new Object[][]{\n+                {new MemoryLayout[]{ C_CHAR }},\n+                {new MemoryLayout[]{ C_SHORT }},\n+                {new MemoryLayout[]{ C_BOOL }},\n+                {new MemoryLayout[]{ C_FLOAT }}\n+        };\n+    }\n+}\n","filename":"test\/jtreg\/generator\/testPrintf\/TestPrintf.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"","filename":"test\/jtreg\/generator\/testPrintf\/libPrintf.c","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jtreg\/generator\/test8244959\/libPrintf.c","status":"renamed"},{"patch":"","filename":"test\/jtreg\/generator\/testPrintf\/printf.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jtreg\/generator\/test8244959\/printf.h","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.lang.foreign.MemorySegment;\n+\n@@ -35,8 +37,1 @@\n- * @test id=classes\n- * @library \/lib\n- * @run main\/othervm JtregJextract -l Struct -t test.jextract.struct struct.h\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibStructTest\n- *\/\n-\n-\/*\n- * @test id=sources\n+ * @test\n@@ -44,2 +39,2 @@\n- *\n- * @run main\/othervm JtregJextractSources -l Struct -t test.jextract.struct struct.h\n+ * @run main\/othervm JtregJextract -l Struct --use-system-load-library -t test.jextract.struct struct.h\n+ * @build LibStructTest\n@@ -48,1 +43,0 @@\n-\n@@ -54,2 +48,2 @@\n-            assertEquals(Point.x$get(seg), 42);\n-            assertEquals(Point.y$get(seg), -39);\n+            assertEquals(Point.x(seg), 42);\n+            assertEquals(Point.y(seg), -39);\n@@ -63,4 +57,4 @@\n-            Point.x$set(seg, 56);\n-            Point.y$set(seg, 65);\n-            assertEquals(Point.x$get(seg), 56);\n-            assertEquals(Point.y$get(seg), 65);\n+            Point.x(seg, 56);\n+            Point.y(seg, 65);\n+            assertEquals(Point.x(seg), 56);\n+            assertEquals(Point.y(seg), 65);\n@@ -75,2 +69,3 @@\n-                Point.x$set(seg, i, 56 + i);\n-                Point.y$set(seg, i, 65 + i);\n+                MemorySegment point = Point.asSlice(seg, i);\n+                Point.x(point, 56 + i);\n+                Point.y(point, 65 + i);\n@@ -79,2 +74,3 @@\n-                assertEquals(Point.x$get(seg, i), 56 + i);\n-                assertEquals(Point.y$get(seg, i), 65 + i);\n+                MemorySegment point = Point.asSlice(seg, i);\n+                assertEquals(Point.x(point), 56 + i);\n+                assertEquals(Point.y(point), 65 + i);\n@@ -91,1 +87,1 @@\n-        GroupLayout g = (GroupLayout)AllTypes.$LAYOUT();\n+        GroupLayout g = (GroupLayout)AllTypes.layout();\n","filename":"test\/jtreg\/generator\/testStruct\/LibStructTest.java","additions":19,"deletions":23,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,0 @@\n-import java.io.IOException;\n@@ -26,0 +25,1 @@\n+import java.io.IOException;\n@@ -28,1 +28,1 @@\n-import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n@@ -32,1 +32,1 @@\n-import java.util.Arrays;\n+import java.util.List;\n@@ -36,0 +36,2 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -37,3 +39,1 @@\n-import org.openjdk.jextract.JextractTool;\n-\n-import java.util.Date;\n+import testlib.TestUtils;\n@@ -41,0 +41,1 @@\n+import org.openjdk.jextract.JextractTool;\n@@ -45,0 +46,2 @@\n+    private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst(\"javac\")\n+            .orElseThrow(() ->  new RuntimeException(\"javac tool not found\"));\n@@ -49,4 +52,0 @@\n-    JtregJextract() {\n-        this(null, null);\n-    }\n-\n@@ -54,5 +53,2 @@\n-        inputDir = (input != null) ? input :\n-                Paths.get(System.getProperty(\"test.src\", \".\"));\n-        outputDir = (output != null) ? output :\n-                Paths.get(System.getProperty(\"test.classes\", \".\"));\n-\n+        inputDir = input;\n+        outputDir = output;\n@@ -61,1 +57,1 @@\n-    protected String[] processArgs(String... args) {\n+    private String[] processArgs(String... args) {\n@@ -65,1 +61,0 @@\n-        jextrOpts.clear();\n@@ -79,10 +74,0 @@\n-            if (\"-libpath\".equals(opt)) {\n-                String lib = args[i];\n-                jextrOpts.add(\"-l\");\n-                String libpath = System.getProperty(\"java.library.path\") + File.separator + System.mapLibraryName(lib);\n-                System.err.println(\"jextract driver libpath passed: \" + libpath);\n-                jextrOpts.add(libpath);\n-                i++;\n-                continue;\n-            }\n-\n@@ -110,1 +95,1 @@\n-    protected int jextract(String... options) {\n+    private void jextract(String... options) {\n@@ -116,1 +101,1 @@\n-                System.err.println(writer.toString());\n+                System.err.println(writer);\n@@ -119,1 +104,0 @@\n-            return result;\n@@ -129,3 +113,17 @@\n-    public static int main(String[] args) {\n-        JtregJextract jj =  new JtregJextract();\n-        return jj.jextract(args);\n+    private static Path getJextractSourcePath() {\n+        Path testSrc = Path.of(System.getProperty(\"test.file\"));\n+        return Path.of(testSrc.toFile().getName() + \"_sources\");\n+    }\n+\n+    public static int main(String[] args) throws IOException {\n+        System.err.println(\"jextract\");\n+        Path sourcePath = getJextractSourcePath();\n+        JtregJextract jj =  new JtregJextract(\n+            Paths.get(System.getProperty(\"test.src\", \".\")),\n+            sourcePath);\n+        jj.jextract(args);\n+\n+        Path outputDir = Paths.get(System.getProperty(\"test.classes\", \".\"));\n+\n+        TestUtils.compile(sourcePath, outputDir);\n+        return 0;\n","filename":"test\/lib\/JtregJextract.java","additions":32,"deletions":34,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.io.UncheckedIOException;\n-import java.lang.reflect.Array;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.spi.ToolProvider;\n-import java.util.stream.Collectors;\n-\n-import org.openjdk.jextract.JextractTool;\n-\n-public class JtregJextractSources {\n-\n-    private static final ToolProvider JEXTRACT_TOOL = new JextractTool.JextractToolProvider();\n-    private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst(\"javac\")\n-            .orElseThrow(() ->\n-                    new RuntimeException(\"javac tool not found\")\n-            );\n-\n-    private static Path getJextractSourcePath() {\n-        Path testSrc = Path.of(System.getProperty(\"test.file\"));\n-        return Path.of(testSrc.toFile().getName() + \"_sources\");\n-    }\n-\n-    public static int main(String[] args) throws IOException {\n-        System.err.println(\"jextract --source mode\");\n-        Path sourcePath = getJextractSourcePath();\n-        JtregJextract jj =  new JtregJextract(null, sourcePath);\n-        String[] newArgs = new String[args.length + 1];\n-        newArgs[0] = \"--source\";\n-        System.arraycopy(args, 0, newArgs, 1, args.length);\n-        jj.jextract(newArgs);\n-\n-        Path outputDir = Paths.get(System.getProperty(\"test.classes\", \".\"));\n-\n-        List<String> files = Files.find(sourcePath.toAbsolutePath(), 999, (path, ignored) -> path.toString().endsWith(\".java\"))\n-                .map(p -> p.toAbsolutePath().toString())\n-                .collect(Collectors.toList());\n-\n-        StringWriter writer = new StringWriter();\n-        PrintWriter pw = new PrintWriter(writer);\n-\n-        try {\n-            System.err.println(\"compiling jextracted sources @ \" + sourcePath.toAbsolutePath());\n-            List<String> commands = new ArrayList<>();\n-            commands.add(\"-parameters\");\n-            commands.add(\"-d\");\n-            commands.add(outputDir.toAbsolutePath().toString());\n-            commands.addAll(files);\n-            int result = JAVAC_TOOL.run(pw, pw, commands.toArray(new String[0]));\n-            if (result != 0) {\n-                System.err.println(writer.toString());\n-                throw new RuntimeException(\"javac returns non-zero value\");\n-            }\n-            return result;\n-        } catch (Throwable t) {\n-            throw new AssertionError(t);\n-        }\n-    }\n-}\n","filename":"test\/lib\/JtregJextractSources.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+\n@@ -45,1 +46,0 @@\n-import org.openjdk.jextract.Type;\n@@ -55,1 +55,1 @@\n-    private static final boolean IS_WINDOWS = System.getProperty(\"os.name\").startsWith(\"Windows\");\n+    public static final boolean IS_WINDOWS = System.getProperty(\"os.name\").startsWith(\"Windows\");\n@@ -142,2 +142,8 @@\n-    protected static JextractResult run(Object... options) {\n-        return run(Arrays.stream(options).map(Objects::toString).toArray(String[]::new));\n+    protected static JextractResult runAndCompile(Path outputDir, Object... options) {\n+        return runAndCompile(outputDir, Arrays.stream(options).map(Objects::toString).toArray(String[]::new));\n+    }\n+\n+    protected static JextractResult runAndCompile(Path outputDir, String... options) {\n+        JextractResult jextractResult = run(outputDir, options).checkSuccess();\n+        TestUtils.compile(outputDir, outputDir);\n+        return jextractResult;\n@@ -146,1 +152,9 @@\n-    protected static JextractResult run(String... options) {\n+    protected static JextractResult run(Path outputDir, String... options) {\n+        String[] extendedOptions = new String[options.length + 2];\n+        extendedOptions[0] = \"--output\";\n+        extendedOptions[1] = outputDir.toString();\n+        System.arraycopy(options, 0, extendedOptions, 2, options.length);\n+        return runNoOuput(extendedOptions);\n+    }\n+\n+    protected static JextractResult runNoOuput(String... options) {\n@@ -149,1 +163,0 @@\n-        String[] args = new String[options.length + 1];\n@@ -174,1 +187,3 @@\n-            return cls.getField(name);\n+            Field field = cls.getDeclaredField(name);\n+            field.setAccessible(true);\n+            return field;\n@@ -237,1 +252,1 @@\n-        assertEquals(m.getReturnType(), returnType);\n+        assertTrue(returnType.isAssignableFrom(m.getReturnType())); \/\/ tolerate more specific type\n@@ -245,1 +260,1 @@\n-        assertEquals(method.getReturnType(), MemoryLayout.class);\n+        assertTrue(MemoryLayout.class.isAssignableFrom(method.getReturnType()));\n@@ -256,1 +271,10 @@\n-        return findLayout(cls, \"\");\n+        Method method = findMethod(cls, \"layout\");\n+        assertNotNull(method);\n+        assertTrue(MemoryLayout.class.isAssignableFrom(method.getReturnType()));\n+        try {\n+            return (MemoryLayout)method.invoke(null);\n+        } catch (Exception exp) {\n+            System.err.println(exp);\n+            assertTrue(false, \"should not reach here\");\n+        }\n+        return null;\n","filename":"test\/lib\/testlib\/JextractToolRunner.java","additions":35,"deletions":11,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n@@ -32,0 +34,2 @@\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Stream;\n@@ -35,0 +39,3 @@\n+    private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst(\"javac\")\n+        .orElseThrow(() ->  new RuntimeException(\"javac tool not found\"));\n+\n@@ -48,0 +55,28 @@\n+        }\n+    }\n+\n+    public static void compile(Path sourcePath, Path outputDir) {\n+        List<String> files;\n+        try (Stream<Path> filesStream = Files.find(sourcePath.toAbsolutePath(), 999, (path, ignored) -> path.toString().endsWith(\".java\"))) {\n+            files = filesStream.map(p -> p.toAbsolutePath().toString()).toList();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        StringWriter writer = new StringWriter();\n+        PrintWriter pw = new PrintWriter(writer);\n+\n+        try {\n+            System.err.println(\"compiling jextracted sources @ \" + sourcePath.toAbsolutePath());\n+            List<String> commands = new ArrayList<>();\n+            commands.add(\"-parameters\");\n+            commands.add(\"-d\");\n+            commands.add(outputDir.toAbsolutePath().toString());\n+            commands.addAll(files);\n+            int result = JAVAC_TOOL.run(pw, pw, commands.toArray(new String[0]));\n+            if (result != 0) {\n+                System.err.println(writer);\n+                throw new RuntimeException(\"javac returns non-zero value\");\n+            }\n+        } catch (Throwable t) {\n+            throw new AssertionError(t);\n","filename":"test\/lib\/testlib\/TestUtils.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-        assertTrue(structBar.layout().isEmpty());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/api\/Test8238712.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.api;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Type;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import testlib.JextractApiTestBase;\n+\n+import static org.testng.Assert.*;\n+import static org.openjdk.jextract.Type.Primitive.Kind.*;\n+import static org.openjdk.jextract.Type.Delegated.Kind.*;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.EnumSet;\n+\n+public class TestAtomic extends JextractApiTestBase {\n+    Declaration.Scoped atomic;\n+\n+    @BeforeClass\n+    public void parse() {\n+        \/\/ We need stdatomic.h\n+        Path builtinInc = Paths.get(System.getProperty(\"java.home\"), \"conf\", \"jextract\");\n+        atomic = parse(\"atomic.h\", \"-I\", builtinInc.toString());\n+    }\n+\n+    @Test(dataProvider = \"atomicTypes\")\n+    public void testAtomic(String varName, Type expected) {\n+        Declaration.Variable var = findDecl(atomic, varName, Declaration.Variable.class);\n+        var kinds = EnumSet.of(ATOMIC);\n+        if (varName.startsWith(\"U_\")) {\n+            kinds.add(UNSIGNED);\n+        }\n+        if (varName.startsWith(\"S_\")) {\n+            kinds.add(SIGNED);\n+        }\n+        checkType(var.type(), kinds, expected);\n+    }\n+\n+    @DataProvider\n+    static Object[][] atomicTypes() {\n+        return new Object[][]{\n+                new Object[] { \"BOOL\", Type.primitive(Bool) },\n+                new Object[] { \"CHAR\", Type.primitive(Char) },\n+                new Object[] { \"S_CHAR\", Type.primitive(Char) },\n+                new Object[] { \"U_CHAR\", Type.primitive(Char) },\n+                new Object[] { \"SHORT\", Type.primitive(Short) },\n+                new Object[] { \"U_SHORT\", Type.primitive(Short) },\n+                new Object[] { \"INT\", Type.primitive(Int) },\n+                new Object[] { \"U_INT\", Type.primitive(Int) },\n+                new Object[] { \"LONG\", Type.primitive(Long) },\n+                new Object[] { \"U_LONG\", Type.primitive(Long) },\n+                new Object[] { \"LONGLONG\", Type.primitive(LongLong) },\n+                new Object[] { \"U_LONGLONG\", Type.primitive(LongLong) },\n+        };\n+    }\n+\n+    static void checkType(Type t, EnumSet<Type.Delegated.Kind> kinds, Type expected) {\n+        while (t instanceof Type.Delegated delegated) {\n+            kinds.remove(delegated.kind());\n+            t = delegated.type();\n+        }\n+        assertTrue(kinds.isEmpty(), \"Missing kinds: \" + kinds);\n+        assertEquals(t, expected);\n+    }\n+}\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/api\/TestAtomic.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,4 +25,0 @@\n-import java.lang.constant.Constable;\n-import java.time.LocalDateTime;\n-import java.time.format.DateTimeFormatter;\n-import java.util.List;\n@@ -30,1 +26,0 @@\n-import java.util.stream.Stream;\n@@ -33,0 +28,1 @@\n+import org.openjdk.jextract.Declaration.ClangAttributes;\n@@ -38,0 +34,1 @@\n+import static org.testng.Assert.assertTrue;\n@@ -44,1 +41,2 @@\n-        var attrs = d.getAttribute(ASMLABEL).get();\n+        var attrs = d.getAttribute(ClangAttributes.class).get();\n+        assertTrue(attrs.attributes().containsKey(ASMLABEL));\n@@ -48,1 +46,1 @@\n-        assertEquals(attrs.get(0), value);\n+        assertEquals(attrs.attributes().get(ASMLABEL).get(0), value);\n@@ -67,1 +65,1 @@\n-            if (foo.getAttribute(ASMLABEL).isPresent()) {\n+            if (foo.getAttribute(ClangAttributes.class).isPresent()) {\n@@ -81,1 +79,1 @@\n-            if (func.getAttribute(ASMLABEL).isPresent()) {\n+            if (func.getAttribute(ClangAttributes.class).isPresent()) {\n@@ -100,58 +98,0 @@\n-\n-    private static  Constable getSingleValue(Declaration d, String name) {\n-        List<Constable> values = d.getAttribute(name).get();\n-        assertEquals(1, values.size());\n-        return values.get(0);\n-    }\n-\n-    @Test\n-    public void testAddAttribute() {\n-        final String ts = \"timestamp\";\n-        Declaration.Scoped d = parse(\"libAsmSymbol.h\");\n-        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME);\n-        Declaration withAttrs = d.withAttribute(\"header\", d.name())\n-                .withAttribute(ts, timestamp);\n-\n-        assertEquals(getSingleValue(withAttrs, \"header\"), d.name());\n-        assertEquals(getSingleValue(withAttrs, ts), timestamp);\n-\n-        String timestamp2 = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n-        Declaration withNewAttrs = withAttrs.withAttribute(ts, timestamp2);\n-        assertEquals(getSingleValue(withNewAttrs, ts), timestamp2);\n-\n-        \/\/ Make sure original Declaration is not altered\n-        assertEquals(getSingleValue(withAttrs, ts), timestamp);\n-\n-        \/\/ Add more value to same attribute\n-        withNewAttrs = withAttrs.withAttribute(ts, Stream.concat(\n-                withAttrs.getAttribute(ts).map(List::stream).orElse(Stream.empty()),\n-                Stream.of(timestamp2)\n-            ).toArray(Constable[]::new));\n-        assertEquals(withNewAttrs.getAttribute(ts).get(), List.of(timestamp, timestamp2));\n-        assertEquals(getSingleValue(withNewAttrs,\"header\"), d.name());\n-\n-        \/\/ Remove attribute\n-        withAttrs = withNewAttrs.withAttribute(ts);\n-        assertTrue(withAttrs.getAttribute(ts).isEmpty());\n-\n-        \/\/ Strip attribute\n-        withNewAttrs = withNewAttrs.stripAttributes();\n-        assertTrue(withNewAttrs.attributeNames().isEmpty());\n-    }\n-\n-    private void assertTrue(boolean empty) {\n-    }\n-\n-    @Test\n-    public void replaceFunctionSymbol() {\n-        Declaration.Scoped d = parse(\"libAsmSymbol.h\", \"-DADD\");\n-        validateHeader(d, true);\n-\n-        var members = d.members().stream()\n-            .map(m -> m.getAttribute(ASMLABEL)\n-                    .map(attr -> m.withAttribute(ASMLABEL, attr.get(0).toString().replace('A', 'B')))\n-                    .orElse(m))\n-            .toArray(Declaration[]::new);\n-        Declaration.Scoped patched = Declaration.toplevel(d.pos(), members);\n-        validateHeader(patched, false);\n-    }\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/api\/TestAttributes.java","additions":8,"deletions":68,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        checkConstant(badMacro, \"NO_FOO\", Type.pointer(Type.declared(foo)), 0L);\n+        checkConstant(badMacro, \"NO_FOO\", Type.pointer(), 0L);\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/api\/TestMacros.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.jextract.test.api;\n-\n-import org.openjdk.jextract.Declaration;\n-import org.testng.annotations.Test;\n-import testlib.JextractApiTestBase;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-import java.lang.foreign.GroupLayout;\n-\n-public class TestPackedStructs extends JextractApiTestBase {\n-\n-    static final String[] NAMES = {\n-            \"S1\", \"S2\", \"S3\", \"S4\", \"S5\", \"S6\", \"S7\", \"S8\"\n-    };\n-\n-    @Test\n-    public void testPackedStructs() {\n-        Declaration.Scoped d = parse(\"packedstructs.h\");\n-        System.out.println(d);\n-        for (String name : NAMES) {\n-            Declaration.Scoped scoped = checkStruct(d, name, \"first\", \"second\");\n-            GroupLayout groupLayout = (GroupLayout)scoped.layout().get();\n-            assertEquals(groupLayout.memberLayouts().get(1).byteAlignment(), 1);\n-        }\n-    }\n-}\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/api\/TestPackedStructs.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdatomic.h>\n+\n+atomic_bool BOOL;\n+atomic_char CHAR;\n+atomic_schar S_CHAR;\n+atomic_uchar U_CHAR;\n+atomic_short SHORT;\n+atomic_ushort U_SHORT;\n+atomic_int INT;\n+atomic_uint U_INT;\n+atomic_long LONG;\n+atomic_ulong U_LONG;\n+atomic_llong LONGLONG;\n+atomic_ullong U_LONGLONG;\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/api\/atomic.h","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,2 +57,2 @@\n-        run(\"--output\", getOutputFilePath(\"badBitfieldsGen\").toString(),\n-                getInputFilePath(\"badBitfields.h\").toString()).checkSuccess();\n+        runAndCompile(getOutputFilePath(\"badBitfieldsGen\"),\n+                getInputFilePath(\"badBitfields.h\").toString());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/BadBitfieldTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,4 +33,1 @@\n-import java.util.function.Predicate;\n-import java.util.stream.Stream;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemorySegment;\n+\n@@ -52,1 +49,1 @@\n-        run( \"--output\", dirPath.toString(), getInputFilePath(\"constants.h\").toString()).checkSuccess();\n+        runAndCompile(dirPath, getInputFilePath(\"constants.h\").toString());\n@@ -96,0 +93,2 @@\n+                { \"SEVEN\", int.class, equalsTo(7) },\n+                { \"EIGHT\", int.class, equalsTo(8) },\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/ConstantsTest.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-        run(\n+        runAndCompile(output,\n@@ -42,2 +42,1 @@\n-            \"--output\", output,\n-            input).checkSuccess();\n+            input);\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/IncompleteArrayTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -41,4 +42,4 @@\n-        run().checkFailure(OPTION_ERROR); \/\/ no options\n-        run(\"--help\").checkSuccess();\n-        run(\"-h\").checkSuccess();\n-        run(\"-?\").checkSuccess();\n+        runNoOuput().checkFailure(OPTION_ERROR); \/\/ no options\n+        runNoOuput(\"--help\").checkSuccess();\n+        runNoOuput(\"-h\").checkSuccess();\n+        runNoOuput(\"-?\").checkSuccess();\n@@ -49,1 +50,1 @@\n-        run(\"--version\").checkSuccess();\n+        runNoOuput(\"--version\").checkSuccess();\n@@ -55,1 +56,1 @@\n-        run(\"@non_existent_args\")\n+        runNoOuput(\"@non_existent_args\")\n@@ -63,1 +64,1 @@\n-        run(getInputFilePath(\"non_existent.h\").toString())\n+        runNoOuput(getInputFilePath(\"non_existent.h\").toString())\n@@ -71,1 +72,1 @@\n-        run(getInputFilePath(\"non_existent_includer.h\").toString())\n+        runNoOuput(getInputFilePath(\"non_existent_includer.h\").toString())\n@@ -78,1 +79,1 @@\n-        run(getInputFilePath(\"directory.h\").toString())\n+        runNoOuput(getInputFilePath(\"directory.h\").toString())\n@@ -86,1 +87,1 @@\n-        run(getInputFilePath(\"illegal_decls.h\").toString())\n+        runNoOuput(getInputFilePath(\"illegal_decls.h\").toString())\n@@ -98,1 +99,1 @@\n-            run(getInputFilePath(\"unsupported_lang.h\").toString())\n+            runNoOuput(getInputFilePath(\"unsupported_lang.h\").toString())\n@@ -110,1 +111,1 @@\n-        run(\"--output\", helloOutput.toString(), helloH.toString()).checkSuccess();\n+        runAndCompile(helloOutput, helloH.toString());\n@@ -113,4 +114,1 @@\n-            \/\/ check a method for \"void func(int)\"\n-            assertNotNull(findMethod(cls, \"func\", int.class));\n-            \/\/ check a method for \"int printf(MemorySegment, Object[])\"\n-            assertNotNull(findMethod(cls, \"printf\", MemorySegment.class, Object[].class));\n+            checkHeaderMembers(cls);\n@@ -122,0 +120,14 @@\n+    private static void checkHeaderMembers(Class<?> header) {\n+        \/\/ check a method for \"void func(int)\"\n+        assertNotNull(findMethod(header, \"func\", int.class));\n+        \/\/ check an interface for printf$invoker\n+        Class<?> invokerCls = findNestedClass(header, \"printf\");\n+        assertNotNull(invokerCls);\n+        \/\/ check a method for \"MethodHandle handle()\"\n+        assertNotNull(findMethod(invokerCls, \"handle\"));\n+        \/\/ check a method for \"FunctionDescriptor descriptor()\"\n+        assertNotNull(findMethod(invokerCls, \"descriptor\"));\n+        \/\/ check a method for \"<invokerCls> invoker(MemoryLayout...)\"\n+        assertNotNull(findMethod(invokerCls, \"makeInvoker\", MemoryLayout[].class));\n+    }\n+\n@@ -125,1 +137,1 @@\n-        run(\"--output\", helloOutput.toString(),\n+        runAndCompile(helloOutput,\n@@ -127,1 +139,1 @@\n-            getInputFilePath(\"hello.h\").toString()).checkSuccess();\n+            getInputFilePath(\"hello.h\").toString());\n@@ -139,2 +151,1 @@\n-        run(targetPkgOption, \"com.acme\", \"--output\",\n-            helloOutput.toString(), helloH.toString()).checkSuccess();\n+        runAndCompile(helloOutput, targetPkgOption, \"com.acme\", helloH.toString());\n@@ -143,4 +154,1 @@\n-            \/\/ check a method for \"void func(int)\"\n-            assertNotNull(findMethod(cls, \"func\", int.class));\n-            \/\/ check a method for \"int printf(MemorySegment, Object[])\"\n-            assertNotNull(findMethod(cls, \"printf\", MemorySegment.class, Object[].class));\n+            checkHeaderMembers(cls);\n@@ -166,2 +174,1 @@\n-        run(\"--header-class-name\", \"MyHello\", \"-t\", \"com.acme\", \"--output\",\n-            helloOutput.toString(), helloH.toString()).checkSuccess();\n+        runAndCompile(helloOutput, \"--header-class-name\", \"MyHello\", \"-t\", \"com.acme\", helloH.toString());\n@@ -170,4 +177,1 @@\n-            \/\/ check a method for \"void func(int)\"\n-            assertNotNull(findMethod(cls, \"func\", int.class));\n-            \/\/ check a method for \"int printf(MemorySegment, Object[])\"\n-            assertNotNull(findMethod(cls, \"printf\", MemorySegment.class, Object[].class));\n+            checkHeaderMembers(cls);\n@@ -183,2 +187,2 @@\n-        run(\"-I\", includerH.getParent().resolve(\"inc\").toString(),\n-            \"--output\", includerOutput.toString(), includerH.toString()).checkSuccess();\n+        runAndCompile(includerOutput, \"-I\", includerH.getParent().resolve(\"inc\").toString(),\n+            includerH.toString());\n@@ -198,2 +202,2 @@\n-        run(\"--include-dir\", includerH.getParent().resolve(\"inc\").toString(),\n-            \"--output\", includerOutput.toString(), includerH.toString()).checkSuccess();\n+        runAndCompile(includerOutput, \"--include-dir\", includerH.getParent().resolve(\"inc\").toString(),\n+            includerH.toString());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/JextractToolProviderTest.java","additions":39,"deletions":35,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.lang.foreign.GroupLayout;\n@@ -33,1 +32,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -45,1 +43,1 @@\n-        run(\"--output\", repeatedDeclsOutput.toString(), repeatedDeclsH.toString()).checkSuccess();\n+        runAndCompile(repeatedDeclsOutput, repeatedDeclsH.toString());\n@@ -67,1 +65,1 @@\n-            assertNotNull(findMethod(cls, \"i$get\"));\n+            assertNotNull(findMethod(cls, \"i\"));\n@@ -70,1 +68,1 @@\n-            assertNotNull(findMethod(cls, \"i$set\", int.class));\n+            assertNotNull(findMethod(cls, \"i\", int.class));\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/RepeatedDeclsTest.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-        run(\"--output\", output.toString(), outputH.toString()).checkSuccess();\n+        runAndCompile(output, outputH.toString());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903148.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-        run(\"--output\", output.toString(), outputH.toString()).checkSuccess();\n+        runAndCompile(output, outputH.toString());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903158.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-        run(\"--output\", output.toString(), outputH.toString()).checkSuccess();\n+        runAndCompile(output, outputH.toString());\n@@ -52,1 +52,1 @@\n-        run(\"-D\", \"FOO\", \"--output\", output.toString(), outputH.toString()).checkSuccess();\n+        runAndCompile(output, \"-D\", \"FOO\", outputH.toString());\n@@ -66,1 +66,1 @@\n-        run(\"--define-macro\", \"FOO\", \"--output\", output.toString(), outputH.toString()).checkSuccess();\n+        runAndCompile(output, \"--define-macro\", \"FOO\", outputH.toString());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903164.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-        run(\"--output\", test7903237Output.toString(), test7903237H.toString()).checkSuccess();\n+        runAndCompile(test7903237Output, test7903237H.toString());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903237.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,211 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.jextract.test.toolprovider.Test7903257;\n-\n-import testlib.JextractToolRunner;\n-import testlib.TestUtils;\n-import org.testng.annotations.Test;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.regex.Pattern;\n-import static org.testng.Assert.assertEquals;\n-\n-public class TestDocComments extends JextractToolRunner {\n-    \/\/ Regular expression for javadoc comment text\n-    \/\/\n-    \/\/   (?s)     dot matches all including newlines\n-    \/\/   \/\\*\\*    doc comment start\n-    \/\/   (.*?)    comment text as a group (reluctant match)\n-    \/\/   \\*\/      doc comment end\n-    private static final Pattern JAVADOC_COMMENT = Pattern.compile(\"(?s)\/\\\\*\\\\*(.*?)\\\\*\/\");\n-\n-    @Test\n-    public void testMacros() throws IOException {\n-        var comments = getDocComments(\"macros.h\", \"macros_h.java\");\n-        assertEquals(comments, List.of(\n-            \"#define FOO 42\", \"#define MSG \\\"Hello\\\"\"));\n-    }\n-\n-    @Test\n-    public void testEnumConstants() throws IOException {\n-        var comments = getDocComments(\"enums.h\", \"enums_h.java\");\n-        assertEquals(comments, List.of(\n-            \"enum Color.RED = 0;\",\n-            \"enum Color.GREEN = 1;\",\n-            \"enum Color.BLUE = 2;\",\n-            \"enum Suit.club = 1;\",\n-            \"enum Suit.diamonds = 2;\",\n-            \"enum Suit.hearts = 3;\",\n-            \"enum Suit.spades = 4;\"));\n-    }\n-\n-    @Test\n-    public void testTypedefs() throws IOException {\n-        var comments = getDocComments(\"typedefs.h\", \"typedefs_h.java\");\n-        assertEquals(comments, List.of(\n-            \"typedef unsigned long long size_t;\",\n-            \"typedef int INT_32;\",\n-            \"typedef int* INT_PTR;\",\n-            \"typedef struct Foo* OPAQUE_PTR;\"));\n-    }\n-\n-    @Test\n-    public void testArrays() throws IOException {\n-        var comments = getDocComments(\"arrays.h\", \"arrays_h.java\");\n-        assertEquals(comments, List.of(\n-            \"int abc[10];\",\n-            \"float numbers[3];\",\n-            \"char* msg[5];\",\n-            \"int pixels[200][100];\",\n-            \"int points[10][20][30];\"));\n-    }\n-\n-    @Test\n-    public void testFunctions() throws IOException {\n-        var comments = getDocComments(\"functions.h\", \"functions_h.java\");\n-        assertEquals(comments, List.of(\n-            \"int func(int* fp);\",\n-            \"double distance(struct Point p);\",\n-            \"int printf(char* fmt,...);\"));\n-    }\n-\n-    @Test\n-    public void testFunctionPointer() throws IOException {\n-        var comments = getDocComments(\"funcptrs.h\", \"funcptr.java\");\n-        assertEquals(comments, List.of(\n-            \"void (*funcptr)(int*,int);\"\n-        ));\n-    }\n-\n-    @Test\n-    public void testFunctionPointer2() throws IOException {\n-        var comments = getDocComments(\"funcptrs.h\", \"signal$func.java\");\n-        assertEquals(comments, List.of(\n-            \"void (*signal$func)(int);\"\n-        ));\n-    }\n-\n-    @Test\n-    public void testFunctionPointer3() throws IOException {\n-        var comments = getDocComments(\"funcptrs.h\", \"signal$return.java\");\n-        assertEquals(comments, List.of(\n-            \"void (*signal$return)(int);\"\n-        ));\n-    }\n-\n-    @Test\n-    public void testFunctionPointer4() throws IOException {\n-        var comments = getDocComments(\"funcptrs.h\", \"funcptrs_h.java\");\n-        assertEquals(comments, List.of(\n-            \"Getter for variable: void (*funcptr)(int*,int);\",\n-            \"Setter for variable: void (*funcptr)(int*,int);\",\n-            \"void (*signal(int sig, void (*func)(int)))(int);\"\n-        ));\n-    }\n-\n-    @Test\n-    public void testVariables() throws IOException {\n-        var comments = getDocComments(\"variables.h\", \"variables_h.java\");\n-        assertEquals(comments, List.of(\n-            \"Getter for variable: int abc;\",\n-            \"Setter for variable: int abc;\",\n-            \"Getter for variable: char* msg;\",\n-            \"Setter for variable: char* msg;\"\n-        ));\n-    }\n-\n-    @Test\n-    public void testStruct() throws IOException {\n-        var comments = getDocComments(\"structs.h\", \"Point.java\");\n-        assertEquals(comments, List.of(\n-            \"struct Point { int x; int y; };\",\n-            \"Getter for field: int x;\",\n-            \"Setter for field: int x;\",\n-            \"Getter for field: int y;\",\n-            \"Setter for field: int y;\"));\n-    }\n-\n-    @Test\n-    public void testStruct2() throws IOException {\n-        var comments = getDocComments(\"structs.h\", \"Point3D.java\");\n-        assertEquals(comments, List.of(\n-            \"struct Point3D { int x; int y; int z; };\",\n-            \"Getter for field: int x;\",\n-            \"Setter for field: int x;\",\n-            \"Getter for field: int y;\",\n-            \"Setter for field: int y;\",\n-            \"Getter for field: int z;\",\n-            \"Setter for field: int z;\"));\n-    }\n-\n-    @Test\n-    public void testStructTypdef() throws IOException {\n-        var comments = getDocComments(\"structs.h\", \"Point_t.java\");\n-        assertEquals(comments, List.of(\n-            \"typedef struct Point Point_t;\"));\n-    }\n-\n-    private List<String> getDocComments(String header, String outputFile)\n-            throws IOException {\n-        var output = getOutputFilePath(\"7903257-parse-\" + header);\n-        var outputH = getInputFilePath(header);\n-        run(\"--source\", \"--output\",\n-            output.toString(), outputH.toString()).checkSuccess();\n-        try {\n-            return findDocComments(Files.readString(output.resolve(outputFile)));\n-        } finally {\n-            TestUtils.deleteDir(output);\n-        }\n-    }\n-\n-    \/\/ get doc comments from the given the source content\n-    private static List<String> findDocComments(String content) {\n-        var matcher = JAVADOC_COMMENT.matcher(content);\n-        var strings = new ArrayList<String>();\n-        while (matcher.find()) {\n-            \/\/ doc comment text is matched in group 1\n-            String rawComment = matcher.group(1);\n-\n-            \/\/ sanitize raw comment for test asserts\n-            strings.add(rawComment\n-                \/\/ remove \\n followed by whitespaces and then *\n-                .replaceAll(\"\\n\\\\s+\\\\*\", \"\")\n-\n-                \/\/ get rid of \"{@snippet :\" prefix\n-                .replaceAll(\"\\\\{@snippet :\", \"\")\n-\n-                \/\/ replace one or more whitespaces as single whitespace\n-                .replaceAll(\"\\\\s+\", \" \")\n-\n-                \/\/ get rid of last \"}\" suffix closing the snippet\n-                .replaceAll(\"\\\\s+}\\\\s+$\", \"\")\n-\n-                .trim());\n-        }\n-        return strings;\n-    }\n-}\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903257\/TestDocComments.java","additions":0,"deletions":211,"binary":false,"changes":211,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-        run(\"--output\", test7903285Output.toString(), test7903285H.toString()).checkSuccess();\n+        runAndCompile(test7903285Output, test7903285H.toString());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903285.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-        run(\"--output\", test7903339Output.toString(), test7903339H.toString()).checkSuccess();\n+        runAndCompile(test7903339Output, test7903339H.toString());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903339.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-        run(\"--output\", anonenumOutput.toString(), anonenumH.toString()).checkSuccess();\n+        runAndCompile(anonenumOutput, anonenumH.toString());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8240181.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-        run(\"--output\", exportsOutput.toString(), exportsH.toString()).checkSuccess();\n+        runAndCompile(exportsOutput, exportsH.toString());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8240657.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import java.lang.reflect.Field;\n@@ -69,1 +68,1 @@\n-        run(\"--output\", floatConstsOutput.toString(), floatConstsH.toString()).checkSuccess();\n+        runAndCompile(floatConstsOutput, floatConstsH.toString());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8240752.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.lang.foreign.GroupLayout;\n@@ -44,1 +43,1 @@\n-        run(\"--output\", nameCollisionOutput.toString(), nameCollisionH.toString()).checkSuccess();\n+        runAndCompile(nameCollisionOutput, nameCollisionH.toString());\n@@ -58,3 +57,0 @@\n-            MemoryLayout fooVarLayout = findLayout(cls, \"foo\");\n-            assertNotNull(fooVarLayout);\n-\n@@ -69,6 +65,0 @@\n-            MemoryLayout foo2VarLayout = findLayout(cls, \"foo2\");\n-            assertNotNull(foo2VarLayout);\n-\n-            MemoryLayout barVarLayout = findLayout(cls, \"bar\");\n-            assertNotNull(barVarLayout);\n-\n@@ -83,3 +73,0 @@\n-            MemoryLayout bar2VarLayout = findLayout(cls, \"bar2\");\n-            assertNotNull(bar2VarLayout);\n-\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8240811.java","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-        run(\"--output\", typedefsOutput.toString(), typedefsH.toString()).checkSuccess();\n+        runAndCompile(typedefsOutput, typedefsH.toString());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8244412.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import java.lang.reflect.Method;\n@@ -33,1 +32,0 @@\n-import static org.testng.Assert.assertNull;\n@@ -42,1 +40,1 @@\n-        run(\"--output\", test8245767Output.toString(), test8245767H.toString()).checkSuccess();\n+        runAndCompile(test8245767Output, test8245767H.toString());\n@@ -47,4 +45,0 @@\n-            \/\/ class should be generated for typedef on opaque struct\n-            Class<?> fooCls = loader.loadClass(\"Foo\");\n-            assertNotNull(fooCls);\n-\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8245767.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import java.lang.foreign.MemorySegment;\n+\n@@ -39,1 +39,1 @@\n-        run(\"--output\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        runAndCompile(outputPath, headerFile.toString());\n@@ -43,7 +43,3 @@\n-            \/\/ Check if getters for pointer fields were generated\n-            checkMethod(nodeClass, \"next$get\", MemorySegment.class, MemorySegment.class);\n-            checkMethod(nodeClass, \"next$get\", MemorySegment.class, MemorySegment.class, long.class);\n-\n-            \/\/ Check if setters for pointer fields were generated\n-            checkMethod(nodeClass, \"next$set\", void.class, MemorySegment.class, MemorySegment.class);\n-            checkMethod(nodeClass, \"next$set\", void.class, MemorySegment.class, long.class, MemorySegment.class);\n+            checkMethod(nodeClass, \"next\", MemorySegment.class, MemorySegment.class);\n+            checkMethod(nodeClass, \"next\", void.class, MemorySegment.class, MemorySegment.class);\n+            checkMethod(nodeClass, \"asSlice\", MemorySegment.class, MemorySegment.class, long.class);\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8248415.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-        run(\"--output\", test8248474Output.toString(), test8248474H.toString()).checkSuccess();\n+        runAndCompile(test8248474Output, test8248474H.toString());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8248474.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-        run(\"--output\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        runAndCompile(outputPath, headerFile.toString());\n@@ -42,1 +42,1 @@\n-            Class<?> fiClass = loader.loadClass(\"func$f\");\n+            Class<?> fiClass = loader.loadClass(\"func$f$Function\");\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8249290.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-        run(\"--output\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        runAndCompile(outputPath, headerFile.toString());\n@@ -42,1 +42,1 @@\n-            Class<?> fiClass = loader.loadClass(\"func$f\");\n+            Class<?> fiClass = loader.loadClass(\"func$f$Function\");\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8249300.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import java.lang.foreign.MemorySegment;\n+\n@@ -42,1 +42,1 @@\n-        run(\"--output\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        runAndCompile(outputPath, headerFile.toString());\n@@ -45,1 +45,1 @@\n-            assertNull(findMethod(headerClass, \"tzname$SEGMENT\"));\n+            assertNotNull(findMethod(headerClass, \"tzname\"));\n@@ -48,2 +48,2 @@\n-            assertNotNull(findMethod(fooClass, \"bar$get\", MemorySegment.class));\n-            assertNull(findMethod(fooClass, \"names$get\", MemorySegment.class));\n+            assertNotNull(findMethod(fooClass, \"bar\", MemorySegment.class));\n+            assertNotNull(findMethod(fooClass, \"names\", MemorySegment.class));\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8251943.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-        run(\"--output\", test8258223Output.toString(), test8258223H.toString()).checkSuccess();\n+        runAndCompile(test8258223Output, test8258223H.toString());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8258223.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-        run(\"--output\", test8258405Output.toString(), test8258405H.toString()).checkSuccess();\n+        runAndCompile(test8258405Output, test8258405H.toString());\n@@ -44,1 +44,1 @@\n-            cls = loader.loadClass(\"func\");\n+            cls = loader.loadClass(\"func$Function\");\n@@ -48,1 +48,1 @@\n-            cls = loader.loadClass(\"Foo$bar\");\n+            cls = loader.loadClass(\"Foo$bar$Function\");\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8258405.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-            run(\"--output\", test8260344Output.toString(), test8260344H.toString()).checkSuccess();\n+            runAndCompile(test8260344Output, test8260344H.toString());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8260344.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-import java.lang.foreign.MemorySegment;\n+\n@@ -42,1 +42,1 @@\n-        run(\"--output\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        runAndCompile(outputPath, headerFile.toString());\n@@ -45,4 +45,3 @@\n-            checkMethod(FooClass, \"c$get\", byte.class, MemorySegment.class);\n-            checkMethod(FooClass, \"c$get\", byte.class, MemorySegment.class, long.class);\n-            checkMethod(FooClass, \"c$set\", void.class, MemorySegment.class, byte.class);\n-            checkMethod(FooClass, \"c$set\", void.class, MemorySegment.class, long.class, byte.class);\n+            checkMethod(FooClass, \"c\", byte.class, MemorySegment.class);\n+            checkMethod(FooClass, \"c\", void.class, MemorySegment.class, byte.class);\n+            checkMethod(FooClass, \"asSlice\", MemorySegment.class, MemorySegment.class, long.class);\n@@ -51,8 +50,5 @@\n-            checkMethod(Foo2Class, \"z$get\", int.class, MemorySegment.class);\n-            checkMethod(Foo2Class, \"z$get\", int.class, MemorySegment.class, long.class);\n-            checkMethod(Foo2Class, \"z$set\", void.class, MemorySegment.class, int.class);\n-            checkMethod(Foo2Class, \"z$set\", void.class, MemorySegment.class, long.class, int.class);\n-            checkMethod(Foo2Class, \"w$get\", int.class, MemorySegment.class);\n-            checkMethod(Foo2Class, \"w$get\", int.class, MemorySegment.class, long.class);\n-            checkMethod(Foo2Class, \"w$set\", void.class, MemorySegment.class, int.class);\n-            checkMethod(Foo2Class, \"w$set\", void.class, MemorySegment.class, long.class, int.class);\n+            checkMethod(Foo2Class, \"z\", int.class, MemorySegment.class);\n+            checkMethod(Foo2Class, \"z\", void.class, MemorySegment.class, int.class);\n+            checkMethod(Foo2Class, \"w\", int.class, MemorySegment.class);\n+            checkMethod(Foo2Class, \"w\", void.class, MemorySegment.class, int.class);\n+            checkMethod(Foo2Class, \"asSlice\", MemorySegment.class, MemorySegment.class, long.class);\n@@ -82,1 +78,0 @@\n-\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8260705.java","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import java.lang.foreign.MemorySegment;\n+\n@@ -38,1 +38,1 @@\n-        run(\"--output\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        runAndCompile(outputPath, headerFile.toString());\n@@ -41,4 +41,2 @@\n-            checkMethod(FooClass, \"s$get\", short.class, MemorySegment.class);\n-            checkMethod(FooClass, \"s$get\", short.class, MemorySegment.class, long.class);\n-            checkMethod(FooClass, \"s$set\", void.class, MemorySegment.class, short.class);\n-            checkMethod(FooClass, \"s$set\", void.class, MemorySegment.class, long.class, short.class);\n+            checkMethod(FooClass, \"s\", short.class, MemorySegment.class);\n+            checkMethod(FooClass, \"s\", void.class, MemorySegment.class, short.class);\n@@ -46,4 +44,2 @@\n-            checkMethod(FooClass, \"ptr$get\", MemorySegment.class, MemorySegment.class);\n-            checkMethod(FooClass, \"ptr$get\", MemorySegment.class, MemorySegment.class, long.class);\n-            checkMethod(FooClass, \"ptr$set\", void.class, MemorySegment.class, MemorySegment.class);\n-            checkMethod(FooClass, \"ptr$set\", void.class, MemorySegment.class, long.class, MemorySegment.class);\n+            checkMethod(FooClass, \"ptr\", MemorySegment.class, MemorySegment.class);\n+            checkMethod(FooClass, \"ptr\", void.class, MemorySegment.class, MemorySegment.class);\n@@ -51,0 +47,1 @@\n+            checkMethod(FooClass, \"asSlice\", MemorySegment.class, MemorySegment.class, long.class);\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8260717.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-        run(\"--output\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        runAndCompile(outputPath, headerFile.toString());\n@@ -46,4 +46,2 @@\n-            checkMethod(rab2Class, \"y$get\", int.class, MemorySegment.class);\n-            checkMethod(rab2Class, \"y$get\", int.class, MemorySegment.class, long.class);\n-            checkMethod(rab2Class, \"y$set\", void.class, MemorySegment.class, int.class);\n-            checkMethod(rab2Class, \"y$set\", void.class, MemorySegment.class, long.class, int.class);\n+            checkMethod(rab2Class, \"y\", int.class, MemorySegment.class);\n+            checkMethod(rab2Class, \"y\", void.class, MemorySegment.class, int.class);\n@@ -51,4 +49,4 @@\n-            checkMethod(rab2Class, \"x$get\", short.class, MemorySegment.class);\n-            checkMethod(rab2Class, \"x$get\", short.class, MemorySegment.class, long.class);\n-            checkMethod(rab2Class, \"x$set\", void.class, MemorySegment.class, short.class);\n-            checkMethod(rab2Class, \"x$set\", void.class, MemorySegment.class, long.class, short.class);\n+            checkMethod(rab2Class, \"x\", short.class, MemorySegment.class);\n+            checkMethod(rab2Class, \"x\", void.class, MemorySegment.class, short.class);\n+\n+            checkMethod(rab2Class, \"asSlice\", MemorySegment.class, MemorySegment.class, long.class);\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8260929.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-        run(\"--output\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        runAndCompile(outputPath, headerFile.toString());\n@@ -44,1 +44,1 @@\n-            checkMethod(ndpi_class, \"gnutella_msg_id$slice\", MemorySegment.class, MemorySegment.class);\n+            checkMethod(ndpi_class, \"gnutella_msg_id\", MemorySegment.class, MemorySegment.class);\n@@ -54,1 +54,1 @@\n-        run(\"--output\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        runAndCompile(outputPath, headerFile.toString());\n@@ -59,5 +59,5 @@\n-            checkMethod(foo_class, \"clear_color$slice\", MemorySegment.class, MemorySegment.class);\n-            checkMethod(foo_class, \"clear_z$get\", int.class, MemorySegment.class);\n-            checkMethod(foo_class, \"clear_z$set\", void.class, MemorySegment.class, int.class);\n-            checkMethod(foo_class, \"clear_s$get\", byte.class, MemorySegment.class);\n-            checkMethod(foo_class, \"clear_s$set\", void.class, MemorySegment.class, byte.class);\n+            checkMethod(foo_class, \"clear_color\", MemorySegment.class, MemorySegment.class);\n+            checkMethod(foo_class, \"clear_z\", int.class, MemorySegment.class);\n+            checkMethod(foo_class, \"clear_z\", void.class, MemorySegment.class, int.class);\n+            checkMethod(foo_class, \"clear_s\", byte.class, MemorySegment.class);\n+            checkMethod(foo_class, \"clear_s\", void.class, MemorySegment.class, byte.class);\n@@ -73,1 +73,1 @@\n-        run(\"--output\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        runAndCompile(outputPath, headerFile.toString());\n@@ -78,2 +78,2 @@\n-            checkMethod(plugin_class, \"maxAl_sduAudioFrames$get\", byte.class, MemorySegment.class);\n-            checkMethod(plugin_class, \"maxAl_sduAudioFrames$set\", void.class, MemorySegment.class, byte.class);\n+            checkMethod(plugin_class, \"maxAl_sduAudioFrames\", byte.class, MemorySegment.class);\n+            checkMethod(plugin_class, \"maxAl_sduAudioFrames\", void.class, MemorySegment.class, byte.class);\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8261578.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-        run(\"--output\", test8261893Output.toString(), test8261893H.toString()).checkSuccess();\n+        runAndCompile(test8261893Output, test8261893H.toString());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8261893.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import java.lang.reflect.Method;\n@@ -42,1 +41,1 @@\n-        run(\"--output\", test8262117Output.toString(), test8262117H.toString()).checkSuccess();\n+        runAndCompile(test8262117Output, test8262117H.toString());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8262117.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-        run(\"--output\", output.toString(), outputH.toString()).checkSuccess();\n+        runAndCompile(output, outputH.toString());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8262733.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-        run(\"--output\", output.toString(), outputH.toString()).checkSuccess();\n+        runAndCompile(output, outputH.toString());\n@@ -46,1 +46,0 @@\n-            assertNotNull(loader.loadClass(\"RuntimeHelper_\"));\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8262825.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-        run(\"--output\", output.toString(), outputH.toString()).checkSuccess();\n+        runAndCompile(output, outputH.toString());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8262851.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,2 @@\n-            run(\"--output\", getOutputFilePath(\"attributedPointerTypedef\").toString(),\n-                getInputFilePath(\"attributedPointerTypedef.h\").toString()).checkSuccess();\n+            runAndCompile(getOutputFilePath(\"attributedPointerTypedef\"),\n+                getInputFilePath(\"attributedPointerTypedef.h\").toString());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/TestAttributedPointerTypedef.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.lang.foreign.MemoryLayout.PathElement;\n@@ -28,1 +29,1 @@\n-import java.lang.foreign.Arena;\n+\n@@ -36,0 +37,1 @@\n+import java.lang.reflect.Field;\n@@ -151,8 +153,0 @@\n-        Method mh_getter = checkMethod(cls, name + \"$MH\", MethodHandle.class);\n-        MethodHandle mh = (MethodHandle) mh_getter.invoke(null);\n-        assertEquals(mh.type(), expectedType);\n-\n-        Object actualReturn = mh.invokeWithArguments(args);\n-        assertEquals(actualReturn.getClass(), expectedReturn.getClass());\n-        assertEquals(actualReturn, expectedReturn);\n-\n@@ -165,10 +159,2 @@\n-        Method layout_getter = checkMethod(cls, name + \"$LAYOUT\", MemoryLayout.class);\n-        assertEquals(layout_getter.invoke(null), expectedLayout);\n-\n-        Method addr_getter = checkMethod(cls, name + \"$SEGMENT\", MemorySegment.class);\n-        MemorySegment segment = (MemorySegment)addr_getter.invoke(null);\n-\n-        Method vh_getter = checkMethod(cls, name + \"$VH\", VarHandle.class);\n-        VarHandle vh = (VarHandle) vh_getter.invoke(null);\n-        assertEquals(vh.varType(), expectedType);\n-        assertEquals(vh.get(segment, 0L), expectedValue);\n+        Method getter = checkMethod(cls, name, expectedType);\n+        assertEquals(getter.invoke(null), expectedValue);\n@@ -176,2 +162,1 @@\n-        checkMethod(cls, name + \"$get\", expectedType);\n-        checkMethod(cls, name + \"$set\", void.class, expectedType);\n+        checkMethod(cls, name, void.class, expectedType);\n@@ -185,1 +170,1 @@\n-        Method layout_getter = checkMethod(structCls, \"$LAYOUT\", MemoryLayout.class);\n+        Method layout_getter = checkMethod(structCls, \"layout\", MemoryLayout.class);\n@@ -189,3 +174,4 @@\n-            Method vh_getter = checkMethod(structCls, memberName + \"$VH\", VarHandle.class);\n-            VarHandle vh = (VarHandle) vh_getter.invoke(null);\n-            assertEquals(vh.varType(), expectedType);\n+            Method offsetMethod = findMethod(structCls, memberName + \"$offset\");\n+            assertNotNull(offsetMethod);\n+            assertEquals(offsetMethod.getReturnType(), long.class);\n+            assertEquals(offsetMethod.invoke(null), structLayout.byteOffset(PathElement.groupElement(memberName)));\n@@ -193,2 +179,2 @@\n-            Method getter = checkMethod(structCls, memberName + \"$get\", expectedType, MemorySegment.class);\n-            Method setter = checkMethod(structCls, memberName + \"$set\", void.class, MemorySegment.class, expectedType);\n+            Method getter = checkMethod(structCls, memberName, expectedType, MemorySegment.class);\n+            Method setter = checkMethod(structCls, memberName, void.class, MemorySegment.class, expectedType);\n@@ -203,1 +189,1 @@\n-        Class<?> fiClass = loader.loadClass(\"com.acme.\" + name);\n+        Class<?> fiClass = loader.loadClass(\"com.acme.\" + name + \"$Function\");\n@@ -206,1 +192,3 @@\n-        checkMethod(fiClass, \"allocate\", MemorySegment.class, fiClass, Arena.class);\n+        Class<?> cbClass = loader.loadClass(\"com.acme.\" + name);\n+        assertNotNull(cbClass);\n+        checkMethod(cbClass, \"allocate\", MemorySegment.class, fiClass, Arena.class);\n@@ -213,1 +201,1 @@\n-        run(\n+        runAndCompile(outputDir,\n@@ -215,2 +203,1 @@\n-            \"--output\", outputDir,\n-            \"-l\", \"Examples\",\n+            \"-l\", \"Examples\", \"--use-system-load-library\",\n@@ -218,1 +205,1 @@\n-        ).checkSuccess();\n+        );\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/TestClassGeneration.java","additions":21,"deletions":34,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-            run(\"--output\", filterOutput.toString(), expectedKind.filterOption, expectedKind.symbolName, filterH.toString()).checkSuccess();\n+            runAndCompile(filterOutput, expectedKind.filterOption, expectedKind.symbolName, filterH.toString());\n@@ -70,1 +70,1 @@\n-            run(\"--dump-includes\", includes.toString(), filterH.toString()).checkSuccess();\n+            runNoOuput(\"--dump-includes\", includes.toString(), filterH.toString()).checkSuccess();\n@@ -109,1 +109,1 @@\n-                case VAR -> findMethod(headerClass, symbolName + \"$get\");\n+                case VAR -> findMethod(headerClass, symbolName);\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/TestFilters.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-        run(\"--output\", nestedOutput.toString(), nestedH.toString()).checkSuccess();\n+        runAndCompile(nestedOutput, nestedH.toString());\n@@ -70,2 +70,2 @@\n-                checkField(\"b\", int.class, 4, \"$anon$0\"),\n-                checkField(\"c\", int.class, 8, \"$anon$0\", \"$anon$0\"),\n+                checkField(\"b\", int.class, 4, \"$anon$48:5\"),\n+                checkField(\"c\", int.class, 8, \"$anon$48:5\", \"$anon$50:9\"),\n@@ -73,2 +73,2 @@\n-                checkField(\"d\", byte.class, 12, \"$anon$0\"),\n-                checkField(\"f\", MemorySegment.class, 13, \"$anon$0\"),\n+                checkField(\"d\", byte.class, 12, \"$anon$48:5\"),\n+                checkField(\"f\", MemorySegment.class, 13, \"$anon$48:5\"),\n@@ -76,2 +76,2 @@\n-                checkField(\"g\", int.class, 16, \"$anon$1\"),\n-                checkField(\"h\", long.class, 16, \"$anon$1\"),\n+                checkField(\"g\", int.class, 16, \"$anon$58:5\"),\n+                checkField(\"h\", long.class, 16, \"$anon$58:5\"),\n@@ -91,2 +91,2 @@\n-                checkField(\"b\", int.class, 0, \"$anon$0\"),\n-                checkField(\"c\", int.class, 4, \"$anon$0\", \"$anon$0\"),\n+                checkField(\"b\", int.class, 0, \"$anon$73:5\"),\n+                checkField(\"c\", int.class, 4, \"$anon$73:5\", \"$anon$75:9\"),\n@@ -94,2 +94,2 @@\n-                checkField(\"d\", byte.class, 8, \"$anon$0\"),\n-                checkField(\"f\", MemorySegment.class, 9, \"$anon$0\"),\n+                checkField(\"d\", byte.class, 8, \"$anon$73:5\"),\n+                checkField(\"f\", MemorySegment.class, 9, \"$anon$73:5\"),\n@@ -97,2 +97,2 @@\n-                checkField(\"g\", int.class, 0, \"$anon$1\"),\n-                checkField(\"h\", int.class, 4, \"$anon$1\"),\n+                checkField(\"g\", int.class, 0, \"$anon$83:5\"),\n+                checkField(\"h\", int.class, 4, \"$anon$83:5\"),\n@@ -110,1 +110,1 @@\n-                checkField(\"Z\", MemorySegment.class, 0, \"$anon$0\")\n+                checkField(\"Z\", MemorySegment.class, 0, \"$anon$97:5\")\n@@ -116,1 +116,1 @@\n-                checkField(\"y\", int.class, 0, \"$anon$0\", \"$anon$0\")\n+                checkField(\"y\", int.class, 0, \"$anon$105:5\", \"$anon$106:9\")\n@@ -120,2 +120,2 @@\n-                checkField(\"y\", int.class, 4, \"$anon$0\"),\n-                checkField(\"z\", int.class, 4, \"$anon$0\")\n+                checkField(\"y\", int.class, 4, \"$anon$114:5\"),\n+                checkField(\"z\", int.class, 4, \"$anon$114:5\")\n@@ -156,1 +156,1 @@\n-                Method slicer = cls.getMethod(fieldName + \"$slice\", MemorySegment.class);\n+                Method slicer = cls.getMethod(fieldName, MemorySegment.class);\n@@ -164,1 +164,1 @@\n-                Method getter = cls.getMethod(fieldName + \"$get\", MemorySegment.class);\n+                Method getter = cls.getMethod(fieldName, MemorySegment.class);\n@@ -166,1 +166,1 @@\n-                Method setter = cls.getMethod(fieldName + \"$set\", MemorySegment.class, type);\n+                Method setter = cls.getMethod(fieldName, MemorySegment.class, type);\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/TestNested.java","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-        run(\"--output\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        runAndCompile(outputPath, headerFile.toString());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/TestTypedefIsFunctionProto.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-        run(\"--output\", uniondeclOutput.toString(), uniondeclH.toString()).checkSuccess();\n+        runAndCompile(uniondeclOutput, uniondeclH.toString());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/UniondeclTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,0 +69,6 @@\n+\n+enum AnEnum {\n+    SEVEN = 7,\n+    #define SEVEN SEVEN\n+    #define EIGHT SEVEN + 1\n+};\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/constants.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider.docComments;\n+\n+import testlib.JextractToolRunner;\n+import testlib.TestUtils;\n+import org.testng.annotations.Test;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.fail;\n+\n+public class TestDocComments extends JextractToolRunner {\n+    \/\/ Regular expression for javadoc comment text\n+    \/\/\n+    \/\/   (?s)     dot matches all including newlines\n+    \/\/   \/\\*\\*    doc comment start\n+    \/\/   (.*?)    comment text as a group (reluctant match)\n+    \/\/   \\*\/      doc comment end\n+    private static final Pattern JAVADOC_COMMENT = Pattern.compile(\"(?s)\/\\\\*\\\\*(.*?)\\\\*\/\");\n+\n+    @Test\n+    public void testMacros() throws IOException {\n+        var comments = getDocComments(\"macros.h\", \"macros_h.java\");\n+        assertEquals(comments, List.of(\n+            \"#define FOO 42\",\n+            \"#define MSG \\\"Hello\\\"\",\n+            \"#define MSG_COMMENT \\\"HelloWithComment\\\"\"));\n+    }\n+\n+    @Test\n+    public void testEnumConstants() throws IOException {\n+        var comments = getDocComments(\"enums.h\", \"enums_h.java\");\n+        assertEquals(comments, List.of(\n+            \"enum Color.RED = 0\",\n+            \"enum Color.GREEN = 1\",\n+            \"enum Color.BLUE = 2\",\n+            \"enum Suit.club = 1\",\n+            \"enum Suit.diamonds = 2\",\n+            \"enum Suit.hearts = 3\",\n+            \"enum Suit.spades = 4\"));\n+    }\n+\n+    @Test\n+    public void testTypedefs() throws IOException {\n+        var comments = getDocComments(\"typedefs.h\", \"typedefs_h.java\");\n+        assertEquals(comments, List.of(\n+            \"typedef unsigned long long size_t\",\n+            \"typedef int INT_32\",\n+            \"typedef int *INT_PTR\",\n+            \"typedef struct Foo *OPAQUE_PTR\"));\n+    }\n+\n+    @Test\n+    public void testArrays() throws IOException {\n+        var comments = getDocComments(\"arrays.h\", \"arrays_h.java\");\n+        assertContains(comments, List.of(\n+            \"Getter for variable: int abc[10]\",\n+            \"Indexed getter for variable: int abc[10]\",\n+            \"Setter for variable: int abc[10]\",\n+            \"Indexed setter for variable: int abc[10]\",\n+            \"Getter for variable: float numbers[3]\",\n+            \"Indexed getter for variable: float numbers[3]\",\n+            \"Setter for variable: float numbers[3]\",\n+            \"Indexed setter for variable: float numbers[3]\",\n+            \"Getter for variable: char *msg[5]\",\n+            \"Indexed getter for variable: char *msg[5]\",\n+            \"Setter for variable: char *msg[5]\",\n+            \"Indexed setter for variable: char *msg[5]\",\n+            \"Getter for variable: int pixels[200][100]\",\n+            \"Indexed getter for variable: int pixels[200][100]\",\n+            \"Setter for variable: int pixels[200][100]\",\n+            \"Indexed setter for variable: int pixels[200][100]\",\n+            \"Getter for variable: int points[10][20][30]\",\n+            \"Indexed getter for variable: int points[10][20][30]\",\n+            \"Setter for variable: int points[10][20][30]\",\n+            \"Indexed setter for variable: int points[10][20][30]\"));\n+    }\n+\n+    @Test\n+    public void testFunctions() throws IOException {\n+        var comments = getDocComments(\"functions.h\", \"functions_h.java\");\n+        assertContains(comments, List.of(\n+            \"int func(int *fp)\",\n+            \"double distance(struct Point p)\",\n+            \"Variadic invoker factory for: int printf(char *fmt, ...)\"));\n+    }\n+\n+    @Test\n+    public void testFunctionPointer() throws IOException {\n+        var comments = getDocComments(\"funcptrs.h\", \"funcptr.java\");\n+        assertContains(comments, List.of(\n+            \"void (*funcptr)(int *, int)\"\n+        ));\n+    }\n+\n+    @Test\n+    public void testFunctionPointer2() throws IOException {\n+        var comments = getDocComments(\"funcptrs.h\", \"signal$func.java\");\n+        assertContains(comments, List.of(\n+            \"void (*func)(int)\"\n+        ));\n+    }\n+\n+    @Test\n+    public void testFunctionPointer3() throws IOException {\n+        var comments = getDocComments(\"funcptrs.h\", \"signal$return.java\");\n+        assertContains(comments, List.of(\n+            \"void (*signal(int sig, void (*func)(int)))(int)\"\n+        ));\n+    }\n+\n+    @Test\n+    public void testFunctionPointer4() throws IOException {\n+        var comments = getDocComments(\"funcptrs.h\", \"funcptrs_h.java\");\n+        assertContains(comments, List.of(\n+            \"Getter for variable: void (*funcptr)(int *, int)\",\n+            \"Setter for variable: void (*funcptr)(int *, int)\",\n+            \"void (*signal(int sig, void (*func)(int)))(int)\"\n+        ));\n+    }\n+\n+    @Test\n+    public void testVariables() throws IOException {\n+        var comments = getDocComments(\"variables.h\", \"variables_h.java\");\n+        assertContains(comments, List.of(\n+            \"Getter for variable: int abc\",\n+            \"Setter for variable: int abc\",\n+            \"Layout for variable: int abc\",\n+            \"Segment for variable: int abc\",\n+            \"Getter for variable: char *msg\",\n+            \"Setter for variable: char *msg\",\n+            \"Layout for variable: char *msg\",\n+            \"Segment for variable: char *msg\"\n+        ));\n+    }\n+\n+    @Test\n+    public void testStruct() throws IOException {\n+        var comments = getDocComments(\"structs.h\", \"Point.java\");\n+        assertContains(comments, List.of(\n+            \"struct Point { int x; int y; }\",\n+            \"Getter for field: int x\",\n+            \"Setter for field: int x\",\n+            \"Getter for field: int y\",\n+            \"Setter for field: int y\"));\n+    }\n+\n+    @Test\n+    public void testStruct2() throws IOException {\n+        var comments = getDocComments(\"structs.h\", \"Point3D.java\");\n+        assertContains(comments, List.of(\n+            \"struct Point3D { int x; int y; int z; }\",\n+            \"Getter for field: int x\",\n+            \"Setter for field: int x\",\n+            \"Getter for field: int y\",\n+            \"Setter for field: int y\",\n+            \"Getter for field: int z\",\n+            \"Setter for field: int z\"));\n+    }\n+\n+    @Test\n+    public void testNestedAnon() throws IOException {\n+        var comments = getDocComments(\"structs.h\", \"NestedAnon.java\");\n+        assertContains(comments, List.of(\n+            \"struct NestedAnon { struct { int l; long long h; } u; }\",\n+            \"struct { int l; long long h; }\",\n+            \"Getter for field: int l\",\n+            \"Setter for field: int l\",\n+            \"Getter for field: long long h\",\n+            \"Setter for field: long long h\",\n+            \"Getter for field: struct { int l; long long h; } u\",\n+            \"Setter for field: struct { int l; long long h; } u\"));\n+    }\n+\n+    @Test\n+    public void testStructTypdef() throws IOException {\n+        var comments = getDocComments(\"structs.h\", \"Point_t.java\");\n+        assertEquals(comments, List.of(\n+            \"typedef struct Point { int x; int y; } Point_t\"));\n+    }\n+\n+    private List<String> getDocComments(String header, String outputFile)\n+            throws IOException {\n+        var output = getOutputFilePath(\"TestDocComments-parse-\" + header);\n+        var outputH = getInputFilePath(header);\n+        run(output, outputH.toString());\n+        try {\n+            return findDocComments(Files.readString(output.resolve(outputFile)));\n+        } finally {\n+            TestUtils.deleteDir(output);\n+        }\n+    }\n+\n+    \/\/ get doc comments from the given the source content\n+    private static List<String> findDocComments(String content) {\n+        var matcher = JAVADOC_COMMENT.matcher(content);\n+        var strings = new ArrayList<String>();\n+        while (matcher.find()) {\n+            \/\/ doc comment text is matched in group 1\n+            String rawComment = matcher.group(1);\n+\n+            \/\/ sanitize raw comment for test asserts\n+            strings.add(rawComment\n+                \/\/ remove \\n followed by whitespaces and then *\n+                .replaceAll(\"\\n\\\\s+\\\\*\", \"\")\n+\n+                \/\/ get rid of \"{@snippet :\" prefix\n+                .replaceAll(\"\\\\{@snippet lang=c :\", \"\")\n+\n+                \/\/ replace one or more whitespaces as single whitespace\n+                .replaceAll(\"\\\\s+\", \" \")\n+\n+                \/\/ get rid of last \"}\" suffix closing the snippet\n+                .replaceAll(\"\\\\s+}\\\\s+$\", \"\")\n+\n+                .trim());\n+        }\n+        return strings;\n+    }\n+\n+    static void assertContains(List<String> found, List<String> expected) {\n+        for (String e : expected) {\n+            if (!found.contains(e)) {\n+                fail(String.format(\"\\\"%s\\\" not found in: \", e, found));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/docComments\/TestDocComments.java","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"},{"patch":"","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/docComments\/arrays.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903257\/arrays.h","status":"renamed"},{"patch":"","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/docComments\/enums.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903257\/enums.h","status":"renamed"},{"patch":"","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/docComments\/funcptrs.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903257\/funcptrs.h","status":"renamed"},{"patch":"","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/docComments\/functions.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903257\/functions.h","status":"renamed"},{"patch":"@@ -26,0 +26,1 @@\n+#define MSG_COMMENT \"HelloWithComment\" \/* Some comment *\/\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/docComments\/macros.h","additions":1,"deletions":0,"binary":false,"changes":1,"previous_filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903257\/macros.h","status":"renamed"},{"patch":"@@ -36,0 +36,7 @@\n+\n+struct NestedAnon {\n+    struct {\n+        int l;\n+        long long h;\n+    } u;\n+};\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/docComments\/structs.h","additions":7,"deletions":0,"binary":false,"changes":7,"previous_filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903257\/structs.h","status":"renamed"},{"patch":"","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/docComments\/typedefs.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903257\/typedefs.h","status":"renamed"},{"patch":"","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/docComments\/variables.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903257\/variables.h","status":"renamed"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.toolprovider.nestedAnonOffset;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import testlib.JextractToolRunner;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.UnionLayout;\n+import java.nio.file.Path;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+\n+public class TestNestedAnonOffset extends JextractToolRunner {\n+\n+    Loader loader;\n+\n+    @BeforeClass\n+    public void beforeClass() {\n+        Path output = getOutputFilePath(\"TestAnon-anonymousStructs.h\");\n+        Path outputH = getInputFilePath(\"anonymousStructs.h\");\n+        runAndCompile(output, outputH.toString());\n+\n+        loader = classLoader(output);\n+    }\n+\n+    @AfterClass\n+    public void afterClass() {\n+        loader.close();\n+    }\n+\n+    @Test\n+    public void testFoo() {\n+        Class<?> foo = loader.loadClass(\"Foo\");\n+        assertNotNull(foo);\n+        StructLayout layout = (StructLayout) findLayout(foo);\n+        assertEquals(layout.memberLayouts().get(0), C_CHAR.withName(\"c\"));\n+        assertEquals(layout.memberLayouts().get(1), MemoryLayout.paddingLayout(3));\n+\n+        StructLayout nestedAnon1 = (StructLayout) layout.memberLayouts().get(2);\n+        assertEquals(nestedAnon1.memberLayouts().get(0), MemoryLayout.paddingLayout(4));\n+\n+        StructLayout nestedAnon2 = (StructLayout) nestedAnon1.memberLayouts().get(1);\n+        assertEquals(nestedAnon2.memberLayouts().get(0), MemoryLayout.paddingLayout(4));\n+        assertEquals(nestedAnon2.memberLayouts().get(1), C_INT.withName(\"x\"));\n+    }\n+\n+    @Test\n+    public void testBar() {\n+        Class<?> bar = loader.loadClass(\"Bar\");\n+        assertNotNull(bar);\n+        StructLayout layout = (StructLayout) findLayout(bar);\n+        assertEquals(layout.memberLayouts().get(0), C_CHAR.withName(\"c\"));\n+        assertEquals(layout.memberLayouts().get(1), MemoryLayout.paddingLayout(3));\n+\n+        StructLayout nestedAnon1 = (StructLayout) layout.memberLayouts().get(2);\n+        assertEquals(nestedAnon1.memberLayouts().get(0), MemoryLayout.paddingLayout(4));\n+\n+        UnionLayout nestedAnon2 = (UnionLayout) nestedAnon1.memberLayouts().get(1);\n+        assertEquals(nestedAnon2.memberLayouts().get(0), C_INT.withName(\"x\"));\n+    }\n+\n+    @Test\n+    public void testBaz() {\n+        Class<?> baz = loader.loadClass(\"Baz\");\n+        assertNotNull(baz);\n+        StructLayout layout = (StructLayout) findLayout(baz);\n+        assertEquals(layout.memberLayouts().get(0), C_CHAR.withName(\"c\"));\n+        \/\/ Note here: only on Windows, the bitfield needs to be aligned and requires more padding\n+        assertEquals(layout.memberLayouts().get(1), MemoryLayout.paddingLayout(IS_WINDOWS ? 11 : 8));\n+    }\n+\n+    @Test\n+    public void testBoo() {\n+        Class<?> boo = loader.loadClass(\"Boo\");\n+        assertNotNull(boo);\n+        StructLayout layout = (StructLayout) findLayout(boo);\n+        assertEquals(layout.memberLayouts().get(0), C_CHAR.withName(\"c\"));\n+        assertEquals(layout.memberLayouts().get(1), MemoryLayout.paddingLayout(3));\n+\n+        StructLayout nestedAnon1 = (StructLayout) layout.memberLayouts().get(2);\n+        assertEquals(nestedAnon1.memberLayouts().get(0), MemoryLayout.paddingLayout(8));\n+\n+        StructLayout nestedAnon2 = (StructLayout) nestedAnon1.memberLayouts().get(1);\n+        assertEquals(nestedAnon2.memberLayouts().get(0), C_INT.withName(\"x\"));\n+    }\n+}\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/nestedAnonOffset\/TestNestedAnonOffset.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+    char c;\n+    struct {\n+        int: 32;\n+        struct {\n+            int: 32;\n+            int x;\n+        };\n+    };\n+};\n+\n+struct Bar {\n+    char c;\n+    struct {\n+        int: 32;\n+        union {\n+            int: 32;\n+            int x;\n+        };\n+    };\n+};\n+\n+struct Baz {\n+    char c;\n+    struct { \/\/ should be skipped\n+        int: 32;\n+        struct {\n+            int: 32;\n+        };\n+    };\n+};\n+\n+struct Boo {\n+    char c;\n+    struct { \/\/ should have offset\n+        int: 32;\n+        struct { \/\/ should be skipped\n+            int: 32;\n+        };\n+        struct {\n+            int x; \/\/ named field in second\n+        };\n+    };\n+};\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/nestedAnonOffset\/anonymousStructs.h","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider.typedefs;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import testlib.JextractToolRunner;\n+\n+import java.nio.file.Path;\n+\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+\n+public class TestRedundantTypedefs extends JextractToolRunner {\n+\n+    Loader loader;\n+\n+    @BeforeClass\n+    public void beforeClass() {\n+        Path output = getOutputFilePath(\"TestRedundantTypedefs-typedefs.h\");\n+        Path input = getInputFilePath(\"typedefs.h\");\n+        runAndCompile(output, input.toString());\n+        loader = classLoader(output);\n+    }\n+\n+    @AfterClass\n+    public void afterClass() {\n+        loader.close();\n+    }\n+\n+    @Test\n+    public void testStructTypedefs() {\n+        assertNotNull(loader.loadClass(\"P\"));\n+        assertNotNull(loader.loadClass(\"Q\"));\n+        assertNull(loader.loadClass(\"P$0\"));\n+        assertNull(loader.loadClass(\"Q$0\"));\n+    }\n+\n+    @Test\n+    public void testFunctionTypedefs() {\n+        assertNotNull(loader.loadClass(\"f\"));\n+        assertNotNull(loader.loadClass(\"g\"));\n+        assertNull(loader.loadClass(\"foo_f$ptr_f\"));\n+        assertNull(loader.loadClass(\"foo_f$return\"));\n+        assertNull(loader.loadClass(\"foo_g$ptr_f\"));\n+        assertNull(loader.loadClass(\"foo_g$return\"));\n+    }\n+}\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/typedefs\/TestRedundantTypedefs.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef struct { int x; int y; } P;\n+typedef P Q;\n+\n+typedef void (*f)(int, double);\n+typedef f g;\n+\n+\/\/ add some uses\n+\n+P foo_P(P p);\n+Q foo_P(Q q);\n+\n+f foo_f(f ptr_f);\n+g foo_g(g ptr_g);\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/typedefs\/typedefs.h","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.toolprovider.unsupported;\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import testlib.JextractToolRunner;\n+\n+import java.nio.file.Path;\n+\n+public class TestUnsupportedTypes extends JextractToolRunner {\n+\n+    JextractToolRunner.JextractResult result;\n+\n+    @BeforeClass\n+    public void before() {\n+        Path output = getOutputFilePath(\"TestUnsupportedTypes-unsupportedTypes.h\");\n+        Path outputH = getInputFilePath(\"unsupportedTypes.h\");\n+        result = run(output, outputH.toString());\n+    }\n+\n+    @Test(dataProvider = \"cases\")\n+    public void testUnsupportedTypes(String skippedName, String reason) {\n+        result.checkContainsOutput(\"WARNING: skipping \" + skippedName + \": \" + reason);\n+    }\n+\n+    private static final String REASON_UNSUPPORTED_TYPE = \"unsupported type usage\";\n+    private static final String REASON_VARARGS_CALLBACK = \"varargs in callbacks is not supported\";\n+\n+    @DataProvider\n+    public static Object[][] cases() {\n+        return new Object[][]{\n+            {\"returns_unsupported\",              REASON_UNSUPPORTED_TYPE},\n+            {\"accepts_unsupported\",              REASON_UNSUPPORTED_TYPE},\n+            {\"unsupported_t\",                    REASON_UNSUPPORTED_TYPE},\n+            {\"unsupported_func_t\",               REASON_UNSUPPORTED_TYPE},\n+            {\"returns_unsupported_func\",         REASON_UNSUPPORTED_TYPE},\n+            {\"accepts_unsupported_func\",         REASON_UNSUPPORTED_TYPE},\n+            {\"accepts_unsupported_func_varargs\", REASON_VARARGS_CALLBACK},\n+            {\"GLOBAL_UNSUPPORTED\",               REASON_UNSUPPORTED_TYPE},\n+            {\"GLOBAL_UNSUPPORTED_FUNC\",          REASON_UNSUPPORTED_TYPE},\n+            {\"accepts_undefined\",                REASON_UNSUPPORTED_TYPE},\n+            {\"returns_undefined\",                REASON_UNSUPPORTED_TYPE},\n+            {\"accepts_undefined_func\",           REASON_UNSUPPORTED_TYPE},\n+            {\"GLOBAL_UNDECLARED\",                REASON_UNSUPPORTED_TYPE},\n+            {\"undefined_typedef\",                REASON_UNSUPPORTED_TYPE},\n+            {\"INT_128_NUM\",                      REASON_UNSUPPORTED_TYPE}\n+        };\n+    }\n+}\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/unsupported\/TestUnsupportedTypes.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+__int128 returns_unsupported(void);\n+void accepts_unsupported(__int128);\n+\n+typedef __int128 unsupported_t;\n+typedef __int128 (*unsupported_func_t)(void);\n+\n+\/\/ this insane syntax indicates a function 'returns_unsupported_func(void)'\n+\/\/ that returns a '__int128 (*)(void)' function pointer\n+__int128 (*returns_unsupported_func(void))(void);\n+void accepts_unsupported_func(__int128 (*)(void));\n+void accepts_unsupported_func_varargs(void (*)(int, ...));\n+\n+extern __int128 GLOBAL_UNSUPPORTED;\n+extern __int128 (*GLOBAL_UNSUPPORTED_FUNC)(void);\n+\n+struct undefined;\n+\n+struct undefined returns_undefined(void);\n+void accepts_undefined(struct undefined);\n+void accepts_undefined_func(void (*)(struct undefined));\n+\n+typedef struct undefined undefined_typedef;\n+\n+extern struct undefined GLOBAL_UNDECLARED;\n+\n+#define INT_128_NUM (__int128)42\n+\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/unsupported\/unsupportedTypes.h","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.toolprovider.variadicNames;\n+\n+import java.nio.file.Path;\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import testlib.JextractToolRunner;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestMangledVariadicNames extends JextractToolRunner {\n+\n+    Loader loader;\n+\n+    @BeforeClass\n+    public void before() {\n+        Path output = getOutputFilePath(\"TestMangledVariadicNames-variadic_names.h\");\n+        Path input = getInputFilePath(\"variadic_names.h\");\n+        runAndCompile(output, input.toString());\n+        loader = classLoader(output);\n+    }\n+\n+    @Test\n+    public void testMangledVariadicNames() {\n+        Class<?> headerClass = loader.loadClass(\"variadic_names_h\");\n+        assertNotNull(headerClass);\n+        assertNotNull(findNestedClass(headerClass, \"f\"));\n+        assertNotNull(findNestedClass(headerClass, \"F$\"));\n+    }\n+}\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/variadicNames\/TestMangledVariadicNames.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,2 @@\n-void func(int);\n+void f(int n, ...);\n+void F(int n, ...);\n\\ No newline at end of file\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/variadicNames\/variadic_names.h","additions":3,"deletions":2,"binary":false,"changes":5,"previous_filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/JDK-8248474.h","status":"copied"},{"patch":"@@ -5,0 +5,1 @@\n+* remove the src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang folder\n@@ -8,0 +9,1 @@\n+* set LIBCLANG_HOME to point to the home of the LLVM distribution\n@@ -12,1 +14,1 @@\n-File: RuntimeHelper.java\n+File: Index_h.java\n","filename":"updateclang\/README.md","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -16,0 +16,1 @@\n+--include-typedef CXCursor\n@@ -18,0 +19,2 @@\n+--include-typedef CXSourceRange\n+--include-typedef CXSourceLocation\n@@ -547,0 +550,1 @@\n+--include-function clang_Type_getAlignOf\n@@ -549,0 +553,1 @@\n+--include-function clang_Type_getValueType\n","filename":"updateclang\/clang.symbols","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"updateclang\/cp_header.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,2 @@\n+echo \"Extracting libclang headers...\"\n+\n@@ -4,1 +6,2 @@\n-  --source -t org.openjdk.jextract.clang.libclang -lclang \\\n+  -t org.openjdk.jextract.clang.libclang -lclang \\\n+  --use-system-load-library \\\n@@ -11,0 +14,2 @@\n+echo \"Adding copyrights...\"\n+\n@@ -12,2 +17,2 @@\n-head -$COPYRIGHTLEN $x | diff cp_header.txt - || ( ( cat cp_header.txt; echo; cat $x) > \/tmp\/file;\n-mv \/tmp\/file $x )\n+(cat cp_header.txt; echo; cat $x) > \/tmp\/file;\n+mv \/tmp\/file $x\n@@ -15,0 +20,2 @@\n+\n+echo \"Done!\"\n","filename":"updateclang\/extract.sh","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"}]}