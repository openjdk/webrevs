{"files":[{"patch":"@@ -487,0 +487,6 @@\n+        \/\/ 64 bit mode on AIX\n+        if (System.getProperty(\"os.name\").toLowerCase().contains(\"aix\")) {\n+            builder.addClangArg(\"-m64\");\n+            builder.addClangArg(\"-DAIX_NATURAL_ALIGN=1\");\n+        }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/JextractTool.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,0 +71,2 @@\n+    private static final int NO_ALIGN_REQUIRED_MARKER = -1;\n+\n@@ -205,1 +207,1 @@\n-        return layoutString(type, Long.MAX_VALUE);\n+        return fieldLayoutString(type, -1, NO_ALIGN_REQUIRED_MARKER);\n@@ -208,1 +210,1 @@\n-    String layoutString(Type type, long align) {\n+    String fieldLayoutString(Type type, long typeAlign, long expectedAlign) {\n@@ -210,7 +212,11 @@\n-            case Primitive p -> primitiveLayoutString(p, align);\n-            case Declared d when Utils.isEnum(d) -> layoutString(ClangEnumType.get(d.tree()).get(), align);\n-            case Declared d when Utils.isStructOrUnion(d) -> alignIfNeeded(JavaName.getFullNameOrThrow(d.tree()) + \".layout()\", ClangAlignOf.getOrThrow(d.tree()) \/ 8, align);\n-            case Delegated d when d.kind() == Delegated.Kind.POINTER -> alignIfNeeded(runtimeHelperName() + \".C_POINTER\", 8, align);\n-            case Delegated d -> layoutString(d.type(), align);\n-            case Function _ -> alignIfNeeded(runtimeHelperName() + \".C_POINTER\", 8, align);\n-            case Array a -> String.format(\"MemoryLayout.sequenceLayout(%1$d, %2$s)\", a.elementCount().orElse(0L), layoutString(a.elementType(), align));\n+            case Primitive p -> primitiveLayoutString(p, typeAlign, expectedAlign);\n+            case Declared d when Utils.isEnum(d) ->\n+                   fieldLayoutString(ClangEnumType.get(d.tree()).get(), typeAlign, expectedAlign);\n+            case Declared d when Utils.isStructOrUnion(d) ->\n+                    alignIfNeeded(JavaName.getFullNameOrThrow(d.tree()) + \".layout()\", typeAlign, expectedAlign);\n+            case Delegated d when d.kind() == Delegated.Kind.POINTER ->\n+                    alignIfNeeded(runtimeHelperName() + \".C_POINTER\", typeAlign, expectedAlign);\n+            case Delegated d -> fieldLayoutString(d.type(), typeAlign, expectedAlign);\n+            case Function _ -> alignIfNeeded(runtimeHelperName() + \".C_POINTER\", typeAlign, expectedAlign);\n+            case Array a -> String.format(\"MemoryLayout.sequenceLayout(%1$d, %2$s)\", a.elementCount().orElse(0L),\n+                    fieldLayoutString(a.elementType(), typeAlign, expectedAlign));\n@@ -253,1 +259,1 @@\n-    private String primitiveLayoutString(Primitive primitiveType, long align) {\n+    private String primitiveLayoutString(Primitive primitiveType, long defaultAlign, long expectedAlign) {\n@@ -255,8 +261,8 @@\n-            case Bool -> runtimeHelperName() + \".C_BOOL\";\n-            case Char -> runtimeHelperName() + \".C_CHAR\";\n-            case Short -> alignIfNeeded(runtimeHelperName() + \".C_SHORT\", 2, align);\n-            case Int -> alignIfNeeded(runtimeHelperName() + \".C_INT\", 4, align);\n-            case Long -> alignIfNeeded(runtimeHelperName() + \".C_LONG\", TypeImpl.IS_WINDOWS ? 4 : 8, align);\n-            case LongLong -> alignIfNeeded(runtimeHelperName() + \".C_LONG_LONG\", 8, align);\n-            case Float -> alignIfNeeded(runtimeHelperName() + \".C_FLOAT\", 4, align);\n-            case Double -> alignIfNeeded(runtimeHelperName() + \".C_DOUBLE\", 8, align);\n+            case Bool -> alignIfNeeded(runtimeHelperName() + \".C_BOOL\", defaultAlign, expectedAlign);\n+            case Char -> alignIfNeeded(runtimeHelperName() + \".C_CHAR\", defaultAlign, expectedAlign);\n+            case Short -> alignIfNeeded(runtimeHelperName() + \".C_SHORT\", defaultAlign, expectedAlign);\n+            case Int -> alignIfNeeded(runtimeHelperName() + \".C_INT\", defaultAlign, expectedAlign);\n+            case Long -> alignIfNeeded(runtimeHelperName() + \".C_LONG\", defaultAlign, expectedAlign);\n+            case LongLong -> alignIfNeeded(runtimeHelperName() + \".C_LONG_LONG\", defaultAlign, expectedAlign);\n+            case Float -> alignIfNeeded(runtimeHelperName() + \".C_FLOAT\", defaultAlign, expectedAlign);\n+            case Double -> alignIfNeeded(runtimeHelperName() + \".C_DOUBLE\", defaultAlign, expectedAlign);\n@@ -264,1 +270,1 @@\n-                    alignIfNeeded(runtimeHelperName() + \".C_LONG_DOUBLE\", 8, align) :\n+                    alignIfNeeded(runtimeHelperName() + \".C_LONG_DOUBLE\", defaultAlign, expectedAlign) :\n@@ -272,2 +278,2 @@\n-    private String alignIfNeeded(String layoutPrefix, long align, long expectedAlign) {\n-        return align > expectedAlign ?\n+    private String alignIfNeeded(String layoutPrefix, long defaultAlign, long expectedAlign) {\n+        return expectedAlign != NO_ALIGN_REQUIRED_MARKER && defaultAlign != expectedAlign ?\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ClassSourceBuilder.java","additions":27,"deletions":21,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -463,1 +463,1 @@\n-        long align = ClangAlignOf.getOrThrow(scoped) \/ 8;\n+        long scopedTypeAlign = ClangAlignOf.getOrThrow(scoped) \/ 8;\n@@ -480,1 +480,9 @@\n-                    memberLayout = layoutString(var.type(), align);\n+                    \/\/ FIXME we can not handle hyper-aligned fields here since clang doesn't attach the\n+                    \/\/ alignment specified by a field alignment specifier to the field declaration cursor.\n+                    \/\/\n+                    \/\/ struct foo { \/\/ ClangAlignOf == 8\n+                    \/\/     _Alignas(8) int x; \/\/ ClangAlignOf == 4\n+                    \/\/ };\n+                    long fieldTypeAlign = ClangAlignOf.getOrThrow(var) \/ 8;\n+                    long expectedAlign = Math.min(scopedTypeAlign, fieldTypeAlign);\n+                    memberLayout = fieldLayoutString(var.type(), fieldTypeAlign, expectedAlign);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructBuilder.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+    public static final boolean IS_AIX = System.getProperty(\"os.name\").startsWith(\"AIX\");\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypeImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,0 +45,3 @@\n+\n+    public static final boolean IS_AIX = System.getProperty(\"os.name\").startsWith(\"AIX\");\n+\n@@ -100,1 +103,1 @@\n-        checkField(g, \"d\",  C_DOUBLE);\n+        checkField(g, \"d\", C_DOUBLE);\n","filename":"test\/jtreg\/generator\/testStruct\/LibStructTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,4 @@\n+#ifdef AIX_NATURAL_ALIGN\n+#pragma align(natural)\n+#endif\n+\n","filename":"test\/jtreg\/generator\/testStruct\/struct.h","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+    public static final boolean IS_AIX = System.getProperty(\"os.name\").equals(\"AIX\");\n","filename":"test\/lib\/testlib\/JextractToolRunner.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,4 @@\n+#ifdef AIX_NATURAL_ALIGN\n+#pragma align(natural)\n+#endif\n+\n@@ -82,1 +86,1 @@\n-};\n\\ No newline at end of file\n+};\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/examples.h","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-        int paddingBytes = (IS_WINDOWS || (IS_LINUX && IS_AARCH64)) ? 11 : 8;\n+        int paddingBytes = (IS_WINDOWS || (IS_LINUX && IS_AARCH64) || IS_AIX) ? 11 : 8;\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/nestedAnonOffset\/TestNestedAnonOffset.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}