{"files":[{"patch":"@@ -43,0 +43,1 @@\n+import java.util.List;\n@@ -45,0 +46,1 @@\n+import java.util.stream.IntStream;\n@@ -269,0 +271,12 @@\n+\n+    record IndexList(String decl, String use) {\n+        static IndexList of(int dims) {\n+            List<String> indexNames = IntStream.range(0, dims).mapToObj(i -> \"index\" + i).toList();\n+            String indexDecls = indexNames.stream()\n+                    .map(i -> \"long \" + i)\n+                    .collect(Collectors.joining(\", \"));\n+            String indexUses = indexNames.stream()\n+                    .collect(Collectors.joining(\", \"));\n+            return new IndexList(indexDecls, indexUses);\n+        }\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ClassSourceBuilder.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -42,0 +41,2 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n@@ -55,1 +56,0 @@\n-        String nativeName = varTree.name();\n@@ -57,1 +57,1 @@\n-        String layoutVar = emitVarLayout(varTree.type(), javaName);\n+        String holderClass = emitVarHolderClass(varTree, javaName);\n@@ -59,3 +59,8 @@\n-            String segmentConstant = emitGlobalSegment(layoutVar, javaName, nativeName);\n-            emitGlobalSegmentGetter(segmentConstant, layoutVar, javaName, varTree, \"Getter for variable:\");\n-            emitGlobalSegmentSetter(segmentConstant, layoutVar, javaName, varTree, \"Setter for variable:\");\n+            emitGlobalSegmentGetter(holderClass, javaName, varTree, \"Getter for variable:\");\n+            emitGlobalSegmentSetter(holderClass, javaName, varTree, \"Setter for variable:\");\n+            int dims = Utils.dimensions(varTree.type()).size();\n+            if (dims > 0) {\n+                IndexList indexList = IndexList.of(dims);\n+                emitGlobalArrayGetter(holderClass, indexList, javaName, varTree, \"Indexed getter for variable:\");\n+                emitGlobalArraySetter(holderClass, indexList, javaName, varTree, \"Indexed setter for variable:\");\n+            }\n@@ -63,3 +68,2 @@\n-            String segmentConstant = emitGlobalSegment(layoutVar, javaName, nativeName);\n-            emitGlobalGetter(segmentConstant, layoutVar, javaName, varTree, \"Getter for variable:\");\n-            emitGlobalSetter(segmentConstant, layoutVar, javaName, varTree, \"Setter for variable:\");\n+            emitGlobalGetter(holderClass, javaName, varTree, \"Getter for variable:\");\n+            emitGlobalSetter(holderClass, javaName, varTree, \"Setter for variable:\");\n@@ -140,1 +144,0 @@\n-        String getterName = mangleName(javaName, MethodHandle.class);\n@@ -147,0 +150,1 @@\n+            String holderClass = STR.\"\\{javaName}$constants\";\n@@ -149,3 +153,2 @@\n-                private static MethodHandle \\{getterName}() {\n-                    class Holder {\n-                        static final FunctionDescriptor DESC = \\{functionDescriptorString(2, decl.type())};\n+                private static class \\{holderClass} {\n+                    public static final FunctionDescriptor DESC = \\{functionDescriptorString(1, decl.type())};\n@@ -153,1 +156,1 @@\n-                        static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(\n@@ -156,2 +159,0 @@\n-                    }\n-                    return Holder.MH;\n@@ -160,13 +161,12 @@\n-                appendBlankLine();\n-                emitDocComment(decl);\n-                appendLines(STR.\"\"\"\n-                public static \\{retType} \\{javaName}(\\{paramExprs(declType, finalParamNames, isVarArg)}) {\n-                    var mh$ = \\{getterName}();\n-                    try {\n-                        if (TRACE_DOWNCALLS) {\n-                            traceDowncall(\\{traceArgList});\n-                        }\n-                        \\{returnWithCast}mh$.invokeExact(\\{paramList});\n-                    } catch (Throwable ex$) {\n-                       throw new AssertionError(\"should not reach here\", ex$);\n-                    }\n+            appendBlankLine();\n+            emitDocComment(decl, \"Function descriptor for:\");\n+            appendLines(STR.\"\"\"\n+                public static FunctionDescriptor \\{javaName}$descriptor() {\n+                    return \\{holderClass}.DESC;\n+                }\n+                \"\"\");\n+            appendBlankLine();\n+            emitDocComment(decl, \"Downcall method handle for:\");\n+            appendLines(STR.\"\"\"\n+                public static MethodHandle \\{javaName}$handle() {\n+                    return \\{holderClass}.HANDLE;\n@@ -175,0 +175,14 @@\n+            emitDocComment(decl);\n+            appendLines(STR.\"\"\"\n+            public static \\{retType} \\{javaName}(\\{paramExprs(declType, finalParamNames, isVarArg)}) {\n+                var mh$ = \\{holderClass}.HANDLE;\n+                try {\n+                    if (TRACE_DOWNCALLS) {\n+                        traceDowncall(\\{traceArgList});\n+                    }\n+                    \\{returnWithCast}mh$.invokeExact(\\{paramList});\n+                } catch (Throwable ex$) {\n+                   throw new AssertionError(\"should not reach here\", ex$);\n+                }\n+            }\n+            \"\"\");\n@@ -312,1 +326,1 @@\n-    private void emitGlobalGetter(String segmentConstant, String layoutVar, String javaName,\n+    private void emitGlobalGetter(String holderClass, String javaName,\n@@ -320,1 +334,1 @@\n-                return \\{segmentConstant}.get(\\{layoutVar}, 0L);\n+                return \\{holderClass}.SEGMENT.get(\\{holderClass}.LAYOUT, 0L);\n@@ -326,1 +340,1 @@\n-    private void emitGlobalSetter(String segmentConstant, String layoutVar, String javaName,\n+    private void emitGlobalSetter(String holderClass, String javaName,\n@@ -333,2 +347,2 @@\n-            public static void \\{javaName}(\\{type.getSimpleName()} x) {\n-                \\{segmentConstant}.set(\\{layoutVar}, 0L, x);\n+            public static void \\{javaName}(\\{type.getSimpleName()} varValue) {\n+                \\{holderClass}.SEGMENT.set(\\{holderClass}.LAYOUT, 0L, varValue);\n@@ -340,1 +354,1 @@\n-    private void emitGlobalSegmentGetter(String segmentConstant, String layoutVar, String javaName,\n+    private void emitGlobalSegmentGetter(String holderClass, String javaName,\n@@ -347,1 +361,1 @@\n-                return \\{segmentConstant};\n+                return \\{holderClass}.SEGMENT;\n@@ -353,1 +367,1 @@\n-    private void emitGlobalSegmentSetter(String segmentConstant, String layoutVar, String javaName,\n+    private void emitGlobalSegmentSetter(String holderClass, String javaName,\n@@ -360,1 +374,1 @@\n-                MemorySegment.copy(varValue, 0L, \\{segmentConstant}, 0L, \\{layoutVar}.byteSize());\n+                MemorySegment.copy(varValue, 0L, \\{holderClass}.SEGMENT, 0L, \\{holderClass}.LAYOUT.byteSize());\n@@ -366,3 +380,26 @@\n-    public String emitGlobalSegment(String layout, String javaName, String nativeName) {\n-        String mangledName = mangleName(javaName, MemorySegment.class);\n-        appendIndentedLines(STR.\"\"\"\n+    private void emitGlobalArrayGetter(String holderClass, IndexList indexList,\n+                                       String javaName, Declaration.Variable varTree, String docHeader) {\n+        Type elemType = Utils.typeOrElemType(varTree.type());\n+        Class<?> typeCls = Utils.carrierFor(elemType);\n+        appendBlankLine();\n+        incrAlign();\n+        emitDocComment(varTree, docHeader);\n+        if (Utils.isStructOrUnion(elemType)) {\n+            appendLines(STR.\"\"\"\n+                public static MemorySegment \\{javaName}(\\{indexList.decl()}) {\n+                    try {\n+                        return (MemorySegment)\\{holderClass}.HANDLE.invokeExact(\\{holderClass}.SEGMENT, 0L, \\{indexList.use()});\n+                    } catch (Throwable ex$) {\n+                        throw new AssertionError(\"should not reach here\", ex$);\n+                    }\n+                }\n+                \"\"\");\n+        } else {\n+            appendLines(STR.\"\"\"\n+                public static \\{typeCls.getSimpleName()} \\{javaName}(\\{indexList.decl()}) {\n+                    return (\\{typeCls.getSimpleName()})\\{holderClass}.HANDLE.get(\\{holderClass}.SEGMENT, 0L, \\{indexList.use()});\n+                }\n+                \"\"\");\n+        }\n+        decrAlign();\n+    }\n@@ -370,4 +407,11 @@\n-            private static MemorySegment \\{mangledName}() {\n-                class Holder {\n-                    static final MemorySegment SEGMENT = \\{runtimeHelperName()}.findOrThrow(\"\\{nativeName}\")\n-                        .reinterpret(\\{layout}.byteSize());\n+    private void emitGlobalArraySetter(String holderClass, IndexList indexList,\n+                                       String javaName, Declaration.Variable varTree, String docHeader) {\n+        Type elemType = Utils.typeOrElemType(varTree.type());\n+        Class<?> typeCls = Utils.carrierFor(elemType);\n+        appendBlankLine();\n+        incrAlign();\n+        emitDocComment(varTree, docHeader);\n+        if (Utils.isStructOrUnion(elemType)) {\n+            appendLines(STR.\"\"\"\n+                public static void \\{javaName}(\\{indexList.decl()}, MemorySegment varValue) {\n+                    MemorySegment.copy(varValue, 0L, \\{javaName}(\\{indexList.use()}), 0L, \\{layoutString(elemType)}.byteSize());\n@@ -375,4 +419,9 @@\n-                return Holder.SEGMENT;\n-            }\n-            \"\"\");\n-        return STR.\"\\{mangledName}()\";\n+                \"\"\");\n+        } else {\n+            appendLines(STR.\"\"\"\n+                public static void \\{javaName}(\\{indexList.decl()}, \\{typeCls.getSimpleName()} varValue) {\n+                    \\{holderClass}.HANDLE.set(\\{holderClass}.SEGMENT, 0L, \\{indexList.use()}, varValue);\n+                }\n+                \"\"\");\n+        }\n+        decrAlign();\n@@ -381,2 +430,3 @@\n-    private String emitVarLayout(Type varType, String javaName) {\n-        String mangledName = mangleName(javaName, MemoryLayout.class);\n+    private String emitVarHolderClass(Declaration.Variable var, String javaName) {\n+        Type varType = var.type();\n+        String mangledName = STR.\"\\{javaName}$constants\";\n@@ -384,4 +434,17 @@\n-        appendIndentedLines(STR.\"\"\"\n-            private static \\{layoutType} \\{mangledName}() {\n-                class Holder {\n-                    static final \\{layoutType} LAYOUT = \\{layoutString(varType)};\n+        if (varType instanceof Type.Array) {\n+            List<Long> dimensions = Utils.dimensions(varType);\n+            String path = IntStream.range(0, dimensions.size())\n+                    .mapToObj(_ -> \"sequenceElement()\")\n+                    .collect(Collectors.joining(\", \"));\n+            Type elemType = Utils.typeOrElemType(varType);\n+            String accessHandle = Utils.isStructOrUnion(elemType) ?\n+                    STR.\"public static final MethodHandle HANDLE = LAYOUT.sliceHandle(\\{path});\" :\n+                    STR.\"public static final VarHandle HANDLE = LAYOUT.varHandle(\\{path});\\n\";\n+            String dimsString = dimensions.stream().map(d -> d.toString())\n+                    .collect(Collectors.joining(\", \"));\n+            appendIndentedLines(STR.\"\"\"\n+                private static class \\{mangledName} {\n+                    public static final \\{layoutType} LAYOUT = \\{layoutString(varType)};\n+                    public static final MemorySegment SEGMENT = \\{runtimeHelperName()}.findOrThrow(\"\\{var.name()}\").reinterpret(LAYOUT.byteSize());\n+                    \\{accessHandle}\n+                    public static final long[] DIMS = { \\{dimsString} };\n@@ -389,4 +452,37 @@\n-                return Holder.LAYOUT;\n-            }\n-            \"\"\");\n-        return STR.\"\\{mangledName}()\";\n+                \"\"\");\n+        } else {\n+            appendIndentedLines(STR.\"\"\"\n+                private static class \\{mangledName} {\n+                    public static final \\{layoutType} LAYOUT = \\{layoutString(varType)};\n+                    public static final MemorySegment SEGMENT = \\{runtimeHelperName()}.findOrThrow(\"\\{var.name()}\").reinterpret(LAYOUT.byteSize());\n+                }\n+                \"\"\");\n+        }\n+        incrAlign();\n+        appendBlankLine();\n+        emitDocComment(var, \"Layout for variable:\");\n+        appendLines(STR.\"\"\"\n+                public static \\{layoutType} \\{javaName}$layout() {\n+                    return \\{mangledName}.LAYOUT;\n+                }\n+                \"\"\");\n+        if (!Utils.isStructOrUnion(varType) && !Utils.isArray(varType)) {\n+            appendBlankLine();\n+            emitDocComment(var, \"Segment for variable:\");\n+            appendLines(STR.\"\"\"\n+                    public static MemorySegment \\{javaName}$segment() {\n+                        return \\{mangledName}.SEGMENT;\n+                    }\n+                    \"\"\");\n+        }\n+        if (varType instanceof Type.Array) {\n+            appendBlankLine();\n+            emitDocComment(var, \"Dimensions for array variable:\");\n+            appendLines(STR.\"\"\"\n+                public static long[] \\{javaName}$dimensions() {\n+                    return \\{mangledName}.DIMS;\n+                }\n+                \"\"\");\n+        }\n+        decrAlign();\n+        return mangledName;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":155,"deletions":59,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.stream.IntStream;\n@@ -136,1 +137,2 @@\n-        String offsetField = emitOffsetFieldDecl(varTree);\n+        String layoutField = emitLayoutFieldDecl(varTree, javaName);\n+        String offsetField = emitOffsetFieldDecl(varTree, javaName);\n@@ -138,3 +140,10 @@\n-            String sizeField = emitSizeFieldDecl(varTree);\n-            emitSegmentGetter(javaName, varTree, offsetField, sizeField);\n-            emitSegmentSetter(javaName, varTree, offsetField, sizeField);\n+            emitDimensionsFieldDecl(varTree, javaName);\n+            emitSegmentGetter(javaName, varTree, offsetField, layoutField);\n+            emitSegmentSetter(javaName, varTree, offsetField, layoutField);\n+            int dims = Utils.dimensions(varTree.type()).size();\n+            if (dims > 0) {\n+                String arrayHandle = emitArrayElementHandle(javaName, varTree, layoutField, dims);\n+                IndexList indexList = IndexList.of(dims);\n+                emitFieldArrayGetter(javaName, varTree, arrayHandle, indexList);\n+                emitFieldArraySetter(javaName, varTree, arrayHandle, indexList);\n+            }\n@@ -142,1 +151,0 @@\n-            String layoutField = emitLayoutFieldDecl(varTree);\n@@ -202,1 +210,1 @@\n-    private void emitSegmentGetter(String javaName, Declaration.Variable varTree, String offsetField, String sizeField) {\n+    private void emitSegmentGetter(String javaName, Declaration.Variable varTree, String offsetField, String layoutField) {\n@@ -208,1 +216,1 @@\n-                return \\{segmentParam}.asSlice(\\{offsetField}, \\{sizeField});\n+                return \\{segmentParam}.asSlice(\\{offsetField}, \\{layoutField}.byteSize());\n@@ -213,1 +221,1 @@\n-    private void emitSegmentSetter(String javaName, Declaration.Variable varTree, String offsetField, String sizeField) {\n+    private void emitSegmentSetter(String javaName, Declaration.Variable varTree, String offsetField, String layoutField) {\n@@ -220,1 +228,1 @@\n-                MemorySegment.copy(\\{valueParam}, 0L, \\{segmentParam}, \\{offsetField}, \\{sizeField});\n+                MemorySegment.copy(\\{valueParam}, 0L, \\{segmentParam}, \\{offsetField}, \\{layoutField}.byteSize());\n@@ -225,0 +233,65 @@\n+    private String emitArrayElementHandle(String javaName, Declaration.Variable varTree, String fieldLayoutName, int dims) {\n+        String arrayHandleName = STR.\"\\{javaName}$ELEM_HANDLE\";\n+        String path = IntStream.range(0, dims)\n+                .mapToObj(_ -> \"sequenceElement()\")\n+                .collect(Collectors.joining(\", \"));\n+        Type elemType = Utils.typeOrElemType(varTree.type());\n+        if (Utils.isStructOrUnion(elemType)) {\n+            appendIndentedLines(STR.\"\"\"\n+                private static final MethodHandle \\{arrayHandleName} = \\{fieldLayoutName}.sliceHandle(\\{path});\n+                \"\"\");\n+        } else {\n+            appendIndentedLines(STR.\"\"\"\n+                private static final VarHandle \\{arrayHandleName} = \\{fieldLayoutName}.varHandle(\\{path});\n+                \"\"\");\n+        }\n+        return arrayHandleName;\n+    }\n+\n+    private void emitFieldArrayGetter(String javaName, Declaration.Variable varTree, String arrayElementHandle, IndexList indexList) {\n+        String segmentParam = safeParameterName(kindName());\n+        Type elemType = Utils.typeOrElemType(varTree.type());\n+        Class<?> elemTypeCls = Utils.carrierFor(elemType);\n+        appendBlankLine();\n+        emitFieldDocComment(varTree, \"Indexed getter for field:\");\n+        if (Utils.isStructOrUnion(elemType)) {\n+            appendIndentedLines(STR.\"\"\"\n+                public static MemorySegment \\{javaName}(MemorySegment \\{segmentParam}, \\{indexList.decl()}) {\n+                    try {\n+                        return (MemorySegment)\\{arrayElementHandle}.invokeExact(\\{segmentParam}, 0L, \\{indexList.use()});\n+                    } catch (Throwable ex$) {\n+                        throw new AssertionError(\"should not reach here\", ex$);\n+                    }\n+                }\n+                \"\"\");\n+        } else {\n+            appendIndentedLines(STR.\"\"\"\n+                public static \\{elemTypeCls.getSimpleName()} \\{javaName}(MemorySegment \\{segmentParam}, \\{indexList.decl()}) {\n+                    return (\\{elemTypeCls.getSimpleName()})\\{arrayElementHandle}.get(\\{segmentParam}, 0L, \\{indexList.use()});\n+                }\n+                \"\"\");\n+        }\n+    }\n+\n+    private void emitFieldArraySetter(String javaName, Declaration.Variable varTree, String arrayElementHandle, IndexList indexList) {\n+        String segmentParam = safeParameterName(kindName());\n+        String valueParam = safeParameterName(\"fieldValue\");\n+        Type elemType = Utils.typeOrElemType(varTree.type());\n+        Class<?> elemTypeCls = Utils.carrierFor(elemType);\n+        appendBlankLine();\n+        emitFieldDocComment(varTree, \"Indexed setter for field:\");\n+        if (Utils.isStructOrUnion(elemType)) {\n+            appendIndentedLines(STR.\"\"\"\n+                public static void \\{javaName}(MemorySegment \\{segmentParam}, \\{indexList.decl()}, MemorySegment \\{valueParam}) {\n+                    MemorySegment.copy(\\{valueParam}, 0L, \\{javaName}(\\{segmentParam}, \\{indexList.use()}), 0L, \\{layoutString(elemType)}.byteSize());\n+                }\n+                \"\"\");\n+        } else {\n+            appendIndentedLines(STR.\"\"\"\n+                public static void \\{javaName}(MemorySegment \\{segmentParam}, \\{indexList.decl()}, \\{elemTypeCls.getSimpleName()} \\{valueParam}) {\n+                    \\{arrayElementHandle}.set(\\{segmentParam}, 0L, \\{indexList.use()}, \\{valueParam});\n+                }\n+                \"\"\");\n+        }\n+    }\n+\n@@ -312,2 +385,2 @@\n-    private String emitOffsetFieldDecl(Declaration field) {\n-        String offsetFieldName = STR.\"\\{field.name()}$OFFSET\";\n+    private String emitOffsetFieldDecl(Declaration.Variable field, String javaName) {\n+        String offsetFieldName = STR.\"\\{javaName}$OFFSET\";\n@@ -317,0 +390,7 @@\n+        appendBlankLine();\n+        emitFieldDocComment(field, \"Offset for field:\");\n+        appendIndentedLines(STR.\"\"\"\n+            public static final long \\{javaName}$offset() {\n+                return \\{offsetFieldName};\n+            }\n+            \"\"\");\n@@ -320,2 +400,2 @@\n-    private String emitLayoutFieldDecl(Declaration.Variable field) {\n-        String layoutFieldName = STR.\"\\{field.name()}$LAYOUT\";\n+    private String emitLayoutFieldDecl(Declaration.Variable field, String javaName) {\n+        String layoutFieldName = STR.\"\\{javaName}$LAYOUT\";\n@@ -326,0 +406,7 @@\n+        appendBlankLine();\n+        emitFieldDocComment(field, \"Layout for field:\");\n+        appendIndentedLines(STR.\"\"\"\n+            public static final \\{layoutType} \\{javaName}$layout() {\n+                return \\{layoutFieldName};\n+            }\n+            \"\"\");\n@@ -329,2 +416,5 @@\n-    private String emitSizeFieldDecl(Declaration field) {\n-        String sizeFieldName = STR.\"\\{field.name()}$SIZE\";\n+    private void emitDimensionsFieldDecl(Declaration.Variable field, String javaName) {\n+        String dimsFieldName = STR.\"\\{javaName}$DIMS\";\n+        List<Long> dimensions = Utils.dimensions(field.type());\n+        String dimsString = dimensions.stream().map(d -> d.toString())\n+                .collect(Collectors.joining(\", \"));\n@@ -332,1 +422,9 @@\n-            private static final long \\{sizeFieldName} = \\{ClangSizeOf.getOrThrow(field) \/ 8};\n+\n+            private static long[] \\{dimsFieldName} = { \\{dimsString} };\n+            \"\"\");\n+        appendBlankLine();\n+        emitFieldDocComment(field, \"Dimensions for array field:\");\n+        appendIndentedLines(STR.\"\"\"\n+            public static long[] \\{javaName}$dimensions() {\n+                return \\{dimsFieldName};\n+            }\n@@ -334,1 +432,0 @@\n-        return sizeFieldName;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructBuilder.java","additions":114,"deletions":17,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -186,0 +188,17 @@\n+    static List<Long> dimensions(Type type) {\n+        List<Long> dims = new ArrayList<>();\n+        while (type instanceof Type.Array array) {\n+            if (array.elementCount().isEmpty()) return List.of();\n+            dims.add(array.elementCount().getAsLong());\n+            type = array.elementType();\n+        }\n+        return dims;\n+    }\n+\n+    static Type typeOrElemType(Type type) {\n+        return switch (type) {\n+            case Type.Array array -> typeOrElemType(array.elementType());\n+            default -> type;\n+        };\n+    }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Utils.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+import test.jextract.arrayaccess.*;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+\n+import static test.jextract.arrayaccess.array_access_h.*;\n+\n+\/*\n+ * @test\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -l ArrayAccess -t test.jextract.arrayaccess array_access.h\n+ * @build TestArrayAccess\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestArrayAccess\n+ *\/\n+\n+public class TestArrayAccess {\n+    @Test\n+    public void testArrayAccessStructInt1() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment foo = Foo.allocate(arena);\n+            long[] dims = Foo.ints1$dimensions();\n+            for (int i = 0 ; i < dims[0] ; i++) {\n+                Foo.ints1(foo, i, i + 1);\n+                assertEquals(Foo.ints1(foo, i), i + 1);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessStructInt2() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment foo = Foo.allocate(arena);\n+            long[] dims = Foo.ints2$dimensions();\n+            for (int i = 0 ; i < dims[0] ; i++) {\n+                for (int j = 0; j < dims[1]; j++) {\n+                    Foo.ints2(foo, i, j, i + j + 1);\n+                    assertEquals(Foo.ints2(foo, i, j), i + j + 1);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessStructInt3() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment foo = Foo.allocate(arena);\n+            long[] dims = Foo.ints3$dimensions();\n+            for (int i = 0 ; i < dims[0] ; i++) {\n+                for (int j = 0; j < dims[1]; j++) {\n+                    for (int k = 0; k < dims[2]; k++) {\n+                        Foo.ints3(foo, i, j, k, i + j + k + 1);\n+                        assertEquals(Foo.ints3(foo, i, j, k), i + j + k + 1);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessGlobalInt1() {\n+        long[] dims = ints1$dimensions();\n+        for (int i = 0 ; i < dims[0] ; i++) {\n+            ints1(i, i + 1);\n+            assertEquals(ints1(i), i + 1);\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessGlobalInt2() {\n+        long[] dims = ints2$dimensions();\n+        for (int i = 0 ; i < dims[0] ; i++) {\n+            for (int j = 0; j < dims[1]; j++) {\n+                ints2(i, j, i + j + 1);\n+                assertEquals(ints2(i, j), i + j + 1);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessGlobalInt3() {\n+        long[] dims = ints3$dimensions();\n+        for (int i = 0 ; i < dims[0] ; i++) {\n+            for (int j = 0; j < dims[1]; j++) {\n+                for (int k = 0; k < dims[2]; k++) {\n+                    ints3(i, j, k, i + j + k + 1);\n+                    assertEquals(ints3(i, j, k), i + j + k + 1);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessStructStruct1() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment foo = Foo.allocate(arena);\n+            long[] dims = Foo.points1$dimensions();\n+            for (int i = 0 ; i < dims[0] ; i++) {\n+                MemorySegment point = Point.allocate(arena);\n+                Point.x(point, i + 1);\n+                Point.y(point, i + 2);\n+                Foo.points1(foo, i, point);\n+                assertEquals(Point.x(Foo.points1(foo, i)), i + 1);\n+                assertEquals(Point.y(Foo.points1(foo, i)), i + 2);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessStructStruct2() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment foo = Foo.allocate(arena);\n+            long[] dims = Foo.points2$dimensions();\n+            for (int i = 0 ; i < dims[0] ; i++) {\n+                for (int j = 0; j < dims[1]; j++) {\n+                    MemorySegment point = Point.allocate(arena);\n+                    Point.x(point, i + j + 1);\n+                    Point.y(point, i + j + 2);\n+                    Foo.points2(foo, i, j, point);\n+                    assertEquals(Point.x(Foo.points2(foo, i, j)), i + j + 1);\n+                    assertEquals(Point.y(Foo.points2(foo, i, j)), i + j + 2);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessStructStruct3() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment foo = Foo.allocate(arena);\n+            long[] dims = Foo.points3$dimensions();\n+            for (int i = 0 ; i < dims[0] ; i++) {\n+                for (int j = 0; j < dims[1]; j++) {\n+                    for (int k = 0; k < dims[2]; k++) {\n+                        MemorySegment point = Point.allocate(arena);\n+                        Point.x(point, i + j + k + 1);\n+                        Point.y(point, i + j + k + 2);\n+                        Foo.points3(foo, i, j, k, point);\n+                        assertEquals(Point.x(Foo.points3(foo, i, j, k)), i + j + k + 1);\n+                        assertEquals(Point.y(Foo.points3(foo, i, j, k)), i + j + k + 2);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessGlobalStruct1() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            long[] dims = points1$dimensions();\n+            for (int i = 0; i < dims[0]; i++) {\n+                MemorySegment point = Point.allocate(arena);\n+                Point.x(point, i + 1);\n+                Point.y(point, i + 2);\n+                points1(i, point);\n+                assertEquals(Point.x(points1(i)), i + 1);\n+                assertEquals(Point.y(points1(i)), i + 2);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessGlobalStruct2() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            long[] dims = points2$dimensions();\n+            for (int i = 0; i < dims[0]; i++) {\n+                for (int j = 0; j < dims[1]; j++) {\n+                    MemorySegment point = Point.allocate(arena);\n+                    Point.x(point, i + j + 1);\n+                    Point.y(point, i + j + 2);\n+                    points2(i, j, point);\n+                    assertEquals(Point.x(points2(i, j)), i + j + 1);\n+                    assertEquals(Point.y(points2(i, j)), i + j + 2);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessGlobalStruct3() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            long[] dims = points3$dimensions();\n+            for (int i = 0 ; i < dims[0] ; i++) {\n+                for (int j = 0; j < dims[1]; j++) {\n+                    for (int k = 0; k < dims[2]; k++) {\n+                        MemorySegment point = Point.allocate(arena);\n+                        Point.x(point, i + j + k + 1);\n+                        Point.y(point, i + j + k + 2);\n+                        points3(i, j, k, point);\n+                        assertEquals(Point.x(points3(i, j, k)), i + j + k + 1);\n+                        assertEquals(Point.y(points3(i, j, k)), i + j + k + 2);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jtreg\/generator\/arrayAccess\/TestArrayAccess.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+struct Point {\n+    int x;\n+    int y;\n+};\n+\n+\/\/ array fields in struct\n+\n+struct Foo {\n+    struct Point points1[2];\n+    struct Point points2[2][3];\n+    struct Point points3[2][3][4];\n+\n+    int ints1[2];\n+    int ints2[2][3];\n+    int ints3[2][3][4];\n+};\n+\n+\/\/ array global vars\n+\n+extern struct Point points1[2];\n+extern struct Point points2[2][3];\n+extern struct Point points3[2][3][4];\n+\n+extern int ints1[2];\n+extern int ints2[2][3];\n+extern int ints3[2][3][4];\n","filename":"test\/jtreg\/generator\/arrayAccess\/array_access.h","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"array_access.h\"\n+\n+EXPORT struct Point points1[2];\n+EXPORT struct Point points2[2][3];\n+EXPORT struct Point points3[2][3][4];\n+\n+EXPORT int ints1[2];\n+EXPORT int ints2[2][3];\n+EXPORT int ints3[2][3][4];\n","filename":"test\/jtreg\/generator\/arrayAccess\/libArrayAccess.c","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -174,4 +174,4 @@\n-            Field offsetField = findField(structCls, memberName + \"$OFFSET\");\n-            assertNotNull(offsetField);\n-            assertEquals(offsetField.getType(), long.class);\n-            assertEquals(offsetField.get(null), structLayout.byteOffset(PathElement.groupElement(memberName)));\n+            Method offsetMethod = findMethod(structCls, memberName + \"$offset\");\n+            assertNotNull(offsetMethod);\n+            assertEquals(offsetMethod.getReturnType(), long.class);\n+            assertEquals(offsetMethod.invoke(null), structLayout.byteOffset(PathElement.groupElement(memberName)));\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/TestClassGeneration.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-        assertEquals(comments, List.of(\n+        assertContains(comments, List.of(\n@@ -83,0 +83,1 @@\n+            \"Indexed getter for variable: int abc[10]\",\n@@ -84,0 +85,1 @@\n+            \"Indexed setter for variable: int abc[10]\",\n@@ -85,0 +87,1 @@\n+            \"Indexed getter for variable: float numbers[3]\",\n@@ -86,0 +89,1 @@\n+            \"Indexed setter for variable: float numbers[3]\",\n@@ -87,0 +91,1 @@\n+            \"Indexed getter for variable: char *msg[5]\",\n@@ -88,0 +93,1 @@\n+            \"Indexed setter for variable: char *msg[5]\",\n@@ -89,0 +95,1 @@\n+            \"Indexed getter for variable: int pixels[200][100]\",\n@@ -90,0 +97,1 @@\n+            \"Indexed setter for variable: int pixels[200][100]\",\n@@ -91,1 +99,3 @@\n-            \"Setter for variable: int points[10][20][30]\"));\n+            \"Indexed getter for variable: int points[10][20][30]\",\n+            \"Setter for variable: int points[10][20][30]\",\n+            \"Indexed setter for variable: int points[10][20][30]\"));\n@@ -140,1 +150,1 @@\n-        assertEquals(comments, List.of(\n+        assertContains(comments, List.of(\n@@ -143,0 +153,2 @@\n+            \"Layout for variable: int abc\",\n+            \"Segment for variable: int abc\",\n@@ -144,1 +156,3 @@\n-            \"Setter for variable: char *msg\"\n+            \"Setter for variable: char *msg\",\n+            \"Layout for variable: char *msg\",\n+            \"Segment for variable: char *msg\"\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/docComments\/TestDocComments.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"}]}