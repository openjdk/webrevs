{"files":[{"patch":"@@ -43,0 +43,1 @@\n+import java.util.List;\n@@ -45,0 +46,1 @@\n+import java.util.stream.IntStream;\n@@ -269,0 +271,12 @@\n+\n+    record IndexList(String decl, String use) {\n+        static IndexList of(int dims) {\n+            List<String> indexNames = IntStream.range(0, dims).mapToObj(i -> \"index\" + i).toList();\n+            String indexDecls = indexNames.stream()\n+                    .map(i -> \"long \" + i)\n+                    .collect(Collectors.joining(\", \"));\n+            String indexUses = indexNames.stream()\n+                    .collect(Collectors.joining(\", \"));\n+            return new IndexList(indexDecls, indexUses);\n+        }\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ClassSourceBuilder.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n@@ -62,0 +64,7 @@\n+            int dims = Utils.dimensions(varTree.type());\n+            if (dims > 0) {\n+                String arrayHandle = emitArrayElementHandle(javaName, varTree, layoutVar, dims);\n+                IndexList indexList = IndexList.of(dims);\n+                emitGlobalArrayGetter(segmentConstant, arrayHandle, indexList, javaName, varTree, \"Indexed getter for variable:\");\n+                emitGlobalArraySetter(segmentConstant, arrayHandle, indexList, javaName, varTree, \"Indexed setter for variable:\");\n+            }\n@@ -333,2 +342,2 @@\n-            public static void \\{javaName}(\\{type.getSimpleName()} x) {\n-                \\{segmentConstant}.set(\\{layoutVar}, 0L, x);\n+            public static void \\{javaName}(\\{type.getSimpleName()} varValue) {\n+                \\{segmentConstant}.set(\\{layoutVar}, 0L, varValue);\n@@ -381,0 +390,80 @@\n+    private String emitArrayElementHandle(String javaName, Declaration.Variable varTree, String fieldLayoutName, int dims) {\n+        String arrayHandleName = STR.\"\\{javaName}$ELEM_HANDLE\";\n+        String path = IntStream.range(0, dims)\n+                .mapToObj(_ -> \"sequenceElement()\")\n+                .collect(Collectors.joining(\", \"));\n+        Type elemType = Utils.typeOrElemType(varTree.type());\n+        if (Utils.isStructOrUnion(elemType)) {\n+            appendIndentedLines(STR.\"\"\"\n+\n+                private static MethodHandle \\{arrayHandleName}() {\n+                    class Holder {\n+                        static final MethodHandle HANDLE = \\{fieldLayoutName}.sliceHandle(\\{path});\n+                    }\n+                    return Holder.HANDLE;\n+                }\n+                \"\"\");\n+        } else {\n+            appendIndentedLines(STR.\"\"\"\n+\n+                private static VarHandle \\{arrayHandleName}() {\n+                    class Holder {\n+                        static final VarHandle HANDLE = \\{fieldLayoutName}.varHandle(\\{path});\n+                    }\n+                    return Holder.HANDLE;\n+                }\n+                \"\"\");\n+        }\n+        return STR.\"\\{arrayHandleName}()\";\n+    }\n+\n+    private void emitGlobalArrayGetter(String segmentConstant, String arrayElementHandle, IndexList indexList,\n+                                       String javaName, Declaration.Variable varTree, String docHeader) {\n+        Type elemType = Utils.typeOrElemType(varTree.type());\n+        Class<?> typeCls = Utils.carrierFor(elemType);\n+        appendBlankLine();\n+        incrAlign();\n+        emitDocComment(varTree, docHeader);\n+        if (Utils.isStructOrUnion(elemType)) {\n+            appendLines(STR.\"\"\"\n+                public static MemorySegment \\{javaName}(\\{indexList.decl()}) {\n+                    try {\n+                        return (MemorySegment)\\{arrayElementHandle}.invokeExact(\\{segmentConstant}, 0L, \\{indexList.use()});\n+                    } catch (Throwable ex$) {\n+                        throw new AssertionError(\"should not reach here\", ex$);\n+                    }\n+                }\n+                \"\"\");\n+        } else {\n+            appendLines(STR.\"\"\"\n+                public static \\{typeCls.getSimpleName()} \\{javaName}(\\{indexList.decl()}) {\n+                    return (\\{typeCls.getSimpleName()})\\{arrayElementHandle}.get(\\{segmentConstant}, 0L, \\{indexList.use()});\n+                }\n+                \"\"\");\n+        }\n+        decrAlign();\n+    }\n+\n+    private void emitGlobalArraySetter(String segmentConstant, String arrayElementHandle, IndexList indexList,\n+                                       String javaName, Declaration.Variable varTree, String docHeader) {\n+        Type elemType = Utils.typeOrElemType(varTree.type());\n+        Class<?> typeCls = Utils.carrierFor(elemType);\n+        appendBlankLine();\n+        incrAlign();\n+        emitDocComment(varTree, docHeader);\n+        if (Utils.isStructOrUnion(elemType)) {\n+            appendLines(STR.\"\"\"\n+                public static void \\{javaName}(\\{indexList.decl()}, MemorySegment varValue) {\n+                    MemorySegment.copy(varValue, 0L, \\{javaName}(\\{indexList.use()}), 0L, \\{layoutString(elemType)}.byteSize());\n+                }\n+                \"\"\");\n+        } else {\n+            appendLines(STR.\"\"\"\n+                public static void \\{javaName}(\\{indexList.decl()}, \\{typeCls.getSimpleName()} varValue) {\n+                    \\{arrayElementHandle}.set(\\{segmentConstant}, 0L, \\{indexList.use()}, varValue);\n+                }\n+                \"\"\");\n+        }\n+        decrAlign();\n+    }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":91,"deletions":2,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.stream.IntStream;\n@@ -136,0 +137,1 @@\n+        String layoutField = emitLayoutFieldDecl(varTree);\n@@ -138,3 +140,9 @@\n-            String sizeField = emitSizeFieldDecl(varTree);\n-            emitSegmentGetter(javaName, varTree, offsetField, sizeField);\n-            emitSegmentSetter(javaName, varTree, offsetField, sizeField);\n+            emitSegmentGetter(javaName, varTree, offsetField, layoutField);\n+            emitSegmentSetter(javaName, varTree, offsetField, layoutField);\n+            int dims = Utils.dimensions(varTree.type());\n+            if (dims > 0) {\n+                String arrayHandle = emitArrayElementHandle(javaName, varTree, layoutField, dims);\n+                IndexList indexList = IndexList.of(dims);\n+                emitFieldArrayGetter(javaName, varTree, arrayHandle, indexList);\n+                emitFieldArraySetter(javaName, varTree, arrayHandle, indexList);\n+            }\n@@ -142,1 +150,0 @@\n-            String layoutField = emitLayoutFieldDecl(varTree);\n@@ -202,1 +209,1 @@\n-    private void emitSegmentGetter(String javaName, Declaration.Variable varTree, String offsetField, String sizeField) {\n+    private void emitSegmentGetter(String javaName, Declaration.Variable varTree, String offsetField, String layoutField) {\n@@ -208,1 +215,1 @@\n-                return \\{segmentParam}.asSlice(\\{offsetField}, \\{sizeField});\n+                return \\{segmentParam}.asSlice(\\{offsetField}, \\{layoutField}.byteSize());\n@@ -213,1 +220,1 @@\n-    private void emitSegmentSetter(String javaName, Declaration.Variable varTree, String offsetField, String sizeField) {\n+    private void emitSegmentSetter(String javaName, Declaration.Variable varTree, String offsetField, String layoutField) {\n@@ -220,1 +227,1 @@\n-                MemorySegment.copy(\\{valueParam}, 0L, \\{segmentParam}, \\{offsetField}, \\{sizeField});\n+                MemorySegment.copy(\\{valueParam}, 0L, \\{segmentParam}, \\{offsetField}, \\{layoutField}.byteSize());\n@@ -225,0 +232,65 @@\n+    private String emitArrayElementHandle(String javaName, Declaration.Variable varTree, String fieldLayoutName, int dims) {\n+        String arrayHandleName = STR.\"\\{javaName}$ELEM_HANDLE\";\n+        String path = IntStream.range(0, dims)\n+                        .mapToObj(_ -> \"sequenceElement()\")\n+                        .collect(Collectors.joining(\", \"));\n+        Type elemType = Utils.typeOrElemType(varTree.type());\n+        if (Utils.isStructOrUnion(elemType)) {\n+            appendIndentedLines(STR.\"\"\"\n+                private static final MethodHandle \\{arrayHandleName} = \\{fieldLayoutName}.sliceHandle(\\{path});\n+                \"\"\");\n+        } else {\n+            appendIndentedLines(STR.\"\"\"\n+                private static final VarHandle \\{arrayHandleName} = \\{fieldLayoutName}.varHandle(\\{path});\n+                \"\"\");\n+        }\n+        return arrayHandleName;\n+    }\n+\n+    private void emitFieldArrayGetter(String javaName, Declaration.Variable varTree, String arrayElementHandle, IndexList indexList) {\n+        String segmentParam = safeParameterName(kindName());\n+        Type elemType = Utils.typeOrElemType(varTree.type());\n+        Class<?> elemTypeCls = Utils.carrierFor(elemType);\n+        appendBlankLine();\n+        emitFieldDocComment(varTree, \"Indexed getter for field:\");\n+        if (Utils.isStructOrUnion(elemType)) {\n+            appendIndentedLines(STR.\"\"\"\n+                public static MemorySegment \\{javaName}(MemorySegment \\{segmentParam}, \\{indexList.decl()}) {\n+                    try {\n+                        return (MemorySegment)\\{arrayElementHandle}.invokeExact(\\{segmentParam}, 0L, \\{indexList.use()});\n+                    } catch (Throwable ex$) {\n+                        throw new AssertionError(\"should not reach here\", ex$);\n+                    }\n+                }\n+                \"\"\");\n+        } else {\n+            appendIndentedLines(STR.\"\"\"\n+                public static \\{elemTypeCls.getSimpleName()} \\{javaName}(MemorySegment \\{segmentParam}, \\{indexList.decl()}) {\n+                    return (\\{elemTypeCls.getSimpleName()})\\{arrayElementHandle}.get(\\{segmentParam}, 0L, \\{indexList.use()});\n+                }\n+                \"\"\");\n+        }\n+    }\n+\n+    private void emitFieldArraySetter(String javaName, Declaration.Variable varTree, String arrayElementHandle, IndexList indexList) {\n+        String segmentParam = safeParameterName(kindName());\n+        String valueParam = safeParameterName(\"fieldValue\");\n+        Type elemType = Utils.typeOrElemType(varTree.type());\n+        Class<?> elemTypeCls = Utils.carrierFor(elemType);\n+        appendBlankLine();\n+        emitFieldDocComment(varTree, \"Indexed setter for field:\");\n+        if (Utils.isStructOrUnion(elemType)) {\n+            appendIndentedLines(STR.\"\"\"\n+                public static void \\{javaName}(MemorySegment \\{segmentParam}, \\{indexList.decl()}, MemorySegment \\{valueParam}) {\n+                    MemorySegment.copy(\\{valueParam}, 0L, \\{javaName}(\\{segmentParam}, \\{indexList.use()}), 0L, \\{layoutString(elemType)}.byteSize());\n+                }\n+                \"\"\");\n+        } else {\n+            appendIndentedLines(STR.\"\"\"\n+                public static void \\{javaName}(MemorySegment \\{segmentParam}, \\{indexList.decl()}, \\{elemTypeCls.getSimpleName()} \\{valueParam}) {\n+                    \\{arrayElementHandle}.set(\\{segmentParam}, 0L, \\{indexList.use()}, \\{valueParam});\n+                }\n+                \"\"\");\n+        }\n+    }\n+\n@@ -329,8 +401,0 @@\n-    private String emitSizeFieldDecl(Declaration field) {\n-        String sizeFieldName = STR.\"\\{field.name()}$SIZE\";\n-        appendIndentedLines(STR.\"\"\"\n-            private static final long \\{sizeFieldName} = \\{ClangSizeOf.getOrThrow(field) \/ 8};\n-            \"\"\");\n-        return sizeFieldName;\n-    }\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructBuilder.java","additions":80,"deletions":16,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -186,0 +186,14 @@\n+    static int dimensions(Type type) {\n+        return switch (type) {\n+            case Type.Array array -> 1 + dimensions(array.elementType());\n+            default -> 0;\n+        };\n+    }\n+\n+    static Type typeOrElemType(Type type) {\n+        return switch (type) {\n+            case Type.Array array -> typeOrElemType(array.elementType());\n+            default -> type;\n+        };\n+    }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Utils.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,211 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+import test.jextract.arrayaccess.*;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+\n+import static test.jextract.arrayaccess.array_access_h.*;\n+\n+\/*\n+ * @test\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -l ArrayAccess -t test.jextract.arrayaccess array_access.h\n+ * @build TestArrayAccess\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestArrayAccess\n+ *\/\n+\n+public class TestArrayAccess {\n+    @Test\n+    public void testArrayAccessStructInt1() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment foo = Foo.allocate(arena);\n+            for (int i = 0 ; i < 2 ; i++) {\n+                Foo.ints1(foo, i, i + 1);\n+                assertEquals(Foo.ints1(foo, i), i + 1);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessStructInt2() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment foo = Foo.allocate(arena);\n+            for (int i = 0 ; i < 2 ; i++) {\n+                for (int j = 0; j < 2; j++) {\n+                    Foo.ints2(foo, i, j, i + j + 1);\n+                    assertEquals(Foo.ints2(foo, i, j), i + j + 1);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessStructInt3() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment foo = Foo.allocate(arena);\n+            for (int i = 0 ; i < 2 ; i++) {\n+                for (int j = 0; j < 2; j++) {\n+                    for (int k = 0; k < 2; k++) {\n+                        Foo.ints3(foo, i, j, k, i + j + k + 1);\n+                        assertEquals(Foo.ints3(foo, i, j, k), i + j + k + 1);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessGlobalInt1() {\n+        for (int i = 0 ; i < 2 ; i++) {\n+            ints1(i, i + 1);\n+            assertEquals(ints1(i), i + 1);\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessGlobalInt2() {\n+        for (int i = 0 ; i < 2 ; i++) {\n+            for (int j = 0; j < 2; j++) {\n+                ints2(i, j, i + j + 1);\n+                assertEquals(ints2(i, j), i + j + 1);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessGlobalInt3() {\n+        for (int i = 0 ; i < 2 ; i++) {\n+            for (int j = 0; j < 2; j++) {\n+                for (int k = 0; k < 2; k++) {\n+                    ints3(i, j, k, i + j + k + 1);\n+                    assertEquals(ints3(i, j, k), i + j + k + 1);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessStructStruct1() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment foo = Foo.allocate(arena);\n+            for (int i = 0 ; i < 2 ; i++) {\n+                MemorySegment point = Point.allocate(arena);\n+                Point.x(point, i + 1);\n+                Point.y(point, i + 2);\n+                Foo.points1(foo, i, point);\n+                assertEquals(Point.x(Foo.points1(foo, i)), i + 1);\n+                assertEquals(Point.y(Foo.points1(foo, i)), i + 2);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessStructStruct2() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment foo = Foo.allocate(arena);\n+            for (int i = 0 ; i < 2 ; i++) {\n+                for (int j = 0; j < 2; j++) {\n+                    MemorySegment point = Point.allocate(arena);\n+                    Point.x(point, i + j + 1);\n+                    Point.y(point, i + j + 2);\n+                    Foo.points2(foo, i, j, point);\n+                    assertEquals(Point.x(Foo.points2(foo, i, j)), i + j + 1);\n+                    assertEquals(Point.y(Foo.points2(foo, i, j)), i + j + 2);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessStructStruct3() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment foo = Foo.allocate(arena);\n+            for (int i = 0 ; i < 2 ; i++) {\n+                for (int j = 0; j < 2; j++) {\n+                    for (int k = 0; k < 2; k++) {\n+                        MemorySegment point = Point.allocate(arena);\n+                        Point.x(point, i + j + k + 1);\n+                        Point.y(point, i + j + k + 2);\n+                        Foo.points3(foo, i, j, k, point);\n+                        assertEquals(Point.x(Foo.points3(foo, i, j, k)), i + j + k + 1);\n+                        assertEquals(Point.y(Foo.points3(foo, i, j, k)), i + j + k + 2);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessGlobalStruct1() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            for (int i = 0; i < 2; i++) {\n+                MemorySegment point = Point.allocate(arena);\n+                Point.x(point, i + 1);\n+                Point.y(point, i + 2);\n+                points1(i, point);\n+                assertEquals(Point.x(points1(i)), i + 1);\n+                assertEquals(Point.y(points1(i)), i + 2);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessGlobalStruct2() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            for (int i = 0; i < 2; i++) {\n+                for (int j = 0; j < 2; j++) {\n+                    MemorySegment point = Point.allocate(arena);\n+                    Point.x(point, i + j + 1);\n+                    Point.y(point, i + j + 2);\n+                    points2(i, j, point);\n+                    assertEquals(Point.x(points2(i, j)), i + j + 1);\n+                    assertEquals(Point.y(points2(i, j)), i + j + 2);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayAccessGlobalStruct3() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            for (int i = 0 ; i < 2 ; i++) {\n+                for (int j = 0; j < 2; j++) {\n+                    for (int k = 0; k < 2; k++) {\n+                        MemorySegment point = Point.allocate(arena);\n+                        Point.x(point, i + j + k + 1);\n+                        Point.y(point, i + j + k + 2);\n+                        points3(i, j, k, point);\n+                        assertEquals(Point.x(points3(i, j, k)), i + j + k + 1);\n+                        assertEquals(Point.y(points3(i, j, k)), i + j + k + 2);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jtreg\/generator\/arrayAccess\/TestArrayAccess.java","additions":211,"deletions":0,"binary":false,"changes":211,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+struct Point {\n+    int x;\n+    int y;\n+};\n+\n+\/\/ array fields in struct\n+\n+struct Foo {\n+    struct Point points1[2];\n+    struct Point points2[2][2];\n+    struct Point points3[2][2][2];\n+\n+    int ints1[2];\n+    int ints2[2][2];\n+    int ints3[2][2][2];\n+};\n+\n+\/\/ array global vars\n+\n+extern struct Point points1[2];\n+extern struct Point points2[2][2];\n+extern struct Point points3[2][2][2];\n+\n+extern int ints1[2];\n+extern int ints2[2][2];\n+extern int ints3[2][2][2];\n","filename":"test\/jtreg\/generator\/arrayAccess\/array_access.h","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"array_access.h\"\n+\n+EXPORT struct Point points1[2];\n+EXPORT struct Point points2[2][2];\n+EXPORT struct Point points3[2][2][2];\n+\n+EXPORT int ints1[2];\n+EXPORT int ints2[2][2];\n+EXPORT int ints3[2][2][2];\n","filename":"test\/jtreg\/generator\/arrayAccess\/libArrayAccess.c","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -81,1 +81,1 @@\n-        assertEquals(comments, List.of(\n+        assertContains(comments, List.of(\n@@ -83,0 +83,1 @@\n+            \"Indexed getter for variable: int abc[10]\",\n@@ -84,0 +85,1 @@\n+            \"Indexed setter for variable: int abc[10]\",\n@@ -85,0 +87,1 @@\n+            \"Indexed getter for variable: float numbers[3]\",\n@@ -86,0 +89,1 @@\n+            \"Indexed setter for variable: float numbers[3]\",\n@@ -87,0 +91,1 @@\n+            \"Indexed getter for variable: char *msg[5]\",\n@@ -88,0 +93,1 @@\n+            \"Indexed setter for variable: char *msg[5]\",\n@@ -89,0 +95,1 @@\n+            \"Indexed getter for variable: int pixels[200][100]\",\n@@ -90,0 +97,1 @@\n+            \"Indexed setter for variable: int pixels[200][100]\",\n@@ -91,1 +99,3 @@\n-            \"Setter for variable: int points[10][20][30]\"));\n+            \"Indexed getter for variable: int points[10][20][30]\",\n+            \"Setter for variable: int points[10][20][30]\",\n+            \"Indexed setter for variable: int points[10][20][30]\"));\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/docComments\/TestDocComments.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"}]}