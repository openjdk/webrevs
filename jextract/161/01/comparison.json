{"files":[{"patch":"@@ -62,1 +62,1 @@\n-        if (type instanceof Type.Declared declared && Utils.isEnum(declared)) {\n+        if (Utils.declarationFor(type).map(Utils::isEnum).orElse(false)) {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/EnumConstantLifter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -188,3 +188,1 @@\n-        if (typedef.type() instanceof Type.Declared declared) {\n-            declared.tree().accept(this, typedef);\n-        }\n+        Utils.declarationFor(typedef.type()).ifPresent(s -> s.accept(this, typedef));\n@@ -208,4 +206,1 @@\n-        if (type instanceof Type.Declared declared) {\n-            \/\/ declared type - visit declaration recursively\n-            declared.tree().accept(this, variable);\n-        }\n+        Utils.declarationFor(type).ifPresent(s -> s.accept(this, variable));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/NameMangler.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -146,4 +146,5 @@\n-        if (type instanceof Type.Declared declared) {\n-            Declaration.Scoped s = declared.tree();\n-            if (!s.name().equals(tree.name())) {\n-                switch (s.kind()) {\n+        Optional<Declaration.Scoped> optScoped = Utils.declarationFor(type);\n+        if (optScoped.isPresent()) {\n+            Declaration.Scoped scoped = optScoped.get();\n+            if (!scoped.name().equals(tree.name())) {\n+                switch (scoped.kind()) {\n@@ -151,2 +152,2 @@\n-                        if (s.name().isEmpty()) {\n-                            visitScoped(s, tree);\n+                        if (scoped.name().isEmpty()) {\n+                            visitScoped(scoped, tree);\n@@ -165,1 +166,1 @@\n-                            toplevelBuilder.addTypedef(tree, JavaName.getFullNameOrThrow(s));\n+                            toplevelBuilder.addTypedef(tree, JavaName.getFullNameOrThrow(scoped));\n@@ -168,1 +169,1 @@\n-                    default -> visitScoped(s, tree);\n+                    default -> visitScoped(scoped, tree);\n@@ -196,4 +197,1 @@\n-        if (type instanceof Type.Declared declared) {\n-            \/\/ declared type - visit declaration recursively\n-            declared.tree().accept(this, tree);\n-        }\n+        Utils.declarationFor(type).ifPresent(s -> s.accept(this, tree));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -101,4 +101,1 @@\n-        if (type instanceof Type.Declared declared) {\n-            \/\/ declared type - visit declaration recursively\n-            declared.tree().accept(this, varTree);\n-        }\n+        Utils.declarationFor(type).ifPresent(s -> s.accept(this, varTree));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnsupportedFilter.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Optional;\n@@ -108,0 +109,9 @@\n+    static Optional<Declaration.Scoped> declarationFor(Type type) {\n+        return switch (type) {\n+            case Type.Declared declared -> Optional.of(declared.tree());\n+            case Type.Array array -> declarationFor(array.elementType());\n+            case Delegated delegated when delegated.kind() != Kind.POINTER -> declarationFor(delegated.type());\n+            default -> Optional.empty();\n+        };\n+    }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Utils.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.SequenceLayout;\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+import test.jextract.nestedtypes.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.nestedtypes nested_types.h\n+ * @build TestNestedTypes\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNestedTypes\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library \/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.nestedtypes nested_types.h\n+ * @build TestNestedTypes\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNestedTypes\n+ *\/\n+public class TestNestedTypes {\n+\n+    @Test\n+    public void testNestedTypes() {\n+        checkNestedLayout(NestedStructArray.$LAYOUT());\n+        checkNestedLayout(NestedStructArrayTypedef.$LAYOUT());\n+        checkNestedLayout(NestedStructArrayTypedefTypedef.$LAYOUT());\n+    }\n+\n+    void checkNestedLayout(MemoryLayout layout) {\n+        MemoryLayout nestedLayout = ((GroupLayout)layout).memberLayouts().get(0);\n+        assertEquals(nestedLayout.name().get(), \"nested\");\n+        assertTrue(nestedLayout instanceof SequenceLayout);\n+        assertEquals(((SequenceLayout)nestedLayout).elementCount(), 1);\n+        assertEquals(((SequenceLayout)nestedLayout).elementLayout().withoutName(), ELEM_NESTED_LAYOUT);\n+    }\n+\n+    static final MemoryLayout ELEM_NESTED_LAYOUT = MemoryLayout.structLayout(nested_types_h.C_INT.withName(\"x\"));\n+}\n","filename":"test\/jtreg\/generator\/nestedTypes\/TestNestedTypes.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct NestedStructArray {\n+    struct {\n+        int x;\n+    } nested[1];\n+};\n+\n+typedef struct {\n+    int x;\n+} T;\n+\n+struct NestedStructArrayTypedef {\n+    T nested[1];\n+};\n+\n+typedef T U;\n+\n+struct NestedStructArrayTypedefTypedef {\n+    U nested[1];\n+};\n","filename":"test\/jtreg\/generator\/nestedTypes\/nested_types.h","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"}]}