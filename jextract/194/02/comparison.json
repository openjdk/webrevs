{"files":[{"patch":"@@ -137,4 +137,3 @@\n-        String returnExpr = \"\";\n-        if (!declType.returnType().equals(void.class)) {\n-            returnExpr = STR.\"return (\\{retType}) \";\n-        }\n+        boolean isVoid = declType.returnType().equals(void.class);\n+        String returnNoCast = isVoid ? \"\" : STR.\"return \";\n+        String returnWithCast = isVoid ? \"\" : STR.\"\\{returnNoCast}(\\{retType})\";\n@@ -170,1 +169,1 @@\n-                        \\{returnExpr}mh$.invokeExact(\\{paramList});\n+                        \\{returnWithCast}mh$.invokeExact(\\{paramList});\n@@ -177,2 +176,0 @@\n-            String invokerName = javaName + \"$invoker\";\n-            String invokerFactoryName = javaName + \"$makeInvoker\";\n@@ -180,0 +177,3 @@\n+            String varargsParam = finalParamNames.get(finalParamNames.size() - 1);\n+            appendBlankLine();\n+            emitDocComment(decl, \"Variadic invoker interface for:\");\n@@ -181,2 +181,10 @@\n-                public interface \\{invokerName} {\n-                    \\{retType} \\{javaName}(\\{paramExprs});\n+                public interface \\{javaName} {\n+                    \\{retType} apply(\\{paramExprs});\n+\n+                    \/**\n+                     * Invoke the variadic function with the given parameters. Layouts for variadic arguments are inferred.\n+                     *\/\n+                    static \\{retType} invoke(\\{paramExprs}) {\n+                        MemoryLayout[] inferredLayouts$ = \\{runtimeHelperName()}.inferVariadicLayouts(\\{varargsParam});\n+                        \\{returnNoCast}\\{javaName}(inferredLayouts$).apply(\\{String.join(\", \", finalParamNames)});\n+                    }\n@@ -186,1 +194,1 @@\n-            emitDocComment(decl);\n+            emitDocComment(decl, \"Variadic invoker factory for:\");\n@@ -188,1 +196,1 @@\n-                public static \\{invokerName} \\{invokerFactoryName}(MemoryLayout... layouts) {\n+                public static \\{javaName} \\{javaName}(MemoryLayout... layouts) {\n@@ -196,1 +204,1 @@\n-                            \\{returnExpr}mh$.invokeExact(\\{paramList});\n+                            \\{returnWithCast}mh$.invokeExact(\\{paramList});\n@@ -205,8 +213,0 @@\n-                \"\"\");\n-            emitDocComment(decl);\n-            String varargsParam = finalParamNames.get(finalParamNames.size() - 1);\n-            appendLines(STR.\"\"\"\n-                public static \\{retType} \\{javaName}(\\{paramExprs}) {\n-                    MemoryLayout[] inferredLayouts$ = \\{runtimeHelperName()}.inferVariadicLayouts(\\{varargsParam});\n-                    \\{returnExpr}\\{invokerFactoryName}(inferredLayouts$).\\{javaName}(\\{String.join(\", \", finalParamNames)});\n-                }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-            my_sprintf(s, arena.allocateFrom(fmt), args.length, args);\n+            my_sprintf.invoke(s, arena.allocateFrom(fmt), args.length, args);\n@@ -59,2 +59,2 @@\n-            my_sprintf$makeInvoker(layouts)\n-                .my_sprintf(s, arena.allocateFrom(fmt), args.length, args);\n+            my_sprintf(layouts)\n+                    .apply(s, arena.allocateFrom(fmt), args.length, args);\n@@ -70,2 +70,2 @@\n-            my_sprintf$makeInvoker(layouts)\n-                .my_sprintf(s, arena.allocateFrom(fmt), args.length, args); \/\/ should throw\n+            my_sprintf(layouts)\n+                    .apply(s, arena.allocateFrom(fmt), args.length, args); \/\/ should throw\n@@ -78,1 +78,1 @@\n-        my_sprintf$makeInvoker(layouts); \/\/ should throw\n+        my_sprintf(layouts); \/\/ should throw\n","filename":"test\/jtreg\/generator\/testPrintf\/TestPrintf.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -114,8 +114,1 @@\n-            \/\/ check a method for \"void func(int)\"\n-            assertNotNull(findMethod(cls, \"func\", int.class));\n-            \/\/ check a method for \"int printf(MemorySegment, Object[])\"\n-            assertNotNull(findMethod(cls, \"printf\", MemorySegment.class, Object[].class));\n-            \/\/ check an interface for printf$invoker\n-            assertNotNull(findNestedClass(cls, \"printf$invoker\"));\n-            \/\/ check a method for \"printf$makeInvoker printf$makeInvoker(MemoryLayout...)\"\n-            assertNotNull(findMethod(cls, \"printf$makeInvoker\", MemoryLayout[].class));\n+            checkHeaderMembers(cls);\n@@ -127,0 +120,12 @@\n+    private static void checkHeaderMembers(Class<?> header) {\n+        \/\/ check a method for \"void func(int)\"\n+        assertNotNull(findMethod(header, \"func\", int.class));\n+        \/\/ check a method for \"printf(MemoryLayout...)\"\n+        assertNotNull(findMethod(header, \"printf\", MemoryLayout[].class));\n+        \/\/ check an interface for printf$invoker\n+        Class<?> invokerCls = findNestedClass(header, \"printf\");\n+        assertNotNull(invokerCls);\n+        \/\/ check a method for \"int printf(MemorySegment, Object[])\"\n+        assertNotNull(findMethod(invokerCls, \"invoke\", MemorySegment.class, Object[].class));\n+    }\n+\n@@ -147,8 +152,1 @@\n-            \/\/ check a method for \"void func(int)\"\n-            assertNotNull(findMethod(cls, \"func\", int.class));\n-            \/\/ check a method for \"int printf(MemorySegment, Object[])\"\n-            assertNotNull(findMethod(cls, \"printf\", MemorySegment.class, Object[].class));\n-            \/\/ check an interface for printf$invoker\n-            assertNotNull(findNestedClass(cls, \"printf$invoker\"));\n-            \/\/ check a method for \"printf$makeInvoker printf$makeInvoker(MemoryLayout...)\"\n-            assertNotNull(findMethod(cls, \"printf$makeInvoker\", MemoryLayout[].class));\n+            checkHeaderMembers(cls);\n@@ -177,8 +175,1 @@\n-            \/\/ check a method for \"void func(int)\"\n-            assertNotNull(findMethod(cls, \"func\", int.class));\n-            \/\/ check a method for \"int printf(MemorySegment, Object[])\"\n-            assertNotNull(findMethod(cls, \"printf\", MemorySegment.class, Object[].class));\n-            \/\/ check an interface for printf$invoker\n-            assertNotNull(findNestedClass(cls, \"printf$invoker\"));\n-            \/\/ check a method for \"printf$makeInvoker printf$makeInvoker(MemoryLayout...)\"\n-            assertNotNull(findMethod(cls, \"printf$makeInvoker\", MemoryLayout[].class));\n+            checkHeaderMembers(cls);\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/JextractToolProviderTest.java","additions":15,"deletions":24,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-        assertEquals(comments, List.of(\n+        assertContains(comments, List.of(\n@@ -100,2 +100,1 @@\n-            \"int printf(char *fmt, ...)\",\n-            \"int printf(char *fmt, ...)\"));\n+            \"Variadic invoker factory for: int printf(char *fmt, ...)\"));\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/docComments\/TestDocComments.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}