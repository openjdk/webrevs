{"files":[{"patch":"@@ -213,0 +213,1 @@\n+            \"-retain:fail,error\",\n","filename":"build.gradle","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -149,3 +149,0 @@\n-        String factoryName = isVarArg ?\n-                \"downcallHandleVariadic\" :\n-                \"downcallHandle\";\n@@ -153,0 +150,1 @@\n+        if (!isVarArg) {\n@@ -159,1 +157,1 @@\n-                    static final MethodHandle MH = RuntimeHelper.\\{factoryName}(\\\"\\{nativeName}\\\", DESC);\n+                    static final MethodHandle MH = RuntimeHelper.downcallHandle(\\\"\\{nativeName}\\\", DESC);\n@@ -173,0 +171,38 @@\n+        } else {\n+            String invokerName = javaName + \"$invoker\";\n+            String invokerFactoryName = javaName + \"$makeInvoker\";\n+            String paramExprs = paramExprs(declType, finalParamNames, isVarArg);\n+            appendLines(STR.\"\"\"\n+                public interface \\{invokerName} {\n+                    \\{retType} \\{javaName}(\\{paramExprs});\n+                }\n+\n+                \"\"\");\n+            emitDocComment(decl);\n+            appendLines(STR.\"\"\"\n+                public static \\{invokerName} \\{invokerFactoryName}(MemoryLayout... layouts) {\n+                    class Holder {\n+                        static final FunctionDescriptor BASE_DESC = \\{descriptorString(2, descriptor)};\n+                    }\n+                    var mh$ = RuntimeHelper.downcallHandleVariadic(\"\\{nativeName}\", Holder.BASE_DESC, layouts);\n+                    return (\\{paramExprs}) -> {\n+                        try {\n+                            \\{returnExpr}mh$.invokeExact(\\{String.join(\", \", finalParamNames)});\n+                        } catch(IllegalArgumentException ex$)  {\n+                            throw ex$; \/\/ rethrow IAE from passing wrong number\/type of args\n+                        } catch (Throwable ex$) {\n+                           throw new AssertionError(\"should not reach here\", ex$);\n+                        }\n+                    };\n+                }\n+\n+                \"\"\");\n+            emitDocComment(decl);\n+            String varargsParam = finalParamNames.get(finalParamNames.size() - 1);\n+            appendLines(STR.\"\"\"\n+                public static \\{retType} \\{javaName}(\\{paramExprs}) {\n+                    MemoryLayout[] inferredLayouts$ = RuntimeHelper.inferVariadicLayouts(\\{varargsParam});\n+                    \\{returnExpr}\\{invokerFactoryName}(inferredLayouts$).\\{javaName}(\\{String.join(\", \", finalParamNames)});\n+                }\n+                \"\"\");\n+        }\n@@ -205,1 +241,1 @@\n-            case Short, Int, Long, LongLong, Float, Double, Char -> true;\n+            case Bool, Short, Int, Long, LongLong, Float, Double, Char -> true;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":41,"deletions":5,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -73,4 +73,15 @@\n-    static MethodHandle downcallHandleVariadic(String name, FunctionDescriptor fdesc) {\n-        return SYMBOL_LOOKUP.find(name).\n-                map(addr -> VarargsInvoker.make(addr, fdesc)).\n-                orElse(null);\n+    static MethodHandle downcallHandleVariadic(String name, FunctionDescriptor baseDesc, MemoryLayout[] variadicLayouts) {\n+        FunctionDescriptor variadicDesc = baseDesc.appendArgumentLayouts(variadicLayouts);\n+        Linker.Option fva = Linker.Option.firstVariadicArg(baseDesc.argumentLayouts().size());\n+        return SYMBOL_LOOKUP.find(name)\n+                .map(addr -> LINKER.downcallHandle(addr, variadicDesc, fva)\n+                        .asSpreader(Object[].class, variadicLayouts.length))\n+                .orElse(null);\n+    }\n+\n+    static MemoryLayout[] inferVariadicLayouts(Object[] varargs) {\n+        MemoryLayout[] result = new MemoryLayout[varargs.length];\n+        for (int i = 0; i < varargs.length; i++) {\n+            result[i] = variadicLayout(normalize(varargs[i].getClass()));\n+        }\n+        return result;\n@@ -102,84 +113,21 @@\n-    private static final class VarargsInvoker {\n-        private static final MethodHandle INVOKE_MH;\n-        private final MemorySegment symbol;\n-        private final FunctionDescriptor function;\n-\n-        private VarargsInvoker(MemorySegment symbol, FunctionDescriptor function) {\n-            this.symbol = symbol;\n-            this.function = function;\n-        }\n-\n-        static {\n-            try {\n-                INVOKE_MH = MethodHandles.lookup().findVirtual(VarargsInvoker.class, \"invoke\", MethodType.methodType(Object.class, SegmentAllocator.class, Object[].class));\n-            } catch (ReflectiveOperationException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        static MethodHandle make(MemorySegment symbol, FunctionDescriptor function) {\n-            VarargsInvoker invoker = new VarargsInvoker(symbol, function);\n-            MethodHandle handle = INVOKE_MH.bindTo(invoker).asCollector(Object[].class, function.argumentLayouts().size() + 1);\n-            MethodType mtype = MethodType.methodType(function.returnLayout().isPresent() ? carrier(function.returnLayout().get(), true) : void.class);\n-            for (MemoryLayout layout : function.argumentLayouts()) {\n-                mtype = mtype.appendParameterTypes(carrier(layout, false));\n-            }\n-            mtype = mtype.appendParameterTypes(Object[].class);\n-            boolean needsAllocator = function.returnLayout().isPresent() &&\n-                                function.returnLayout().get() instanceof GroupLayout;\n-            if (needsAllocator) {\n-                mtype = mtype.insertParameterTypes(0, SegmentAllocator.class);\n-            } else {\n-                handle = MethodHandles.insertArguments(handle, 0, THROWING_ALLOCATOR);\n-            }\n-            return handle.asType(mtype);\n-        }\n-\n-        static Class<?> carrier(MemoryLayout layout, boolean ret) {\n-            if (layout instanceof ValueLayout valueLayout) {\n-                return valueLayout.carrier();\n-            } else if (layout instanceof GroupLayout) {\n-                return MemorySegment.class;\n-            } else {\n-                throw new AssertionError(\"Cannot get here!\");\n-            }\n-        }\n-\n-        private Object invoke(SegmentAllocator allocator, Object[] args) throws Throwable {\n-            \/\/ one trailing Object[]\n-            int nNamedArgs = function.argumentLayouts().size();\n-            assert(args.length == nNamedArgs + 1);\n-            \/\/ The last argument is the array of vararg collector\n-            Object[] unnamedArgs = (Object[]) args[args.length - 1];\n-\n-            int argsCount = nNamedArgs + unnamedArgs.length;\n-            Class<?>[] argTypes = new Class<?>[argsCount];\n-            MemoryLayout[] argLayouts = new MemoryLayout[nNamedArgs + unnamedArgs.length];\n-\n-            int pos = 0;\n-            for (pos = 0; pos < nNamedArgs; pos++) {\n-                argLayouts[pos] = function.argumentLayouts().get(pos);\n-            }\n-\n-            assert pos == nNamedArgs;\n-            for (Object o: unnamedArgs) {\n-                argLayouts[pos] = variadicLayout(normalize(o.getClass()));\n-                pos++;\n-            }\n-            assert pos == argsCount;\n-\n-            FunctionDescriptor f = (function.returnLayout().isEmpty()) ?\n-                    FunctionDescriptor.ofVoid(argLayouts) :\n-                    FunctionDescriptor.of(function.returnLayout().get(), argLayouts);\n-            MethodHandle mh = LINKER.downcallHandle(symbol, f);\n-            boolean needsAllocator = function.returnLayout().isPresent() &&\n-                                            function.returnLayout().get() instanceof GroupLayout;\n-            if (needsAllocator) {\n-                mh = mh.bindTo(allocator);\n-            }\n-            \/\/ flatten argument list so that it can be passed to an asSpreader MH\n-            Object[] allArgs = new Object[nNamedArgs + unnamedArgs.length];\n-            System.arraycopy(args, 0, allArgs, 0, nNamedArgs);\n-            System.arraycopy(unnamedArgs, 0, allArgs, nNamedArgs, unnamedArgs.length);\n-\n-            return mh.asSpreader(Object[].class, argsCount).invoke(allArgs);\n+    private static Class<?> unboxIfNeeded(Class<?> clazz) {\n+        if (clazz == Boolean.class) {\n+            return boolean.class;\n+        } else if (clazz == Void.class) {\n+            return void.class;\n+        } else if (clazz == Byte.class) {\n+            return byte.class;\n+        } else if (clazz == Character.class) {\n+            return char.class;\n+        } else if (clazz == Short.class) {\n+            return short.class;\n+        } else if (clazz == Integer.class) {\n+            return int.class;\n+        } else if (clazz == Long.class) {\n+            return long.class;\n+        } else if (clazz == Float.class) {\n+            return float.class;\n+        } else if (clazz == Double.class) {\n+            return double.class;\n+        } else {\n+            return clazz;\n@@ -187,0 +135,1 @@\n+    }\n@@ -188,22 +137,7 @@\n-        private static Class<?> unboxIfNeeded(Class<?> clazz) {\n-            if (clazz == Boolean.class) {\n-                return boolean.class;\n-            } else if (clazz == Void.class) {\n-                return void.class;\n-            } else if (clazz == Byte.class) {\n-                return byte.class;\n-            } else if (clazz == Character.class) {\n-                return char.class;\n-            } else if (clazz == Short.class) {\n-                return short.class;\n-            } else if (clazz == Integer.class) {\n-                return int.class;\n-            } else if (clazz == Long.class) {\n-                return long.class;\n-            } else if (clazz == Float.class) {\n-                return float.class;\n-            } else if (clazz == Double.class) {\n-                return double.class;\n-            } else {\n-                return clazz;\n-            }\n+    private static Class<?> promote(Class<?> c) {\n+        if (c == byte.class || c == char.class || c == short.class || c == int.class) {\n+            return long.class;\n+        } else if (c == float.class) {\n+            return double.class;\n+        } else {\n+            return c;\n@@ -211,0 +145,1 @@\n+    }\n@@ -212,8 +147,4 @@\n-        private Class<?> promote(Class<?> c) {\n-            if (c == byte.class || c == char.class || c == short.class || c == int.class) {\n-                return long.class;\n-            } else if (c == float.class) {\n-                return double.class;\n-            } else {\n-                return c;\n-            }\n+    private static Class<?> normalize(Class<?> c) {\n+        c = unboxIfNeeded(c);\n+        if (c.isPrimitive()) {\n+            return promote(c);\n@@ -221,10 +152,2 @@\n-\n-        private Class<?> normalize(Class<?> c) {\n-            c = unboxIfNeeded(c);\n-            if (c.isPrimitive()) {\n-                return promote(c);\n-            }\n-            if (MemorySegment.class.isAssignableFrom(c)) {\n-                return MemorySegment.class;\n-            }\n-            throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n+        if (MemorySegment.class.isAssignableFrom(c)) {\n+            return MemorySegment.class;\n@@ -232,0 +155,2 @@\n+        throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n+    }\n@@ -233,10 +158,9 @@\n-        private MemoryLayout variadicLayout(Class<?> c) {\n-            if (c == long.class) {\n-                return JAVA_LONG;\n-            } else if (c == double.class) {\n-                return JAVA_DOUBLE;\n-            } else if (c == MemorySegment.class) {\n-                return ADDRESS;\n-            } else {\n-                throw new IllegalArgumentException(\"Unhandled variadic argument class: \" + c);\n-            }\n+    private static MemoryLayout variadicLayout(Class<?> c) {\n+        if (c == long.class) {\n+            return JAVA_LONG;\n+        } else if (c == double.class) {\n+            return JAVA_DOUBLE;\n+        } else if (c == MemorySegment.class) {\n+            return ADDRESS;\n+        } else {\n+            throw new IllegalArgumentException(\"Unhandled variadic argument class: \" + c);\n","filename":"src\/main\/resources\/org\/openjdk\/jextract\/impl\/resources\/RuntimeHelper.java.template","additions":62,"deletions":138,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-int getpid();\n+int getpid(void);\n","filename":"test.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-    jtreg\/generator\/test8244959\/Test8244959.java \\\n+    jtreg\/generator\/testPrintf\/TestPrintf.java \\\n","filename":"test\/TEST.groups","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+ * @build TestFuncPointerInvokers\n@@ -44,1 +45,2 @@\n- * @run main\/othervm JtregJextract -l Func -t test.jextract.funcpointers func.h\n+ * @run main\/othervm JtregJextractSources -l Func -t test.jextract.funcpointers func.h\n+ * @build TestFuncPointerInvokers\n","filename":"test\/jtreg\/generator\/funcPointerInvokers\/TestFuncPointerInvokers.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @build LibTest7903347Test\n@@ -41,0 +42,1 @@\n+ * @build LibTest7903347Test\n","filename":"test\/jtreg\/generator\/test7903347\/LibTest7903347Test.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-  * @library \/lib\n+ * @library \/lib\n@@ -34,0 +34,1 @@\n+ * @build LibTest8239918Test\n@@ -40,1 +41,1 @@\n-  * @library \/lib\n+ * @library \/lib\n@@ -42,0 +43,1 @@\n+ * @build LibTest8239918Test\n","filename":"test\/jtreg\/generator\/test8239918\/LibTest8239918Test.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @build Lib8240373Test\n@@ -44,0 +45,1 @@\n+ * @build Lib8240373Test\n","filename":"test\/jtreg\/generator\/test8240373\/Lib8240373Test.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+ * @build LibTest8244412Test\n@@ -49,0 +50,1 @@\n+ * @build LibTest8244412Test\n","filename":"test\/jtreg\/generator\/test8244412\/LibTest8244412Test.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+ * @build Test8244938\n@@ -46,0 +47,1 @@\n+ * @build Test8244938\n","filename":"test\/jtreg\/generator\/test8244938\/Test8244938.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.foreign.Arena;\n-import org.testng.annotations.Test;\n-\n-import java.lang.foreign.MemorySegment;\n-\n-import static org.testng.Assert.assertEquals;\n-import static test.jextract.printf.printf_h.*;\n-import static java.lang.foreign.Linker.*;\n-\n-\/*\n- * @test id=classes\n- * @bug 8244959\n- * @summary Jextract's VarargsInvoker fails to link functions when passing integer types other than long\n- * @library \/lib\n- * @run main\/othervm JtregJextract -t test.jextract.printf -l Printf printf.h\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8244959\n- *\/\n-\/*\n- * @test id=sources\n- * @bug 8244959\n- * @summary Jextract's VarargsInvoker fails to link functions when passing integer types other than long\n- * @library \/lib\n- * @run main\/othervm JtregJextractSources -t test.jextract.printf -l Printf printf.h\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8244959\n- *\/\n-public class Test8244959 {\n-    @Test\n-    public void testsPrintf() {\n-        try (Arena arena = Arena.ofConfined()) {\n-            MemorySegment s = arena.allocate(1024);\n-            my_sprintf(s,\n-                    arena.allocateFrom(\"%hhd %c %.2f %.2f %lld %lld %d %hd %d %d %lld %c\"), 12,\n-                    (byte) 1, 'b', -1.25f, 5.5d, -200L, Long.MAX_VALUE, (byte) -2, (short) 2, 3, (short) -4, 5L, 'a');\n-            String str = s.getString(0);\n-            assertEquals(str, \"1 b -1.25 5.50 -200 \" + Long.MAX_VALUE + \" -2 2 3 -4 5 a\");\n-        }\n-    }\n-}\n","filename":"test\/jtreg\/generator\/test8244959\/Test8244959.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -38,0 +38,1 @@\n+ * @build Test8245003\n@@ -46,0 +47,1 @@\n+ * @build Test8245003\n","filename":"test\/jtreg\/generator\/test8245003\/Test8245003.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+ * @build LibTest8246341Test\n@@ -46,0 +47,1 @@\n+ * @build LibTest8246341Test\n","filename":"test\/jtreg\/generator\/test8246341\/LibTest8246341Test.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+ * @build LibTest8246400Test\n@@ -46,0 +47,1 @@\n+ * @build LibTest8246400Test\n","filename":"test\/jtreg\/generator\/test8246400\/LibTest8246400Test.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @build LibTest8249757Test\n@@ -42,0 +43,1 @@\n+ * @build LibTest8249757Test\n","filename":"test\/jtreg\/generator\/test8249757\/LibTest8249757Test.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+ * @build Test8252121\n@@ -48,0 +49,1 @@\n+ * @build Test8252121\n","filename":"test\/jtreg\/generator\/test8252121\/Test8252121.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+ * @build LibTest8252465Test\n@@ -46,0 +47,1 @@\n+ * @build LibTest8252465Test\n","filename":"test\/jtreg\/generator\/test8252465\/LibTest8252465Test.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+ * @build LibTest8253102Test\n@@ -47,0 +48,1 @@\n+ * @build LibTest8253102Test\n","filename":"test\/jtreg\/generator\/test8253102\/LibTest8253102Test.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @build LibTest8253390Test\n@@ -42,0 +43,1 @@\n+ * @build LibTest8253390Test\n","filename":"test\/jtreg\/generator\/test8253390\/LibTest8253390Test.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+ * @build LibTest8254983Test\n@@ -46,0 +47,1 @@\n+ * @build LibTest8254983Test\n","filename":"test\/jtreg\/generator\/test8254983\/LibTest8254983Test.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+ * @build LibUnsupportedTest\n@@ -51,0 +52,1 @@\n+ * @build LibUnsupportedTest\n","filename":"test\/jtreg\/generator\/test8257892\/LibUnsupportedTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,2 +44,2 @@\n-EXPORT Foo* getFoo();\n-EXPORT Foo makeFoo();\n+EXPORT Foo* getFoo(void);\n+EXPORT Foo makeFoo(void);\n","filename":"test\/jtreg\/generator\/test8257892\/unsupported.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+ * @build LibTest8258605Test\n@@ -46,0 +47,1 @@\n+ * @build LibTest8258605Test\n","filename":"test\/jtreg\/generator\/test8258605\/LibTest8258605Test.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-EXPORT struct Foo getFoo();\n+EXPORT struct Foo getFoo(void);\n","filename":"test\/jtreg\/generator\/test8258605\/funcParam.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+ * @build LibTest8259473Test\n@@ -46,0 +47,1 @@\n+ * @build LibTest8259473Test\n","filename":"test\/jtreg\/generator\/test8259473\/LibTest8259473Test.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-void func();\n+void func(void);\n","filename":"test\/jtreg\/generator\/test8259473\/test8259473.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+ * @build Test8261511\n@@ -45,0 +46,1 @@\n+ * @build Test8261511\n","filename":"test\/jtreg\/generator\/test8261511\/Test8261511.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-EXPORT struct Foo get_foo();\n+EXPORT struct Foo get_foo(void);\n","filename":"test\/jtreg\/generator\/test8261511\/test8261511.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @build Test8281764\n","filename":"test\/jtreg\/generator\/test8281764\/Test8281764.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @build Test8282235\n@@ -46,1 +47,0 @@\n-\n","filename":"test\/jtreg\/generator\/test8282235\/Test8282235.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @build LibFuncPtrTest\n@@ -41,0 +42,1 @@\n+ * @build LibFuncPtrTest\n","filename":"test\/jtreg\/generator\/testFunctionPointer\/LibFuncPtrTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+ * @build TestGlobalRedefinition\n@@ -42,0 +43,1 @@\n+ * @build TestGlobalRedefinition\n","filename":"test\/jtreg\/generator\/testGlobalRedefinition\/TestGlobalRedefinition.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.foreign.Arena;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.printf.printf_h.*;\n+\n+\/*\n+ * @test id=classes\n+ *\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.printf -l Printf printf.h\n+ * @build TestPrintf\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestPrintf\n+ *\/\n+\/*\n+ * @test id=sources\n+ *\n+ * @library \/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.printf -l Printf printf.h\n+ * @build TestPrintf\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestPrintf\n+ *\/\n+public class TestPrintf {\n+\n+    @Test(dataProvider = \"cases\")\n+    public void testsPrintf(String fmt, Object[] args, String expected, MemoryLayout[] unused) {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment s = arena.allocate(1024);\n+            my_sprintf(s, arena.allocateFrom(fmt), args.length, args);\n+            String str = s.getString(0);\n+            assertEquals(str, expected);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"cases\")\n+    public void testsPrintfInvoker(String fmt, Object[] args, String expected, MemoryLayout[] layouts) {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment s = arena.allocate(1024);\n+            my_sprintf$makeInvoker(layouts)\n+                .my_sprintf(s, arena.allocateFrom(fmt), args.length, args);\n+            String str = s.getString(0);\n+            assertEquals(str, expected);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"wrongArgsCases\", expectedExceptions = IllegalArgumentException.class)\n+    public void testsPrintfInvokerWrongArgs(String fmt, MemoryLayout[] layouts, Object[] args) {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment s = arena.allocate(1024);\n+            my_sprintf$makeInvoker(layouts)\n+                .my_sprintf(s, arena.allocateFrom(fmt), args.length, args); \/\/ should throw\n+        }\n+    }\n+\n+    \/\/ linker does not except unpromoted layouts\n+    @Test(dataProvider = \"illegalLinkCases\", expectedExceptions = IllegalArgumentException.class)\n+    public void testsPrintfInvokerWrongArgs(MemoryLayout[] layouts) {\n+        my_sprintf$makeInvoker(layouts); \/\/ should throw\n+    }\n+\n+    \/\/ data providers:\n+    @DataProvider\n+    public Object[][] cases() {\n+        return new Object[][]{\n+            {\n+                \"%hhd %c %.2f %.2f %lld %lld %d %hd %d %d %lld %c\",\n+                new Object[] {(byte) 1, 'b', -1.25f, 5.5d, -200L, Long.MAX_VALUE, (byte) -2, (short) 2, 3, (short) -4, 5L, 'a' },\n+                \"1 b -1.25 5.50 -200 \" + Long.MAX_VALUE + \" -2 2 3 -4 5 a\",\n+                new MemoryLayout[] { C_INT, C_INT, C_DOUBLE, C_DOUBLE, C_LONG_LONG, C_LONG_LONG, C_INT, C_INT,\n+                        C_INT, C_INT, C_LONG_LONG, C_INT }\n+            }\n+        };\n+    }\n+\n+    @DataProvider\n+    public Object[][] wrongArgsCases() {\n+        return new Object[][] {\n+            {\n+                \"%d\", new MemoryLayout[] {C_INT}, new Object[0], \/\/ too few args\n+                \"%d\", new MemoryLayout[] {C_INT}, new Object[] { 1, 2 }, \/\/ too many args\n+                \"%.2f\", new MemoryLayout[] {C_DOUBLE}, new Object[] { 1 }, \/\/ wrong type\n+            }\n+        };\n+    }\n+\n+    @DataProvider\n+    public static Object[][] illegalLinkCases() {\n+        return new Object[][]{\n+                {new MemoryLayout[]{ C_CHAR }},\n+                {new MemoryLayout[]{ C_SHORT }},\n+                {new MemoryLayout[]{ C_BOOL }},\n+                {new MemoryLayout[]{ C_FLOAT }}\n+        };\n+    }\n+}\n","filename":"test\/jtreg\/generator\/testPrintf\/TestPrintf.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"","filename":"test\/jtreg\/generator\/testPrintf\/libPrintf.c","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jtreg\/generator\/test8244959\/libPrintf.c","status":"renamed"},{"patch":"","filename":"test\/jtreg\/generator\/testPrintf\/printf.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jtreg\/generator\/test8244959\/printf.h","status":"renamed"},{"patch":"@@ -38,0 +38,1 @@\n+ * @build LibStructTest\n@@ -46,0 +47,1 @@\n+ * @build LibStructTest\n","filename":"test\/jtreg\/generator\/testStruct\/LibStructTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -117,0 +118,4 @@\n+            \/\/ check an interface for printf$invoker\n+            assertNotNull(findNestedClass(cls, \"printf$invoker\"));\n+            \/\/ check a method for \"printf$makeInvoker printf$makeInvoker(MemoryLayout...)\"\n+            assertNotNull(findMethod(cls, \"printf$makeInvoker\", MemoryLayout[].class));\n@@ -147,0 +152,4 @@\n+            \/\/ check an interface for printf$invoker\n+            assertNotNull(findNestedClass(cls, \"printf$invoker\"));\n+            \/\/ check a method for \"printf$makeInvoker printf$makeInvoker(MemoryLayout...)\"\n+            assertNotNull(findMethod(cls, \"printf$makeInvoker\", MemoryLayout[].class));\n@@ -174,0 +183,4 @@\n+            \/\/ check an interface for printf$invoker\n+            assertNotNull(findNestedClass(cls, \"printf$invoker\"));\n+            \/\/ check a method for \"printf$makeInvoker printf$makeInvoker(MemoryLayout...)\"\n+            assertNotNull(findMethod(cls, \"printf$makeInvoker\", MemoryLayout[].class));\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/JextractToolProviderTest.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+            \"int printf(char* fmt,...);\",\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903257\/TestDocComments.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}