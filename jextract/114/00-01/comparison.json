{"files":[{"patch":"@@ -3,1 +3,1 @@\n-`jextract` is a tool which mechanically generates Java bindings from a native library headers. This tools leverages the [clang C API](https:\/\/clang.llvm.org\/doxygen\/group__CINDEX.html) in order to parse the headers associated with a given native library, and the generated Java bindings build upon the [Foreign Function & Memory API](https:\/\/openjdk.java.net\/jeps\/424). The `jextract` tool was originally developed in the context of [Project Panama](https:\/\/openjdk.java.net\/projects\/panama\/) (and then made available in the Project Panama [Early Access binaries](https:\/\/jdk.java.net\/panama\/)).\n+`jextract` is a tool which mechanically generates Java bindings from a native library headers. This tools leverages the [clang C API](https:\/\/clang.llvm.org\/doxygen\/group__CINDEX.html) in order to parse the headers associated with a given native library, and the generated Java bindings build upon the [Foreign Function & Memory API](https:\/\/openjdk.java.net\/jeps\/434). The `jextract` tool was originally developed in the context of [Project Panama](https:\/\/openjdk.java.net\/projects\/panama\/) (and then made available in the Project Panama [Early Access binaries](https:\/\/jdk.java.net\/panama\/)).\n@@ -5,1 +5,1 @@\n-### Getting started\n+### Getting jextract\n@@ -7,1 +7,1 @@\n-`jextract` depends on the [C libclang API](https:\/\/clang.llvm.org\/doxygen\/group__CINDEX.html). To build the jextract sources, the easiest option is to download LLVM binaries for your platform, which can be found [here](https:\/\/releases.llvm.org\/download.html) (a version >= 9 is required). Both the `jextract` tool and the bindings it generates depend heavily on the [Foreign Function & Memory API](https:\/\/openjdk.java.net\/jeps\/424), so a suitable build of the [panama\/foreign repository](https:\/\/github.com\/openjdk\/panama-foreign) is also required.\n+Pre-built binaries for jextract are periodically released [here](https:\/\/jdk.java.net\/jextract). These binaries are built from the `master` branch of this repo, and target the foreign memory access and function API in the latest mainline JDK (for which binaries can be found [here](https:\/\/jdk.java.net)).\n@@ -9,42 +9,1 @@\n-> <details><summary><strong>Building older jextract versions<\/strong><\/summary>\n-> \n-> The `master` branch always tracks the latest version of the JDK. If you wish to build an older version of jextract, which targets an earlier version of the JDK you can do so by chercking out the appropriate branch.\n-> For example, to build a jextract tool which works against JDK 18:\n-> \n-> `git checkout jdk18`\n-> \n-> Over time, new branches will be added, each targeting a specific JDK version.\n-> <\/details>\n-\n-`jextract` can be built using `gradle`, as follows (on Windows, `gradlew.bat` should be used instead).\n-\n-(**Note**: Run the Gradle build with a Java version appropriate for the Gradle version. For example, Gradle 7.5.1\n-supports JDK 18. Please checkout the [Gradle compatibility matrix](https:\/\/docs.gradle.org\/current\/userguide\/compatibility.html#java) for the appropate JDK version needed for builds)\n-\n-\n-\n-```sh\n-$ sh .\/gradlew -Pjdk20_home=<jdk20_home_dir> -Pllvm_home=<libclang_dir> clean verify\n-```\n-\n-\n-> <details><summary><strong>Using a local installation of LLVM<\/strong><\/summary>\n-> \n-> While the recommended way is to use a [release from the LLVM project](https:\/\/releases.llvm.org\/download.html),\n-> extract it then make `llvm_home` point to this directory, it may be possible to use a local installation instead.\n->\n-> E.g. on macOs the `llvm_home` can also be set as one of these locations :\n-> \n-> * `\/Library\/Developer\/CommandLineTools\/usr\/` if using Command Line Tools\n-> * `\/Applications\/Xcode.app\/Contents\/Developer\/Toolchains\/XcodeDefault.xctoolchain\/usr\/` if using XCode\n-> * `$(brew --prefix llvm)` if using the [LLVM install from Homebrew](https:\/\/formulae.brew.sh\/formula\/llvm#default)\n-> \n-> <\/details>\n-\n-After building, there should be a new `jextract` folder under `build`.\n-To run the `jextract` tool, simply run the `jextract` command in the `bin` folder:\n-\n-```sh\n-$ build\/jextract\/bin\/jextract\n-Expected a header file\n-```\n+Alternatively, to build jextract from the latest sources (which include all the latest updates and fixes) please refer to the [building](#building--testing) section below.\n@@ -52,7 +11,1 @@\n-The repository also contains a comprehensive set of tests, written using the [jtreg](https:\/\/openjdk.java.net\/jtreg\/) test framework, which can be run as follows (again, on Windows, `gradlew.bat` should be used instead):\n-\n-```sh\n-$ sh .\/gradlew -Pjdk20_home=<jdk20_home_dir> -Pllvm_home=<libclang_dir> -Pjtreg_home=<jtreg_home> jtreg\n-```\n-\n-Note however that running `jtreg` task requires `cmake` to be available on the `PATH`.\n+---\n@@ -89,2 +42,2 @@\n-        try (var arena = Arena.openConfined()) {\n-           MemorySegment point = arena.allocate(Point2d.$LAYOUT());\n+        try (var session = MemorySession.openConfined()) {\n+           MemorySegment point = MemorySegment.allocateNative(Point2d.$LAYOUT(), session);\n@@ -130,4 +83,1 @@\n-The `jextract` tool includes several customization options. Users can select in which package the generated code should be emitted, and what the name of the main extracted class should be. If no package is specified, classes are generated in the unnamed package. If no name is specified for the main header class, then the header class name is\n-derived from the header file name. For example, if jextract is run on foo.h, then foo_h will be the name of the main header class.\n-\n-A complete list of all the supported options is given below:\n+The `jextract` tool includes several customization options. Users can select in which package the generated code should be emitted, and what the name of the main extracted class should be. A complete list of all the supported options is given below:\n@@ -137,5 +87,5 @@\n-| `-D --define-macro <macro>=<value>`                          | define <macro> to <value> (or 1 if <value> omitted)          |\n-| `--header-class-name <name>`                                 | name of the generated header class. If this option is not specified, then header class name is derived from the header file name. For example, class \"foo_h\" for header \"foo.h\". |\n-| `-t, --target-package <package>`                             | target package name for the generated classes. If this option is not specified, then unnamed package is used.  |\n-| `-I, --include-dir <dir>`                                    | append directory to the include search paths. Include search paths are searched in order. For example, if `-I foo -I bar` is specified, header files will be searched in \"foo\" first, then (if nothing is found) in \"bar\".|\n-| `-l, --library <name \\| path>`                               | specify a library by platform-independent name (e.g. \"GL\") or by absolute path (\"\/usr\/lib\/libGL.so\") that will be loaded by the generated class. |\n+| `-D <macro>`                                                 | define a C preprocessor macro                                |\n+| `--header-class-name <name>`                                 | specify the name of the main header class                    |\n+| `-t, --target-package <package>`                             | specify target package for the generated bindings            |\n+| `-I <path>`                                                  | specify include files path for the clang parser              |\n+| `-l <library>`                                               | specify a library that will be loaded by the generated bindings |\n@@ -145,1 +95,1 @@\n-| `--include-[function,constant,struct,union,typedef,var]<String>` | Include a symbol of the given name and kind in the generated bindings (see below). When one of these options is specified, any symbol that is not matched by any specified filters is omitted from the generated bindings. |\n+| `--include-[function,macro,struct,union,typedef,var]<String>` | Include a symbol of the given name and kind in the generated bindings (see below). When one of these options is specified, any symbol that is not matched by any specified filters is omitted from the generated bindings. |\n@@ -159,1 +109,1 @@\n-jextract --dump-includes includes.txt point.h\n+jextract --dump-includes=includes.txt point.h\n@@ -179,0 +129,58 @@\n+---\n+\n+### Building & Testing\n+\n+`jextract` depends on the [C libclang API](https:\/\/clang.llvm.org\/doxygen\/group__CINDEX.html). To build the jextract sources, the easiest option is to download LLVM binaries for your platform, which can be found [here](https:\/\/releases.llvm.org\/download.html) (a version >= 9 is required). Both the `jextract` tool and the bindings it generates depend heavily on the [Foreign Function & Memory API](https:\/\/openjdk.java.net\/jeps\/434), so a suitable [jdk 20 distribution](https:\/\/jdk.java.net\/20\/) is also required.\n+\n+> <details><summary><strong>Building older jextract versions<\/strong><\/summary>\n+>\n+> The `master` branch always tracks the latest version of the JDK. If you wish to build an older version of jextract, which targets an earlier version of the JDK you can do so by chercking out the appropriate branch.\n+> For example, to build a jextract tool which works against JDK 18:\n+>\n+> `git checkout jdk18`\n+>\n+> Over time, new branches will be added, each targeting a specific JDK version.\n+> <\/details>\n+\n+`jextract` can be built using `gradle`, as follows (on Windows, `gradlew.bat` should be used instead).\n+\n+(**Note**: Run the Gradle build with a Java version appropriate for the Gradle version. For example, Gradle 7.5.1\n+supports JDK 18. Please checkout the [Gradle compatibility matrix](https:\/\/docs.gradle.org\/current\/userguide\/compatibility.html#java) for the appropate JDK version needed for builds)\n+\n+\n+\n+```sh\n+$ sh .\/gradlew -Pjdk20_home=<jdk20_home_dir> -Pllvm_home=<libclang_dir> clean verify\n+```\n+\n+\n+> <details><summary><strong>Using a local installation of LLVM<\/strong><\/summary>\n+>\n+> While the recommended way is to use a [release from the LLVM project](https:\/\/releases.llvm.org\/download.html),\n+> extract it then make `llvm_home` point to this directory, it may be possible to use a local installation instead.\n+>\n+> E.g. on macOs the `llvm_home` can also be set as one of these locations :\n+>\n+> * `\/Library\/Developer\/CommandLineTools\/usr\/` if using Command Line Tools\n+> * `\/Applications\/Xcode.app\/Contents\/Developer\/Toolchains\/XcodeDefault.xctoolchain\/usr\/` if using XCode\n+> * `$(brew --prefix llvm)` if using the [LLVM install from Homebrew](https:\/\/formulae.brew.sh\/formula\/llvm#default)\n+>\n+> <\/details>\n+\n+After building, there should be a new `jextract` folder under `build`.\n+To run the `jextract` tool, simply run the `jextract` command in the `bin` folder:\n+\n+```sh\n+$ build\/jextract\/bin\/jextract\n+Expected a header file\n+```\n+\n+#### Testing\n+\n+The repository also contains a comprehensive set of tests, written using the [jtreg](https:\/\/openjdk.java.net\/jtreg\/) test framework, which can be run as follows (again, on Windows, `gradlew.bat` should be used instead):\n+\n+```sh\n+$ sh .\/gradlew -Pjdk20_home=<jdk20_home_dir> -Pllvm_home=<libclang_dir> -Pjtreg_home=<jtreg_home> jtreg\n+```\n+\n+Note: running `jtreg` task requires `cmake` to be available on the `PATH`.\n","filename":"README.md","additions":73,"deletions":65,"binary":false,"changes":138,"status":"modified"}]}