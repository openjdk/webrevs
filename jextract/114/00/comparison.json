{"files":[{"patch":"@@ -237,6 +237,0 @@\n-        \/**\n-         * The optional layout associated with this variable declaration.\n-         * @return The optional layout associated with this variable declaration.\n-         *\/\n-        Optional<MemoryLayout> layout();\n-\n@@ -250,0 +244,16 @@\n+    \/**\n+     * A bitfield declaration. Same as a variable declaration, but doesn't have a layout. Instead, it has\n+     * an offset (relative to the enclosing container) and a width.\n+     *\/\n+    interface Bitfield extends Variable {\n+        \/**\n+         * {@return The bitfield offset (relative to the enclosing container)}\n+         *\/\n+        long offset();\n+\n+        \/**\n+         * {@return The bitfield width (in bits)}\n+         *\/\n+        long width();\n+    }\n+\n@@ -357,1 +367,1 @@\n-     * Creates a new bitfield declaration with given name, type and layout.\n+     * Creates a new bitfield declaration with given name, type, offset and width.\n@@ -361,1 +371,2 @@\n-     * @param layout the bitfield declaration layout.\n+     * @param offset the offset of the bitfield (relative to the enclosing container).\n+     * @param width the bitfield width.\n@@ -364,2 +375,2 @@\n-    static Declaration.Variable bitfield(Position pos, String name, Type type, MemoryLayout layout) {\n-        return new DeclarationImpl.VariableImpl(type, layout, Declaration.Variable.Kind.BITFIELD, name, pos);\n+    static Declaration.Variable bitfield(Position pos, String name, Type type, long offset, long width) {\n+        return new DeclarationImpl.BitfieldImpl(type, offset, width, name, pos);\n@@ -417,1 +428,0 @@\n-     * @param layout the bitfields group declaration layout.\n@@ -421,1 +431,1 @@\n-    static Declaration.Scoped bitfields(Position pos, MemoryLayout layout, Declaration.Variable... bitfields) {\n+    static Declaration.Scoped bitfields(Position pos, Declaration.Variable... bitfields) {\n@@ -423,1 +433,1 @@\n-        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.BITFIELDS, layout, declList, \"\", pos);\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.BITFIELDS, declList, \"\", pos);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Declaration.java","additions":23,"deletions":13,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -84,1 +83,6 @@\n-    public Constant addMethodHandle(String javaName, String nativeName, FunctionDescriptor descriptor, boolean isVarargs, boolean virtual) {\n+    public Constant addDowncallMethodHandle(String javaName, String nativeName, FunctionDescriptor descriptor, boolean isVarargs, boolean virtual) {\n+        return emitIfAbsent(javaName, Constant.Kind.METHOD_HANDLE,\n+                () -> emitDowncallMethodHandleField(javaName, nativeName, descriptor, isVarargs, virtual));\n+    }\n+\n+    public Constant addLookupMethodHandle(String javaName, String className, String name, FunctionDescriptor descriptor) {\n@@ -86,1 +90,1 @@\n-                () -> emitMethodHandleField(javaName, nativeName, descriptor, isVarargs, virtual));\n+                () -> emitUpcallMethodHandleField(javaName, className, name, descriptor));\n@@ -200,1 +204,1 @@\n-    private Constant emitMethodHandleField(String javaName, String nativeName, FunctionDescriptor descriptor, boolean isVarargs, boolean virtual) {\n+    private Constant emitDowncallMethodHandleField(String javaName, String nativeName, FunctionDescriptor descriptor, boolean isVarargs, boolean virtual) {\n@@ -229,0 +233,15 @@\n+    private Constant emitUpcallMethodHandleField(String javaName, String className, String methodName, FunctionDescriptor descriptor) {\n+        Constant functionDesc = addFunctionDesc(javaName, descriptor);\n+        incrAlign();\n+        String fieldName = Constant.Kind.METHOD_HANDLE.fieldName(javaName);\n+        indent();\n+        append(memberMods() + \"MethodHandle \");\n+        append(fieldName + \" = RuntimeHelper.upcallHandle(\");\n+        append(className + \".class, \");\n+        append(\"\\\"\" + methodName + \"\\\", \");\n+        append(functionDesc.accessExpression());\n+        append(\");\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.METHOD_HANDLE);\n+    }\n+\n@@ -273,0 +292,5 @@\n+            if (l.bitAlignment() != l.bitSize()) {\n+                append(\".withBitAlignment(\");\n+                append(l.bitAlignment());\n+                append(\")\");\n+            }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ConstantBuilder.java","additions":28,"deletions":4,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-    public static final class VariableImpl extends DeclarationImpl implements Declaration.Variable {\n+    public static class VariableImpl extends DeclarationImpl implements Declaration.Variable {\n@@ -180,5 +180,0 @@\n-        @Override\n-        public Optional<MemoryLayout> layout() {\n-            return layout;\n-        }\n-\n@@ -210,0 +205,50 @@\n+    public static final class BitfieldImpl extends VariableImpl implements Declaration.Bitfield {\n+\n+        final long offset;\n+        final long width;\n+\n+        private BitfieldImpl(Type type, long offset, long width, String name, Position pos, Map<String, List<Constable>> attrs) {\n+            super(type, Optional.<MemoryLayout>empty(), Kind.BITFIELD, name, pos, attrs);\n+            this.offset = offset;\n+            this.width = width;\n+        }\n+\n+        public BitfieldImpl(Type type, long offset, long width, String name, Position pos) {\n+            this(type, offset, width, name, pos, null);\n+        }\n+\n+        @Override\n+        public long offset() {\n+            return offset;\n+        }\n+\n+        @Override\n+        public long width() {\n+            return width;\n+        }\n+\n+        @Override\n+        public Variable withAttributes(Map<String, List<Constable>> attrs) {\n+            return new BitfieldImpl(type, offset, width, name(), pos(), attrs);\n+        }\n+\n+        @Override\n+        public Variable stripAttributes() {\n+            return new BitfieldImpl(type, offset, width, name(), pos(), null);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof BitfieldImpl bitfield)) return false;\n+            if (!super.equals(o)) return false;\n+            return offset == bitfield.offset &&\n+                    width == bitfield.width;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), offset, width);\n+        }\n+    }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/DeclarationImpl.java","additions":51,"deletions":6,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+            Constant upcallHandle = constantBuilder.addLookupMethodHandle(className() + \"_UP\", className(), \"apply\", fiDesc);\n@@ -105,2 +106,2 @@\n-            append(\"return RuntimeHelper.upcallStub(\" + className() + \".class, fi, \" +\n-                functionDesc.accessExpression() + \", scope);\\n\");\n+            append(\"return RuntimeHelper.upcallStub(\" +\n+                upcallHandle.accessExpression() + \", fi, \" + functionDesc.accessExpression() + \", scope);\\n\");\n@@ -116,1 +117,1 @@\n-            Constant mhConstant = constantBuilder.addMethodHandle(className(), className(),\n+            Constant mhConstant = constantBuilder.addDowncallMethodHandle(className() + \"_DOWN\", className(),\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.foreign.Linker;\n@@ -112,1 +111,1 @@\n-            Constant mhConstant = constantBuilder.addMethodHandle(javaName, nativeName, descriptor, isVarargs, false)\n+            Constant mhConstant = constantBuilder.addDowncallMethodHandle(javaName, nativeName, descriptor, isVarargs, false)\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -357,1 +357,1 @@\n-        MemoryLayout layout = tree.layout().orElse(Type.layoutFor(type).orElse(null));\n+        MemoryLayout layout = Type.layoutFor(type).orElse(null);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import org.openjdk.jextract.Declaration.Bitfield;\n+import org.openjdk.jextract.Declaration.Variable.Kind;\n@@ -107,1 +109,6 @@\n-        builder.append(\"Variable: \" + d.kind() + \" \" + d.name() + \" type = \" + d.type().accept(typeVisitor, null) + \", layout = \" + d.layout());\n+        if (d instanceof Bitfield bitfield) {\n+            builder.append(\"Bitfield: \" + \" type = \" + d.type().accept(typeVisitor, null) + \", name = \" + bitfield.name()\n+                    + \", offset = \" + bitfield.offset() + \", width = \" + bitfield.width());\n+        } else {\n+            builder.append(\"Variable: \" + d.kind() + \" \" + d.name() + \" type = \" + d.type().accept(typeVisitor, null));\n+        }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/PrettyPrinter.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.foreign.GroupLayout;\n@@ -36,0 +37,3 @@\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -120,1 +124,1 @@\n-    void addField(Declaration declaration) {\n+    void addField(long offset, Declaration declaration) {\n@@ -126,1 +130,1 @@\n-            layout = var.layout().orElse(null);\n+            layout = org.openjdk.jextract.Type.layoutFor(var.type()).orElse(null);\n@@ -129,1 +133,4 @@\n-            \/\/fieldLayouts.add(layout.name().isEmpty() ? layout.withName(declaration.name()) : layout);\n+            if ((offset % layout.bitAlignment()) != 0) {\n+                long maxAlign = Long.lowestOneBit(offset);\n+                layout = forceAlign(layout, maxAlign);\n+            }\n@@ -140,1 +147,1 @@\n-            addField(((org.openjdk.jextract.Type.Declared)computeAnonymous(typeMaker, offset, parent, c.type(), nextAnonymousName())).tree());\n+            addField(offset, ((org.openjdk.jextract.Type.Declared)computeAnonymous(typeMaker, offset, parent, c.type(), nextAnonymousName())).tree());\n@@ -142,1 +149,1 @@\n-            addField(field(c));\n+            addField(offset, field(offset, c));\n@@ -150,1 +157,1 @@\n-    Declaration field(Cursor c) {\n+    Declaration field(long offset, Cursor c) {\n@@ -154,2 +161,1 @@\n-            MemoryLayout sublayout = MemoryLayout.paddingLayout(c.getBitFieldWidth());\n-            return Declaration.bitfield(TreeMaker.CursorPosition.of(c), name, type, sublayout.withName(name));\n+            return Declaration.bitfield(TreeMaker.CursorPosition.of(c), name, type, offset, c.getBitFieldWidth());\n@@ -170,2 +176,2 @@\n-    Declaration.Scoped bitfield(List<MemoryLayout> sublayouts, Declaration.Variable... declarations) {\n-        return Declaration.bitfields(declarations[0].pos(), MemoryLayout.structLayout(sublayouts.toArray(new MemoryLayout[0])), declarations);\n+    Declaration.Scoped bitfield(Declaration.Variable... declarations) {\n+        return Declaration.bitfields(declarations[0].pos(), declarations);\n@@ -189,0 +195,16 @@\n+\n+    MemoryLayout forceAlign(MemoryLayout layout, long maxAlign) {\n+        if (layout instanceof GroupLayout groupLayout) {\n+            MemoryLayout[] newMembers = groupLayout.memberLayouts()\n+                    .stream().map(l -> forceAlign(l, maxAlign)).toArray(MemoryLayout[]::new);\n+            return groupLayout instanceof StructLayout ?\n+                    MemoryLayout.structLayout(newMembers) :\n+                    MemoryLayout.unionLayout(newMembers);\n+        } else if (layout instanceof SequenceLayout sequenceLayout) {\n+            return MemoryLayout.sequenceLayout(sequenceLayout.elementCount(),\n+                    forceAlign(sequenceLayout.elementLayout(), maxAlign));\n+        } else {\n+            return layout.bitAlignment() > maxAlign ?\n+                    layout.withBitAlignment(maxAlign) : layout;\n+        }\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/RecordLayoutComputer.java","additions":32,"deletions":10,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    private List<MemoryLayout> bitfieldLayouts;\n+    private long bitfieldSize;\n@@ -54,1 +54,1 @@\n-    void addField(Declaration declaration) {\n+    void addField(long offset, Declaration declaration) {\n@@ -57,9 +57,1 @@\n-            MemoryLayout layout = null;\n-            if (declaration instanceof Declaration.Scoped scoped) {\n-                layout = scoped.layout().orElse(null);\n-            } else if (declaration instanceof Declaration.Variable var) {\n-                layout = var.layout().orElse(null);\n-            }\n-            if (layout != null) {\n-                bitfieldLayouts.add(declaration.name().isEmpty() ? layout : layout.withName(declaration.name()));\n-            }\n+            bitfieldSize += ((Declaration.Bitfield)declaration).width();\n@@ -67,1 +59,1 @@\n-            super.addField(declaration);\n+            super.addField(offset, declaration);\n@@ -73,3 +65,1 @@\n-        if (bitfieldDecls != null) {\n-            bitfieldLayouts.add(MemoryLayout.paddingLayout(bits));\n-        } else {\n+        if (bitfieldDecls == null) {\n@@ -77,0 +67,2 @@\n+        } else {\n+            bitfieldSize += bits;\n@@ -89,1 +81,1 @@\n-            bitfieldLayouts = new ArrayList<>();\n+            bitfieldSize = 0;\n@@ -151,1 +143,2 @@\n-        Declaration.Scoped declaration = Declaration.struct(TreeMaker.CursorPosition.of(cursor), cursor.spelling(), g, fieldDecls.stream().toArray(Declaration[]::new));\n+        Declaration.Scoped declaration = Declaration.struct(TreeMaker.CursorPosition.of(cursor), cursor.spelling(),\n+                g, fieldDecls.stream().toArray(Declaration[]::new));\n@@ -158,1 +151,0 @@\n-            List<MemoryLayout> prevBitfieldLayouts = bitfieldLayouts;\n@@ -160,0 +152,1 @@\n+            long prevBitfieldSize = bitfieldSize;\n@@ -161,0 +154,1 @@\n+            bitfieldSize = 0;\n@@ -162,1 +156,5 @@\n-                addField(bitfield(prevBitfieldLayouts, prevBitfieldDecls.toArray(new Declaration.Variable[0])));\n+                addField(offset, bitfield(prevBitfieldDecls.toArray(new Declaration.Variable[0])));\n+            }\n+            if (prevBitfieldSize == 0) {\n+                \/\/ nothing to do\n+                return;\n@@ -164,0 +162,1 @@\n+            fieldLayouts.add(MemoryLayout.paddingLayout(prevBitfieldSize));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructLayoutComputer.java","additions":18,"deletions":19,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import org.openjdk.jextract.Type.Primitive;\n+import org.openjdk.jextract.Type.Primitive.Kind;\n@@ -278,1 +280,1 @@\n-            ValueLayout layoutNoName = layoutNoName(layout);\n+            ValueLayout layoutNoName = normalize(layout);\n@@ -288,4 +290,2 @@\n-        private ValueLayout layoutNoName(ValueLayout layout) {\n-            \/\/ drop name if present\n-            return MemoryLayout.valueLayout(layout.carrier(), layout.order())\n-                    .withBitAlignment(layout.bitAlignment());\n+        public Constant resolvePrimitiveLayout(ValueLayout layout) {\n+            return primitiveLayouts.get(normalize(layout));\n@@ -294,2 +294,3 @@\n-        public Constant resolvePrimitiveLayout(ValueLayout layout) {\n-            return primitiveLayouts.get(layoutNoName(layout));\n+        public ValueLayout normalize(ValueLayout valueLayout) {\n+            return MemoryLayout.valueLayout(valueLayout.carrier(), valueLayout.order()) \/\/ drop name\n+                    .withBitAlignment(valueLayout.bitSize()); \/\/ use natural alignment\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ToplevelBuilder.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -101,3 +101,1 @@\n-            case FieldDecl -> c.isBitField() ?\n-                        createBitfield(c) :\n-                        createVar(c, Declaration.Variable.Kind.FIELD);\n+            case FieldDecl -> createVar(c, Declaration.Variable.Kind.FIELD);\n@@ -317,6 +315,0 @@\n-    private Declaration.Variable createBitfield(Cursor c) {\n-        checkCursorAny(c, CursorKind.FieldDecl);\n-        return Declaration.bitfield(CursorPosition.of(c), c.spelling(), toType(c),\n-                MemoryLayout.paddingLayout(c.getBitFieldWidth()));\n-    }\n-\n@@ -324,0 +316,1 @@\n+        if (c.isBitField()) throw new AssertionError(\"Cannot get here!\");\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeMaker.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    Declaration field(Cursor c) {\n+    Declaration field(long offset, Cursor c) {\n@@ -69,2 +69,2 @@\n-            Declaration.Variable var = (Declaration.Variable)super.field(c);\n-            return bitfield(List.of(var.layout().get()), var);\n+            Declaration.Variable var = (Declaration.Variable)super.field(offset, c);\n+            return bitfield(var);\n@@ -72,1 +72,1 @@\n-            return super.field(c);\n+            return super.field(offset, c);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnionLayoutComputer.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    static <Z> MemorySegment upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, SegmentScope scope) {\n+    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n@@ -74,3 +74,10 @@\n-            MethodHandle handle = MH_LOOKUP.findVirtual(fi, \"apply\", fdesc.toMethodType());\n-            handle = handle.bindTo(z);\n-            return LINKER.upcallStub(handle, fdesc, scope);\n+            return MH_LOOKUP.findVirtual(fi, name, fdesc.toMethodType());\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static <Z> MemorySegment upcallStub(MethodHandle fiHandle, Z z, FunctionDescriptor fdesc, SegmentScope scope) {\n+        try {\n+            fiHandle = fiHandle.bindTo(z);\n+            return LINKER.upcallStub(fiHandle, fdesc, scope);\n","filename":"src\/main\/resources\/org\/openjdk\/jextract\/impl\/resources\/RuntimeHelper.java.template","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-        assertEquals(global.layout().get().bitSize(), size);\n+        assertEquals(((Declaration.Bitfield)global).width(), size);\n","filename":"test\/lib\/testlib\/JextractApiTestBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.api;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.testng.annotations.Test;\n+import testlib.JextractApiTestBase;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+import java.lang.foreign.GroupLayout;\n+\n+public class TestPackedStructs extends JextractApiTestBase {\n+\n+    static final String[] NAMES = {\n+            \"S1\", \"S2\", \"S3\", \"S4\", \"S5\", \"S6\"\n+    };\n+\n+    @Test\n+    public void testPackedStructs() {\n+        Declaration.Scoped d = parse(\"packedstructs.h\");\n+        System.out.println(d);\n+        for (String name : NAMES) {\n+            Declaration.Scoped scoped = checkStruct(d, name, \"first\", \"second\");\n+            GroupLayout groupLayout = (GroupLayout)scoped.layout().get();\n+            assertEquals(groupLayout.memberLayouts().get(1).bitAlignment(), 8);\n+        }\n+    }\n+}\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/api\/TestPackedStructs.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#pragma pack(1)\n+struct S1 {\n+   char first;\n+   int second;\n+};\n+\n+#pragma pack(1)\n+struct S2 {\n+   char first;\n+   struct { int i } second;\n+};\n+\n+#pragma pack(1)\n+struct S3 {\n+   char first;\n+   int second[2];\n+};\n+\n+#pragma pack(1)\n+struct S4 {\n+   char first;\n+   union { int x; int y; } second;\n+};\n+\n+#pragma pack(1)\n+struct S5 {\n+   char first;\n+   union { struct { int i } x; struct { int i } y; } second;\n+};\n+\n+#pragma pack(1)\n+struct S6 {\n+   char first;\n+   union { int x[2]; int y[2]; } second;\n+};\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/api\/packedstructs.h","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"}]}