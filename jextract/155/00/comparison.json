{"files":[{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package org.openjdk.jextract;\n-\n-import java.util.Collection;\n-import java.util.Optional;\n-\n-\/**\n- * Subtypes of this interface can be customized with a variable number of attributes. Each attribute\n- * is modelled as an instance of a record class. The record class is used to lookup attributes.\n- * There can be at most one attribute associated with a given record class. Moreover, the set of\n- * attributes associated with an entity implementing this interface can only monotonically increase over time\n- * (that is, removing or replacing attributes is not supported).\n- *\/\n-public interface Attributed {\n-\n-    \/**\n-     * {@return the attributes associated with this entity}\n-     *\/\n-    Collection<Record> attributes();\n-\n-    \/**\n-     * Obtains an attribute from this entity.\n-     * @param attributeClass the class of the attribute to be obtained.\n-     * @param <R> the attribute's type.\n-     * @return the attribute (if any).\n-     *\/\n-    <R extends Record> Optional<R> getAttribute(Class<R> attributeClass);\n-\n-    \/**\n-     * Adds a new attribute to this entity.\n-     * @param attribute the attribute to be added.\n-     * @param <R> the attribute's type.\n-     *\/\n-    <R extends Record> void addAttribute(R attribute);\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Attributed.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Collection;\n@@ -43,1 +44,1 @@\n-public interface Declaration extends Attributed {\n+public interface Declaration {\n@@ -84,0 +85,20 @@\n+    \/**\n+     * {@return the attributes associated with this declaration}\n+     *\/\n+    Collection<Record> attributes();\n+\n+    \/**\n+     * Obtains an attribute from this declaration.\n+     * @param attributeClass the class of the attribute to be obtained.\n+     * @param <R> the attribute's type.\n+     * @return the attribute (if any).\n+     *\/\n+    <R extends Record> Optional<R> getAttribute(Class<R> attributeClass);\n+\n+    \/**\n+     * Adds a new attribute to this declaration.\n+     * @param attribute the attribute to be added.\n+     * @param <R> the attribute's type.\n+     *\/\n+    <R extends Record> void addAttribute(R attribute);\n+\n@@ -112,0 +133,4 @@\n+            \/**\n+             * Class declaration.\n+             *\/\n+            CLASS,\n@@ -441,1 +466,1 @@\n-        return new DeclarationImpl.TypedefImpl(type, name, pos, null);\n+        return new DeclarationImpl.TypedefImpl(type, name, pos);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Declaration.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-public interface Type extends Attributed {\n+public interface Type {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Type.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package org.openjdk.jextract.impl;\n-\n-import org.openjdk.jextract.Attributed;\n-\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Optional;\n-\n-public abstract class AttributedImpl implements Attributed {\n-\n-    private final Map<Class<?>, Record> attributes = new HashMap<>();\n-\n-    @Override\n-    public Collection<Record> attributes() {\n-        return attributes.values();\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public <R extends Record> Optional<R> getAttribute(Class<R> attributeClass) {\n-        return Optional.ofNullable((R)attributes.get(attributeClass));\n-    }\n-\n-    @Override\n-    public <R extends Record> void addAttribute(R attribute) {\n-        Record attr = attributes.get(attribute.getClass());\n-        if (attr != null && !attr.equals(attribute)) {\n-            throw new IllegalStateException(\"Attribute already exists: \" + attribute.getClass().getSimpleName());\n-        }\n-        attributes.put(attribute.getClass(), attribute);\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/AttributedImpl.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.constant.Constable;\n@@ -36,0 +35,2 @@\n+import java.util.Collection;\n+import java.util.HashMap;\n@@ -41,1 +42,0 @@\n-import java.util.concurrent.atomic.AtomicInteger;\n@@ -47,1 +47,0 @@\n-import org.openjdk.jextract.Type.Declared;\n@@ -49,1 +48,1 @@\n-public abstract class DeclarationImpl extends AttributedImpl implements Declaration {\n+public abstract class DeclarationImpl implements Declaration {\n@@ -53,0 +52,1 @@\n+    private final Map<Class<?>, Record> attributes = new HashMap<>();\n@@ -54,1 +54,1 @@\n-    public DeclarationImpl(String name, Position pos, Map<String, List<Constable>> attrs) {\n+    DeclarationImpl(String name, Position pos) {\n@@ -77,1 +77,3 @@\n-        return o instanceof Declaration decl && name().equals(decl.name());\n+        return o instanceof Declaration decl &&\n+                name().equals(decl.name()) &&\n+                attributes.equals(decl.attributes());\n@@ -82,1 +84,21 @@\n-        return Objects.hash(name);\n+        return Objects.hash(name, attributes);\n+    }\n+\n+    @Override\n+    public Collection<Record> attributes() {\n+        return attributes.values();\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public <R extends Record> Optional<R> getAttribute(Class<R> attributeClass) {\n+        return Optional.ofNullable((R)attributes.get(attributeClass));\n+    }\n+\n+    @Override\n+    public <R extends Record> void addAttribute(R attribute) {\n+        Record attr = attributes.get(attribute.getClass());\n+        if (attr != null && !attr.equals(attribute)) {\n+            throw new IllegalStateException(\"Attribute already exists: \" + attribute.getClass().getSimpleName());\n+        }\n+        attributes.put(attribute.getClass(), attribute);\n@@ -88,2 +110,2 @@\n-        public TypedefImpl(Type type, String name, Position pos, Map<String, List<Constable>> attrs) {\n-            super(name, pos, attrs);\n+        public TypedefImpl(Type type, String name, Position pos) {\n+            super(name, pos);\n@@ -107,1 +129,1 @@\n-                    name().equals(other.name()) &&\n+                    super.equals(other) &&\n@@ -122,3 +144,2 @@\n-        private VariableImpl(Type type, Variable.Kind kind, String name,\n-                             Position pos, Map<String, List<Constable>> attrs) {\n-            super(name, pos, attrs);\n+        public VariableImpl(Type type, Variable.Kind kind, String name, Position pos) {\n+            super(name, pos);\n@@ -129,4 +150,0 @@\n-        public VariableImpl(Type type, Variable.Kind kind, String name, Position pos) {\n-            this(type, kind, name, pos, null);\n-        }\n-\n@@ -151,3 +168,3 @@\n-            if (!(o instanceof Declaration.Variable variable)) return false;\n-            if (!super.equals(o)) return false;\n-            return kind == variable.kind() &&\n+            return o instanceof Declaration.Variable variable &&\n+                    super.equals(o) &&\n+                    kind == variable.kind() &&\n@@ -167,5 +184,0 @@\n-        private BitfieldImpl(Type type, long width, String name, Position pos, Map<String, List<Constable>> attrs) {\n-            super(type, Kind.BITFIELD, name, pos, attrs);\n-            this.width = width;\n-        }\n-\n@@ -173,1 +185,2 @@\n-            this(type, width, name, pos, null);\n+            super(type, Kind.BITFIELD, name, pos);\n+            this.width = width;\n@@ -184,3 +197,3 @@\n-            if (!(o instanceof BitfieldImpl bitfield)) return false;\n-            if (!super.equals(o)) return false;\n-            return width == bitfield.width;\n+            return o instanceof Declaration.Bitfield bitfield &&\n+                    super.equals(o) &&\n+                    width == bitfield.width();\n@@ -201,5 +214,1 @@\n-            this(type, params, name, pos, null);\n-        }\n-\n-        public FunctionImpl(Type.Function type, List<Variable> params, String name, Position pos, Map<String, List<Constable>> attrs) {\n-            super(name, pos, attrs);\n+            super(name, pos);\n@@ -228,3 +237,4 @@\n-            if (!(o instanceof Declaration.Function function)) return false;\n-            if (!super.equals(o)) return false;\n-            return type.equals(function.type());\n+            return o instanceof Declaration.Function function &&\n+                    super.equals(o) &&\n+                    params.equals(function.parameters()) &&\n+                    type.equals(function.type());\n@@ -235,1 +245,1 @@\n-            return Objects.hash(super.hashCode(), type);\n+            return Objects.hash(super.hashCode(), params, type);\n@@ -245,6 +255,1 @@\n-            this(kind, declarations, name, pos, null);\n-        }\n-\n-        ScopedImpl(Kind kind, List<Declaration> declarations,\n-                String name, Position pos, Map<String, List<Constable>> attrs) {\n-            super(name, pos, attrs);\n+            super(name, pos);\n@@ -273,3 +278,3 @@\n-            if (!(o instanceof Declaration.Scoped scoped)) return false;\n-            if (!super.equals(o)) return false;\n-            return kind == scoped.kind() &&\n+            return o instanceof Declaration.Scoped scoped &&\n+                    super.equals(o) &&\n+                    kind == scoped.kind() &&\n@@ -291,5 +296,1 @@\n-            this(type, value, name, pos, null);\n-        }\n-\n-        public ConstantImpl(Type type, Object value, String name, Position pos, Map<String, List<Constable>> attrs) {\n-            super(name, pos, attrs);\n+            super(name, pos);\n@@ -318,3 +319,3 @@\n-            if (!(o instanceof Declaration.Constant constant)) return false;\n-            if (!super.equals(o)) return false;\n-            return value.equals(constant.value()) &&\n+            return o instanceof Declaration.Constant constant &&\n+                    super.equals(o) &&\n+                    value == constant.value() &&\n@@ -504,4 +505,0 @@\n-        public static void with(Type type) {\n-            type.addAttribute(INSTANCE);\n-        }\n-\n@@ -511,4 +508,0 @@\n-\n-        public static boolean isPresent(Type type) {\n-            return type.getAttribute(Skip.class).isPresent();\n-        }\n@@ -540,14 +533,0 @@\n-    \/**\n-     * An attribute to attach a list of Java parameter names to a C function type.\n-     *\/\n-    record JavaParameterNames(List<String> parameterNames) {\n-        public static void with(Type.Function function, List<String> parameterNames) {\n-            function.addAttribute(new JavaParameterNames(parameterNames));\n-        }\n-\n-        public static Optional<List<String>> get(Type.Function function) {\n-            return function.getAttribute(JavaParameterNames.class)\n-                    .map(JavaParameterNames::parameterNames);\n-        }\n-    }\n-\n@@ -573,3 +552,0 @@\n-    \/**\n-     * An attribute to attach a layout to a scoped declaration.\n-     *\/\n@@ -587,3 +563,0 @@\n-    \/**\n-     * An attribute to attach alignment info to a declaration.\n-     *\/\n@@ -606,3 +579,0 @@\n-    \/**\n-     * An attribute to attach size info to a declaration.\n-     *\/\n@@ -625,3 +595,0 @@\n-    \/**\n-     * An attribute to attach offset info to a declaration.\n-     *\/\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/DeclarationImpl.java","additions":56,"deletions":89,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-    private final Set<Declaration.Typedef> typedefs = new HashSet<>();\n-    private final Set<Declaration.Function> functions = new HashSet<>();\n+    private final Set<String> typedefs = new HashSet<>();\n+    private final Set<String> functions = new HashSet<>();\n@@ -57,1 +57,1 @@\n-        return !functions.add(tree);\n+        return !functions.add(tree.name());\n@@ -62,1 +62,1 @@\n-        return !typedefs.add(tree);\n+        return !typedefs.add(tree.name());\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/DuplicateFilter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -304,1 +304,0 @@\n-            treeMaker.typeMaker.resolveTypeReferences();\n@@ -311,1 +310,1 @@\n-        void updateTable(TypeMaker typeMaker, Cursor decl) {\n+        void updateTable(TreeMaker treeMaker, Cursor decl) {\n@@ -318,1 +317,1 @@\n-                        yield entry.success(typeMaker.makeType(decl.type()), value);\n+                        yield entry.success(treeMaker.toType(decl), value);\n@@ -322,1 +321,1 @@\n-                        yield entry.success(typeMaker.makeType(decl.type()), value);\n+                        yield entry.success(treeMaker.toType(decl), value);\n@@ -326,1 +325,1 @@\n-                        yield entry.success(typeMaker.makeType(decl.type()), value);\n+                        yield entry.success(treeMaker.toType(decl), value);\n@@ -330,1 +329,1 @@\n-                                null : typeMaker.makeType(decl.type());\n+                                null : treeMaker.toType(decl);\n@@ -340,11 +339,7 @@\n-            TreeMaker treeMaker = new TreeMaker(); \/\/ @@@: what about de-duplicated declarations?\n-            try {\n-                reparser.reparse(snippet).forEach(c -> {\n-                    if (c.kind() == CursorKind.VarDecl &&\n-                            c.spelling().contains(\"jextract$\")) {\n-                        updateTable(treeMaker.typeMaker, c);\n-                    }\n-                });\n-            } finally {\n-                treeMaker.typeMaker.resolveTypeReferences();\n-            }\n+            TreeMaker treeMaker = new TreeMaker(MacroParserImpl.this.treeMaker);\n+            reparser.reparse(snippet).forEach(c -> {\n+                if (c.kind() == CursorKind.VarDecl &&\n+                        c.spelling().contains(\"jextract$\")) {\n+                    updateTable(treeMaker, c);\n+                }\n+            });\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/MacroParserImpl.java","additions":12,"deletions":17,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import org.openjdk.jextract.impl.DeclarationImpl.JavaParameterNames;\n@@ -199,10 +198,0 @@\n-           var paramNamesOpt = func.parameterNames();\n-           if (paramNamesOpt.isPresent()) {\n-               JavaParameterNames.with(func,\n-                   paramNamesOpt.\n-                      get().\n-                      stream().\n-                      map(NameMangler::javaSafeIdentifier).\n-                      toList()\n-               );\n-           }\n@@ -248,1 +237,1 @@\n-    private static String javaSafeIdentifier(String name) {\n+    public static String javaSafeIdentifier(String name) {\n@@ -252,0 +241,6 @@\n+    public static List<String> javaSafeIdentifiers(List<String> names) {\n+        return names.stream().\n+                map(NameMangler::javaSafeIdentifier).\n+                toList();\n+    }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/NameMangler.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-        this.treeMaker = new TreeMaker();\n+        this.treeMaker = new TreeMaker(null);\n@@ -103,1 +103,0 @@\n-            treeMaker.freeze();\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Parser.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import org.openjdk.jextract.impl.DeclarationImpl.JavaFunctionalInterfaceName;\n@@ -37,1 +36,0 @@\n-import org.openjdk.jextract.impl.DeclarationImpl.JavaParameterNames;\n@@ -140,1 +138,2 @@\n-                this, runtimeHelperName(), funcType, descriptor, JavaParameterNames.get(funcType));\n+                this, runtimeHelperName(), funcType, descriptor,\n+                funcType.parameterNames().map(NameMangler::javaSafeIdentifiers));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructBuilder.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import org.openjdk.jextract.impl.DeclarationImpl.JavaFunctionalInterfaceName;\n@@ -34,1 +33,0 @@\n-import org.openjdk.jextract.impl.DeclarationImpl.JavaParameterNames;\n@@ -148,1 +146,2 @@\n-        FunctionalInterfaceBuilder.generate(sfb, sfb.className(), null, firstHeader.className(), funcType, descriptor, JavaParameterNames.get(funcType));\n+        FunctionalInterfaceBuilder.generate(sfb, sfb.className(), null, firstHeader.className(), funcType, descriptor,\n+                funcType.parameterNames().map(NameMangler::javaSafeIdentifiers));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ToplevelBuilder.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.util.Optional;\n@@ -41,0 +42,1 @@\n+import org.openjdk.jextract.Declaration.Typedef;\n@@ -44,0 +46,1 @@\n+import org.openjdk.jextract.Type.Declared;\n@@ -55,0 +58,5 @@\n+\/**\n+ * This class turns a clang cursor into a jextract declaration. All declarations are de-duplicated,\n+ * based on the declaration position. Because of this, the tree maker's declaration cache effectively\n+ * acts as a symbol table.\n+ *\/\n@@ -56,1 +64,0 @@\n-    public TreeMaker() {}\n@@ -58,1 +65,2 @@\n-    TypeMaker typeMaker = new TypeMaker(this);\n+    private final TreeMaker parent;\n+    private final Map<Position, Declaration> declarationCache = new HashMap<>();\n@@ -60,2 +68,2 @@\n-    public void freeze() {\n-        typeMaker.resolveTypeReferences();\n+    public TreeMaker(TreeMaker parent) {\n+        this.parent = parent;\n@@ -64,2 +72,0 @@\n-    Map<Position, Declaration> declarationCache = new HashMap<>();\n-\n@@ -81,0 +87,7 @@\n+    public Optional<Declaration> lookup(Position pos) {\n+        Declaration declaration = declarationCache.get(pos);\n+        return (declaration == null && parent != null) ?\n+                parent.lookup(pos) :\n+                Optional.ofNullable(declaration);\n+    }\n+\n@@ -114,14 +127,17 @@\n-        Declaration decl = declarationCache.get(pos);\n-        if (decl == null) {\n-            decl = switch (c.kind()) {\n-                case EnumDecl -> createEnum(c);\n-                case EnumConstantDecl -> createEnumConstant(c);\n-                case FieldDecl -> createVar(c, Declaration.Variable.Kind.FIELD);\n-                case ParmDecl -> createVar(c, Declaration.Variable.Kind.PARAMETER);\n-                case FunctionDecl -> createFunction(c);\n-                case StructDecl -> createRecord(c, Declaration.Scoped.Kind.STRUCT);\n-                case UnionDecl -> createRecord(c, Declaration.Scoped.Kind.UNION);\n-                case TypedefDecl -> createTypedef(c);\n-                case VarDecl -> createVar(c, Declaration.Variable.Kind.GLOBAL);\n-                default -> null; \/\/ skip\n-            };\n+        Optional<Declaration> cachedDecl = lookup(pos);\n+        if (cachedDecl.isPresent()) {\n+            return cachedDecl.get();\n+        }\n+        Declaration decl = switch (c.kind()) {\n+            case EnumDecl -> createEnum(c);\n+            case EnumConstantDecl -> createEnumConstant(c);\n+            case FieldDecl -> createVar(c, Declaration.Variable.Kind.FIELD);\n+            case ParmDecl -> createVar(c, Declaration.Variable.Kind.PARAMETER);\n+            case FunctionDecl -> createFunction(c);\n+            case StructDecl -> createRecord(c, Declaration.Scoped.Kind.STRUCT);\n+            case UnionDecl -> createRecord(c, Declaration.Scoped.Kind.UNION);\n+            case TypedefDecl -> createTypedef(c);\n+            case VarDecl -> createVar(c, Declaration.Variable.Kind.GLOBAL);\n+            default -> null; \/\/ skip\n+        };\n+        if (decl != null) {\n@@ -142,1 +158,1 @@\n-            this.path = loc.path();\n+            this.path = loc.path().toAbsolutePath();\n@@ -218,1 +234,2 @@\n-        return Declaration.constant(CursorPosition.of(c), c.spelling(), c.getEnumConstantValue(), typeMaker.makeType(c.type()));\n+        return Declaration.constant(CursorPosition.of(c), c.spelling(), c.getEnumConstantValue(),\n+                toType(c));\n@@ -249,1 +266,1 @@\n-                    Type fieldType = typeMaker.makeType(fc.type());\n+                    Type fieldType = toType(fc);\n@@ -264,2 +281,2 @@\n-                    } else {\n-                        Type fieldType = typeMaker.makeType(fc.type());\n+                    } else if (!fc.isBitField() && !fc.spelling().isEmpty()) {\n+                        Type fieldType = toType(fc);\n@@ -307,0 +324,1 @@\n+            \/\/if there's a real definition somewhere else, skip this redundant declaration\n@@ -316,0 +334,6 @@\n+    private static boolean isRedundantTypedef(Declaration d) {\n+        return d instanceof Typedef typedef &&\n+                typedef.type() instanceof Declared declaredType &&\n+                declaredType.tree().name().equals(typedef.name());\n+    }\n+\n@@ -324,1 +348,1 @@\n-                .filter(d -> isEnum(d) || !d.name().isEmpty())\n+                .filter(d -> isEnum(d) || (!d.name().isEmpty() && !isRedundantTypedef(d)))\n@@ -331,7 +355,0 @@\n-        if (canonicalType instanceof Type.Declared declaredCanonicalType) {\n-            Declaration.Scoped s = declaredCanonicalType.tree();\n-            if (s.name().equals(c.spelling())) {\n-                \/\/ typedef record with the same name, no need to present twice\n-                return null;\n-            }\n-        }\n@@ -346,1 +363,1 @@\n-            } catch (NullPointerException npe) {\n+            } catch (IllegalStateException unresolved) {\n@@ -383,8 +400,1 @@\n-        Type type;\n-        try {\n-            type = toType(c);\n-        } catch (TypeMaker.TypeException ex) {\n-            System.err.println(ex);\n-            System.err.println(\"WARNING: ignoring variable: \" + c.spelling());\n-            return null;\n-        }\n+        Type type = toType(c);\n@@ -394,2 +404,2 @@\n-    private Type toType(Cursor c) {\n-        return typeMaker.makeType(c.type());\n+    Type toType(Cursor c) {\n+        return TypeMaker.makeType(c.type(), this);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeMaker.java","additions":55,"deletions":45,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-public abstract class TypeImpl extends AttributedImpl implements Type {\n+public abstract class TypeImpl implements Type {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypeImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.nio.ByteOrder;\n@@ -31,2 +30,0 @@\n-import java.util.ConcurrentModificationException;\n-import java.util.HashMap;\n@@ -34,3 +31,1 @@\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.function.Supplier;\n+import java.util.Optional;\n@@ -38,1 +33,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -40,0 +34,3 @@\n+import org.openjdk.jextract.Declaration.Scoped;\n+import org.openjdk.jextract.Declaration.Typedef;\n+import org.openjdk.jextract.Position;\n@@ -43,1 +40,0 @@\n-import org.openjdk.jextract.clang.Cursor;\n@@ -45,1 +41,9 @@\n-\n+import org.openjdk.jextract.impl.TreeMaker.CursorPosition;\n+\n+\/**\n+ * This class turns a clang type into a jextract type. Unlike declarations, jextract types are not\n+ * de-duplicated, so relying on the identity of a jextract type is wrong. Since pointer types can\n+ * point back to declarations, we create special pointer types backed by a supplier which fetches\n+ * the correct declaration from the tree maker cache. This makes sure that situations with\n+ * mutually referring pointers are dealt with correctly (i.e. by breaking cycles).\n+ *\/\n@@ -48,74 +52,1 @@\n-    TreeMaker treeMaker;\n-    private final Map<org.openjdk.jextract.clang.Type, Type> typeCache = new HashMap<>();\n-    private List<ClangTypeReference> unresolved = new ArrayList<>();\n-\n-    private class ClangTypeReference implements Supplier<Type> {\n-        org.openjdk.jextract.clang.Type origin;\n-        Type derived;\n-\n-        private ClangTypeReference(org.openjdk.jextract.clang.Type origin) {\n-            this.origin = origin;\n-            derived = typeCache.get(origin);\n-        }\n-\n-        public boolean isUnresolved() {\n-            return null == derived;\n-        }\n-\n-        public void resolve() {\n-            derived = makeType(origin);\n-            Objects.requireNonNull(derived, \"Clang type cannot be resolved: \" + origin.spelling());\n-        }\n-\n-        public Type get() {\n-            Objects.requireNonNull(derived, \"Type is not yet resolved.\");\n-            return derived;\n-        }\n-    }\n-\n-    private ClangTypeReference reference(org.openjdk.jextract.clang.Type type) {\n-        ClangTypeReference ref = new ClangTypeReference(type);\n-        if (ref.isUnresolved()) {\n-            unresolved.add(ref);\n-        }\n-        return ref;\n-    }\n-\n-    public TypeMaker(TreeMaker treeMaker) {\n-        this.treeMaker = treeMaker;\n-    }\n-\n-    \/**\n-     * Resolve all type references. This method should be called before discard clang cursors\/types\n-     *\/\n-    void resolveTypeReferences() {\n-        List<ClangTypeReference> resolving = unresolved;\n-        unresolved = new ArrayList<>();\n-        while (! resolving.isEmpty()) {\n-            resolving.forEach(ClangTypeReference::resolve);\n-            resolving = unresolved;\n-            unresolved = new ArrayList<>();\n-        }\n-    }\n-\n-    Type makeType(org.openjdk.jextract.clang.Type t) {\n-        Type rv = typeCache.get(t);\n-        if (rv != null) {\n-            return rv;\n-        }\n-        rv = makeTypeInternal(t);\n-        if (null != rv && typeCache.put(t, rv) != null) {\n-            throw new ConcurrentModificationException();\n-        }\n-        return rv;\n-    }\n-\n-    static class TypeException extends RuntimeException {\n-        static final long serialVersionUID = 1L;\n-\n-        TypeException(String msg) {\n-            super(msg);\n-        }\n-    }\n-\n-    Type makeTypeInternal(org.openjdk.jextract.clang.Type t) {\n+    static Type makeType(org.openjdk.jextract.clang.Type t, TreeMaker treeMaker) {\n@@ -124,1 +55,1 @@\n-                return makeType(t.canonicalType());\n+                return makeType(t.canonicalType(), treeMaker);\n@@ -173,1 +104,1 @@\n-                    throw new TypeException(\"Unknown type with same canonical type: \" + t.spelling());\n+                    return Type.error(t.spelling());\n@@ -175,1 +106,1 @@\n-                return makeType(canonical);\n+                return makeType(canonical, treeMaker);\n@@ -177,1 +108,1 @@\n-                Type elem = makeType(t.getElementType());\n+                Type elem = makeType(t.getElementType(), treeMaker);\n@@ -181,1 +112,1 @@\n-                Type elem = makeType(t.getElementType());\n+                Type elem = makeType(t.getElementType(), treeMaker);\n@@ -189,1 +120,1 @@\n-                    args.add(lowerFunctionType(t.argType(i)));\n+                    args.add(lowerFunctionType(t.argType(i), treeMaker));\n@@ -191,1 +122,1 @@\n-                return Type.function(t.isVariadic(), lowerFunctionType(t.resultType()), args.toArray(new Type[0]));\n+                return Type.function(t.isVariadic(), lowerFunctionType(t.resultType(), treeMaker), args.toArray(new Type[0]));\n@@ -201,3 +132,4 @@\n-                \/\/ TODO: We can always erase type for macro evaluation, should we?\n-                if (t.getPointeeType().kind() == TypeKind.FunctionProto) {\n-                    return new TypeImpl.PointerImpl(makeType(t.getPointeeType()));\n+                org.openjdk.jextract.clang.Type pointee = t.getPointeeType();\n+                if (pointee.kind() == TypeKind.FunctionProto ||\n+                        pointee.getDeclarationCursor().isInvalid()) {\n+                    return Type.pointer(makeType(t.getPointeeType(), treeMaker));\n@@ -205,1 +137,16 @@\n-                    return new TypeImpl.PointerImpl(reference(t.getPointeeType()));\n+                    \/\/ struct\/union pointer - defer processing of pointee type\n+                    Position pos = CursorPosition.of(pointee.getDeclarationCursor());\n+                    String spelling = t.spelling();\n+                    return Type.pointer(() -> {\n+                        Optional<Declaration> decl = treeMaker.lookup(pos);\n+                        if (decl.isEmpty()) {\n+                            \/\/ no declaration, maybe an opaque type, return an error type\n+                            return Type.error(spelling);\n+                        } else {\n+                            return switch (decl.get()) {\n+                                case Scoped scoped -> Type.declared(scoped);\n+                                case Typedef typedef -> Type.typedef(typedef.name(), typedef.type());\n+                                default -> throw new UnsupportedOperationException();\n+                            };\n+                        }\n+                    });\n@@ -209,1 +156,1 @@\n-                Type __type = makeType(t.canonicalType());\n+                Type __type = makeType(t.canonicalType(), treeMaker);\n@@ -213,1 +160,1 @@\n-                Type __type = makeType(t.getElementType());\n+                Type __type = makeType(t.getElementType(), treeMaker);\n@@ -217,1 +164,1 @@\n-                Type __type = makeType(t.getElementType());\n+                Type __type = makeType(t.getElementType(), treeMaker);\n@@ -235,1 +182,1 @@\n-                Type aType = makeType(t.getValueType());\n+                Type aType = makeType(t.getValueType(), treeMaker);\n@@ -243,2 +190,2 @@\n-    private Type lowerFunctionType(org.openjdk.jextract.clang.Type t) {\n-        Type t2 = makeType(t);\n+    private static Type lowerFunctionType(org.openjdk.jextract.clang.Type t, TreeMaker treeMaker) {\n+        Type t2 = makeType(t, treeMaker);\n@@ -248,1 +195,1 @@\n-    private Type.Visitor<Type, Void> lowerFunctionType = new Type.Visitor<>() {\n+    private static final Type.Visitor<Type, Void> lowerFunctionType = new Type.Visitor<>() {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypeMaker.java","additions":49,"deletions":102,"binary":false,"changes":151,"status":"modified"}]}