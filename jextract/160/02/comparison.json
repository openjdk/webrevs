{"files":[{"patch":"@@ -65,1 +65,0 @@\n-            String vhConstant = emitGlobalVarHandle(javaName, layoutVar);\n@@ -67,2 +66,2 @@\n-            emitGlobalGetter(segmentConstant, vhConstant, javaName, varTree, \"Getter for variable:\");\n-            emitGlobalSetter(segmentConstant, vhConstant, javaName, varTree, \"Setter for variable:\");\n+            emitGlobalGetter(segmentConstant, layoutVar, javaName, varTree, \"Getter for variable:\");\n+            emitGlobalSetter(segmentConstant, layoutVar, javaName, varTree, \"Setter for variable:\");\n@@ -295,1 +294,1 @@\n-    private void emitGlobalGetter(String segmentConstant, String vhConstant, String javaName,\n+    private void emitGlobalGetter(String segmentConstant, String layoutVar, String javaName,\n@@ -302,1 +301,1 @@\n-                return (\\{type.getSimpleName()}) \\{vhConstant}.get(\\{segmentConstant}(), 0L);\n+                return \\{segmentConstant}.get(\\{layoutVar}, 0L);\n@@ -308,1 +307,1 @@\n-    private void emitGlobalSetter(String segmentConstant, String vhConstant, String javaName,\n+    private void emitGlobalSetter(String segmentConstant, String layoutVar, String javaName,\n@@ -315,1 +314,1 @@\n-                \\{vhConstant}.set(\\{segmentConstant}(), 0L, x);\n+                \\{segmentConstant}.set(\\{layoutVar}, 0L, x);\n@@ -337,1 +336,1 @@\n-        return mangledName;\n+        return STR.\"\\{mangledName}()\";\n@@ -342,0 +341,1 @@\n+        String layoutType = Utils.layoutCarrierFor(varType).getSimpleName();\n@@ -343,16 +343,5 @@\n-            private static final MemoryLayout \\{mangledName} = \\{layoutString(varType)};\n-\n-            \\{MEMBER_MODS} MemoryLayout \\{mangledName}() {\n-                return \\{mangledName};\n-            }\n-            \"\"\");\n-        return mangledName;\n-    }\n-\n-    private String emitGlobalVarHandle(String javaName, String layoutVar) {\n-        String mangledName = mangleName(javaName, VarHandle.class);\n-        appendIndentedLines(STR.\"\"\"\n-            private static final VarHandle \\{mangledName} = \\{layoutVar}.varHandle();\n-\n-            \\{MEMBER_MODS} VarHandle \\{mangledName}() {\n-                return \\{mangledName};\n+            \\{MEMBER_MODS} \\{layoutType} \\{mangledName}() {\n+                class Holder {\n+                    static final \\{layoutType} LAYOUT = \\{layoutString(varType)};\n+                }\n+                return Holder.LAYOUT;\n@@ -361,1 +350,1 @@\n-        return mangledName;\n+        return STR.\"\\{mangledName}()\";\n@@ -424,1 +413,1 @@\n-        public static final \\{Utils.valueLayoutCarrierFor(type).getSimpleName()} \\{javaName} = \\{layoutString(type)};\n+        public static final \\{Utils.layoutCarrierFor(type).getSimpleName()} \\{javaName} = \\{layoutString(type)};\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":15,"deletions":26,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -94,0 +94,4 @@\n+    public JavaFileObject toFile(String suffix, Function<String, String> finisher) {\n+        return Utils.fileFromString(packageName, STR.\"\\{className}\\{suffix}\", finisher.apply(sb.toString()));\n+    }\n+\n@@ -95,1 +99,1 @@\n-        return Utils.fileFromString(packageName, className, finisher.apply(sb.toString()));\n+        return toFile(\"\", finisher);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/SourceFileBuilder.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-            private static final MemoryLayout $LAYOUT = \\{structOrUnionLayoutString(structType)};\n+            private static final GroupLayout $LAYOUT = \\{structOrUnionLayoutString(structType)};\n@@ -249,1 +249,1 @@\n-            public static final MemoryLayout $LAYOUT() {\n+            public static final GroupLayout $LAYOUT() {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-    private final List<SourceFileBuilder> builders = new ArrayList<>();\n-    private final HeaderFileBuilder firstHeader;\n+    private final List<SourceFileBuilder> headerBuilders = new ArrayList<>();\n+    private final List<SourceFileBuilder> otherBuilders = new ArrayList<>();\n@@ -49,1 +49,0 @@\n-    private int headersCount;\n@@ -55,1 +54,2 @@\n-        lastHeader = firstHeader = createFirstHeader(sfb, libraries);\n+        headerBuilders.add(sfb);\n+        lastHeader = createFirstHeader(sfb, libraries);\n@@ -59,1 +59,1 @@\n-        HeaderFileBuilder first = new HeaderFileBuilder(sfb, sfb.className(), \"#{SUPER}\", sfb.className());\n+        HeaderFileBuilder first = new HeaderFileBuilder(sfb, STR.\"\\{sfb.className()}#{SUFFIX}\", null, sfb.className());\n@@ -80,0 +80,1 @@\n+        first.emitRuntimeHelperMethods();\n@@ -84,4 +85,0 @@\n-        boolean hasOneHeader = lastHeader == firstHeader;\n-        if (hasOneHeader) {\n-            firstHeader.emitRuntimeHelperMethods();\n-        }\n@@ -91,3 +88,20 @@\n-        files.add(firstHeader.sourceFileBuilder().toFile(s -> s.replace(\"extends #{SUPER}\",\n-                hasOneHeader ? \"\" : \"extends \" + lastHeader.className())));\n-        files.addAll(builders.stream()\n+\n+        if (headerBuilders.size() == 1) {\n+            files.add(headerBuilders.get(0).toFile(s -> s.replace(\"#{SUFFIX}\", \"\")));\n+        } else {\n+            \/\/ adjust suffixes so that the last header class becomes the main header class,\n+            \/\/ and extends all the other header classes\n+            int suffix = headerBuilders.size() - 1;\n+            for (SourceFileBuilder header : headerBuilders) {\n+                String currentSuffix = suffix == 0 ?\n+                        \"\" : \/\/ main header class, drop the suffix\n+                        STR.\"_\\{suffix}\";\n+                String prevSuffix = STR.\"_\\{suffix + 1}\";\n+                files.add(header.toFile(currentSuffix,\n+                        s -> s.replace(\"#{SUFFIX}\", currentSuffix)\n+                              .replace(\"#{PREV_SUFFIX}\", prevSuffix)));\n+                suffix--;\n+            }\n+        }\n+        \/\/ add remaining builders\n+        files.addAll(otherBuilders.stream()\n@@ -98,0 +112,4 @@\n+    public String mainHeaderClassName() {\n+        return headerDesc.displayName();\n+    }\n+\n@@ -128,2 +146,2 @@\n-            TypedefBuilder.generate(sfb, sfb.className(), superClass, firstHeader.className(), typedefTree);\n-            builders.add(sfb);\n+            TypedefBuilder.generate(sfb, sfb.className(), superClass, mainHeaderClassName(), typedefTree);\n+            otherBuilders.add(sfb);\n@@ -136,2 +154,2 @@\n-        builders.add(sfb);\n-        StructBuilder structBuilder = new StructBuilder(sfb, \"public\", sfb.className(), null, firstHeader.className(), tree);\n+        otherBuilders.add(sfb);\n+        StructBuilder structBuilder = new StructBuilder(sfb, \"public\", sfb.className(), null, mainHeaderClassName(), tree);\n@@ -145,2 +163,2 @@\n-        builders.add(sfb);\n-        FunctionalInterfaceBuilder.generate(sfb, sfb.className(), null, firstHeader.className(), funcType,\n+        otherBuilders.add(sfb);\n+        FunctionalInterfaceBuilder.generate(sfb, sfb.className(), null, mainHeaderClassName(), funcType,\n@@ -152,8 +170,4 @@\n-            boolean wasFirstHeader = lastHeader == firstHeader;\n-            if (wasFirstHeader) {\n-                firstHeader.emitRuntimeHelperMethods();\n-            }\n-            String className = headerDesc.displayName() + \"_\" + ++headersCount;\n-            SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName(), className);\n-            HeaderFileBuilder headerFileBuilder = new HeaderFileBuilder(sfb, sfb.className(),\n-                    wasFirstHeader ? null : lastHeader.className(), firstHeader.className());\n+            SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName(), mainHeaderClassName());\n+            String className = mainHeaderClassName() + \"#{SUFFIX}\";\n+            HeaderFileBuilder headerFileBuilder = new HeaderFileBuilder(sfb, className,\n+                    mainHeaderClassName() + \"#{PREV_SUFFIX}\", mainHeaderClassName());\n@@ -162,1 +176,1 @@\n-            builders.add(sfb);\n+            headerBuilders.add(sfb);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ToplevelBuilder.java","additions":41,"deletions":27,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import org.openjdk.jextract.Declaration.Constant;\n@@ -41,0 +42,1 @@\n+import java.lang.foreign.GroupLayout;\n@@ -42,0 +44,1 @@\n+import java.lang.foreign.SequenceLayout;\n@@ -230,9 +233,13 @@\n-    public static Class<?> valueLayoutCarrierFor(Type t) {\n-        if (t instanceof Delegated delegated && delegated.kind() == Delegated.Kind.POINTER) {\n-            return AddressLayout.class;\n-        } else if (t instanceof Type.Primitive p) {\n-            Class<?> clazz = carrierFor(p);\n-            return CARRIERS_TO_LAYOUT_CARRIERS.get(clazz);\n-        } else {\n-            throw new UnsupportedOperationException(t.toString());\n-        }\n+    public static Class<?> layoutCarrierFor(Type t) {\n+        return switch (t) {\n+            case Type.Array _ -> SequenceLayout.class;\n+            case Delegated delegated when delegated.kind() == Kind.POINTER -> AddressLayout.class;\n+            case Delegated delegated -> layoutCarrierFor(delegated.type());\n+            case Type.Primitive primitive -> {\n+                Class<?> clazz = carrierFor(primitive);\n+                yield CARRIERS_TO_LAYOUT_CARRIERS.get(clazz);\n+            }\n+            case Type.Declared declared when isStructOrUnion(declared) -> GroupLayout.class;\n+            case Type.Declared declared when isEnum(declared) -> layoutCarrierFor(((Constant)declared.tree().members().get(0)).type());\n+            default -> throw new UnsupportedOperationException(t.toString());\n+        };\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Utils.java","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+import test.jextract.clinit.*;\n+\n+import java.lang.foreign.ValueLayout;\n+\n+\/*\n+ * @test id=classes\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.clinit -Djextract.decls.per.header=1 clinit_global.h\n+ * @build TestGlobal\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestGlobal\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library \/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.clinit -Djextract.decls.per.header=1 clinit_global.h\n+ * @build TestGlobal\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestGlobal\n+ *\/\n+public class TestGlobal {\n+\n+    @Test\n+    public void testGlobal() {\n+        ValueLayout layout = clinit_global_h.C_INT;\n+        assertNotNull(layout);\n+        assertEquals(layout, clinit_global_h.global1$LAYOUT());\n+        assertEquals(layout, clinit_global_h.global2$LAYOUT());\n+    }\n+}\n","filename":"test\/jtreg\/generator\/clinitCycles\/TestGlobal.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.clinit.*;\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.ValueLayout;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.clinit -Djextract.decls.per.header=1 clinit_struct.h\n+ * @build TestStruct\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestStruct\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library \/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.clinit -Djextract.decls.per.header=1 clinit_struct.h\n+ * @build TestStruct\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestStruct\n+ *\/\n+public class TestStruct {\n+\n+    @Test\n+    public void TestStruct() {\n+        ValueLayout layout = clinit_struct_h.C_INT;\n+        assertNotNull(layout);\n+        GroupLayout pointLayout = Point.$LAYOUT();\n+        assertNotNull(pointLayout);\n+        assertEquals(pointLayout.memberLayouts().get(0).withoutName(), layout);\n+        assertEquals(pointLayout.memberLayouts().get(1).withoutName(), layout);\n+    }\n+}\n","filename":"test\/jtreg\/generator\/clinitCycles\/TestStruct.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+import test.jextract.clinit.*;\n+\n+import java.lang.foreign.ValueLayout;\n+\n+\/*\n+ * @test id=classes\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -l Func -t test.jextract.clinit -Djextract.decls.per.header=1 clinit_typedef.h\n+ * @build TestTypedef\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestTypedef\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library \/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.clinit -Djextract.decls.per.header=1 clinit_typedef.h\n+ * @build TestTypedef\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestTypedef\n+ *\/\n+public class TestTypedef {\n+\n+    @Test\n+    public void TestTypedef() {\n+        ValueLayout layout = clinit_typedef_h.C_INT;\n+        assertNotNull(layout);\n+        assertEquals(layout, clinit_typedef_h.one);\n+        assertEquals(layout, clinit_typedef_h.two);\n+        assertEquals(layout, clinit_typedef_h.three);\n+    }\n+}\n","filename":"test\/jtreg\/generator\/clinitCycles\/TestTypedef.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int global1;\n+EXPORT int global2;\n","filename":"test\/jtreg\/generator\/clinitCycles\/clinit_global.h","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -1,2 +1,1 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +23,3 @@\n-struct Foo {\n-    int (*Foo)();\n+struct Point {\n+   int x;\n+   int y;\n","filename":"test\/jtreg\/generator\/clinitCycles\/clinit_struct.h","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/test7903237.h","status":"copied"},{"patch":"@@ -0,0 +1,25 @@\n+\/* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef int one;\n+typedef one two;\n+typedef two three;\n","filename":"test\/jtreg\/generator\/clinitCycles\/clinit_typedef.h","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main\/othervm JtregJextractSources -l Func -t test.jextract.packedstructs packedstructs.h\n+ * @run main\/othervm JtregJextractSources -t test.jextract.packedstructs packedstructs.h\n","filename":"test\/jtreg\/generator\/packed\/TestPackedStructs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -238,1 +238,1 @@\n-        assertEquals(m.getReturnType(), returnType);\n+        assertTrue(returnType.isAssignableFrom(m.getReturnType())); \/\/ tolerate more specific type\n@@ -246,1 +246,1 @@\n-        assertEquals(method.getReturnType(), MemoryLayout.class);\n+        assertTrue(MemoryLayout.class.isAssignableFrom(method.getReturnType()));\n","filename":"test\/lib\/testlib\/JextractToolRunner.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -173,4 +173,2 @@\n-        Method vh_getter = checkMethod(cls, name + \"$VH\", VarHandle.class);\n-        VarHandle vh = (VarHandle) vh_getter.invoke(null);\n-        assertEquals(vh.varType(), expectedType);\n-        assertEquals(vh.get(segment, 0L), expectedValue);\n+        Method getter = checkMethod(cls, name + \"$get\", expectedType);\n+        assertEquals(getter.invoke(segment), expectedValue);\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/TestClassGeneration.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}