{"files":[{"patch":"@@ -62,0 +62,1 @@\n+    options.compilerArgs << \"-Xlint:unchecked\"\n@@ -236,0 +237,5 @@\n+                \"-javacoption:--add-exports=org.openjdk.jextract\/org.openjdk.jextract.json=ALL-UNNAMED\",\n+                \"-javacoption:--add-exports=org.openjdk.jextract\/org.openjdk.jextract.json.parser=ALL-UNNAMED\",\n+                \"-javacoption:-Xlint:unchecked\",\n+                \"-javaoption:--add-exports=org.openjdk.jextract\/org.openjdk.jextract.json=ALL-UNNAMED\",\n+                \"-javaoption:--add-exports=org.openjdk.jextract\/org.openjdk.jextract.json.parser=ALL-UNNAMED\",\n","filename":"build.gradle","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.json;\n+\n+import java.util.Objects;\n+\n+import org.openjdk.jextract.json.parser.JSONObject;\n+import org.openjdk.jextract.json.parser.JSONParser;\n+import org.openjdk.jextract.json.parser.JSONValue;\n+import org.openjdk.jextract.json.parser.JWCC;\n+\n+\/**\n+ * Simple interface to parse a JSON string to a record and\n+ * to convert a record to a JSON string.\n+ *\/\n+public final class JSON {\n+    private JSON() {}\n+\n+    \/**\n+     * Parse a given String to a Record object of given type.\n+     *\n+     * @param str JSON string to parse.\n+     * @param cls the target record class type.\n+     * @param extension parse extended JSON format.\n+     *                  Allows comments and trailing commas.\n+     * @return parsed and mapped record.\n+     *\/\n+    public static <T extends Record> T parse(String str, Class<T> cls, boolean extension) {\n+        Objects.requireNonNull(str);\n+        Objects.requireNonNull(cls);\n+\n+        JSONValue jsonValue = extension ? JWCC.parse(str) : new JSONParser().parse(str);\n+        return JSONObjects.toRecord(jsonValue.asObject(), cls);\n+    }\n+\n+    \/**\n+     * Parse a given String to a Record object of given type.\n+     *\n+     * @param str JSON string to parse.\n+     * @param cls the target record class type.\n+     * @return parsed and mapped record.\n+     *\/\n+    public static <T extends Record> T parse(String str, Class<T> cls) {\n+        return JSON.parse(str, cls, false);\n+    }\n+\n+    \/**\n+     * Convert a given record as a JSON String.\n+     *\n+     * @param record the record to be converted as JSON String.\n+     * @param pretty whether to indentation the JSON String or not.\n+     * @rerurn converted JSON String.\n+     *\/\n+    public static String toString(Record record, boolean pretty) {\n+        Objects.requireNonNull(record);\n+\n+        JSONObject jsonObj = JSONObjects.from(record);\n+        return pretty ? JSONValue.toPrettyString(jsonObj) : jsonObj.toString();\n+    }\n+\n+    \/**\n+     * Convert a given record as a JSON String.\n+     *\n+     * @param record the record to be converted as JSON String.\n+     * @rerurn converted JSON String.\n+     *\/\n+    public static String toString(Record record) {\n+        return toString(record, true);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/json\/JSON.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,470 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.json;\n+\n+import java.lang.reflect.Array;\n+import java.util.EnumSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import org.openjdk.jextract.json.parser.JSONArray;\n+import org.openjdk.jextract.json.parser.JSONValue;\n+\n+\/**\n+ * Helper class that has static utilities to convert between JSONArrays\n+ * and Java arrays, iterables, lists, sets and enum sets. RuntimeException\n+ * is thrown for conversion failures.\n+ *\/\n+public final class JSONArrays {\n+    private JSONArrays() {}\n+\n+    \/**\n+     * Converts the given boolean array as a JSONArray.\n+     *\n+     * @param ba the boolean array being converted.\n+     * @return converted JSONArray.\n+     *\/\n+    public static JSONArray from(boolean[] ba) {\n+        Objects.requireNonNull(ba);\n+\n+        JSONArray ja = new JSONArray();\n+        for (boolean b : ba) {\n+            ja.add(JSONValue.from(b));\n+        }\n+        return ja;\n+    }\n+\n+    \/**\n+     * Converts the JSONArray as a boolean array.\n+     *\n+     * @param ja the JSONArray being converted.\n+     * @return converted boolean array.\n+     *\/\n+    public static boolean[] toBooleanArray(JSONArray ja) {\n+        Objects.requireNonNull(ja);\n+\n+        boolean[] arr = new boolean[ja.size()];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ja.get(i).asBoolean();\n+        }\n+        return arr;\n+    }\n+\n+    \/**\n+     * Converts the given char array as a JSONArray.\n+     *\n+     * @param ca the char array being converted.\n+     * @return converted JSONArray.\n+     *\/\n+    public static JSONArray from(char[] ca) {\n+        Objects.requireNonNull(ca);\n+\n+        JSONArray ja = new JSONArray();\n+        for (char c : ca) {\n+            ja.add(JSONValue.from(String.valueOf(c)));\n+        }\n+        return ja;\n+    }\n+\n+    \/**\n+     * Converts the JSONArray as a char array.\n+     *\n+     * @param ja the JSONArray being converted.\n+     * @return converted char array.\n+     *\/\n+    public static char[] toCharArray(JSONArray ja) {\n+        Objects.requireNonNull(ja);\n+\n+        char[] arr = new char[ja.size()];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ja.get(i).asChar();\n+        }\n+        return arr;\n+    }\n+\n+    \/**\n+     * Converts the given byte array as a JSONArray.\n+     *\n+     * @param ba the byte array being converted.\n+     * @return converted JSONArray.\n+     *\/\n+    public static JSONArray from(byte[] ba) {\n+        Objects.requireNonNull(ba);\n+\n+        JSONArray ja = new JSONArray();\n+        for (byte b : ba) {\n+            ja.add(JSONValue.from((int)b));\n+        }\n+        return ja;\n+    }\n+\n+    \/**\n+     * Converts the JSONArray as a byte array.\n+     *\n+     * @param ja the JSONArray being converted.\n+     * @return converted byte array.\n+     *\/\n+    public static byte[] toByteArray(JSONArray ja) {\n+        Objects.requireNonNull(ja);\n+\n+        byte[] arr = new byte[ja.size()];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ja.get(i).asByte();\n+        }\n+        return arr;\n+    }\n+\n+    \/**\n+     * Converts the given short array as a JSONArray.\n+     *\n+     * @param sa the short array being converted.\n+     * @return converted JSONArray.\n+     *\/\n+    public static JSONArray from(short[] sa) {\n+        Objects.requireNonNull(sa);\n+\n+        JSONArray ja = new JSONArray();\n+        for (short s : sa) {\n+            ja.add(JSONValue.from((int)s));\n+        }\n+        return ja;\n+    }\n+\n+    \/**\n+     * Converts the JSONArray as a short array.\n+     *\n+     * @param ja the JSONArray being converted.\n+     * @return converted short array.\n+     *\/\n+    public static short[] toShortArray(JSONArray ja) {\n+        Objects.requireNonNull(ja);\n+\n+        short[] arr = new short[ja.size()];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ja.get(i).asShort();\n+        }\n+        return arr;\n+    }\n+\n+    \/**\n+     * Converts the given int array as a JSONArray.\n+     *\n+     * @param ia the int array being converted.\n+     * @return converted JSONArray.\n+     *\/\n+    public static JSONArray from(int[] ia) {\n+        Objects.requireNonNull(ia);\n+\n+        JSONArray ja = new JSONArray();\n+        for (int i : ia) {\n+            ja.add(JSONValue.from(i));\n+        }\n+        return ja;\n+    }\n+\n+    \/**\n+     * Converts the JSONArray as an int array.\n+     *\n+     * @param ja the JSONArray being converted.\n+     * @return converted int array.\n+     *\/\n+    public static int[] toIntArray(JSONArray ja) {\n+        Objects.requireNonNull(ja);\n+\n+        int[] arr = new int[ja.size()];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ja.get(i).asInt();\n+        }\n+        return arr;\n+    }\n+\n+    \/**\n+     * Converts the given long array as a JSONArray.\n+     *\n+     * @param la the long array being converted.\n+     * @return converted JSONArray.\n+     *\/\n+    public static JSONArray from(long[] la) {\n+        Objects.requireNonNull(la);\n+\n+        JSONArray ja = new JSONArray();\n+        for (long l : la) {\n+            ja.add(JSONValue.from(l));\n+        }\n+        return ja;\n+    }\n+\n+    \/**\n+     * Converts the JSONArray as a long array.\n+     *\n+     * @param ja the JSONArray being converted.\n+     * @return converted long array.\n+     *\/\n+    public static long[] toLongArray(JSONArray ja) {\n+        Objects.requireNonNull(ja);\n+\n+        long[] arr = new long[ja.size()];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ja.get(i).asLong();\n+        }\n+        return arr;\n+    }\n+\n+    \/**\n+     * Converts the given float array as a JSONArray.\n+     *\n+     * @param fa the float array being converted.\n+     * @return converted JSONArray.\n+     *\/\n+    public static JSONArray from(float[] fa) {\n+        Objects.requireNonNull(fa);\n+\n+        JSONArray ja = new JSONArray();\n+        for (float f : fa) {\n+            ja.add(JSONValue.from((double)f));\n+        }\n+        return ja;\n+    }\n+\n+    \/**\n+     * Converts the JSONArray as a float array.\n+     *\n+     * @param ja the JSONArray being converted.\n+     * @return converted float array.\n+     *\/\n+    public static float[] toFloatArray(JSONArray ja) {\n+        Objects.requireNonNull(ja);\n+\n+        float[] arr = new float[ja.size()];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ja.get(i).asFloat();\n+        }\n+        return arr;\n+    }\n+\n+    \/**\n+     * Converts the given double array as a JSONArray.\n+     *\n+     * @param da the double array being converted.\n+     * @return converted JSONArray.\n+     *\/\n+    public static JSONArray from(double[] da) {\n+        Objects.requireNonNull(da);\n+\n+        JSONArray ja = new JSONArray();\n+        for (double d : da) {\n+            ja.add(JSONValue.from(d));\n+        }\n+        return ja;\n+    }\n+\n+    \/**\n+     * Converts the JSONArray as a double array.\n+     *\n+     * @param ja the JSONArray being converted.\n+     * @return converted double array.\n+     *\/\n+    public static double[] toDoubleArray(JSONArray ja) {\n+        Objects.requireNonNull(ja);\n+\n+        double[] arr = new double[ja.size()];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ja.get(i).asDouble();\n+        }\n+        return arr;\n+    }\n+\n+    \/**\n+     * Converts the given String array as a JSONArray.\n+     *\n+     * @param sa the String array being converted.\n+     * @return converted JSONArray.\n+     *\/\n+    public static JSONArray from(String[] sa) {\n+        Objects.requireNonNull(sa);\n+\n+        JSONArray ja = new JSONArray();\n+        for (String s : sa) {\n+            ja.add(JSONValue.from(s));\n+        }\n+        return ja;\n+    }\n+\n+    \/**\n+     * Converts the JSONArray as a String array.\n+     *\n+     * @param ja the JSONArray being converted.\n+     * @return converted String array.\n+     *\/\n+    public static String[] toStringArray(JSONArray ja) {\n+        Objects.requireNonNull(ja);\n+\n+        String[] arr = new String[ja.size()];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ja.get(i).asString();\n+        }\n+        return arr;\n+    }\n+\n+    \/**\n+     * Converts the given Object array as a JSONArray.\n+     *\n+     * @param sa the Object array being converted.\n+     * @return converted JSONArray.\n+     *\/\n+    public static JSONArray from(Object[] array) {\n+        Objects.requireNonNull(array);\n+\n+        JSONArray ja = new JSONArray();\n+        for (Object elem : array) {\n+            ja.add(JSONObjects.from(elem));\n+        }\n+        return ja;\n+    }\n+\n+    \/**\n+     * Converts the JSONArray as an Object array.\n+     *\n+     * @param ja the JSONArray being converted.\n+     * @return converted Object array.\n+     *\/\n+    public static Object[] toObjectArray(JSONArray ja) {\n+        Objects.requireNonNull(ja);\n+\n+        final int length = ja.size();\n+        Object[] arr = new Object[length];\n+        for (int i = 0; i < length; i++) {\n+             arr[i] = JSONObjects.toObject(ja.get(i));\n+        }\n+        return arr;\n+    }\n+\n+    \/**\n+     * Converts the given Iterable as a JSONArray.\n+     *\n+     * @param iterable the Iterable being converted.\n+     * @return converted JSONArray.\n+     *\/\n+    public static JSONArray from(Iterable<?> iterable) {\n+        Objects.requireNonNull(iterable);\n+\n+        return from(iterable.iterator());\n+    }\n+\n+    \/**\n+     * Converts the given Iterator as a JSONArray.\n+     *\n+     * @param iterator the Iterator being converted.\n+     * @return converted JSONArray.\n+     *\/\n+    public static JSONArray from(Iterator<?> iterator) {\n+        Objects.requireNonNull(iterator);\n+\n+        JSONArray ja = new JSONArray();\n+        while (iterator.hasNext()) {\n+            ja.add(JSONObjects.from(iterator.next()));\n+        }\n+        return ja;\n+    }\n+\n+    \/**\n+     * Returns an array containing all of the elements in the given JSONArray in\n+     * proper sequence (from first to last element) after conversion; the runtime\n+     * type of the returned array is that of the specified array.  If the converted\n+     * JSONArray fits in the specified array, it is returned therein.  Otherwise, a new\n+     * array is allocated with the runtime type of the specified array and\n+     * the size of the given JSONArray.\n+     *\n+     * @param ja the JSONArray being converted.\n+     * @param arr the array into which the elements of the given JSONArray are to\n+     *          be stored after conversion, if it is big enough; otherwise, a new\n+     *          array of the same runtime type is allocated for this purpose.\n+     * @return an array containing the elements of the JSONArray after conversion.\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T[] toArray(JSONArray ja, T[] arr) {\n+        Objects.requireNonNull(ja);\n+        Objects.requireNonNull(arr);\n+\n+        final int length = ja.size();\n+        Class<?> compType = arr.getClass().getComponentType();\n+        if (arr.length < length) {\n+            \/\/ Make a new array of arr's runtime type\n+            arr = (T[]) Array.newInstance(compType, length);\n+        }\n+        for (int i = 0; i < length; i++) {\n+             arr[i] = (T) JSONObjects.toObject(ja.get(i), compType);\n+        }\n+        if (arr.length > length) {\n+            arr[length] = null;\n+        }\n+        return arr;\n+    }\n+\n+    \/**\n+     * Returns a list containing all of the elements in the given JSONArray in\n+     * proper sequence (from first to last element) after conversion.\n+     *\n+     * @param ja the JSONArray being converted.\n+     * @param elemType the target list element type for conversion.\n+     * @return a list containing the elements of the JSONArray after conversion.\n+     *\/\n+    public static <T> List<T> toList(JSONArray ja, Class<T> elemType) {\n+        Objects.requireNonNull(ja);\n+        Objects.requireNonNull(elemType);\n+\n+        return JSONObjects.toList(ja, elemType);\n+    }\n+\n+    \/**\n+     * Returns a set containing all of the elements in the given JSONArray in\n+     * after conversion with the duplicates removed.\n+     *\n+     * @param ja the JSONArray being converted.\n+     * @param elemType the target set element type for conversion.\n+     * @return a set containing the elements of the JSONArray after conversion.\n+     *\/\n+    public static <T> Set<T> toSet(JSONArray ja, Class<T> elemType) {\n+        Objects.requireNonNull(ja);\n+        Objects.requireNonNull(elemType);\n+\n+        return JSONObjects.toSet(ja, elemType);\n+    }\n+\n+    \/**\n+     * Returns a set containing all of the elements in the given JSONArray in\n+     * after conversion with the duplicates removed.\n+     *\n+     * @param ja the JSONArray being converted.\n+     * @param enumCls the target EnumSet element enum type for conversion.\n+     * @return a EnumSet containing the elements of the JSONArray after conversion.\n+     *\/\n+    public static <T extends Enum<T>> EnumSet<T> toEnumSet(JSONArray ja, Class<T> enumCls) {\n+        Objects.requireNonNull(ja);\n+        Objects.requireNonNull(enumCls);\n+\n+        return JSONObjects.toEnumSet(ja, enumCls);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/json\/JSONArrays.java","additions":470,"deletions":0,"binary":false,"changes":470,"status":"added"},{"patch":"@@ -0,0 +1,826 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.json;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.RecordComponent;\n+import java.lang.reflect.WildcardType;\n+import java.lang.reflect.Type;\n+import java.io.File;\n+import java.math.BigInteger;\n+import java.math.BigDecimal;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.OptionalInt;\n+import java.util.OptionalLong;\n+import java.util.OptionalDouble;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.openjdk.jextract.json.parser.JSONArray;\n+import org.openjdk.jextract.json.parser.JSONBoolean;\n+import org.openjdk.jextract.json.parser.JSONDecimal;\n+import org.openjdk.jextract.json.parser.JSONNull;\n+import org.openjdk.jextract.json.parser.JSONNumber;\n+import org.openjdk.jextract.json.parser.JSONObject;\n+import org.openjdk.jextract.json.parser.JSONString;\n+import org.openjdk.jextract.json.parser.JSONValue;\n+\n+\/**\n+ * Helper class that has static utilities to convert between JSONValue\n+ * and Java records\/maps\/enummaps. RuntimeException is thrown for\n+ * conversion failures.\n+ *\/\n+public final class JSONObjects {\n+    private JSONObjects() {}\n+\n+    \/**\n+     * Converts the given object as a JSONValue.\n+     *\n+     * @param value the object being converted.\n+     * @return converted JSONValue.\n+     *\/\n+    public static JSONValue from(Object value) {\n+        return switch (value) {\n+            case JSONValue jv -> jv;\n+            case Boolean b -> JSONValue.from((boolean)b);\n+            case Character c -> JSONValue.from(c.toString());\n+            case Byte bi -> JSONValue.from((int)bi);\n+            case Short s -> JSONValue.from((int)s);\n+            case Integer i -> JSONValue.from((int)i);\n+            case Long l -> JSONValue.from((long)l);\n+            case Float f -> JSONValue.from((double)f);\n+            case Double d -> JSONValue.from((double)d);\n+            case String s -> JSONValue.from(s);\n+            case OptionalInt oi -> from(oi.isEmpty() ? null : oi.getAsInt());\n+            case OptionalLong ol -> from(ol.isEmpty() ? null : ol.getAsLong());\n+            case OptionalDouble od -> from(od.isEmpty() ? null : od.getAsDouble());\n+            case Optional opt -> from(opt.isEmpty() ? null : opt.get());\n+            case Enum<?> en -> JSONValue.from(en.name());\n+            case Record r -> from(r);\n+            case Map<?,?> m -> from(m);\n+            case Iterable<?> iterable -> JSONArrays.from(iterable);\n+            case Iterator<?> iterator -> JSONArrays.from(iterator);\n+            case boolean[] boa -> JSONArrays.from(boa);\n+            case char[] ca -> JSONArrays.from(ca);\n+            case byte[] bia -> JSONArrays.from(bia);\n+            case short[] sa -> JSONArrays.from(sa);\n+            case int[] ia -> JSONArrays.from(ia);\n+            case long[] la -> JSONArrays.from(la);\n+            case float[] fa -> JSONArrays.from(fa);\n+            case double[] da -> JSONArrays.from(da);\n+            case String[] sa -> JSONArrays.from(sa);\n+            case Object[] oa -> JSONArrays.from(oa);\n+            case null -> JSONValue.fromNull();\n+            default -> JSONValue.from(Objects.toString(value));\n+        };\n+    }\n+\n+    \/**\n+     * Converts the given record as a JSONObject.\n+     *\n+     * @param record the record being converted.\n+     * @return converted JSONObject.\n+     *\/\n+    public static JSONObject from(Record record) {\n+        Objects.requireNonNull(record);\n+\n+        Class<? extends Record> cls = record.getClass();\n+        Map<String, JSONValue> props = new LinkedHashMap<>();\n+        for (RecordComponent rc : cls.getRecordComponents()) {\n+            props.put(rc.getName(), getRecordProperty(record, rc));\n+        }\n+\n+        return new JSONObject(props);\n+    }\n+\n+    \/**\n+     * Converts the given Map as a JSONObject.\n+     *\n+     * @param map the Map being converted.\n+     * @return converted JSONObject.\n+     *\/\n+    public static JSONObject from(Map<?,?> map) {\n+        Objects.requireNonNull(map);\n+\n+        JSONObject jo = new JSONObject();\n+        if (map instanceof EnumMap) {\n+            for (Map.Entry<?,?> e : map.entrySet()) {\n+                jo.put(((Enum)e.getKey()).name(),\n+                       from(e.getValue()));\n+            }\n+        } else {\n+            for (Map.Entry<?,?> e : map.entrySet()) {\n+                jo.put(Objects.toString(e.getKey()),\n+                       from(e.getValue()));\n+            }\n+        }\n+\n+        return jo;\n+    }\n+\n+    \/**\n+     * Converts the given JSONValue as a convenient object.\n+     *\n+     * @param jsonValue the JSONValue being converted.\n+     * @param targetTyoe the target type for conversion.\n+     * @return converted convenient object.\n+     *\/\n+    public static Object toObject(JSONValue jsonValue, Type targetType) {\n+        Objects.requireNonNull(jsonValue);\n+        Objects.requireNonNull(targetType);\n+\n+        if (jsonValue.getClass() == targetType) {\n+            return jsonValue;\n+        }\n+\n+        boolean isOptional = false;\n+        if (targetType instanceof ParameterizedType pt &&\n+            pt.getRawType() == Optional.class) {\n+            \/\/ Change the targetType to the underlying Optional value type.\n+            \/\/ We'll wrap the value to be Optional later.\n+            targetType = getFirstTypeArgument(pt);\n+            isOptional = true;\n+        } else if (targetType == Optional.class) {\n+            \/\/ raw Optional type!\n+            targetType = Object.class;\n+            isOptional = true;\n+        }\n+\n+        Object result = switch (jsonValue) {\n+            case JSONObject jo -> convertObject(jo, targetType);\n+            case JSONArray ja -> convertArray(ja, targetType);\n+            case JSONNull jn -> convertNull(jn, targetType);\n+            case JSONBoolean jb -> convertBoolean(jb, targetType);\n+            case JSONNumber jn -> convertNumber(jn, targetType);\n+            case JSONDecimal jd -> convertDecimal(jd, targetType);\n+            case JSONString js -> convertString(js, targetType);\n+        };\n+\n+        \/\/ wrap the return value if the target is an Optional type\n+        return isOptional ? Optional.ofNullable(result) : result;\n+    }\n+\n+    \/**\n+     * Converts the given JSONValue as a convenient object.\n+     *\n+     * @param jsonValue the JSONValue being converted.\n+     * @return converted convenient object.\n+     *\/\n+    public static Object toObject(JSONValue jsonValue) {\n+        return toObject(jsonValue, Object.class);\n+    }\n+\n+    \/**\n+     * Converts the given JSONObject as a record.\n+     *\n+     * @param jsonObj the JSONValue being converted.\n+     * @param cls the target record Class type.\n+     * @return converted record.\n+     *\/\n+    public static <T extends Record> T toRecord(JSONObject jsonObj, Class<T> cls) {\n+        Objects.requireNonNull(jsonObj);\n+        Objects.requireNonNull(cls);\n+\n+        Constructor<? extends Record> cons = getRecordConstructor(cls);\n+        Object[] params = Arrays.stream(cls.getRecordComponents()).\n+              map(rc -> {\n+                  String rcName = rc.getName();\n+                  Type rcType = rc.getGenericType();\n+                  if (jsonObj.contains(rcName)) {\n+                     return toObject(jsonObj.get(rcName), rcType);\n+                  } else {\n+                     \/\/ It is okay to miss an optional record component.\n+                     \/\/ Return the corresponding Optional empty value\n+                     \/\/ for the missing properties.\n+                     if (rcType == OptionalInt.class) {\n+                         return OptionalInt.empty();\n+                     } else if (rcType == OptionalLong.class) {\n+                         return OptionalLong.empty();\n+                     } else if (rcType == OptionalDouble.class) {\n+                         return OptionalDouble.empty();\n+                     } else if (isOptionalType(rcType)) {\n+                         return Optional.empty();\n+                     } else {\n+                         \/\/ non-Optional property. report missing property value error.\n+                         throw new RuntimeException(\"cannot find value for property: \" + rcName);\n+                     }\n+                  }\n+              }).\n+              toArray();\n+        try {\n+            return cls.cast(cons.newInstance(params));\n+        } catch (ReflectiveOperationException roe) {\n+            throw new RuntimeException(roe);\n+        }\n+    }\n+\n+    \/**\n+     * Converts the given JSONObject as a Map.\n+     *\n+     * @param jsonObj the JSONValue being converted.\n+     * @return converted Map.\n+     *\/\n+    public static Map<String, Object> toMap(JSONObject jsonObj) {\n+        return toMap(jsonObj, String.class, Object.class);\n+    }\n+\n+    \/**\n+     * Converts the given JSONObject as a Map.\n+     *\n+     * @param jsonObj the JSONValue being converted.\n+     * @param keyType the target key type for the Map.\n+     * @param valueType the value key type for the Map.\n+     * @return converted Map.\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K,V> Map<K, V> toMap(JSONObject jsonObj, Class<K> keyType, Class<V> valueType) {\n+        Objects.requireNonNull(jsonObj);\n+        Objects.requireNonNull(keyType);\n+        Objects.requireNonNull(valueType);\n+        return (Map<K, V>) convertToMap(jsonObj, keyType, valueType);\n+    }\n+\n+    \/**\n+     * Converts the given JSONObject as a EnumMap.\n+     *\n+     * @param jsonObj the JSONValue being converted.\n+     * @param enumCls the target enum key Class for the Map.\n+     * @param valueType the value key type for the map.\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K extends Enum<K>, V> EnumMap<K, V> toEnumMap(JSONObject jsonObj,\n+                Class<K> enumCls, Class<V> valueType) {\n+        Objects.requireNonNull(jsonObj);\n+        Objects.requireNonNull(enumCls);\n+        Objects.requireNonNull(valueType);\n+\n+        return (EnumMap<K, V>) convertToEnumMap(jsonObj, enumCls, valueType);\n+    }\n+\n+    \/\/ package private helpers for JSONArrays\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> List<T> toList(JSONArray ja, Class<T> elemType) {\n+        return (List<T>) convertToList(ja, elemType);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> Set<T> toSet(JSONArray ja, Class<T> elemType) {\n+        return (Set<T>) convertToSet(ja, elemType);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <T extends Enum<T>> EnumSet<T> toEnumSet(JSONArray ja, Class<T> enumCls) {\n+        return (EnumSet<T>) convertToEnumSet(ja, enumCls);\n+    }\n+\n+    \/\/ Internals only below this point\n+\n+    \/\/ Type helpers\n+\n+    \/\/ is the given Type Optional raw type or Optional<T>?\n+    private static boolean isOptionalType(Type type) {\n+        return type == Optional.class ||\n+            (type instanceof ParameterizedType pt &&\n+            pt.getRawType() == Optional.class);\n+    }\n+\n+    \/\/ is this a List\/ArrayList\/Iterable?\n+    private static boolean isListOrIterable(Class<?> cls) {\n+        return cls == List.class || cls == ArrayList.class || cls == Iterable.class;\n+    }\n+\n+    \/\/ is this a Set\/HashSet\/LinkedHashSet?\n+    private static boolean isSet(Class<?> cls) {\n+        return cls == Set.class || cls == HashSet.class || cls == LinkedHashSet.class;\n+    }\n+\n+    \/\/ is this a Map\/HashMap\/LinkedHashMap?\n+    private static boolean isMap(Class<?> cls) {\n+        return cls == Map.class || cls == HashMap.class || cls == LinkedHashMap.class;\n+    }\n+\n+    \/\/ is this String or CharSequence class?\n+    private static boolean isStringOrCharSequence(Type type) {\n+        return type == String.class || type == CharSequence.class;\n+    }\n+\n+    \/\/ The ParamerizedType is expected to have only one type argument at most\n+    private static Type getFirstTypeArgument(ParameterizedType pt) {\n+        return getNthTypeArgument(pt, 0);\n+    }\n+\n+    private static Type getSecondTypeArgument(ParameterizedType pt) {\n+        return getNthTypeArgument(pt, 1);\n+    }\n+\n+    private static Type getNthTypeArgument(ParameterizedType pt, int n) {\n+        Type[] typeArgs = pt.getActualTypeArguments();\n+        Type nthType = typeArgs.length > n ? typeArgs[n] : Object.class;\n+        if (nthType instanceof WildcardType wt) {\n+            Type[] upper = wt.getUpperBounds();\n+            Type[] lower = wt.getLowerBounds();\n+            if (upper.length > 0) {\n+                nthType = upper[0];\n+            } else if (lower.length > 0) {\n+                nthType = lower[0];\n+            } else {\n+                nthType = Object.class;\n+            }\n+        }\n+        return nthType;\n+    }\n+\n+    \/\/ record helpers\n+\n+    \/\/ get the record's canonical constructor\n+    private static Constructor<? extends Record> getRecordConstructor(Class<? extends Record> cls) {\n+        Class<?>[] paramTypes = Arrays.stream(cls.getRecordComponents()).\n+            map(RecordComponent::getType).\n+            toArray(Class<?>[]::new);\n+\n+        try {\n+            return cls.getConstructor(paramTypes);\n+        } catch (ReflectiveOperationException roe) {\n+            throw new RuntimeException(\"cannot find canonical constructor\", roe);\n+        }\n+    }\n+\n+    \/\/ get the Record component value as a JSONValue\n+    private static JSONValue getRecordProperty(Record record, RecordComponent rc) {\n+        Object value = null;\n+        try {\n+            value = rc.getAccessor().invoke(record);\n+        } catch (ReflectiveOperationException roe) {\n+            throw new RuntimeException(roe);\n+        }\n+        return from(value);\n+    }\n+\n+    \/\/ JSONValue to convenient Java objects conversion helpers\n+\n+    \/\/ create cannot convert exception\n+    private static RuntimeException cannotConvert(JSONValue jv, Type targetType) {\n+        return new RuntimeException(\"cannot convert \" + jv + \" to \" + targetType.getTypeName());\n+    }\n+\n+    \/\/ JSONObject converter helpers\n+\n+    \/\/ exists only localized SuppressWarnings\n+    @SuppressWarnings(\"unchecked\")\n+    private static Record convertToRecord(JSONObject jo, Class<?> cls) {\n+        assert cls.isRecord();\n+        return toRecord(jo, (Class<? extends Record>)cls);\n+    }\n+\n+    private static Map<?,?> convertToMap(JSONObject jo, Type keyType, Type valueType) {\n+        if (isStringOrCharSequence(keyType)) {\n+            return jo.fields().stream().\n+                collect(Collectors.toMap(JSONObject.Field::name,\n+                    field -> toObject(field.value(), valueType),\n+                    (e1, e2) -> e1, LinkedHashMap::new));\n+        } else {\n+            return jo.fields().stream().\n+                collect(Collectors.toMap(\n+                    field -> toObject(JSONValue.from(field.name()), keyType),\n+                    field -> toObject(field.value(), valueType),\n+                    (e1, e2) -> e1, LinkedHashMap::new));\n+        }\n+    }\n+\n+    private static EnumMap convertToEnumMap(JSONObject jo, ParameterizedType pt) {\n+        assert pt.getRawType() == EnumMap.class;\n+        Type keyType = getFirstTypeArgument(pt);\n+        if (keyType instanceof Class enumCls && enumCls.isEnum()) {\n+            Type valueType = getSecondTypeArgument(pt);\n+            return convertToEnumMap(jo, enumCls, valueType);\n+        }\n+\n+        throw cannotConvert(jo, pt);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static EnumMap convertToEnumMap(JSONObject jo, Class<?> enumCls, Type valueType) {\n+        EnumMap enumMap = new EnumMap(enumCls);\n+        jo.fields().forEach(field -> {\n+            enumMap.put(convertToEnum(field.name(), enumCls),\n+                toObject(field.value(), valueType));\n+        });\n+        return enumMap;\n+    }\n+\n+    private static Object convertObject(JSONObject jo, Type targetType) {\n+        if (targetType instanceof Class cls) {\n+            if (cls.isRecord()) {\n+                return convertToRecord(jo, cls);\n+            } else if (cls == Object.class || isMap(cls)) {\n+                \/\/ convert as Map<String, Object>\n+                return convertToMap(jo, String.class, Object.class);\n+            }\n+        } else if (targetType instanceof ParameterizedType pt) {\n+            if (pt.getRawType() instanceof Class cls) {\n+                if (cls == EnumMap.class) {\n+                    \/\/ EnumMap<K, V>\n+                    return convertToEnumMap(jo, pt);\n+                } else if (isMap(cls)) {\n+                    \/\/ Map<K, V>\n+                    Type keyType = getFirstTypeArgument(pt);\n+                    Type valueType = getSecondTypeArgument(pt);\n+                    return convertToMap(jo, keyType, valueType);\n+                }\n+            }\n+        }\n+\n+        throw cannotConvert(jo, targetType);\n+    }\n+\n+    \/\/ JSONArray converter helpers\n+    private static final Map<Class<?>, Function<JSONArray, Object>> arrayConverters =\n+        new IdentityHashMap<>();\n+\n+    private static void addArrayConverter(Class<?> cls, Function<JSONArray, Object> func) {\n+        arrayConverters.put(cls, func);\n+    }\n+\n+    static {\n+        addArrayConverter(boolean[].class, JSONArrays::toBooleanArray);\n+        addArrayConverter(char[].class, JSONArrays::toCharArray);\n+        addArrayConverter(byte[].class, JSONArrays::toByteArray);\n+        addArrayConverter(int[].class, JSONArrays::toIntArray);\n+        addArrayConverter(long[].class, JSONArrays::toLongArray);\n+        addArrayConverter(float[].class, JSONArrays::toFloatArray);\n+        addArrayConverter(double[].class, JSONArrays::toDoubleArray);\n+        addArrayConverter(Object[].class, JSONArrays::toObjectArray);\n+        addArrayConverter(String[].class, JSONArrays::toStringArray);\n+\n+        \/\/ for Object.class too, we return an Object[]\n+        addArrayConverter(Object.class, JSONArrays::toObjectArray);\n+\n+        \/\/ convert to List cases\n+        Function<JSONArray, Object> listFunc = jo -> convertToList(jo, Object.class);\n+        addArrayConverter(List.class, listFunc);\n+        addArrayConverter(ArrayList.class, listFunc);\n+        addArrayConverter(Iterable.class, listFunc);\n+\n+        \/\/ convert to Map cases\n+        Function<JSONArray, Object> setFunc = jo -> convertToSet(jo, Object.class);\n+        addArrayConverter(Set.class, setFunc);\n+        addArrayConverter(HashSet.class, setFunc);\n+        addArrayConverter(LinkedHashSet.class, setFunc);\n+    }\n+\n+    \/\/ convert the given JSONArray to a Java object of the given Type\n+\n+    private static EnumSet<?> convertToEnumSet(JSONArray ja, ParameterizedType pt) {\n+        assert pt.getRawType() == EnumSet.class;\n+        Type compType = getFirstTypeArgument(pt);\n+        if (compType instanceof Class enumCls && enumCls.isEnum()) {\n+            return convertToEnumSet(ja, enumCls);\n+        } else {\n+            throw cannotConvert(ja, pt);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static EnumSet convertToEnumSet(JSONArray ja, Class enumCls) {\n+        final int length = ja.size();\n+        return switch (length) {\n+            case 0 -> EnumSet.noneOf(enumCls);\n+            case 1 -> EnumSet.of(convertToEnum(ja.get(0).asString(), enumCls));\n+            default -> {\n+                Enum first = convertToEnum(ja.get(0).asString(), enumCls);\n+                Enum[] rest = new Enum[length - 1];\n+                for (int i = 1; i < length; i++) {\n+                    rest[i - 1] = convertToEnum(ja.get(i).asString(), enumCls);\n+                }\n+                yield EnumSet.of(first, rest);\n+            }\n+        };\n+    }\n+\n+    private static List<?> convertToList(JSONArray ja, Type compType) {\n+        List<Object> list = new ArrayList<>();\n+        final int length = ja.size();\n+        for (int i = 0; i < length; i++) {\n+             list.add(toObject(ja.get(i), compType));\n+        }\n+        return list;\n+    }\n+\n+    private static Set<?> convertToSet(JSONArray ja, Type compType) {\n+        Set<Object> set = new LinkedHashSet<>();\n+        final int length = ja.size();\n+        for (int i = 0; i < length; i++) {\n+             set.add(toObject(ja.get(i), compType));\n+        }\n+        return set;\n+    }\n+\n+    private static Object convertArray(JSONArray ja, Type targetType) {\n+        if (targetType instanceof Class cls) {\n+            var func = arrayConverters.get(cls);\n+            if (func != null) {\n+                return func.apply(ja);\n+            } else if (cls.isArray()) {\n+                \/\/ T[] for some type T\n+                Class<?> elemCls = cls.getComponentType();\n+                final int length = ja.size();\n+                Object arr = Array.newInstance(elemCls, length);\n+                for (int i = 0; i < length; i++) {\n+                    Array.set(arr, i, JSONObjects.toObject(ja.get(i), elemCls));\n+                }\n+                return arr;\n+            }\n+        } else if (targetType instanceof ParameterizedType pt) {\n+            if (pt.getRawType() instanceof Class cls) {\n+                \/\/ List<T>, ArrayList<T> or Iterable<T>\n+                if (isListOrIterable(cls)) {\n+                    Type compType = getFirstTypeArgument(pt);\n+                    return convertToList(ja, compType);\n+                \/\/ Set<T>, HashMap<T> or LinkedHashMap<T>\n+                } else if (isSet(cls)) {\n+                    Type compType = getFirstTypeArgument(pt);\n+                    return convertToSet(ja, compType);\n+                \/\/ EnumSet<T>\n+                } else if (cls == EnumSet.class) {\n+                    return convertToEnumSet(ja, pt);\n+                }\n+            }\n+        }\n+\n+        throw cannotConvert(ja, targetType);\n+    }\n+\n+    \/\/ convert JSONNull value to a Java oject of the given Type\n+    private static Object convertNull(JSONNull jn, Type targetType) {\n+        if (targetType instanceof Class cls && cls.isPrimitive()) {\n+            throw cannotConvert(jn, targetType);\n+        } else if (targetType == OptionalInt.class) {\n+            return OptionalInt.empty();\n+        } else if (targetType == OptionalLong.class) {\n+            return OptionalLong.empty();\n+        } else if (targetType == OptionalDouble.class) {\n+            return OptionalDouble.empty();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    \/\/ convert the JSONBoolean value to a Java object of the given Type\n+    private static Object convertBoolean(JSONBoolean jb, Type targetType) {\n+        if (targetType == boolean.class ||\n+            targetType == Boolean.class ||\n+            targetType == Object.class) {\n+            return jb.asBoolean();\n+        } else {\n+            throw cannotConvert(jb, targetType);\n+        }\n+    }\n+\n+    private static final Map<Class<?>, Function<JSONNumber, Object>> numberConverters =\n+        new IdentityHashMap<>();\n+\n+    private static void addNumberConverter(Class<?> cls, Function<JSONNumber, Object> func) {\n+        numberConverters.put(cls, func);\n+    }\n+\n+    static {\n+        addNumberConverter(byte.class, JSONNumber::asByte);\n+        addNumberConverter(Byte.class, JSONNumber::asByte);\n+        addNumberConverter(short.class, JSONNumber::asShort);\n+        addNumberConverter(Short.class, JSONNumber::asShort);\n+        addNumberConverter(int.class, JSONNumber::asInt);\n+        addNumberConverter(Integer.class, JSONNumber::asInt);\n+        addNumberConverter(long.class, JSONNumber::asLong);\n+        addNumberConverter(Long.class, JSONNumber::asLong);\n+        addNumberConverter(OptionalInt.class, jn -> OptionalInt.of(jn.asInt()));\n+        addNumberConverter(OptionalLong.class, jn -> OptionalLong.of(jn.asLong()));\n+        addNumberConverter(BigInteger.class, jn -> BigInteger.valueOf(jn.asLong()));\n+        addNumberConverter(BigDecimal.class, jn -> BigDecimal.valueOf(jn.asLong()));\n+        Function<JSONNumber, Object> intOrLong = jn -> {\n+            try {\n+                 return jn.asInt();\n+            } catch (ArithmeticException ae) {\n+                 return jn.asLong();\n+            }\n+        };\n+        addNumberConverter(Number.class, intOrLong);\n+        addNumberConverter(Object.class, intOrLong);\n+    }\n+\n+    \/\/ convert the JSONNumber value to a Java object of the given Type\n+    private static Object convertNumber(JSONNumber jn, Type targetType) {\n+        var func = numberConverters.get(targetType);\n+        if (func != null) {\n+            return func.apply(jn);\n+        } else {\n+            throw cannotConvert(jn, targetType);\n+        }\n+    }\n+\n+    private static final Map<Class<?>, Function<JSONDecimal, Object>> decimalConverters =\n+        new IdentityHashMap<>();\n+\n+    private static void addDecimalConverter(Class<?> cls, Function<JSONDecimal, Object> func) {\n+        decimalConverters.put(cls, func);\n+    }\n+\n+    static {\n+        addDecimalConverter(double.class, JSONDecimal::asDouble);\n+        addDecimalConverter(Double.class, JSONDecimal::asDouble);\n+        addDecimalConverter(Number.class, JSONDecimal::asDouble);\n+        addDecimalConverter(Object.class, JSONDecimal::asDouble);\n+        addDecimalConverter(float.class, JSONDecimal::asFloat);\n+        addDecimalConverter(Float.class, JSONDecimal::asFloat);\n+        addDecimalConverter(OptionalDouble.class, jd -> OptionalDouble.of(jd.asDouble()));\n+        addDecimalConverter(BigDecimal.class, jd -> BigDecimal.valueOf(jd.asDouble()));\n+    }\n+\n+    \/\/ convert the JSONDecimal value to a Java object of the given Type\n+    private static Object convertDecimal(JSONDecimal jd, Type targetType) {\n+        var func = decimalConverters.get(targetType);\n+        if (func != null) {\n+            return func.apply(jd);\n+        } else {\n+            throw cannotConvert(jd, targetType);\n+        }\n+    }\n+\n+    \/\/ exists only localized SuppressWarnings\n+    @SuppressWarnings(\"unchecked\")\n+    private static Enum convertToEnum(String str, Class<?> cls) {\n+        assert cls.isEnum();\n+        return Enum.valueOf((Class<? extends Enum>)cls, str);\n+    }\n+\n+    \/\/ special case String to object parse helpers\n+    private static BigInteger parseBigInteger(String str) {\n+        return new BigInteger(str);\n+    }\n+\n+    private static BigDecimal parseBigDecimal(String str) {\n+        return new BigDecimal(str);\n+    }\n+\n+    private static File parseFile(String str) {\n+        return new File(str);\n+    }\n+\n+    private static Number parseBigNumber(String str) {\n+        try {\n+            return new BigInteger(str);\n+        } catch (NumberFormatException nfe) {\n+            \/\/ Try as BigDecimal\n+            return new BigDecimal(str);\n+        }\n+    }\n+\n+    private static Path parsePath(String str) {\n+        return Path.of(str);\n+    }\n+\n+    private static URL parseURL(String str) {\n+        try {\n+            return URI.create(str).toURL();\n+        } catch (MalformedURLException mue) {\n+            throw new RuntimeException(mue);\n+        }\n+    }\n+\n+    \/\/ String -> Java type parse helper functions cache\n+    private static final Map<Class<?>, Function<String, Object>> parseFunctions =\n+        new IdentityHashMap<>();\n+\n+    private static void addParseFuncToCache(Class<?> cls, Function<String, Object> func) {\n+        parseFunctions.put(cls, func);\n+    }\n+\n+    private static void addParseFuncToCache(Class<?> cls, Method m) {\n+        parseFunctions.put(cls, methodToFunction(m));\n+    }\n+\n+    \/\/ wrap a static Method as a Function\n+    private static Function<String, Object> methodToFunction(Method m) {\n+        Function<String, Object> func = str -> {\n+            try {\n+                return m.invoke(null, str);\n+            } catch (ReflectiveOperationException roe) {\n+                throw new RuntimeException(roe);\n+            }\n+        };\n+        return func;\n+    }\n+\n+    static {\n+        \/\/ special case parse methods\n+        addParseFuncToCache(BigInteger.class, JSONObjects::parseBigInteger);\n+        addParseFuncToCache(BigDecimal.class, JSONObjects::parseBigDecimal);\n+        addParseFuncToCache(File.class, JSONObjects::parseFile);\n+        addParseFuncToCache(Number.class, JSONObjects::parseBigNumber);\n+        addParseFuncToCache(Path.class, JSONObjects::parsePath);\n+        addParseFuncToCache(URL.class, JSONObjects::parseURL);\n+\n+        \/\/ specific method wrapping cases\n+        try {\n+            addParseFuncToCache(Pattern.class, Pattern.class.getMethod(\"compile\", String.class));\n+            addParseFuncToCache(URI.class, URI.class.getMethod(\"create\", String.class));\n+        } catch (ReflectiveOperationException roe) {\n+            throw new RuntimeException(roe);\n+        }\n+    }\n+\n+    private static Optional<Function<String, Object>> findParseFunction(Class<?> cls) {\n+        \/\/ check the cache\n+        if (parseFunctions.containsKey(cls)) {\n+            return Optional.of(parseFunctions.get(cls));\n+        }\n+\n+        var optMethod = Arrays.stream(cls.getMethods()).\n+            filter(mth -> Modifier.isStatic(mth.getModifiers()) &&\n+                   mth.getParameterCount() == 1 &&\n+                   mth.getName().equals(\"parse\") &&\n+                   mth.getReturnType() == cls &&\n+                   isStringOrCharSequence(mth.getParameterTypes()[0])).\n+            findFirst();\n+\n+        if (optMethod.isPresent()) {\n+            var func = methodToFunction(optMethod.get());\n+            \/\/ cache for future - only for bootstrap classes\n+            if (cls.getClassLoader() == null) {\n+                addParseFuncToCache(cls, func);\n+            }\n+            return Optional.of(func);\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    \/\/ convert the JSONString value to a Java object of the given Type\n+    private static Object convertString(JSONString js, Type targetType) {\n+        if (isStringOrCharSequence(targetType)) {\n+            return js.asString();\n+        } else if (targetType == char.class ||\n+                   targetType == Character.class) {\n+            return js.asChar();\n+        } else if (targetType == Object.class) {\n+            \/\/ return Character or String object depending on the length\n+            String str = js.asString();\n+            return str.length() == 1 ? Character.valueOf(str.charAt(0)) : str;\n+        } else if (targetType instanceof Class cls) {\n+            if (cls.isEnum()) {\n+                return convertToEnum(js.asString(), cls);\n+            } else {\n+                \/\/ check if we can convert the JSON String value to an object\n+                \/\/ of the given target type by a type specific \"parse\" function.\n+                var optFunc = findParseFunction(cls);\n+                if (optFunc.isPresent()) {\n+                    return optFunc.get().apply(js.asString());\n+                }\n+            }\n+        }\n+\n+        throw cannotConvert(js, targetType);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/json\/JSONObjects.java","additions":826,"deletions":0,"binary":false,"changes":826,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.json.parser;\n+\n+public final class JSON {\n+    private JSON() {}\n+\n+    public static JSONValue parse(String s) {\n+        return new JSONParser().parse(s);\n+    }\n+\n+    public static JSONValue of(int i) {\n+        return JSONValue.from(i);\n+    }\n+\n+    public static JSONValue of(long l) {\n+        return JSONValue.from(l);\n+    }\n+\n+    public static JSONValue of(double d) {\n+        return JSONValue.from(d);\n+    }\n+\n+    public static JSONValue of(boolean b) {\n+        return JSONValue.from(b);\n+    }\n+\n+    public static JSONValue of(String s) {\n+        return JSONValue.from(s);\n+    }\n+\n+    public static JSONValue of() {\n+        return JSONValue.fromNull();\n+    }\n+\n+    public static JSONArray array() {\n+        return new JSONArray();\n+    }\n+\n+    public static JSONObject object() {\n+        return new JSONObject();\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/json\/parser\/JSON.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.json.parser;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+public final class JSONArray implements JSONValue, Iterable<JSONValue> {\n+    private final List<JSONValue> values;\n+\n+    public JSONArray() {\n+        this.values = new ArrayList<>();\n+    }\n+\n+    public JSONArray(JSONValue[] array) {\n+        this.values = new ArrayList<>(array.length);\n+        for (var v : array) {\n+            values.add(v);\n+        }\n+    }\n+\n+    public JSONArray(List<JSONValue> values) {\n+        this.values = new ArrayList<>(values);\n+    }\n+\n+    @Override\n+    public boolean isArray() {\n+        return true;\n+    }\n+\n+    @Override\n+    public JSONArray asArray() {\n+        return this;\n+    }\n+\n+    public JSONArray set(int i, boolean value) {\n+        values.set(i, JSON.of(value));\n+        return this;\n+    }\n+\n+    public JSONArray set(int i, int value) {\n+        values.set(i, JSON.of(value));\n+        return this;\n+    }\n+\n+    public JSONArray set(int i, long value) {\n+        values.set(i, JSON.of(value));\n+        return this;\n+    }\n+\n+    public JSONArray set(int i, String value) {\n+        values.set(i, JSON.of(value));\n+        return this;\n+    }\n+\n+    public JSONArray set(int i, double value) {\n+        values.set(i, JSON.of(value));\n+        return this;\n+    }\n+\n+    public JSONArray set(int i, JSONValue value) {\n+        values.set(i, value);\n+        return this;\n+    }\n+\n+    public JSONArray setNull(int i) {\n+        values.set(i, JSON.of());\n+        return this;\n+    }\n+\n+    public JSONArray add(boolean value) {\n+        values.add(JSON.of(value));\n+        return this;\n+    }\n+\n+    public JSONArray add(int value) {\n+        values.add(JSON.of(value));\n+        return this;\n+    }\n+\n+    public JSONArray add(long value) {\n+        values.add(JSON.of(value));\n+        return this;\n+    }\n+\n+    public JSONArray add(String value) {\n+        values.add(JSON.of(value));\n+        return this;\n+    }\n+\n+    public JSONArray add(double value) {\n+        values.add(JSON.of(value));\n+        return this;\n+    }\n+\n+    public JSONArray add(JSONValue value) {\n+        values.add(value);\n+        return this;\n+    }\n+\n+    public JSONArray addNull() {\n+        values.add(JSON.of());\n+        return this;\n+    }\n+\n+    public JSONValue get(int i) {\n+        return values.get(i);\n+    }\n+\n+    public int size() {\n+        return values.size();\n+    }\n+\n+    public boolean isEmpty() {\n+        return values.isEmpty();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        var builder = new StringBuilder();\n+\n+        builder.append(\"[\");\n+        for (var i = 0; i < size(); i++) {\n+            builder.append(get(i).toString());\n+            if (i != (size() - 1)) {\n+                builder.append(\",\");\n+            }\n+        }\n+        builder.append(\"]\");\n+        return builder.toString();\n+    }\n+\n+    @Override\n+    public Stream<JSONValue> stream() {\n+        return values.stream();\n+    }\n+\n+    @Override\n+    public Iterator<JSONValue> iterator() {\n+        return values.iterator();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        JSONArray that = (JSONArray) o;\n+        return values.equals(that.values);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(values);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/json\/parser\/JSONArray.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.json.parser;\n+\n+import java.util.Objects;\n+\n+public final class JSONBoolean implements JSONValue {\n+    private final boolean value;\n+\n+    public JSONBoolean(boolean value) {\n+        this.value = value;\n+    }\n+\n+    @Override\n+    public boolean isBoolean() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean asBoolean() {\n+        return value;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return value ? \"true\" : \"false\";\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        JSONBoolean that = (JSONBoolean) o;\n+        return value == that.value;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(value);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/json\/parser\/JSONBoolean.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.json.parser;\n+\n+import java.util.Objects;\n+\n+public final class JSONDecimal implements JSONValue {\n+    private final double value;\n+\n+    public JSONDecimal(double value) {\n+        this.value = value;\n+    }\n+\n+    @Override\n+    public boolean isDouble() {\n+        return true;\n+    }\n+\n+    @Override\n+    public float asFloat() {\n+        return (float) value;\n+    }\n+\n+    @Override\n+    public double asDouble() {\n+        return value;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Double.toString(value);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        JSONDecimal that = (JSONDecimal) o;\n+        return Double.compare(that.value, value) == 0;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(value);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/json\/parser\/JSONDecimal.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.json.parser;\n+\n+public final class JSONNull implements JSONValue {\n+    static final JSONNull instance = new JSONNull();\n+\n+    private JSONNull() {\n+    }\n+\n+    @Override\n+    public boolean isNull() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String asString() {\n+        return null;\n+    }\n+\n+    @Override\n+    public JSONArray asArray() {\n+        return null;\n+    }\n+\n+    @Override\n+    public JSONObject asObject() {\n+        return null;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"null\";\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/json\/parser\/JSONNull.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.json.parser;\n+\n+import java.util.Objects;\n+\n+public final class JSONNumber implements JSONValue {\n+    private final long value;\n+\n+    public JSONNumber(int value) {\n+        this.value = (long) value;\n+    }\n+\n+    public JSONNumber(long value) {\n+        this.value = value;\n+    }\n+\n+    @Override\n+    public boolean isInt() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isLong() {\n+        return true;\n+    }\n+\n+    @Override\n+    public byte asByte() {\n+        int v = asInt();\n+        if ((byte)v != v) {\n+            throw new ArithmeticException(\"byte overflow: \" + value);\n+        }\n+        return (byte) v;\n+    }\n+\n+    @Override\n+    public short asShort() {\n+        int v = asInt();\n+        if ((short)v != v) {\n+            throw new ArithmeticException(\"short overflow: \" + value);\n+        }\n+        return (short) v;\n+    }\n+\n+    @Override\n+    public int asInt() {\n+        return Math.toIntExact(value);\n+    }\n+\n+    @Override\n+    public long asLong() {\n+        return value;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Long.toString(value);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        JSONNumber that = (JSONNumber) o;\n+        return value == that.value;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(value);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/json\/parser\/JSONNumber.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.json.parser;\n+\n+import java.util.Map;\n+import java.util.List;\n+import java.util.LinkedHashMap;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public final class JSONObject implements JSONValue {\n+    public static class Field {\n+        private final String name;\n+        private final JSONValue value;\n+\n+        private Field(String name, JSONValue value) {\n+            this.name = name;\n+            this.value = value;\n+        }\n+\n+        public String name() {\n+            return name;\n+        }\n+\n+        public JSONValue value() {\n+            return value;\n+        }\n+    }\n+\n+    private final Map<String, JSONValue> value;\n+\n+    public JSONObject() {\n+        this(new LinkedHashMap<>(), false);\n+    }\n+\n+    public JSONObject(Map<String, JSONValue> map) {\n+        this(map, true);\n+    }\n+\n+    \/\/ package private helper to avoid copying the map\n+    JSONObject(Map<String, JSONValue> map, boolean copy) {\n+        this.value = copy ? new LinkedHashMap<>(map) : map;\n+    }\n+\n+    @Override\n+    public boolean isObject() {\n+        return true;\n+    }\n+\n+    @Override\n+    public JSONObject asObject() {\n+        return this;\n+    }\n+\n+    public JSONObject put(String k, boolean v) {\n+        value.put(k, JSON.of(v));\n+        return this;\n+    }\n+\n+    public JSONObject put(String k, int v) {\n+        value.put(k, JSON.of(v));\n+        return this;\n+    }\n+\n+    public JSONObject put(String k, long v) {\n+        value.put(k, JSON.of(v));\n+        return this;\n+    }\n+\n+    public JSONObject put(String k, String v) {\n+        value.put(k, JSON.of(v));\n+        return this;\n+    }\n+\n+    public JSONObject put(String k, double v) {\n+        value.put(k, JSON.of(v));\n+        return this;\n+    }\n+\n+    public JSONObject put(String k, JSONArray v) {\n+        value.put(k, v);\n+        return this;\n+    }\n+\n+    public JSONObject put(String k, JSONObject v) {\n+        value.put(k, v);\n+        return this;\n+    }\n+\n+    public JSONObject put(String k, JSONValue v) {\n+        value.put(k, v);\n+        return this;\n+    }\n+\n+    public JSONObject putNull(String k) {\n+        value.put(k, JSON.of());\n+        return this;\n+    }\n+\n+    public JSONObject remove(String k) {\n+        value.remove(k);\n+        return this;\n+    }\n+\n+    public JSONValue get(String k) {\n+        return value.get(k);\n+    }\n+\n+    public JSONValue getOrDefault(String k, JSONValue fallback) {\n+        return value.getOrDefault(k, fallback);\n+    }\n+\n+    public List<Field> fields() {\n+        return value.entrySet()\n+                    .stream()\n+                    .map(e -> new Field(e.getKey(), e.getValue()))\n+                    .collect(Collectors.toList());\n+    }\n+\n+    public boolean contains(String field) {\n+        return value.containsKey(field);\n+    }\n+\n+    public int size() {\n+        return value.size();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        var builder = new StringBuilder();\n+        builder.append(\"{\");\n+        for (var key : value.keySet()) {\n+            builder.append(\"\\\"\");\n+            builder.append(key);\n+            builder.append(\"\\\":\");\n+            builder.append(value.get(key).toString());\n+            builder.append(\",\");\n+        }\n+\n+        var end = builder.length() - 1;\n+        if (builder.charAt(end) == ',') {\n+            builder.deleteCharAt(end);\n+        }\n+\n+        builder.append(\"}\");\n+        return builder.toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        JSONObject that = (JSONObject) o;\n+        return value.equals(that.value);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(value);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/json\/parser\/JSONObject.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,472 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.json.parser;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.Optional;\n+\n+public final class JSONParser {\n+    private int pos = 0;\n+    private String input;\n+    private final boolean allowComments;\n+    private final boolean allowTrailingCommas;\n+\n+    public JSONParser() {\n+        this(false, false);\n+    }\n+\n+    public JSONParser(boolean allowComments, boolean allowTrailingCommas) {\n+        this.allowComments = allowComments;\n+        this.allowTrailingCommas = allowTrailingCommas;\n+    }\n+\n+    private IllegalStateException failure(String message) {\n+        return new IllegalStateException(String.format(\"[%d]: %s : %s\", pos, message, input));\n+    }\n+\n+    private char current() {\n+        return input.charAt(pos);\n+    }\n+\n+    private Optional<Character> next() {\n+        var nextPos = pos + 1;\n+        return nextPos < input.length() ?\n+            Optional.of(input.charAt(nextPos)) : Optional.empty();\n+    }\n+\n+    private void advance() {\n+        pos++;\n+    }\n+\n+    private boolean hasInput() {\n+        return pos < input.length();\n+    }\n+\n+    private void expectMoreInput(String message) {\n+        if (!hasInput()) {\n+            throw failure(message);\n+        }\n+    }\n+\n+    private char next(String message) {\n+        advance();\n+        if (!hasInput()) {\n+            throw failure(message);\n+        }\n+        return current();\n+    }\n+\n+\n+    private void expect(char c) {\n+        var msg = String.format(\"Expected character %c\", c);\n+\n+        var n = next(msg);\n+        if (n != c) {\n+            throw failure(msg);\n+        }\n+    }\n+\n+    private void assume(char c, String message) {\n+        expectMoreInput(message);\n+        if (current() != c) {\n+            throw failure(message);\n+        }\n+    }\n+\n+    private JSONBoolean parseBoolean() {\n+        if (current() == 't') {\n+            expect('r');\n+            expect('u');\n+            expect('e');\n+            advance();\n+            return new JSONBoolean(true);\n+        }\n+\n+        if (current() == 'f') {\n+            expect('a');\n+            expect('l');\n+            expect('s');\n+            expect('e');\n+            advance();\n+            return new JSONBoolean(false);\n+        }\n+\n+        throw failure(\"a boolean can only be 'true' or 'false'\");\n+    }\n+\n+    private JSONValue parseNumber() {\n+        var isInteger = true;\n+        var builder = new StringBuilder();\n+\n+        if (current() == '-') {\n+            builder.append(current());\n+            advance();\n+            expectMoreInput(\"a number cannot consist of only '-'\");\n+        }\n+\n+        if (current() == '0') {\n+            builder.append(current());\n+            advance();\n+\n+            if (hasInput() && current() == '.') {\n+                isInteger = false;\n+                builder.append(current());\n+                advance();\n+\n+                expectMoreInput(\"a number cannot end with '.'\");\n+\n+                if (!isDigit(current())) {\n+                    throw failure(\"must be at least one digit after '.'\");\n+                }\n+\n+                while (hasInput() && isDigit(current())) {\n+                    builder.append(current());\n+                    advance();\n+                }\n+            }\n+        } else {\n+            while (hasInput() && isDigit(current())) {\n+                builder.append(current());\n+                advance();\n+            }\n+\n+            if (hasInput() && current() == '.') {\n+                isInteger = false;\n+                builder.append(current());\n+                advance();\n+\n+                expectMoreInput(\"a number cannot end with '.'\");\n+\n+                if (!isDigit(current())) {\n+                    throw failure(\"must be at least one digit after '.'\");\n+                }\n+\n+                while (hasInput() && isDigit(current())) {\n+                    builder.append(current());\n+                    advance();\n+                }\n+            }\n+        }\n+\n+        if (hasInput() && (current() == 'e' || current() == 'E')) {\n+            isInteger = false;\n+\n+            builder.append(current());\n+            advance();\n+            expectMoreInput(\"a number cannot end with 'e' or 'E'\");\n+\n+            if (current() == '+' || current() == '-') {\n+                builder.append(current());\n+                advance();\n+            }\n+\n+            if (!isDigit(current())) {\n+                throw failure(\"a digit must follow {'e','E'}{'+','-'}\");\n+            }\n+\n+            while (hasInput() && isDigit(current())) {\n+                builder.append(current());\n+                advance();\n+            }\n+        }\n+\n+        var value = builder.toString();\n+        return isInteger ? new JSONNumber(Long.parseLong(value)) :\n+                           new JSONDecimal(Double.parseDouble(value));\n+\n+    }\n+\n+    private JSONString parseString() {\n+        var missingEndChar = \"string is not terminated with '\\\"'\";\n+        var builder = new StringBuilder();\n+        for (var c = next(missingEndChar); c != '\"'; c = next(missingEndChar)) {\n+            if (c == '\\\\') {\n+                var n = next(missingEndChar);\n+                switch (n) {\n+                    case '\"':\n+                        builder.append(\"\\\"\");\n+                        break;\n+                    case '\\\\':\n+                        builder.append(\"\\\\\");\n+                        break;\n+                    case '\/':\n+                        builder.append(\"\/\");\n+                        break;\n+                    case 'b':\n+                        builder.append(\"\\b\");\n+                        break;\n+                    case 'f':\n+                        builder.append(\"\\f\");\n+                        break;\n+                    case 'n':\n+                        builder.append(\"\\n\");\n+                        break;\n+                    case 'r':\n+                        builder.append(\"\\r\");\n+                        break;\n+                    case 't':\n+                        builder.append(\"\\t\");\n+                        break;\n+                    case 'u':\n+                        var u1 = next(missingEndChar);\n+                        var u2 = next(missingEndChar);\n+                        var u3 = next(missingEndChar);\n+                        var u4 = next(missingEndChar);\n+                        var cp = Integer.parseInt(String.format(\"%c%c%c%c\", u1, u2, u3, u4), 16);\n+                        builder.append(new String(new int[]{cp}, 0, 1));\n+                        break;\n+                    default:\n+                        throw failure(String.format(\"Unexpected escaped character '%c'\", n));\n+                }\n+            } else {\n+                builder.append(c);\n+            }\n+        }\n+\n+        advance(); \/\/ step beyond closing \"\n+        return new JSONString(builder.toString());\n+    }\n+\n+    private JSONArray parseArray() {\n+        var error = \"array is not terminated with ']'\";\n+        var list = new ArrayList<JSONValue>();\n+\n+        advance(); \/\/ step beyond opening '['\n+        if (allowComments) {\n+            consumeCommentsAndWhitespace();\n+        } else {\n+            consumeWhitespace();\n+        }\n+        expectMoreInput(error);\n+\n+        while (current() != ']') {\n+            var val = parseValue();\n+            list.add(val);\n+\n+            expectMoreInput(error);\n+            if (current() == ',') {\n+                advance();\n+                if (allowTrailingCommas) {\n+                    if (allowComments) {\n+                        consumeCommentsAndWhitespace();\n+                    } else {\n+                        consumeWhitespace();\n+                    }\n+                }\n+            }\n+            expectMoreInput(error);\n+        }\n+\n+        advance(); \/\/ step beyond closing ']'\n+        return new JSONArray(list.toArray(new JSONValue[0]));\n+    }\n+\n+    public JSONNull parseNull() {\n+        expect('u');\n+        expect('l');\n+        expect('l');\n+        advance();\n+        return JSONNull.instance;\n+    }\n+\n+    public JSONObject parseObject() {\n+        var error = \"object is not terminated with '}'\";\n+        var map = new LinkedHashMap<String, JSONValue>();\n+\n+        advance(); \/\/ step beyond opening '{'\n+        if (allowComments) {\n+            consumeCommentsAndWhitespace();\n+        } else {\n+            consumeWhitespace();\n+        }\n+        expectMoreInput(error);\n+\n+        while (current() != '}') {\n+            var key = parseValue();\n+            if (!(key instanceof JSONString)) {\n+                throw failure(\"a field must of type string\");\n+            }\n+\n+            if (!hasInput() || current() != ':') {\n+                throw failure(\"a field must be followed by ':'\");\n+            }\n+            advance(); \/\/ skip ':'\n+\n+            var val = parseValue();\n+            map.put(key.asString(), val);\n+\n+            expectMoreInput(error);\n+            if (current() == ',') {\n+                advance();\n+                if (allowTrailingCommas) {\n+                    if (allowComments) {\n+                        consumeCommentsAndWhitespace();\n+                    } else {\n+                        consumeWhitespace();\n+                    }\n+                }\n+            }\n+            expectMoreInput(error);\n+        }\n+\n+        advance(); \/\/ step beyond '}'\n+        return new JSONObject(map, false \/* do not copy *\/);\n+    }\n+\n+    private boolean isDigit(char c) {\n+        return c == '0' ||\n+               c == '1' ||\n+               c == '2' ||\n+               c == '3' ||\n+               c == '4' ||\n+               c == '5' ||\n+               c == '6' ||\n+               c == '7' ||\n+               c == '8' ||\n+               c == '9';\n+    }\n+\n+    private boolean isStartOfNumber(char c) {\n+        return isDigit(c) || c == '-';\n+    }\n+\n+    private boolean isStartOfString(char c) {\n+        return c == '\"';\n+    }\n+\n+    private boolean isStartOfBoolean(char c) {\n+        return c == 't' || c == 'f';\n+    }\n+\n+    private boolean isStartOfArray(char c) {\n+        return c == '[';\n+    }\n+\n+    private boolean isStartOfNull(char c) {\n+        return c == 'n';\n+    }\n+\n+    private boolean isWhitespace(char c) {\n+        return c == '\\r' ||\n+               c == '\\n' ||\n+               c == '\\t' ||\n+               c == ' ';\n+    }\n+\n+    private boolean isStartOfObject(char c) {\n+        return c == '{';\n+    }\n+\n+    private void consumeCommentsAndWhitespace() {\n+        while (hasInput() && (isWhitespace(current()) || isComment())) {\n+            consumeWhitespace();\n+            consumeComment();\n+        }\n+    }\n+\n+    private boolean isComment() {\n+        return hasInput() &&\n+               current() == '\/' &&\n+               (next().equals(Optional.of('*')) || next().equals(Optional.of('\/')));\n+    }\n+\n+    private void consumeComment() {\n+        if (isComment()) {\n+            advance();\n+            if (current() == '\/') {\n+                advance();\n+                while (hasInput() && current() != '\\n') {\n+                    advance();\n+                }\n+            } else {\n+                advance();\n+                while (hasInput()) {\n+                    if (current() == '*' && next().equals(Optional.of('\/'))) {\n+                        advance();\n+                        advance();\n+                        break;\n+                    }\n+                    advance();\n+                }\n+            }\n+        }\n+    }\n+\n+    private void consumeWhitespace() {\n+        while (hasInput() && isWhitespace(current())) {\n+            advance();\n+        }\n+    }\n+\n+    public JSONValue parseValue() {\n+        JSONValue ret = null;\n+\n+        if (allowComments) {\n+            consumeCommentsAndWhitespace();\n+        } else {\n+            consumeWhitespace();\n+        }\n+        if (hasInput()) {\n+            var c = current();\n+\n+            if (isStartOfNumber(c)) {\n+                ret = parseNumber();\n+            } else if (isStartOfString(c)) {\n+                ret = parseString();\n+            } else if (isStartOfBoolean(c)) {\n+                ret = parseBoolean();\n+            } else if (isStartOfArray(c)) {\n+                ret = parseArray();\n+            } else if (isStartOfNull(c)) {\n+                ret = parseNull();\n+            } else if (isStartOfObject(c)) {\n+                ret = parseObject();\n+            } else {\n+                throw failure(\"not a valid start of a JSON value\");\n+            }\n+        }\n+        if (allowComments) {\n+            consumeCommentsAndWhitespace();\n+        } else {\n+            consumeWhitespace();\n+        }\n+\n+        return ret;\n+    }\n+\n+    public JSONValue parse(String s) {\n+        if (s == null || s.equals(\"\")) {\n+            return null;\n+        }\n+\n+        pos = 0;\n+        input = s;\n+\n+        var result = parseValue();\n+        if (hasInput()) {\n+            throw failure(\"can only have one top-level JSON value\");\n+        }\n+        return result;\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/json\/parser\/JSONParser.java","additions":472,"deletions":0,"binary":false,"changes":472,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.json.parser;\n+\n+import java.util.Objects;\n+\n+public final class JSONString implements JSONValue {\n+    private final String value;\n+\n+    public JSONString(String value) {\n+        this.value = value;\n+    }\n+\n+    @Override\n+    public boolean isString() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String asString() {\n+        return value;\n+    }\n+\n+    @Override\n+    public char asChar() {\n+        String s = asString();\n+        if (s.length() != 1) {\n+            throw new IllegalStateException(\"cannot convert to char: \" + s);\n+        }\n+        return s.charAt(0);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        var builder = new StringBuilder();\n+        builder.append(\"\\\"\");\n+\n+        for (var i = 0; i < value.length(); i++) {\n+            var c = value.charAt(i);\n+\n+            switch (c) {\n+                case '\"':\n+                    builder.append(\"\\\\\\\"\");\n+                    break;\n+                case '\\\\':\n+                    builder.append(\"\\\\\\\\\");\n+                    break;\n+                case '\/':\n+                    builder.append(\"\\\\\/\");\n+                    break;\n+                case '\\b':\n+                    builder.append(\"\\\\b\");\n+                    break;\n+                case '\\f':\n+                    builder.append(\"\\\\f\");\n+                    break;\n+                case '\\n':\n+                    builder.append(\"\\\\n\");\n+                    break;\n+                case '\\r':\n+                    builder.append(\"\\\\r\");\n+                    break;\n+                case '\\t':\n+                    builder.append(\"\\\\t\");\n+                    break;\n+                default:\n+                    builder.append(c);\n+                    break;\n+            }\n+        }\n+\n+        builder.append(\"\\\"\");\n+        return builder.toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        JSONString that = (JSONString) o;\n+        return Objects.equals(value, that.value);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(value);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/json\/parser\/JSONString.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.json.parser;\n+\n+import java.util.stream.Stream;\n+import java.util.List;\n+\n+public sealed interface JSONValue permits\n+        JSONBoolean, JSONNumber, JSONDecimal, JSONString,\n+        JSONObject, JSONArray, JSONNull  {\n+    default byte asByte() {\n+        throw new IllegalStateException(\"Unsupported conversion to byte\");\n+    }\n+\n+    default short asShort() {\n+        throw new IllegalStateException(\"Unsupported conversion to short\");\n+    }\n+\n+    default int asInt() {\n+        throw new IllegalStateException(\"Unsupported conversion to int\");\n+    }\n+\n+    default long asLong() {\n+        throw new IllegalStateException(\"Unsupported conversion to long\");\n+    }\n+\n+    default float asFloat() {\n+        throw new IllegalStateException(\"Unsupported conversion to float\");\n+    }\n+\n+    default double asDouble() {\n+        throw new IllegalStateException(\"Unsupported conversion to double\");\n+    }\n+\n+    default String asString() {\n+        throw new IllegalStateException(\"Unsupported conversion to String\");\n+    }\n+\n+    default char asChar() {\n+        throw new IllegalStateException(\"Unsupported conversion to char\");\n+    }\n+\n+    default boolean asBoolean() {\n+        throw new IllegalStateException(\"Unsupported conversion to boolean\");\n+    }\n+\n+    default JSONArray asArray() {\n+        throw new IllegalStateException(\"Unsupported conversion to array\");\n+    }\n+\n+    default JSONObject asObject() {\n+        throw new IllegalStateException(\"Unsupported conversion to object\");\n+    }\n+\n+    default boolean isInt() {\n+        return false;\n+    }\n+\n+    default boolean isLong() {\n+        return false;\n+    }\n+\n+    default boolean isDouble() {\n+        return false;\n+    }\n+\n+    default boolean isString() {\n+        return false;\n+    }\n+\n+    default boolean isBoolean() {\n+        return false;\n+    }\n+\n+    default boolean isArray() {\n+        return false;\n+    }\n+\n+    default boolean isObject() {\n+        return false;\n+    }\n+\n+    default boolean isNull() {\n+        return false;\n+    }\n+\n+    default List<JSONObject.Field> fields() {\n+        return asObject().fields();\n+    }\n+\n+    default boolean contains(String field) {\n+        return asObject().contains(field);\n+    }\n+\n+    default JSONValue get(String field) {\n+        return asObject().get(field);\n+    }\n+\n+    default JSONValue getOrDefault(String field, JSONValue fallback) {\n+        return asObject().getOrDefault(field, fallback);\n+    }\n+\n+    default JSONValue get(int i) {\n+        return asArray().get(i);\n+    }\n+\n+    default Stream<JSONValue> stream() {\n+        return Stream.of(this);\n+    }\n+\n+    static JSONValue from(int i) {\n+        return new JSONNumber(i);\n+    }\n+\n+    static JSONValue from(long l) {\n+        return new JSONNumber(l);\n+    }\n+\n+    static JSONValue from(double d) {\n+        return new JSONDecimal(d);\n+    }\n+\n+    static JSONValue from(boolean b) {\n+        return new JSONBoolean(b);\n+    }\n+\n+    static JSONValue from(String s) {\n+        return new JSONString(s);\n+    }\n+\n+    static JSONValue fromNull() {\n+        return JSONNull.instance;\n+    }\n+\n+    static String toPrettyString(JSONValue value) {\n+        StringBuilder builder = new StringBuilder();\n+        toPrettyString(builder, 0, false, value);\n+        return builder.toString();\n+    }\n+\n+    private static void toPrettyString(StringBuilder builder, int level, boolean asField, JSONValue value) {\n+        if (!asField) {\n+            indent(builder, level);\n+        }\n+        switch (value) {\n+            case JSONObject obj -> {\n+                builder.append(\"{\\n\");\n+                List<JSONObject.Field> fields = obj.fields();\n+                for (int i = 0; i < fields.size(); i++) {\n+                    JSONObject.Field field = fields.get(i);\n+                    indent(builder, level + 1).append(\"\\\"\" + field.name() + \"\\\": \");\n+                    toPrettyString(builder, level + 1, true, field.value());\n+                    if (i < fields.size() - 1) {\n+                        builder.append(\",\\n\");\n+                    } else {\n+                        builder.append(\"\\n\");\n+                    }\n+                }\n+                indent(builder, level).append(\"}\");\n+            }\n+            case JSONArray array -> {\n+                builder.append(\"[\\n\");\n+                for (int i = 0; i < array.size(); i++) {\n+                    toPrettyString(builder, level + 1, false, array.get(i));\n+                    if (i < array.size() - 1) {\n+                        builder.append(\",\\n\");\n+                    } else {\n+                        builder.append(\"\\n\");\n+                    }\n+                }\n+                indent(builder, level).append(\"]\");\n+            }\n+            case JSONValue v -> builder.append(v);\n+        }\n+    }\n+\n+    private static StringBuilder indent(StringBuilder builder, int level) {\n+        builder.append(\"  \".repeat(level));\n+        return builder;\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/json\/parser\/JSONValue.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.json.parser;\n+\n+\/**\n+ * JWCC is JSON With Commas and Comments. In addition to supporting all of JSON\n+ * JWCC also supports trailing commas and comments. Comments can be either\n+ * until single-line or multi-line.\n+ *\n+ * Comments are stripped and are not present in the parsed result.\n+ *\/\n+public final class JWCC {\n+    private JWCC() {}\n+\n+    public static JSONValue parse(String s) {\n+        return new JSONParser(true, true).parse(s);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/json\/parser\/JWCC.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,570 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.json;\n+\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+import java.util.function.Function;\n+\n+import org.openjdk.jextract.json.JSONArrays;\n+import org.openjdk.jextract.json.JSONObjects;\n+import org.openjdk.jextract.json.parser.JSONArray;\n+import org.openjdk.jextract.json.parser.JSONBoolean;\n+import org.openjdk.jextract.json.parser.JSONNumber;\n+import org.openjdk.jextract.json.parser.JSONDecimal;\n+import org.openjdk.jextract.json.parser.JSONObject;\n+import org.openjdk.jextract.json.parser.JSONString;\n+import org.openjdk.jextract.json.parser.JSONValue;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class JSONArraysTests {\n+\n+    private void checkArrayElementTypes(JSONArray array, Class<?> type) {\n+        for (JSONValue elem : array) {\n+            assertEquals(elem.getClass(), type);\n+        }\n+    }\n+\n+    @Test\n+    public void testBooleanArray() {\n+        var array = new boolean[] { true, false, false, true, false };\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertEquals(jsonArray.size(), array.length);\n+        checkArrayElementTypes(jsonArray, JSONBoolean.class);\n+        \/\/ round trip\n+        assertEquals(JSONArrays.toBooleanArray(jsonArray), array);\n+        assertEquals((boolean[])JSONObjects.toObject(jsonArray, boolean[].class), array);\n+    }\n+\n+    @Test\n+    public void testEmptyBooleanArray() {\n+        var array = new boolean[0];\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertTrue(jsonArray.size() == 0);\n+        \/\/ round trip\n+        assertEquals(JSONArrays.toBooleanArray(jsonArray), array);\n+        assertEquals((boolean[])JSONObjects.toObject(jsonArray, boolean[].class), array);\n+    }\n+\n+    @Test\n+    public void testCharArray() {\n+        var array = new char[] { 'J', 'a', 'v', 'a' };\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertEquals(jsonArray.size(), array.length);\n+        checkArrayElementTypes(jsonArray, JSONString.class);\n+        \/\/ round trip\n+        assertEquals(JSONArrays.toCharArray(jsonArray), array);\n+        assertEquals((char[])JSONObjects.toObject(jsonArray, char[].class), array);\n+    }\n+\n+    @Test\n+    public void testEmptyCharArray() {\n+        var array = new boolean[0];\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertTrue(jsonArray.size() == 0);\n+        \/\/ round trip\n+        assertEquals(JSONArrays.toCharArray(jsonArray), array);\n+        assertEquals((char[])JSONObjects.toObject(jsonArray, char[].class), array);\n+    }\n+\n+    @Test\n+    public void testByteArray() {\n+        var array = new byte[] { 34, Byte.MAX_VALUE, 63, -72, Byte.MIN_VALUE };\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertEquals(jsonArray.size(), array.length);\n+        checkArrayElementTypes(jsonArray, JSONNumber.class);\n+        \/\/ round trip\n+        assertEquals(JSONArrays.toByteArray(jsonArray), array);\n+        assertEquals((byte[])JSONObjects.toObject(jsonArray, byte[].class), array);\n+    }\n+\n+    @Test\n+    public void testEmptyByteArray() {\n+        var array = new byte[0];\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertTrue(jsonArray.size() == 0);\n+        \/\/ round trip\n+        assertEquals(JSONArrays.toByteArray(jsonArray), array);\n+        assertEquals((byte[])JSONObjects.toObject(jsonArray, byte[].class), array);\n+    }\n+\n+    @Test\n+    public void testShortArray() {\n+        var array = new short[] { Short.MAX_VALUE, 1 + Byte.MAX_VALUE,\n+            263, -3372, Short.MIN_VALUE, Byte.MIN_VALUE - 1 };\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertEquals(jsonArray.size(), array.length);\n+        checkArrayElementTypes(jsonArray, JSONNumber.class);\n+        \/\/ round trip\n+        assertEquals(JSONArrays.toShortArray(jsonArray), array);\n+        assertEquals((short[])JSONObjects.toObject(jsonArray, short[].class), array);\n+    }\n+\n+    @Test\n+    public void testEmptyShortArray() {\n+        var array = new short[0];\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertTrue(jsonArray.size() == 0);\n+        \/\/ round trip\n+        assertEquals(JSONArrays.toShortArray(jsonArray), array);\n+        assertEquals((short[])JSONObjects.toObject(jsonArray, short[].class), array);\n+    }\n+\n+    @Test\n+    public void testIntArray() {\n+        var array = new int[] { Integer.MAX_VALUE, 53, 563, -729,\n+            Integer.MIN_VALUE, Short.MAX_VALUE + 1, Short.MIN_VALUE - 1 };\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertEquals(jsonArray.size(), array.length);\n+        checkArrayElementTypes(jsonArray, JSONNumber.class);\n+        \/\/ round trip\n+        assertEquals(JSONArrays.toIntArray(jsonArray), array);\n+        assertEquals((int[])JSONObjects.toObject(jsonArray, int[].class), array);\n+    }\n+\n+    @Test\n+    public void testEmptyIntArray() {\n+        var array = new short[0];\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertTrue(jsonArray.size() == 0);\n+        \/\/ round trip\n+        assertEquals(JSONArrays.toIntArray(jsonArray), array);\n+        assertEquals((int[])JSONObjects.toObject(jsonArray, int[].class), array);\n+    }\n+\n+    @Test\n+    public void testLongArray() {\n+        var array = new long[] { Long.MAX_VALUE, Long.MIN_VALUE,\n+            Integer.MAX_VALUE + 1L, Integer.MIN_VALUE - 1L };\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertEquals(jsonArray.size(), array.length);\n+        checkArrayElementTypes(jsonArray, JSONNumber.class);\n+        \/\/ round trip\n+        assertEquals(JSONArrays.toLongArray(jsonArray), array);\n+        assertEquals((long[])JSONObjects.toObject(jsonArray, long[].class), array);\n+    }\n+\n+    @Test\n+    public void testEmptyLongArray() {\n+        var array = new long[0];\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertTrue(jsonArray.size() == 0);\n+        \/\/ round trip\n+        assertEquals(JSONArrays.toLongArray(jsonArray), array);\n+        assertEquals((long[])JSONObjects.toObject(jsonArray, long[].class), array);\n+    }\n+\n+    @Test\n+    public void testFloatArray() {\n+        final var DELTA = 0.001f;\n+        var array = new float[] { 3.14f, 2.18f, -56.91f, 92.62f, -555.19f };\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertEquals(jsonArray.size(), array.length);\n+        checkArrayElementTypes(jsonArray, JSONDecimal.class);\n+        \/\/ round trip\n+        assertEquals(JSONArrays.toFloatArray(jsonArray), array, DELTA);\n+        assertEquals((float[])JSONObjects.toObject(jsonArray, float[].class), array);\n+    }\n+\n+    @Test\n+    public void testEmptyFloatArray() {\n+        var array = new long[0];\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertTrue(jsonArray.size() == 0);\n+        \/\/ round trip\n+        assertEquals(JSONArrays.toFloatArray(jsonArray), array);\n+        assertEquals((float[])JSONObjects.toObject(jsonArray, float[].class), array);\n+    }\n+\n+    @Test\n+    public void testDoubleArray() {\n+        final var DELTA = 0.001;\n+        var array = new double[] { 34.23, 53.71, 563.89, -729.76, 43555.19 };\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertEquals(jsonArray.size(), array.length);\n+        checkArrayElementTypes(jsonArray, JSONDecimal.class);\n+        \/\/ round trip\n+        assertEquals(JSONArrays.toDoubleArray(jsonArray), array, DELTA);\n+        assertEquals((double[])JSONObjects.toObject(jsonArray, double[].class), array);\n+    }\n+\n+    @Test\n+    public void testEmptyDoubleArray() {\n+        var array = new double[0];\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertTrue(jsonArray.size() == 0);\n+        \/\/ round trip\n+        assertEquals(JSONArrays.toDoubleArray(jsonArray), array);\n+        assertEquals((double[])JSONObjects.toObject(jsonArray, double[].class), array);\n+    }\n+\n+    @Test\n+    public void testStringArray() {\n+        var array = new String[] { \"Java\", \"is\", \"great!\" };\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertEquals(jsonArray.size(), array.length);\n+        checkArrayElementTypes(jsonArray, JSONString.class);\n+        \/\/ round trip\n+        assertEquals(JSONArrays.toStringArray(jsonArray), array);\n+        assertEquals((String[])JSONObjects.toObject(jsonArray, String[].class), array);\n+    }\n+\n+    @Test\n+    public void testEmptyStringArray() {\n+        var array = new String[0];\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertTrue(jsonArray.size() == 0);\n+        \/\/ round trip\n+        assertEquals(JSONArrays.toStringArray(jsonArray), array);\n+        assertEquals((String[])JSONObjects.toObject(jsonArray, String[].class), array);\n+    }\n+\n+    public record Point(int x, int y) {}\n+    public enum Color { RED, GREEN, BLUE };\n+\n+    private void checkPointArray(JSONArray jsonArray, Point[] points) {\n+        assertEquals(jsonArray.size(), points.length);\n+        for (int i = 0; i < points.length; i++) {\n+            JSONValue jv = jsonArray.get(i);\n+            assertTrue(jv.isObject());\n+            JSONObject jo = jv.asObject();\n+            assertTrue(jo.get(\"x\").isInt());\n+            assertTrue(jo.get(\"y\").isInt());\n+            assertEquals(jo.get(\"x\").asInt(), points[i].x());\n+            assertEquals(jo.get(\"y\").asInt(), points[i].y());\n+        }\n+\n+        \/\/ check round trip conversion as well\n+        assertEquals(JSONArrays.toArray(jsonArray, new Point[0]), points);\n+    }\n+\n+    private void checkColorArray(JSONArray jsonArray, Color[] colors) {\n+        assertEquals(jsonArray.size(), colors.length);\n+        for (int i = 0; i < colors.length; i++) {\n+            JSONValue jv = jsonArray.get(i);\n+            assertTrue(jv.isString());\n+            assertEquals(jv.asString(), colors[i].name());\n+        }\n+\n+        \/\/ check round trip conversion as well\n+        assertEquals(JSONArrays.toArray(jsonArray, new Color[0]), colors);\n+    }\n+\n+    private void checkStringArray(JSONArray jsonArray, String[] strings) {\n+        assertEquals(jsonArray.size(), strings.length);\n+        for (int i = 0; i < strings.length; i++) {\n+            JSONValue jv = jsonArray.get(i);\n+            assertTrue(jv.isString());\n+            assertEquals(jv.asString(), strings[i]);\n+        }\n+\n+        \/\/ check round trip conversion as well\n+        assertEquals(JSONArrays.toStringArray(jsonArray), strings);\n+    }\n+\n+    @Test\n+    public void testRecordArray() {\n+        var array = new Point[] { new Point(23, 45), new Point(-313, 4543) };\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertEquals(jsonArray.size(), array.length);\n+        checkArrayElementTypes(jsonArray, JSONObject.class);\n+        checkPointArray(jsonArray, array);\n+    }\n+\n+    @Test\n+    public void testEmptyRecordArray() {\n+        var array = new Point[0];\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertTrue(jsonArray.size() == 0);\n+        checkPointArray(jsonArray, array);\n+    }\n+\n+    @Test\n+    public void testEnumArray() {\n+        var array = new Color[] { Color.GREEN, Color.RED, Color.RED, Color.BLUE, Color.GREEN };\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertEquals(jsonArray.size(), array.length);\n+        checkArrayElementTypes(jsonArray, JSONString.class);\n+        checkColorArray(jsonArray, array);\n+    }\n+\n+    @Test\n+    public void testEmptyEnumArray() {\n+        var array = new Color[0];\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertTrue(jsonArray.size() == 0);\n+        checkColorArray(jsonArray, array);\n+    }\n+\n+    @Test\n+    public void testObjectArray() {\n+        var map = JSONObjects.toMap(JSONObjects.from(new Point(34, 124)));\n+\n+        \/\/ array with mixed type elements\n+        var array = new Object[] {\n+            true, 'Z', false, -34, 431246, Integer.MIN_VALUE,\n+            (long)Integer.MAX_VALUE + 1L, Long.MAX_VALUE,\n+            Color.GREEN.name(), \"Java\", map, null,\n+            new String[] { \"Java\", \"is\", \"great!\" },\n+            new int[] { 33, 4343, -23434, Integer.MAX_VALUE }\n+        };\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertEquals(jsonArray.size(), array.length);\n+        \/\/ round trip\n+        assertEquals(JSONArrays.toObjectArray(jsonArray), array);\n+        assertEquals((Object[])JSONObjects.toObject(jsonArray, Object[].class), array);\n+        \/\/ Object.class as target also returns an Object[]\n+        assertEquals((Object[])JSONObjects.toObject(jsonArray, Object.class), array);\n+    }\n+\n+    @Test\n+    public void testEmptyObjectArray() {\n+        var array = new Object[0];\n+        JSONArray jsonArray = JSONArrays.from(array);\n+        assertTrue(jsonArray.size() == 0);\n+        \/\/ round trip\n+        assertEquals(JSONArrays.toObjectArray(jsonArray), array);\n+        assertEquals((Object[])JSONObjects.toObject(jsonArray, Object[].class), array);\n+        \/\/ Object.class as target also returns an Object[]\n+        assertEquals((Object[])JSONObjects.toObject(jsonArray, Object.class), array);\n+    }\n+\n+    @Test\n+    public void testMultidimensionalArray() {\n+        int[][] int2DArray = new int[][] {\n+            { 23, 45, 345, -2389 },\n+            { 3423, 23 },\n+            { -23, 212, 129 }\n+        };\n+        JSONArray jsonArray = JSONArrays.from(int2DArray);\n+        assertTrue(jsonArray.size() == int2DArray.length);\n+        for (int i = 0; i < int2DArray.length; i++) {\n+            JSONArray jia = jsonArray.get(i).asArray();\n+            assertTrue(jia.size() == int2DArray[i].length);\n+            checkArrayElementTypes(jia, JSONNumber.class);\n+        }\n+        \/\/ round trip\n+        int[][] convertedIntArray = (int[][]) JSONObjects.toObject(jsonArray, int[][].class);\n+        assertTrue(Arrays.deepEquals(convertedIntArray, int2DArray));\n+\n+        String[][] str2DArray = new String[][] {\n+            { \"java\", \"is\", \"great!\" },\n+            { \"hello\", \"world\" },\n+            { \"abc\", \"xyz\", \"uvw\", \"ijk\", \"pqrs\" }\n+        };\n+        jsonArray = JSONArrays.from(str2DArray);\n+        assertTrue(jsonArray.size() == str2DArray.length);\n+        for (int i = 0; i < str2DArray.length; i++) {\n+            JSONArray jia = jsonArray.get(i).asArray();\n+            assertTrue(jia.size() == str2DArray[i].length);\n+            checkArrayElementTypes(jia, JSONString.class);\n+        }\n+        \/\/ round trip\n+        String[][] convertedStrArray = (String[][]) JSONObjects.toObject(jsonArray, String[][].class);\n+        assertTrue(Arrays.deepEquals(convertedStrArray, str2DArray));\n+\n+        Point[][] pts2DArray = new Point[][] {\n+            { new Point(3, 43), new Point(-43, 342) },\n+            { new Point(899, 143), new Point(123, 456), new Point(-2333, 565) }\n+        };\n+        jsonArray = JSONArrays.from(pts2DArray);\n+        assertTrue(jsonArray.size() == pts2DArray.length);\n+        for (int i = 0; i < pts2DArray.length; i++) {\n+            JSONArray jpa = jsonArray.get(i).asArray();\n+            assertTrue(jpa.size() == pts2DArray[i].length);\n+            checkArrayElementTypes(jpa, JSONObject.class);\n+        }\n+        \/\/ round trip\n+        Point[][] convertedPtsArray = (Point[][]) JSONObjects.toObject(jsonArray, Point[][].class);\n+        assertTrue(Arrays.deepEquals(convertedPtsArray, pts2DArray));\n+    }\n+\n+    @Test\n+    public void testIterable() {\n+        var strings = new String[] { \"hello\", \"world\", \"is\", \"great!\" };\n+        JSONArray jsonArray = JSONArrays.from(Arrays.asList(strings));\n+        checkArrayElementTypes(jsonArray, JSONString.class);\n+        checkStringArray(jsonArray, strings);\n+\n+        Point[] points = new Point[] { new Point(24, 342), new Point(423, -233) };\n+        jsonArray = JSONArrays.from(Arrays.asList(points));\n+        checkArrayElementTypes(jsonArray, JSONObject.class);\n+        checkPointArray(jsonArray, points);\n+\n+        Color[] colors = new Color[] { Color.RED, Color.BLUE, Color.GREEN, Color.RED };\n+        jsonArray = JSONArrays.from(Arrays.asList(colors));\n+        checkArrayElementTypes(jsonArray, JSONString.class);\n+        checkColorArray(jsonArray, colors);\n+    }\n+\n+    @Test\n+    public void testIterator() {\n+        var strings = new String[] { \"java\", \"Java\", \"JAVA\" };\n+        JSONArray jsonArray = JSONArrays.from(Stream.of(strings).iterator());\n+        checkArrayElementTypes(jsonArray, JSONString.class);\n+        checkStringArray(jsonArray, strings);\n+\n+        Point[] points = new Point[] { new Point(334, 98), new Point(-99, 679) };\n+        jsonArray = JSONArrays.from(Stream.of(points).iterator());\n+        checkArrayElementTypes(jsonArray, JSONObject.class);\n+        checkPointArray(jsonArray, points);\n+\n+        Color[] colors = new Color[] { Color.RED, Color.BLUE, Color.GREEN, Color.RED };\n+        jsonArray = JSONArrays.from(Stream.of(colors).iterator());\n+        checkArrayElementTypes(jsonArray, JSONString.class);\n+        checkColorArray(jsonArray, colors);\n+    }\n+\n+    @Test\n+    public void testToList() {\n+        List<String> strList = List.of(\"java\", \"Java\", \"JAVA\");\n+        JSONArray jsonArray = JSONArrays.from(strList);\n+        List<String> convertedStrList = JSONArrays.toList(jsonArray, String.class);\n+        \/\/ round trip check\n+        assertEquals(convertedStrList, strList);\n+\n+        List<Point> pointList = List.of(new Point(432, 23), new Point(-231, 22));\n+        jsonArray = JSONArrays.from(pointList);\n+        List<Point> convertedPointList = JSONArrays.toList(jsonArray, Point.class);\n+        \/\/ round trip check\n+        assertEquals(convertedPointList, pointList);\n+    }\n+\n+    @Test\n+    public void testListOfLists() {\n+        List<List<String>> listOfLists = List.of(\n+            List.of(\"java\", \"is\", \"great!\"),\n+            List.of(\"hello\", \"world\"),\n+            List.of(\"abc\", \"xyz\", \"uvw\", \"ijk\", \"pqrs\")\n+        );\n+        JSONArray jsonArray = JSONArrays.from(listOfLists);\n+        assertTrue(jsonArray.size() == listOfLists.size());\n+        for (int i = 0; i < listOfLists.size(); i++) {\n+            JSONArray jia = jsonArray.get(i).asArray();\n+            assertTrue(jia.size() == listOfLists.get(i).size());\n+            checkArrayElementTypes(jia, JSONString.class);\n+        }\n+\n+        \/\/ round trip\n+        record DummyRecord(List<List<String>> abc) {};\n+        Type type = DummyRecord.class.getRecordComponents()[0].getGenericType();\n+        assertEquals(JSONObjects.toObject(jsonArray, type), listOfLists);\n+    }\n+\n+    @Test\n+    public void testToSet() {\n+        Set<String> strSet = Set.of(\"java\", \"Java\", \"JAVA\");\n+        JSONArray jsonArray = JSONArrays.from(strSet);\n+        Set<String> convertedStrSet = JSONArrays.toSet(jsonArray, String.class);\n+        \/\/ round trip check\n+        assertEquals(convertedStrSet, strSet);\n+\n+        Set<Point> pointSet = Set.of(new Point(2, 3), new Point(13, 32));\n+        jsonArray = JSONArrays.from(pointSet);\n+        Set<Point> convertedPointSet = JSONArrays.toSet(jsonArray, Point.class);\n+        \/\/ round trip check\n+        assertEquals(convertedPointSet, pointSet);\n+    }\n+\n+    @Test\n+    public void testToEnumSet() {\n+        EnumSet<Color> cs = EnumSet.noneOf(Color.class);\n+        JSONArray colors = JSONArrays.from(cs);\n+        \/\/ round trip check\n+        EnumSet<Color> converted = JSONArrays.toEnumSet(colors, Color.class);\n+        assertEquals(converted, cs);\n+\n+        cs = EnumSet.of(Color.RED);\n+        colors = JSONArrays.from(cs);\n+        assertEquals(colors.size(), 1);\n+        assertEquals(colors.get(0).asString(), \"RED\");\n+        \/\/ round trip check\n+        converted = JSONArrays.toEnumSet(colors, Color.class);\n+        assertEquals(converted, cs);\n+\n+        cs = EnumSet.of(Color.RED, Color.GREEN, Color.RED);\n+        colors = JSONArrays.from(cs);\n+        \/\/ set and so duplicate removed\n+        assertEquals(colors.size(), 2);\n+        assertEquals(colors.get(0).asString(), \"RED\");\n+        assertEquals(colors.get(1).asString(), \"GREEN\");\n+        \/\/ round trip check\n+        converted = JSONArrays.toEnumSet(colors, Color.class);\n+        assertEquals(converted, cs);\n+\n+        cs = EnumSet.allOf(Color.class);\n+        colors = JSONArrays.from(cs);\n+        assertEquals(colors.size(), 3);\n+        assertEquals(colors.get(0).asString(), \"RED\");\n+        assertEquals(colors.get(1).asString(), \"GREEN\");\n+        assertEquals(colors.get(2).asString(), \"BLUE\");\n+        \/\/ round trip check\n+        converted = JSONArrays.toEnumSet(colors, Color.class);\n+        assertEquals(converted, cs);\n+    }\n+\n+    private void checkConversionFails(JSONArray jsonArray, Function<JSONArray, Object> func) {\n+        boolean exceptionSeen = false;\n+        try {\n+            func.apply(jsonArray);\n+        } catch (RuntimeException re) {\n+            var msg = re.getMessage();\n+            assertTrue(msg.contains(\"cannot convert\") ||\n+                msg.contains(\"Unsupported conversion\"), msg);\n+            exceptionSeen = true;\n+        }\n+        assertTrue(exceptionSeen);\n+    }\n+\n+    @Test\n+    public void testArrayConversionFailures() {\n+        \/\/ array with mixed type elements\n+        var array = new Object[] {\n+            true, 'Z', false, -34, 431246, Integer.MIN_VALUE,\n+            (long)Integer.MAX_VALUE + 1L, Long.MAX_VALUE,\n+            Color.GREEN.name(), \"Java\", null,\n+            new String[] { \"Java\", \"is\", \"great!\" },\n+            new int[] { 33, 4343, -23434, Integer.MAX_VALUE }\n+        };\n+\n+        JSONArray jsonArray = JSONArrays.from(array);\n+\n+        \/\/ all homogeneous array conversions other than Object[] should fail\n+        checkConversionFails(jsonArray, JSONArrays::toBooleanArray);\n+        checkConversionFails(jsonArray, JSONArrays::toCharArray);\n+        checkConversionFails(jsonArray, JSONArrays::toByteArray);\n+        checkConversionFails(jsonArray, JSONArrays::toShortArray);\n+        checkConversionFails(jsonArray, JSONArrays::toIntArray);\n+        checkConversionFails(jsonArray, JSONArrays::toLongArray);\n+        checkConversionFails(jsonArray, JSONArrays::toFloatArray);\n+        checkConversionFails(jsonArray, JSONArrays::toDoubleArray);\n+        checkConversionFails(jsonArray, ja -> JSONArrays.toArray(ja, new Point[0]));\n+        checkConversionFails(jsonArray, ja -> JSONArrays.toArray(ja, new Color[0]));\n+    }\n+}\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/json\/JSONArraysTests.java","additions":570,"deletions":0,"binary":false,"changes":570,"status":"added"},{"patch":"@@ -0,0 +1,582 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.json;\n+\n+import java.lang.reflect.Type;\n+import java.net.URI;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.time.LocalDate;\n+import java.util.EnumMap;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.OptionalInt;\n+import java.util.OptionalLong;\n+import java.util.OptionalDouble;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.openjdk.jextract.json.JSONObjects;\n+import org.openjdk.jextract.json.parser.JSONArray;\n+import org.openjdk.jextract.json.parser.JSONBoolean;\n+import org.openjdk.jextract.json.parser.JSONDecimal;\n+import org.openjdk.jextract.json.parser.JSONNull;\n+import org.openjdk.jextract.json.parser.JSONNumber;\n+import org.openjdk.jextract.json.parser.JSONObject;\n+import org.openjdk.jextract.json.parser.JSONString;\n+import org.openjdk.jextract.json.parser.JSONValue;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class JSONObjectsTests {\n+    \/\/ delta for floating point comparisons\n+    private static final double DELTA = 0.0001;\n+\n+    \/\/ Tests for Java objects to JSONValue subtypes conversions\n+\n+    @Test\n+    public void testFromPrimitive() {\n+        boolean b = true;\n+        JSONValue jv = JSONObjects.from(b);\n+        assertTrue(jv.isBoolean());\n+        assertEquals(jv.asBoolean(), b);\n+\n+        b = false;\n+        jv = JSONObjects.from(b);\n+        assertTrue(jv.isBoolean());\n+        assertEquals(jv.asBoolean(), b);\n+\n+        char c = 'U';\n+        jv = JSONObjects.from(c);\n+        assertTrue(jv.isString());\n+        assertEquals(jv.asChar(), c);\n+\n+        byte bi = 33;\n+        jv = JSONObjects.from(bi);\n+        assertTrue(jv.isInt());\n+        assertEquals(jv.asByte(), bi);\n+\n+        short s = 3324;\n+        jv = JSONObjects.from(s);\n+        assertTrue(jv.isInt());\n+        assertEquals(jv.asShort(), s);\n+\n+        int i = 343233413;\n+        jv = JSONObjects.from(i);\n+        assertTrue(jv.isInt());\n+        assertEquals(jv.asInt(), i);\n+\n+        long l = Long.MAX_VALUE;\n+        jv = JSONObjects.from(l);\n+        assertTrue(jv.isLong());\n+        assertEquals(jv.asLong(), l);\n+\n+        float f = 3.14f;\n+        jv = JSONObjects.from(f);\n+        assertTrue(jv.isDouble());\n+        assertEquals(jv.asFloat(), f, (float)DELTA);\n+\n+        double d = 3.14;\n+        jv = JSONObjects.from(d);\n+        assertTrue(jv.isDouble());\n+        assertEquals(jv.asDouble(), d, DELTA);\n+    }\n+\n+    @Test\n+    public void testFromPrimitiveFailures() {\n+        JSONValue jv = JSONObjects.from(\"hello\");\n+        assertTrue(jv.isString());\n+        try {\n+            \/\/ cannot convert a String that has\n+            \/\/ more than one character to char\n+            jv.asChar();\n+            throw new RuntimeException(\"should not reach here\");\n+        } catch (RuntimeException re) {\n+            assertTrue(re.getMessage().contains(\"cannot convert\"));\n+        }\n+\n+        jv = JSONObjects.from(\"\");\n+        assertTrue(jv.isString());\n+        try {\n+            \/\/ empty string has no character\n+            jv.asChar();\n+            throw new RuntimeException(\"should not reach here\");\n+        } catch (RuntimeException re) {\n+            assertTrue(re.getMessage().contains(\"cannot convert\"));\n+        }\n+\n+        short s = Byte.MAX_VALUE + 1;\n+        jv = JSONObjects.from(s);\n+        assertTrue(jv.isInt());\n+        \/\/ overflow value cannot be converted to byte\n+        try {\n+            jv.asByte();\n+            throw new RuntimeException(\"should not reach here\");\n+        } catch (ArithmeticException ae) {\n+            assertTrue(ae.getMessage().contains(\"byte overflow\"));\n+        }\n+\n+        int i = Short.MIN_VALUE - 1;\n+        jv = JSONObjects.from(i);\n+        assertTrue(jv.isInt());\n+        \/\/ overflow value cannot be converted to byte\n+        try {\n+            jv.asByte();\n+            throw new RuntimeException(\"should not reach here\");\n+        } catch (ArithmeticException ae) {\n+            assertTrue(ae.getMessage().contains(\"byte overflow\"));\n+        }\n+        \/\/ overflow value cannot be converted to short\n+        try {\n+            jv.asShort();\n+            throw new RuntimeException(\"should not reach here\");\n+        } catch (ArithmeticException ae) {\n+            assertTrue(ae.getMessage().contains(\"short overflow\"));\n+        }\n+\n+        long l = Long.MAX_VALUE;\n+        jv = JSONObjects.from(l);\n+        assertTrue(jv.isLong());\n+        \/\/ overflow value cannot be converted to int\n+        try {\n+            jv.asInt();\n+            throw new RuntimeException(\"should not reach here\");\n+        } catch (ArithmeticException ae) {\n+            assertTrue(ae.getMessage().contains(\"integer overflow\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testFromString() {\n+        String s = \"hello\";\n+        JSONValue jv = JSONObjects.from(s);\n+        assertTrue(jv.isString());\n+        assertEquals(jv.asString(), s);\n+    }\n+\n+    @Test\n+    public void testFromNull() {\n+        JSONValue jv = JSONObjects.from((Object)null);\n+        assertTrue(jv.isNull());\n+    }\n+\n+    @Test\n+    public void testFromOptionals() {\n+        \/\/ Optional empty values are converted to JSONNull\n+        JSONValue jv = JSONObjects.from(Optional.empty());\n+        assertTrue(jv.isNull());\n+        jv = JSONObjects.from(OptionalInt.empty());\n+        assertTrue(jv.isNull());\n+        jv = JSONObjects.from(OptionalInt.empty());\n+        assertTrue(jv.isNull());\n+        jv = JSONObjects.from(OptionalLong.empty());\n+        assertTrue(jv.isNull());\n+        jv = JSONObjects.from(OptionalDouble.empty());\n+        assertTrue(jv.isNull());\n+\n+        \/\/ non-empty Optional values are converted from underlying values\n+        Optional<String> os = Optional.of(\"Hello\");\n+        jv = JSONObjects.from(os);\n+        assertTrue(jv.isString());\n+        assertEquals(jv.asString(), os.get());\n+\n+        OptionalInt oi = OptionalInt.of(4234);\n+        jv = JSONObjects.from(oi);\n+        assertTrue(jv instanceof JSONNumber);\n+        assertEquals(jv.asInt(), oi.getAsInt());\n+\n+        OptionalLong ol = OptionalLong.of(Long.MIN_VALUE);\n+        jv = JSONObjects.from(ol);\n+        assertTrue(jv instanceof JSONNumber);\n+        assertEquals(jv.asLong(), ol.getAsLong());\n+\n+        OptionalDouble od = OptionalDouble.of(Math.PI);\n+        jv = JSONObjects.from(od);\n+        assertTrue(jv instanceof JSONDecimal);\n+        assertEquals(jv.asDouble(), od.getAsDouble(), DELTA);\n+    }\n+\n+    public record Point(int x, int y) {}\n+\n+    \/\/ more complex record types\n+    public record UserInfo(String name,\n+        List<String> address,\n+        String email,\n+        Optional<List<String>> alternateAddress,\n+        Optional<URI> homePage) {}\n+\n+    public enum Color { RED, GREEN, BLUE }\n+\n+    @Test\n+    public void testFromEnum() {\n+        Color c = Color.BLUE;\n+        JSONValue jv = JSONObjects.from(c);\n+        assertTrue(jv.isString());\n+        assertEquals(jv.asString(), c.name());\n+\n+        c = Color.RED;\n+        jv = JSONObjects.from(c);\n+        assertTrue(jv.isString());\n+        assertEquals(jv.asString(), c.name());\n+    }\n+\n+    @Test\n+    public void testFromRecord() {\n+        Point pt = new Point(44, -289);\n+        JSONObject jo = JSONObjects.from(pt);\n+        assertEquals(jo.size(), Point.class.getRecordComponents().length);\n+        assertEquals(jo.get(\"x\").asInt(), pt.x());\n+        assertEquals(jo.get(\"y\").asInt(), pt.y());\n+\n+        \/\/ try a complex record\n+        UserInfo ui = new UserInfo(\"Batman\",\n+            List.of(\"224\", \"Park Drive\", \"Gotham City\"),\n+            \"bruce.wayne@batcave.com\",\n+            Optional.empty(),\n+            Optional.of(URI.create(\"http:\/\/www.thebatman.com\")));\n+        jo = JSONObjects.from(ui);\n+        assertEquals(jo.size(), UserInfo.class.getRecordComponents().length);\n+        assertEquals(jo.get(\"name\").asString(), ui.name());\n+        assertEquals(jo.get(\"email\").asString(), ui.email());\n+        assertTrue(jo.get(\"address\").isArray());\n+        JSONArray address = jo.get(\"address\").asArray();\n+        assertEquals(address.size(), ui.address().size());\n+        assertEquals(address.get(0).asString(), ui.address().get(0));\n+        assertEquals(address.get(1).asString(), ui.address().get(1));\n+        assertEquals(address.get(2).asString(), ui.address().get(2));\n+        \/\/ empty Optional value\n+        assertTrue(jo.get(\"alternateAddress\").isNull());\n+        assertEquals(URI.create(jo.get(\"homePage\").asString()), ui.homePage().get());\n+    }\n+\n+    @Test\n+    public void testFromMap() {\n+        Map<String, Object> map = Map.of(\"x\", 44243, \"y\", 5455);\n+\n+        JSONObject jo = JSONObjects.from(map);\n+        assertEquals(jo.size(), map.size());\n+        assertEquals(jo.get(\"x\").asInt(), (int)map.get(\"x\"));\n+        assertEquals(jo.get(\"y\").asInt(), (int)map.get(\"y\"));\n+    }\n+\n+    \/\/ tests for JSONValues to Java object conversions\n+\n+    @Test\n+    public void testJSONBooleanConversions() {\n+        JSONBoolean jb = new JSONBoolean(false);\n+        assertEquals(JSONObjects.toObject(jb, boolean.class), jb.asBoolean());\n+        assertEquals(JSONObjects.toObject(jb, Boolean.class), jb.asBoolean());\n+        assertEquals(JSONObjects.toObject(jb, Object.class), jb.asBoolean());\n+\n+        jb = new JSONBoolean(true);\n+        assertEquals(JSONObjects.toObject(jb, boolean.class), jb.asBoolean());\n+        assertEquals(JSONObjects.toObject(jb, Boolean.class), jb.asBoolean());\n+        assertEquals(JSONObjects.toObject(jb, Object.class), jb.asBoolean());\n+    }\n+\n+    @Test\n+    public void testJSONNumberConversions() {\n+        JSONNumber jn = new JSONNumber(345673);\n+        assertEquals(JSONObjects.toObject(jn, int.class), jn.asInt());\n+        assertEquals(JSONObjects.toObject(jn, long.class), jn.asLong());\n+        assertEquals(JSONObjects.toObject(jn, Object.class), jn.asInt());\n+        assertEquals(JSONObjects.toObject(jn, Number.class), jn.asInt());\n+        assertEquals(JSONObjects.toObject(jn, OptionalInt.class), OptionalInt.of(jn.asInt()));\n+\n+        jn = new JSONNumber(Integer.MAX_VALUE + 1L);\n+        assertEquals(JSONObjects.toObject(jn, long.class), jn.asLong());\n+        assertEquals(JSONObjects.toObject(jn, Object.class), jn.asLong());\n+        assertEquals(JSONObjects.toObject(jn, Number.class), jn.asLong());\n+        assertEquals(JSONObjects.toObject(jn, OptionalLong.class), OptionalLong.of(jn.asLong()));\n+        assertEquals(JSONObjects.toObject(jn, BigInteger.class), BigInteger.valueOf(jn.asLong()));\n+    }\n+\n+    @Test\n+    public void testJSONDecimalConversions() {\n+        JSONDecimal jd = new JSONDecimal(Math.E);\n+\n+        Object obj = JSONObjects.toObject(jd, double.class);\n+        assertEquals((double)obj, jd.asDouble(), DELTA);\n+        obj = JSONObjects.toObject(jd, Double.class);\n+        assertEquals((double)obj, jd.asDouble(), DELTA);\n+        obj = JSONObjects.toObject(jd, float.class);\n+        assertEquals((float)obj, jd.asFloat(), (float) DELTA);\n+        obj = JSONObjects.toObject(jd, Float.class);\n+        assertEquals((float)obj, jd.asFloat(), (float) DELTA);\n+        obj = JSONObjects.toObject(jd, OptionalDouble.class);\n+        assertEquals(((OptionalDouble)obj).getAsDouble(), jd.asDouble(), DELTA);\n+        obj = JSONObjects.toObject(jd, BigDecimal.class);\n+        assertEquals(obj, BigDecimal.valueOf(jd.asDouble()));\n+    }\n+\n+    @Test\n+    public void testJSONStringConversions() {\n+        JSONString js = new JSONString(\"JAVA\");\n+        Object obj = JSONObjects.toObject(js, String.class);\n+        assertEquals(obj, js.asString());\n+\n+        obj = JSONObjects.toObject(js, CharSequence.class);\n+        assertEquals(obj, js.asString());\n+\n+        \/\/ when target type is Object.class, we still get a String\n+        obj = JSONObjects.toObject(js, Object.class);\n+        assertEquals(obj, js.asString());\n+\n+        \/\/ conversion from String length of 1 to char\/Character\n+        js = new JSONString(\"X\");\n+        obj = JSONObjects.toObject(js, char.class);\n+        assertEquals(obj, (Character) js.asString().charAt(0));\n+        obj = JSONObjects.toObject(js, Character.class);\n+        assertEquals(obj, (Character) js.asString().charAt(0));\n+        obj = JSONObjects.toObject(js, Object.class);\n+        assertEquals(obj, (Character) js.asString().charAt(0));\n+\n+        \/\/ to enum constant\n+        js = new JSONString(\"RED\");\n+        obj = JSONObjects.toObject(js, Color.class);\n+        assertEquals(obj, Color.RED);\n+\n+        \/\/ use special parsing functions to convert JSON strings\n+\n+        js = new JSONString(\"123456789123456789444\");\n+        obj = JSONObjects.toObject(js, BigInteger.class);\n+        assertEquals(obj, new BigInteger(js.asString()));\n+\n+        js = new JSONString(\"35.3E+400\");\n+        obj = JSONObjects.toObject(js, BigDecimal.class);\n+        assertEquals(obj, new BigDecimal(js.asString()));\n+\n+        js = new JSONString(\"2024-01-01\");\n+        obj = JSONObjects.toObject(js, LocalDate.class);\n+        assertEquals(obj, LocalDate.parse(js.asString()));\n+\n+        js = new JSONString(\"https:\/\/docs.oracle.com\");\n+        obj = JSONObjects.toObject(js, URI.class);\n+        assertEquals(obj, URI.create(js.asString()));\n+\n+        js = new JSONString(\"[_a-zA-Z][_a-zA-Z0-9]*\");\n+        obj = JSONObjects.toObject(js, Pattern.class);\n+        assertTrue(obj instanceof Pattern);\n+        try {\n+            \/\/ Can't do equality check on Pattern as Pattern.equals is identity comparison.\n+            \/\/ We convert to string and compare string representation.\n+            assertEquals(obj.toString(), Pattern.compile(js.asString()).toString());\n+        } catch (Exception ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    @Test\n+    public void testJSONNullToOptionals() {\n+        JSONNull jn = (JSONNull) JSONObjects.from((Object)null);\n+        assertEquals(JSONObjects.toObject(jn, OptionalInt.class),\n+            OptionalInt.empty());\n+        assertEquals(JSONObjects.toObject(jn, OptionalLong.class),\n+            OptionalLong.empty());\n+        assertEquals(JSONObjects.toObject(jn, OptionalDouble.class),\n+            OptionalDouble.empty());\n+        assertEquals(JSONObjects.toObject(jn, Optional.class),\n+            Optional.empty());\n+    }\n+\n+    @Test\n+    public void testToRecord() {\n+        Point pt = new Point(434, -4423);\n+        JSONObject jo = JSONObjects.from(pt);\n+        assertEquals(jo.size(), Point.class.getRecordComponents().length);\n+        assertTrue(jo.get(\"x\").isInt());\n+        assertTrue(jo.get(\"y\").isInt());\n+        assertEquals(jo.get(\"x\").asInt(), pt.x());\n+        assertEquals(jo.get(\"y\").asInt(), pt.y());\n+        \/\/ round trip check\n+        assertEquals(JSONObjects.toRecord(jo, Point.class), pt);\n+\n+        \/\/ try a complex record\n+        UserInfo ui = new UserInfo(\"Batman\",\n+            List.of(\"224\", \"Park Drive\", \"Gotham City\"),\n+            \"bruce.wayne@batcave.com\",\n+            Optional.of(List.of(\"1007\", \"Mountain Drive\", \"Gotham\")),\n+            Optional.empty());\n+        jo = JSONObjects.from(ui);\n+        assertEquals(jo.size(), UserInfo.class.getRecordComponents().length);\n+        \/\/ round trip check\n+        assertEquals(JSONObjects.toRecord(jo, UserInfo.class), ui);\n+    }\n+\n+    private Type getFirstComponentType(Class<? extends Record> cls) {\n+        return cls.getRecordComponents()[0].getGenericType();\n+    }\n+\n+    @Test\n+    public void testToMap() {\n+        Point pt = new Point(4299, 1456);\n+        JSONObject jo = JSONObjects.from(pt);\n+        Map<String, Object> expectedMap = Map.of(\"x\", pt.x(), \"y\", pt.y());\n+\n+        assertEquals(JSONObjects.toMap(jo), expectedMap);\n+\n+        \/\/ toObject also returns a Map\n+        assertEquals(JSONObjects.toObject(jo), expectedMap);\n+\n+        \/\/ toObject with Object.class as target also returns a Map\n+        assertEquals(JSONObjects.toObject(jo, Object.class), expectedMap);\n+\n+        \/\/ Just used only to construct Type for Map<String, Point>\n+        record DummyRecord(Map<String, Point> namedPoints) {};\n+        Type pointMapType = getFirstComponentType(DummyRecord.class);\n+\n+        \/\/ test Map with specific value type other than Object\n+        Map<String, Point> pointMap = Map.of(\n+             \"x\", new Point(23, 234),\n+             \"y\", new Point(13, -23));\n+        jo = JSONObjects.from(pointMap);\n+        \/\/ round trip check\n+        assertEquals(JSONObjects.toObject(jo, pointMapType), pointMap);\n+\n+        \/\/ use proper typed map converter method\n+        Map<String, Point> convertedPointMap = JSONObjects.toMap(jo, String.class, Point.class);\n+        assertTrue(convertedPointMap.get(\"x\") instanceof Point);\n+        assertTrue(convertedPointMap.get(\"y\") instanceof Point);\n+        assertEquals(convertedPointMap.get(\"x\"), pointMap.get(\"x\"));\n+        assertEquals(convertedPointMap.get(\"y\"), pointMap.get(\"y\"));\n+        \/\/ round trip check\n+        assertEquals(convertedPointMap, pointMap);\n+\n+        \/\/ Just used only to construct Type for Map<URI, String>\n+        record DummyRecord2(Map<URI, String> urls) {};\n+        Type uriMapType = getFirstComponentType(DummyRecord2.class);\n+        \/\/ test Map with specific value type other than Object\n+        Map<URI, String> uriMap = Map.of(\n+             URI.create(\"https:\/\/docs.oracle.com\"), \"Oracle Help Center\",\n+             URI.create(\"https:\/\/jdk.java.net\"), \"OpenJDK home\");\n+        jo = JSONObjects.from(uriMap);\n+        assertEquals(JSONObjects.toObject(jo, uriMapType), uriMap);\n+\n+        \/\/ use proper typed map converter method\n+        Map<URI, String> convertedURIMap = JSONObjects.toMap(jo, URI.class, String.class);\n+        for (URI key : uriMap.keySet()) {\n+            assertTrue(convertedURIMap.get(key) instanceof String);\n+            assertEquals(convertedURIMap.get(key), uriMap.get(key));\n+        }\n+        \/\/ round trip check\n+        assertEquals(convertedURIMap, uriMap);\n+    }\n+\n+    @Test\n+    public void testToEnumMap() {\n+        EnumMap<Color, List<String>> em = new EnumMap<>(Color.class);\n+        em.put(Color.RED, List.of(\"red\", \"RED\", \"#ff0000\"));\n+        em.put(Color.GREEN, List.of(\"green\",\"GREEN\", \"#00ff00\"));\n+        em.put(Color.BLUE, List.of(\"blue\", \"BLUE\", \"#0000ff\"));\n+\n+        \/\/ Just used to construct Type for EnumMap<String, List<String>>\n+        record DummyRecord(EnumMap<Color, List<String>> colors) {};\n+        Type enumMapType = getFirstComponentType(DummyRecord.class);\n+\n+        JSONObject colors = JSONObjects.from(em);\n+        assertTrue(colors.get(\"RED\").isArray());\n+        assertEquals(colors.get(\"RED\").asArray().size(),\n+            em.get(Color.RED).size());\n+        assertTrue(colors.get(\"GREEN\").isArray());\n+        assertEquals(colors.get(\"GREEN\").asArray().size(),\n+            em.get(Color.GREEN).size());\n+        assertTrue(colors.get(\"BLUE\").isArray());\n+        assertEquals(colors.get(\"BLUE\").asArray().size(),\n+            em.get(Color.BLUE).size());\n+\n+        \/\/ round trip check\n+        assertEquals(JSONObjects.toObject(colors, enumMapType), em);\n+\n+        EnumMap<Color, String[]> colorMap = new EnumMap<>(Color.class);\n+        colorMap.put(Color.RED, em.get(Color.RED).toArray(new String[0]));\n+        colorMap.put(Color.GREEN, em.get(Color.GREEN).toArray(new String[0]));\n+        colorMap.put(Color.BLUE, em.get(Color.BLUE).toArray(new String[0]));\n+\n+        colors = JSONObjects.from(colorMap);\n+        \/\/ use proper typed EnumMap converter method\n+        EnumMap<Color, String[]> convertedMap = JSONObjects.\n+                toEnumMap(colors, Color.class, String[].class);\n+\n+        \/\/ round trip check\n+        assertEqualsDeep(convertedMap, colorMap);\n+    }\n+\n+    @Test\n+    public void testSet() {\n+        Set<Point> ps = Set.of(\n+            new Point(24, 13), new Point(124, 81), new Point(2, 132));\n+\n+        \/\/ Just used only to construct Type for Set<Point>\n+        record DummyRecord(Set<Point> points) {};\n+        Type pointSetType = getFirstComponentType(DummyRecord.class);\n+\n+        JSONValue jv = JSONObjects.from(ps);\n+        assertTrue(jv.isArray());\n+        assertEquals(JSONObjects.toObject(jv, pointSetType), ps);\n+    }\n+\n+    @Test\n+    public void testEnumSet() {\n+        \/\/ Just used to construct Type for EnumSet<Color>\n+        record DummyRecord(EnumSet<Color> colors) {};\n+        Type colorSetType = getFirstComponentType(DummyRecord.class);\n+\n+        EnumSet<Color> cs = EnumSet.noneOf(Color.class);\n+        JSONValue colors = JSONObjects.from(cs);\n+        assertTrue(colors.isArray());\n+        assertEquals(colors.asArray().size(), 0);\n+        \/\/ round trip check\n+        assertEquals(JSONObjects.toObject(colors, colorSetType), cs);\n+\n+        cs = EnumSet.of(Color.RED);\n+        colors = JSONObjects.from(cs);\n+        assertTrue(colors.isArray());\n+        assertEquals(colors.asArray().size(), 1);\n+        assertEquals(colors.get(0).asString(), \"RED\");\n+        \/\/ round trip check\n+        assertEquals(JSONObjects.toObject(colors, colorSetType), cs);\n+\n+        cs = EnumSet.of(Color.RED, Color.GREEN, Color.RED);\n+        colors = JSONObjects.from(cs);\n+        assertTrue(colors.isArray());\n+        \/\/ set and so duplicate removed\n+        assertEquals(colors.asArray().size(), 2);\n+        assertEquals(colors.get(0).asString(), \"RED\");\n+        assertEquals(colors.get(1).asString(), \"GREEN\");\n+        \/\/ round trip check\n+        assertEquals(JSONObjects.toObject(colors, colorSetType), cs);\n+\n+        cs = EnumSet.allOf(Color.class);\n+        colors = JSONObjects.from(cs);\n+        assertTrue(colors.isArray());\n+        assertEquals(colors.asArray().size(), 3);\n+        assertEquals(colors.get(0).asString(), \"RED\");\n+        assertEquals(colors.get(1).asString(), \"GREEN\");\n+        assertEquals(colors.get(2).asString(), \"BLUE\");\n+        \/\/ round trip check\n+        assertEquals(JSONObjects.toObject(colors, colorSetType), cs);\n+    }\n+}\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/json\/JSONObjectsTests.java","additions":582,"deletions":0,"binary":false,"changes":582,"status":"added"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.json;\n+\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import org.openjdk.jextract.json.JSON;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class JSONTests {\n+    \/\/ delta for floating point comparisons\n+    private static final double DELTA = 0.0001;\n+\n+    public record Point(int x, int y) {}\n+\n+    @Test\n+    public void testRecordAsJSON() {\n+        Point pt = new Point(233, 435);\n+        String json = JSON.toString(pt, false);\n+        assertEquals(json, \"{\\\"x\\\":233,\\\"y\\\":435}\");\n+    }\n+\n+    @Test\n+    public void testParseRecordFromJSON() {\n+        String json = \"{\\\"x\\\":-989,\\\"y\\\":256}\";\n+        Point pt = JSON.parse(json, Point.class);\n+        assertEquals(pt.x(), -989);\n+        assertEquals(pt.y(), 256);\n+    }\n+\n+    @Test\n+    public void testRecordAsJSONPretty() {\n+        Point pt = new Point(555, 242);\n+        String json = JSON.toString(pt, true);\n+        assertEquals(json, \"{\\n  \\\"x\\\": 555,\\n  \\\"y\\\": 242\\n}\");\n+        \/\/ default of pretty is true!\n+        json = JSON.toString(pt);\n+        assertEquals(json, \"{\\n  \\\"x\\\": 555,\\n  \\\"y\\\": 242\\n}\");\n+    }\n+\n+    @Test\n+    public void testParseRecordFromJSONPretty() {\n+        String json = \"{\\n  \\\"x\\\": 233,\\n  \\\"y\\\": 435\\n}\";\n+        Point pt = JSON.parse(json, Point.class);\n+        assertEquals(pt.x(), 233);\n+        assertEquals(pt.y(), 435);\n+    }\n+\n+    @Test\n+    public void testParseRecordFromJSONExtended() {\n+        String json = \"\"\"\n+        {\n+          \"x\" : 888,  \/\/ X coordinate value\n+          \"y\" : -777, \/\/ Y coordinate value\n+        }\"\"\";\n+        Point pt = JSON.parse(json, Point.class, true);\n+        assertEquals(pt.x(), 888);\n+        assertEquals(pt.y(), -777);\n+\n+        \/\/ parsing without extension should fail!\n+        boolean gotException = false;\n+        try {\n+            JSON.parse(json, Point.class, false);\n+        } catch (RuntimeException re) {\n+            gotException = true;\n+        }\n+        assertTrue(gotException);\n+\n+        \/\/ parsing without extension should fail!\n+        gotException = false;\n+        try {\n+            \/\/ default mode is to disable extensions\n+            JSON.parse(json, Point.class);\n+        } catch (RuntimeException re) {\n+            gotException = true;\n+        }\n+        assertTrue(gotException);\n+    }\n+\n+    \/\/ simple expression language tree model\n+\n+    \/\/ Expr = BinaryExpr | UnaryExpr | OptionalDouble\n+    public record Expr(\n+        Optional<BinaryExpr> binary,\n+        Optional<UnaryExpr> unary,\n+        OptionalDouble literal) {\n+        public Expr {\n+            int emptyCount = 0;\n+            if (binary.isEmpty()) emptyCount++;\n+            if (unary.isEmpty()) emptyCount++;\n+            if (literal.isEmpty()) emptyCount++;\n+            if (emptyCount != 2)\n+                throw new RuntimeException(\"only one of binary, unary, literal has to be non-empty\");\n+        }\n+\n+        @Override\n+        public String toString() {\n+            if (binary.isPresent())\n+                return binary.get().toString();\n+            if (unary.isPresent())\n+                return unary.get().toString();\n+            if (literal.isPresent())\n+                return Double.toString(literal.getAsDouble());\n+            \/\/ atleast one should be non-empty\n+            \/\/ as enforced in the constructor\n+            throw new RuntimeException(\"should not reach here\");\n+        }\n+    }\n+\n+    public enum UnaryOperator { PLUS, MINUS;\n+        @Override\n+        public String toString() {\n+            return this == PLUS ? \"+\" : \"-\";\n+        }\n+    }\n+\n+    public record UnaryExpr(UnaryOperator operator, Expr expr) {\n+        @Override\n+        public String toString() {\n+            return String.format(\"(%s%s)\",\n+                operator.toString(), expr.toString());\n+        }\n+    }\n+\n+    public enum BinaryOperator { ADD, SUB, MUL, DIV;\n+        @Override\n+        public String toString() {\n+            return switch (this) {\n+                case ADD -> \"+\";\n+                case SUB -> \"-\";\n+                case MUL -> \"*\";\n+                case DIV -> \"\/\";\n+            };\n+        }\n+    }\n+\n+    public record BinaryExpr(BinaryOperator operator, Expr left, Expr right) {\n+        @Override\n+        public String toString() {\n+            return String.format(\"(%s %s %s)\",\n+                left.toString(), operator.toString(), right.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testExprTree() {\n+        \/\/ -33.2 \/ 44.5\n+\n+        \/\/ parse expression object from JSON a String\n+        Expr expr = JSON.parse(\"\"\"\n+        {\n+            \"binary\": {\n+                \"operator\": \"DIV\",\n+                \"left\": { \"unary\" : { \"operator\": \"MINUS\", \"expr\": { \"literal\": 33.2 } } },\n+                \"right\": { \"literal\": 44.5 }\n+            }\n+        }\n+        \"\"\",\n+        Expr.class);\n+\n+        assertTrue(expr.literal().isEmpty());\n+        assertTrue(expr.unary().isEmpty());\n+        assertTrue(expr.binary().isPresent());\n+\n+        BinaryExpr binaryExpr = expr.binary().get();\n+        assertEquals(binaryExpr.operator(), BinaryOperator.DIV);\n+\n+        Expr leftExpr = binaryExpr.left();\n+        assertTrue(leftExpr.binary().isEmpty());\n+        assertTrue(leftExpr.literal().isEmpty());\n+        UnaryExpr unaryExpr = leftExpr.unary().get();\n+        assertEquals(unaryExpr.operator(), UnaryOperator.MINUS);\n+        assertEquals(unaryExpr.expr().literal().getAsDouble(), 33.2, DELTA);\n+\n+        Expr rightExpr = binaryExpr.right();\n+        assertTrue(rightExpr.unary().isEmpty());\n+        assertTrue(rightExpr.binary().isEmpty());\n+        assertEquals(rightExpr.literal().getAsDouble(), 44.5, DELTA);\n+\n+        assertEquals(expr.toString(), \"((-33.2) \/ 44.5)\");\n+    }\n+}\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/json\/JSONTests.java","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"@@ -0,0 +1,622 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.json.parser;\n+\n+import java.util.*;\n+import java.util.stream.*;\n+import org.openjdk.jextract.json.parser.*;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class JSONParserTests {\n+    private final JSONParser parser = new JSONParser();\n+\n+    @Test\n+    void testParseTrue() {\n+        var value = parser.parse(\"true\");\n+        assertEquals(value.asBoolean(), true);\n+    }\n+\n+    @Test\n+    void testParseFalse() {\n+        var value = parser.parse(\"false\");\n+        assertEquals(value.asBoolean(), false);\n+    }\n+\n+    @Test\n+    void testParseInt() {\n+        var value = parser.parse(\"17\");\n+        assertEquals(value.asInt(), 17);\n+    }\n+\n+    @Test\n+    void testParseTrueWithWhitespace() {\n+        var value = parser.parse(\"    true   \\n \\t   \\r\\n\");\n+        assertEquals(value.asBoolean(), true);\n+    }\n+\n+    @Test\n+    void testParseFalseWithWhitespace() {\n+        var value = parser.parse(\"\\r\\n    \\t    false  \\t\\t\\t\");\n+        assertEquals(value.asBoolean(), false);\n+    }\n+\n+    @Test\n+    void testParseString() {\n+        var value = parser.parse(\"\\\"Hello, JSON\\\"\");\n+        assertEquals(value.asString(), \"Hello, JSON\");\n+    }\n+\n+    @Test\n+    void testParseArray() {\n+        var value = parser.parse(\"[1,2,3]\");\n+        assertEquals(value.asArray().get(0).asInt(), 1);\n+        assertEquals(value.asArray().get(1).asInt(), 2);\n+        assertEquals(value.asArray().get(2).asInt(), 3);\n+    }\n+\n+    @Test\n+    void testParseNull() {\n+        var value = parser.parse(\"null\");\n+        assertEquals(value.asArray(), null);\n+    }\n+\n+    @Test\n+    void testParseObject() {\n+        var value = parser.parse(\"{\\\"a\\\":1,\\\"b\\\":2,\\\"c\\\":3}\");\n+        assertEquals(value.asObject().get(\"a\").asInt(), 1);\n+        assertEquals(value.asObject().get(\"b\").asInt(), 2);\n+        assertEquals(value.asObject().get(\"c\").asInt(), 3);\n+    }\n+\n+    @Test\n+    void testParseArrayWithWhitespace() {\n+        var value = parser.parse(\"\\n\\n\\n\\t [  1, \\t\\n   2, \\r\\n \\t \\t 3  ] \\t\\t\\t\\n\");\n+        assertEquals(value.asArray().get(0).asInt(), 1);\n+        assertEquals(value.asArray().get(1).asInt(), 2);\n+        assertEquals(value.asArray().get(2).asInt(), 3);\n+    }\n+\n+    @Test\n+    void testParseObjectWithWhitespace() {\n+        var value = parser.parse(\"   \\t \\r\\n   {  \\t \\n \\r\\\"a\\\" \\n\\n \\t : \\r\\n 1 \\n\\n, \\\"b\\\"  :  2 ,  \\\"c\\\"  :  3  }  \");\n+        assertEquals(value.asObject().get(\"a\").asInt(), 1);\n+        assertEquals(value.asObject().get(\"b\").asInt(), 2);\n+        assertEquals(value.asObject().get(\"c\").asInt(), 3);\n+    }\n+\n+    @Test\n+    void testObjectShortcut() {\n+        var value = parser.parse(\"{ \\\"a\\\":1, \\\"b\\\":2, \\\"c\\\":3 }\");\n+        assertEquals(value.get(\"a\").asInt(), 1);\n+        assertEquals(value.get(\"b\").asInt(), 2);\n+        assertEquals(value.get(\"c\").asInt(), 3);\n+    }\n+\n+    @Test\n+    void testArrayShortcut() {\n+        var value = parser.parse(\"[ 1, 2, 3]\");\n+        assertEquals(value.get(0).asInt(), 1);\n+        assertEquals(value.get(1).asInt(), 2);\n+        assertEquals(value.get(2).asInt(), 3);\n+    }\n+\n+    @Test\n+    void testIntToString() {\n+        var v = JSON.of(17);\n+        assertEquals(v.toString(), \"17\");\n+    }\n+\n+    @Test\n+    void testDoubleToString() {\n+        var v = JSON.of(17.7);\n+        assertEquals(v.toString(), \"17.7\");\n+    }\n+\n+    @Test\n+    void testBooleanToString() {\n+        var v = JSON.of(true);\n+        assertEquals(v.toString(), \"true\");\n+    }\n+\n+    @Test\n+    void testNullToString() {\n+        var v = JSON.of();\n+        assertEquals(v.toString(), \"null\");\n+    }\n+\n+    @Test\n+    void testStringToString() {\n+        var v = JSON.of(\"Hello, JSON\");\n+        assertEquals(v.toString(), \"\\\"Hello, JSON\\\"\");\n+    }\n+\n+    @Test\n+    void testArrayToString() {\n+        var v = new JSONArray();\n+        v.add(1);\n+        v.add(2);\n+        v.add(3);\n+        assertEquals(v.toString(), \"[1,2,3]\");\n+    }\n+\n+    @Test\n+    void testObjectToString() {\n+        var v = new JSONObject();\n+        v.put(\"a\", 1);\n+        v.put(\"b\", 2);\n+        v.put(\"c\", 3);\n+        assertEquals(v.toString(), \"{\\\"a\\\":1,\\\"b\\\":2,\\\"c\\\":3}\");\n+    }\n+\n+    @Test\n+    void testNestedObjectToString() {\n+        var inner = new JSONObject();\n+        inner.put(\"a\", 1);\n+        inner.put(\"b\", 2);\n+        inner.put(\"c\", 3);\n+\n+        var outer = new JSONObject();\n+        outer.put(\"inner\", inner);\n+        assertEquals(outer.toString(), \"{\\\"inner\\\":{\\\"a\\\":1,\\\"b\\\":2,\\\"c\\\":3}}\");\n+    }\n+\n+    @Test\n+    void testToStringAndParse() {\n+        var inner = new JSONObject();\n+        inner.put(\"a\", 1);\n+        inner.put(\"b\", 2);\n+        inner.put(\"c\", 3);\n+\n+        var outer = new JSONObject();\n+        outer.put(\"inner\", inner);\n+\n+        var s = outer.toString();\n+\n+        var parsed = parser.parse(s);\n+        assertEquals(parsed.get(\"inner\").get(\"a\").asInt(), 1);\n+        assertEquals(parsed.get(\"inner\").get(\"b\").asInt(), 2);\n+        assertEquals(parsed.get(\"inner\").get(\"c\").asInt(), 3);\n+    }\n+\n+    @Test\n+    void testLargerJSONText() {\n+        var text = \"{\\n\" +\n+                   \"  \\\"name\\\": \\\"mighty_readme\\\",\\n\" +\n+                   \"  \\\"head_sha\\\": \\\"ce587453ced02b1526dfb4cb910479d431683101\\\",\\n\" +\n+                   \"  \\\"status\\\": \\\"completed\\\",\\n\" +\n+                   \"  \\\"started_at\\\": \\\"2017-11-30T19:39:10Z\\\",\\n\" +\n+                   \"  \\\"completed_at\\\": \\\"2017-11-30T19:49:10Z\\\",\\n\" +\n+                   \"  \\\"output\\\": {\\n\" +\n+                   \"    \\\"title\\\": \\\"Mighty Readme report\\\",\\n\" +\n+                   \"    \\\"summary\\\": \\\"There are 0 failures, 2 warnings, and 1 notices.\\\",\\n\" +\n+                   \"    \\\"text\\\": \\\"You may have some misspelled words on lines 2 and 4. You also may want to add a section in your README about how to install your app.\\\",\\n\" +\n+                   \"    \\\"annotations\\\": [\\n\" +\n+                   \"      {\\n\" +\n+                   \"        \\\"path\\\": \\\"README.md\\\",\\n\" +\n+                   \"        \\\"annotation_level\\\": \\\"warning\\\",\\n\" +\n+                   \"        \\\"title\\\": \\\"Spell Checker\\\",\\n\" +\n+                   \"        \\\"message\\\": \\\"Check your spelling for 'banaas'.\\\",\\n\" +\n+                   \"        \\\"raw_details\\\": \\\"Do you mean 'bananas' or 'banana'?\\\",\\n\" +\n+                   \"        \\\"start_line\\\": \\\"2\\\",\\n\" +\n+                   \"        \\\"end_line\\\": \\\"2\\\"\\n\" +\n+                   \"      },\\n\" +\n+                   \"      {\\n\" +\n+                   \"        \\\"path\\\": \\\"README.md\\\",\\n\" +\n+                   \"        \\\"annotation_level\\\": \\\"warning\\\",\\n\" +\n+                   \"        \\\"title\\\": \\\"Spell Checker\\\",\\n\" +\n+                   \"        \\\"message\\\": \\\"Check your spelling for 'aples'\\\",\\n\" +\n+                   \"        \\\"raw_details\\\": \\\"Do you mean 'apples' or 'Naples'\\\",\\n\" +\n+                   \"        \\\"start_line\\\": \\\"4\\\",\\n\" +\n+                   \"        \\\"end_line\\\": \\\"4\\\"\\n\" +\n+                   \"      }\\n\" +\n+                   \"    ],\\n\" +\n+                   \"    \\\"images\\\": [\\n\" +\n+                   \"      {\\n\" +\n+                   \"        \\\"alt\\\": \\\"Super bananas\\\",\\n\" +\n+                   \"        \\\"image_url\\\": \\\"http:\/\/example.com\/images\/42\\\"\\n\" +\n+                   \"      }\\n\" +\n+                   \"    ]\\n\" +\n+                   \"  },\\n\" +\n+                   \"  \\\"actions\\\": [\\n\" +\n+                   \"    {\\n\" +\n+                   \"      \\\"label\\\": \\\"Fix\\\",\\n\" +\n+                   \"      \\\"identifier\\\": \\\"fix_errors\\\",\\n\" +\n+                   \"      \\\"description\\\": \\\"Allow us to fix these errors for you\\\"\\n\" +\n+                   \"    }\\n\" +\n+                   \"  ]\\n\" +\n+                   \"}\";\n+        var v = parser.parse(text);\n+        assertEquals(v.get(\"name\").asString(), \"mighty_readme\");\n+        assertEquals(v.get(\"output\").get(\"annotations\").get(0).get(\"path\").asString(), \"README.md\");\n+    }\n+\n+    @Test\n+    void testAPI() {\n+        var o = JSON.object()\n+                    .put(\"a\", 1)\n+                    .put(\"b\", 2)\n+                    .put(\"c\", 3);\n+\n+        var parsed = JSON.parse(o.toString());\n+        assertEquals(parsed.get(\"a\").asInt(), 1);\n+        assertEquals(parsed.get(\"b\").asInt(), 2);\n+        assertEquals(parsed.get(\"c\").asInt(), 3);\n+\n+        var a = JSON.array()\n+                    .add(\"a\")\n+                    .add(2)\n+                    .add(false)\n+                    .add(3.14);\n+\n+        parsed = JSON.parse(a.toString());\n+        assertEquals(parsed.get(0).asString(), \"a\");\n+        assertEquals(parsed.get(1).asInt(), 2);\n+        assertEquals(parsed.get(2).asBoolean(), false);\n+        assertEquals(parsed.get(3).asDouble(), 3.14);\n+\n+        var o2 = JSON.object()\n+                     .put(\"inner\",\n+                        JSON.object()\n+                            .put(\"x\", 1)\n+                            .put(\"y\", \"user_2\")\n+                            .put(\"z\", 2.1))\n+                     .put(\"array\",\n+                        JSON.array()\n+                            .add(4)\n+                            .add(false)\n+                            .add(\"user_1\"));\n+\n+        parsed = JSON.parse(o2.toString());\n+        assertEquals(parsed.get(\"inner\").get(\"x\").asInt(), 1);\n+        assertEquals(parsed.get(\"inner\").get(\"y\").asString(), \"user_2\");\n+        assertEquals(parsed.get(\"inner\").get(\"z\").asDouble(), 2.1);\n+        assertEquals(parsed.get(\"array\").get(0).asInt(), 4);\n+        assertEquals(parsed.get(\"array\").get(1).asBoolean(), false);\n+        assertEquals(parsed.get(\"array\").get(2).asString(), \"user_1\");\n+    }\n+\n+    @Test\n+    void testParseStringWithCitation() {\n+        var v = JSON.parse(\"\\\"hello, \\\\\\\"citation\\\\\\\"\\\"\");\n+        assertEquals(\"hello, \\\"citation\\\"\", v.asString());\n+    }\n+\n+    @Test\n+    void testParseStringBackslash() {\n+        var v = JSON.parse(\"\\\"hello, backslash: \\\\\\\\ \\\"\");\n+        assertEquals(\"hello, backslash: \\\\ \", v.asString());\n+    }\n+\n+    @Test\n+    void testParseStringBackslashAndN() {\n+        var v = JSON.parse(\"\\\"hello, backslash: \\\\\\\\n \\\"\");\n+        assertEquals(\"hello, backslash: \\\\n \", v.asString());\n+    }\n+\n+    @Test\n+    void testParseEmptyString() {\n+        var v = JSON.parse(\"\\\"\\\"\");\n+        assertEquals(\"\", v.asString());\n+    }\n+\n+    @Test\n+    void testParseStringWithNewline() {\n+        var v = JSON.parse(\"\\\"hello newline\\\\n\\\"\");\n+        assertEquals(\"hello newline\\n\", v.asString());\n+    }\n+\n+    @Test\n+    void testStreamAPI() {\n+        var v = JSON.array().add(1).add(2).add(3);\n+        var a = v.stream().mapToInt(JSONValue::asInt).toArray();\n+        assertEquals(a[0], 1);\n+        assertEquals(a[1], 2);\n+        assertEquals(a[2], 3);\n+\n+        var v2 = JSON.of(17.7);\n+        assertEquals(v2.stream().count(), 1L);\n+    }\n+\n+    @Test\n+    void testIterateFieldsInObject() {\n+        var o = JSON.object()\n+                    .put(\"a\", 1)\n+                    .put(\"b\", 2)\n+                    .put(\"c\", 3);\n+\n+        var fields = o.fields();\n+        assertEquals(fields.size(), 3);\n+\n+        var seen = new HashSet<String>();\n+        fields.forEach(f -> seen.add(f.name()));\n+        assertTrue(seen.contains(\"a\"));\n+        assertTrue(seen.contains(\"b\"));\n+        assertTrue(seen.contains(\"c\"));\n+    }\n+\n+    @Test\n+    void testObjectContains() {\n+        var o = JSON.object().put(\"a\", 1);\n+        assertTrue(o.contains(\"a\"));\n+        assertFalse(o.contains(\"b\"));\n+    }\n+\n+    @Test\n+    void testArrayIterator() {\n+        var array = JSON.array().add(1).add(2).add(3);\n+        var count = 0;\n+        for (var e : array) {\n+            count++;\n+        }\n+        assertEquals(count, 3);\n+    }\n+\n+    @Test\n+    void testStringEncodingWithEscapedChars() {\n+        var s = JSON.of(\"hello newline\\n\");\n+        assertEquals(\"\\\"hello newline\\\\n\\\"\", s.toString());\n+\n+        s = JSON.of(\"backslash: \\\\\");\n+        assertEquals(\"\\\"backslash: \\\\\\\\\\\"\", s.toString());\n+    }\n+\n+    @Test\n+    void testLongNumber() {\n+        var l = 1337L;\n+        var json = JSON.of(l);\n+        assertEquals(\"1337\", json.toString());\n+        assertEquals(1337L, json.asLong());\n+        assertEquals(1337, json.asInt());\n+    }\n+\n+    @Test\n+    void testEscapedUnicodeCodePoint() {\n+        var s = \"\\\"\\\\ud83d\\\\ude04\\\"\";\n+        var json = JSON.parse(s);\n+        assertEquals(\"\\ud83d\\ude04\", json.asString());\n+\n+        s = \"\\\"\\\\u003c\\\"\";\n+        json = JSON.parse(s);\n+        assertEquals(\"\\u003c\", json.asString());\n+        assertEquals(\"<\", json.asString());\n+    }\n+\n+    @Test\n+    void testLargeGitLabExample() {\n+        var s =\n+        \"[\" +\n+            \"{\" +\n+                \"\\\"id\\\":369,\" +\n+                \"\\\"iid\\\":2,\" +\n+                \"\\\"project_id\\\":55,\" +\n+                \"\\\"title\\\":\\\"Add some useful whitespace\\\",\"+\n+                \"\\\"description\\\":\\\"It is that time.\\\\n\\\\n\\\\u003c!-- \" +\n+                                  \"Anything below this marker will be \" +\n+                                  \"automatically updated, please do not \" +\n+                                  \"edit manually! --\\\\u003e\\\\n\\\\n- [x] \" +\n+                                  \"Your change must have been available for \" +\n+                                  \"review at least 24 hours\\\\n- [ ] Title must \" +\n+                                  \"be of the format id: description where id \" +\n+                                  \"matches an existing JBS issue\\\",\" +\n+                \"\\\"state\\\":\\\"opened\\\",\" +\n+                \"\\\"created_at\\\":\\\"2018-09-06T11:52:39.314Z\\\",\" +\n+                \"\\\"updated_at\\\":\\\"2018-09-10T13:08:27.648Z\\\",\" +\n+                \"\\\"target_branch\\\":\\\"master\\\",\" +\n+                \"\\\"source_branch\\\":\\\"rwtest-1\\\",\" +\n+                \"\\\"upvotes\\\":0,\" +\n+                \"\\\"downvotes\\\":0,\"+\n+                \"\\\"author\\\":{\" +\n+                    \"\\\"id\\\":2,\" +\n+                    \"\\\"name\\\":\\\"User Number 3\\\",\" +\n+                    \"\\\"username\\\":\\\"user_3\\\",\" +\n+                    \"\\\"state\\\":\\\"active\\\",\" +\n+                    \"\\\"avatar_url\\\":\\\"avatar.png\\\",\" +\n+                    \"\\\"web_url\\\":\\\"https:\/\/host.com\/user_3\\\"\" +\n+                    \"},\" +\n+                \"\\\"assignee\\\":null,\" +\n+                \"\\\"source_project_id\\\":55,\" +\n+                \"\\\"target_project_id\\\":55,\" +\n+                \"\\\"labels\\\":[],\" +\n+                \"\\\"draft\\\":false,\" +\n+                \"\\\"milestone\\\":null,\" +\n+                \"\\\"merge_when_pipeline_succeeds\\\":false,\" +\n+                \"\\\"merge_status\\\":\\\"can_be_merged\\\",\" +\n+                \"\\\"sha\\\":\\\"e282f1d56fa0710783d1c5d77a6c850669937a72\\\",\" +\n+                \"\\\"merge_commit_sha\\\":null,\" +\n+                \"\\\"user_notes_count\\\":2,\" +\n+                \"\\\"discussion_locked\\\":null,\" +\n+                \"\\\"should_remove_source_branch\\\":null,\" +\n+                \"\\\"force_remove_source_branch\\\":false,\" +\n+                \"\\\"web_url\\\":\\\"https:\/\/host.com\/user_3\/test\/merge_requests\/2\\\",\" +\n+                \"\\\"time_stats\\\":{\" +\n+                    \"\\\"time_estimate\\\":0,\" +\n+                    \"\\\"total_time_spent\\\":0,\" +\n+                    \"\\\"human_time_estimate\\\":null,\" +\n+                    \"\\\"human_total_time_spent\\\":null\" +\n+                    \"},\" +\n+                \"\\\"squash\\\":false\" +\n+            \"}\" +\n+        \"]\";\n+\n+        var json = JSON.parse(s);\n+        assertEquals(369, json.get(0).get(\"id\").asInt());\n+        assertEquals(\"active\", json.get(0).get(\"author\").get(\"state\").asString());\n+    }\n+\n+    @Test\n+    public void testIsNull() {\n+        var json = JSON.parse(\"[{\\\"id\\\":705,\\\"type\\\":null,\\\"body\\\":\\\"description\\\"}]\");\n+        assertTrue(json.get(0).get(\"type\").isNull());\n+        assertFalse(json.get(0).get(\"type\").isInt());\n+        assertFalse(json.get(0).get(\"type\").isLong());\n+        assertFalse(json.get(0).get(\"type\").isDouble());\n+        assertFalse(json.get(0).get(\"type\").isString());\n+        assertFalse(json.get(0).get(\"type\").isBoolean());\n+        assertFalse(json.get(0).get(\"type\").isArray());\n+        assertFalse(json.get(0).get(\"type\").isObject());\n+\n+        assertFalse(json.get(0).get(\"id\").isNull());\n+    }\n+\n+    @Test\n+    public void testContainsShortcut() {\n+        var json = JSON.parse(\"{\\\"id\\\":705,\\\"type\\\":null,\\\"body\\\":\\\"description\\\"}\");\n+        assertTrue(json.contains(\"id\"));\n+        assertFalse(json.contains(\"header\"));\n+        assertTrue(json.contains(\"type\"));\n+    }\n+\n+    @Test\n+    public void testFieldsShortcut() {\n+        var json = JSON.parse(\"{\\\"id\\\":705,\\\"type\\\":null,\\\"body\\\":\\\"description\\\"}\");\n+        var names = json.fields().stream().map(JSONObject.Field::name).collect(Collectors.toSet());\n+        assertEquals(Set.of(\"id\", \"type\", \"body\"), names);\n+    }\n+\n+    @Test\n+    public void testArrayWithWhitespace() {\n+        var json = JSON.parse(\"{ \\\"foo\\\": [ ] }\");\n+        assertEquals(0, json.get(\"foo\").asArray().size());\n+    }\n+\n+    @Test\n+    public void testObjectWithWhitespace() {\n+        var json = JSON.parse(\"{ \\\"foo\\\": { } }\");\n+        assertEquals(0, json.get(\"foo\").asObject().fields().size());\n+    }\n+\n+    @Test\n+    public void testIsInt() {\n+        var json = JSON.parse(\"{ \\\"foo\\\": 1 }\");\n+\n+        assertTrue(json.get(\"foo\").isInt());\n+        assertTrue(json.get(\"foo\").isLong());\n+\n+        assertFalse(json.get(\"foo\").isDouble());\n+        assertFalse(json.get(\"foo\").isString());\n+        assertFalse(json.get(\"foo\").isBoolean());\n+        assertFalse(json.get(\"foo\").isArray());\n+        assertFalse(json.get(\"foo\").isObject());\n+        assertFalse(json.get(\"foo\").isNull());\n+    }\n+\n+    @Test\n+    public void testIsLong() {\n+        var json = JSON.parse(\"{ \\\"foo\\\": 1337 }\");\n+\n+        assertTrue(json.get(\"foo\").isInt());\n+        assertTrue(json.get(\"foo\").isLong());\n+\n+        assertFalse(json.get(\"foo\").isDouble());\n+        assertFalse(json.get(\"foo\").isString());\n+        assertFalse(json.get(\"foo\").isBoolean());\n+        assertFalse(json.get(\"foo\").isArray());\n+        assertFalse(json.get(\"foo\").isObject());\n+        assertFalse(json.get(\"foo\").isNull());\n+    }\n+\n+    @Test\n+    public void testIsDouble() {\n+        var json = JSON.parse(\"{ \\\"foo\\\": 17.7 }\");\n+\n+        assertTrue(json.get(\"foo\").isDouble());\n+\n+        assertFalse(json.get(\"foo\").isInt());\n+        assertFalse(json.get(\"foo\").isLong());\n+        assertFalse(json.get(\"foo\").isBoolean());\n+        assertFalse(json.get(\"foo\").isString());\n+        assertFalse(json.get(\"foo\").isArray());\n+        assertFalse(json.get(\"foo\").isObject());\n+        assertFalse(json.get(\"foo\").isNull());\n+    }\n+\n+    @Test\n+    public void testIsString() {\n+        var json = JSON.parse(\"{ \\\"foo\\\": \\\"bar\\\" }\");\n+\n+        assertTrue(json.get(\"foo\").isString());\n+\n+        assertFalse(json.get(\"foo\").isInt());\n+        assertFalse(json.get(\"foo\").isLong());\n+        assertFalse(json.get(\"foo\").isDouble());\n+        assertFalse(json.get(\"foo\").isBoolean());\n+        assertFalse(json.get(\"foo\").isArray());\n+        assertFalse(json.get(\"foo\").isObject());\n+        assertFalse(json.get(\"foo\").isNull());\n+    }\n+\n+    @Test\n+    public void testIsBoolean() {\n+        var json = JSON.parse(\"{ \\\"foo\\\": true }\");\n+\n+        assertTrue(json.get(\"foo\").isBoolean());\n+\n+        assertFalse(json.get(\"foo\").isInt());\n+        assertFalse(json.get(\"foo\").isLong());\n+        assertFalse(json.get(\"foo\").isDouble());\n+        assertFalse(json.get(\"foo\").isString());\n+        assertFalse(json.get(\"foo\").isArray());\n+        assertFalse(json.get(\"foo\").isObject());\n+        assertFalse(json.get(\"foo\").isNull());\n+    }\n+\n+    @Test\n+    public void testIsArray() {\n+        var json = JSON.parse(\"{ \\\"foo\\\": [1,2,3] }\");\n+\n+        assertTrue(json.get(\"foo\").isArray());\n+\n+        assertFalse(json.get(\"foo\").isInt());\n+        assertFalse(json.get(\"foo\").isLong());\n+        assertFalse(json.get(\"foo\").isDouble());\n+        assertFalse(json.get(\"foo\").isBoolean());\n+        assertFalse(json.get(\"foo\").isString());\n+        assertFalse(json.get(\"foo\").isObject());\n+        assertFalse(json.get(\"foo\").isNull());\n+    }\n+\n+    @Test\n+    public void testIsObject() {\n+        var json = JSON.parse(\"{ \\\"foo\\\": { \\\"bar\\\": true } }\");\n+\n+        assertTrue(json.get(\"foo\").isObject());\n+\n+        assertFalse(json.get(\"foo\").isInt());\n+        assertFalse(json.get(\"foo\").isLong());\n+        assertFalse(json.get(\"foo\").isDouble());\n+        assertFalse(json.get(\"foo\").isBoolean());\n+        assertFalse(json.get(\"foo\").isString());\n+        assertFalse(json.get(\"foo\").isArray());\n+        assertFalse(json.get(\"foo\").isNull());\n+    }\n+\n+    @Test\n+    public void testJSONObjectWithNullField() {\n+        var json = JSON.parse(\"{ \\\"foo\\\": null }\");\n+\n+        assertNotNull(json.get(\"foo\"));\n+        assertTrue(json.get(\"foo\").isNull());\n+    }\n+}\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/json\/parser\/JSONParserTests.java","additions":622,"deletions":0,"binary":false,"changes":622,"status":"added"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.json.parser;\n+\n+import java.util.*;\n+import java.util.stream.*;\n+import org.openjdk.jextract.json.parser.*;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class JWCCTests {\n+    @Test\n+    public void testSingleLineComment() {\n+        var text = \"\"\"\n+                   \/\/ this is a comment before the object\n+                   { \/\/ this is a comment after opening brace\n+                     \"foo\": \"bar\" \/\/ this is a comment after field\n+                   } \/\/ this is a comment after closening brace\n+                   \/\/ this is a comment after the object\n+                   \"\"\";\n+        var json = JWCC.parse(text);\n+        assertEquals(\"bar\", json.get(\"foo\").asString());\n+    }\n+\n+    @Test\n+    public void testSingleLineCommentAfterKey() {\n+        var text = \"\"\"\n+                   {\n+                     \"foo\": \/\/ comment\n+                         \"bar\"\n+                   }\n+                   \"\"\";\n+        var json = JWCC.parse(text);\n+        assertEquals(\"bar\", json.get(\"foo\").asString());\n+    }\n+\n+    @Test\n+    public void testSingleLineCommentAfterKeyWithoutValue() {\n+        var text = \"\"\"\n+                   {\n+                     \"foo\": \/\/ comment\n+                   }\n+                   \"\"\";\n+        assertThrows(IllegalStateException.class, () -> {\n+            JWCC.parse(text);\n+        });\n+    }\n+\n+    @Test\n+    public void testInlineComment() {\n+        var text = \"\"\"\n+                   \/*\n+                    * This is a multi-line comment\n+                    *\n+                    *\/\n+                   \/*\n+                    * This is another multi-line comment with JSON in it\n+                    {\n+                      \"foo\": 17\n+                    }\n+                    *\/\n+                   \/* small comment *\/ { \/* another\n+                   multi-line *\/\n+                     \/* before *\/ \"foo\" \/* a comment *\/ : \/* another comment *\/ \"bar\" \/* so many comments *\/\n+                   } \/* after *\/\n+                   \/*\n+                    * A final multi-line\n+                    *\/\n+                   \"\"\";\n+        var json = JWCC.parse(text);\n+        assertEquals(\"bar\", json.get(\"foo\").asString());\n+    }\n+\n+    @Test\n+    public void testInlineAndLineComment() {\n+        var text = \"\"\"\n+                   \/*\n+                    * This is a multi-line comment\n+                    * \/\/ with a line comment inside it\n+                    *\/\n+                   \/*\n+                    * This is another multi-line comment with JSON in it\n+                    {\n+                      \"foo\": 17\n+                    }\n+                    *\/\n+                   \/* small comment *\/ { \/\/ until end-of-line with closing brace }\n+                     \/* before *\/ \"foo\" \/* a comment *\/ : \/* another comment *\/ \"bar\" \/\/\/\/\/\/\/ end-of-line\n+                   } \/* after *\/ \/\/ end-of-line \/* with in-line *\/\n+                   \/*\n+                    * A final multi-line\n+                    *\/\n+                    \/\/ A final singe-line\n+                   \"\"\";\n+        var json = JWCC.parse(text);\n+        assertEquals(\"bar\", json.get(\"foo\").asString());\n+    }\n+\n+    @Test\n+    public void testInlineAndLineCommentWithArray() {\n+        var text = \"\"\"\n+                   \/*\n+                    * This is a multi-line comment\n+                    * \/\/ with a line comment inside it\n+                    *\/\n+                   \/*\n+                    * This is another multi-line comment with JSON in it\n+                    {\n+                      \"foo\": 17\n+                    }\n+                    *\/\n+                   \/* small comment *\/ [ \/\/ until end-of-line with closing brace }\n+                     \/* before *\/ \"foo\" \/* a comment *\/ , \/* another comment *\/ \"bar\" \/\/\/\/\/\/\/ end-of-line\n+                   ] \/* after *\/ \/\/ end-of-line \/* with in-line *\/\n+                   \/*\n+                    * A final multi-line\n+                    *\/\n+                    \/\/ A final singe-line\n+                   \"\"\";\n+        var json = JWCC.parse(text);\n+        assertEquals(\"foo\", json.get(0).asString());\n+        assertEquals(\"bar\", json.get(1).asString());\n+        assertEquals(2, json.asArray().size());\n+    }\n+\n+    @Test\n+    public void testTrailingComma() {\n+        var text = \"\"\"\n+                   {\n+                       \"a\": 1,\n+                       \"b\": 2,\n+                   }\n+                   \"\"\";\n+        var json = JWCC.parse(text);\n+        assertEquals(1, json.get(\"a\").asInt());\n+        assertEquals(2, json.get(\"b\").asInt());\n+    }\n+\n+    @Test\n+    public void testTrailingCommaWithLineComment() {\n+        var text = \"\"\"\n+                   {\n+                       \"a\": 1, \/\/ a comment\n+                       \"b\": 2, \/\/ another comment\n+                   }\n+                   \"\"\";\n+        var json = JWCC.parse(text);\n+        assertEquals(1, json.get(\"a\").asInt());\n+        assertEquals(2, json.get(\"b\").asInt());\n+    }\n+\n+    @Test\n+    public void testTrailingCommaWithInLineComment() {\n+        var text = \"\"\"\n+                   {\n+                       \"a\": 1, \/* an in-line *\/\n+                       \"b\": 2, \/* another in-line *\/\n+                   }\n+                   \"\"\";\n+        var json = JWCC.parse(text);\n+        assertEquals(1, json.get(\"a\").asInt());\n+        assertEquals(2, json.get(\"b\").asInt());\n+    }\n+\n+    @Test\n+    public void testTrailingOnSameLine() {\n+        var text = \"\"\"\n+                   {\n+                       \"a\": 1, \"b\": 2, \/* in-line *\/ \"c\": 3,\n+                   }\n+                   \"\"\";\n+        var json = JWCC.parse(text);\n+        assertEquals(1, json.get(\"a\").asInt());\n+        assertEquals(2, json.get(\"b\").asInt());\n+        assertEquals(3, json.get(\"c\").asInt());\n+    }\n+\n+    @Test\n+    public void testTrailingWithArray() {\n+        var text = \"\"\"\n+                   [\n+                       \"a\",\n+                   ]\n+                   \"\"\";\n+        var json = JWCC.parse(text);\n+        assertEquals(\"a\", json.get(0).asString());\n+    }\n+\n+    @Test\n+    public void testTrailingWithMultipleArray() {\n+        var text = \"\"\"\n+                   [\n+                       \"a\",\n+                       \"b\",\n+                   ]\n+                   \"\"\";\n+        var json = JWCC.parse(text);\n+        assertEquals(\"a\", json.get(0).asString());\n+        assertEquals(\"b\", json.get(1).asString());\n+    }\n+}\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/json\/parser\/JWCCTests.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"}]}