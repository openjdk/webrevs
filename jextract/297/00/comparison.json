{"files":[{"patch":"@@ -41,1 +41,0 @@\n-\n@@ -76,15 +75,22 @@\n-    \/\/ make sure we only pick up the \"real\" shared library file from LLVM installation\n-    \/\/ (e.g. exclude symlinks on Linux)\n-    def clang_path_include = (Os.isFamily(Os.FAMILY_UNIX) && !Os.isFamily(Os.FAMILY_MAC)) ?\n-            \"libclang.so.${clang_version}\" : \"*clang*\"\n-\n-    from(\"${libclang_dir}\") {\n-        include(clang_path_include)\n-        include(\"libLLVM.*\")\n-        exclude(\"clang.exe\")\n-        into(\"libs\")\n-        \/\/ make sure we drop shared library version name (Linux only)\n-        rename(\"libclang.so.${clang_version}\", \"libclang.so\")\n-    }\n-\n-    from(\"$clang_include_dir\") {\n+     \/\/ make sure we only pick up the \"real\" shared library file from LLVM installation\n+     \/\/ (e.g. exclude symlinks on Linux)\n+     def isAix = Os.isName(\"AIX\") || Os.isName(\"aix\")\n+     def isUnixNotMac  = Os.isFamily(Os.FAMILY_UNIX) && !Os.isFamily(Os.FAMILY_MAC)\n+     def clang_path_include =\n+        isAix  ? \"libclang.a\" :\n+        isUnixNotMac ? \"libclang.so.${clang_version}\" :\n+                 \"*clang*\"\n+     from(\"${libclang_dir}\") {\n+         include(clang_path_include)\n+         include(\"libLLVM.*\")\n+         exclude(\"clang.exe\")\n+         into(\"libs\")\n+         \/\/ make sure we drop shared library version name (Linux only)\n+         rename(\"libclang.so.*\", \"libclang.so\")\n+\n+     }\n+     from(\"${libclang_dir}\") {\n+        include(\"libclang.a\")\n+        into(\"$buildDir\/test-libs\")\n+     }\n+     from(\"$clang_include_dir\") {\n@@ -93,1 +99,2 @@\n-    }\n+     }\n+\n@@ -197,0 +204,2 @@\n+    environment \"CC\", \"\/opt\/IBM\/xlC\/13.1.3\/bin\/xlc\"\n+    environment \"CXX\", \"\/opt\/IBM\/xlC\/13.1.3\/bin\/xlC\"\n@@ -206,0 +215,1 @@\n+\n@@ -241,1 +251,1 @@\n-                \"-retain:fail,error\",\n+                \"-retain:fail,error\"\n@@ -261,0 +271,18 @@\n+\n+tasks.register(\"copyLibClangToTestLib\", Copy) {\n+    def srcFile = file(\"${project.buildDir}\/jmod_inputs\/libs\/libclang.a\")\n+    def destDir = file(\"${project.buildDir}\/test-lib\/libs\")\n+    dependsOn(copyLibClang)\n+    from(srcFile) \n+    into(destDir)\n+\n+    doLast {\n+        println \"[DEBUG] Successfully copied libclang.a to test-lib\/libs\"\n+    }\n+}\n+\n+\/\/ Make jtreg depend on it\n+tasks.named(\"jtreg\") {\n+    dependsOn(\"copyLibClangToTestLib\")\n+}\n+\n","filename":"build.gradle","additions":46,"deletions":18,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -1,252 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright © 2015-2021 the original authors.\n-#\n-# Licensed under the Apache License, Version 2.0 (the \"License\");\n-# you may not use this file except in compliance with the License.\n-# You may obtain a copy of the License at\n-#\n-#      https:\/\/www.apache.org\/licenses\/LICENSE-2.0\n-#\n-# Unless required by applicable law or agreed to in writing, software\n-# distributed under the License is distributed on an \"AS IS\" BASIS,\n-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-# See the License for the specific language governing permissions and\n-# limitations under the License.\n-#\n-# SPDX-License-Identifier: Apache-2.0\n-#\n-\n-##############################################################################\n-#\n-#   Gradle start up script for POSIX generated by Gradle.\n-#\n-#   Important for running:\n-#\n-#   (1) You need a POSIX-compliant shell to run this script. If your \/bin\/sh is\n-#       noncompliant, but you have some other compliant shell such as ksh or\n-#       bash, then to run this script, type that shell name before the whole\n-#       command line, like:\n-#\n-#           ksh Gradle\n-#\n-#       Busybox and similar reduced shells will NOT work, because this script\n-#       requires all of these POSIX shell features:\n-#         * functions;\n-#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,\n-#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;\n-#         * compound commands having a testable exit status, especially «case»;\n-#         * various built-in commands including «command», «set», and «ulimit».\n-#\n-#   Important for patching:\n-#\n-#   (2) This script targets any POSIX shell, so it avoids extensions provided\n-#       by Bash, Ksh, etc; in particular arrays are avoided.\n-#\n-#       The \"traditional\" practice of packing multiple parameters into a\n-#       space-separated string is a well documented source of bugs and security\n-#       problems, so this is (mostly) avoided, by progressively accumulating\n-#       options in \"$@\", and eventually passing that to Java.\n-#\n-#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,\n-#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;\n-#       see the in-line comments for details.\n-#\n-#       There are tweaks for specific operating systems such as AIX, CygWin,\n-#       Darwin, MinGW, and NonStop.\n-#\n-#   (3) This script is generated from the Groovy template\n-#       https:\/\/github.com\/gradle\/gradle\/blob\/HEAD\/platforms\/jvm\/plugins-application\/src\/main\/resources\/org\/gradle\/api\/internal\/plugins\/unixStartScript.txt\n-#       within the Gradle project.\n-#\n-#       You can find Gradle at https:\/\/github.com\/gradle\/gradle\/.\n-#\n-##############################################################################\n-\n-# Attempt to set APP_HOME\n-\n-# Resolve links: $0 may be a link\n-app_path=$0\n-\n-# Need this for daisy-chained symlinks.\n-while\n-    APP_HOME=${app_path%\"${app_path##*\/}\"}  # leaves a trailing \/; empty if no leading path\n-    [ -h \"$app_path\" ]\n-do\n-    ls=$( ls -ld \"$app_path\" )\n-    link=${ls#*' -> '}\n-    case $link in             #(\n-      \/*)   app_path=$link ;; #(\n-      *)    app_path=$APP_HOME$link ;;\n-    esac\n-done\n-\n-# This is normally unused\n-# shellcheck disable=SC2034\n-APP_BASE_NAME=${0##*\/}\n-# Discard cd standard output in case $CDPATH is set (https:\/\/github.com\/gradle\/gradle\/issues\/25036)\n-APP_HOME=$( cd -P \"${APP_HOME:-.\/}\" > \/dev\/null && printf '%s\n-' \"$PWD\" ) || exit\n-\n-# Use the maximum available, or set MAX_FD != -1 to use that value.\n-MAX_FD=maximum\n-\n-warn () {\n-    echo \"$*\"\n-} >&2\n-\n-die () {\n-    echo\n-    echo \"$*\"\n-    echo\n-    exit 1\n-} >&2\n-\n-# OS specific support (must be 'true' or 'false').\n-cygwin=false\n-msys=false\n-darwin=false\n-nonstop=false\n-case \"$( uname )\" in                #(\n-  CYGWIN* )         cygwin=true  ;; #(\n-  Darwin* )         darwin=true  ;; #(\n-  MSYS* | MINGW* )  msys=true    ;; #(\n-  NONSTOP* )        nonstop=true ;;\n-esac\n-\n-CLASSPATH=$APP_HOME\/gradle\/wrapper\/gradle-wrapper.jar\n-\n-\n-# Determine the Java command to use to start the JVM.\n-if [ -n \"$JAVA_HOME\" ] ; then\n-    if [ -x \"$JAVA_HOME\/jre\/sh\/java\" ] ; then\n-        # IBM's JDK on AIX uses strange locations for the executables\n-        JAVACMD=$JAVA_HOME\/jre\/sh\/java\n-    else\n-        JAVACMD=$JAVA_HOME\/bin\/java\n-    fi\n-    if [ ! -x \"$JAVACMD\" ] ; then\n-        die \"ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME\n-\n-Please set the JAVA_HOME variable in your environment to match the\n-location of your Java installation.\"\n-    fi\n-else\n-    JAVACMD=java\n-    if ! command -v java >\/dev\/null 2>&1\n-    then\n-        die \"ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.\n-\n-Please set the JAVA_HOME variable in your environment to match the\n-location of your Java installation.\"\n-    fi\n-fi\n-\n-# Increase the maximum file descriptors if we can.\n-if ! \"$cygwin\" && ! \"$darwin\" && ! \"$nonstop\" ; then\n-    case $MAX_FD in #(\n-      max*)\n-        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.\n-        # shellcheck disable=SC2039,SC3045\n-        MAX_FD=$( ulimit -H -n ) ||\n-            warn \"Could not query maximum file descriptor limit\"\n-    esac\n-    case $MAX_FD in  #(\n-      '' | soft) :;; #(\n-      *)\n-        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.\n-        # shellcheck disable=SC2039,SC3045\n-        ulimit -n \"$MAX_FD\" ||\n-            warn \"Could not set maximum file descriptor limit to $MAX_FD\"\n-    esac\n-fi\n-\n-# Collect all arguments for the java command, stacking in reverse order:\n-#   * args from the command line\n-#   * the main class name\n-#   * -classpath\n-#   * -D...appname settings\n-#   * --module-path (only if needed)\n-#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.\n-\n-# For Cygwin or MSYS, switch paths to Windows format before running java\n-if \"$cygwin\" || \"$msys\" ; then\n-    APP_HOME=$( cygpath --path --mixed \"$APP_HOME\" )\n-    CLASSPATH=$( cygpath --path --mixed \"$CLASSPATH\" )\n-\n-    JAVACMD=$( cygpath --unix \"$JAVACMD\" )\n-\n-    # Now convert the arguments - kludge to limit ourselves to \/bin\/sh\n-    for arg do\n-        if\n-            case $arg in                                #(\n-              -*)   false ;;                            # don't mess with options #(\n-              \/?*)  t=${arg#\/} t=\/${t%%\/*}              # looks like a POSIX filepath\n-                    [ -e \"$t\" ] ;;                      #(\n-              *)    false ;;\n-            esac\n-        then\n-            arg=$( cygpath --path --ignore --mixed \"$arg\" )\n-        fi\n-        # Roll the args list around exactly as many times as the number of\n-        # args, so each arg winds up back in the position where it started, but\n-        # possibly modified.\n-        #\n-        # NB: a `for` loop captures its iteration list before it begins, so\n-        # changing the positional parameters here affects neither the number of\n-        # iterations, nor the values presented in `arg`.\n-        shift                   # remove old arg\n-        set -- \"$@\" \"$arg\"      # push replacement arg\n-    done\n-fi\n-\n-\n-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\n-DEFAULT_JVM_OPTS='\"-Xmx64m\" \"-Xms64m\"'\n-\n-# Collect all arguments for the java command:\n-#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,\n-#     and any embedded shellness will be escaped.\n-#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be\n-#     treated as '${Hostname}' itself on the command line.\n-\n-set -- \\\n-        \"-Dorg.gradle.appname=$APP_BASE_NAME\" \\\n-        -classpath \"$CLASSPATH\" \\\n-        org.gradle.wrapper.GradleWrapperMain \\\n-        \"$@\"\n-\n-# Stop when \"xargs\" is not available.\n-if ! command -v xargs >\/dev\/null 2>&1\n-then\n-    die \"xargs is not available\"\n-fi\n-\n-# Use \"xargs\" to parse quoted args.\n-#\n-# With -n1 it outputs one arg per line, with the quotes and backslashes removed.\n-#\n-# In Bash we could simply go:\n-#\n-#   readarray ARGS < <( xargs -n1 <<<\"$var\" ) &&\n-#   set -- \"${ARGS[@]}\" \"$@\"\n-#\n-# but POSIX shell has neither arrays nor command substitution, so instead we\n-# post-process each arg (as a line of input to sed) to backslash-escape any\n-# character that might be a shell metacharacter, then use eval to reverse\n-# that process (while maintaining the separation between arguments), and wrap\n-# the whole thing up as a single \"set\" statement.\n-#\n-# This will of course break if any of these variables contains a newline or\n-# an unmatched quote.\n-#\n-\n-eval \"set -- $(\n-        printf '%s\\n' \"$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS\" |\n-        xargs -n1 |\n-        sed ' s~[^-[:alnum:]+,.\/:=@_]~\\\\&~g; ' |\n-        tr '\\n' ' '\n-    )\" '\"$@\"'\n-\n-exec \"$JAVACMD\" \"$@\"\n","filename":"gradlew","additions":0,"deletions":252,"binary":false,"changes":252,"status":"deleted"},{"patch":"@@ -17,0 +17,2 @@\n+else ifeq ($(PLATFORM_OS), aix)\n+  TAR_SUPPORTS_TRANSFORM := false\n@@ -32,0 +34,2 @@\n+else ifeq ($(PLATFORM_OS), aix)\n+  BUNDLE_PLATFORM := aix-$(PLATFORM_CPU)\n@@ -58,0 +62,2 @@\n+else ifeq ($(PLATFORM_OS), aix)\n+  LIBCLANG_COPY_PATH := \"libclang.a\"\n@@ -73,1 +79,0 @@\n-\n","filename":"make\/Build.gmk","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-\n+UNAME_P := $(shell uname -p)\n@@ -73,0 +73,2 @@\n+\n+# CPU detection\n@@ -74,8 +76,2 @@\n-  DEVKIT_VS_CPU_VAR_NAME := x86_64\n-  PLATFORM_CPU := x64\n-else ifeq ($(UNAME_M),arm64)\n-  DEVKIT_VS_CPU_VAR_NAME := aarch64\n-  PLATFORM_CPU := aarch64\n-else ifeq ($(UNAME_M),aarch64)\n-  DEVKIT_VS_CPU_VAR_NAME := aarch64\n-  PLATFORM_CPU := aarch64\n+    DEVKIT_VS_CPU_VAR_NAME := x86_64\n+    PLATFORM_CPU := x64\n@@ -83,1 +79,16 @@\n-  $(error \"Unknown CPU: $(UNAME_M)\")\n+    ifeq ($(UNAME_M),arm64)\n+        DEVKIT_VS_CPU_VAR_NAME := aarch64\n+        PLATFORM_CPU := aarch64\n+    else\n+        ifeq ($(UNAME_M),aarch64)\n+            DEVKIT_VS_CPU_VAR_NAME := aarch64\n+            PLATFORM_CPU := aarch64\n+        else\n+            ifeq ($(UNAME_P),powerpc)\n+                DEVKIT_VS_CPU_VAR_NAME := ppc64\n+                PLATFORM_CPU := ppc64\n+            else\n+                $(error \"Unknown CPU: $(UNAME_M)\")\n+            endif\n+        endif\n+    endif\n@@ -86,0 +97,1 @@\n+# OS detection\n@@ -87,2 +99,2 @@\n-  PLATFORM_OS := windows\n-  FIXPATH := bash $(TOPDIR)\/make\/scripts\/fixpath.sh exec\n+    PLATFORM_OS := windows\n+    FIXPATH := bash $(TOPDIR)\/make\/scripts\/fixpath.sh exec\n@@ -90,8 +102,4 @@\n-  FIXPATH :=\n-\n-  UNAME_S := $(shell uname -s)\n-  ifeq ($(UNAME_S), Darwin)\n-    PLATFORM_OS := macosx\n-  else\n-    ifeq ($(UNAME_S), Linux)\n-      PLATFORM_OS := linux\n+    FIXPATH :=\n+    UNAME_S := $(shell uname -s)\n+    ifeq ($(UNAME_S),Darwin)\n+        PLATFORM_OS := macosx\n@@ -99,1 +107,9 @@\n-      $(error \"Unknown OS: $(UNAME_S)\")\n+        ifeq ($(UNAME_S),Linux)\n+            PLATFORM_OS := linux\n+        else\n+            ifeq ($(UNAME_S),AIX)\n+                PLATFORM_OS := aix\n+            else\n+                $(error \"Unknown OS: $(UNAME_S)\")\n+            endif\n+        endif\n@@ -101,1 +117,0 @@\n-  endif\n@@ -103,1 +118,0 @@\n-\n","filename":"make\/Common.gmk","additions":37,"deletions":23,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -89,0 +89,13 @@\n+    ifeq ($(PLATFORM_OS), aix)\n+      SHARED_LIB_SUFFIX := .a\n+      CC_NAME := xlc\n+      LINK_NAME := xlc\n+\n+      # xlc typically requires -q64 for 64-bit builds\n+      CFLAGS += -q64 -bexpall -qhalt=e -qalign=power -sysroot=$(SYSROOT) -m64\n+      LDFLAGS += -q64 -G -Wl,-bnoentry -Wl,-bexpall, -malign-power -m64\n+      CPPFLAGS += -D_AIX\n+\n+      # AIX-specific export file handling can be added here if needed\n+    endif\n+\n","filename":"make\/NativeCompilation.gmk","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-\n@@ -38,0 +37,1 @@\n+import java.util.StringTokenizer;\n@@ -39,0 +39,1 @@\n+import java.io.File;\n@@ -83,0 +84,1 @@\n+    static SymbolLookup SYMBOL_LOOKUP;\n@@ -85,2 +87,24 @@\n-        String libName = System.getProperty(\"os.name\").startsWith(\"Windows\") ? \"libclang\" : \"clang\";\n-        System.loadLibrary(libName);\n+        String osName = System.getProperty(\"os.name\");\n+        String libName = \"\";\n+        if (osName.startsWith(\"AIX\")) {\n+        List<String> pathsToCheck = new ArrayList<>(Arrays.asList(\n+                System.getProperty(\"java.library.path\").split(File.pathSeparator)\n+        ));\n+        \/\/ 2. Add alternate calculated paths\n+        String currentDir = System.getProperty(\"user.dir\"); \/\/ wherever JVM was launched\n+        pathsToCheck.add(currentDir + \"\/build\/jextract-jdk-test-image\/lib\");\n+        pathsToCheck.add(currentDir + \"\/..\/..\/..\/jextract-jdk-test-image\/lib\"); \/\/ in case running from subdir\n+        \/\/ 3. Try to find the library\n+        for (String path : pathsToCheck) {\n+            File f = new File(path, \"libclang.a\"); \/\/ AIX uses .a, Linux .so\n+            if (f.exists() && !f.isDirectory()) {\n+                libName = f.getAbsolutePath();\n+                break;\n+            }\n+        }\n+        SYMBOL_LOOKUP = SymbolLookup.libraryLookup(libName + \"(libclang.so.14)\", Arena.global());\n+        } else {\n+            libName = osName.startsWith(\"Windows\") ? \"libclang\" : \"clang\";\n+            System.loadLibrary(libName);\n+            SYMBOL_LOOKUP = SymbolLookup.loaderLookup().or(Linker.nativeLinker().defaultLookup());\n+        }\n@@ -88,4 +112,0 @@\n-\n-    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()\n-            .or(Linker.nativeLinker().defaultLookup());\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/Index_h.java","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -5,1 +5,0 @@\n-\n@@ -14,0 +13,11 @@\n+    if(${CMAKE_SYSTEM_NAME} MATCHES \"AIX\")\n+      add_library(${LIB_NAME} SHARED ${TEST_LIB})\n+      set_target_properties(${LIB_NAME} PROPERTIES\n+          PREFIX \"lib\"\n+          SUFFIX \".a\"\n+          COMPILE_FLAGS \"-q64  -qhalt=e\"\n+          LINK_FLAGS \"-q64 -G -Wl,-bnoentry,-bexpall\"\n+    \t)\n+    else()\n+      add_library(${LIB_NAME} SHARED ${TEST_LIB})\n+    endif()\n@@ -15,1 +25,0 @@\n-    add_library(${LIB_NAME} SHARED ${TEST_LIB})\n@@ -21,0 +30,3 @@\n+    # Link against libm to resolve sqrt() and other math symbols\n+    target_link_libraries(${LIB_NAME} m)\n+\n","filename":"test\/test-support\/CMakeLists.txt","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"}]}