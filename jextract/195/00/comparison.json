{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import org.openjdk.jextract.Type.Declared;\n@@ -172,1 +173,7 @@\n-                String name = scoped.name().isEmpty() ?\n+                String name;\n+                if (Utils.getAnonymousStructTypedef(parent) == scoped) {\n+                    \/\/ typedef struct { ... } Foo;\n+                    \/\/ steal the name from the parent typedef\n+                    name = JavaName.getOrThrow(parent);\n+                } else {\n+                    name = scoped.name().isEmpty() ?\n@@ -175,0 +182,1 @@\n+                }\n@@ -195,3 +203,10 @@\n-        \/\/ We may potentially generate a class for a typedef. Make sure\n-        \/\/ class name is unique in the current nesting context.\n-        String javaName = curScope.uniqueNestedClassName(typedef.name());\n+        String javaName;\n+        if (Utils.getAnonymousStructTypedef(typedef) != null) {\n+            \/\/ a typedef of a struct\/union without a name is special-cased,\n+            \/\/ so that the structs \"inherits\" the typedef name.\n+            javaName = typedef.name();\n+        } else {\n+            \/\/ We may potentially generate a class for a typedef. Make sure\n+            \/\/ class name is unique in the current nesting context.\n+            javaName = curScope.uniqueNestedClassName(typedef.name());\n+        }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/NameMangler.java","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -147,1 +147,2 @@\n-        if (structOrUnionDecl != null) {\n+        if (structOrUnionDecl != null && !structOrUnionDecl.name().isEmpty()) {\n+            \/\/ do not generate a typedef class if this is a typedef of an anonymous struct (see NameMangler)\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import org.openjdk.jextract.Declaration.Scoped;\n+import org.openjdk.jextract.Declaration.Typedef;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jextract.Type.Declared;\n@@ -183,0 +186,8 @@\n+    static Scoped getAnonymousStructTypedef(Declaration declaration) {\n+        return switch (declaration) {\n+            case Typedef typedef when typedef.type() instanceof Declared declared &&\n+                    isStructOrUnion(declared) && declared.tree().name().isEmpty() -> declared.tree();\n+            case null, default -> null;\n+        };\n+    }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Utils.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-        checkLayout(outer_td$0.layout(), UNDEFINED_STRUCT);\n","filename":"test\/jtreg\/generator\/nestedTypes\/TestNestedTypesUnsupported.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -118,2 +118,2 @@\n-            { \"Bar$0\", C_INT.withName(\"a\"),       int.class,           10 },\n-            { \"Bar$0\", C_INT.withName(\"b\"),       int.class,           10 },\n+            { \"Bar\", C_INT.withName(\"a\"),       int.class,           10 },\n+            { \"Bar\", C_INT.withName(\"b\"),       int.class,           10 },\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/TestClassGeneration.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}