{"files":[{"patch":"@@ -92,1 +92,4 @@\n-        d.members().forEach(m -> m.accept(this, null));\n+        d.members().forEach(m -> {\n+            m.accept(this, null);\n+            builder.append(\"\\n\");\n+        });\n@@ -96,1 +99,1 @@\n-            builder.append(\"};\\n\");\n+            builder.append(\"};\");\n@@ -127,1 +130,1 @@\n-        builder.append(\";\\n\");\n+        builder.append(\";\");\n@@ -135,1 +138,1 @@\n-        builder.append(\";\\n\");\n+        builder.append(\";\");\n@@ -147,1 +150,1 @@\n-            builder.append(\";\\n\");\n+            builder.append(\";\");\n@@ -158,1 +161,0 @@\n-            builder.append(\"\\n\");\n@@ -168,1 +170,1 @@\n-        builder.append(\";\\n\");\n+        builder.append(\";\");\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/CDeclarationPrinter.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,1 +29,10 @@\n-import org.openjdk.jextract.impl.Constants.Constant;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n@@ -158,1 +167,1 @@\n-             \\{CDeclarationPrinter.declaration(decl, \" \".repeat(align()*4) + \" * \")}\n+            \\{CDeclarationPrinter.declaration(decl, \" * \")}\n@@ -174,4 +183,17 @@\n-    final void emitConstantGetter(String mods, String getterName, boolean nullCheck, String symbolName, Constant constant, Declaration decl) {\n-        incrAlign();\n-        if (decl != null) {\n-            emitDocComment(decl);\n+    public String mangleName(String javaName, Class<?> type) {\n+        return javaName + nameSuffix(type);\n+    }\n+\n+    String nameSuffix(Class<?> type) {\n+        if (type.equals(MemorySegment.class)) {\n+            return \"$SEGMENT\";\n+        } else if (type.equals(MemoryLayout.class)) {\n+            return \"$LAYOUT\";\n+        } else if (type.equals(MethodHandle.class)) {\n+            return \"$MH\";\n+        } else if (type.equals(VarHandle.class)) {\n+            return \"$VH\";\n+        } else if (type.equals(FunctionDescriptor.class)) {\n+            return \"$DESC\";\n+        } else {\n+            return \"\";\n@@ -179,3 +201,14 @@\n-        appendLines(STR.\"\"\"\n-            \\{mods} \\{constant.type().getSimpleName()} \\{getterName}() {\n-                return \\{nullCheck ? STR.\"RuntimeHelper.requireNonNull(\\{constant}, \\\"\\{symbolName}\\\")\" : constant};\n+    }\n+\n+    String layoutString(int textBoxIndent, MemoryLayout l) {\n+        StringBuilder builder = new StringBuilder();\n+        layoutString(textBoxIndent, builder, l);\n+        return builder.toString();\n+    }\n+\n+    private void layoutString(int textBoxIndent, StringBuilder builder, MemoryLayout l) {\n+        String indent = indentString(textBoxIndent);\n+        if (l instanceof ValueLayout val) {\n+            builder.append(STR.\"\\{indent}\\{valueLayoutString(val)}\");\n+            if (l.byteAlignment() != l.byteSize()) {\n+                builder.append(STR.\"\\{indent}.withByteAlignment(\\{l.byteAlignment()})\");\n@@ -183,2 +216,80 @@\n-            \"\"\");\n-        decrAlign();\n+        } else if (l instanceof SequenceLayout seq) {\n+            builder.append(STR.\"\\{indent}MemoryLayout.sequenceLayout(\\{seq.elementCount()}, \");\n+            layoutString(textBoxIndent + 1, builder, seq.elementLayout());\n+            builder.append(STR.\"\\{indent})\");\n+        } else if (l instanceof GroupLayout group) {\n+            if (group instanceof StructLayout) {\n+                builder.append(STR.\"\\{indent}MemoryLayout.structLayout(\\n\");\n+            } else {\n+                builder.append(STR.\"\\{indent}MemoryLayout.unionLayout(\\n\");\n+            }\n+            String delim = \"\";\n+            for (MemoryLayout e : group.memberLayouts()) {\n+                builder.append(delim);\n+                layoutString(textBoxIndent + 1, builder, e);\n+                delim = \",\\n\";\n+            }\n+            builder.append(\"\\n\");\n+            builder.append(STR.\"\\{indent})\");\n+        } else {\n+            \/\/ padding (or unsupported)\n+            builder.append(STR.\"\\{indent}MemoryLayout.paddingLayout(\\{l.byteSize()})\");\n+        }\n+        if (l.name().isPresent()) {\n+            builder.append(STR.\".withName(\\\"\\{l.name().get()}\\\")\");\n+        }\n+    }\n+\n+    private static String indentString(int size) {\n+        return \" \".repeat(size * 4);\n+    }\n+\n+    private static String valueLayoutString(ValueLayout vl) {\n+        if (vl.carrier() == boolean.class) {\n+            return \"JAVA_BOOLEAN\";\n+        } else if (vl.carrier() == char.class) {\n+            return \"JAVA_CHAR\";\n+        } else if (vl.carrier() == byte.class) {\n+            return \"JAVA_BYTE\";\n+        } else if (vl.carrier() == short.class) {\n+            return \"JAVA_SHORT\";\n+        } else if (vl.carrier() == int.class) {\n+            return \"JAVA_INT\";\n+        } else if (vl.carrier() == float.class) {\n+            return \"JAVA_FLOAT\";\n+        } else if (vl.carrier() == long.class) {\n+            return \"JAVA_LONG\";\n+        } else if (vl.carrier() == double.class) {\n+            return \"JAVA_DOUBLE\";\n+        } else if (vl.carrier() == MemorySegment.class) {\n+            return \"RuntimeHelper.POINTER\";\n+        } else {\n+            throw new UnsupportedOperationException(\"Unsupported layout: \" + vl);\n+        }\n+    }\n+\n+    public String descriptorString(int textBoxIndent, FunctionDescriptor desc) {\n+        final boolean noArgs = desc.argumentLayouts().isEmpty();\n+        StringBuilder builder = new StringBuilder();\n+        if (desc.returnLayout().isPresent()) {\n+            builder.append(\"FunctionDescriptor.of(\");\n+            builder.append(\"\\n\");\n+            layoutString(textBoxIndent + 1, builder, desc.returnLayout().get());\n+            if (!noArgs) {\n+                builder.append(\",\");\n+            }\n+        } else {\n+            builder.append(\"FunctionDescriptor.ofVoid(\");\n+        }\n+        if (!noArgs) {\n+            builder.append(\"\\n\");\n+            String delim = \"\";\n+            for (MemoryLayout e : desc.argumentLayouts()) {\n+                builder.append(delim);\n+                layoutString(textBoxIndent + 1, builder, e);\n+                delim = \",\\n\";\n+            }\n+            builder.append(\"\\n\");\n+        }\n+        builder.append(STR.\"\\{indentString(textBoxIndent)})\");\n+        return builder.toString();\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ClassSourceBuilder.java","additions":122,"deletions":11,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -1,530 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.jextract.impl;\n-\n-import org.openjdk.jextract.Declaration;\n-import org.openjdk.jextract.Type;\n-\n-import javax.tools.JavaFileObject;\n-import java.lang.foreign.AddressLayout;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.StructLayout;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.StringJoiner;\n-import java.util.function.Function;\n-\n-public class Constants {\n-\n-    private final Map<Object, Constant> cache = new HashMap<>();\n-\n-    private final List<SourceFileBuilder> constantBuilders = new ArrayList<>();\n-    private Builder currentBuilder;\n-\n-    private final String packageName;\n-\n-    public Constants(String packageName) {\n-        this.packageName = packageName;\n-        currentBuilder = startNewBuilder(packageName, 0);\n-        \/\/ prime the cache with basic primitive\/pointer (immediate) layouts\n-        for (Type.Primitive.Kind kind : Type.Primitive.Kind.values()) {\n-            kind.layout().ifPresent(layout -> {\n-                if (layout instanceof ValueLayout valueLayout) {\n-                    cache.put(valueLayout, ImmediateConstant.ofPrimitiveLayout(valueLayout));\n-                }\n-            });\n-        }\n-        AddressLayout pointerLayout = ValueLayout.ADDRESS.withTargetLayout(\n-                MemoryLayout.sequenceLayout(Long.MAX_VALUE, ValueLayout.JAVA_BYTE));\n-        cache.put(pointerLayout, ImmediateConstant.ofPrimitiveLayout(pointerLayout));\n-    }\n-\n-    static final int CONSTANTS_PER_CLASS = Integer.getInteger(\"jextract.constants.per.class\", 5);\n-\n-    private Builder startNewBuilder(String packageName, int id) {\n-        String builderClassName = \"constants$\" + id;\n-        SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName, builderClassName);\n-        constantBuilders.add(sfb);\n-        Builder builder = new Builder(sfb, sfb.className());\n-        builder.classBegin();\n-        builder.emitPrivateDefaultConstructor();\n-        return builder;\n-    }\n-\n-    private Builder builder() {\n-        if (currentBuilder.constantIndex > CONSTANTS_PER_CLASS) {\n-            currentBuilder.classEnd();\n-            currentBuilder = startNewBuilder(packageName, constantBuilders.size());\n-        }\n-        return currentBuilder;\n-    }\n-\n-    static sealed abstract class Constant permits Builder.NamedConstant, ImmediateConstant {\n-\n-        final Class<?> type;\n-\n-        public Constant(Class<?> type) {\n-            this.type = type;\n-        }\n-\n-        Class<?> type() {\n-            return type;\n-        }\n-\n-        String getterName(String javaName) {\n-            return javaName + nameSuffix();\n-        }\n-\n-        Constant emitGetter(ClassSourceBuilder builder, String mods, String javaName) {\n-            return emitGetter(builder, mods, c -> c.getterName(javaName));\n-        }\n-\n-        Constant emitGetter(ClassSourceBuilder builder, String mods, String javaName, String symbolName) {\n-            return emitGetter(builder, mods, symbolName, c -> c.getterName(javaName));\n-        }\n-\n-        Constant emitGetterWithComment(ClassSourceBuilder builder, String mods, String javaName, String symbolName,\n-                                       Declaration decl) {\n-            return emitGetterWithComment(builder, mods, symbolName, c -> c.getterName(javaName), decl);\n-        }\n-\n-        Constant emitGetter(ClassSourceBuilder builder, String mods, Function<Constant, String> getterNameFunc) {\n-            builder.emitConstantGetter(mods, getterNameFunc.apply(this), false, null, this, null);\n-            return this;\n-        }\n-\n-        Constant emitGetterWithComment(ClassSourceBuilder builder, String mods, Function<Constant, String> getterNameFunc,\n-                                       Declaration decl) {\n-            builder.emitConstantGetter(mods, getterNameFunc.apply(this), false, null, this, decl);\n-            return this;\n-        }\n-\n-        Constant emitGetter(ClassSourceBuilder builder, String mods, String symbolName, Function<Constant, String> getterNameFunc) {\n-            builder.emitConstantGetter(mods, getterNameFunc.apply(this), true, symbolName, this, null);\n-            return this;\n-        }\n-\n-        Constant emitGetterWithComment(ClassSourceBuilder builder, String mods, String symbolName,\n-                                       Function<Constant, String> getterNameFunc, Declaration decl) {\n-            builder.emitConstantGetter(mods, getterNameFunc.apply(this), true, symbolName, this, decl);\n-            return this;\n-        }\n-\n-        String nameSuffix() {\n-            if (type.equals(MemorySegment.class)) {\n-                return \"$SEGMENT\";\n-            } else if (type.equals(MemoryLayout.class)) {\n-                return \"$LAYOUT\";\n-            } else if (type.equals(MethodHandle.class)) {\n-                return \"$MH\";\n-            } else if (type.equals(VarHandle.class)) {\n-                return \"$VH\";\n-            } else if (type.equals(FunctionDescriptor.class)) {\n-                return \"$DESC\";\n-            } else {\n-                return \"\";\n-            }\n-        }\n-\n-        abstract String accessExpression();\n-\n-        @Override\n-        public String toString() {\n-            return accessExpression();\n-        }\n-    }\n-\n-    final static class ImmediateConstant extends Constant {\n-        final String value;\n-\n-        ImmediateConstant(Class<?> type, String value) {\n-            super(type);\n-            this.value = value;\n-        }\n-\n-        @Override\n-        String accessExpression() {\n-            return value;\n-        }\n-\n-        static ImmediateConstant ofPrimitiveLayout(ValueLayout vl) {\n-            final String layoutStr;\n-            if (vl.carrier() == boolean.class) {\n-                layoutStr = \"JAVA_BOOLEAN\";\n-            } else if (vl.carrier() == char.class) {\n-                layoutStr = \"JAVA_CHAR\";\n-            } else if (vl.carrier() == byte.class) {\n-                layoutStr = \"JAVA_BYTE\";\n-            } else if (vl.carrier() == short.class) {\n-                layoutStr = \"JAVA_SHORT\";\n-            } else if (vl.carrier() == int.class) {\n-                layoutStr = \"JAVA_INT\";\n-            } else if (vl.carrier() == float.class) {\n-                layoutStr = \"JAVA_FLOAT\";\n-            } else if (vl.carrier() == long.class) {\n-                layoutStr = \"JAVA_LONG\";\n-            } else if (vl.carrier() == double.class) {\n-                layoutStr = \"JAVA_DOUBLE\";\n-            } else if (vl.carrier() == MemorySegment.class) {\n-                layoutStr = \"RuntimeHelper.POINTER\";\n-            } else {\n-                throw new UnsupportedOperationException(\"Unsupported layout: \" + vl);\n-            }\n-            return new ImmediateConstant(MemoryLayout.class, layoutStr);\n-        }\n-\n-        static Constant ofLiteral(Class<?> type, Object value) {\n-            StringBuilder buf = new StringBuilder();\n-            if (type == float.class) {\n-                float f = ((Number)value).floatValue();\n-                if (Float.isFinite(f)) {\n-                    buf.append(value);\n-                    buf.append(\"f\");\n-                } else {\n-                    buf.append(\"Float.valueOf(\\\"\");\n-                    buf.append(value);\n-                    buf.append(\"\\\")\");\n-                }\n-            } else if (type == long.class) {\n-                buf.append(value.toString());\n-                buf.append(\"L\");\n-            } else if (type == double.class) {\n-                double d = ((Number)value).doubleValue();\n-                if (Double.isFinite(d)) {\n-                    buf.append(value);\n-                    buf.append(\"d\");\n-                } else {\n-                    buf.append(\"Double.valueOf(\\\"\");\n-                    buf.append(value);\n-                    buf.append(\"\\\")\");\n-                }\n-            } else if (type == boolean.class) {\n-                boolean booleanValue = ((Number)value).byteValue() != 0;\n-                buf.append(booleanValue);\n-            } else {\n-                buf.append(\"(\" + type.getName() + \")\");\n-                buf.append(value + \"L\");\n-            }\n-            return new ImmediateConstant(type, buf.toString());\n-        }\n-    }\n-\n-    public List<JavaFileObject> toFiles() {\n-        currentBuilder.classEnd();\n-        return new ArrayList<>(constantBuilders.stream()\n-                .map(SourceFileBuilder::toFile).toList());\n-    }\n-\n-    class Builder extends ClassSourceBuilder {\n-\n-        private static final String MEMBER_MODS = \"static final\";\n-\n-        Builder(SourceFileBuilder builder, String className) {\n-            super(builder, \"final\", Kind.CLASS, className, null, null);\n-        }\n-\n-        int constantIndex = 0;\n-\n-        final class NamedConstant extends Constant {\n-            final String constantName;\n-\n-            NamedConstant(Class<?> type) {\n-                super(type);\n-                this.constantName = newConstantName();\n-            }\n-\n-            @Override\n-            String accessExpression() {\n-                return className() + \".\" + constantName;\n-            }\n-        }\n-\n-        private Constant emitDowncallMethodHandleField(String nativeName, FunctionDescriptor descriptor, boolean isVarargs, boolean virtual) {\n-            Constant functionDesc = addFunctionDesc(descriptor);\n-            incrAlign();\n-            NamedConstant mhConst = new NamedConstant(MethodHandle.class);\n-            indent();\n-            append(MEMBER_MODS + \" MethodHandle \");\n-            append(mhConst.constantName + \" = RuntimeHelper.\");\n-            if (isVarargs) {\n-                append(\"downcallHandleVariadic\");\n-            } else {\n-                append(\"downcallHandle\");\n-            }\n-            append(\"(\\n\");\n-            incrAlign();\n-            indent();\n-            if (!virtual) {\n-                append(\"\\\"\" + nativeName + \"\\\"\");\n-                append(\",\\n\");\n-                indent();\n-            }\n-            append(functionDesc.accessExpression());\n-            append(\"\\n\");\n-            decrAlign();\n-            indent();\n-            append(\");\\n\");\n-            decrAlign();\n-            return mhConst;\n-        }\n-\n-        private Constant emitUpcallMethodHandleField(String className, String methodName, FunctionDescriptor descriptor) {\n-            Constant functionDesc = addFunctionDesc(descriptor);\n-            NamedConstant mhConst = new NamedConstant(MethodHandle.class);\n-            appendIndentedLines(STR.\"\"\"\n-                static final MethodHandle \\{mhConst.constantName} = RuntimeHelper.upcallHandle(\\{className}.class, \"\\{methodName}\", \\{functionDesc});\n-                \"\"\");\n-            return mhConst;\n-        }\n-\n-        private Constant emitVarHandle(ValueLayout valueLayout) {\n-            Constant layoutConstant = addLayout(valueLayout);\n-            NamedConstant vhConst = new NamedConstant(VarHandle.class);\n-            appendIndentedLines(STR.\"\"\"\n-                static final VarHandle \\{vhConst.constantName} = \\{layoutConstant}.varHandle();\n-                \"\"\");\n-            return vhConst;\n-        }\n-\n-        private static String pathElementStr(String nativeName, List<String> prefixElementNames) {\n-            StringJoiner joiner = new StringJoiner(\", \");\n-            for (String prefixElementName : prefixElementNames) {\n-                joiner.add(STR.\"MemoryLayout.PathElement.groupElement(\\\"\\{prefixElementName}\\\")\");\n-            }\n-            joiner.add(STR.\"MemoryLayout.PathElement.groupElement(\\\"\\{nativeName}\\\")\");\n-            return joiner.toString();\n-        }\n-\n-        private Constant emitFieldVarHandle(String nativeName, GroupLayout parentLayout, List<String> prefixElementNames) {\n-            Constant layoutConstant = addLayout(parentLayout);\n-            NamedConstant vhConst = new NamedConstant(VarHandle.class);\n-            appendIndentedLines(STR.\"\"\"\n-                static final VarHandle \\{vhConst.constantName} = \\{layoutConstant}.varHandle(\\{pathElementStr(nativeName, prefixElementNames)});\n-                \"\"\");\n-            return vhConst;\n-        }\n-\n-        private Constant emitLayoutField(MemoryLayout layout) {\n-            NamedConstant layoutConst = new NamedConstant(MemoryLayout.class);\n-            incrAlign();\n-            indent();\n-            String layoutClassName = Utils.layoutDeclarationType(layout).getSimpleName();\n-            append(STR.\"static final \\{layoutClassName} \\{layoutConst.constantName} = \");\n-            emitLayoutString(layout);\n-            append(\";\\n\");\n-            decrAlign();\n-            return layoutConst;\n-        }\n-\n-        private void emitLayoutString(MemoryLayout l) {\n-            if (l instanceof ValueLayout val) {\n-                append(ImmediateConstant.ofPrimitiveLayout(val).accessExpression());\n-                if (l.byteAlignment() != l.byteSize()) {\n-                    append(STR.\".withByteAlignment(\\{l.byteAlignment()})\");\n-                }\n-            } else if (l instanceof SequenceLayout seq) {\n-                append(STR.\"MemoryLayout.sequenceLayout(\\{seq.elementCount()}, \");\n-                emitLayoutString(seq.elementLayout());\n-                append(\")\");\n-            } else if (l instanceof GroupLayout group) {\n-                if (group instanceof StructLayout) {\n-                    append(\"MemoryLayout.structLayout(\\n\");\n-                } else {\n-                    append(\"MemoryLayout.unionLayout(\\n\");\n-                }\n-                incrAlign();\n-                String delim = \"\";\n-                for (MemoryLayout e : group.memberLayouts()) {\n-                    append(delim);\n-                    indent();\n-                    emitLayoutString(e);\n-                    delim = \",\\n\";\n-                }\n-                append(\"\\n\");\n-                decrAlign();\n-                indent();\n-                append(\")\");\n-            } else {\n-                \/\/ padding (or unsupported)\n-                append(STR.\"MemoryLayout.paddingLayout(\\{l.byteSize()})\");\n-            }\n-            if (l.name().isPresent()) {\n-                append(STR.\".withName(\\\"\\{l.name().get()}\\\")\");\n-            }\n-        }\n-\n-        private Constant emitFunctionDescField(FunctionDescriptor desc) {\n-            incrAlign();\n-            indent();\n-            final boolean noArgs = desc.argumentLayouts().isEmpty();\n-            NamedConstant descConstant = new NamedConstant(FunctionDescriptor.class);\n-            append(STR.\"static final FunctionDescriptor \\{descConstant.constantName} =\");\n-            if (desc.returnLayout().isPresent()) {\n-                append(\"FunctionDescriptor.of(\");\n-                emitLayoutString(desc.returnLayout().get());\n-                if (!noArgs) {\n-                    append(\",\");\n-                }\n-            } else {\n-                append(\"FunctionDescriptor.ofVoid(\");\n-            }\n-            if (!noArgs) {\n-                append(\"\\n\");\n-                incrAlign();\n-                String delim = \"\";\n-                for (MemoryLayout e : desc.argumentLayouts()) {\n-                    append(delim);\n-                    indent();\n-                    emitLayoutString(e);\n-                    delim = \",\\n\";\n-                }\n-                append(\"\\n\");\n-                decrAlign();\n-                indent();\n-            }\n-            append(\");\\n\");\n-            decrAlign();\n-            return descConstant;\n-        }\n-\n-        private Constant emitConstantString(Object value) {\n-            NamedConstant segConstant = new NamedConstant(MemorySegment.class);\n-            appendIndentedLines(STR.\"\"\"\n-                static final MemorySegment \\{segConstant.constantName} =\n-                        RuntimeHelper.CONSTANT_ALLOCATOR.allocateFrom(\"\\{Utils.quote(Objects.toString(value))}\");\n-                \"\"\");\n-            return segConstant;\n-        }\n-\n-        private Constant emitConstantAddress(Object value) {\n-            NamedConstant segConstant = new NamedConstant(MemorySegment.class);\n-            appendIndentedLines(STR.\"\"\"\n-                static final MemorySegment \\{segConstant.constantName} =\n-                        MemorySegment.ofAddress(\\{((Number)value).longValue()}L);\n-                \"\"\");\n-            return segConstant;\n-        }\n-\n-        private Constant emitSegmentField(String nativeName, MemoryLayout layout) {\n-            Constant layoutConstant = addLayout(layout);\n-            NamedConstant segConstant = new NamedConstant(MemorySegment.class);\n-            appendIndentedLines(STR.\"\"\"\n-                static final MemorySegment \\{segConstant.constantName} =\n-                        RuntimeHelper.lookupGlobalVariable(\"\\{nativeName}\", \\{layoutConstant});\n-                \"\"\");\n-            return segConstant;\n-        }\n-\n-        String newConstantName() {\n-            return \"const$\" + constantIndex++;\n-        }\n-    }\n-\n-    \/\/ public API\n-\n-    public Constant addLayout(MemoryLayout layout) {\n-        Constant constant = cache.get(layout);\n-        if (constant == null) {\n-            constant = builder().emitLayoutField(layout);\n-            cache.put(layout, constant);\n-        }\n-        return constant;\n-    }\n-\n-    public Constant addFieldVarHandle(String nativeName, GroupLayout parentLayout, List<String> prefixElementNames) {\n-        return builder().emitFieldVarHandle(nativeName, parentLayout, prefixElementNames);\n-    }\n-\n-    public Constant addGlobalVarHandle(ValueLayout valueLayout) {\n-        record VarHandleKey(ValueLayout valueLayout) { }\n-        VarHandleKey key = new VarHandleKey(valueLayout.withoutName());\n-        Constant constant = cache.get(key);\n-        if (constant == null) {\n-            constant = builder().emitVarHandle(valueLayout);\n-            cache.put(key, constant);\n-        }\n-        return constant;\n-    }\n-\n-    public Constant addDowncallMethodHandle(String nativeName, FunctionDescriptor descriptor, boolean isVarargs) {\n-        return builder().emitDowncallMethodHandleField(nativeName, descriptor, isVarargs, false);\n-    }\n-\n-    public Constant addVirtualDowncallMethodHandle(FunctionDescriptor descriptor) {\n-        record DowncallKey(FunctionDescriptor desc) { }\n-        DowncallKey downcallKey = new DowncallKey(descriptor);\n-        Constant constant = cache.get(downcallKey);\n-        if (constant == null) {\n-            constant = builder().emitDowncallMethodHandleField(null, descriptor, false, true);\n-            cache.put(downcallKey, constant);\n-        }\n-        return constant;\n-    }\n-\n-    public Constant addUpcallMethodHandle(String className, String name, FunctionDescriptor descriptor) {\n-        return builder().emitUpcallMethodHandleField(className, name, descriptor);\n-    }\n-\n-    public Constant addSegment(String nativeName, MemoryLayout layout) {\n-        return builder().emitSegmentField(nativeName, layout);\n-    }\n-\n-    public Constant addFunctionDesc(FunctionDescriptor desc) {\n-        Constant constant = cache.get(desc);\n-        if (constant == null) {\n-            constant = builder().emitFunctionDescField(desc);\n-            cache.put(desc, constant);\n-        }\n-        return constant;\n-    }\n-\n-    public Constant addConstantDesc(Class<?> type, Object value) {\n-        record ConstantKey(Class<?> type, Object value) { }\n-        var key = new ConstantKey(type, value);\n-        Constant constant = cache.get(key);\n-        if (constant == null) {\n-            if (value instanceof String) {\n-                constant = builder().emitConstantString(value);\n-            } else if (type == MemorySegment.class) {\n-                constant = builder().emitConstantAddress(value);\n-            } else {\n-                constant = ImmediateConstant.ofLiteral(type, value);\n-            }\n-            cache.put(key, constant);\n-        }\n-        return constant;\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Constants.java","additions":0,"deletions":530,"binary":false,"changes":530,"status":"deleted"},{"patch":"@@ -30,1 +30,0 @@\n-import org.openjdk.jextract.impl.Constants.Constant;\n@@ -41,0 +40,2 @@\n+    private static final String MEMBER_MODS = \"static\";\n+\n@@ -45,1 +46,0 @@\n-    private final Constants constants;\n@@ -47,1 +47,1 @@\n-    private FunctionalInterfaceBuilder(SourceFileBuilder builder, Constants constants, String className, ClassSourceBuilder enclosing,\n+    private FunctionalInterfaceBuilder(SourceFileBuilder builder, String className, ClassSourceBuilder enclosing,\n@@ -54,1 +54,0 @@\n-        this.constants = constants;\n@@ -57,3 +56,3 @@\n-    public static void generate(SourceFileBuilder builder, Constants constants, String className, ClassSourceBuilder enclosing,\n-                               Type.Function funcType, FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n-        FunctionalInterfaceBuilder fib = new FunctionalInterfaceBuilder(builder, constants, className, enclosing,\n+    public static void generate(SourceFileBuilder builder, String className, ClassSourceBuilder enclosing,\n+                                Type.Function funcType, FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n+        FunctionalInterfaceBuilder fib = new FunctionalInterfaceBuilder(builder, className, enclosing,\n@@ -63,0 +62,1 @@\n+        fib.emitDescriptorDecl();\n@@ -76,2 +76,0 @@\n-        Constant functionDesc = constants.addFunctionDesc(fiDesc);\n-        Constant upcallHandle = constants.addUpcallMethodHandle(fullName(), \"apply\", fiDesc);\n@@ -79,0 +77,2 @@\n+            MethodHandle UP$MH = RuntimeHelper.upcallHandle(\\{className()}.class, \\\"apply\\\", $DESC);\n+\n@@ -80,1 +80,1 @@\n-                return RuntimeHelper.upcallStub(\\{upcallHandle}, fi, \\{functionDesc}, scope);\n+                return RuntimeHelper.upcallStub(UP$MH, fi, $DESC, scope);\n@@ -86,1 +86,0 @@\n-        Constant mhConstant = constants.addVirtualDowncallMethodHandle(fiDesc);\n@@ -88,0 +87,2 @@\n+            MethodHandle DOWN$MH = RuntimeHelper.downcallHandle($DESC);\n+\n@@ -92,1 +93,1 @@\n-                        \\{retExpr()} \\{mhConstant}.invokeExact(symbol\\{otherArgExprs()});\n+                        \\{retExpr()} DOWN$MH.invokeExact(symbol\\{otherArgExprs()});\n@@ -159,0 +160,6 @@\n+\n+    private void emitDescriptorDecl() {\n+        appendIndentedLines(STR.\"\"\"\n+            FunctionDescriptor $DESC = \\{descriptorString(0, fiDesc)};\n+            \"\"\");\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -33,0 +34,2 @@\n+import java.lang.invoke.MethodHandle;\n+\n@@ -36,2 +39,0 @@\n-import org.openjdk.jextract.impl.Constants.Constant;\n-\n@@ -39,0 +40,1 @@\n+import java.lang.invoke.VarHandle;\n@@ -41,0 +43,1 @@\n+import java.util.Objects;\n@@ -53,3 +56,1 @@\n-    private final Constants constants;\n-\n-    HeaderFileBuilder(SourceFileBuilder builder, Constants constants, String className, String superName) {\n+    HeaderFileBuilder(SourceFileBuilder builder, String className, String superName) {\n@@ -57,1 +58,0 @@\n-        this.constants = constants;\n@@ -63,0 +63,1 @@\n+        String layoutVar = emitVarLayout(layout, javaName);\n@@ -65,2 +66,1 @@\n-                constants.addSegment(nativeName, layout)\n-                        .emitGetterWithComment(this, MEMBER_MODS, javaName, nativeName, varTree);\n+                emitGlobalSegment(layout, javaName, nativeName, varTree);\n@@ -69,6 +69,2 @@\n-            constants.addLayout(valueLayout)\n-                    .emitGetter(this, MEMBER_MODS, javaName);\n-            Constant vhConstant = constants.addGlobalVarHandle(valueLayout)\n-                    .emitGetter(this, MEMBER_MODS, javaName);\n-            Constant segmentConstant = constants.addSegment(nativeName, valueLayout)\n-                    .emitGetter(this, MEMBER_MODS, javaName, nativeName);\n+            String vhConstant = emitGlobalVarHandle(javaName, layoutVar);\n+            String segmentConstant = emitGlobalSegment(layout, javaName, nativeName, null);\n@@ -88,4 +84,0 @@\n-\n-        Constant mhConstant = constants.addDowncallMethodHandle(nativeName, descriptor, isVarargs)\n-                .emitGetter(this, MEMBER_MODS, javaName, nativeName);\n-        MethodType downcallType = descriptor.toMethodType();\n@@ -94,1 +86,1 @@\n-        emitFunctionWrapper(mhConstant, javaName, downcallType, needsAllocator, isVarargs, parameterNames, funcTree);\n+        emitFunctionWrapper(javaName, nativeName, descriptor, needsAllocator, isVarargs, parameterNames, funcTree);\n@@ -99,2 +91,1 @@\n-        constants.addConstantDesc(javaType, value)\n-                    .emitGetterWithComment(this, MEMBER_MODS, c -> javaName, constantTree);\n+        emitConstant(javaType, javaName, value, constantTree);\n@@ -104,0 +95,1 @@\n+\n@@ -143,1 +135,1 @@\n-    private void emitFunctionWrapper(Constant mhConstant, String javaName, MethodType declType, boolean needsAllocator,\n+    private void emitFunctionWrapper(String javaName, String nativeName, FunctionDescriptor descriptor, boolean needsAllocator,\n@@ -145,0 +137,1 @@\n+        MethodType declType = descriptor.toMethodType();\n@@ -155,0 +148,4 @@\n+        String getterName = mangleName(javaName, MethodHandle.class);\n+        String factoryName = isVarArg ?\n+                \"downcallHandleVariadic\" :\n+                \"downcallHandle\";\n@@ -158,0 +155,9 @@\n+            \\{MEMBER_MODS} MethodHandle \\{getterName}() {\n+                class Holder {\n+                    static final FunctionDescriptor DESC = \\{descriptorString(2, descriptor)};\n+\n+                    static final MethodHandle MH = RuntimeHelper.\\{factoryName}(\\\"\\{nativeName}\\\", DESC);\n+                }\n+                return RuntimeHelper.requireNonNull(Holder.MH, \\\"\\{javaName}\\\");\n+            }\n+\n@@ -159,1 +165,1 @@\n-                var mh$ = \\{mhConstant.getterName(javaName)}();\n+                var mh$ = \\{getterName}();\n@@ -185,10 +191,1 @@\n-            String declType = Utils.layoutDeclarationType(primType.kind().layout().orElseThrow()).getSimpleName();\n-            Constant layoutConstant = constants.addLayout(kind.layout().get());\n-            incrAlign();\n-            if (typedefTree != null) {\n-                emitDocComment(typedefTree);\n-            }\n-            appendLines(STR.\"\"\"\n-                public static final \\{declType} \\{name} = \\{layoutConstant};\n-                \"\"\");\n-            decrAlign();\n+            emitPrimitiveTypedefLayout(name, kind.layout().get(), typedefTree);\n@@ -203,9 +200,1 @@\n-        Constant layoutConstant = constants.addLayout(TypeImpl.PointerImpl.POINTER_LAYOUT);\n-        incrAlign();\n-        if (typedefTree != null) {\n-            emitDocComment(typedefTree);\n-        }\n-        appendLines(STR.\"\"\"\n-            public static final AddressLayout \\{name} = \\{layoutConstant};\n-            \"\"\");\n-        decrAlign();\n+        emitPrimitiveTypedefLayout(name, TypeImpl.PointerImpl.POINTER_LAYOUT, typedefTree);\n@@ -221,1 +210,1 @@\n-    private void emitGlobalGetter(Constant segmentConstant, Constant vhConstant, String javaName, String nativeName,\n+    private void emitGlobalGetter(String segmentConstant, String vhConstant, String javaName, String nativeName,\n@@ -233,1 +222,1 @@\n-    private void emitGlobalSetter(Constant segmentConstant, Constant vhConstant, String javaName, String nativeName,\n+    private void emitGlobalSetter(String segmentConstant, String vhConstant, String javaName, String nativeName,\n@@ -244,0 +233,106 @@\n+\n+    public String emitGlobalSegment(MemoryLayout layout, String javaName, String nativeName, Declaration declaration) {\n+        String mangledName = mangleName(javaName, MemorySegment.class);\n+        appendIndentedLines(STR.\"\"\"\n+            private static final MemorySegment \\{mangledName} = RuntimeHelper.lookupGlobalVariable(\\\"\\{nativeName}\\\", \\{layoutString(0, layout)});\n+\n+            \"\"\");\n+        if (declaration != null) {\n+            emitDocComment(declaration);\n+        }\n+        appendIndentedLines(STR.\"\"\"\n+            \\{MEMBER_MODS} MemorySegment \\{mangledName}() {\n+                return RuntimeHelper.requireNonNull(\\{mangledName}, \\\"\\{javaName}\\\");\n+            }\n+            \"\"\");\n+        return mangledName;\n+    }\n+\n+    private String emitVarLayout(MemoryLayout layout, String javaName) {\n+        String mangledName = mangleName(javaName, MemoryLayout.class);\n+        appendIndentedLines(STR.\"\"\"\n+            private static final MemoryLayout \\{mangledName} = \\{layoutString(0, layout)};\n+\n+            \\{MEMBER_MODS} MemoryLayout \\{mangledName}() {\n+                return \\{mangledName};\n+            }\n+            \"\"\");\n+        return mangledName;\n+    }\n+\n+    private String emitGlobalVarHandle(String javaName, String layoutVar) {\n+        String mangledName = mangleName(javaName, VarHandle.class);\n+        appendIndentedLines(STR.\"\"\"\n+            private static final VarHandle \\{mangledName} = \\{layoutVar}.varHandle();\n+\n+            \\{MEMBER_MODS} VarHandle \\{mangledName}() {\n+                return \\{mangledName};\n+            }\n+            \"\"\");\n+        return mangledName;\n+    }\n+\n+    private void emitConstant(Class<?> javaType, String constantName, Object value, Declaration declaration) {\n+        appendIndentedLines(STR.\"\"\"\n+            private static final \\{javaType.getSimpleName()} \\{constantName} = \\{constantValue(javaType, value)};\n+\n+            \"\"\");\n+        if (declaration != null) {\n+            emitDocComment(declaration);\n+        }\n+        appendIndentedLines(STR.\"\"\"\n+            \\{MEMBER_MODS} \\{javaType.getSimpleName()} \\{constantName}() {\n+                return \\{constantName};\n+            }\n+            \"\"\");\n+    }\n+\n+    private String constantValue(Class<?> type, Object value) {\n+        if (value instanceof String) {\n+            return STR.\"RuntimeHelper.CONSTANT_ALLOCATOR.allocateFrom(\\\"\\{Utils.quote(Objects.toString(value))}\\\");\";\n+        } else if (type == MemorySegment.class) {\n+            return STR.\"MemorySegment.ofAddress(\\{((Number)value).longValue()}L);\";\n+        } else {\n+            StringBuilder buf = new StringBuilder();\n+            if (type == float.class) {\n+                float f = ((Number)value).floatValue();\n+                if (Float.isFinite(f)) {\n+                    buf.append(value);\n+                    buf.append(\"f\");\n+                } else {\n+                    buf.append(\"Float.valueOf(\\\"\");\n+                    buf.append(value);\n+                    buf.append(\"\\\")\");\n+                }\n+            } else if (type == long.class) {\n+                buf.append(value.toString());\n+                buf.append(\"L\");\n+            } else if (type == double.class) {\n+                double d = ((Number)value).doubleValue();\n+                if (Double.isFinite(d)) {\n+                    buf.append(value);\n+                    buf.append(\"d\");\n+                } else {\n+                    buf.append(\"Double.valueOf(\\\"\");\n+                    buf.append(value);\n+                    buf.append(\"\\\")\");\n+                }\n+            } else if (type == boolean.class) {\n+                boolean booleanValue = ((Number)value).byteValue() != 0;\n+                buf.append(booleanValue);\n+            } else {\n+                buf.append(\"(\" + type.getName() + \")\");\n+                buf.append(value + \"L\");\n+            }\n+            return buf.toString();\n+        }\n+    }\n+\n+    private void emitPrimitiveTypedefLayout(String javaName, MemoryLayout layout, Declaration declaration) {\n+        if (declaration != null) {\n+            emitDocComment(declaration);\n+        }\n+        appendIndentedLines(STR.\"\"\"\n+        public static final \\{Utils.layoutDeclarationType(layout).getSimpleName()} \\{javaName} = \\{layoutString(0, layout)};\n+        \"\"\");\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":139,"deletions":44,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import org.openjdk.jextract.impl.Constants.Constant;\n@@ -36,0 +35,1 @@\n+import java.lang.invoke.VarHandle;\n@@ -42,0 +42,1 @@\n+import java.util.StringJoiner;\n@@ -54,1 +55,0 @@\n-    private final Constants constants;\n@@ -56,1 +56,1 @@\n-    StructBuilder(SourceFileBuilder builder, Constants constants, String modifiers, String className,\n+    StructBuilder(SourceFileBuilder builder, String modifiers, String className,\n@@ -63,1 +63,0 @@\n-        this.constants = constants;\n@@ -91,2 +90,1 @@\n-            Constant layoutConstant = constants.addLayout(((Type.Declared) structType).tree().layout().orElseThrow());\n-            layoutConstant.emitGetter(this, MEMBER_MODS, Constant::nameSuffix);\n+            emitLayoutDecl();\n@@ -126,1 +124,1 @@\n-            StructBuilder builder = new StructBuilder(sourceFileBuilder(), constants, \"public static final\", name, this, tree, layout);\n+            StructBuilder builder = new StructBuilder(sourceFileBuilder(), \"public static final\", name, this, tree, layout);\n@@ -137,1 +135,1 @@\n-        FunctionalInterfaceBuilder.generate(sourceFileBuilder(), constants, javaName, this, funcType, descriptor, parameterNames);\n+        FunctionalInterfaceBuilder.generate(sourceFileBuilder(), javaName, this, funcType, descriptor, parameterNames);\n@@ -157,2 +155,1 @@\n-            Constant vhConstant = constants.addFieldVarHandle(nativeName, structLayout, prefixNamesList())\n-                    .emitGetter(this, MEMBER_MODS, javaName);\n+            String constantField = emitFieldVarHandle(javaName, nativeName, prefixNamesList());\n@@ -160,1 +157,1 @@\n-            emitFieldGetter(vhConstant, javaName, valueLayout.carrier());\n+            emitFieldGetter(constantField, javaName, valueLayout.carrier());\n@@ -162,3 +159,3 @@\n-            emitFieldSetter(vhConstant, javaName, valueLayout.carrier());\n-            emitIndexedFieldGetter(vhConstant, javaName, valueLayout.carrier());\n-            emitIndexedFieldSetter(vhConstant, javaName, valueLayout.carrier());\n+            emitFieldSetter(constantField, javaName, valueLayout.carrier());\n+            emitIndexedFieldGetter(constantField, javaName, valueLayout.carrier());\n+            emitIndexedFieldSetter(constantField, javaName, valueLayout.carrier());\n@@ -185,1 +182,1 @@\n-    private void emitFieldGetter(Constant vhConstant, String javaName, Class<?> type) {\n+    private void emitFieldGetter(String vhConstant, String javaName, Class<?> type) {\n@@ -194,1 +191,1 @@\n-    private void emitFieldSetter(Constant vhConstant, String javaName, Class<?> type) {\n+    private void emitFieldSetter(String vhConstant, String javaName, Class<?> type) {\n@@ -252,1 +249,1 @@\n-    private void emitIndexedFieldGetter(Constant vhConstant, String javaName, Class<?> type) {\n+    private void emitIndexedFieldGetter(String vhConstant, String javaName, Class<?> type) {\n@@ -262,1 +259,1 @@\n-    private void emitIndexedFieldSetter(Constant vhConstant, String javaName, Class<?> type) {\n+    private void emitIndexedFieldSetter(String vhConstant, String javaName, Class<?> type) {\n@@ -272,0 +269,31 @@\n+\n+    private void emitLayoutDecl() {\n+        appendIndentedLines(STR.\"\"\"\n+            private static final MemoryLayout $LAYOUT = \\{layoutString(0, structLayout)};\n+\n+            public static final MemoryLayout $LAYOUT() {\n+                return $LAYOUT;\n+            }\n+            \"\"\");\n+    }\n+\n+    private String emitFieldVarHandle(String javaName, String nativeName, List<String> prefixElementNames) {\n+        String mangledName = mangleName(javaName, VarHandle.class);\n+        appendIndentedLines(STR.\"\"\"\n+            private static final VarHandle \\{mangledName} = $LAYOUT.varHandle(\\{pathElementStr(nativeName, prefixElementNames)});\n+\n+            \\{MEMBER_MODS} VarHandle \\{mangledName}() {\n+                return \\{mangledName};\n+            }\n+            \"\"\");\n+        return mangledName;\n+    }\n+\n+    private static String pathElementStr(String nativeName, List<String> prefixElementNames) {\n+        StringJoiner joiner = new StringJoiner(\", \");\n+        for (String prefixElementName : prefixElementNames) {\n+            joiner.add(STR.\"MemoryLayout.PathElement.groupElement(\\\"\\{prefixElementName}\\\")\");\n+        }\n+        joiner.add(STR.\"MemoryLayout.PathElement.groupElement(\\\"\\{nativeName}\\\")\");\n+        return joiner.toString();\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructBuilder.java","additions":46,"deletions":18,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-    private final Constants constants;\n@@ -57,1 +56,0 @@\n-        this.constants = new Constants(packageName);\n@@ -59,1 +57,1 @@\n-        lastHeader = firstHeader = createFirstHeader(sfb, constants);\n+        lastHeader = firstHeader = createFirstHeader(sfb);\n@@ -62,2 +60,2 @@\n-    private static HeaderFileBuilder createFirstHeader(SourceFileBuilder sfb, Constants constants) {\n-        HeaderFileBuilder first = new HeaderFileBuilder(sfb, constants, sfb.className(), \"#{SUPER}\");\n+    private static HeaderFileBuilder createFirstHeader(SourceFileBuilder sfb) {\n+        HeaderFileBuilder first = new HeaderFileBuilder(sfb, sfb.className(), \"#{SUPER}\");\n@@ -86,1 +84,0 @@\n-        files.addAll(constants.toFiles());\n@@ -132,1 +129,1 @@\n-        StructBuilder structBuilder = new StructBuilder(sfb, constants, \"public\", sfb.className(), null, tree, layout);\n+        StructBuilder structBuilder = new StructBuilder(sfb, \"public\", sfb.className(), null, tree, layout);\n@@ -142,1 +139,1 @@\n-        FunctionalInterfaceBuilder.generate(sfb, constants, sfb.className(), null, funcType, descriptor, parameterNames);\n+        FunctionalInterfaceBuilder.generate(sfb, sfb.className(), null, funcType, descriptor, parameterNames);\n@@ -150,1 +147,1 @@\n-            HeaderFileBuilder headerFileBuilder = new HeaderFileBuilder(sfb, constants, sfb.className(),\n+            HeaderFileBuilder headerFileBuilder = new HeaderFileBuilder(sfb, sfb.className(),\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ToplevelBuilder.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"}]}