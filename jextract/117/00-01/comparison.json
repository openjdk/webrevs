{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jextract.Type;\n+\n@@ -29,0 +31,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -56,0 +59,11 @@\n+        \/\/ prime the cache with basic primitive\/pointer (immediate) layouts\n+        for (Type.Primitive.Kind kind : Type.Primitive.Kind.values()) {\n+            kind.layout().ifPresent(layout -> {\n+                if (layout instanceof ValueLayout valueLayout) {\n+                    cache.put(valueLayout, ImmediateConstant.ofPrimitiveLayout(valueLayout));\n+                }\n+            });\n+        }\n+        AddressLayout pointerLayout = ValueLayout.ADDRESS.withTargetLayout(\n+                MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE));\n+        cache.put(pointerLayout, ImmediateConstant.ofPrimitiveLayout(pointerLayout));\n@@ -72,1 +86,1 @@\n-    record Constant(Builder builder, Class<?> type, String constantName) {\n+    static sealed abstract class Constant permits Builder.NamedConstant, ImmediateConstant {\n@@ -74,2 +88,4 @@\n-        String getterName(String javaName) {\n-            return javaName + nameSuffix();\n+        final Class<?> type;\n+\n+        public Constant(Class<?> type) {\n+            this.type = type;\n@@ -78,2 +94,6 @@\n-        String accessExpression() {\n-            return builder.className() + \".\" + constantName;\n+        Class<?> type() {\n+            return type;\n+        }\n+\n+        String getterName(String javaName) {\n+            return javaName + nameSuffix();\n@@ -111,2 +131,0 @@\n-            } else if (type.isPrimitive()) {\n-                return \"$\" + type.getSimpleName().toUpperCase();\n@@ -114,1 +132,1 @@\n-                throw new AssertionError(\"Cannot get here: \" + type.getSimpleName());\n+                return \"\";\n@@ -117,0 +135,77 @@\n+\n+        abstract String accessExpression();\n+    }\n+\n+    final static class ImmediateConstant extends Constant {\n+        final String value;\n+\n+        ImmediateConstant(Class<?> type, String value) {\n+            super(type);\n+            this.value = value;\n+        }\n+\n+        @Override\n+        String accessExpression() {\n+            return value;\n+        }\n+\n+        static ImmediateConstant ofPrimitiveLayout(ValueLayout vl) {\n+            final String layoutStr;\n+            if (vl.carrier() == boolean.class) {\n+                layoutStr = \"JAVA_BOOLEAN\";\n+            } else if (vl.carrier() == char.class) {\n+                layoutStr = \"JAVA_CHAR\";\n+            } else if (vl.carrier() == byte.class) {\n+                layoutStr = \"JAVA_BYTE\";\n+            } else if (vl.carrier() == short.class) {\n+                layoutStr = \"JAVA_SHORT\";\n+            } else if (vl.carrier() == int.class) {\n+                layoutStr = \"JAVA_INT\";\n+            } else if (vl.carrier() == float.class) {\n+                layoutStr = \"JAVA_FLOAT\";\n+            } else if (vl.carrier() == long.class) {\n+                layoutStr = \"JAVA_LONG\";\n+            } else if (vl.carrier() == double.class) {\n+                layoutStr = \"JAVA_DOUBLE\";\n+            } else if (vl.carrier() == MemorySegment.class) {\n+                layoutStr = \"RuntimeHelper.POINTER\";\n+            } else {\n+                throw new UnsupportedOperationException(\"Unsupported layout: \" + vl);\n+            }\n+            return new ImmediateConstant(MemoryLayout.class, layoutStr);\n+        }\n+\n+        static Constant ofLiteral(Class<?> type, Object value) {\n+            StringBuilder buf = new StringBuilder();\n+            if (type == float.class) {\n+                float f = ((Number)value).floatValue();\n+                if (Float.isFinite(f)) {\n+                    buf.append(value);\n+                    buf.append(\"f\");\n+                } else {\n+                    buf.append(\"Float.valueOf(\\\"\");\n+                    buf.append(value);\n+                    buf.append(\"\\\")\");\n+                }\n+            } else if (type == long.class) {\n+                buf.append(value.toString());\n+                buf.append(\"L\");\n+            } else if (type == double.class) {\n+                double d = ((Number)value).doubleValue();\n+                if (Double.isFinite(d)) {\n+                    buf.append(value);\n+                    buf.append(\"d\");\n+                } else {\n+                    buf.append(\"Double.valueOf(\\\"\");\n+                    buf.append(value);\n+                    buf.append(\"\\\")\");\n+                }\n+            } else if (type == boolean.class) {\n+                boolean booleanValue = ((Number)value).byteValue() != 0;\n+                buf.append(booleanValue);\n+            } else {\n+                buf.append(\"(\" + type.getName() + \")\");\n+                buf.append(value + \"L\");\n+            }\n+            return new ImmediateConstant(type, buf.toString());\n+        }\n@@ -145,0 +240,18 @@\n+        final class NamedConstant extends Constant {\n+            final String constantName;\n+\n+            NamedConstant(Class<?> type) {\n+                super(type);\n+                this.constantName = newConstantName();\n+            }\n+\n+            String constantName() {\n+                return constantName;\n+            }\n+\n+            @Override\n+            String accessExpression() {\n+                return className() + \".\" + constantName;\n+            }\n+        }\n+\n@@ -148,1 +261,1 @@\n-            String constName = newConstantName();\n+            NamedConstant mhConst = new NamedConstant(MethodHandle.class);\n@@ -151,1 +264,1 @@\n-            append(constName + \" = RuntimeHelper.\");\n+            append(mhConst.constantName + \" = RuntimeHelper.\");\n@@ -171,1 +284,1 @@\n-            return new Constant(this, MethodHandle.class, constName);\n+            return mhConst;\n@@ -177,1 +290,1 @@\n-            String constName = newConstantName();\n+            NamedConstant mhConst = new NamedConstant(MethodHandle.class);\n@@ -180,1 +293,1 @@\n-            append(constName + \" = RuntimeHelper.upcallHandle(\");\n+            append(mhConst.constantName + \" = RuntimeHelper.upcallHandle(\");\n@@ -186,1 +299,1 @@\n-            return new Constant(this, MethodHandle.class, constName);\n+            return mhConst;\n@@ -196,2 +309,2 @@\n-            String constName = newConstantName();\n-            append(memberMods() + \"VarHandle \" + constName + \" = \");\n+            NamedConstant vhConst = new NamedConstant(VarHandle.class);\n+            append(memberMods() + \"VarHandle \" + vhConst.constantName + \" = \");\n@@ -211,1 +324,1 @@\n-            return new Constant(this, VarHandle.class, constName);\n+            return vhConst;\n@@ -215,1 +328,1 @@\n-            String constName = newConstantName();\n+            NamedConstant layoutConst = new NamedConstant(MemoryLayout.class);\n@@ -219,1 +332,1 @@\n-            append(memberMods() + layoutClassName + \" \" + constName + \" = \");\n+            append(memberMods() + layoutClassName + \" \" + layoutConst.constantName + \" = \");\n@@ -223,25 +336,1 @@\n-            return new Constant(this, MemoryLayout.class, constName);\n-        }\n-\n-        protected String primitiveLayoutString(ValueLayout vl) {\n-            if (vl.carrier() == boolean.class) {\n-                return \"JAVA_BOOLEAN\";\n-            } else if (vl.carrier() == char.class) {\n-                return \"JAVA_CHAR\";\n-            } else if (vl.carrier() == byte.class) {\n-                return \"JAVA_BYTE\";\n-            } else if (vl.carrier() == short.class) {\n-                return \"JAVA_SHORT\";\n-            } else if (vl.carrier() == int.class) {\n-                return \"JAVA_INT\";\n-            } else if (vl.carrier() == float.class) {\n-                return \"JAVA_FLOAT\";\n-            } else if (vl.carrier() == long.class) {\n-                return \"JAVA_LONG\";\n-            } else if (vl.carrier() == double.class) {\n-                return \"JAVA_DOUBLE\";\n-            } else if (vl.carrier() == MemorySegment.class) {\n-                return \"RuntimeHelper.POINTER\";\n-            } else {\n-                return \"MemoryLayout.paddingLayout(\" + vl.bitSize() +  \")\";\n-            }\n+            return layoutConst;\n@@ -252,1 +341,1 @@\n-                append(primitiveLayoutString(val));\n+                append(ImmediateConstant.ofPrimitiveLayout(val).accessExpression());\n@@ -296,2 +385,2 @@\n-            String constName = newConstantName();\n-            append(constName);\n+            NamedConstant descConstant = new NamedConstant(FunctionDescriptor.class);\n+            append(descConstant.constantName);\n@@ -324,1 +413,1 @@\n-            return new Constant(this, FunctionDescriptor.class, constName);\n+            return descConstant;\n@@ -332,2 +421,2 @@\n-            String constName = newConstantName();\n-            append(constName);\n+            NamedConstant segConstant = new NamedConstant(MemorySegment.class);\n+            append(segConstant.constantName);\n@@ -338,1 +427,1 @@\n-            return new Constant(this, MemorySegment.class, constName);\n+            return segConstant;\n@@ -346,2 +435,2 @@\n-            String constName = newConstantName();\n-            append(constName);\n+            NamedConstant segConstant = new NamedConstant(MemorySegment.class);\n+            append(segConstant.constantName);\n@@ -352,43 +441,1 @@\n-            return new Constant(this, MemorySegment.class, constName);\n-        }\n-\n-        private Constant emitLiteral(Class<?> type, Object value) {\n-            incrAlign();\n-            indent();\n-            append(memberMods());\n-            append(type.getSimpleName() + \" \");\n-            String constName = newConstantName();\n-            append(constName + \" = \");\n-            if (type == float.class) {\n-                float f = ((Number)value).floatValue();\n-                if (Float.isFinite(f)) {\n-                    append(value);\n-                    append(\"f\");\n-                } else {\n-                    append(\"Float.valueOf(\\\"\");\n-                    append(value);\n-                    append(\"\\\")\");\n-                }\n-            } else if (type == long.class) {\n-                append(value.toString());\n-                append(\"L\");\n-            } else if (type == double.class) {\n-                double d = ((Number)value).doubleValue();\n-                if (Double.isFinite(d)) {\n-                    append(value);\n-                    append(\"d\");\n-                } else {\n-                    append(\"Double.valueOf(\\\"\");\n-                    append(value);\n-                    append(\"\\\")\");\n-                }\n-            } else if (type == boolean.class) {\n-                boolean booleanValue = ((Number)value).byteValue() != 0;\n-                append(booleanValue);\n-            } else {\n-                append(\"(\" + type.getName() + \")\");\n-                append(value + \"L\");\n-            }\n-            append(\";\\n\");\n-            decrAlign();\n-            return new Constant(this, type, constName);\n+            return segConstant;\n@@ -403,2 +450,2 @@\n-            String constName = newConstantName();\n-            append(constName);\n+            NamedConstant segConstant = new NamedConstant(MemorySegment.class);\n+            append(segConstant.constantName);\n@@ -411,1 +458,1 @@\n-            return new Constant(this, MemorySegment.class, constName);\n+            return segConstant;\n@@ -475,1 +522,1 @@\n-                constant = builder().emitLiteral(type, value);\n+                constant = ImmediateConstant.ofLiteral(type, value);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Constants.java","additions":147,"deletions":100,"binary":false,"changes":247,"status":"modified"}]}