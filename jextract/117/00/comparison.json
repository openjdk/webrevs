{"files":[{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,1 +110,1 @@\n-            Short(\"short\", ValueLayout.JAVA_SHORT.withBitAlignment(16)),\n+            Short(\"short\", ValueLayout.JAVA_SHORT),\n@@ -114,1 +114,1 @@\n-            Int(\"int\", ValueLayout.JAVA_INT.withBitAlignment(32)),\n+            Int(\"int\", ValueLayout.JAVA_INT),\n@@ -119,2 +119,2 @@\n-                ValueLayout.JAVA_INT.withBitAlignment(32) :\n-                ValueLayout.JAVA_LONG.withBitAlignment(64)),\n+                ValueLayout.JAVA_INT :\n+                ValueLayout.JAVA_LONG),\n@@ -124,1 +124,1 @@\n-            LongLong(\"long long\", ValueLayout.JAVA_LONG.withBitAlignment(64)),\n+            LongLong(\"long long\", ValueLayout.JAVA_LONG),\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Type.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-import java.util.function.Consumer;\n+\n@@ -33,0 +33,1 @@\n+import org.openjdk.jextract.impl.Constants.Constant;\n@@ -162,0 +163,4 @@\n+    void append(Object o) {\n+        sb.append(o);\n+    }\n+\n@@ -267,1 +272,1 @@\n-    protected void emitGetter(String mods, Class<?> type, String name, String access, boolean nullCheck, String symbolName) {\n+    void emitConstantGetter(String mods, String getterName, boolean nullCheck, String symbolName, Constant constant) {\n@@ -270,1 +275,1 @@\n-        append(mods + \" \" + type.getSimpleName() + \" \" +name + \"() {\\n\");\n+        append(mods + \" \" + constant.type().getSimpleName() + \" \" + getterName + \"() {\\n\");\n@@ -277,1 +282,1 @@\n-        append(access);\n+        append(constant.accessExpression());\n@@ -290,12 +295,0 @@\n-    protected void emitGetter(String mods, Class<?> type, String name, String access) {\n-        emitGetter(mods, type, name, access, false, null);\n-    }\n-\n-    ToplevelBuilder toplevel() {\n-        JavaSourceBuilder encl = enclosing;\n-        while (encl instanceof ClassSourceBuilder classSourceBuilder) {\n-            encl = classSourceBuilder.enclosing;\n-        }\n-        return (ToplevelBuilder)encl;\n-    }\n-\n@@ -303,2 +296,2 @@\n-    protected void emitWithConstantClass(Consumer<ConstantBuilder> constantConsumer) {\n-        enclosing.emitWithConstantClass(constantConsumer);\n+    protected Constants constants() {\n+        return enclosing.constants();\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ClassSourceBuilder.java","additions":12,"deletions":19,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1,415 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.jextract.impl;\n-\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.StructLayout;\n-import java.lang.foreign.ValueLayout;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-\n-public class ConstantBuilder extends ClassSourceBuilder {\n-\n-    \/\/ set of names generates already\n-    private final Map<String, Constant> namesGenerated = new HashMap<>();\n-\n-    public ConstantBuilder(JavaSourceBuilder enclosing, String className) {\n-        super(enclosing, Kind.CLASS, className);\n-    }\n-\n-    String memberMods() {\n-        return kind == ClassSourceBuilder.Kind.CLASS ?\n-                \"static final \" : \"\";\n-    }\n-\n-    \/\/ public API\n-\n-    public Constant addLayout(String javaName, MemoryLayout layout) {\n-        return emitIfAbsent(javaName, Constant.Kind.LAYOUT,\n-                () -> emitLayoutField(javaName, layout));\n-    }\n-\n-    public Constant addFieldVarHandle(String javaName, String nativeName, ValueLayout valueLayout,\n-                                      String rootJavaName, List<String> prefixElementNames) {\n-        return addVarHandle(javaName, nativeName, valueLayout, rootJavaName, prefixElementNames);\n-    }\n-\n-    public Constant addGlobalVarHandle(String javaName, String nativeName, ValueLayout valueLayout) {\n-        return addVarHandle(javaName, nativeName, valueLayout, null, List.of());\n-    }\n-\n-    private Constant addVarHandle(String javaName, String nativeName, ValueLayout valueLayout,\n-                                String rootLayoutName, List<String> prefixElementNames) {\n-        return emitIfAbsent(javaName, Constant.Kind.VAR_HANDLE,\n-                () -> emitVarHandleField(javaName, nativeName, valueLayout, rootLayoutName, prefixElementNames));\n-    }\n-\n-    public Constant addDowncallMethodHandle(String javaName, String nativeName, FunctionDescriptor descriptor, boolean isVarargs, boolean virtual) {\n-        return emitIfAbsent(javaName, Constant.Kind.METHOD_HANDLE,\n-                () -> emitDowncallMethodHandleField(javaName, nativeName, descriptor, isVarargs, virtual));\n-    }\n-\n-    public Constant addLookupMethodHandle(String javaName, String className, String name, FunctionDescriptor descriptor) {\n-        return emitIfAbsent(javaName, Constant.Kind.METHOD_HANDLE,\n-                () -> emitUpcallMethodHandleField(javaName, className, name, descriptor));\n-    }\n-\n-    public Constant addSegment(String javaName, String nativeName, MemoryLayout layout) {\n-        return emitIfAbsent(javaName, Constant.Kind.SEGMENT,\n-                () -> emitSegmentField(javaName, nativeName, layout));\n-    }\n-\n-    public Constant addFunctionDesc(String javaName, FunctionDescriptor desc) {\n-        return emitIfAbsent(javaName, Constant.Kind.FUNCTION_DESCRIPTOR,\n-                () -> emitFunctionDescField(javaName, desc));\n-    }\n-\n-    public Constant addConstantDesc(String javaName, Class<?> type, Object value) {\n-        if (value instanceof String) {\n-            return emitIfAbsent(javaName, Constant.Kind.SEGMENT,\n-                    () -> emitConstantSegment(javaName, value));\n-        } else if (type == MemorySegment.class) {\n-            return emitIfAbsent(javaName, Constant.Kind.ADDRESS,\n-                    () -> emitConstantAddress(javaName, value));\n-        } else {\n-            throw new UnsupportedOperationException();\n-        }\n-    }\n-\n-    static final class Constant {\n-\n-        enum Kind {\n-            LAYOUT(MemoryLayout.class, \"$LAYOUT\"),\n-            METHOD_HANDLE(MethodHandle.class, \"$MH\"),\n-            VAR_HANDLE(VarHandle.class, \"$VH\"),\n-            FUNCTION_DESCRIPTOR(FunctionDescriptor.class, \"$FUNC\"),\n-            ADDRESS(MemorySegment.class, \"$ADDR\"),\n-            SEGMENT(MemorySegment.class, \"$SEGMENT\");\n-\n-            final Class<?> type;\n-            final String nameSuffix;\n-\n-            Kind(Class<?> type, String nameSuffix) {\n-                this.type = type;\n-                this.nameSuffix = nameSuffix;\n-            }\n-\n-            String fieldName(String javaName) {\n-                return javaName + nameSuffix;\n-            }\n-        }\n-\n-        private final String className;\n-        private final String javaName;\n-        private final Kind kind;\n-\n-        Constant(String className, String javaName, Kind kind) {\n-            this.className = className;\n-            this.javaName = javaName;\n-            this.kind = kind;\n-        }\n-\n-        String className() {\n-            return className;\n-        }\n-\n-        String javaName() {\n-            return javaName;\n-        }\n-\n-        Kind kind() {\n-            return kind;\n-        }\n-\n-        List<String> getterNameParts() {\n-            return List.of(className, javaName, kind.nameSuffix);\n-        }\n-\n-        String accessExpression() {\n-            return className + \".\" + kind.fieldName(javaName);\n-        }\n-\n-        Constant emitGetter(ClassSourceBuilder builder, String mods, Function<List<String>, String> getterNameFunc) {\n-            builder.emitGetter(mods, kind.type, getterNameFunc.apply(getterNameParts()), accessExpression());\n-            return this;\n-        }\n-\n-        Constant emitGetter(ClassSourceBuilder builder, String mods, Function<List<String>, String> getterNameFunc, String symbolName) {\n-            builder.emitGetter(mods, kind.type, getterNameFunc.apply(getterNameParts()), accessExpression(), true, symbolName);\n-            return this;\n-        }\n-\n-        static final Function<List<String>, String> QUALIFIED_NAME =\n-                l -> l.stream().skip(1).collect(Collectors.joining());\n-\n-        static final Function<List<String>, String> JAVA_NAME =\n-                l -> l.get(1);\n-\n-        static final Function<List<String>, String> SUFFIX_ONLY =\n-                l -> l.get(2);\n-    }\n-\n-    \/\/ private generators\n-\n-    public Constant emitIfAbsent(String name, Constant.Kind kind, Supplier<Constant> constantFactory) {\n-        String lookupName = kind.fieldName(name);\n-        Constant constant = namesGenerated.get(lookupName);\n-        if (constant == null) {\n-            constant = constantFactory.get();\n-            if (constant.kind != kind) {\n-                throw new AssertionError(\"Factory return wrong kind of constant; expected: \"\n-                        + kind + \"; found: \" + constant.kind);\n-            }\n-            namesGenerated.put(lookupName, constant);\n-        }\n-        return constant;\n-    }\n-\n-    private Constant emitDowncallMethodHandleField(String javaName, String nativeName, FunctionDescriptor descriptor, boolean isVarargs, boolean virtual) {\n-        Constant functionDesc = addFunctionDesc(javaName, descriptor);\n-        incrAlign();\n-        String fieldName = Constant.Kind.METHOD_HANDLE.fieldName(javaName);\n-        indent();\n-        append(memberMods() + \"MethodHandle \");\n-        append(fieldName + \" = RuntimeHelper.\");\n-        if (isVarargs) {\n-            append(\"downcallHandleVariadic\");\n-        } else {\n-            append(\"downcallHandle\");\n-        }\n-        append(\"(\\n\");\n-        incrAlign();\n-        indent();\n-        if (!virtual) {\n-            append(\"\\\"\" + nativeName + \"\\\"\");\n-            append(\",\\n\");\n-            indent();\n-        }\n-        append(functionDesc.accessExpression());\n-        append(\"\\n\");\n-        decrAlign();\n-        indent();\n-        append(\");\\n\");\n-        decrAlign();\n-        return new Constant(className(), javaName, Constant.Kind.METHOD_HANDLE);\n-    }\n-\n-    private Constant emitUpcallMethodHandleField(String javaName, String className, String methodName, FunctionDescriptor descriptor) {\n-        Constant functionDesc = addFunctionDesc(javaName, descriptor);\n-        incrAlign();\n-        String fieldName = Constant.Kind.METHOD_HANDLE.fieldName(javaName);\n-        indent();\n-        append(memberMods() + \"MethodHandle \");\n-        append(fieldName + \" = RuntimeHelper.upcallHandle(\");\n-        append(className + \".class, \");\n-        append(\"\\\"\" + methodName + \"\\\", \");\n-        append(functionDesc.accessExpression());\n-        append(\");\\n\");\n-        decrAlign();\n-        return new Constant(className(), javaName, Constant.Kind.METHOD_HANDLE);\n-    }\n-\n-    private Constant emitVarHandleField(String javaName, String nativeName, ValueLayout valueLayout,\n-                                      String rootLayoutName, List<String> prefixElementNames) {\n-        String layoutAccess = rootLayoutName != null ?\n-                Constant.Kind.LAYOUT.fieldName(rootLayoutName) :\n-                addLayout(javaName, valueLayout).accessExpression();\n-        incrAlign();\n-        indent();\n-        String fieldName = Constant.Kind.VAR_HANDLE.fieldName(javaName);\n-        append(memberMods() + \"VarHandle \" + fieldName + \" = \");\n-        append(layoutAccess);\n-        append(\".varHandle(\");\n-        String prefix = \"\";\n-        if (rootLayoutName != null) {\n-            for (String prefixElementName : prefixElementNames) {\n-                append(prefix + \"MemoryLayout.PathElement.groupElement(\\\"\" + prefixElementName + \"\\\")\");\n-                prefix = \", \";\n-            }\n-            append(prefix + \"MemoryLayout.PathElement.groupElement(\\\"\" + nativeName + \"\\\")\");\n-        }\n-        append(\")\");\n-        append(\";\\n\");\n-        decrAlign();\n-        return new Constant(className(), javaName, Constant.Kind.VAR_HANDLE);\n-    }\n-\n-    private Constant emitLayoutField(String javaName, MemoryLayout layout) {\n-        String fieldName = Constant.Kind.LAYOUT.fieldName(javaName);\n-        incrAlign();\n-        indent();\n-        String layoutClassName = Utils.layoutDeclarationType(layout).getSimpleName();\n-        append(memberMods() + layoutClassName + \" \" + fieldName + \" = \");\n-        emitLayoutString(layout);\n-        append(\";\\n\");\n-        decrAlign();\n-        return new Constant(className(), javaName, Constant.Kind.LAYOUT);\n-    }\n-\n-    protected String primitiveLayoutString(ValueLayout layout) {\n-        return toplevel().rootConstants().resolvePrimitiveLayout(layout).accessExpression();\n-    }\n-\n-    private void emitLayoutString(MemoryLayout l) {\n-        if (l instanceof ValueLayout val) {\n-            append(primitiveLayoutString(val));\n-            if (l.bitAlignment() != l.bitSize()) {\n-                append(\".withBitAlignment(\");\n-                append(l.bitAlignment());\n-                append(\")\");\n-            }\n-        } else if (l instanceof SequenceLayout seq) {\n-            append(\"MemoryLayout.sequenceLayout(\");\n-            append(seq.elementCount() + \", \");\n-            emitLayoutString(seq.elementLayout());\n-            append(\")\");\n-        } else if (l instanceof GroupLayout group) {\n-            if (group instanceof StructLayout) {\n-                append(\"MemoryLayout.structLayout(\\n\");\n-            } else {\n-                append(\"MemoryLayout.unionLayout(\\n\");\n-            }\n-            incrAlign();\n-            String delim = \"\";\n-            for (MemoryLayout e : group.memberLayouts()) {\n-                append(delim);\n-                indent();\n-                emitLayoutString(e);\n-                delim = \",\\n\";\n-            }\n-            append(\"\\n\");\n-            decrAlign();\n-            indent();\n-            append(\")\");\n-        } else {\n-            \/\/ padding (or unsupported)\n-            append(\"MemoryLayout.paddingLayout(\" + l.bitSize() + \")\");\n-        }\n-        if (l.name().isPresent()) {\n-            append(\".withName(\\\"\" +  l.name().get() + \"\\\")\");\n-        }\n-    }\n-\n-    private Constant emitFunctionDescField(String javaName, FunctionDescriptor desc) {\n-        incrAlign();\n-        indent();\n-        String fieldName = Constant.Kind.FUNCTION_DESCRIPTOR.fieldName(javaName);\n-        final boolean noArgs = desc.argumentLayouts().isEmpty();\n-        append(memberMods());\n-        append(\"FunctionDescriptor \");\n-        append(fieldName);\n-        append(\" = \");\n-        if (desc.returnLayout().isPresent()) {\n-            append(\"FunctionDescriptor.of(\");\n-            emitLayoutString(desc.returnLayout().get());\n-            if (!noArgs) {\n-                append(\",\");\n-            }\n-        } else {\n-            append(\"FunctionDescriptor.ofVoid(\");\n-        }\n-        if (!noArgs) {\n-            append(\"\\n\");\n-            incrAlign();\n-            String delim = \"\";\n-            for (MemoryLayout e : desc.argumentLayouts()) {\n-                append(delim);\n-                indent();\n-                emitLayoutString(e);\n-                delim = \",\\n\";\n-            }\n-            append(\"\\n\");\n-            decrAlign();\n-            indent();\n-        }\n-        append(\");\\n\");\n-        decrAlign();\n-        return new Constant(className(), javaName, Constant.Kind.FUNCTION_DESCRIPTOR);\n-    }\n-\n-    private Constant emitConstantSegment(String javaName, Object value) {\n-        incrAlign();\n-        indent();\n-        String fieldName = Constant.Kind.SEGMENT.fieldName(javaName);\n-        append(memberMods());\n-        append(\"MemorySegment \");\n-        append(fieldName);\n-        append(\" = RuntimeHelper.CONSTANT_ALLOCATOR.allocateUtf8String(\\\"\");\n-        append(Utils.quote(Objects.toString(value)));\n-        append(\"\\\");\\n\");\n-        decrAlign();\n-        return new Constant(className(), javaName, Constant.Kind.SEGMENT);\n-    }\n-\n-    private Constant emitConstantAddress(String javaName, Object value) {\n-        incrAlign();\n-        indent();\n-        String fieldName = Constant.Kind.ADDRESS.fieldName(javaName);\n-        append(memberMods());\n-        append(\"MemorySegment \");\n-        append(fieldName);\n-        append(\" = MemorySegment.ofAddress(\");\n-        append(((Number)value).longValue());\n-        append(\"L);\\n\");\n-        decrAlign();\n-        return new Constant(className(), javaName, Constant.Kind.ADDRESS);\n-    }\n-\n-    private Constant emitSegmentField(String javaName, String nativeName, MemoryLayout layout) {\n-        Constant layoutConstant = addLayout(javaName, layout);\n-        incrAlign();\n-        indent();\n-        String fieldName = Constant.Kind.SEGMENT.fieldName(javaName);\n-        append(memberMods());\n-        append(\"MemorySegment \");\n-        append(fieldName);\n-        append(\" = \");\n-        append(\"RuntimeHelper.lookupGlobalVariable(\");\n-        append(\"\\\"\" + nativeName + \"\\\", \");\n-        append(layoutConstant.accessExpression());\n-        append(\");\\n\");\n-        decrAlign();\n-        return new Constant(className(), javaName, Constant.Kind.SEGMENT);\n-    }\n-\n-    @Override\n-    protected void emitWithConstantClass(Consumer<ConstantBuilder> constantConsumer) {\n-        constantConsumer.accept(this);\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ConstantBuilder.java","additions":0,"deletions":415,"binary":false,"changes":415,"status":"deleted"},{"patch":"@@ -0,0 +1,481 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+import javax.tools.JavaFileObject;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+public class Constants {\n+\n+    private final Map<Object, Constant> cache = new HashMap<>();\n+\n+    List<Builder> constantBuilders = new ArrayList<>();\n+    Builder currentBuilder;\n+\n+    public Constants(JavaSourceBuilder enclosing) {\n+        currentBuilder = new Builder(enclosing, 0);\n+        constantBuilders.add(currentBuilder);\n+        currentBuilder.classBegin();\n+    }\n+\n+    static final int CONSTANTS_PER_CLASS = Integer.getInteger(\"jextract.constants.per.class\", 5);\n+\n+    private Builder builder() {\n+        if (currentBuilder.constantIndex > CONSTANTS_PER_CLASS || currentBuilder == null) {\n+            if (currentBuilder != null) {\n+                currentBuilder.classEnd();\n+            }\n+            currentBuilder = new Builder(currentBuilder.enclosing, constantBuilders.size());\n+            constantBuilders.add(currentBuilder);\n+            currentBuilder.classBegin();\n+        }\n+        return currentBuilder;\n+    }\n+\n+    record Constant(Builder builder, Class<?> type, String constantName) {\n+\n+        String getterName(String javaName) {\n+            return javaName + nameSuffix();\n+        }\n+\n+        String accessExpression() {\n+            return builder.className() + \".\" + constantName;\n+        }\n+\n+        Constant emitGetter(ClassSourceBuilder builder, String mods, String javaName) {\n+            return emitGetter(builder, mods, c -> c.getterName(javaName));\n+        }\n+\n+        Constant emitGetter(ClassSourceBuilder builder, String mods, String javaName, String symbolName) {\n+            return emitGetter(builder, mods, symbolName, c -> c.getterName(javaName));\n+        }\n+\n+        Constant emitGetter(ClassSourceBuilder builder, String mods, Function<Constant, String> getterNameFunc) {\n+            builder.emitConstantGetter(mods, getterNameFunc.apply(this), false, null, this);\n+            return this;\n+        }\n+\n+        Constant emitGetter(ClassSourceBuilder builder, String mods, String symbolName, Function<Constant, String> getterNameFunc) {\n+            builder.emitConstantGetter(mods, getterNameFunc.apply(this), true, symbolName, this);\n+            return this;\n+        }\n+\n+        String nameSuffix() {\n+            if (type.equals(MemorySegment.class)) {\n+                return \"$SEGMENT\";\n+            } else if (type.equals(MemoryLayout.class)) {\n+                return \"$LAYOUT\";\n+            } else if (type.equals(MethodHandle.class)) {\n+                return \"$MH\";\n+            } else if (type.equals(VarHandle.class)) {\n+                return \"$VH\";\n+            } else if (type.equals(FunctionDescriptor.class)) {\n+                return \"$DESC\";\n+            } else if (type.isPrimitive()) {\n+                return \"$\" + type.getSimpleName().toUpperCase();\n+            } else {\n+                throw new AssertionError(\"Cannot get here: \" + type.getSimpleName());\n+            }\n+        }\n+    }\n+\n+    public List<JavaFileObject> toFiles() {\n+        currentBuilder.classEnd();\n+        List<JavaFileObject> files = new ArrayList<>();\n+        files.addAll(constantBuilders.stream()\n+                .flatMap(b -> b.toFiles().stream()).toList());\n+        return files;\n+    }\n+\n+    class Builder extends ClassSourceBuilder {\n+\n+        Builder(JavaSourceBuilder encl, int id) {\n+            super(encl, Kind.CLASS, \"constants$\" + id);\n+        }\n+\n+        String memberMods() {\n+            return kind == ClassSourceBuilder.Kind.CLASS ?\n+                    \"static final \" : \"\";\n+        }\n+\n+        @Override\n+        String mods() {\n+            return \"final \"; \/\/ constants package-private!\n+        }\n+\n+        int constantIndex = 0;\n+\n+        private Constant emitDowncallMethodHandleField(String nativeName, FunctionDescriptor descriptor, boolean isVarargs, boolean virtual) {\n+            Constant functionDesc = addFunctionDesc(descriptor);\n+            incrAlign();\n+            String constName = newConstantName();\n+            indent();\n+            append(memberMods() + \"MethodHandle \");\n+            append(constName + \" = RuntimeHelper.\");\n+            if (isVarargs) {\n+                append(\"downcallHandleVariadic\");\n+            } else {\n+                append(\"downcallHandle\");\n+            }\n+            append(\"(\\n\");\n+            incrAlign();\n+            indent();\n+            if (!virtual) {\n+                append(\"\\\"\" + nativeName + \"\\\"\");\n+                append(\",\\n\");\n+                indent();\n+            }\n+            append(functionDesc.accessExpression());\n+            append(\"\\n\");\n+            decrAlign();\n+            indent();\n+            append(\");\\n\");\n+            decrAlign();\n+            return new Constant(this, MethodHandle.class, constName);\n+        }\n+\n+        private Constant emitUpcallMethodHandleField(String className, String methodName, FunctionDescriptor descriptor) {\n+            Constant functionDesc = addFunctionDesc(descriptor);\n+            incrAlign();\n+            String constName = newConstantName();\n+            indent();\n+            append(memberMods() + \"MethodHandle \");\n+            append(constName + \" = RuntimeHelper.upcallHandle(\");\n+            append(className + \".class, \");\n+            append(\"\\\"\" + methodName + \"\\\", \");\n+            append(functionDesc.accessExpression());\n+            append(\");\\n\");\n+            decrAlign();\n+            return new Constant(this, MethodHandle.class, constName);\n+        }\n+\n+        private Constant emitVarHandleField(String nativeName, ValueLayout valueLayout,\n+                                            Constant rootLayout, List<String> prefixElementNames) {\n+            String layoutAccess = rootLayout != null ?\n+                    rootLayout.accessExpression() :\n+                    addLayout(valueLayout).accessExpression();\n+            incrAlign();\n+            indent();\n+            String constName = newConstantName();\n+            append(memberMods() + \"VarHandle \" + constName + \" = \");\n+            append(layoutAccess);\n+            append(\".varHandle(\");\n+            String prefix = \"\";\n+            if (rootLayout != null) {\n+                for (String prefixElementName : prefixElementNames) {\n+                    append(prefix + \"MemoryLayout.PathElement.groupElement(\\\"\" + prefixElementName + \"\\\")\");\n+                    prefix = \", \";\n+                }\n+                append(prefix + \"MemoryLayout.PathElement.groupElement(\\\"\" + nativeName + \"\\\")\");\n+            }\n+            append(\")\");\n+            append(\";\\n\");\n+            decrAlign();\n+            return new Constant(this, VarHandle.class, constName);\n+        }\n+\n+        private Constant emitLayoutField(MemoryLayout layout) {\n+            String constName = newConstantName();\n+            incrAlign();\n+            indent();\n+            String layoutClassName = Utils.layoutDeclarationType(layout).getSimpleName();\n+            append(memberMods() + layoutClassName + \" \" + constName + \" = \");\n+            emitLayoutString(layout);\n+            append(\";\\n\");\n+            decrAlign();\n+            return new Constant(this, MemoryLayout.class, constName);\n+        }\n+\n+        protected String primitiveLayoutString(ValueLayout vl) {\n+            if (vl.carrier() == boolean.class) {\n+                return \"JAVA_BOOLEAN\";\n+            } else if (vl.carrier() == char.class) {\n+                return \"JAVA_CHAR\";\n+            } else if (vl.carrier() == byte.class) {\n+                return \"JAVA_BYTE\";\n+            } else if (vl.carrier() == short.class) {\n+                return \"JAVA_SHORT\";\n+            } else if (vl.carrier() == int.class) {\n+                return \"JAVA_INT\";\n+            } else if (vl.carrier() == float.class) {\n+                return \"JAVA_FLOAT\";\n+            } else if (vl.carrier() == long.class) {\n+                return \"JAVA_LONG\";\n+            } else if (vl.carrier() == double.class) {\n+                return \"JAVA_DOUBLE\";\n+            } else if (vl.carrier() == MemorySegment.class) {\n+                return \"RuntimeHelper.POINTER\";\n+            } else {\n+                return \"MemoryLayout.paddingLayout(\" + vl.bitSize() +  \")\";\n+            }\n+        }\n+\n+        private void emitLayoutString(MemoryLayout l) {\n+            if (l instanceof ValueLayout val) {\n+                append(primitiveLayoutString(val));\n+                if (l.bitAlignment() != l.bitSize()) {\n+                    append(\".withBitAlignment(\");\n+                    append(l.bitAlignment());\n+                    append(\")\");\n+                }\n+            } else if (l instanceof SequenceLayout seq) {\n+                append(\"MemoryLayout.sequenceLayout(\");\n+                append(seq.elementCount() + \", \");\n+                emitLayoutString(seq.elementLayout());\n+                append(\")\");\n+            } else if (l instanceof GroupLayout group) {\n+                if (group instanceof StructLayout) {\n+                    append(\"MemoryLayout.structLayout(\\n\");\n+                } else {\n+                    append(\"MemoryLayout.unionLayout(\\n\");\n+                }\n+                incrAlign();\n+                String delim = \"\";\n+                for (MemoryLayout e : group.memberLayouts()) {\n+                    append(delim);\n+                    indent();\n+                    emitLayoutString(e);\n+                    delim = \",\\n\";\n+                }\n+                append(\"\\n\");\n+                decrAlign();\n+                indent();\n+                append(\")\");\n+            } else {\n+                \/\/ padding (or unsupported)\n+                append(\"MemoryLayout.paddingLayout(\" + l.bitSize() + \")\");\n+            }\n+            if (l.name().isPresent()) {\n+                append(\".withName(\\\"\" +  l.name().get() + \"\\\")\");\n+            }\n+        }\n+\n+        private Constant emitFunctionDescField(FunctionDescriptor desc) {\n+            incrAlign();\n+            indent();\n+            final boolean noArgs = desc.argumentLayouts().isEmpty();\n+            append(memberMods());\n+            append(\"FunctionDescriptor \");\n+            String constName = newConstantName();\n+            append(constName);\n+            append(\" = \");\n+            if (desc.returnLayout().isPresent()) {\n+                append(\"FunctionDescriptor.of(\");\n+                emitLayoutString(desc.returnLayout().get());\n+                if (!noArgs) {\n+                    append(\",\");\n+                }\n+            } else {\n+                append(\"FunctionDescriptor.ofVoid(\");\n+            }\n+            if (!noArgs) {\n+                append(\"\\n\");\n+                incrAlign();\n+                String delim = \"\";\n+                for (MemoryLayout e : desc.argumentLayouts()) {\n+                    append(delim);\n+                    indent();\n+                    emitLayoutString(e);\n+                    delim = \",\\n\";\n+                }\n+                append(\"\\n\");\n+                decrAlign();\n+                indent();\n+            }\n+            append(\");\\n\");\n+            decrAlign();\n+            return new Constant(this, FunctionDescriptor.class, constName);\n+        }\n+\n+        private Constant emitConstantSegment(Object value) {\n+            incrAlign();\n+            indent();\n+            append(memberMods());\n+            append(\"MemorySegment \");\n+            String constName = newConstantName();\n+            append(constName);\n+            append(\" = RuntimeHelper.CONSTANT_ALLOCATOR.allocateUtf8String(\\\"\");\n+            append(Utils.quote(Objects.toString(value)));\n+            append(\"\\\");\\n\");\n+            decrAlign();\n+            return new Constant(this, MemorySegment.class, constName);\n+        }\n+\n+        private Constant emitConstantAddress(Object value) {\n+            incrAlign();\n+            indent();\n+            append(memberMods());\n+            append(\"MemorySegment \");\n+            String constName = newConstantName();\n+            append(constName);\n+            append(\" = MemorySegment.ofAddress(\");\n+            append(((Number)value).longValue());\n+            append(\"L);\\n\");\n+            decrAlign();\n+            return new Constant(this, MemorySegment.class, constName);\n+        }\n+\n+        private Constant emitLiteral(Class<?> type, Object value) {\n+            incrAlign();\n+            indent();\n+            append(memberMods());\n+            append(type.getSimpleName() + \" \");\n+            String constName = newConstantName();\n+            append(constName + \" = \");\n+            if (type == float.class) {\n+                float f = ((Number)value).floatValue();\n+                if (Float.isFinite(f)) {\n+                    append(value);\n+                    append(\"f\");\n+                } else {\n+                    append(\"Float.valueOf(\\\"\");\n+                    append(value);\n+                    append(\"\\\")\");\n+                }\n+            } else if (type == long.class) {\n+                append(value.toString());\n+                append(\"L\");\n+            } else if (type == double.class) {\n+                double d = ((Number)value).doubleValue();\n+                if (Double.isFinite(d)) {\n+                    append(value);\n+                    append(\"d\");\n+                } else {\n+                    append(\"Double.valueOf(\\\"\");\n+                    append(value);\n+                    append(\"\\\")\");\n+                }\n+            } else if (type == boolean.class) {\n+                boolean booleanValue = ((Number)value).byteValue() != 0;\n+                append(booleanValue);\n+            } else {\n+                append(\"(\" + type.getName() + \")\");\n+                append(value + \"L\");\n+            }\n+            append(\";\\n\");\n+            decrAlign();\n+            return new Constant(this, type, constName);\n+        }\n+\n+        private Constant emitSegmentField(String nativeName, MemoryLayout layout) {\n+            Constant layoutConstant = addLayout(layout);\n+            incrAlign();\n+            indent();\n+            append(memberMods());\n+            append(\"MemorySegment \");\n+            String constName = newConstantName();\n+            append(constName);\n+            append(\" = \");\n+            append(\"RuntimeHelper.lookupGlobalVariable(\");\n+            append(\"\\\"\" + nativeName + \"\\\", \");\n+            append(layoutConstant.accessExpression());\n+            append(\");\\n\");\n+            decrAlign();\n+            return new Constant(this, MemorySegment.class, constName);\n+        }\n+\n+        String newConstantName() {\n+            return \"const$\" + constantIndex++;\n+        }\n+    }\n+\n+    \/\/ public API\n+\n+    public Constant addLayout(MemoryLayout layout) {\n+        Constant constant = cache.get(layout);\n+        if (constant == null) {\n+            constant = builder().emitLayoutField(layout);\n+            cache.put(layout, constant);\n+        }\n+        return constant;\n+    }\n+\n+    public Constant addFieldVarHandle(String nativeName, ValueLayout valueLayout,\n+                                      Constant rootLayout, List<String> prefixElementNames) {\n+        return addVarHandle(nativeName, valueLayout, rootLayout, prefixElementNames);\n+    }\n+\n+    public Constant addGlobalVarHandle(String nativeName, ValueLayout valueLayout) {\n+        return addVarHandle(nativeName, valueLayout, null, List.of());\n+    }\n+\n+    private Constant addVarHandle(String nativeName, ValueLayout valueLayout,\n+                                  Constant rootLayout, List<String> prefixElementNames) {\n+        return builder().emitVarHandleField(nativeName, valueLayout, rootLayout, prefixElementNames);\n+    }\n+\n+    public Constant addDowncallMethodHandle(String nativeName, FunctionDescriptor descriptor, boolean isVarargs, boolean virtual) {\n+        return builder().emitDowncallMethodHandleField(nativeName, descriptor, isVarargs, virtual);\n+    }\n+\n+    public Constant addUpcallMethodHandle(String className, String name, FunctionDescriptor descriptor) {\n+        return builder().emitUpcallMethodHandleField(className, name, descriptor);\n+    }\n+\n+    public Constant addSegment(String nativeName, MemoryLayout layout) {\n+        return builder().emitSegmentField(nativeName, layout);\n+    }\n+\n+    public Constant addFunctionDesc(FunctionDescriptor desc) {\n+        Constant constant = cache.get(desc);\n+        if (constant == null) {\n+            constant = builder().emitFunctionDescField(desc);\n+            cache.put(desc, constant);\n+        }\n+        return constant;\n+    }\n+\n+    public Constant addConstantDesc(Class<?> type, Object value) {\n+        record ConstantKey(Class<?> type, Object value) { }\n+        var key = new ConstantKey(type, value);\n+        Constant constant = cache.get(key);\n+        if (constant == null) {\n+            if (value instanceof String) {\n+                constant = builder().emitConstantSegment(value);\n+            } else if (type == MemorySegment.class) {\n+                constant = builder().emitConstantAddress(value);\n+            } else {\n+                constant = builder().emitLiteral(type, value);\n+            }\n+            cache.put(key, constant);\n+        }\n+        return constant;\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Constants.java","additions":481,"deletions":0,"binary":false,"changes":481,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-import org.openjdk.jextract.impl.ConstantBuilder.Constant;\n+import org.openjdk.jextract.impl.Constants.Constant;\n@@ -36,1 +36,0 @@\n-import java.util.function.Consumer;\n@@ -98,15 +97,13 @@\n-        emitWithConstantClass(constantBuilder -> {\n-            Constant functionDesc = constantBuilder.addFunctionDesc(className(), fiDesc);\n-            Constant upcallHandle = constantBuilder.addLookupMethodHandle(className() + \"_UP\", className(), \"apply\", fiDesc);\n-            incrAlign();\n-            indent();\n-            append(MEMBER_MODS + \" MemorySegment allocate(\" + className() + \" fi, Arena scope) {\\n\");\n-            incrAlign();\n-            indent();\n-            append(\"return RuntimeHelper.upcallStub(\" +\n-                upcallHandle.accessExpression() + \", fi, \" + functionDesc.accessExpression() + \", scope);\\n\");\n-            decrAlign();\n-            indent();\n-            append(\"}\\n\");\n-            decrAlign();\n-        });\n+        Constant functionDesc = constants().addFunctionDesc(fiDesc);\n+        Constant upcallHandle = constants().addUpcallMethodHandle(fullName(), \"apply\", fiDesc);\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" MemorySegment allocate(\" + className() + \" fi, Arena scope) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return RuntimeHelper.upcallStub(\" +\n+            upcallHandle.accessExpression() + \", fi, \" + functionDesc.accessExpression() + \", scope);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n@@ -116,2 +113,1 @@\n-        emitWithConstantClass(constantBuilder -> {\n-            Constant mhConstant = constantBuilder.addDowncallMethodHandle(className() + \"_DOWN\", className(),\n+        Constant mhConstant = constants().addDowncallMethodHandle(fullName(),\n@@ -119,43 +115,27 @@\n-            incrAlign();\n-            indent();\n-            append(MEMBER_MODS + \" \" + className() + \" ofAddress(MemorySegment addr, Arena arena) {\\n\");\n-            incrAlign();\n-            indent();\n-            append(\"MemorySegment symbol = addr.reinterpret(\");\n-            append(\"arena, null);\\n\");\n-            indent();\n-            append(\"return (\");\n-            String delim = \"\";\n-            for (int i = 0 ; i < fiType.parameterCount(); i++) {\n-                append(delim + fiType.parameterType(i).getName());\n-                append(\" \");\n-                append(\"_\" + parameterName(i));\n-                delim = \", \";\n-            }\n-            append(\") -> {\\n\");\n-            incrAlign();\n-            indent();\n-            append(\"try {\\n\");\n-            incrAlign();\n-            indent();\n-            if (!fiType.returnType().equals(void.class)) {\n-                append(\"return (\" + fiType.returnType().getName() + \")\");\n-                if (fiType.returnType() != downcallType.returnType()) {\n-                    \/\/ add cast for invokeExact\n-                    append(\"(\" + downcallType.returnType().getName() + \")\");\n-                }\n-            }\n-            append(mhConstant.accessExpression() + \".invokeExact(symbol\");\n-            if (fiType.parameterCount() > 0) {\n-                String params = IntStream.range(0, fiType.parameterCount())\n-                        .mapToObj(i -> {\n-                            String paramExpr = \"_\" + parameterName(i);\n-                            if (fiType.parameterType(i) != downcallType.parameterType(i)) {\n-                                \/\/ add cast for invokeExact\n-                                return \"(\" + downcallType.parameterType(i).getName() + \")\" + paramExpr;\n-                            } else {\n-                                return paramExpr;\n-                            }\n-                        })\n-                        .collect(Collectors.joining(\", \"));\n-                append(\", \" + params);\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \" + className() + \" ofAddress(MemorySegment addr, Arena arena) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"MemorySegment symbol = addr.reinterpret(\");\n+        append(\"arena, null);\\n\");\n+        indent();\n+        append(\"return (\");\n+        String delim = \"\";\n+        for (int i = 0 ; i < fiType.parameterCount(); i++) {\n+            append(delim + fiType.parameterType(i).getName());\n+            append(\" \");\n+            append(\"_\" + parameterName(i));\n+            delim = \", \";\n+        }\n+        append(\") -> {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"try {\\n\");\n+        incrAlign();\n+        indent();\n+        if (!fiType.returnType().equals(void.class)) {\n+            append(\"return (\" + fiType.returnType().getName() + \")\");\n+            if (fiType.returnType() != downcallType.returnType()) {\n+                \/\/ add cast for invokeExact\n+                append(\"(\" + downcallType.returnType().getName() + \")\");\n@@ -163,18 +143,33 @@\n-            append(\");\\n\");\n-            decrAlign();\n-            indent();\n-            append(\"} catch (Throwable ex$) {\\n\");\n-            incrAlign();\n-            indent();\n-            append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n-            decrAlign();\n-            indent();\n-            append(\"}\\n\");\n-            decrAlign();\n-            indent();\n-            append(\"};\\n\");\n-            decrAlign();\n-            indent();\n-            append(\"}\\n\");\n-            decrAlign();\n-        });\n+        }\n+        append(mhConstant.accessExpression() + \".invokeExact(symbol\");\n+        if (fiType.parameterCount() > 0) {\n+            String params = IntStream.range(0, fiType.parameterCount())\n+                    .mapToObj(i -> {\n+                        String paramExpr = \"_\" + parameterName(i);\n+                        if (fiType.parameterType(i) != downcallType.parameterType(i)) {\n+                            \/\/ add cast for invokeExact\n+                            return \"(\" + downcallType.parameterType(i).getName() + \")\" + paramExpr;\n+                        } else {\n+                            return paramExpr;\n+                        }\n+                    })\n+                    .collect(Collectors.joining(\", \"));\n+            append(\", \" + params);\n+        }\n+        append(\");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"} catch (Throwable ex$) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"};\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n@@ -183,3 +178,13 @@\n-    @Override\n-    protected void emitWithConstantClass(Consumer<ConstantBuilder> constantConsumer) {\n-        enclosing.emitWithConstantClass(constantConsumer);\n+    private String qualifiedName(ClassSourceBuilder builder) {\n+        if (builder.isNested()) {\n+            String prefix = qualifiedName((ClassSourceBuilder)builder.enclosing);\n+            return prefix.isEmpty() ?\n+                    builder.className() :\n+                    prefix + \"$\" + builder.className();\n+        } else {\n+            return \"\";\n+        }\n+    }\n+\n+    private String prefixName() {\n+        return qualifiedName(this) + \"$FI\";\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":89,"deletions":84,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-import org.openjdk.jextract.impl.ConstantBuilder.Constant;\n+import org.openjdk.jextract.impl.Constants.Constant;\n@@ -77,7 +77,5 @@\n-            emitWithConstantClass(constantBuilder -> {\n-                if (layout.byteSize() > 0) {\n-                    emitDocComment(varTree);\n-                    constantBuilder.addSegment(javaName, nativeName, layout)\n-                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n-                }\n-            });\n+            if (layout.byteSize() > 0) {\n+                emitDocComment(varTree);\n+                constants().addSegment(nativeName, layout)\n+                        .emitGetter(this, MEMBER_MODS, javaName, nativeName);\n+            };\n@@ -85,11 +83,10 @@\n-            emitWithConstantClass(constantBuilder -> {\n-                constantBuilder.addLayout(javaName, valueLayout)\n-                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME);\n-                Constant vhConstant = constantBuilder.addGlobalVarHandle(javaName, nativeName, valueLayout)\n-                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME);\n-                Constant segmentConstant = constantBuilder.addSegment(javaName, nativeName, valueLayout)\n-                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n-                emitDocComment(varTree, \"Getter for variable:\");\n-                emitGlobalGetter(segmentConstant, vhConstant, javaName, nativeName, valueLayout.carrier());\n-                emitDocComment(varTree, \"Setter for variable:\");\n-                emitGlobalSetter(segmentConstant, vhConstant, javaName, nativeName, valueLayout.carrier());\n+            constants().addLayout(valueLayout)\n+                    .emitGetter(this, MEMBER_MODS, javaName);\n+            Constant vhConstant = constants().addGlobalVarHandle(nativeName, valueLayout)\n+                    .emitGetter(this, MEMBER_MODS, javaName);\n+            Constant segmentConstant = constants().addSegment(nativeName, valueLayout)\n+                    .emitGetter(this, MEMBER_MODS, javaName, nativeName);\n+            emitDocComment(varTree, \"Getter for variable:\");\n+            emitGlobalGetter(segmentConstant, vhConstant, javaName, nativeName, valueLayout.carrier());\n+            emitDocComment(varTree, \"Setter for variable:\");\n+            emitGlobalSetter(segmentConstant, vhConstant, javaName, nativeName, valueLayout.carrier());\n@@ -97,4 +94,3 @@\n-                if (fiName.isPresent()) {\n-                    emitFunctionalInterfaceGetter(fiName.get(), javaName);\n-                }\n-            });\n+            if (fiName.isPresent()) {\n+                emitFunctionalInterfaceGetter(fiName.get(), javaName);\n+            }\n@@ -110,9 +106,7 @@\n-        emitWithConstantClass(constantBuilder -> {\n-            Constant mhConstant = constantBuilder.addDowncallMethodHandle(javaName, nativeName, descriptor, isVarargs, false)\n-                    .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n-            MethodType downcallType = descriptor.toMethodType();\n-            boolean needsAllocator = descriptor.returnLayout().isPresent() &&\n-                    descriptor.returnLayout().get() instanceof GroupLayout;\n-            emitDocComment(funcTree);\n-            emitFunctionWrapper(mhConstant, javaName, nativeName, downcallType, needsAllocator, isVarargs, parameterNames);\n-        });\n+        Constant mhConstant = constants().addDowncallMethodHandle(nativeName, descriptor, isVarargs, false)\n+                .emitGetter(this, MEMBER_MODS, javaName, nativeName);\n+        MethodType downcallType = descriptor.toMethodType();\n+        boolean needsAllocator = descriptor.returnLayout().isPresent() &&\n+                descriptor.returnLayout().get() instanceof GroupLayout;\n+        emitDocComment(funcTree);\n+        emitFunctionWrapper(mhConstant, javaName, nativeName, downcallType, needsAllocator, isVarargs, parameterNames);\n@@ -125,8 +119,2 @@\n-        if (javaType.equals(MemorySegment.class)) {\n-            emitWithConstantClass(constantBuilder -> {\n-                constantBuilder.addConstantDesc(javaName, javaType, value)\n-                        .emitGetter(this, MEMBER_MODS, Constant.JAVA_NAME);\n-            });\n-        } else {\n-            emitGetter(MEMBER_MODS, javaType, javaName, getConstantString(javaType, value));\n-        }\n+        constants().addConstantDesc(javaType, value)\n+                    .emitGetter(this, MEMBER_MODS, c -> javaName);\n@@ -153,1 +141,1 @@\n-        append(mhConstant.kind().fieldName(javaName));\n+        append(mhConstant.getterName(javaName));\n@@ -233,1 +221,1 @@\n-            append(toplevel().rootConstants().resolvePrimitiveLayout((ValueLayout)kind.layout().get()).accessExpression());\n+            append(constants().addLayout(kind.layout().get()).accessExpression());\n@@ -254,1 +242,1 @@\n-        append(toplevel().rootConstants().resolvePrimitiveLayout(TypeImpl.PointerImpl.POINTER_LAYOUT).accessExpression());\n+        append(constants().addLayout(TypeImpl.PointerImpl.POINTER_LAYOUT).accessExpression());\n@@ -266,35 +254,0 @@\n-    private String getConstantString(Class<?> type, Object value) {\n-        StringBuilder buf = new StringBuilder();\n-        if (type == float.class) {\n-            float f = ((Number)value).floatValue();\n-            if (Float.isFinite(f)) {\n-                buf.append(value);\n-                buf.append(\"f\");\n-            } else {\n-                buf.append(\"Float.valueOf(\\\"\");\n-                buf.append(value);\n-                buf.append(\"\\\")\");\n-            }\n-        } else if (type == long.class) {\n-            buf.append(value);\n-            buf.append(\"L\");\n-        } else if (type == double.class) {\n-            double d = ((Number)value).doubleValue();\n-            if (Double.isFinite(d)) {\n-                buf.append(value);\n-                buf.append(\"d\");\n-            } else {\n-                buf.append(\"Double.valueOf(\\\"\");\n-                buf.append(value);\n-                buf.append(\"\\\")\");\n-            }\n-        } else if (type == boolean.class) {\n-            boolean booleanValue = ((Number)value).byteValue() != 0;\n-            buf.append(booleanValue);\n-        } else {\n-            buf.append(\"(\" + type.getName() + \")\");\n-            buf.append(value + \"L\");\n-        }\n-        return buf.toString();\n-    }\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":32,"deletions":79,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.util.HashSet;\n@@ -38,2 +37,0 @@\n-import java.util.Set;\n-import java.util.function.Consumer;\n@@ -82,1 +79,1 @@\n-    abstract protected void emitWithConstantClass(Consumer<ConstantBuilder> constantConsumer);\n+    abstract protected Constants constants();\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/JavaSourceBuilder.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import java.lang.foreign.UnionLayout;\n@@ -36,0 +35,1 @@\n+import org.openjdk.jextract.impl.Constants.Constant;\n@@ -47,1 +47,1 @@\n-class StructBuilder extends ConstantBuilder {\n+class StructBuilder extends ClassSourceBuilder {\n@@ -55,0 +55,1 @@\n+    private Constant layoutConstant;\n@@ -58,1 +59,1 @@\n-        super(enclosing, name);\n+        super(enclosing, Kind.CLASS, name);\n@@ -87,2 +88,2 @@\n-            addLayout(layoutField(), ((Type.Declared) structType).tree().layout().orElseThrow())\n-                    .emitGetter(this, MEMBER_MODS, Constant.SUFFIX_ONLY);\n+            layoutConstant = constants().addLayout(((Type.Declared) structType).tree().layout().orElseThrow());\n+            layoutConstant.emitGetter(this, MEMBER_MODS, Constant::nameSuffix);\n@@ -155,2 +156,2 @@\n-            Constant vhConstant = addFieldVarHandle(javaName, nativeName, valueLayout, layoutField(), prefixNamesList())\n-                    .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME);\n+            Constant vhConstant = constants().addFieldVarHandle(nativeName, valueLayout, layoutConstant, prefixNamesList())\n+                    .emitGetter(this, MEMBER_MODS, javaName);\n@@ -333,16 +334,0 @@\n-\n-    private String qualifiedName(ClassSourceBuilder builder) {\n-        if (builder.isNested()) {\n-            String prefix = qualifiedName((ClassSourceBuilder)builder.enclosing);\n-            return prefix.isEmpty() ?\n-                    builder.className() :\n-                    prefix + \"$\" + builder.className();\n-        } else {\n-            return \"\";\n-        }\n-    }\n-\n-    private String layoutField() {\n-        String suffix = (structLayout instanceof UnionLayout) ? \"union\" : \"struct\";\n-        return qualifiedName(this) + \"$\" + suffix;\n-    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructBuilder.java","additions":9,"deletions":24,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -31,1 +30,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -34,2 +32,0 @@\n-import org.openjdk.jextract.Type.Primitive;\n-import org.openjdk.jextract.Type.Primitive.Kind;\n@@ -39,3 +35,3 @@\n-import java.util.*;\n-import java.util.function.Consumer;\n-import java.util.stream.Collectors;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n@@ -53,1 +49,0 @@\n-    private final RootConstants rootConstants;\n@@ -57,0 +52,2 @@\n+    Constants constants;\n+\n@@ -62,2 +59,0 @@\n-        rootConstants = new RootConstants();\n-        first.classBegin();\n@@ -65,4 +60,2 @@\n-    }\n-\n-    public RootConstants rootConstants() {\n-        return rootConstants;\n+        constants = new Constants(this);\n+        first.classBegin();\n@@ -72,3 +65,0 @@\n-        if (constantBuilder != null) {\n-            constantBuilder.classEnd();\n-        }\n@@ -76,2 +66,0 @@\n-        builders.addAll(constantBuilders);\n-        builders.add(rootConstants);\n@@ -81,0 +69,1 @@\n+        files.addAll(constants.toFiles());\n@@ -98,0 +87,5 @@\n+    @Override\n+    protected Constants constants() {\n+        return constants;\n+    }\n+\n@@ -220,118 +214,0 @@\n-\n-    \/\/ constant support\n-\n-    class RootConstants extends ConstantBuilder {\n-\n-        private final Map<ValueLayout, Constant> primitiveLayouts = new HashMap<>();\n-\n-        public RootConstants() {\n-            super(ToplevelBuilder.this, \"Constants$root\");\n-            classBegin();\n-            addPrimitiveLayout(\"C_BOOL\", Type.Primitive.Kind.Bool);\n-            addPrimitiveLayout(\"C_CHAR\", Type.Primitive.Kind.Char);\n-            addPrimitiveLayout(\"C_SHORT\", Type.Primitive.Kind.Short);\n-            addPrimitiveLayout(\"C_INT\", Type.Primitive.Kind.Int);\n-            addPrimitiveLayout(\"C_LONG\", Type.Primitive.Kind.Long);\n-            addPrimitiveLayout(\"C_LONG_LONG\", Type.Primitive.Kind.LongLong);\n-            addPrimitiveLayout(\"C_FLOAT\", Type.Primitive.Kind.Float);\n-            addPrimitiveLayout(\"C_DOUBLE\", Type.Primitive.Kind.Double);\n-            addPrimitiveLayout(\"C_POINTER\", TypeImpl.PointerImpl.POINTER_LAYOUT);\n-            classEnd();\n-        }\n-\n-        @Override\n-        String mods() {\n-            return \"final \"; \/\/ Constants$root package-private!\n-        }\n-\n-        @Override\n-        protected String primitiveLayoutString(ValueLayout vl) {\n-            if (vl.carrier() == boolean.class) {\n-                return \"JAVA_BOOLEAN\";\n-            } else if (vl.carrier() == char.class) {\n-                return \"JAVA_CHAR\" + withBitAlignmentIfNeeded(ValueLayout.JAVA_CHAR, vl);\n-            } else if (vl.carrier() == byte.class) {\n-                return \"JAVA_BYTE\";\n-            } else if (vl.carrier() == short.class) {\n-                return \"JAVA_SHORT\" + withBitAlignmentIfNeeded(ValueLayout.JAVA_SHORT, vl);\n-            } else if (vl.carrier() == int.class) {\n-                return \"JAVA_INT\" + withBitAlignmentIfNeeded(ValueLayout.JAVA_INT, vl);\n-            } else if (vl.carrier() == float.class) {\n-                return \"JAVA_FLOAT\" + withBitAlignmentIfNeeded(ValueLayout.JAVA_FLOAT, vl);\n-            } else if (vl.carrier() == long.class) {\n-                return \"JAVA_LONG\" + withBitAlignmentIfNeeded(ValueLayout.JAVA_LONG, vl);\n-            } else if (vl.carrier() == double.class) {\n-                return \"JAVA_DOUBLE\" + withBitAlignmentIfNeeded(ValueLayout.JAVA_DOUBLE, vl);\n-            } else if (vl.carrier() == MemorySegment.class) {\n-                return \"ADDRESS.withBitAlignment(\" + vl.bitAlignment() + \")\" +\n-                \".withTargetLayout(MemoryLayout.sequenceLayout(\" +\n-                        resolvePrimitiveLayout((ValueLayout)Primitive.Kind.Char.layout().get()).accessExpression() + \"))\";\n-            } else {\n-                return \"MemoryLayout.paddingLayout(\" + vl.bitSize() +  \")\";\n-            }\n-        }\n-\n-        String withBitAlignmentIfNeeded(ValueLayout original, ValueLayout actual) {\n-            if (original.bitAlignment() == actual.bitAlignment()) {\n-                return \"\";\n-            }\n-            return \".withBitAlignment(\" + actual.bitAlignment() + \")\";\n-        }\n-\n-        private Constant addPrimitiveLayout(String javaName, ValueLayout layout) {\n-            ValueLayout layoutNoName = normalize(layout);\n-            Constant layoutConstant = super.addLayout(javaName, layoutNoName);\n-            primitiveLayouts.put(layoutNoName, layoutConstant);\n-            return layoutConstant;\n-        }\n-\n-        private Constant addPrimitiveLayout(String javaName, Type.Primitive.Kind kind) {\n-            return addPrimitiveLayout(javaName, (ValueLayout)kind.layout().orElseThrow());\n-        }\n-\n-        public Constant resolvePrimitiveLayout(ValueLayout layout) {\n-            return primitiveLayouts.get(normalize(layout));\n-        }\n-\n-        public ValueLayout normalize(ValueLayout valueLayout) {\n-            return valueLayout\n-                    .withBitAlignment(valueLayout.bitSize()) \/\/ use natural alignment\n-                    .withoutName(); \/\/ drop name\n-        }\n-    }\n-\n-    \/\/ other constants\n-\n-    int constant_counter = 0;\n-    int constant_class_index = 0;\n-    List<ConstantBuilder> constantBuilders = new ArrayList<>();\n-\n-    static final int CONSTANTS_PER_CLASS = Integer.getInteger(\"jextract.constants.per.class\", 5);\n-    ConstantBuilder constantBuilder;\n-\n-    protected void emitWithConstantClass(Consumer<ConstantBuilder> constantConsumer) {\n-        if (constant_counter > CONSTANTS_PER_CLASS || constantBuilder == null) {\n-            if (constantBuilder != null) {\n-                constantBuilder.classEnd();\n-            }\n-            constant_counter = 0;\n-            constantBuilder = new ConstantsSequelBuilder(this, \"constants$\" + constant_class_index++);\n-            constantBuilders.add(constantBuilder);\n-            constantBuilder.classBegin();\n-        }\n-        constantConsumer.accept(constantBuilder);\n-        constant_counter++;\n-    }\n-\n-    static final class ConstantsSequelBuilder extends ConstantBuilder {\n-\n-        ConstantsSequelBuilder(JavaSourceBuilder enclosing, String className) {\n-            super(enclosing, className);\n-        }\n-\n-        @Override\n-        String mods() {\n-            return \"final \"; \/\/ constants package-private!\n-        }\n-    }\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ToplevelBuilder.java","additions":14,"deletions":138,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -22,0 +22,3 @@\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.MemoryLayout;\n+\n@@ -32,0 +35,1 @@\n+    static final AddressLayout POINTER = ValueLayout.ADDRESS.withTargetLayout(MemoryLayout.sequenceLayout(JAVA_BYTE));\n","filename":"src\/main\/resources\/org\/openjdk\/jextract\/impl\/resources\/RuntimeHelper.java.template","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}