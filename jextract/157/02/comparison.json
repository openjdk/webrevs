{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.FunctionDescriptor;\n@@ -34,1 +33,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -465,24 +463,0 @@\n-    \/**\n-     * Compute the layout for a given declaration.\n-     * @param d the declaration.\n-     * @return the layout for given declaration.\n-     *\/\n-    static Optional<MemoryLayout> layoutFor(Declaration d) {\n-        return switch (d) {\n-            case Scoped scoped -> DeclarationImpl.layoutFor(scoped);\n-            case Variable var -> Type.layoutFor(var.type());\n-            case Typedef typedef -> Type.layoutFor(typedef.type());\n-            case Constant constant -> Type.layoutFor(constant.type());\n-            default -> Optional.empty();\n-        };\n-    }\n-\n-    \/**\n-     * Compute the function descriptor for a given function declaration.\n-     * @param function the function declaration.\n-     * @return the function descriptor for given function declaration.\n-     *\/\n-    static Optional<FunctionDescriptor> descriptorFor(Function function) {\n-        return Type.descriptorFor(function.type());\n-    }\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Declaration.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemoryLayout;\n@@ -379,18 +377,0 @@\n-    \/**\n-     * Compute the layout for a given type.\n-     * @param t the type.\n-     * @return the layout for given type.\n-     *\/\n-    static Optional<MemoryLayout> layoutFor(Type t) {\n-        return TypeImpl.getLayout(t);\n-    }\n-\n-    \/**\n-     * Compute the function descriptor for a given function type.\n-     * @param function the function type.\n-     * @return the function descriptor for given function type.\n-     *\/\n-    static Optional<FunctionDescriptor> descriptorFor(Function function) {\n-        return TypeImpl.getDescriptor(function);\n-    }\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Type.java","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jextract.Declaration.Constant;\n+import org.openjdk.jextract.Declaration.Scoped;\n@@ -29,0 +31,6 @@\n+import org.openjdk.jextract.Type.Array;\n+import org.openjdk.jextract.Type.Declared;\n+import org.openjdk.jextract.Type.Delegated;\n+import org.openjdk.jextract.Type.Function;\n+import org.openjdk.jextract.Type.Primitive;\n+import org.openjdk.jextract.impl.DeclarationImpl.JavaName;\n@@ -31,1 +39,0 @@\n-import java.lang.foreign.GroupLayout;\n@@ -34,3 +41,0 @@\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.StructLayout;\n-import java.lang.foreign.ValueLayout;\n@@ -38,0 +42,1 @@\n+import java.lang.invoke.MethodType;\n@@ -210,38 +215,2 @@\n-    String layoutString(int textBoxIndent, MemoryLayout l) {\n-        StringBuilder builder = new StringBuilder();\n-        layoutString(textBoxIndent, builder, l);\n-        return builder.toString();\n-    }\n-\n-    private void layoutString(int textBoxIndent, StringBuilder builder, MemoryLayout l) {\n-        String indent = indentString(textBoxIndent);\n-        if (l instanceof ValueLayout val) {\n-            builder.append(STR.\"\\{indent}\\{valueLayoutString(val)}\");\n-            if (l.byteAlignment() != l.byteSize()) {\n-                builder.append(STR.\"\\{indent}.withByteAlignment(\\{l.byteAlignment()})\");\n-            }\n-        } else if (l instanceof SequenceLayout seq) {\n-            builder.append(STR.\"\\{indent}MemoryLayout.sequenceLayout(\\{seq.elementCount()}, \");\n-            layoutString(textBoxIndent + 1, builder, seq.elementLayout());\n-            builder.append(STR.\"\\{indent})\");\n-        } else if (l instanceof GroupLayout group) {\n-            if (group instanceof StructLayout) {\n-                builder.append(STR.\"\\{indent}MemoryLayout.structLayout(\\n\");\n-            } else {\n-                builder.append(STR.\"\\{indent}MemoryLayout.unionLayout(\\n\");\n-            }\n-            String delim = \"\";\n-            for (MemoryLayout e : group.memberLayouts()) {\n-                builder.append(delim);\n-                layoutString(textBoxIndent + 1, builder, e);\n-                delim = \",\\n\";\n-            }\n-            builder.append(\"\\n\");\n-            builder.append(STR.\"\\{indent})\");\n-        } else {\n-            \/\/ padding (or unsupported)\n-            builder.append(STR.\"\\{indent}MemoryLayout.paddingLayout(\\{l.byteSize()})\");\n-        }\n-        if (l.name().isPresent()) {\n-            builder.append(STR.\".withName(\\\"\\{l.name().get()}\\\")\");\n-        }\n+    String layoutString(Type type) {\n+        return layoutString(type, Long.MAX_VALUE);\n@@ -250,2 +219,11 @@\n-    private static String indentString(int size) {\n-        return \" \".repeat(size * 4);\n+    String layoutString(Type type, long align) {\n+        return switch (type) {\n+            case Primitive p -> primitiveLayoutString(p, align);\n+            case Declared d when Utils.isEnum(d) -> layoutString(((Constant)d.tree().members().get(0)).type(), align);\n+            case Declared d when Utils.isStructOrUnion(d) -> STR.\"\\{JavaName.getFullNameOrThrow(d.tree())}.$LAYOUT()\";\n+            case Delegated d when d.kind() == Delegated.Kind.POINTER -> STR.\"\\{runtimeHelperName()}.C_POINTER\";\n+            case Delegated d -> layoutString(d.type(), align);\n+            case Function _ -> STR.\"\\{runtimeHelperName()}.C_POINTER\";\n+            case Array a -> STR.\"MemoryLayout.sequenceLayout(\\{a.elementCount().orElse(0L)}, \\{layoutString(a.elementType(), align)})\";\n+            default -> throw new UnsupportedOperationException();\n+        };\n@@ -254,26 +232,3 @@\n-    private String valueLayoutString(ValueLayout vl) {\n-        if (vl.carrier() == boolean.class) {\n-            return \"JAVA_BOOLEAN\";\n-        } else if (vl.carrier() == char.class) {\n-            return \"JAVA_CHAR\";\n-        } else if (vl.carrier() == byte.class) {\n-            return \"JAVA_BYTE\";\n-        } else if (vl.carrier() == short.class) {\n-            return \"JAVA_SHORT\";\n-        } else if (vl.carrier() == int.class) {\n-            return \"JAVA_INT\";\n-        } else if (vl.carrier() == float.class) {\n-            return \"JAVA_FLOAT\";\n-        } else if (vl.carrier() == long.class) {\n-            return \"JAVA_LONG\";\n-        } else if (vl.carrier() == double.class) {\n-            return \"JAVA_DOUBLE\";\n-        } else if (vl.carrier() == MemorySegment.class) {\n-            return STR.\"\\{runtimeHelperName}.C_POINTER\";\n-        } else {\n-            throw new UnsupportedOperationException(\"Unsupported layout: \" + vl);\n-        }\n-    }\n-\n-    public String descriptorString(int textBoxIndent, FunctionDescriptor desc) {\n-        final boolean noArgs = desc.argumentLayouts().isEmpty();\n+    String functionDescriptorString(int textBoxIndent, Type.Function functionType) {\n+        final MethodType type = Utils.methodTypeFor(functionType);\n+        boolean noArgs = type.parameterCount() == 0;\n@@ -281,1 +236,1 @@\n-        if (desc.returnLayout().isPresent()) {\n+        if (!type.returnType().equals(void.class)) {\n@@ -284,1 +239,1 @@\n-            layoutString(textBoxIndent + 1, builder, desc.returnLayout().get());\n+            builder.append(STR.\"\\{indentString(textBoxIndent + 1)}\\{layoutString(functionType.returnType())}\");\n@@ -294,1 +249,1 @@\n-            for (MemoryLayout e : desc.argumentLayouts()) {\n+            for (Type arg : functionType.argumentTypes()) {\n@@ -296,1 +251,1 @@\n-                layoutString(textBoxIndent + 1, builder, e);\n+                builder.append(STR.\"\\{indentString(textBoxIndent + 1)}\\{layoutString(arg)}\");\n@@ -304,0 +259,33 @@\n+\n+    String indentString(int size) {\n+        return \" \".repeat(size * 4);\n+    }\n+\n+    private String primitiveLayoutString(Primitive primitiveType, long align) {\n+        return switch (primitiveType.kind()) {\n+            case Bool -> STR.\"\\{runtimeHelperName()}.C_BOOL\";\n+            case Char -> STR.\"\\{runtimeHelperName()}.C_CHAR\";\n+            case Short -> alignIfNeeded(STR.\"\\{runtimeHelperName()}.C_SHORT\", 2, align);\n+            case Int -> alignIfNeeded(STR.\"\\{runtimeHelperName()}.C_INT\", 4, align);\n+            case Long -> alignIfNeeded(STR.\"\\{runtimeHelperName()}.C_LONG\", TypeImpl.IS_WINDOWS ? 4 : 8, align);\n+            case LongLong -> alignIfNeeded(STR.\"\\{runtimeHelperName()}.C_LONG_LONG\", 8, align);\n+            case Float -> alignIfNeeded(STR.\"\\{runtimeHelperName()}.C_FLOAT\", 4, align);\n+            case Double -> alignIfNeeded(STR.\"\\{runtimeHelperName()}.C_DOUBLE\", 8, align);\n+            case LongDouble -> TypeImpl.IS_WINDOWS ?\n+                    alignIfNeeded(STR.\"\\{runtimeHelperName()}.C_LONG_DOUBLE\", 8, align) :\n+                    paddingLayoutString(8);\n+            case HalfFloat, Char16, WChar -> paddingLayoutString(2); \/\/ unsupported\n+            case Float128, Int128 -> paddingLayoutString(16); \/\/ unsupported\n+            default -> throw new UnsupportedOperationException(primitiveType.toString());\n+        };\n+    }\n+\n+    private String alignIfNeeded(String layoutPrefix, long align, long expectedAlign) {\n+        return align > expectedAlign ?\n+                STR.\"\\{layoutPrefix}.withByteAlignment(\\{expectedAlign})\" :\n+                layoutPrefix;\n+    }\n+\n+    String paddingLayoutString(long size) {\n+        return STR.\"MemoryLayout.paddingLayout(\\{size})\";\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ClassSourceBuilder.java","additions":62,"deletions":74,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import java.lang.foreign.AddressLayout;\n-import java.lang.foreign.GroupLayout;\n@@ -32,3 +30,0 @@\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.StructLayout;\n-import java.util.ArrayList;\n@@ -44,1 +39,0 @@\n-import org.openjdk.jextract.Declaration.Scoped.Kind;\n@@ -331,92 +325,1 @@\n-    public static Optional<MemoryLayout> layoutFor(Scoped scoped) {\n-        Optional<MemoryLayout> layout = ScopedLayout.get(scoped);\n-        if (layout.isPresent()) {\n-            return layout;\n-        } else {\n-            \/\/ compute and cache for later use\n-            switch (scoped.kind()) {\n-                case Kind.STRUCT, Kind.UNION -> {\n-                    if (ClangSizeOf.get(scoped).isPresent()) {\n-                        Optional<MemoryLayout> recordLayout = recordLayout(scoped);\n-                        recordLayout.ifPresent(memoryLayout -> ScopedLayout.with(scoped, memoryLayout));\n-                        return recordLayout;\n-                    }\n-                }\n-                case Kind.ENUM -> {\n-                    Optional<MemoryLayout> constLayout = Type.layoutFor(((Constant)scoped.members().get(0)).type());\n-                    constLayout.ifPresent(memoryLayout -> ScopedLayout.with(scoped, memoryLayout));\n-                    return constLayout;\n-                }\n-            }\n-            return Optional.empty();\n-        }\n-    }\n-\n-    \/\/ Note: this method always returns the same result when called on the same tree. More specifically,\n-    \/\/ even if a client calls this method on a nested anonymous struct, the nested layout is computed\n-    \/\/ correctly, as if it was computed as part of the enclosing non-anonymous struct. This ensures maximum\n-    \/\/ flexibility, as there is no specific order in which clients should obtain layouts for scoped declarations.\n-    private static Optional<MemoryLayout> recordLayout(Scoped scoped) {\n-        boolean isStruct = scoped.kind() == Kind.STRUCT;\n-\n-        long offset = 0;\n-        if (AnonymousStruct.isPresent(scoped)) {\n-            \/\/ find the starting offset of this anon declaration inside its\n-            \/\/ innermost non-anonymous container\n-            OptionalLong firstOffset = nextOffset(scoped);\n-            if (firstOffset.isEmpty()) {\n-                return Optional.empty();\n-            }\n-            offset = firstOffset.getAsLong();\n-        }\n-\n-        long size = 0L; \/\/ bits\n-        List<MemoryLayout> memberLayouts = new ArrayList<>();\n-        for (Declaration member : scoped.members()) {\n-            if (member instanceof Scoped nested && nested.kind() == Kind.BITFIELDS) {\n-                \/\/ skip\n-            } else if (nextOffset(member).isPresent()) {\n-                long nextOffset = nextOffset(member).getAsLong();\n-                long delta = nextOffset - offset;\n-                if (delta > 0) {\n-                    memberLayouts.add(MemoryLayout.paddingLayout(delta \/ 8));\n-                    offset += delta;\n-                    if (isStruct) {\n-                        size += delta;\n-                    }\n-                }\n-                Optional<MemoryLayout> layout = Declaration.layoutFor(member);\n-                if (layout.isPresent()) {\n-                    MemoryLayout memberLayout = layout.get();\n-                    if (member instanceof Variable) {\n-                        memberLayout = memberLayout.withName(member.name());\n-                    }\n-                    memberLayouts.add(memberLayout);\n-                    \/\/ update offset and size\n-                    long fieldSize = ClangSizeOf.getOrThrow(member);\n-                    if (isStruct) {\n-                        offset += fieldSize;\n-                        size += fieldSize;\n-                    } else {\n-                        size = Math.max(size, ClangSizeOf.getOrThrow(member));\n-                    }\n-                }\n-            }\n-        }\n-        long expectedSize = ClangSizeOf.getOrThrow(scoped);\n-        if (size != expectedSize) {\n-            memberLayouts.add(MemoryLayout.paddingLayout((expectedSize - size) \/ 8));\n-        }\n-        long align = ClangAlignOf.getOrThrow(scoped) \/ 8;\n-        GroupLayout layout = isStruct ?\n-                MemoryLayout.structLayout(alignFields(memberLayouts, align)) :\n-                MemoryLayout.unionLayout(alignFields(memberLayouts, align));\n-\n-        \/\/ the name is only useful for clients accessing the layout, jextract doesn't care about it\n-        String name = scoped.name().isEmpty() ?\n-                AnonymousStruct.anonName(scoped) :\n-                scoped.name();\n-        return Optional.of(layout.withName(name));\n-    }\n-\n-    public static OptionalLong nextOffset(Declaration member) {\n+    public static OptionalLong recordMemberOffset(Declaration member) {\n@@ -429,1 +332,1 @@\n-                    nextOffset(firstDecl.get());\n+                    recordMemberOffset(firstDecl.get());\n@@ -433,33 +336,0 @@\n-    private static MemoryLayout[] alignFields(List<MemoryLayout> members, long align) {\n-        return members.stream()\n-                .map(l -> forceAlign(l, align))\n-                .toArray(MemoryLayout[]::new);\n-    }\n-\n-    private static MemoryLayout forceAlign(MemoryLayout layout, long align) {\n-        if (align >= layout.byteAlignment()) {\n-            return layout; \/\/ fast-path\n-        }\n-        MemoryLayout res = switch (layout) {\n-            case GroupLayout groupLayout -> {\n-                MemoryLayout[] newMembers = groupLayout.memberLayouts()\n-                        .stream().map(l -> forceAlign(l, align)).toArray(MemoryLayout[]::new);\n-                yield groupLayout instanceof StructLayout ?\n-                        MemoryLayout.structLayout(newMembers) :\n-                        MemoryLayout.unionLayout(newMembers);\n-            }\n-            case SequenceLayout sequenceLayout ->\n-                    MemoryLayout.sequenceLayout(sequenceLayout.elementCount(),\n-                            forceAlign(sequenceLayout.elementLayout(), align));\n-            default -> layout.withByteAlignment(align);\n-        };\n-        \/\/ copy name and target layout, if present\n-        if (layout.name().isPresent()) {\n-            res = res.withName(layout.name().get());\n-        }\n-        if (layout instanceof AddressLayout addressLayout && addressLayout.targetLayout().isPresent()) {\n-            ((AddressLayout)res).withTargetLayout(addressLayout.targetLayout().get());\n-        }\n-        return res;\n-    }\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/DeclarationImpl.java","additions":2,"deletions":132,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -49,2 +49,1 @@\n-        boolean isEnum = scoped.kind() == Declaration.Scoped.Kind.ENUM;\n-        if (isEnum) {\n+        if (Utils.isEnum(scoped)) {\n@@ -63,6 +62,4 @@\n-        if (type instanceof Type.Declared declared) {\n-            if (declared.tree().kind() == Kind.ENUM) {\n-                \/\/ no need to do anything for a typedef enum, as the IR always\n-                \/\/ lifts the enum tree before the typedef.\n-                Skip.with(tree);\n-            }\n+        if (type instanceof Type.Declared declared && Utils.isEnum(declared)) {\n+            \/\/ no need to do anything for a typedef enum, as the IR always\n+            \/\/ lifts the enum tree before the typedef.\n+            Skip.with(tree);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/EnumConstantLifter.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.lang.foreign.*;\n-\n@@ -139,1 +137,0 @@\n-        FunctionDescriptor descriptor = Type.descriptorFor(funcType).get();\n@@ -141,1 +138,1 @@\n-            FunctionDescriptor $DESC = \\{descriptorString(0, descriptor)};\n+            FunctionDescriptor $DESC = \\{functionDescriptorString(0, funcType)};\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n@@ -33,2 +31,0 @@\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.ValueLayout;\n@@ -151,1 +147,0 @@\n-        FunctionDescriptor descriptor = Declaration.descriptorFor(decl).get();\n@@ -158,1 +153,1 @@\n-                        static final FunctionDescriptor DESC = \\{descriptorString(2, descriptor)};\n+                        static final FunctionDescriptor DESC = \\{functionDescriptorString(2, decl.type())};\n@@ -189,1 +184,1 @@\n-                    FunctionDescriptor baseDesc$ = \\{descriptorString(2, descriptor)};\n+                    FunctionDescriptor baseDesc$ = \\{functionDescriptorString(2, decl.type())};\n@@ -223,4 +218,0 @@\n-    void emitPrimitiveTypedef(Type.Primitive primType, String name) {\n-        emitPrimitiveTypedef(null, primType, name);\n-    }\n-\n@@ -352,1 +343,0 @@\n-        MemoryLayout layout = Type.layoutFor(varType).get();\n@@ -354,1 +344,1 @@\n-            private static final MemoryLayout \\{mangledName} = \\{layoutString(0, layout)};\n+            private static final MemoryLayout \\{mangledName} = \\{layoutString(varType)};\n@@ -438,1 +428,0 @@\n-        MemoryLayout layout = Type.layoutFor(type).get();\n@@ -440,1 +429,1 @@\n-        public static final \\{Utils.valueLayoutCarrierFor(type).getSimpleName()} \\{javaName} = \\{layoutString(0, layout)};\n+        public static final \\{Utils.valueLayoutCarrierFor(type).getSimpleName()} \\{javaName} = \\{layoutString(type)};\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -27,4 +27,0 @@\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.ValueLayout;\n@@ -32,0 +28,2 @@\n+import org.openjdk.jextract.Declaration.Scoped;\n+import org.openjdk.jextract.Declaration.Variable;\n@@ -33,0 +31,1 @@\n+import org.openjdk.jextract.Type.Declared;\n@@ -34,0 +33,1 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.ClangAlignOf;\n@@ -39,0 +39,1 @@\n+import java.util.ArrayList;\n@@ -40,0 +41,1 @@\n+import java.util.List;\n@@ -41,0 +43,1 @@\n+import java.util.stream.Collectors;\n@@ -164,1 +167,0 @@\n-        MemoryLayout layout = Type.layoutFor(varType).get();\n@@ -167,1 +169,1 @@\n-                return \\{seg}.get(\\{layoutString(0, layout)}, \\{offsetField});\n+                return \\{seg}.get(\\{layoutString(varType)}, \\{offsetField});\n@@ -176,1 +178,0 @@\n-        MemoryLayout layout = Type.layoutFor(varType).get();\n@@ -179,1 +180,1 @@\n-                \\{seg}.set(\\{layoutString(1, layout)}, \\{offsetField}, \\{x});\n+                \\{seg}.set(\\{layoutString(varType)}, \\{offsetField}, \\{x});\n@@ -225,1 +226,0 @@\n-        MemoryLayout layout = Type.layoutFor(varType).get();\n@@ -228,1 +228,1 @@\n-                return \\{seg}.get(\\{layoutString(1, layout)}, \\{offsetField} + (\\{index} * sizeof()));\n+                return \\{seg}.get(\\{layoutString(varType)}, \\{offsetField} + (\\{index} * sizeof()));\n@@ -238,1 +238,0 @@\n-        MemoryLayout layout = Type.layoutFor(varType).get();\n@@ -241,1 +240,1 @@\n-                \\{seg}.set(\\{layoutString(1, layout)}, \\{offsetField} + (\\{index} * sizeof()), \\{x});\n+                \\{seg}.set(\\{layoutString(varType)}, \\{offsetField} + (\\{index} * sizeof()), \\{x});\n@@ -247,1 +246,0 @@\n-        MemoryLayout structLayout = Type.layoutFor(structType).get();\n@@ -249,1 +247,1 @@\n-            private static final MemoryLayout $LAYOUT = \\{layoutString(0, structLayout)};\n+            private static final MemoryLayout $LAYOUT = \\{structOrUnionLayoutString(structType)};\n@@ -272,0 +270,68 @@\n+\n+    private String structOrUnionLayoutString(Type type) {\n+        return switch (type) {\n+            case Declared d when Utils.isStructOrUnion(type) -> structOrUnionLayoutString(0, d.tree());\n+            default -> throw new UnsupportedOperationException(type.toString());\n+        };\n+    }\n+\n+    private String structOrUnionLayoutString(long base, Declaration.Scoped scoped) {\n+        List<String> memberLayouts = new ArrayList<>();\n+\n+        boolean isStruct = scoped.kind() == Scoped.Kind.STRUCT;\n+\n+        long align = ClangAlignOf.getOrThrow(scoped) \/ 8;\n+        long offset = base;\n+\n+        long size = 0L; \/\/ bits\n+        for (Declaration member : scoped.members()) {\n+            if (member instanceof Scoped nested && nested.kind() == Scoped.Kind.BITFIELDS) {\n+                \/\/ skip\n+            } else {\n+                long nextOffset = DeclarationImpl.recordMemberOffset(member).getAsLong();\n+                long delta = nextOffset - offset;\n+                if (delta > 0) {\n+                    memberLayouts.add(paddingLayoutString(delta \/ 8));\n+                    offset += delta;\n+                    if (isStruct) {\n+                        size += delta;\n+                    }\n+                }\n+                String memberLayout;\n+                if (member instanceof Variable var) {\n+                    memberLayout = layoutString(var.type(), align);\n+                    memberLayout = STR.\"\\{memberLayout}.withName(\\\"\\{member.name()}\\\")\";\n+                } else {\n+                    \/\/ anon struct\n+                    memberLayout = structOrUnionLayoutString(offset, (Scoped) member);\n+                }\n+                if ((ClangAlignOf.getOrThrow(member) \/ 8) > align) {\n+                    memberLayout = STR.\"\\{memberLayout}.withByteAlignment(\\{align})\";\n+                }\n+                memberLayouts.add(memberLayout);\n+                \/\/ update offset and size\n+                long fieldSize = ClangSizeOf.getOrThrow(member);\n+                if (isStruct) {\n+                    offset += fieldSize;\n+                    size += fieldSize;\n+                } else {\n+                    size = Math.max(size, ClangSizeOf.getOrThrow(member));\n+                }\n+            }\n+        }\n+        long expectedSize = ClangSizeOf.getOrThrow(scoped);\n+        if (size != expectedSize) {\n+            memberLayouts.add(paddingLayoutString((expectedSize - size) \/ 8));\n+        }\n+\n+        String indentNewLine = STR.\"\\n\\{indentString(1)}\";\n+        String prefix = isStruct ? \"MemoryLayout.structLayout(\" :\n+                \"MemoryLayout.unionLayout(\";\n+        String layoutString = memberLayouts.stream()\n+                .collect(Collectors.joining(\",\" + indentNewLine, prefix + indentNewLine, \"\\n)\"));\n+\n+        \/\/ the name is only useful for clients accessing the layout, jextract doesn't care about it\n+        String name = scoped.name().isEmpty() ?\n+                AnonymousStruct.anonName(scoped) : scoped.name();\n+        return STR.\"\\{layoutString}.withName(\\\"\\{name}\\\")\";\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructBuilder.java","additions":80,"deletions":14,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -27,3 +27,0 @@\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n@@ -66,11 +63,10 @@\n-        first.emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Bool), \"C_BOOL\");\n-        first.emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Char), \"C_CHAR\");\n-        first.emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Short), \"C_SHORT\");\n-        first.emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Int), \"C_INT\");\n-        first.emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Long), \"C_LONG\");\n-        first.emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.LongLong), \"C_LONG_LONG\");\n-        first.emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Float), \"C_FLOAT\");\n-        first.emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Double), \"C_DOUBLE\");\n-\n-        \/\/ we don't use 'emitPrimitiveTypedef' so we can attach the target layout\n-        first.appendIndentedLines(\"\"\"\n+        String longType = TypeImpl.IS_WINDOWS ? \"INT\" : \"LONG\";\n+        first.appendIndentedLines(STR.\"\"\"\n+            public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+            public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+            public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n+            public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+            public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_\\{longType};\n+            public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n+            public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n+            public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n@@ -80,0 +76,3 @@\n+        if (TypeImpl.IS_WINDOWS) {\n+            first.appendIndentedLines(\"public static final AddressLayout C_LONG_DOUBLE = ValueLayout.JAVA_DOUBLE;\");\n+        }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ToplevelBuilder.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -65,0 +65,6 @@\n+    record CursorKey(Position position, String spelling) {\n+        static CursorKey of(Cursor cursor) {\n+            return new CursorKey(CursorPosition.of(cursor), cursor.spelling());\n+        }\n+    }\n+\n@@ -66,1 +72,1 @@\n-    private final Map<Position, Declaration> declarationCache = new HashMap<>();\n+    private final Map<CursorKey, Declaration> declarationCache = new HashMap<>();\n@@ -87,2 +93,2 @@\n-    public Optional<Declaration> lookup(Position pos) {\n-        Declaration declaration = declarationCache.get(pos);\n+    public Optional<Declaration> lookup(CursorKey key) {\n+        Declaration declaration = declarationCache.get(key);\n@@ -90,1 +96,1 @@\n-                parent.lookup(pos) :\n+                parent.lookup(key) :\n@@ -128,1 +134,2 @@\n-        Optional<Declaration> cachedDecl = lookup(pos);\n+        CursorKey key = CursorKey.of(c);\n+        Optional<Declaration> cachedDecl = lookup(key);\n@@ -144,2 +151,2 @@\n-        if (decl != null && pos != Position.NO_POSITION) {\n-            declarationCache.put(pos, decl);\n+        if (decl != null) {\n+            declarationCache.put(key, decl);\n@@ -287,0 +294,1 @@\n+                        ClangAlignOf.with(fieldDecl, fc.type().align() * 8);\n@@ -290,0 +298,3 @@\n+            } else {\n+                \/\/ propagate\n+                createTree(fc);\n@@ -329,5 +340,0 @@\n-    private static boolean isEnum(Declaration d) {\n-        return d instanceof Declaration.Scoped scoped &&\n-                scoped.kind() == Declaration.Scoped.Kind.ENUM;\n-    }\n-\n@@ -348,1 +354,1 @@\n-                .filter(d -> isEnum(d) || (!d.name().isEmpty() && !isRedundantTypedef(d)))\n+                .filter(d -> Utils.isEnum(d) || (!d.name().isEmpty() && !isRedundantTypedef(d)))\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeMaker.java","additions":19,"deletions":13,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.lang.foreign.FunctionDescriptor;\n@@ -376,110 +375,0 @@\n-\n-    \/\/ Utilities to fetch layouts\/descriptor from types\n-\n-    public static Optional<MemoryLayout> getLayout(org.openjdk.jextract.Type t) {\n-        try {\n-            return Optional.of(getLayoutInternal(t));\n-        } catch (UnsupportedOperationException ex) {\n-            return Optional.empty();\n-        }\n-    }\n-\n-    public static Optional<FunctionDescriptor> getDescriptor(Function t) {\n-        try {\n-            MemoryLayout[] args = t.argumentTypes().stream()\n-                    .map(TypeImpl::getLayoutInternal)\n-                    .toArray(MemoryLayout[]::new);\n-            Type retType = t.returnType();\n-            if (isVoidType(retType)) {\n-                return Optional.of(FunctionDescriptor.ofVoid(args));\n-            } else {\n-                return Optional.of(FunctionDescriptor.of(getLayoutInternal(retType), args));\n-            }\n-        } catch (UnsupportedOperationException ex) {\n-            return Optional.empty();\n-        }\n-    }\n-\n-    private static boolean isVoidType(org.openjdk.jextract.Type type) {\n-        if (type instanceof org.openjdk.jextract.Type.Primitive pt) {\n-            return pt.kind() == org.openjdk.jextract.Type.Primitive.Kind.Void;\n-        } else if (type instanceof org.openjdk.jextract.Type.Delegated dt) {\n-            return dt.kind() == org.openjdk.jextract.Type.Delegated.Kind.TYPEDEF? isVoidType(dt.type()) : false;\n-        }\n-        return false;\n-    }\n-\n-    public static MemoryLayout getLayoutInternal(org.openjdk.jextract.Type t) {\n-        return t.accept(layoutMaker, null);\n-    }\n-\n-    private static org.openjdk.jextract.Type.Visitor<MemoryLayout, Void> layoutMaker = new org.openjdk.jextract.Type.Visitor<>() {\n-        @Override\n-        public MemoryLayout visitPrimitive(org.openjdk.jextract.Type.Primitive t, Void _ignored) {\n-            return switch (t.kind()) {\n-                case Void -> throw new UnsupportedOperationException();\n-                case Bool -> ValueLayout.JAVA_BOOLEAN;\n-                case Char -> ValueLayout.JAVA_BYTE;\n-                case Char16 -> unsupportedLayout(2, t);\n-                case Short -> ValueLayout.JAVA_SHORT;\n-                case Int -> ValueLayout.JAVA_INT;\n-                case Long -> TypeImpl.IS_WINDOWS ?\n-                        ValueLayout.JAVA_INT :\n-                        ValueLayout.JAVA_LONG;\n-                case LongLong -> ValueLayout.JAVA_LONG;\n-                case Int128 -> unsupportedLayout(16, t);\n-                case Float -> ValueLayout.JAVA_FLOAT;\n-                case Double -> ValueLayout.JAVA_DOUBLE;\n-                case LongDouble -> TypeImpl.IS_WINDOWS ?\n-                        ValueLayout.JAVA_DOUBLE :\n-                        unsupportedLayout(16, t);\n-                case Float128 -> unsupportedLayout(16, t);\n-                case HalfFloat -> unsupportedLayout(2, t);\n-                case WChar -> unsupportedLayout(2, t);\n-            };\n-        }\n-\n-        private MemoryLayout unsupportedLayout(long size, Type.Primitive t) {\n-            return MemoryLayout.paddingLayout(size).withByteAlignment(size).withName(t.kind().typeName());\n-        }\n-\n-        @Override\n-        public MemoryLayout visitDelegated(org.openjdk.jextract.Type.Delegated t, Void _ignored) {\n-            if (t.kind() == org.openjdk.jextract.Type.Delegated.Kind.POINTER) {\n-                return PointerImpl.POINTER_LAYOUT;\n-            } else {\n-                return t.type().accept(this, null);\n-            }\n-        }\n-\n-        @Override\n-        public MemoryLayout visitFunction(org.openjdk.jextract.Type.Function t, Void _ignored) {\n-            \/*\n-             * \/\/ pointer to function declared as function like this\n-             *\n-             * typedef void CB(int);\n-             * void func(CB cb);\n-             *\/\n-            return PointerImpl.POINTER_LAYOUT;\n-        }\n-\n-        @Override\n-        public MemoryLayout visitDeclared(org.openjdk.jextract.Type.Declared t, Void _ignored) {\n-            return Declaration.layoutFor(t.tree()).orElseThrow(UnsupportedOperationException::new);\n-        }\n-\n-        @Override\n-        public MemoryLayout visitArray(org.openjdk.jextract.Type.Array t, Void _ignored) {\n-            MemoryLayout elem = t.elementType().accept(this, null);\n-            if (t.elementCount().isPresent()) {\n-                return MemoryLayout.sequenceLayout(t.elementCount().getAsLong(), elem);\n-            } else {\n-                return MemoryLayout.sequenceLayout(0, elem);\n-            }\n-        }\n-\n-        @Override\n-        public MemoryLayout visitType(org.openjdk.jextract.Type t, Void _ignored) {\n-            throw new UnsupportedOperationException();\n-        }\n-    };\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypeImpl.java","additions":0,"deletions":111,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -138,2 +138,1 @@\n-                    Position pos = CursorPosition.of(pointee.getDeclarationCursor());\n-                    String spelling = t.spelling();\n+                    TreeMaker.CursorKey key = TreeMaker.CursorKey.of(pointee.getDeclarationCursor());\n@@ -141,1 +140,1 @@\n-                        Optional<Declaration> decl = treeMaker.lookup(pos);\n+                        Optional<Declaration> decl = treeMaker.lookup(key);\n@@ -144,1 +143,1 @@\n-                            return Type.error(spelling);\n+                            return Type.error(key.spelling());\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypeMaker.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -232,1 +232,1 @@\n-                    DeclarationImpl.nextOffset(scoped).isEmpty()) {\n+                    DeclarationImpl.recordMemberOffset(scoped).isEmpty()) {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnsupportedFilter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,5 +108,4 @@\n-    static boolean isStructOrUnion(Declaration.Scoped scoped) {\n-        return switch (scoped.kind()) {\n-            case STRUCT, UNION -> true;\n-            default -> false;\n-        };\n+    static boolean isStructOrUnion(Declaration declaration) {\n+        return declaration instanceof Declaration.Scoped scoped &&\n+                (scoped.kind() == Declaration.Scoped.Kind.STRUCT ||\n+                 scoped.kind() == Declaration.Scoped.Kind.UNION);\n@@ -115,5 +114,3 @@\n-    static boolean isEnum(Declaration.Scoped scoped) {\n-        return switch (scoped.kind()) {\n-            case ENUM -> true;\n-            default -> false;\n-        };\n+    static boolean isEnum(Declaration declaration) {\n+        return declaration instanceof Declaration.Scoped scoped &&\n+                scoped.kind() == Declaration.Scoped.Kind.ENUM;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Utils.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemoryLayout.PathElement;\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+import test.jextract.packedstructs.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -l Func -t test.jextract.packedstructs packedstructs.h\n+ * @build TestPackedStructs\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestPackedStructs\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library \/lib\n+ * @run main\/othervm JtregJextractSources -l Func -t test.jextract.packedstructs packedstructs.h\n+ * @build TestPackedStructs\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestPackedStructs\n+ *\/\n+public class TestPackedStructs {\n+\n+    @Test\n+    public void testPackedStructs() {\n+        checkLayout(S1.$LAYOUT());\n+        checkLayout(S2.$LAYOUT());\n+        checkLayout(S3.$LAYOUT());\n+        checkLayout(S4.$LAYOUT());\n+        checkLayout(S5.$LAYOUT());\n+        checkLayout(S6.$LAYOUT());\n+        checkLayout(S7.$LAYOUT());\n+        checkLayout(S8.$LAYOUT());\n+    }\n+\n+    private void checkLayout(MemoryLayout layout) {\n+        layout.select(PathElement.groupElement(\"first\"));\n+        layout.select(PathElement.groupElement(\"second\"));\n+        assertEquals(((GroupLayout)layout).memberLayouts().get(1).byteAlignment(), 1);\n+    }\n+}\n","filename":"test\/jtreg\/generator\/packed\/TestPackedStructs.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"","filename":"test\/jtreg\/generator\/packed\/packedstructs.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/testng\/org\/openjdk\/jextract\/test\/api\/packedstructs.h","status":"renamed"},{"patch":"@@ -43,1 +43,0 @@\n-        assertTrue(Declaration.layoutFor(structBar).isEmpty());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/api\/Test8238712.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.jextract.test.api;\n-\n-import org.openjdk.jextract.Declaration;\n-import org.testng.annotations.Test;\n-import testlib.JextractApiTestBase;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-import java.lang.foreign.GroupLayout;\n-\n-public class TestPackedStructs extends JextractApiTestBase {\n-\n-    static final String[] NAMES = {\n-            \"S1\", \"S2\", \"S3\", \"S4\", \"S5\", \"S6\", \"S7\", \"S8\"\n-    };\n-\n-    @Test\n-    public void testPackedStructs() {\n-        Declaration.Scoped d = parse(\"packedstructs.h\");\n-        System.out.println(d);\n-        for (String name : NAMES) {\n-            Declaration.Scoped scoped = checkStruct(d, name, \"first\", \"second\");\n-            GroupLayout groupLayout = (GroupLayout)Declaration.layoutFor(scoped).get();\n-            assertEquals(groupLayout.memberLayouts().get(1).byteAlignment(), 1);\n-        }\n-    }\n-}\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/api\/TestPackedStructs.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"}]}