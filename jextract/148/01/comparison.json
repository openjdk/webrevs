{"files":[{"patch":"@@ -55,2 +55,1 @@\n-     * Adds a new attribute to this entity. This method is idempotent, that is, it allows adding an attribute\n-     * that is identical to the one already stored.\n+     * Adds a new attribute to this entity.\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Attributed.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.EnumConstant;\n@@ -145,1 +146,1 @@\n-        Optional<String> enumName = EnumConstantLifter.enumName(d);\n+        Optional<String> enumName = EnumConstant.get(d);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/CDeclarationPrinter.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-        var nameMangler = new NameMangler(headerName);\n@@ -40,1 +39,1 @@\n-            map(new IncludeFilter(includeHelper)::transform).\n+            map(new IncludeFilter(includeHelper)::process).\n@@ -43,1 +42,1 @@\n-            map(nameMangler::scan).\n+            map(new NameMangler(headerName)::scan).\n@@ -45,1 +44,1 @@\n-        return OutputFactory.generateWrapped(transformedDecl, targetPkg, libNames, nameMangler);\n+        return OutputFactory.generateWrapped(transformedDecl, targetPkg, libNames);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/CodeGenerator.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,3 +30,0 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n@@ -37,1 +34,0 @@\n-import java.util.Set;\n@@ -348,0 +344,2 @@\n+    \/\/ attributes\n+\n@@ -351,1 +349,11 @@\n-    record AnonymousStruct() { }\n+    record AnonymousStruct() {\n+        private static final AnonymousStruct INSTANCE = new AnonymousStruct();\n+\n+        public static void with(Scoped scoped) {\n+            scoped.addAttribute(INSTANCE);\n+        }\n+\n+        public static boolean is(Scoped scoped) {\n+            return scoped.getAttribute(AnonymousStruct.class).isPresent();\n+        }\n+    }\n@@ -356,1 +364,67 @@\n-    record EnumConstant(String enumName) { }\n+    record EnumConstant(String get) {\n+        public static void with(Constant constant, String enumName) {\n+            constant.addAttribute(new EnumConstant(enumName));\n+        }\n+\n+        public static Optional<String> get(Constant constant) {\n+            return constant.getAttribute(EnumConstant.class)\n+                    .map(EnumConstant::get);\n+        }\n+    }\n+\n+    \/**\n+     * An attribute to mark declaration for which no code should be generated.\n+     *\/\n+    record Skip() {\n+        private static final Skip INSTANCE = new Skip();\n+\n+        public static void with(Declaration declaration) {\n+            declaration.addAttribute(INSTANCE);\n+        }\n+\n+        public static boolean is(Declaration declaration) {\n+            return declaration.getAttribute(Skip.class).isPresent();\n+        }\n+    }\n+\n+    \/**\n+     * An attribute to attach a Java name to a C declaration.\n+     *\/\n+    record JavaName(String name) {\n+        public static void with(Declaration declaration, String javaName) {\n+            declaration.addAttribute(new JavaName(javaName));\n+        }\n+\n+        public static String getOrThrow(Declaration declaration) {\n+            return declaration.getAttribute(JavaName.class)\n+                    .map(JavaName::name).get();\n+        }\n+    }\n+\n+    \/**\n+     * An attribute to attach a list of Java parameter names to a C function type.\n+     *\/\n+    record JavaParameterNames(List<String> parameterNames) {\n+        public static void with(Type.Function function, List<String> parameterNames) {\n+            function.addAttribute(new JavaParameterNames(parameterNames));\n+        }\n+\n+        public static Optional<List<String>> get(Type.Function function) {\n+            return function.getAttribute(JavaParameterNames.class)\n+                    .map(JavaParameterNames::parameterNames);\n+        }\n+    }\n+\n+    \/**\n+     * An attribute to attach a Java functional interface name to a C declaration.\n+     *\/\n+    record JavaFunctionalInterfaceName(String fiName) {\n+        public static void with(Declaration declaration, String fiName) {\n+            declaration.addAttribute(new JavaFunctionalInterfaceName(fiName));\n+        }\n+\n+        public static String getOrThrow(Declaration declaration) {\n+            return declaration.getAttribute(JavaFunctionalInterfaceName.class)\n+                    .map(JavaFunctionalInterfaceName::fiName).get();\n+        }\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/DeclarationImpl.java","additions":80,"deletions":6,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.Skip;\n+\n@@ -36,1 +38,1 @@\n-final class DuplicateFilter implements TreeTransformer, Declaration.Visitor<Void, Void> {\n+final class DuplicateFilter implements Declaration.Visitor<Void, Void> {\n@@ -67,1 +69,0 @@\n-    @Override\n@@ -73,1 +74,1 @@\n-        return createHeader(header, decls);\n+        return header;\n@@ -80,1 +81,1 @@\n-            return null;\n+            Skip.with(constant);\n@@ -91,1 +92,1 @@\n-            return null;\n+            Skip.with(funcTree);\n@@ -102,1 +103,1 @@\n-            return null;\n+            Skip.with(tree);\n@@ -113,1 +114,1 @@\n-            return null;\n+            Skip.with(tree);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/DuplicateFilter.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jextract.Declaration.Constant;\n+import org.openjdk.jextract.Declaration.Scoped.Kind;\n@@ -30,4 +32,1 @@\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n+import org.openjdk.jextract.impl.DeclarationImpl.Skip;\n@@ -38,5 +37,1 @@\n-final class EnumConstantLifter implements TreeTransformer, Declaration.Visitor<Void, Void> {\n-\n-    private final List<Declaration> decls = new ArrayList<>();\n-    EnumConstantLifter() {\n-    }\n+final class EnumConstantLifter implements Declaration.Visitor<Void, Void> {\n@@ -44,5 +39,0 @@\n-    static Optional<String> enumName(Declaration.Constant constant) {\n-        return constant.getAttribute(EnumConstant.class).map(EnumConstant::enumName);\n-    }\n-\n-    @Override\n@@ -54,1 +44,1 @@\n-        return createHeader(header, decls);\n+        return header;\n@@ -59,2 +49,7 @@\n-        if (liftEnumConstants(scoped)) {\n-            return null;\n+        boolean isEnum = scoped.kind() == Declaration.Scoped.Kind.ENUM;\n+        if (isEnum) {\n+            \/\/ add the name of the enum as an attribute.\n+            scoped.members().forEach(fieldTree -> {\n+                EnumConstant.with((Constant)fieldTree, scoped.name());\n+                fieldTree.accept(this, null);\n+            });\n@@ -62,1 +57,0 @@\n-        decls.add(scoped);\n@@ -70,2 +64,4 @@\n-            if (liftEnumConstants(declared.tree())) {\n-                return null;\n+            if (declared.tree().kind() == Kind.ENUM) {\n+                \/\/ no need to do anything for a typedef enum, as the IR always\n+                \/\/ lifts the enum tree before the typedef.\n+                Skip.with(tree);\n@@ -74,1 +70,0 @@\n-        decls.add(tree);\n@@ -80,1 +75,0 @@\n-        decls.add(decl);\n@@ -83,12 +77,0 @@\n-\n-    private boolean liftEnumConstants(Declaration.Scoped scoped) {\n-        boolean isEnum = scoped.kind() == Declaration.Scoped.Kind.ENUM;\n-        if (isEnum) {\n-            \/\/ add the name of the enum as an attribute.\n-            scoped.members().forEach(fieldTree -> {\n-                fieldTree.addAttribute(new EnumConstant(scoped.name()));\n-                fieldTree.accept(this, null);\n-            });\n-        }\n-        return isEnum;\n-    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/EnumConstantLifter.java","additions":16,"deletions":34,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -28,4 +28,1 @@\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n+import org.openjdk.jextract.impl.DeclarationImpl.Skip;\n@@ -34,1 +31,1 @@\n- * This visitor filters tree elements based on --include options specified.\n+ * This visitor marks declarations to be skipped, based on --include options specified.\n@@ -36,2 +33,1 @@\n-final class IncludeFilter implements TreeTransformer, Declaration.Visitor<Void, Declaration> {\n-    private List<Declaration> decls = new ArrayList<>();\n+final class IncludeFilter implements Declaration.Visitor<Void, Declaration> {\n@@ -44,2 +40,1 @@\n-    @Override\n-    public Declaration.Scoped transform(Declaration.Scoped header) {\n+    public Declaration.Scoped process(Declaration.Scoped header) {\n@@ -50,1 +45,1 @@\n-        return createHeader(header, decls);\n+        return header;\n@@ -57,1 +52,1 @@\n-            return null;\n+            Skip.with(constant);\n@@ -59,1 +54,0 @@\n-        decls.add(constant);\n@@ -66,1 +60,2 @@\n-            return null;\n+            \/\/skip\n+            Skip.with(funcTree);\n@@ -68,2 +63,0 @@\n-\n-        decls.add(funcTree);\n@@ -79,1 +72,2 @@\n-                return null;\n+                \/\/skip\n+                Skip.with(d);\n@@ -83,9 +77,1 @@\n-        List<Declaration> oldDecls = decls;\n-        this.decls = new ArrayList<>();\n-        try {\n-            d.members().forEach(fieldTree -> fieldTree.accept(this, d));\n-        } finally {\n-            var scoped = createScoped(d, decls);\n-            this.decls = oldDecls;\n-            decls.add(scoped);\n-        }\n+        d.members().forEach(fieldTree -> fieldTree.accept(this, d));\n@@ -98,1 +84,2 @@\n-            return null;\n+            \/\/skip\n+            Skip.with(tree);\n@@ -100,1 +87,0 @@\n-        decls.add(tree);\n@@ -107,1 +93,2 @@\n-            return null;\n+            \/\/skip\n+            Skip.with(tree);\n@@ -109,1 +96,0 @@\n-        decls.add(tree);\n@@ -115,1 +101,0 @@\n-        decls.add(decl);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/IncludeFilter.java","additions":15,"deletions":30,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -29,1 +29,4 @@\n-import java.util.HashMap;\n+import org.openjdk.jextract.impl.DeclarationImpl.JavaFunctionalInterfaceName;\n+import org.openjdk.jextract.impl.DeclarationImpl.JavaName;\n+import org.openjdk.jextract.impl.DeclarationImpl.JavaParameterNames;\n+\n@@ -31,4 +34,0 @@\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n@@ -39,7 +38,3 @@\n- * This visitor handles java safe names for identifiers, type names. This visitor\n- * stores java safe names in maps. Subsequent code generation steps can check for\n- * java safe names via lookup methods.\n- *\n- * NOTE: Unlike other transforming tree visitors, this visitor collects name\n- * mappings as it visits tree nodes. Subsequent code generation steps can check\n- * the collected names using getters.\n+ * This visitor handles java safe names for identifiers, type names and stores such names\n+ * in the corresponding declaration. The mangled name is later retrieved by\n+ * OutputFactory via the lookup methods provided by this class.\n@@ -97,9 +92,0 @@\n-    private static record NameAndDecl(String name, Declaration decl) {}\n-    \/\/ key is either Declaration or NameAndDecl\n-    private final Map<Object, String> declJavaNames = new HashMap<>();\n-\n-    private static record DeclPair(Declaration parent, Declaration decl) {}\n-    \/\/ key is either Declaration or NameAndDecl or DeclPair\n-    private final Map<Object, String> declFiNames = new HashMap<>();\n-    private final Map<Type.Function, List<String>> parameterNames = new HashMap<>();\n-\n@@ -110,82 +96,0 @@\n-    \/\/ package private name lookup API\n-    String getJavaName(Declaration parent, Declaration decl) {\n-        Objects.requireNonNull(decl);\n-        if (declJavaNames.containsKey(decl)) {\n-            return Objects.requireNonNull(declJavaNames.get(decl));\n-        } else {\n-            var name = decl.name().isEmpty()? parent.name() : decl.name();\n-            var nameAndDecl = new NameAndDecl(name, decl);\n-            return Objects.requireNonNull(declJavaNames.get(nameAndDecl));\n-        }\n-    }\n-\n-    Optional<List<String>> getParameterNames(Type.Function func) {\n-        return Optional.ofNullable(parameterNames.get(func));\n-    }\n-\n-    String getFiName(Declaration.Function func, int paramNum, Declaration.Variable param) {\n-        Objects.requireNonNull(func);\n-        Objects.requireNonNull(param);\n-        var nameAndDecl = new NameAndDecl(funcParamID(func, paramNum), param);\n-        return Objects.requireNonNull(declFiNames.get(nameAndDecl));\n-    }\n-\n-    String getReturnFiName(Declaration.Function func) {\n-        Objects.requireNonNull(func);\n-        return funcReturnID(func);\n-    }\n-\n-    String getFiName(Declaration parent, Declaration decl) {\n-        Objects.requireNonNull(decl);\n-        if (declFiNames.containsKey(decl)) {\n-            return Objects.requireNonNull(declFiNames.get(decl));\n-        } else {\n-            Objects.requireNonNull(parent);\n-            var declPair = new DeclPair(parent, decl);\n-            return Objects.requireNonNull(declFiNames.get(declPair));\n-        }\n-    }\n-\n-    \/\/ Internals below this point\n-\n-    private static String funcReturnID(Declaration.Function func) {\n-        return func.name() + \"$return\";\n-    }\n-\n-    private static String funcParamID(Declaration.Function func, int paramNum) {\n-        return func.name() + \"$\" + paramNum;\n-    }\n-\n-    private void putJavaName(Declaration decl, String javaName) {\n-        assert decl != null;\n-        assert javaName != null;\n-        declJavaNames.put(decl, javaName);\n-    }\n-\n-    private void putJavaName(String name, Declaration decl, String javaName) {\n-        assert name != null;\n-        assert decl != null;\n-        assert javaName != null;\n-        declJavaNames.put(new NameAndDecl(name, decl), javaName);\n-    }\n-\n-    private void putFiName(Declaration decl, String javaName) {\n-        assert decl != null;\n-        assert javaName != null;\n-        declFiNames.put(decl, javaName);\n-    }\n-\n-    private void putFiName(Declaration parent, Declaration.Variable variable, String javaName) {\n-        assert parent != null;\n-        assert variable != null;\n-        assert javaName != null;\n-        declFiNames.put(new DeclPair(parent, variable), javaName);\n-    }\n-\n-    private void putFiName(String name, Declaration decl, String javaName) {\n-        assert name != null;\n-        assert decl != null;\n-        assert javaName != null;\n-        declFiNames.put(new NameAndDecl(name, decl), javaName);\n-    }\n-\n@@ -196,1 +100,1 @@\n-        putJavaName(header, javaName);\n+        JavaName.with(header, javaName);\n@@ -204,1 +108,1 @@\n-        putJavaName(constant, makeJavaName(constant));\n+        JavaName.with(constant, makeJavaName(constant));\n@@ -210,1 +114,1 @@\n-        putJavaName(func, makeJavaName(func));\n+        JavaName.with(func, makeJavaName(func));\n@@ -216,1 +120,1 @@\n-                putFiName(funcParamID(func, i), param, declFiName);\n+                JavaFunctionalInterfaceName.with(param, declFiName);\n@@ -219,1 +123,5 @@\n-            putJavaName(param, makeJavaName(param));\n+            JavaName.with(param, makeJavaName(param));\n+        }\n+        Type.Function returnFunc = Utils.getAsFunctionPointer(func.type().returnType());\n+        if (returnFunc != null) {\n+            JavaFunctionalInterfaceName.with(func, func.name() + \"$return\");\n@@ -227,4 +135,3 @@\n-        String name = scoped.name().isEmpty()? parent.name() : scoped.name();\n-        if (declJavaNames.containsKey(new NameAndDecl(name, scoped))) {\n-            \/\/skip struct that's seen already\n-            return null;\n+        String name = scoped.name();\n+        if (name.isEmpty() && parent != null) {\n+            name = parent.name();\n@@ -232,3 +139,2 @@\n-\n-        boolean isStruct = Utils.isStructOrUnion(scoped);\n-        if (!isStruct) {\n+        if (scoped.getAttribute(JavaName.class).isPresent()) {\n+            \/\/skip struct that's seen already\n@@ -243,1 +149,1 @@\n-            putJavaName(name, scoped, curScope.className());\n+            JavaName.with(scoped, curScope.className());\n@@ -256,1 +162,1 @@\n-        if (declJavaNames.containsKey(typedef)) {\n+        if (typedef.getAttribute(JavaName.class).isPresent()) {\n@@ -269,1 +175,1 @@\n-        putJavaName(typedef, javaName);\n+        JavaName.with(typedef, javaName);\n@@ -274,1 +180,1 @@\n-               parameterNames.put(func,\n+               JavaParameterNames.with(func,\n@@ -282,1 +188,1 @@\n-           putFiName(typedef, javaName);\n+           JavaFunctionalInterfaceName.with(typedef, javaName);\n@@ -289,1 +195,1 @@\n-        putJavaName(variable, makeJavaName(variable));\n+        JavaName.with(variable, makeJavaName(variable));\n@@ -298,5 +204,1 @@\n-            if (parent != null) {\n-                putFiName(parent, variable, fiName);\n-            } else {\n-                putFiName(variable, fiName);\n-            }\n+            JavaFunctionalInterfaceName.with(variable, fiName);\n@@ -312,6 +214,0 @@\n-    private List<String> javaSafeNameList(List<String> names) {\n-        return names.stream().\n-            map(n -> n.isEmpty()? n : javaSafeIdentifier(n)).\n-            toList();\n-    }\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/NameMangler.java","additions":28,"deletions":132,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -30,0 +30,4 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.JavaFunctionalInterfaceName;\n+import org.openjdk.jextract.impl.DeclarationImpl.JavaName;\n+import org.openjdk.jextract.impl.DeclarationImpl.JavaParameterNames;\n+import org.openjdk.jextract.impl.DeclarationImpl.Skip;\n@@ -61,1 +65,0 @@\n-    private final NameMangler nameMangler;\n@@ -88,2 +91,2 @@\n-                String pkgName, List<String> libraryNames, NameMangler nameMangler) {\n-        String clsName = nameMangler.getJavaName(null, decl);\n+                String pkgName, List<String> libraryNames) {\n+        String clsName = JavaName.getOrThrow(decl);\n@@ -91,1 +94,1 @@\n-        return new OutputFactory(pkgName, toplevelBuilder, nameMangler).\n+        return new OutputFactory(pkgName, toplevelBuilder).\n@@ -95,1 +98,1 @@\n-    private OutputFactory(String pkgName, ToplevelBuilder toplevelBuilder, NameMangler nameMangler) {\n+    private OutputFactory(String pkgName, ToplevelBuilder toplevelBuilder) {\n@@ -99,1 +102,0 @@\n-        this.nameMangler = nameMangler;\n@@ -108,1 +110,1 @@\n-            toplevelBuilder.addTypedef(td, nameMangler.getJavaName(null, td), structDefinitionName(structDef));\n+            toplevelBuilder.addTypedef(td, JavaName.getOrThrow(td), structDefinitionName(structDef));\n@@ -156,6 +158,1 @@\n-        \/*\n-         * This method is called from visitVariable when it recursively visits type\n-         * When type is enum, enum constants are visited again! Checking parent to be\n-         * null to avoid duplicate generation of enum constant getter methods.\n-         *\/\n-        if (parent != null) {\n+        if (constant.getAttribute(Skip.class).isPresent()) {\n@@ -170,1 +167,1 @@\n-        toplevelBuilder.addConstant(constant, nameMangler.getJavaName(parent, constant), clazz);\n+        toplevelBuilder.addConstant(constant, JavaName.getOrThrow(constant), clazz);\n@@ -176,0 +173,3 @@\n+        if (d.getAttribute(Skip.class).isPresent()) {\n+            return null;\n+        }\n@@ -192,1 +192,1 @@\n-                isNestedAnonStruct? null : nameMangler.getJavaName(parent, d),\n+                isNestedAnonStruct? null : JavaName.getOrThrow(d),\n@@ -232,1 +232,1 @@\n-            nameMangler.getParameterNames(func));\n+            JavaParameterNames.get(func));\n@@ -238,0 +238,3 @@\n+        if (funcTree.getAttribute(Skip.class).isPresent()) {\n+            return null;\n+        }\n@@ -256,1 +259,1 @@\n-                String fiName = nameMangler.getFiName(funcTree, i, param);\n+                String fiName = JavaFunctionalInterfaceName.getOrThrow(param);\n@@ -267,1 +270,1 @@\n-             if (! generateFunctionalInterface(returnFunc, nameMangler.getReturnFiName(funcTree))) {\n+             if (! generateFunctionalInterface(returnFunc, JavaFunctionalInterfaceName.getOrThrow(funcTree))) {\n@@ -272,1 +275,1 @@\n-        toplevelBuilder.addFunction(funcTree, descriptor, nameMangler.getJavaName(parent, funcTree),\n+        toplevelBuilder.addFunction(funcTree, descriptor, JavaName.getOrThrow(funcTree),\n@@ -275,1 +278,1 @@\n-                map(param -> nameMangler.getJavaName(null, param)).\n+                map(JavaName::getOrThrow).\n@@ -293,0 +296,3 @@\n+        if (tree.getAttribute(Skip.class).isPresent()) {\n+            return null;\n+        }\n@@ -314,1 +320,1 @@\n-                                String javaName = nameMangler.getJavaName(parent, tree);\n+                                String javaName = JavaName.getOrThrow(tree);\n@@ -329,1 +335,1 @@\n-            toplevelBuilder.addTypedef(tree, nameMangler.getJavaName(parent, tree), null);\n+            toplevelBuilder.addTypedef(tree, JavaName.getOrThrow(tree), null);\n@@ -333,1 +339,1 @@\n-                String fiName = nameMangler.getFiName(parent, tree);\n+                String fiName = JavaFunctionalInterfaceName.getOrThrow(tree);\n@@ -339,1 +345,1 @@\n-                toplevelBuilder.addTypedef(tree, nameMangler.getJavaName(parent, tree), null);\n+                toplevelBuilder.addTypedef(tree, JavaName.getOrThrow(tree), null);\n@@ -343,1 +349,1 @@\n-                    toplevelBuilder.addTypedef(tree, nameMangler.getJavaName(parent, tree), null, primitive);\n+                    toplevelBuilder.addTypedef(tree, JavaName.getOrThrow(tree), null, primitive);\n@@ -352,0 +358,3 @@\n+        if (tree.getAttribute(Skip.class).isPresent()) {\n+            return null;\n+        }\n@@ -395,1 +404,1 @@\n-            fiName = nameMangler.getFiName(parent, tree);\n+            fiName = JavaFunctionalInterfaceName.getOrThrow(tree);\n@@ -406,1 +415,1 @@\n-        currentBuilder.addVar(tree, nameMangler.getJavaName(parent, tree), layout, Optional.ofNullable(fiName));\n+        currentBuilder.addVar(tree, JavaName.getOrThrow(tree), layout, Optional.ofNullable(fiName));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":36,"deletions":27,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-            declaration.addAttribute(new AnonymousStruct());\n+            AnonymousStruct.with(declaration);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/RecordLayoutComputer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.constant.Constable;\n@@ -31,1 +30,0 @@\n-import java.util.Collection;\n@@ -42,0 +40,1 @@\n+import org.openjdk.jextract.Declaration.Scoped;\n@@ -60,0 +59,2 @@\n+    Map<Position, Declaration> declarationCache = new HashMap<>();\n+\n@@ -106,12 +107,19 @@\n-        return switch (c.kind()) {\n-            case EnumDecl -> createEnum(c);\n-            case EnumConstantDecl -> createEnumConstant(c);\n-            case FieldDecl -> createVar(c, Declaration.Variable.Kind.FIELD);\n-            case ParmDecl -> createVar(c, Declaration.Variable.Kind.PARAMETER);\n-            case FunctionDecl -> createFunction(c);\n-            case StructDecl -> createRecord(c, Declaration.Scoped.Kind.STRUCT);\n-            case UnionDecl -> createRecord(c, Declaration.Scoped.Kind.UNION);\n-            case TypedefDecl -> createTypedef(c);\n-            case VarDecl -> createVar(c, Declaration.Variable.Kind.GLOBAL);\n-            default -> null; \/\/ skip\n-        };\n+        Position pos = CursorPosition.of(c);\n+        \/\/ dedup multiple declarations that point to the same source location\n+        Declaration decl = declarationCache.get(pos);\n+        if (decl == null) {\n+            decl = switch (c.kind()) {\n+                case EnumDecl -> createEnum(c);\n+                case EnumConstantDecl -> createEnumConstant(c);\n+                case FieldDecl -> createVar(c, Declaration.Variable.Kind.FIELD);\n+                case ParmDecl -> createVar(c, Declaration.Variable.Kind.PARAMETER);\n+                case FunctionDecl -> createFunction(c);\n+                case StructDecl -> createRecord(c, Declaration.Scoped.Kind.STRUCT);\n+                case UnionDecl -> createRecord(c, Declaration.Scoped.Kind.UNION);\n+                case TypedefDecl -> createTypedef(c);\n+                case VarDecl -> createVar(c, Declaration.Variable.Kind.GLOBAL);\n+                default -> null; \/\/ skip\n+            };\n+            declarationCache.put(pos, decl);\n+        }\n+        return decl;\n@@ -257,1 +265,1 @@\n-        return declaration.getAttribute(AnonymousStruct.class).isPresent();\n+        return declaration instanceof Scoped scoped && AnonymousStruct.is(scoped);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeMaker.java","additions":23,"deletions":15,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserveold.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.jextract.impl;\n-\n-import java.util.List;\n-import org.openjdk.jextract.Declaration;\n-\n-interface TreeTransformer {\n-    Declaration.Scoped transform(Declaration.Scoped header);\n-\n-    default Declaration.Scoped createHeader(Declaration.Scoped old, List<Declaration> members) {\n-        return Declaration.toplevel(old.pos(), members.toArray(new Declaration[0]));\n-    }\n-\n-    default Declaration.Scoped createScoped(Declaration.Scoped old, List<Declaration> members) {\n-        var declsArray = members.toArray(new Declaration[0]);\n-        return old.layout().isEmpty() ?\n-            Declaration.scoped(old.kind(), old.pos(), old.name(), declsArray) :\n-            Declaration.scoped(old.kind(), old.pos(), old.name(), old.layout().get(), declsArray);\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeTransformer.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"}]}