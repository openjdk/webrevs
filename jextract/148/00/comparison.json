{"files":[{"patch":"@@ -55,2 +55,1 @@\n-     * Adds a new attribute to this entity. This method is idempotent, that is, it allows adding an attribute\n-     * that is identical to the one already stored.\n+     * Adds a new attribute to this entity.\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Attributed.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-        var nameMangler = new NameMangler(headerName);\n@@ -40,1 +39,1 @@\n-            map(new IncludeFilter(includeHelper)::transform).\n+            map(new IncludeFilter(includeHelper)::process).\n@@ -43,1 +42,1 @@\n-            map(nameMangler::scan).\n+            map(new NameMangler(headerName)::scan).\n@@ -45,1 +44,1 @@\n-        return OutputFactory.generateWrapped(transformedDecl, targetPkg, libNames, nameMangler);\n+        return OutputFactory.generateWrapped(transformedDecl, targetPkg, libNames);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/CodeGenerator.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,3 +30,0 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n@@ -37,1 +34,0 @@\n-import java.util.Set;\n@@ -357,0 +353,5 @@\n+\n+    \/**\n+     * An attribute to mark declaration for which no code should be generated.\n+     *\/\n+    record Skip() { }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/DeclarationImpl.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.Skip;\n+\n@@ -36,1 +38,1 @@\n-final class DuplicateFilter implements TreeTransformer, Declaration.Visitor<Void, Void> {\n+final class DuplicateFilter implements Declaration.Visitor<Void, Void> {\n@@ -67,1 +69,0 @@\n-    @Override\n@@ -73,1 +74,1 @@\n-        return createHeader(header, decls);\n+        return header;\n@@ -80,1 +81,1 @@\n-            return null;\n+            constant.addAttribute(new Skip());\n@@ -91,1 +92,1 @@\n-            return null;\n+            funcTree.addAttribute(new Skip());\n@@ -102,1 +103,1 @@\n-            return null;\n+            tree.addAttribute(new Skip());\n@@ -113,1 +114,1 @@\n-            return null;\n+            tree.addAttribute(new Skip());\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/DuplicateFilter.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import org.openjdk.jextract.Declaration.Scoped.Kind;\n@@ -30,0 +31,1 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.Skip;\n@@ -31,2 +33,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n@@ -38,5 +38,1 @@\n-final class EnumConstantLifter implements TreeTransformer, Declaration.Visitor<Void, Void> {\n-\n-    private final List<Declaration> decls = new ArrayList<>();\n-    EnumConstantLifter() {\n-    }\n+final class EnumConstantLifter implements Declaration.Visitor<Void, Void> {\n@@ -48,1 +44,0 @@\n-    @Override\n@@ -54,1 +49,1 @@\n-        return createHeader(header, decls);\n+        return header;\n@@ -59,2 +54,7 @@\n-        if (liftEnumConstants(scoped)) {\n-            return null;\n+        boolean isEnum = scoped.kind() == Declaration.Scoped.Kind.ENUM;\n+        if (isEnum) {\n+            \/\/ add the name of the enum as an attribute.\n+            scoped.members().forEach(fieldTree -> {\n+                fieldTree.addAttribute(new EnumConstant(scoped.name()));\n+                fieldTree.accept(this, null);\n+            });\n@@ -62,1 +62,0 @@\n-        decls.add(scoped);\n@@ -70,2 +69,4 @@\n-            if (liftEnumConstants(declared.tree())) {\n-                return null;\n+            if (declared.tree().kind() == Kind.ENUM) {\n+                \/\/ no need to do anything for a typedef enum, as the IR always\n+                \/\/ lifts the enum tree before the typedef.\n+                tree.addAttribute(new Skip());\n@@ -74,1 +75,0 @@\n-        decls.add(tree);\n@@ -80,1 +80,0 @@\n-        decls.add(decl);\n@@ -83,12 +82,0 @@\n-\n-    private boolean liftEnumConstants(Declaration.Scoped scoped) {\n-        boolean isEnum = scoped.kind() == Declaration.Scoped.Kind.ENUM;\n-        if (isEnum) {\n-            \/\/ add the name of the enum as an attribute.\n-            scoped.members().forEach(fieldTree -> {\n-                fieldTree.addAttribute(new EnumConstant(scoped.name()));\n-                fieldTree.accept(this, null);\n-            });\n-        }\n-        return isEnum;\n-    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/EnumConstantLifter.java","additions":15,"deletions":28,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -28,4 +28,1 @@\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n+import org.openjdk.jextract.impl.DeclarationImpl.Skip;\n@@ -34,1 +31,1 @@\n- * This visitor filters tree elements based on --include options specified.\n+ * This visitor marks declarations to be skipped, based on --include options specified.\n@@ -36,2 +33,1 @@\n-final class IncludeFilter implements TreeTransformer, Declaration.Visitor<Void, Declaration> {\n-    private List<Declaration> decls = new ArrayList<>();\n+final class IncludeFilter implements Declaration.Visitor<Void, Declaration> {\n@@ -44,2 +40,1 @@\n-    @Override\n-    public Declaration.Scoped transform(Declaration.Scoped header) {\n+    public Declaration.Scoped process(Declaration.Scoped header) {\n@@ -50,1 +45,1 @@\n-        return createHeader(header, decls);\n+        return header;\n@@ -57,1 +52,1 @@\n-            return null;\n+            constant.addAttribute(new Skip());\n@@ -59,1 +54,0 @@\n-        decls.add(constant);\n@@ -66,1 +60,2 @@\n-            return null;\n+            \/\/skip\n+            funcTree.addAttribute(new Skip());\n@@ -68,2 +63,0 @@\n-\n-        decls.add(funcTree);\n@@ -79,1 +72,2 @@\n-                return null;\n+                \/\/skip\n+                d.addAttribute(new Skip());\n@@ -83,9 +77,1 @@\n-        List<Declaration> oldDecls = decls;\n-        this.decls = new ArrayList<>();\n-        try {\n-            d.members().forEach(fieldTree -> fieldTree.accept(this, d));\n-        } finally {\n-            var scoped = createScoped(d, decls);\n-            this.decls = oldDecls;\n-            decls.add(scoped);\n-        }\n+        d.members().forEach(fieldTree -> fieldTree.accept(this, d));\n@@ -98,1 +84,2 @@\n-            return null;\n+            \/\/skip\n+            tree.addAttribute(new Skip());\n@@ -100,1 +87,0 @@\n-        decls.add(tree);\n@@ -107,1 +93,2 @@\n-            return null;\n+            \/\/skip\n+            tree.addAttribute(new Skip());\n@@ -109,1 +96,0 @@\n-        decls.add(tree);\n@@ -115,1 +101,0 @@\n-        decls.add(decl);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/IncludeFilter.java","additions":15,"deletions":30,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.util.HashMap;\n@@ -32,1 +31,0 @@\n-import java.util.Map;\n@@ -39,7 +37,3 @@\n- * This visitor handles java safe names for identifiers, type names. This visitor\n- * stores java safe names in maps. Subsequent code generation steps can check for\n- * java safe names via lookup methods.\n- *\n- * NOTE: Unlike other transforming tree visitors, this visitor collects name\n- * mappings as it visits tree nodes. Subsequent code generation steps can check\n- * the collected names using getters.\n+ * This visitor handles java safe names for identifiers, type names and stores such names\n+ * in the corresponding declaration. The mangled name is later retrieved by\n+ * OutputFactory via the lookup methods provided by this class.\n@@ -97,9 +91,0 @@\n-    private static record NameAndDecl(String name, Declaration decl) {}\n-    \/\/ key is either Declaration or NameAndDecl\n-    private final Map<Object, String> declJavaNames = new HashMap<>();\n-\n-    private static record DeclPair(Declaration parent, Declaration decl) {}\n-    \/\/ key is either Declaration or NameAndDecl or DeclPair\n-    private final Map<Object, String> declFiNames = new HashMap<>();\n-    private final Map<Type.Function, List<String>> parameterNames = new HashMap<>();\n-\n@@ -111,20 +96,2 @@\n-    String getJavaName(Declaration parent, Declaration decl) {\n-        Objects.requireNonNull(decl);\n-        if (declJavaNames.containsKey(decl)) {\n-            return Objects.requireNonNull(declJavaNames.get(decl));\n-        } else {\n-            var name = decl.name().isEmpty()? parent.name() : decl.name();\n-            var nameAndDecl = new NameAndDecl(name, decl);\n-            return Objects.requireNonNull(declJavaNames.get(nameAndDecl));\n-        }\n-    }\n-\n-    Optional<List<String>> getParameterNames(Type.Function func) {\n-        return Optional.ofNullable(parameterNames.get(func));\n-    }\n-\n-    String getFiName(Declaration.Function func, int paramNum, Declaration.Variable param) {\n-        Objects.requireNonNull(func);\n-        Objects.requireNonNull(param);\n-        var nameAndDecl = new NameAndDecl(funcParamID(func, paramNum), param);\n-        return Objects.requireNonNull(declFiNames.get(nameAndDecl));\n+    static String getJavaName(Declaration decl) {\n+        return decl.getAttribute(JavaName.class).get().name;\n@@ -133,3 +100,2 @@\n-    String getReturnFiName(Declaration.Function func) {\n-        Objects.requireNonNull(func);\n-        return funcReturnID(func);\n+    static Optional<List<String>> getParameterNames(Type.Function func) {\n+        return func.getAttribute(JavaParameterNames.class).map(JavaParameterNames::names);\n@@ -138,1 +104,1 @@\n-    String getFiName(Declaration parent, Declaration decl) {\n+    static String getFiName(Declaration decl) {\n@@ -140,7 +106,1 @@\n-        if (declFiNames.containsKey(decl)) {\n-            return Objects.requireNonNull(declFiNames.get(decl));\n-        } else {\n-            Objects.requireNonNull(parent);\n-            var declPair = new DeclPair(parent, decl);\n-            return Objects.requireNonNull(declFiNames.get(declPair));\n-        }\n+        return decl.getAttribute(JavaFunctionalInterfaceName.class).get().name;\n@@ -151,8 +111,0 @@\n-    private static String funcReturnID(Declaration.Function func) {\n-        return func.name() + \"$return\";\n-    }\n-\n-    private static String funcParamID(Declaration.Function func, int paramNum) {\n-        return func.name() + \"$\" + paramNum;\n-    }\n-\n@@ -160,10 +112,3 @@\n-        assert decl != null;\n-        assert javaName != null;\n-        declJavaNames.put(decl, javaName);\n-    }\n-\n-    private void putJavaName(String name, Declaration decl, String javaName) {\n-        assert name != null;\n-        assert decl != null;\n-        assert javaName != null;\n-        declJavaNames.put(new NameAndDecl(name, decl), javaName);\n+        Objects.requireNonNull(decl);\n+        Objects.requireNonNull(javaName);\n+        decl.addAttribute(new JavaName(javaName));\n@@ -173,17 +118,3 @@\n-        assert decl != null;\n-        assert javaName != null;\n-        declFiNames.put(decl, javaName);\n-    }\n-\n-    private void putFiName(Declaration parent, Declaration.Variable variable, String javaName) {\n-        assert parent != null;\n-        assert variable != null;\n-        assert javaName != null;\n-        declFiNames.put(new DeclPair(parent, variable), javaName);\n-    }\n-\n-    private void putFiName(String name, Declaration decl, String javaName) {\n-        assert name != null;\n-        assert decl != null;\n-        assert javaName != null;\n-        declFiNames.put(new NameAndDecl(name, decl), javaName);\n+        Objects.requireNonNull(decl);\n+        Objects.requireNonNull(javaName);\n+        decl.addAttribute(new JavaFunctionalInterfaceName(javaName));\n@@ -216,1 +147,1 @@\n-                putFiName(funcParamID(func, i), param, declFiName);\n+                putFiName(param, declFiName);\n@@ -221,0 +152,4 @@\n+        Type.Function returnFunc = Utils.getAsFunctionPointer(func.type().returnType());\n+        if (returnFunc != null) {\n+            putFiName(func, func.name() + \"$return\");\n+        }\n@@ -227,4 +162,3 @@\n-        String name = scoped.name().isEmpty()? parent.name() : scoped.name();\n-        if (declJavaNames.containsKey(new NameAndDecl(name, scoped))) {\n-            \/\/skip struct that's seen already\n-            return null;\n+        String name = scoped.name();\n+        if (name.isEmpty() && parent != null) {\n+            name = parent.name();\n@@ -232,3 +166,2 @@\n-\n-        boolean isStruct = Utils.isStructOrUnion(scoped);\n-        if (!isStruct) {\n+        if (scoped.getAttribute(JavaName.class).isPresent()) {\n+            \/\/skip struct that's seen already\n@@ -243,1 +176,1 @@\n-            putJavaName(name, scoped, curScope.className());\n+            putJavaName(scoped, curScope.className());\n@@ -256,1 +189,1 @@\n-        if (declJavaNames.containsKey(typedef)) {\n+        if (typedef.getAttribute(JavaName.class).isPresent()) {\n@@ -274,1 +207,1 @@\n-               parameterNames.put(func,\n+               func.addAttribute(new JavaParameterNames(\n@@ -280,1 +213,1 @@\n-               );\n+               ));\n@@ -298,5 +231,1 @@\n-            if (parent != null) {\n-                putFiName(parent, variable, fiName);\n-            } else {\n-                putFiName(variable, fiName);\n-            }\n+            putFiName(variable, fiName);\n@@ -312,6 +241,0 @@\n-    private List<String> javaSafeNameList(List<String> names) {\n-        return names.stream().\n-            map(n -> n.isEmpty()? n : javaSafeIdentifier(n)).\n-            toList();\n-    }\n-\n@@ -376,0 +299,6 @@\n+\n+    record JavaName(String name) { }\n+\n+    record JavaParameterNames(List<String> names) { }\n+\n+    record JavaFunctionalInterfaceName(String name) { }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/NameMangler.java","additions":36,"deletions":107,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.Skip;\n@@ -61,1 +62,0 @@\n-    private final NameMangler nameMangler;\n@@ -88,2 +88,2 @@\n-                String pkgName, List<String> libraryNames, NameMangler nameMangler) {\n-        String clsName = nameMangler.getJavaName(null, decl);\n+                String pkgName, List<String> libraryNames) {\n+        String clsName = NameMangler.getJavaName(decl);\n@@ -91,1 +91,1 @@\n-        return new OutputFactory(pkgName, toplevelBuilder, nameMangler).\n+        return new OutputFactory(pkgName, toplevelBuilder).\n@@ -95,1 +95,1 @@\n-    private OutputFactory(String pkgName, ToplevelBuilder toplevelBuilder, NameMangler nameMangler) {\n+    private OutputFactory(String pkgName, ToplevelBuilder toplevelBuilder) {\n@@ -99,1 +99,0 @@\n-        this.nameMangler = nameMangler;\n@@ -108,1 +107,1 @@\n-            toplevelBuilder.addTypedef(td, nameMangler.getJavaName(null, td), structDefinitionName(structDef));\n+            toplevelBuilder.addTypedef(td, NameMangler.getJavaName(td), structDefinitionName(structDef));\n@@ -156,6 +155,1 @@\n-        \/*\n-         * This method is called from visitVariable when it recursively visits type\n-         * When type is enum, enum constants are visited again! Checking parent to be\n-         * null to avoid duplicate generation of enum constant getter methods.\n-         *\/\n-        if (parent != null) {\n+        if (constant.getAttribute(Skip.class).isPresent()) {\n@@ -170,1 +164,1 @@\n-        toplevelBuilder.addConstant(constant, nameMangler.getJavaName(parent, constant), clazz);\n+        toplevelBuilder.addConstant(constant, NameMangler.getJavaName(constant), clazz);\n@@ -176,0 +170,3 @@\n+        if (d.getAttribute(Skip.class).isPresent()) {\n+            return null;\n+        }\n@@ -192,1 +189,1 @@\n-                isNestedAnonStruct? null : nameMangler.getJavaName(parent, d),\n+                isNestedAnonStruct? null : NameMangler.getJavaName(d),\n@@ -232,1 +229,1 @@\n-            nameMangler.getParameterNames(func));\n+            NameMangler.getParameterNames(func));\n@@ -238,0 +235,3 @@\n+        if (funcTree.getAttribute(Skip.class).isPresent()) {\n+            return null;\n+        }\n@@ -256,1 +256,1 @@\n-                String fiName = nameMangler.getFiName(funcTree, i, param);\n+                String fiName = NameMangler.getFiName(param);\n@@ -267,1 +267,1 @@\n-             if (! generateFunctionalInterface(returnFunc, nameMangler.getReturnFiName(funcTree))) {\n+             if (! generateFunctionalInterface(returnFunc, NameMangler.getFiName(funcTree))) {\n@@ -272,1 +272,1 @@\n-        toplevelBuilder.addFunction(funcTree, descriptor, nameMangler.getJavaName(parent, funcTree),\n+        toplevelBuilder.addFunction(funcTree, descriptor, NameMangler.getJavaName(funcTree),\n@@ -275,1 +275,1 @@\n-                map(param -> nameMangler.getJavaName(null, param)).\n+                map(NameMangler::getJavaName).\n@@ -293,0 +293,3 @@\n+        if (tree.getAttribute(Skip.class).isPresent()) {\n+            return null;\n+        }\n@@ -314,1 +317,1 @@\n-                                String javaName = nameMangler.getJavaName(parent, tree);\n+                                String javaName = NameMangler.getJavaName(tree);\n@@ -329,1 +332,1 @@\n-            toplevelBuilder.addTypedef(tree, nameMangler.getJavaName(parent, tree), null);\n+            toplevelBuilder.addTypedef(tree, NameMangler.getJavaName(tree), null);\n@@ -333,1 +336,1 @@\n-                String fiName = nameMangler.getFiName(parent, tree);\n+                String fiName = NameMangler.getFiName(tree);\n@@ -339,1 +342,1 @@\n-                toplevelBuilder.addTypedef(tree, nameMangler.getJavaName(parent, tree), null);\n+                toplevelBuilder.addTypedef(tree, NameMangler.getJavaName(tree), null);\n@@ -343,1 +346,1 @@\n-                    toplevelBuilder.addTypedef(tree, nameMangler.getJavaName(parent, tree), null, primitive);\n+                    toplevelBuilder.addTypedef(tree, NameMangler.getJavaName(tree), null, primitive);\n@@ -352,0 +355,3 @@\n+        if (tree.getAttribute(Skip.class).isPresent()) {\n+            return null;\n+        }\n@@ -395,1 +401,1 @@\n-            fiName = nameMangler.getFiName(parent, tree);\n+            fiName = NameMangler.getFiName(tree);\n@@ -406,1 +412,1 @@\n-        currentBuilder.addVar(tree, nameMangler.getJavaName(parent, tree), layout, Optional.ofNullable(fiName));\n+        currentBuilder.addVar(tree, NameMangler.getJavaName(tree), layout, Optional.ofNullable(fiName));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":33,"deletions":27,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.constant.Constable;\n@@ -31,1 +30,0 @@\n-import java.util.Collection;\n@@ -60,0 +58,2 @@\n+    Map<Position, Declaration> declarationCache = new HashMap<>();\n+\n@@ -106,12 +106,19 @@\n-        return switch (c.kind()) {\n-            case EnumDecl -> createEnum(c);\n-            case EnumConstantDecl -> createEnumConstant(c);\n-            case FieldDecl -> createVar(c, Declaration.Variable.Kind.FIELD);\n-            case ParmDecl -> createVar(c, Declaration.Variable.Kind.PARAMETER);\n-            case FunctionDecl -> createFunction(c);\n-            case StructDecl -> createRecord(c, Declaration.Scoped.Kind.STRUCT);\n-            case UnionDecl -> createRecord(c, Declaration.Scoped.Kind.UNION);\n-            case TypedefDecl -> createTypedef(c);\n-            case VarDecl -> createVar(c, Declaration.Variable.Kind.GLOBAL);\n-            default -> null; \/\/ skip\n-        };\n+        Position pos = CursorPosition.of(c);\n+        \/\/ dedup multiple declarations that point to the same source location\n+        Declaration decl = declarationCache.get(pos);\n+        if (decl == null) {\n+            decl = switch (c.kind()) {\n+                case EnumDecl -> createEnum(c);\n+                case EnumConstantDecl -> createEnumConstant(c);\n+                case FieldDecl -> createVar(c, Declaration.Variable.Kind.FIELD);\n+                case ParmDecl -> createVar(c, Declaration.Variable.Kind.PARAMETER);\n+                case FunctionDecl -> createFunction(c);\n+                case StructDecl -> createRecord(c, Declaration.Scoped.Kind.STRUCT);\n+                case UnionDecl -> createRecord(c, Declaration.Scoped.Kind.UNION);\n+                case TypedefDecl -> createTypedef(c);\n+                case VarDecl -> createVar(c, Declaration.Variable.Kind.GLOBAL);\n+                default -> null; \/\/ skip\n+            };\n+            declarationCache.put(pos, decl);\n+        }\n+        return decl;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeMaker.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserveold.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.jextract.impl;\n-\n-import java.util.List;\n-import org.openjdk.jextract.Declaration;\n-\n-interface TreeTransformer {\n-    Declaration.Scoped transform(Declaration.Scoped header);\n-\n-    default Declaration.Scoped createHeader(Declaration.Scoped old, List<Declaration> members) {\n-        return Declaration.toplevel(old.pos(), members.toArray(new Declaration[0]));\n-    }\n-\n-    default Declaration.Scoped createScoped(Declaration.Scoped old, List<Declaration> members) {\n-        var declsArray = members.toArray(new Declaration[0]);\n-        return old.layout().isEmpty() ?\n-            Declaration.scoped(old.kind(), old.pos(), old.name(), declsArray) :\n-            Declaration.scoped(old.kind(), old.pos(), old.name(), old.layout().get(), declsArray);\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeTransformer.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"}]}