{"files":[{"patch":"@@ -29,2 +29,1 @@\n-import java.lang.constant.Constable;\n-import java.util.Collection;\n+import java.lang.foreign.FunctionDescriptor;\n@@ -34,1 +33,0 @@\n-import java.util.Set;\n@@ -36,0 +34,1 @@\n+\n@@ -113,8 +112,0 @@\n-            \/**\n-             * Namespace declaration.\n-             *\/\n-            NAMESPACE,\n-            \/**\n-             * Class declaration.\n-             *\/\n-            CLASS,\n@@ -149,10 +140,0 @@\n-        \/**\n-         * The (optional) layout associated with this scoped declaration.\n-         * @return The (optional) layout associated with this scoped declaration.\n-         *\n-         * @implSpec a layout is present if the scoped declaration kind is one of {@link Kind#STRUCT}, {@link Kind#UNION},\n-         * {@link Kind#ENUM}, {@link Kind#BITFIELDS}, {@link Kind#CLASS} <em>and<\/em> if this declaration models an entity in the foreign\n-         * language that is associated with a <em>definition<\/em>.\n-         *\/\n-        Optional<MemoryLayout> layout();\n-\n@@ -221,4 +202,0 @@\n-        \/**\n-         * {@return The bitfield offset (relative to the enclosing container)}\n-         *\/\n-        long offset();\n@@ -343,2 +320,0 @@\n-     * @param offset the offset of the bitfield (relative to the enclosing container).\n-     * @param width the bitfield width.\n@@ -347,2 +322,2 @@\n-    static Declaration.Variable bitfield(Position pos, String name, Type type, long offset, long width) {\n-        return new DeclarationImpl.BitfieldImpl(type, offset, width, name, pos);\n+    static Declaration.Variable bitfield(Position pos, String name, long width, Type type) {\n+        return new DeclarationImpl.BitfieldImpl(type, width, name, pos);\n@@ -385,12 +360,0 @@\n-    \/**\n-     * Creates a new namespace declaration with given name and member declarations.\n-     * @param pos the namespace declaration position.\n-     * @param name the namespace declaration name.\n-     * @param decls the namespace declaration member declarations.\n-     * @return a new namespace declaration with given name and member declarations.\n-     *\/\n-    static Declaration.Scoped namespace(Position pos, String name, Declaration... decls) {\n-        List<Declaration> declList = List.of(decls);\n-        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.NAMESPACE, declList, name, pos);\n-    }\n-\n@@ -420,13 +383,0 @@\n-    \/**\n-     * Creates a new struct declaration with given name, layout and member declarations.\n-     * @param pos the struct declaration position.\n-     * @param name the struct declaration name.\n-     * @param layout the struct declaration layout.\n-     * @param decls the struct declaration member declarations.\n-     * @return a new struct declaration with given name, layout and member declarations.\n-     *\/\n-    static Declaration.Scoped struct(Position pos, String name, MemoryLayout layout, Declaration... decls) {\n-        List<Declaration> declList = List.of(decls);\n-        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.STRUCT, layout, declList, name, pos);\n-    }\n-\n@@ -445,38 +395,0 @@\n-    \/**\n-     * Creates a new union declaration with given name, layout and member declarations.\n-     * @param pos the union declaration position.\n-     * @param name the union declaration name.\n-     * @param layout the union declaration layout.\n-     * @param decls the union declaration member declarations.\n-     * @return a new union declaration with given name, layout and member declarations.\n-     *\/\n-    static Declaration.Scoped union(Position pos, String name, MemoryLayout layout, Declaration... decls) {\n-        List<Declaration> declList = List.of(decls);\n-        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.UNION, layout, declList, name, pos);\n-    }\n-\n-    \/**\n-     * Creates a new class declaration with given name and member declarations.\n-     * @param pos the class declaration position.\n-     * @param name the class declaration name.\n-     * @param decls the class declaration member declarations.\n-     * @return a new class declaration with given name and member declarations.\n-     *\/\n-    static Declaration.Scoped class_(Position pos, String name, Declaration... decls) {\n-        List<Declaration> declList = List.of(decls);\n-        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.CLASS, declList, name, pos);\n-    }\n-\n-    \/**\n-     * Creates a new class declaration with given name, layout and member declarations.\n-     * @param pos the class declaration position.\n-     * @param name the class declaration name.\n-     * @param layout the class declaration layout.\n-     * @param decls the class declaration member declarations.\n-     * @return a new class declaration with given name, layout and member declarations.\n-     *\/\n-    static Declaration.Scoped class_(Position pos, String name, MemoryLayout layout, Declaration... decls) {\n-        List<Declaration> declList = List.of(decls);\n-        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.CLASS, layout, declList, name, pos);\n-    }\n-\n@@ -495,13 +407,0 @@\n-    \/**\n-     * Creates a new enum declaration with given name, layout and member declarations.\n-     * @param pos the enum declaration position.\n-     * @param name the enum declaration name.\n-     * @param layout the enum declaration layout.\n-     * @param decls the enum declaration member declarations.\n-     * @return a new enum declaration with given name, layout and member declarations.\n-     *\/\n-    static Declaration.Scoped enum_(Position pos, String name, MemoryLayout layout, Declaration... decls) {\n-        List<Declaration> declList = List.of(decls);\n-        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.ENUM, layout, declList, name, pos);\n-    }\n-\n@@ -521,14 +420,0 @@\n-    \/**\n-     * Creates a new scoped declaration with given kind, name, layout and member declarations.\n-     * @param kind the kind of the scoped declaration.\n-     * @param pos the scoped declaration position.\n-     * @param name the scoped declaration name.\n-     * @param layout the scoped declaration layout.\n-     * @param decls the scoped declaration member declarations.\n-     * @return a new scoped declaration with given kind, name, layout and member declarations.\n-     *\/\n-    static Declaration.Scoped scoped(Scoped.Kind kind, Position pos, String name, MemoryLayout layout, Declaration... decls) {\n-        List<Declaration> declList = List.of(decls);\n-        return new DeclarationImpl.ScopedImpl(kind, layout, declList, name, pos);\n-    }\n-\n@@ -559,0 +444,24 @@\n+    \/**\n+     * Compute the layout for a given declaration.\n+     * @param d the declaration.\n+     * @return the layout for given declaration.\n+     *\/\n+    static Optional<MemoryLayout> layoutFor(Declaration d) {\n+        return switch (d) {\n+            case Scoped scoped -> DeclarationImpl.layoutFor(scoped);\n+            case Variable var -> Type.layoutFor(var.type());\n+            case Typedef typedef -> Type.layoutFor(typedef.type());\n+            case Constant constant -> Type.layoutFor(constant.type());\n+            default -> Optional.empty();\n+        };\n+    }\n+\n+    \/**\n+     * Compute the function descriptor for a given function declaration.\n+     * @param function the function declaration.\n+     * @return the function descriptor for given function declaration.\n+     *\/\n+    static Optional<FunctionDescriptor> descriptorFor(Function function) {\n+        return Type.descriptorFor(function.type());\n+    }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Declaration.java","additions":28,"deletions":119,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -33,0 +32,1 @@\n+import org.openjdk.jextract.impl.TypeImpl.ErronrousTypeImpl;\n@@ -93,1 +93,1 @@\n-            Void(\"void\", null),\n+            Void(\"void\"),\n@@ -97,1 +97,1 @@\n-            Bool(\"_Bool\", ValueLayout.JAVA_BOOLEAN),\n+            Bool(\"_Bool\"),\n@@ -101,1 +101,1 @@\n-            Char(\"char\", ValueLayout.JAVA_BYTE),\n+            Char(\"char\"),\n@@ -105,1 +105,1 @@\n-            Char16(\"char16\", unsupportedLayout(2, \"char16\")),\n+            Char16(\"char16\"),\n@@ -109,1 +109,1 @@\n-            Short(\"short\", ValueLayout.JAVA_SHORT),\n+            Short(\"short\"),\n@@ -113,1 +113,1 @@\n-            Int(\"int\", ValueLayout.JAVA_INT),\n+            Int(\"int\"),\n@@ -117,3 +117,1 @@\n-            Long(\"long\", TypeImpl.IS_WINDOWS ?\n-                ValueLayout.JAVA_INT :\n-                ValueLayout.JAVA_LONG),\n+            Long(\"long\"),\n@@ -123,1 +121,1 @@\n-            LongLong(\"long long\", ValueLayout.JAVA_LONG),\n+            LongLong(\"long long\"),\n@@ -127,1 +125,1 @@\n-            Int128(\"__int128\", unsupportedLayout(16, \"__int128\")),\n+            Int128(\"__int128\"),\n@@ -131,1 +129,1 @@\n-            Float(\"float\", ValueLayout.JAVA_FLOAT),\n+            Float(\"float\"),\n@@ -135,1 +133,1 @@\n-            Double(\"double\", ValueLayout.JAVA_DOUBLE),\n+            Double(\"double\"),\n@@ -139,3 +137,1 @@\n-            LongDouble(\"long double\", TypeImpl.IS_WINDOWS ?\n-                    ValueLayout.JAVA_DOUBLE :\n-                    unsupportedLayout(16, \"long double\")),\n+            LongDouble(\"long double\"),\n@@ -145,1 +141,1 @@\n-            Float128(\"float128\", unsupportedLayout(16, \"_float128\")),\n+            Float128(\"float128\"),\n@@ -149,1 +145,1 @@\n-            HalfFloat(\"__fp16\", unsupportedLayout(2, \"__fp16\")),\n+            HalfFloat(\"__fp16\"),\n@@ -153,1 +149,1 @@\n-            WChar(\"wchar_t\", unsupportedLayout(2, \"wchar_t\"));\n+            WChar(\"wchar_t\");\n@@ -156,1 +152,0 @@\n-            private final MemoryLayout layout;\n@@ -158,1 +153,1 @@\n-            Kind(String typeName, MemoryLayout layout) {\n+            Kind(String typeName) {\n@@ -160,1 +155,0 @@\n-                this.layout = layout;\n@@ -166,12 +160,0 @@\n-\n-            \/**\n-             * The primitive type (optional) layout.\n-             * @return The primitive type (optional) layout.\n-             *\/\n-            public Optional<MemoryLayout> layout() {\n-                return Optional.ofNullable(layout);\n-            }\n-\n-            private static MemoryLayout unsupportedLayout(long size, String name) {\n-                return MemoryLayout.paddingLayout(size).withByteAlignment(size).withName(name);\n-            }\n@@ -528,2 +510,2 @@\n-     * Creates an erroneous type.\n-     * @return an erroneous type.\n+     * Creates an erroneous type with the given name.\n+     * @return an erroneous type with the given name.\n@@ -531,2 +513,2 @@\n-    static Type error() {\n-        return TypeImpl.ERROR;\n+    static Type error(String erroneousName) {\n+        return new ErronrousTypeImpl(erroneousName);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Type.java","additions":21,"deletions":39,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -30,0 +30,6 @@\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.StructLayout;\n+import java.util.ArrayList;\n@@ -34,1 +40,2 @@\n-import java.lang.foreign.MemoryLayout;\n+import java.util.OptionalLong;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -37,0 +44,1 @@\n+import org.openjdk.jextract.Declaration.Scoped.Kind;\n@@ -39,0 +47,1 @@\n+import org.openjdk.jextract.Type.Declared;\n@@ -112,1 +121,0 @@\n-        final Optional<MemoryLayout> layout;\n@@ -114,1 +122,2 @@\n-        private VariableImpl(Type type, Optional<MemoryLayout> layout, Variable.Kind kind, String name, Position pos, Map<String, List<Constable>> attrs) {\n+        private VariableImpl(Type type, Variable.Kind kind, String name,\n+                             Position pos, Map<String, List<Constable>> attrs) {\n@@ -118,1 +127,0 @@\n-            this.layout = Objects.requireNonNull(layout);\n@@ -122,5 +130,1 @@\n-            this(type, TypeImpl.getLayout(type), kind, name, pos, null);\n-        }\n-\n-        public VariableImpl(Type type, MemoryLayout layout, Variable.Kind kind, String name, Position pos) {\n-            this(type, Optional.of(layout), kind, name, pos, null);\n+            this(type, kind, name, pos, null);\n@@ -161,1 +165,0 @@\n-        final long offset;\n@@ -164,3 +167,2 @@\n-        private BitfieldImpl(Type type, long offset, long width, String name, Position pos, Map<String, List<Constable>> attrs) {\n-            super(type, Optional.<MemoryLayout>empty(), Kind.BITFIELD, name, pos, attrs);\n-            this.offset = offset;\n+        private BitfieldImpl(Type type, long width, String name, Position pos, Map<String, List<Constable>> attrs) {\n+            super(type, Kind.BITFIELD, name, pos, attrs);\n@@ -170,7 +172,2 @@\n-        public BitfieldImpl(Type type, long offset, long width, String name, Position pos) {\n-            this(type, offset, width, name, pos, null);\n-        }\n-\n-        @Override\n-        public long offset() {\n-            return offset;\n+        public BitfieldImpl(Type type, long width, String name, Position pos) {\n+            this(type, width, name, pos, null);\n@@ -189,2 +186,1 @@\n-            return offset == bitfield.offset &&\n-                    width == bitfield.width;\n+            return width == bitfield.width;\n@@ -195,1 +191,1 @@\n-            return Objects.hash(super.hashCode(), offset, width);\n+            return Objects.hash(super.hashCode(), width);\n@@ -247,5 +243,0 @@\n-        private final Optional<MemoryLayout> optLayout;\n-\n-        public ScopedImpl(Kind kind, MemoryLayout layout, List<Declaration> declarations, String name, Position pos) {\n-            this(kind, Optional.of(layout), declarations, name, pos, null);\n-        }\n@@ -254,1 +245,1 @@\n-            this(kind, Optional.empty(), declarations, name, pos, null);\n+            this(kind, declarations, name, pos, null);\n@@ -257,1 +248,1 @@\n-        ScopedImpl(Kind kind, Optional<MemoryLayout> optLayout, List<Declaration> declarations,\n+        ScopedImpl(Kind kind, List<Declaration> declarations,\n@@ -262,1 +253,0 @@\n-            this.optLayout = Objects.requireNonNull(optLayout);\n@@ -275,5 +265,0 @@\n-        @Override\n-        public Optional<MemoryLayout> layout() {\n-            return optLayout;\n-        }\n-\n@@ -345,0 +330,133 @@\n+    public static Optional<MemoryLayout> layoutFor(Scoped scoped) {\n+        Optional<MemoryLayout> layout = ScopedLayout.get(scoped);\n+        if (layout.isPresent()) {\n+            return layout;\n+        } else {\n+            \/\/ compute and cache for later use\n+            switch (scoped.kind()) {\n+                case Kind.STRUCT, Kind.UNION -> {\n+                    if (ClangSizeOf.get(scoped).isPresent()) {\n+                        Optional<MemoryLayout> recordLayout = recordLayout(scoped);\n+                        recordLayout.ifPresent(memoryLayout -> ScopedLayout.with(scoped, memoryLayout));\n+                        return recordLayout;\n+                    }\n+                }\n+                case Kind.ENUM -> {\n+                    Optional<MemoryLayout> constLayout = Type.layoutFor(((Constant)scoped.members().get(0)).type());\n+                    constLayout.ifPresent(memoryLayout -> ScopedLayout.with(scoped, memoryLayout));\n+                    return constLayout;\n+                }\n+            }\n+            return Optional.empty();\n+        }\n+    }\n+\n+    \/\/ Note: this method always returns the same result when called on the same tree. More specifically,\n+    \/\/ even if a client calls this method on a nested anonymous struct, the nested layout is computed\n+    \/\/ correctly, as if it was computed as part of the enclosing non-anonymous struct. This ensures maximum\n+    \/\/ flexibility, as there is no specific order in which clients should obtain layouts for scoped declarations.\n+    private static Optional<MemoryLayout> recordLayout(Scoped scoped) {\n+        boolean isStruct = scoped.kind() == Kind.STRUCT;\n+        String name = scoped.name().isEmpty() ?\n+                \"$anon$\" + scoped.pos().line() + \":\" + scoped.pos().col() :\n+                scoped.name();\n+\n+        long offset = 0;\n+        if (AnonymousStruct.isPresent(scoped)) {\n+            \/\/ find the starting offset of this anon declaration inside its\n+            \/\/ innermost non-anonymous container\n+            OptionalLong firstOffset = nextOffset(scoped);\n+            if (firstOffset.isEmpty()) {\n+                return Optional.empty();\n+            }\n+            offset = firstOffset.getAsLong();\n+        }\n+\n+        long size = 0L; \/\/ bits\n+        List<MemoryLayout> memberLayouts = new ArrayList<>();\n+        for (Declaration member : scoped.members()) {\n+            if (member instanceof Scoped nested && nested.kind() == Kind.BITFIELDS) {\n+                \/\/ skip\n+            } else if (nextOffset(member).isPresent()) {\n+                long nextOffset = nextOffset(member).getAsLong();\n+                long delta = nextOffset - offset;\n+                if (delta > 0) {\n+                    memberLayouts.add(MemoryLayout.paddingLayout(delta \/ 8));\n+                    offset += delta;\n+                    if (isStruct) {\n+                        size += delta;\n+                    }\n+                }\n+                Optional<MemoryLayout> layout = Declaration.layoutFor(member);\n+                if (layout.isPresent()) {\n+                    MemoryLayout memberLayout = layout.get();\n+                    if (member instanceof Variable) {\n+                        memberLayout = memberLayout.withName(member.name());\n+                    }\n+                    memberLayouts.add(memberLayout);\n+                    \/\/ update offset and size\n+                    long fieldSize = ClangSizeOf.getOrThrow(member);\n+                    if (isStruct) {\n+                        offset += fieldSize;\n+                        size += fieldSize;\n+                    } else {\n+                        size = Math.max(size, ClangSizeOf.getOrThrow(member));\n+                    }\n+                }\n+            }\n+        }\n+        long expectedSize = ClangSizeOf.getOrThrow(scoped);\n+        if (size != expectedSize) {\n+            memberLayouts.add(MemoryLayout.paddingLayout((expectedSize - size) \/ 8));\n+        }\n+        long align = ClangAlignOf.getOrThrow(scoped) \/ 8;\n+        GroupLayout layout = isStruct ?\n+                MemoryLayout.structLayout(alignFields(memberLayouts, align)) :\n+                MemoryLayout.unionLayout(alignFields(memberLayouts, align));\n+        return Optional.of(layout.withName(name));\n+    }\n+\n+    private static OptionalLong nextOffset(Declaration member) {\n+        if (member instanceof Variable) {\n+            return ClangOffsetOf.get(member);\n+        } else {\n+            Optional<Declaration> firstDecl = ((Scoped)member).members().stream().findFirst();\n+            return firstDecl.isEmpty() ?\n+                    OptionalLong.empty() :\n+                    nextOffset(firstDecl.get());\n+        }\n+    }\n+\n+    private static MemoryLayout[] alignFields(List<MemoryLayout> members, long align) {\n+        return members.stream()\n+                .map(l -> forceAlign(l, align))\n+                .toArray(MemoryLayout[]::new);\n+    }\n+\n+    private static MemoryLayout forceAlign(MemoryLayout layout, long align) {\n+        if (align >= layout.byteAlignment()) {\n+            return layout; \/\/ fast-path\n+        }\n+        MemoryLayout res = switch (layout) {\n+            case GroupLayout groupLayout -> {\n+                MemoryLayout[] newMembers = groupLayout.memberLayouts()\n+                        .stream().map(l -> forceAlign(l, align)).toArray(MemoryLayout[]::new);\n+                yield groupLayout instanceof StructLayout ?\n+                        MemoryLayout.structLayout(newMembers) :\n+                        MemoryLayout.unionLayout(newMembers);\n+            }\n+            case SequenceLayout sequenceLayout ->\n+                    MemoryLayout.sequenceLayout(sequenceLayout.elementCount(),\n+                            forceAlign(sequenceLayout.elementLayout(), align));\n+            default -> layout.withByteAlignment(align);\n+        };\n+        \/\/ copy name and target layout, if present\n+        if (layout.name().isPresent()) {\n+            res = res.withName(layout.name().get());\n+        }\n+        if (layout instanceof AddressLayout addressLayout && addressLayout.targetLayout().isPresent()) {\n+            ((AddressLayout)res).withTargetLayout(addressLayout.targetLayout().get());\n+        }\n+        return res;\n+    }\n+\n@@ -454,0 +572,71 @@\n+\n+    \/**\n+     * An attribute to attach a layout to a scoped declaration.\n+     *\/\n+    record ScopedLayout(MemoryLayout layout) {\n+        public static void with(Scoped declaration, MemoryLayout layout) {\n+            declaration.addAttribute(new ScopedLayout(layout));\n+        }\n+\n+        public static Optional<MemoryLayout> get(Scoped declaration) {\n+            return declaration.getAttribute(ScopedLayout.class)\n+                    .map(ScopedLayout::layout);\n+        }\n+    }\n+\n+    \/**\n+     * An attribute to attach alignment info to a declaration.\n+     *\/\n+    record ClangAlignOf(long align) {\n+        public static void with(Declaration declaration, long align) {\n+            declaration.addAttribute(new ClangAlignOf(align));\n+        }\n+\n+        public static OptionalLong get(Declaration declaration) {\n+            return declaration.getAttribute(ClangAlignOf.class)\n+                    .stream().mapToLong(ClangAlignOf::align).findFirst();\n+        }\n+\n+        public static long getOrThrow(Declaration declaration) {\n+            return declaration.getAttribute(ClangAlignOf.class)\n+                    .stream().mapToLong(ClangAlignOf::align).findFirst().getAsLong();\n+        }\n+    }\n+\n+    \/**\n+     * An attribute to attach size info to a declaration.\n+     *\/\n+    record ClangSizeOf(long size) {\n+        public static void with(Declaration declaration, long size) {\n+            declaration.addAttribute(new ClangSizeOf(size));\n+        }\n+\n+        public static OptionalLong get(Declaration declaration) {\n+            return declaration.getAttribute(ClangSizeOf.class)\n+                    .stream().mapToLong(ClangSizeOf::size).findFirst();\n+        }\n+\n+        public static long getOrThrow(Declaration declaration) {\n+            return declaration.getAttribute(ClangSizeOf.class)\n+                    .stream().mapToLong(ClangSizeOf::size).findFirst().getAsLong();\n+        }\n+    }\n+\n+    \/**\n+     * An attribute to attach offset info to a declaration.\n+     *\/\n+    record ClangOffsetOf(long offset) {\n+        public static void with(Declaration declaration, long size) {\n+            declaration.addAttribute(new ClangOffsetOf(size));\n+        }\n+\n+        public static OptionalLong get(Declaration declaration) {\n+            return declaration.getAttribute(ClangOffsetOf.class)\n+                    .stream().mapToLong(ClangOffsetOf::offset).findFirst();\n+        }\n+\n+        public static long getOrThrow(Declaration declaration) {\n+            return declaration.getAttribute(ClangOffsetOf.class)\n+                    .stream().mapToLong(ClangOffsetOf::offset).findFirst().getAsLong();\n+        }\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/DeclarationImpl.java","additions":225,"deletions":36,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -230,4 +230,1 @@\n-        Type.Primitive.Kind kind = primType.kind();\n-        if (primitiveKindSupported(kind) && kind.layout().isPresent()) {\n-            emitPrimitiveTypedefLayout(name, kind.layout().get(), typedefTree);\n-        }\n+        emitPrimitiveTypedefLayout(name, Type.layoutFor(primType).get(), typedefTree);\n@@ -310,7 +307,0 @@\n-    private boolean primitiveKindSupported(Type.Primitive.Kind kind) {\n-        return switch(kind) {\n-            case Bool, Short, Int, Long, LongLong, Float, Double, Char -> true;\n-            default -> false;\n-        };\n-    }\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -340,1 +340,1 @@\n-            TreeMaker treeMaker = new TreeMaker();\n+            TreeMaker treeMaker = new TreeMaker(); \/\/ @@@: what about de-duplicated declarations?\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/MacroParserImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.ScopedLayout;\n@@ -35,3 +36,0 @@\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n@@ -39,4 +37,0 @@\n-import java.net.URL;\n-import java.net.URISyntaxException;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n@@ -46,1 +40,0 @@\n-import java.util.stream.Collectors;\n@@ -109,1 +102,1 @@\n-            GroupLayout layout = (GroupLayout) layoutFor(d);\n+            GroupLayout layout = (GroupLayout)Declaration.layoutFor(d).get();\n@@ -181,1 +174,1 @@\n-                            toplevelBuilder.addTypedef(tree, s.layout().isEmpty() ? null : JavaName.getFullNameOrThrow(s));\n+                            toplevelBuilder.addTypedef(tree, JavaName.getFullNameOrThrow(s));\n@@ -231,11 +224,0 @@\n-    protected static MemoryLayout layoutFor(Declaration decl) {\n-        if (decl instanceof Declaration.Typedef alias) {\n-            return Type.layoutFor(alias.type()).orElseThrow();\n-        } else if (decl instanceof Declaration.Scoped scoped) {\n-            return scoped.layout().orElseThrow();\n-        } else {\n-            throw new IllegalArgumentException(\"Unexpected parent declaration\");\n-        }\n-        \/\/ case like `typedef struct { ... } Foo`\n-    }\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":3,"deletions":21,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.constant.Constable;\n@@ -31,1 +30,0 @@\n-import java.util.Set;\n@@ -33,1 +31,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -36,1 +33,0 @@\n-import org.openjdk.jextract.Declaration.Variable.Kind;\n@@ -87,2 +83,1 @@\n-        builder.append(\"Scoped: \" + d.kind() + \" \" + d.name() + d.layout().map(l -> \" layout = \" + l).orElse(\"\"));\n-        builder.append(\"\\n\");\n+        builder.append(\"Scoped: \" + d.kind() + \" \" + d.name() + \"\\n\");\n@@ -113,1 +108,1 @@\n-                    + \", offset = \" + bitfield.offset() + \", width = \" + bitfield.width());\n+                    + \", width = \" + bitfield.width());\n@@ -143,1 +138,1 @@\n-            return t.kind().toString() + t.kind().layout().map(l -> \"(layout = \" + l + \")\").orElse(\"\");\n+            return t.kind().toString() + Type.layoutFor(t).map(l -> \"(layout = \" + l + \")\").orElse(\"\");\n@@ -169,1 +164,1 @@\n-            return \"Declared(\" + t.tree().layout().map(MemoryLayout::toString).orElse(\"\") + \")\";\n+            return \"Declared(\" + t.tree().name() + \")\";\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/PrettyPrinter.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,245 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package org.openjdk.jextract.impl;\n-\n-import java.lang.foreign.AddressLayout;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import org.openjdk.jextract.Declaration;\n-import org.openjdk.jextract.clang.Cursor;\n-import org.openjdk.jextract.clang.CursorKind;\n-import org.openjdk.jextract.clang.Type;\n-import org.openjdk.jextract.clang.TypeKind;\n-import org.openjdk.jextract.impl.DeclarationImpl.AnonymousStruct;\n-\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.StructLayout;\n-import java.lang.foreign.ValueLayout;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\/**\n- * Base class for C struct, union MemoryLayout computer helper classes.\n- *\/\n-abstract class RecordLayoutComputer {\n-    \/\/ enclosing struct type (or this struct type for top level structs)\n-    final Type parent;\n-    \/\/ this struct type\n-    final Type type;\n-    \/\/ cursor of this struct\n-    final Cursor cursor;\n-    final List<Declaration> fieldDecls;\n-    final List<MemoryLayout> fieldLayouts;\n-\n-    final TypeMaker typeMaker;\n-\n-    private int anonCount = 0;\n-\n-    RecordLayoutComputer(TypeMaker typeMaker, Type parent, Type type) {\n-        this.parent = parent;\n-        this.type = type;\n-        this.cursor = type.getDeclarationCursor().getDefinition();\n-        this.fieldDecls = new ArrayList<>();\n-        this.fieldLayouts = new ArrayList<>();\n-        this.typeMaker = typeMaker;\n-    }\n-\n-    static org.openjdk.jextract.Type compute(TypeMaker typeMaker, long offsetInParent, Type parent, Type type) {\n-        return computeInternal(typeMaker, offsetInParent, parent, type, null);\n-    }\n-\n-    private static org.openjdk.jextract.Type computeAnonymous(TypeMaker typeMaker, long offsetInParent, Type parent, Type type, String name) {\n-        return computeInternal(typeMaker, offsetInParent, parent, type, name);\n-    }\n-\n-    static final org.openjdk.jextract.Type.Declared ERRONEOUS = org.openjdk.jextract.Type.declared(\n-            Declaration.struct(TreeMaker.CursorPosition.NO_POSITION, \"\", MemoryLayout.paddingLayout(8)));\n-\n-    private static org.openjdk.jextract.Type computeInternal(TypeMaker typeMaker, long offsetInParent, Type parent, Type type, String name) {\n-        Cursor cursor = type.getDeclarationCursor().getDefinition();\n-        if (cursor.isInvalid()) {\n-            return ERRONEOUS;\n-        }\n-\n-        final boolean isUnion = cursor.kind() == CursorKind.UnionDecl;\n-        return isUnion? new UnionLayoutComputer(typeMaker, offsetInParent, parent, type).compute(name) :\n-                new StructLayoutComputer(typeMaker, offsetInParent, parent, type).compute(name);\n-    }\n-\n-    final org.openjdk.jextract.Type.Declared compute(String anonName) {\n-        cursor.forEach(fc -> {\n-            if (Utils.isFlattenable(fc)) {\n-                \/*\n-                 * Ignore bitfields of zero width.\n-                 *\n-                 * struct Foo {\n-                 *     int i:0;\n-                 * }\n-                 *\n-                 * And bitfields without a name.\n-                 * (padding is computed automatically)\n-                 *\/\n-                if (fc.isBitField() && (fc.getBitFieldWidth() == 0 || fc.spelling().isEmpty())) {\n-                    startBitfield();\n-                } else {\n-                    processField(fc);\n-                }\n-            }\n-        });\n-\n-        String declName = recordName();\n-        Declaration.Scoped declaration = finishRecord(anonName != null ? anonName : declName, declName);\n-        if (cursor.isAnonymousStruct()) {\n-            \/\/ record this with a declaration attribute, so we don't have to rely on the cursor again later\n-            AnonymousStruct.with(declaration);\n-        }\n-        return org.openjdk.jextract.Type.declared(declaration);\n-    }\n-\n-    abstract void startBitfield();\n-    abstract void processField(Cursor c);\n-    abstract Declaration.Scoped finishRecord(String layoutName, String declName);\n-\n-    void addField(long offset, Declaration declaration) {\n-        fieldDecls.add(declaration);\n-        MemoryLayout layout = null;\n-        if (declaration instanceof Declaration.Scoped scoped) {\n-            layout = scoped.layout().orElse(null);\n-        } else if (declaration instanceof Declaration.Variable var) {\n-            layout = org.openjdk.jextract.Type.layoutFor(var.type()).orElse(null);\n-        }\n-        if (layout != null) {\n-            fieldLayouts.add(declaration.name().isEmpty() ? layout : layout.withName(declaration.name()));\n-        }\n-    }\n-\n-    void addPadding(long bits) {\n-        fieldLayouts.add(MemoryLayout.paddingLayout(bits \/ 8));\n-    }\n-\n-    void addField(long offset, Type parent, Cursor c) {\n-        if (c.isAnonymousStruct()) {\n-            addField(offset, ((org.openjdk.jextract.Type.Declared)computeAnonymous(typeMaker, offset, parent, c.type(), nextAnonymousName())).tree());\n-        } else {\n-            addField(offset, field(offset, c));\n-        }\n-    }\n-\n-    private String nextAnonymousName() {\n-        return \"$anon$\" + anonCount++;\n-    }\n-\n-    Declaration field(long offset, Cursor c) {\n-        org.openjdk.jextract.Type type = typeMaker.makeType(c.type());\n-        String name = c.spelling();\n-        if (c.isBitField()) {\n-            return Declaration.bitfield(TreeMaker.CursorPosition.of(c), name, type, offset, c.getBitFieldWidth());\n-        } else if (c.isAnonymousStruct() && type instanceof org.openjdk.jextract.Type.Declared decl) {\n-            return decl.tree();\n-        } else {\n-            return Declaration.field(TreeMaker.CursorPosition.of(c), name, type);\n-        }\n-    }\n-\n-    long fieldSize(Cursor c) {\n-        if (c.type().kind() == TypeKind.IncompleteArray) {\n-            return 0;\n-        }\n-        return c.isBitField() ? c.getBitFieldWidth() : c.type().size() * 8;\n-    }\n-\n-    Declaration.Scoped bitfield(Declaration.Variable... declarations) {\n-        return Declaration.bitfields(declarations[0].pos(), declarations);\n-    }\n-\n-    long offsetOf(Type parent, Cursor c) {\n-        if (c.kind() == CursorKind.FieldDecl) {\n-            return parent.getOffsetOf(c.spelling());\n-        } else {\n-            List<Long> offsets = new ArrayList<>();\n-            c.forEach(child -> {\n-                if (Utils.isFlattenable(child)) {\n-                    offsets.add(offsetOf(parent, child));\n-                }\n-            });\n-            return offsets.stream().findFirst()\n-                    .orElseThrow(() -> new IllegalStateException(\n-                            \"Can not find offset of: \" + c + \", in: \" + parent));\n-        }\n-    }\n-\n-    void checkSize(GroupLayout layout) {\n-        \/\/ sanity check\n-        if (cursor.type().size() != layout.byteSize()) {\n-            throw new AssertionError(\n-                    String.format(\"Unexpected size for layout %s. Found %d ; expected %d\",\n-                            layout, layout.byteSize(), cursor.type().size()));\n-        }\n-    }\n-\n-    private String recordName() {\n-        if (cursor.isAnonymous()) {\n-            return \"\";\n-        } else {\n-            return cursor.spelling();\n-        }\n-    }\n-\n-    MemoryLayout[] alignFields() {\n-        long align = cursor.type().align();\n-        return fieldLayouts.stream()\n-                .map(l -> forceAlign(l, align))\n-                .toArray(MemoryLayout[]::new);\n-    }\n-\n-    private static MemoryLayout forceAlign(MemoryLayout layout, long align) {\n-        if (align >= layout.byteAlignment()) {\n-            return layout; \/\/ fast-path\n-        }\n-        MemoryLayout res = switch (layout) {\n-            case GroupLayout groupLayout -> {\n-                MemoryLayout[] newMembers = groupLayout.memberLayouts()\n-                        .stream().map(l -> forceAlign(l, align)).toArray(MemoryLayout[]::new);\n-                yield groupLayout instanceof StructLayout ?\n-                        MemoryLayout.structLayout(newMembers) :\n-                        MemoryLayout.unionLayout(newMembers);\n-            }\n-            case SequenceLayout sequenceLayout ->\n-                MemoryLayout.sequenceLayout(sequenceLayout.elementCount(),\n-                        forceAlign(sequenceLayout.elementLayout(), align));\n-            default -> layout.withByteAlignment(align);\n-        };\n-        \/\/ copy name and target layout, if present\n-        if (layout.name().isPresent()) {\n-            res = res.withName(layout.name().get());\n-        }\n-        if (layout instanceof AddressLayout addressLayout && addressLayout.targetLayout().isPresent()) {\n-            ((AddressLayout)res).withTargetLayout(addressLayout.targetLayout().get());\n-        }\n-        return res;\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/RecordLayoutComputer.java","additions":0,"deletions":245,"binary":false,"changes":245,"status":"deleted"},{"patch":"@@ -1,167 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package org.openjdk.jextract.impl;\n-\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import org.openjdk.jextract.Declaration;\n-import org.openjdk.jextract.clang.Cursor;\n-import org.openjdk.jextract.clang.Type;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\/**\n- * MemoryLayout computer for C structs.\n- *\/\n-final class StructLayoutComputer extends RecordLayoutComputer {\n-    private long offset;\n-    private long actualSize = 0L;\n-    \/\/ List to collect bitfield fields to process later, may be null\n-    private List<Declaration> bitfieldDecls;\n-    private long bitfieldSize;\n-\n-    StructLayoutComputer(TypeMaker typeMaker, long offsetInParent, Type parent, Type type) {\n-        super(typeMaker, parent, type);\n-        this.offset = offsetInParent;\n-    }\n-\n-    @Override\n-    void addField(long offset, Declaration declaration) {\n-        if (bitfieldDecls != null) {\n-            bitfieldDecls.add(declaration);\n-            bitfieldSize += ((Declaration.Bitfield)declaration).width();\n-        } else {\n-            super.addField(offset, declaration);\n-        }\n-    }\n-\n-    @Override\n-    void addPadding(long bits) {\n-        if (bitfieldDecls == null) {\n-            super.addPadding(bits);\n-        } else {\n-            bitfieldSize += bits;\n-        }\n-    }\n-\n-    @Override\n-    void startBitfield() {\n-        \/*\n-         * In a struct, a bitfield field is seen after a non-bitfield.\n-         * Initialize bitfieldLayouts list to collect this and subsequent\n-         * bitfield layouts.\n-         *\/\n-        if (bitfieldDecls == null) {\n-            bitfieldDecls = new ArrayList<>();\n-            bitfieldSize = 0;\n-        }\n-    }\n-\n-    @Override\n-    void processField(Cursor c) {\n-        boolean isBitfield = c.isBitField();\n-        long expectedOffset = offsetOf(parent, c);\n-        if (offset > expectedOffset) {\n-            \/\/ out-of-order field, skip\n-            System.err.println(\"WARNING: ignoring field: \" + c.spelling() + \" in struct \" + type.spelling());\n-            return;\n-        }\n-        if (expectedOffset > offset) {\n-            addPadding(expectedOffset - offset);\n-            actualSize += (expectedOffset - offset);\n-            offset = expectedOffset;\n-        }\n-\n-        if (isBitfield) {\n-            startBitfield();\n-        } else { \/\/ !isBitfield\n-            \/*\n-             * We may be crossing from bit fields to non-bitfield field.\n-             *\n-             * struct Foo {\n-             *     int i:12;\n-             *     int j:20;\n-             *     int k; \/\/ <-- processing this\n-             *     int m;\n-             * }\n-             *\/\n-            handleBitfields();\n-        }\n-\n-        addField(offset, parent, c);\n-        long size = fieldSize(c);\n-        offset += size;\n-        actualSize += size;\n-    }\n-\n-    @Override\n-    Declaration.Scoped finishRecord(String layoutName, String declName) {\n-        \/\/ pad at the end, if any\n-        long expectedSize = type.size() * 8;\n-        if (actualSize < expectedSize) {\n-            addPadding(expectedSize - actualSize);\n-        }\n-\n-        \/*\n-         * Handle bitfields at the end, if any.\n-         *\n-         * struct Foo {\n-         *     int i,j, k;\n-         *     int f:10;\n-         *     int pad:12;\n-         * }\n-         *\/\n-        handleBitfields();\n-\n-        GroupLayout g = MemoryLayout.structLayout(alignFields());\n-        checkSize(g);\n-        g = g.withName(layoutName);\n-        Declaration.Scoped declaration = Declaration.struct(TreeMaker.CursorPosition.of(cursor), declName,\n-                g, fieldDecls.stream().toArray(Declaration[]::new));\n-        return declaration;\n-    }\n-\n-    \/\/ process bitfields if any and clear bitfield layouts\n-    private void handleBitfields() {\n-        if (bitfieldDecls != null) {\n-            List<Declaration> prevBitfieldDecls = bitfieldDecls;\n-            long prevBitfieldSize = bitfieldSize;\n-            bitfieldDecls = null;\n-            bitfieldSize = 0;\n-            if (!prevBitfieldDecls.isEmpty()) {\n-                addField(offset, bitfield(prevBitfieldDecls.toArray(new Declaration.Variable[0])));\n-            }\n-            if (prevBitfieldSize > 0) {\n-                if (prevBitfieldSize % 8 != 0) {\n-                    throw new IllegalStateException(\"Cannot get here: \" + prevBitfieldSize);\n-                }\n-                fieldLayouts.add(MemoryLayout.paddingLayout(prevBitfieldSize \/ 8));\n-            }\n-        }\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructLayoutComputer.java","additions":0,"deletions":167,"binary":false,"changes":167,"status":"deleted"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -37,1 +38,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -41,0 +41,1 @@\n+import org.openjdk.jextract.Declaration.Variable;\n@@ -48,0 +49,1 @@\n+import org.openjdk.jextract.clang.TypeKind;\n@@ -49,0 +51,3 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.ClangAlignOf;\n+import org.openjdk.jextract.impl.DeclarationImpl.ClangOffsetOf;\n+import org.openjdk.jextract.impl.DeclarationImpl.ClangSizeOf;\n@@ -217,1 +222,1 @@\n-        return Declaration.toplevel(CursorPosition.of(c), filterNestedDeclarations(decls).toArray(new Declaration[0]));\n+        return Declaration.toplevel(CursorPosition.of(c), filterHeaderDeclarations(decls).toArray(new Declaration[0]));\n@@ -221,1 +226,1 @@\n-        Type.Declared t = (Type.Declared)RecordLayoutComputer.compute(typeMaker, 0, c.type(), c.type());\n+        checkCursorAny(c, CursorKind.StructDecl, CursorKind.UnionDecl);\n@@ -223,5 +228,2 @@\n-            Declaration.Scoped scoped = t.tree();\n-            List<Declaration> decls = filterNestedDeclarations(scoped.members());\n-            \/\/just a declaration AND definition, we have a layout\n-            return Declaration.scoped(scoped.kind(), scoped.pos(), scoped.name(),\n-                                      scoped.layout().get(), decls.toArray(new Declaration[0]));\n+            Type.Declared t = recordDeclaration(c, c);\n+            return t.tree();\n@@ -237,0 +239,57 @@\n+    final Type.Declared recordDeclaration(Cursor parent, Cursor recordCursor) {\n+        List<Declaration> pendingFields = new ArrayList<>();\n+        List<Variable> pendingBitFields = new ArrayList<>();\n+        AtomicReference<Position> pendingBitfieldsPos = new AtomicReference<>();\n+        recordCursor.forEach(fc -> {\n+            if (Utils.isFlattenable(fc)) {\n+                if (fc.isBitField()) {\n+                    if (pendingBitfieldsPos.get() == null) {\n+                        pendingBitfieldsPos.set(CursorPosition.of(fc));\n+                    }\n+                    Type fieldType = typeMaker.makeType(fc.type());\n+                    Variable bitfieldDecl = Declaration.bitfield(CursorPosition.of(fc), fc.spelling(), fc.getBitFieldWidth(), fieldType);\n+                    if (!fc.spelling().isEmpty()) {\n+                        ClangOffsetOf.with(bitfieldDecl, parent.type().getOffsetOf(fc.spelling()));\n+                    }\n+                    pendingBitFields.add(bitfieldDecl);\n+                } else {\n+                    if (!pendingBitFields.isEmpty()) {\n+                        pendingFields.add(Declaration.bitfields(pendingBitfieldsPos.get(), pendingBitFields.toArray(Variable[]::new)));\n+                        pendingBitFields.clear();\n+                        pendingBitfieldsPos.set(null);\n+                    }\n+                    if (fc.isAnonymousStruct()) {\n+                        \/\/ process struct recursively\n+                        pendingFields.add(recordDeclaration(parent, fc).tree());\n+                    } else {\n+                        Type fieldType = typeMaker.makeType(fc.type());\n+                        Declaration fieldDecl = Declaration.field(CursorPosition.of(fc), fc.spelling(), fieldType);\n+                        ClangSizeOf.with(fieldDecl, fc.type().kind() == TypeKind.IncompleteArray ?\n+                                0 : fc.type().size() * 8);\n+                        ClangOffsetOf.with(fieldDecl, parent.type().getOffsetOf(fc.spelling()));\n+                        pendingFields.add(fieldDecl);\n+                    }\n+                }\n+            }\n+        });\n+\n+        if (!pendingBitFields.isEmpty()) {\n+            pendingFields.add(Declaration.bitfields(pendingBitfieldsPos.get(), pendingBitFields.toArray(Variable[]::new)));\n+            pendingBitFields.clear();\n+            pendingBitfieldsPos.set(null);\n+        }\n+\n+        Scoped structOrUnionDecl = recordCursor.kind() == CursorKind.StructDecl ?\n+                Declaration.struct(CursorPosition.of(recordCursor), recordCursor.spelling(),\n+                        pendingFields.toArray(new Declaration[0])) :\n+                Declaration.union(CursorPosition.of(recordCursor), recordCursor.spelling(),\n+                        pendingFields.toArray(new Declaration[0]));\n+        ClangSizeOf.with(structOrUnionDecl, recordCursor.type().size() * 8);\n+        ClangAlignOf.with(structOrUnionDecl, recordCursor.type().align() * 8);\n+        if (recordCursor.isAnonymousStruct()) {\n+            AnonymousStruct.with(structOrUnionDecl);\n+        }\n+\n+        return Type.declared(structOrUnionDecl);\n+    }\n+\n@@ -238,1 +297,1 @@\n-        List<Declaration> allDecls = new ArrayList<>();\n+        List<Declaration> decls = new ArrayList<>();\n@@ -241,1 +300,1 @@\n-                allDecls.add(createTree(child));\n+                decls.add(createTree(child));\n@@ -244,1 +303,0 @@\n-        List<Declaration> decls = filterNestedDeclarations(allDecls);\n@@ -247,2 +305,1 @@\n-            MemoryLayout layout = TypeMaker.valueLayoutForSize(c.type().size() * 8).layout().orElseThrow();\n-            return Declaration.enum_(CursorPosition.of(c), c.spelling(), layout, decls.toArray(new Declaration[0]));\n+            return Declaration.enum_(CursorPosition.of(c), c.spelling(), decls.toArray(new Declaration[0]));\n@@ -259,10 +316,6 @@\n-    private static boolean isBitfield(Declaration d) {\n-        return d instanceof Declaration.Scoped scoped &&\n-                scoped.kind() == Declaration.Scoped.Kind.BITFIELDS;\n-    }\n-\n-    private static boolean isAnonymousStruct(Declaration declaration) {\n-        return declaration instanceof Scoped scoped && AnonymousStruct.isPresent(scoped);\n-    }\n-\n-    private List<Declaration> filterNestedDeclarations(List<Declaration> declarations) {\n+    \/*\n+     * This method drops anonymous structs from the resulting toplevel declaration. These structs\n+     * can appear as part of a typedef, but are presented by libclang as toplevel structs, so we\n+     * need to filter them out.\n+     *\/\n+    private List<Declaration> filterHeaderDeclarations(List<Declaration> declarations) {\n@@ -271,1 +324,1 @@\n-                .filter(d -> isEnum(d) || !d.name().isEmpty() || isAnonymousStruct(d) || isBitfield(d))\n+                .filter(d -> isEnum(d) || !d.name().isEmpty())\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeMaker.java","additions":77,"deletions":24,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.PaddingLayout;\n@@ -42,1 +41,0 @@\n-import org.openjdk.jextract.impl.DeclarationImpl.Skip;\n@@ -62,1 +60,7 @@\n-    public static final TypeImpl ERROR = new TypeImpl() {\n+    public static class ErronrousTypeImpl extends TypeImpl {\n+        final String erroneousName;\n+\n+        public ErronrousTypeImpl(String erroneousName) {\n+            this.erroneousName = erroneousName;\n+        }\n+\n@@ -80,4 +84,0 @@\n-            if (kind.layout().isPresent() && kind.layout().get() instanceof PaddingLayout) {\n-                \/\/ this type is unsupported, add a Skip attribute\n-                Skip.with(this);\n-            }\n@@ -419,1 +419,25 @@\n-            return t.kind().layout().orElseThrow(UnsupportedOperationException::new);\n+            return switch (t.kind()) {\n+                case Void -> throw new UnsupportedOperationException();\n+                case Bool -> ValueLayout.JAVA_BOOLEAN;\n+                case Char -> ValueLayout.JAVA_BYTE;\n+                case Char16 -> unsupportedLayout(2, t);\n+                case Short -> ValueLayout.JAVA_SHORT;\n+                case Int -> ValueLayout.JAVA_INT;\n+                case Long -> TypeImpl.IS_WINDOWS ?\n+                        ValueLayout.JAVA_INT :\n+                        ValueLayout.JAVA_LONG;\n+                case LongLong -> ValueLayout.JAVA_LONG;\n+                case Int128 -> unsupportedLayout(16, t);\n+                case Float -> ValueLayout.JAVA_FLOAT;\n+                case Double -> ValueLayout.JAVA_DOUBLE;\n+                case LongDouble -> TypeImpl.IS_WINDOWS ?\n+                        ValueLayout.JAVA_DOUBLE :\n+                        unsupportedLayout(16, t);\n+                case Float128 -> unsupportedLayout(16, t);\n+                case HalfFloat -> unsupportedLayout(2, t);\n+                case WChar -> unsupportedLayout(2, t);\n+            };\n+        }\n+\n+        private MemoryLayout unsupportedLayout(long size, Type.Primitive t) {\n+            return MemoryLayout.paddingLayout(size).withByteAlignment(size).withName(t.kind().typeName());\n@@ -444,1 +468,1 @@\n-            return t.tree().layout().orElseThrow(UnsupportedOperationException::new);\n+            return Declaration.layoutFor(t.tree()).orElseThrow(UnsupportedOperationException::new);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypeImpl.java","additions":33,"deletions":9,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -195,1 +195,3 @@\n-                return Type.declared((Declaration.Scoped) treeMaker.createTree(t.getDeclarationCursor()));\n+                Declaration d = treeMaker.createTree(t.getDeclarationCursor());\n+                return d != null ?\n+                        Type.declared((Declaration.Scoped)d) : Type.error(t.spelling());\n@@ -237,1 +239,1 @@\n-                return TypeImpl.ERROR;\n+                return Type.error(t.spelling());\n@@ -265,10 +267,0 @@\n-\n-    public static Primitive.Kind valueLayoutForSize(long size) {\n-        return switch ((int) size) {\n-            case 8 -> Primitive.Kind.Char;\n-            case 16 -> Primitive.Kind.Short;\n-            case 32 -> Primitive.Kind.Int;\n-            case 64 -> Primitive.Kind.LongLong;\n-            default -> throw new IllegalStateException(\"Cannot infer container layout\");\n-        };\n-    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypeMaker.java","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,101 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package org.openjdk.jextract.impl;\n-\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import org.openjdk.jextract.Declaration;\n-import org.openjdk.jextract.clang.Cursor;\n-import org.openjdk.jextract.clang.Type;\n-import org.openjdk.jextract.clang.TypeKind;\n-\n-import java.util.List;\n-\n-\/**\n- * MemoryLayout computer for C unions.\n- *\/\n-final class UnionLayoutComputer extends RecordLayoutComputer {\n-    private final long offset;\n-    private long actualSize = 0L;\n-\n-    UnionLayoutComputer(TypeMaker typeMaker, long offsetInParent, Type parent, Type type) {\n-        super(typeMaker, parent, type);\n-        this.offset = offsetInParent;\n-    }\n-\n-    @Override\n-    void processField(Cursor c) {\n-        long expectedOffset = offsetOf(parent, c);\n-        if (expectedOffset > offset) {\n-            throw new IllegalStateException(\"No padding in union elements!\");\n-        }\n-\n-        addField(offset, parent, c);\n-        actualSize = Math.max(actualSize, fieldSize(c));\n-    }\n-\n-    @Override\n-    void startBitfield() {\n-        \/\/ do nothing\n-    }\n-\n-    @Override\n-    Declaration field(long offset, Cursor c) {\n-        if (c.isBitField()) {\n-            Declaration.Variable var = (Declaration.Variable)super.field(offset, c);\n-            return bitfield(var);\n-        } else {\n-            return super.field(offset, c);\n-        }\n-    }\n-\n-    @Override\n-    long fieldSize(Cursor c) {\n-        if (c.type().kind() == TypeKind.IncompleteArray) {\n-            return 0;\n-        } else if (c.isBitField()) {\n-            return c.getBitFieldWidth();\n-        } else {\n-            return c.type().size() * 8;\n-        }\n-    }\n-\n-    @Override\n-    Declaration.Scoped finishRecord(String layoutName, String declName) {\n-        \/\/ size mismatch indicates use of bitfields in union\n-        long expectedSize = type.size() * 8;\n-        if (actualSize < expectedSize) {\n-            \/\/ emit an extra padding of expected size to make sure union layout size is computed correctly\n-            addPadding(expectedSize);\n-        }\n-\n-        GroupLayout g = MemoryLayout.unionLayout(alignFields());\n-        checkSize(g);\n-        g = g.withName(layoutName);\n-        return Declaration.union(TreeMaker.CursorPosition.of(cursor), declName, g, fieldDecls.stream().toArray(Declaration[]::new));\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnionLayoutComputer.java","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -32,0 +32,1 @@\n+import org.openjdk.jextract.Declaration.Scoped.Kind;\n@@ -38,0 +39,1 @@\n+import org.openjdk.jextract.impl.TypeImpl.ErronrousTypeImpl;\n@@ -42,1 +44,2 @@\n-import java.lang.foreign.ValueLayout;\n+import java.lang.foreign.PaddingLayout;\n+import java.util.Optional;\n@@ -139,1 +142,2 @@\n-        if (scoped.layout().isEmpty()) {\n+        if ((scoped.kind() == Kind.STRUCT ||\n+                scoped.kind() == Kind.UNION) && Declaration.layoutFor(scoped).isEmpty()) {\n@@ -212,2 +216,3 @@\n-            if (Skip.isPresent(t)) {\n-                return t.kind().layout().get().name().get();\n+            Optional<MemoryLayout> layout = Type.layoutFor(t);\n+            if (layout.isPresent() && layout.get() instanceof PaddingLayout) {\n+                return t.kind().typeName();\n@@ -266,1 +271,2 @@\n-            return null;\n+            return t.isErroneous() ?\n+                    ((ErronrousTypeImpl)t).erroneousName : null;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnsupportedFilter.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-        assertTrue(structBar.layout().isEmpty());\n+        assertTrue(Declaration.layoutFor(structBar).isEmpty());\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/api\/Test8238712.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-            GroupLayout groupLayout = (GroupLayout)scoped.layout().get();\n+            GroupLayout groupLayout = (GroupLayout)Declaration.layoutFor(scoped).get();\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/api\/TestPackedStructs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,2 +70,2 @@\n-                checkField(\"b\", int.class, 4, \"$anon$0\"),\n-                checkField(\"c\", int.class, 8, \"$anon$0\", \"$anon$0\"),\n+                checkField(\"b\", int.class, 4, \"$anon$48:5\"),\n+                checkField(\"c\", int.class, 8, \"$anon$48:5\", \"$anon$50:9\"),\n@@ -73,2 +73,2 @@\n-                checkField(\"d\", byte.class, 12, \"$anon$0\"),\n-                checkField(\"f\", MemorySegment.class, 13, \"$anon$0\"),\n+                checkField(\"d\", byte.class, 12, \"$anon$48:5\"),\n+                checkField(\"f\", MemorySegment.class, 13, \"$anon$48:5\"),\n@@ -76,2 +76,2 @@\n-                checkField(\"g\", int.class, 16, \"$anon$1\"),\n-                checkField(\"h\", long.class, 16, \"$anon$1\"),\n+                checkField(\"g\", int.class, 16, \"$anon$58:5\"),\n+                checkField(\"h\", long.class, 16, \"$anon$58:5\"),\n@@ -91,2 +91,2 @@\n-                checkField(\"b\", int.class, 0, \"$anon$0\"),\n-                checkField(\"c\", int.class, 4, \"$anon$0\", \"$anon$0\"),\n+                checkField(\"b\", int.class, 0, \"$anon$73:5\"),\n+                checkField(\"c\", int.class, 4, \"$anon$73:5\", \"$anon$75:9\"),\n@@ -94,2 +94,2 @@\n-                checkField(\"d\", byte.class, 8, \"$anon$0\"),\n-                checkField(\"f\", MemorySegment.class, 9, \"$anon$0\"),\n+                checkField(\"d\", byte.class, 8, \"$anon$73:5\"),\n+                checkField(\"f\", MemorySegment.class, 9, \"$anon$73:5\"),\n@@ -97,2 +97,2 @@\n-                checkField(\"g\", int.class, 0, \"$anon$1\"),\n-                checkField(\"h\", int.class, 4, \"$anon$1\"),\n+                checkField(\"g\", int.class, 0, \"$anon$83:5\"),\n+                checkField(\"h\", int.class, 4, \"$anon$83:5\"),\n@@ -110,1 +110,1 @@\n-                checkField(\"Z\", MemorySegment.class, 0, \"$anon$0\")\n+                checkField(\"Z\", MemorySegment.class, 0, \"$anon$97:5\")\n@@ -116,1 +116,1 @@\n-                checkField(\"y\", int.class, 0, \"$anon$0\", \"$anon$0\")\n+                checkField(\"y\", int.class, 0, \"$anon$105:5\", \"$anon$106:9\")\n@@ -120,2 +120,2 @@\n-                checkField(\"y\", int.class, 4, \"$anon$0\"),\n-                checkField(\"z\", int.class, 4, \"$anon$0\")\n+                checkField(\"y\", int.class, 4, \"$anon$114:5\"),\n+                checkField(\"z\", int.class, 4, \"$anon$114:5\")\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/TestNested.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"}]}