{"files":[{"patch":"@@ -361,3 +361,0 @@\n-        String name = scoped.name().isEmpty() ?\n-                \"$anon$\" + scoped.pos().line() + \":\" + scoped.pos().col() :\n-                scoped.name();\n@@ -417,0 +414,5 @@\n+\n+        \/\/ the name is only useful for clients accessing the layout, jextract doesn't care about it\n+        String name = scoped.name().isEmpty() ?\n+                AnonymousStruct.anonName(scoped) :\n+                scoped.name();\n@@ -420,1 +422,1 @@\n-    private static OptionalLong nextOffset(Declaration member) {\n+    public static OptionalLong nextOffset(Declaration member) {\n@@ -479,0 +481,4 @@\n+\n+        public static String anonName(Scoped scoped) {\n+            return \"$anon$\" + scoped.pos().line() + \":\" + scoped.pos().col();\n+        }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/DeclarationImpl.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -40,3 +40,2 @@\n-    private final MethodType fiType;\n-    private final MethodType downcallType;\n-    private final FunctionDescriptor fiDesc;\n+    private final Type.Function funcType;\n+    private final MethodType methodType;\n@@ -46,1 +45,1 @@\n-                                       String runtimeHelperName, FunctionDescriptor descriptor,\n+                                       String runtimeHelperName, Type.Function funcType,\n@@ -49,3 +48,0 @@\n-        this.fiType = descriptor.toMethodType();\n-        this.downcallType = descriptor.toMethodType();\n-        this.fiDesc = descriptor;\n@@ -53,0 +49,2 @@\n+        this.funcType = funcType;\n+        this.methodType = Utils.methodTypeFor(funcType);\n@@ -56,1 +54,1 @@\n-                                Type.Function funcType, FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n+                                Type.Function funcType, Optional<List<String>> parameterNames) {\n@@ -58,1 +56,1 @@\n-                descriptor, parameterNames);\n+                funcType, parameterNames);\n@@ -70,1 +68,1 @@\n-            \\{fiRetType()} apply(\\{paramExprs(\"\")});\n+            \\{methodType.returnType().getSimpleName()} apply(\\{paramExprs(\"\")});\n@@ -113,2 +111,2 @@\n-        for (int i = 0 ; i < fiType.parameterCount(); i++) {\n-            result.append(delim).append(fiType.parameterType(i).getSimpleName());\n+        for (int i = 0 ; i < methodType.parameterCount(); i++) {\n+            result.append(delim).append(methodType.parameterType(i).getSimpleName());\n@@ -122,8 +120,0 @@\n-    private String fiRetType() {\n-        return fiType.returnType().getSimpleName();\n-    }\n-\n-    private String downcallRetType() {\n-        return fiType.returnType().getSimpleName();\n-    }\n-\n@@ -132,6 +122,2 @@\n-        if (!fiType.returnType().equals(void.class)) {\n-            retExpr = STR.\"return (\\{fiRetType()})\";\n-            if (fiType.returnType() != downcallType.returnType()) {\n-                \/\/ add cast for invokeExact\n-                retExpr += STR.\" (\\{downcallRetType()})\";\n-            }\n+        if (!methodType.returnType().equals(void.class)) {\n+            retExpr = STR.\"return (\\{methodType.returnType().getSimpleName()})\";\n@@ -144,11 +130,3 @@\n-        if (fiType.parameterCount() > 0) {\n-            argsExprs += \", \" + IntStream.range(0, fiType.parameterCount())\n-                    .mapToObj(i -> {\n-                        String paramExpr = \"_\" + parameterName(i);\n-                        if (fiType.parameterType(i) != downcallType.parameterType(i)) {\n-                            \/\/ add cast for invokeExact\n-                            return \"(\" + downcallType.parameterType(i).getName() + \")\" + paramExpr;\n-                        } else {\n-                            return paramExpr;\n-                        }\n-                    })\n+        if (methodType.parameterCount() > 0) {\n+            argsExprs += \", \" + IntStream.range(0, methodType.parameterCount())\n+                    .mapToObj(i -> \"_\" + parameterName(i))\n@@ -161,0 +139,1 @@\n+        FunctionDescriptor descriptor = Type.descriptorFor(funcType).get();\n@@ -162,1 +141,1 @@\n-            FunctionDescriptor $DESC = \\{descriptorString(0, fiDesc)};\n+            FunctionDescriptor $DESC = \\{descriptorString(0, descriptor)};\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":17,"deletions":38,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-    public void addVar(Declaration.Variable varTree, MemoryLayout layout, Optional<String> fiName) {\n+    public void addVar(Declaration.Variable varTree, Optional<String> fiName) {\n@@ -65,6 +65,4 @@\n-        String layoutVar = emitVarLayout(layout, javaName);\n-        if (layout instanceof SequenceLayout || layout instanceof GroupLayout) {\n-            if (layout.byteSize() > 0) {\n-                emitGlobalSegment(layoutVar, javaName, nativeName, varTree);\n-            };\n-        } else if (layout instanceof ValueLayout valueLayout) {\n+        String layoutVar = emitVarLayout(varTree.type(), javaName);\n+        if (Utils.isArray(varTree.type()) || Utils.isStructOrUnion(varTree.type())) {\n+            emitGlobalSegment(layoutVar, javaName, nativeName, varTree);\n+        } else if (Utils.isPointer(varTree.type()) || Utils.isPrimitive(varTree.type())) {\n@@ -73,2 +71,2 @@\n-            emitGlobalGetter(segmentConstant, vhConstant, javaName, nativeName, valueLayout.carrier(), varTree, \"Getter for variable:\");\n-            emitGlobalSetter(segmentConstant, vhConstant, javaName, nativeName, valueLayout.carrier(), varTree, \"Setter for variable:\");\n+            emitGlobalGetter(segmentConstant, vhConstant, javaName, varTree, \"Getter for variable:\");\n+            emitGlobalSetter(segmentConstant, vhConstant, javaName, varTree, \"Setter for variable:\");\n@@ -82,1 +80,1 @@\n-    public void addFunction(Declaration.Function funcTree, FunctionDescriptor descriptor) {\n+    public void addFunction(Declaration.Function funcTree) {\n@@ -85,2 +83,1 @@\n-        boolean needsAllocator = descriptor.returnLayout().isPresent() &&\n-                descriptor.returnLayout().get() instanceof GroupLayout;\n+        boolean needsAllocator = Utils.isStructOrUnion(funcTree.type().returnType());\n@@ -91,1 +88,1 @@\n-        emitFunctionWrapper(JavaName.getOrThrow(funcTree), nativeName, descriptor, needsAllocator, isVarargs, parameterNames, funcTree);\n+        emitFunctionWrapper(JavaName.getOrThrow(funcTree), nativeName, needsAllocator, isVarargs, parameterNames, funcTree);\n@@ -94,1 +91,1 @@\n-    public void addConstant(Declaration.Constant constantTree, Class<?> javaType) {\n+    public void addConstant(Declaration.Constant constantTree) {\n@@ -96,1 +93,1 @@\n-        emitConstant(javaType, JavaName.getOrThrow(constantTree), value, constantTree);\n+        emitConstant(Utils.carrierFor(constantTree.type()), JavaName.getOrThrow(constantTree), value, constantTree);\n@@ -140,3 +137,3 @@\n-    private void emitFunctionWrapper(String javaName, String nativeName, FunctionDescriptor descriptor, boolean needsAllocator,\n-                                     boolean isVarArg, List<String> parameterNames, Declaration decl) {\n-        MethodType declType = descriptor.toMethodType();\n+    private void emitFunctionWrapper(String javaName, String nativeName, boolean needsAllocator,\n+                                     boolean isVarArg, List<String> parameterNames, Declaration.Function decl) {\n+        MethodType declType = Utils.methodTypeFor(decl.type());\n@@ -154,0 +151,1 @@\n+        FunctionDescriptor descriptor = Declaration.descriptorFor(decl).get();\n@@ -156,9 +154,11 @@\n-        emitDocComment(decl);\n-        appendLines(STR.\"\"\"\n-            \\{MEMBER_MODS} MethodHandle \\{getterName}() {\n-                class Holder {\n-                    static final FunctionDescriptor DESC = \\{descriptorString(2, descriptor)};\n-\n-                    static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n-                            \\{runtimeHelperName()}.findOrThrow(\"\\{nativeName}\"),\n-                            DESC);\n+            emitDocComment(decl);\n+            appendLines(STR.\"\"\"\n+                \\{MEMBER_MODS} MethodHandle \\{getterName}() {\n+                    class Holder {\n+                        static final FunctionDescriptor DESC = \\{descriptorString(2, descriptor)};\n+\n+                        static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                                \\{runtimeHelperName()}.findOrThrow(\"\\{nativeName}\"),\n+                                DESC);\n+                    }\n+                    return Holder.MH;\n@@ -166,2 +166,0 @@\n-                return Holder.MH;\n-            }\n@@ -169,6 +167,7 @@\n-            public static \\{retType} \\{javaName}(\\{paramExprs(declType, finalParamNames, isVarArg)}) {\n-                var mh$ = \\{getterName}();\n-                try {\n-                    \\{returnExpr}mh$.invokeExact(\\{String.join(\", \", finalParamNames)});\n-                } catch (Throwable ex$) {\n-                   throw new AssertionError(\"should not reach here\", ex$);\n+                public static \\{retType} \\{javaName}(\\{paramExprs(declType, finalParamNames, isVarArg)}) {\n+                    var mh$ = \\{getterName}();\n+                    try {\n+                        \\{returnExpr}mh$.invokeExact(\\{String.join(\", \", finalParamNames)});\n+                    } catch (Throwable ex$) {\n+                       throw new AssertionError(\"should not reach here\", ex$);\n+                    }\n@@ -176,2 +175,1 @@\n-            }\n-            \"\"\");\n+                \"\"\");\n@@ -230,1 +228,1 @@\n-        emitPrimitiveTypedefLayout(name, Type.layoutFor(primType).get(), typedefTree);\n+        emitPrimitiveTypedefLayout(name, primType, typedefTree);\n@@ -234,1 +232,1 @@\n-        emitPrimitiveTypedefLayout(name, TypeImpl.PointerImpl.POINTER_LAYOUT, typedefTree);\n+        emitPrimitiveTypedefLayout(name, Type.pointer(), typedefTree);\n@@ -307,2 +305,2 @@\n-    private void emitGlobalGetter(String segmentConstant, String vhConstant, String javaName, String nativeName,\n-                                  Class<?> type, Declaration.Variable decl, String docHeader) {\n+    private void emitGlobalGetter(String segmentConstant, String vhConstant, String javaName,\n+                                  Declaration.Variable decl, String docHeader) {\n@@ -311,0 +309,1 @@\n+        Class<?> type = Utils.carrierFor(decl.type());\n@@ -319,2 +318,2 @@\n-    private void emitGlobalSetter(String segmentConstant, String vhConstant, String javaName, String nativeName,\n-                                  Class<?> type, Declaration.Variable decl, String docHeader) {\n+    private void emitGlobalSetter(String segmentConstant, String vhConstant, String javaName,\n+                                  Declaration.Variable decl, String docHeader) {\n@@ -323,0 +322,1 @@\n+        Class<?> type = Utils.carrierFor(decl.type());\n@@ -350,1 +350,1 @@\n-    private String emitVarLayout(MemoryLayout layout, String javaName) {\n+    private String emitVarLayout(Type varType, String javaName) {\n@@ -352,0 +352,1 @@\n+        MemoryLayout layout = Type.layoutFor(varType).get();\n@@ -432,1 +433,1 @@\n-    private void emitPrimitiveTypedefLayout(String javaName, MemoryLayout layout, Declaration declaration) {\n+    private void emitPrimitiveTypedefLayout(String javaName, Type type, Declaration declaration) {\n@@ -437,0 +438,1 @@\n+        MemoryLayout layout = Type.layoutFor(type).get();\n@@ -438,1 +440,1 @@\n-        public static final \\{Utils.layoutDeclarationType(layout).getSimpleName()} \\{javaName} = \\{layoutString(0, layout)};\n+        public static final \\{Utils.valueLayoutCarrierFor(type).getSimpleName()} \\{javaName} = \\{layoutString(0, layout)};\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":48,"deletions":46,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -86,2 +86,1 @@\n-        Class<?> clazz = getJavaType(constant.type());\n-        toplevelBuilder.addConstant(constant, clazz);\n+        toplevelBuilder.addConstant(constant);\n@@ -102,1 +101,0 @@\n-            GroupLayout layout = (GroupLayout)Declaration.layoutFor(d).get();\n@@ -104,3 +102,1 @@\n-            currentBuilder = structBuilder = currentBuilder.addStruct(\n-                d,\n-                layout);\n+            currentBuilder = structBuilder = currentBuilder.addStruct(d);\n@@ -120,2 +116,1 @@\n-        FunctionDescriptor descriptor = Type.descriptorFor(func).get();\n-        currentBuilder.addFunctionalInterface(name, func, descriptor);\n+        currentBuilder.addFunctionalInterface(name, func);\n@@ -144,2 +139,1 @@\n-        FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).get();\n-        toplevelBuilder.addFunction(funcTree, descriptor);\n+        toplevelBuilder.addFunction(funcTree);\n@@ -219,2 +213,1 @@\n-        MemoryLayout layout = Type.layoutFor(type).get();\n-        currentBuilder.addVar(tree, layout, fiName);\n+        currentBuilder.addVar(tree, fiName);\n@@ -224,12 +217,0 @@\n-    private Class<?> getJavaType(Type type) {\n-        Optional<MemoryLayout> layout = Type.layoutFor(type);\n-        if (!layout.isPresent()) return null;\n-        if (layout.get() instanceof SequenceLayout || layout.get() instanceof GroupLayout) {\n-            return MemorySegment.class;\n-        } else if (layout.get() instanceof ValueLayout valueLayout) {\n-            return valueLayout.carrier();\n-        } else {\n-            return null;\n-        }\n-    }\n-\n@@ -238,1 +219,1 @@\n-        default void addVar(Declaration.Variable varTree, MemoryLayout layout, Optional<String> fiName) {\n+        default void addVar(Declaration.Variable varTree, Optional<String> fiName) {\n@@ -242,1 +223,1 @@\n-        default void addFunction(Declaration.Function funcTree, FunctionDescriptor descriptor) {\n+        default void addFunction(Declaration.Function funcTree) {\n@@ -246,1 +227,1 @@\n-        default void addConstant(Declaration.Constant constantTree, Class<?> javaType) {\n+        default void addConstant(Declaration.Constant constantTree) {\n@@ -258,1 +239,1 @@\n-        default StructBuilder addStruct(Declaration.Scoped structTree, GroupLayout layout) {\n+        default StructBuilder addStruct(Declaration.Scoped structTree) {\n@@ -262,1 +243,1 @@\n-        default void addFunctionalInterface(String name, Type.Function funcType, FunctionDescriptor descriptor) {\n+        default void addFunctionalInterface(String name, Type.Function funcType) {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":10,"deletions":29,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-            return t.kind().toString() + Type.layoutFor(t).map(l -> \"(layout = \" + l + \")\").orElse(\"\");\n+            return t.kind().toString();\n@@ -176,1 +176,3 @@\n-            return \"Unknown type: \" + t.getClass().getName();\n+            return t.isErroneous() ?\n+                    STR.\"<error: \\{((TypeImpl.ErronrousTypeImpl)t).erroneousName}>\" :\n+                    STR.\"<unknown: \\{t.getClass().getName()}>\";\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/PrettyPrinter.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.foreign.FunctionDescriptor;\n@@ -35,0 +34,2 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.ClangOffsetOf;\n+import org.openjdk.jextract.impl.DeclarationImpl.ClangSizeOf;\n@@ -37,1 +38,0 @@\n-import java.lang.invoke.VarHandle;\n@@ -39,2 +39,0 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n@@ -42,1 +40,0 @@\n-import java.util.List;\n@@ -44,1 +41,0 @@\n-import java.util.StringJoiner;\n@@ -51,2 +47,0 @@\n-    private static final String MEMBER_MODS = \"public static\";\n-\n@@ -54,1 +48,0 @@\n-    private final GroupLayout structLayout;\n@@ -56,1 +49,1 @@\n-    private final Deque<String> prefixElementNames;\n+    private final Deque<Declaration> nestedAnonDeclarations;\n@@ -59,2 +52,1 @@\n-                  ClassSourceBuilder enclosing, String runtimeHelperName, Declaration.Scoped structTree,\n-                  GroupLayout structLayout) {\n+                  ClassSourceBuilder enclosing, String runtimeHelperName, Declaration.Scoped structTree) {\n@@ -63,1 +55,0 @@\n-        this.structLayout = structLayout;\n@@ -65,1 +56,1 @@\n-        this.prefixElementNames = new ArrayDeque<>();\n+        this.nestedAnonDeclarations = new ArrayDeque<>();\n@@ -72,6 +63,2 @@\n-    private void pushPrefixElement(String prefixElementName) {\n-        prefixElementNames.push(prefixElementName);\n-    }\n-\n-    private void popPrefixElement() {\n-        prefixElementNames.pop();\n+    private void pushNestedAnonDecl(Declaration anonDecl) {\n+        nestedAnonDeclarations.push(anonDecl);\n@@ -80,4 +67,2 @@\n-    private List<String> prefixNamesList() {\n-        List<String> prefixes = new ArrayList<>(prefixElementNames);\n-        Collections.reverse(prefixes);\n-        return Collections.unmodifiableList(prefixes);\n+    private void popNestedAnonDecl() {\n+        nestedAnonDeclarations.pop();\n@@ -110,1 +95,1 @@\n-            popPrefixElement();\n+            popNestedAnonDecl();\n@@ -115,1 +100,1 @@\n-        return !prefixElementNames.isEmpty();\n+        return !nestedAnonDeclarations.isEmpty();\n@@ -119,1 +104,1 @@\n-    public StructBuilder addStruct(Declaration.Scoped tree, GroupLayout layout) {\n+    public StructBuilder addStruct(Declaration.Scoped tree) {\n@@ -122,2 +107,1 @@\n-            String anonName = layout.name().orElseThrow();\n-            pushPrefixElement(anonName);\n+            pushNestedAnonDecl(tree);\n@@ -127,1 +111,1 @@\n-                    JavaName.getOrThrow(tree), this, runtimeHelperName(), tree, layout);\n+                    JavaName.getOrThrow(tree), this, runtimeHelperName(), tree);\n@@ -135,1 +119,1 @@\n-    public void addFunctionalInterface(String name, Type.Function funcType, FunctionDescriptor descriptor) {\n+    public void addFunctionalInterface(String name, Type.Function funcType) {\n@@ -138,1 +122,1 @@\n-                this, runtimeHelperName(), funcType, descriptor,\n+                this, runtimeHelperName(), funcType,\n@@ -144,2 +128,1 @@\n-    public void addVar(Declaration.Variable varTree, MemoryLayout layout, Optional<String> fiName) {\n-        String nativeName = varTree.name();\n+    public void addVar(Declaration.Variable varTree, Optional<String> fiName) {\n@@ -147,6 +130,5 @@\n-        if (layout instanceof SequenceLayout || layout instanceof GroupLayout) {\n-            if (layout.byteSize() > 0) {\n-                emitSegmentGetter(javaName, nativeName, layout);\n-            }\n-        } else if (layout instanceof ValueLayout valueLayout) {\n-            String constantField = emitFieldVarHandle(javaName, nativeName, prefixNamesList());\n+        long offset = ClangOffsetOf.getOrThrow(varTree) \/ 8;\n+        long size = ClangSizeOf.getOrThrow(varTree) \/ 8;\n+        if (Utils.isArray(varTree.type()) || Utils.isStructOrUnion(varTree.type())) {\n+            emitSegmentGetter(javaName, offset, size);\n+        } else if (Utils.isPointer(varTree.type()) || Utils.isPrimitive(varTree.type())) {\n@@ -154,1 +136,1 @@\n-            emitFieldGetter(constantField, javaName, valueLayout.carrier());\n+            emitFieldGetter(javaName, varTree.type(), offset);\n@@ -156,3 +138,3 @@\n-            emitFieldSetter(constantField, javaName, valueLayout.carrier());\n-            emitIndexedFieldGetter(constantField, javaName, valueLayout.carrier());\n-            emitIndexedFieldSetter(constantField, javaName, valueLayout.carrier());\n+            emitFieldSetter(javaName, varTree.type(), offset);\n+            emitIndexedFieldGetter(javaName, varTree.type(), offset);\n+            emitIndexedFieldSetter(javaName, varTree.type(), offset);\n@@ -179,1 +161,1 @@\n-    private void emitFieldGetter(String vhConstant, String javaName, Class<?> type) {\n+    private void emitFieldGetter(String javaName, Type varType, long offset) {\n@@ -181,0 +163,2 @@\n+        Class<?> type = Utils.carrierFor(varType);\n+        MemoryLayout layout = Type.layoutFor(varType).get();\n@@ -183,1 +167,1 @@\n-                return (\\{type.getName()}) \\{vhConstant}.get(\\{seg}, 0L);\n+                return \\{seg}.get(\\{layoutString(1, layout)}, \\{offset});\n@@ -188,1 +172,1 @@\n-    private void emitFieldSetter(String vhConstant, String javaName, Class<?> type) {\n+    private void emitFieldSetter(String javaName, Type varType, long offset) {\n@@ -191,0 +175,2 @@\n+        Class<?> type = Utils.carrierFor(varType);\n+        MemoryLayout layout = Type.layoutFor(varType).get();\n@@ -193,1 +179,1 @@\n-                \\{vhConstant}.set(\\{seg}, 0L, \\{x});\n+                \\{seg}.set(\\{layoutString(1, layout)}, \\{offset}, \\{x});\n@@ -198,12 +184,1 @@\n-    private MemoryLayout.PathElement[] elementPaths(String nativeFieldName) {\n-        List<String> prefixElements = prefixNamesList();\n-        MemoryLayout.PathElement[] elems = new MemoryLayout.PathElement[prefixElements.size() + 1];\n-        int i = 0;\n-        for (; i < prefixElements.size(); i++) {\n-            elems[i] = MemoryLayout.PathElement.groupElement(prefixElements.get(i));\n-        }\n-        elems[i] = MemoryLayout.PathElement.groupElement(nativeFieldName);\n-        return elems;\n-    }\n-\n-    private void emitSegmentGetter(String javaName, String nativeName, MemoryLayout layout) {\n+    private void emitSegmentGetter(String javaName, long offset, long size) {\n@@ -213,1 +188,1 @@\n-                return \\{seg}.asSlice(\\{structLayout.byteOffset(elementPaths(nativeName))}, \\{layout.byteSize()});\n+                return \\{seg}.asSlice(\\{offset}, \\{size});\n@@ -246,1 +221,1 @@\n-    private void emitIndexedFieldGetter(String vhConstant, String javaName, Class<?> type) {\n+    private void emitIndexedFieldGetter(String javaName, Type varType, long offset) {\n@@ -249,0 +224,2 @@\n+        Class<?> type = Utils.carrierFor(varType);\n+        MemoryLayout layout = Type.layoutFor(varType).get();\n@@ -251,1 +228,1 @@\n-                return (\\{type.getName()}) \\{vhConstant}.get(\\{seg}, \\{index} * sizeof());\n+                return \\{seg}.get(\\{layoutString(1, layout)}, \\{offset} + (\\{index} * sizeof()));\n@@ -256,1 +233,1 @@\n-    private void emitIndexedFieldSetter(String vhConstant, String javaName, Class<?> type) {\n+    private void emitIndexedFieldSetter(String javaName, Type varType, long offset) {\n@@ -260,0 +237,2 @@\n+        Class<?> type = Utils.carrierFor(varType);\n+        MemoryLayout layout = Type.layoutFor(varType).get();\n@@ -262,1 +241,1 @@\n-                \\{vhConstant}.set(\\{seg}, \\{index} * sizeof(), \\{x});\n+                \\{seg}.set(\\{layoutString(1, layout)}, \\{offset} + (\\{index} * sizeof()), \\{x});\n@@ -268,0 +247,1 @@\n+        MemoryLayout structLayout = Type.layoutFor(structType).get();\n@@ -276,21 +256,0 @@\n-\n-    private String emitFieldVarHandle(String javaName, String nativeName, List<String> prefixElementNames) {\n-        String mangledName = mangleName(javaName, VarHandle.class);\n-        appendIndentedLines(STR.\"\"\"\n-            private static final VarHandle \\{mangledName} = $LAYOUT.varHandle(\\{pathElementStr(nativeName, prefixElementNames)});\n-\n-            \\{MEMBER_MODS} VarHandle \\{mangledName}() {\n-                return \\{mangledName};\n-            }\n-            \"\"\");\n-        return mangledName;\n-    }\n-\n-    private static String pathElementStr(String nativeName, List<String> prefixElementNames) {\n-        StringJoiner joiner = new StringJoiner(\", \");\n-        for (String prefixElementName : prefixElementNames) {\n-            joiner.add(STR.\"MemoryLayout.PathElement.groupElement(\\\"\\{prefixElementName}\\\")\");\n-        }\n-        joiner.add(STR.\"MemoryLayout.PathElement.groupElement(\\\"\\{nativeName}\\\")\");\n-        return joiner.toString();\n-    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructBuilder.java","additions":45,"deletions":86,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -103,2 +103,2 @@\n-    public void addVar(Declaration.Variable varTree, MemoryLayout layout, Optional<String> fiName) {\n-        nextHeader().addVar(varTree, layout, fiName);\n+    public void addVar(Declaration.Variable varTree, Optional<String> fiName) {\n+        nextHeader().addVar(varTree, fiName);\n@@ -108,2 +108,2 @@\n-    public void addFunction(Declaration.Function funcTree, FunctionDescriptor descriptor) {\n-        nextHeader().addFunction(funcTree, descriptor);\n+    public void addFunction(Declaration.Function funcTree) {\n+        nextHeader().addFunction(funcTree);\n@@ -113,2 +113,2 @@\n-    public void addConstant(Declaration.Constant constantTree, Class<?> javaType) {\n-        nextHeader().addConstant(constantTree, javaType);\n+    public void addConstant(Declaration.Constant constantTree) {\n+        nextHeader().addConstant(constantTree);\n@@ -134,1 +134,1 @@\n-    public StructBuilder addStruct(Declaration.Scoped tree, GroupLayout layout) {\n+    public StructBuilder addStruct(Declaration.Scoped tree) {\n@@ -137,1 +137,1 @@\n-        StructBuilder structBuilder = new StructBuilder(sfb, \"public\", sfb.className(), null, firstHeader.className(), tree, layout);\n+        StructBuilder structBuilder = new StructBuilder(sfb, \"public\", sfb.className(), null, firstHeader.className(), tree);\n@@ -143,1 +143,1 @@\n-    public void addFunctionalInterface(String name, Type.Function funcType, FunctionDescriptor descriptor) {\n+    public void addFunctionalInterface(String name, Type.Function funcType) {\n@@ -146,1 +146,1 @@\n-        FunctionalInterfaceBuilder.generate(sfb, sfb.className(), null, firstHeader.className(), funcType, descriptor,\n+        FunctionalInterfaceBuilder.generate(sfb, sfb.className(), null, firstHeader.className(), funcType,\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ToplevelBuilder.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -359,1 +359,1 @@\n-        } else if (Utils.isPointerType(canonicalType)) {\n+        } else if (Utils.isPointer(canonicalType)) {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeMaker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.AnonymousStruct;\n+import org.openjdk.jextract.impl.DeclarationImpl.ClangSizeOf;\n@@ -39,1 +41,0 @@\n-import org.openjdk.jextract.impl.TypeImpl.ErronrousTypeImpl;\n@@ -42,4 +43,0 @@\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.PaddingLayout;\n-import java.util.Optional;\n@@ -55,0 +52,1 @@\n+ * - anonymous struct whose first (possibly nested) member has unknown offset\n@@ -64,2 +62,2 @@\n-    static String firstUnsupportedType(Type type) {\n-        return type.accept(UNSUPPORTED_VISITOR, null);\n+    static Type firstUnsupportedType(Type type, boolean allowVoid) {\n+        return type.accept(UNSUPPORTED_VISITOR, allowVoid);\n@@ -76,1 +74,1 @@\n-        String unsupportedType = firstUnsupportedType(funcTree.type());\n+        Type unsupportedType = firstUnsupportedType(funcTree.type(), false);\n@@ -82,6 +80,0 @@\n-        FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).orElse(null);\n-        if (descriptor == null) {\n-            warnSkip(funcTree.name(), \"does not have a valid function descriptor\");\n-            Skip.with(funcTree);\n-            return null;\n-        }\n@@ -108,1 +100,7 @@\n-        String unsupportedType = firstUnsupportedType(varTree.type());\n+        Type type = varTree.type();\n+        if (type instanceof Type.Declared declared) {\n+            \/\/ declared type - visit declaration recursively\n+            declared.tree().accept(this, varTree);\n+        }\n+\n+        Type unsupportedType = firstUnsupportedType(varTree.type(), false);\n@@ -116,7 +114,0 @@\n-        MemoryLayout layout = Type.layoutFor(varTree.type()).orElse(null);\n-        if (layout == null) {\n-            \/\/no layout - skip\n-            warnSkip(name, \"does not have a valid memory layout\");\n-            Skip.with(varTree);\n-            return null;\n-        }\n@@ -142,3 +133,3 @@\n-        if ((scoped.kind() == Kind.STRUCT ||\n-                scoped.kind() == Kind.UNION) && Declaration.layoutFor(scoped).isEmpty()) {\n-            \/\/ skip\n+        Type unsupportedType = firstUnsupportedType(Type.declared(scoped), false);\n+        if (unsupportedType != null) {\n+            warnSkip(scoped.name(), STR.\"unsupported type usage: \\{unsupportedType}\");\n@@ -156,1 +147,6 @@\n-        String unsupportedType = firstUnsupportedType(typedefTree.type());\n+        \/\/ propagate\n+        if (typedefTree.type() instanceof Declared declared) {\n+            visitScoped(declared.tree(), null);\n+        }\n+\n+        Type unsupportedType = firstUnsupportedType(typedefTree.type(),false);\n@@ -167,13 +163,0 @@\n-\n-        MemoryLayout layout = Type.layoutFor(typedefTree.type()).orElse(null);\n-        if (layout == null) {\n-            \/\/no layout - skip\n-            warnSkip(typedefTree.name(), \"does not have a valid memory layout\");\n-            Skip.with(typedefTree);\n-            return null;\n-        }\n-\n-        \/\/ propagate\n-        if (typedefTree.type() instanceof Declared declared) {\n-            visitScoped(declared.tree(), null);\n-        }\n@@ -194,1 +177,1 @@\n-        String unsupportedType = firstUnsupportedType(func);\n+        Type unsupportedType = firstUnsupportedType(func, false);\n@@ -199,5 +182,0 @@\n-        FunctionDescriptor descriptor = Type.descriptorFor(func).orElse(null);\n-        if (descriptor == null) {\n-            warnSkip(nameOfSkipped, \"does not have a valid function descriptor\");\n-            return false;\n-        }\n@@ -213,1 +191,1 @@\n-    private static final Type.Visitor<String, Void> UNSUPPORTED_VISITOR = new Type.Visitor<>() {\n+    private static final Type.Visitor<Type, Boolean> UNSUPPORTED_VISITOR = new Type.Visitor<>() {\n@@ -215,7 +193,7 @@\n-        public String visitPrimitive(Type.Primitive t, Void unused) {\n-            Optional<MemoryLayout> layout = Type.layoutFor(t);\n-            if (layout.isPresent() && layout.get() instanceof PaddingLayout) {\n-                return t.kind().typeName();\n-            } else {\n-                return null;\n-            }\n+        public Type visitPrimitive(Type.Primitive t, Boolean allowVoid) {\n+            return switch (t.kind()) {\n+                case Char16, Float128, HalfFloat, Int128, WChar -> t;\n+                case LongDouble -> TypeImpl.IS_WINDOWS ? null : t;\n+                case Void -> allowVoid ? null : t;\n+                default -> null;\n+            };\n@@ -225,1 +203,1 @@\n-        public String visitFunction(Type.Function t, Void unused) {\n+        public Type visitFunction(Type.Function t, Boolean allowVoid) {\n@@ -227,1 +205,1 @@\n-                String unsupported = firstUnsupportedType(arg);\n+                Type unsupported = firstUnsupportedType(arg, false);\n@@ -232,1 +210,1 @@\n-            String unsupported = firstUnsupportedType(t.returnType());\n+            Type unsupported = firstUnsupportedType(t.returnType(), true);\n@@ -240,7 +218,4 @@\n-        public String visitDeclared(Type.Declared t, Void unused) {\n-            for (Declaration d : t.tree().members()) {\n-                if (d instanceof Declaration.Variable variable) {\n-                    String unsupported = firstUnsupportedType(variable.type());\n-                    if (unsupported != null) {\n-                        return unsupported;\n-                    }\n+        public Type visitDeclared(Type.Declared t, Boolean allowVoid) {\n+            if (t.tree().kind() == Kind.STRUCT || t.tree().kind() == Kind.UNION) {\n+                if (!isValidStructOrUnion(t.tree())) {\n+                    return t;\n@@ -252,0 +227,11 @@\n+        private boolean isValidStructOrUnion(Scoped scoped) {\n+            if (ClangSizeOf.get(scoped).isEmpty()) {\n+                return false;\n+            }\n+            if (AnonymousStruct.isPresent(scoped) &&\n+                    DeclarationImpl.nextOffset(scoped).isEmpty()) {\n+                return false;\n+            }\n+            return true;\n+        }\n+\n@@ -253,1 +239,4 @@\n-        public String visitDelegated(Type.Delegated t, Void unused) {\n+        public Type visitDelegated(Type.Delegated t, Boolean allowVoid) {\n+            \/\/ Note: unsupported pointer types (e.g. *long double) are not detected, but they are not problematic\n+            \/\/ layout-wise (e.g. they are always 32- or 64-bits, depending on the platform). This policy also allows\n+            \/\/ more flexibility when it comes to opaque struct types.\n@@ -255,1 +244,1 @@\n-                    firstUnsupportedType(t.type()) :\n+                    firstUnsupportedType(t.type(), allowVoid) :\n@@ -257,5 +246,0 @@\n-            \/\/in principle we should always do this:\n-            \/\/ return firstUnsupportedType(t.type());\n-            \/\/ but if we do that, we might end up with infinite recursion (because of pointer types).\n-            \/\/ Unsupported pointer types (e.g. *long double) are not detected, but they are not problematic layout-wise\n-            \/\/ (e.g. they are always 32- or 64-bits, depending on the platform).\n@@ -265,2 +249,2 @@\n-        public String visitArray(Type.Array t, Void unused) {\n-            return firstUnsupportedType(t.elementType());\n+        public Type visitArray(Type.Array t, Boolean allowVoid) {\n+            return firstUnsupportedType(t.elementType(), false);\n@@ -270,1 +254,1 @@\n-        public String visitType(Type t, Void unused) {\n+        public Type visitType(Type t, Boolean allowVoid) {\n@@ -272,1 +256,1 @@\n-                    ((ErronrousTypeImpl)t).erroneousName : null;\n+                    t : null;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnsupportedFilter.java","additions":58,"deletions":74,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.AddressLayout;\n@@ -40,0 +40,3 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodType;\n@@ -41,0 +44,1 @@\n+import java.util.Map;\n@@ -103,21 +107,0 @@\n-    \/**\n-     * Returns the type that should be used in declarations of various\n-     * memory layout implementations.\n-     * <p>\n-     * For example, the concrete layout implementation class {@code OfLongImpl} should be\n-     * declared as {@code OfLong} and not {@code OfLongImpl}.\n-     *\n-     * @param layout to generate a declaring type string for.\n-     * @return the unqualified type\n-     *\/\n-    static Class<?> layoutDeclarationType(MemoryLayout layout) {\n-        if (!layout.getClass().isInterface()) {\n-            Class<?> ifs[] = layout.getClass().getInterfaces();\n-            if (ifs.length != 1) {\n-                throw new IllegalStateException(\"The class\" + layout.getClass() + \" does not implement exactly one interface\");\n-            }\n-            return ifs[0];\n-        }\n-        return layout.getClass();\n-    }\n-\n@@ -131,6 +114,52 @@\n-    static boolean isPointerType(Type type) {\n-        if (type instanceof Delegated delegated) {\n-            return delegated.kind() == Delegated.Kind.POINTER;\n-        } else {\n-            return false;\n-        }\n+    static boolean isEnum(Declaration.Scoped scoped) {\n+        return switch (scoped.kind()) {\n+            case ENUM -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    static boolean isArray(Type type) {\n+        return switch (type) {\n+            case Type.Array _ -> true;\n+            case Type.Delegated delegated when delegated.kind() == Delegated.Kind.TYPEDEF ->\n+                    isArray(delegated.type());\n+            default -> false;\n+        };\n+    }\n+\n+    static boolean isEnum(Type type) {\n+        return switch (type) {\n+            case Type.Declared declared -> isEnum(declared.tree());\n+            case Type.Delegated delegated when delegated.kind() == Delegated.Kind.TYPEDEF ->\n+                    isEnum(delegated.type());\n+            default -> false;\n+        };\n+    }\n+\n+    static boolean isStructOrUnion(Type type) {\n+        return switch (type) {\n+            case Type.Declared declared -> isStructOrUnion(declared.tree());\n+            case Type.Delegated delegated when delegated.kind() == Delegated.Kind.TYPEDEF ->\n+                isStructOrUnion(delegated.type());\n+            default -> false;\n+        };\n+    }\n+\n+    static boolean isPointer(Type type) {\n+        return switch (type) {\n+            case Type.Delegated delegated when delegated.kind() == Delegated.Kind.TYPEDEF ->\n+                    isPointer(delegated.type());\n+            case Type.Delegated delegated when delegated.kind() == Delegated.Kind.POINTER ->\n+                    true;\n+            default -> false;\n+        };\n+    }\n+\n+    static boolean isPrimitive(Type type) {\n+        return switch (type) {\n+            case Type.Declared declared when declared.tree().kind() == Declaration.Scoped.Kind.ENUM ->\n+                isPrimitive(((Declaration.Constant)declared.tree().members().get(0)).type());\n+            case Type.Delegated delegated -> isPrimitive(delegated.type());\n+            case Type.Primitive _ -> true;\n+            default -> false;\n+        };\n@@ -140,13 +169,5 @@\n-        if (type instanceof Function function) {\n-            \/*\n-             * \/\/ pointer to function declared as function like this\n-             *\n-             * typedef void CB(int);\n-             * void func(CB cb);\n-             *\/\n-            return function;\n-        } else if (isPointerType(type)) {\n-            return getAsFunctionPointer(((Delegated)type).type());\n-        } else {\n-            return null;\n-        }\n+        return switch (type) {\n+            case Type.Delegated delegated -> getAsFunctionPointer(delegated.type());\n+            case Type.Function function -> function;\n+            default -> null;\n+        };\n@@ -173,0 +194,66 @@\n+\n+    public static Class<?> carrierFor(Type type) {\n+        return switch (type) {\n+            case Type.Array _ -> MemorySegment.class;\n+            case Type.Primitive p -> Utils.carrierFor(p);\n+            case Type.Declared declared -> declared.tree().kind() == Declaration.Scoped.Kind.ENUM ?\n+                    carrierFor(((Declaration.Constant) declared.tree().members().get(0)).type()) :\n+                    MemorySegment.class;\n+            case Type.Delegated delegated -> delegated.kind() == Type.Delegated.Kind.POINTER ?\n+                    MemorySegment.class :\n+                    carrierFor(delegated.type());\n+            case Type.Function _ -> MemorySegment.class;\n+            default -> throw new UnsupportedOperationException(type.toString());\n+        };\n+    };\n+\n+    public static Class<?> carrierFor(Type.Primitive p) {\n+        return switch (p.kind()) {\n+            case Void -> void.class;\n+            case Bool -> boolean.class;\n+            case Char -> byte.class;\n+            case Short -> short.class;\n+            case Int -> int.class;\n+            case Long -> TypeImpl.IS_WINDOWS ? int.class : long.class;\n+            case LongLong -> long.class;\n+            case Float -> float.class;\n+            case Double -> double.class;\n+            case LongDouble -> {\n+                if (TypeImpl.IS_WINDOWS) {\n+                    yield (Class<?>) double.class;\n+                } else {\n+                    throw new UnsupportedOperationException(p.toString());\n+                }\n+            }\n+            default -> throw new UnsupportedOperationException(p.toString());\n+        };\n+    }\n+\n+    public static Class<?> valueLayoutCarrierFor(Type t) {\n+        if (t instanceof Delegated delegated && delegated.kind() == Delegated.Kind.POINTER) {\n+            return AddressLayout.class;\n+        } else if (t instanceof Type.Primitive p) {\n+            Class<?> clazz = carrierFor(p);\n+            return CARRIERS_TO_LAYOUT_CARRIERS.get(clazz);\n+        } else {\n+            throw new UnsupportedOperationException(t.toString());\n+        }\n+    }\n+\n+    static final Map<Class<?>, Class<?>> CARRIERS_TO_LAYOUT_CARRIERS = Map.of(\n+            byte.class, ValueLayout.OfByte.class,\n+            boolean.class, ValueLayout.OfBoolean.class,\n+            char.class, ValueLayout.OfChar.class,\n+            short.class, ValueLayout.OfShort.class,\n+            int.class, ValueLayout.OfInt.class,\n+            float.class, ValueLayout.OfFloat.class,\n+            long.class, ValueLayout.OfLong.class,\n+            double.class, ValueLayout.OfDouble.class\n+    );\n+\n+    public static MethodType methodTypeFor(Type.Function type) {\n+        return MethodType.methodType(\n+                carrierFor(type.returnType()),\n+                type.argumentTypes().stream().map(Utils::carrierFor).toList()\n+        );\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Utils.java","additions":128,"deletions":41,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertNull;\n+\n+import static org.testng.Assert.*;\n@@ -94,1 +94,1 @@\n-    public void testIgnoredMethods() {\n+    public void testProblematicMethods() {\n@@ -96,1 +96,7 @@\n-            throw new SkipException(\"long double works on Windows\");\n+            assertNotNull(findMethod(unsupported_h.class, \"func\"));\n+            assertNotNull(findMethod(unsupported_h.class, \"func2\"));\n+            assertNotNull(findMethod(unsupported_h.class, \"func3\"));\n+        } else {\n+            assertNull(findMethod(unsupported_h.class, \"func\"));\n+            assertNull(findMethod(unsupported_h.class, \"func2\"));\n+            assertNull(findMethod(unsupported_h.class, \"func3\"));\n@@ -98,6 +104,3 @@\n-        assertNull(findMethod(unsupported_h.class, \"func\"));\n-        assertNull(findMethod(unsupported_h.class, \"func2\"));\n-        assertNull(findMethod(unsupported_h.class, \"func3\"));\n-        assertNull(findMethod(unsupported_h.class, \"func4\"));\n-        assertNull(findMethod(unsupported_h.class, \"makeFoo\"));\n-        assertNull(findMethod(unsupported_h.class, \"copyFoo\"));\n+        assertNotNull(findMethod(unsupported_h.class, \"func4\"));\n+        assertNotNull(findMethod(unsupported_h.class, \"makeFoo\"));\n+        assertNotNull(findMethod(unsupported_h.class, \"copyFoo\"));\n","filename":"test\/jtreg\/generator\/test8257892\/LibUnsupportedTest.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -72,2 +72,1 @@\n-            \"typedef int* INT_PTR;\",\n-            \"typedef struct Foo* OPAQUE_PTR;\"));\n+            \"typedef int* INT_PTR;\"));\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903257\/TestDocComments.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-typedef struct Foo* OPAQUE_PTR;\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903257\/typedefs.h","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-            assertNull(findMethod(headerClass, \"tzname$SEGMENT\"));\n+            assertNotNull(findMethod(headerClass, \"tzname$SEGMENT\"));\n@@ -50,0 +50,1 @@\n+            assertNotNull(findMethod(fooClass, \"names$slice\", MemorySegment.class));\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8251943.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -189,3 +189,0 @@\n-            Method vh_getter = checkMethod(structCls, memberName + \"$VH\", VarHandle.class);\n-            VarHandle vh = (VarHandle) vh_getter.invoke(null);\n-            assertEquals(vh.varType(), expectedType);\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/TestClassGeneration.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -51,2 +51,0 @@\n-    private static final String REASON_NO_FUNC_DESC = \"does not have a valid function descriptor\";\n-    private static final String REASON_NO_MEM_LAYOUT = \"does not have a valid memory layout\";\n@@ -66,6 +64,5 @@\n-            {\"GLOBAL_HAS_UNSUPPORTED\",           REASON_UNSUPPORTED_TYPE},\n-            {\"accepts_undefined\",                REASON_NO_FUNC_DESC},\n-            {\"returns_undefined\",                REASON_NO_FUNC_DESC},\n-            {\"accepts_undefined_func\",           REASON_NO_FUNC_DESC},\n-            {\"GLOBAL_UNDECLARED\",                REASON_NO_MEM_LAYOUT},\n-            {\"undefined_typedef\",                REASON_NO_MEM_LAYOUT},\n+            {\"accepts_undefined\",                REASON_UNSUPPORTED_TYPE},\n+            {\"returns_undefined\",                REASON_UNSUPPORTED_TYPE},\n+            {\"accepts_undefined_func\",           REASON_UNSUPPORTED_TYPE},\n+            {\"GLOBAL_UNDECLARED\",                REASON_UNSUPPORTED_TYPE},\n+            {\"undefined_typedef\",                REASON_UNSUPPORTED_TYPE},\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/unsupported\/TestUnsupportedTypes.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"}]}