{"files":[{"patch":"@@ -1,293 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package org.openjdk.jextract.impl;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-import org.openjdk.jextract.Declaration;\n-import org.openjdk.jextract.Type;\n-import org.openjdk.jextract.impl.DeclarationImpl.EnumConstant;\n-\n-final class CDeclarationPrinter implements Declaration.Visitor<Void, Void> {\n-    private static String SPACES = \" \".repeat(92);\n-    private int align = 0;\n-    private String prefix;\n-\n-    private void incr() {\n-        align += 4;\n-    }\n-\n-    private void decr() {\n-        align -= 4;\n-    }\n-\n-    private CDeclarationPrinter(String prefix) {\n-        this.prefix = prefix;\n-    }\n-\n-    private void indent() {\n-        builder.append(prefix);\n-        builder.append(SPACES.substring(0, align));\n-    }\n-\n-    private final StringBuilder builder = new StringBuilder();\n-\n-    private String print(Declaration decl) {\n-        decl.accept(this, null);\n-        return builder.toString();\n-    }\n-\n-    \/\/ Return C source style signature for the given declaration.\n-    \/\/ The prefix is emitted for every line. This can be used\n-    \/\/ to prefix per line comment character \"*\" in generated javadoc.\n-    static String declaration(Declaration decl, String prefix) {\n-        Objects.requireNonNull(decl);\n-        Objects.requireNonNull(prefix);\n-        return new CDeclarationPrinter(prefix).print(decl);\n-    }\n-\n-    static String declaration(Type.Function funcType, String name) {\n-        return nameAndType(funcType, \"*\" + name);\n-    }\n-\n-    @Override\n-    public Void visitScoped(Declaration.Scoped d, Void ignored) {\n-        indent();\n-        var tag = typeTag(d);\n-        if (!tag.isEmpty()) {\n-            builder.append(tag);\n-            if (!d.name().isEmpty()) {\n-                builder.append(\" \" + d.name());\n-            }\n-            builder.append(\" {\");\n-            builder.append(\"\\n\");\n-            incr();\n-        }\n-        d.members().forEach(m -> {\n-            m.accept(this, null);\n-            builder.append(\"\\n\");\n-        });\n-        if (!tag.isEmpty()) {\n-            decr();\n-            indent();\n-            builder.append(\"};\");\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitFunction(Declaration.Function d, Void ignored) {\n-        indent();\n-\n-        \/\/ name and args part of the function\n-        StringBuilder buf = new StringBuilder();\n-        buf.append(d.name());\n-        buf.append('(');\n-        buf.append(\n-            d.parameters().\n-                stream().\n-                map(p -> nameAndType(p.type(), p.name())).\n-                collect(Collectors.joining(\", \"))\n-        );\n-        if (d.type().varargs()) {\n-            buf.append(\",...\");\n-        }\n-        buf.append(')');\n-\n-        \/\/ The return type is handled later to take care of\n-        \/\/ pointer to function return type like signal from signal.h\n-        \/\/ void (*signal(int sig, void (*func)(int)))(int)\n-\n-        String funcNameAndArgs = buf.toString();\n-        Type returnType = d.type().returnType();\n-        builder.append(nameAndType(returnType, funcNameAndArgs));\n-        builder.append(\";\");\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitVariable(Declaration.Variable d, Void ignored) {\n-        indent();\n-        builder.append(nameAndType(d.type(), d.name()));\n-        builder.append(\";\");\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitConstant(Declaration.Constant d, Void ignored) {\n-        indent();\n-        Optional<String> enumName = EnumConstant.get(d);\n-        if (enumName.isPresent()) {\n-            builder.append(\"enum \" + enumName.get() + \".\" + d.name());\n-            builder.append(\" = \");\n-            builder.append(d.value());\n-            builder.append(\";\");\n-        } else {\n-            builder.append(\"#define \");\n-            builder.append(d.name());\n-            Object value = d.value();\n-            builder.append(\" \");\n-            if (value instanceof String str) {\n-                builder.append(\"\\\"\" + Utils.quote(str) + \"\\\"\");\n-            } else {\n-                builder.append(value);\n-            }\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitTypedef(Declaration.Typedef d, Void ignored) {\n-        indent();\n-        builder.append(\"typedef \");\n-        builder.append(nameAndType(d.type(), d.name()));\n-        builder.append(\";\");\n-        return null;\n-    }\n-\n-    \/\/ In few cases, C type signature 'embeds' name.\n-    \/\/ Examples:\n-    \/\/     int a[3]; \/\/ 'a' in between int and []\n-    \/\/     int (*func)(int); \/\/ 'func' is inside paren after '*'\n-    \/\/ TypeVisitor accepts name and includes it in the appropriate\n-    \/\/ place as needed. If not included, boolean flag is set to false\n-    \/\/ in the result.\n-\n-    private static String nameAndType(Type type, String name) {\n-        var result = type.accept(typeVisitor, name);\n-        var typeStr = result.typeStr();\n-        return result.nameIncluded() || name.isEmpty() ?\n-            typeStr : (typeStr + \" \" + name);\n-    }\n-\n-    \/\/ result type for Type.Visitor\n-    private record TypeVisitorResult(boolean nameIncluded, String typeStr) {}\n-\n-    private static Type.Visitor<TypeVisitorResult, String> typeVisitor = new Type.Visitor<>() {\n-        \/\/ context argument in this visitor usually starts with a name. But it may pick up\n-        \/\/ \"*\" prefixes for pointer type. [] suffix for array types. For pointer to function\n-        \/\/ return type, the context is name of the function + argument types as in declaration.\n-\n-        @Override\n-        public TypeVisitorResult visitPrimitive(Type.Primitive t, String context) {\n-            return new TypeVisitorResult(false, t.kind().typeName());\n-        }\n-\n-        private TypeVisitorResult prefixedType(String prefix, Type.Delegated delegated) {\n-            return new TypeVisitorResult(false,\n-                    prefix + \" \" + delegated.type().accept(this, \"\").typeStr());\n-        }\n-\n-        @Override\n-        public TypeVisitorResult visitDelegated(Type.Delegated t, String context) {\n-            switch (t.kind()) {\n-                case POINTER: {\n-                    var result = t.type().accept(this, \"*\" + context);\n-                    if (result.nameIncluded()) {\n-                        return new TypeVisitorResult(true, result.typeStr());\n-                    } else {\n-                        return new TypeVisitorResult(false, result.typeStr() + \"*\");\n-                    }\n-                }\n-                case UNSIGNED:\n-                    return prefixedType(\"unsigned\", t);\n-                case SIGNED:\n-                    return prefixedType(\"signed\", t);\n-                case VOLATILE:\n-                    return prefixedType(\"volatile\", t);\n-                case COMPLEX:\n-                    return prefixedType(\"complex\", t);\n-            }\n-            \/\/ defensive. If no name is present, we don't want to crash\n-            return new TypeVisitorResult(false, t.name().orElse(defaultName(t)));\n-        }\n-\n-        @Override\n-        public TypeVisitorResult visitFunction(Type.Function t, String context) {\n-            String argsStr;\n-            \/\/ Function type may optionally have parameter names.\n-            \/\/ Include parameter names if available.\n-            var optParameterNames = t.parameterNames();\n-            if (optParameterNames.isPresent()) {\n-                List<Type> argTypes = t.argumentTypes();\n-                List<String> argNames = optParameterNames.get();\n-                int numArgs = argTypes.size();\n-                List<String> args = new ArrayList<>(numArgs);\n-                for (int i = 0; i < numArgs; i++) {\n-                    args.add(nameAndType(argTypes.get(i), argNames.get(i)));\n-                }\n-                argsStr = args.stream()\n-                    .collect(Collectors.joining(\",\", \"(\", \")\"));\n-            } else {\n-                argsStr = t.argumentTypes().stream()\n-                    .map(a -> a.accept(this, \"\").typeStr())\n-                    .collect(Collectors.joining(\",\", \"(\", \")\"));\n-            }\n-            String res = t.returnType().accept(this, \"\").typeStr();\n-            return new TypeVisitorResult(true, res + \" (\" + context + \")\" + argsStr);\n-        }\n-\n-        @Override\n-        public TypeVisitorResult visitDeclared(Type.Declared t, String context) {\n-            Declaration.Scoped scoped = t.tree();\n-            return new TypeVisitorResult(false, typeTag(scoped) + \" \" + scoped.name());\n-        }\n-\n-        @Override\n-        public TypeVisitorResult visitArray(Type.Array t, String context) {\n-            String brackets = String.format(\" %s[%s]\", context,\n-                t.elementCount().isPresent() ? t.elementCount().getAsLong() : \"\");\n-            var result = t.elementType().accept(this, brackets);\n-            if (result.nameIncluded()) {\n-                return new TypeVisitorResult(true, result.typeStr());\n-            } else {\n-                return new TypeVisitorResult(true, result.typeStr() + brackets);\n-            }\n-        }\n-\n-        @Override\n-        public TypeVisitorResult visitType(Type t, String context) {\n-            return new TypeVisitorResult(false, defaultName(t));\n-        }\n-\n-        private String defaultName(Type t) {\n-            return t.toString();\n-        }\n-    };\n-\n-    private static String typeTag(Declaration.Scoped scoped) {\n-        return switch (scoped.kind()) {\n-            case STRUCT -> \"struct\";\n-            case UNION -> \"union\";\n-            case ENUM -> \"enum\";\n-            default -> \"\";\n-        };\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/CDeclarationPrinter.java","additions":0,"deletions":293,"binary":false,"changes":293,"status":"deleted"},{"patch":"@@ -35,0 +35,1 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.DeclarationString;\n@@ -42,0 +43,2 @@\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n@@ -159,11 +162,1 @@\n-            \\{CDeclarationPrinter.declaration(decl, \" * \")}\n-             * }\n-             *\/\n-            \"\"\");\n-    }\n-\n-    final void emitDocComment(Type.Function funcType, String name) {\n-        appendLines(STR.\"\"\"\n-            \/**\n-             * {@snippet lang=c :\n-             * \\{CDeclarationPrinter.declaration(funcType, name)};\n+            \\{declarationComment(decl)}\n@@ -269,0 +262,8 @@\n+\n+    \/\/ Return C source style signature for the given declaration.\n+    \/\/ A \" * \" prefix is emitted for every line.\n+    static String declarationComment(Declaration decl) {\n+        Objects.requireNonNull(decl);\n+        String declString = DeclarationString.getOrThrow(decl);\n+        return declString.lines().collect(Collectors.joining(\"\\n * \", \" * \", \"\"));\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ClassSourceBuilder.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-                .map(new EnumConstantLifter()::scan)\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/CodeGenerator.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -466,0 +466,16 @@\n+\n+    record DeclarationString(String declString) {\n+        public static void with(Declaration declaration, String declString) {\n+            declaration.addAttribute(new DeclarationString(declString));\n+        }\n+\n+        public static Optional<String> get(Declaration declaration) {\n+            return declaration.getAttribute(DeclarationString.class)\n+                    .stream().map(DeclarationString::declString).findFirst();\n+        }\n+\n+        public static String getOrThrow(Declaration declaration) {\n+            return declaration.getAttribute(DeclarationString.class)\n+                    .stream().map(DeclarationString::declString).findFirst().get();\n+        }\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/DeclarationImpl.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.jextract.impl;\n-\n-import org.openjdk.jextract.Declaration;\n-import org.openjdk.jextract.Declaration.Constant;\n-import org.openjdk.jextract.Declaration.Scoped.Kind;\n-import org.openjdk.jextract.Type;\n-import org.openjdk.jextract.impl.DeclarationImpl.EnumConstant;\n-import org.openjdk.jextract.impl.DeclarationImpl.Skip;\n-\n-\/*\n- * This visitor lifts enum constants to the top level and removes enum Trees.\n- *\/\n-final class EnumConstantLifter implements Declaration.Visitor<Void, Void> {\n-\n-    public Declaration.Scoped scan(Declaration.Scoped header) {\n-        \/\/ Process all header declarations are collect potential\n-        \/\/ declarations that will go into transformed HeaderTree\n-        \/\/ into the this.decls field.\n-        header.members().forEach(fieldTree -> fieldTree.accept(this, null));\n-        return header;\n-    }\n-\n-    @Override\n-    public Void visitScoped(Declaration.Scoped scoped, Void ignored) {\n-        if (Utils.isEnum(scoped)) {\n-            \/\/ add the name of the enum as an attribute.\n-            scoped.members().forEach(fieldTree -> {\n-                EnumConstant.with((Constant)fieldTree, scoped.name());\n-                fieldTree.accept(this, null);\n-            });\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitTypedef(Declaration.Typedef tree, Void ignored) {\n-        Type type = tree.type();\n-        if (Utils.declarationFor(type).map(Utils::isEnum).orElse(false)) {\n-            \/\/ no need to do anything for a typedef enum, as the IR always\n-            \/\/ lifts the enum tree before the typedef.\n-            Skip.with(tree);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitDeclaration(Declaration decl, Void ignored) {\n-        return null;\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/EnumConstantLifter.java","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -28,0 +28,1 @@\n+import org.openjdk.jextract.Declaration;\n@@ -29,0 +30,1 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.DeclarationString;\n@@ -43,2 +45,1 @@\n-                                       String runtimeHelperName, Type.Function funcType,\n-                                       Optional<List<String>> parameterNames) {\n+                                       String runtimeHelperName, Type.Function funcType) {\n@@ -46,1 +47,1 @@\n-        this.parameterNames = parameterNames;\n+        this.parameterNames = funcType.parameterNames().map(NameMangler::javaSafeIdentifiers);\n@@ -52,3 +53,3 @@\n-                                Type.Function funcType, Optional<List<String>> parameterNames) {\n-        FunctionalInterfaceBuilder fib = new FunctionalInterfaceBuilder(builder, className, enclosing, runtimeHelperName,\n-                funcType, parameterNames);\n+                                Declaration parentDecl, Type.Function funcType) {\n+        FunctionalInterfaceBuilder fib = new FunctionalInterfaceBuilder(builder, className,\n+                enclosing, runtimeHelperName, funcType);\n@@ -56,1 +57,1 @@\n-        fib.emitDocComment(funcType, className);\n+        fib.emitDocComment(parentDecl);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.JavaFunctionalInterfaceName;\n@@ -62,1 +63,2 @@\n-    public void addVar(Declaration.Variable varTree, Optional<String> fiName) {\n+    public void addVar(Declaration.Variable varTree) {\n+        Optional<String> fiName = JavaFunctionalInterfaceName.get(varTree);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,1 +88,2 @@\n-                return Optional.of(treeMaker.createMacro(TreeMaker.CursorPosition.of(cursor), name, Type.primitive(Type.Primitive.Kind.Int), (long)num));\n+                return Optional.of(treeMaker.createMacro(TreeMaker.CursorPosition.of(cursor), tokens,\n+                        name, Type.primitive(Type.Primitive.Kind.Int), (long)num));\n@@ -265,1 +266,1 @@\n-                constant = treeMaker.createMacro(position, name, type, value);\n+                constant = treeMaker.createMacro(position, tokens, name, type, value);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/MacroParserImpl.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -112,2 +112,2 @@\n-    private void generateFunctionalInterface(String name, Type.Function func) {\n-        currentBuilder.addFunctionalInterface(name, func);\n+    private void generateFunctionalInterface(Declaration parentDecl, Type.Function func) {\n+        currentBuilder.addFunctionalInterface(parentDecl, func);\n@@ -126,1 +126,1 @@\n-                generateFunctionalInterface(JavaFunctionalInterfaceName.getOrThrow(param), f);\n+                generateFunctionalInterface(param, f);\n@@ -133,1 +133,1 @@\n-             generateFunctionalInterface(JavaFunctionalInterfaceName.getOrThrow(funcTree), returnFunc);\n+             generateFunctionalInterface(funcTree, returnFunc);\n@@ -177,1 +177,1 @@\n-                generateFunctionalInterface(JavaFunctionalInterfaceName.getOrThrow(tree), func);\n+                generateFunctionalInterface(tree, func);\n@@ -202,1 +202,0 @@\n-        Optional<String> fiName = JavaFunctionalInterfaceName.get(tree);\n@@ -205,1 +204,1 @@\n-            generateFunctionalInterface(fiName.get(), func);\n+            generateFunctionalInterface(tree, func);\n@@ -208,1 +207,1 @@\n-        currentBuilder.addVar(tree, fiName);\n+        currentBuilder.addVar(tree);\n@@ -214,1 +213,1 @@\n-        default void addVar(Declaration.Variable varTree, Optional<String> fiName) {\n+        default void addVar(Declaration.Variable varTree) {\n@@ -238,1 +237,1 @@\n-        default void addFunctionalInterface(String name, Type.Function funcType) {\n+        default void addFunctionalInterface(Declaration parentDecl, Type.Function funcType) {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.JavaFunctionalInterfaceName;\n@@ -125,1 +126,1 @@\n-    public void addFunctionalInterface(String name, Type.Function funcType) {\n+    public void addFunctionalInterface(Declaration parentDecl, Type.Function funcType) {\n@@ -127,3 +128,2 @@\n-        FunctionalInterfaceBuilder.generate(sourceFileBuilder(), name,\n-                this, runtimeHelperName(), funcType,\n-                funcType.parameterNames().map(NameMangler::javaSafeIdentifiers));\n+        FunctionalInterfaceBuilder.generate(sourceFileBuilder(), JavaFunctionalInterfaceName.getOrThrow(parentDecl),\n+                this, runtimeHelperName(), parentDecl, funcType);\n@@ -134,1 +134,2 @@\n-    public void addVar(Declaration.Variable varTree, Optional<String> fiName) {\n+    public void addVar(Declaration.Variable varTree) {\n+        Optional<String> fiName = JavaFunctionalInterfaceName.get(varTree);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructBuilder.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.JavaFunctionalInterfaceName;\n@@ -124,2 +125,2 @@\n-    public void addVar(Declaration.Variable varTree, Optional<String> fiName) {\n-        nextHeader().addVar(varTree, fiName);\n+    public void addVar(Declaration.Variable varTree) {\n+        nextHeader().addVar(varTree);\n@@ -164,2 +165,2 @@\n-    public void addFunctionalInterface(String name, Type.Function funcType) {\n-        SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName(), name);\n+    public void addFunctionalInterface(Declaration parentDecl, Type.Function funcType) {\n+        SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName(), JavaFunctionalInterfaceName.getOrThrow(parentDecl));\n@@ -167,2 +168,1 @@\n-        FunctionalInterfaceBuilder.generate(sfb, sfb.className(), null, mainHeaderClassName(), funcType,\n-                funcType.parameterNames().map(NameMangler::javaSafeIdentifiers));\n+        FunctionalInterfaceBuilder.generate(sfb, sfb.className(), null, mainHeaderClassName(), parentDecl, funcType);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ToplevelBuilder.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.util.stream.Stream;\n@@ -44,0 +45,1 @@\n+import org.openjdk.jextract.Declaration.Constant;\n@@ -54,0 +56,2 @@\n+import org.openjdk.jextract.clang.PrintingPolicy;\n+import org.openjdk.jextract.clang.PrintingPolicyProperty;\n@@ -60,0 +64,1 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.DeclarationString;\n@@ -143,1 +148,1 @@\n-            declarationCache.put(key, decl);\n+            declarationCache.put(key, withDeclarationString(decl, c));\n@@ -228,2 +233,5 @@\n-    public Declaration.Constant createMacro(Position pos, String name, Type type, Object value) {\n-        return Declaration.constant(pos, name, value, type);\n+    public Declaration.Constant createMacro(Position pos, String[] tokens, String name, Type type, Object value) {\n+        Declaration.Constant macro = Declaration.constant(pos, name, value, type);\n+        String macroString = Stream.of(tokens).skip(1).collect(Collectors.joining());\n+        DeclarationString.with(macro, STR.\"#define \\{name} \\{macroString}\");\n+        return macro;\n@@ -361,0 +369,4 @@\n+            decls.forEach(d -> {\n+                \/\/ append declaration string\n+                DeclarationString.with(d, enumConstantString(c.spelling(), (Declaration.Constant)d));\n+            });\n@@ -452,0 +464,20 @@\n+\n+    private <D extends Declaration> D withDeclarationString(D decl, Cursor cursor) {\n+        if (decl instanceof Declaration.Constant) return decl; \/\/ do nothing for enum constants\n+        DeclarationString.with(decl, declarationString(cursor));\n+        return decl;\n+    }\n+\n+    String declarationString(Cursor cursor) {\n+        PrintingPolicy pp = cursor.getPrintingPolicy();\n+        pp.setProperty(PrintingPolicyProperty.IncludeTagDefinition, true);\n+        pp.setProperty(PrintingPolicyProperty.PolishForDeclaration, true);\n+        return cursor.prettyPrinted(pp);\n+    }\n+\n+    String enumConstantString(String enumName, Declaration.Constant enumConstant) {\n+        if (enumName.isEmpty()) {\n+            enumName = \"<anonymous>\";\n+        }\n+        return STR.\"enum \\{enumName}.\\{enumConstant.name()} = \\{enumConstant.value()}\";\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeMaker.java","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -192,2 +192,1 @@\n-            warnSkip(nameOfSkipped, \"varargs in callbacks is not supported: \"\n-                    + CDeclarationPrinter.declaration(func, JavaName.getOrThrow(decl)));\n+            warnSkip(nameOfSkipped, \"varargs in callbacks is not supported: \" + decl.name());\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnsupportedFilter.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,7 +57,7 @@\n-            \"enum Color.RED = 0;\",\n-            \"enum Color.GREEN = 1;\",\n-            \"enum Color.BLUE = 2;\",\n-            \"enum Suit.club = 1;\",\n-            \"enum Suit.diamonds = 2;\",\n-            \"enum Suit.hearts = 3;\",\n-            \"enum Suit.spades = 4;\"));\n+            \"enum Color.RED = 0\",\n+            \"enum Color.GREEN = 1\",\n+            \"enum Color.BLUE = 2\",\n+            \"enum Suit.club = 1\",\n+            \"enum Suit.diamonds = 2\",\n+            \"enum Suit.hearts = 3\",\n+            \"enum Suit.spades = 4\"));\n@@ -70,4 +70,4 @@\n-            \"typedef unsigned long long size_t;\",\n-            \"typedef int INT_32;\",\n-            \"typedef int* INT_PTR;\",\n-            \"typedef struct Foo* OPAQUE_PTR;\"));\n+            \"typedef unsigned long long size_t\",\n+            \"typedef int INT_32\",\n+            \"typedef int *INT_PTR\",\n+            \"typedef struct Foo *OPAQUE_PTR\"));\n@@ -80,5 +80,5 @@\n-            \"int abc[10];\",\n-            \"float numbers[3];\",\n-            \"char* msg[5];\",\n-            \"int pixels[200][100];\",\n-            \"int points[10][20][30];\"));\n+            \"int abc[10]\",\n+            \"float numbers[3]\",\n+            \"char *msg[5]\",\n+            \"int pixels[200][100]\",\n+            \"int points[10][20][30]\"));\n@@ -91,4 +91,4 @@\n-            \"int func(int* fp);\",\n-            \"double distance(struct Point p);\",\n-            \"int printf(char* fmt,...);\",\n-            \"int printf(char* fmt,...);\"));\n+            \"int func(int *fp)\",\n+            \"double distance(struct Point { int x; int y; } p)\",\n+            \"int printf(char *fmt, ...)\",\n+            \"int printf(char *fmt, ...)\"));\n@@ -101,1 +101,1 @@\n-            \"void (*funcptr)(int*,int);\"\n+            \"void (*funcptr)(int *, int)\"\n@@ -109,1 +109,1 @@\n-            \"void (*signal$func)(int);\"\n+            \"void (*func)(int)\"\n@@ -117,1 +117,1 @@\n-            \"void (*signal$return)(int);\"\n+            \"void (*signal(int sig, void (*func)(int)))(int)\"\n@@ -125,3 +125,3 @@\n-            \"Getter for variable: void (*funcptr)(int*,int);\",\n-            \"Setter for variable: void (*funcptr)(int*,int);\",\n-            \"void (*signal(int sig, void (*func)(int)))(int);\"\n+            \"Getter for variable: void (*funcptr)(int *, int)\",\n+            \"Setter for variable: void (*funcptr)(int *, int)\",\n+            \"void (*signal(int sig, void (*func)(int)))(int)\"\n@@ -135,4 +135,4 @@\n-            \"Getter for variable: int abc;\",\n-            \"Setter for variable: int abc;\",\n-            \"Getter for variable: char* msg;\",\n-            \"Setter for variable: char* msg;\"\n+            \"Getter for variable: int abc\",\n+            \"Setter for variable: int abc\",\n+            \"Getter for variable: char *msg\",\n+            \"Setter for variable: char *msg\"\n@@ -146,5 +146,5 @@\n-            \"struct Point { int x; int y; };\",\n-            \"Getter for field: int x;\",\n-            \"Setter for field: int x;\",\n-            \"Getter for field: int y;\",\n-            \"Setter for field: int y;\"));\n+            \"struct Point { int x; int y; }\",\n+            \"Getter for field: int x\",\n+            \"Setter for field: int x\",\n+            \"Getter for field: int y\",\n+            \"Setter for field: int y\"));\n@@ -157,7 +157,7 @@\n-            \"struct Point3D { int x; int y; int z; };\",\n-            \"Getter for field: int x;\",\n-            \"Setter for field: int x;\",\n-            \"Getter for field: int y;\",\n-            \"Setter for field: int y;\",\n-            \"Getter for field: int z;\",\n-            \"Setter for field: int z;\"));\n+            \"struct Point3D { int x; int y; int z; }\",\n+            \"Getter for field: int x\",\n+            \"Setter for field: int x\",\n+            \"Getter for field: int y\",\n+            \"Setter for field: int y\",\n+            \"Getter for field: int z\",\n+            \"Setter for field: int z\"));\n@@ -170,1 +170,1 @@\n-            \"typedef struct Point Point_t;\"));\n+            \"typedef struct Point { int x; int y; } Point_t\"));\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903257\/TestDocComments.java","additions":43,"deletions":43,"binary":false,"changes":86,"status":"modified"}]}