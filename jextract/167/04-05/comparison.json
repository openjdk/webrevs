{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jextract.Declaration.Typedef;\n+import org.openjdk.jextract.Declaration.Variable;\n@@ -30,0 +32,2 @@\n+import org.openjdk.jextract.Type.Function;\n+import org.openjdk.jextract.impl.DeclarationImpl.AnonymousStruct;\n@@ -139,2 +143,2 @@\n-                String declFiName = func.name() + \"$\" + (param.name().isEmpty() ? \"x\" + i : param.name());\n-                JavaFunctionalInterfaceName.with(param, declFiName);\n+                String fiName = func.name() + \"$\" + (param.name().isEmpty() ? \"x\" + i : param.name());\n+                JavaFunctionalInterfaceName.with(param, fiName);\n@@ -144,0 +148,1 @@\n+            Utils.forEachNested(param, s -> s.accept(this, func));\n@@ -145,0 +150,1 @@\n+\n@@ -149,0 +155,1 @@\n+        Utils.forEachNested(func, s -> s.accept(this, func));\n@@ -155,8 +162,7 @@\n-        String name = scoped.name();\n-        if (name.isEmpty() && parent != null) {\n-            name = parent.name();\n-        }\n-        if (JavaName.isPresent(scoped)) {\n-            \/\/skip struct that's seen already\n-            return null;\n-        }\n+        if (Utils.isEnum(scoped)) {\n+            scoped.members().forEach(fieldTree -> fieldTree.accept(this, null));\n+        } else if (Utils.isStructOrUnion(scoped)) {\n+            if (JavaName.isPresent(scoped)) {\n+                \/\/skip struct that's seen already\n+                return null;\n+            }\n@@ -164,11 +170,13 @@\n-        Scope oldScope = curScope;\n-        boolean isNestedAnonStruct = scoped.name().isEmpty() &&\n-            (parent instanceof Declaration.Scoped);\n-        if (!isNestedAnonStruct) {\n-            this.curScope = Scope.newStruct(oldScope, name);\n-            JavaName.with(scoped, curScope.fullName());\n-        }\n-        try {\n-            scoped.members().forEach(fieldTree -> fieldTree.accept(this, scoped));\n-        } finally {\n-            this.curScope = oldScope;\n+            Scope oldScope = curScope;\n+            if (!AnonymousStruct.isPresent(scoped)) {\n+                String name = scoped.name().isEmpty() ?\n+                        fallbackNameFor(parent, scoped) :\n+                        scoped.name();\n+                this.curScope = Scope.newStruct(oldScope, name);\n+                JavaName.with(scoped, curScope.fullName());\n+            }\n+            try {\n+                scoped.members().forEach(fieldTree -> fieldTree.accept(this, null));\n+            } finally {\n+                this.curScope = oldScope;\n+            }\n@@ -187,3 +195,0 @@\n-        \/\/ handle if this typedef is of a struct\/union\/enum etc.\n-        Utils.forEachNested(typedef, d -> d.accept(this, typedef));\n-\n@@ -199,0 +204,5 @@\n+\n+        \/\/ handle if this typedef is of a struct\/union\/enum etc.\n+        Utils.forEachNested(typedef, d -> {\n+            d.accept(this, typedef);\n+        });\n@@ -202,0 +212,27 @@\n+    private String fallbackNameFor(Declaration parent, Declaration.Scoped nested) {\n+        String nestedName = parent.name();\n+        Function func = switch (parent) {\n+            case Declaration.Function f -> f.type();\n+            case Variable v -> Utils.getAsFunctionPointer(v.type());\n+            case Typedef t -> Utils.getAsFunctionPointer(t.type());\n+            default -> null;\n+        };\n+        if (func != null) {\n+            \/\/ if this is a function pointer type def, try to use better fallback names for any\n+            \/\/ anon struct\/union that might be defined as part of this typedef\n+            String suffix = null;\n+            for (int i = 0 ; i < func.argumentTypes().size() ; i++) {\n+                if (func.argumentTypes().get(i) instanceof Type.Declared declared && declared.tree() == nested) {\n+                    \/\/ it's a function argument\n+                    suffix = \"$x\" + i;\n+                }\n+            }\n+            if (suffix == null) {\n+                \/\/ not found, assume it's the function return\n+                suffix = \"$return\";\n+            }\n+            nestedName = nestedName + suffix;\n+        }\n+        return nestedName;\n+    }\n+\n@@ -206,1 +243,0 @@\n-        Utils.forEachNested(variable, s -> s.accept(this, variable));\n@@ -217,0 +253,1 @@\n+        Utils.forEachNested(variable, s -> s.accept(this, variable));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/NameMangler.java","additions":62,"deletions":25,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -121,0 +121,1 @@\n+            Utils.forEachNested(param, s -> s.accept(this, param));\n@@ -127,0 +128,2 @@\n+        Utils.forEachNested(funcTree, s -> s.accept(this, funcTree));\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-                params.toArray(new Declaration.Variable[0])), c);\n+                params.toArray(new Declaration.Variable[0])), c, true);\n@@ -413,1 +413,1 @@\n-        return withNestedTypes(Declaration.typedef(CursorPosition.of(c), c.spelling(), canonicalType), c);\n+        return withNestedTypes(Declaration.typedef(CursorPosition.of(c), c.spelling(), canonicalType), c, false);\n@@ -429,1 +429,1 @@\n-        return withNestedTypes(Declaration.var(kind, CursorPosition.of(c), c.spelling(), type), c);\n+        return withNestedTypes(Declaration.var(kind, CursorPosition.of(c), c.spelling(), type), c, false);\n@@ -437,1 +437,1 @@\n-    private <D extends Declaration> D withNestedTypes(D d, Cursor c) {\n+    private <D extends Declaration> D withNestedTypes(D d, Cursor c, boolean ignoreNestedParams) {\n@@ -439,5 +439,1 @@\n-        c.forEach(m -> {\n-            if (m.isDefinition()) {\n-                nestedDefinitions.add(createTree(m));\n-            }\n-        });\n+        collectNestedTypes(c, nestedDefinitions, ignoreNestedParams);\n@@ -454,0 +450,12 @@\n+    private void collectNestedTypes(Cursor c, List<Declaration> nestedTypes, boolean ignoreNestedParams) {\n+        c.forEach(m -> {\n+            if (m.isDefinition()) {\n+                if (m.kind() == CursorKind.ParmDecl && !ignoreNestedParams) {\n+                    collectNestedTypes(m, nestedTypes, ignoreNestedParams);\n+                } else {\n+                    nestedTypes.add(createTree(m));\n+                }\n+            }\n+        });\n+    }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeMaker.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import org.openjdk.jextract.Declaration.Typedef;\n+import org.openjdk.jextract.Declaration.Variable;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Utils.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.nestedtypes.names.*;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test id=classes\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.nestedtypes.names nested_types_names.h\n+ * @build TestNestedTypesNames\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNestedTypesNames\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library \/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.nestedtypes.names nested_types_names.h\n+ * @build TestNestedTypesNames\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNestedTypesNames\n+ *\/\n+public class TestNestedTypesNames {\n+\n+    static MemoryLayout ARG_STRUCT = MemoryLayout.structLayout(\n+        nested_types_names_h.C_INT.withName(\"y\")\n+    );\n+\n+    static MemoryLayout RET_STRUCT = MemoryLayout.structLayout(\n+        nested_types_names_h.C_INT.withName(\"x\")\n+    );\n+\n+    static FunctionDescriptor FUNC_DESC = FunctionDescriptor.of(\n+            RET_STRUCT,\n+            ARG_STRUCT\n+    );\n+\n+    @Test\n+    public void testTypeNamesAndLayouts() {\n+        \/\/ function, anonymous\n+        checkLayout(f1$return.$LAYOUT(), RET_STRUCT);\n+        checkLayout(f1$x0.$LAYOUT(), ARG_STRUCT);\n+        \/\/ function, explicit names\n+        checkLayout(SR_FUN.$LAYOUT(), RET_STRUCT);\n+        checkLayout(SA_FUN.$LAYOUT(), ARG_STRUCT);\n+        \/\/ global, anonymous\n+        checkLayout(fp1$return.$LAYOUT(), RET_STRUCT);\n+        checkLayout(fp1$x0.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(fp1.$DESC, FUNC_DESC);\n+        \/\/ global, explicit names\n+        checkLayout(SR_VAR.$LAYOUT(), RET_STRUCT);\n+        checkLayout(SA_VAR.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(fp2.$DESC, FUNC_DESC);\n+        \/\/ typedef, anonymous\n+        checkLayout(td1$return.$LAYOUT(), RET_STRUCT);\n+        checkLayout(td1$x0.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(td1.$DESC, FUNC_DESC);\n+        \/\/ typedef, explicit names\n+        checkLayout(SR_DEF.$LAYOUT(), RET_STRUCT);\n+        checkLayout(SA_DEF.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(td2.$DESC, FUNC_DESC);\n+        \/\/ struct, anonymous\n+        checkLayout(Outer.fp1$return.$LAYOUT(), RET_STRUCT);\n+        checkLayout(Outer.fp1$x0.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(Outer.fp1.$DESC, FUNC_DESC);\n+        \/\/ struct, explicit names\n+        checkLayout(Outer.SR_FLD.$LAYOUT(), RET_STRUCT);\n+        checkLayout(Outer.SA_FLD.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(Outer.fp2.$DESC, FUNC_DESC);\n+        \/\/ struct + global, anonymous\n+        checkLayout(outer_var.fp1$return.$LAYOUT(), RET_STRUCT);\n+        checkLayout(outer_var.fp1$x0.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(outer_var.fp1.$DESC, FUNC_DESC);\n+        \/\/ struct + global, explicit names\n+        checkLayout(outer_var.SR_FLD_VAR.$LAYOUT(), RET_STRUCT);\n+        checkLayout(outer_var.SA_FLD_VAR.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(outer_var.fp2.$DESC, FUNC_DESC);\n+        \/\/ struct + typedef, anonymous\n+        checkLayout(outer_td.fp1$return.$LAYOUT(), RET_STRUCT);\n+        checkLayout(outer_td.fp1$x0.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(outer_td.fp1.$DESC, FUNC_DESC);\n+        \/\/ struct + typedef, explicit names\n+        checkLayout(outer_td.SR_FLD_DEF.$LAYOUT(), RET_STRUCT);\n+        checkLayout(outer_td.SA_FLD_DEF.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(outer_td.fp2.$DESC, FUNC_DESC);\n+        \/\/ struct + func return, anonymous\n+        checkLayout(f3$return.fp1$return.$LAYOUT(), RET_STRUCT);\n+        checkLayout(f3$return.fp1$x0.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(f3$return.fp1.$DESC, FUNC_DESC);\n+        \/\/ struct + func return, explicit names\n+        checkLayout(f3$return.SR_FLD_FUN_RET.$LAYOUT(), RET_STRUCT);\n+        checkLayout(f3$return.SA_FLD_FUN_RET.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(f3$return.fp2.$DESC, FUNC_DESC);\n+        \/\/ struct + func arg, anonymous\n+        checkLayout(f4$x0.fp1$return.$LAYOUT(), RET_STRUCT);\n+        checkLayout(f4$x0.fp1$x0.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(f4$x0.fp1.$DESC, FUNC_DESC);\n+        \/\/ struct + func arg, explicit names\n+        checkLayout(f4$x0.SR_FLD_FUN_ARG.$LAYOUT(), RET_STRUCT);\n+        checkLayout(f4$x0.SA_FLD_FUN_ARG.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(f4$x0.fp2.$DESC, FUNC_DESC);\n+    }\n+\n+    void checkLayout(MemoryLayout found, MemoryLayout expected) {\n+        assertEquals(found.withoutName(), expected);\n+    }\n+\n+    void checkDescriptor(FunctionDescriptor found, FunctionDescriptor expected) {\n+        assertEquals(\n+                FunctionDescriptor.of(\n+                        found.returnLayout().get().withoutName(),\n+                        found.argumentLayouts().get(0).withoutName()),\n+                expected);\n+    }\n+}\n","filename":"test\/jtreg\/generator\/nestedTypes\/TestNestedTypesNames.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ function declarations\n+struct { int x; } f1(struct { int y; } p);\n+\n+struct SR_FUN { int x; } f2(struct SA_FUN { int y; } p);\n+\n+\/\/ global variable declarations\n+\n+struct { int x; } (*fp1)(struct { int y; } p);\n+\n+struct SR_VAR { int x; } (*fp2)(struct SA_VAR { int y; } p);\n+\n+\/\/ typedef declarations\n+\n+typedef struct { int x; } (*td1)(struct { int y; } p);\n+\n+typedef struct SR_DEF { int x; } (*td2)(struct SA_DEF { int y; } p);\n+\n+\/\/ field declarations\n+\n+struct Outer {\n+    struct { int x; } (*fp1)(struct { int y; } p);\n+    struct SR_FLD { int x; } (*fp2)(struct SA_FLD { int y; } p);\n+};\n+\n+\/\/ field and global\n+\n+struct {\n+    struct { int x; } (*fp1)(struct { int y; } p);\n+    struct SR_FLD_VAR { int x; } (*fp2)(struct SA_FLD_VAR { int y; } p);\n+} outer_var;\n+\n+\/\/ field and typedef\n+\n+typedef struct {\n+    struct { int x; } (*fp1)(struct { int y; } p);\n+    struct SR_FLD_DEF { int x; } (*fp2)(struct SA_FLD_DEF { int y; } p);\n+} outer_td;\n+\n+\/\/ field and function return\n+\n+ struct {\n+     struct { int x; } (*fp1)(struct { int y; } p);\n+     struct SR_FLD_FUN_RET { int x; } (*fp2)(struct SA_FLD_FUN_RET { int y; } p);\n+ } f3(void);\n+\n+ \/\/ field and function arg\n+\n+ void f4(struct {\n+     struct { int x; } (*fp1)(struct { int y; } p);\n+     struct SR_FLD_FUN_ARG { int x; } (*fp2)(struct SA_FLD_FUN_ARG { int y; } p);\n+ } p);\n\\ No newline at end of file\n","filename":"test\/jtreg\/generator\/nestedTypes\/nested_types_names.h","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -118,2 +118,2 @@\n-            { \"Bar\", C_INT.withName(\"a\"),       int.class,           10 },\n-            { \"Bar\", C_INT.withName(\"b\"),       int.class,           10 },\n+            { \"Bar$0\", C_INT.withName(\"a\"),       int.class,           10 },\n+            { \"Bar$0\", C_INT.withName(\"b\"),       int.class,           10 },\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/TestClassGeneration.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}