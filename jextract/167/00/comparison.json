{"files":[{"patch":"@@ -41,0 +41,1 @@\n+                .map(new NestedDeclFinder()::scan)\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/CodeGenerator.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -466,0 +466,15 @@\n+\n+    \/**\n+     * An attribute to mark nested struct\/union\/enum declarations.\n+     *\/\n+    record NestedDecl() {\n+        private static final NestedDecl INSTANCE = new NestedDecl();\n+\n+        public static void with(Declaration declaration) {\n+            declaration.addAttribute(INSTANCE);\n+        }\n+\n+        public static boolean isPresent(Declaration declaration) {\n+            return declaration.getAttribute(NestedDecl.class).isPresent();\n+        }\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/DeclarationImpl.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-        if (Utils.declarationFor(type).map(Utils::isEnum).orElse(false)) {\n+        if (Utils.nestedDeclarationFor(type).map(Utils::isEnum).orElse(false)) {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/EnumConstantLifter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-        Utils.declarationFor(typedef.type()).ifPresent(s -> s.accept(this, typedef));\n+        Utils.nestedDeclarationFor(typedef.type()).ifPresent(s -> s.accept(this, typedef));\n@@ -206,1 +206,1 @@\n-        Utils.declarationFor(type).ifPresent(s -> s.accept(this, variable));\n+        Utils.nestedDeclarationFor(type).ifPresent(s -> s.accept(this, variable));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/NameMangler.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2023 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.impl;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Declaration.Scoped;\n+import org.openjdk.jextract.Type;\n+import org.openjdk.jextract.Type.Array;\n+import org.openjdk.jextract.Type.Declared;\n+import org.openjdk.jextract.Type.Delegated;\n+import org.openjdk.jextract.Type.Function;\n+import org.openjdk.jextract.Type.Visitor;\n+import org.openjdk.jextract.impl.DeclarationImpl.NestedDecl;\n+\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.Set;\n+\n+\/*\n+ * This visitor searches for scoped declarations that appear indirectly in the toplevel tree, as part of some\n+ * declared type, and marks them with the NestedDecl attribute.\n+ *\/\n+final class NestedDeclFinder implements Declaration.Visitor<Void, Void> {\n+\n+    private final Set<Declaration> seen = Collections.newSetFromMap(new IdentityHashMap<>());\n+    private final Set<Declaration> pending = Collections.newSetFromMap(new IdentityHashMap<>());\n+\n+    public Declaration.Scoped scan(Declaration.Scoped header) {\n+        \/\/ Initial scan. After this step:\n+        \/\/ (a) \"seen\" contains declarations directly nested in any of the visited members\n+        \/\/ (b) \"pending\" contains declarations that are indirectly (e.g. via a type) nested in any of the visited members\n+        header.members().forEach(fieldTree -> fieldTree.accept(this, null));\n+        while (!seen.isEmpty()) {\n+            \/\/ remove directly nested declaration from \"pending\" (as these are not true nested declarations)\n+            seen.removeAll(pending);\n+            \/\/ for each remaining nested declaration in the to do list:\n+            \/\/ (a) mark it with NestedDecl attribute\n+            \/\/ (b) propagate the visit (this results in further updates to \"seen\" and \"pending\", as described above)\n+            for (Declaration d : Set.copyOf(seen)) {\n+                NestedDecl.with(d);\n+                d.accept(this, null);\n+            }\n+        }\n+\n+        return header;\n+    }\n+\n+    @Override\n+    public Void visitFunction(Declaration.Function funcTree, Void ignored) {\n+        funcTree.type().accept(nestedDeclarationTypeVisitor, null);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitTypedef(Declaration.Typedef tree, Void ignored) {\n+        tree.type().accept(nestedDeclarationTypeVisitor, null);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitVariable(Declaration.Variable tree, Void ignored) {\n+        tree.type().accept(nestedDeclarationTypeVisitor, null);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitScoped(Scoped d, Void unused) {\n+        pending.add(d);\n+        \/\/ propagate\n+        d.members().forEach(m -> m.accept(this, null));\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitDeclaration(Declaration decl, Void ignored) {\n+        return null;\n+    }\n+\n+    Type.Visitor<Void, Void> nestedDeclarationTypeVisitor = new Visitor<Void, Void>() {\n+        @Override\n+        public Void visitArray(Array t, Void unused) {\n+            t.elementType().accept(this, null);\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitDelegated(Delegated t, Void unused) {\n+            t.type().accept(this, null);\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitDeclared(Declared t, Void unused) {\n+            seen.add(t.tree());\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitFunction(Function t, Void unused) {\n+            t.returnType().accept(this, null);\n+            t.argumentTypes().forEach(a -> a.accept(this, null));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitType(Type t, Void unused) {\n+            return null;\n+        }\n+    };\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/NestedDeclFinder.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -46,1 +46,0 @@\n-    private final String pkgName;\n@@ -52,2 +51,1 @@\n-        return new OutputFactory(pkgName, toplevelBuilder).\n-            generate(decl);\n+        return new OutputFactory(toplevelBuilder).generate(decl);\n@@ -56,2 +54,1 @@\n-    private OutputFactory(String pkgName, ToplevelBuilder toplevelBuilder) {\n-        this.pkgName = pkgName;\n+    private OutputFactory(ToplevelBuilder toplevelBuilder) {\n@@ -146,26 +143,6 @@\n-        Optional<Declaration.Scoped> optScoped = Utils.declarationFor(type);\n-        if (optScoped.isPresent()) {\n-            Declaration.Scoped scoped = optScoped.get();\n-            if (!scoped.name().equals(tree.name())) {\n-                switch (scoped.kind()) {\n-                    case STRUCT, UNION -> {\n-                        if (scoped.name().isEmpty()) {\n-                            visitScoped(scoped, tree);\n-                        } else {\n-                            \/*\n-                             * If typedef is seen after the struct\/union definition, we can generate subclass\n-                             * right away. If not, we've to save it and revisit after all the declarations are\n-                             * seen. This is to support forward declaration of typedefs.\n-                             *\n-                             * typedef struct Foo Bar;\n-                             *\n-                             * struct Foo {\n-                             *     int x, y;\n-                             * };\n-                             *\/\n-                            toplevelBuilder.addTypedef(tree, JavaName.getFullNameOrThrow(scoped));\n-                        }\n-                    }\n-                    default -> visitScoped(scoped, tree);\n-                }\n-            }\n+        Optional<Declaration.Scoped> optScoped = Utils.nestedDeclarationFor(type);\n+        optScoped.ifPresent(s -> s.accept(this, null));\n+\n+        Declaration.Scoped structOrUnionDecl = Utils.structOrUnionDecl(type);\n+        if (structOrUnionDecl != null) {\n+            toplevelBuilder.addTypedef(tree, JavaName.getFullNameOrThrow(structOrUnionDecl));\n@@ -197,1 +174,1 @@\n-        Utils.declarationFor(type).ifPresent(s -> s.accept(this, tree));\n+        Utils.nestedDeclarationFor(type).ifPresent(s -> s.accept(this, tree));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":9,"deletions":32,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-        Utils.declarationFor(type).ifPresent(s -> s.accept(this, varTree));\n+        Utils.nestedDeclarationFor(type).ifPresent(s -> s.accept(this, varTree));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnsupportedFilter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.NestedDecl;\n@@ -112,3 +113,1 @@\n-    static Optional<Declaration.Scoped> declarationFor(Type type) {\n-        \/\/ @@@: we don't chase delegated types (typedefs or pointers). This could lead to declarations\n-        \/\/ not being visited, which could result in missing generated code.\n+    static Optional<Declaration.Scoped> nestedDeclarationFor(Type type) {\n@@ -116,2 +115,3 @@\n-            case Type.Declared declared -> Optional.of(declared.tree());\n-            case Type.Array array -> declarationFor(array.elementType());\n+            case Type.Declared declared when NestedDecl.isPresent(declared.tree()) -> Optional.of(declared.tree());\n+            case Type.Array array -> nestedDeclarationFor(array.elementType());\n+            case Type.Delegated delegated -> nestedDeclarationFor(delegated.type());\n@@ -152,0 +152,4 @@\n+        return structOrUnionDecl(type) != null;\n+    }\n+\n+    static Declaration.Scoped structOrUnionDecl(Type type) {\n@@ -153,1 +157,1 @@\n-            case Type.Declared declared -> isStructOrUnion(declared.tree());\n+            case Type.Declared declared when isStructOrUnion(declared.tree()) -> declared.tree();\n@@ -155,2 +159,2 @@\n-                isStructOrUnion(delegated.type());\n-            default -> false;\n+                    structOrUnionDecl(delegated.type());\n+            default -> null;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Utils.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.nested.anon.*;\n+\n+import java.lang.foreign.GroupLayout;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.nested.anon nestedInsideAnon.h\n+ * @build TestNestedInsideAnon\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNestedInsideAnon\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library \/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.nested.anon nestedInsideAnon.h\n+ * @build TestNestedInsideAnon\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNestedInsideAnon\n+ *\/\n+public class TestNestedInsideAnon {\n+\n+    @Test\n+    public void testAnonField() {\n+        checkLayout(P.$LAYOUT());\n+    }\n+\n+    void checkLayout(GroupLayout layout) {\n+        assertEquals(((GroupLayout)layout.memberLayouts().get(0)).memberLayouts().get(0).withoutName(),\n+                P.Flags.$LAYOUT().withoutName());\n+    }\n+}\n","filename":"test\/jtreg\/generator\/nestedInsideAnon\/TestNestedInsideAnon.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -24,11 +24,7 @@\n-#define FIELDS \\\n-int x; \\\n-int y;\n-\n-struct PointA {\n-   FIELDS\n-};\n-\n-struct PointB {\n-   FIELDS\n-};\n+typedef struct {\n+    struct {\n+        struct {\n+            char y;\n+        } Flags;\n+    };\n+} P;\n","filename":"test\/jtreg\/generator\/nestedInsideAnon\/nestedInsideAnon.h","additions":7,"deletions":11,"binary":false,"changes":18,"previous_filename":"test\/jtreg\/generator\/dedup\/macro_fields.h","status":"copied"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.out.typedef.*;\n+\n+import java.lang.foreign.GroupLayout;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.out.typedef out_of_order_typedef.h\n+ * @build TestOutOfOrderTypedef\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestOutOfOrderTypedef\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library \/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.out.typedef out_of_order_typedef.h\n+ * @build TestOutOfOrderTypedef\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestOutOfOrderTypedef\n+ *\/\n+public class TestOutOfOrderTypedef {\n+\n+    @Test\n+    public void testFoo() {\n+        checkLayout(Foo.$LAYOUT());\n+    }\n+\n+    void checkLayout(GroupLayout layout) {\n+        assertEquals(layout.memberLayouts().get(0).withoutName(),\n+                Foo.Baz.$LAYOUT().withoutName());\n+    }\n+}\n","filename":"test\/jtreg\/generator\/outOfOrderTypedef\/TestOutOfOrderTypedef.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -24,3 +24,1 @@\n-#define FIELDS \\\n-int x; \\\n-int y;\n+typedef struct tagFoo Foo;\n@@ -28,2 +26,2 @@\n-struct PointA {\n-   FIELDS\n+struct Bar {\n+    int x;\n@@ -32,3 +30,3 @@\n-struct PointB {\n-   FIELDS\n-};\n+typedef struct tagFoo {\n+    struct Baz { int y; } bar;\n+} Foo;\n","filename":"test\/jtreg\/generator\/outOfOrderTypedef\/out_of_order_typedef.h","additions":6,"deletions":8,"binary":false,"changes":14,"previous_filename":"test\/jtreg\/generator\/dedup\/macro_fields.h","status":"copied"}]}