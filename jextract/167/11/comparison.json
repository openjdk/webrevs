{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -467,0 +466,15 @@\n+    \/**\n+     * An attribute to attach nested struct\/union\/enum declarations to other declarations.\n+     *\/\n+    record NestedDeclarations(List<Scoped> nestedDeclarations) {\n+\n+        public static void with(Declaration declaration, List<Scoped> nestedDeclarations) {\n+            declaration.addAttribute(new NestedDeclarations(nestedDeclarations));\n+        }\n+\n+        public static Optional<List<Scoped>> get(Declaration declaration) {\n+            return declaration.getAttribute(NestedDeclarations.class)\n+                    .stream().map(NestedDeclarations::nestedDeclarations).findFirst();\n+        }\n+    }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/DeclarationImpl.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jextract.Declaration.Typedef;\n+import org.openjdk.jextract.Declaration.Variable;\n@@ -30,0 +32,2 @@\n+import org.openjdk.jextract.Type.Function;\n+import org.openjdk.jextract.impl.DeclarationImpl.AnonymousStruct;\n@@ -139,2 +143,2 @@\n-                String declFiName = func.name() + \"$\" + (param.name().isEmpty() ? \"x\" + i : param.name());\n-                JavaFunctionalInterfaceName.with(param, declFiName);\n+                String fiName = func.name() + \"$\" + (param.name().isEmpty() ? \"x\" + i : param.name());\n+                JavaFunctionalInterfaceName.with(param, fiName);\n@@ -144,0 +148,1 @@\n+            Utils.forEachNested(param, s -> s.accept(this, func));\n@@ -145,0 +150,1 @@\n+\n@@ -149,0 +155,1 @@\n+        Utils.forEachNested(func, s -> s.accept(this, func));\n@@ -155,8 +162,7 @@\n-        String name = scoped.name();\n-        if (name.isEmpty() && parent != null) {\n-            name = parent.name();\n-        }\n-        if (JavaName.isPresent(scoped)) {\n-            \/\/skip struct that's seen already\n-            return null;\n-        }\n+        if (Utils.isEnum(scoped)) {\n+            scoped.members().forEach(fieldTree -> fieldTree.accept(this, null));\n+        } else if (Utils.isStructOrUnion(scoped)) {\n+            if (JavaName.isPresent(scoped)) {\n+                \/\/skip struct that's seen already\n+                return null;\n+            }\n@@ -164,11 +170,13 @@\n-        Scope oldScope = curScope;\n-        boolean isNestedAnonStruct = scoped.name().isEmpty() &&\n-            (parent instanceof Declaration.Scoped);\n-        if (!isNestedAnonStruct) {\n-            this.curScope = Scope.newStruct(oldScope, name);\n-            JavaName.with(scoped, curScope.fullName());\n-        }\n-        try {\n-            scoped.members().forEach(fieldTree -> fieldTree.accept(this, scoped));\n-        } finally {\n-            this.curScope = oldScope;\n+            Scope oldScope = curScope;\n+            if (!AnonymousStruct.isPresent(scoped)) {\n+                String name = scoped.name().isEmpty() ?\n+                        fallbackNameFor(parent, scoped) :\n+                        scoped.name();\n+                this.curScope = Scope.newStruct(oldScope, name);\n+                JavaName.with(scoped, curScope.fullName());\n+            }\n+            try {\n+                scoped.members().forEach(fieldTree -> fieldTree.accept(this, null));\n+            } finally {\n+                this.curScope = oldScope;\n+            }\n@@ -187,3 +195,0 @@\n-        \/\/ handle if this typedef is of a struct\/union\/enum etc.\n-        Utils.declarationFor(typedef.type()).ifPresent(s -> s.accept(this, typedef));\n-\n@@ -199,0 +204,5 @@\n+\n+        \/\/ handle if this typedef is of a struct\/union\/enum etc.\n+        Utils.forEachNested(typedef, d -> {\n+            d.accept(this, typedef);\n+        });\n@@ -202,0 +212,27 @@\n+    private String fallbackNameFor(Declaration parent, Declaration.Scoped nested) {\n+        String nestedName = parent.name();\n+        Function func = switch (parent) {\n+            case Declaration.Function f -> f.type();\n+            case Variable v -> Utils.getAsFunctionPointer(v.type());\n+            case Typedef t -> Utils.getAsFunctionPointer(t.type());\n+            default -> null;\n+        };\n+        if (func != null) {\n+            \/\/ if this is a function pointer type def, try to use better fallback names for any\n+            \/\/ anon struct\/union that might be defined as part of this typedef\n+            String suffix = null;\n+            for (int i = 0 ; i < func.argumentTypes().size() ; i++) {\n+                if (func.argumentTypes().get(i) instanceof Type.Declared declared && declared.tree() == nested) {\n+                    \/\/ it's a function argument\n+                    suffix = \"$x\" + i;\n+                }\n+            }\n+            if (suffix == null) {\n+                \/\/ not found, assume it's the function return\n+                suffix = \"$return\";\n+            }\n+            nestedName = nestedName + suffix;\n+        }\n+        return nestedName;\n+    }\n+\n@@ -206,1 +243,0 @@\n-        Utils.declarationFor(type).ifPresent(s -> s.accept(this, variable));\n@@ -209,2 +245,2 @@\n-            String fiName = curScope.uniqueNestedClassName(variable.name());\n-            JavaFunctionalInterfaceName.with(variable, fiName);\n+            String declFiName = curScope.uniqueNestedClassName(variable.name());\n+            JavaFunctionalInterfaceName.with(variable, declFiName);\n@@ -217,0 +253,1 @@\n+        Utils.forEachNested(variable, s -> s.accept(this, variable));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/NameMangler.java","additions":64,"deletions":27,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-    private final String pkgName;\n@@ -52,2 +51,1 @@\n-        return new OutputFactory(pkgName, toplevelBuilder).\n-            generate(decl);\n+        return new OutputFactory(toplevelBuilder).generate(decl);\n@@ -56,2 +54,1 @@\n-    private OutputFactory(String pkgName, ToplevelBuilder toplevelBuilder) {\n-        this.pkgName = pkgName;\n+    private OutputFactory(ToplevelBuilder toplevelBuilder) {\n@@ -124,0 +121,1 @@\n+            Utils.forEachNested(param, s -> s.accept(this, param));\n@@ -130,0 +128,2 @@\n+        Utils.forEachNested(funcTree, s -> s.accept(this, funcTree));\n+\n@@ -146,26 +146,5 @@\n-        Optional<Declaration.Scoped> optScoped = Utils.declarationFor(type);\n-        if (optScoped.isPresent()) {\n-            Declaration.Scoped scoped = optScoped.get();\n-            if (!scoped.name().equals(tree.name())) {\n-                switch (scoped.kind()) {\n-                    case STRUCT, UNION -> {\n-                        if (scoped.name().isEmpty()) {\n-                            visitScoped(scoped, tree);\n-                        } else {\n-                            \/*\n-                             * If typedef is seen after the struct\/union definition, we can generate subclass\n-                             * right away. If not, we've to save it and revisit after all the declarations are\n-                             * seen. This is to support forward declaration of typedefs.\n-                             *\n-                             * typedef struct Foo Bar;\n-                             *\n-                             * struct Foo {\n-                             *     int x, y;\n-                             * };\n-                             *\/\n-                            toplevelBuilder.addTypedef(tree, JavaName.getFullNameOrThrow(scoped));\n-                        }\n-                    }\n-                    default -> visitScoped(scoped, tree);\n-                }\n-            }\n+        Utils.forEachNested(tree, s -> s.accept(this, null));\n+\n+        Declaration.Scoped structOrUnionDecl = Utils.structOrUnionDecl(type);\n+        if (structOrUnionDecl != null) {\n+            toplevelBuilder.addTypedef(tree, JavaName.getFullNameOrThrow(structOrUnionDecl));\n@@ -197,1 +176,1 @@\n-        Utils.declarationFor(type).ifPresent(s -> s.accept(this, tree));\n+        Utils.forEachNested(tree, s -> s.accept(this, tree));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":11,"deletions":32,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.NestedDeclarations;\n@@ -225,2 +226,2 @@\n-        return Declaration.function(CursorPosition.of(c), c.spelling(), (Type.Function)funcType,\n-                params.toArray(new Declaration.Variable[0]));\n+        return withNestedTypes(Declaration.function(CursorPosition.of(c), c.spelling(), (Type.Function)funcType,\n+                params.toArray(new Declaration.Variable[0])), c, true);\n@@ -429,1 +430,1 @@\n-        return Declaration.typedef(CursorPosition.of(c), c.spelling(), canonicalType);\n+        return withNestedTypes(Declaration.typedef(CursorPosition.of(c), c.spelling(), canonicalType), c, false);\n@@ -445,1 +446,31 @@\n-        return Declaration.var(kind, CursorPosition.of(c), c.spelling(), type);\n+        return withNestedTypes(Declaration.var(kind, CursorPosition.of(c), c.spelling(), type), c, false);\n+    }\n+\n+    \/*\n+     * Some declarations (global vars, struct\/union fields, function parameter\/return types might contain\n+     * inline nested struct\/union\/enum definitions. This method collects such definitions and\n+     * attaches them to the original declaration, using an attribute.\n+     *\/\n+    private <D extends Declaration> D withNestedTypes(D d, Cursor c, boolean ignoreNestedParams) {\n+        List<Declaration> nestedDefinitions = new ArrayList<>();\n+        collectNestedTypes(c, nestedDefinitions, ignoreNestedParams);\n+        List<Scoped> nestedDecls = nestedDefinitions.stream()\n+                .filter(m -> m instanceof Scoped)\n+                .map(Scoped.class::cast)\n+                .toList();\n+        if (!nestedDecls.isEmpty()) {\n+            NestedDeclarations.with(d, nestedDecls);\n+        }\n+        return d;\n+    }\n+\n+    private void collectNestedTypes(Cursor c, List<Declaration> nestedTypes, boolean ignoreNestedParams) {\n+        c.forEach(m -> {\n+            if (m.isDefinition()) {\n+                if (m.kind() == CursorKind.ParmDecl && !ignoreNestedParams) {\n+                    collectNestedTypes(m, nestedTypes, ignoreNestedParams);\n+                } else {\n+                    nestedTypes.add(createTree(m));\n+                }\n+            }\n+        });\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeMaker.java","additions":35,"deletions":4,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -73,0 +73,2 @@\n+        Utils.forEachNested(funcTree, s -> s.accept(this, firstNamedParent));\n+\n@@ -83,0 +85,1 @@\n+            Utils.forEachNested(param, s -> s.accept(this, firstNamedParent));\n@@ -106,2 +109,1 @@\n-        Type type = varTree.type();\n-        Utils.declarationFor(type).ifPresent(s -> s.accept(this, varTree));\n+        Utils.forEachNested(varTree, s -> s.accept(this, varTree));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnsupportedFilter.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.NestedDeclarations;\n@@ -49,1 +50,1 @@\n-import java.util.Optional;\n+import java.util.function.Consumer;\n@@ -112,8 +113,3 @@\n-    static Optional<Declaration.Scoped> declarationFor(Type type) {\n-        \/\/ @@@: we don't chase delegated types (typedefs or pointers). This could lead to declarations\n-        \/\/ not being visited, which could result in missing generated code.\n-        return switch (type) {\n-            case Type.Declared declared -> Optional.of(declared.tree());\n-            case Type.Array array -> declarationFor(array.elementType());\n-            default -> Optional.empty();\n-        };\n+    static void forEachNested(Declaration declaration, Consumer<Declaration> nestedDeclAction) {\n+        NestedDeclarations.get(declaration).ifPresent(decls ->\n+            decls.forEach(nestedDeclAction));\n@@ -152,0 +148,4 @@\n+        return structOrUnionDecl(type) != null;\n+    }\n+\n+    static Declaration.Scoped structOrUnionDecl(Type type) {\n@@ -153,1 +153,1 @@\n-            case Type.Declared declared -> isStructOrUnion(declared.tree());\n+            case Type.Declared declared when isStructOrUnion(declared.tree()) -> declared.tree();\n@@ -155,2 +155,2 @@\n-                isStructOrUnion(delegated.type());\n-            default -> false;\n+                    structOrUnionDecl(delegated.type());\n+            default -> null;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Utils.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.nested.anon.*;\n+\n+import java.lang.foreign.GroupLayout;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.nested.anon nestedInsideAnon.h\n+ * @build TestNestedInsideAnon\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNestedInsideAnon\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library \/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.nested.anon nestedInsideAnon.h\n+ * @build TestNestedInsideAnon\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNestedInsideAnon\n+ *\/\n+public class TestNestedInsideAnon {\n+\n+    @Test\n+    public void testAnonField() {\n+        checkLayout(P.$LAYOUT());\n+    }\n+\n+    void checkLayout(GroupLayout layout) {\n+        assertEquals(((GroupLayout)layout.memberLayouts().get(0)).memberLayouts().get(0).withoutName(),\n+                P.Flags.$LAYOUT().withoutName());\n+    }\n+}\n","filename":"test\/jtreg\/generator\/nestedInsideAnon\/TestNestedInsideAnon.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -24,11 +24,7 @@\n-#define FIELDS \\\n-int x; \\\n-int y;\n-\n-struct PointA {\n-   FIELDS\n-};\n-\n-struct PointB {\n-   FIELDS\n-};\n+typedef struct {\n+    struct {\n+        struct {\n+            char y;\n+        } Flags;\n+    };\n+} P;\n","filename":"test\/jtreg\/generator\/nestedInsideAnon\/nestedInsideAnon.h","additions":7,"deletions":11,"binary":false,"changes":18,"previous_filename":"test\/jtreg\/generator\/dedup\/macro_fields.h","status":"copied"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.nestedtypes.names.*;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test id=classes\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.nestedtypes.names nested_types_names.h\n+ * @build TestNestedTypesNames\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNestedTypesNames\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library \/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.nestedtypes.names nested_types_names.h\n+ * @build TestNestedTypesNames\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNestedTypesNames\n+ *\/\n+public class TestNestedTypesNames {\n+\n+    static MemoryLayout ARG_STRUCT = MemoryLayout.structLayout(\n+        nested_types_names_h.C_INT.withName(\"y\")\n+    );\n+\n+    static MemoryLayout RET_STRUCT = MemoryLayout.structLayout(\n+        nested_types_names_h.C_INT.withName(\"x\")\n+    );\n+\n+    static FunctionDescriptor FUNC_DESC = FunctionDescriptor.of(\n+            RET_STRUCT,\n+            ARG_STRUCT\n+    );\n+\n+    @Test\n+    public void testTypeNamesAndLayouts() {\n+        \/\/ function, anonymous\n+        checkLayout(f1$return.$LAYOUT(), RET_STRUCT);\n+        checkLayout(f1$x0.$LAYOUT(), ARG_STRUCT);\n+        \/\/ function, explicit names\n+        checkLayout(SR_FUN.$LAYOUT(), RET_STRUCT);\n+        checkLayout(SA_FUN.$LAYOUT(), ARG_STRUCT);\n+        \/\/ global, anonymous\n+        checkLayout(fp1$return.$LAYOUT(), RET_STRUCT);\n+        checkLayout(fp1$x0.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(fp1.$DESC, FUNC_DESC);\n+        \/\/ global, explicit names\n+        checkLayout(SR_VAR.$LAYOUT(), RET_STRUCT);\n+        checkLayout(SA_VAR.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(fp2.$DESC, FUNC_DESC);\n+        \/\/ typedef, anonymous\n+        checkLayout(td1$return.$LAYOUT(), RET_STRUCT);\n+        checkLayout(td1$x0.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(td1.$DESC, FUNC_DESC);\n+        \/\/ typedef, explicit names\n+        checkLayout(SR_DEF.$LAYOUT(), RET_STRUCT);\n+        checkLayout(SA_DEF.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(td2.$DESC, FUNC_DESC);\n+        \/\/ struct, anonymous\n+        checkLayout(Outer.fp1$return.$LAYOUT(), RET_STRUCT);\n+        checkLayout(Outer.fp1$x0.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(Outer.fp1.$DESC, FUNC_DESC);\n+        \/\/ struct, explicit names\n+        checkLayout(Outer.SR_FLD.$LAYOUT(), RET_STRUCT);\n+        checkLayout(Outer.SA_FLD.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(Outer.fp2.$DESC, FUNC_DESC);\n+        \/\/ struct + global, anonymous\n+        checkLayout(outer_var.fp1$return.$LAYOUT(), RET_STRUCT);\n+        checkLayout(outer_var.fp1$x0.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(outer_var.fp1.$DESC, FUNC_DESC);\n+        \/\/ struct + global, explicit names\n+        checkLayout(outer_var.SR_FLD_VAR.$LAYOUT(), RET_STRUCT);\n+        checkLayout(outer_var.SA_FLD_VAR.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(outer_var.fp2.$DESC, FUNC_DESC);\n+        \/\/ struct + typedef, anonymous\n+        checkLayout(outer_td.fp1$return.$LAYOUT(), RET_STRUCT);\n+        checkLayout(outer_td.fp1$x0.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(outer_td.fp1.$DESC, FUNC_DESC);\n+        \/\/ struct + typedef, explicit names\n+        checkLayout(outer_td.SR_FLD_DEF.$LAYOUT(), RET_STRUCT);\n+        checkLayout(outer_td.SA_FLD_DEF.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(outer_td.fp2.$DESC, FUNC_DESC);\n+        \/\/ struct + func return, anonymous\n+        checkLayout(f3$return.fp1$return.$LAYOUT(), RET_STRUCT);\n+        checkLayout(f3$return.fp1$x0.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(f3$return.fp1.$DESC, FUNC_DESC);\n+        \/\/ struct + func return, explicit names\n+        checkLayout(f3$return.SR_FLD_FUN_RET.$LAYOUT(), RET_STRUCT);\n+        checkLayout(f3$return.SA_FLD_FUN_RET.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(f3$return.fp2.$DESC, FUNC_DESC);\n+        \/\/ struct + func arg, anonymous\n+        checkLayout(f4$x0.fp1$return.$LAYOUT(), RET_STRUCT);\n+        checkLayout(f4$x0.fp1$x0.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(f4$x0.fp1.$DESC, FUNC_DESC);\n+        \/\/ struct + func arg, explicit names\n+        checkLayout(f4$x0.SR_FLD_FUN_ARG.$LAYOUT(), RET_STRUCT);\n+        checkLayout(f4$x0.SA_FLD_FUN_ARG.$LAYOUT(), ARG_STRUCT);\n+        checkDescriptor(f4$x0.fp2.$DESC, FUNC_DESC);\n+    }\n+\n+    void checkLayout(MemoryLayout found, MemoryLayout expected) {\n+        assertEquals(found.withoutName(), expected);\n+    }\n+\n+    void checkDescriptor(FunctionDescriptor found, FunctionDescriptor expected) {\n+        assertEquals(\n+                FunctionDescriptor.of(\n+                        found.returnLayout().get().withoutName(),\n+                        found.argumentLayouts().get(0).withoutName()),\n+                expected);\n+    }\n+}\n","filename":"test\/jtreg\/generator\/nestedTypes\/TestNestedTypesNames.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.nestedtypes.unsupported.*;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test id=classes\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.nestedtypes.unsupported nested_types_unsupported.h\n+ * @build TestNestedTypesUnsupported\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNestedTypesUnsupported\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library \/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.nestedtypes.unsupported nested_types_unsupported.h\n+ * @build TestNestedTypesUnsupported\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNestedTypesUnsupported\n+ *\/\n+public class TestNestedTypesUnsupported {\n+\n+    static MemoryLayout UNDEFINED_STRUCT = MemoryLayout.structLayout(\n+            MemoryLayout.paddingLayout(nested_types_unsupported_h.C_POINTER.byteSize())\n+    );\n+\n+    @Test\n+    public void testTypeNamesAndLayouts() {\n+        checkLayout(Outer.$LAYOUT(), UNDEFINED_STRUCT);\n+        checkLayout(outer_var.$LAYOUT(), UNDEFINED_STRUCT);\n+        checkLayout(outer_td.$LAYOUT(), UNDEFINED_STRUCT);\n+        checkLayout(outer_td$0.$LAYOUT(), UNDEFINED_STRUCT);\n+        checkLayout(f2$return.$LAYOUT(), UNDEFINED_STRUCT);\n+        checkLayout(f3$x0.$LAYOUT(), UNDEFINED_STRUCT);\n+    }\n+\n+    void checkLayout(MemoryLayout found, MemoryLayout expected) {\n+        assertEquals(found.withoutName(), expected);\n+    }\n+}\n","filename":"test\/jtreg\/generator\/nestedTypes\/TestNestedTypesUnsupported.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+\/\/ function declarations\n+EXPORT struct { int x; } f1(struct { int y; } p);\n+\n+EXPORT struct SR_FUN { int x; } f2(struct SA_FUN { int y; } p);\n+\n+\/\/ global variable declarations\n+\n+EXPORT struct { int x; } (*fp1)(struct { int y; } p);\n+\n+EXPORT struct SR_VAR { int x; } (*fp2)(struct SA_VAR { int y; } p);\n+\n+\/\/ typedef declarations\n+\n+typedef struct { int x; } (*td1)(struct { int y; } p);\n+\n+typedef struct SR_DEF { int x; } (*td2)(struct SA_DEF { int y; } p);\n+\n+\/\/ field declarations\n+\n+struct Outer {\n+    struct { int x; } (*fp1)(struct { int y; } p);\n+    struct SR_FLD { int x; } (*fp2)(struct SA_FLD { int y; } p);\n+};\n+\n+\/\/ field and global\n+\n+EXPORT struct {\n+    struct { int x; } (*fp1)(struct { int y; } p);\n+    struct SR_FLD_VAR { int x; } (*fp2)(struct SA_FLD_VAR { int y; } p);\n+} outer_var;\n+\n+\/\/ field and typedef\n+\n+typedef struct {\n+    struct { int x; } (*fp1)(struct { int y; } p);\n+    struct SR_FLD_DEF { int x; } (*fp2)(struct SA_FLD_DEF { int y; } p);\n+} outer_td;\n+\n+\/\/ field and function return\n+\n+EXPORT struct {\n+    struct { int x; } (*fp1)(struct { int y; } p);\n+    struct SR_FLD_FUN_RET { int x; } (*fp2)(struct SA_FLD_FUN_RET { int y; } p);\n+} f3(void);\n+\n+\/\/ field and function arg\n+EXPORT void f4(struct {\n+    struct { int x; } (*fp1)(struct { int y; } p);\n+    struct SR_FLD_FUN_ARG { int x; } (*fp2)(struct SA_FLD_FUN_ARG { int y; } p);\n+} p);\n","filename":"test\/jtreg\/generator\/nestedTypes\/nested_types_names.h","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+\/\/ function declarations\n+EXPORT struct UNSUPPORTED f1(struct UNSUPPORTED p);\n+\n+\/\/ global variable declarations\n+\n+EXPORT struct UNSUPPORTED (*fp)(struct UNSUPPORTED p);\n+\n+\/\/ typedef declarations\n+\n+typedef struct UNSUPPORTED (*td)(struct UNSUPPORTED p);\n+\n+\/\/ field declarations\n+\n+struct Outer {\n+    struct UNSUPPORTED (*fp)(struct UNSUPPORTED p);\n+};\n+\n+\/\/ field and global\n+\n+EXPORT struct {\n+    struct UNSUPPORTED (*fp)(struct UNSUPPORTED p);\n+} outer_var;\n+\n+\/\/ field and typedef\n+\n+typedef struct {\n+    struct UNSUPPORTED (*fp)(struct UNSUPPORTED p);\n+} outer_td;\n+\n+\/\/ field and function return\n+\n+EXPORT struct {\n+    struct UNSUPPORTED (*fp)(struct UNSUPPORTED p);\n+} f2(void);\n+\n+\/\/ field and function arg\n+EXPORT void f3(struct {\n+    struct UNSUPPORTED (*fp)(struct UNSUPPORTED p);\n+} p);\n","filename":"test\/jtreg\/generator\/nestedTypes\/nested_types_unsupported.h","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.out.struct.*;\n+\n+import java.lang.foreign.GroupLayout;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.out.struct out_of_order_struct.h\n+ * @build TestOutOfOrderStruct\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestOutOfOrderStruct\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library \/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.out.struct out_of_order_struct.h\n+ * @build TestOutOfOrderStruct\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestOutOfOrderStruct\n+ *\/\n+public class TestOutOfOrderStruct {\n+\n+    @Test\n+    public void testFoo() {\n+        checkLayout(Foo.$LAYOUT());\n+    }\n+\n+    void checkLayout(GroupLayout layout) {\n+        assertEquals(layout.memberLayouts().get(0).withoutName(),\n+                Foo.Baz.$LAYOUT().withoutName());\n+    }\n+}\n","filename":"test\/jtreg\/generator\/outOfOrder\/TestOutOfOrderStruct.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.out.typedef.*;\n+\n+import java.lang.foreign.GroupLayout;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.out.typedef out_of_order_typedef.h\n+ * @build TestOutOfOrderTypedef\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestOutOfOrderTypedef\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library \/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.out.typedef out_of_order_typedef.h\n+ * @build TestOutOfOrderTypedef\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestOutOfOrderTypedef\n+ *\/\n+public class TestOutOfOrderTypedef {\n+\n+    @Test\n+    public void testFoo() {\n+        checkLayout(Foo.$LAYOUT());\n+    }\n+\n+    void checkLayout(GroupLayout layout) {\n+        assertEquals(layout.memberLayouts().get(0).withoutName(),\n+                Foo.Baz.$LAYOUT().withoutName());\n+    }\n+}\n","filename":"test\/jtreg\/generator\/outOfOrder\/TestOutOfOrderTypedef.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -24,6 +24,2 @@\n-#define FIELDS \\\n-int x; \\\n-int y;\n-\n-struct PointA {\n-   FIELDS\n+struct Dummy {\n+    struct tagFoo *Foo;\n@@ -32,3 +28,3 @@\n-struct PointB {\n-   FIELDS\n-};\n+typedef struct tagFoo {\n+    struct Baz { int y; } bar;\n+} Foo;\n","filename":"test\/jtreg\/generator\/outOfOrder\/out_of_order_struct.h","additions":5,"deletions":9,"binary":false,"changes":14,"previous_filename":"test\/jtreg\/generator\/dedup\/macro_fields.h","status":"copied"},{"patch":"@@ -24,3 +24,1 @@\n-struct Outer {\n-    struct Inner { int x; } a;\n-};\n+typedef struct tagFoo Foo;\n@@ -28,1 +26,3 @@\n-typedef struct Inner T;\n+typedef struct tagFoo {\n+    struct Baz { int y; } bar;\n+} Foo;\n","filename":"test\/jtreg\/generator\/outOfOrder\/out_of_order_typedef.h","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/jtreg\/generator\/nestedStructTypedef\/nestedStructTypedef.h","status":"copied"},{"patch":"@@ -118,2 +118,2 @@\n-            { \"Bar\", C_INT.withName(\"a\"),       int.class,           10 },\n-            { \"Bar\", C_INT.withName(\"b\"),       int.class,           10 },\n+            { \"Bar$0\", C_INT.withName(\"a\"),       int.class,           10 },\n+            { \"Bar$0\", C_INT.withName(\"b\"),       int.class,           10 },\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/TestClassGeneration.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}