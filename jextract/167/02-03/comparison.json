{"files":[{"patch":"@@ -41,1 +41,0 @@\n-                .map(new NestedDeclFinder()::scan)\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/CodeGenerator.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -468,1 +467,1 @@\n-     * An attribute to mark nested struct\/union\/enum declarations.\n+     * An attribute to attach nested struct\/union\/enum declarations to other declarations.\n@@ -470,2 +469,1 @@\n-    record NestedDecl() {\n-        private static final NestedDecl INSTANCE = new NestedDecl();\n+    record NestedTypes(List<Type.Declared> nestedTypes) {\n@@ -473,2 +471,2 @@\n-        public static void with(Declaration declaration) {\n-            declaration.addAttribute(INSTANCE);\n+        public static void with(Declaration declaration, List<Type.Declared> nestedTypes) {\n+            declaration.addAttribute(new NestedTypes(nestedTypes));\n@@ -477,2 +475,3 @@\n-        public static boolean isPresent(Declaration declaration) {\n-            return declaration.getAttribute(NestedDecl.class).isPresent();\n+        public static Optional<List<Type.Declared>> get(Declaration declaration) {\n+            return declaration.getAttribute(NestedTypes.class)\n+                    .stream().map(NestedTypes::nestedTypes).findFirst();\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/DeclarationImpl.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import org.openjdk.jextract.Declaration.Scoped.Kind;\n-import org.openjdk.jextract.Type;\n@@ -61,6 +59,7 @@\n-        Type type = tree.type();\n-        if (Utils.nestedDeclarationFor(type).map(Utils::isEnum).orElse(false)) {\n-            \/\/ no need to do anything for a typedef enum, as the IR always\n-            \/\/ lifts the enum tree before the typedef.\n-            Skip.with(tree);\n-        }\n+        Utils.forEachNested(tree, d -> {\n+            if (Utils.isEnum(d)) {\n+                \/\/ no need to do anything for a typedef enum, as the IR always\n+                \/\/ lifts the enum tree before the typedef.\n+                Skip.with(tree);\n+            }\n+        });\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/EnumConstantLifter.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-        Utils.nestedDeclarationFor(typedef.type()).ifPresent(s -> s.accept(this, typedef));\n+        Utils.forEachNested(typedef, d -> d.accept(this, typedef));\n@@ -206,1 +206,1 @@\n-        Utils.nestedDeclarationFor(type).ifPresent(s -> s.accept(this, variable));\n+        Utils.forEachNested(variable, s -> s.accept(this, variable));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/NameMangler.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,132 +0,0 @@\n-\/*\n- * Copyright (c) 2023 Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.jextract.impl;\n-\n-import org.openjdk.jextract.Declaration;\n-import org.openjdk.jextract.Declaration.Scoped;\n-import org.openjdk.jextract.Type;\n-import org.openjdk.jextract.Type.Array;\n-import org.openjdk.jextract.Type.Declared;\n-import org.openjdk.jextract.Type.Delegated;\n-import org.openjdk.jextract.Type.Function;\n-import org.openjdk.jextract.Type.Visitor;\n-import org.openjdk.jextract.impl.DeclarationImpl.NestedDecl;\n-\n-import java.util.Collections;\n-import java.util.IdentityHashMap;\n-import java.util.Set;\n-\n-\/*\n- * This visitor searches for scoped declarations that appear indirectly in the toplevel tree, as part of some\n- * declared type, and marks them with the NestedDecl attribute.\n- *\/\n-final class NestedDeclFinder implements Declaration.Visitor<Void, Void> {\n-\n-    private final Set<Declaration> seen = Collections.newSetFromMap(new IdentityHashMap<>());\n-    private final Set<Declaration> pending = Collections.newSetFromMap(new IdentityHashMap<>());\n-\n-    public Declaration.Scoped scan(Declaration.Scoped header) {\n-        \/\/ Initial scan. After this step:\n-        \/\/ (a) \"seen\" contains declarations directly nested in any of the visited members\n-        \/\/ (b) \"pending\" contains declarations that are indirectly (e.g. via a type) nested in any of the visited members\n-        header.members().forEach(fieldTree -> fieldTree.accept(this, null));\n-        while (!pending.isEmpty()) {\n-            \/\/ remove directly nested declaration from \"pending\" (as these are not true nested declarations)\n-            pending.removeAll(seen);\n-            \/\/ for each remaining nested declaration in the to do list:\n-            \/\/ (a) mark it with NestedDecl attribute\n-            \/\/ (b) propagate the visit (this results in further updates to \"seen\" and \"pending\", as described above)\n-            for (Declaration d : Set.copyOf(pending)) {\n-                NestedDecl.with(d);\n-                d.accept(this, null);\n-            }\n-        }\n-\n-        return header;\n-    }\n-\n-    @Override\n-    public Void visitFunction(Declaration.Function funcTree, Void ignored) {\n-        funcTree.type().accept(nestedDeclarationTypeVisitor, null);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitTypedef(Declaration.Typedef tree, Void ignored) {\n-        tree.type().accept(nestedDeclarationTypeVisitor, null);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitVariable(Declaration.Variable tree, Void ignored) {\n-        tree.type().accept(nestedDeclarationTypeVisitor, null);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitScoped(Scoped d, Void unused) {\n-        seen.add(d);\n-        \/\/ propagate\n-        d.members().forEach(m -> m.accept(this, null));\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitDeclaration(Declaration decl, Void ignored) {\n-        return null;\n-    }\n-\n-    Type.Visitor<Void, Void> nestedDeclarationTypeVisitor = new Visitor<Void, Void>() {\n-        @Override\n-        public Void visitArray(Array t, Void unused) {\n-            t.elementType().accept(this, null);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitDelegated(Delegated t, Void unused) {\n-            t.type().accept(this, null);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitDeclared(Declared t, Void unused) {\n-            pending.add(t.tree());\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitFunction(Function t, Void unused) {\n-            t.returnType().accept(this, null);\n-            t.argumentTypes().forEach(a -> a.accept(this, null));\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitType(Type t, Void unused) {\n-            return null;\n-        }\n-    };\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/NestedDeclFinder.java","additions":0,"deletions":132,"binary":false,"changes":132,"status":"deleted"},{"patch":"@@ -28,0 +28,1 @@\n+import org.openjdk.jextract.Declaration.Variable.Kind;\n@@ -143,2 +144,1 @@\n-        Optional<Declaration.Scoped> optScoped = Utils.nestedDeclarationFor(type);\n-        optScoped.ifPresent(s -> s.accept(this, null));\n+        Utils.forEachNested(tree, s -> s.accept(this, null));\n@@ -174,1 +174,1 @@\n-        Utils.nestedDeclarationFor(type).ifPresent(s -> s.accept(this, tree));\n+        Utils.forEachNested(tree, s -> s.accept(this, tree));\n@@ -185,1 +185,3 @@\n-        currentBuilder.addVar(tree, fiName);\n+        if (tree.kind() == Kind.GLOBAL || tree.kind() == Kind.FIELD) {\n+            currentBuilder.addVar(tree, fiName);\n+        }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n@@ -60,0 +58,1 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.NestedTypes;\n@@ -224,2 +223,2 @@\n-        return Declaration.function(CursorPosition.of(c), c.spelling(), (Type.Function)funcType,\n-                params.toArray(new Declaration.Variable[0]));\n+        return withNestedTypes(Declaration.function(CursorPosition.of(c), c.spelling(), (Type.Function)funcType,\n+                params.toArray(new Declaration.Variable[0])), c);\n@@ -414,1 +413,1 @@\n-        return Declaration.typedef(CursorPosition.of(c), c.spelling(), canonicalType);\n+        return withNestedTypes(Declaration.typedef(CursorPosition.of(c), c.spelling(), canonicalType), c);\n@@ -430,1 +429,23 @@\n-        return Declaration.var(kind, CursorPosition.of(c), c.spelling(), type);\n+        return withNestedTypes(Declaration.var(kind, CursorPosition.of(c), c.spelling(), type), c);\n+    }\n+\n+    \/*\n+     * Some declarations (global vars, struct\/union fields, function parameter\/return types might contain\n+     * inline nested struct\/union\/enum definitions. This method collects such definitions and\n+     * attaches them to the original declaration, using an attribute.\n+     *\/\n+    private <D extends Declaration> D withNestedTypes(D d, Cursor c) {\n+        List<Declaration> nestedDefinitions = new ArrayList<>();\n+        c.forEach(m -> {\n+            if (m.isDefinition()) {\n+                nestedDefinitions.add(createTree(m));\n+            }\n+        });\n+        List<Type.Declared> nestedTypes = nestedDefinitions.stream()\n+                .filter(m -> m instanceof Scoped)\n+                .map(s -> Type.declared((Scoped)s))\n+                .toList();\n+        if (!nestedTypes.isEmpty()) {\n+            NestedTypes.with(d, nestedTypes);\n+        }\n+        return d;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeMaker.java","additions":27,"deletions":6,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-        Utils.nestedDeclarationFor(type).ifPresent(s -> s.accept(this, varTree));\n+        Utils.forEachNested(varTree, s -> s.accept(this, varTree));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnsupportedFilter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import org.openjdk.jextract.impl.DeclarationImpl.NestedDecl;\n+import org.openjdk.jextract.impl.DeclarationImpl.NestedTypes;\n@@ -50,1 +50,1 @@\n-import java.util.Optional;\n+import java.util.function.Consumer;\n@@ -113,7 +113,3 @@\n-    static Optional<Declaration.Scoped> nestedDeclarationFor(Type type) {\n-        return switch (type) {\n-            case Type.Declared declared when NestedDecl.isPresent(declared.tree()) -> Optional.of(declared.tree());\n-            case Type.Array array -> nestedDeclarationFor(array.elementType());\n-            case Type.Delegated delegated -> nestedDeclarationFor(delegated.type());\n-            default -> Optional.empty();\n-        };\n+    static void forEachNested(Declaration declaration, Consumer<Declaration> nestedDeclAction) {\n+        NestedTypes.get(declaration).ifPresent(decls ->\n+            decls.stream().map(Type.Declared::tree).forEach(nestedDeclAction));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Utils.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.out.struct.*;\n+\n+import java.lang.foreign.GroupLayout;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.out.struct out_of_order_struct.h\n+ * @build TestOutOfOrderStruct\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestOutOfOrderStruct\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library \/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.out.struct out_of_order_struct.h\n+ * @build TestOutOfOrderStruct\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestOutOfOrderStruct\n+ *\/\n+public class TestOutOfOrderStruct {\n+\n+    @Test\n+    public void testFoo() {\n+        checkLayout(Foo.$LAYOUT());\n+    }\n+\n+    void checkLayout(GroupLayout layout) {\n+        assertEquals(layout.memberLayouts().get(0).withoutName(),\n+                Foo.Baz.$LAYOUT().withoutName());\n+    }\n+}\n","filename":"test\/jtreg\/generator\/outOfOrder\/TestOutOfOrderStruct.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"","filename":"test\/jtreg\/generator\/outOfOrder\/TestOutOfOrderTypedef.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jtreg\/generator\/outOfOrderTypedef\/TestOutOfOrderTypedef.java","status":"renamed"},{"patch":"@@ -24,1 +24,3 @@\n-typedef struct tagFoo Foo;\n+struct Dummy {\n+    struct tagFoo *Foo;\n+};\n","filename":"test\/jtreg\/generator\/outOfOrder\/out_of_order_struct.h","additions":3,"deletions":1,"binary":false,"changes":4,"previous_filename":"test\/jtreg\/generator\/outOfOrderTypedef\/out_of_order_typedef.h","status":"copied"},{"patch":"","filename":"test\/jtreg\/generator\/outOfOrder\/out_of_order_typedef.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jtreg\/generator\/outOfOrderTypedef\/out_of_order_typedef.h","status":"renamed"}]}