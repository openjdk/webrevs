{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -466,0 +465,15 @@\n+\n+    \/**\n+     * An attribute to attach nested struct\/union\/enum declarations to other declarations.\n+     *\/\n+    record NestedTypes(List<Type.Declared> nestedTypes) {\n+\n+        public static void with(Declaration declaration, List<Type.Declared> nestedTypes) {\n+            declaration.addAttribute(new NestedTypes(nestedTypes));\n+        }\n+\n+        public static Optional<List<Type.Declared>> get(Declaration declaration) {\n+            return declaration.getAttribute(NestedTypes.class)\n+                    .stream().map(NestedTypes::nestedTypes).findFirst();\n+        }\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/DeclarationImpl.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import org.openjdk.jextract.Declaration.Scoped.Kind;\n-import org.openjdk.jextract.Type;\n@@ -61,6 +59,7 @@\n-        Type type = tree.type();\n-        if (Utils.declarationFor(type).map(Utils::isEnum).orElse(false)) {\n-            \/\/ no need to do anything for a typedef enum, as the IR always\n-            \/\/ lifts the enum tree before the typedef.\n-            Skip.with(tree);\n-        }\n+        Utils.forEachNested(tree, d -> {\n+            if (Utils.isEnum(d)) {\n+                \/\/ no need to do anything for a typedef enum, as the IR always\n+                \/\/ lifts the enum tree before the typedef.\n+                Skip.with(tree);\n+            }\n+        });\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/EnumConstantLifter.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-        Utils.declarationFor(typedef.type()).ifPresent(s -> s.accept(this, typedef));\n+        Utils.forEachNested(typedef, d -> d.accept(this, typedef));\n@@ -206,1 +206,1 @@\n-        Utils.declarationFor(type).ifPresent(s -> s.accept(this, variable));\n+        Utils.forEachNested(variable, s -> s.accept(this, variable));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/NameMangler.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-    private final String pkgName;\n@@ -52,2 +51,1 @@\n-        return new OutputFactory(pkgName, toplevelBuilder).\n-            generate(decl);\n+        return new OutputFactory(toplevelBuilder).generate(decl);\n@@ -56,2 +54,1 @@\n-    private OutputFactory(String pkgName, ToplevelBuilder toplevelBuilder) {\n-        this.pkgName = pkgName;\n+    private OutputFactory(ToplevelBuilder toplevelBuilder) {\n@@ -146,26 +143,5 @@\n-        Optional<Declaration.Scoped> optScoped = Utils.declarationFor(type);\n-        if (optScoped.isPresent()) {\n-            Declaration.Scoped scoped = optScoped.get();\n-            if (!scoped.name().equals(tree.name())) {\n-                switch (scoped.kind()) {\n-                    case STRUCT, UNION -> {\n-                        if (scoped.name().isEmpty()) {\n-                            visitScoped(scoped, tree);\n-                        } else {\n-                            \/*\n-                             * If typedef is seen after the struct\/union definition, we can generate subclass\n-                             * right away. If not, we've to save it and revisit after all the declarations are\n-                             * seen. This is to support forward declaration of typedefs.\n-                             *\n-                             * typedef struct Foo Bar;\n-                             *\n-                             * struct Foo {\n-                             *     int x, y;\n-                             * };\n-                             *\/\n-                            toplevelBuilder.addTypedef(tree, JavaName.getFullNameOrThrow(scoped));\n-                        }\n-                    }\n-                    default -> visitScoped(scoped, tree);\n-                }\n-            }\n+        Utils.forEachNested(tree, s -> s.accept(this, null));\n+\n+        Declaration.Scoped structOrUnionDecl = Utils.structOrUnionDecl(type);\n+        if (structOrUnionDecl != null) {\n+            toplevelBuilder.addTypedef(tree, JavaName.getFullNameOrThrow(structOrUnionDecl));\n@@ -197,1 +173,1 @@\n-        Utils.declarationFor(type).ifPresent(s -> s.accept(this, tree));\n+        Utils.forEachNested(tree, s -> s.accept(this, tree));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":8,"deletions":32,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n@@ -60,0 +58,1 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.NestedTypes;\n@@ -224,2 +223,2 @@\n-        return Declaration.function(CursorPosition.of(c), c.spelling(), (Type.Function)funcType,\n-                params.toArray(new Declaration.Variable[0]));\n+        return withNestedTypes(Declaration.function(CursorPosition.of(c), c.spelling(), (Type.Function)funcType,\n+                params.toArray(new Declaration.Variable[0])), c);\n@@ -414,1 +413,1 @@\n-        return Declaration.typedef(CursorPosition.of(c), c.spelling(), canonicalType);\n+        return withNestedTypes(Declaration.typedef(CursorPosition.of(c), c.spelling(), canonicalType), c);\n@@ -430,1 +429,23 @@\n-        return Declaration.var(kind, CursorPosition.of(c), c.spelling(), type);\n+        return withNestedTypes(Declaration.var(kind, CursorPosition.of(c), c.spelling(), type), c);\n+    }\n+\n+    \/*\n+     * Some declarations (global vars, struct\/union fields, function parameter\/return types might contain\n+     * inline nested struct\/union\/enum definitions. This method collects such definitions and\n+     * attaches them to the original declaration, using an attribute.\n+     *\/\n+    private <D extends Declaration> D withNestedTypes(D d, Cursor c) {\n+        List<Declaration> nestedDefinitions = new ArrayList<>();\n+        c.forEach(m -> {\n+            if (m.isDefinition()) {\n+                nestedDefinitions.add(createTree(m));\n+            }\n+        });\n+        List<Type.Declared> nestedTypes = nestedDefinitions.stream()\n+                .filter(m -> m instanceof Scoped)\n+                .map(s -> Type.declared((Scoped)s))\n+                .toList();\n+        if (!nestedTypes.isEmpty()) {\n+            NestedTypes.with(d, nestedTypes);\n+        }\n+        return d;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeMaker.java","additions":27,"deletions":6,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-        Utils.declarationFor(type).ifPresent(s -> s.accept(this, varTree));\n+        Utils.forEachNested(varTree, s -> s.accept(this, varTree));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnsupportedFilter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.NestedTypes;\n@@ -49,1 +50,1 @@\n-import java.util.Optional;\n+import java.util.function.Consumer;\n@@ -112,8 +113,3 @@\n-    static Optional<Declaration.Scoped> declarationFor(Type type) {\n-        \/\/ @@@: we don't chase delegated types (typedefs or pointers). This could lead to declarations\n-        \/\/ not being visited, which could result in missing generated code.\n-        return switch (type) {\n-            case Type.Declared declared -> Optional.of(declared.tree());\n-            case Type.Array array -> declarationFor(array.elementType());\n-            default -> Optional.empty();\n-        };\n+    static void forEachNested(Declaration declaration, Consumer<Declaration> nestedDeclAction) {\n+        NestedTypes.get(declaration).ifPresent(decls ->\n+            decls.stream().map(Type.Declared::tree).forEach(nestedDeclAction));\n@@ -152,0 +148,4 @@\n+        return structOrUnionDecl(type) != null;\n+    }\n+\n+    static Declaration.Scoped structOrUnionDecl(Type type) {\n@@ -153,1 +153,1 @@\n-            case Type.Declared declared -> isStructOrUnion(declared.tree());\n+            case Type.Declared declared when isStructOrUnion(declared.tree()) -> declared.tree();\n@@ -155,2 +155,2 @@\n-                isStructOrUnion(delegated.type());\n-            default -> false;\n+                    structOrUnionDecl(delegated.type());\n+            default -> null;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Utils.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.nested.anon.*;\n+\n+import java.lang.foreign.GroupLayout;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.nested.anon nestedInsideAnon.h\n+ * @build TestNestedInsideAnon\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNestedInsideAnon\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library \/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.nested.anon nestedInsideAnon.h\n+ * @build TestNestedInsideAnon\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNestedInsideAnon\n+ *\/\n+public class TestNestedInsideAnon {\n+\n+    @Test\n+    public void testAnonField() {\n+        checkLayout(P.$LAYOUT());\n+    }\n+\n+    void checkLayout(GroupLayout layout) {\n+        assertEquals(((GroupLayout)layout.memberLayouts().get(0)).memberLayouts().get(0).withoutName(),\n+                P.Flags.$LAYOUT().withoutName());\n+    }\n+}\n","filename":"test\/jtreg\/generator\/nestedInsideAnon\/TestNestedInsideAnon.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -24,11 +24,7 @@\n-#define FIELDS \\\n-int x; \\\n-int y;\n-\n-struct PointA {\n-   FIELDS\n-};\n-\n-struct PointB {\n-   FIELDS\n-};\n+typedef struct {\n+    struct {\n+        struct {\n+            char y;\n+        } Flags;\n+    };\n+} P;\n","filename":"test\/jtreg\/generator\/nestedInsideAnon\/nestedInsideAnon.h","additions":7,"deletions":11,"binary":false,"changes":18,"previous_filename":"test\/jtreg\/generator\/dedup\/macro_fields.h","status":"copied"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.out.struct.*;\n+\n+import java.lang.foreign.GroupLayout;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.out.struct out_of_order_struct.h\n+ * @build TestOutOfOrderStruct\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestOutOfOrderStruct\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library \/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.out.struct out_of_order_struct.h\n+ * @build TestOutOfOrderStruct\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestOutOfOrderStruct\n+ *\/\n+public class TestOutOfOrderStruct {\n+\n+    @Test\n+    public void testFoo() {\n+        checkLayout(Foo.$LAYOUT());\n+    }\n+\n+    void checkLayout(GroupLayout layout) {\n+        assertEquals(layout.memberLayouts().get(0).withoutName(),\n+                Foo.Baz.$LAYOUT().withoutName());\n+    }\n+}\n","filename":"test\/jtreg\/generator\/outOfOrder\/TestOutOfOrderStruct.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.out.typedef.*;\n+\n+import java.lang.foreign.GroupLayout;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.out.typedef out_of_order_typedef.h\n+ * @build TestOutOfOrderTypedef\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestOutOfOrderTypedef\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library \/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.out.typedef out_of_order_typedef.h\n+ * @build TestOutOfOrderTypedef\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestOutOfOrderTypedef\n+ *\/\n+public class TestOutOfOrderTypedef {\n+\n+    @Test\n+    public void testFoo() {\n+        checkLayout(Foo.$LAYOUT());\n+    }\n+\n+    void checkLayout(GroupLayout layout) {\n+        assertEquals(layout.memberLayouts().get(0).withoutName(),\n+                Foo.Baz.$LAYOUT().withoutName());\n+    }\n+}\n","filename":"test\/jtreg\/generator\/outOfOrder\/TestOutOfOrderTypedef.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Dummy {\n+    struct tagFoo *Foo;\n+};\n+\n+struct Bar {\n+    int x;\n+};\n+\n+typedef struct tagFoo {\n+    struct Baz { int y; } bar;\n+} Foo;\n","filename":"test\/jtreg\/generator\/outOfOrder\/out_of_order_struct.h","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -24,3 +24,1 @@\n-#define FIELDS \\\n-int x; \\\n-int y;\n+typedef struct tagFoo Foo;\n@@ -28,2 +26,2 @@\n-struct PointA {\n-   FIELDS\n+struct Bar {\n+    int x;\n@@ -32,3 +30,3 @@\n-struct PointB {\n-   FIELDS\n-};\n+typedef struct tagFoo {\n+    struct Baz { int y; } bar;\n+} Foo;\n","filename":"test\/jtreg\/generator\/outOfOrder\/out_of_order_typedef.h","additions":6,"deletions":8,"binary":false,"changes":14,"previous_filename":"test\/jtreg\/generator\/dedup\/macro_fields.h","status":"copied"}]}