{"files":[{"patch":"@@ -8,1 +8,1 @@\n-by loading a native library (e.g. a `.so`\/`.dll`\/`.dylib` file), which is essentially an\n+by loading a native library (e.g., a `.so`\/`.dll`\/`.dylib` file), which is essentially an\n@@ -11,1 +11,1 @@\n-`Linker::downcallHandle` method. Additionally, a client may need to create function pointer for\n+`Linker::downcallHandle` method. Additionally, a client may need to create function pointers for\n@@ -18,1 +18,1 @@\n-The samples under [`samples`](samples) direcotry are also a good source of examples.\n+The samples under the [`samples`](samples) direcotry are also a good source of examples.\n@@ -30,1 +30,1 @@\n-directory corresponding to,the root package. A typical way to run jextract would be like\n+directory corresponding to the root package. A typical way to run jextract would be like\n@@ -48,1 +48,1 @@\n-- `--output src` specifies the root directory for the output. This matches to root package\n+- `--output src` specifies the root directory for the output. This matches the root package\n@@ -51,1 +51,1 @@\n-  classes and interfaces will belong. (note that jextract will automatically create the\n+  classes and interfaces will belong. (Note that jextract will automatically create the\n@@ -61,0 +61,12 @@\n+Most of the code that jextract generates will be available through a single class. By default,\n+the name of that class is derived from the name of the main header file that is passed to\n+jextract. For example, if the header file is named `mylib.h`, then the derived class name\n+will be `mylib_h`. The class name can be set explicitly using the `--header-class-name`\n+option as well.\n+\n+Besides the main header class that is generated, jextract also generates several\n+separate files for certain declarations in the C header file. Namely, structs, unions,\n+function pointer types, and typedefs of struct or union types result in additional files\n+being generated. (All of these are discussed in more detail in the\n+[Using The Code Generated By Jextract section](#using-the-code-generated-by-jextract)).\n+\n@@ -63,3 +75,32 @@\n-Jextract only needs to be run again when the native library, or jextract itself are updated. (This is also\n-the workflow that jextract itself follows: jextract depends on the [libclang](https:\/\/clang.llvm.org\/docs\/LibClang.html)\n-native library in order to parse C sources).\n+Jextract only needs to be run again when the native library, or jextract itself are updated.\n+(This is also the workflow that jextract itself follows: jextract depends on the\n+[libclang](https:\/\/clang.llvm.org\/docs\/LibClang.html) native library in order to parse C sources).\n+\n+### Preprocessor Definitions\n+\n+C header files are processed by a pre-processor by a compiler before they are inspected\n+further. It is possible for a header file to contain so-called 'compiler switches', which\n+can be used to conditionally generate code based on the value of a macro, for instance:\n+\n+```c\n+#ifdef MY_MACRO\n+int x = 42;\n+#else\n+int x = 0;\n+#endif\n+```\n+\n+The value of these macros also affects the behavior of jextract. Therefore, jextract\n+supports setting macro values on the command line using the `-D` or\n+`--define-macro <macro>=<value>` option. For instance, we can use `-D MY_MACRO` to set\n+the value of `MY_MACRO` in the above snippet to `1`, and trigger the first _branch_ of the\n+compiler switch, thereby defining `int x = 42`.\n+\n+Please note that other header files included by jextract may also define macro values using\n+the `#define` pre-processor directive. It is therefore important to notice the order in\n+which header files are processed by a compiler, as feeding header files to jextract in the\n+wrong order may result in weird errors due to missing macro definitions. A well-known\n+example of this are Windows SDK headers. Almost always, the main `Windows.h` header file\n+should be passed to jextract for things to work correctly. Please consult the\n+documentation of the library that you're trying to use to find out which header file should\n+be included\/passed to jextract.\n@@ -72,1 +113,1 @@\n-This means for instance that on Linux, when specifying `--library mylib` the bindings will\n+This means, for instance, that on Linux, when specifying `--library mylib`, the bindings will\n@@ -80,1 +121,1 @@\n-When using the HotSpot JVM, the `-Xlog:library` option can als be use to log where the JVM\n+When using the HotSpot JVM, the `-Xlog:library` option can also be used to log where the JVM\n@@ -83,3 +124,3 @@\n-The `<libspec>` argument of the `--library` option can either be a library name, such as,\n-`mylib` which will, be mapped to a platform specific name using [`System::mapLibraryName`](https:\/\/docs.oracle.com\/en\/java\/javase\/22\/docs\/api\/java.base\/java\/lang\/System.html#mapLibraryName(java.lang.String)), or a path to a library file (either relative or\n-absolute) if `<libspec>` is prefixed with the `:` character, such as `mylib.dll`.\n+The `<libspec>` argument of the `--library` option can either be a library name, or a path\n+to a library file (either relative or absolute) if `<libspec>` is prefixed with the `:`\n+character, such as `:mylib.dll`.\n@@ -106,11 +147,0 @@\n-Most of the code that jextract generates will be available through a single class. By default\n-the name of that class is derived from the name of the main header file that is passed to\n-jextract. For example, if the header file is named `mylib.h`, then the derived class name\n-will be `mylib_h`. The class name can be set explicitly using the `--header-class-name`\n-option as well.\n-\n-Besides the main header class that is generated, jextract also generates several\n-separate files for certain declarations in the C header file. Namely, structs, unions,\n-function pointer types, and typedefs of struct or union types result in additional files\n-being generated. We will look at those in more detail in this section.\n-\n@@ -126,1 +156,1 @@\n-Where `org.mypackage` is the package into which jextract put the generates source files\n+Where `org.mypackage` is the package into which jextract puts the generates source files\n@@ -134,2 +164,2 @@\n-The latter import statement imports all the other classes the jextract generates, which\n-includes: classes representing structs or unions, function types, and struct or union\n+The latter import statement imports all the other classes generated by jextract, which\n+include: classes representing structs or unions, function types, and struct or union\n@@ -164,4 +194,4 @@\n-`T*`). Note that these layouts are platform dependent, depending on the platform that\n-jextract runs on. For instance, since these constants were generated on Windows, the\n-`long` type has the same layout as the Java `int` type, indicating a 32-bit value, and the\n-`long double` type has the same layout as the Java `double` type. (note that the latter is\n+`T*`). Note that the layouts that jextract generates depend on the platform that jextract\n+runs on. For instance, since these constants were generated on Windows, the `long` type\n+has the same layout as the Java `int` type, indicating a 32-bit value, and the\n+`long double` type has the same layout as the Java `double` type. (Note that the latter is\n@@ -181,1 +211,1 @@\n-Jextract will generate the following set of methods for this function, in the main header\n+Jextract will generate the following set of methods for this function in the main header\n@@ -196,6 +226,9 @@\n-additional meta-data for the method: the function's address (2), the function descriptor\n-(3), and the method handle returned by the FFM linker (4), which is used to implement the\n-static wrapper method (1).\n-\n-The parameter types and return type of this method depend on the carrier types of the\n-layouts that make up the function descriptor of the function, which is itself derived\n+additional meta-data for the method: the function's address, represented as a\n+[`MemorySegment`](https:\/\/docs.oracle.com\/en\/java\/javase\/22\/docs\/api\/java.base\/java\/lang\/foreign\/MemorySegment.html) (2),\n+the [function descriptor](https:\/\/docs.oracle.com\/en\/java\/javase\/22\/docs\/api\/java.base\/java\/lang\/foreign\/FunctionDescriptor.html) (3),\n+and the [method handle](https:\/\/docs.oracle.com\/en\/java\/javase\/22\/docs\/api\/java.base\/java\/lang\/invoke\/MethodHandle.html)\n+returned by the FFM linker (4), which is used to implement the static wrapper method (1).\n+\n+The parameter types and return type of this method depend on the\n+[carrier types](https:\/\/docs.oracle.com\/en\/java\/javase\/22\/docs\/api\/java.base\/java\/lang\/foreign\/FunctionDescriptor.html#toMethodType())\n+of the layouts that make up the function descriptor of the function, which is itself derived\n@@ -269,1 +302,1 @@\n-the function-like macro in a proper exported C function, that can then be linked against\n+the function-like macro in a proper exported C function that can then be linked against\n@@ -272,0 +305,4 @@\n+Note that for macros, jextract only generates an accessor when it sees a macro definition,\n+like the one in the example, in the header files it parses. When a macro is only defined\n+using `-D` on the command line, not accessor will be generated.\n+\n@@ -358,1 +395,1 @@\n-        MemorySegment element = Point.asSlice(point, i);\n+        MemorySegment element = Point.asSlice(points, i);\n@@ -369,1 +406,1 @@\n-can be used to access individual elements of the `points` array, when given\n+can be used to access individual elements of the `points` array when given\n@@ -438,1 +475,1 @@\n-For instance, let's say we have a function that accepts an instance of the `callback_t`\n+For instance, let's say we have a C function that accepts an instance of the `callback_t`\n@@ -468,1 +505,1 @@\n-Additionally, we can using the `callback_t::invoke` method invoke an instance of\n+Additionally, we can use the `callback_t::invoke` method invoke an instance of\n@@ -485,2 +522,2 @@\n-pointing to the native `mult` function. We can call `callback_t` instance that `get_callback()`\n-return in Java using the `invoke` method in the `callback_t` class that jextract generates\n+pointing to the native `mult` function. We can call the `callback_t` instance that `get_callback()`\n+returns in Java using the `invoke` method in the `callback_t` class that jextract generates\n@@ -534,1 +571,1 @@\n-Jextract doesn't generates a regular method, but a _class_, which represents the invoker:\n+Jextract doesn't generate a regular method, but a _class_, which represents the invoker:\n@@ -576,1 +613,1 @@\n-As mentioned before: typedefs are either translated as a `static final` memory layout fields\n+As mentioned before, typedefs are either translated as a `static final` memory layout fields\n@@ -603,1 +640,1 @@\n-The `MyPoint` `typedef` on the other hand is a typedef for a struct, so it is translated\n+The `MyPoint` `typedef`, on the other hand, is a typedef for a struct, so it is translated\n@@ -617,2 +654,1 @@\n-C allows variable declarations to have an inline anonymous type. Jextract handles in\n-particular cases where a struct's field has an inline type specially. For instance, if we\n+C allows variable declarations to have an inline anonymous type. For instance, if we\n@@ -634,1 +670,1 @@\n-fields, _inside of_ the class it generates for the `Foo` struct itself:\n+fields _inside of_ the class it generates for the `Foo` struct itself:\n@@ -692,1 +728,1 @@\n-file (using the `@argfile` syntax also available in other JDK tools) to e.g. generate\n+file (using the `@argfile` syntax also available in other JDK tools) to e.g., generate\n@@ -713,1 +749,1 @@\n-desired, for instance using other command line tools such as `grep` or `Select-String`,\n+desired, for instance, using other command line tools such as `grep` or `Select-String`,\n@@ -756,3 +792,4 @@\n-To enable the tracing support, just pass the `-Djextract.trace.downcalls=true` flag to the\n-launcher used to start the application. Below we show an excerpt of the output when\n-running the [OpenGL example](samples\/opengl) with tracing support enabled:\n+To enable the tracing support, just pass the `-Djextract.trace.downcalls=true` flag as a VM\n+argument to the launcher used to start the application that uses the generated bindings.\n+Below we show an excerpt of the output when running the [OpenGL example](samples\/opengl)\n+with tracing support enabled:\n@@ -785,29 +822,0 @@\n-## Preprocessor Definitions\n-\n-C header files are processed by a pre-processor by a compiler before they are inspected\n-further. It is possible for a header file to contain so-called 'compiler switches', which\n-can be used to conditionally generate code based on the value of a macro, for instance:\n-\n-```c\n-#ifdef MY_MACRO\n-int x = 42;\n-#else\n-int x = 0;\n-#endif\n-```\n-\n-The value of these macros also affects the behavior of jextract. Therefore, jextract\n-supports setting macro values on the command line using the `-D` or\n-`--define-macro <macro>=<value>` option. For instance, we can use `-D MY_MACRO` to set\n-the value of `MY_MACRO` in the above snippet to `1`, and trigger the first _branch_ of the\n-compiler switch, thereby defining `int x = 42`.\n-\n-Please note that other header files included by jextract may also define macro values using\n-the `#define` pre-processor directive. It is therefore important to notice the order in\n-which header files are processed by a compiler, as feeding header files to jextract in the\n-wrong order may result in weird errors due to missing macro definitions. A well-known\n-example of this are Windows SDK headers. Almost always, the main `Windows.h` header file\n-should be passed to jextract for things to work correctly. Please consult the\n-documentation of the library that you're trying to use to find out which header file should\n-be included\/passed to jextract.\n-\n@@ -838,0 +846,24 @@\n+## Unsupported Features\n+\n+There are several elements for which jextract can not generate bindings:\n+\n+- Function-like macros (as mentioned in the [section on constants](#constants-macros--enums))\n+- Bit fields. You will see a warning about bit fields being skipped, such as:\n+  \n+  ```txt\n+  WARNING: Skipping Foo.x (bitfields are not supported)\n+  ```\n+\n+- Opaque types. When a struct or union type is declared but not defined, like:\n+\n+  ```c\n+  struct Foo;\n+  ```\n+\n+  Jextract is not able to generate the regular `Foo` class. You will see a warning about\n+  these structs being skipped, such as:\n+\n+  ```txt\n+  WARNING: Skipping Foo (type Declared(Foo) is not supported)\n+  ```\n+\n","filename":"doc\/GUIDE.md","additions":118,"deletions":86,"binary":false,"changes":204,"status":"modified"}]}