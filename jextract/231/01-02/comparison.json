{"files":[{"patch":"@@ -4,2 +4,2 @@\n-called 'bindings', which  use the Foreign Function and Memory API (FFM API) under the hood,\n-that can be used by a client to access the native library.\n+called _bindings_, which use the [Foreign Function and Memory API](https:\/\/openjdk.org\/jeps\/442)\n+(FFM API) under the hood, that can be used by a client to access the native library.\n@@ -10,1 +10,1 @@\n-they want to call using a `SymbolLookup`, and finally 'link' the functions by using the\n+they want to call using a `SymbolLookup`, and finally _link_ the functions by using the\n@@ -14,2 +14,2 @@\n-Jextract aims to automate many of these steps, so that a client can instead immediately start\n-using a native library they are interested in.\n+The jextract tool aims to automate many of these steps, so that a client can instead\n+immediately start using the native libraries they are interested in.\n@@ -26,1 +26,1 @@\n-that define the interface of the library, with one 'main' header file. Let's say we have a\n+that define the interface of the library, with one _main_ header file. Let's say we have a\n@@ -28,3 +28,4 @@\n-with all the header files. And let's say that we have a shell open in the root directory\n-of the Java project we're working on, which has an `src` source directory corresponding to\n-the root package. A typical way to run jextract would be like this:\n+where the header files of that library are stored. And let's say that we have a shell open\n+in the root directory of the Java project we're working on, which has an `src` source\n+directory corresponding to,the root package. A typical way to run jextract would be like\n+this:\n@@ -63,1 +64,2 @@\n-the workflow that jextract itself uses for talking to the libclang library).\n+the workflow that jextract itself follows: jextract depends on the [libclang](https:\/\/clang.llvm.org\/docs\/LibClang.html)\n+native library in order to parse C sources).\n@@ -136,1 +138,2 @@\n-will generate a set of memory layouts for the common builtin C types:\n+will generate a set of memory layouts for the common builtin C types in the main header\n+class it generates:\n@@ -139,0 +142,2 @@\n+\/\/ mylib_h.java\n+\n@@ -147,2 +152,2 @@\n-        .withTargetLayout(\n-\t\tMemoryLayout.sequenceLayout(Long.MAX_VALUE, ValueLayout.JAVA_BYTE));\n+        .withTargetLayout(\n+                MemoryLayout.sequenceLayout(Long.MAX_VALUE, ValueLayout.JAVA_BYTE));\n@@ -253,2 +258,3 @@\n-strategy mimics C's behavior of enum constants being accessible as a top-level declaration\n-as well.\n+strategy mimics C's behavior of enum constants being accessible as a top-level declaration,\n+and also makes it easier to do bitwise operations like `A | B`, which are not possible\n+with Java `enum`s.\n@@ -258,1 +264,4 @@\n-not supported by jextract.\n+not supported by jextract. For function-like macros, alternatives include re-writing the\n+code inside the macro in Java, using the FFM API, or writing a small C library which wraps\n+the function-like macro in a proper exported C function, that can then be linked against\n+through the FFM API.\n@@ -309,8 +318,11 @@\n-There's a getter and setter for each field of the struct (1), which takes a pointer to a struct\n-(a `MemorySegment`) to get\/set the field from\/to. Besides that, there are also meta-data\n-accessors for each field (`xxx$layout()` and `xxx$offset()`) (2). Then, there are\n-meta-data accessors `sizeof` and `layout`, which can be used to get the size and layout\n-of the struct (3), `allocate*` methods for allocating single structs or arrays of structs\n-(4), an `asSlice` method which can be used to access elements of an array of structs (5),\n-and finally there are two `reinterpret` methods which can be used to sanitize raw addresses\n-returned by native code, or read from native memory (6).\n+There are:\n+\n+1. a getter and setter for each field of the struct, which takes a pointer to a struct\n+  (a `MemorySegment`) to get\/set the field from\/to.\n+2. meta-data accessors for each field (`xxx$layout()` and `xxx$offset()`).\n+3. meta-data accessors `sizeof` and `layout`, which can be used to get the size and layout\n+  of the struct.\n+4. `allocate*` methods for allocating a single struct or arrays of structs.\n+5. an `asSlice` method which can be used to access elements of an array of structs.\n+6. two `reinterpret` methods which can be used to sanitize raw addresses\n+  returned by native code, or read from native memory.\n@@ -352,1 +364,1 @@\n-In the above example, the `asSlice` method is used to 'slice' out a section of\n+In the above example, the `asSlice` method is used to _slice_ out a section of\n@@ -357,1 +369,1 @@\n-Finally, the `reinterpret` method can be used to 'sanitize' a pointer that is\n+Finally, the `reinterpret` method can be used to _sanitize_ a pointer that is\n@@ -392,3 +404,2 @@\n-If jextract finds a function pointer type in the header files it parses, it will generate\n-a separate class for each of these. For instance, for a function pointer `typedef` like\n-this:\n+Jextract will generate a separate class for each function pointer type found in the header\n+files it parses. For instance, for a function pointer `typedef` like this:\n@@ -449,3 +460,4 @@\n-returned by the `java.lang.foreign.Linker::upcallStub` method. The `arena` argument denotes\n-the lifetime of the upcall stub, meaning that the upcall stub will be freed when the arena\n-is closed (after which the callback instance should no longer be called).\n+returned by the [`java.lang.foreign.Linker::upcallStub`](https:\/\/docs.oracle.com\/en\/java\/javase\/22\/docs\/api\/java.base\/java\/lang\/foreign\/Linker.html#upcallStub(java.lang.invoke.MethodHandle,java.lang.foreign.FunctionDescriptor,java.lang.foreign.Arena,java.lang.foreign.Linker.Option...))\n+method. The `arena` argument denotes the lifetime of the upcall stub, meaning that the\n+upcall stub will be freed when the arena is closed (after which the callback instance\n+can no longer be called).\n@@ -488,1 +500,11 @@\n-(such as struct fields or global variables).\n+(such as struct fields or global variables):\n+\n+```c\n+void func(void (*cb)(void)); \/\/ function parameter\n+void (*func(void))(void); \/\/ function return type\n+typedef void (*cb)(void); \/\/ typedef\n+void (*cb)(void); \/\/ global variable\n+struct Foo {\n+  void (*cb)(void); \/\/ struct field\n+};\n+```\n@@ -499,2 +521,2 @@\n-To make calling variadic functions easier, jextract introduces the concept of an 'invoker'.\n-An invoker represents a particular 'instantiation' of a variadic function for a particular\n+To make calling variadic functions easier, jextract introduces the concept of an _invoker_.\n+An invoker represents a particular _instantiation_ of a variadic function for a particular\n@@ -656,1 +678,1 @@\n-'see' the update to the `bar` field of the `foo` instance on the line before.\n+_see_ the update to the `bar` field of the `foo` instance on the line before.\n@@ -660,1 +682,1 @@\n-Some libraries are incredibly large (such as a platform SDK), and we might not be\n+Some libraries are incredibly large (such as `Windows.h`), and we might not be\n@@ -665,1 +687,1 @@\n-To allow for symbol filtering, `jextract` can generate a _dump_ of all the symbols\n+To allow for symbol filtering, jextract can generate a _dump_ of all the symbols\n@@ -668,2 +690,2 @@\n-bindings only for a _subset_ of symbols seen by `jextract`. For instance, if we run\n-`jextract` with as follows:\n+bindings only for a _subset_ of symbols seen by jextract. For instance, if we run\n+jextract with as follows:\n@@ -708,1 +730,1 @@\n-Here, we could run `jextract` and filter out `A`, like so:\n+Here, we could run jextract and filter out `A`, like so:\n@@ -717,1 +739,1 @@\n-In such cases, `jextract` will report the missing dependency and terminate without\n+In such cases, jextract will report the missing dependency and terminate without\n@@ -727,1 +749,1 @@\n-diagnosing application bugs and\/or crashes. The code generated by the `jextract` tool\n+diagnosing application bugs and\/or crashes. The code generated by the jextract tool\n@@ -777,1 +799,1 @@\n-the value of `MY_MACRO` in the above snippet to `1`, and trigger the first 'branch' of the\n+the value of `MY_MACRO` in the above snippet to `1`, and trigger the first _branch_ of the\n@@ -781,3 +803,3 @@\n-the `#define` pre-processor directive. Therefore it is often important in which order\n-header files are processed by a compiler, and as such, the feeding the wrong header file\n-to jextract may result in weird errors due to missing macro definitions. A well-known\n+the `#define` pre-processor directive. It is therefore important to notice the order in\n+which header files are processed by a compiler, as feeding header files to jextract in the\n+wrong order may result in weird errors due to missing macro definitions. A well-known\n@@ -800,1 +822,1 @@\n-| `--use-system-load-library`                                  | libraries specified using `-l` are loaded in the loader symbol lookup (using either `System::loadLibrary`, or `System::load`). Useful if the libraries must be loaded from one of the paths in `java.library.path`.| \n+| `--use-system-load-library`                                  | libraries specified using `-l` are loaded in the loader symbol lookup (using either `System::loadLibrary`, or `System::load`). Useful if the libraries must be loaded from one of the paths in `java.library.path`.|\n@@ -804,1 +826,1 @@\n-| `--version`                                                  | print version information and exit      \n+| `--version`                                                  | print version information and exit |\n@@ -808,1 +830,2 @@\n-Users can also specify additional clang compiler options, by creating a file named\n+Jextract uses an embedded clang compiler (through libclang) to parse header files. Users\n+can also specify additional clang compiler options, by creating a file named\n","filename":"doc\/GUIDE.md","additions":73,"deletions":50,"binary":false,"changes":123,"status":"modified"}]}