{"files":[{"patch":"@@ -5,0 +5,2 @@\n+:bulb: For instruction on how to use the jextract tool, please refer to the guide [here](doc\/GUIDE.md)\n+\n@@ -13,171 +15,0 @@\n-### Using jextract\n-\n-To understand how `jextract` works, consider the following C header file:\n-\n-```c\n-\/\/point.h\n-struct Point2d {\n-    double x;\n-    double y;\n-};\n-\n-double distance(struct Point2d);\n-```\n-\n-We can run `jextract`, as follows:\n-\n-```\n-jextract -l distance -t org.jextract point.h\n-```\n-\n-We can then use the generated code as follows:\n-\n-```java\n-import java.lang.foreign.*;\n-import static org.jextract.point_h.*;\n-import org.jextract.Point2d;\n-\n-class TestPoint {\n-    public static void main(String[] args) {\n-        try (Arena arena = Arena.ofConfined()) {\n-           MemorySegment point = Point2d.allocate(arena);\n-           Point2d.x(point, 3d);\n-           Point2d.y(point, 4d);\n-           System.out.println(\"Distance to origin = \" + distance(point));\n-        }\n-    }\n-}\n-```\n-\n-(Note that, to run the above example, a native library called  `(lib)distance.(so|dylib|dll)` that exports the `distance` function needs to be available on the OS's standard library search path. `LD_LIBRARY_PATH` on Linux, `DYLD_LIBRARY_PATH` on Mac, or `PATH` on Windows)\n-\n-As we can see, the `jextract` tool generated a `Point2d` class, modelling the C struct, and a `point_h` class which contains static native function wrappers, such as `distance`. If we look inside the generated code for `distance` we can find the following (for clarity, some details have been omitted):\n-\n-```java\n-static final FunctionDescriptor DESC = FunctionDescriptor.of(\n-        foo_h.C_DOUBLE,\n-        Point2d.$LAYOUT()\n-);\n-\n-static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n-        foo_h.findOrThrow(\"distance\"),\n-        DESC);\n-\n-public static double distance(MemorySegment x0) {\n-    return (double) mh$.invokeExact(x0);\n-}\n-```\n-\n-In other words, the `jextract` tool has generated all the required supporting code (`MemoryLayout`, `MethodHandle` and `FunctionDescriptor`) that is needed to call the underlying `distance` native function. For more examples on how to use the `jextract` tool with real-world libraries, please refer to the [samples folder](samples) (building\/running particular sample may require specific third-party software installation).\n-\n-#### Command line options\n-\n-The `jextract` tool includes several customization options. Users can select in which package the generated code should be emitted, and what the name of the main extracted class should be. If no package is specified, classes are generated in the unnamed package. If no name is specified for the main header class, then the header class name is\n-derived from the header file name. For example, if jextract is run on foo.h, then foo_h will be the name of the main header class.\n-\n-A complete list of all the supported options is given below:\n-\n-| Option                                                       | Meaning                                                      |\n-| :----------------------------------------------------------- | ------------------------------------------------------------ |\n-| `-D --define-macro <macro>=<value>`                          | define `<macro>` to `<value>` (or 1 if `<value>` omitted)          |\n-| `--header-class-name <name>`                                 | name of the generated header class. If this option is not specified, then header class name is derived from the header file name. For example, class \"foo_h\" for header \"foo.h\". |\n-| `-t, --target-package <package>`                             | target package name for the generated classes. If this option is not specified, then unnamed package is used.  |\n-| `-I, --include-dir <dir>`                                    | append directory to the include search paths. Include search paths are searched in order. For example, if `-I foo -I bar` is specified, header files will be searched in \"foo\" first, then (if nothing is found) in \"bar\".|\n-| `-l, --library <name \\| path>`                               | specify a shared library that should be loaded by the generated header class. If <libspec> starts with `:`, then what follows is interpreted as a library path. Otherwise, `<libspec>` denotes a library name. Examples: <br>`-l GL`<br>`-l :libGL.so.1`<br>`-l :\/usr\/lib\/libGL.so.1`|\n-| `--use-system-load-library`                                  | libraries specified using `-l` are loaded in the loader symbol lookup (using either `System::loadLibrary`, or `System::load`). Useful if the libraries must be loaded from one of the paths in `java.library.path`.| \n-| `--output <path>`                                            | specify where to place generated files                       |\n-| `--dump-includes <String>`                                   | dump included symbols into specified file (see below)        |\n-| `--include-[function,constant,struct,union,typedef,var]<String>` | Include a symbol of the given name and kind in the generated bindings (see below). When one of these options is specified, any symbol that is not matched by any specified filters is omitted from the generated bindings. |\n-| `--version`                                                  | print version information and exit                           |\n-\n-\n-#### Additional clang options\n-\n-Users can specify additional clang compiler options, by creating a file named\n-`compile_flags.txt` in the current folder, as described [here](https:\/\/clang.llvm.org\/docs\/JSONCompilationDatabase.html#alternatives).\n-\n-#### Filtering symbols\n-\n-To allow for symbol filtering, `jextract` can generate a *dump* of all the symbols encountered in an header file; this dump can be manipulated, and then used as an argument file (using the `@argfile` syntax also available in other JDK tools) to e.g. generate bindings only for a *subset* of symbols seen by `jextract`. For instance, if we run `jextract` with as follows:\n-\n-```\n-jextract --dump-includes includes.txt point.h\n-```\n-\n-We obtain the following file (`includes.txt`):\n-\n-```\n-#### Extracted from: point.h\n-\n---include-struct Point2d    # header: point.h\n---include-function distance # header: point.h\n-```\n-\n-This file can be passed back to `jextract`, as follows:\n-\n-```\n-jextract -t org.jextract @includes.txt point.h\n-```\n-\n-It is easy to see how this mechanism allows developers to look into the set of symbols seen by `jextract` while parsing, and then process the generated include file, so as to prevent code generation for otherwise unused symbols.\n-\n-Users should exercise caution when filtering symbols, as it is relatively easy to filter out a declaration that is depended on by one or more declarations:\n-\n-```c\n-\/\/ test.h\n-struct A {\n-   int x;\n-}\n-struct A aVar;\n-```\n-\n-Here, we could run `jextract` and filter out `A`, like so:\n-\n-```\n-jextract --include-var aVar test.h\n-```\n-\n-However, doing so would lead to broken generated code, as the layout of the global variable `aVar` depends on the layout of the excluded struct `A`.\n-\n-In such cases, `jextract` will report the missing dependency and terminate without generating any bindings:\n-\n-```\n-ERROR: aVar depends on A which has been excluded\n-```\n-\n-#### Tracing support\n-\n-It is sometimes useful to inspect the parameters passed to a native call, especially when diagnosing application\n-bugs and\/or crashes. The code generated by the `jextract` tool supports *tracing* of native calls, that is, parameters\n-passed to native calls can be printed on the standard output.\n-\n-To enable the tracing support, just pass the `-Djextract.trace.downcalls=true` flag to the launcher used to start the application.\n-Below we show an excerpt of the output when running the [OpenGL example](samples\/opengl) with tracing support enabled:\n-\n-```\n-glutInit(MemorySegment{ address: 0x7fa6b03d6400, byteSize: 4 }, MemorySegment{ address: 0x7fa6b03d6400, byteSize: 4 })\n-glutInitDisplayMode(18)\n-glutInitWindowSize(900, 900)\n-glutCreateWindow(MemorySegment{ address: 0x7fa6b03f8e70, byteSize: 14 })\n-glClearColor(0.0, 0.0, 0.0, 0.0)\n-glShadeModel(7425)\n-glLightfv(16384, 4611, MemorySegment{ address: 0x7fa6b03de8d0, byteSize: 16 })\n-glLightfv(16384, 4608, MemorySegment{ address: 0x7fa6b0634840, byteSize: 16 })\n-glLightfv(16384, 4609, MemorySegment{ address: 0x7fa6b0634840, byteSize: 16 })\n-glLightfv(16384, 4610, MemorySegment{ address: 0x7fa6b0634840, byteSize: 16 })\n-glMaterialfv(1028, 5633, MemorySegment{ address: 0x7fa6b0634860, byteSize: 4 })\n-glEnable(2896)\n-glEnable(16384)\n-glEnable(2929)\n-glutDisplayFunc(MemorySegment{ address: 0x7fa6a002e820, byteSize: 0 })\n-glutIdleFunc(MemorySegment{ address: 0x7fa6a015a620, byteSize: 0 })\n-glutMainLoop()\n-glClear(16640)\n-glPushMatrix()\n-glRotatef(-20.0, 1.0, 1.0, 0.0)\n-glRotatef(0.0, 0.0, 1.0, 0.0)\n-glutSolidTeapot(0.5)\n-```\n-\n----\n-\n","filename":"README.md","additions":2,"deletions":171,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -0,0 +1,845 @@\n+# Jextract Guide\n+\n+The jextract tool parses header (.h) files of native libraries, and generates Java code,\n+called _bindings_, which use the [Foreign Function and Memory API](https:\/\/openjdk.org\/jeps\/442)\n+(FFM API) under the hood, that can be used by a client to access the native library.\n+\n+Interacting with native C code through the FFM API works\n+by loading a native library (e.g. a `.so`\/`.dll`\/`.dylib` file), which is essentially an\n+archive of native functions and global variables. The user then has to look up the functions\n+they want to call using a `SymbolLookup`, and finally _link_ the functions by using the\n+`Linker::downcallHandle` method. Additionally, a client may need to create function pointer for\n+Java functions using `Linker::upcallStub`, access global variables through the addresses\n+returned by a lookup, and construct `MemoryLayout` instances for the structs they want to access.\n+The jextract tool aims to automate many of these steps, so that a client can instead\n+immediately start using the native libraries they are interested in.\n+\n+This guide shows how to run the jextract tool, and how to use the Java code that it generates.\n+The samples under [`samples`](samples) direcotry are also a good source of examples.\n+\n+Note that at this time, jextract only supports C header files. If you have a library written\n+in another language, see the section on [other languages](#other-languages).\n+\n+## Running Jextract\n+\n+A native library typically has an `include` directory which contains all the header files\n+that define the interface of the library, with one _main_ header file. Let's say we have a\n+library called `mylib` stored at `\/path\/to\/mylib` that has a directory `\/path\/to\/mylib\/include`\n+where the header files of that library are stored. And let's say that we have a shell open\n+in the root directory of the Java project we're working on, which has an `src` source\n+directory corresponding to,the root package. A typical way to run jextract would be like\n+this:\n+\n+```sh\n+$ jextract \\\n+  --include-dir \/path\/to\/mylib\/include \\\n+  --output src \\\n+  --target-package org.jextract.mylib \\\n+  --library mylib \\\n+  \/path\/to\/mylib\/include\/mylib.h\n+```\n+\n+In this command:\n+\n+- `\/path\/to\/mylib\/include\/mylib.h` is the main header file of the native library we want\n+  to generate bindings for.\n+- `--include-dir \/path\/to\/mylib\/include` specifies a header file search directory, which\n+   is used to find header files included through `#include` in the main header file.\n+- `--output src` specifies the root directory for the output. This matches to root package\n+  of the project's source directory.\n+- `--target-package org.jextract.mylib` specifies the target package to which the generated\n+  classes and interfaces will belong. (note that jextract will automatically create the\n+  directories representing the package structure under the `src` directory specified\n+  through `--output`)\n+- `--library mylib` tells jextract that the generated bindings should load the library\n+  called `mylib`. (The section on [library loading](#library-loading) discusses how is done)\n+\n+Besides these options, it is also possible to filter the output of jextract using one of the `--include-XXX` options\n+that jextract has. See the section on [filtering](#filtering) for a more detailed overview. See also the full\n+list of command line options [here](#command-line-option-reference).\n+\n+Jextract assumes that the version of a native library that a project uses is relatively stable.\n+Therefore, jextract is intended to be run once, and then for the generated sources to be added to the project.\n+Jextract only needs to be run again when the native library, or jextract itself are updated. (This is also\n+the workflow that jextract itself follows: jextract depends on the [libclang](https:\/\/clang.llvm.org\/docs\/LibClang.html)\n+native library in order to parse C sources).\n+\n+### Library Loading\n+\n+When using the `--library <libspec>` option, the generated code internally uses [`SymbolLookup::libraryLookup`](https:\/\/docs.oracle.com\/en\/java\/javase\/22\/docs\/api\/java.base\/java\/lang\/foreign\/SymbolLookup.html#libraryLookup(java.nio.file.Path,java.lang.foreign.Arena))\n+to load libraries specified by `<libspec>`, after potentially mapping the name of the library to a platform dependent name using [`System::mapLibraryName`](https:\/\/docs.oracle.com\/en\/java\/javase\/22\/docs\/api\/java.base\/java\/lang\/System.html#mapLibraryName(java.lang.String)).\n+This means for instance that on Linux, when specifying `--library mylib` the bindings will try to load `libmylib.so` using the OS-specific\n+library loading mechanism on Linux, which is [`dlopen`](https:\/\/man7.org\/linux\/man-pages\/man3\/dlopen.3.html).\n+This way of loading libraries also relies on OS-specific search mechanisms to find the library file.\n+On Linux the search path can be amended using the `LD_LIBRARY_PATH` environment variable (see the documentation of `dlopen`).\n+On Mac the relevant environment variable is `DYLD_LIBRARY_PATH`, and on Windows the variable is `PATH`.\n+Though, for the latter the overall library search mechanism is entirely different (described [here](https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/dlls\/dynamic-link-library-search-order)).\n+When using the HotSpot JVM, the `-Xlog:library` option can als be use to log where the JVM is trying to load a library from,\n+which can be useful to debug a failure to load a library.\n+\n+The `<libspec>` argument of the `--library` option can either be a library name, such as,\n+`mylib` which will, be mapped to a platform specific name using [`System::mapLibraryName`](https:\/\/docs.oracle.com\/en\/java\/javase\/22\/docs\/api\/java.base\/java\/lang\/System.html#mapLibraryName(java.lang.String)), or a path to a library file (either relative or\n+absolute) if `<libspec>` is prefixed with the `:` character, such as `mylib.dll`.\n+\n+It is important to understand how libraries are loaded on the platform that is being used,\n+as the library search mechanisms differ between them. Alternatively, JNI's library loading\n+and search mechanism can be used as well. When the `--use-system-load-library` option is\n+specified to jextract, the generated bindings will try to load libraries specified using\n+`--library` through [`System::loadLibrary`](https:\/\/docs.oracle.com\/en\/java\/javase\/22\/docs\/api\/java.base\/java\/lang\/System.html#loadLibrary(java.lang.String)).\n+The library search path for `System::loadLibrary` is specified through the [`java.library.path`](https:\/\/docs.oracle.com\/en\/java\/javase\/22\/docs\/api\/java.base\/java\/lang\/System.html#java.library.path)\n+system property instead of the OS-specific environment variable. Though, please note\n+that if the loaded library has any dependencies, those dependencies will again be loaded\n+through the OS-specific library loading mechanism (this is outside of the JVM's control).\n+\n+In both cases, the library is unloaded when the class loader that loads the binding\n+classes is garbage collected.\n+\n+## Using The Code Generated By Jextract\n+\n+In the following section we'll go over examples of declarations that might be found in a C\n+header file, show the code that jextract generates for these declarations, and show\n+some examples of how to use the generated Java code.\n+\n+Most of the code that jextract generates will be available through a single class. By default\n+the name of that class is derived from the name of the main header file that is passed to\n+jextract. For example, if the header file is named `mylib.h`, then the derived class name\n+will be `mylib_h`. The class name can be set explicitly using the `--header-class-name`\n+option as well.\n+\n+Besides the main header class that is generated, jextract also generates several\n+separate files for certain declarations in the C header file. Namely, structs, unions,\n+function pointer types, and typedefs of struct or union types result in additional files\n+being generated. We will look at those in more detail in this section.\n+\n+Most of the methods that jextract generates are `static`, and are designed to be imported\n+using `import static`. Typically, to access the code that jextract generates for a header\n+file called `mylib.h`, only the following two wildcard imports are needed:\n+\n+```java\n+import static org.mypackage.mylib_h.*;\n+import org.mypackage.*;\n+```\n+\n+Where `org.mypackage` is the package into which jextract put the generates source files\n+(using `--target-package`\/`-t`).\n+\n+The former import statement will import all the static functions and fields from the class\n+that jextract generates for the main header file of the library. This includes methods to\n+access functions, global variables, macros, enums, primitive typedefs, and layouts for\n+builtin C types.\n+\n+The latter import statement imports all the other classes the jextract generates, which\n+includes: classes representing structs or unions, function types, and struct or union\n+typedefs.\n+\n+### Builtin Type Layouts\n+\n+For every jextract run, regardless of the contents of the library header files, jextract\n+will generate a set of memory layouts for the common builtin C types in the main header\n+class it generates:\n+\n+```java\n+\/\/ mylib_h.java\n+\n+public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n+public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n+public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n+public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n+public static final AddressLayout C_POINTER = ValueLayout.ADDRESS\n+        .withTargetLayout(\n+                MemoryLayout.sequenceLayout(Long.MAX_VALUE, ValueLayout.JAVA_BYTE));\n+public static final ValueLayout.OfInt C_LONG = ValueLayout.JAVA_INT;\n+public static final ValueLayout.OfDouble C_LONG_DOUBLE = ValueLayout.JAVA_DOUBLE;\n+```\n+\n+The above layout constants represent the layouts for the C builtin types: `bool`, `char,`\n+`short,` `int`, `long long`, `float`, `double` `long`, and `long double`. Additionally,\n+there is a `C_POINTER` layout which represents the layout for any C pointer type (such as\n+`T*`). Note that these layouts are platform dependent, depending on the platform that\n+jextract runs on. For instance, since these constants were generated on Windows, the\n+`long` type has the same layout as the Java `int` type, indicating a 32-bit value, and the\n+`long double` type has the same layout as the Java `double` type. (note that the latter is\n+only available on Windows).\n+\n+### Functions\n+\n+Let's say we have a main library header file `mylib.h` that contains the following\n+function declaration:\n+\n+```c\n+\/\/ mylib.h\n+\n+void foo(int x);\n+```\n+\n+Jextract will generate the following set of methods for this function, in the main header\n+class it generates:\n+\n+```java\n+\/\/ mylib_h.java\n+\n+public static void foo(int x) { ... } \/\/ 1\n+\n+public static MemorySegment foo$address() { ... } \/\/ 2\n+public static FunctionDescriptor foo$descriptor() { ... } \/\/ 3\n+public static MethodHandle foo$handle() { ... } \/\/ 4\n+```\n+\n+First and foremost, there is a static wrapper method that is generated that can be used to\n+call the C function (1). Besides that, there are also several accessors that return\n+additional meta-data for the method: the function's address (2), the function descriptor\n+(3), and the method handle returned by the FFM linker (4), which is used to implement the\n+static wrapper method (1).\n+\n+The parameter types and return type of this method depend on the carrier types of the\n+layouts that make up the function descriptor of the function, which is itself derived\n+from the parsed header files.\n+\n+### Global Variables\n+\n+For a global variable declaration in a header file like this:\n+\n+```c\n+\/\/ mylib.h\n+\n+int bar;\n+```\n+\n+Jextract generates the following:\n+\n+```java\n+\/\/ mylib_h.java\n+\n+public static OfInt bar$layout() { ... } \/\/ 1\n+public static MemorySegment bar$segment() { ... } \/\/ 2\n+\n+public static int bar() { ... } \/\/ 3\n+public static void bar(int varValue) { ... } \/\/ 3\n+```\n+\n+`bar$layout` is the FFM memory layout of the global variable (1), and `bar$segment` is the\n+address of the global variable (2).\n+\n+Besides that, jextract also generates a getter and a setter method to get and set the value\n+of the global variable (3). Once again, the parameter and return type of the getter and\n+setter depend on the carrier type of the layout of the global variable, which is itself\n+derived from the header files.\n+\n+### Constants (Macros & Enums)\n+\n+Both macros and enums are translated similarly. If we have a header file containing these\n+declarations:\n+\n+```c\n+\/\/ mylib.h\n+\n+#define MY_MACRO 42\n+enum MY_ENUM { A, B, C };\n+```\n+\n+Jextract will generate a set of simple getter methods to access the constant values of the\n+macro and the enum constants:\n+\n+```java\n+\/\/ mylib_h.java\n+\n+public static int MY_MACRO() { ... }\n+\n+public static int A() { ... }\n+public static int B() { ... }\n+public static int C() { ... }\n+```\n+\n+Note that the enum constants are exposed as top-level methods, rather than being nested\n+inside a class called `MY_ENUM`, or through the use of a Java `enum`. This translation\n+strategy mimics C's behavior of enum constants being accessible as a top-level declaration,\n+and also makes it easier to do bitwise operations like `A | B`, which are not possible\n+with Java `enum`s.\n+\n+Not all types of macros are supported though. Only macros that have a primitive numerical\n+value, a string, or a pointer type are supported. Most notably, function-like macros are\n+not supported by jextract. For function-like macros, alternatives include re-writing the\n+code inside the macro in Java, using the FFM API, or writing a small C library which wraps\n+the function-like macro in a proper exported C function, that can then be linked against\n+through the FFM API.\n+\n+### Structs & Unions\n+\n+Things get a little more complicated for structs and unions. For a struct delcaration like\n+this:\n+\n+```c\n+\/\/ mylib.h\n+\n+struct Point {\n+    int x;\n+    int y;\n+};\n+```\n+\n+Jextract generates a separate class which roughly looks like the following:\n+\n+```java\n+\/\/ Point.java\n+\n+public class Point {\n+    public static final GroupLayout layout() { ... } \/\/ 3\n+\n+    public static final OfInt x$layout() { ... } \/\/ 2\n+    public static final long x$offset() { ... } \/\/ 2\n+\n+    public static int x(MemorySegment struct) { ... } \/\/ 1\n+    public static void x(MemorySegment struct, int fieldValue) { ... } \/\/ 1\n+\n+    public static final OfInt y$layout() { ... } \/\/ 2\n+    public static final long y$offset() { ... } \/\/ 2\n+\n+    public static int y(MemorySegment struct) { ... } \/\/ 1\n+    public static void y(MemorySegment struct, int fieldValue) { ... } \/\/ 1\n+\n+    public static MemorySegment asSlice(MemorySegment array, long index) { ... } \/\/ 5\n+\n+    public static long sizeof() { ... } \/\/ 3\n+\n+    public static MemorySegment allocate(SegmentAllocator allocator) { ... } \/\/ 4\n+    public static MemorySegment allocateArray(long elementCount,\n+            SegmentAllocator allocator) { ... } \/\/ 4\n+\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena,\n+            Consumer<MemorySegment> cleanup) { ... } \/\/ 6\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount,\n+            Arena arena, Consumer<MemorySegment> cleanup) { ... } \/\/ 6\n+}\n+```\n+\n+There are:\n+\n+1. a getter and setter for each field of the struct, which takes a pointer to a struct\n+  (a `MemorySegment`) to get\/set the field from\/to.\n+2. meta-data accessors for each field (`xxx$layout()` and `xxx$offset()`).\n+3. meta-data accessors `sizeof` and `layout`, which can be used to get the size and layout\n+  of the struct.\n+4. `allocate*` methods for allocating a single struct or arrays of structs.\n+5. an `asSlice` method which can be used to access elements of an array of structs.\n+6. two `reinterpret` methods which can be used to sanitize raw addresses\n+  returned by native code, or read from native memory.\n+\n+The following example shows how to allocate a struct using the `allocate` method, and then\n+sets both the `x` and `y` field to `10` and `5` respectively:\n+\n+```java\n+\/\/ Main.java\n+\n+try (Arena arena = Arena.ofConfined()) {\n+    MemorySegment point = Point.allocate(arena);\n+    Point.x(point, 10);\n+    Point.y(point, 5);\n+    \/\/ ...\n+}\n+```\n+\n+For working with arrays of structs, we can use the `allocateArray` method which accepts an\n+additional element count, indicating the length of the array:\n+\n+```java\n+\/\/ Main.java\n+\n+try (Arena arena = Arena.ofConfined()) {\n+    int arrLen = 5;\n+    MemorySegment points = Point.allocateArray(arrLen, arena);\n+\n+    for (int i = 0; i < arrLen; i++) {\n+        MemorySegment element = Point.asSlice(point, i);\n+        Point.x(element, 10 + i);\n+        Point.y(element, 5 + i);\n+    }\n+\n+    \/\/ ...\n+}\n+```\n+\n+In the above example, the `asSlice` method is used to _slice_ out a section of\n+the array, which corresponds to a single `Point` struct element. This method\n+can be used to access individual elements of the `points` array, when given\n+an index.\n+\n+Finally, the `reinterpret` method can be used to _sanitize_ a pointer that is\n+returned from native code. Let's say we have a C function that creates an instance\n+of a `Point`, and returns a pointer to it, as well as a function that deletes a\n+point, given a pointer:\n+\n+```c\n+struct Point* new_point(void);\n+void delete_point(struct Point* ptr);\n+```\n+\n+The pointer that is returned by the corresponding method that jextract generates\n+for this function does not have the correct bounds or lifetime associated with it.\n+These things are not possible to figure out automatically (for instance, a pointer\n+could point at a single `Point` struct, or an array of multiple `Point` structs).\n+\n+The `reinterpret` method can be used to associate the correct bounds and lifetime:\n+\n+```java\n+\/\/ Main.java\n+\n+try (Arena arena = Arena.ofConfined()) {\n+    MemorySegment point = Point.reinterpret(new_point(), arena, mylib_h::delete_point);\n+\n+    \/\/ ...\n+} \/\/ 'delete_point` called here\n+```\n+\n+The `point` segment returned by `reinterpret` has exactly the size of one `Point` (for\n+arrays of struct, use the `reinterpret` overload that takes an element count as well). The\n+lifetime we associate with the segment is the lifetime denoted by `arena`, and when the\n+arena is closed, we want to call `delete_point`, which we can do by passing a method\n+reference to `delete_point` as a cleanup action when calling `reinterpret`.\n+\n+### Function Pointers\n+\n+Jextract will generate a separate class for each function pointer type found in the header\n+files it parses. For instance, for a function pointer `typedef` like this:\n+\n+```c\n+\/\/ mylib.h\n+\n+typedef int (*callback_t)(int x, int y);\n+```\n+\n+Jextract generates the following class in a `callback_t.java` file:\n+\n+```java\n+\/\/ callback_t.java\n+\n+public class callback_t {\n+    public interface Function {\n+        int apply(int x, int y);\n+    }\n+\n+    public static FunctionDescriptor descriptor() { ... }\n+    public static MemorySegment allocate(callback_t.Function fi, Arena arena) { ... }\n+    public static int invoke(MemorySegment funcPtr,int x, int y) { ... }\n+}\n+```\n+\n+We again have a meta-data accessor for the function descriptor (`descriptor()`). There's\n+an `allocate` method that can be used to allocate a new instance of this function pointer,\n+whose implementation is defined by the `fi` functional interface instance. And finally,\n+there's an `invoke` method which can be used to invoke an instance of `callback_t` that\n+we received from native code.\n+\n+For instance, let's say we have a function that accepts an instance of the `callback_t`\n+function pointer type:\n+\n+```c\n+\/\/ mylib.c\n+\n+int call_me_back(callback_t callback) {\n+    return callback(1, 2);\n+}\n+```\n+\n+We can call this function from Java as follows:\n+\n+```java\n+\/\/ Main.java\n+\n+try (Arena arena = Arena.ofConfined()) {\n+    MemorySegment cb = callback_t.allocate((a, b) -> a * b, arena);\n+    int result = call_me_back(cb);\n+    System.out.println(result); \/\/ prints: 2\n+} \/\/ 'cb' freed here\n+```\n+\n+Here we use the lambda `(a, b) -> a * b` as the implementation of the `callback_t` instance\n+we create using `allocate`. This method returns an upcall stub like the ones\n+returned by the [`java.lang.foreign.Linker::upcallStub`](https:\/\/docs.oracle.com\/en\/java\/javase\/22\/docs\/api\/java.base\/java\/lang\/foreign\/Linker.html#upcallStub(java.lang.invoke.MethodHandle,java.lang.foreign.FunctionDescriptor,java.lang.foreign.Arena,java.lang.foreign.Linker.Option...))\n+method. The `arena` argument denotes the lifetime of the upcall stub, meaning that the\n+upcall stub will be freed when the arena is closed (after which the callback instance\n+can no longer be called).\n+\n+Additionally, we can using the `callback_t::invoke` method invoke an instance of\n+`callback_t` that we get back from a call to a C function. Let's say we have a couple of\n+functions like this:\n+\n+```c\n+\/\/ mylib.c\n+\n+int mult(int x, int y) {\n+    return x * y;\n+}\n+\n+callback_t get_callback(void) {\n+    return &mult;\n+}\n+```\n+\n+The `get_callback` function returns an instance of `callback_t`, which is a function pointer\n+pointing to the native `mult` function. We can call `callback_t` instance that `get_callback()`\n+return in Java using the `invoke` method in the `callback_t` class that jextract generates\n+for us:\n+\n+```java\n+\/\/ Main.java\n+\n+MemorySegment cb = get_callback();\n+int result = callback_t.invoke(cb, 1, 2);\n+System.out.println(result); \/\/ prints: 2\n+```\n+\n+Here the `callback_t` instance we want to invoke is passed as the first argument to\n+`invoke`, and then the `1` and `2` represent the arguments passed when calling the\n+`callback_t` instance.\n+\n+Jextract generates function pointer classes like the `callback_t` class for function\n+pointers found in function parameter or return types, typedefs, or the types of variables\n+(such as struct fields or global variables):\n+\n+```c\n+void func(void (*cb)(void)); \/\/ function parameter\n+void (*func(void))(void); \/\/ function return type\n+typedef void (*cb)(void); \/\/ typedef\n+void (*cb)(void); \/\/ global variable\n+struct Foo {\n+  void (*cb)(void); \/\/ struct field\n+};\n+```\n+\n+### Variadic Functions\n+\n+Jextract handles variadic functions differently from regular functions. Variadic functions\n+in C behave more or less like a template, where the calling convention changes based on the number\n+and types of arguments passed to the function. Because of this, the FFM linker needs to\n+know exactly which argument types are going to be passed to a variadic function when the\n+function is linked. This is described in greater detail in the [javadoc of the\n+`java.lang.foreign.Linker` class](https:\/\/docs.oracle.com\/en\/java\/javase\/22\/docs\/api\/java.base\/java\/lang\/foreign\/Linker.html#variadic-funcs).\n+\n+To make calling variadic functions easier, jextract introduces the concept of an _invoker_.\n+An invoker represents a particular _instantiation_ of a variadic function for a particular\n+set of variadic parameter types. When the header files contain a variadic function like this:\n+\n+```c\n+\/\/ mylib.h\n+\n+void foo_variadic(int x, ...);\n+```\n+\n+Jextract doesn't generates a regular method, but a _class_, which represents the invoker:\n+\n+```java\n+\/\/ mylib.h\n+\n+public static class foo_variadic {\n+    public static MemorySegment address() { ... }\n+    public static foo_variadic makeInvoker(MemoryLayout... layouts) { ... }\n+\n+    \/\/ not static!\n+    public MethodHandle handle() { ... }\n+    public FunctionDescriptor descriptor() { ... }\n+    public void apply(int x, Object... x1) { ... }\n+}\n+```\n+\n+This class has a `static` meta-data accessor for the function address, and a `makeInvoker`\n+factory method which can be used to create an instance on the invoker class. The `MemoryLayout...`\n+arguments passed to `makeInvoker` represent the memory layouts of the variadic parameters\n+that are to be passed to the function. The `makeInvoker` factory essentially instantiates\n+the variadic function (like you would a template) for a particular set of parameter types.\n+\n+We can then use the instance methods `apply` or `handle` if we want to invoke the function,\n+as follows:\n+\n+```java\n+\/\/ Main.java\n+\n+foo_variadic invoker = foo_variadic.makeInvoker(C_INT, C_INT, C_INT);\n+invoker.apply(3, 1, 2, 3);\n+invoker.handle().invokeExact(3, 1, 2, 3);\n+```\n+\n+Here we instantiate `foo_variadic` for 3 parameter types of the C type `int`. These parameter\n+types essentially replace the `...` ellipsis in the C function type.\n+\n+We can call the instantiated invoker either by calling `apply`, which will box the arguments\n+into an `Object[]`, or through the method handle returned by `handle()` which avoids the\n+overhead of boxing.\n+\n+### Typedefs\n+\n+As mentioned before: typedefs are either translated as a `static final` memory layout fields\n+in the main header class that jextract generates, or as a separate class, depending on\n+whether the typedef is for a primitive type or a struct\/union type respectively.\n+\n+Take for example the following `typedef` declarations:\n+\n+```c\n+\/\/ mylib.h\n+\n+typedef int MyInt;\n+\n+struct Point {\n+    int x;\n+    int y;\n+};\n+typedef struct Point MyPoint;\n+```\n+\n+`MyInt` is a `typedef` of the primitive type `int`, so it is translated by jextract as a\n+`static final` layout field in the main header class:\n+\n+```java\n+\/\/ mylib_h.java\n+\n+public static final OfInt MyInt = mylib_h.C_INT;\n+```\n+\n+The `MyPoint` `typedef` on the other hand is a typedef for a struct, so it is translated\n+as a separate class which extends the class that is generated for the `Point` struct:\n+\n+```java\n+\/\/ MyPoint.java\n+\n+public class MyPoint extends Point { }\n+```\n+\n+Through static inheritance, all the methods in the `Point` class are available through the\n+`MyPoint` class as well.\n+\n+### Nested Types\n+\n+C allows variable declarations to have an inline anonymous type. Jextract handles in\n+particular cases where a struct's field has an inline type specially. For instance, if we\n+have a struct such as this:\n+\n+```c\n+\/\/ mylib.h\n+\n+struct Foo {\n+    struct {\n+        int baz;\n+    } bar; \/\/ field of Foo\n+\n+    void (*cb)(void);\n+};\n+```\n+\n+Jextract generates a _nested_ struct and function pointer class for the `bar` and `cb`\n+fields, _inside of_ the class it generates for the `Foo` struct itself:\n+\n+```java\n+\/\/ mylib_h.java\n+\n+public class Foo {\n+    ...\n+    public static class bar { ... }\n+    public static final GroupLayout bar$layout() { ... }\n+    public static final long bar$offset() { ... }\n+\n+    public static MemorySegment bar(MemorySegment struct) { ... }\n+    public static void bar(MemorySegment struct, MemorySegment fieldValue) { ... }\n+    ...\n+    public static class cb { ... }\n+    public static final AddressLayout cb$layout() { ... }\n+    public static final long cb$offset() { ... }\n+\n+    public static MemorySegment cb(MemorySegment struct) { ... }\n+    public static void cb(MemorySegment struct, MemorySegment fieldValue) { ... }\n+    ...\n+}\n+```\n+\n+In both cases, the name of the nested class is the name of the field of the struct.\n+\n+Both fields also have the usual getter and setter, but note that the getter for the struct\n+field returns a _reference_ to the memory inside the `Foo` struct that corresponds to the\n+`bar` field. This means that writes to the returned memory segment will be visible in the\n+enclosing struct instance as well:\n+\n+```java\n+\/\/ Main.java\n+\n+try (Arena arena = Arena.ofConfined()) {\n+    MemorySegment foo = Foo.allocate(arena);\n+    MemorySegment bar = Foo.bar(foo); \/\/ reference to bar inside foo\n+    System.out.println(Foo.bar.baz(bar));  \/\/ prints: 0\n+\n+    MemorySegment bar2 = Foo.bar.allocate(arena);\n+    Foo.bar.baz(bar2, 42);\n+    Foo.bar(foo, bar2);  \/\/ copies bar2 into foo\n+    System.out.println(Foo.bar.baz(bar));  \/\/ prints: 42\n+}\n+```\n+\n+In the above snippet, note that the load of the `baz` field value on the last line will\n+_see_ the update to the `bar` field of the `foo` instance on the line before.\n+\n+## Filtering\n+\n+Some libraries are incredibly large (such as `Windows.h`), and we might not be\n+interested in letting jextract generate code for the entire library. In cases like that,\n+we can use jextract's `--include-XXX` command line options to only generate classes for\n+the elements we specify.\n+\n+To allow for symbol filtering, jextract can generate a _dump_ of all the symbols\n+encountered in an header file; this dump can be manipulated, and then used as an argument\n+file (using the `@argfile` syntax also available in other JDK tools) to e.g. generate\n+bindings only for a _subset_ of symbols seen by jextract. For instance, if we run\n+jextract with as follows:\n+\n+```sh\n+$ jextract --dump-includes includes.txt mylib.h\n+```\n+\n+We obtain the following file (`includes.txt`):\n+\n+```sh\n+#### Extracted from: \/workspace\/myproj\/mylib.h\n+\n+--include-struct Foo                  # header: \/workspace\/myproj\/mylib.h\n+--include-struct Point                # header: \/workspace\/myproj\/mylib.h\n+--include-typedef callback_t          # header: \/workspace\/myproj\/mylib.h\n+--include-function call_me_back       # header: \/workspace\/myproj\/mylib.h\n+...\n+```\n+\n+The include options in this file can then be edited down to a set of symbols that is\n+desired, for instance using other command line tools such as `grep` or `Select-String`,\n+and passed back to jextract:\n+\n+```sh\n+$ jextract --dump-includes includes.txt mylib.h\n+$ grep Foo includes.txt > includes_filtered.txt\n+$ jextract @includes_filtered.txt mylib.h\n+```\n+\n+Users should exercise caution when filtering symbols, as it is relatively easy to filter\n+out a declaration that is depended on by one or more declarations:\n+\n+```c\n+\/\/ test.h\n+struct A {\n+   int x;\n+}\n+struct A aVar;\n+```\n+\n+Here, we could run jextract and filter out `A`, like so:\n+\n+```sh\n+$ jextract --include-var aVar test.h\n+```\n+\n+However, doing so would lead to broken generated code, as the layout of the global variable\n+`aVar` depends on the layout of the excluded struct `A`.\n+\n+In such cases, jextract will report the missing dependency and terminate without\n+generating any bindings:\n+\n+```txt\n+ERROR: aVar depends on A which has been excluded\n+```\n+\n+## Tracing\n+\n+It is sometimes useful to inspect the parameters passed to a native call, especially when\n+diagnosing application bugs and\/or crashes. The code generated by the jextract tool\n+supports _tracing_ of native calls, that is, parameters passed to native calls can be\n+printed on the standard output.\n+\n+To enable the tracing support, just pass the `-Djextract.trace.downcalls=true` flag to the\n+launcher used to start the application. Below we show an excerpt of the output when\n+running the [OpenGL example](samples\/opengl) with tracing support enabled:\n+\n+```txt\n+glutInit(MemorySegment{ address: 0x7fa6b03d6400, byteSize: 4 }, MemorySegment{ address: 0x7fa6b03d6400, byteSize: 4 })\n+glutInitDisplayMode(18)\n+glutInitWindowSize(900, 900)\n+glutCreateWindow(MemorySegment{ address: 0x7fa6b03f8e70, byteSize: 14 })\n+glClearColor(0.0, 0.0, 0.0, 0.0)\n+glShadeModel(7425)\n+glLightfv(16384, 4611, MemorySegment{ address: 0x7fa6b03de8d0, byteSize: 16 })\n+glLightfv(16384, 4608, MemorySegment{ address: 0x7fa6b0634840, byteSize: 16 })\n+glLightfv(16384, 4609, MemorySegment{ address: 0x7fa6b0634840, byteSize: 16 })\n+glLightfv(16384, 4610, MemorySegment{ address: 0x7fa6b0634840, byteSize: 16 })\n+glMaterialfv(1028, 5633, MemorySegment{ address: 0x7fa6b0634860, byteSize: 4 })\n+glEnable(2896)\n+glEnable(16384)\n+glEnable(2929)\n+glutDisplayFunc(MemorySegment{ address: 0x7fa6a002e820, byteSize: 0 })\n+glutIdleFunc(MemorySegment{ address: 0x7fa6a015a620, byteSize: 0 })\n+glutMainLoop()\n+glClear(16640)\n+glPushMatrix()\n+glRotatef(-20.0, 1.0, 1.0, 0.0)\n+glRotatef(0.0, 0.0, 1.0, 0.0)\n+glutSolidTeapot(0.5)\n+```\n+\n+## Preprocessor Definitions\n+\n+C header files are processed by a pre-processor by a compiler before they are inspected\n+further. It is possible for a header file to contain so-called 'compiler switches', which\n+can be used to conditionally generate code based on the value of a macro, for instance:\n+\n+```c\n+#ifdef MY_MACRO\n+int x = 42;\n+#else\n+int x = 0;\n+#endif\n+```\n+\n+The value of these macros also affects the behavior of jextract. Therefore, jextract\n+supports setting macro values on the command line using the `-D` or\n+`--define-macro <macro>=<value>` option. For instance, we can use `-D MY_MACRO` to set\n+the value of `MY_MACRO` in the above snippet to `1`, and trigger the first _branch_ of the\n+compiler switch, thereby defining `int x = 42`.\n+\n+Please note that other header files included by jextract may also define macro values using\n+the `#define` pre-processor directive. It is therefore important to notice the order in\n+which header files are processed by a compiler, as feeding header files to jextract in the\n+wrong order may result in weird errors due to missing macro definitions. A well-known\n+example of this are Windows SDK headers. Almost always, the main `Windows.h` header file\n+should be passed to jextract for things to work correctly. Please consult the\n+documentation of the library that you're trying to use to find out which header file should\n+be included\/passed to jextract.\n+\n+## Command Line Option Reference\n+\n+A complete list of all the supported command line options is given below:\n+\n+| Option                                                       | Meaning                                                      |\n+| :----------------------------------------------------------- | ------------------------------------------------------------ |\n+| `-D --define-macro <macro>=<value>`                          | define `<macro>` to `<value>` (or 1 if `<value>` omitted)          |\n+| `--header-class-name <name>`                                 | name of the generated header class. If this option is not specified, then header class name is derived from the header file name. For example, class \"foo_h\" for header \"foo.h\". |\n+| `-t, --target-package <package>`                             | target package name for the generated classes. If this option is not specified, then unnamed package is used.  |\n+| `-I, --include-dir <dir>`                                    | append directory to the include search paths. Include search paths are searched in order. For example, if `-I foo -I bar` is specified, header files will be searched in \"foo\" first, then (if nothing is found) in \"bar\".|\n+| `-l, --library <name \\| path>`                               | specify a shared library that should be loaded by the generated header class. If <libspec> starts with `:`, then what follows is interpreted as a library path. Otherwise, `<libspec>` denotes a library name. Examples: <br>`-l GL`<br>`-l :libGL.so.1`<br>`-l :\/usr\/lib\/libGL.so.1`|\n+| `--use-system-load-library`                                  | libraries specified using `-l` are loaded in the loader symbol lookup (using either `System::loadLibrary`, or `System::load`). Useful if the libraries must be loaded from one of the paths in `java.library.path`.|\n+| `--output <path>`                                            | specify where to place generated files                       |\n+| `--dump-includes <String>`                                   | dump included symbols into specified file (see below)        |\n+| `--include-[function,constant,struct,union,typedef,var]<String>` | Include a symbol of the given name and kind in the generated bindings. When one of these options is specified, any symbol that is not matched by any specified filters is omitted from the generated bindings. |\n+| `--version`                                                  | print version information and exit |\n+\n+### Additional clang options\n+\n+Jextract uses an embedded clang compiler (through libclang) to parse header files. Users\n+can also specify additional clang compiler options, by creating a file named\n+`compile_flags.txt` in the current folder, as described\n+[here](https:\/\/clang.llvm.org\/docs\/JSONCompilationDatabase.html#alternatives).\n+\n+## Other Languages\n+\n+As noted in the introduction, jextract currently only supports C header files, but many\n+other languages also support C interop, and jextract\/FFM can still be used to talk to\n+libraries written in those language through an intermediate C layer. The table below\n+describes how to do this for various different langauges:\n+\n+| Language  | Method of access                                             |\n+| :---------| ------------------------------------------------------------ |\n+| C++       | C++ allows declaring C methods using `extern \"C\"`, and many C++ libraries have a C interface to go with them. Jextract can consume such a C interface, which can then be used to access the library in question. |\n+| Rust      | The Rust ecosystem has a tool called `cbindgen` which can be used to generate a C interface for a Rust library. Such a generated C interface can then be consumed by jextract, and be used to access the library in question. |\n","filename":"doc\/GUIDE.md","additions":845,"deletions":0,"binary":false,"changes":845,"status":"added"}]}