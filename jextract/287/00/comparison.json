{"files":[{"patch":"@@ -148,1 +148,1 @@\n-                        options.sharedClassName));\n+                        options.includeHelper, options.sharedClassName));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/JextractTool.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.Collections;\n@@ -37,0 +38,1 @@\n+import java.util.HashMap;\n@@ -85,0 +87,3 @@\n+\n+    private final Map<String, Set<String>> propertiesByName = new HashMap<>();\n+\n@@ -88,0 +93,3 @@\n+    \/**\n+     * Register an include, may be:Name or Name,flag1,flag2 orName,prop=value,flag\n+     *\/\n@@ -89,2 +97,19 @@\n-        Set<String> names = includesSymbolNamesByKind.computeIfAbsent(kind, (_unused) -> new HashSet<>());\n-        names.add(symbolName);\n+        String[] parts = symbolName.split(\",\", 2);\n+        String name = parts[0].trim();\n+\n+        includesSymbolNamesByKind.computeIfAbsent(kind, k -> new HashSet<>())\n+                .add(name);\n+\n+        if (parts.length == 2) {\n+            Set<String> props = propertiesByName\n+                    .computeIfAbsent(name, k -> new HashSet<>());\n+            for (String tok : parts[1].split(\",\")) {\n+                props.add(tok.trim());\n+            }\n+        }\n+\n+        if (kind == IncludeKind.STRUCT || kind == IncludeKind.UNION) {\n+            includesSymbolNamesByKind\n+                    .computeIfAbsent(IncludeKind.TYPEDEF, k -> new HashSet<>())\n+                    .add(name);\n+        }\n@@ -114,1 +139,4 @@\n-        boolean included = isIncludedInternal(kind, declaration);\n+        boolean included = !isEnabled()\n+                || includesSymbolNamesByKind\n+                .getOrDefault(kind, Collections.emptySet())\n+                .contains(declaration.name());\n@@ -121,7 +149,2 @@\n-    private boolean isIncludedInternal(IncludeKind kind, Declaration declaration) {\n-        if (!isEnabled()) {\n-            return true;\n-        } else {\n-            Set<String> names = includesSymbolNamesByKind.computeIfAbsent(kind, (_unused) -> new HashSet<>());\n-            return names.contains(declaration.name());\n-        }\n+    public boolean isEnabled() {\n+        return !includesSymbolNamesByKind.isEmpty();\n@@ -130,2 +153,4 @@\n-    public boolean isEnabled() {\n-        return includesSymbolNamesByKind.size() > 0;\n+    public boolean isFunctionalDispatch(String name) {\n+        return propertiesByName\n+                .getOrDefault(name, Collections.emptySet())\n+                .contains(\"functional\");\n@@ -142,2 +167,3 @@\n-                writer.append(lineSep);\n-                writer.append(\"#### Extracted from: \" + pathEntries.getKey().toString() + \"\\n\\n\");\n+                writer.append(lineSep)\n+                        .append(\"#### Extracted from: \")\n+                        .append(pathEntries.getKey().toString()).append(\"\\n\\n\");\n@@ -152,1 +178,1 @@\n-                        writer.append(String.format(\"%-\" + maxLengthOptionCol + \"s %s\",\n+                        writer.append(String.format(\"%-\" + maxLengthOptionCol + \"s %s\\n\",\n@@ -154,1 +180,1 @@\n-                                       \"# header: \" + pathEntries.getKey() + \"\\n\"));\n+                                \"# header: \" + pathEntries.getKey()));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/IncludeHelper.java","additions":42,"deletions":16,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+                                                   IncludeHelper includeHelper,\n@@ -53,1 +54,1 @@\n-                libs, useSystemLoadLibrary, sharedClassName);\n+                libs, useSystemLoadLibrary, sharedClassName, includeHelper);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,0 +55,2 @@\n+    private final IncludeHelper includeHelper;\n+    private final boolean functionalDispatch;\n@@ -57,1 +59,2 @@\n-                  ClassSourceBuilder enclosing, String runtimeHelperName, Declaration.Scoped structTree) {\n+                  ClassSourceBuilder enclosing, String runtimeHelperName, Declaration.Scoped structTree,\n+                  IncludeHelper includeHelper) {\n@@ -62,0 +65,2 @@\n+        this.functionalDispatch = includeHelper.isFunctionalDispatch(builder.className());\n+        this.includeHelper = includeHelper;\n@@ -119,1 +124,1 @@\n-                    JavaName.getOrThrow(tree), this, runtimeHelperName(), tree);\n+                    JavaName.getOrThrow(tree), this, runtimeHelperName(), tree, this.includeHelper);\n@@ -140,1 +145,2 @@\n-        if (Utils.isArray(varTree.type()) || Utils.isStructOrUnion(varTree.type())) {\n+        Type type = varTree.type();\n+        if (Utils.isArray(type) || Utils.isStructOrUnion(type)) {\n@@ -143,1 +149,1 @@\n-            int dims = Utils.dimensions(varTree.type()).size();\n+            int dims = Utils.dimensions(type).size();\n@@ -151,3 +157,15 @@\n-        } else if (Utils.isPointer(varTree.type()) || Utils.isPrimitive(varTree.type())) {\n-            emitFieldGetter(javaName, varTree, layoutField, offsetField);\n-            emitFieldSetter(javaName, varTree, layoutField, offsetField);\n+        } else if (Utils.isPointer(type) || Utils.isPrimitive(type)) {\n+            boolean isFuncPtr = functionalDispatch && Utils.isFunctionPointer(type);\n+            if (isFuncPtr) {\n+                emitFieldSetter(javaName, varTree, layoutField, offsetField);\n+                emitFunctionalConvenience(\n+                        javaName,\n+                        (Type.Function)((Type.Delegated) type).type(),\n+                        varTree,\n+                        layoutField,\n+                        offsetField\n+                );\n+            } else {\n+                emitFieldGetter(javaName, varTree, layoutField, offsetField);\n+                emitFieldSetter(javaName, varTree, layoutField, offsetField);\n+            }\n@@ -155,1 +173,1 @@\n-            throw new IllegalArgumentException(String.format(\"Type not supported: %1$s\", varTree.type()));\n+            throw new IllegalArgumentException(\"Type not supported: \" + type);\n@@ -159,0 +177,64 @@\n+    \/**\n+     * Generates exactly one invoker, inlining the struct.get(...) to avoid name collision.\n+     *\/\n+    private void emitFunctionalConvenience(String invokerName,\n+                                           Type.Function funcType,\n+                                           Declaration.Variable varTree,\n+                                           String layoutField,\n+                                           String offsetField) {\n+        String returnType = Utils.carrierFor(funcType.returnType()).getSimpleName();\n+        List<Type> params = funcType.argumentTypes();\n+\n+        String sig  = IntStream.range(0, params.size())\n+                .mapToObj(i -> Utils.carrierFor(params.get(i)).getSimpleName() + \" _x\" + i)\n+                .collect(Collectors.joining(\", \"));\n+        String args = IntStream.range(0, params.size())\n+                .mapToObj(i -> \"_x\" + i)\n+                .collect(Collectors.joining(\", \"));\n+\n+        boolean structRet = !Utils.isPrimitive(funcType.returnType())\n+                && !Utils.isPointer(funcType.returnType());\n+        String retKw = returnType.equals(\"void\") ? \"\" : \"return \";\n+\n+        appendBlankLine();\n+        incrAlign();\n+        emitDocComment(varTree, \"Invoker for the pointer inside the Struct:\");\n+        decrAlign();\n+\n+        if (structRet) {\n+            appendIndentedLines(\n+                    \"public static %1$s %2$s(MemorySegment struct, SegmentAllocator alloc%3$s) {\",\n+                    returnType, invokerName, sig.isEmpty() ? \"\" : \", \" + sig\n+            );\n+            incrAlign();\n+            appendIndentedLines(\n+                    \"MemorySegment fp = struct.get(%1$s, %2$s);\",\n+                    layoutField, offsetField\n+            );\n+            appendIndentedLines(\n+                    \"%1$s%2$s.invoke(fp, alloc%3$s);\",\n+                    retKw,\n+                    JavaFunctionalInterfaceName.getOrThrow(varTree),\n+                    args.isEmpty() ? \"\" : \", \" + args\n+            );\n+        } else {\n+            appendIndentedLines(\n+                    \"public static %1$s %2$s(MemorySegment struct%3$s) {\",\n+                    returnType, invokerName, sig.isEmpty() ? \"\" : \", \" + sig\n+            );\n+            incrAlign();\n+            appendIndentedLines(\n+                    \"MemorySegment fp = struct.get(%1$s, %2$s);\",\n+                    layoutField, offsetField\n+            );\n+            appendIndentedLines(\n+                    \"%1$s%2$s.invoke(fp%3$s);\",\n+                    retKw,\n+                    JavaFunctionalInterfaceName.getOrThrow(varTree),\n+                    args.isEmpty() ? \"\" : \", \" + args\n+            );\n+        }\n+        decrAlign();\n+        appendIndentedLines(\"}\");\n+    }\n+\n@@ -493,1 +575,1 @@\n-                    size = Math.max(size, ClangSizeOf.getOrThrow(member));\n+                    size = Math.max(size, fieldSize);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructBuilder.java","additions":91,"deletions":9,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+    private final IncludeHelper includeHelper;\n@@ -55,1 +56,1 @@\n-                    boolean useSystemLoadLibrary, String sharedClassName) {\n+                    boolean useSystemLoadLibrary, String sharedClassName, IncludeHelper includeHelper) {\n@@ -57,0 +58,1 @@\n+        this.includeHelper = includeHelper;\n@@ -129,0 +131,1 @@\n+            String className = headerBuilders.get(0).className();\n@@ -136,1 +139,0 @@\n-                String className = headerBuilders.getFirst().className();\n@@ -195,1 +197,8 @@\n-        StructBuilder structBuilder = new StructBuilder(sfb, \"public\", sfb.className(), null, mainHeaderClassName(), tree);\n+        StructBuilder structBuilder = new StructBuilder(sfb,\n+                \"public\",\n+                sfb.className(),\n+                null,\n+                mainHeaderClassName(),\n+                tree,\n+                includeHelper\n+        );\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ToplevelBuilder.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,0 +154,11 @@\n+    static boolean isFunctionPointer(Type type) {\n+        return switch (type) {\n+            case Type.Delegated delegated when delegated.kind() == Delegated.Kind.POINTER ->\n+                    delegated.type() instanceof Type.Function;\n+            case Type.Delegated delegated when delegated.kind() == Delegated.Kind.TYPEDEF ->\n+                    isFunctionPointer(delegated.type());\n+            default -> false;\n+        };\n+    }\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Utils.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * @test\n+ * @library \/lib\n+ * @build testlib.TestUtils\n+ * @bug 7903947\n+ * @summary test option to streamline access to function pointers\n+ * @run main\/othervm JtregJextract\n+ *      --include-typedef DupStruct,functional\n+ *      --include-typedef Funcs,functional\n+ *      --include-typedef Simple,functional\n+ *      -t test.jextract.functional_dispatch functional_dispatch.h\n+ * @build FunctionalDispatch\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED FunctionalDispatch\n+ *\/\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import test.jextract.functional_dispatch.*;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class FunctionalDispatch {\n+    @Test\n+    public void testSimpleStruct() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment s = Simple.allocate(arena);\n+            assertEquals(Simple.value(s), 0);\n+            Simple.value(s, 999);\n+            assertEquals(Simple.value(s), 999);\n+        }\n+    }\n+\n+    @Test\n+    public void testFuncsFunctionalDispatch() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment f = Funcs.allocate(arena);\n+\n+            Funcs.zero.Function zeroLam = () -> 7;\n+            MemorySegment zeroPtr = Funcs.zero.allocate(zeroLam, arena);\n+            Funcs.zero(f, zeroPtr);\n+            assertEquals(Funcs.zero(f), 7);\n+\n+            Funcs.one.Function oneLam = x -> x * 3;\n+            MemorySegment onePtr = Funcs.one.allocate(oneLam, arena);\n+            Funcs.one(f, onePtr);\n+            assertEquals(Funcs.one(f, 5), 15);\n+\n+            Funcs.sum.Function sumLam = (a, b) -> a + b;\n+            MemorySegment sumPtr = Funcs.sum.allocate(sumLam, arena);\n+            Funcs.sum(f, sumPtr);\n+            assertEquals(Funcs.sum(f, 100L, 23L), 123L);\n+\n+            Funcs.make_point.Function mpLam = (x, y) -> {\n+                MemorySegment p = Funcs.Point.allocate(arena);\n+                Funcs.Point.x(p, x);\n+                Funcs.Point.y(p, y);\n+                return p;\n+            };\n+            MemorySegment mpPtr = Funcs.make_point.allocate(mpLam, arena);\n+            Funcs.make_point(f, mpPtr);\n+            MemorySegment p = Funcs.make_point(f, arena, 8, 9);\n+            assertEquals(Funcs.Point.x(p), 8);\n+            assertEquals(Funcs.Point.y(p), 9);\n+        }\n+    }\n+\n+    @Test\n+    public void testDupStructFunctional() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment ds = DupStruct.allocate(arena);\n+\n+            DupStruct.dup.Function dupLam = () -> {\n+                MemorySegment s = Simple.allocate(arena);\n+                Simple.value(s, 555);\n+                return s;\n+            };\n+            MemorySegment dupPtr = DupStruct.dup.allocate(dupLam, arena);\n+            DupStruct.dup(ds, dupPtr);\n+            MemorySegment result = DupStruct.dup(ds, arena);\n+            assertEquals(Simple.value(result), 555);\n+        }\n+    }\n+}\n","filename":"test\/jtreg\/generator\/functionalDispatch\/FunctionalDispatch.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ typedef struct {\n+    int    (*zero)();\n+    int    (*one)(int);\n+    long   (*sum)(long, long);\n+    struct Point { int x; int y; } (*make_point)(int, int);\n+} Funcs;\n+\n+typedef struct { int value; } Simple;\n+\n+typedef struct {\n+    Simple (*dup)();\n+} DupStruct;\n","filename":"test\/jtreg\/generator\/functionalDispatch\/functional_dispatch.h","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"}]}