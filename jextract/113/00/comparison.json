{"files":[{"patch":"@@ -237,6 +237,0 @@\n-        \/**\n-         * The optional layout associated with this variable declaration.\n-         * @return The optional layout associated with this variable declaration.\n-         *\/\n-        Optional<MemoryLayout> layout();\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Declaration.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -292,0 +292,5 @@\n+            if (l.bitAlignment() != l.bitSize()) {\n+                append(\".withBitAlignment(\");\n+                append(l.bitAlignment());\n+                append(\")\");\n+            }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ConstantBuilder.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -180,5 +180,0 @@\n-        @Override\n-        public Optional<MemoryLayout> layout() {\n-            return layout;\n-        }\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/DeclarationImpl.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -357,1 +357,1 @@\n-        MemoryLayout layout = tree.layout().orElse(Type.layoutFor(type).orElse(null));\n+        MemoryLayout layout = Type.layoutFor(type).orElse(null);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-            builder.append(\"Variable: \" + d.kind() + \" \" + d.name() + \" type = \" + d.type().accept(typeVisitor, null) + \", layout = \" + d.layout());\n+            builder.append(\"Variable: \" + d.kind() + \" \" + d.name() + \" type = \" + d.type().accept(typeVisitor, null));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/PrettyPrinter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.foreign.GroupLayout;\n@@ -36,0 +37,3 @@\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -120,1 +124,1 @@\n-    void addField(Declaration declaration) {\n+    void addField(long offset, Declaration declaration) {\n@@ -126,1 +130,1 @@\n-            layout = var.layout().orElse(null);\n+            layout = org.openjdk.jextract.Type.layoutFor(var.type()).orElse(null);\n@@ -129,1 +133,4 @@\n-            \/\/fieldLayouts.add(layout.name().isEmpty() ? layout.withName(declaration.name()) : layout);\n+            if ((offset % layout.bitAlignment()) != 0) {\n+                long maxAlign = Long.lowestOneBit(offset);\n+                layout = forceAlign(layout, maxAlign);\n+            }\n@@ -140,1 +147,1 @@\n-            addField(((org.openjdk.jextract.Type.Declared)computeAnonymous(typeMaker, offset, parent, c.type(), nextAnonymousName())).tree());\n+            addField(offset, ((org.openjdk.jextract.Type.Declared)computeAnonymous(typeMaker, offset, parent, c.type(), nextAnonymousName())).tree());\n@@ -142,1 +149,1 @@\n-            addField(field(offset, c));\n+            addField(offset, field(offset, c));\n@@ -188,0 +195,16 @@\n+\n+    MemoryLayout forceAlign(MemoryLayout layout, long maxAlign) {\n+        if (layout instanceof GroupLayout groupLayout) {\n+            MemoryLayout[] newMembers = groupLayout.memberLayouts()\n+                    .stream().map(l -> forceAlign(l, maxAlign)).toArray(MemoryLayout[]::new);\n+            return groupLayout instanceof StructLayout ?\n+                    MemoryLayout.structLayout(newMembers) :\n+                    MemoryLayout.unionLayout(newMembers);\n+        } else if (layout instanceof SequenceLayout sequenceLayout) {\n+            return MemoryLayout.sequenceLayout(sequenceLayout.elementCount(),\n+                    forceAlign(sequenceLayout.elementLayout(), maxAlign));\n+        } else {\n+            return layout.bitAlignment() > maxAlign ?\n+                    layout.withBitAlignment(maxAlign) : layout;\n+        }\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/RecordLayoutComputer.java","additions":28,"deletions":5,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    void addField(Declaration declaration) {\n+    void addField(long offset, Declaration declaration) {\n@@ -59,1 +59,1 @@\n-            super.addField(declaration);\n+            super.addField(offset, declaration);\n@@ -143,1 +143,2 @@\n-        Declaration.Scoped declaration = Declaration.struct(TreeMaker.CursorPosition.of(cursor), cursor.spelling(), g, fieldDecls.stream().toArray(Declaration[]::new));\n+        Declaration.Scoped declaration = Declaration.struct(TreeMaker.CursorPosition.of(cursor), cursor.spelling(),\n+                g, fieldDecls.stream().toArray(Declaration[]::new));\n@@ -155,1 +156,1 @@\n-                addField(bitfield(prevBitfieldDecls.toArray(new Declaration.Variable[0])));\n+                addField(offset, bitfield(prevBitfieldDecls.toArray(new Declaration.Variable[0])));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructLayoutComputer.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -282,1 +282,1 @@\n-            ValueLayout layoutNoName = layout.withoutName();\n+            ValueLayout layoutNoName = normalize(layout);\n@@ -293,1 +293,7 @@\n-            return primitiveLayouts.get(layout.withoutName());\n+            return primitiveLayouts.get(normalize(layout));\n+        }\n+\n+        public ValueLayout normalize(ValueLayout valueLayout) {\n+            return valueLayout\n+                    .withBitAlignment(valueLayout.bitSize()) \/\/ use natural alignment\n+                    .withoutName(); \/\/ drop name\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ToplevelBuilder.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.api;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.testng.annotations.Test;\n+import testlib.JextractApiTestBase;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+import java.lang.foreign.GroupLayout;\n+\n+public class TestPackedStructs extends JextractApiTestBase {\n+\n+    static final String[] NAMES = {\n+            \"S1\", \"S2\", \"S3\", \"S4\", \"S5\", \"S6\"\n+    };\n+\n+    @Test\n+    public void testPackedStructs() {\n+        Declaration.Scoped d = parse(\"packedstructs.h\");\n+        System.out.println(d);\n+        for (String name : NAMES) {\n+            Declaration.Scoped scoped = checkStruct(d, name, \"first\", \"second\");\n+            GroupLayout groupLayout = (GroupLayout)scoped.layout().get();\n+            assertEquals(groupLayout.memberLayouts().get(1).bitAlignment(), 8);\n+        }\n+    }\n+}\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/api\/TestPackedStructs.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#pragma pack(1)\n+struct S1 {\n+   char first;\n+   int second;\n+};\n+\n+#pragma pack(1)\n+struct S2 {\n+   char first;\n+   struct { int i } second;\n+};\n+\n+#pragma pack(1)\n+struct S3 {\n+   char first;\n+   int second[2];\n+};\n+\n+#pragma pack(1)\n+struct S4 {\n+   char first;\n+   union { int x; int y; } second;\n+};\n+\n+#pragma pack(1)\n+struct S5 {\n+   char first;\n+   union { struct { int i } x; struct { int i } y; } second;\n+};\n+\n+#pragma pack(1)\n+struct S6 {\n+   char first;\n+   union { int x[2]; int y[2]; } second;\n+};\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/api\/packedstructs.h","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"}]}