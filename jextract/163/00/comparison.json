{"files":[{"patch":"@@ -31,0 +31,2 @@\n+\n+import org.openjdk.jextract.clang.libclang.CXCursor;\n@@ -34,0 +36,2 @@\n+import java.lang.foreign.SegmentAllocator;\n+import java.util.Objects;\n@@ -37,0 +41,2 @@\n+import static org.openjdk.jextract.clang.libclang.Index_h.C_CHAR;\n+\n@@ -290,7 +296,2 @@\n-    @Override\n-    public boolean equals(Object other) {\n-        if (this == other) {\n-            return true;\n-        }\n-        return other instanceof Cursor otherCursor &&\n-                (Index_h.clang_equalCursors(segment, otherCursor.segment) != 0);\n+    public Key toKey() {\n+        return new Key(this);\n@@ -299,3 +300,39 @@\n-    @Override\n-    public int hashCode() {\n-        return spelling().hashCode();\n+    \/**\n+     * A key that can be used for cursor comparisons. This avoids the problem of comparing cursors\n+     * which are already closed, and also optimizes the use of the underlying 'clang_equalCursors' function,\n+     * to avoid unnecessary off-heap allocation. This is required by the deduplication logic in TreeMaker.\n+     *\/\n+    public static class Key {\n+\n+        final String spelling;\n+        final CursorKind kind;\n+        final MemorySegment payload;\n+\n+        private Key(Cursor cursor) {\n+            spelling = cursor.spelling();\n+            kind = cursor.kind();\n+            payload = MemorySegment.ofArray(new byte[(int)CXCursor.$LAYOUT().byteSize()]);\n+            payload.copyFrom(cursor.segment);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!(obj instanceof Key key)) return false;\n+            if (kind != key.kind) return false;\n+            if (!spelling.equals(key.spelling)) return false;\n+            \/\/ slow path\n+            SegmentAllocator allocator = SegmentAllocator.slicingAllocator(COMPARISON_SEGMENT);\n+            return Index_h.clang_equalCursors(toSegment(allocator), key.toSegment(allocator)) != 0;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(kind, spelling);\n+        }\n+\n+        private MemorySegment toSegment(SegmentAllocator allocator) {\n+            return allocator.allocateFrom(C_CHAR, payload,\n+                                          C_CHAR, 0, CXCursor.$LAYOUT().byteSize());\n+        }\n+\n+        private static final MemorySegment COMPARISON_SEGMENT = Arena.ofAuto().allocate(CXCursor.$LAYOUT(), 2);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/Cursor.java","additions":47,"deletions":10,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * struct {\n+ *     enum CXCursorKind kind;\n+ *     int xdata;\n+ *     void* data[3];\n+ * };\n+ * }\n+ *\/\n+public class CXCursor {\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        Index_h.C_INT.withName(\"kind\"),\n+        Index_h.C_INT.withName(\"xdata\"),\n+        MemoryLayout.sequenceLayout(3, Index_h.C_POINTER).withName(\"data\")\n+    ).withName(\"$anon$2706:9\");\n+\n+    public static final GroupLayout $LAYOUT() {\n+        return $LAYOUT;\n+    }\n+    private static final long kind$OFFSET = 0;\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * enum CXCursorKind kind;\n+     * }\n+     *\/\n+    public static int kind$get(MemorySegment seg) {\n+        return seg.get(Index_h.C_INT, kind$OFFSET);\n+    }\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * enum CXCursorKind kind;\n+     * }\n+     *\/\n+    public static void kind$set(MemorySegment seg, int x) {\n+        seg.set(Index_h.C_INT, kind$OFFSET, x);\n+    }\n+    public static int kind$get(MemorySegment seg, long index) {\n+        return seg.get(Index_h.C_INT, kind$OFFSET + (index * sizeof()));\n+    }\n+    public static void kind$set(MemorySegment seg, long index, int x) {\n+        seg.set(Index_h.C_INT, kind$OFFSET + (index * sizeof()), x);\n+    }\n+    private static final long xdata$OFFSET = 4;\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int xdata;\n+     * }\n+     *\/\n+    public static int xdata$get(MemorySegment seg) {\n+        return seg.get(Index_h.C_INT, xdata$OFFSET);\n+    }\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int xdata;\n+     * }\n+     *\/\n+    public static void xdata$set(MemorySegment seg, int x) {\n+        seg.set(Index_h.C_INT, xdata$OFFSET, x);\n+    }\n+    public static int xdata$get(MemorySegment seg, long index) {\n+        return seg.get(Index_h.C_INT, xdata$OFFSET + (index * sizeof()));\n+    }\n+    public static void xdata$set(MemorySegment seg, long index, int x) {\n+        seg.set(Index_h.C_INT, xdata$OFFSET + (index * sizeof()), x);\n+    }\n+    private static final long data$OFFSET = 8;\n+    private static final long data$SIZE = 24;\n+    public static MemorySegment data$slice(MemorySegment seg) {\n+        return seg.asSlice(data$OFFSET, data$SIZE);\n+    }\n+    public static long sizeof() { return $LAYOUT().byteSize(); }\n+    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }\n+    public static MemorySegment allocateArray(long len, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));\n+    }\n+    public static MemorySegment ofAddress(MemorySegment addr, Arena scope) {\n+        return addr.reinterpret($LAYOUT().byteSize(), scope, null);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXCursor.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -339,1 +339,4 @@\n-            TreeMaker treeMaker = new TreeMaker(MacroParserImpl.this.treeMaker);\n+            \/\/ note: cursors returned during reparsing are not comparable with existing ones.\n+            \/\/ Because of that, here we create a brand new tree maker, which means pointers to already declared types\n+            \/\/ (e.g. structs, unions, enums) will be downgraded to void*.\n+            TreeMaker treeMaker = new TreeMaker();\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/MacroParserImpl.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-        this.treeMaker = new TreeMaker(null);\n+        this.treeMaker = new TreeMaker();\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Parser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n@@ -66,5 +68,1 @@\n-    record CursorKey(Position position, String spelling) {\n-        static CursorKey of(Cursor cursor) {\n-            return new CursorKey(CursorPosition.of(cursor), cursor.spelling());\n-        }\n-    }\n+    private final Map<Cursor.Key, Declaration> declarationCache = new HashMap<>();\n@@ -72,6 +70,1 @@\n-    private final TreeMaker parent;\n-    private final Map<CursorKey, Declaration> declarationCache = new HashMap<>();\n-\n-    public TreeMaker(TreeMaker parent) {\n-        this.parent = parent;\n-    }\n+    public TreeMaker() { }\n@@ -94,5 +87,2 @@\n-    public Optional<Declaration> lookup(CursorKey key) {\n-        Declaration declaration = declarationCache.get(key);\n-        return (declaration == null && parent != null) ?\n-                parent.lookup(key) :\n-                Optional.ofNullable(declaration);\n+    public Optional<Declaration> lookup(Cursor.Key key) {\n+        return Optional.ofNullable(declarationCache.get(key));\n@@ -135,1 +125,1 @@\n-        CursorKey key = CursorKey.of(c);\n+        Cursor.Key key = c.toKey();\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeMaker.java","additions":7,"deletions":17,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import org.openjdk.jextract.Position;\n@@ -40,0 +39,1 @@\n+import org.openjdk.jextract.clang.Cursor;\n@@ -41,1 +41,0 @@\n-import org.openjdk.jextract.impl.TreeMaker.CursorPosition;\n@@ -138,1 +137,2 @@\n-                    TreeMaker.CursorKey key = TreeMaker.CursorKey.of(pointee.getDeclarationCursor());\n+                    Cursor declCursor = pointee.getDeclarationCursor();\n+                    Cursor.Key key = declCursor.toKey();\n@@ -142,2 +142,2 @@\n-                            \/\/ no declaration, maybe an opaque type, return an error type\n-                            return Type.error(key.spelling());\n+                            \/\/ no declaration, maybe an opaque type, give up and downgrade to void pointer\n+                            return Type.void_();\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypeMaker.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+import test.jextract.dedup.*;\n+\n+import java.lang.foreign.GroupLayout;\n+\n+\/*\n+ * @test id=classes\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.dedup macro_fields.h\n+ * @build TestDedup\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestDedup\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library \/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.dedup macro_fields.h\n+ * @build TestDedup\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestDedup\n+ *\/\n+public class TestDedup {\n+\n+    @Test\n+    public void testMacroFields() {\n+        checkLayout(PointA.$LAYOUT());\n+        checkLayout(PointB.$LAYOUT());\n+    }\n+\n+    void checkLayout(GroupLayout layout) {\n+        assertEquals(layout.memberLayouts().get(0), macro_fields_h.C_INT.withName(\"x\"));\n+        assertEquals(layout.memberLayouts().get(1), macro_fields_h.C_INT.withName(\"y\"));\n+    }\n+}\n","filename":"test\/jtreg\/generator\/dedup\/TestDedup.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#define FIELDS \\\n+int x; \\\n+int y;\n+\n+struct PointA {\n+   FIELDS\n+};\n+\n+struct PointB {\n+   FIELDS\n+};\n","filename":"test\/jtreg\/generator\/dedup\/macro_fields.h","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -56,1 +56,1 @@\n-        checkConstant(badMacro, \"NO_FOO\", Type.pointer(Type.declared(foo)), 0L);\n+        checkConstant(badMacro, \"NO_FOO\", Type.pointer(), 0L);\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/api\/TestMacros.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}