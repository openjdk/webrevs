{"files":[{"patch":"@@ -0,0 +1,2 @@\n+OPENBLAS_HOME=\/usr\/local\/opt\/openblas\n+\n@@ -2,1 +4,2 @@\n-  -l openblas -t blas \/usr\/local\/opt\/openblas\/include\/cblas.h\n+  -l :${OPENBLAS_HOME}\/lib\/libopenblas.dylib -t blas \\\n+  ${OPENBLAS_HOME}\/include\/cblas.h\n","filename":"samples\/cblas\/compilesource.sh","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,3 +1,1 @@\n-java --enable-native-access=ALL-UNNAMED \\\n-    -Djava.library.path=\/usr\/local\/opt\/openblas\/lib \\\n-    TestBlas.java\n+java --enable-native-access=ALL-UNNAMED TestBlas.java\n","filename":"samples\/cblas\/run.sh","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,2 @@\n-rm -rf build\n+rm -rf org\n+rm -rf src\n","filename":"samples\/cleanall.sh","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,2 +1,1 @@\n-java --enable-native-access=ALL-UNNAMED \\\n-   Dlopen.java $*\n+java --enable-native-access=ALL-UNNAMED Dlopen.java $*\n","filename":"samples\/dlopen\/run.sh","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,2 @@\n+LAPACK_HOME=\/usr\/local\/opt\/lapack\n+\n@@ -2,2 +4,3 @@\n-   -l lapacke -t lapack \\\n-   \/usr\/local\/opt\/lapack\/include\/lapacke.h \n+   -l :${LAPACK_HOME}\/lib\/liblapacke.dylib \\\n+   -t lapack \\\n+   ${LAPACK_HOME}\/include\/lapacke.h \n","filename":"samples\/lapack\/compilesource.sh","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,3 +1,1 @@\n-java --enable-native-access=ALL-UNNAMED \\\n-    -Djava.library.path=\/usr\/local\/opt\/lapack\/lib \\\n-    TestLapack.java\n+java --enable-native-access=ALL-UNNAMED TestLapack.java\n","filename":"samples\/lapack\/run.sh","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,2 @@\n-jextract --output src -t org.llvm.clang -lclang \\\n+jextract --output src -t org.llvm.clang \\\n+  -l :${LIBCLANG_HOME}\/lib\/libclang.dylib \\\n","filename":"samples\/libclang\/compilesource.sh","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,2 +1,1 @@\n-java -Djava.library.path=${LIBCLANG_HOME}\/lib --enable-native-access=ALL-UNNAMED \\\n-    ASTPrinter.java $*\n+java --enable-native-access=ALL-UNNAMED ASTPrinter.java $*\n","filename":"samples\/libclang\/run.sh","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,1 +46,3 @@\n-               curl_easy_setopt.invoke(curl, CURLOPT_URL(), url.address());\n+               curl_easy_setopt.\n+                   makeInvoker(C_LONG_LONG).\n+                   apply(curl, CURLOPT_URL(), url.address());\n","filename":"samples\/libcurl\/CurlMain.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,2 +1,1 @@\n-java --enable-native-access=ALL-UNNAMED \\\n-    -Djava.library.path=\/usr\/lib CurlMain.java $*\n+java --enable-native-access=ALL-UNNAMED CurlMain.java $*\n","filename":"samples\/libcurl\/run.sh","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,2 @@\n+FFMPEG_HOME=\/usr\/local\/Cellar\/ffmpeg@4\/4.4.4_4\n+\n@@ -2,5 +4,5 @@\n-  -I \/usr\/local\/Cellar\/ffmpeg@4\/4.4.4_4\/include \\\n-  -l avcodec \\\n-  -l avformat \\\n-  -l avutil \\\n-  -l swscale \\\n+  -I ${FFMPEG_HOME}\/include \\\n+  -l :${FFMPEG_HOME}\/lib\/libavcodec.dylib \\\n+  -l :${FFMPEG_HOME}\/lib\/libavformat.dylib \\\n+  -l :${FFMPEG_HOME}\/lib\/libavutil.dylib \\\n+  -l :${FFMPEG_HOME}\/lib\/libswscale.dylib \\\n","filename":"samples\/libffmpeg\/compilesource.sh","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,2 +1,1 @@\n-java --enable-native-access=ALL-UNNAMED \\\n-   -Djava.library.path=\/usr\/local\/Cellar\/ffmpeg@4\/4.4.4_4\/lib LibffmpegMain.java $*\n+java --enable-native-access=ALL-UNNAMED LibffmpegMain.java $*\n","filename":"samples\/libffmpeg\/run.sh","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,2 @@\n-jextract --output src -t com.github -lgit2 \\\n+jextract --output src -t com.github \\\n+  -l :${LIBGIT2_HOME}\/build\/libgit2.dylib \\\n","filename":"samples\/libgit2\/compilesource.sh","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,4 +1,1 @@\n-java --enable-native-access=ALL-UNNAMED \\\n-    --enable-preview --source=22 \\\n-    -Djava.library.path=${LIBGIT2_HOME}\/build\/ \\\n-    GitClone.java $*\n+java --enable-native-access=ALL-UNNAMED GitClone.java $*\n","filename":"samples\/libgit2\/run.sh","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -5,12 +5,0 @@\n-\n-libjimage.dylib\/libjimages.so\/jimage.dll is loaded by boot loader.\n-So an application cannot load this using System.loadLibrary\/.load. This\n-is because System.loadLibrary\/.load is classloader based. Two or more\n-classloaders cannot share a native library. While this is needed for type\n-safety of JNI (Java Native Interface) based native libraries, Panama libraries\n-need not have this restriction. This sample demonstrates using platform native\n-dlopen\/dlsym to load & use libjimage.dylib from a Java application.\n-\n-extract.sh script was used to jextract jimage.h and dlfcn.h. These two extracted\n-libraries are used together in this project to access libjimage.dylib functions\n-from a Java app.\n","filename":"samples\/libjimage\/README.md","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,1 +1,7 @@\n-javac -d build --source=22 org\/openjdk\/*.java\n+jextract \\\n+  --output src \\\n+  -l jimage \\\n+  -t org.openjdk \\\n+  jimage.h\n+\n+javac --source=22 -d . src\/org\/openjdk\/*.java\n","filename":"samples\/libjimage\/compilesource.sh","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,3 +0,0 @@\n-jextract \\\n-  -t org.openjdk \\\n-  jimage.h\n","filename":"samples\/libjimage\/extract.sh","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,57 +0,0 @@\n-\/\/ Generated by jextract\n-\n-package org.openjdk;\n-\n-import java.lang.invoke.*;\n-import java.lang.foreign.*;\n-import java.nio.ByteOrder;\n-import java.util.*;\n-import java.util.function.*;\n-import java.util.stream.*;\n-\n-import static java.lang.foreign.ValueLayout.*;\n-import static java.lang.foreign.MemoryLayout.PathElement.*;\n-\n-\/**\n- * {@snippet lang=c :\n- * JImageResourceVisitor_t visitor\n- * }\n- *\/\n-public class JIMAGE_ResourceIterator$visitor {\n-\n-    public interface Function {\n-        int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6);\n-    }\n-\n-    private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-        jimage_h.C_INT,\n-        jimage_h.C_POINTER,\n-        jimage_h.C_POINTER,\n-        jimage_h.C_POINTER,\n-        jimage_h.C_POINTER,\n-        jimage_h.C_POINTER,\n-        jimage_h.C_POINTER,\n-        jimage_h.C_POINTER\n-    );\n-\n-    public static FunctionDescriptor descriptor() {\n-        return $DESC;\n-    }\n-\n-    private static final MethodHandle UP$MH = jimage_h.upcallHandle(JIMAGE_ResourceIterator$visitor.Function.class, \"apply\", $DESC);\n-\n-    public static MemorySegment allocate(JIMAGE_ResourceIterator$visitor.Function fi, Arena scope) {\n-        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n-    }\n-\n-    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-    public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6) {\n-        try {\n-            return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-}\n-\n","filename":"samples\/libjimage\/org\/openjdk\/JIMAGE_ResourceIterator$visitor.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/\/ Generated by jextract\n-\n-package org.openjdk;\n-\n-import java.lang.invoke.*;\n-import java.lang.foreign.*;\n-import java.nio.ByteOrder;\n-import java.util.*;\n-import java.util.function.*;\n-import java.util.stream.*;\n-\n-import static java.lang.foreign.ValueLayout.*;\n-import static java.lang.foreign.MemoryLayout.PathElement.*;\n-\n-\/**\n- * {@snippet lang=c :\n- * typedef void (*JImageClose_t)(JImageFile *)\n- * }\n- *\/\n-public class JImageClose_t {\n-\n-    public interface Function {\n-        void apply(MemorySegment jimage);\n-    }\n-\n-    private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-        jimage_h.C_POINTER\n-    );\n-\n-    public static FunctionDescriptor descriptor() {\n-        return $DESC;\n-    }\n-\n-    private static final MethodHandle UP$MH = jimage_h.upcallHandle(JImageClose_t.Function.class, \"apply\", $DESC);\n-\n-    public static MemorySegment allocate(JImageClose_t.Function fi, Arena scope) {\n-        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n-    }\n-\n-    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-    public static void invoke(MemorySegment funcPtr,MemorySegment jimage) {\n-        try {\n-             DOWN$MH.invokeExact(funcPtr, jimage);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-}\n-\n","filename":"samples\/libjimage\/org\/openjdk\/JImageClose_t.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/\/ Generated by jextract\n-\n-package org.openjdk;\n-\n-import java.lang.invoke.*;\n-import java.lang.foreign.*;\n-import java.nio.ByteOrder;\n-import java.util.*;\n-import java.util.function.*;\n-import java.util.stream.*;\n-\n-import static java.lang.foreign.ValueLayout.*;\n-import static java.lang.foreign.MemoryLayout.PathElement.*;\n-\n-\/**\n- * {@snippet lang=c :\n- * typedef JImageLocationRef (*JImageFindResource_t)(JImageFile *, const char *, const char *, const char *, jlong *)\n- * }\n- *\/\n-public class JImageFindResource_t {\n-\n-    public interface Function {\n-        long apply(MemorySegment jimage, MemorySegment module_name, MemorySegment version, MemorySegment name, MemorySegment size);\n-    }\n-\n-    private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-        jimage_h.C_LONG_LONG,\n-        jimage_h.C_POINTER,\n-        jimage_h.C_POINTER,\n-        jimage_h.C_POINTER,\n-        jimage_h.C_POINTER,\n-        jimage_h.C_POINTER\n-    );\n-\n-    public static FunctionDescriptor descriptor() {\n-        return $DESC;\n-    }\n-\n-    private static final MethodHandle UP$MH = jimage_h.upcallHandle(JImageFindResource_t.Function.class, \"apply\", $DESC);\n-\n-    public static MemorySegment allocate(JImageFindResource_t.Function fi, Arena scope) {\n-        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n-    }\n-\n-    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-    public static long invoke(MemorySegment funcPtr,MemorySegment jimage, MemorySegment module_name, MemorySegment version, MemorySegment name, MemorySegment size) {\n-        try {\n-            return (long) DOWN$MH.invokeExact(funcPtr, jimage, module_name, version, name, size);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-}\n-\n","filename":"samples\/libjimage\/org\/openjdk\/JImageFindResource_t.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/\/ Generated by jextract\n-\n-package org.openjdk;\n-\n-import java.lang.invoke.*;\n-import java.lang.foreign.*;\n-import java.nio.ByteOrder;\n-import java.util.*;\n-import java.util.function.*;\n-import java.util.stream.*;\n-\n-import static java.lang.foreign.ValueLayout.*;\n-import static java.lang.foreign.MemoryLayout.PathElement.*;\n-\n-\/**\n- * {@snippet lang=c :\n- * typedef jlong (*JImageGetResource_t)(JImageFile *, JImageLocationRef, char *, jlong)\n- * }\n- *\/\n-public class JImageGetResource_t {\n-\n-    public interface Function {\n-        long apply(MemorySegment jimage, long location, MemorySegment buffer, long size);\n-    }\n-\n-    private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-        jimage_h.C_LONG_LONG,\n-        jimage_h.C_POINTER,\n-        jimage_h.C_LONG_LONG,\n-        jimage_h.C_POINTER,\n-        jimage_h.C_LONG_LONG\n-    );\n-\n-    public static FunctionDescriptor descriptor() {\n-        return $DESC;\n-    }\n-\n-    private static final MethodHandle UP$MH = jimage_h.upcallHandle(JImageGetResource_t.Function.class, \"apply\", $DESC);\n-\n-    public static MemorySegment allocate(JImageGetResource_t.Function fi, Arena scope) {\n-        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n-    }\n-\n-    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-    public static long invoke(MemorySegment funcPtr,MemorySegment jimage, long location, MemorySegment buffer, long size) {\n-        try {\n-            return (long) DOWN$MH.invokeExact(funcPtr, jimage, location, buffer, size);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-}\n-\n","filename":"samples\/libjimage\/org\/openjdk\/JImageGetResource_t.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/\/ Generated by jextract\n-\n-package org.openjdk;\n-\n-import java.lang.invoke.*;\n-import java.lang.foreign.*;\n-import java.nio.ByteOrder;\n-import java.util.*;\n-import java.util.function.*;\n-import java.util.stream.*;\n-\n-import static java.lang.foreign.ValueLayout.*;\n-import static java.lang.foreign.MemoryLayout.PathElement.*;\n-\n-\/**\n- * {@snippet lang=c :\n- * typedef JImageFile *(*JImageOpen_t)(const char *, jint *)\n- * }\n- *\/\n-public class JImageOpen_t {\n-\n-    public interface Function {\n-        MemorySegment apply(MemorySegment name, MemorySegment error);\n-    }\n-\n-    private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-        jimage_h.C_POINTER,\n-        jimage_h.C_POINTER,\n-        jimage_h.C_POINTER\n-    );\n-\n-    public static FunctionDescriptor descriptor() {\n-        return $DESC;\n-    }\n-\n-    private static final MethodHandle UP$MH = jimage_h.upcallHandle(JImageOpen_t.Function.class, \"apply\", $DESC);\n-\n-    public static MemorySegment allocate(JImageOpen_t.Function fi, Arena scope) {\n-        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n-    }\n-\n-    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-    public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment name, MemorySegment error) {\n-        try {\n-            return (MemorySegment) DOWN$MH.invokeExact(funcPtr, name, error);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-}\n-\n","filename":"samples\/libjimage\/org\/openjdk\/JImageOpen_t.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/\/ Generated by jextract\n-\n-package org.openjdk;\n-\n-import java.lang.invoke.*;\n-import java.lang.foreign.*;\n-import java.nio.ByteOrder;\n-import java.util.*;\n-import java.util.function.*;\n-import java.util.stream.*;\n-\n-import static java.lang.foreign.ValueLayout.*;\n-import static java.lang.foreign.MemoryLayout.PathElement.*;\n-\n-\/**\n- * {@snippet lang=c :\n- * typedef const char *(*JImagePackageToModule_t)(JImageFile *, const char *)\n- * }\n- *\/\n-public class JImagePackageToModule_t {\n-\n-    public interface Function {\n-        MemorySegment apply(MemorySegment jimage, MemorySegment package_name);\n-    }\n-\n-    private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-        jimage_h.C_POINTER,\n-        jimage_h.C_POINTER,\n-        jimage_h.C_POINTER\n-    );\n-\n-    public static FunctionDescriptor descriptor() {\n-        return $DESC;\n-    }\n-\n-    private static final MethodHandle UP$MH = jimage_h.upcallHandle(JImagePackageToModule_t.Function.class, \"apply\", $DESC);\n-\n-    public static MemorySegment allocate(JImagePackageToModule_t.Function fi, Arena scope) {\n-        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n-    }\n-\n-    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-    public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment jimage, MemorySegment package_name) {\n-        try {\n-            return (MemorySegment) DOWN$MH.invokeExact(funcPtr, jimage, package_name);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-}\n-\n","filename":"samples\/libjimage\/org\/openjdk\/JImagePackageToModule_t.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/\/ Generated by jextract\n-\n-package org.openjdk;\n-\n-import java.lang.invoke.*;\n-import java.lang.foreign.*;\n-import java.nio.ByteOrder;\n-import java.util.*;\n-import java.util.function.*;\n-import java.util.stream.*;\n-\n-import static java.lang.foreign.ValueLayout.*;\n-import static java.lang.foreign.MemoryLayout.PathElement.*;\n-\n-\/**\n- * {@snippet lang=c :\n- * typedef void (*JImageResourceIterator_t)(JImageFile *, JImageResourceVisitor_t, void *)\n- * }\n- *\/\n-public class JImageResourceIterator_t {\n-\n-    public interface Function {\n-        void apply(MemorySegment jimage, MemorySegment visitor, MemorySegment arg);\n-    }\n-\n-    private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-        jimage_h.C_POINTER,\n-        jimage_h.C_POINTER,\n-        jimage_h.C_POINTER\n-    );\n-\n-    public static FunctionDescriptor descriptor() {\n-        return $DESC;\n-    }\n-\n-    private static final MethodHandle UP$MH = jimage_h.upcallHandle(JImageResourceIterator_t.Function.class, \"apply\", $DESC);\n-\n-    public static MemorySegment allocate(JImageResourceIterator_t.Function fi, Arena scope) {\n-        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n-    }\n-\n-    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-    public static void invoke(MemorySegment funcPtr,MemorySegment jimage, MemorySegment visitor, MemorySegment arg) {\n-        try {\n-             DOWN$MH.invokeExact(funcPtr, jimage, visitor, arg);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-}\n-\n","filename":"samples\/libjimage\/org\/openjdk\/JImageResourceIterator_t.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,57 +0,0 @@\n-\/\/ Generated by jextract\n-\n-package org.openjdk;\n-\n-import java.lang.invoke.*;\n-import java.lang.foreign.*;\n-import java.nio.ByteOrder;\n-import java.util.*;\n-import java.util.function.*;\n-import java.util.stream.*;\n-\n-import static java.lang.foreign.ValueLayout.*;\n-import static java.lang.foreign.MemoryLayout.PathElement.*;\n-\n-\/**\n- * {@snippet lang=c :\n- * typedef int (*JImageResourceVisitor_t)(JImageFile *, const char *, const char *, const char *, const char *, const char *, void *)\n- * }\n- *\/\n-public class JImageResourceVisitor_t {\n-\n-    public interface Function {\n-        int apply(MemorySegment jimage, MemorySegment module_name, MemorySegment version, MemorySegment package_, MemorySegment name, MemorySegment extension, MemorySegment arg);\n-    }\n-\n-    private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-        jimage_h.C_INT,\n-        jimage_h.C_POINTER,\n-        jimage_h.C_POINTER,\n-        jimage_h.C_POINTER,\n-        jimage_h.C_POINTER,\n-        jimage_h.C_POINTER,\n-        jimage_h.C_POINTER,\n-        jimage_h.C_POINTER\n-    );\n-\n-    public static FunctionDescriptor descriptor() {\n-        return $DESC;\n-    }\n-\n-    private static final MethodHandle UP$MH = jimage_h.upcallHandle(JImageResourceVisitor_t.Function.class, \"apply\", $DESC);\n-\n-    public static MemorySegment allocate(JImageResourceVisitor_t.Function fi, Arena scope) {\n-        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n-    }\n-\n-    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-    public static int invoke(MemorySegment funcPtr,MemorySegment jimage, MemorySegment module_name, MemorySegment version, MemorySegment package_, MemorySegment name, MemorySegment extension, MemorySegment arg) {\n-        try {\n-            return (int) DOWN$MH.invokeExact(funcPtr, jimage, module_name, version, package_, name, extension, arg);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-}\n-\n","filename":"samples\/libjimage\/org\/openjdk\/JImageResourceVisitor_t.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -1,368 +0,0 @@\n-\/\/ Generated by jextract\n-\n-package org.openjdk;\n-\n-import java.lang.invoke.*;\n-import java.lang.foreign.*;\n-import java.nio.ByteOrder;\n-import java.util.*;\n-import java.util.function.*;\n-import java.util.stream.*;\n-\n-import static java.lang.foreign.ValueLayout.*;\n-import static java.lang.foreign.MemoryLayout.PathElement.*;\n-\n-public class jimage_h {\n-\n-    static final SymbolLookup SYMBOL_LOOKUP;\n-    \/\/ manual change\n-    static {\n-        var libPath = System.getProperty(\"java.home\");\n-        var OS = System.getProperty(\"os.name\");\n-        if (OS.contains(\"Mac OS X\")) {\n-            libPath += \"\/lib\/libjimage.dylib\";\n-        } else if (OS.contains(\"Windows\")) {\n-            libPath = \"\/bin\/jimage.dll\";\n-        } else {\n-            libPath = \"\/lib\/libjimage.so\"; \/\/ some Unix\n-        }\n-        SymbolLookup loaderLookup = SymbolLookup.libraryLookup(libPath, Arena.global());\n-        SYMBOL_LOOKUP = name -> loaderLookup.find(name).or(() -> Linker.nativeLinker().defaultLookup().find(name));\n-    }\n-\n-    jimage_h() {\n-        \/\/ Suppresses public default constructor, ensuring non-instantiability,\n-        \/\/ but allows generated subclasses in same package.\n-    }\n-\n-    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n-    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n-    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n-    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n-    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n-    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n-    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n-    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS\n-            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));\n-    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;\n-\n-    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean(\"jextract.trace.downcalls\");\n-\n-    static void traceDowncall(String name, Object... args) {\n-         String traceArgs = Arrays.stream(args)\n-                       .map(Object::toString)\n-                       .collect(Collectors.joining(\", \"));\n-         System.out.printf(\"%s(%s)\\n\", name, traceArgs);\n-    }\n-\n-    static MemorySegment findOrThrow(String symbol) {\n-        return SYMBOL_LOOKUP.find(symbol)\n-            .orElseThrow(() -> new UnsatisfiedLinkError(\"unresolved symbol: \" + symbol));\n-    }\n-\n-    static MemoryLayout[] inferVariadicLayouts(Object[] varargs) {\n-        MemoryLayout[] result = new MemoryLayout[varargs.length];\n-        for (int i = 0; i < varargs.length; i++) {\n-            result[i] = variadicLayout(varargs[i].getClass());\n-        }\n-        return result;\n-    }\n-\n-    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n-        try {\n-            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());\n-        } catch (ReflectiveOperationException ex) {\n-            throw new AssertionError(ex);\n-        }\n-    }\n-\n-    static MethodHandle downcallHandleVariadic(String name, FunctionDescriptor baseDesc, MemoryLayout[] variadicLayouts) {\n-        FunctionDescriptor variadicDesc = baseDesc.appendArgumentLayouts(variadicLayouts);\n-        Linker.Option fva = Linker.Option.firstVariadicArg(baseDesc.argumentLayouts().size());\n-        return SYMBOL_LOOKUP.find(name)\n-                .map(addr -> Linker.nativeLinker().downcallHandle(addr, variadicDesc, fva)\n-                        .asSpreader(Object[].class, variadicLayouts.length))\n-                .orElse(null);\n-    }\n-\n-    \/\/ Internals only below this point\n-\n-    private static MemoryLayout variadicLayout(Class<?> c) {\n-        \/\/ apply default argument promotions per C spec\n-        \/\/ note that all primitives are boxed, since they are passed through an Object[]\n-        if (c == Boolean.class || c == Byte.class || c == Character.class || c == Short.class || c == Integer.class) {\n-            return JAVA_INT;\n-        } else if (c == Long.class) {\n-            return JAVA_LONG;\n-        } else if (c == Float.class || c == Double.class) {\n-            return JAVA_DOUBLE;\n-        } else if (MemorySegment.class.isAssignableFrom(c)) {\n-            return ADDRESS;\n-        }\n-        throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n-    }\n-    private static final int JIMAGE_MAX_PATH = (int)4096L;\n-\n-    \/**\n-     * {@snippet lang=c :\n-     * #define JIMAGE_MAX_PATH 4096\n-     * }\n-     *\/\n-    public static int JIMAGE_MAX_PATH() {\n-        return JIMAGE_MAX_PATH;\n-    }\n-    \/**\n-     * {@snippet lang=c :\n-     * typedef long long jlong\n-     * }\n-     *\/\n-    public static final OfLong jlong = jimage_h.C_LONG_LONG;\n-    \/**\n-     * {@snippet lang=c :\n-     * typedef int jint\n-     * }\n-     *\/\n-    public static final OfInt jint = jimage_h.C_INT;\n-    \/**\n-     * {@snippet lang=c :\n-     * typedef jlong JImageLocationRef\n-     * }\n-     *\/\n-    public static final OfLong JImageLocationRef = jimage_h.C_LONG_LONG;\n-\n-    public static MethodHandle JIMAGE_Open$MH() {\n-        class Holder {\n-            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n-                jimage_h.C_POINTER,\n-                jimage_h.C_POINTER,\n-                jimage_h.C_POINTER\n-            );\n-\n-            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n-                    jimage_h.findOrThrow(\"JIMAGE_Open\"),\n-                    DESC);\n-        }\n-        return Holder.MH;\n-    }\n-\n-    \/**\n-     * {@snippet lang=c :\n-     * JImageFile *JIMAGE_Open(const char *name, jint *error)\n-     * }\n-     *\/\n-    public static MemorySegment JIMAGE_Open(MemorySegment name, MemorySegment error) {\n-        var mh$ = JIMAGE_Open$MH();\n-        try {\n-            if (TRACE_DOWNCALLS) {\n-                traceDowncall(\"JIMAGE_Open\", name, error);\n-            }\n-            return (MemorySegment) mh$.invokeExact(name, error);\n-        } catch (Throwable ex$) {\n-           throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-\n-    public static MethodHandle JIMAGE_Close$MH() {\n-        class Holder {\n-            static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n-                jimage_h.C_POINTER\n-            );\n-\n-            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n-                    jimage_h.findOrThrow(\"JIMAGE_Close\"),\n-                    DESC);\n-        }\n-        return Holder.MH;\n-    }\n-\n-    \/**\n-     * {@snippet lang=c :\n-     * void JIMAGE_Close(JImageFile *jimage)\n-     * }\n-     *\/\n-    public static void JIMAGE_Close(MemorySegment jimage) {\n-        var mh$ = JIMAGE_Close$MH();\n-        try {\n-            if (TRACE_DOWNCALLS) {\n-                traceDowncall(\"JIMAGE_Close\", jimage);\n-            }\n-            mh$.invokeExact(jimage);\n-        } catch (Throwable ex$) {\n-           throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-\n-    public static MethodHandle JIMAGE_PackageToModule$MH() {\n-        class Holder {\n-            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n-                jimage_h.C_POINTER,\n-                jimage_h.C_POINTER,\n-                jimage_h.C_POINTER\n-            );\n-\n-            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n-                    jimage_h.findOrThrow(\"JIMAGE_PackageToModule\"),\n-                    DESC);\n-        }\n-        return Holder.MH;\n-    }\n-\n-    \/**\n-     * {@snippet lang=c :\n-     * const char *JIMAGE_PackageToModule(JImageFile *jimage, const char *package_name)\n-     * }\n-     *\/\n-    public static MemorySegment JIMAGE_PackageToModule(MemorySegment jimage, MemorySegment package_name) {\n-        var mh$ = JIMAGE_PackageToModule$MH();\n-        try {\n-            if (TRACE_DOWNCALLS) {\n-                traceDowncall(\"JIMAGE_PackageToModule\", jimage, package_name);\n-            }\n-            return (MemorySegment) mh$.invokeExact(jimage, package_name);\n-        } catch (Throwable ex$) {\n-           throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-\n-    public static MethodHandle JIMAGE_FindResource$MH() {\n-        class Holder {\n-            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n-                jimage_h.C_LONG_LONG,\n-                jimage_h.C_POINTER,\n-                jimage_h.C_POINTER,\n-                jimage_h.C_POINTER,\n-                jimage_h.C_POINTER,\n-                jimage_h.C_POINTER\n-            );\n-\n-            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n-                    jimage_h.findOrThrow(\"JIMAGE_FindResource\"),\n-                    DESC);\n-        }\n-        return Holder.MH;\n-    }\n-\n-    \/**\n-     * {@snippet lang=c :\n-     * JImageLocationRef JIMAGE_FindResource(JImageFile *jimage, const char *module_name, const char *version, const char *name, jlong *size)\n-     * }\n-     *\/\n-    public static long JIMAGE_FindResource(MemorySegment jimage, MemorySegment module_name, MemorySegment version, MemorySegment name, MemorySegment size) {\n-        var mh$ = JIMAGE_FindResource$MH();\n-        try {\n-            if (TRACE_DOWNCALLS) {\n-                traceDowncall(\"JIMAGE_FindResource\", jimage, module_name, version, name, size);\n-            }\n-            return (long) mh$.invokeExact(jimage, module_name, version, name, size);\n-        } catch (Throwable ex$) {\n-           throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-\n-    public static MethodHandle JIMAGE_GetResource$MH() {\n-        class Holder {\n-            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n-                jimage_h.C_LONG_LONG,\n-                jimage_h.C_POINTER,\n-                jimage_h.C_LONG_LONG,\n-                jimage_h.C_POINTER,\n-                jimage_h.C_LONG_LONG\n-            );\n-\n-            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n-                    jimage_h.findOrThrow(\"JIMAGE_GetResource\"),\n-                    DESC);\n-        }\n-        return Holder.MH;\n-    }\n-\n-    \/**\n-     * {@snippet lang=c :\n-     * jlong JIMAGE_GetResource(JImageFile *jimage, JImageLocationRef location, char *buffer, jlong size)\n-     * }\n-     *\/\n-    public static long JIMAGE_GetResource(MemorySegment jimage, long location, MemorySegment buffer, long size) {\n-        var mh$ = JIMAGE_GetResource$MH();\n-        try {\n-            if (TRACE_DOWNCALLS) {\n-                traceDowncall(\"JIMAGE_GetResource\", jimage, location, buffer, size);\n-            }\n-            return (long) mh$.invokeExact(jimage, location, buffer, size);\n-        } catch (Throwable ex$) {\n-           throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-\n-    public static MethodHandle JIMAGE_ResourceIterator$MH() {\n-        class Holder {\n-            static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n-                jimage_h.C_POINTER,\n-                jimage_h.C_POINTER,\n-                jimage_h.C_POINTER\n-            );\n-\n-            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n-                    jimage_h.findOrThrow(\"JIMAGE_ResourceIterator\"),\n-                    DESC);\n-        }\n-        return Holder.MH;\n-    }\n-\n-    \/**\n-     * {@snippet lang=c :\n-     * void JIMAGE_ResourceIterator(JImageFile *jimage, JImageResourceVisitor_t visitor, void *arg)\n-     * }\n-     *\/\n-    public static void JIMAGE_ResourceIterator(MemorySegment jimage, MemorySegment visitor, MemorySegment arg) {\n-        var mh$ = JIMAGE_ResourceIterator$MH();\n-        try {\n-            if (TRACE_DOWNCALLS) {\n-                traceDowncall(\"JIMAGE_ResourceIterator\", jimage, visitor, arg);\n-            }\n-            mh$.invokeExact(jimage, visitor, arg);\n-        } catch (Throwable ex$) {\n-           throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-    private static final int JIMAGE_NOT_FOUND = (int)0L;\n-\n-    \/**\n-     * {@snippet lang=c :\n-     * #define JIMAGE_NOT_FOUND 0\n-     * }\n-     *\/\n-    public static int JIMAGE_NOT_FOUND() {\n-        return JIMAGE_NOT_FOUND;\n-    }\n-    private static final int JIMAGE_BAD_MAGIC = (int)-1L;\n-\n-    \/**\n-     * {@snippet lang=c :\n-     * #define JIMAGE_BAD_MAGIC -1\n-     * }\n-     *\/\n-    public static int JIMAGE_BAD_MAGIC() {\n-        return JIMAGE_BAD_MAGIC;\n-    }\n-    private static final int JIMAGE_BAD_VERSION = (int)-2L;\n-\n-    \/**\n-     * {@snippet lang=c :\n-     * #define JIMAGE_BAD_VERSION -2\n-     * }\n-     *\/\n-    public static int JIMAGE_BAD_VERSION() {\n-        return JIMAGE_BAD_VERSION;\n-    }\n-    private static final int JIMAGE_CORRUPTED = (int)-3L;\n-\n-    \/**\n-     * {@snippet lang=c :\n-     * #define JIMAGE_CORRUPTED -3\n-     * }\n-     *\/\n-    public static int JIMAGE_CORRUPTED() {\n-        return JIMAGE_CORRUPTED;\n-    }\n-}\n-\n","filename":"samples\/libjimage\/org\/openjdk\/jimage_h.java","additions":0,"deletions":368,"binary":false,"changes":368,"status":"deleted"},{"patch":"@@ -1,3 +1,1 @@\n-java -cp build \\\n-   --enable-native-access=ALL-UNNAMED \\\n-   JImageFile.java\n+java --enable-native-access=ALL-UNNAMED JImageFile.java\n","filename":"samples\/libjimage\/run.sh","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,2 +1,1 @@\n-java --enable-native-access=ALL-UNNAMED \\\n-   -Djava.library.path=\/usr\/lib LibprocMain.java\n+java --enable-native-access=ALL-UNNAMED LibprocMain.java\n","filename":"samples\/libproc\/run.sh","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,2 @@\n+LIBZSTD_HOME=\/usr\/local\/Cellar\/zstd\/1.5.5\n+\n@@ -2,2 +4,2 @@\n-  -I \/usr\/local\/Cellar\/zstd\/1.5.5\/include \\\n-  -l zstd \\\n+  -I ${LIBZSTD_HOME}\/include \\\n+  -l :${LIBZSTD_HOME}\/lib\/libzstd.dylib \\\n@@ -5,1 +7,1 @@\n-  \/usr\/local\/Cellar\/zstd\/1.5.5\/include\/zstd.h\n+  ${LIBZSTD_HOME}\/include\/zstd.h\n","filename":"samples\/libzstd\/compilesource.sh","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,2 +1,1 @@\n-java --enable-native-access=ALL-UNNAMED \\\n-   -Djava.library.path=\/usr\/local\/Cellar\/zstd\/1.5.5\/lib LibzstdMain.java\n+java --enable-native-access=ALL-UNNAMED LibzstdMain.java\n","filename":"samples\/libzstd\/run.sh","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,0 +3,2 @@\n+\n+LP_SOLVE_HOME=\/usr\/local\/Cellar\/lp_solve\/5.5.2.11\n@@ -7,2 +9,2 @@\n-  -l lpsolve55 \\\n-  \/usr\/local\/Cellar\/lp_solve\/5.5.2.11\/include\/lp_lib.h\n+  -l :${LP_SOLVE_HOME}\/lib\/liblpsolve55.dylib \\\n+  ${LP_SOLVE_HOME}\/include\/lp_lib.h\n","filename":"samples\/lp_solve\/compilesource.sh","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,3 +1,1 @@\n-java --enable-native-access=ALL-UNNAMED \\\n-   -Djava.library.path=\/usr\/local\/Cellar\/lp_solve\/5.5.2.11\/lib \\\n-    LpSolveDemo.java\n+java --enable-native-access=ALL-UNNAMED LpSolveDemo.java\n","filename":"samples\/lp_solve\/run.sh","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,2 +1,1 @@\n-java --enable-native-access=ALL-UNNAMED \\\n-    -Djava.library.path=\/usr\/local\/opt\/pcre2\/lib PcreCheck.java $*\n+java --enable-native-access=ALL-UNNAMED PcreCheck.java $*\n","filename":"samples\/pcre2\/run.sh","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5,1 +5,2 @@\n-jextract --output src -l python3.11 \\\n+jextract --output src \\\n+  -l :${ANACONDA3_HOME}\/lib\/libpython3.11.dylib \\\n","filename":"samples\/python3\/compilesource.sh","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,7 +1,1 @@\n-if [[ -z \"${ANACONDA3_HOME}\" ]]; then\n-    ANACONDA3_HOME=\/opt\/anaconda3\n-fi\n-\n-java --enable-native-access=ALL-UNNAMED \\\n-    -Djava.library.path=${ANACONDA3_HOME}\/lib \\\n-    PythonMain.java\n+java --enable-native-access=ALL-UNNAMED PythonMain.java\n","filename":"samples\/python3\/run.sh","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,3 +2,1 @@\n-java --enable-native-access=ALL-UNNAMED \\\n-    -Djava.library.path=\/usr\/local\/opt\/readline\/lib\/ Readline.java\n-\n+java --enable-native-access=ALL-UNNAMED Readline.java\n","filename":"samples\/readline\/run.sh","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-   -Djava.library.path=\/usr\/lib SqliteMain.java\n+   SqliteMain.java\n","filename":"samples\/sqlite\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n-    -Djava.library.path=\/usr\/lib \\\n","filename":"samples\/tcl\/run.sh","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,1 +4,2 @@\n-  -l ${LIBTENSORFLOW_HOME}\/lib\/libtensorflow.dylib \\\n+  -l :${LIBTENSORFLOW_HOME}\/lib\/libtensorflow.dylib \\\n+  --use-system-load-library \\\n","filename":"samples\/tensorflow\/compilesource.sh","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,3 +1,1 @@\n-\n-java --enable-native-access=ALL-UNNAMED \\\n-    PanamaTime.java\n+java --enable-native-access=ALL-UNNAMED PanamaTime.java\n","filename":"samples\/time\/run.sh","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}