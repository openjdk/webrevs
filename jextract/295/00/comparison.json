{"files":[{"patch":"@@ -148,1 +148,1 @@\n-                        options.sharedClassName));\n+                        options.libraryPathResolver, options.sharedClassName));\n@@ -376,0 +376,1 @@\n+        parser.accepts(\"--library-path-resolver\", \"help.library.path.resolver\", true);\n@@ -467,0 +468,10 @@\n+        if (optionSet.has(\"--library-path-resolver\")) {\n+            String resolver = optionSet.valueOf(\"--library-path-resolver\");\n+            assert resolver != null;\n+            if (resolver.indexOf('#') == -1) {\n+                logger.err(\"jextract.library.path.resolver.format.error\");\n+                return OPTION_ERROR;\n+            }\n+            builder.setLibraryPathResolver(resolver);\n+        }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/JextractTool.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -312,1 +312,2 @@\n-    void emitFirstHeaderPreamble(List<Options.Library> libraries, boolean useSystemLoadLibrary) {\n+    void emitFirstHeaderPreamble(List<Options.Library> libraries,\n+                                 boolean useSystemLoadLibrary, String libraryPathResolver) {\n@@ -323,2 +324,10 @@\n-                String method = lib.specKind() == Options.Library.SpecKind.PATH ? \"load\" : \"loadLibrary\";\n-                appendIndentedLines(\"System.%1$s(\\\"%2$s\\\");\", method, lib.toQuotedName());\n+                if (lib.specKind() == Options.Library.SpecKind.PATH) {\n+                    appendIndentedLines(\"System.load(\\\"%1$s\\\");\", lib.toQuotedName());\n+                } else {\n+                    if (libraryPathResolver != null && !libraryPathResolver.isEmpty()) {\n+                        String resolverMethodCall = libraryPathResolver.replace(\"#\", \".\");\n+                        appendIndentedLines(\"System.load(%1$s(\\\"%2$s\\\"));\", resolverMethodCall, lib.toQuotedName());\n+                    } else {\n+                        appendIndentedLines(\"System.loadLibrary(\\\"%1$s\\\");\", lib.toQuotedName());\n+                    }\n+                }\n@@ -333,3 +342,13 @@\n-                    .map(l -> l.specKind() == Options.Library.SpecKind.PATH ?\n-                            String.format(\"SymbolLookup.libraryLookup(\\\"%1$s\\\", LIBRARY_ARENA)\", l.toQuotedName()) :\n-                            String.format(\"SymbolLookup.libraryLookup(System.mapLibraryName(\\\"%1$s\\\"), LIBRARY_ARENA)\", l.toQuotedName()))\n+                    .map(l -> {\n+                        if (l.specKind() == Options.Library.SpecKind.PATH) {\n+                            return String.format(\"SymbolLookup.libraryLookup(\\\"%1$s\\\", LIBRARY_ARENA)\", l.toQuotedName());\n+                        }\n+\n+                        if (libraryPathResolver != null && !libraryPathResolver.isEmpty()) {\n+                            String resolverMethodCall = libraryPathResolver.replace(\"#\", \".\");\n+                            return String.format(\"SymbolLookup.libraryLookup(%1$s(\\\"%2$s\\\"), LIBRARY_ARENA)\",\n+                                                 resolverMethodCall, l.toQuotedName());\n+                        }\n+\n+                        return String.format(\"SymbolLookup.libraryLookup(System.mapLibraryName(\\\"%1$s\\\"), LIBRARY_ARENA)\", l.toQuotedName());\n+                    })\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+    \/\/ The custom library path resolver (Format: Class#method)\n+    public final String libraryPathResolver;\n@@ -46,1 +48,1 @@\n-                    String targetPackage, String outputDir, String sharedClassName,\n+                    String libraryPathResolver, String targetPackage, String outputDir, String sharedClassName,\n@@ -51,0 +53,1 @@\n+        this.libraryPathResolver = libraryPathResolver;\n@@ -65,0 +68,1 @@\n+        private String libraryPathResolver;\n@@ -76,0 +80,1 @@\n+            this.libraryPathResolver = null;\n@@ -83,1 +88,1 @@\n-                    useSystemLoadLibrary, targetPackage, outputDir, sharedClassName, includeHelper\n+                    useSystemLoadLibrary, libraryPathResolver, targetPackage, outputDir, sharedClassName, includeHelper\n@@ -99,0 +104,4 @@\n+        public void setLibraryPathResolver(String libraryPathResolver) {\n+            this.libraryPathResolver = libraryPathResolver;\n+        }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Options.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+                                                   String libraryPathResolver,\n@@ -53,1 +54,1 @@\n-                libs, useSystemLoadLibrary, sharedClassName);\n+                libs, useSystemLoadLibrary, libraryPathResolver, sharedClassName);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-                    boolean useSystemLoadLibrary, String sharedClassName) {\n+                    boolean useSystemLoadLibrary, String libraryPathResolver, String sharedClassName) {\n@@ -62,1 +62,1 @@\n-        initFirstHeader(libs, useSystemLoadLibrary);\n+        initFirstHeader(libs, useSystemLoadLibrary, libraryPathResolver);\n@@ -74,1 +74,1 @@\n-    private void initFirstHeader(List<Options.Library> libs, boolean useSystemLoadLibrary) {\n+    private void initFirstHeader(List<Options.Library> libs, boolean useSystemLoadLibrary, String libraryPathResolver) {\n@@ -86,1 +86,1 @@\n-        lastHeader.emitFirstHeaderPreamble(libs, useSystemLoadLibrary);\n+        lastHeader.emitFirstHeaderPreamble(libs, useSystemLoadLibrary, libraryPathResolver);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ToplevelBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+help.library.path.resolver=specify a static method to resolve library paths\n@@ -84,0 +85,4 @@\n+--library-path-resolver <method>   specify a static method to resolve library paths.            \\n\\\n+\\                                   The method must match the signature:                        \\n\\\n+\\                                   'String method(String libName)'.                            \\n\\\n+\\                                   Format: <package>.<class>#<method>                          \\n\\\n@@ -135,0 +140,3 @@\n+\n+jextract.library.path.resolver.format.error=\\\n+Invalid format for --library-path-resolver. Expected format: 'package.ClassName#methodName'\n\\ No newline at end of file\n","filename":"src\/main\/resources\/org\/openjdk\/jextract\/impl\/resources\/Messages.properties","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -20,0 +20,1 @@\n+    jtreg\/generator\/testLibraryPathResolver\/TestLibraryPathResolver.java \\\n","filename":"test\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+import testlib.JextractToolRunner;\n+import testlib.TestUtils;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+\/*\n+ * @test\n+ * @library \/lib\n+ * @build testlib.JextractToolRunner testlib.TestUtils\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestLibraryPathResolver\n+ *\/\n+public class TestLibraryPathResolver extends JextractToolRunner {\n+    @Test\n+    public void testCustomResolver() throws Throwable {\n+        Path outputDir = getOutputFilePath(\"libraryPathResolverTestGen\");\n+        Files.createDirectories(outputDir);\n+\n+        try {\n+            Path pathResolverSource = outputDir.resolve(\"test\/testLibraryPathResolver\/MyPathResolver.java\");\n+            Files.createDirectories(pathResolverSource.getParent());\n+\n+            String pathResolverContent = \"\"\"\n+                    package test.testLibraryPathResolver;\n+\n+                    import java.nio.file.Files;\n+                    import java.nio.file.Path;\n+                    import java.nio.file.Paths;\n+\n+                    public class MyPathResolver {\n+                        public static volatile boolean RESOLVER_CALLED = false;\n+\n+                        public static String resolve(String libName) {\n+                            System.out.println(\"MyTestLoader: Custom resolver called for library: \" + libName);\n+                            RESOLVER_CALLED = true;\n+\n+                            String mappedLibName = System.mapLibraryName(libName);\n+                            String javaLibraryPath = System.getProperty(\"java.library.path\");\n+\n+                            if (javaLibraryPath == null) return mappedLibName;\n+\n+                            String[] paths = javaLibraryPath.split(System.getProperty(\"path.separator\"));\n+                            for (String dir : paths) {\n+                                Path path = Paths.get(dir).resolve(mappedLibName);\n+                                if (Files.exists(path)) {\n+                                    return path.toAbsolutePath().toString();\n+                                }\n+                            }\n+\n+                            throw new UnsatisfiedLinkError(\"MyTestLoader: Could not find \" + mappedLibName);\n+                        }\n+                    }\n+                    \"\"\";\n+            Files.writeString(pathResolverSource, pathResolverContent);\n+\n+            Path headerFile = getInputFilePath(\"testLibraryPathResolver.h\");\n+            run(outputDir,\n+                \"-I\", headerFile.getParent().toString(),\n+                \"-t\", \"test.testLibraryPathResolver\",\n+                \"-l\", \"LibraryPathResolver\",\n+                \"--use-system-load-library\",\n+                \"--library-path-resolver\", \"test.testLibraryPathResolver.MyPathResolver#resolve\",\n+                headerFile.toString()\n+            ).checkSuccess();\n+\n+            TestUtils.compile(outputDir, outputDir);\n+\n+            try (TestUtils.Loader loader = TestUtils.classLoader(outputDir)) {\n+                Class<?> pathResolverClass = loader.loadClass(\"test.testLibraryPathResolver.MyPathResolver\");\n+                Class<?> headerClass = loader.loadClass(\"test.testLibraryPathResolver.testLibraryPathResolver_h\");\n+\n+                Method method = headerClass.getMethod(\"getMagicNumber\");\n+                int result = (int) method.invoke(null);\n+\n+                assertEquals(result, 990218, \"Native function result mismatch\");\n+\n+                Field field = pathResolverClass.getField(\"RESOLVER_CALLED\");\n+                boolean called = field.getBoolean(null);\n+                assertTrue(called, \"Custom library resolver was NOT called!\");\n+            }\n+        } finally {\n+            TestUtils.deleteDir(outputDir);\n+        }\n+    }\n+}\n","filename":"test\/jtreg\/generator\/testLibraryPathResolver\/TestLibraryPathResolver.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -24,2 +24,5 @@\n-typedef int T;\n-typedef char* P1;\n+#include \"testLibraryPathResolver.h\"\n+\n+int getMagicNumber(void) {\n+    return 990218;\n+}\n\\ No newline at end of file\n","filename":"test\/jtreg\/generator\/testLibraryPathResolver\/libLibraryPathResolver.c","additions":5,"deletions":2,"binary":false,"changes":7,"previous_filename":"test\/jtreg\/generator\/sharedSymbolsHeader\/sharedSymbolsHeader.h","status":"copied"},{"patch":"@@ -24,1 +24,7 @@\n-typedef void (*simple_callback)(int value);\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int getMagicNumber(void);\n\\ No newline at end of file\n","filename":"test\/jtreg\/generator\/testLibraryPathResolver\/testLibraryPathResolver.h","additions":7,"deletions":1,"binary":false,"changes":8,"previous_filename":"test\/jtreg\/generator\/reachableException\/reachableException.h","status":"copied"}]}