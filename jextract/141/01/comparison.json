{"files":[{"patch":"@@ -27,2 +27,0 @@\n-import javax.tools.JavaFileObject;\n-import java.lang.constant.ClassDesc;\n@@ -30,0 +28,2 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -38,4 +38,1 @@\n-abstract class ClassSourceBuilder extends JavaSourceBuilder {\n-\n-    private static final boolean SHOW_GENERATING_CLASS = Boolean.getBoolean(\"jextract.showGeneratingClass\");\n-\n+abstract class ClassSourceBuilder {\n@@ -53,3 +50,6 @@\n-    final Kind kind;\n-    final ClassDesc desc;\n-    protected final JavaSourceBuilder enclosing;\n+    private final SourceFileBuilder sb;\n+    private final String modifiers;\n+    private final Kind kind;\n+    private final String className;\n+    private final String superName;\n+    private final ClassSourceBuilder enclosing;\n@@ -57,9 +57,3 @@\n-    \/\/ code buffer\n-    private StringBuilder sb = new StringBuilder();\n-    \/\/ current line alignment (number of 4-spaces)\n-    private int align;\n-\n-    ClassSourceBuilder(JavaSourceBuilder enclosing, Kind kind, String name) {\n-        this.enclosing = enclosing;\n-        this.align = (enclosing instanceof ClassSourceBuilder classSourceBuilder)\n-                ? classSourceBuilder.align : 0;\n+    ClassSourceBuilder(SourceFileBuilder builder, String modifiers, Kind kind, String className, String superName, ClassSourceBuilder enclosing) {\n+        this.sb = builder;\n+        this.modifiers = modifiers;\n@@ -67,9 +61,3 @@\n-        this.desc = ClassDesc.of(enclosing.packageName(), name);\n-    }\n-\n-    boolean isNested() {\n-        return enclosing instanceof ClassSourceBuilder;\n-    }\n-\n-    String className() {\n-        return desc.displayName();\n+        this.className = className;\n+        this.superName = superName;\n+        this.enclosing = enclosing;\n@@ -78,4 +66,3 @@\n-    String fullName() {\n-        return isNested() ?\n-                ((ClassSourceBuilder)enclosing).className() + \".\" + className() :\n-                className();\n+    final String className() {\n+        \/\/ for a (nested) class 'com.foo.package.A.B.C' this will return 'C'\n+        return className;\n@@ -84,3 +71,3 @@\n-    @Override\n-    public final String packageName() {\n-        return desc.packageName();\n+    final String fullName() {\n+        \/\/ for a (nested) class 'com.foo.package.A.B.C' this will return 'A.B.C'\n+        return isNested() ? enclosing.fullName() + \".\" + className : className;\n@@ -89,2 +76,3 @@\n-    String superClass() {\n-        return null;\n+    \/\/ is the name enclosed by a class of the same name?\n+    protected final boolean isEnclosedBySameName(String name) {\n+        return className().equals(name) || (isNested() && enclosing.isEnclosedBySameName(name));\n@@ -93,6 +81,2 @@\n-    String mods() {\n-        if (kind == Kind.INTERFACE) {\n-            return \"public \";\n-        }\n-        return (isNested() ? \"public static \" : \"public \") +\n-                (isClassFinal() ? \"final \" : \"\");\n+    protected final boolean isNested() {\n+        return enclosing != null;\n@@ -101,2 +85,2 @@\n-    boolean isClassFinal() {\n-        return true;\n+    final SourceFileBuilder sourceFileBuilder() {\n+        return sb;\n@@ -105,8 +89,1 @@\n-    void classBegin() {\n-        if (isNested()) {\n-            incrAlign();\n-        }\n-        emitPackagePrefix();\n-        emitImportSection();\n-\n-        classDeclBegin();\n+    final void classBegin() {\n@@ -114,3 +91,4 @@\n-        append(mods());\n-        append(kind.kindName + \" \" + className());\n-        if (superClass() != null) {\n+        append(modifiers);\n+        append(\" \");\n+        append(kind.kindName + \" \" + className);\n+        if (superName != null) {\n@@ -118,1 +96,1 @@\n-            append(superClass());\n+            append(superName);\n@@ -121,3 +99,0 @@\n-        if (kind != Kind.INTERFACE) {\n-            emitConstructor();\n-        }\n@@ -126,15 +101,1 @@\n-    void classDeclBegin() {}\n-\n-    void emitConstructor() {\n-        incrAlign();\n-        indent();\n-        append(\"\/\/ Suppresses default constructor, ensuring non-instantiability.\\n\");\n-        indent();\n-        append(\"private \");\n-        append(className());\n-        append(\"() {}\");\n-        append('\\n');\n-        decrAlign();\n-    }\n-\n-    JavaSourceBuilder classEnd() {\n+    final void classEnd() {\n@@ -143,16 +104,0 @@\n-        if (isNested()) {\n-            decrAlign();\n-            ((ClassSourceBuilder)enclosing).append(build());\n-            sb = null;\n-        }\n-        return enclosing;\n-    }\n-\n-    @Override\n-    public List<JavaFileObject> toFiles() {\n-        if (isNested()) {\n-            throw new UnsupportedOperationException(\"Nested builder!\");\n-        }\n-        String res = build();\n-        sb = null;\n-        return List.of(Utils.fileFromString(packageName(), className(), res));\n@@ -163,5 +108,1 @@\n-    void append(Object o) {\n-        sb.append(o);\n-    }\n-\n-    void append(String s) {\n+    final void append(String s) {\n@@ -171,1 +112,1 @@\n-    void append(char c) {\n+    final void append(char c) {\n@@ -175,2 +116,2 @@\n-    void append(boolean b) {\n-        sb.append(b);\n+    final void append(long l) {\n+        sb.append(l);\n@@ -179,2 +120,2 @@\n-    void append(long l) {\n-        sb.append(l);\n+    final void indent() {\n+        sb.indent();\n@@ -183,4 +124,2 @@\n-    void indent() {\n-        for (int i = 0; i < align; i++) {\n-            append(\"    \");\n-        }\n+    final void incrAlign() {\n+        sb.incrAlign();\n@@ -189,2 +128,2 @@\n-    void incrAlign() {\n-        align++;\n+    final void decrAlign() {\n+        sb.decrAlign();\n@@ -193,2 +132,2 @@\n-    void decrAlign() {\n-        align--;\n+    final int align() {\n+        return sb.align();\n@@ -197,3 +136,10 @@\n-    String build() {\n-        String s = sb.toString();\n-        return s;\n+    final void emitPrivateDefaultConstructor() {\n+        incrAlign();\n+        indent();\n+        append(\"\/\/ Suppresses default constructor, ensuring non-instantiability.\\n\");\n+        indent();\n+        append(\"private \");\n+        append(className);\n+        append(\"() {}\");\n+        append('\\n');\n+        decrAlign();\n@@ -202,1 +148,1 @@\n-    void emitDocComment(Declaration decl) {\n+    final void emitDocComment(Declaration decl) {\n@@ -206,1 +152,1 @@\n-    void emitDocComment(Declaration decl, String header) {\n+    final void emitDocComment(Declaration decl, String header) {\n@@ -217,1 +163,1 @@\n-        append(CDeclarationPrinter.declaration(decl, \" \".repeat(align*4) + \" * \"));\n+        append(CDeclarationPrinter.declaration(decl, \" \".repeat(align()*4) + \" * \"));\n@@ -224,1 +170,1 @@\n-    void emitDocComment(Type.Function funcType, String name) {\n+    final void emitDocComment(Type.Function funcType, String name) {\n@@ -238,35 +184,1 @@\n-    \/\/ is the name enclosed enclosed by a class of the same name?\n-    boolean isEnclosedBySameName(String name) {\n-        return className().equals(name) ||\n-                (isNested() && enclosing.isEnclosedBySameName(name));\n-    }\n-\n-    protected void emitPackagePrefix() {\n-        if (!isNested()) {\n-            assert packageName().indexOf('\/') == -1 : \"package name invalid: \" + packageName();\n-            append(\"\/\/ Generated by jextract\");\n-            if (SHOW_GENERATING_CLASS) {\n-                append(\" (via \");\n-                append(getClass().getName());\n-                append(\")\");\n-            }\n-            append(\"\\n\\n\");\n-            if (!packageName().isEmpty()) {\n-                append(\"package \");\n-                append(packageName());\n-                append(\";\\n\\n\");\n-            }\n-        }\n-    }\n-\n-    protected void emitImportSection() {\n-        if (!isNested()) {\n-            append(\"import java.lang.invoke.MethodHandle;\\n\");\n-            append(\"import java.lang.invoke.VarHandle;\\n\");\n-            append(\"import java.nio.ByteOrder;\\n\");\n-            append(\"import java.lang.foreign.*;\\n\");\n-            append(\"import static java.lang.foreign.ValueLayout.*;\\n\");\n-        }\n-    }\n-\n-    void emitConstantGetter(String mods, String getterName, boolean nullCheck, String symbolName, Constant constant) {\n+    final void emitConstantGetter(String mods, String getterName, boolean nullCheck, String symbolName, Constant constant, Declaration decl) {\n@@ -274,0 +186,3 @@\n+        if (decl != null) {\n+            emitDocComment(decl);\n+        }\n@@ -294,5 +209,0 @@\n-\n-    @Override\n-    protected Constants constants() {\n-        return enclosing.constants();\n-    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ClassSourceBuilder.java","additions":65,"deletions":155,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import org.openjdk.jextract.Declaration;\n@@ -52,2 +53,2 @@\n-    List<Builder> constantBuilders = new ArrayList<>();\n-    Builder currentBuilder;\n+    private final List<SourceFileBuilder> constantBuilders = new ArrayList<>();\n+    private Builder currentBuilder;\n@@ -55,4 +56,5 @@\n-    public Constants(JavaSourceBuilder enclosing) {\n-        currentBuilder = new Builder(enclosing, 0);\n-        constantBuilders.add(currentBuilder);\n-        currentBuilder.classBegin();\n+    private final String packageName;\n+\n+    public Constants(String packageName) {\n+        this.packageName = packageName;\n+        currentBuilder = startNewBuilder(packageName, 0);\n@@ -74,0 +76,10 @@\n+    private Builder startNewBuilder(String packageName, int id) {\n+        String builderClassName = \"constants$\" + id;\n+        SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName, builderClassName);\n+        constantBuilders.add(sfb);\n+        Builder builder = new Builder(sfb, sfb.className());\n+        builder.classBegin();\n+        builder.emitPrivateDefaultConstructor();\n+        return builder;\n+    }\n+\n@@ -75,7 +87,3 @@\n-        if (currentBuilder.constantIndex > CONSTANTS_PER_CLASS || currentBuilder == null) {\n-            if (currentBuilder != null) {\n-                currentBuilder.classEnd();\n-            }\n-            currentBuilder = new Builder(currentBuilder.enclosing, constantBuilders.size());\n-            constantBuilders.add(currentBuilder);\n-            currentBuilder.classBegin();\n+        if (currentBuilder.constantIndex > CONSTANTS_PER_CLASS) {\n+            currentBuilder.classEnd();\n+            currentBuilder = startNewBuilder(packageName, constantBuilders.size());\n@@ -110,0 +118,5 @@\n+        Constant emitGetterWithComment(ClassSourceBuilder builder, String mods, String javaName, String symbolName,\n+                                       Declaration decl) {\n+            return emitGetterWithComment(builder, mods, symbolName, c -> c.getterName(javaName), decl);\n+        }\n+\n@@ -111,1 +124,7 @@\n-            builder.emitConstantGetter(mods, getterNameFunc.apply(this), false, null, this);\n+            builder.emitConstantGetter(mods, getterNameFunc.apply(this), false, null, this, null);\n+            return this;\n+        }\n+\n+        Constant emitGetterWithComment(ClassSourceBuilder builder, String mods, Function<Constant, String> getterNameFunc,\n+                                       Declaration decl) {\n+            builder.emitConstantGetter(mods, getterNameFunc.apply(this), false, null, this, decl);\n@@ -116,1 +135,7 @@\n-            builder.emitConstantGetter(mods, getterNameFunc.apply(this), true, symbolName, this);\n+            builder.emitConstantGetter(mods, getterNameFunc.apply(this), true, symbolName, this, null);\n+            return this;\n+        }\n+\n+        Constant emitGetterWithComment(ClassSourceBuilder builder, String mods, String symbolName,\n+                                       Function<Constant, String> getterNameFunc, Declaration decl) {\n+            builder.emitConstantGetter(mods, getterNameFunc.apply(this), true, symbolName, this, decl);\n@@ -216,4 +241,2 @@\n-        List<JavaFileObject> files = new ArrayList<>();\n-        files.addAll(constantBuilders.stream()\n-                .flatMap(b -> b.toFiles().stream()).toList());\n-        return files;\n+        return new ArrayList<>(constantBuilders.stream()\n+                .map(SourceFileBuilder::toFile).toList());\n@@ -224,3 +247,1 @@\n-        Builder(JavaSourceBuilder encl, int id) {\n-            super(encl, Kind.CLASS, \"constants$\" + id);\n-        }\n+        private static final String MEMBER_MODS = \"static final\";\n@@ -228,8 +249,2 @@\n-        String memberMods() {\n-            return kind == ClassSourceBuilder.Kind.CLASS ?\n-                    \"static final \" : \"\";\n-        }\n-\n-        @Override\n-        String mods() {\n-            return \"final \"; \/\/ constants package-private!\n+        Builder(SourceFileBuilder builder, String className) {\n+            super(builder, \"final\", Kind.CLASS, className, null, null);\n@@ -248,4 +263,0 @@\n-            String constantName() {\n-                return constantName;\n-            }\n-\n@@ -263,1 +274,1 @@\n-            append(memberMods() + \"MethodHandle \");\n+            append(MEMBER_MODS + \" MethodHandle \");\n@@ -292,1 +303,1 @@\n-            append(memberMods() + \"MethodHandle \");\n+            append(MEMBER_MODS + \" MethodHandle \");\n@@ -307,1 +318,1 @@\n-            append(memberMods() + \"VarHandle \" + vhConst.constantName + \" = \");\n+            append(MEMBER_MODS + \" VarHandle \" + vhConst.constantName + \" = \");\n@@ -319,1 +330,1 @@\n-            append(memberMods() + \"VarHandle \" + vhConst.constantName + \" = \");\n+            append(MEMBER_MODS + \" VarHandle \" + vhConst.constantName + \" = \");\n@@ -339,1 +350,1 @@\n-            append(memberMods() + layoutClassName + \" \" + layoutConst.constantName + \" = \");\n+            append(MEMBER_MODS + \" \" + layoutClassName + \" \" + layoutConst.constantName + \" = \");\n@@ -390,2 +401,2 @@\n-            append(memberMods());\n-            append(\"FunctionDescriptor \");\n+            append(MEMBER_MODS);\n+            append(\" FunctionDescriptor \");\n@@ -426,2 +437,2 @@\n-            append(memberMods());\n-            append(\"MemorySegment \");\n+            append(MEMBER_MODS);\n+            append(\" MemorySegment \");\n@@ -440,2 +451,2 @@\n-            append(memberMods());\n-            append(\"MemorySegment \");\n+            append(MEMBER_MODS);\n+            append(\" MemorySegment \");\n@@ -455,2 +466,2 @@\n-            append(memberMods());\n-            append(\"MemorySegment \");\n+            append(MEMBER_MODS);\n+            append(\" MemorySegment \");\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Constants.java","additions":58,"deletions":47,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-public class FunctionalInterfaceBuilder extends ClassSourceBuilder {\n+final class FunctionalInterfaceBuilder extends ClassSourceBuilder {\n@@ -43,1 +43,0 @@\n-    private final Type.Function funcType;\n@@ -48,0 +47,1 @@\n+    private final Constants constants;\n@@ -49,4 +49,3 @@\n-    FunctionalInterfaceBuilder(JavaSourceBuilder enclosing, Type.Function funcType, String className,\n-                               FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n-        super(enclosing, Kind.INTERFACE, className);\n-        this.funcType = funcType;\n+    private FunctionalInterfaceBuilder(SourceFileBuilder builder, Constants constants, String className, ClassSourceBuilder enclosing,\n+                                       FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n+        super(builder, \"public\", Kind.INTERFACE, className, null, enclosing);\n@@ -57,0 +56,1 @@\n+        this.constants = constants;\n@@ -59,11 +59,10 @@\n-    @Override\n-    void classDeclBegin() {\n-        emitDocComment(funcType, className());\n-    }\n-\n-    @Override\n-    JavaSourceBuilder classEnd() {\n-        emitFunctionalInterfaceMethod();\n-        emitFunctionalFactories();\n-        emitFunctionalFactoryForPointer();\n-        return super.classEnd();\n+    public static void generate(SourceFileBuilder builder, Constants constants, String className, ClassSourceBuilder enclosing,\n+                               Type.Function funcType, FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n+        FunctionalInterfaceBuilder fib = new FunctionalInterfaceBuilder(builder, constants, className, enclosing,\n+                descriptor, parameterNames);\n+        fib.emitDocComment(funcType, className);\n+        fib.classBegin();\n+        fib.emitFunctionalInterfaceMethod();\n+        fib.emitFunctionalFactories();\n+        fib.emitFunctionalFactoryForPointer();\n+        fib.classEnd();\n@@ -97,2 +96,2 @@\n-        Constant functionDesc = constants().addFunctionDesc(fiDesc);\n-        Constant upcallHandle = constants().addUpcallMethodHandle(fullName(), \"apply\", fiDesc);\n+        Constant functionDesc = constants.addFunctionDesc(fiDesc);\n+        Constant upcallHandle = constants.addUpcallMethodHandle(fullName(), \"apply\", fiDesc);\n@@ -113,1 +112,1 @@\n-        Constant mhConstant = constants().addVirtualDowncallMethodHandle(fiDesc);\n+        Constant mhConstant = constants.addVirtualDowncallMethodHandle(fiDesc);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":19,"deletions":20,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -49,1 +48,1 @@\n-abstract class HeaderFileBuilder extends ClassSourceBuilder {\n+class HeaderFileBuilder extends ClassSourceBuilder {\n@@ -53,1 +52,1 @@\n-    private final String superclass;\n+    private final Constants constants;\n@@ -55,3 +54,3 @@\n-    HeaderFileBuilder(ToplevelBuilder enclosing, String name, String superclass) {\n-        super(enclosing, Kind.CLASS, name);\n-        this.superclass = superclass;\n+    HeaderFileBuilder(SourceFileBuilder builder, Constants constants, String className, String superName) {\n+        super(builder, \"public\", Kind.CLASS, className, superName, null);\n+        this.constants = constants;\n@@ -60,13 +59,0 @@\n-    @Override\n-    String superClass() {\n-        return superclass;\n-    }\n-\n-    @Override\n-    void emitDocComment(Declaration decl, String header) {\n-        incrAlign();\n-        super.emitDocComment(decl, header);\n-        decrAlign();\n-    }\n-\n-    @Override\n@@ -78,3 +64,2 @@\n-                emitDocComment(varTree);\n-                constants().addSegment(nativeName, layout)\n-                        .emitGetter(this, MEMBER_MODS, javaName, nativeName);\n+                constants.addSegment(nativeName, layout)\n+                        .emitGetterWithComment(this, MEMBER_MODS, javaName, nativeName, varTree);\n@@ -83,1 +68,1 @@\n-            constants().addLayout(valueLayout)\n+            constants.addLayout(valueLayout)\n@@ -85,1 +70,1 @@\n-            Constant vhConstant = constants().addGlobalVarHandle(valueLayout)\n+            Constant vhConstant = constants.addGlobalVarHandle(valueLayout)\n@@ -87,1 +72,1 @@\n-            Constant segmentConstant = constants().addSegment(nativeName, valueLayout)\n+            Constant segmentConstant = constants.addSegment(nativeName, valueLayout)\n@@ -89,4 +74,2 @@\n-            emitDocComment(varTree, \"Getter for variable:\");\n-            emitGlobalGetter(segmentConstant, vhConstant, javaName, nativeName, valueLayout.carrier());\n-            emitDocComment(varTree, \"Setter for variable:\");\n-            emitGlobalSetter(segmentConstant, vhConstant, javaName, nativeName, valueLayout.carrier());\n+            emitGlobalGetter(segmentConstant, vhConstant, javaName, nativeName, valueLayout.carrier(), varTree, \"Getter for variable:\");\n+            emitGlobalSetter(segmentConstant, vhConstant, javaName, nativeName, valueLayout.carrier(), varTree, \"Setter for variable:\");\n@@ -100,1 +83,0 @@\n-    @Override\n@@ -106,1 +88,1 @@\n-        Constant mhConstant = constants().addDowncallMethodHandle(nativeName, descriptor, isVarargs)\n+        Constant mhConstant = constants.addDowncallMethodHandle(nativeName, descriptor, isVarargs)\n@@ -111,2 +93,1 @@\n-        emitDocComment(funcTree);\n-        emitFunctionWrapper(mhConstant, javaName, nativeName, downcallType, needsAllocator, isVarargs, parameterNames);\n+        emitFunctionWrapper(mhConstant, javaName, nativeName, downcallType, needsAllocator, isVarargs, parameterNames, funcTree);\n@@ -115,1 +96,0 @@\n-    @Override\n@@ -118,3 +98,2 @@\n-        emitDocComment(constantTree);\n-        constants().addConstantDesc(javaType, value)\n-                    .emitGetter(this, MEMBER_MODS, c -> javaName);\n+        constants.addConstantDesc(javaType, value)\n+                    .emitGetterWithComment(this, MEMBER_MODS, c -> javaName, constantTree);\n@@ -126,1 +105,1 @@\n-                                     boolean needsAllocator, boolean isVarargs, List<String> parameterNames) {\n+                                     boolean needsAllocator, boolean isVarargs, List<String> parameterNames, Declaration decl) {\n@@ -128,0 +107,1 @@\n+        emitDocComment(decl);\n@@ -211,0 +191,1 @@\n+            incrAlign();\n@@ -214,1 +195,0 @@\n-            incrAlign();\n@@ -221,1 +201,1 @@\n-            append(constants().addLayout(kind.layout().get()).accessExpression());\n+            append(constants.addLayout(kind.layout().get()).accessExpression());\n@@ -232,0 +212,1 @@\n+        incrAlign();\n@@ -235,1 +216,0 @@\n-        incrAlign();\n@@ -242,1 +222,1 @@\n-        append(constants().addLayout(TypeImpl.PointerImpl.POINTER_LAYOUT).accessExpression());\n+        append(constants.addLayout(TypeImpl.PointerImpl.POINTER_LAYOUT).accessExpression());\n@@ -254,1 +234,2 @@\n-    private void emitGlobalGetter(Constant segmentConstant, Constant vhConstant, String javaName, String nativeName, Class<?> type) {\n+    private void emitGlobalGetter(Constant segmentConstant, Constant vhConstant, String javaName, String nativeName,\n+                                  Class<?> type, Declaration.Variable decl, String docHeader) {\n@@ -256,0 +237,1 @@\n+        emitDocComment(decl, docHeader);\n@@ -273,1 +255,2 @@\n-    private void emitGlobalSetter(Constant segmentConstant, Constant vhConstant, String javaName, String nativeName, Class<?> type) {\n+    private void emitGlobalSetter(Constant segmentConstant, Constant vhConstant, String javaName, String nativeName,\n+                                  Class<?> type, Declaration.Variable decl, String docHeader) {\n@@ -275,0 +258,1 @@\n+        emitDocComment(decl, docHeader);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":28,"deletions":44,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.jextract.impl;\n-\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import org.openjdk.jextract.Declaration;\n-import org.openjdk.jextract.Type;\n-\n-import javax.tools.JavaFileObject;\n-import java.util.List;\n-import java.util.Optional;\n-\n-public abstract class JavaSourceBuilder {\n-\n-    public void addVar(Declaration.Variable varTree, String javaName,\n-        MemoryLayout layout, Optional<String> fiName) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void addFunction(Declaration.Function funcTree, FunctionDescriptor descriptor,\n-        String javaName, List<String> parameterNames) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void addConstant(Declaration.Constant constantTree, String javaName, Class<?> javaType) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void addTypedef(Declaration.Typedef typedefTree, String javaName, String superClass) {\n-        addTypedef(typedefTree, javaName, superClass, typedefTree.type());\n-    }\n-\n-    public void addTypedef(Declaration.Typedef typedefTree, String javaName,\n-        String superClass, Type type) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public StructBuilder addStruct(Declaration.Scoped structTree, boolean isNestedAnonStruct,\n-        String javaName, GroupLayout layout) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void addFunctionalInterface(Type.Function funcType, String javaName,\n-        FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    abstract public List<JavaFileObject> toFiles();\n-\n-    public abstract String packageName();\n-\n-    abstract boolean isEnclosedBySameName(String name);\n-\n-    abstract protected Constants constants();\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/JavaSourceBuilder.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -56,1 +56,1 @@\n-    protected JavaSourceBuilder currentBuilder;\n+    protected Builder currentBuilder;\n@@ -182,0 +182,1 @@\n+        Builder prevBuilder = null;\n@@ -187,0 +188,1 @@\n+            prevBuilder = currentBuilder;\n@@ -192,1 +194,0 @@\n-            structBuilder.classBegin();\n@@ -204,1 +205,2 @@\n-                currentBuilder = structBuilder.classEnd();\n+                structBuilder.end();\n+                currentBuilder = prevBuilder;\n@@ -435,0 +437,36 @@\n+\n+    interface Builder {\n+\n+        default void addVar(Declaration.Variable varTree, String javaName,\n+                            MemoryLayout layout, Optional<String> fiName) {\n+            throw new UnsupportedOperationException(\"Not implemented\");\n+        }\n+\n+        default void addFunction(Declaration.Function funcTree, FunctionDescriptor descriptor,\n+                                 String javaName, List<String> parameterNames) {\n+            throw new UnsupportedOperationException(\"Not implemented\");\n+        }\n+\n+        default void addConstant(Declaration.Constant constantTree, String javaName, Class<?> javaType) {\n+            throw new UnsupportedOperationException(\"Not implemented\");\n+        }\n+\n+        default void addTypedef(Declaration.Typedef typedefTree, String javaName, String superClass) {\n+            addTypedef(typedefTree, javaName, superClass, typedefTree.type());\n+        }\n+\n+        default void addTypedef(Declaration.Typedef typedefTree, String javaName,\n+                                String superClass, Type type) {\n+            throw new UnsupportedOperationException(\"Not implemented\");\n+        }\n+\n+        default StructBuilder addStruct(Declaration.Scoped structTree, boolean isNestedAnonStruct,\n+                                        String javaName, GroupLayout layout) {\n+            throw new UnsupportedOperationException(\"Not implemented\");\n+        }\n+\n+        default void addFunctionalInterface(Type.Function funcType, String javaName,\n+                                    FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n+            throw new UnsupportedOperationException(\"Not implemented\");\n+        }\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":41,"deletions":3,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.impl;\n+\n+import javax.tools.JavaFileObject;\n+import java.lang.constant.ClassDesc;\n+import java.util.function.Function;\n+\n+final class SourceFileBuilder {\n+\n+    private static final boolean SHOW_GENERATING_CLASS = Boolean.getBoolean(\"jextract.showGeneratingClass\");\n+\n+    private final String packageName;\n+    private final String className;\n+\n+    \/\/ code buffer\n+    private final StringBuilder sb = new StringBuilder();\n+    \/\/ current line alignment (number of 4-spaces)\n+    private int align;\n+\n+    private SourceFileBuilder(String packageName, String className) {\n+        this.packageName = packageName;\n+        this.className = className;\n+    }\n+\n+    public String className() {\n+        return className;\n+    }\n+\n+    public static SourceFileBuilder newSourceFile(String packageName, String className) {\n+        SourceFileBuilder sfb = new SourceFileBuilder(packageName, className);\n+        sfb.emitPackagePrefix();\n+        sfb.emitImportSection();\n+        return sfb;\n+    }\n+\n+    void emitPackagePrefix() {\n+        assert packageName.indexOf('\/') == -1 : \"package name invalid: \" + packageName;\n+        append(\"\/\/ Generated by jextract\");\n+        if (SHOW_GENERATING_CLASS) {\n+            append(\" (via \");\n+            append(getClass().getName());\n+            append(\")\");\n+        }\n+        append(\"\\n\\n\");\n+        if (!packageName.isEmpty()) {\n+            append(\"package \");\n+            append(packageName);\n+            append(\";\\n\\n\");\n+        }\n+    }\n+\n+    void emitImportSection() {\n+        append(\"import java.lang.invoke.MethodHandle;\\n\");\n+        append(\"import java.lang.invoke.VarHandle;\\n\");\n+        append(\"import java.nio.ByteOrder;\\n\");\n+        append(\"import java.lang.foreign.*;\\n\");\n+        append(\"import static java.lang.foreign.ValueLayout.*;\\n\");\n+        append(\"\\n\");\n+    }\n+\n+\n+    \/\/ Internal generation helpers (used by other builders)\n+\n+    void append(String s) {\n+        sb.append(s);\n+    }\n+\n+    void append(char c) {\n+        sb.append(c);\n+    }\n+\n+    void append(long l) {\n+        sb.append(l);\n+    }\n+\n+    void indent() {\n+        for (int i = 0; i < align; i++) {\n+            append(\"    \");\n+        }\n+    }\n+\n+    void incrAlign() {\n+        align++;\n+    }\n+\n+    void decrAlign() {\n+        align--;\n+    }\n+\n+    int align() {\n+        return align;\n+    }\n+\n+    public JavaFileObject toFile(Function<String, String> finisher) {\n+        return Utils.fileFromString(packageName, className, finisher.apply(sb.toString()));\n+    }\n+\n+    public JavaFileObject toFile() {\n+        return toFile(s -> s);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/SourceFileBuilder.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -47,1 +47,1 @@\n-class StructBuilder extends ClassSourceBuilder {\n+final class StructBuilder extends ClassSourceBuilder implements OutputFactory.Builder {\n@@ -55,1 +55,1 @@\n-    private Constant layoutConstant;\n+    private final Constants constants;\n@@ -57,3 +57,3 @@\n-    StructBuilder(JavaSourceBuilder enclosing, Declaration.Scoped structTree,\n-        String name, GroupLayout structLayout) {\n-        super(enclosing, Kind.CLASS, name);\n+    StructBuilder(SourceFileBuilder builder, Constants constants, String modifiers, String className,\n+                  ClassSourceBuilder enclosing, Declaration.Scoped structTree, GroupLayout structLayout) {\n+        super(builder, modifiers, Kind.CLASS, className, null, enclosing);\n@@ -63,1 +63,2 @@\n-        prefixElementNames = new ArrayDeque<>();\n+        this.prefixElementNames = new ArrayDeque<>();\n+        this.constants = constants;\n@@ -70,1 +71,1 @@\n-    void pushPrefixElement(String prefixElementName) {\n+    private void pushPrefixElement(String prefixElementName) {\n@@ -74,1 +75,1 @@\n-    void popPrefixElement() {\n+    private void popPrefixElement() {\n@@ -84,11 +85,1 @@\n-    @Override\n-    void classBegin() {\n-        if (!inAnonymousNested()) {\n-            super.classBegin();\n-            layoutConstant = constants().addLayout(((Type.Declared) structType).tree().layout().orElseThrow());\n-            layoutConstant.emitGetter(this, MEMBER_MODS, Constant::nameSuffix);\n-        }\n-    }\n-\n-    @Override\n-    void classDeclBegin() {\n+    void begin() {\n@@ -96,0 +87,3 @@\n+            if (isNested()) {\n+                sourceFileBuilder().incrAlign();\n+            }\n@@ -97,0 +91,3 @@\n+            classBegin();\n+            Constant layoutConstant = constants.addLayout(((Type.Declared) structType).tree().layout().orElseThrow());\n+            layoutConstant.emitGetter(this, MEMBER_MODS, Constant::nameSuffix);\n@@ -100,2 +97,1 @@\n-    @Override\n-    JavaSourceBuilder classEnd() {\n+    void end() {\n@@ -107,1 +103,5 @@\n-            return super.classEnd();\n+            classEnd();\n+            if (isNested()) {\n+                \/\/ we are nested. Decrease align\n+                sourceFileBuilder().decrAlign();\n+            }\n@@ -111,1 +111,0 @@\n-            return this;\n@@ -115,1 +114,1 @@\n-    boolean inAnonymousNested() {\n+    private boolean inAnonymousNested() {\n@@ -121,1 +120,1 @@\n-        String name, GroupLayout layout) {\n+                                   String name, GroupLayout layout) {\n@@ -128,1 +127,4 @@\n-            return new StructBuilder(this, tree, name, layout);\n+            StructBuilder builder = new StructBuilder(sourceFileBuilder(), constants, \"public static final\", name, this, tree, layout);\n+            builder.begin();\n+            builder.emitPrivateDefaultConstructor();\n+            return builder;\n@@ -134,4 +136,4 @@\n-        FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n-        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, funcType, javaName, descriptor, parameterNames);\n-        builder.classBegin();\n-        builder.classEnd();\n+                                       FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n+        incrAlign();\n+        FunctionalInterfaceBuilder.generate(sourceFileBuilder(), constants, javaName, this, funcType, descriptor, parameterNames);\n+        decrAlign();\n@@ -156,1 +158,1 @@\n-            Constant vhConstant = constants().addFieldVarHandle(nativeName, structLayout, prefixNamesList())\n+            Constant vhConstant = constants.addFieldVarHandle(nativeName, structLayout, prefixNamesList())\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructBuilder.java","additions":33,"deletions":31,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -44,1 +44,2 @@\n-class ToplevelBuilder extends JavaSourceBuilder {\n+class ToplevelBuilder implements OutputFactory.Builder {\n+    private static final int DECLS_PER_HEADER_CLASS = Integer.getInteger(\"jextract.decls.per.header\", 1000);\n@@ -47,2 +48,3 @@\n-    private final List<JavaSourceBuilder> builders = new ArrayList<>();\n-    private SplitHeader lastHeader;\n+    private final List<SourceFileBuilder> builders = new ArrayList<>();\n+    private final HeaderFileBuilder firstHeader;\n+    private HeaderFileBuilder lastHeader;\n@@ -51,4 +53,1 @@\n-\n-    Constants constants;\n-\n-    static final int DECLS_PER_HEADER_CLASS = Integer.getInteger(\"jextract.decls.per.header\", 1000);\n+    private final Constants constants;\n@@ -58,3 +57,7 @@\n-        SplitHeader first = lastHeader = new FirstHeader(headerClassName);\n-        builders.add(first);\n-        constants = new Constants(this);\n+        this.constants = new Constants(packageName);\n+        SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName, headerClassName);\n+        lastHeader = firstHeader = createFirstHeader(sfb, constants);\n+    }\n+\n+    private static HeaderFileBuilder createFirstHeader(SourceFileBuilder sfb, Constants constants) {\n+        HeaderFileBuilder first = new HeaderFileBuilder(sfb, constants, sfb.className(), \"#{SUPER}\");\n@@ -62,0 +65,11 @@\n+        \/\/ emit basic primitive types\n+        first.emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Bool), \"C_BOOL\");\n+        first.emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Char), \"C_CHAR\");\n+        first.emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Short), \"C_SHORT\");\n+        first.emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Int), \"C_INT\");\n+        first.emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Long), \"C_LONG\");\n+        first.emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.LongLong), \"C_LONG_LONG\");\n+        first.emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Float), \"C_FLOAT\");\n+        first.emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Double), \"C_DOUBLE\");\n+        first.emitPointerTypedef(\"C_POINTER\");\n+        return first;\n@@ -66,0 +80,1 @@\n+\n@@ -67,0 +82,2 @@\n+        files.add(firstHeader.sourceFileBuilder().toFile(s -> s.replace(\"extends #{SUPER}\",\n+                lastHeader != firstHeader ? \"extends \" + lastHeader.className() : \"\")));\n@@ -68,1 +85,1 @@\n-                .flatMap(b -> b.toFiles().stream()).toList());\n+                .map(SourceFileBuilder::toFile).toList());\n@@ -73,10 +90,0 @@\n-    public String headerClassName() {\n-        return headerDesc.displayName();\n-    }\n-\n-    @Override\n-    boolean isEnclosedBySameName(String name) {\n-        return false;\n-    }\n-\n-    @Override\n@@ -87,5 +94,0 @@\n-    @Override\n-    protected Constants constants() {\n-        return constants;\n-    }\n-\n@@ -119,4 +121,3 @@\n-            TypedefBuilder builder = new TypedefBuilder(this, typedefTree, javaName, superClass);\n-            builders.add(builder);\n-            builder.classBegin();\n-            builder.classEnd();\n+            SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName(), javaName);\n+            TypedefBuilder.generate(sfb, sfb.className(), superClass, typedefTree);\n+            builders.add(sfb);\n@@ -129,12 +130,4 @@\n-        StructBuilder structBuilder = new StructBuilder(this, tree, javaName, layout) {\n-            @Override\n-            boolean isClassFinal() {\n-                return false;\n-            }\n-\n-            @Override\n-            void emitConstructor() {\n-                \/\/ None...\n-            }\n-        };\n-        builders.add(structBuilder);\n+        SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName(), javaName);\n+        builders.add(sfb);\n+        StructBuilder structBuilder = new StructBuilder(sfb, constants, \"public\", sfb.className(), null, tree, layout);\n+        structBuilder.begin();\n@@ -147,4 +140,3 @@\n-        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, funcType, javaName, descriptor, parameterNames);\n-        builders.add(builder);\n-        builder.classBegin();\n-        builder.classEnd();\n+        SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName(), javaName);\n+        builders.add(sfb);\n+        FunctionalInterfaceBuilder.generate(sfb, constants, sfb.className(), null, funcType, descriptor, parameterNames);\n@@ -153,1 +145,1 @@\n-    private SplitHeader nextHeader() {\n+    private HeaderFileBuilder nextHeader() {\n@@ -155,2 +147,4 @@\n-            boolean hasSuper = !(lastHeader instanceof FirstHeader);\n-            SplitHeader headerFileBuilder = new SplitHeader(headerDesc.displayName() + \"_\" + ++headersCount,\n+            boolean hasSuper = lastHeader != firstHeader;\n+            String className = headerDesc.displayName() + \"_\" + ++headersCount;\n+            SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName(), className);\n+            HeaderFileBuilder headerFileBuilder = new HeaderFileBuilder(sfb, constants, sfb.className(),\n@@ -160,1 +154,1 @@\n-            builders.add(headerFileBuilder);\n+            builders.add(sfb);\n@@ -169,45 +163,0 @@\n-\n-    class SplitHeader extends HeaderFileBuilder {\n-        SplitHeader(String name, String superclass) {\n-            super(ToplevelBuilder.this, name, superclass);\n-        }\n-\n-        @Override\n-        boolean isClassFinal() {\n-            return false;\n-        }\n-\n-        @Override\n-        void emitConstructor() {\n-            \/\/ None...\n-        }\n-    }\n-\n-    class FirstHeader extends SplitHeader {\n-\n-        FirstHeader(String name) {\n-            super(name, \"#{SUPER}\");\n-        }\n-\n-        @Override\n-        void classBegin() {\n-            super.classBegin();\n-            \/\/ emit basic primitive types\n-            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Bool), \"C_BOOL\");\n-            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Char), \"C_CHAR\");\n-            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Short), \"C_SHORT\");\n-            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Int), \"C_INT\");\n-            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Long), \"C_LONG\");\n-            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.LongLong), \"C_LONG_LONG\");\n-            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Float), \"C_FLOAT\");\n-            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Double), \"C_DOUBLE\");\n-            emitPointerTypedef(\"C_POINTER\");\n-        }\n-\n-        @Override\n-        String build() {\n-            HeaderFileBuilder last = lastHeader;\n-            return super.build().replace(\"extends #{SUPER}\",\n-                    last != this ? \"extends \" + last.className() : \"\");\n-        }\n-    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ToplevelBuilder.java","additions":44,"deletions":95,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jextract.Type;\n@@ -30,3 +31,1 @@\n-public class TypedefBuilder extends ClassSourceBuilder {\n-    private final Declaration.Typedef typedefTree;\n-    private final String superClass;\n+import java.util.List;\n@@ -34,5 +33,3 @@\n-    public TypedefBuilder(JavaSourceBuilder enclosing,\n-        Declaration.Typedef typedefTree, String name, String superClass) {\n-        super(enclosing, Kind.CLASS, name);\n-        this.typedefTree = typedefTree;\n-        this.superClass = superClass;\n+final class TypedefBuilder extends ClassSourceBuilder {\n+    private TypedefBuilder(SourceFileBuilder builder, String className, String superClass) {\n+        super(builder, \"public\", Kind.CLASS, className, superClass, null);\n@@ -41,13 +38,7 @@\n-    @Override\n-    String superClass() {\n-        return superClass;\n-    }\n-\n-    @Override\n-    void classDeclBegin() {\n-        emitDocComment(typedefTree);\n-    }\n-\n-    @Override\n-    JavaSourceBuilder classEnd() {\n-        return super.classEnd();\n+    public static void generate(SourceFileBuilder builder, String className, String superClass,\n+                          Declaration.Typedef typedefTree) {\n+        TypedefBuilder tdb = new TypedefBuilder(builder, className, superClass);\n+        tdb.emitDocComment(typedefTree);\n+        tdb.classBegin();\n+        tdb.emitPrivateDefaultConstructor();\n+        tdb.classEnd();\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypedefBuilder.java","additions":12,"deletions":21,"binary":false,"changes":33,"status":"modified"}]}