{"files":[{"patch":"@@ -195,1 +195,0 @@\n-            String varargsParam = finalParamNames.get(finalParamNames.size() - 1);\n@@ -200,0 +199,3 @@\n+                    FunctionDescriptor BASE_DESC = \\{functionDescriptorString(2, decl.type())};\n+                    MemorySegment ADDR = \\{runtimeHelperName()}.findOrThrow(\"\\{nativeName}\");\n+\n@@ -201,0 +203,1 @@\n+                \"\"\");\n@@ -202,7 +205,19 @@\n-                    \/**\n-                     * Invoke the variadic function with the given parameters. Layouts for variadic arguments are inferred.\n-                     *\/\n-                    static \\{retType} invoke(\\{paramExprs}) {\n-                        MemoryLayout[] inferredLayouts$ = \\{runtimeHelperName()}.inferVariadicLayouts(\\{varargsParam});\n-                        \\{returnNoCast}\\{javaName}(inferredLayouts$).apply(\\{String.join(\", \", finalParamNames)});\n-                    }\n+            incrAlign();\n+            appendBlankLine();\n+            emitDocComment(decl, \"Specialized method handle factory for:\");\n+            appendLines(STR.\"\"\"\n+                static MethodHandle handle(MemoryLayout... layouts) {\n+                    FunctionDescriptor desc = descriptor(layouts);\n+                    Linker.Option fva = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());\n+                    return Linker.nativeLinker().downcallHandle(ADDR, desc, fva);\n+                }\n+                \"\"\");\n+            appendBlankLine();\n+            emitDocComment(decl, \"Specialized function descriptor factory for:\");\n+            appendLines(STR.\"\"\"\n+                static FunctionDescriptor descriptor(MemoryLayout... layouts) {\n+                    return BASE_DESC.appendArgumentLayouts(layouts);\n+                }\n+                \"\"\");\n+            decrAlign();\n+            appendLines(\"\"\"\n@@ -215,2 +230,1 @@\n-                    FunctionDescriptor baseDesc$ = \\{functionDescriptorString(2, decl.type())};\n-                    var mh$ = \\{runtimeHelperName()}.downcallHandleVariadic(\"\\{nativeName}\", baseDesc$, layouts);\n+                    var mh$ = \\{invokerClassName}.handle(layouts).asSpreader(Object[].class, layouts.length);\n@@ -306,8 +320,0 @@\n-            static MemoryLayout[] inferVariadicLayouts(Object[] varargs) {\n-                MemoryLayout[] result = new MemoryLayout[varargs.length];\n-                for (int i = 0; i < varargs.length; i++) {\n-                    result[i] = variadicLayout(varargs[i].getClass());\n-                }\n-                return result;\n-            }\n-\n@@ -321,26 +327,0 @@\n-\n-            static MethodHandle downcallHandleVariadic(String name, FunctionDescriptor baseDesc, MemoryLayout[] variadicLayouts) {\n-                FunctionDescriptor variadicDesc = baseDesc.appendArgumentLayouts(variadicLayouts);\n-                Linker.Option fva = Linker.Option.firstVariadicArg(baseDesc.argumentLayouts().size());\n-                return SYMBOL_LOOKUP.find(name)\n-                        .map(addr -> Linker.nativeLinker().downcallHandle(addr, variadicDesc, fva)\n-                                .asSpreader(Object[].class, variadicLayouts.length))\n-                        .orElse(null);\n-            }\n-\n-            \/\/ Internals only below this point\n-\n-            private static MemoryLayout variadicLayout(Class<?> c) {\n-                \/\/ apply default argument promotions per C spec\n-                \/\/ note that all primitives are boxed, since they are passed through an Object[]\n-                if (c == Boolean.class || c == Byte.class || c == Character.class || c == Short.class || c == Integer.class) {\n-                    return JAVA_INT;\n-                } else if (c == Long.class) {\n-                    return JAVA_LONG;\n-                } else if (c == Float.class || c == Double.class) {\n-                    return JAVA_DOUBLE;\n-                } else if (MemorySegment.class.isAssignableFrom(c)) {\n-                    return ADDRESS;\n-                }\n-                throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n-            }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":24,"deletions":44,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.invoke.MethodHandle;\n@@ -31,1 +33,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -46,0 +47,6 @@\n+    @Test\n+    public void testBaseDescriptor() {\n+        FunctionDescriptor baseDesc = my_sprintf.descriptor();\n+        assertEquals(baseDesc, FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER, C_INT));\n+    }\n+\n@@ -47,1 +54,1 @@\n-    public void testsPrintf(String fmt, Object[] args, String expected, MemoryLayout[] unused) {\n+    public void testsPrintfHandle(String fmt, Object[] args, String expected, MemoryLayout[] layouts) throws Throwable {\n@@ -50,1 +57,7 @@\n-            my_sprintf.invoke(s, arena.allocateFrom(fmt), args.length, args);\n+            MethodHandle handle = my_sprintf.handle(layouts);\n+            Object[] fullArgs = new Object[args.length + 3];\n+            fullArgs[0] = s;\n+            fullArgs[1] = arena.allocateFrom(fmt);\n+            fullArgs[2] = args.length;\n+            System.arraycopy(args, 0, fullArgs, 3, args.length);\n+            handle.invokeWithArguments(fullArgs);\n","filename":"test\/jtreg\/generator\/testPrintf\/TestPrintf.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -128,2 +128,7 @@\n-        \/\/ check a method for \"int printf(MemorySegment, Object[])\"\n-        assertNotNull(findMethod(invokerCls, \"invoke\", MemorySegment.class, Object[].class));\n+        \/\/ check for base desc and address fields\n+        assertNotNull(findField(invokerCls, \"BASE_DESC\"));\n+        assertNotNull(findField(invokerCls, \"ADDR\"));\n+        \/\/ check a method for \"MethodHandle handle(MemoryLayout...)\"\n+        assertNotNull(findMethod(invokerCls, \"handle\", MemoryLayout[].class));\n+        \/\/ check a method for \"FunctionDescriptor descriptor(MemoryLayout...)\"\n+        assertNotNull(findMethod(invokerCls, \"descriptor\", MemoryLayout[].class));\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/JextractToolProviderTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"}]}