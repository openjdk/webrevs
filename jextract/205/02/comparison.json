{"files":[{"patch":"@@ -195,1 +195,0 @@\n-            String varargsParam = finalParamNames.get(finalParamNames.size() - 1);\n@@ -197,1 +196,1 @@\n-            emitDocComment(decl, \"Variadic invoker interface for:\");\n+            emitDocComment(decl, \"Variadic invoker class for:\");\n@@ -199,2 +198,21 @@\n-                public interface \\{invokerClassName} {\n-                    \\{retType} apply(\\{paramExprs});\n+                public static class \\{invokerClassName} {\n+                    private static final FunctionDescriptor BASE_DESC = \\{functionDescriptorString(2, decl.type())};\n+                    private static final MemorySegment ADDR = \\{runtimeHelperName()}.findOrThrow(\"\\{nativeName}\");\n+\n+                    private final MethodHandle handle;\n+                    private final FunctionDescriptor descriptor;\n+                    private final MethodHandle spreader;\n+\n+                    private \\{invokerClassName}(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {\n+                        this.handle = handle;\n+                        this.descriptor = descriptor;\n+                        this.spreader = spreader;\n+                    }\n+\n+                    static \\{invokerClassName} specialize(MemoryLayout... layouts) {\n+                        FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);\n+                        Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());\n+                        var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);\n+                        var spreader$ = mh$.asSpreader(Object[].class, layouts.length);\n+                        return new \\{invokerClassName}(mh$, desc$, spreader$);\n+                    }\n@@ -203,1 +221,1 @@\n-                     * Invoke the variadic function with the given parameters. Layouts for variadic arguments are inferred.\n+                     * {@return specialized method handle}\n@@ -205,3 +223,2 @@\n-                    static \\{retType} invoke(\\{paramExprs}) {\n-                        MemoryLayout[] inferredLayouts$ = \\{runtimeHelperName()}.inferVariadicLayouts(\\{varargsParam});\n-                        \\{returnNoCast}\\{javaName}(inferredLayouts$).apply(\\{String.join(\", \", finalParamNames)});\n+                    public MethodHandle handle() {\n+                        return handle;\n@@ -209,1 +226,0 @@\n-                }\n@@ -211,7 +227,8 @@\n-                \"\"\");\n-            emitDocComment(decl, \"Variadic invoker factory for:\");\n-            appendLines(STR.\"\"\"\n-                public static \\{invokerClassName} \\{javaName}(MemoryLayout... layouts) {\n-                    FunctionDescriptor baseDesc$ = \\{functionDescriptorString(2, decl.type())};\n-                    var mh$ = \\{runtimeHelperName()}.downcallHandleVariadic(\"\\{nativeName}\", baseDesc$, layouts);\n-                    return (\\{paramExprs}) -> {\n+                    \/**\n+                     * {@return specialized descriptor}\n+                     *\/\n+                    public FunctionDescriptor descriptor() {\n+                        return descriptor;\n+                    }\n+\n+                    public \\{retType} apply(\\{paramExprs}) {\n@@ -222,1 +239,1 @@\n-                            \\{returnWithCast}mh$.invokeExact(\\{paramList});\n+                            \\{returnWithCast}spreader.invokeExact(\\{paramList});\n@@ -228,1 +245,8 @@\n-                    };\n+                    }\n+                }\n+\n+                \"\"\");\n+            emitDocComment(decl, \"Variadic invoker factory for:\");\n+            appendLines(STR.\"\"\"\n+                public static \\{invokerClassName} \\{javaName}(MemoryLayout... layouts) {\n+                    return \\{invokerClassName}.specialize(layouts);\n@@ -306,8 +330,0 @@\n-            static MemoryLayout[] inferVariadicLayouts(Object[] varargs) {\n-                MemoryLayout[] result = new MemoryLayout[varargs.length];\n-                for (int i = 0; i < varargs.length; i++) {\n-                    result[i] = variadicLayout(varargs[i].getClass());\n-                }\n-                return result;\n-            }\n-\n@@ -321,26 +337,0 @@\n-\n-            static MethodHandle downcallHandleVariadic(String name, FunctionDescriptor baseDesc, MemoryLayout[] variadicLayouts) {\n-                FunctionDescriptor variadicDesc = baseDesc.appendArgumentLayouts(variadicLayouts);\n-                Linker.Option fva = Linker.Option.firstVariadicArg(baseDesc.argumentLayouts().size());\n-                return SYMBOL_LOOKUP.find(name)\n-                        .map(addr -> Linker.nativeLinker().downcallHandle(addr, variadicDesc, fva)\n-                                .asSpreader(Object[].class, variadicLayouts.length))\n-                        .orElse(null);\n-            }\n-\n-            \/\/ Internals only below this point\n-\n-            private static MemoryLayout variadicLayout(Class<?> c) {\n-                \/\/ apply default argument promotions per C spec\n-                \/\/ note that all primitives are boxed, since they are passed through an Object[]\n-                if (c == Boolean.class || c == Byte.class || c == Character.class || c == Short.class || c == Integer.class) {\n-                    return JAVA_INT;\n-                } else if (c == Long.class) {\n-                    return JAVA_LONG;\n-                } else if (c == Float.class || c == Double.class) {\n-                    return JAVA_DOUBLE;\n-                } else if (MemorySegment.class.isAssignableFrom(c)) {\n-                    return ADDRESS;\n-                }\n-                throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n-            }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":42,"deletions":52,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.invoke.MethodHandle;\n@@ -31,1 +33,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -46,0 +47,6 @@\n+    @Test\n+    public void testBaseDescriptor() {\n+        my_sprintf invoker = my_sprintf();\n+        assertEquals(invoker.descriptor(), FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER, C_INT));\n+    }\n+\n@@ -47,1 +54,1 @@\n-    public void testsPrintf(String fmt, Object[] args, String expected, MemoryLayout[] unused) {\n+    public void testsPrintfHandle(String fmt, Object[] args, String expected, MemoryLayout[] layouts) throws Throwable {\n@@ -50,1 +57,7 @@\n-            my_sprintf.invoke(s, arena.allocateFrom(fmt), args.length, args);\n+            MethodHandle handle = my_sprintf(layouts).handle();\n+            Object[] fullArgs = new Object[args.length + 3];\n+            fullArgs[0] = s;\n+            fullArgs[1] = arena.allocateFrom(fmt);\n+            fullArgs[2] = args.length;\n+            System.arraycopy(args, 0, fullArgs, 3, args.length);\n+            handle.invokeWithArguments(fullArgs);\n","filename":"test\/jtreg\/generator\/testPrintf\/TestPrintf.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -128,2 +128,4 @@\n-        \/\/ check a method for \"int printf(MemorySegment, Object[])\"\n-        assertNotNull(findMethod(invokerCls, \"invoke\", MemorySegment.class, Object[].class));\n+        \/\/ check a method for \"MethodHandle handle()\"\n+        assertNotNull(findMethod(invokerCls, \"handle\"));\n+        \/\/ check a method for \"FunctionDescriptor descriptor()\"\n+        assertNotNull(findMethod(invokerCls, \"descriptor\"));\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/JextractToolProviderTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}