{"files":[{"patch":"@@ -120,2 +120,2 @@\n-                                                String targetPkg, List<String> libNames) {\n-        return List.of(CodeGenerator.generate(decl, headerName, targetPkg, new IncludeHelper(), libNames));\n+                                                String targetPkg, List<String> libNames, PrintWriter errStream) {\n+        return List.of(CodeGenerator.generate(decl, headerName, targetPkg, new IncludeHelper(), libNames, errStream));\n@@ -125,2 +125,3 @@\n-                                                String targetPkg, IncludeHelper includeHelper, List<String> libNames) {\n-        return List.of(CodeGenerator.generate(decl, headerName, targetPkg, includeHelper, libNames));\n+                                                         String targetPkg, IncludeHelper includeHelper,\n+                                                         List<String> libNames, PrintWriter errStream) {\n+        return List.of(CodeGenerator.generate(decl, headerName, targetPkg, includeHelper, libNames, errStream));\n@@ -478,1 +479,1 @@\n-                options.targetPackage, options.includeHelper, options.libraryNames);\n+                options.targetPackage, options.includeHelper, options.libraryNames, err);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/JextractTool.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+\n+import java.io.PrintWriter;\n@@ -36,2 +38,2 @@\n-                    String targetPkg, IncludeHelper includeHelper,\n-                    List<String> libNames) {\n+                                            String targetPkg, IncludeHelper includeHelper,\n+                                            List<String> libNames, PrintWriter errStream) {\n@@ -43,1 +45,1 @@\n-                .map(new UnsupportedFilter()::scan)\n+                .map(new UnsupportedFilter(errStream)::scan)\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/CodeGenerator.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,115 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.jextract.impl;\n-\n-import org.openjdk.jextract.Declaration;\n-import org.openjdk.jextract.Type;\n-import java.lang.foreign.FunctionDescriptor;\n-\n-import java.util.Optional;\n-import java.util.Set;\n-\n-class FunctionalInterfaceScanner implements Declaration.Visitor<Void, Set<FunctionDescriptor>> {\n-\n-    private final Set<FunctionDescriptor> descriptors;\n-\n-    FunctionalInterfaceScanner(Set<FunctionDescriptor> descriptors) {\n-        this.descriptors = descriptors;\n-    }\n-\n-    Declaration.Scoped scan(Declaration.Scoped decl) {\n-        decl.accept(this, descriptors);\n-        return decl;\n-    }\n-\n-    void scanType(Type t, Set<FunctionDescriptor> functionDescriptors) {\n-        t.accept(new TypeScanner(), functionDescriptors);\n-    }\n-\n-    @Override\n-    public Void visitScoped(Declaration.Scoped d, Set<FunctionDescriptor> functionDescriptors) {\n-        d.members().forEach(m -> m.accept(this, functionDescriptors));\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitFunction(Declaration.Function d, Set<FunctionDescriptor> functionDescriptors) {\n-        scanType(d.type().returnType(), functionDescriptors);\n-        d.parameters().forEach(p -> p.accept(this, functionDescriptors));\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitVariable(Declaration.Variable d, Set<FunctionDescriptor> functionDescriptors) {\n-        scanType(d.type(), functionDescriptors);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitConstant(Declaration.Constant d, Set<FunctionDescriptor> functionDescriptors) {\n-        scanType(d.type(), functionDescriptors);\n-        return null;\n-    }\n-\n-    static class TypeScanner implements Type.Visitor<Void, Set<FunctionDescriptor>> {\n-\n-        @Override\n-        public Void visitPrimitive(Type.Primitive t, Set<FunctionDescriptor> functionDescriptors) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitDelegated(Type.Delegated t, Set<FunctionDescriptor> functionDescriptors) {\n-            return t.type().accept(this, functionDescriptors);\n-        }\n-\n-        @Override\n-        public Void visitFunction(Type.Function t, Set<FunctionDescriptor> functionDescriptors) {\n-            t.returnType().accept(this, functionDescriptors);\n-            t.argumentTypes().forEach(a -> a.accept(this, functionDescriptors));\n-            Optional<FunctionDescriptor> descriptor = Type.descriptorFor(t);\n-            if (descriptor.isPresent()) {\n-                functionDescriptors.add(descriptor.get());\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitDeclared(Type.Declared t, Set<FunctionDescriptor> functionDescriptors) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitArray(Type.Array t, Set<FunctionDescriptor> functionDescriptors) {\n-            return t.elementType().accept(this, functionDescriptors);\n-        }\n-\n-        @Override\n-        public Void visitType(Type t, Set<FunctionDescriptor> functionDescriptors) {\n-            throw new UnsupportedOperationException();\n-        }\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/FunctionalInterfaceScanner.java","additions":0,"deletions":115,"binary":false,"changes":115,"status":"deleted"},{"patch":"@@ -58,18 +58,0 @@\n-    static JavaFileObject jfoFromByteArray(URI uri, byte[] bytes) {\n-        return new SimpleJavaFileObject(uri, JavaFileObject.Kind.CLASS) {\n-            @Override\n-            public InputStream openInputStream() {\n-                return new ByteArrayInputStream(bytes);\n-            }\n-        };\n-    }\n-\n-    static JavaFileObject jfoFromString(URI uri, String contents) {\n-        return new SimpleJavaFileObject(uri, JavaFileObject.Kind.SOURCE) {\n-            @Override\n-            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n-                return contents;\n-            }\n-        };\n-    }\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/InMemoryJavaCompiler.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -87,5 +87,0 @@\n-    private JavaFileObject jfoFromString(String pkgName, String clsName, String contents) {\n-        String pkgPrefix = pkgName.isEmpty() ? \"\" : pkgName.replaceAll(\"\\\\.\", \"\/\") + \"\/\";\n-        return InMemoryJavaCompiler.jfoFromString(URI.create(pkgPrefix + clsName + \".java\"), contents);\n-    }\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.io.PrintWriter;\n@@ -53,0 +54,7 @@\n+\n+    private final PrintWriter errStream;\n+\n+    public UnsupportedFilter(PrintWriter errStream) {\n+        this.errStream = errStream;\n+    }\n+\n@@ -67,2 +75,1 @@\n-            warn(\"skipping \" + funcTree.name() + \" because of unsupported type usage: \" +\n-                    unsupportedType);\n+            warnUnsupportedType(funcTree.name(), unsupportedType);\n@@ -74,0 +81,1 @@\n+            warnSkip(funcTree.name(), \"can not compute FunctionDescriptor\");\n@@ -81,1 +89,1 @@\n-            if (f != null && !checkFunctionTypeSupported(param, f)) {\n+            if (f != null && !checkFunctionTypeSupported(param, f, funcTree.name())) {\n@@ -88,1 +96,1 @@\n-        if (returnFunc != null && !checkFunctionTypeSupported(funcTree, returnFunc)) {\n+        if (returnFunc != null && !checkFunctionTypeSupported(funcTree, returnFunc, funcTree.name())) {\n@@ -98,0 +106,2 @@\n+        String name = parent != null ? parent.name() + \".\" : \"\";\n+        name += varTree.name();\n@@ -99,4 +109,1 @@\n-            String name = parent != null ? parent.name() + \".\" : \"\";\n-            name += varTree.name();\n-            warn(\"skipping \" + name + \" because of unsupported type usage: \" +\n-                    unsupportedType);\n+            warnUnsupportedType(name, unsupportedType);\n@@ -109,0 +116,1 @@\n+            warnSkip(name, \"can not compute MemoryLayout\");\n@@ -113,2 +121,1 @@\n-        if (varTree.kind() == Declaration.Variable.Kind.BITFIELD ||\n-                (layout instanceof ValueLayout && layout.byteSize() > 8)) {\n+        if (varTree.kind() == Declaration.Variable.Kind.BITFIELD) {\n@@ -116,0 +123,1 @@\n+            warnSkip(name, \"type is bitfield\");\n@@ -122,1 +130,2 @@\n-        if (func != null && !checkFunctionTypeSupported(varTree, func)) {\n+        if (func != null && !checkFunctionTypeSupported(varTree, func, name)) {\n+            Skip.with(varTree);\n@@ -143,0 +152,7 @@\n+        String unsupportedType = firstUnsupportedType(typedefTree.type());\n+        if (unsupportedType != null) {\n+            warnUnsupportedType(typedefTree.name(), unsupportedType);\n+            Skip.with(typedefTree);\n+            return null;\n+        }\n+\n@@ -144,1 +160,1 @@\n-        if (func != null && !checkFunctionTypeSupported(typedefTree, func)) {\n+        if (func != null && !checkFunctionTypeSupported(typedefTree, func, typedefTree.name())) {\n@@ -147,0 +163,9 @@\n+\n+        MemoryLayout layout = Type.layoutFor(typedefTree.type()).orElse(null);\n+        if (layout == null) {\n+            \/\/no layout - skip\n+            warnSkip(typedefTree.name(), \"can not compute MemoryLayout\");\n+            Skip.with(typedefTree);\n+            return null;\n+        }\n+\n@@ -164,1 +189,1 @@\n-    private boolean checkFunctionTypeSupported(Declaration decl, Type.Function func) {\n+    private boolean checkFunctionTypeSupported(Declaration decl, Type.Function func, String nameOfSkipped) {\n@@ -167,2 +192,1 @@\n-            warn(\"skipping \" + JavaName.getOrThrow(decl) + \" because of unsupported type usage: \" +\n-                    unsupportedType);\n+            warnUnsupportedType(nameOfSkipped, unsupportedType);\n@@ -173,0 +197,1 @@\n+            warnSkip(nameOfSkipped, \"can not compute FunctionDescriptor\");\n@@ -177,1 +202,2 @@\n-            warn(\"varargs in callbacks is not supported: \" + CDeclarationPrinter.declaration(func, JavaName.getOrThrow(decl)));\n+            warnSkip(nameOfSkipped, \"varargs in callbacks is not supported: \"\n+                    + CDeclarationPrinter.declaration(func, JavaName.getOrThrow(decl)));\n@@ -244,2 +270,10 @@\n-    private static void warn(String msg) {\n-        System.err.println(\"WARNING: \" + msg);\n+    private void warnUnsupportedType(String treeName, String type) {\n+        warnSkip(treeName, STR.\"unsupported type usage: \\{type}\");\n+    }\n+\n+    private void warnSkip(String treeName, String message) {\n+        warn(STR.\"skipping \\{treeName}: \\{message}\");\n+    }\n+\n+    private void warn(String msg) {\n+        errStream.println(\"WARNING: \" + msg);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnsupportedFilter.java","additions":52,"deletions":18,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -149,1 +149,0 @@\n-        String[] args = new String[options.length + 1];\n","filename":"test\/lib\/testlib\/JextractToolRunner.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import java.lang.reflect.Method;\n@@ -33,1 +32,0 @@\n-import static org.testng.Assert.assertNull;\n@@ -47,4 +45,0 @@\n-            \/\/ class should be generated for typedef on opaque struct\n-            Class<?> fooCls = loader.loadClass(\"Foo\");\n-            assertNotNull(fooCls);\n-\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8245767.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.toolprovider.unsupported;\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import testlib.JextractToolRunner;\n+\n+import java.nio.file.Path;\n+\n+public class TestUnsupportedTypes extends JextractToolRunner {\n+\n+    JextractToolRunner.JextractResult result;\n+\n+    @BeforeClass\n+    public void before() {\n+        Path output = getOutputFilePath(\"TestUnsupportedTypes-unsupportedTypes.h\");\n+        Path outputH = getInputFilePath(\"unsupportedTypes.h\");\n+        result = run(\"--source\", \"--output\",\n+            output.toString(), outputH.toString()).checkSuccess();\n+    }\n+\n+    @Test(dataProvider = \"cases\")\n+    public void testUnsupportedTypes(String skippedName, String reason) {\n+        result.checkContainsOutput(\"WARNING: skipping \" + skippedName + \": \" + reason);\n+    }\n+\n+    private static final String REASON_UNSUPPORTED_TYPE = \"unsupported type usage\";\n+    private static final String REASON_VARARGS_CALLBACK = \"varargs in callbacks is not supported\";\n+    private static final String REASON_NO_FUNC_DESC = \"can not compute FunctionDescriptor\";\n+    private static final String REASON_NO_MEM_LAYOUT = \"can not compute MemoryLayout\";\n+\n+    @DataProvider\n+    public static Object[][] cases() {\n+        return new Object[][]{\n+            {\"returns_unsupported\",              REASON_UNSUPPORTED_TYPE},\n+            {\"accepts_unsupported\",              REASON_UNSUPPORTED_TYPE},\n+            {\"unsupported_t\",                    REASON_UNSUPPORTED_TYPE},\n+            {\"unsupported_func_t\",               REASON_UNSUPPORTED_TYPE},\n+            {\"returns_unsupported_func\",         REASON_UNSUPPORTED_TYPE},\n+            {\"accepts_unsupported_func\",         REASON_UNSUPPORTED_TYPE},\n+            {\"accepts_unsupported_func_varargs\", REASON_VARARGS_CALLBACK},\n+            {\"GLOBAL_UNSUPPORTED\",               REASON_UNSUPPORTED_TYPE},\n+            {\"GLOBAL_UNSUPPORTED_FUNC\",          REASON_UNSUPPORTED_TYPE},\n+            {\"GLOBAL_HAS_UNSUPPORTED\",           REASON_UNSUPPORTED_TYPE},\n+            {\"accepts_undefined\",               REASON_NO_FUNC_DESC},\n+            {\"returns_undefined\",               REASON_NO_FUNC_DESC},\n+            {\"accepts_undefined_func\",          REASON_NO_FUNC_DESC},\n+            {\"GLOBAL_UNDECLARED\",                REASON_NO_MEM_LAYOUT},\n+            {\"undefined_typedef\",               REASON_NO_MEM_LAYOUT},\n+        };\n+    }\n+}\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/unsupported\/TestUnsupportedTypes.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+__int128 returns_unsupported(void);\n+void accepts_unsupported(__int128);\n+\n+typedef __int128 unsupported_t;\n+typedef __int128 (*unsupported_func_t)(void);\n+\n+\/\/ this insane syntax indicates a function 'returns_unsupported_func(void)'\n+\/\/ that returns a '__int128 (*)(void)' function pointer\n+__int128 (*returns_unsupported_func(void))(void);\n+void accepts_unsupported_func(__int128 (*)(void));\n+void accepts_unsupported_func_varargs(void (*)(int, ...));\n+\n+extern __int128 GLOBAL_UNSUPPORTED;\n+extern __int128 (*GLOBAL_UNSUPPORTED_FUNC)(void);\n+\n+struct undefined;\n+\n+struct undefined returns_undefined(void);\n+void accepts_undefined(struct undefined);\n+void accepts_undefined_func(void (*)(struct undefined));\n+\n+typedef struct undefined undefined_typedef;\n+\n+extern struct undefined GLOBAL_UNDECLARED;\n+\n+struct HasUnsupported {\n+    __int128 x;\n+};\n+\n+extern struct HasUnsupported GLOBAL_HAS_UNSUPPORTED;\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/unsupported\/unsupportedTypes.h","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"}]}