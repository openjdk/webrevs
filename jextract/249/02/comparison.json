{"files":[{"patch":"@@ -156,0 +156,1 @@\n+        Files.copy(Path.of(\"$projectDir\/src\/main\/jextract.ps1\"), Path.of(\"${jextract_bin_dir}\/jextract.ps1\"))\n","filename":"build.gradle","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -772,1 +772,1 @@\n-  \n+\n@@ -989,0 +989,15 @@\n+Jextract accepts one or more header files. When multiple header files are specified,\n+the `--header-class-name` option is mandatory. Header files can be specified in two different ways:\n+\n+   1. Simple header file name like `foo.h` or header file path like `bar\/foo.h`\n+\n+   2. Special header file path or file name like `<stdio.h>`, `<GLUT\/glut.h>`.\n+      With this syntax, the header path is considered to be relative to one of the paths\n+      in the C compiler include path. This simplifies the extraction of header files\n+      from standard include paths and include paths specified by `-I` options.\n+\n+      Note that '>' and '<' are special characters in OS Shells and therefore those\n+      need to be escaped appropriately. On Unix platforms, simple quoting like `\"<stdio.h>\"`\n+      is enough.\n+\n+\n","filename":"doc\/GUIDE.md","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-  \"$blasPath\\include\\cblas.h\"\r\n+  '<cblas.h>'\r\n","filename":"samples\/cblas\/compile_windows.ps1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -14,1 +14,0 @@\n-  -D\"java.library.path=$blasPath\\bin\" `\r\n","filename":"samples\/cblas\/run_windows.ps1","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,2 +3,1 @@\n-jextract --output src -t org.unix \\\n-  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/dlfcn.h\n+jextract --output src -t org.unix \"<dlfcn.h>\"\n","filename":"samples\/dlopen\/compilesource.sh","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-  \"$lapackPath\\include\\lapacke.h\"\r\n+  '<lapacke.h>'\r\n","filename":"samples\/lapack\/compile_windows.ps1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -14,1 +14,0 @@\n-  -D\"java.library.path=$lapackPath\\bin\" `\r\n","filename":"samples\/lapack\/run_windows.ps1","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -11,0 +11,1 @@\n+  --use-system-load-library `\r\n@@ -12,1 +13,1 @@\n-  \"$clangPath\\include\\clang-c\\Index.h\"\r\n+  '<Index.h>'\r\n","filename":"samples\/libclang\/compile_windows.ps1","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5,1 +5,2 @@\n-  ${LIBCLANG_HOME}\/include\/clang-c\/Index.h\n+  \"<Index.h>\"\n+\n","filename":"samples\/libclang\/compilesource.sh","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-  \"$curlpath\\include\\curl\\curl.h\"\r\n+  '<curl.h>'\r\n@@ -19,1 +19,2 @@\n-  -llibcurl `\r\n+  -l libcurl `\r\n+  --use-system-load-library `\r\n@@ -21,1 +22,1 @@\n-  \"$curlpath\\include\\curl\\curl.h\"\r\n+  '<curl.h>'\r\n","filename":"samples\/libcurl\/compile_windows.ps1","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,2 +1,1 @@\n-jextract --output src -t org.jextract -lcurl \\\n-  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/curl\/curl.h\n+jextract --output src -t org.jextract -lcurl \"<curl\/curl.h>\"\n","filename":"samples\/libcurl\/compilesource.sh","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -10,1 +10,3 @@\n-  libffmpeg.h\n+  \"<libavcodec\/avcodec.h>\" \\\n+  \"<libavformat\/avformat.h>\" \\\n+  \"<libswscale\/swscale.h>\"\n","filename":"samples\/libffmpeg\/compilesource.sh","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,3 +0,0 @@\n-#include <libavcodec\/avcodec.h>\n-#include <libavformat\/avformat.h>\n-#include <libswscale\/swscale.h>\n","filename":"samples\/libffmpeg\/libffmpeg.h","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -10,0 +10,1 @@\n+  --use-system-load-library `\r\n@@ -11,1 +12,1 @@\n-  \"$libgit2path\\include\\git2.h\"\r\n+  '<git2.h>'\r\n","filename":"samples\/libgit2\/compile_windows.ps1","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-  ${LIBGIT2_HOME}\/include\/git2.h\n+  \"<git2.h>\"\n","filename":"samples\/libgit2\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,2 +1,1 @@\n-jextract --output src -t org.unix \\\n-  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/libproc.h\n+jextract --output src -t org.unix \"<libproc.h>\"\n","filename":"samples\/libproc\/compilesource.sh","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n-  ${LIBZSTD_HOME}\/include\/zstd.h\n+  \"<zstd.h>\"\n","filename":"samples\/libzstd\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,3 +0,0 @@\n-jextract -t opengl -l :\/System\/Library\/Frameworks\/GLUT.framework\/GLUT \\\n-  -l :\/System\/Library\/Frameworks\/OpenGL.framework\/OpenGL \\\n-  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks\/GLUT.framework\/Headers\/glut.h\n","filename":"samples\/opengl\/compile.sh","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -9,0 +9,1 @@\n+  --use-system-load-library `\r\n@@ -13,1 +14,1 @@\n-  \"$freeglutPath\\include\\GL\\glut.h\"\r\n+  '<GL\\glut.h>'\r\n","filename":"samples\/opengl\/compile_windows.ps1","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks\/GLUT.framework\/Headers\/glut.h\n+  \"<GLUT\/glut.h>\"\n","filename":"samples\/opengl\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-  \/usr\/local\/opt\/pcre2\/include\/pcre2.h\n+  \"<pcre2.h>\"\n","filename":"samples\/pcre2\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -13,1 +13,1 @@\n-  \"$pythonPath\\include\\Python.h\"\r\n+  '<Python.h>'\r\n","filename":"samples\/python3\/compile_windows.ps1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-  ${ANACONDA3_HOME}\/include\/python3.11\/Python.h\n+  \"<Python.h>\"\n","filename":"samples\/python3\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,2 @@\n-  myreadline.h\n+  \"<stdlib.h>\" \\\n+  \"<readline\/readline.h>\"\n","filename":"samples\/readline\/compilesource.sh","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-#include <stdlib.h>\n-#include <readline\/readline.h>\n","filename":"samples\/readline\/myreadline.h","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -2,2 +2,2 @@\n-  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/sqlite3.h \\\n-  -t org.sqlite -lsqlite3\n+  -t org.sqlite -lsqlite3 \\\n+  \"<sqlite3.h>\"\n","filename":"samples\/sqlite\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,2 +1,1 @@\n-jextract --output src -l tcl -t org.tcl \\\n-   \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/tcl.h\n+jextract --output src -l tcl -t org.tcl \"<tcl.h>\"\n","filename":"samples\/tcl\/compilesource.sh","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -10,0 +10,1 @@\n+  --use-system-load-library `\r\n@@ -11,1 +12,1 @@\n-  \"$tensorflowPath\\include\\tensorflow\\c\\c_api.h\"\r\n+  '<tensorflow\\c\\c_api.h>'\r\n","filename":"samples\/tensorflow\/compile_windows.ps1","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,2 +1,1 @@\n-jextract --output src -t org.unix \\\n-   \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/time.h\n+jextract --output src -t org.unix \"<time.h>\"\n","filename":"samples\/time\/compilesource.sh","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -85,2 +85,5 @@\n-    private static Path generateTmpSource(List<Path> headers) {\n-        assert headers.size() > 1;\n+    private static boolean isSpecialHeaderName(String str) {\n+        return str.startsWith(\"<\") && str.endsWith(\">\");\n+    }\n+\n+    private static Path generateTmpSource(List<String> headers) {\n@@ -91,1 +94,7 @@\n-                    map(src -> \"#include \\\"\" + src + \"\\\"\").\n+                    map(src -> {\n+                        if (isSpecialHeaderName(src)) {\n+                            return \"#include \" + src + \"\\n\";\n+                        } else {\n+                            return \"#include \\\"\" + src + \"\\\"\\n\";\n+                        }\n+                    }).\n@@ -104,1 +113,1 @@\n-    public static Declaration.Scoped parse(List<Path> headers, String... parserOptions) {\n+    public static Declaration.Scoped parse(List<String> headers, String... parserOptions) {\n@@ -108,2 +117,2 @@\n-    private static Declaration.Scoped parseInternal(Logger logger, List<Path> headers, String... parserOptions) {\n-        Path source = headers.size() > 1? generateTmpSource(headers) : headers.iterator().next();\n+    private static Declaration.Scoped parseInternal(Logger logger, List<String> headers, String... parserOptions) {\n+        Path source = generateTmpSource(headers);\n@@ -388,5 +397,0 @@\n-        if (optionSet.nonOptionArguments().size() != 1) {\n-            printOptionError(logger.format(\"expected.one.header\", optionSet.nonOptionArguments().size()));\n-            return OPTION_ERROR;\n-        }\n-\n@@ -473,1 +477,1 @@\n-        Options options = builder.build();\n+        builder.addClangArg(\"-I\" + System.getProperty(\"user.dir\"));\n@@ -475,8 +479,3 @@\n-        Path header = Paths.get(optionSet.nonOptionArguments().get(0));\n-        if (!Files.isReadable(header)) {\n-            logger.err(\"cannot.read.header.file\", header);\n-            return INPUT_ERROR;\n-        }\n-        if (!(Files.isRegularFile(header))) {\n-            logger.err(\"not.a.file\", header);\n-            return INPUT_ERROR;\n+        if (optionSet.nonOptionArguments().size() == 0) {\n+            printOptionError(logger.format(\"expected.atleast.one.header\"));\n+            return OPTION_ERROR;\n@@ -485,0 +484,3 @@\n+        Options options = builder.build();\n+        List<String> headers = optionSet.nonOptionArguments();\n+\n@@ -487,1 +489,16 @@\n-            Declaration.Scoped toplevel = parseInternal(logger, List.of(header), options.clangArgs.toArray(new String[0]));\n+            String headerName;\n+            if (optionSet.has(\"--header-class-name\")) {\n+                headerName = optionSet.valueOf(\"--header-class-name\");\n+            } else {\n+                if (headers.size() > 1) {\n+                    \/\/ more than one header specified but no --header-class-name specified.\n+                    logger.err(\"class.name.missing.for.multiple.headers\");\n+                    return OPTION_ERROR;\n+                }\n+                headerName = headers.get(0);\n+                if (isSpecialHeaderName(headerName)) {\n+                    headerName = headerName.substring(1, headerName.length() - 1);\n+                }\n+                headerName = Paths.get(headerName).getFileName().toString();\n+            }\n+            Declaration.Scoped toplevel = parseInternal(logger, headers, options.clangArgs.toArray(new String[0]));\n@@ -492,5 +509,0 @@\n-\n-            String headerName = optionSet.has(\"--header-class-name\") ?\n-                optionSet.valueOf(\"--header-class-name\") :\n-                header.getFileName().toString();\n-\n@@ -572,1 +584,0 @@\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/JextractTool.java","additions":38,"deletions":27,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -0,0 +1,2 @@\n+$ROOT = \"$PSScriptRoot\\..\"\n+& \"$ROOT\\runtime\\bin\\java\" $Env:JEXTRACT_JAVA_OPTIONS -m 'org.openjdk.jextract\/org.openjdk.jextract.JextractTool' $args\n","filename":"src\/main\/jextract.ps1","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+class.name.missing.for.multiple.headers=multiple headers specified without --header-class-name\n@@ -51,1 +52,1 @@\n-Usage: jextract <options> <header file>                                                         \\n\\\n+Usage: jextract <options> <header file> [<header file>] [...]                                   \\n\\\n@@ -95,2 +96,2 @@\n-expected.one.header=\\\n-  Expected one header file, not {0}\n+expected.atleast.one.header=\\\n+  Expected at least one header file\n@@ -123,1 +124,1 @@\n-Error occurred while processing macro: {0}\n\\ No newline at end of file\n+Error occurred while processing macro: {0}\n","filename":"src\/main\/resources\/org\/openjdk\/jextract\/impl\/resources\/Messages.properties","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-        return JextractTool.parse(List.of(header), parseOptions);\n+        return JextractTool.parse(List.of(header.toString()), parseOptions);\n","filename":"test\/lib\/testlib\/JextractApiTestBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    protected static final int RUNTIME_ERROR = 5;\n+    protected static final int FATAL_ERROR = 5;\n@@ -99,0 +99,8 @@\n+    protected Path getInputDir() {\n+        return inputDir.toAbsolutePath();\n+    }\n+\n+    protected Path getOutputDir() {\n+        return outputDir.toAbsolutePath();\n+    }\n+\n","filename":"test\/lib\/testlib\/JextractToolRunner.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+    private static final boolean IS_WINDOWS = System.getProperty(\"os.name\").startsWith(\"Windows\");\n+\n@@ -65,2 +67,2 @@\n-            .checkFailure(INPUT_ERROR)\n-            .checkContainsOutput(\"cannot read header file\");\n+            .checkFailure(CLANG_ERROR)\n+            .checkContainsOutput(\"file not found\");\n@@ -80,2 +82,2 @@\n-            .checkFailure(INPUT_ERROR)\n-            .checkContainsOutput(\"not a file\");\n+            .checkFailure(CLANG_ERROR)\n+            .checkContainsOutput(\"file not found\");\n@@ -100,1 +102,1 @@\n-                .checkFailure(RUNTIME_ERROR)\n+                .checkFailure(FATAL_ERROR)\n@@ -212,0 +214,86 @@\n+\n+    @Test\n+    public void testSpecialHeaderSyntax() {\n+        Path helloOutput = getOutputFilePath(\"hello_special\");\n+        runAndCompile(helloOutput, \"-I\", getInputDir().toString(), \"<hello.h>\");\n+        try(TestUtils.Loader loader = TestUtils.classLoader(helloOutput)) {\n+            Class<?> cls = loader.loadClass(\"hello_h\");\n+            checkHeaderMembers(cls);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void testSpecialStandardHeaderSyntax() {\n+        \/\/ standard include header files cannot be found on Windows without setting\n+        \/\/ the location of standard header explicitly!\n+        if (IS_WINDOWS) {\n+            System.err.println(\"skipping test that uses standard header\");\n+        } else {\n+            Path stdioOutput = getOutputFilePath(\"stdio\");\n+            runAndCompile(stdioOutput, \"<stdio.h>\");\n+            try(TestUtils.Loader loader = TestUtils.classLoader(stdioOutput)) {\n+                Class<?> cls = loader.loadClass(\"stdio_h\");\n+                Class<?> invokerCls = findNestedClass(cls, \"printf\");\n+                assertNotNull(invokerCls);\n+                \/\/ check a method for \"MethodHandle handle()\"\n+                assertNotNull(findMethod(invokerCls, \"handle\"));\n+                \/\/ check a method for \"FunctionDescriptor descriptor()\"\n+                assertNotNull(findMethod(invokerCls, \"descriptor\"));\n+                \/\/ check a method for \"<invokerCls> invoker(MemoryLayout...)\"\n+                assertNotNull(findMethod(invokerCls, \"makeInvoker\", MemoryLayout[].class));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testMultipleHeadersWithoutHeaderClassName() {\n+        runNoOuput(\"foo.h\", \"bar.h\")\n+            .checkFailure(OPTION_ERROR)\n+            .checkContainsOutput(\"multiple headers specified without --header-class-name\");\n+    }\n+\n+    @Test\n+    public void testMultipleHeaders() {\n+        Path multiOutput = getOutputFilePath(\"multi\");\n+        runAndCompile(multiOutput,\n+            \"-I\", getInputDir().toString(),\n+            \"--header-class-name\", \"Multi\",\n+            \"hello.h\", \"typedefs.h\");\n+        try(TestUtils.Loader loader = TestUtils.classLoader(multiOutput)) {\n+            Class<?> cls = loader.loadClass(\"Multi\");\n+\n+            \/\/ check stuff from hello.h\n+            checkHeaderMembers(cls);\n+\n+            \/\/ check stuff from typedefs.h\n+            assertNotNull(findField(cls, \"byte_t\"));\n+            assertNotNull(findField(cls, \"mysize_t\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testStandardMultipleHeaders() {\n+        \/\/ standard include header files cannot be found on Windows without setting\n+        \/\/ the location of standard header explicitly!\n+        if (IS_WINDOWS) {\n+            System.err.println(\"skipping test that uses standard headers\");\n+        } else {\n+            Path unixOutput = getOutputFilePath(\"unix\");\n+            runAndCompile(unixOutput, \"--header-class-name\", \"Unix\", \"<stdio.h>\", \"<stdlib.h>\");\n+            try(TestUtils.Loader loader = TestUtils.classLoader(unixOutput)) {\n+                Class<?> cls = loader.loadClass(\"Unix\");\n+                Class<?> invokerCls = findNestedClass(cls, \"printf\");\n+                assertNotNull(invokerCls);\n+                \/\/ check a method for \"MethodHandle handle()\"\n+                assertNotNull(findMethod(invokerCls, \"handle\"));\n+                \/\/ check a method for \"FunctionDescriptor descriptor()\"\n+                assertNotNull(findMethod(invokerCls, \"descriptor\"));\n+                \/\/ check a method for \"<invokerCls> invoker(MemoryLayout...)\"\n+                assertNotNull(findMethod(invokerCls, \"makeInvoker\", MemoryLayout[].class));\n+\n+                \/\/ check qsort function\n+                assertNotNull(findMethod(cls, \"qsort\", MemorySegment.class, long.class, long.class, MemorySegment.class));\n+            }\n+        }\n+    }\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/JextractToolProviderTest.java","additions":93,"deletions":5,"binary":false,"changes":98,"status":"modified"}]}