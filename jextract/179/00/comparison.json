{"files":[{"patch":"@@ -140,1 +140,2 @@\n-            emitSegmentGetter(javaName, offsetField, sizeField);\n+            emitSegmentGetter(javaName, varTree, offsetField, sizeField);\n+            emitSegmentSetter(javaName, varTree, offsetField, sizeField);\n@@ -155,0 +156,4 @@\n+    private String kindName() {\n+        return structTree.kind() == Scoped.Kind.STRUCT ? \"struct\" : \"union\";\n+    }\n+\n@@ -156,1 +161,1 @@\n-        String seg = safeParameterName(\"seg\");\n+        String segmentParam = safeParameterName(kindName());\n@@ -161,2 +166,2 @@\n-            public static \\{type.getSimpleName()} \\{javaName}(MemorySegment \\{seg}) {\n-                return \\{seg}.get(\\{layoutString(varTree.type())}, \\{offsetField});\n+            public static \\{type.getSimpleName()} \\{javaName}(MemorySegment \\{segmentParam}) {\n+                return \\{segmentParam}.get(\\{layoutString(varTree.type())}, \\{offsetField});\n@@ -168,2 +173,2 @@\n-        String seg = safeParameterName(\"seg\");\n-        String x = safeParameterName(\"x\");\n+        String segmentParam = safeParameterName(kindName());\n+        String valueParam = safeParameterName(\"fieldValue\");\n@@ -174,2 +179,2 @@\n-            public static void \\{javaName}(MemorySegment \\{seg}, \\{type.getSimpleName()} \\{x}) {\n-                \\{seg}.set(\\{layoutString(varTree.type())}, \\{offsetField}, \\{x});\n+            public static void \\{javaName}(MemorySegment \\{segmentParam}, \\{type.getSimpleName()} \\{valueParam}) {\n+                \\{segmentParam}.set(\\{layoutString(varTree.type())}, \\{offsetField}, \\{valueParam});\n@@ -180,2 +185,4 @@\n-    private void emitSegmentGetter(String javaName, String offsetField, String sizeField) {\n-        String seg = safeParameterName(\"seg\");\n+    private void emitSegmentGetter(String javaName, Declaration.Variable varTree, String offsetField, String sizeField) {\n+        appendBlankLine();\n+        emitFieldDocComment(varTree, \"Getter for field:\");\n+        String segmentParam = safeParameterName(kindName());\n@@ -183,0 +190,5 @@\n+            public static MemorySegment \\{javaName}(MemorySegment \\{segmentParam}) {\n+                return \\{segmentParam}.asSlice(\\{offsetField}, \\{sizeField});\n+            }\n+            \"\"\");\n+    }\n@@ -184,2 +196,8 @@\n-            public static MemorySegment \\{javaName}(MemorySegment \\{seg}) {\n-                return \\{seg}.asSlice(\\{offsetField}, \\{sizeField});\n+    private void emitSegmentSetter(String javaName, Declaration.Variable varTree, String offsetField, String sizeField) {\n+        appendBlankLine();\n+        emitFieldDocComment(varTree, \"Setter for field:\");\n+        String segmentParam = safeParameterName(kindName());\n+        String valueParam = safeParameterName(\"fieldValue\");\n+        appendIndentedLines(STR.\"\"\"\n+            public static void \\{javaName}(MemorySegment \\{segmentParam}, MemorySegment \\{valueParam}) {\n+                MemorySegment.copy(\\{valueParam}, 0L, \\{segmentParam}, \\{offsetField}, \\{sizeField});\n@@ -191,0 +209,1 @@\n+        String arrayParam = safeParameterName(\"array\");\n@@ -193,2 +212,2 @@\n-            public static MemorySegment asSlice(MemorySegment ptr, long index) {\n-                return ptr.asSlice($LAYOUT().byteSize() * index);\n+            public static MemorySegment asSlice(MemorySegment \\{arrayParam}, long index) {\n+                return \\{arrayParam}.asSlice($LAYOUT().byteSize() * index);\n@@ -206,2 +225,6 @@\n-        appendIndentedLines(\"\"\"\n-            public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }\n+        String allocatorParam = safeParameterName(\"allocator\");\n+        appendIndentedLines(STR.\"\"\"\n+\n+            public static MemorySegment allocate(SegmentAllocator \\{allocatorParam}) {\n+                return \\{allocatorParam}.allocate($LAYOUT());\n+            }\n@@ -212,1 +235,3 @@\n-        appendIndentedLines(\"\"\"\n+        String allocatorParam = safeParameterName(\"allocator\");\n+        String elementCountParam = safeParameterName(\"elementCount\");\n+        appendIndentedLines(STR.\"\"\"\n@@ -214,2 +239,2 @@\n-            public static MemorySegment allocateArray(long len, SegmentAllocator allocator) {\n-                return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));\n+            public static MemorySegment allocateArray(long \\{elementCountParam}, SegmentAllocator \\{allocatorParam}) {\n+                return \\{allocatorParam}.allocate(MemoryLayout.sequenceLayout(\\{elementCountParam}, $LAYOUT()));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructBuilder.java","additions":44,"deletions":19,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import test.jextract.nestedaccess.*;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+\n+\/*\n+ * @test id=classes\n+  * @library \/lib\n+ * @run main\/othervm JtregJextract -l Func -t test.jextract.nestedaccess nestedStructAccess.h\n+ * @build TestNestedStructAccess\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNestedStructAccess\n+ *\/\n+\/*\n+ * @test id=sources\n+  * @library \/lib\n+ * @run main\/othervm JtregJextractSources -l Func -t test.jextract.nestedaccess nestedStructAccess.h\n+ * @build TestNestedStructAccess\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNestedStructAccess\n+ *\/\n+public class TestNestedStructAccess {\n+\n+    @Test\n+    public void testNestedStructAccess() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment start = allocatePoint(1, 2, arena);\n+            MemorySegment end = allocatePoint(3, 4, arena);\n+            MemorySegment line = allocateLine(start, end, arena);\n+            checkPointEquals(Line.start(line), start);\n+            checkPointEquals(Line.end(line), end);\n+        }\n+    }\n+\n+    static MemorySegment allocatePoint(int x, int y, Arena arena) {\n+        MemorySegment point = Point.allocate(arena);\n+        Point.x(point, x);\n+        Point.y(point, y);\n+        return point;\n+    }\n+\n+    static MemorySegment allocateLine(MemorySegment start, MemorySegment end, Arena arena) {\n+        MemorySegment line = Line.allocate(arena);\n+        Line.start(line, start);\n+        Line.end(line, end);\n+        return line;\n+    }\n+\n+    static void checkPointEquals(MemorySegment found, MemorySegment expected) {\n+        assertEquals(Point.x(found), Point.x(expected));\n+        assertEquals(Point.y(found), Point.y(expected));\n+    }\n+}\n","filename":"test\/jtreg\/generator\/nestedStructAccess\/TestNestedStructAccess.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Point {\n+    int x;\n+    int y;\n+};\n+\n+struct Line {\n+   struct Point start;\n+   struct Point end;\n+};\n","filename":"test\/jtreg\/generator\/nestedStructAccess\/nestedStructAccess.h","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"}]}