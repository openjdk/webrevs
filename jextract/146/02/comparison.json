{"files":[{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+\n+\/**\n+ * Subtypes of this interface can be customized with a variable number of attributes. Each attribute\n+ * is modelled as an instance of a record class. The record class is used to lookup attributes.\n+ * There can be at most one attribute associated with a given record class. Moreover, the set of\n+ * attributes associated with an entity implementing this interface can only monotonically increase over time\n+ * (that is, removing or replacing attributes is not supported).\n+ *\/\n+public interface Attributed {\n+\n+    \/**\n+     * {@return the attributes associated with this entity}\n+     *\/\n+    Collection<Record> attributes();\n+\n+    \/**\n+     * Obtains an attribute from this entity.\n+     * @param attributeClass the class of the attribute to be obtained.\n+     * @param <R> the attribute's type.\n+     * @return the attribute (if any).\n+     *\/\n+    <R extends Record> Optional<R> getAttribute(Class<R> attributeClass);\n+\n+    \/**\n+     * Adds a new attribute to this entity. This method is idempotent, that is, it allows adding an attribute\n+     * that is identical to the one already stored.\n+     * @param attribute the attribute to be added.\n+     * @param <R> the attribute's type.\n+     *\/\n+    <R extends Record> void addAttribute(R attribute);\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Attributed.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Collection;\n@@ -31,0 +32,1 @@\n+import java.util.Map;\n@@ -42,1 +44,1 @@\n-public interface Declaration {\n+public interface Declaration extends Attributed {\n@@ -56,30 +58,0 @@\n-    \/**\n-     * Get a declaration with specified attribute.\n-     * Set the values to the specified attribute while other attributes remains unchanged. If the specified attribute\n-     * already exist, the new values are replacing the old ones. By not specifying any value, the attribute will become\n-     * empty as {@link #getAttribute(String) getAttribute(name).isEmpty()} will return true.\n-     * @param name The attribute name\n-     * @param values More attribute values\n-     * @return the Declaration with attributes\n-     *\/\n-    Declaration withAttribute(String name, Constable... values);\n-\n-    \/**\n-     * Get a declaration without current attributes\n-     * @return the Declatation without any attributes\n-     *\/\n-    Declaration stripAttributes();\n-\n-    \/**\n-     * The values of the specified attribute.\n-     * @param name The attribute to retrieve\n-     * @return The list of values associate with this attribute\n-     *\/\n-    Optional<List<Constable>> getAttribute(String name);\n-\n-    \/**\n-     * The attributes associated with this declaration\n-     * @return The attributes associated with this declaration\n-     *\/\n-    Set<String> attributeNames();\n-\n@@ -586,0 +558,6 @@\n+\n+    \/**\n+     * A record used to capture clang attributes attached to a declaration.\n+     * @param attributes a map from attribute name to attribute values.\n+     *\/\n+    record ClangAttributes(Map<String, List<String>> attributes) { }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Declaration.java","additions":9,"deletions":31,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-public interface Type {\n+public interface Type extends Attributed {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Type.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+import org.openjdk.jextract.Attributed;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+public abstract class AttributedImpl implements Attributed {\n+\n+    private final Map<Class<?>, Record> attributes = new HashMap<>();\n+\n+    @Override\n+    public Collection<Record> attributes() {\n+        return attributes.values();\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public <R extends Record> Optional<R> getAttribute(Class<R> attributeClass) {\n+        return Optional.ofNullable((R)attributes.get(attributeClass));\n+    }\n+\n+    @Override\n+    public <R extends Record> void addAttribute(R attribute) {\n+        Record attr = attributes.get(attribute.getClass());\n+        if (attr != null && !attr.equals(attribute)) {\n+            throw new IllegalStateException(\"Attribute already exists: \" + attribute.getClass().getSimpleName());\n+        }\n+        attributes.put(attribute.getClass(), attribute);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/AttributedImpl.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.ArrayList;\n@@ -42,1 +43,1 @@\n-public abstract class DeclarationImpl implements Declaration {\n+public abstract class DeclarationImpl extends AttributedImpl implements Declaration {\n@@ -46,1 +47,0 @@\n-    private final Optional<Map<String, List<Constable>>> attributes;\n@@ -51,1 +51,0 @@\n-        this.attributes = Optional.ofNullable(attrs);\n@@ -67,22 +66,0 @@\n-    @Override\n-    public Optional<List<Constable>> getAttribute(String name) {\n-        return attributes.map(attrs -> attrs.get(name));\n-    }\n-\n-    @Override\n-    public Set<String> attributeNames() { return Collections.unmodifiableSet(\n-            attributes.map(Map::keySet).orElse(Collections.emptySet()));\n-    }\n-\n-    @Override\n-    public Declaration withAttribute(String name, Constable... values) {\n-        if (values == null || values.length == 0) {\n-            return withAttributes(null);\n-        }\n-        var attrs = attributes.map(HashMap::new).orElseGet(HashMap::new);\n-        attrs.put(name, List.of(values));\n-        return withAttributes(attrs);\n-    }\n-\n-    abstract protected Declaration withAttributes(Map<String, List<Constable>> attrs);\n-\n@@ -120,10 +97,0 @@\n-        @Override\n-        public Typedef withAttributes(Map<String, List<Constable>> attrs) {\n-            return new TypedefImpl(type, name(), pos(), attrs);\n-        }\n-\n-        @Override\n-        public Typedef stripAttributes() {\n-            return new TypedefImpl(type, name(), pos(), null);\n-        }\n-\n@@ -180,10 +147,0 @@\n-        @Override\n-        public Variable withAttributes(Map<String, List<Constable>> attrs) {\n-            return new VariableImpl(type, layout, kind, name(), pos(), attrs);\n-        }\n-\n-        @Override\n-        public Variable stripAttributes() {\n-            return new VariableImpl(type, layout, kind, name(), pos(), null);\n-        }\n-\n@@ -230,10 +187,0 @@\n-        @Override\n-        public Variable withAttributes(Map<String, List<Constable>> attrs) {\n-            return new BitfieldImpl(type, offset, width, name(), pos(), attrs);\n-        }\n-\n-        @Override\n-        public Variable stripAttributes() {\n-            return new BitfieldImpl(type, offset, width, name(), pos(), null);\n-        }\n-\n@@ -285,10 +232,0 @@\n-        @Override\n-        public Function withAttributes(Map<String, List<Constable>> attrs) {\n-            return new FunctionImpl(type, params, name(), pos(), attrs);\n-        }\n-\n-        @Override\n-        public Function stripAttributes() {\n-            return new FunctionImpl(type, params, name(), pos(), null);\n-        }\n-\n@@ -351,10 +288,0 @@\n-        @Override\n-        public Scoped withAttributes(Map<String, List<Constable>> attrs) {\n-            return new ScopedImpl(kind, optLayout, declarations, name(), pos(), attrs);\n-        }\n-\n-        @Override\n-        public Scoped stripAttributes() {\n-            return new ScopedImpl(kind, optLayout, declarations, name(), pos(), null);\n-        }\n-\n@@ -406,10 +333,0 @@\n-        @Override\n-        public Constant withAttributes(Map<String, List<Constable>> attrs) {\n-            return new ConstantImpl(type, value, name(), pos(), attrs);\n-        }\n-\n-        @Override\n-        public Constant stripAttributes() {\n-            return new ConstantImpl(type, value, name(), pos(), null);\n-        }\n-\n@@ -430,0 +347,10 @@\n+\n+    \/**\n+     * An attribute to mark anonymous struct declarations.\n+     *\/\n+    record AnonymousStruct() { }\n+\n+    \/**\n+     * An attribute to mark enum constants, with a link to the name of their parent enum.\n+     *\/\n+    record EnumConstant(String enumName) { }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/DeclarationImpl.java","additions":12,"deletions":85,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.EnumConstant;\n+\n@@ -37,1 +39,0 @@\n-    private static final String ENUM_NAME = \"enum-name\";\n@@ -44,1 +45,1 @@\n-        return constant.getAttribute(ENUM_NAME).map(attrs -> attrs.get(0).toString());\n+        return constant.getAttribute(EnumConstant.class).map(EnumConstant::enumName);\n@@ -87,3 +88,4 @@\n-            scoped.members().forEach(fieldTree -> fieldTree\n-                .withAttribute(ENUM_NAME, scoped.name())\n-                .accept(this, null));\n+            scoped.members().forEach(fieldTree -> {\n+                fieldTree.addAttribute(new EnumConstant(scoped.name()));\n+                fieldTree.accept(this, null);\n+            });\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/EnumConstantLifter.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Collection;\n@@ -59,3 +60,13 @@\n-        Set<String> attrs = decl.attributeNames();\n-        if (attrs.isEmpty()) {\n-            return;\n+        Collection<Record> attrs = decl.attributes();\n+        if (!attrs.isEmpty()) {\n+            incr();\n+            builder.append(\"Attributes: \");\n+            String sep = \"\\n\";\n+            for (Record attr : attrs) {\n+                incr();\n+                builder.append(sep);\n+                builder.append(attr);\n+                decr();\n+                sep = \",\\n\";\n+            }\n+            decr();\n@@ -63,12 +74,0 @@\n-        incr();\n-        indent();\n-        for (String k: attrs) {\n-            builder.append(\"Attr: \");\n-            builder.append(k);\n-            builder.append(\" -> [\");\n-            builder.append(decl.getAttribute(k).get().stream()\n-                .map(Constable::toString)\n-                .collect(Collectors.joining(\", \")));\n-            builder.append(\"]\\n\");\n-        }\n-        decr();\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/PrettyPrinter.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.AnonymousStruct;\n@@ -117,1 +118,1 @@\n-            declaration = (Declaration.Scoped)declaration.withAttribute(\"ANONYMOUS\", true);\n+            declaration.addAttribute(new AnonymousStruct());\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/RecordLayoutComputer.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.util.Collection;\n+import java.util.Collections;\n@@ -39,0 +41,1 @@\n+import org.openjdk.jextract.Declaration.ClangAttributes;\n@@ -46,0 +49,1 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.AnonymousStruct;\n@@ -56,2 +60,3 @@\n-    Map<String, List<Constable>> collectAttributes(Cursor c) {\n-        Map<String, List<Constable>> attributeMap = new HashMap<>();\n+    Declaration addAttributes(Declaration d, Cursor c) {\n+        if (d == null) return null;\n+        Map<String, List<String>> attributes = new HashMap<>();\n@@ -60,1 +65,1 @@\n-                List<Constable> attrs = attributeMap.computeIfAbsent(child.kind().name(), _unused -> new ArrayList<>());\n+                List<String> attrs = attributes.computeIfAbsent(child.kind().name(), _unused -> new ArrayList<>());\n@@ -64,1 +69,4 @@\n-        return attributeMap;\n+        if (!attributes.isEmpty()) {\n+            d.addAttribute(new ClangAttributes(Collections.unmodifiableMap(attributes)));\n+        }\n+        return d;\n@@ -94,1 +102,1 @@\n-        return (rv == null) ? null : rv.withAttributes(collectAttributes(c));\n+        return addAttributes(rv, c);\n@@ -249,1 +257,1 @@\n-        return declaration.getAttribute(\"ANONYMOUS\").isPresent();\n+        return declaration.getAttribute(AnonymousStruct.class).isPresent();\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeMaker.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-public abstract class TypeImpl implements Type {\n+public abstract class TypeImpl extends AttributedImpl implements Type {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypeImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,4 +25,0 @@\n-import java.lang.constant.Constable;\n-import java.time.LocalDateTime;\n-import java.time.format.DateTimeFormatter;\n-import java.util.List;\n@@ -30,1 +26,0 @@\n-import java.util.stream.Stream;\n@@ -33,0 +28,1 @@\n+import org.openjdk.jextract.Declaration.ClangAttributes;\n@@ -38,0 +34,1 @@\n+import static org.testng.Assert.assertTrue;\n@@ -44,1 +41,2 @@\n-        var attrs = d.getAttribute(ASMLABEL).get();\n+        var attrs = d.getAttribute(ClangAttributes.class).get();\n+        assertTrue(attrs.attributes().containsKey(ASMLABEL));\n@@ -48,1 +46,1 @@\n-        assertEquals(attrs.get(0), value);\n+        assertEquals(attrs.attributes().get(ASMLABEL).get(0), value);\n@@ -67,1 +65,1 @@\n-            if (foo.getAttribute(ASMLABEL).isPresent()) {\n+            if (foo.getAttribute(ClangAttributes.class).isPresent()) {\n@@ -81,1 +79,1 @@\n-            if (func.getAttribute(ASMLABEL).isPresent()) {\n+            if (func.getAttribute(ClangAttributes.class).isPresent()) {\n@@ -100,58 +98,0 @@\n-\n-    private static  Constable getSingleValue(Declaration d, String name) {\n-        List<Constable> values = d.getAttribute(name).get();\n-        assertEquals(1, values.size());\n-        return values.get(0);\n-    }\n-\n-    @Test\n-    public void testAddAttribute() {\n-        final String ts = \"timestamp\";\n-        Declaration.Scoped d = parse(\"libAsmSymbol.h\");\n-        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME);\n-        Declaration withAttrs = d.withAttribute(\"header\", d.name())\n-                .withAttribute(ts, timestamp);\n-\n-        assertEquals(getSingleValue(withAttrs, \"header\"), d.name());\n-        assertEquals(getSingleValue(withAttrs, ts), timestamp);\n-\n-        String timestamp2 = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n-        Declaration withNewAttrs = withAttrs.withAttribute(ts, timestamp2);\n-        assertEquals(getSingleValue(withNewAttrs, ts), timestamp2);\n-\n-        \/\/ Make sure original Declaration is not altered\n-        assertEquals(getSingleValue(withAttrs, ts), timestamp);\n-\n-        \/\/ Add more value to same attribute\n-        withNewAttrs = withAttrs.withAttribute(ts, Stream.concat(\n-                withAttrs.getAttribute(ts).map(List::stream).orElse(Stream.empty()),\n-                Stream.of(timestamp2)\n-            ).toArray(Constable[]::new));\n-        assertEquals(withNewAttrs.getAttribute(ts).get(), List.of(timestamp, timestamp2));\n-        assertEquals(getSingleValue(withNewAttrs,\"header\"), d.name());\n-\n-        \/\/ Remove attribute\n-        withAttrs = withNewAttrs.withAttribute(ts);\n-        assertTrue(withAttrs.getAttribute(ts).isEmpty());\n-\n-        \/\/ Strip attribute\n-        withNewAttrs = withNewAttrs.stripAttributes();\n-        assertTrue(withNewAttrs.attributeNames().isEmpty());\n-    }\n-\n-    private void assertTrue(boolean empty) {\n-    }\n-\n-    @Test\n-    public void replaceFunctionSymbol() {\n-        Declaration.Scoped d = parse(\"libAsmSymbol.h\", \"-DADD\");\n-        validateHeader(d, true);\n-\n-        var members = d.members().stream()\n-            .map(m -> m.getAttribute(ASMLABEL)\n-                    .map(attr -> m.withAttribute(ASMLABEL, attr.get(0).toString().replace('A', 'B')))\n-                    .orElse(m))\n-            .toArray(Declaration[]::new);\n-        Declaration.Scoped patched = Declaration.toplevel(d.pos(), members);\n-        validateHeader(patched, false);\n-    }\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/api\/TestAttributes.java","additions":8,"deletions":68,"binary":false,"changes":76,"status":"modified"}]}