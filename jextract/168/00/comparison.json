{"files":[{"patch":"@@ -102,1 +102,1 @@\n-        var valueType = Index_h.clang_getValueType(owner, segment);\n+        var valueType = Index_h.clang_Type_getValueType(owner, segment);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/Type.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n@@ -5,5 +30,6 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentAllocator;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.lang.foreign.*;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -22,0 +48,5 @@\n+    CXCursor() {\n+        \/\/ Suppresses public default constructor, ensuring non-instantiability,\n+        \/\/ but allows generated subclasses in same package.\n+    }\n+\n@@ -31,0 +62,1 @@\n+\n@@ -32,0 +64,1 @@\n+\n@@ -41,0 +74,5 @@\n+\n+    public static int kind$get(MemorySegment seg, long index) {\n+        return seg.get(Index_h.C_INT, kind$OFFSET + (index * sizeof()));\n+    }\n+\n@@ -50,3 +88,1 @@\n-    public static int kind$get(MemorySegment seg, long index) {\n-        return seg.get(Index_h.C_INT, kind$OFFSET + (index * sizeof()));\n-    }\n+\n@@ -56,0 +92,1 @@\n+\n@@ -57,0 +94,1 @@\n+\n@@ -66,0 +104,5 @@\n+\n+    public static int xdata$get(MemorySegment seg, long index) {\n+        return seg.get(Index_h.C_INT, xdata$OFFSET + (index * sizeof()));\n+    }\n+\n@@ -75,3 +118,1 @@\n-    public static int xdata$get(MemorySegment seg, long index) {\n-        return seg.get(Index_h.C_INT, xdata$OFFSET + (index * sizeof()));\n-    }\n+\n@@ -81,0 +122,1 @@\n+\n@@ -83,0 +125,1 @@\n+\n@@ -86,0 +129,1 @@\n+\n@@ -88,0 +132,1 @@\n+\n@@ -91,0 +136,1 @@\n+\n@@ -95,0 +141,1 @@\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXCursor.java","additions":58,"deletions":11,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -35,0 +36,1 @@\n+\n@@ -36,1 +38,1 @@\n- * {@snippet :\n+ * {@snippet lang=c :\n@@ -42,1 +44,11 @@\n-    int apply(java.lang.foreign.MemorySegment cursor, java.lang.foreign.MemorySegment parent, java.lang.foreign.MemorySegment client_data);\n+    int apply(MemorySegment cursor, MemorySegment parent, MemorySegment client_data);\n+\n+    FunctionDescriptor $DESC = FunctionDescriptor.of(\n+        Index_h.C_INT,\n+        CXCursor.$LAYOUT(),\n+        CXCursor.$LAYOUT(),\n+        Index_h.C_POINTER\n+    );\n+\n+    MethodHandle UP$MH = Index_h.upcallHandle(CXCursorVisitor.class, \"apply\", $DESC);\n+\n@@ -44,1 +56,1 @@\n-        return RuntimeHelper.upcallStub(CXCursorVisitor.class, fi, constants$13.CXCursorVisitor$FUNC, scope);\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n@@ -46,0 +58,3 @@\n+\n+    MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n@@ -48,1 +63,1 @@\n-        return (java.lang.foreign.MemorySegment _cursor, java.lang.foreign.MemorySegment _parent, java.lang.foreign.MemorySegment _client_data) -> {\n+        return (MemorySegment _cursor, MemorySegment _parent, MemorySegment _client_data) -> {\n@@ -50,1 +65,1 @@\n-                return (int)constants$13.CXCursorVisitor$MH.invokeExact(symbol, _cursor, _parent, _client_data);\n+                return (int) DOWN$MH.invokeExact(symbol, _cursor, _parent, _client_data);\n@@ -58,1 +73,0 @@\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXCursorVisitor.java","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.lang.foreign.*;\n+import static java.lang.foreign.ValueLayout.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * struct {\n+ *     void* ptr_data[2];\n+ *     unsigned int int_data;\n+ * };\n+ * }\n+ *\/\n+public class CXSourceLocation {\n+\n+    CXSourceLocation() {\n+        \/\/ Suppresses public default constructor, ensuring non-instantiability,\n+        \/\/ but allows generated subclasses in same package.\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, Index_h.C_POINTER).withName(\"ptr_data\"),\n+        Index_h.C_INT.withName(\"int_data\"),\n+        MemoryLayout.paddingLayout(4)\n+    ).withName(\"$anon$456:9\");\n+\n+    public static final GroupLayout $LAYOUT() {\n+        return $LAYOUT;\n+    }\n+\n+    private static final long ptr_data$OFFSET = 0;\n+    private static final long ptr_data$SIZE = 16;\n+\n+    public static MemorySegment ptr_data$slice(MemorySegment seg) {\n+        return seg.asSlice(ptr_data$OFFSET, ptr_data$SIZE);\n+    }\n+\n+    private static final long int_data$OFFSET = 16;\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * unsigned int int_data;\n+     * }\n+     *\/\n+    public static int int_data$get(MemorySegment seg) {\n+        return seg.get(Index_h.C_INT, int_data$OFFSET);\n+    }\n+\n+    public static int int_data$get(MemorySegment seg, long index) {\n+        return seg.get(Index_h.C_INT, int_data$OFFSET + (index * sizeof()));\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * unsigned int int_data;\n+     * }\n+     *\/\n+    public static void int_data$set(MemorySegment seg, int x) {\n+        seg.set(Index_h.C_INT, int_data$OFFSET, x);\n+    }\n+\n+    public static void int_data$set(MemorySegment seg, long index, int x) {\n+        seg.set(Index_h.C_INT, int_data$OFFSET + (index * sizeof()), x);\n+    }\n+\n+    public static long sizeof() { return $LAYOUT().byteSize(); }\n+    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }\n+\n+    public static MemorySegment allocateArray(long len, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));\n+    }\n+\n+    public static MemorySegment ofAddress(MemorySegment addr, Arena scope) {\n+        return addr.reinterpret($LAYOUT().byteSize(), scope, null);\n+    }\n+}\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXSourceLocation.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.lang.foreign.*;\n+import static java.lang.foreign.ValueLayout.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * struct {\n+ *     void* ptr_data[2];\n+ *     unsigned int begin_int_data;\n+ *     unsigned int end_int_data;\n+ * };\n+ * }\n+ *\/\n+public class CXSourceRange {\n+\n+    CXSourceRange() {\n+        \/\/ Suppresses public default constructor, ensuring non-instantiability,\n+        \/\/ but allows generated subclasses in same package.\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, Index_h.C_POINTER).withName(\"ptr_data\"),\n+        Index_h.C_INT.withName(\"begin_int_data\"),\n+        Index_h.C_INT.withName(\"end_int_data\")\n+    ).withName(\"$anon$467:9\");\n+\n+    public static final GroupLayout $LAYOUT() {\n+        return $LAYOUT;\n+    }\n+\n+    private static final long ptr_data$OFFSET = 0;\n+    private static final long ptr_data$SIZE = 16;\n+\n+    public static MemorySegment ptr_data$slice(MemorySegment seg) {\n+        return seg.asSlice(ptr_data$OFFSET, ptr_data$SIZE);\n+    }\n+\n+    private static final long begin_int_data$OFFSET = 16;\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * unsigned int begin_int_data;\n+     * }\n+     *\/\n+    public static int begin_int_data$get(MemorySegment seg) {\n+        return seg.get(Index_h.C_INT, begin_int_data$OFFSET);\n+    }\n+\n+    public static int begin_int_data$get(MemorySegment seg, long index) {\n+        return seg.get(Index_h.C_INT, begin_int_data$OFFSET + (index * sizeof()));\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * unsigned int begin_int_data;\n+     * }\n+     *\/\n+    public static void begin_int_data$set(MemorySegment seg, int x) {\n+        seg.set(Index_h.C_INT, begin_int_data$OFFSET, x);\n+    }\n+\n+    public static void begin_int_data$set(MemorySegment seg, long index, int x) {\n+        seg.set(Index_h.C_INT, begin_int_data$OFFSET + (index * sizeof()), x);\n+    }\n+\n+    private static final long end_int_data$OFFSET = 20;\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * unsigned int end_int_data;\n+     * }\n+     *\/\n+    public static int end_int_data$get(MemorySegment seg) {\n+        return seg.get(Index_h.C_INT, end_int_data$OFFSET);\n+    }\n+\n+    public static int end_int_data$get(MemorySegment seg, long index) {\n+        return seg.get(Index_h.C_INT, end_int_data$OFFSET + (index * sizeof()));\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * unsigned int end_int_data;\n+     * }\n+     *\/\n+    public static void end_int_data$set(MemorySegment seg, int x) {\n+        seg.set(Index_h.C_INT, end_int_data$OFFSET, x);\n+    }\n+\n+    public static void end_int_data$set(MemorySegment seg, long index, int x) {\n+        seg.set(Index_h.C_INT, end_int_data$OFFSET + (index * sizeof()), x);\n+    }\n+\n+    public static long sizeof() { return $LAYOUT().byteSize(); }\n+    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }\n+\n+    public static MemorySegment allocateArray(long len, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));\n+    }\n+\n+    public static MemorySegment ofAddress(MemorySegment addr, Arena scope) {\n+        return addr.reinterpret($LAYOUT().byteSize(), scope, null);\n+    }\n+}\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXSourceRange.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -35,0 +36,1 @@\n+\n@@ -36,1 +38,1 @@\n- * {@snippet :\n+ * {@snippet lang=c :\n@@ -45,7 +47,3 @@\n-    static final StructLayout $struct$LAYOUT = MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    );\n-    public static MemoryLayout $LAYOUT() {\n-        return CXString.$struct$LAYOUT;\n+    CXString() {\n+        \/\/ Suppresses public default constructor, ensuring non-instantiability,\n+        \/\/ but allows generated subclasses in same package.\n@@ -53,3 +51,9 @@\n-    static final VarHandle data$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"data\"));\n-    public static VarHandle data$VH() {\n-        return CXString.data$VH;\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        Index_h.C_POINTER.withName(\"data\"),\n+        Index_h.C_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(4)\n+    ).withName(\"$anon$37:9\");\n+\n+    public static final GroupLayout $LAYOUT() {\n+        return $LAYOUT;\n@@ -57,0 +61,3 @@\n+\n+    private static final long data$OFFSET = 0;\n+\n@@ -59,1 +66,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -64,1 +71,1 @@\n-        return (java.lang.foreign.MemorySegment)CXString.data$VH.get(seg, 0L);\n+        return seg.get(Index_h.C_POINTER, data$OFFSET);\n@@ -66,0 +73,5 @@\n+\n+    public static MemorySegment data$get(MemorySegment seg, long index) {\n+        return seg.get(Index_h.C_POINTER, data$OFFSET + (index * sizeof()));\n+    }\n+\n@@ -68,1 +80,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -73,4 +85,1 @@\n-        CXString.data$VH.set(seg, 0L, x);\n-    }\n-    public static MemorySegment data$get(MemorySegment seg, long index) {\n-        return (java.lang.foreign.MemorySegment)CXString.data$VH.get(seg.asSlice(index*sizeof()));\n+        seg.set(Index_h.C_POINTER, data$OFFSET, x);\n@@ -78,0 +87,1 @@\n+\n@@ -79,5 +89,1 @@\n-        CXString.data$VH.set(seg.asSlice(index*sizeof()), x);\n-    }\n-    static final VarHandle private_flags$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"private_flags\"));\n-    public static VarHandle private_flags$VH() {\n-        return CXString.private_flags$VH;\n+        seg.set(Index_h.C_POINTER, data$OFFSET + (index * sizeof()), x);\n@@ -85,0 +91,3 @@\n+\n+    private static final long private_flags$OFFSET = 8;\n+\n@@ -87,1 +96,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -92,1 +101,1 @@\n-        return (int)CXString.private_flags$VH.get(seg, 0L);\n+        return seg.get(Index_h.C_INT, private_flags$OFFSET);\n@@ -94,0 +103,5 @@\n+\n+    public static int private_flags$get(MemorySegment seg, long index) {\n+        return seg.get(Index_h.C_INT, private_flags$OFFSET + (index * sizeof()));\n+    }\n+\n@@ -96,1 +110,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -101,4 +115,1 @@\n-        CXString.private_flags$VH.set(seg, 0L, x);\n-    }\n-    public static int private_flags$get(MemorySegment seg, long index) {\n-        return (int)CXString.private_flags$VH.get(seg.asSlice(index*sizeof()));\n+        seg.set(Index_h.C_INT, private_flags$OFFSET, x);\n@@ -106,0 +117,1 @@\n+\n@@ -107,1 +119,1 @@\n-        CXString.private_flags$VH.set(seg.asSlice(index*sizeof()), x);\n+        seg.set(Index_h.C_INT, private_flags$OFFSET + (index * sizeof()), x);\n@@ -109,0 +121,1 @@\n+\n@@ -111,0 +124,1 @@\n+\n@@ -114,2 +128,0 @@\n-    public static MemorySegment ofAddress(MemorySegment addr, Arena scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }\n-}\n@@ -117,0 +129,4 @@\n+    public static MemorySegment ofAddress(MemorySegment addr, Arena scope) {\n+        return addr.reinterpret($LAYOUT().byteSize(), scope, null);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXString.java","additions":50,"deletions":34,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -35,0 +36,1 @@\n+\n@@ -36,1 +38,1 @@\n- * {@snippet :\n+ * {@snippet lang=c :\n@@ -45,6 +47,3 @@\n-    static final StructLayout $struct$LAYOUT = MemoryLayout.structLayout(\n-        MemoryLayout.sequenceLayout(4, Constants$root.C_INT$LAYOUT).withName(\"int_data\"),\n-        Constants$root.C_POINTER$LAYOUT.withName(\"ptr_data\")\n-    );\n-    public static MemoryLayout $LAYOUT() {\n-        return CXToken.$struct$LAYOUT;\n+    CXToken() {\n+        \/\/ Suppresses public default constructor, ensuring non-instantiability,\n+        \/\/ but allows generated subclasses in same package.\n@@ -52,2 +51,8 @@\n-    public static MemorySegment int_data$slice(MemorySegment seg) {\n-        return seg.asSlice(0, 16);\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(4, Index_h.C_INT).withName(\"int_data\"),\n+        Index_h.C_POINTER.withName(\"ptr_data\")\n+    ).withName(\"$anon$4996:9\");\n+\n+    public static final GroupLayout $LAYOUT() {\n+        return $LAYOUT;\n@@ -55,3 +60,6 @@\n-    static final VarHandle ptr_data$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"ptr_data\"));\n-    public static VarHandle ptr_data$VH() {\n-        return CXToken.ptr_data$VH;\n+\n+    private static final long int_data$OFFSET = 0;\n+    private static final long int_data$SIZE = 16;\n+\n+    public static MemorySegment int_data$slice(MemorySegment seg) {\n+        return seg.asSlice(int_data$OFFSET, int_data$SIZE);\n@@ -59,0 +67,3 @@\n+\n+    private static final long ptr_data$OFFSET = 16;\n+\n@@ -61,1 +72,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -66,1 +77,1 @@\n-        return (java.lang.foreign.MemorySegment)CXToken.ptr_data$VH.get(seg, 0L);\n+        return seg.get(Index_h.C_POINTER, ptr_data$OFFSET);\n@@ -68,0 +79,5 @@\n+\n+    public static MemorySegment ptr_data$get(MemorySegment seg, long index) {\n+        return seg.get(Index_h.C_POINTER, ptr_data$OFFSET + (index * sizeof()));\n+    }\n+\n@@ -70,1 +86,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -75,4 +91,1 @@\n-        CXToken.ptr_data$VH.set(seg, 0L, x);\n-    }\n-    public static MemorySegment ptr_data$get(MemorySegment seg, long index) {\n-        return (java.lang.foreign.MemorySegment)CXToken.ptr_data$VH.get(seg.asSlice(index*sizeof()));\n+        seg.set(Index_h.C_POINTER, ptr_data$OFFSET, x);\n@@ -80,0 +93,1 @@\n+\n@@ -81,1 +95,1 @@\n-        CXToken.ptr_data$VH.set(seg.asSlice(index*sizeof()), x);\n+        seg.set(Index_h.C_POINTER, ptr_data$OFFSET + (index * sizeof()), x);\n@@ -83,0 +97,1 @@\n+\n@@ -85,0 +100,1 @@\n+\n@@ -88,2 +104,0 @@\n-    public static MemorySegment ofAddress(MemorySegment addr, Arena scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }\n-}\n@@ -91,0 +105,4 @@\n+    public static MemorySegment ofAddress(MemorySegment addr, Arena scope) {\n+        return addr.reinterpret($LAYOUT().byteSize(), scope, null);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXToken.java","additions":41,"deletions":23,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -35,0 +36,1 @@\n+\n@@ -36,1 +38,1 @@\n- * {@snippet :\n+ * {@snippet lang=c :\n@@ -45,7 +47,3 @@\n-    static final StructLayout $struct$LAYOUT = MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        MemoryLayout.paddingLayout(4),\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    );\n-    public static MemoryLayout $LAYOUT() {\n-        return CXType.$struct$LAYOUT;\n+    CXType() {\n+        \/\/ Suppresses public default constructor, ensuring non-instantiability,\n+        \/\/ but allows generated subclasses in same package.\n@@ -53,3 +51,9 @@\n-    static final VarHandle kind$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"kind\"));\n-    public static VarHandle kind$VH() {\n-        return CXType.kind$VH;\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        Index_h.C_INT.withName(\"kind\"),\n+        MemoryLayout.paddingLayout(4),\n+        MemoryLayout.sequenceLayout(2, Index_h.C_POINTER).withName(\"data\")\n+    ).withName(\"$anon$3431:9\");\n+\n+    public static final GroupLayout $LAYOUT() {\n+        return $LAYOUT;\n@@ -57,0 +61,3 @@\n+\n+    private static final long kind$OFFSET = 0;\n+\n@@ -59,1 +66,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -64,1 +71,1 @@\n-        return (int)CXType.kind$VH.get(seg, 0L);\n+        return seg.get(Index_h.C_INT, kind$OFFSET);\n@@ -66,0 +73,5 @@\n+\n+    public static int kind$get(MemorySegment seg, long index) {\n+        return seg.get(Index_h.C_INT, kind$OFFSET + (index * sizeof()));\n+    }\n+\n@@ -68,1 +80,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -73,4 +85,1 @@\n-        CXType.kind$VH.set(seg, 0L, x);\n-    }\n-    public static int kind$get(MemorySegment seg, long index) {\n-        return (int)CXType.kind$VH.get(seg.asSlice(index*sizeof()));\n+        seg.set(Index_h.C_INT, kind$OFFSET, x);\n@@ -78,0 +87,1 @@\n+\n@@ -79,1 +89,1 @@\n-        CXType.kind$VH.set(seg.asSlice(index*sizeof()), x);\n+        seg.set(Index_h.C_INT, kind$OFFSET + (index * sizeof()), x);\n@@ -81,0 +91,4 @@\n+\n+    private static final long data$OFFSET = 8;\n+    private static final long data$SIZE = 16;\n+\n@@ -82,1 +96,1 @@\n-        return seg.asSlice(8, 16);\n+        return seg.asSlice(data$OFFSET, data$SIZE);\n@@ -84,0 +98,1 @@\n+\n@@ -86,0 +101,1 @@\n+\n@@ -89,2 +105,0 @@\n-    public static MemorySegment ofAddress(MemorySegment addr, Arena scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }\n-}\n@@ -92,0 +106,4 @@\n+    public static MemorySegment ofAddress(MemorySegment addr, Arena scope) {\n+        return addr.reinterpret($LAYOUT().byteSize(), scope, null);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXType.java","additions":41,"deletions":23,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -35,0 +36,1 @@\n+\n@@ -36,1 +38,1 @@\n- * {@snippet :\n+ * {@snippet lang=c :\n@@ -46,7 +48,3 @@\n-    static final StructLayout $struct$LAYOUT = MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"Filename\"),\n-        Constants$root.C_POINTER$LAYOUT.withName(\"Contents\"),\n-        Constants$root.C_LONG_LONG$LAYOUT.withName(\"Length\")\n-    ).withName(\"CXUnsavedFile\");\n-    public static MemoryLayout $LAYOUT() {\n-        return CXUnsavedFile.$struct$LAYOUT;\n+    CXUnsavedFile() {\n+        \/\/ Suppresses public default constructor, ensuring non-instantiability,\n+        \/\/ but allows generated subclasses in same package.\n@@ -54,3 +52,9 @@\n-    static final VarHandle Filename$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"Filename\"));\n-    public static VarHandle Filename$VH() {\n-        return CXUnsavedFile.Filename$VH;\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        Index_h.C_POINTER.withName(\"Filename\"),\n+        Index_h.C_POINTER.withName(\"Contents\"),\n+        Index_h.C_LONG.withName(\"Length\")\n+    ).withName(\"CXUnsavedFile\");\n+\n+    public static final GroupLayout $LAYOUT() {\n+        return $LAYOUT;\n@@ -58,0 +62,3 @@\n+\n+    private static final long Filename$OFFSET = 0;\n+\n@@ -60,1 +67,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -65,1 +72,5 @@\n-        return (java.lang.foreign.MemorySegment)CXUnsavedFile.Filename$VH.get(seg, 0L);\n+        return seg.get(Index_h.C_POINTER, Filename$OFFSET);\n+    }\n+\n+    public static MemorySegment Filename$get(MemorySegment seg, long index) {\n+        return seg.get(Index_h.C_POINTER, Filename$OFFSET + (index * sizeof()));\n@@ -67,0 +78,1 @@\n+\n@@ -69,1 +81,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -74,4 +86,1 @@\n-        CXUnsavedFile.Filename$VH.set(seg, 0L, x);\n-    }\n-    public static MemorySegment Filename$get(MemorySegment seg, long index) {\n-        return (java.lang.foreign.MemorySegment)CXUnsavedFile.Filename$VH.get(seg.asSlice(index*sizeof()));\n+        seg.set(Index_h.C_POINTER, Filename$OFFSET, x);\n@@ -79,0 +88,1 @@\n+\n@@ -80,5 +90,1 @@\n-        CXUnsavedFile.Filename$VH.set(seg.asSlice(index*sizeof()), x);\n-    }\n-    static final VarHandle Contents$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"Contents\"));\n-    public static VarHandle Contents$VH() {\n-        return CXUnsavedFile.Contents$VH;\n+        seg.set(Index_h.C_POINTER, Filename$OFFSET + (index * sizeof()), x);\n@@ -86,0 +92,3 @@\n+\n+    private static final long Contents$OFFSET = 8;\n+\n@@ -88,1 +97,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -93,1 +102,5 @@\n-        return (java.lang.foreign.MemorySegment)CXUnsavedFile.Contents$VH.get(seg, 0L);\n+        return seg.get(Index_h.C_POINTER, Contents$OFFSET);\n+    }\n+\n+    public static MemorySegment Contents$get(MemorySegment seg, long index) {\n+        return seg.get(Index_h.C_POINTER, Contents$OFFSET + (index * sizeof()));\n@@ -95,0 +108,1 @@\n+\n@@ -97,1 +111,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -102,4 +116,1 @@\n-        CXUnsavedFile.Contents$VH.set(seg, 0L, x);\n-    }\n-    public static MemorySegment Contents$get(MemorySegment seg, long index) {\n-        return (java.lang.foreign.MemorySegment)CXUnsavedFile.Contents$VH.get(seg.asSlice(index*sizeof()));\n+        seg.set(Index_h.C_POINTER, Contents$OFFSET, x);\n@@ -107,0 +118,1 @@\n+\n@@ -108,5 +120,1 @@\n-        CXUnsavedFile.Contents$VH.set(seg.asSlice(index*sizeof()), x);\n-    }\n-    static final VarHandle Length$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"Length\"));\n-    public static VarHandle Length$VH() {\n-        return CXUnsavedFile.Length$VH;\n+        seg.set(Index_h.C_POINTER, Contents$OFFSET + (index * sizeof()), x);\n@@ -114,0 +122,3 @@\n+\n+    private static final long Length$OFFSET = 16;\n+\n@@ -116,1 +127,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -121,1 +132,5 @@\n-        return (long)CXUnsavedFile.Length$VH.get(seg, 0L);\n+        return seg.get(Index_h.C_LONG, Length$OFFSET);\n+    }\n+\n+    public static long Length$get(MemorySegment seg, long index) {\n+        return seg.get(Index_h.C_LONG, Length$OFFSET + (index * sizeof()));\n@@ -123,0 +138,1 @@\n+\n@@ -125,1 +141,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -130,4 +146,1 @@\n-        CXUnsavedFile.Length$VH.set(seg, 0L, x);\n-    }\n-    public static long Length$get(MemorySegment seg, long index) {\n-        return (long)CXUnsavedFile.Length$VH.get(seg.asSlice(index*sizeof()));\n+        seg.set(Index_h.C_LONG, Length$OFFSET, x);\n@@ -135,0 +148,1 @@\n+\n@@ -136,1 +150,1 @@\n-        CXUnsavedFile.Length$VH.set(seg.asSlice(index*sizeof()), x);\n+        seg.set(Index_h.C_LONG, Length$OFFSET + (index * sizeof()), x);\n@@ -138,0 +152,1 @@\n+\n@@ -140,0 +155,1 @@\n+\n@@ -143,2 +159,0 @@\n-    public static MemorySegment ofAddress(MemorySegment addr, Arena scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }\n-}\n@@ -146,0 +160,4 @@\n+    public static MemorySegment ofAddress(MemorySegment addr, Arena scope) {\n+        return addr.reinterpret($LAYOUT().byteSize(), scope, null);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXUnsavedFile.java","additions":64,"deletions":46,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class Constants$root {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private Constants$root() {}\n-    static final OfBoolean C_BOOL$LAYOUT = JAVA_BOOLEAN;\n-    static final OfByte C_CHAR$LAYOUT = JAVA_BYTE;\n-    static final OfShort C_SHORT$LAYOUT = JAVA_SHORT;\n-    static final OfInt C_INT$LAYOUT = JAVA_INT;\n-    static final OfLong C_LONG$LAYOUT = JAVA_LONG;\n-    static final OfLong C_LONG_LONG$LAYOUT = JAVA_LONG;\n-    static final OfFloat C_FLOAT$LAYOUT = JAVA_FLOAT;\n-    static final OfDouble C_DOUBLE$LAYOUT = JAVA_DOUBLE;\n-    static final AddressLayout C_POINTER$LAYOUT = ADDRESS\n-            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, C_CHAR$LAYOUT));\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/Constants$root.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -35,12 +36,76 @@\n-public class Index_h  {\n-\n-    public static final OfByte C_CHAR = Constants$root.C_CHAR$LAYOUT;\n-    public static final OfShort C_SHORT = Constants$root.C_SHORT$LAYOUT;\n-    public static final OfInt C_INT = Constants$root.C_INT$LAYOUT;\n-    public static final OfLong C_LONG = Constants$root.C_LONG_LONG$LAYOUT;\n-    public static final OfLong C_LONG_LONG = Constants$root.C_LONG_LONG$LAYOUT;\n-    public static final OfFloat C_FLOAT = Constants$root.C_FLOAT$LAYOUT;\n-    public static final OfDouble C_DOUBLE = Constants$root.C_DOUBLE$LAYOUT;\n-    public static final AddressLayout C_POINTER = Constants$root.C_POINTER$LAYOUT;\n-    \/**\n-     * {@snippet :\n+\n+public class Index_h {\n+\n+    static final SymbolLookup SYMBOL_LOOKUP\n+            = SymbolLookup.loaderLookup().or(Linker.nativeLinker().defaultLookup());\n+\n+    static {\n+        System.loadLibrary(\"clang\");\n+    }\n+\n+    Index_h() {\n+        \/\/ Suppresses public default constructor, ensuring non-instantiability,\n+        \/\/ but allows generated subclasses in same package.\n+    }\n+\n+    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n+    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n+    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n+    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n+    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS\n+            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));\n+    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;\n+\n+    static MemorySegment findOrThrow(String symbol) {\n+        return SYMBOL_LOOKUP.find(symbol)\n+            .orElseThrow(() -> new UnsatisfiedLinkError(\"unresolved symbol: \" + symbol));\n+    }\n+\n+    static MemoryLayout[] inferVariadicLayouts(Object[] varargs) {\n+        MemoryLayout[] result = new MemoryLayout[varargs.length];\n+        for (int i = 0; i < varargs.length; i++) {\n+            result[i] = variadicLayout(varargs[i].getClass());\n+        }\n+        return result;\n+    }\n+\n+    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n+        try {\n+            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static MethodHandle downcallHandleVariadic(String name, FunctionDescriptor baseDesc, MemoryLayout[] variadicLayouts) {\n+        FunctionDescriptor variadicDesc = baseDesc.appendArgumentLayouts(variadicLayouts);\n+        Linker.Option fva = Linker.Option.firstVariadicArg(baseDesc.argumentLayouts().size());\n+        return SYMBOL_LOOKUP.find(name)\n+                .map(addr -> Linker.nativeLinker().downcallHandle(addr, variadicDesc, fva)\n+                        .asSpreader(Object[].class, variadicLayouts.length))\n+                .orElse(null);\n+    }\n+\n+    \/\/ Internals only below this point\n+\n+    private static MemoryLayout variadicLayout(Class<?> c) {\n+        \/\/ apply default argument promotions per C spec\n+        \/\/ note that all primitives are boxed, since they are passed through an Object[]\n+        if (c == Boolean.class || c == Byte.class || c == Character.class || c == Short.class || c == Integer.class) {\n+            return JAVA_INT;\n+        } else if (c == Long.class) {\n+            return JAVA_LONG;\n+        } else if (c == Float.class || c == Double.class) {\n+            return JAVA_DOUBLE;\n+        } else if (MemorySegment.class.isAssignableFrom(c)) {\n+            return ADDRESS;\n+        }\n+        throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n+    }\n+    private static final int CXError_Success = (int)0L;\n+\n+    \/**\n+     * {@snippet lang=c :\n@@ -51,1 +116,1 @@\n-        return (int)0L;\n+        return CXError_Success;\n@@ -53,0 +118,2 @@\n+    private static final int CXError_Failure = (int)1L;\n+\n@@ -54,1 +121,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -59,1 +126,1 @@\n-        return (int)1L;\n+        return CXError_Failure;\n@@ -61,0 +128,2 @@\n+    private static final int CXError_Crashed = (int)2L;\n+\n@@ -62,1 +131,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -67,1 +136,1 @@\n-        return (int)2L;\n+        return CXError_Crashed;\n@@ -69,0 +138,2 @@\n+    private static final int CXError_InvalidArguments = (int)3L;\n+\n@@ -70,1 +141,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -75,1 +146,1 @@\n-        return (int)3L;\n+        return CXError_InvalidArguments;\n@@ -77,0 +148,2 @@\n+    private static final int CXError_ASTReadError = (int)4L;\n+\n@@ -78,1 +151,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -83,4 +156,1 @@\n-        return (int)4L;\n-    }\n-    public static MethodHandle clang_getCString$MH() {\n-        return RuntimeHelper.requireNonNull(constants$0.clang_getCString$MH,\"clang_getCString\");\n+        return CXError_ASTReadError;\n@@ -89,1 +159,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -93,0 +163,14 @@\n+    public static MethodHandle clang_getCString$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_POINTER,\n+                CXString.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCString\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -96,1 +180,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(string);\n+            return (MemorySegment) mh$.invokeExact(string);\n@@ -98,1 +182,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -101,3 +185,0 @@\n-    public static MethodHandle clang_disposeString$MH() {\n-        return RuntimeHelper.requireNonNull(constants$0.clang_disposeString$MH,\"clang_disposeString\");\n-    }\n@@ -105,1 +186,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -109,0 +190,13 @@\n+    public static MethodHandle clang_disposeString$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+                CXString.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_disposeString\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -114,1 +208,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -118,1 +212,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -122,1 +216,1 @@\n-    public static final AddressLayout CXIndex = Constants$root.C_POINTER$LAYOUT;\n+    public static final AddressLayout CXIndex = Index_h.C_POINTER;\n@@ -124,1 +218,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -128,1 +222,3 @@\n-    public static final AddressLayout CXTranslationUnit = Constants$root.C_POINTER$LAYOUT;\n+    public static final AddressLayout CXTranslationUnit = Index_h.C_POINTER;\n+    private static final int CXCursor_ExceptionSpecificationKind_None = (int)0L;\n+\n@@ -130,1 +226,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -135,1 +231,1 @@\n-        return (int)0L;\n+        return CXCursor_ExceptionSpecificationKind_None;\n@@ -137,0 +233,2 @@\n+    private static final int CXCursor_ExceptionSpecificationKind_DynamicNone = (int)1L;\n+\n@@ -138,1 +236,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -143,1 +241,1 @@\n-        return (int)1L;\n+        return CXCursor_ExceptionSpecificationKind_DynamicNone;\n@@ -145,0 +243,2 @@\n+    private static final int CXCursor_ExceptionSpecificationKind_Dynamic = (int)2L;\n+\n@@ -146,1 +246,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -151,1 +251,1 @@\n-        return (int)2L;\n+        return CXCursor_ExceptionSpecificationKind_Dynamic;\n@@ -153,0 +253,2 @@\n+    private static final int CXCursor_ExceptionSpecificationKind_MSAny = (int)3L;\n+\n@@ -154,1 +256,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -159,1 +261,1 @@\n-        return (int)3L;\n+        return CXCursor_ExceptionSpecificationKind_MSAny;\n@@ -161,0 +263,2 @@\n+    private static final int CXCursor_ExceptionSpecificationKind_BasicNoexcept = (int)4L;\n+\n@@ -162,1 +266,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -167,1 +271,1 @@\n-        return (int)4L;\n+        return CXCursor_ExceptionSpecificationKind_BasicNoexcept;\n@@ -169,0 +273,2 @@\n+    private static final int CXCursor_ExceptionSpecificationKind_ComputedNoexcept = (int)5L;\n+\n@@ -170,1 +276,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -175,1 +281,1 @@\n-        return (int)5L;\n+        return CXCursor_ExceptionSpecificationKind_ComputedNoexcept;\n@@ -177,0 +283,2 @@\n+    private static final int CXCursor_ExceptionSpecificationKind_Unevaluated = (int)6L;\n+\n@@ -178,1 +286,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -183,1 +291,1 @@\n-        return (int)6L;\n+        return CXCursor_ExceptionSpecificationKind_Unevaluated;\n@@ -185,0 +293,2 @@\n+    private static final int CXCursor_ExceptionSpecificationKind_Uninstantiated = (int)7L;\n+\n@@ -186,1 +296,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -191,1 +301,1 @@\n-        return (int)7L;\n+        return CXCursor_ExceptionSpecificationKind_Uninstantiated;\n@@ -193,0 +303,2 @@\n+    private static final int CXCursor_ExceptionSpecificationKind_Unparsed = (int)8L;\n+\n@@ -194,1 +306,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -199,1 +311,1 @@\n-        return (int)8L;\n+        return CXCursor_ExceptionSpecificationKind_Unparsed;\n@@ -201,0 +313,2 @@\n+    private static final int CXCursor_ExceptionSpecificationKind_NoThrow = (int)9L;\n+\n@@ -202,1 +316,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -207,4 +321,1 @@\n-        return (int)9L;\n-    }\n-    public static MethodHandle clang_createIndex$MH() {\n-        return RuntimeHelper.requireNonNull(constants$0.clang_createIndex$MH,\"clang_createIndex\");\n+        return CXCursor_ExceptionSpecificationKind_NoThrow;\n@@ -213,1 +324,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -217,0 +328,15 @@\n+    public static MethodHandle clang_createIndex$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_POINTER,\n+                Index_h.C_INT,\n+                Index_h.C_INT\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_createIndex\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -220,1 +346,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(excludeDeclarationsFromPCH, displayDiagnostics);\n+            return (MemorySegment) mh$.invokeExact(excludeDeclarationsFromPCH, displayDiagnostics);\n@@ -222,1 +348,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -225,3 +351,0 @@\n-    public static MethodHandle clang_disposeIndex$MH() {\n-        return RuntimeHelper.requireNonNull(constants$0.clang_disposeIndex$MH,\"clang_disposeIndex\");\n-    }\n@@ -229,1 +352,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -233,0 +356,13 @@\n+    public static MethodHandle clang_disposeIndex$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_disposeIndex\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -238,1 +374,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -241,3 +377,0 @@\n-    public static MethodHandle clang_getFileName$MH() {\n-        return RuntimeHelper.requireNonNull(constants$0.clang_getFileName$MH,\"clang_getFileName\");\n-    }\n@@ -245,1 +378,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -249,0 +382,14 @@\n+    public static MethodHandle clang_getFileName$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXString.$LAYOUT(),\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getFileName\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -252,1 +399,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, SFile);\n+            return (MemorySegment) mh$.invokeExact(allocator, SFile);\n@@ -254,1 +401,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -257,3 +404,0 @@\n-    public static MethodHandle clang_getNullLocation$MH() {\n-        return RuntimeHelper.requireNonNull(constants$0.clang_getNullLocation$MH,\"clang_getNullLocation\");\n-    }\n@@ -261,1 +405,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -265,0 +409,12 @@\n+    public static MethodHandle clang_getNullLocation$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXSourceLocation.$LAYOUT()        );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getNullLocation\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -268,1 +424,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator);\n+            return (MemorySegment) mh$.invokeExact(allocator);\n@@ -270,1 +426,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -273,3 +429,0 @@\n-    public static MethodHandle clang_equalLocations$MH() {\n-        return RuntimeHelper.requireNonNull(constants$1.clang_equalLocations$MH,\"clang_equalLocations\");\n-    }\n@@ -277,1 +430,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -281,0 +434,15 @@\n+    public static MethodHandle clang_equalLocations$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXSourceLocation.$LAYOUT(),\n+                CXSourceLocation.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_equalLocations\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -284,1 +452,1 @@\n-            return (int)mh$.invokeExact(loc1, loc2);\n+            return (int) mh$.invokeExact(loc1, loc2);\n@@ -286,1 +454,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -289,3 +457,0 @@\n-    public static MethodHandle clang_getLocation$MH() {\n-        return RuntimeHelper.requireNonNull(constants$1.clang_getLocation$MH,\"clang_getLocation\");\n-    }\n@@ -293,1 +458,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -297,0 +462,17 @@\n+    public static MethodHandle clang_getLocation$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXSourceLocation.$LAYOUT(),\n+                Index_h.C_POINTER,\n+                Index_h.C_POINTER,\n+                Index_h.C_INT,\n+                Index_h.C_INT\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getLocation\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -300,1 +482,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, tu, file, line, column);\n+            return (MemorySegment) mh$.invokeExact(allocator, tu, file, line, column);\n@@ -302,1 +484,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -305,3 +487,0 @@\n-    public static MethodHandle clang_getLocationForOffset$MH() {\n-        return RuntimeHelper.requireNonNull(constants$1.clang_getLocationForOffset$MH,\"clang_getLocationForOffset\");\n-    }\n@@ -309,1 +488,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -313,0 +492,16 @@\n+    public static MethodHandle clang_getLocationForOffset$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXSourceLocation.$LAYOUT(),\n+                Index_h.C_POINTER,\n+                Index_h.C_POINTER,\n+                Index_h.C_INT\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getLocationForOffset\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -316,1 +511,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, tu, file, offset);\n+            return (MemorySegment) mh$.invokeExact(allocator, tu, file, offset);\n@@ -318,1 +513,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -321,3 +516,0 @@\n-    public static MethodHandle clang_Location_isInSystemHeader$MH() {\n-        return RuntimeHelper.requireNonNull(constants$1.clang_Location_isInSystemHeader$MH,\"clang_Location_isInSystemHeader\");\n-    }\n@@ -325,1 +517,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -329,0 +521,14 @@\n+    public static MethodHandle clang_Location_isInSystemHeader$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXSourceLocation.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Location_isInSystemHeader\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -332,1 +538,1 @@\n-            return (int)mh$.invokeExact(location);\n+            return (int) mh$.invokeExact(location);\n@@ -334,1 +540,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -337,3 +543,0 @@\n-    public static MethodHandle clang_Location_isFromMainFile$MH() {\n-        return RuntimeHelper.requireNonNull(constants$1.clang_Location_isFromMainFile$MH,\"clang_Location_isFromMainFile\");\n-    }\n@@ -341,1 +544,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -345,0 +548,14 @@\n+    public static MethodHandle clang_Location_isFromMainFile$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXSourceLocation.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Location_isFromMainFile\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -348,1 +565,1 @@\n-            return (int)mh$.invokeExact(location);\n+            return (int) mh$.invokeExact(location);\n@@ -350,1 +567,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -353,3 +570,0 @@\n-    public static MethodHandle clang_Range_isNull$MH() {\n-        return RuntimeHelper.requireNonNull(constants$1.clang_Range_isNull$MH,\"clang_Range_isNull\");\n-    }\n@@ -357,1 +571,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -361,0 +575,14 @@\n+    public static MethodHandle clang_Range_isNull$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXSourceRange.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Range_isNull\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -364,1 +592,1 @@\n-            return (int)mh$.invokeExact(range);\n+            return (int) mh$.invokeExact(range);\n@@ -366,1 +594,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -369,3 +597,0 @@\n-    public static MethodHandle clang_getExpansionLocation$MH() {\n-        return RuntimeHelper.requireNonNull(constants$2.clang_getExpansionLocation$MH,\"clang_getExpansionLocation\");\n-    }\n@@ -373,1 +598,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -377,0 +602,17 @@\n+    public static MethodHandle clang_getExpansionLocation$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+                CXSourceLocation.$LAYOUT(),\n+                Index_h.C_POINTER,\n+                Index_h.C_POINTER,\n+                Index_h.C_POINTER,\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getExpansionLocation\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -382,1 +624,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -385,3 +627,0 @@\n-    public static MethodHandle clang_getSpellingLocation$MH() {\n-        return RuntimeHelper.requireNonNull(constants$2.clang_getSpellingLocation$MH,\"clang_getSpellingLocation\");\n-    }\n@@ -389,1 +628,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -393,0 +632,17 @@\n+    public static MethodHandle clang_getSpellingLocation$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+                CXSourceLocation.$LAYOUT(),\n+                Index_h.C_POINTER,\n+                Index_h.C_POINTER,\n+                Index_h.C_POINTER,\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getSpellingLocation\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -398,1 +654,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -401,3 +657,0 @@\n-    public static MethodHandle clang_getFileLocation$MH() {\n-        return RuntimeHelper.requireNonNull(constants$2.clang_getFileLocation$MH,\"clang_getFileLocation\");\n-    }\n@@ -405,1 +658,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -409,0 +662,17 @@\n+    public static MethodHandle clang_getFileLocation$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+                CXSourceLocation.$LAYOUT(),\n+                Index_h.C_POINTER,\n+                Index_h.C_POINTER,\n+                Index_h.C_POINTER,\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getFileLocation\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -414,1 +684,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -417,3 +687,0 @@\n-    public static MethodHandle clang_getRangeStart$MH() {\n-        return RuntimeHelper.requireNonNull(constants$2.clang_getRangeStart$MH,\"clang_getRangeStart\");\n-    }\n@@ -421,1 +688,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -425,0 +692,14 @@\n+    public static MethodHandle clang_getRangeStart$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXSourceLocation.$LAYOUT(),\n+                CXSourceRange.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getRangeStart\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -428,1 +709,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, range);\n+            return (MemorySegment) mh$.invokeExact(allocator, range);\n@@ -430,1 +711,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -433,3 +714,0 @@\n-    public static MethodHandle clang_getRangeEnd$MH() {\n-        return RuntimeHelper.requireNonNull(constants$2.clang_getRangeEnd$MH,\"clang_getRangeEnd\");\n-    }\n@@ -437,1 +715,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -441,0 +719,14 @@\n+    public static MethodHandle clang_getRangeEnd$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXSourceLocation.$LAYOUT(),\n+                CXSourceRange.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getRangeEnd\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -444,1 +736,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, range);\n+            return (MemorySegment) mh$.invokeExact(allocator, range);\n@@ -446,1 +738,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -449,0 +741,2 @@\n+    private static final int CXDiagnostic_Ignored = (int)0L;\n+\n@@ -450,1 +744,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -455,1 +749,1 @@\n-        return (int)0L;\n+        return CXDiagnostic_Ignored;\n@@ -457,0 +751,2 @@\n+    private static final int CXDiagnostic_Note = (int)1L;\n+\n@@ -458,1 +754,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -463,1 +759,1 @@\n-        return (int)1L;\n+        return CXDiagnostic_Note;\n@@ -465,0 +761,2 @@\n+    private static final int CXDiagnostic_Warning = (int)2L;\n+\n@@ -466,1 +764,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -471,1 +769,1 @@\n-        return (int)2L;\n+        return CXDiagnostic_Warning;\n@@ -473,0 +771,2 @@\n+    private static final int CXDiagnostic_Error = (int)3L;\n+\n@@ -474,1 +774,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -479,1 +779,1 @@\n-        return (int)3L;\n+        return CXDiagnostic_Error;\n@@ -481,0 +781,2 @@\n+    private static final int CXDiagnostic_Fatal = (int)4L;\n+\n@@ -482,1 +784,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -487,4 +789,1 @@\n-        return (int)4L;\n-    }\n-    public static MethodHandle clang_getChildDiagnostics$MH() {\n-        return RuntimeHelper.requireNonNull(constants$2.clang_getChildDiagnostics$MH,\"clang_getChildDiagnostics\");\n+        return CXDiagnostic_Fatal;\n@@ -493,1 +792,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -497,0 +796,14 @@\n+    public static MethodHandle clang_getChildDiagnostics$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_POINTER,\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getChildDiagnostics\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -500,1 +813,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(D);\n+            return (MemorySegment) mh$.invokeExact(D);\n@@ -502,1 +815,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -505,3 +818,0 @@\n-    public static MethodHandle clang_getNumDiagnostics$MH() {\n-        return RuntimeHelper.requireNonNull(constants$3.clang_getNumDiagnostics$MH,\"clang_getNumDiagnostics\");\n-    }\n@@ -509,1 +819,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -513,0 +823,14 @@\n+    public static MethodHandle clang_getNumDiagnostics$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getNumDiagnostics\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -516,1 +840,1 @@\n-            return (int)mh$.invokeExact(Unit);\n+            return (int) mh$.invokeExact(Unit);\n@@ -518,1 +842,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -521,3 +845,0 @@\n-    public static MethodHandle clang_getDiagnostic$MH() {\n-        return RuntimeHelper.requireNonNull(constants$3.clang_getDiagnostic$MH,\"clang_getDiagnostic\");\n-    }\n@@ -525,1 +846,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -529,0 +850,15 @@\n+    public static MethodHandle clang_getDiagnostic$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_POINTER,\n+                Index_h.C_POINTER,\n+                Index_h.C_INT\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getDiagnostic\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -532,1 +868,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(Unit, Index);\n+            return (MemorySegment) mh$.invokeExact(Unit, Index);\n@@ -534,1 +870,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -537,3 +873,0 @@\n-    public static MethodHandle clang_disposeDiagnostic$MH() {\n-        return RuntimeHelper.requireNonNull(constants$3.clang_disposeDiagnostic$MH,\"clang_disposeDiagnostic\");\n-    }\n@@ -541,1 +874,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -545,0 +878,13 @@\n+    public static MethodHandle clang_disposeDiagnostic$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_disposeDiagnostic\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -550,1 +896,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -553,0 +899,2 @@\n+    private static final int CXDiagnostic_DisplaySourceLocation = (int)1L;\n+\n@@ -554,1 +902,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -559,1 +907,1 @@\n-        return (int)1L;\n+        return CXDiagnostic_DisplaySourceLocation;\n@@ -561,0 +909,2 @@\n+    private static final int CXDiagnostic_DisplayColumn = (int)2L;\n+\n@@ -562,1 +912,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -567,1 +917,1 @@\n-        return (int)2L;\n+        return CXDiagnostic_DisplayColumn;\n@@ -569,0 +919,2 @@\n+    private static final int CXDiagnostic_DisplaySourceRanges = (int)4L;\n+\n@@ -570,1 +922,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -575,1 +927,1 @@\n-        return (int)4L;\n+        return CXDiagnostic_DisplaySourceRanges;\n@@ -577,0 +929,2 @@\n+    private static final int CXDiagnostic_DisplayOption = (int)8L;\n+\n@@ -578,1 +932,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -583,1 +937,1 @@\n-        return (int)8L;\n+        return CXDiagnostic_DisplayOption;\n@@ -585,0 +939,2 @@\n+    private static final int CXDiagnostic_DisplayCategoryId = (int)16L;\n+\n@@ -586,1 +942,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -591,1 +947,1 @@\n-        return (int)16L;\n+        return CXDiagnostic_DisplayCategoryId;\n@@ -593,0 +949,2 @@\n+    private static final int CXDiagnostic_DisplayCategoryName = (int)32L;\n+\n@@ -594,1 +952,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -599,4 +957,1 @@\n-        return (int)32L;\n-    }\n-    public static MethodHandle clang_formatDiagnostic$MH() {\n-        return RuntimeHelper.requireNonNull(constants$3.clang_formatDiagnostic$MH,\"clang_formatDiagnostic\");\n+        return CXDiagnostic_DisplayCategoryName;\n@@ -605,1 +960,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -609,0 +964,15 @@\n+    public static MethodHandle clang_formatDiagnostic$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXString.$LAYOUT(),\n+                Index_h.C_POINTER,\n+                Index_h.C_INT\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_formatDiagnostic\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -612,1 +982,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, Diagnostic, Options);\n+            return (MemorySegment) mh$.invokeExact(allocator, Diagnostic, Options);\n@@ -614,1 +984,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -617,3 +987,0 @@\n-    public static MethodHandle clang_defaultDiagnosticDisplayOptions$MH() {\n-        return RuntimeHelper.requireNonNull(constants$3.clang_defaultDiagnosticDisplayOptions$MH,\"clang_defaultDiagnosticDisplayOptions\");\n-    }\n@@ -621,1 +988,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -625,0 +992,12 @@\n+    public static MethodHandle clang_defaultDiagnosticDisplayOptions$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT        );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_defaultDiagnosticDisplayOptions\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -628,1 +1007,1 @@\n-            return (int)mh$.invokeExact();\n+            return (int) mh$.invokeExact();\n@@ -630,1 +1009,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -633,3 +1012,0 @@\n-    public static MethodHandle clang_getDiagnosticSeverity$MH() {\n-        return RuntimeHelper.requireNonNull(constants$3.clang_getDiagnosticSeverity$MH,\"clang_getDiagnosticSeverity\");\n-    }\n@@ -637,1 +1013,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -641,0 +1017,14 @@\n+    public static MethodHandle clang_getDiagnosticSeverity$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getDiagnosticSeverity\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -644,1 +1034,1 @@\n-            return (int)mh$.invokeExact(x0);\n+            return (int) mh$.invokeExact(x0);\n@@ -646,1 +1036,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -649,3 +1039,0 @@\n-    public static MethodHandle clang_getDiagnosticLocation$MH() {\n-        return RuntimeHelper.requireNonNull(constants$4.clang_getDiagnosticLocation$MH,\"clang_getDiagnosticLocation\");\n-    }\n@@ -653,1 +1040,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -657,1 +1044,15 @@\n-    public static MemorySegment clang_getDiagnosticLocation(SegmentAllocator allocator, MemorySegment x1) {\n+    public static MethodHandle clang_getDiagnosticLocation$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXSourceLocation.$LAYOUT(),\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getDiagnosticLocation\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n+    public static MemorySegment clang_getDiagnosticLocation(SegmentAllocator allocator, MemorySegment x0) {\n@@ -660,1 +1061,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+            return (MemorySegment) mh$.invokeExact(allocator, x0);\n@@ -662,1 +1063,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -665,3 +1066,0 @@\n-    public static MethodHandle clang_getDiagnosticSpelling$MH() {\n-        return RuntimeHelper.requireNonNull(constants$4.clang_getDiagnosticSpelling$MH,\"clang_getDiagnosticSpelling\");\n-    }\n@@ -669,1 +1067,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -673,1 +1071,15 @@\n-    public static MemorySegment clang_getDiagnosticSpelling(SegmentAllocator allocator, MemorySegment x1) {\n+    public static MethodHandle clang_getDiagnosticSpelling$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXString.$LAYOUT(),\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getDiagnosticSpelling\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n+    public static MemorySegment clang_getDiagnosticSpelling(SegmentAllocator allocator, MemorySegment x0) {\n@@ -676,1 +1088,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+            return (MemorySegment) mh$.invokeExact(allocator, x0);\n@@ -678,1 +1090,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -681,0 +1093,2 @@\n+    private static final int CXTranslationUnit_None = (int)0L;\n+\n@@ -682,1 +1096,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -687,1 +1101,1 @@\n-        return (int)0L;\n+        return CXTranslationUnit_None;\n@@ -689,0 +1103,2 @@\n+    private static final int CXTranslationUnit_DetailedPreprocessingRecord = (int)1L;\n+\n@@ -690,1 +1106,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -695,1 +1111,1 @@\n-        return (int)1L;\n+        return CXTranslationUnit_DetailedPreprocessingRecord;\n@@ -697,0 +1113,2 @@\n+    private static final int CXTranslationUnit_Incomplete = (int)2L;\n+\n@@ -698,1 +1116,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -703,1 +1121,1 @@\n-        return (int)2L;\n+        return CXTranslationUnit_Incomplete;\n@@ -705,0 +1123,2 @@\n+    private static final int CXTranslationUnit_PrecompiledPreamble = (int)4L;\n+\n@@ -706,1 +1126,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -711,1 +1131,1 @@\n-        return (int)4L;\n+        return CXTranslationUnit_PrecompiledPreamble;\n@@ -713,0 +1133,2 @@\n+    private static final int CXTranslationUnit_CacheCompletionResults = (int)8L;\n+\n@@ -714,1 +1136,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -719,1 +1141,1 @@\n-        return (int)8L;\n+        return CXTranslationUnit_CacheCompletionResults;\n@@ -721,0 +1143,2 @@\n+    private static final int CXTranslationUnit_ForSerialization = (int)16L;\n+\n@@ -722,1 +1146,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -727,1 +1151,1 @@\n-        return (int)16L;\n+        return CXTranslationUnit_ForSerialization;\n@@ -729,0 +1153,2 @@\n+    private static final int CXTranslationUnit_CXXChainedPCH = (int)32L;\n+\n@@ -730,1 +1156,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -735,1 +1161,1 @@\n-        return (int)32L;\n+        return CXTranslationUnit_CXXChainedPCH;\n@@ -737,0 +1163,2 @@\n+    private static final int CXTranslationUnit_SkipFunctionBodies = (int)64L;\n+\n@@ -738,1 +1166,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -743,1 +1171,1 @@\n-        return (int)64L;\n+        return CXTranslationUnit_SkipFunctionBodies;\n@@ -745,0 +1173,2 @@\n+    private static final int CXTranslationUnit_IncludeBriefCommentsInCodeCompletion = (int)128L;\n+\n@@ -746,1 +1176,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -751,1 +1181,1 @@\n-        return (int)128L;\n+        return CXTranslationUnit_IncludeBriefCommentsInCodeCompletion;\n@@ -753,0 +1183,2 @@\n+    private static final int CXTranslationUnit_CreatePreambleOnFirstParse = (int)256L;\n+\n@@ -754,1 +1186,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -759,1 +1191,1 @@\n-        return (int)256L;\n+        return CXTranslationUnit_CreatePreambleOnFirstParse;\n@@ -761,0 +1193,2 @@\n+    private static final int CXTranslationUnit_KeepGoing = (int)512L;\n+\n@@ -762,1 +1196,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -767,1 +1201,1 @@\n-        return (int)512L;\n+        return CXTranslationUnit_KeepGoing;\n@@ -769,0 +1203,2 @@\n+    private static final int CXTranslationUnit_SingleFileParse = (int)1024L;\n+\n@@ -770,1 +1206,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -775,1 +1211,1 @@\n-        return (int)1024L;\n+        return CXTranslationUnit_SingleFileParse;\n@@ -777,0 +1213,2 @@\n+    private static final int CXTranslationUnit_LimitSkipFunctionBodiesToPreamble = (int)2048L;\n+\n@@ -778,1 +1216,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -783,1 +1221,1 @@\n-        return (int)2048L;\n+        return CXTranslationUnit_LimitSkipFunctionBodiesToPreamble;\n@@ -785,0 +1223,2 @@\n+    private static final int CXTranslationUnit_IncludeAttributedTypes = (int)4096L;\n+\n@@ -786,1 +1226,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -791,1 +1231,1 @@\n-        return (int)4096L;\n+        return CXTranslationUnit_IncludeAttributedTypes;\n@@ -793,0 +1233,2 @@\n+    private static final int CXTranslationUnit_VisitImplicitAttributes = (int)8192L;\n+\n@@ -794,1 +1236,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -799,1 +1241,1 @@\n-        return (int)8192L;\n+        return CXTranslationUnit_VisitImplicitAttributes;\n@@ -801,0 +1243,2 @@\n+    private static final int CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles = (int)16384L;\n+\n@@ -802,1 +1246,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -807,1 +1251,1 @@\n-        return (int)16384L;\n+        return CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles;\n@@ -809,0 +1253,2 @@\n+    private static final int CXTranslationUnit_RetainExcludedConditionalBlocks = (int)32768L;\n+\n@@ -810,1 +1256,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -815,4 +1261,1 @@\n-        return (int)32768L;\n-    }\n-    public static MethodHandle clang_parseTranslationUnit$MH() {\n-        return RuntimeHelper.requireNonNull(constants$4.clang_parseTranslationUnit$MH,\"clang_parseTranslationUnit\");\n+        return CXTranslationUnit_RetainExcludedConditionalBlocks;\n@@ -821,1 +1264,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -825,0 +1268,20 @@\n+    public static MethodHandle clang_parseTranslationUnit$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_POINTER,\n+                Index_h.C_POINTER,\n+                Index_h.C_POINTER,\n+                Index_h.C_POINTER,\n+                Index_h.C_INT,\n+                Index_h.C_POINTER,\n+                Index_h.C_INT,\n+                Index_h.C_INT\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_parseTranslationUnit\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -828,1 +1291,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(CIdx, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, options);\n+            return (MemorySegment) mh$.invokeExact(CIdx, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, options);\n@@ -830,1 +1293,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -833,3 +1296,0 @@\n-    public static MethodHandle clang_parseTranslationUnit2$MH() {\n-        return RuntimeHelper.requireNonNull(constants$4.clang_parseTranslationUnit2$MH,\"clang_parseTranslationUnit2\");\n-    }\n@@ -837,1 +1297,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -841,0 +1301,21 @@\n+    public static MethodHandle clang_parseTranslationUnit2$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                Index_h.C_POINTER,\n+                Index_h.C_POINTER,\n+                Index_h.C_POINTER,\n+                Index_h.C_INT,\n+                Index_h.C_POINTER,\n+                Index_h.C_INT,\n+                Index_h.C_INT,\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_parseTranslationUnit2\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -844,1 +1325,1 @@\n-            return (int)mh$.invokeExact(CIdx, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, options, out_TU);\n+            return (int) mh$.invokeExact(CIdx, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, options, out_TU);\n@@ -846,1 +1327,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -849,0 +1330,2 @@\n+    private static final int CXSaveTranslationUnit_None = (int)0L;\n+\n@@ -850,1 +1333,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -855,1 +1338,1 @@\n-        return (int)0L;\n+        return CXSaveTranslationUnit_None;\n@@ -857,0 +1340,2 @@\n+    private static final int CXSaveError_None = (int)0L;\n+\n@@ -858,1 +1343,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -863,1 +1348,1 @@\n-        return (int)0L;\n+        return CXSaveError_None;\n@@ -865,0 +1350,2 @@\n+    private static final int CXSaveError_Unknown = (int)1L;\n+\n@@ -866,1 +1353,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -871,1 +1358,1 @@\n-        return (int)1L;\n+        return CXSaveError_Unknown;\n@@ -873,0 +1360,2 @@\n+    private static final int CXSaveError_TranslationErrors = (int)2L;\n+\n@@ -874,1 +1363,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -879,1 +1368,1 @@\n-        return (int)2L;\n+        return CXSaveError_TranslationErrors;\n@@ -881,0 +1370,2 @@\n+    private static final int CXSaveError_InvalidTU = (int)3L;\n+\n@@ -882,1 +1373,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -887,4 +1378,1 @@\n-        return (int)3L;\n-    }\n-    public static MethodHandle clang_saveTranslationUnit$MH() {\n-        return RuntimeHelper.requireNonNull(constants$4.clang_saveTranslationUnit$MH,\"clang_saveTranslationUnit\");\n+        return CXSaveError_InvalidTU;\n@@ -893,1 +1381,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -897,0 +1385,16 @@\n+    public static MethodHandle clang_saveTranslationUnit$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                Index_h.C_POINTER,\n+                Index_h.C_POINTER,\n+                Index_h.C_INT\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_saveTranslationUnit\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -900,1 +1404,1 @@\n-            return (int)mh$.invokeExact(TU, FileName, options);\n+            return (int) mh$.invokeExact(TU, FileName, options);\n@@ -902,1 +1406,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -905,3 +1409,0 @@\n-    public static MethodHandle clang_disposeTranslationUnit$MH() {\n-        return RuntimeHelper.requireNonNull(constants$4.clang_disposeTranslationUnit$MH,\"clang_disposeTranslationUnit\");\n-    }\n@@ -909,1 +1410,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -913,0 +1414,13 @@\n+    public static MethodHandle clang_disposeTranslationUnit$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_disposeTranslationUnit\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -918,1 +1432,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -921,0 +1435,2 @@\n+    private static final int CXReparse_None = (int)0L;\n+\n@@ -922,1 +1438,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -927,4 +1443,1 @@\n-        return (int)0L;\n-    }\n-    public static MethodHandle clang_defaultReparseOptions$MH() {\n-        return RuntimeHelper.requireNonNull(constants$5.clang_defaultReparseOptions$MH,\"clang_defaultReparseOptions\");\n+        return CXReparse_None;\n@@ -933,1 +1446,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -937,0 +1450,14 @@\n+    public static MethodHandle clang_defaultReparseOptions$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_defaultReparseOptions\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -940,1 +1467,1 @@\n-            return (int)mh$.invokeExact(TU);\n+            return (int) mh$.invokeExact(TU);\n@@ -942,1 +1469,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -945,3 +1472,0 @@\n-    public static MethodHandle clang_reparseTranslationUnit$MH() {\n-        return RuntimeHelper.requireNonNull(constants$5.clang_reparseTranslationUnit$MH,\"clang_reparseTranslationUnit\");\n-    }\n@@ -949,1 +1473,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -953,0 +1477,17 @@\n+    public static MethodHandle clang_reparseTranslationUnit$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                Index_h.C_POINTER,\n+                Index_h.C_INT,\n+                Index_h.C_POINTER,\n+                Index_h.C_INT\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_reparseTranslationUnit\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -956,1 +1497,1 @@\n-            return (int)mh$.invokeExact(TU, num_unsaved_files, unsaved_files, options);\n+            return (int) mh$.invokeExact(TU, num_unsaved_files, unsaved_files, options);\n@@ -958,1 +1499,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -961,0 +1502,2 @@\n+    private static final int CXCursor_UnexposedDecl = (int)1L;\n+\n@@ -962,1 +1505,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -967,1 +1510,1 @@\n-        return (int)1L;\n+        return CXCursor_UnexposedDecl;\n@@ -969,0 +1512,2 @@\n+    private static final int CXCursor_StructDecl = (int)2L;\n+\n@@ -970,1 +1515,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -975,1 +1520,1 @@\n-        return (int)2L;\n+        return CXCursor_StructDecl;\n@@ -977,0 +1522,2 @@\n+    private static final int CXCursor_UnionDecl = (int)3L;\n+\n@@ -978,1 +1525,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -983,1 +1530,1 @@\n-        return (int)3L;\n+        return CXCursor_UnionDecl;\n@@ -985,0 +1532,2 @@\n+    private static final int CXCursor_ClassDecl = (int)4L;\n+\n@@ -986,1 +1535,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -991,1 +1540,1 @@\n-        return (int)4L;\n+        return CXCursor_ClassDecl;\n@@ -993,0 +1542,2 @@\n+    private static final int CXCursor_EnumDecl = (int)5L;\n+\n@@ -994,1 +1545,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -999,1 +1550,1 @@\n-        return (int)5L;\n+        return CXCursor_EnumDecl;\n@@ -1001,0 +1552,2 @@\n+    private static final int CXCursor_FieldDecl = (int)6L;\n+\n@@ -1002,1 +1555,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1007,1 +1560,1 @@\n-        return (int)6L;\n+        return CXCursor_FieldDecl;\n@@ -1009,0 +1562,2 @@\n+    private static final int CXCursor_EnumConstantDecl = (int)7L;\n+\n@@ -1010,1 +1565,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1015,1 +1570,1 @@\n-        return (int)7L;\n+        return CXCursor_EnumConstantDecl;\n@@ -1017,0 +1572,2 @@\n+    private static final int CXCursor_FunctionDecl = (int)8L;\n+\n@@ -1018,1 +1575,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1023,1 +1580,1 @@\n-        return (int)8L;\n+        return CXCursor_FunctionDecl;\n@@ -1025,0 +1582,2 @@\n+    private static final int CXCursor_VarDecl = (int)9L;\n+\n@@ -1026,1 +1585,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1031,1 +1590,1 @@\n-        return (int)9L;\n+        return CXCursor_VarDecl;\n@@ -1033,0 +1592,2 @@\n+    private static final int CXCursor_ParmDecl = (int)10L;\n+\n@@ -1034,1 +1595,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1039,1 +1600,1 @@\n-        return (int)10L;\n+        return CXCursor_ParmDecl;\n@@ -1041,0 +1602,2 @@\n+    private static final int CXCursor_ObjCInterfaceDecl = (int)11L;\n+\n@@ -1042,1 +1605,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1047,1 +1610,1 @@\n-        return (int)11L;\n+        return CXCursor_ObjCInterfaceDecl;\n@@ -1049,0 +1612,2 @@\n+    private static final int CXCursor_ObjCCategoryDecl = (int)12L;\n+\n@@ -1050,1 +1615,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1055,1 +1620,1 @@\n-        return (int)12L;\n+        return CXCursor_ObjCCategoryDecl;\n@@ -1057,0 +1622,2 @@\n+    private static final int CXCursor_ObjCProtocolDecl = (int)13L;\n+\n@@ -1058,1 +1625,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1063,1 +1630,1 @@\n-        return (int)13L;\n+        return CXCursor_ObjCProtocolDecl;\n@@ -1065,0 +1632,2 @@\n+    private static final int CXCursor_ObjCPropertyDecl = (int)14L;\n+\n@@ -1066,1 +1635,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1071,1 +1640,1 @@\n-        return (int)14L;\n+        return CXCursor_ObjCPropertyDecl;\n@@ -1073,0 +1642,2 @@\n+    private static final int CXCursor_ObjCIvarDecl = (int)15L;\n+\n@@ -1074,1 +1645,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1079,1 +1650,1 @@\n-        return (int)15L;\n+        return CXCursor_ObjCIvarDecl;\n@@ -1081,0 +1652,2 @@\n+    private static final int CXCursor_ObjCInstanceMethodDecl = (int)16L;\n+\n@@ -1082,1 +1655,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1087,1 +1660,1 @@\n-        return (int)16L;\n+        return CXCursor_ObjCInstanceMethodDecl;\n@@ -1089,0 +1662,2 @@\n+    private static final int CXCursor_ObjCClassMethodDecl = (int)17L;\n+\n@@ -1090,1 +1665,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1095,1 +1670,1 @@\n-        return (int)17L;\n+        return CXCursor_ObjCClassMethodDecl;\n@@ -1097,0 +1672,2 @@\n+    private static final int CXCursor_ObjCImplementationDecl = (int)18L;\n+\n@@ -1098,1 +1675,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1103,1 +1680,1 @@\n-        return (int)18L;\n+        return CXCursor_ObjCImplementationDecl;\n@@ -1105,0 +1682,2 @@\n+    private static final int CXCursor_ObjCCategoryImplDecl = (int)19L;\n+\n@@ -1106,1 +1685,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1111,1 +1690,1 @@\n-        return (int)19L;\n+        return CXCursor_ObjCCategoryImplDecl;\n@@ -1113,0 +1692,2 @@\n+    private static final int CXCursor_TypedefDecl = (int)20L;\n+\n@@ -1114,1 +1695,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1119,1 +1700,1 @@\n-        return (int)20L;\n+        return CXCursor_TypedefDecl;\n@@ -1121,0 +1702,2 @@\n+    private static final int CXCursor_CXXMethod = (int)21L;\n+\n@@ -1122,1 +1705,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1127,1 +1710,1 @@\n-        return (int)21L;\n+        return CXCursor_CXXMethod;\n@@ -1129,0 +1712,2 @@\n+    private static final int CXCursor_Namespace = (int)22L;\n+\n@@ -1130,1 +1715,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1135,1 +1720,1 @@\n-        return (int)22L;\n+        return CXCursor_Namespace;\n@@ -1137,0 +1722,2 @@\n+    private static final int CXCursor_LinkageSpec = (int)23L;\n+\n@@ -1138,1 +1725,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1143,1 +1730,1 @@\n-        return (int)23L;\n+        return CXCursor_LinkageSpec;\n@@ -1145,0 +1732,2 @@\n+    private static final int CXCursor_Constructor = (int)24L;\n+\n@@ -1146,1 +1735,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1151,1 +1740,1 @@\n-        return (int)24L;\n+        return CXCursor_Constructor;\n@@ -1153,0 +1742,2 @@\n+    private static final int CXCursor_Destructor = (int)25L;\n+\n@@ -1154,1 +1745,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1159,1 +1750,1 @@\n-        return (int)25L;\n+        return CXCursor_Destructor;\n@@ -1161,0 +1752,2 @@\n+    private static final int CXCursor_ConversionFunction = (int)26L;\n+\n@@ -1162,1 +1755,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1167,1 +1760,1 @@\n-        return (int)26L;\n+        return CXCursor_ConversionFunction;\n@@ -1169,0 +1762,2 @@\n+    private static final int CXCursor_TemplateTypeParameter = (int)27L;\n+\n@@ -1170,1 +1765,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1175,1 +1770,1 @@\n-        return (int)27L;\n+        return CXCursor_TemplateTypeParameter;\n@@ -1177,0 +1772,2 @@\n+    private static final int CXCursor_NonTypeTemplateParameter = (int)28L;\n+\n@@ -1178,1 +1775,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1183,1 +1780,1 @@\n-        return (int)28L;\n+        return CXCursor_NonTypeTemplateParameter;\n@@ -1185,0 +1782,2 @@\n+    private static final int CXCursor_TemplateTemplateParameter = (int)29L;\n+\n@@ -1186,1 +1785,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1191,1 +1790,1 @@\n-        return (int)29L;\n+        return CXCursor_TemplateTemplateParameter;\n@@ -1193,0 +1792,2 @@\n+    private static final int CXCursor_FunctionTemplate = (int)30L;\n+\n@@ -1194,1 +1795,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1199,1 +1800,1 @@\n-        return (int)30L;\n+        return CXCursor_FunctionTemplate;\n@@ -1201,0 +1802,2 @@\n+    private static final int CXCursor_ClassTemplate = (int)31L;\n+\n@@ -1202,1 +1805,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1207,1 +1810,1 @@\n-        return (int)31L;\n+        return CXCursor_ClassTemplate;\n@@ -1209,0 +1812,2 @@\n+    private static final int CXCursor_ClassTemplatePartialSpecialization = (int)32L;\n+\n@@ -1210,1 +1815,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1215,1 +1820,1 @@\n-        return (int)32L;\n+        return CXCursor_ClassTemplatePartialSpecialization;\n@@ -1217,0 +1822,2 @@\n+    private static final int CXCursor_NamespaceAlias = (int)33L;\n+\n@@ -1218,1 +1825,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1223,1 +1830,1 @@\n-        return (int)33L;\n+        return CXCursor_NamespaceAlias;\n@@ -1225,0 +1832,2 @@\n+    private static final int CXCursor_UsingDirective = (int)34L;\n+\n@@ -1226,1 +1835,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1231,1 +1840,1 @@\n-        return (int)34L;\n+        return CXCursor_UsingDirective;\n@@ -1233,0 +1842,2 @@\n+    private static final int CXCursor_UsingDeclaration = (int)35L;\n+\n@@ -1234,1 +1845,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1239,1 +1850,1 @@\n-        return (int)35L;\n+        return CXCursor_UsingDeclaration;\n@@ -1241,0 +1852,2 @@\n+    private static final int CXCursor_TypeAliasDecl = (int)36L;\n+\n@@ -1242,1 +1855,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1247,1 +1860,1 @@\n-        return (int)36L;\n+        return CXCursor_TypeAliasDecl;\n@@ -1249,0 +1862,2 @@\n+    private static final int CXCursor_ObjCSynthesizeDecl = (int)37L;\n+\n@@ -1250,1 +1865,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1255,1 +1870,1 @@\n-        return (int)37L;\n+        return CXCursor_ObjCSynthesizeDecl;\n@@ -1257,0 +1872,2 @@\n+    private static final int CXCursor_ObjCDynamicDecl = (int)38L;\n+\n@@ -1258,1 +1875,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1263,1 +1880,1 @@\n-        return (int)38L;\n+        return CXCursor_ObjCDynamicDecl;\n@@ -1265,0 +1882,2 @@\n+    private static final int CXCursor_CXXAccessSpecifier = (int)39L;\n+\n@@ -1266,1 +1885,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1271,1 +1890,1 @@\n-        return (int)39L;\n+        return CXCursor_CXXAccessSpecifier;\n@@ -1273,0 +1892,2 @@\n+    private static final int CXCursor_FirstDecl = (int)1L;\n+\n@@ -1274,1 +1895,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1279,1 +1900,1 @@\n-        return (int)1L;\n+        return CXCursor_FirstDecl;\n@@ -1281,0 +1902,2 @@\n+    private static final int CXCursor_LastDecl = (int)39L;\n+\n@@ -1282,1 +1905,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1287,1 +1910,1 @@\n-        return (int)39L;\n+        return CXCursor_LastDecl;\n@@ -1289,0 +1912,2 @@\n+    private static final int CXCursor_FirstRef = (int)40L;\n+\n@@ -1290,1 +1915,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1295,1 +1920,1 @@\n-        return (int)40L;\n+        return CXCursor_FirstRef;\n@@ -1297,0 +1922,2 @@\n+    private static final int CXCursor_ObjCSuperClassRef = (int)40L;\n+\n@@ -1298,1 +1925,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1303,1 +1930,1 @@\n-        return (int)40L;\n+        return CXCursor_ObjCSuperClassRef;\n@@ -1305,0 +1932,2 @@\n+    private static final int CXCursor_ObjCProtocolRef = (int)41L;\n+\n@@ -1306,1 +1935,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1311,1 +1940,1 @@\n-        return (int)41L;\n+        return CXCursor_ObjCProtocolRef;\n@@ -1313,0 +1942,2 @@\n+    private static final int CXCursor_ObjCClassRef = (int)42L;\n+\n@@ -1314,1 +1945,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1319,1 +1950,1 @@\n-        return (int)42L;\n+        return CXCursor_ObjCClassRef;\n@@ -1321,0 +1952,2 @@\n+    private static final int CXCursor_TypeRef = (int)43L;\n+\n@@ -1322,1 +1955,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1327,1 +1960,1 @@\n-        return (int)43L;\n+        return CXCursor_TypeRef;\n@@ -1329,0 +1962,2 @@\n+    private static final int CXCursor_CXXBaseSpecifier = (int)44L;\n+\n@@ -1330,1 +1965,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1335,1 +1970,1 @@\n-        return (int)44L;\n+        return CXCursor_CXXBaseSpecifier;\n@@ -1337,0 +1972,2 @@\n+    private static final int CXCursor_TemplateRef = (int)45L;\n+\n@@ -1338,1 +1975,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1343,1 +1980,1 @@\n-        return (int)45L;\n+        return CXCursor_TemplateRef;\n@@ -1345,0 +1982,2 @@\n+    private static final int CXCursor_NamespaceRef = (int)46L;\n+\n@@ -1346,1 +1985,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1351,1 +1990,1 @@\n-        return (int)46L;\n+        return CXCursor_NamespaceRef;\n@@ -1353,0 +1992,2 @@\n+    private static final int CXCursor_MemberRef = (int)47L;\n+\n@@ -1354,1 +1995,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1359,1 +2000,1 @@\n-        return (int)47L;\n+        return CXCursor_MemberRef;\n@@ -1361,0 +2002,2 @@\n+    private static final int CXCursor_LabelRef = (int)48L;\n+\n@@ -1362,1 +2005,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1367,1 +2010,1 @@\n-        return (int)48L;\n+        return CXCursor_LabelRef;\n@@ -1369,0 +2012,2 @@\n+    private static final int CXCursor_OverloadedDeclRef = (int)49L;\n+\n@@ -1370,1 +2015,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1375,1 +2020,1 @@\n-        return (int)49L;\n+        return CXCursor_OverloadedDeclRef;\n@@ -1377,0 +2022,2 @@\n+    private static final int CXCursor_VariableRef = (int)50L;\n+\n@@ -1378,1 +2025,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1383,1 +2030,1 @@\n-        return (int)50L;\n+        return CXCursor_VariableRef;\n@@ -1385,0 +2032,2 @@\n+    private static final int CXCursor_LastRef = (int)50L;\n+\n@@ -1386,1 +2035,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1391,1 +2040,1 @@\n-        return (int)50L;\n+        return CXCursor_LastRef;\n@@ -1393,0 +2042,2 @@\n+    private static final int CXCursor_FirstInvalid = (int)70L;\n+\n@@ -1394,1 +2045,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1399,1 +2050,1 @@\n-        return (int)70L;\n+        return CXCursor_FirstInvalid;\n@@ -1401,0 +2052,2 @@\n+    private static final int CXCursor_InvalidFile = (int)70L;\n+\n@@ -1402,1 +2055,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1407,1 +2060,1 @@\n-        return (int)70L;\n+        return CXCursor_InvalidFile;\n@@ -1409,0 +2062,2 @@\n+    private static final int CXCursor_NoDeclFound = (int)71L;\n+\n@@ -1410,1 +2065,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1415,1 +2070,1 @@\n-        return (int)71L;\n+        return CXCursor_NoDeclFound;\n@@ -1417,0 +2072,2 @@\n+    private static final int CXCursor_NotImplemented = (int)72L;\n+\n@@ -1418,1 +2075,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1423,1 +2080,1 @@\n-        return (int)72L;\n+        return CXCursor_NotImplemented;\n@@ -1425,0 +2082,2 @@\n+    private static final int CXCursor_InvalidCode = (int)73L;\n+\n@@ -1426,1 +2085,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1431,1 +2090,1 @@\n-        return (int)73L;\n+        return CXCursor_InvalidCode;\n@@ -1433,0 +2092,2 @@\n+    private static final int CXCursor_LastInvalid = (int)73L;\n+\n@@ -1434,1 +2095,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1439,1 +2100,1 @@\n-        return (int)73L;\n+        return CXCursor_LastInvalid;\n@@ -1441,0 +2102,2 @@\n+    private static final int CXCursor_FirstExpr = (int)100L;\n+\n@@ -1442,1 +2105,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1447,1 +2110,1 @@\n-        return (int)100L;\n+        return CXCursor_FirstExpr;\n@@ -1449,0 +2112,2 @@\n+    private static final int CXCursor_UnexposedExpr = (int)100L;\n+\n@@ -1450,1 +2115,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1455,1 +2120,1 @@\n-        return (int)100L;\n+        return CXCursor_UnexposedExpr;\n@@ -1457,0 +2122,2 @@\n+    private static final int CXCursor_DeclRefExpr = (int)101L;\n+\n@@ -1458,1 +2125,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1463,1 +2130,1 @@\n-        return (int)101L;\n+        return CXCursor_DeclRefExpr;\n@@ -1465,0 +2132,2 @@\n+    private static final int CXCursor_MemberRefExpr = (int)102L;\n+\n@@ -1466,1 +2135,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1471,1 +2140,1 @@\n-        return (int)102L;\n+        return CXCursor_MemberRefExpr;\n@@ -1473,0 +2142,2 @@\n+    private static final int CXCursor_CallExpr = (int)103L;\n+\n@@ -1474,1 +2145,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1479,1 +2150,1 @@\n-        return (int)103L;\n+        return CXCursor_CallExpr;\n@@ -1481,0 +2152,2 @@\n+    private static final int CXCursor_ObjCMessageExpr = (int)104L;\n+\n@@ -1482,1 +2155,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1487,1 +2160,1 @@\n-        return (int)104L;\n+        return CXCursor_ObjCMessageExpr;\n@@ -1489,0 +2162,2 @@\n+    private static final int CXCursor_BlockExpr = (int)105L;\n+\n@@ -1490,1 +2165,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1495,1 +2170,1 @@\n-        return (int)105L;\n+        return CXCursor_BlockExpr;\n@@ -1497,0 +2172,2 @@\n+    private static final int CXCursor_IntegerLiteral = (int)106L;\n+\n@@ -1498,1 +2175,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1503,1 +2180,1 @@\n-        return (int)106L;\n+        return CXCursor_IntegerLiteral;\n@@ -1505,0 +2182,2 @@\n+    private static final int CXCursor_FloatingLiteral = (int)107L;\n+\n@@ -1506,1 +2185,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1511,1 +2190,1 @@\n-        return (int)107L;\n+        return CXCursor_FloatingLiteral;\n@@ -1513,0 +2192,2 @@\n+    private static final int CXCursor_ImaginaryLiteral = (int)108L;\n+\n@@ -1514,1 +2195,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1519,1 +2200,1 @@\n-        return (int)108L;\n+        return CXCursor_ImaginaryLiteral;\n@@ -1521,0 +2202,2 @@\n+    private static final int CXCursor_StringLiteral = (int)109L;\n+\n@@ -1522,1 +2205,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1527,1 +2210,1 @@\n-        return (int)109L;\n+        return CXCursor_StringLiteral;\n@@ -1529,0 +2212,2 @@\n+    private static final int CXCursor_CharacterLiteral = (int)110L;\n+\n@@ -1530,1 +2215,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1535,1 +2220,1 @@\n-        return (int)110L;\n+        return CXCursor_CharacterLiteral;\n@@ -1537,0 +2222,2 @@\n+    private static final int CXCursor_ParenExpr = (int)111L;\n+\n@@ -1538,1 +2225,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1543,1 +2230,1 @@\n-        return (int)111L;\n+        return CXCursor_ParenExpr;\n@@ -1545,0 +2232,2 @@\n+    private static final int CXCursor_UnaryOperator = (int)112L;\n+\n@@ -1546,1 +2235,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1551,1 +2240,1 @@\n-        return (int)112L;\n+        return CXCursor_UnaryOperator;\n@@ -1553,0 +2242,2 @@\n+    private static final int CXCursor_ArraySubscriptExpr = (int)113L;\n+\n@@ -1554,1 +2245,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1559,1 +2250,1 @@\n-        return (int)113L;\n+        return CXCursor_ArraySubscriptExpr;\n@@ -1561,0 +2252,2 @@\n+    private static final int CXCursor_BinaryOperator = (int)114L;\n+\n@@ -1562,1 +2255,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1567,1 +2260,1 @@\n-        return (int)114L;\n+        return CXCursor_BinaryOperator;\n@@ -1569,0 +2262,2 @@\n+    private static final int CXCursor_CompoundAssignOperator = (int)115L;\n+\n@@ -1570,1 +2265,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1575,1 +2270,1 @@\n-        return (int)115L;\n+        return CXCursor_CompoundAssignOperator;\n@@ -1577,0 +2272,2 @@\n+    private static final int CXCursor_ConditionalOperator = (int)116L;\n+\n@@ -1578,1 +2275,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1583,1 +2280,1 @@\n-        return (int)116L;\n+        return CXCursor_ConditionalOperator;\n@@ -1585,0 +2282,2 @@\n+    private static final int CXCursor_CStyleCastExpr = (int)117L;\n+\n@@ -1586,1 +2285,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1591,1 +2290,1 @@\n-        return (int)117L;\n+        return CXCursor_CStyleCastExpr;\n@@ -1593,0 +2292,2 @@\n+    private static final int CXCursor_CompoundLiteralExpr = (int)118L;\n+\n@@ -1594,1 +2295,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1599,1 +2300,1 @@\n-        return (int)118L;\n+        return CXCursor_CompoundLiteralExpr;\n@@ -1601,0 +2302,2 @@\n+    private static final int CXCursor_InitListExpr = (int)119L;\n+\n@@ -1602,1 +2305,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1607,1 +2310,1 @@\n-        return (int)119L;\n+        return CXCursor_InitListExpr;\n@@ -1609,0 +2312,2 @@\n+    private static final int CXCursor_AddrLabelExpr = (int)120L;\n+\n@@ -1610,1 +2315,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1615,1 +2320,1 @@\n-        return (int)120L;\n+        return CXCursor_AddrLabelExpr;\n@@ -1617,0 +2322,2 @@\n+    private static final int CXCursor_StmtExpr = (int)121L;\n+\n@@ -1618,1 +2325,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1623,1 +2330,1 @@\n-        return (int)121L;\n+        return CXCursor_StmtExpr;\n@@ -1625,0 +2332,2 @@\n+    private static final int CXCursor_GenericSelectionExpr = (int)122L;\n+\n@@ -1626,1 +2335,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1631,1 +2340,1 @@\n-        return (int)122L;\n+        return CXCursor_GenericSelectionExpr;\n@@ -1633,0 +2342,2 @@\n+    private static final int CXCursor_GNUNullExpr = (int)123L;\n+\n@@ -1634,1 +2345,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1639,1 +2350,1 @@\n-        return (int)123L;\n+        return CXCursor_GNUNullExpr;\n@@ -1641,0 +2352,2 @@\n+    private static final int CXCursor_CXXStaticCastExpr = (int)124L;\n+\n@@ -1642,1 +2355,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1647,1 +2360,1 @@\n-        return (int)124L;\n+        return CXCursor_CXXStaticCastExpr;\n@@ -1649,0 +2362,2 @@\n+    private static final int CXCursor_CXXDynamicCastExpr = (int)125L;\n+\n@@ -1650,1 +2365,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1655,1 +2370,1 @@\n-        return (int)125L;\n+        return CXCursor_CXXDynamicCastExpr;\n@@ -1657,0 +2372,2 @@\n+    private static final int CXCursor_CXXReinterpretCastExpr = (int)126L;\n+\n@@ -1658,1 +2375,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1663,1 +2380,1 @@\n-        return (int)126L;\n+        return CXCursor_CXXReinterpretCastExpr;\n@@ -1665,0 +2382,2 @@\n+    private static final int CXCursor_CXXConstCastExpr = (int)127L;\n+\n@@ -1666,1 +2385,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1671,1 +2390,1 @@\n-        return (int)127L;\n+        return CXCursor_CXXConstCastExpr;\n@@ -1673,0 +2392,2 @@\n+    private static final int CXCursor_CXXFunctionalCastExpr = (int)128L;\n+\n@@ -1674,1 +2395,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1679,1 +2400,1 @@\n-        return (int)128L;\n+        return CXCursor_CXXFunctionalCastExpr;\n@@ -1681,0 +2402,2 @@\n+    private static final int CXCursor_CXXTypeidExpr = (int)129L;\n+\n@@ -1682,1 +2405,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1687,1 +2410,1 @@\n-        return (int)129L;\n+        return CXCursor_CXXTypeidExpr;\n@@ -1689,0 +2412,2 @@\n+    private static final int CXCursor_CXXBoolLiteralExpr = (int)130L;\n+\n@@ -1690,1 +2415,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1695,1 +2420,1 @@\n-        return (int)130L;\n+        return CXCursor_CXXBoolLiteralExpr;\n@@ -1697,0 +2422,2 @@\n+    private static final int CXCursor_CXXNullPtrLiteralExpr = (int)131L;\n+\n@@ -1698,1 +2425,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1703,1 +2430,1 @@\n-        return (int)131L;\n+        return CXCursor_CXXNullPtrLiteralExpr;\n@@ -1705,0 +2432,2 @@\n+    private static final int CXCursor_CXXThisExpr = (int)132L;\n+\n@@ -1706,1 +2435,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1711,1 +2440,1 @@\n-        return (int)132L;\n+        return CXCursor_CXXThisExpr;\n@@ -1713,0 +2442,2 @@\n+    private static final int CXCursor_CXXThrowExpr = (int)133L;\n+\n@@ -1714,1 +2445,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1719,1 +2450,1 @@\n-        return (int)133L;\n+        return CXCursor_CXXThrowExpr;\n@@ -1721,0 +2452,2 @@\n+    private static final int CXCursor_CXXNewExpr = (int)134L;\n+\n@@ -1722,1 +2455,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1727,1 +2460,1 @@\n-        return (int)134L;\n+        return CXCursor_CXXNewExpr;\n@@ -1729,0 +2462,2 @@\n+    private static final int CXCursor_CXXDeleteExpr = (int)135L;\n+\n@@ -1730,1 +2465,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1735,1 +2470,1 @@\n-        return (int)135L;\n+        return CXCursor_CXXDeleteExpr;\n@@ -1737,0 +2472,2 @@\n+    private static final int CXCursor_UnaryExpr = (int)136L;\n+\n@@ -1738,1 +2475,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1743,1 +2480,1 @@\n-        return (int)136L;\n+        return CXCursor_UnaryExpr;\n@@ -1745,0 +2482,2 @@\n+    private static final int CXCursor_ObjCStringLiteral = (int)137L;\n+\n@@ -1746,1 +2485,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1751,1 +2490,1 @@\n-        return (int)137L;\n+        return CXCursor_ObjCStringLiteral;\n@@ -1753,0 +2492,2 @@\n+    private static final int CXCursor_ObjCEncodeExpr = (int)138L;\n+\n@@ -1754,1 +2495,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1759,1 +2500,1 @@\n-        return (int)138L;\n+        return CXCursor_ObjCEncodeExpr;\n@@ -1761,0 +2502,2 @@\n+    private static final int CXCursor_ObjCSelectorExpr = (int)139L;\n+\n@@ -1762,1 +2505,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1767,1 +2510,1 @@\n-        return (int)139L;\n+        return CXCursor_ObjCSelectorExpr;\n@@ -1769,0 +2512,2 @@\n+    private static final int CXCursor_ObjCProtocolExpr = (int)140L;\n+\n@@ -1770,1 +2515,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1775,1 +2520,1 @@\n-        return (int)140L;\n+        return CXCursor_ObjCProtocolExpr;\n@@ -1777,0 +2522,2 @@\n+    private static final int CXCursor_ObjCBridgedCastExpr = (int)141L;\n+\n@@ -1778,1 +2525,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1783,1 +2530,1 @@\n-        return (int)141L;\n+        return CXCursor_ObjCBridgedCastExpr;\n@@ -1785,0 +2532,2 @@\n+    private static final int CXCursor_PackExpansionExpr = (int)142L;\n+\n@@ -1786,1 +2535,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1791,1 +2540,1 @@\n-        return (int)142L;\n+        return CXCursor_PackExpansionExpr;\n@@ -1793,0 +2542,2 @@\n+    private static final int CXCursor_SizeOfPackExpr = (int)143L;\n+\n@@ -1794,1 +2545,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1799,1 +2550,1 @@\n-        return (int)143L;\n+        return CXCursor_SizeOfPackExpr;\n@@ -1801,0 +2552,2 @@\n+    private static final int CXCursor_LambdaExpr = (int)144L;\n+\n@@ -1802,1 +2555,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1807,1 +2560,1 @@\n-        return (int)144L;\n+        return CXCursor_LambdaExpr;\n@@ -1809,0 +2562,2 @@\n+    private static final int CXCursor_ObjCBoolLiteralExpr = (int)145L;\n+\n@@ -1810,1 +2565,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1815,1 +2570,1 @@\n-        return (int)145L;\n+        return CXCursor_ObjCBoolLiteralExpr;\n@@ -1817,0 +2572,2 @@\n+    private static final int CXCursor_ObjCSelfExpr = (int)146L;\n+\n@@ -1818,1 +2575,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1823,1 +2580,1 @@\n-        return (int)146L;\n+        return CXCursor_ObjCSelfExpr;\n@@ -1825,0 +2582,2 @@\n+    private static final int CXCursor_OMPArraySectionExpr = (int)147L;\n+\n@@ -1826,1 +2585,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1831,1 +2590,1 @@\n-        return (int)147L;\n+        return CXCursor_OMPArraySectionExpr;\n@@ -1833,0 +2592,2 @@\n+    private static final int CXCursor_ObjCAvailabilityCheckExpr = (int)148L;\n+\n@@ -1834,1 +2595,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1839,1 +2600,1 @@\n-        return (int)148L;\n+        return CXCursor_ObjCAvailabilityCheckExpr;\n@@ -1841,0 +2602,2 @@\n+    private static final int CXCursor_FixedPointLiteral = (int)149L;\n+\n@@ -1842,1 +2605,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1847,1 +2610,1 @@\n-        return (int)149L;\n+        return CXCursor_FixedPointLiteral;\n@@ -1849,0 +2612,2 @@\n+    private static final int CXCursor_LastExpr = (int)152L;\n+\n@@ -1850,1 +2615,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1855,1 +2620,1 @@\n-        return (int)152L;\n+        return CXCursor_LastExpr;\n@@ -1857,0 +2622,2 @@\n+    private static final int CXCursor_FirstStmt = (int)200L;\n+\n@@ -1858,1 +2625,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1863,1 +2630,1 @@\n-        return (int)200L;\n+        return CXCursor_FirstStmt;\n@@ -1865,0 +2632,2 @@\n+    private static final int CXCursor_UnexposedStmt = (int)200L;\n+\n@@ -1866,1 +2635,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1871,1 +2640,1 @@\n-        return (int)200L;\n+        return CXCursor_UnexposedStmt;\n@@ -1873,0 +2642,2 @@\n+    private static final int CXCursor_LabelStmt = (int)201L;\n+\n@@ -1874,1 +2645,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1879,1 +2650,1 @@\n-        return (int)201L;\n+        return CXCursor_LabelStmt;\n@@ -1881,0 +2652,2 @@\n+    private static final int CXCursor_CompoundStmt = (int)202L;\n+\n@@ -1882,1 +2655,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1887,1 +2660,1 @@\n-        return (int)202L;\n+        return CXCursor_CompoundStmt;\n@@ -1889,0 +2662,2 @@\n+    private static final int CXCursor_CaseStmt = (int)203L;\n+\n@@ -1890,1 +2665,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1895,1 +2670,1 @@\n-        return (int)203L;\n+        return CXCursor_CaseStmt;\n@@ -1897,0 +2672,2 @@\n+    private static final int CXCursor_DefaultStmt = (int)204L;\n+\n@@ -1898,1 +2675,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1903,1 +2680,1 @@\n-        return (int)204L;\n+        return CXCursor_DefaultStmt;\n@@ -1905,0 +2682,2 @@\n+    private static final int CXCursor_IfStmt = (int)205L;\n+\n@@ -1906,1 +2685,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1911,1 +2690,1 @@\n-        return (int)205L;\n+        return CXCursor_IfStmt;\n@@ -1913,0 +2692,2 @@\n+    private static final int CXCursor_SwitchStmt = (int)206L;\n+\n@@ -1914,1 +2695,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1919,1 +2700,1 @@\n-        return (int)206L;\n+        return CXCursor_SwitchStmt;\n@@ -1921,0 +2702,2 @@\n+    private static final int CXCursor_WhileStmt = (int)207L;\n+\n@@ -1922,1 +2705,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1927,1 +2710,1 @@\n-        return (int)207L;\n+        return CXCursor_WhileStmt;\n@@ -1929,0 +2712,2 @@\n+    private static final int CXCursor_DoStmt = (int)208L;\n+\n@@ -1930,1 +2715,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1935,1 +2720,1 @@\n-        return (int)208L;\n+        return CXCursor_DoStmt;\n@@ -1937,0 +2722,2 @@\n+    private static final int CXCursor_ForStmt = (int)209L;\n+\n@@ -1938,1 +2725,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1943,1 +2730,1 @@\n-        return (int)209L;\n+        return CXCursor_ForStmt;\n@@ -1945,0 +2732,2 @@\n+    private static final int CXCursor_GotoStmt = (int)210L;\n+\n@@ -1946,1 +2735,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1951,1 +2740,1 @@\n-        return (int)210L;\n+        return CXCursor_GotoStmt;\n@@ -1953,0 +2742,2 @@\n+    private static final int CXCursor_IndirectGotoStmt = (int)211L;\n+\n@@ -1954,1 +2745,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1959,1 +2750,1 @@\n-        return (int)211L;\n+        return CXCursor_IndirectGotoStmt;\n@@ -1961,0 +2752,2 @@\n+    private static final int CXCursor_ContinueStmt = (int)212L;\n+\n@@ -1962,1 +2755,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1967,1 +2760,1 @@\n-        return (int)212L;\n+        return CXCursor_ContinueStmt;\n@@ -1969,0 +2762,2 @@\n+    private static final int CXCursor_BreakStmt = (int)213L;\n+\n@@ -1970,1 +2765,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1975,1 +2770,1 @@\n-        return (int)213L;\n+        return CXCursor_BreakStmt;\n@@ -1977,0 +2772,2 @@\n+    private static final int CXCursor_ReturnStmt = (int)214L;\n+\n@@ -1978,1 +2775,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1983,1 +2780,1 @@\n-        return (int)214L;\n+        return CXCursor_ReturnStmt;\n@@ -1985,0 +2782,2 @@\n+    private static final int CXCursor_GCCAsmStmt = (int)215L;\n+\n@@ -1986,1 +2785,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1991,1 +2790,1 @@\n-        return (int)215L;\n+        return CXCursor_GCCAsmStmt;\n@@ -1993,0 +2792,2 @@\n+    private static final int CXCursor_AsmStmt = (int)215L;\n+\n@@ -1994,1 +2795,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -1999,1 +2800,1 @@\n-        return (int)215L;\n+        return CXCursor_AsmStmt;\n@@ -2001,0 +2802,2 @@\n+    private static final int CXCursor_ObjCAtTryStmt = (int)216L;\n+\n@@ -2002,1 +2805,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2007,1 +2810,1 @@\n-        return (int)216L;\n+        return CXCursor_ObjCAtTryStmt;\n@@ -2009,0 +2812,2 @@\n+    private static final int CXCursor_ObjCAtCatchStmt = (int)217L;\n+\n@@ -2010,1 +2815,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2015,1 +2820,1 @@\n-        return (int)217L;\n+        return CXCursor_ObjCAtCatchStmt;\n@@ -2017,0 +2822,2 @@\n+    private static final int CXCursor_ObjCAtFinallyStmt = (int)218L;\n+\n@@ -2018,1 +2825,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2023,1 +2830,1 @@\n-        return (int)218L;\n+        return CXCursor_ObjCAtFinallyStmt;\n@@ -2025,0 +2832,2 @@\n+    private static final int CXCursor_ObjCAtThrowStmt = (int)219L;\n+\n@@ -2026,1 +2835,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2031,1 +2840,1 @@\n-        return (int)219L;\n+        return CXCursor_ObjCAtThrowStmt;\n@@ -2033,0 +2842,2 @@\n+    private static final int CXCursor_ObjCAtSynchronizedStmt = (int)220L;\n+\n@@ -2034,1 +2845,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2039,1 +2850,1 @@\n-        return (int)220L;\n+        return CXCursor_ObjCAtSynchronizedStmt;\n@@ -2041,0 +2852,2 @@\n+    private static final int CXCursor_ObjCAutoreleasePoolStmt = (int)221L;\n+\n@@ -2042,1 +2855,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2047,1 +2860,1 @@\n-        return (int)221L;\n+        return CXCursor_ObjCAutoreleasePoolStmt;\n@@ -2049,0 +2862,2 @@\n+    private static final int CXCursor_ObjCForCollectionStmt = (int)222L;\n+\n@@ -2050,1 +2865,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2055,1 +2870,1 @@\n-        return (int)222L;\n+        return CXCursor_ObjCForCollectionStmt;\n@@ -2057,0 +2872,2 @@\n+    private static final int CXCursor_CXXCatchStmt = (int)223L;\n+\n@@ -2058,1 +2875,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2063,1 +2880,1 @@\n-        return (int)223L;\n+        return CXCursor_CXXCatchStmt;\n@@ -2065,0 +2882,2 @@\n+    private static final int CXCursor_CXXTryStmt = (int)224L;\n+\n@@ -2066,1 +2885,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2071,1 +2890,1 @@\n-        return (int)224L;\n+        return CXCursor_CXXTryStmt;\n@@ -2073,0 +2892,2 @@\n+    private static final int CXCursor_CXXForRangeStmt = (int)225L;\n+\n@@ -2074,1 +2895,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2079,1 +2900,1 @@\n-        return (int)225L;\n+        return CXCursor_CXXForRangeStmt;\n@@ -2081,0 +2902,2 @@\n+    private static final int CXCursor_SEHTryStmt = (int)226L;\n+\n@@ -2082,1 +2905,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2087,1 +2910,1 @@\n-        return (int)226L;\n+        return CXCursor_SEHTryStmt;\n@@ -2089,0 +2912,2 @@\n+    private static final int CXCursor_SEHExceptStmt = (int)227L;\n+\n@@ -2090,1 +2915,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2095,1 +2920,1 @@\n-        return (int)227L;\n+        return CXCursor_SEHExceptStmt;\n@@ -2097,0 +2922,2 @@\n+    private static final int CXCursor_SEHFinallyStmt = (int)228L;\n+\n@@ -2098,1 +2925,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2103,1 +2930,1 @@\n-        return (int)228L;\n+        return CXCursor_SEHFinallyStmt;\n@@ -2105,0 +2932,2 @@\n+    private static final int CXCursor_MSAsmStmt = (int)229L;\n+\n@@ -2106,1 +2935,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2111,1 +2940,1 @@\n-        return (int)229L;\n+        return CXCursor_MSAsmStmt;\n@@ -2113,0 +2942,2 @@\n+    private static final int CXCursor_NullStmt = (int)230L;\n+\n@@ -2114,1 +2945,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2119,1 +2950,1 @@\n-        return (int)230L;\n+        return CXCursor_NullStmt;\n@@ -2121,0 +2952,2 @@\n+    private static final int CXCursor_DeclStmt = (int)231L;\n+\n@@ -2122,1 +2955,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2127,1 +2960,1 @@\n-        return (int)231L;\n+        return CXCursor_DeclStmt;\n@@ -2129,0 +2962,2 @@\n+    private static final int CXCursor_OMPParallelDirective = (int)232L;\n+\n@@ -2130,1 +2965,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2135,1 +2970,1 @@\n-        return (int)232L;\n+        return CXCursor_OMPParallelDirective;\n@@ -2137,0 +2972,2 @@\n+    private static final int CXCursor_OMPSimdDirective = (int)233L;\n+\n@@ -2138,1 +2975,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2143,1 +2980,1 @@\n-        return (int)233L;\n+        return CXCursor_OMPSimdDirective;\n@@ -2145,0 +2982,2 @@\n+    private static final int CXCursor_OMPForDirective = (int)234L;\n+\n@@ -2146,1 +2985,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2151,1 +2990,1 @@\n-        return (int)234L;\n+        return CXCursor_OMPForDirective;\n@@ -2153,0 +2992,2 @@\n+    private static final int CXCursor_OMPSectionsDirective = (int)235L;\n+\n@@ -2154,1 +2995,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2159,1 +3000,1 @@\n-        return (int)235L;\n+        return CXCursor_OMPSectionsDirective;\n@@ -2161,0 +3002,2 @@\n+    private static final int CXCursor_OMPSectionDirective = (int)236L;\n+\n@@ -2162,1 +3005,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2167,1 +3010,1 @@\n-        return (int)236L;\n+        return CXCursor_OMPSectionDirective;\n@@ -2169,0 +3012,2 @@\n+    private static final int CXCursor_OMPSingleDirective = (int)237L;\n+\n@@ -2170,1 +3015,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2175,1 +3020,1 @@\n-        return (int)237L;\n+        return CXCursor_OMPSingleDirective;\n@@ -2177,0 +3022,2 @@\n+    private static final int CXCursor_OMPParallelForDirective = (int)238L;\n+\n@@ -2178,1 +3025,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2183,1 +3030,1 @@\n-        return (int)238L;\n+        return CXCursor_OMPParallelForDirective;\n@@ -2185,0 +3032,2 @@\n+    private static final int CXCursor_OMPParallelSectionsDirective = (int)239L;\n+\n@@ -2186,1 +3035,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2191,1 +3040,1 @@\n-        return (int)239L;\n+        return CXCursor_OMPParallelSectionsDirective;\n@@ -2193,0 +3042,2 @@\n+    private static final int CXCursor_OMPTaskDirective = (int)240L;\n+\n@@ -2194,1 +3045,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2199,1 +3050,1 @@\n-        return (int)240L;\n+        return CXCursor_OMPTaskDirective;\n@@ -2201,0 +3052,2 @@\n+    private static final int CXCursor_OMPMasterDirective = (int)241L;\n+\n@@ -2202,1 +3055,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2207,1 +3060,1 @@\n-        return (int)241L;\n+        return CXCursor_OMPMasterDirective;\n@@ -2209,0 +3062,2 @@\n+    private static final int CXCursor_OMPCriticalDirective = (int)242L;\n+\n@@ -2210,1 +3065,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2215,1 +3070,1 @@\n-        return (int)242L;\n+        return CXCursor_OMPCriticalDirective;\n@@ -2217,0 +3072,2 @@\n+    private static final int CXCursor_OMPTaskyieldDirective = (int)243L;\n+\n@@ -2218,1 +3075,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2223,1 +3080,1 @@\n-        return (int)243L;\n+        return CXCursor_OMPTaskyieldDirective;\n@@ -2225,0 +3082,2 @@\n+    private static final int CXCursor_OMPBarrierDirective = (int)244L;\n+\n@@ -2226,1 +3085,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2231,1 +3090,1 @@\n-        return (int)244L;\n+        return CXCursor_OMPBarrierDirective;\n@@ -2233,0 +3092,2 @@\n+    private static final int CXCursor_OMPTaskwaitDirective = (int)245L;\n+\n@@ -2234,1 +3095,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2239,1 +3100,1 @@\n-        return (int)245L;\n+        return CXCursor_OMPTaskwaitDirective;\n@@ -2241,0 +3102,2 @@\n+    private static final int CXCursor_OMPFlushDirective = (int)246L;\n+\n@@ -2242,1 +3105,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2247,1 +3110,1 @@\n-        return (int)246L;\n+        return CXCursor_OMPFlushDirective;\n@@ -2249,0 +3112,2 @@\n+    private static final int CXCursor_SEHLeaveStmt = (int)247L;\n+\n@@ -2250,1 +3115,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2255,1 +3120,1 @@\n-        return (int)247L;\n+        return CXCursor_SEHLeaveStmt;\n@@ -2257,0 +3122,2 @@\n+    private static final int CXCursor_OMPOrderedDirective = (int)248L;\n+\n@@ -2258,1 +3125,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2263,1 +3130,1 @@\n-        return (int)248L;\n+        return CXCursor_OMPOrderedDirective;\n@@ -2265,0 +3132,2 @@\n+    private static final int CXCursor_OMPAtomicDirective = (int)249L;\n+\n@@ -2266,1 +3135,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2271,1 +3140,1 @@\n-        return (int)249L;\n+        return CXCursor_OMPAtomicDirective;\n@@ -2273,0 +3142,2 @@\n+    private static final int CXCursor_OMPForSimdDirective = (int)250L;\n+\n@@ -2274,1 +3145,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2279,1 +3150,1 @@\n-        return (int)250L;\n+        return CXCursor_OMPForSimdDirective;\n@@ -2281,0 +3152,2 @@\n+    private static final int CXCursor_OMPParallelForSimdDirective = (int)251L;\n+\n@@ -2282,1 +3155,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2287,1 +3160,1 @@\n-        return (int)251L;\n+        return CXCursor_OMPParallelForSimdDirective;\n@@ -2289,0 +3162,2 @@\n+    private static final int CXCursor_OMPTargetDirective = (int)252L;\n+\n@@ -2290,1 +3165,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2295,1 +3170,1 @@\n-        return (int)252L;\n+        return CXCursor_OMPTargetDirective;\n@@ -2297,0 +3172,2 @@\n+    private static final int CXCursor_OMPTeamsDirective = (int)253L;\n+\n@@ -2298,1 +3175,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2303,1 +3180,1 @@\n-        return (int)253L;\n+        return CXCursor_OMPTeamsDirective;\n@@ -2305,0 +3182,2 @@\n+    private static final int CXCursor_OMPTaskgroupDirective = (int)254L;\n+\n@@ -2306,1 +3185,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2311,1 +3190,1 @@\n-        return (int)254L;\n+        return CXCursor_OMPTaskgroupDirective;\n@@ -2313,0 +3192,2 @@\n+    private static final int CXCursor_OMPCancellationPointDirective = (int)255L;\n+\n@@ -2314,1 +3195,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2319,1 +3200,1 @@\n-        return (int)255L;\n+        return CXCursor_OMPCancellationPointDirective;\n@@ -2321,0 +3202,2 @@\n+    private static final int CXCursor_OMPCancelDirective = (int)256L;\n+\n@@ -2322,1 +3205,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2327,1 +3210,1 @@\n-        return (int)256L;\n+        return CXCursor_OMPCancelDirective;\n@@ -2329,0 +3212,2 @@\n+    private static final int CXCursor_OMPTargetDataDirective = (int)257L;\n+\n@@ -2330,1 +3215,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2335,1 +3220,1 @@\n-        return (int)257L;\n+        return CXCursor_OMPTargetDataDirective;\n@@ -2337,0 +3222,2 @@\n+    private static final int CXCursor_OMPTaskLoopDirective = (int)258L;\n+\n@@ -2338,1 +3225,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2343,1 +3230,1 @@\n-        return (int)258L;\n+        return CXCursor_OMPTaskLoopDirective;\n@@ -2345,0 +3232,2 @@\n+    private static final int CXCursor_OMPTaskLoopSimdDirective = (int)259L;\n+\n@@ -2346,1 +3235,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2351,1 +3240,1 @@\n-        return (int)259L;\n+        return CXCursor_OMPTaskLoopSimdDirective;\n@@ -2353,0 +3242,2 @@\n+    private static final int CXCursor_OMPDistributeDirective = (int)260L;\n+\n@@ -2354,1 +3245,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2359,1 +3250,1 @@\n-        return (int)260L;\n+        return CXCursor_OMPDistributeDirective;\n@@ -2361,0 +3252,2 @@\n+    private static final int CXCursor_OMPTargetEnterDataDirective = (int)261L;\n+\n@@ -2362,1 +3255,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2367,1 +3260,1 @@\n-        return (int)261L;\n+        return CXCursor_OMPTargetEnterDataDirective;\n@@ -2369,0 +3262,2 @@\n+    private static final int CXCursor_OMPTargetExitDataDirective = (int)262L;\n+\n@@ -2370,1 +3265,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2375,1 +3270,1 @@\n-        return (int)262L;\n+        return CXCursor_OMPTargetExitDataDirective;\n@@ -2377,0 +3272,2 @@\n+    private static final int CXCursor_OMPTargetParallelDirective = (int)263L;\n+\n@@ -2378,1 +3275,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2383,1 +3280,1 @@\n-        return (int)263L;\n+        return CXCursor_OMPTargetParallelDirective;\n@@ -2385,0 +3282,2 @@\n+    private static final int CXCursor_OMPTargetParallelForDirective = (int)264L;\n+\n@@ -2386,1 +3285,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2391,1 +3290,1 @@\n-        return (int)264L;\n+        return CXCursor_OMPTargetParallelForDirective;\n@@ -2393,0 +3292,2 @@\n+    private static final int CXCursor_OMPTargetUpdateDirective = (int)265L;\n+\n@@ -2394,1 +3295,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2399,1 +3300,1 @@\n-        return (int)265L;\n+        return CXCursor_OMPTargetUpdateDirective;\n@@ -2401,0 +3302,2 @@\n+    private static final int CXCursor_OMPDistributeParallelForDirective = (int)266L;\n+\n@@ -2402,1 +3305,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2407,1 +3310,1 @@\n-        return (int)266L;\n+        return CXCursor_OMPDistributeParallelForDirective;\n@@ -2409,0 +3312,2 @@\n+    private static final int CXCursor_OMPDistributeParallelForSimdDirective = (int)267L;\n+\n@@ -2410,1 +3315,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2415,1 +3320,1 @@\n-        return (int)267L;\n+        return CXCursor_OMPDistributeParallelForSimdDirective;\n@@ -2417,0 +3322,2 @@\n+    private static final int CXCursor_OMPDistributeSimdDirective = (int)268L;\n+\n@@ -2418,1 +3325,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2423,1 +3330,1 @@\n-        return (int)268L;\n+        return CXCursor_OMPDistributeSimdDirective;\n@@ -2425,0 +3332,2 @@\n+    private static final int CXCursor_OMPTargetParallelForSimdDirective = (int)269L;\n+\n@@ -2426,1 +3335,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2431,1 +3340,1 @@\n-        return (int)269L;\n+        return CXCursor_OMPTargetParallelForSimdDirective;\n@@ -2433,0 +3342,2 @@\n+    private static final int CXCursor_OMPTargetSimdDirective = (int)270L;\n+\n@@ -2434,1 +3345,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2439,1 +3350,1 @@\n-        return (int)270L;\n+        return CXCursor_OMPTargetSimdDirective;\n@@ -2441,0 +3352,2 @@\n+    private static final int CXCursor_OMPTeamsDistributeDirective = (int)271L;\n+\n@@ -2442,1 +3355,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2447,1 +3360,1 @@\n-        return (int)271L;\n+        return CXCursor_OMPTeamsDistributeDirective;\n@@ -2449,0 +3362,2 @@\n+    private static final int CXCursor_OMPTeamsDistributeSimdDirective = (int)272L;\n+\n@@ -2450,1 +3365,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2455,1 +3370,1 @@\n-        return (int)272L;\n+        return CXCursor_OMPTeamsDistributeSimdDirective;\n@@ -2457,0 +3372,2 @@\n+    private static final int CXCursor_OMPTeamsDistributeParallelForSimdDirective = (int)273L;\n+\n@@ -2458,1 +3375,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2463,1 +3380,1 @@\n-        return (int)273L;\n+        return CXCursor_OMPTeamsDistributeParallelForSimdDirective;\n@@ -2465,0 +3382,2 @@\n+    private static final int CXCursor_OMPTeamsDistributeParallelForDirective = (int)274L;\n+\n@@ -2466,1 +3385,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2471,1 +3390,1 @@\n-        return (int)274L;\n+        return CXCursor_OMPTeamsDistributeParallelForDirective;\n@@ -2473,0 +3392,2 @@\n+    private static final int CXCursor_OMPTargetTeamsDirective = (int)275L;\n+\n@@ -2474,1 +3395,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2479,1 +3400,1 @@\n-        return (int)275L;\n+        return CXCursor_OMPTargetTeamsDirective;\n@@ -2481,0 +3402,2 @@\n+    private static final int CXCursor_OMPTargetTeamsDistributeDirective = (int)276L;\n+\n@@ -2482,1 +3405,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2487,1 +3410,1 @@\n-        return (int)276L;\n+        return CXCursor_OMPTargetTeamsDistributeDirective;\n@@ -2489,0 +3412,2 @@\n+    private static final int CXCursor_OMPTargetTeamsDistributeParallelForDirective = (int)277L;\n+\n@@ -2490,1 +3415,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2495,1 +3420,1 @@\n-        return (int)277L;\n+        return CXCursor_OMPTargetTeamsDistributeParallelForDirective;\n@@ -2497,0 +3422,2 @@\n+    private static final int CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective = (int)278L;\n+\n@@ -2498,1 +3425,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2503,1 +3430,1 @@\n-        return (int)278L;\n+        return CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective;\n@@ -2505,0 +3432,2 @@\n+    private static final int CXCursor_OMPTargetTeamsDistributeSimdDirective = (int)279L;\n+\n@@ -2506,1 +3435,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2511,1 +3440,1 @@\n-        return (int)279L;\n+        return CXCursor_OMPTargetTeamsDistributeSimdDirective;\n@@ -2513,0 +3442,2 @@\n+    private static final int CXCursor_BuiltinBitCastExpr = (int)280L;\n+\n@@ -2514,1 +3445,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2519,1 +3450,1 @@\n-        return (int)280L;\n+        return CXCursor_BuiltinBitCastExpr;\n@@ -2521,0 +3452,2 @@\n+    private static final int CXCursor_OMPMasterTaskLoopDirective = (int)281L;\n+\n@@ -2522,1 +3455,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2527,1 +3460,1 @@\n-        return (int)281L;\n+        return CXCursor_OMPMasterTaskLoopDirective;\n@@ -2529,0 +3462,2 @@\n+    private static final int CXCursor_OMPParallelMasterTaskLoopDirective = (int)282L;\n+\n@@ -2530,1 +3465,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2535,1 +3470,1 @@\n-        return (int)282L;\n+        return CXCursor_OMPParallelMasterTaskLoopDirective;\n@@ -2537,0 +3472,2 @@\n+    private static final int CXCursor_OMPMasterTaskLoopSimdDirective = (int)283L;\n+\n@@ -2538,1 +3475,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2543,1 +3480,1 @@\n-        return (int)283L;\n+        return CXCursor_OMPMasterTaskLoopSimdDirective;\n@@ -2545,0 +3482,2 @@\n+    private static final int CXCursor_OMPParallelMasterTaskLoopSimdDirective = (int)284L;\n+\n@@ -2546,1 +3485,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2551,1 +3490,1 @@\n-        return (int)284L;\n+        return CXCursor_OMPParallelMasterTaskLoopSimdDirective;\n@@ -2553,0 +3492,2 @@\n+    private static final int CXCursor_LastStmt = (int)293L;\n+\n@@ -2554,1 +3495,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2559,1 +3500,1 @@\n-        return (int)293L;\n+        return CXCursor_LastStmt;\n@@ -2561,0 +3502,2 @@\n+    private static final int CXCursor_TranslationUnit = (int)300L;\n+\n@@ -2562,1 +3505,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2567,1 +3510,1 @@\n-        return (int)300L;\n+        return CXCursor_TranslationUnit;\n@@ -2569,0 +3512,2 @@\n+    private static final int CXCursor_FirstAttr = (int)400L;\n+\n@@ -2570,1 +3515,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2575,1 +3520,1 @@\n-        return (int)400L;\n+        return CXCursor_FirstAttr;\n@@ -2577,0 +3522,2 @@\n+    private static final int CXCursor_UnexposedAttr = (int)400L;\n+\n@@ -2578,1 +3525,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2583,1 +3530,1 @@\n-        return (int)400L;\n+        return CXCursor_UnexposedAttr;\n@@ -2585,0 +3532,2 @@\n+    private static final int CXCursor_IBActionAttr = (int)401L;\n+\n@@ -2586,1 +3535,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2591,1 +3540,1 @@\n-        return (int)401L;\n+        return CXCursor_IBActionAttr;\n@@ -2593,0 +3542,2 @@\n+    private static final int CXCursor_IBOutletAttr = (int)402L;\n+\n@@ -2594,1 +3545,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2599,1 +3550,1 @@\n-        return (int)402L;\n+        return CXCursor_IBOutletAttr;\n@@ -2601,0 +3552,2 @@\n+    private static final int CXCursor_IBOutletCollectionAttr = (int)403L;\n+\n@@ -2602,1 +3555,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2607,1 +3560,1 @@\n-        return (int)403L;\n+        return CXCursor_IBOutletCollectionAttr;\n@@ -2609,0 +3562,2 @@\n+    private static final int CXCursor_CXXFinalAttr = (int)404L;\n+\n@@ -2610,1 +3565,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2615,1 +3570,1 @@\n-        return (int)404L;\n+        return CXCursor_CXXFinalAttr;\n@@ -2617,0 +3572,2 @@\n+    private static final int CXCursor_CXXOverrideAttr = (int)405L;\n+\n@@ -2618,1 +3575,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2623,1 +3580,1 @@\n-        return (int)405L;\n+        return CXCursor_CXXOverrideAttr;\n@@ -2625,0 +3582,2 @@\n+    private static final int CXCursor_AnnotateAttr = (int)406L;\n+\n@@ -2626,1 +3585,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2631,1 +3590,1 @@\n-        return (int)406L;\n+        return CXCursor_AnnotateAttr;\n@@ -2633,0 +3592,2 @@\n+    private static final int CXCursor_AsmLabelAttr = (int)407L;\n+\n@@ -2634,1 +3595,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2639,1 +3600,1 @@\n-        return (int)407L;\n+        return CXCursor_AsmLabelAttr;\n@@ -2641,0 +3602,2 @@\n+    private static final int CXCursor_PackedAttr = (int)408L;\n+\n@@ -2642,1 +3605,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2647,1 +3610,1 @@\n-        return (int)408L;\n+        return CXCursor_PackedAttr;\n@@ -2649,0 +3612,2 @@\n+    private static final int CXCursor_PureAttr = (int)409L;\n+\n@@ -2650,1 +3615,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2655,1 +3620,1 @@\n-        return (int)409L;\n+        return CXCursor_PureAttr;\n@@ -2657,0 +3622,2 @@\n+    private static final int CXCursor_ConstAttr = (int)410L;\n+\n@@ -2658,1 +3625,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2663,1 +3630,1 @@\n-        return (int)410L;\n+        return CXCursor_ConstAttr;\n@@ -2665,0 +3632,2 @@\n+    private static final int CXCursor_NoDuplicateAttr = (int)411L;\n+\n@@ -2666,1 +3635,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2671,1 +3640,1 @@\n-        return (int)411L;\n+        return CXCursor_NoDuplicateAttr;\n@@ -2673,0 +3642,2 @@\n+    private static final int CXCursor_CUDAConstantAttr = (int)412L;\n+\n@@ -2674,1 +3645,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2679,1 +3650,1 @@\n-        return (int)412L;\n+        return CXCursor_CUDAConstantAttr;\n@@ -2681,0 +3652,2 @@\n+    private static final int CXCursor_CUDADeviceAttr = (int)413L;\n+\n@@ -2682,1 +3655,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2687,1 +3660,1 @@\n-        return (int)413L;\n+        return CXCursor_CUDADeviceAttr;\n@@ -2689,0 +3662,2 @@\n+    private static final int CXCursor_CUDAGlobalAttr = (int)414L;\n+\n@@ -2690,1 +3665,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2695,1 +3670,1 @@\n-        return (int)414L;\n+        return CXCursor_CUDAGlobalAttr;\n@@ -2697,0 +3672,2 @@\n+    private static final int CXCursor_CUDAHostAttr = (int)415L;\n+\n@@ -2698,1 +3675,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2703,1 +3680,1 @@\n-        return (int)415L;\n+        return CXCursor_CUDAHostAttr;\n@@ -2705,0 +3682,2 @@\n+    private static final int CXCursor_CUDASharedAttr = (int)416L;\n+\n@@ -2706,1 +3685,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2711,1 +3690,1 @@\n-        return (int)416L;\n+        return CXCursor_CUDASharedAttr;\n@@ -2713,0 +3692,2 @@\n+    private static final int CXCursor_VisibilityAttr = (int)417L;\n+\n@@ -2714,1 +3695,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2719,1 +3700,1 @@\n-        return (int)417L;\n+        return CXCursor_VisibilityAttr;\n@@ -2721,0 +3702,2 @@\n+    private static final int CXCursor_DLLExport = (int)418L;\n+\n@@ -2722,1 +3705,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2727,1 +3710,1 @@\n-        return (int)418L;\n+        return CXCursor_DLLExport;\n@@ -2729,0 +3712,2 @@\n+    private static final int CXCursor_DLLImport = (int)419L;\n+\n@@ -2730,1 +3715,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2735,1 +3720,1 @@\n-        return (int)419L;\n+        return CXCursor_DLLImport;\n@@ -2737,0 +3722,2 @@\n+    private static final int CXCursor_NSReturnsRetained = (int)420L;\n+\n@@ -2738,1 +3725,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2743,1 +3730,1 @@\n-        return (int)420L;\n+        return CXCursor_NSReturnsRetained;\n@@ -2745,0 +3732,2 @@\n+    private static final int CXCursor_NSReturnsNotRetained = (int)421L;\n+\n@@ -2746,1 +3735,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2751,1 +3740,1 @@\n-        return (int)421L;\n+        return CXCursor_NSReturnsNotRetained;\n@@ -2753,0 +3742,2 @@\n+    private static final int CXCursor_NSReturnsAutoreleased = (int)422L;\n+\n@@ -2754,1 +3745,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2759,1 +3750,1 @@\n-        return (int)422L;\n+        return CXCursor_NSReturnsAutoreleased;\n@@ -2761,0 +3752,2 @@\n+    private static final int CXCursor_NSConsumesSelf = (int)423L;\n+\n@@ -2762,1 +3755,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2767,1 +3760,1 @@\n-        return (int)423L;\n+        return CXCursor_NSConsumesSelf;\n@@ -2769,0 +3762,2 @@\n+    private static final int CXCursor_NSConsumed = (int)424L;\n+\n@@ -2770,1 +3765,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2775,1 +3770,1 @@\n-        return (int)424L;\n+        return CXCursor_NSConsumed;\n@@ -2777,0 +3772,2 @@\n+    private static final int CXCursor_ObjCException = (int)425L;\n+\n@@ -2778,1 +3775,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2783,1 +3780,1 @@\n-        return (int)425L;\n+        return CXCursor_ObjCException;\n@@ -2785,0 +3782,2 @@\n+    private static final int CXCursor_ObjCNSObject = (int)426L;\n+\n@@ -2786,1 +3785,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2791,1 +3790,1 @@\n-        return (int)426L;\n+        return CXCursor_ObjCNSObject;\n@@ -2793,0 +3792,2 @@\n+    private static final int CXCursor_ObjCIndependentClass = (int)427L;\n+\n@@ -2794,1 +3795,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2799,1 +3800,1 @@\n-        return (int)427L;\n+        return CXCursor_ObjCIndependentClass;\n@@ -2801,0 +3802,2 @@\n+    private static final int CXCursor_ObjCPreciseLifetime = (int)428L;\n+\n@@ -2802,1 +3805,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2807,1 +3810,1 @@\n-        return (int)428L;\n+        return CXCursor_ObjCPreciseLifetime;\n@@ -2809,0 +3812,2 @@\n+    private static final int CXCursor_ObjCReturnsInnerPointer = (int)429L;\n+\n@@ -2810,1 +3815,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2815,1 +3820,1 @@\n-        return (int)429L;\n+        return CXCursor_ObjCReturnsInnerPointer;\n@@ -2817,0 +3822,2 @@\n+    private static final int CXCursor_ObjCRequiresSuper = (int)430L;\n+\n@@ -2818,1 +3825,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2823,1 +3830,1 @@\n-        return (int)430L;\n+        return CXCursor_ObjCRequiresSuper;\n@@ -2825,0 +3832,2 @@\n+    private static final int CXCursor_ObjCRootClass = (int)431L;\n+\n@@ -2826,1 +3835,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2831,1 +3840,1 @@\n-        return (int)431L;\n+        return CXCursor_ObjCRootClass;\n@@ -2833,0 +3842,2 @@\n+    private static final int CXCursor_ObjCSubclassingRestricted = (int)432L;\n+\n@@ -2834,1 +3845,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2839,1 +3850,1 @@\n-        return (int)432L;\n+        return CXCursor_ObjCSubclassingRestricted;\n@@ -2841,0 +3852,2 @@\n+    private static final int CXCursor_ObjCExplicitProtocolImpl = (int)433L;\n+\n@@ -2842,1 +3855,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2847,1 +3860,1 @@\n-        return (int)433L;\n+        return CXCursor_ObjCExplicitProtocolImpl;\n@@ -2849,0 +3862,2 @@\n+    private static final int CXCursor_ObjCDesignatedInitializer = (int)434L;\n+\n@@ -2850,1 +3865,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2855,1 +3870,1 @@\n-        return (int)434L;\n+        return CXCursor_ObjCDesignatedInitializer;\n@@ -2857,0 +3872,2 @@\n+    private static final int CXCursor_ObjCRuntimeVisible = (int)435L;\n+\n@@ -2858,1 +3875,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2863,1 +3880,1 @@\n-        return (int)435L;\n+        return CXCursor_ObjCRuntimeVisible;\n@@ -2865,0 +3882,2 @@\n+    private static final int CXCursor_ObjCBoxable = (int)436L;\n+\n@@ -2866,1 +3885,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2871,1 +3890,1 @@\n-        return (int)436L;\n+        return CXCursor_ObjCBoxable;\n@@ -2873,0 +3892,2 @@\n+    private static final int CXCursor_FlagEnum = (int)437L;\n+\n@@ -2874,1 +3895,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2879,1 +3900,1 @@\n-        return (int)437L;\n+        return CXCursor_FlagEnum;\n@@ -2881,0 +3902,2 @@\n+    private static final int CXCursor_ConvergentAttr = (int)438L;\n+\n@@ -2882,1 +3905,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2887,1 +3910,1 @@\n-        return (int)438L;\n+        return CXCursor_ConvergentAttr;\n@@ -2889,0 +3912,2 @@\n+    private static final int CXCursor_WarnUnusedAttr = (int)439L;\n+\n@@ -2890,1 +3915,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2895,1 +3920,1 @@\n-        return (int)439L;\n+        return CXCursor_WarnUnusedAttr;\n@@ -2897,0 +3922,2 @@\n+    private static final int CXCursor_WarnUnusedResultAttr = (int)440L;\n+\n@@ -2898,1 +3925,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2903,1 +3930,1 @@\n-        return (int)440L;\n+        return CXCursor_WarnUnusedResultAttr;\n@@ -2905,0 +3932,2 @@\n+    private static final int CXCursor_AlignedAttr = (int)441L;\n+\n@@ -2906,1 +3935,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2911,1 +3940,1 @@\n-        return (int)441L;\n+        return CXCursor_AlignedAttr;\n@@ -2913,0 +3942,2 @@\n+    private static final int CXCursor_LastAttr = (int)441L;\n+\n@@ -2914,1 +3945,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2919,1 +3950,1 @@\n-        return (int)441L;\n+        return CXCursor_LastAttr;\n@@ -2921,0 +3952,2 @@\n+    private static final int CXCursor_PreprocessingDirective = (int)500L;\n+\n@@ -2922,1 +3955,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2927,1 +3960,1 @@\n-        return (int)500L;\n+        return CXCursor_PreprocessingDirective;\n@@ -2929,0 +3962,2 @@\n+    private static final int CXCursor_MacroDefinition = (int)501L;\n+\n@@ -2930,1 +3965,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2935,1 +3970,1 @@\n-        return (int)501L;\n+        return CXCursor_MacroDefinition;\n@@ -2937,0 +3972,2 @@\n+    private static final int CXCursor_MacroExpansion = (int)502L;\n+\n@@ -2938,1 +3975,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2943,1 +3980,1 @@\n-        return (int)502L;\n+        return CXCursor_MacroExpansion;\n@@ -2945,0 +3982,2 @@\n+    private static final int CXCursor_MacroInstantiation = (int)502L;\n+\n@@ -2946,1 +3985,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2951,1 +3990,1 @@\n-        return (int)502L;\n+        return CXCursor_MacroInstantiation;\n@@ -2953,0 +3992,2 @@\n+    private static final int CXCursor_InclusionDirective = (int)503L;\n+\n@@ -2954,1 +3995,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2959,1 +4000,1 @@\n-        return (int)503L;\n+        return CXCursor_InclusionDirective;\n@@ -2961,0 +4002,2 @@\n+    private static final int CXCursor_FirstPreprocessing = (int)500L;\n+\n@@ -2962,1 +4005,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2967,1 +4010,1 @@\n-        return (int)500L;\n+        return CXCursor_FirstPreprocessing;\n@@ -2969,0 +4012,2 @@\n+    private static final int CXCursor_LastPreprocessing = (int)503L;\n+\n@@ -2970,1 +4015,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2975,1 +4020,1 @@\n-        return (int)503L;\n+        return CXCursor_LastPreprocessing;\n@@ -2977,0 +4022,2 @@\n+    private static final int CXCursor_ModuleImportDecl = (int)600L;\n+\n@@ -2978,1 +4025,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2983,1 +4030,1 @@\n-        return (int)600L;\n+        return CXCursor_ModuleImportDecl;\n@@ -2985,0 +4032,2 @@\n+    private static final int CXCursor_TypeAliasTemplateDecl = (int)601L;\n+\n@@ -2986,1 +4035,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2991,1 +4040,1 @@\n-        return (int)601L;\n+        return CXCursor_TypeAliasTemplateDecl;\n@@ -2993,0 +4042,2 @@\n+    private static final int CXCursor_StaticAssert = (int)602L;\n+\n@@ -2994,1 +4045,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -2999,1 +4050,1 @@\n-        return (int)602L;\n+        return CXCursor_StaticAssert;\n@@ -3001,0 +4052,2 @@\n+    private static final int CXCursor_FriendDecl = (int)603L;\n+\n@@ -3002,1 +4055,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3007,1 +4060,1 @@\n-        return (int)603L;\n+        return CXCursor_FriendDecl;\n@@ -3009,0 +4062,2 @@\n+    private static final int CXCursor_FirstExtraDecl = (int)600L;\n+\n@@ -3010,1 +4065,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3015,1 +4070,1 @@\n-        return (int)600L;\n+        return CXCursor_FirstExtraDecl;\n@@ -3017,0 +4072,2 @@\n+    private static final int CXCursor_LastExtraDecl = (int)603L;\n+\n@@ -3018,1 +4075,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3023,1 +4080,1 @@\n-        return (int)603L;\n+        return CXCursor_LastExtraDecl;\n@@ -3025,0 +4082,2 @@\n+    private static final int CXCursor_OverloadCandidate = (int)700L;\n+\n@@ -3026,1 +4085,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3031,4 +4090,1 @@\n-        return (int)700L;\n-    }\n-    public static MethodHandle clang_getNullCursor$MH() {\n-        return RuntimeHelper.requireNonNull(constants$5.clang_getNullCursor$MH,\"clang_getNullCursor\");\n+        return CXCursor_OverloadCandidate;\n@@ -3037,1 +4093,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3041,0 +4097,12 @@\n+    public static MethodHandle clang_getNullCursor$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXCursor.$LAYOUT()        );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getNullCursor\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -3044,1 +4112,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator);\n+            return (MemorySegment) mh$.invokeExact(allocator);\n@@ -3046,1 +4114,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -3049,3 +4117,0 @@\n-    public static MethodHandle clang_getTranslationUnitCursor$MH() {\n-        return RuntimeHelper.requireNonNull(constants$5.clang_getTranslationUnitCursor$MH,\"clang_getTranslationUnitCursor\");\n-    }\n@@ -3053,1 +4118,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3057,1 +4122,15 @@\n-    public static MemorySegment clang_getTranslationUnitCursor(SegmentAllocator allocator, MemorySegment x1) {\n+    public static MethodHandle clang_getTranslationUnitCursor$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXCursor.$LAYOUT(),\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getTranslationUnitCursor\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n+    public static MemorySegment clang_getTranslationUnitCursor(SegmentAllocator allocator, MemorySegment x0) {\n@@ -3060,1 +4139,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+            return (MemorySegment) mh$.invokeExact(allocator, x0);\n@@ -3062,1 +4141,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -3065,3 +4144,0 @@\n-    public static MethodHandle clang_equalCursors$MH() {\n-        return RuntimeHelper.requireNonNull(constants$5.clang_equalCursors$MH,\"clang_equalCursors\");\n-    }\n@@ -3069,1 +4145,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3073,0 +4149,15 @@\n+    public static MethodHandle clang_equalCursors$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXCursor.$LAYOUT(),\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_equalCursors\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -3076,1 +4167,1 @@\n-            return (int)mh$.invokeExact(x0, x1);\n+            return (int) mh$.invokeExact(x0, x1);\n@@ -3078,1 +4169,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -3081,3 +4172,0 @@\n-    public static MethodHandle clang_Cursor_isNull$MH() {\n-        return RuntimeHelper.requireNonNull(constants$5.clang_Cursor_isNull$MH,\"clang_Cursor_isNull\");\n-    }\n@@ -3085,1 +4173,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3089,0 +4177,14 @@\n+    public static MethodHandle clang_Cursor_isNull$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_isNull\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -3092,1 +4194,1 @@\n-            return (int)mh$.invokeExact(cursor);\n+            return (int) mh$.invokeExact(cursor);\n@@ -3094,1 +4196,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -3097,3 +4199,0 @@\n-    public static MethodHandle clang_getCursorKind$MH() {\n-        return RuntimeHelper.requireNonNull(constants$6.clang_getCursorKind$MH,\"clang_getCursorKind\");\n-    }\n@@ -3101,1 +4200,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3105,0 +4204,14 @@\n+    public static MethodHandle clang_getCursorKind$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorKind\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -3108,1 +4221,1 @@\n-            return (int)mh$.invokeExact(x0);\n+            return (int) mh$.invokeExact(x0);\n@@ -3110,1 +4223,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -3113,3 +4226,0 @@\n-    public static MethodHandle clang_isDeclaration$MH() {\n-        return RuntimeHelper.requireNonNull(constants$6.clang_isDeclaration$MH,\"clang_isDeclaration\");\n-    }\n@@ -3117,1 +4227,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3121,0 +4231,14 @@\n+    public static MethodHandle clang_isDeclaration$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                Index_h.C_INT\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_isDeclaration\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -3124,1 +4248,1 @@\n-            return (int)mh$.invokeExact(x0);\n+            return (int) mh$.invokeExact(x0);\n@@ -3126,1 +4250,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -3129,3 +4253,0 @@\n-    public static MethodHandle clang_isAttribute$MH() {\n-        return RuntimeHelper.requireNonNull(constants$6.clang_isAttribute$MH,\"clang_isAttribute\");\n-    }\n@@ -3133,1 +4254,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3137,0 +4258,14 @@\n+    public static MethodHandle clang_isAttribute$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                Index_h.C_INT\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_isAttribute\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -3140,1 +4275,1 @@\n-            return (int)mh$.invokeExact(x0);\n+            return (int) mh$.invokeExact(x0);\n@@ -3142,1 +4277,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -3145,3 +4280,0 @@\n-    public static MethodHandle clang_isInvalid$MH() {\n-        return RuntimeHelper.requireNonNull(constants$6.clang_isInvalid$MH,\"clang_isInvalid\");\n-    }\n@@ -3149,1 +4281,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3153,0 +4285,14 @@\n+    public static MethodHandle clang_isInvalid$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                Index_h.C_INT\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_isInvalid\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -3156,1 +4302,1 @@\n-            return (int)mh$.invokeExact(x0);\n+            return (int) mh$.invokeExact(x0);\n@@ -3158,1 +4304,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -3161,3 +4307,0 @@\n-    public static MethodHandle clang_isPreprocessing$MH() {\n-        return RuntimeHelper.requireNonNull(constants$6.clang_isPreprocessing$MH,\"clang_isPreprocessing\");\n-    }\n@@ -3165,1 +4308,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3169,0 +4312,14 @@\n+    public static MethodHandle clang_isPreprocessing$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                Index_h.C_INT\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_isPreprocessing\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -3172,1 +4329,1 @@\n-            return (int)mh$.invokeExact(x0);\n+            return (int) mh$.invokeExact(x0);\n@@ -3174,1 +4331,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -3177,0 +4334,2 @@\n+    private static final int CXLinkage_Invalid = (int)0L;\n+\n@@ -3178,1 +4337,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3183,1 +4342,1 @@\n-        return (int)0L;\n+        return CXLinkage_Invalid;\n@@ -3185,0 +4344,2 @@\n+    private static final int CXLinkage_NoLinkage = (int)1L;\n+\n@@ -3186,1 +4347,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3191,1 +4352,1 @@\n-        return (int)1L;\n+        return CXLinkage_NoLinkage;\n@@ -3193,0 +4354,2 @@\n+    private static final int CXLinkage_Internal = (int)2L;\n+\n@@ -3194,1 +4357,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3199,1 +4362,1 @@\n-        return (int)2L;\n+        return CXLinkage_Internal;\n@@ -3201,0 +4364,2 @@\n+    private static final int CXLinkage_UniqueExternal = (int)3L;\n+\n@@ -3202,1 +4367,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3207,1 +4372,1 @@\n-        return (int)3L;\n+        return CXLinkage_UniqueExternal;\n@@ -3209,0 +4374,2 @@\n+    private static final int CXLinkage_External = (int)4L;\n+\n@@ -3210,1 +4377,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3215,4 +4382,1 @@\n-        return (int)4L;\n-    }\n-    public static MethodHandle clang_getCursorLinkage$MH() {\n-        return RuntimeHelper.requireNonNull(constants$6.clang_getCursorLinkage$MH,\"clang_getCursorLinkage\");\n+        return CXLinkage_External;\n@@ -3221,1 +4385,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3225,0 +4389,14 @@\n+    public static MethodHandle clang_getCursorLinkage$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorLinkage\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -3228,1 +4406,1 @@\n-            return (int)mh$.invokeExact(cursor);\n+            return (int) mh$.invokeExact(cursor);\n@@ -3230,1 +4408,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -3233,0 +4411,2 @@\n+    private static final int CXLanguage_Invalid = (int)0L;\n+\n@@ -3234,1 +4414,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3239,1 +4419,1 @@\n-        return (int)0L;\n+        return CXLanguage_Invalid;\n@@ -3241,0 +4421,2 @@\n+    private static final int CXLanguage_C = (int)1L;\n+\n@@ -3242,1 +4424,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3247,1 +4429,1 @@\n-        return (int)1L;\n+        return CXLanguage_C;\n@@ -3249,0 +4431,2 @@\n+    private static final int CXLanguage_ObjC = (int)2L;\n+\n@@ -3250,1 +4434,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3255,1 +4439,1 @@\n-        return (int)2L;\n+        return CXLanguage_ObjC;\n@@ -3257,0 +4441,2 @@\n+    private static final int CXLanguage_CPlusPlus = (int)3L;\n+\n@@ -3258,1 +4444,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3263,4 +4449,1 @@\n-        return (int)3L;\n-    }\n-    public static MethodHandle clang_getCursorLanguage$MH() {\n-        return RuntimeHelper.requireNonNull(constants$7.clang_getCursorLanguage$MH,\"clang_getCursorLanguage\");\n+        return CXLanguage_CPlusPlus;\n@@ -3269,1 +4452,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3273,0 +4456,14 @@\n+    public static MethodHandle clang_getCursorLanguage$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorLanguage\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -3276,1 +4473,1 @@\n-            return (int)mh$.invokeExact(cursor);\n+            return (int) mh$.invokeExact(cursor);\n@@ -3278,1 +4475,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -3281,3 +4478,0 @@\n-    public static MethodHandle clang_Cursor_getTranslationUnit$MH() {\n-        return RuntimeHelper.requireNonNull(constants$7.clang_Cursor_getTranslationUnit$MH,\"clang_Cursor_getTranslationUnit\");\n-    }\n@@ -3285,1 +4479,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3289,0 +4483,14 @@\n+    public static MethodHandle clang_Cursor_getTranslationUnit$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_POINTER,\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_getTranslationUnit\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -3292,1 +4500,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(x0);\n+            return (MemorySegment) mh$.invokeExact(x0);\n@@ -3294,1 +4502,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -3297,3 +4505,0 @@\n-    public static MethodHandle clang_getCursorLocation$MH() {\n-        return RuntimeHelper.requireNonNull(constants$7.clang_getCursorLocation$MH,\"clang_getCursorLocation\");\n-    }\n@@ -3301,1 +4506,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3305,1 +4510,15 @@\n-    public static MemorySegment clang_getCursorLocation(SegmentAllocator allocator, MemorySegment x1) {\n+    public static MethodHandle clang_getCursorLocation$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXSourceLocation.$LAYOUT(),\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorLocation\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n+    public static MemorySegment clang_getCursorLocation(SegmentAllocator allocator, MemorySegment x0) {\n@@ -3308,1 +4527,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+            return (MemorySegment) mh$.invokeExact(allocator, x0);\n@@ -3310,1 +4529,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -3313,3 +4532,0 @@\n-    public static MethodHandle clang_getCursorExtent$MH() {\n-        return RuntimeHelper.requireNonNull(constants$7.clang_getCursorExtent$MH,\"clang_getCursorExtent\");\n-    }\n@@ -3317,1 +4533,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3321,1 +4537,15 @@\n-    public static MemorySegment clang_getCursorExtent(SegmentAllocator allocator, MemorySegment x1) {\n+    public static MethodHandle clang_getCursorExtent$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXSourceRange.$LAYOUT(),\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorExtent\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n+    public static MemorySegment clang_getCursorExtent(SegmentAllocator allocator, MemorySegment x0) {\n@@ -3324,1 +4554,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+            return (MemorySegment) mh$.invokeExact(allocator, x0);\n@@ -3326,1 +4556,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -3329,0 +4559,2 @@\n+    private static final int CXType_Invalid = (int)0L;\n+\n@@ -3330,1 +4562,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3335,1 +4567,1 @@\n-        return (int)0L;\n+        return CXType_Invalid;\n@@ -3337,0 +4569,2 @@\n+    private static final int CXType_Unexposed = (int)1L;\n+\n@@ -3338,1 +4572,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3343,1 +4577,1 @@\n-        return (int)1L;\n+        return CXType_Unexposed;\n@@ -3345,0 +4579,2 @@\n+    private static final int CXType_Void = (int)2L;\n+\n@@ -3346,1 +4582,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3351,1 +4587,1 @@\n-        return (int)2L;\n+        return CXType_Void;\n@@ -3353,0 +4589,2 @@\n+    private static final int CXType_Bool = (int)3L;\n+\n@@ -3354,1 +4592,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3359,1 +4597,1 @@\n-        return (int)3L;\n+        return CXType_Bool;\n@@ -3361,0 +4599,2 @@\n+    private static final int CXType_Char_U = (int)4L;\n+\n@@ -3362,1 +4602,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3367,1 +4607,1 @@\n-        return (int)4L;\n+        return CXType_Char_U;\n@@ -3369,0 +4609,2 @@\n+    private static final int CXType_UChar = (int)5L;\n+\n@@ -3370,1 +4612,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3375,1 +4617,1 @@\n-        return (int)5L;\n+        return CXType_UChar;\n@@ -3377,0 +4619,2 @@\n+    private static final int CXType_Char16 = (int)6L;\n+\n@@ -3378,1 +4622,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3383,1 +4627,1 @@\n-        return (int)6L;\n+        return CXType_Char16;\n@@ -3385,0 +4629,2 @@\n+    private static final int CXType_Char32 = (int)7L;\n+\n@@ -3386,1 +4632,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3391,1 +4637,1 @@\n-        return (int)7L;\n+        return CXType_Char32;\n@@ -3393,0 +4639,2 @@\n+    private static final int CXType_UShort = (int)8L;\n+\n@@ -3394,1 +4642,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3399,1 +4647,1 @@\n-        return (int)8L;\n+        return CXType_UShort;\n@@ -3401,0 +4649,2 @@\n+    private static final int CXType_UInt = (int)9L;\n+\n@@ -3402,1 +4652,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3407,1 +4657,1 @@\n-        return (int)9L;\n+        return CXType_UInt;\n@@ -3409,0 +4659,2 @@\n+    private static final int CXType_ULong = (int)10L;\n+\n@@ -3410,1 +4662,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3415,1 +4667,1 @@\n-        return (int)10L;\n+        return CXType_ULong;\n@@ -3417,0 +4669,2 @@\n+    private static final int CXType_ULongLong = (int)11L;\n+\n@@ -3418,1 +4672,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3423,1 +4677,1 @@\n-        return (int)11L;\n+        return CXType_ULongLong;\n@@ -3425,0 +4679,2 @@\n+    private static final int CXType_UInt128 = (int)12L;\n+\n@@ -3426,1 +4682,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3431,1 +4687,1 @@\n-        return (int)12L;\n+        return CXType_UInt128;\n@@ -3433,0 +4689,2 @@\n+    private static final int CXType_Char_S = (int)13L;\n+\n@@ -3434,1 +4692,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3439,1 +4697,1 @@\n-        return (int)13L;\n+        return CXType_Char_S;\n@@ -3441,0 +4699,2 @@\n+    private static final int CXType_SChar = (int)14L;\n+\n@@ -3442,1 +4702,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3447,1 +4707,1 @@\n-        return (int)14L;\n+        return CXType_SChar;\n@@ -3449,0 +4709,2 @@\n+    private static final int CXType_WChar = (int)15L;\n+\n@@ -3450,1 +4712,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3455,1 +4717,1 @@\n-        return (int)15L;\n+        return CXType_WChar;\n@@ -3457,0 +4719,2 @@\n+    private static final int CXType_Short = (int)16L;\n+\n@@ -3458,1 +4722,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3463,1 +4727,1 @@\n-        return (int)16L;\n+        return CXType_Short;\n@@ -3465,0 +4729,2 @@\n+    private static final int CXType_Int = (int)17L;\n+\n@@ -3466,1 +4732,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3471,1 +4737,1 @@\n-        return (int)17L;\n+        return CXType_Int;\n@@ -3473,0 +4739,2 @@\n+    private static final int CXType_Long = (int)18L;\n+\n@@ -3474,1 +4742,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3479,1 +4747,1 @@\n-        return (int)18L;\n+        return CXType_Long;\n@@ -3481,0 +4749,2 @@\n+    private static final int CXType_LongLong = (int)19L;\n+\n@@ -3482,1 +4752,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3487,1 +4757,1 @@\n-        return (int)19L;\n+        return CXType_LongLong;\n@@ -3489,0 +4759,2 @@\n+    private static final int CXType_Int128 = (int)20L;\n+\n@@ -3490,1 +4762,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3495,1 +4767,1 @@\n-        return (int)20L;\n+        return CXType_Int128;\n@@ -3497,0 +4769,2 @@\n+    private static final int CXType_Float = (int)21L;\n+\n@@ -3498,1 +4772,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3503,1 +4777,1 @@\n-        return (int)21L;\n+        return CXType_Float;\n@@ -3505,0 +4779,2 @@\n+    private static final int CXType_Double = (int)22L;\n+\n@@ -3506,1 +4782,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3511,1 +4787,1 @@\n-        return (int)22L;\n+        return CXType_Double;\n@@ -3513,0 +4789,2 @@\n+    private static final int CXType_LongDouble = (int)23L;\n+\n@@ -3514,1 +4792,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3519,1 +4797,1 @@\n-        return (int)23L;\n+        return CXType_LongDouble;\n@@ -3521,0 +4799,2 @@\n+    private static final int CXType_NullPtr = (int)24L;\n+\n@@ -3522,1 +4802,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3527,1 +4807,1 @@\n-        return (int)24L;\n+        return CXType_NullPtr;\n@@ -3529,0 +4809,2 @@\n+    private static final int CXType_Overload = (int)25L;\n+\n@@ -3530,1 +4812,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3535,1 +4817,1 @@\n-        return (int)25L;\n+        return CXType_Overload;\n@@ -3537,0 +4819,2 @@\n+    private static final int CXType_Dependent = (int)26L;\n+\n@@ -3538,1 +4822,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3543,1 +4827,1 @@\n-        return (int)26L;\n+        return CXType_Dependent;\n@@ -3545,0 +4829,2 @@\n+    private static final int CXType_ObjCId = (int)27L;\n+\n@@ -3546,1 +4832,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3551,1 +4837,1 @@\n-        return (int)27L;\n+        return CXType_ObjCId;\n@@ -3553,0 +4839,2 @@\n+    private static final int CXType_ObjCClass = (int)28L;\n+\n@@ -3554,1 +4842,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3559,1 +4847,1 @@\n-        return (int)28L;\n+        return CXType_ObjCClass;\n@@ -3561,0 +4849,2 @@\n+    private static final int CXType_ObjCSel = (int)29L;\n+\n@@ -3562,1 +4852,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3567,1 +4857,1 @@\n-        return (int)29L;\n+        return CXType_ObjCSel;\n@@ -3569,0 +4859,2 @@\n+    private static final int CXType_Float128 = (int)30L;\n+\n@@ -3570,1 +4862,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3575,1 +4867,1 @@\n-        return (int)30L;\n+        return CXType_Float128;\n@@ -3577,0 +4869,2 @@\n+    private static final int CXType_Half = (int)31L;\n+\n@@ -3578,1 +4872,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3583,1 +4877,1 @@\n-        return (int)31L;\n+        return CXType_Half;\n@@ -3585,0 +4879,2 @@\n+    private static final int CXType_Float16 = (int)32L;\n+\n@@ -3586,1 +4882,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3591,1 +4887,1 @@\n-        return (int)32L;\n+        return CXType_Float16;\n@@ -3593,0 +4889,2 @@\n+    private static final int CXType_ShortAccum = (int)33L;\n+\n@@ -3594,1 +4892,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3599,1 +4897,1 @@\n-        return (int)33L;\n+        return CXType_ShortAccum;\n@@ -3601,0 +4899,2 @@\n+    private static final int CXType_Accum = (int)34L;\n+\n@@ -3602,1 +4902,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3607,1 +4907,1 @@\n-        return (int)34L;\n+        return CXType_Accum;\n@@ -3609,0 +4909,2 @@\n+    private static final int CXType_LongAccum = (int)35L;\n+\n@@ -3610,1 +4912,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3615,1 +4917,1 @@\n-        return (int)35L;\n+        return CXType_LongAccum;\n@@ -3617,0 +4919,2 @@\n+    private static final int CXType_UShortAccum = (int)36L;\n+\n@@ -3618,1 +4922,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3623,1 +4927,1 @@\n-        return (int)36L;\n+        return CXType_UShortAccum;\n@@ -3625,0 +4929,2 @@\n+    private static final int CXType_UAccum = (int)37L;\n+\n@@ -3626,1 +4932,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3631,1 +4937,1 @@\n-        return (int)37L;\n+        return CXType_UAccum;\n@@ -3633,0 +4939,2 @@\n+    private static final int CXType_ULongAccum = (int)38L;\n+\n@@ -3634,1 +4942,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3639,1 +4947,1 @@\n-        return (int)38L;\n+        return CXType_ULongAccum;\n@@ -3641,0 +4949,2 @@\n+    private static final int CXType_FirstBuiltin = (int)2L;\n+\n@@ -3642,1 +4952,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3647,1 +4957,1 @@\n-        return (int)2L;\n+        return CXType_FirstBuiltin;\n@@ -3649,0 +4959,2 @@\n+    private static final int CXType_LastBuiltin = (int)39L;\n+\n@@ -3650,1 +4962,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3655,1 +4967,1 @@\n-        return (int)39L;\n+        return CXType_LastBuiltin;\n@@ -3657,0 +4969,2 @@\n+    private static final int CXType_Complex = (int)100L;\n+\n@@ -3658,1 +4972,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3663,1 +4977,1 @@\n-        return (int)100L;\n+        return CXType_Complex;\n@@ -3665,0 +4979,2 @@\n+    private static final int CXType_Pointer = (int)101L;\n+\n@@ -3666,1 +4982,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3671,1 +4987,1 @@\n-        return (int)101L;\n+        return CXType_Pointer;\n@@ -3673,0 +4989,2 @@\n+    private static final int CXType_BlockPointer = (int)102L;\n+\n@@ -3674,1 +4992,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3679,1 +4997,1 @@\n-        return (int)102L;\n+        return CXType_BlockPointer;\n@@ -3681,0 +4999,2 @@\n+    private static final int CXType_LValueReference = (int)103L;\n+\n@@ -3682,1 +5002,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3687,1 +5007,1 @@\n-        return (int)103L;\n+        return CXType_LValueReference;\n@@ -3689,0 +5009,2 @@\n+    private static final int CXType_RValueReference = (int)104L;\n+\n@@ -3690,1 +5012,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3695,1 +5017,1 @@\n-        return (int)104L;\n+        return CXType_RValueReference;\n@@ -3697,0 +5019,2 @@\n+    private static final int CXType_Record = (int)105L;\n+\n@@ -3698,1 +5022,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3703,1 +5027,1 @@\n-        return (int)105L;\n+        return CXType_Record;\n@@ -3705,0 +5029,2 @@\n+    private static final int CXType_Enum = (int)106L;\n+\n@@ -3706,1 +5032,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3711,1 +5037,1 @@\n-        return (int)106L;\n+        return CXType_Enum;\n@@ -3713,0 +5039,2 @@\n+    private static final int CXType_Typedef = (int)107L;\n+\n@@ -3714,1 +5042,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3719,1 +5047,1 @@\n-        return (int)107L;\n+        return CXType_Typedef;\n@@ -3721,0 +5049,2 @@\n+    private static final int CXType_ObjCInterface = (int)108L;\n+\n@@ -3722,1 +5052,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3727,1 +5057,1 @@\n-        return (int)108L;\n+        return CXType_ObjCInterface;\n@@ -3729,0 +5059,2 @@\n+    private static final int CXType_ObjCObjectPointer = (int)109L;\n+\n@@ -3730,1 +5062,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3735,1 +5067,1 @@\n-        return (int)109L;\n+        return CXType_ObjCObjectPointer;\n@@ -3737,0 +5069,2 @@\n+    private static final int CXType_FunctionNoProto = (int)110L;\n+\n@@ -3738,1 +5072,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3743,1 +5077,1 @@\n-        return (int)110L;\n+        return CXType_FunctionNoProto;\n@@ -3745,0 +5079,2 @@\n+    private static final int CXType_FunctionProto = (int)111L;\n+\n@@ -3746,1 +5082,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3751,1 +5087,1 @@\n-        return (int)111L;\n+        return CXType_FunctionProto;\n@@ -3753,0 +5089,2 @@\n+    private static final int CXType_ConstantArray = (int)112L;\n+\n@@ -3754,1 +5092,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3759,1 +5097,1 @@\n-        return (int)112L;\n+        return CXType_ConstantArray;\n@@ -3761,0 +5099,2 @@\n+    private static final int CXType_Vector = (int)113L;\n+\n@@ -3762,1 +5102,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3767,1 +5107,1 @@\n-        return (int)113L;\n+        return CXType_Vector;\n@@ -3769,0 +5109,2 @@\n+    private static final int CXType_IncompleteArray = (int)114L;\n+\n@@ -3770,1 +5112,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3775,1 +5117,1 @@\n-        return (int)114L;\n+        return CXType_IncompleteArray;\n@@ -3777,0 +5119,2 @@\n+    private static final int CXType_VariableArray = (int)115L;\n+\n@@ -3778,1 +5122,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3783,1 +5127,1 @@\n-        return (int)115L;\n+        return CXType_VariableArray;\n@@ -3785,0 +5129,2 @@\n+    private static final int CXType_DependentSizedArray = (int)116L;\n+\n@@ -3786,1 +5132,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3791,1 +5137,1 @@\n-        return (int)116L;\n+        return CXType_DependentSizedArray;\n@@ -3793,0 +5139,2 @@\n+    private static final int CXType_MemberPointer = (int)117L;\n+\n@@ -3794,1 +5142,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3799,1 +5147,1 @@\n-        return (int)117L;\n+        return CXType_MemberPointer;\n@@ -3801,0 +5149,2 @@\n+    private static final int CXType_Auto = (int)118L;\n+\n@@ -3802,1 +5152,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3807,1 +5157,1 @@\n-        return (int)118L;\n+        return CXType_Auto;\n@@ -3809,0 +5159,2 @@\n+    private static final int CXType_Elaborated = (int)119L;\n+\n@@ -3810,1 +5162,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3815,1 +5167,1 @@\n-        return (int)119L;\n+        return CXType_Elaborated;\n@@ -3817,0 +5169,2 @@\n+    private static final int CXType_Pipe = (int)120L;\n+\n@@ -3818,1 +5172,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3823,1 +5177,1 @@\n-        return (int)120L;\n+        return CXType_Pipe;\n@@ -3825,0 +5179,2 @@\n+    private static final int CXType_OCLImage1dRO = (int)121L;\n+\n@@ -3826,1 +5182,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3831,1 +5187,1 @@\n-        return (int)121L;\n+        return CXType_OCLImage1dRO;\n@@ -3833,0 +5189,2 @@\n+    private static final int CXType_OCLImage1dArrayRO = (int)122L;\n+\n@@ -3834,1 +5192,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3839,1 +5197,1 @@\n-        return (int)122L;\n+        return CXType_OCLImage1dArrayRO;\n@@ -3841,0 +5199,2 @@\n+    private static final int CXType_OCLImage1dBufferRO = (int)123L;\n+\n@@ -3842,1 +5202,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3847,1 +5207,1 @@\n-        return (int)123L;\n+        return CXType_OCLImage1dBufferRO;\n@@ -3849,0 +5209,2 @@\n+    private static final int CXType_OCLImage2dRO = (int)124L;\n+\n@@ -3850,1 +5212,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3855,1 +5217,1 @@\n-        return (int)124L;\n+        return CXType_OCLImage2dRO;\n@@ -3857,0 +5219,2 @@\n+    private static final int CXType_OCLImage2dArrayRO = (int)125L;\n+\n@@ -3858,1 +5222,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3863,1 +5227,1 @@\n-        return (int)125L;\n+        return CXType_OCLImage2dArrayRO;\n@@ -3865,0 +5229,2 @@\n+    private static final int CXType_OCLImage2dDepthRO = (int)126L;\n+\n@@ -3866,1 +5232,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3871,1 +5237,1 @@\n-        return (int)126L;\n+        return CXType_OCLImage2dDepthRO;\n@@ -3873,0 +5239,2 @@\n+    private static final int CXType_OCLImage2dArrayDepthRO = (int)127L;\n+\n@@ -3874,1 +5242,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3879,1 +5247,1 @@\n-        return (int)127L;\n+        return CXType_OCLImage2dArrayDepthRO;\n@@ -3881,0 +5249,2 @@\n+    private static final int CXType_OCLImage2dMSAARO = (int)128L;\n+\n@@ -3882,1 +5252,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3887,1 +5257,1 @@\n-        return (int)128L;\n+        return CXType_OCLImage2dMSAARO;\n@@ -3889,0 +5259,2 @@\n+    private static final int CXType_OCLImage2dArrayMSAARO = (int)129L;\n+\n@@ -3890,1 +5262,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3895,1 +5267,1 @@\n-        return (int)129L;\n+        return CXType_OCLImage2dArrayMSAARO;\n@@ -3897,0 +5269,2 @@\n+    private static final int CXType_OCLImage2dMSAADepthRO = (int)130L;\n+\n@@ -3898,1 +5272,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3903,1 +5277,1 @@\n-        return (int)130L;\n+        return CXType_OCLImage2dMSAADepthRO;\n@@ -3905,0 +5279,2 @@\n+    private static final int CXType_OCLImage2dArrayMSAADepthRO = (int)131L;\n+\n@@ -3906,1 +5282,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3911,1 +5287,1 @@\n-        return (int)131L;\n+        return CXType_OCLImage2dArrayMSAADepthRO;\n@@ -3913,0 +5289,2 @@\n+    private static final int CXType_OCLImage3dRO = (int)132L;\n+\n@@ -3914,1 +5292,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3919,1 +5297,1 @@\n-        return (int)132L;\n+        return CXType_OCLImage3dRO;\n@@ -3921,0 +5299,2 @@\n+    private static final int CXType_OCLImage1dWO = (int)133L;\n+\n@@ -3922,1 +5302,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3927,1 +5307,1 @@\n-        return (int)133L;\n+        return CXType_OCLImage1dWO;\n@@ -3929,0 +5309,2 @@\n+    private static final int CXType_OCLImage1dArrayWO = (int)134L;\n+\n@@ -3930,1 +5312,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3935,1 +5317,1 @@\n-        return (int)134L;\n+        return CXType_OCLImage1dArrayWO;\n@@ -3937,0 +5319,2 @@\n+    private static final int CXType_OCLImage1dBufferWO = (int)135L;\n+\n@@ -3938,1 +5322,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3943,1 +5327,1 @@\n-        return (int)135L;\n+        return CXType_OCLImage1dBufferWO;\n@@ -3945,0 +5329,2 @@\n+    private static final int CXType_OCLImage2dWO = (int)136L;\n+\n@@ -3946,1 +5332,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3951,1 +5337,1 @@\n-        return (int)136L;\n+        return CXType_OCLImage2dWO;\n@@ -3953,0 +5339,2 @@\n+    private static final int CXType_OCLImage2dArrayWO = (int)137L;\n+\n@@ -3954,1 +5342,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3959,1 +5347,1 @@\n-        return (int)137L;\n+        return CXType_OCLImage2dArrayWO;\n@@ -3961,0 +5349,2 @@\n+    private static final int CXType_OCLImage2dDepthWO = (int)138L;\n+\n@@ -3962,1 +5352,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3967,1 +5357,1 @@\n-        return (int)138L;\n+        return CXType_OCLImage2dDepthWO;\n@@ -3969,0 +5359,2 @@\n+    private static final int CXType_OCLImage2dArrayDepthWO = (int)139L;\n+\n@@ -3970,1 +5362,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3975,1 +5367,1 @@\n-        return (int)139L;\n+        return CXType_OCLImage2dArrayDepthWO;\n@@ -3977,0 +5369,2 @@\n+    private static final int CXType_OCLImage2dMSAAWO = (int)140L;\n+\n@@ -3978,1 +5372,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3983,1 +5377,1 @@\n-        return (int)140L;\n+        return CXType_OCLImage2dMSAAWO;\n@@ -3985,0 +5379,2 @@\n+    private static final int CXType_OCLImage2dArrayMSAAWO = (int)141L;\n+\n@@ -3986,1 +5382,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3991,1 +5387,1 @@\n-        return (int)141L;\n+        return CXType_OCLImage2dArrayMSAAWO;\n@@ -3993,0 +5389,2 @@\n+    private static final int CXType_OCLImage2dMSAADepthWO = (int)142L;\n+\n@@ -3994,1 +5392,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -3999,1 +5397,1 @@\n-        return (int)142L;\n+        return CXType_OCLImage2dMSAADepthWO;\n@@ -4001,0 +5399,2 @@\n+    private static final int CXType_OCLImage2dArrayMSAADepthWO = (int)143L;\n+\n@@ -4002,1 +5402,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4007,1 +5407,1 @@\n-        return (int)143L;\n+        return CXType_OCLImage2dArrayMSAADepthWO;\n@@ -4009,0 +5409,2 @@\n+    private static final int CXType_OCLImage3dWO = (int)144L;\n+\n@@ -4010,1 +5412,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4015,1 +5417,1 @@\n-        return (int)144L;\n+        return CXType_OCLImage3dWO;\n@@ -4017,0 +5419,2 @@\n+    private static final int CXType_OCLImage1dRW = (int)145L;\n+\n@@ -4018,1 +5422,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4023,1 +5427,1 @@\n-        return (int)145L;\n+        return CXType_OCLImage1dRW;\n@@ -4025,0 +5429,2 @@\n+    private static final int CXType_OCLImage1dArrayRW = (int)146L;\n+\n@@ -4026,1 +5432,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4031,1 +5437,1 @@\n-        return (int)146L;\n+        return CXType_OCLImage1dArrayRW;\n@@ -4033,0 +5439,2 @@\n+    private static final int CXType_OCLImage1dBufferRW = (int)147L;\n+\n@@ -4034,1 +5442,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4039,1 +5447,1 @@\n-        return (int)147L;\n+        return CXType_OCLImage1dBufferRW;\n@@ -4041,0 +5449,2 @@\n+    private static final int CXType_OCLImage2dRW = (int)148L;\n+\n@@ -4042,1 +5452,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4047,1 +5457,1 @@\n-        return (int)148L;\n+        return CXType_OCLImage2dRW;\n@@ -4049,0 +5459,2 @@\n+    private static final int CXType_OCLImage2dArrayRW = (int)149L;\n+\n@@ -4050,1 +5462,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4055,1 +5467,1 @@\n-        return (int)149L;\n+        return CXType_OCLImage2dArrayRW;\n@@ -4057,0 +5469,2 @@\n+    private static final int CXType_OCLImage2dDepthRW = (int)150L;\n+\n@@ -4058,1 +5472,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4063,1 +5477,1 @@\n-        return (int)150L;\n+        return CXType_OCLImage2dDepthRW;\n@@ -4065,0 +5479,2 @@\n+    private static final int CXType_OCLImage2dArrayDepthRW = (int)151L;\n+\n@@ -4066,1 +5482,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4071,1 +5487,1 @@\n-        return (int)151L;\n+        return CXType_OCLImage2dArrayDepthRW;\n@@ -4073,0 +5489,2 @@\n+    private static final int CXType_OCLImage2dMSAARW = (int)152L;\n+\n@@ -4074,1 +5492,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4079,1 +5497,1 @@\n-        return (int)152L;\n+        return CXType_OCLImage2dMSAARW;\n@@ -4081,0 +5499,2 @@\n+    private static final int CXType_OCLImage2dArrayMSAARW = (int)153L;\n+\n@@ -4082,1 +5502,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4087,1 +5507,1 @@\n-        return (int)153L;\n+        return CXType_OCLImage2dArrayMSAARW;\n@@ -4089,0 +5509,2 @@\n+    private static final int CXType_OCLImage2dMSAADepthRW = (int)154L;\n+\n@@ -4090,1 +5512,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4095,1 +5517,1 @@\n-        return (int)154L;\n+        return CXType_OCLImage2dMSAADepthRW;\n@@ -4097,0 +5519,2 @@\n+    private static final int CXType_OCLImage2dArrayMSAADepthRW = (int)155L;\n+\n@@ -4098,1 +5522,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4103,1 +5527,1 @@\n-        return (int)155L;\n+        return CXType_OCLImage2dArrayMSAADepthRW;\n@@ -4105,0 +5529,2 @@\n+    private static final int CXType_OCLImage3dRW = (int)156L;\n+\n@@ -4106,1 +5532,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4111,1 +5537,1 @@\n-        return (int)156L;\n+        return CXType_OCLImage3dRW;\n@@ -4113,0 +5539,2 @@\n+    private static final int CXType_OCLSampler = (int)157L;\n+\n@@ -4114,1 +5542,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4119,1 +5547,1 @@\n-        return (int)157L;\n+        return CXType_OCLSampler;\n@@ -4121,0 +5549,2 @@\n+    private static final int CXType_OCLEvent = (int)158L;\n+\n@@ -4122,1 +5552,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4127,1 +5557,1 @@\n-        return (int)158L;\n+        return CXType_OCLEvent;\n@@ -4129,0 +5559,2 @@\n+    private static final int CXType_OCLQueue = (int)159L;\n+\n@@ -4130,1 +5562,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4135,1 +5567,1 @@\n-        return (int)159L;\n+        return CXType_OCLQueue;\n@@ -4137,0 +5569,2 @@\n+    private static final int CXType_OCLReserveID = (int)160L;\n+\n@@ -4138,1 +5572,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4143,1 +5577,1 @@\n-        return (int)160L;\n+        return CXType_OCLReserveID;\n@@ -4145,0 +5579,2 @@\n+    private static final int CXType_ObjCObject = (int)161L;\n+\n@@ -4146,1 +5582,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4151,1 +5587,1 @@\n-        return (int)161L;\n+        return CXType_ObjCObject;\n@@ -4153,0 +5589,2 @@\n+    private static final int CXType_ObjCTypeParam = (int)162L;\n+\n@@ -4154,1 +5592,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4159,1 +5597,1 @@\n-        return (int)162L;\n+        return CXType_ObjCTypeParam;\n@@ -4161,0 +5599,2 @@\n+    private static final int CXType_Attributed = (int)163L;\n+\n@@ -4162,1 +5602,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4167,1 +5607,1 @@\n-        return (int)163L;\n+        return CXType_Attributed;\n@@ -4169,0 +5609,2 @@\n+    private static final int CXType_OCLIntelSubgroupAVCMcePayload = (int)164L;\n+\n@@ -4170,1 +5612,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4175,1 +5617,1 @@\n-        return (int)164L;\n+        return CXType_OCLIntelSubgroupAVCMcePayload;\n@@ -4177,0 +5619,2 @@\n+    private static final int CXType_OCLIntelSubgroupAVCImePayload = (int)165L;\n+\n@@ -4178,1 +5622,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4183,1 +5627,1 @@\n-        return (int)165L;\n+        return CXType_OCLIntelSubgroupAVCImePayload;\n@@ -4185,0 +5629,2 @@\n+    private static final int CXType_OCLIntelSubgroupAVCRefPayload = (int)166L;\n+\n@@ -4186,1 +5632,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4191,1 +5637,1 @@\n-        return (int)166L;\n+        return CXType_OCLIntelSubgroupAVCRefPayload;\n@@ -4193,0 +5639,2 @@\n+    private static final int CXType_OCLIntelSubgroupAVCSicPayload = (int)167L;\n+\n@@ -4194,1 +5642,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4199,1 +5647,1 @@\n-        return (int)167L;\n+        return CXType_OCLIntelSubgroupAVCSicPayload;\n@@ -4201,0 +5649,2 @@\n+    private static final int CXType_OCLIntelSubgroupAVCMceResult = (int)168L;\n+\n@@ -4202,1 +5652,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4207,1 +5657,1 @@\n-        return (int)168L;\n+        return CXType_OCLIntelSubgroupAVCMceResult;\n@@ -4209,0 +5659,2 @@\n+    private static final int CXType_OCLIntelSubgroupAVCImeResult = (int)169L;\n+\n@@ -4210,1 +5662,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4215,1 +5667,1 @@\n-        return (int)169L;\n+        return CXType_OCLIntelSubgroupAVCImeResult;\n@@ -4217,0 +5669,2 @@\n+    private static final int CXType_OCLIntelSubgroupAVCRefResult = (int)170L;\n+\n@@ -4218,1 +5672,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4223,1 +5677,1 @@\n-        return (int)170L;\n+        return CXType_OCLIntelSubgroupAVCRefResult;\n@@ -4225,0 +5679,2 @@\n+    private static final int CXType_OCLIntelSubgroupAVCSicResult = (int)171L;\n+\n@@ -4226,1 +5682,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4231,1 +5687,1 @@\n-        return (int)171L;\n+        return CXType_OCLIntelSubgroupAVCSicResult;\n@@ -4233,0 +5689,2 @@\n+    private static final int CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout = (int)172L;\n+\n@@ -4234,1 +5692,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4239,1 +5697,1 @@\n-        return (int)172L;\n+        return CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout;\n@@ -4241,0 +5699,2 @@\n+    private static final int CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout = (int)173L;\n+\n@@ -4242,1 +5702,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4247,1 +5707,1 @@\n-        return (int)173L;\n+        return CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout;\n@@ -4249,0 +5709,2 @@\n+    private static final int CXType_OCLIntelSubgroupAVCImeSingleRefStreamin = (int)174L;\n+\n@@ -4250,1 +5712,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4255,1 +5717,1 @@\n-        return (int)174L;\n+        return CXType_OCLIntelSubgroupAVCImeSingleRefStreamin;\n@@ -4257,0 +5719,2 @@\n+    private static final int CXType_OCLIntelSubgroupAVCImeDualRefStreamin = (int)175L;\n+\n@@ -4258,1 +5722,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4263,1 +5727,1 @@\n-        return (int)175L;\n+        return CXType_OCLIntelSubgroupAVCImeDualRefStreamin;\n@@ -4265,0 +5729,2 @@\n+    private static final int CXType_ExtVector = (int)176L;\n+\n@@ -4266,1 +5732,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4271,1 +5737,1 @@\n-        return (int)176L;\n+        return CXType_ExtVector;\n@@ -4273,0 +5739,2 @@\n+    private static final int CXCallingConv_Default = (int)0L;\n+\n@@ -4274,1 +5742,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4279,1 +5747,1 @@\n-        return (int)0L;\n+        return CXCallingConv_Default;\n@@ -4281,0 +5749,2 @@\n+    private static final int CXCallingConv_C = (int)1L;\n+\n@@ -4282,1 +5752,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4287,1 +5757,1 @@\n-        return (int)1L;\n+        return CXCallingConv_C;\n@@ -4289,0 +5759,2 @@\n+    private static final int CXCallingConv_X86StdCall = (int)2L;\n+\n@@ -4290,1 +5762,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4295,1 +5767,1 @@\n-        return (int)2L;\n+        return CXCallingConv_X86StdCall;\n@@ -4297,0 +5769,2 @@\n+    private static final int CXCallingConv_X86FastCall = (int)3L;\n+\n@@ -4298,1 +5772,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4303,1 +5777,1 @@\n-        return (int)3L;\n+        return CXCallingConv_X86FastCall;\n@@ -4305,0 +5779,2 @@\n+    private static final int CXCallingConv_X86ThisCall = (int)4L;\n+\n@@ -4306,1 +5782,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4311,1 +5787,1 @@\n-        return (int)4L;\n+        return CXCallingConv_X86ThisCall;\n@@ -4313,0 +5789,2 @@\n+    private static final int CXCallingConv_X86Pascal = (int)5L;\n+\n@@ -4314,1 +5792,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4319,1 +5797,1 @@\n-        return (int)5L;\n+        return CXCallingConv_X86Pascal;\n@@ -4321,0 +5799,2 @@\n+    private static final int CXCallingConv_AAPCS = (int)6L;\n+\n@@ -4322,1 +5802,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4327,1 +5807,1 @@\n-        return (int)6L;\n+        return CXCallingConv_AAPCS;\n@@ -4329,0 +5809,2 @@\n+    private static final int CXCallingConv_AAPCS_VFP = (int)7L;\n+\n@@ -4330,1 +5812,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4335,1 +5817,1 @@\n-        return (int)7L;\n+        return CXCallingConv_AAPCS_VFP;\n@@ -4337,0 +5819,2 @@\n+    private static final int CXCallingConv_X86RegCall = (int)8L;\n+\n@@ -4338,1 +5822,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4343,1 +5827,1 @@\n-        return (int)8L;\n+        return CXCallingConv_X86RegCall;\n@@ -4345,0 +5829,2 @@\n+    private static final int CXCallingConv_IntelOclBicc = (int)9L;\n+\n@@ -4346,1 +5832,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4351,1 +5837,1 @@\n-        return (int)9L;\n+        return CXCallingConv_IntelOclBicc;\n@@ -4353,0 +5839,2 @@\n+    private static final int CXCallingConv_Win64 = (int)10L;\n+\n@@ -4354,1 +5842,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4359,1 +5847,1 @@\n-        return (int)10L;\n+        return CXCallingConv_Win64;\n@@ -4361,0 +5849,2 @@\n+    private static final int CXCallingConv_X86_64Win64 = (int)10L;\n+\n@@ -4362,1 +5852,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4367,1 +5857,1 @@\n-        return (int)10L;\n+        return CXCallingConv_X86_64Win64;\n@@ -4369,0 +5859,2 @@\n+    private static final int CXCallingConv_X86_64SysV = (int)11L;\n+\n@@ -4370,1 +5862,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4375,1 +5867,1 @@\n-        return (int)11L;\n+        return CXCallingConv_X86_64SysV;\n@@ -4377,0 +5869,2 @@\n+    private static final int CXCallingConv_X86VectorCall = (int)12L;\n+\n@@ -4378,1 +5872,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4383,1 +5877,1 @@\n-        return (int)12L;\n+        return CXCallingConv_X86VectorCall;\n@@ -4385,0 +5879,2 @@\n+    private static final int CXCallingConv_Swift = (int)13L;\n+\n@@ -4386,1 +5882,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4391,1 +5887,1 @@\n-        return (int)13L;\n+        return CXCallingConv_Swift;\n@@ -4393,0 +5889,2 @@\n+    private static final int CXCallingConv_PreserveMost = (int)14L;\n+\n@@ -4394,1 +5892,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4399,1 +5897,1 @@\n-        return (int)14L;\n+        return CXCallingConv_PreserveMost;\n@@ -4401,0 +5899,2 @@\n+    private static final int CXCallingConv_PreserveAll = (int)15L;\n+\n@@ -4402,1 +5902,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4407,1 +5907,1 @@\n-        return (int)15L;\n+        return CXCallingConv_PreserveAll;\n@@ -4409,0 +5909,2 @@\n+    private static final int CXCallingConv_AArch64VectorCall = (int)16L;\n+\n@@ -4410,1 +5912,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4415,1 +5917,1 @@\n-        return (int)16L;\n+        return CXCallingConv_AArch64VectorCall;\n@@ -4417,0 +5919,2 @@\n+    private static final int CXCallingConv_Invalid = (int)100L;\n+\n@@ -4418,1 +5922,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4423,1 +5927,1 @@\n-        return (int)100L;\n+        return CXCallingConv_Invalid;\n@@ -4425,0 +5929,2 @@\n+    private static final int CXCallingConv_Unexposed = (int)200L;\n+\n@@ -4426,1 +5932,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4431,4 +5937,1 @@\n-        return (int)200L;\n-    }\n-    public static MethodHandle clang_getCursorType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$7.clang_getCursorType$MH,\"clang_getCursorType\");\n+        return CXCallingConv_Unexposed;\n@@ -4437,1 +5940,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4441,0 +5944,14 @@\n+    public static MethodHandle clang_getCursorType$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXType.$LAYOUT(),\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorType\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4444,1 +5961,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, C);\n+            return (MemorySegment) mh$.invokeExact(allocator, C);\n@@ -4446,1 +5963,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4449,3 +5966,0 @@\n-    public static MethodHandle clang_getTypeSpelling$MH() {\n-        return RuntimeHelper.requireNonNull(constants$7.clang_getTypeSpelling$MH,\"clang_getTypeSpelling\");\n-    }\n@@ -4453,1 +5967,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4457,0 +5971,14 @@\n+    public static MethodHandle clang_getTypeSpelling$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXString.$LAYOUT(),\n+                CXType.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getTypeSpelling\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4460,1 +5988,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, CT);\n+            return (MemorySegment) mh$.invokeExact(allocator, CT);\n@@ -4462,1 +5990,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4465,3 +5993,0 @@\n-    public static MethodHandle clang_getTypedefDeclUnderlyingType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$8.clang_getTypedefDeclUnderlyingType$MH,\"clang_getTypedefDeclUnderlyingType\");\n-    }\n@@ -4469,1 +5994,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4473,0 +5998,14 @@\n+    public static MethodHandle clang_getTypedefDeclUnderlyingType$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXType.$LAYOUT(),\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getTypedefDeclUnderlyingType\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4476,1 +6015,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, C);\n+            return (MemorySegment) mh$.invokeExact(allocator, C);\n@@ -4478,1 +6017,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4481,3 +6020,0 @@\n-    public static MethodHandle clang_getEnumDeclIntegerType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$8.clang_getEnumDeclIntegerType$MH,\"clang_getEnumDeclIntegerType\");\n-    }\n@@ -4485,1 +6021,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4489,0 +6025,14 @@\n+    public static MethodHandle clang_getEnumDeclIntegerType$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXType.$LAYOUT(),\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getEnumDeclIntegerType\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4492,1 +6042,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, C);\n+            return (MemorySegment) mh$.invokeExact(allocator, C);\n@@ -4494,1 +6044,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4497,3 +6047,0 @@\n-    public static MethodHandle clang_getEnumConstantDeclValue$MH() {\n-        return RuntimeHelper.requireNonNull(constants$8.clang_getEnumConstantDeclValue$MH,\"clang_getEnumConstantDeclValue\");\n-    }\n@@ -4501,1 +6048,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4505,0 +6052,14 @@\n+    public static MethodHandle clang_getEnumConstantDeclValue$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_LONG_LONG,\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getEnumConstantDeclValue\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4508,1 +6069,1 @@\n-            return (long)mh$.invokeExact(C);\n+            return (long) mh$.invokeExact(C);\n@@ -4510,1 +6071,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4513,3 +6074,0 @@\n-    public static MethodHandle clang_getEnumConstantDeclUnsignedValue$MH() {\n-        return RuntimeHelper.requireNonNull(constants$8.clang_getEnumConstantDeclUnsignedValue$MH,\"clang_getEnumConstantDeclUnsignedValue\");\n-    }\n@@ -4517,1 +6075,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4521,0 +6079,14 @@\n+    public static MethodHandle clang_getEnumConstantDeclUnsignedValue$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_LONG_LONG,\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getEnumConstantDeclUnsignedValue\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4524,1 +6096,1 @@\n-            return (long)mh$.invokeExact(C);\n+            return (long) mh$.invokeExact(C);\n@@ -4526,1 +6098,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4529,3 +6101,0 @@\n-    public static MethodHandle clang_getFieldDeclBitWidth$MH() {\n-        return RuntimeHelper.requireNonNull(constants$8.clang_getFieldDeclBitWidth$MH,\"clang_getFieldDeclBitWidth\");\n-    }\n@@ -4533,1 +6102,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4537,0 +6106,14 @@\n+    public static MethodHandle clang_getFieldDeclBitWidth$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getFieldDeclBitWidth\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4540,1 +6123,1 @@\n-            return (int)mh$.invokeExact(C);\n+            return (int) mh$.invokeExact(C);\n@@ -4542,1 +6125,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4545,3 +6128,0 @@\n-    public static MethodHandle clang_Cursor_getNumArguments$MH() {\n-        return RuntimeHelper.requireNonNull(constants$8.clang_Cursor_getNumArguments$MH,\"clang_Cursor_getNumArguments\");\n-    }\n@@ -4549,1 +6129,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4553,0 +6133,14 @@\n+    public static MethodHandle clang_Cursor_getNumArguments$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_getNumArguments\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4556,1 +6150,1 @@\n-            return (int)mh$.invokeExact(C);\n+            return (int) mh$.invokeExact(C);\n@@ -4558,1 +6152,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4561,3 +6155,0 @@\n-    public static MethodHandle clang_Cursor_getArgument$MH() {\n-        return RuntimeHelper.requireNonNull(constants$9.clang_Cursor_getArgument$MH,\"clang_Cursor_getArgument\");\n-    }\n@@ -4565,1 +6156,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4569,0 +6160,15 @@\n+    public static MethodHandle clang_Cursor_getArgument$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXCursor.$LAYOUT(),\n+                CXCursor.$LAYOUT(),\n+                Index_h.C_INT\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_getArgument\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4572,1 +6178,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, C, i);\n+            return (MemorySegment) mh$.invokeExact(allocator, C, i);\n@@ -4574,1 +6180,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4577,3 +6183,0 @@\n-    public static MethodHandle clang_equalTypes$MH() {\n-        return RuntimeHelper.requireNonNull(constants$9.clang_equalTypes$MH,\"clang_equalTypes\");\n-    }\n@@ -4581,1 +6184,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4585,0 +6188,15 @@\n+    public static MethodHandle clang_equalTypes$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXType.$LAYOUT(),\n+                CXType.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_equalTypes\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4588,1 +6206,1 @@\n-            return (int)mh$.invokeExact(A, B);\n+            return (int) mh$.invokeExact(A, B);\n@@ -4590,1 +6208,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4593,3 +6211,0 @@\n-    public static MethodHandle clang_getCanonicalType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$9.clang_getCanonicalType$MH,\"clang_getCanonicalType\");\n-    }\n@@ -4597,1 +6212,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4601,0 +6216,14 @@\n+    public static MethodHandle clang_getCanonicalType$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXType.$LAYOUT(),\n+                CXType.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCanonicalType\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4604,1 +6233,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n+            return (MemorySegment) mh$.invokeExact(allocator, T);\n@@ -4606,1 +6235,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4609,3 +6238,0 @@\n-    public static MethodHandle clang_isConstQualifiedType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$9.clang_isConstQualifiedType$MH,\"clang_isConstQualifiedType\");\n-    }\n@@ -4613,1 +6239,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4617,0 +6243,14 @@\n+    public static MethodHandle clang_isConstQualifiedType$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXType.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_isConstQualifiedType\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4620,1 +6260,1 @@\n-            return (int)mh$.invokeExact(T);\n+            return (int) mh$.invokeExact(T);\n@@ -4622,1 +6262,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4625,3 +6265,0 @@\n-    public static MethodHandle clang_Cursor_isMacroFunctionLike$MH() {\n-        return RuntimeHelper.requireNonNull(constants$9.clang_Cursor_isMacroFunctionLike$MH,\"clang_Cursor_isMacroFunctionLike\");\n-    }\n@@ -4629,1 +6266,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4633,0 +6270,14 @@\n+    public static MethodHandle clang_Cursor_isMacroFunctionLike$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_isMacroFunctionLike\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4636,1 +6287,1 @@\n-            return (int)mh$.invokeExact(C);\n+            return (int) mh$.invokeExact(C);\n@@ -4638,1 +6289,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4641,3 +6292,0 @@\n-    public static MethodHandle clang_Cursor_isFunctionInlined$MH() {\n-        return RuntimeHelper.requireNonNull(constants$9.clang_Cursor_isFunctionInlined$MH,\"clang_Cursor_isFunctionInlined\");\n-    }\n@@ -4645,1 +6293,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4649,0 +6297,14 @@\n+    public static MethodHandle clang_Cursor_isFunctionInlined$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_isFunctionInlined\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4652,1 +6314,1 @@\n-            return (int)mh$.invokeExact(C);\n+            return (int) mh$.invokeExact(C);\n@@ -4654,1 +6316,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4657,3 +6319,0 @@\n-    public static MethodHandle clang_isVolatileQualifiedType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$10.clang_isVolatileQualifiedType$MH,\"clang_isVolatileQualifiedType\");\n-    }\n@@ -4661,1 +6320,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4665,0 +6324,14 @@\n+    public static MethodHandle clang_isVolatileQualifiedType$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXType.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_isVolatileQualifiedType\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4668,1 +6341,1 @@\n-            return (int)mh$.invokeExact(T);\n+            return (int) mh$.invokeExact(T);\n@@ -4670,1 +6343,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4673,3 +6346,0 @@\n-    public static MethodHandle clang_getTypedefName$MH() {\n-        return RuntimeHelper.requireNonNull(constants$10.clang_getTypedefName$MH,\"clang_getTypedefName\");\n-    }\n@@ -4677,1 +6347,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4681,0 +6351,14 @@\n+    public static MethodHandle clang_getTypedefName$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXString.$LAYOUT(),\n+                CXType.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getTypedefName\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4684,1 +6368,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, CT);\n+            return (MemorySegment) mh$.invokeExact(allocator, CT);\n@@ -4686,1 +6370,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4689,3 +6373,0 @@\n-    public static MethodHandle clang_getPointeeType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$10.clang_getPointeeType$MH,\"clang_getPointeeType\");\n-    }\n@@ -4693,1 +6374,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4697,0 +6378,14 @@\n+    public static MethodHandle clang_getPointeeType$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXType.$LAYOUT(),\n+                CXType.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getPointeeType\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4700,1 +6395,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n+            return (MemorySegment) mh$.invokeExact(allocator, T);\n@@ -4702,1 +6397,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4705,3 +6400,0 @@\n-    public static MethodHandle clang_getTypeDeclaration$MH() {\n-        return RuntimeHelper.requireNonNull(constants$10.clang_getTypeDeclaration$MH,\"clang_getTypeDeclaration\");\n-    }\n@@ -4709,1 +6401,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4713,0 +6405,14 @@\n+    public static MethodHandle clang_getTypeDeclaration$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXCursor.$LAYOUT(),\n+                CXType.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getTypeDeclaration\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4716,1 +6422,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n+            return (MemorySegment) mh$.invokeExact(allocator, T);\n@@ -4718,1 +6424,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4721,3 +6427,0 @@\n-    public static MethodHandle clang_getTypeKindSpelling$MH() {\n-        return RuntimeHelper.requireNonNull(constants$10.clang_getTypeKindSpelling$MH,\"clang_getTypeKindSpelling\");\n-    }\n@@ -4725,1 +6428,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4729,0 +6432,14 @@\n+    public static MethodHandle clang_getTypeKindSpelling$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXString.$LAYOUT(),\n+                Index_h.C_INT\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getTypeKindSpelling\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4732,1 +6449,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, K);\n+            return (MemorySegment) mh$.invokeExact(allocator, K);\n@@ -4734,1 +6451,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4737,3 +6454,0 @@\n-    public static MethodHandle clang_getFunctionTypeCallingConv$MH() {\n-        return RuntimeHelper.requireNonNull(constants$10.clang_getFunctionTypeCallingConv$MH,\"clang_getFunctionTypeCallingConv\");\n-    }\n@@ -4741,1 +6455,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4745,0 +6459,14 @@\n+    public static MethodHandle clang_getFunctionTypeCallingConv$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXType.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getFunctionTypeCallingConv\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4748,1 +6476,1 @@\n-            return (int)mh$.invokeExact(T);\n+            return (int) mh$.invokeExact(T);\n@@ -4750,1 +6478,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4753,3 +6481,0 @@\n-    public static MethodHandle clang_getResultType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$11.clang_getResultType$MH,\"clang_getResultType\");\n-    }\n@@ -4757,1 +6482,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4761,0 +6486,14 @@\n+    public static MethodHandle clang_getResultType$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXType.$LAYOUT(),\n+                CXType.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getResultType\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4764,1 +6503,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n+            return (MemorySegment) mh$.invokeExact(allocator, T);\n@@ -4766,1 +6505,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4769,3 +6508,0 @@\n-    public static MethodHandle clang_getNumArgTypes$MH() {\n-        return RuntimeHelper.requireNonNull(constants$11.clang_getNumArgTypes$MH,\"clang_getNumArgTypes\");\n-    }\n@@ -4773,1 +6509,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4777,0 +6513,14 @@\n+    public static MethodHandle clang_getNumArgTypes$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXType.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getNumArgTypes\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4780,1 +6530,1 @@\n-            return (int)mh$.invokeExact(T);\n+            return (int) mh$.invokeExact(T);\n@@ -4782,1 +6532,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4785,3 +6535,0 @@\n-    public static MethodHandle clang_getArgType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$11.clang_getArgType$MH,\"clang_getArgType\");\n-    }\n@@ -4789,1 +6536,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4793,0 +6540,15 @@\n+    public static MethodHandle clang_getArgType$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXType.$LAYOUT(),\n+                CXType.$LAYOUT(),\n+                Index_h.C_INT\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getArgType\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4796,1 +6558,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, T, i);\n+            return (MemorySegment) mh$.invokeExact(allocator, T, i);\n@@ -4798,1 +6560,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4801,3 +6563,0 @@\n-    public static MethodHandle clang_isFunctionTypeVariadic$MH() {\n-        return RuntimeHelper.requireNonNull(constants$11.clang_isFunctionTypeVariadic$MH,\"clang_isFunctionTypeVariadic\");\n-    }\n@@ -4805,1 +6564,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4809,0 +6568,14 @@\n+    public static MethodHandle clang_isFunctionTypeVariadic$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXType.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_isFunctionTypeVariadic\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4812,1 +6585,1 @@\n-            return (int)mh$.invokeExact(T);\n+            return (int) mh$.invokeExact(T);\n@@ -4814,1 +6587,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4817,3 +6590,0 @@\n-    public static MethodHandle clang_getCursorResultType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$11.clang_getCursorResultType$MH,\"clang_getCursorResultType\");\n-    }\n@@ -4821,1 +6591,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4825,0 +6595,14 @@\n+    public static MethodHandle clang_getCursorResultType$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXType.$LAYOUT(),\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorResultType\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4828,1 +6612,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, C);\n+            return (MemorySegment) mh$.invokeExact(allocator, C);\n@@ -4830,1 +6614,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4833,4 +6617,0 @@\n-    public static MethodHandle clang_getElementType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$11.clang_getElementType$MH,\"clang_getElementType\");\n-    }\n-\n@@ -4838,1 +6618,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4842,8 +6622,6 @@\n-    public static MemorySegment clang_getElementType(SegmentAllocator allocator, MemorySegment T) {\n-        var mh$ = clang_getElementType$MH();\n-        try {\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n-        } catch (Throwable ex$) {\n-            throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n+    public static MethodHandle clang_getElementType$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXType.$LAYOUT(),\n+                CXType.$LAYOUT()\n+            );\n@@ -4851,2 +6629,5 @@\n-    public static MethodHandle clang_getValueType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$11.clang_getValueType$MH,\"clang_Type_getValueType\");\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getElementType\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n@@ -4855,7 +6636,2 @@\n-    \/**\n-     * {@snippet :\n-     * CXType clang_getValueType(CXType T);\n-     * }\n-     *\/\n-    public static MemorySegment clang_getValueType(SegmentAllocator allocator, MemorySegment T) {\n-        var mh$ = clang_getValueType$MH();\n+    public static MemorySegment clang_getElementType(SegmentAllocator allocator, MemorySegment T) {\n+        var mh$ = clang_getElementType$MH();\n@@ -4863,1 +6639,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n+            return (MemorySegment) mh$.invokeExact(allocator, T);\n@@ -4865,1 +6641,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4868,3 +6644,0 @@\n-    public static MethodHandle clang_getNumElements$MH() {\n-        return RuntimeHelper.requireNonNull(constants$12.clang_getNumElements$MH,\"clang_getNumElements\");\n-    }\n@@ -4872,1 +6645,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4876,0 +6649,14 @@\n+    public static MethodHandle clang_getNumElements$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_LONG_LONG,\n+                CXType.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getNumElements\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4879,1 +6666,1 @@\n-            return (long)mh$.invokeExact(T);\n+            return (long) mh$.invokeExact(T);\n@@ -4881,1 +6668,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4884,3 +6671,0 @@\n-    public static MethodHandle clang_getArrayElementType$MH() {\n-        return RuntimeHelper.requireNonNull(constants$12.clang_getArrayElementType$MH,\"clang_getArrayElementType\");\n-    }\n@@ -4888,1 +6672,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4892,0 +6676,14 @@\n+    public static MethodHandle clang_getArrayElementType$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXType.$LAYOUT(),\n+                CXType.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getArrayElementType\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4895,1 +6693,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n+            return (MemorySegment) mh$.invokeExact(allocator, T);\n@@ -4897,1 +6695,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4900,3 +6698,0 @@\n-    public static MethodHandle clang_getArraySize$MH() {\n-        return RuntimeHelper.requireNonNull(constants$12.clang_getArraySize$MH,\"clang_getArraySize\");\n-    }\n@@ -4904,1 +6699,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4908,0 +6703,14 @@\n+    public static MethodHandle clang_getArraySize$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_LONG_LONG,\n+                CXType.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getArraySize\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -4911,1 +6720,1 @@\n-            return (long)mh$.invokeExact(T);\n+            return (long) mh$.invokeExact(T);\n@@ -4913,1 +6722,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -4916,0 +6725,2 @@\n+    private static final int CXTypeNullability_NonNull = (int)0L;\n+\n@@ -4917,1 +6728,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4922,1 +6733,1 @@\n-        return (int)0L;\n+        return CXTypeNullability_NonNull;\n@@ -4924,0 +6735,2 @@\n+    private static final int CXTypeNullability_Nullable = (int)1L;\n+\n@@ -4925,1 +6738,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4930,1 +6743,1 @@\n-        return (int)1L;\n+        return CXTypeNullability_Nullable;\n@@ -4932,0 +6745,2 @@\n+    private static final int CXTypeNullability_Unspecified = (int)2L;\n+\n@@ -4933,1 +6748,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4938,1 +6753,1 @@\n-        return (int)2L;\n+        return CXTypeNullability_Unspecified;\n@@ -4940,0 +6755,2 @@\n+    private static final int CXTypeNullability_Invalid = (int)3L;\n+\n@@ -4941,1 +6758,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4946,1 +6763,1 @@\n-        return (int)3L;\n+        return CXTypeNullability_Invalid;\n@@ -4948,0 +6765,2 @@\n+    private static final int CXTypeLayoutError_Invalid = (int)-1L;\n+\n@@ -4949,1 +6768,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4954,1 +6773,1 @@\n-        return (int)-1L;\n+        return CXTypeLayoutError_Invalid;\n@@ -4956,0 +6775,2 @@\n+    private static final int CXTypeLayoutError_Incomplete = (int)-2L;\n+\n@@ -4957,1 +6778,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4962,1 +6783,1 @@\n-        return (int)-2L;\n+        return CXTypeLayoutError_Incomplete;\n@@ -4964,0 +6785,2 @@\n+    private static final int CXTypeLayoutError_Dependent = (int)-3L;\n+\n@@ -4965,1 +6788,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4970,1 +6793,1 @@\n-        return (int)-3L;\n+        return CXTypeLayoutError_Dependent;\n@@ -4972,0 +6795,2 @@\n+    private static final int CXTypeLayoutError_NotConstantSize = (int)-4L;\n+\n@@ -4973,1 +6798,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4978,1 +6803,1 @@\n-        return (int)-4L;\n+        return CXTypeLayoutError_NotConstantSize;\n@@ -4980,0 +6805,2 @@\n+    private static final int CXTypeLayoutError_InvalidFieldName = (int)-5L;\n+\n@@ -4981,1 +6808,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4986,1 +6813,1 @@\n-        return (int)-5L;\n+        return CXTypeLayoutError_InvalidFieldName;\n@@ -4988,0 +6815,2 @@\n+    private static final int CXTypeLayoutError_Undeduced = (int)-6L;\n+\n@@ -4989,1 +6818,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -4994,4 +6823,1 @@\n-        return (int)-6L;\n-    }\n-    public static MethodHandle clang_Type_getSizeOf$MH() {\n-        return RuntimeHelper.requireNonNull(constants$12.clang_Type_getSizeOf$MH,\"clang_Type_getSizeOf\");\n+        return CXTypeLayoutError_Undeduced;\n@@ -5000,2 +6826,2 @@\n-     * {@snippet :\n-     * long long clang_Type_getSizeOf(CXType T);\n+     * {@snippet lang=c :\n+     * long long clang_Type_getAlignOf(CXType T);\n@@ -5004,2 +6830,16 @@\n-    public static long clang_Type_getSizeOf(MemorySegment T) {\n-        var mh$ = clang_Type_getSizeOf$MH();\n+    public static MethodHandle clang_Type_getAlignOf$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_LONG_LONG,\n+                CXType.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Type_getAlignOf\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n+    public static long clang_Type_getAlignOf(MemorySegment T) {\n+        var mh$ = clang_Type_getAlignOf$MH();\n@@ -5007,1 +6847,1 @@\n-            return (long)mh$.invokeExact(T);\n+            return (long) mh$.invokeExact(T);\n@@ -5009,1 +6849,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5012,3 +6852,0 @@\n-    public static MethodHandle clang_Type_getAlignOf$MH() {\n-        return RuntimeHelper.requireNonNull(constants$12.clang_Type_getAlignOf$MH,\"clang_Type_getAlignOf\");\n-    }\n@@ -5016,2 +6853,2 @@\n-     * {@snippet :\n-     * long long clang_Type_getAlignOf(CXType T);\n+     * {@snippet lang=c :\n+     * long long clang_Type_getSizeOf(CXType T);\n@@ -5020,2 +6857,16 @@\n-    public static long clang_Type_getAlignOf(MemorySegment T) {\n-        var mh$ = clang_Type_getAlignOf$MH();\n+    public static MethodHandle clang_Type_getSizeOf$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_LONG_LONG,\n+                CXType.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Type_getSizeOf\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n+    public static long clang_Type_getSizeOf(MemorySegment T) {\n+        var mh$ = clang_Type_getSizeOf$MH();\n@@ -5023,1 +6874,1 @@\n-            return (long)mh$.invokeExact(T);\n+            return (long) mh$.invokeExact(T);\n@@ -5025,1 +6876,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5028,3 +6879,0 @@\n-    public static MethodHandle clang_Type_getOffsetOf$MH() {\n-        return RuntimeHelper.requireNonNull(constants$12.clang_Type_getOffsetOf$MH,\"clang_Type_getOffsetOf\");\n-    }\n@@ -5032,1 +6880,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5036,0 +6884,15 @@\n+    public static MethodHandle clang_Type_getOffsetOf$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_LONG_LONG,\n+                CXType.$LAYOUT(),\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Type_getOffsetOf\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5039,1 +6902,1 @@\n-            return (long)mh$.invokeExact(T, S);\n+            return (long) mh$.invokeExact(T, S);\n@@ -5041,1 +6904,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5044,2 +6907,26 @@\n-    public static MethodHandle clang_Cursor_isAnonymous$MH() {\n-        return RuntimeHelper.requireNonNull(constants$12.clang_Cursor_isAnonymous$MH,\"clang_Cursor_isAnonymous\");\n+    \/**\n+     * {@snippet lang=c :\n+     * CXType clang_Type_getValueType(CXType CT);\n+     * }\n+     *\/\n+    public static MethodHandle clang_Type_getValueType$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXType.$LAYOUT(),\n+                CXType.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Type_getValueType\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n+    public static MemorySegment clang_Type_getValueType(SegmentAllocator allocator, MemorySegment CT) {\n+        var mh$ = clang_Type_getValueType$MH();\n+        try {\n+            return (MemorySegment) mh$.invokeExact(allocator, CT);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n@@ -5048,1 +6935,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5052,0 +6939,14 @@\n+    public static MethodHandle clang_Cursor_isAnonymous$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_isAnonymous\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5055,1 +6956,1 @@\n-            return (int)mh$.invokeExact(C);\n+            return (int) mh$.invokeExact(C);\n@@ -5057,1 +6958,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5060,3 +6961,0 @@\n-    public static MethodHandle clang_Cursor_isAnonymousRecordDecl$MH() {\n-        return RuntimeHelper.requireNonNull(constants$13.clang_Cursor_isAnonymousRecordDecl$MH,\"clang_Cursor_isAnonymousRecordDecl\");\n-    }\n@@ -5064,1 +6962,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5068,0 +6966,14 @@\n+    public static MethodHandle clang_Cursor_isAnonymousRecordDecl$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_isAnonymousRecordDecl\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5071,1 +6983,1 @@\n-            return (int)mh$.invokeExact(C);\n+            return (int) mh$.invokeExact(C);\n@@ -5073,1 +6985,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5076,3 +6988,0 @@\n-    public static MethodHandle clang_Cursor_isBitField$MH() {\n-        return RuntimeHelper.requireNonNull(constants$13.clang_Cursor_isBitField$MH,\"clang_Cursor_isBitField\");\n-    }\n@@ -5080,1 +6989,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5084,0 +6993,14 @@\n+    public static MethodHandle clang_Cursor_isBitField$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_isBitField\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5087,1 +7010,1 @@\n-            return (int)mh$.invokeExact(C);\n+            return (int) mh$.invokeExact(C);\n@@ -5089,1 +7012,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5092,0 +7015,2 @@\n+    private static final int CXChildVisit_Break = (int)0L;\n+\n@@ -5093,1 +7018,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5098,1 +7023,1 @@\n-        return (int)0L;\n+        return CXChildVisit_Break;\n@@ -5100,0 +7025,2 @@\n+    private static final int CXChildVisit_Continue = (int)1L;\n+\n@@ -5101,1 +7028,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5106,1 +7033,1 @@\n-        return (int)1L;\n+        return CXChildVisit_Continue;\n@@ -5108,0 +7035,2 @@\n+    private static final int CXChildVisit_Recurse = (int)2L;\n+\n@@ -5109,1 +7038,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5114,4 +7043,1 @@\n-        return (int)2L;\n-    }\n-    public static MethodHandle clang_visitChildren$MH() {\n-        return RuntimeHelper.requireNonNull(constants$13.clang_visitChildren$MH,\"clang_visitChildren\");\n+        return CXChildVisit_Recurse;\n@@ -5120,1 +7046,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5124,0 +7050,16 @@\n+    public static MethodHandle clang_visitChildren$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXCursor.$LAYOUT(),\n+                Index_h.C_POINTER,\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_visitChildren\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5127,1 +7069,1 @@\n-            return (int)mh$.invokeExact(parent, visitor, client_data);\n+            return (int) mh$.invokeExact(parent, visitor, client_data);\n@@ -5129,1 +7071,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5132,3 +7074,0 @@\n-    public static MethodHandle clang_getCursorUSR$MH() {\n-        return RuntimeHelper.requireNonNull(constants$13.clang_getCursorUSR$MH,\"clang_getCursorUSR\");\n-    }\n@@ -5136,1 +7075,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5140,1 +7079,15 @@\n-    public static MemorySegment clang_getCursorUSR(SegmentAllocator allocator, MemorySegment x1) {\n+    public static MethodHandle clang_getCursorUSR$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXString.$LAYOUT(),\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorUSR\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n+    public static MemorySegment clang_getCursorUSR(SegmentAllocator allocator, MemorySegment x0) {\n@@ -5143,1 +7096,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+            return (MemorySegment) mh$.invokeExact(allocator, x0);\n@@ -5145,1 +7098,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5148,3 +7101,0 @@\n-    public static MethodHandle clang_getCursorSpelling$MH() {\n-        return RuntimeHelper.requireNonNull(constants$14.clang_getCursorSpelling$MH,\"clang_getCursorSpelling\");\n-    }\n@@ -5152,1 +7102,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5156,1 +7106,15 @@\n-    public static MemorySegment clang_getCursorSpelling(SegmentAllocator allocator, MemorySegment x1) {\n+    public static MethodHandle clang_getCursorSpelling$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXString.$LAYOUT(),\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorSpelling\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n+    public static MemorySegment clang_getCursorSpelling(SegmentAllocator allocator, MemorySegment x0) {\n@@ -5159,1 +7123,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+            return (MemorySegment) mh$.invokeExact(allocator, x0);\n@@ -5161,1 +7125,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5164,0 +7128,2 @@\n+    private static final int CXPrintingPolicy_Indentation = (int)0L;\n+\n@@ -5165,1 +7131,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5170,1 +7136,1 @@\n-        return (int)0L;\n+        return CXPrintingPolicy_Indentation;\n@@ -5172,0 +7138,2 @@\n+    private static final int CXPrintingPolicy_SuppressSpecifiers = (int)1L;\n+\n@@ -5173,1 +7141,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5178,1 +7146,1 @@\n-        return (int)1L;\n+        return CXPrintingPolicy_SuppressSpecifiers;\n@@ -5180,0 +7148,2 @@\n+    private static final int CXPrintingPolicy_SuppressTagKeyword = (int)2L;\n+\n@@ -5181,1 +7151,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5186,1 +7156,1 @@\n-        return (int)2L;\n+        return CXPrintingPolicy_SuppressTagKeyword;\n@@ -5188,0 +7158,2 @@\n+    private static final int CXPrintingPolicy_IncludeTagDefinition = (int)3L;\n+\n@@ -5189,1 +7161,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5194,1 +7166,1 @@\n-        return (int)3L;\n+        return CXPrintingPolicy_IncludeTagDefinition;\n@@ -5196,0 +7168,2 @@\n+    private static final int CXPrintingPolicy_SuppressScope = (int)4L;\n+\n@@ -5197,1 +7171,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5202,1 +7176,1 @@\n-        return (int)4L;\n+        return CXPrintingPolicy_SuppressScope;\n@@ -5204,0 +7178,2 @@\n+    private static final int CXPrintingPolicy_SuppressUnwrittenScope = (int)5L;\n+\n@@ -5205,1 +7181,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5210,1 +7186,1 @@\n-        return (int)5L;\n+        return CXPrintingPolicy_SuppressUnwrittenScope;\n@@ -5212,0 +7188,2 @@\n+    private static final int CXPrintingPolicy_SuppressInitializers = (int)6L;\n+\n@@ -5213,1 +7191,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5218,1 +7196,1 @@\n-        return (int)6L;\n+        return CXPrintingPolicy_SuppressInitializers;\n@@ -5220,0 +7198,2 @@\n+    private static final int CXPrintingPolicy_ConstantArraySizeAsWritten = (int)7L;\n+\n@@ -5221,1 +7201,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5226,1 +7206,1 @@\n-        return (int)7L;\n+        return CXPrintingPolicy_ConstantArraySizeAsWritten;\n@@ -5228,0 +7208,2 @@\n+    private static final int CXPrintingPolicy_AnonymousTagLocations = (int)8L;\n+\n@@ -5229,1 +7211,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5234,1 +7216,1 @@\n-        return (int)8L;\n+        return CXPrintingPolicy_AnonymousTagLocations;\n@@ -5236,0 +7218,2 @@\n+    private static final int CXPrintingPolicy_SuppressStrongLifetime = (int)9L;\n+\n@@ -5237,1 +7221,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5242,1 +7226,1 @@\n-        return (int)9L;\n+        return CXPrintingPolicy_SuppressStrongLifetime;\n@@ -5244,0 +7228,2 @@\n+    private static final int CXPrintingPolicy_SuppressLifetimeQualifiers = (int)10L;\n+\n@@ -5245,1 +7231,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5250,1 +7236,1 @@\n-        return (int)10L;\n+        return CXPrintingPolicy_SuppressLifetimeQualifiers;\n@@ -5252,0 +7238,2 @@\n+    private static final int CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors = (int)11L;\n+\n@@ -5253,1 +7241,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5258,1 +7246,1 @@\n-        return (int)11L;\n+        return CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors;\n@@ -5260,0 +7248,2 @@\n+    private static final int CXPrintingPolicy_Bool = (int)12L;\n+\n@@ -5261,1 +7251,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5266,1 +7256,1 @@\n-        return (int)12L;\n+        return CXPrintingPolicy_Bool;\n@@ -5268,0 +7258,2 @@\n+    private static final int CXPrintingPolicy_Restrict = (int)13L;\n+\n@@ -5269,1 +7261,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5274,1 +7266,1 @@\n-        return (int)13L;\n+        return CXPrintingPolicy_Restrict;\n@@ -5276,0 +7268,2 @@\n+    private static final int CXPrintingPolicy_Alignof = (int)14L;\n+\n@@ -5277,1 +7271,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5282,1 +7276,1 @@\n-        return (int)14L;\n+        return CXPrintingPolicy_Alignof;\n@@ -5284,0 +7278,2 @@\n+    private static final int CXPrintingPolicy_UnderscoreAlignof = (int)15L;\n+\n@@ -5285,1 +7281,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5290,1 +7286,1 @@\n-        return (int)15L;\n+        return CXPrintingPolicy_UnderscoreAlignof;\n@@ -5292,0 +7288,2 @@\n+    private static final int CXPrintingPolicy_UseVoidForZeroParams = (int)16L;\n+\n@@ -5293,1 +7291,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5298,1 +7296,1 @@\n-        return (int)16L;\n+        return CXPrintingPolicy_UseVoidForZeroParams;\n@@ -5300,0 +7298,2 @@\n+    private static final int CXPrintingPolicy_TerseOutput = (int)17L;\n+\n@@ -5301,1 +7301,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5306,1 +7306,1 @@\n-        return (int)17L;\n+        return CXPrintingPolicy_TerseOutput;\n@@ -5308,0 +7308,2 @@\n+    private static final int CXPrintingPolicy_PolishForDeclaration = (int)18L;\n+\n@@ -5309,1 +7311,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5314,1 +7316,1 @@\n-        return (int)18L;\n+        return CXPrintingPolicy_PolishForDeclaration;\n@@ -5316,0 +7318,2 @@\n+    private static final int CXPrintingPolicy_Half = (int)19L;\n+\n@@ -5317,1 +7321,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5322,1 +7326,1 @@\n-        return (int)19L;\n+        return CXPrintingPolicy_Half;\n@@ -5324,0 +7328,2 @@\n+    private static final int CXPrintingPolicy_MSWChar = (int)20L;\n+\n@@ -5325,1 +7331,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5330,1 +7336,1 @@\n-        return (int)20L;\n+        return CXPrintingPolicy_MSWChar;\n@@ -5332,0 +7338,2 @@\n+    private static final int CXPrintingPolicy_IncludeNewlines = (int)21L;\n+\n@@ -5333,1 +7341,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5338,1 +7346,1 @@\n-        return (int)21L;\n+        return CXPrintingPolicy_IncludeNewlines;\n@@ -5340,0 +7348,2 @@\n+    private static final int CXPrintingPolicy_MSVCFormatting = (int)22L;\n+\n@@ -5341,1 +7351,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5346,1 +7356,1 @@\n-        return (int)22L;\n+        return CXPrintingPolicy_MSVCFormatting;\n@@ -5348,0 +7358,2 @@\n+    private static final int CXPrintingPolicy_ConstantsAsWritten = (int)23L;\n+\n@@ -5349,1 +7361,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5354,1 +7366,1 @@\n-        return (int)23L;\n+        return CXPrintingPolicy_ConstantsAsWritten;\n@@ -5356,0 +7368,2 @@\n+    private static final int CXPrintingPolicy_SuppressImplicitBase = (int)24L;\n+\n@@ -5357,1 +7371,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5362,1 +7376,1 @@\n-        return (int)24L;\n+        return CXPrintingPolicy_SuppressImplicitBase;\n@@ -5364,0 +7378,2 @@\n+    private static final int CXPrintingPolicy_FullyQualifiedName = (int)25L;\n+\n@@ -5365,1 +7381,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5370,1 +7386,1 @@\n-        return (int)25L;\n+        return CXPrintingPolicy_FullyQualifiedName;\n@@ -5372,0 +7388,2 @@\n+    private static final int CXPrintingPolicy_LastProperty = (int)25L;\n+\n@@ -5373,1 +7391,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5378,4 +7396,1 @@\n-        return (int)25L;\n-    }\n-    public static MethodHandle clang_PrintingPolicy_getProperty$MH() {\n-        return RuntimeHelper.requireNonNull(constants$14.clang_PrintingPolicy_getProperty$MH,\"clang_PrintingPolicy_getProperty\");\n+        return CXPrintingPolicy_LastProperty;\n@@ -5384,1 +7399,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5388,0 +7403,15 @@\n+    public static MethodHandle clang_PrintingPolicy_getProperty$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                Index_h.C_POINTER,\n+                Index_h.C_INT\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_PrintingPolicy_getProperty\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5391,1 +7421,1 @@\n-            return (int)mh$.invokeExact(Policy, Property);\n+            return (int) mh$.invokeExact(Policy, Property);\n@@ -5393,1 +7423,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5396,3 +7426,0 @@\n-    public static MethodHandle clang_PrintingPolicy_setProperty$MH() {\n-        return RuntimeHelper.requireNonNull(constants$14.clang_PrintingPolicy_setProperty$MH,\"clang_PrintingPolicy_setProperty\");\n-    }\n@@ -5400,1 +7427,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5404,0 +7431,15 @@\n+    public static MethodHandle clang_PrintingPolicy_setProperty$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+                Index_h.C_POINTER,\n+                Index_h.C_INT,\n+                Index_h.C_INT\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_PrintingPolicy_setProperty\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5409,1 +7451,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5412,3 +7454,0 @@\n-    public static MethodHandle clang_getCursorPrintingPolicy$MH() {\n-        return RuntimeHelper.requireNonNull(constants$14.clang_getCursorPrintingPolicy$MH,\"clang_getCursorPrintingPolicy\");\n-    }\n@@ -5416,1 +7455,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5420,0 +7459,14 @@\n+    public static MethodHandle clang_getCursorPrintingPolicy$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_POINTER,\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorPrintingPolicy\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5423,1 +7476,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(x0);\n+            return (MemorySegment) mh$.invokeExact(x0);\n@@ -5425,1 +7478,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5428,3 +7481,0 @@\n-    public static MethodHandle clang_PrintingPolicy_dispose$MH() {\n-        return RuntimeHelper.requireNonNull(constants$14.clang_PrintingPolicy_dispose$MH,\"clang_PrintingPolicy_dispose\");\n-    }\n@@ -5432,1 +7482,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5436,0 +7486,13 @@\n+    public static MethodHandle clang_PrintingPolicy_dispose$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_PrintingPolicy_dispose\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5441,1 +7504,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5444,3 +7507,0 @@\n-    public static MethodHandle clang_getCursorPrettyPrinted$MH() {\n-        return RuntimeHelper.requireNonNull(constants$14.clang_getCursorPrettyPrinted$MH,\"clang_getCursorPrettyPrinted\");\n-    }\n@@ -5448,1 +7508,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5452,0 +7512,15 @@\n+    public static MethodHandle clang_getCursorPrettyPrinted$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXString.$LAYOUT(),\n+                CXCursor.$LAYOUT(),\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorPrettyPrinted\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5455,1 +7530,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, Cursor, Policy);\n+            return (MemorySegment) mh$.invokeExact(allocator, Cursor, Policy);\n@@ -5457,1 +7532,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5460,3 +7535,0 @@\n-    public static MethodHandle clang_getCursorDisplayName$MH() {\n-        return RuntimeHelper.requireNonNull(constants$15.clang_getCursorDisplayName$MH,\"clang_getCursorDisplayName\");\n-    }\n@@ -5464,1 +7536,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5468,1 +7540,15 @@\n-    public static MemorySegment clang_getCursorDisplayName(SegmentAllocator allocator, MemorySegment x1) {\n+    public static MethodHandle clang_getCursorDisplayName$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXString.$LAYOUT(),\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorDisplayName\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n+    public static MemorySegment clang_getCursorDisplayName(SegmentAllocator allocator, MemorySegment x0) {\n@@ -5471,1 +7557,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+            return (MemorySegment) mh$.invokeExact(allocator, x0);\n@@ -5473,1 +7559,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5476,3 +7562,0 @@\n-    public static MethodHandle clang_getCursorReferenced$MH() {\n-        return RuntimeHelper.requireNonNull(constants$15.clang_getCursorReferenced$MH,\"clang_getCursorReferenced\");\n-    }\n@@ -5480,1 +7563,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5484,1 +7567,15 @@\n-    public static MemorySegment clang_getCursorReferenced(SegmentAllocator allocator, MemorySegment x1) {\n+    public static MethodHandle clang_getCursorReferenced$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXCursor.$LAYOUT(),\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorReferenced\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n+    public static MemorySegment clang_getCursorReferenced(SegmentAllocator allocator, MemorySegment x0) {\n@@ -5487,1 +7584,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+            return (MemorySegment) mh$.invokeExact(allocator, x0);\n@@ -5489,1 +7586,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5492,3 +7589,0 @@\n-    public static MethodHandle clang_getCursorDefinition$MH() {\n-        return RuntimeHelper.requireNonNull(constants$15.clang_getCursorDefinition$MH,\"clang_getCursorDefinition\");\n-    }\n@@ -5496,1 +7590,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5500,1 +7594,15 @@\n-    public static MemorySegment clang_getCursorDefinition(SegmentAllocator allocator, MemorySegment x1) {\n+    public static MethodHandle clang_getCursorDefinition$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXCursor.$LAYOUT(),\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorDefinition\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n+    public static MemorySegment clang_getCursorDefinition(SegmentAllocator allocator, MemorySegment x0) {\n@@ -5503,1 +7611,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+            return (MemorySegment) mh$.invokeExact(allocator, x0);\n@@ -5505,1 +7613,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5508,3 +7616,0 @@\n-    public static MethodHandle clang_isCursorDefinition$MH() {\n-        return RuntimeHelper.requireNonNull(constants$15.clang_isCursorDefinition$MH,\"clang_isCursorDefinition\");\n-    }\n@@ -5512,1 +7617,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5516,0 +7621,14 @@\n+    public static MethodHandle clang_isCursorDefinition$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_isCursorDefinition\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5519,1 +7638,1 @@\n-            return (int)mh$.invokeExact(x0);\n+            return (int) mh$.invokeExact(x0);\n@@ -5521,1 +7640,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5524,3 +7643,0 @@\n-    public static MethodHandle clang_Cursor_isVariadic$MH() {\n-        return RuntimeHelper.requireNonNull(constants$15.clang_Cursor_isVariadic$MH,\"clang_Cursor_isVariadic\");\n-    }\n@@ -5528,1 +7644,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5532,0 +7648,14 @@\n+    public static MethodHandle clang_Cursor_isVariadic$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_isVariadic\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5535,1 +7665,1 @@\n-            return (int)mh$.invokeExact(C);\n+            return (int) mh$.invokeExact(C);\n@@ -5537,1 +7667,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5540,3 +7670,0 @@\n-    public static MethodHandle clang_Cursor_getMangling$MH() {\n-        return RuntimeHelper.requireNonNull(constants$15.clang_Cursor_getMangling$MH,\"clang_Cursor_getMangling\");\n-    }\n@@ -5544,1 +7671,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5548,1 +7675,15 @@\n-    public static MemorySegment clang_Cursor_getMangling(SegmentAllocator allocator, MemorySegment x1) {\n+    public static MethodHandle clang_Cursor_getMangling$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXString.$LAYOUT(),\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_getMangling\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n+    public static MemorySegment clang_Cursor_getMangling(SegmentAllocator allocator, MemorySegment x0) {\n@@ -5551,1 +7692,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+            return (MemorySegment) mh$.invokeExact(allocator, x0);\n@@ -5553,1 +7694,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5556,0 +7697,2 @@\n+    private static final int CXToken_Punctuation = (int)0L;\n+\n@@ -5557,1 +7700,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5562,1 +7705,1 @@\n-        return (int)0L;\n+        return CXToken_Punctuation;\n@@ -5564,0 +7707,2 @@\n+    private static final int CXToken_Keyword = (int)1L;\n+\n@@ -5565,1 +7710,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5570,1 +7715,1 @@\n-        return (int)1L;\n+        return CXToken_Keyword;\n@@ -5572,0 +7717,2 @@\n+    private static final int CXToken_Identifier = (int)2L;\n+\n@@ -5573,1 +7720,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5578,1 +7725,1 @@\n-        return (int)2L;\n+        return CXToken_Identifier;\n@@ -5580,0 +7727,2 @@\n+    private static final int CXToken_Literal = (int)3L;\n+\n@@ -5581,1 +7730,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5586,1 +7735,1 @@\n-        return (int)3L;\n+        return CXToken_Literal;\n@@ -5588,0 +7737,2 @@\n+    private static final int CXToken_Comment = (int)4L;\n+\n@@ -5589,1 +7740,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5594,4 +7745,1 @@\n-        return (int)4L;\n-    }\n-    public static MethodHandle clang_getTokenKind$MH() {\n-        return RuntimeHelper.requireNonNull(constants$16.clang_getTokenKind$MH,\"clang_getTokenKind\");\n+        return CXToken_Comment;\n@@ -5600,1 +7748,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5604,0 +7752,14 @@\n+    public static MethodHandle clang_getTokenKind$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                CXToken.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getTokenKind\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5607,1 +7769,1 @@\n-            return (int)mh$.invokeExact(x0);\n+            return (int) mh$.invokeExact(x0);\n@@ -5609,1 +7771,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5612,3 +7774,0 @@\n-    public static MethodHandle clang_getTokenSpelling$MH() {\n-        return RuntimeHelper.requireNonNull(constants$16.clang_getTokenSpelling$MH,\"clang_getTokenSpelling\");\n-    }\n@@ -5616,1 +7775,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5620,1 +7779,16 @@\n-    public static MemorySegment clang_getTokenSpelling(SegmentAllocator allocator, MemorySegment x1, MemorySegment x2) {\n+    public static MethodHandle clang_getTokenSpelling$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXString.$LAYOUT(),\n+                Index_h.C_POINTER,\n+                CXToken.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getTokenSpelling\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n+    public static MemorySegment clang_getTokenSpelling(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1) {\n@@ -5623,1 +7797,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1, x2);\n+            return (MemorySegment) mh$.invokeExact(allocator, x0, x1);\n@@ -5625,1 +7799,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5628,3 +7802,0 @@\n-    public static MethodHandle clang_getTokenLocation$MH() {\n-        return RuntimeHelper.requireNonNull(constants$16.clang_getTokenLocation$MH,\"clang_getTokenLocation\");\n-    }\n@@ -5632,1 +7803,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5636,1 +7807,16 @@\n-    public static MemorySegment clang_getTokenLocation(SegmentAllocator allocator, MemorySegment x1, MemorySegment x2) {\n+    public static MethodHandle clang_getTokenLocation$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXSourceLocation.$LAYOUT(),\n+                Index_h.C_POINTER,\n+                CXToken.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getTokenLocation\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n+    public static MemorySegment clang_getTokenLocation(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1) {\n@@ -5639,1 +7825,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1, x2);\n+            return (MemorySegment) mh$.invokeExact(allocator, x0, x1);\n@@ -5641,1 +7827,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5644,3 +7830,0 @@\n-    public static MethodHandle clang_getTokenExtent$MH() {\n-        return RuntimeHelper.requireNonNull(constants$16.clang_getTokenExtent$MH,\"clang_getTokenExtent\");\n-    }\n@@ -5648,1 +7831,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5652,1 +7835,16 @@\n-    public static MemorySegment clang_getTokenExtent(SegmentAllocator allocator, MemorySegment x1, MemorySegment x2) {\n+    public static MethodHandle clang_getTokenExtent$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXSourceRange.$LAYOUT(),\n+                Index_h.C_POINTER,\n+                CXToken.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getTokenExtent\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n+    public static MemorySegment clang_getTokenExtent(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1) {\n@@ -5655,1 +7853,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, x1, x2);\n+            return (MemorySegment) mh$.invokeExact(allocator, x0, x1);\n@@ -5657,1 +7855,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5660,3 +7858,0 @@\n-    public static MethodHandle clang_tokenize$MH() {\n-        return RuntimeHelper.requireNonNull(constants$16.clang_tokenize$MH,\"clang_tokenize\");\n-    }\n@@ -5664,1 +7859,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5668,0 +7863,16 @@\n+    public static MethodHandle clang_tokenize$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+                Index_h.C_POINTER,\n+                CXSourceRange.$LAYOUT(),\n+                Index_h.C_POINTER,\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_tokenize\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5673,1 +7884,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5676,3 +7887,0 @@\n-    public static MethodHandle clang_disposeTokens$MH() {\n-        return RuntimeHelper.requireNonNull(constants$16.clang_disposeTokens$MH,\"clang_disposeTokens\");\n-    }\n@@ -5680,1 +7888,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5684,0 +7892,15 @@\n+    public static MethodHandle clang_disposeTokens$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+                Index_h.C_POINTER,\n+                Index_h.C_POINTER,\n+                Index_h.C_INT\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_disposeTokens\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5689,1 +7912,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5692,3 +7915,0 @@\n-    public static MethodHandle clang_getCursorKindSpelling$MH() {\n-        return RuntimeHelper.requireNonNull(constants$17.clang_getCursorKindSpelling$MH,\"clang_getCursorKindSpelling\");\n-    }\n@@ -5696,1 +7916,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5700,0 +7920,14 @@\n+    public static MethodHandle clang_getCursorKindSpelling$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXString.$LAYOUT(),\n+                Index_h.C_INT\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getCursorKindSpelling\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5703,1 +7937,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, Kind);\n+            return (MemorySegment) mh$.invokeExact(allocator, Kind);\n@@ -5705,1 +7939,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5708,3 +7942,0 @@\n-    public static MethodHandle clang_getClangVersion$MH() {\n-        return RuntimeHelper.requireNonNull(constants$17.clang_getClangVersion$MH,\"clang_getClangVersion\");\n-    }\n@@ -5712,1 +7943,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5716,0 +7947,12 @@\n+    public static MethodHandle clang_getClangVersion$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                CXString.$LAYOUT()        );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_getClangVersion\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5719,1 +7962,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator);\n+            return (MemorySegment) mh$.invokeExact(allocator);\n@@ -5721,1 +7964,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5724,3 +7967,0 @@\n-    public static MethodHandle clang_toggleCrashRecovery$MH() {\n-        return RuntimeHelper.requireNonNull(constants$17.clang_toggleCrashRecovery$MH,\"clang_toggleCrashRecovery\");\n-    }\n@@ -5728,1 +7968,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5732,0 +7972,13 @@\n+    public static MethodHandle clang_toggleCrashRecovery$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+                Index_h.C_INT\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_toggleCrashRecovery\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5737,1 +7990,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5740,3 +7993,0 @@\n-    public static MethodHandle clang_Cursor_Evaluate$MH() {\n-        return RuntimeHelper.requireNonNull(constants$17.clang_Cursor_Evaluate$MH,\"clang_Cursor_Evaluate\");\n-    }\n@@ -5744,1 +7994,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5748,0 +7998,14 @@\n+    public static MethodHandle clang_Cursor_Evaluate$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_POINTER,\n+                CXCursor.$LAYOUT()\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_Cursor_Evaluate\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5751,1 +8015,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(C);\n+            return (MemorySegment) mh$.invokeExact(C);\n@@ -5753,1 +8017,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5756,3 +8020,0 @@\n-    public static MethodHandle clang_EvalResult_getKind$MH() {\n-        return RuntimeHelper.requireNonNull(constants$17.clang_EvalResult_getKind$MH,\"clang_EvalResult_getKind\");\n-    }\n@@ -5760,1 +8021,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5764,0 +8025,14 @@\n+    public static MethodHandle clang_EvalResult_getKind$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_EvalResult_getKind\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5767,1 +8042,1 @@\n-            return (int)mh$.invokeExact(E);\n+            return (int) mh$.invokeExact(E);\n@@ -5769,1 +8044,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5772,3 +8047,0 @@\n-    public static MethodHandle clang_EvalResult_getAsInt$MH() {\n-        return RuntimeHelper.requireNonNull(constants$17.clang_EvalResult_getAsInt$MH,\"clang_EvalResult_getAsInt\");\n-    }\n@@ -5776,1 +8048,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5780,0 +8052,14 @@\n+    public static MethodHandle clang_EvalResult_getAsInt$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_EvalResult_getAsInt\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5783,1 +8069,1 @@\n-            return (int)mh$.invokeExact(E);\n+            return (int) mh$.invokeExact(E);\n@@ -5785,1 +8071,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5788,3 +8074,0 @@\n-    public static MethodHandle clang_EvalResult_getAsLongLong$MH() {\n-        return RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_getAsLongLong$MH,\"clang_EvalResult_getAsLongLong\");\n-    }\n@@ -5792,1 +8075,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5796,0 +8079,14 @@\n+    public static MethodHandle clang_EvalResult_getAsLongLong$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_LONG_LONG,\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_EvalResult_getAsLongLong\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5799,1 +8096,1 @@\n-            return (long)mh$.invokeExact(E);\n+            return (long) mh$.invokeExact(E);\n@@ -5801,1 +8098,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5804,3 +8101,0 @@\n-    public static MethodHandle clang_EvalResult_isUnsignedInt$MH() {\n-        return RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_isUnsignedInt$MH,\"clang_EvalResult_isUnsignedInt\");\n-    }\n@@ -5808,1 +8102,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5812,0 +8106,14 @@\n+    public static MethodHandle clang_EvalResult_isUnsignedInt$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_INT,\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_EvalResult_isUnsignedInt\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5815,1 +8123,1 @@\n-            return (int)mh$.invokeExact(E);\n+            return (int) mh$.invokeExact(E);\n@@ -5817,1 +8125,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5820,3 +8128,0 @@\n-    public static MethodHandle clang_EvalResult_getAsUnsigned$MH() {\n-        return RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_getAsUnsigned$MH,\"clang_EvalResult_getAsUnsigned\");\n-    }\n@@ -5824,1 +8129,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5828,0 +8133,14 @@\n+    public static MethodHandle clang_EvalResult_getAsUnsigned$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_LONG_LONG,\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_EvalResult_getAsUnsigned\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5831,1 +8150,1 @@\n-            return (long)mh$.invokeExact(E);\n+            return (long) mh$.invokeExact(E);\n@@ -5833,1 +8152,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5836,3 +8155,0 @@\n-    public static MethodHandle clang_EvalResult_getAsDouble$MH() {\n-        return RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_getAsDouble$MH,\"clang_EvalResult_getAsDouble\");\n-    }\n@@ -5840,1 +8156,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5844,0 +8160,14 @@\n+    public static MethodHandle clang_EvalResult_getAsDouble$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_DOUBLE,\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_EvalResult_getAsDouble\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5847,1 +8177,1 @@\n-            return (double)mh$.invokeExact(E);\n+            return (double) mh$.invokeExact(E);\n@@ -5849,1 +8179,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5852,3 +8182,0 @@\n-    public static MethodHandle clang_EvalResult_getAsStr$MH() {\n-        return RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_getAsStr$MH,\"clang_EvalResult_getAsStr\");\n-    }\n@@ -5856,1 +8183,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5860,0 +8187,14 @@\n+    public static MethodHandle clang_EvalResult_getAsStr$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                Index_h.C_POINTER,\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_EvalResult_getAsStr\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5863,1 +8204,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(E);\n+            return (MemorySegment) mh$.invokeExact(E);\n@@ -5865,1 +8206,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5868,3 +8209,0 @@\n-    public static MethodHandle clang_EvalResult_dispose$MH() {\n-        return RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_dispose$MH,\"clang_EvalResult_dispose\");\n-    }\n@@ -5872,1 +8210,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5876,0 +8214,13 @@\n+    public static MethodHandle clang_EvalResult_dispose$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+                Index_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    Index_h.findOrThrow(\"clang_EvalResult_dispose\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -5881,1 +8232,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -5884,0 +8235,2 @@\n+    private static final int CXResult_Success = (int)0L;\n+\n@@ -5885,1 +8238,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5890,1 +8243,1 @@\n-        return (int)0L;\n+        return CXResult_Success;\n@@ -5892,0 +8245,2 @@\n+    private static final int CXResult_Invalid = (int)1L;\n+\n@@ -5893,1 +8248,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5898,1 +8253,1 @@\n-        return (int)1L;\n+        return CXResult_Invalid;\n@@ -5900,0 +8255,2 @@\n+    private static final int CXResult_VisitBreak = (int)2L;\n+\n@@ -5901,1 +8258,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -5906,1 +8263,1 @@\n-        return (int)2L;\n+        return CXResult_VisitBreak;\n@@ -5910,1 +8267,0 @@\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/Index_h.java","additions":4081,"deletions":1725,"binary":false,"changes":5806,"status":"modified"},{"patch":"@@ -1,262 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-package org.openjdk.jextract.clang.libclang;\n-\/\/ Generated by jextract\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.SymbolLookup;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.io.File;\n-import java.nio.file.Path;\n-import java.nio.charset.StandardCharsets;\n-import java.util.Arrays;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-import static java.lang.foreign.Linker.*;\n-import static java.lang.foreign.ValueLayout.*;\n-\n-final class RuntimeHelper {\n-\n-    private static final Linker LINKER = Linker.nativeLinker();\n-    private static final ClassLoader LOADER = RuntimeHelper.class.getClassLoader();\n-    private static final MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();\n-    private static final SymbolLookup SYMBOL_LOOKUP;\n-    private static final SegmentAllocator THROWING_ALLOCATOR = (x, y) -> { throw new AssertionError(\"should not reach here\"); };\n-\n-    final static SegmentAllocator CONSTANT_ALLOCATOR =\n-            (size, align) -> Arena.ofAuto().allocate(size, align);\n-\n-    static {\n-        \/\/ Manual change to handle platform specific library name difference\n-        String libName = System.getProperty(\"os.name\").startsWith(\"Windows\")? \"libclang\" : \"clang\";\n-        System.loadLibrary(libName);\n-\n-        SymbolLookup loaderLookup = SymbolLookup.loaderLookup();\n-        SYMBOL_LOOKUP = name -> loaderLookup.find(name).or(() -> LINKER.defaultLookup().find(name));\n-    }\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private RuntimeHelper() {}\n-\n-    static <T> T requireNonNull(T obj, String symbolName) {\n-        if (obj == null) {\n-            throw new UnsatisfiedLinkError(\"unresolved symbol: \" + symbolName);\n-        }\n-        return obj;\n-    }\n-\n-    static MemorySegment lookupGlobalVariable(String name, MemoryLayout layout) {\n-        return SYMBOL_LOOKUP.find(name)\n-                .map(s -> s.reinterpret(layout.byteSize()))\n-                .orElse(null);\n-    }\n-\n-    static MethodHandle downcallHandle(String name, FunctionDescriptor fdesc) {\n-        return SYMBOL_LOOKUP.find(name).\n-                map(addr -> LINKER.downcallHandle(addr, fdesc)).\n-                orElse(null);\n-    }\n-\n-    static MethodHandle downcallHandle(FunctionDescriptor fdesc) {\n-        return LINKER.downcallHandle(fdesc);\n-    }\n-\n-    static MethodHandle downcallHandleVariadic(String name, FunctionDescriptor fdesc) {\n-        return SYMBOL_LOOKUP.find(name).\n-                map(addr -> VarargsInvoker.make(addr, fdesc)).\n-                orElse(null);\n-    }\n-\n-    static <Z> MemorySegment upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, Arena scope) {\n-        try {\n-            MethodHandle handle = MH_LOOKUP.findVirtual(fi, \"apply\", fdesc.toMethodType());\n-            handle = handle.bindTo(z);\n-            return LINKER.upcallStub(handle, fdesc, scope);\n-        } catch (Throwable ex) {\n-            throw new AssertionError(ex);\n-        }\n-    }\n-\n-    static MemorySegment asArray(MemorySegment addr, MemoryLayout layout, int numElements, Arena arena) {\n-         return addr.reinterpret(numElements * layout.byteSize(), arena, null);\n-    }\n-\n-    \/\/ Internals only below this point\n-\n-    private static final class VarargsInvoker {\n-        private static final MethodHandle INVOKE_MH;\n-        private final MemorySegment symbol;\n-        private final FunctionDescriptor function;\n-\n-        private VarargsInvoker(MemorySegment symbol, FunctionDescriptor function) {\n-            this.symbol = symbol;\n-            this.function = function;\n-        }\n-\n-        static {\n-            try {\n-                INVOKE_MH = MethodHandles.lookup().findVirtual(VarargsInvoker.class, \"invoke\", MethodType.methodType(Object.class, SegmentAllocator.class, Object[].class));\n-            } catch (ReflectiveOperationException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        static MethodHandle make(MemorySegment symbol, FunctionDescriptor function) {\n-            VarargsInvoker invoker = new VarargsInvoker(symbol, function);\n-            MethodHandle handle = INVOKE_MH.bindTo(invoker).asCollector(Object[].class, function.argumentLayouts().size() + 1);\n-            MethodType mtype = MethodType.methodType(function.returnLayout().isPresent() ? carrier(function.returnLayout().get(), true) : void.class);\n-            for (MemoryLayout layout : function.argumentLayouts()) {\n-                mtype = mtype.appendParameterTypes(carrier(layout, false));\n-            }\n-            mtype = mtype.appendParameterTypes(Object[].class);\n-            boolean needsAllocator = function.returnLayout().isPresent() &&\n-                                function.returnLayout().get() instanceof GroupLayout;\n-            if (needsAllocator) {\n-                mtype = mtype.insertParameterTypes(0, SegmentAllocator.class);\n-            } else {\n-                handle = MethodHandles.insertArguments(handle, 0, THROWING_ALLOCATOR);\n-            }\n-            return handle.asType(mtype);\n-        }\n-\n-        static Class<?> carrier(MemoryLayout layout, boolean ret) {\n-            if (layout instanceof ValueLayout valueLayout) {\n-                return valueLayout.carrier();\n-            } else if (layout instanceof GroupLayout) {\n-                return MemorySegment.class;\n-            } else {\n-                throw new AssertionError(\"Cannot get here!\");\n-            }\n-        }\n-\n-        private Object invoke(SegmentAllocator allocator, Object[] args) throws Throwable {\n-            \/\/ one trailing Object[]\n-            int nNamedArgs = function.argumentLayouts().size();\n-            assert(args.length == nNamedArgs + 1);\n-            \/\/ The last argument is the array of vararg collector\n-            Object[] unnamedArgs = (Object[]) args[args.length - 1];\n-\n-            int argsCount = nNamedArgs + unnamedArgs.length;\n-            Class<?>[] argTypes = new Class<?>[argsCount];\n-            MemoryLayout[] argLayouts = new MemoryLayout[nNamedArgs + unnamedArgs.length];\n-\n-            int pos = 0;\n-            for (pos = 0; pos < nNamedArgs; pos++) {\n-                argLayouts[pos] = function.argumentLayouts().get(pos);\n-            }\n-\n-            assert pos == nNamedArgs;\n-            for (Object o: unnamedArgs) {\n-                argLayouts[pos] = variadicLayout(normalize(o.getClass()));\n-                pos++;\n-            }\n-            assert pos == argsCount;\n-\n-            FunctionDescriptor f = (function.returnLayout().isEmpty()) ?\n-                    FunctionDescriptor.ofVoid(argLayouts) :\n-                    FunctionDescriptor.of(function.returnLayout().get(), argLayouts);\n-            MethodHandle mh = LINKER.downcallHandle(symbol, f);\n-            boolean needsAllocator = function.returnLayout().isPresent() &&\n-                                            function.returnLayout().get() instanceof GroupLayout;\n-            if (needsAllocator) {\n-                mh = mh.bindTo(allocator);\n-            }\n-            \/\/ flatten argument list so that it can be passed to an asSpreader MH\n-            Object[] allArgs = new Object[nNamedArgs + unnamedArgs.length];\n-            System.arraycopy(args, 0, allArgs, 0, nNamedArgs);\n-            System.arraycopy(unnamedArgs, 0, allArgs, nNamedArgs, unnamedArgs.length);\n-\n-            return mh.asSpreader(Object[].class, argsCount).invoke(allArgs);\n-        }\n-\n-        private static Class<?> unboxIfNeeded(Class<?> clazz) {\n-            if (clazz == Boolean.class) {\n-                return boolean.class;\n-            } else if (clazz == Void.class) {\n-                return void.class;\n-            } else if (clazz == Byte.class) {\n-                return byte.class;\n-            } else if (clazz == Character.class) {\n-                return char.class;\n-            } else if (clazz == Short.class) {\n-                return short.class;\n-            } else if (clazz == Integer.class) {\n-                return int.class;\n-            } else if (clazz == Long.class) {\n-                return long.class;\n-            } else if (clazz == Float.class) {\n-                return float.class;\n-            } else if (clazz == Double.class) {\n-                return double.class;\n-            } else {\n-                return clazz;\n-            }\n-        }\n-\n-        private Class<?> promote(Class<?> c) {\n-            if (c == byte.class || c == char.class || c == short.class || c == int.class) {\n-                return long.class;\n-            } else if (c == float.class) {\n-                return double.class;\n-            } else {\n-                return c;\n-            }\n-        }\n-\n-        private Class<?> normalize(Class<?> c) {\n-            c = unboxIfNeeded(c);\n-            if (c.isPrimitive()) {\n-                return promote(c);\n-            }\n-            if (c == MemorySegment.class) {\n-                return MemorySegment.class;\n-            }\n-            throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n-        }\n-\n-        private MemoryLayout variadicLayout(Class<?> c) {\n-            if (c == long.class) {\n-                return JAVA_LONG;\n-            } else if (c == double.class) {\n-                return JAVA_DOUBLE;\n-            } else if (c == MemorySegment.class) {\n-                return ADDRESS;\n-            } else {\n-                throw new IllegalArgumentException(\"Unhandled variadic argument class: \" + c);\n-            }\n-        }\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/RuntimeHelper.java","additions":0,"deletions":262,"binary":false,"changes":262,"status":"deleted"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.lang.foreign.*;\n+import static java.lang.foreign.ValueLayout.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * enum CXChildVisitResult (*clang_visitChildren$visitor)(struct ,struct ,void*);\n+ * }\n+ *\/\n+public interface clang_visitChildren$visitor {\n+\n+    int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+\n+    FunctionDescriptor $DESC = FunctionDescriptor.of(\n+        Index_h.C_INT,\n+        CXCursor.$LAYOUT(),\n+        CXCursor.$LAYOUT(),\n+        Index_h.C_POINTER\n+    );\n+\n+    MethodHandle UP$MH = Index_h.upcallHandle(clang_visitChildren$visitor.class, \"apply\", $DESC);\n+\n+    static MemorySegment allocate(clang_visitChildren$visitor fi, Arena scope) {\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n+    }\n+\n+    MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+    static clang_visitChildren$visitor ofAddress(MemorySegment addr, Arena arena) {\n+        MemorySegment symbol = addr.reinterpret(arena, null);\n+        return (MemorySegment __x0, MemorySegment __x1, MemorySegment __x2) -> {\n+            try {\n+                return (int) DOWN$MH.invokeExact(symbol, __x0, __x1, __x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        };\n+    }\n+}\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/clang_visitChildren$visitor.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$0 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$0() {}\n-    static final FunctionDescriptor clang_getCString$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-            MemoryLayout.paddingLayout(4)\n-        )\n-    );\n-    static final MethodHandle clang_getCString$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCString\",\n-        constants$0.clang_getCString$FUNC\n-    );\n-    static final FunctionDescriptor clang_disposeString$FUNC = FunctionDescriptor.ofVoid(\n-        MemoryLayout.structLayout(\n-            Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-            MemoryLayout.paddingLayout(4)\n-        )\n-    );\n-    static final MethodHandle clang_disposeString$MH = RuntimeHelper.downcallHandle(\n-        \"clang_disposeString\",\n-        constants$0.clang_disposeString$FUNC\n-    );\n-    static final FunctionDescriptor clang_createIndex$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_createIndex$MH = RuntimeHelper.downcallHandle(\n-        \"clang_createIndex\",\n-        constants$0.clang_createIndex$FUNC\n-    );\n-    static final FunctionDescriptor clang_disposeIndex$FUNC = FunctionDescriptor.ofVoid(\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_disposeIndex$MH = RuntimeHelper.downcallHandle(\n-        \"clang_disposeIndex\",\n-        constants$0.clang_disposeIndex$FUNC\n-    );\n-    static final FunctionDescriptor clang_getFileName$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_getFileName$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getFileName\",\n-        constants$0.clang_getFileName$FUNC\n-    );\n-    static final FunctionDescriptor clang_getNullLocation$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-        MemoryLayout.paddingLayout(4)\n-    ));\n-    static final MethodHandle clang_getNullLocation$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getNullLocation\",\n-        constants$0.clang_getNullLocation$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$0.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$1 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$1() {}\n-    static final FunctionDescriptor clang_equalLocations$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-            MemoryLayout.paddingLayout(4)\n-        ),\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-            MemoryLayout.paddingLayout(4)\n-        )\n-    );\n-    static final MethodHandle clang_equalLocations$MH = RuntimeHelper.downcallHandle(\n-        \"clang_equalLocations\",\n-        constants$1.clang_equalLocations$FUNC\n-    );\n-    static final FunctionDescriptor clang_getLocation$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_getLocation$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getLocation\",\n-        constants$1.clang_getLocation$FUNC\n-    );\n-    static final FunctionDescriptor clang_getLocationForOffset$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_getLocationForOffset$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getLocationForOffset\",\n-        constants$1.clang_getLocationForOffset$FUNC\n-    );\n-    static final FunctionDescriptor clang_Location_isInSystemHeader$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-            MemoryLayout.paddingLayout(4)\n-        )\n-    );\n-    static final MethodHandle clang_Location_isInSystemHeader$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Location_isInSystemHeader\",\n-        constants$1.clang_Location_isInSystemHeader$FUNC\n-    );\n-    static final FunctionDescriptor clang_Location_isFromMainFile$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-            MemoryLayout.paddingLayout(4)\n-        )\n-    );\n-    static final MethodHandle clang_Location_isFromMainFile$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Location_isFromMainFile\",\n-        constants$1.clang_Location_isFromMainFile$FUNC\n-    );\n-    static final FunctionDescriptor clang_Range_isNull$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"begin_int_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"end_int_data\")\n-        )\n-    );\n-    static final MethodHandle clang_Range_isNull$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Range_isNull\",\n-        constants$1.clang_Range_isNull$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$1.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$10 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$10() {}\n-    static final FunctionDescriptor clang_isVolatileQualifiedType$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_isVolatileQualifiedType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_isVolatileQualifiedType\",\n-        constants$10.clang_isVolatileQualifiedType$FUNC\n-    );\n-    static final FunctionDescriptor clang_getTypedefName$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getTypedefName$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getTypedefName\",\n-        constants$10.clang_getTypedefName$FUNC\n-    );\n-    static final FunctionDescriptor clang_getPointeeType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        MemoryLayout.paddingLayout(4),\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getPointeeType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getPointeeType\",\n-        constants$10.clang_getPointeeType$FUNC\n-    );\n-    static final FunctionDescriptor clang_getTypeDeclaration$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-        MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getTypeDeclaration$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getTypeDeclaration\",\n-        constants$10.clang_getTypeDeclaration$FUNC\n-    );\n-    static final FunctionDescriptor clang_getTypeKindSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_getTypeKindSpelling$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getTypeKindSpelling\",\n-        constants$10.clang_getTypeKindSpelling$FUNC\n-    );\n-    static final FunctionDescriptor clang_getFunctionTypeCallingConv$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getFunctionTypeCallingConv$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getFunctionTypeCallingConv\",\n-        constants$10.clang_getFunctionTypeCallingConv$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$10.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -1,129 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$11 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$11() {}\n-    static final FunctionDescriptor clang_getResultType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        MemoryLayout.paddingLayout(4),\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getResultType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getResultType\",\n-        constants$11.clang_getResultType$FUNC\n-    );\n-    static final FunctionDescriptor clang_getNumArgTypes$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getNumArgTypes$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getNumArgTypes\",\n-        constants$11.clang_getNumArgTypes$FUNC\n-    );\n-    static final FunctionDescriptor clang_getArgType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        MemoryLayout.paddingLayout(4),\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        ),\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_getArgType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getArgType\",\n-        constants$11.clang_getArgType$FUNC\n-    );\n-    static final FunctionDescriptor clang_isFunctionTypeVariadic$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_isFunctionTypeVariadic$MH = RuntimeHelper.downcallHandle(\n-        \"clang_isFunctionTypeVariadic\",\n-        constants$11.clang_isFunctionTypeVariadic$FUNC\n-    );\n-    static final FunctionDescriptor clang_getCursorResultType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        MemoryLayout.paddingLayout(4),\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorResultType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorResultType\",\n-        constants$11.clang_getCursorResultType$FUNC\n-    );\n-    static final FunctionDescriptor clang_getElementType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        MemoryLayout.paddingLayout(4),\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getElementType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getElementType\",\n-        constants$11.clang_getElementType$FUNC\n-    );\n-\n-    static final MethodHandle clang_getValueType$MH = RuntimeHelper.downcallHandle(\n-            \"clang_Type_getValueType\",\n-            constants$11.clang_getElementType$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$11.java","additions":0,"deletions":129,"binary":false,"changes":129,"status":"deleted"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$12 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$12() {}\n-    static final FunctionDescriptor clang_getNumElements$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getNumElements$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getNumElements\",\n-        constants$12.clang_getNumElements$FUNC\n-    );\n-    static final FunctionDescriptor clang_getArrayElementType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        MemoryLayout.paddingLayout(4),\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getArrayElementType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getArrayElementType\",\n-        constants$12.clang_getArrayElementType$FUNC\n-    );\n-    static final FunctionDescriptor clang_getArraySize$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getArraySize$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getArraySize\",\n-        constants$12.clang_getArraySize$FUNC\n-    );\n-    static final FunctionDescriptor clang_Type_getSizeOf$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Type_getSizeOf$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Type_getSizeOf\",\n-        constants$12.clang_Type_getSizeOf$FUNC\n-    );\n-    static final FunctionDescriptor clang_Type_getAlignOf$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,\n-            MemoryLayout.structLayout(\n-                    Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-                    MemoryLayout.paddingLayout(4),\n-                    MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-            )\n-    );\n-    static final MethodHandle clang_Type_getAlignOf$MH = RuntimeHelper.downcallHandle(\n-            \"clang_Type_getAlignOf\",\n-            constants$12.clang_Type_getAlignOf$FUNC\n-    );\n-    static final FunctionDescriptor clang_Type_getOffsetOf$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        ),\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_Type_getOffsetOf$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Type_getOffsetOf\",\n-        constants$12.clang_Type_getOffsetOf$FUNC\n-    );\n-    static final FunctionDescriptor clang_Cursor_isAnonymous$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Cursor_isAnonymous$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_isAnonymous\",\n-        constants$12.clang_Cursor_isAnonymous$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$12.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$13 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$13() {}\n-    static final FunctionDescriptor clang_Cursor_isAnonymousRecordDecl$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Cursor_isAnonymousRecordDecl$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_isAnonymousRecordDecl\",\n-        constants$13.clang_Cursor_isAnonymousRecordDecl$FUNC\n-    );\n-    static final FunctionDescriptor clang_Cursor_isBitField$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Cursor_isBitField$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_isBitField\",\n-        constants$13.clang_Cursor_isBitField$FUNC\n-    );\n-    static final FunctionDescriptor CXCursorVisitor$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        ),\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle CXCursorVisitor$MH = RuntimeHelper.downcallHandle(\n-        constants$13.CXCursorVisitor$FUNC\n-    );\n-    static final FunctionDescriptor clang_visitChildren$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        ),\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_visitChildren$MH = RuntimeHelper.downcallHandle(\n-        \"clang_visitChildren\",\n-        constants$13.clang_visitChildren$FUNC\n-    );\n-    static final FunctionDescriptor clang_getCursorUSR$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorUSR$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorUSR\",\n-        constants$13.clang_getCursorUSR$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$13.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$14 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$14() {}\n-    static final FunctionDescriptor clang_getCursorSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorSpelling$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorSpelling\",\n-        constants$14.clang_getCursorSpelling$FUNC\n-    );\n-    static final FunctionDescriptor clang_PrintingPolicy_getProperty$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_PrintingPolicy_getProperty$MH = RuntimeHelper.downcallHandle(\n-        \"clang_PrintingPolicy_getProperty\",\n-        constants$14.clang_PrintingPolicy_getProperty$FUNC\n-    );\n-    static final FunctionDescriptor clang_PrintingPolicy_setProperty$FUNC = FunctionDescriptor.ofVoid(\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_PrintingPolicy_setProperty$MH = RuntimeHelper.downcallHandle(\n-        \"clang_PrintingPolicy_setProperty\",\n-        constants$14.clang_PrintingPolicy_setProperty$FUNC\n-    );\n-    static final FunctionDescriptor clang_getCursorPrintingPolicy$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorPrintingPolicy$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorPrintingPolicy\",\n-        constants$14.clang_getCursorPrintingPolicy$FUNC\n-    );\n-    static final FunctionDescriptor clang_PrintingPolicy_dispose$FUNC = FunctionDescriptor.ofVoid(\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_PrintingPolicy_dispose$MH = RuntimeHelper.downcallHandle(\n-        \"clang_PrintingPolicy_dispose\",\n-        constants$14.clang_PrintingPolicy_dispose$FUNC\n-    );\n-    static final FunctionDescriptor clang_getCursorPrettyPrinted$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        ),\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_getCursorPrettyPrinted$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorPrettyPrinted\",\n-        constants$14.clang_getCursorPrettyPrinted$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$14.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$15 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$15() {}\n-    static final FunctionDescriptor clang_getCursorDisplayName$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorDisplayName$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorDisplayName\",\n-        constants$15.clang_getCursorDisplayName$FUNC\n-    );\n-    static final FunctionDescriptor clang_getCursorReferenced$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-        MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorReferenced$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorReferenced\",\n-        constants$15.clang_getCursorReferenced$FUNC\n-    );\n-    static final FunctionDescriptor clang_getCursorDefinition$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-        MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorDefinition$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorDefinition\",\n-        constants$15.clang_getCursorDefinition$FUNC\n-    );\n-    static final FunctionDescriptor clang_isCursorDefinition$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_isCursorDefinition$MH = RuntimeHelper.downcallHandle(\n-        \"clang_isCursorDefinition\",\n-        constants$15.clang_isCursorDefinition$FUNC\n-    );\n-    static final FunctionDescriptor clang_Cursor_isVariadic$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Cursor_isVariadic$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_isVariadic\",\n-        constants$15.clang_Cursor_isVariadic$FUNC\n-    );\n-    static final FunctionDescriptor clang_Cursor_getMangling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Cursor_getMangling$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_getMangling\",\n-        constants$15.clang_Cursor_getMangling$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$15.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$16 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$16() {}\n-    static final FunctionDescriptor clang_getTokenKind$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(4, Constants$root.C_INT$LAYOUT).withName(\"int_data\"),\n-            Constants$root.C_POINTER$LAYOUT.withName(\"ptr_data\")\n-        )\n-    );\n-    static final MethodHandle clang_getTokenKind$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getTokenKind\",\n-        constants$16.clang_getTokenKind$FUNC\n-    );\n-    static final FunctionDescriptor clang_getTokenSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        Constants$root.C_POINTER$LAYOUT,\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(4, Constants$root.C_INT$LAYOUT).withName(\"int_data\"),\n-            Constants$root.C_POINTER$LAYOUT.withName(\"ptr_data\")\n-        )\n-    );\n-    static final MethodHandle clang_getTokenSpelling$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getTokenSpelling\",\n-        constants$16.clang_getTokenSpelling$FUNC\n-    );\n-    static final FunctionDescriptor clang_getTokenLocation$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        Constants$root.C_POINTER$LAYOUT,\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(4, Constants$root.C_INT$LAYOUT).withName(\"int_data\"),\n-            Constants$root.C_POINTER$LAYOUT.withName(\"ptr_data\")\n-        )\n-    );\n-    static final MethodHandle clang_getTokenLocation$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getTokenLocation\",\n-        constants$16.clang_getTokenLocation$FUNC\n-    );\n-    static final FunctionDescriptor clang_getTokenExtent$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"begin_int_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"end_int_data\")\n-    ),\n-        Constants$root.C_POINTER$LAYOUT,\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(4, Constants$root.C_INT$LAYOUT).withName(\"int_data\"),\n-            Constants$root.C_POINTER$LAYOUT.withName(\"ptr_data\")\n-        )\n-    );\n-    static final MethodHandle clang_getTokenExtent$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getTokenExtent\",\n-        constants$16.clang_getTokenExtent$FUNC\n-    );\n-    static final FunctionDescriptor clang_tokenize$FUNC = FunctionDescriptor.ofVoid(\n-        Constants$root.C_POINTER$LAYOUT,\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"begin_int_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"end_int_data\")\n-        ),\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_tokenize$MH = RuntimeHelper.downcallHandle(\n-        \"clang_tokenize\",\n-        constants$16.clang_tokenize$FUNC\n-    );\n-    static final FunctionDescriptor clang_disposeTokens$FUNC = FunctionDescriptor.ofVoid(\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_disposeTokens$MH = RuntimeHelper.downcallHandle(\n-        \"clang_disposeTokens\",\n-        constants$16.clang_disposeTokens$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$16.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$17 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$17() {}\n-    static final FunctionDescriptor clang_getCursorKindSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_getCursorKindSpelling$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorKindSpelling\",\n-        constants$17.clang_getCursorKindSpelling$FUNC\n-    );\n-    static final FunctionDescriptor clang_getClangVersion$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ));\n-    static final MethodHandle clang_getClangVersion$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getClangVersion\",\n-        constants$17.clang_getClangVersion$FUNC\n-    );\n-    static final FunctionDescriptor clang_toggleCrashRecovery$FUNC = FunctionDescriptor.ofVoid(\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_toggleCrashRecovery$MH = RuntimeHelper.downcallHandle(\n-        \"clang_toggleCrashRecovery\",\n-        constants$17.clang_toggleCrashRecovery$FUNC\n-    );\n-    static final FunctionDescriptor clang_Cursor_Evaluate$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Cursor_Evaluate$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_Evaluate\",\n-        constants$17.clang_Cursor_Evaluate$FUNC\n-    );\n-    static final FunctionDescriptor clang_EvalResult_getKind$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_EvalResult_getKind$MH = RuntimeHelper.downcallHandle(\n-        \"clang_EvalResult_getKind\",\n-        constants$17.clang_EvalResult_getKind$FUNC\n-    );\n-    static final FunctionDescriptor clang_EvalResult_getAsInt$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_EvalResult_getAsInt$MH = RuntimeHelper.downcallHandle(\n-        \"clang_EvalResult_getAsInt\",\n-        constants$17.clang_EvalResult_getAsInt$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$17.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$18 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$18() {}\n-    static final FunctionDescriptor clang_EvalResult_getAsLongLong$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_EvalResult_getAsLongLong$MH = RuntimeHelper.downcallHandle(\n-        \"clang_EvalResult_getAsLongLong\",\n-        constants$18.clang_EvalResult_getAsLongLong$FUNC\n-    );\n-    static final FunctionDescriptor clang_EvalResult_isUnsignedInt$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_EvalResult_isUnsignedInt$MH = RuntimeHelper.downcallHandle(\n-        \"clang_EvalResult_isUnsignedInt\",\n-        constants$18.clang_EvalResult_isUnsignedInt$FUNC\n-    );\n-    static final FunctionDescriptor clang_EvalResult_getAsUnsigned$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_EvalResult_getAsUnsigned$MH = RuntimeHelper.downcallHandle(\n-        \"clang_EvalResult_getAsUnsigned\",\n-        constants$18.clang_EvalResult_getAsUnsigned$FUNC\n-    );\n-    static final FunctionDescriptor clang_EvalResult_getAsDouble$FUNC = FunctionDescriptor.of(Constants$root.C_DOUBLE$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_EvalResult_getAsDouble$MH = RuntimeHelper.downcallHandle(\n-        \"clang_EvalResult_getAsDouble\",\n-        constants$18.clang_EvalResult_getAsDouble$FUNC\n-    );\n-    static final FunctionDescriptor clang_EvalResult_getAsStr$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_EvalResult_getAsStr$MH = RuntimeHelper.downcallHandle(\n-        \"clang_EvalResult_getAsStr\",\n-        constants$18.clang_EvalResult_getAsStr$FUNC\n-    );\n-    static final FunctionDescriptor clang_EvalResult_dispose$FUNC = FunctionDescriptor.ofVoid(\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_EvalResult_dispose$MH = RuntimeHelper.downcallHandle(\n-        \"clang_EvalResult_dispose\",\n-        constants$18.clang_EvalResult_dispose$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$18.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$2 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$2() {}\n-    static final FunctionDescriptor clang_getExpansionLocation$FUNC = FunctionDescriptor.ofVoid(\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-            MemoryLayout.paddingLayout(4)\n-        ),\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_getExpansionLocation$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getExpansionLocation\",\n-        constants$2.clang_getExpansionLocation$FUNC\n-    );\n-    static final FunctionDescriptor clang_getSpellingLocation$FUNC = FunctionDescriptor.ofVoid(\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-            MemoryLayout.paddingLayout(4)\n-        ),\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_getSpellingLocation$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getSpellingLocation\",\n-        constants$2.clang_getSpellingLocation$FUNC\n-    );\n-    static final FunctionDescriptor clang_getFileLocation$FUNC = FunctionDescriptor.ofVoid(\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-            MemoryLayout.paddingLayout(4)\n-        ),\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_getFileLocation$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getFileLocation\",\n-        constants$2.clang_getFileLocation$FUNC\n-    );\n-    static final FunctionDescriptor clang_getRangeStart$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"begin_int_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"end_int_data\")\n-        )\n-    );\n-    static final MethodHandle clang_getRangeStart$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getRangeStart\",\n-        constants$2.clang_getRangeStart$FUNC\n-    );\n-    static final FunctionDescriptor clang_getRangeEnd$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        MemoryLayout.structLayout(\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"begin_int_data\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"end_int_data\")\n-        )\n-    );\n-    static final MethodHandle clang_getRangeEnd$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getRangeEnd\",\n-        constants$2.clang_getRangeEnd$FUNC\n-    );\n-    static final FunctionDescriptor clang_getChildDiagnostics$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_getChildDiagnostics$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getChildDiagnostics\",\n-        constants$2.clang_getChildDiagnostics$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$2.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$3 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$3() {}\n-    static final FunctionDescriptor clang_getNumDiagnostics$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_getNumDiagnostics$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getNumDiagnostics\",\n-        constants$3.clang_getNumDiagnostics$FUNC\n-    );\n-    static final FunctionDescriptor clang_getDiagnostic$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_getDiagnostic$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getDiagnostic\",\n-        constants$3.clang_getDiagnostic$FUNC\n-    );\n-    static final FunctionDescriptor clang_disposeDiagnostic$FUNC = FunctionDescriptor.ofVoid(\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_disposeDiagnostic$MH = RuntimeHelper.downcallHandle(\n-        \"clang_disposeDiagnostic\",\n-        constants$3.clang_disposeDiagnostic$FUNC\n-    );\n-    static final FunctionDescriptor clang_formatDiagnostic$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_formatDiagnostic$MH = RuntimeHelper.downcallHandle(\n-        \"clang_formatDiagnostic\",\n-        constants$3.clang_formatDiagnostic$FUNC\n-    );\n-    static final FunctionDescriptor clang_defaultDiagnosticDisplayOptions$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT);\n-    static final MethodHandle clang_defaultDiagnosticDisplayOptions$MH = RuntimeHelper.downcallHandle(\n-        \"clang_defaultDiagnosticDisplayOptions\",\n-        constants$3.clang_defaultDiagnosticDisplayOptions$FUNC\n-    );\n-    static final FunctionDescriptor clang_getDiagnosticSeverity$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_getDiagnosticSeverity$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getDiagnosticSeverity\",\n-        constants$3.clang_getDiagnosticSeverity$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$3.java","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -1,106 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$4 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$4() {}\n-    static final FunctionDescriptor clang_getDiagnosticLocation$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_getDiagnosticLocation$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getDiagnosticLocation\",\n-        constants$4.clang_getDiagnosticLocation$FUNC\n-    );\n-    static final FunctionDescriptor clang_getDiagnosticSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_getDiagnosticSpelling$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getDiagnosticSpelling\",\n-        constants$4.clang_getDiagnosticSpelling$FUNC\n-    );\n-    static final FunctionDescriptor clang_parseTranslationUnit$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_parseTranslationUnit$MH = RuntimeHelper.downcallHandle(\n-        \"clang_parseTranslationUnit\",\n-        constants$4.clang_parseTranslationUnit$FUNC\n-    );\n-    static final FunctionDescriptor clang_parseTranslationUnit2$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_parseTranslationUnit2$MH = RuntimeHelper.downcallHandle(\n-        \"clang_parseTranslationUnit2\",\n-        constants$4.clang_parseTranslationUnit2$FUNC\n-    );\n-    static final FunctionDescriptor clang_saveTranslationUnit$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_saveTranslationUnit$MH = RuntimeHelper.downcallHandle(\n-        \"clang_saveTranslationUnit\",\n-        constants$4.clang_saveTranslationUnit$FUNC\n-    );\n-    static final FunctionDescriptor clang_disposeTranslationUnit$FUNC = FunctionDescriptor.ofVoid(\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_disposeTranslationUnit$MH = RuntimeHelper.downcallHandle(\n-        \"clang_disposeTranslationUnit\",\n-        constants$4.clang_disposeTranslationUnit$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$4.java","additions":0,"deletions":106,"binary":false,"changes":106,"status":"deleted"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$5 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$5() {}\n-    static final FunctionDescriptor clang_defaultReparseOptions$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_defaultReparseOptions$MH = RuntimeHelper.downcallHandle(\n-        \"clang_defaultReparseOptions\",\n-        constants$5.clang_defaultReparseOptions$FUNC\n-    );\n-    static final FunctionDescriptor clang_reparseTranslationUnit$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_POINTER$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_reparseTranslationUnit$MH = RuntimeHelper.downcallHandle(\n-        \"clang_reparseTranslationUnit\",\n-        constants$5.clang_reparseTranslationUnit$FUNC\n-    );\n-    static final FunctionDescriptor clang_getNullCursor$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-        MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ));\n-    static final MethodHandle clang_getNullCursor$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getNullCursor\",\n-        constants$5.clang_getNullCursor$FUNC\n-    );\n-    static final FunctionDescriptor clang_getTranslationUnitCursor$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-        MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        Constants$root.C_POINTER$LAYOUT\n-    );\n-    static final MethodHandle clang_getTranslationUnitCursor$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getTranslationUnitCursor\",\n-        constants$5.clang_getTranslationUnitCursor$FUNC\n-    );\n-    static final FunctionDescriptor clang_equalCursors$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_equalCursors$MH = RuntimeHelper.downcallHandle(\n-        \"clang_equalCursors\",\n-        constants$5.clang_equalCursors$FUNC\n-    );\n-    static final FunctionDescriptor clang_Cursor_isNull$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Cursor_isNull$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_isNull\",\n-        constants$5.clang_Cursor_isNull$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$5.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$6 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$6() {}\n-    static final FunctionDescriptor clang_getCursorKind$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorKind$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorKind\",\n-        constants$6.clang_getCursorKind$FUNC\n-    );\n-    static final FunctionDescriptor clang_isDeclaration$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_isDeclaration$MH = RuntimeHelper.downcallHandle(\n-        \"clang_isDeclaration\",\n-        constants$6.clang_isDeclaration$FUNC\n-    );\n-    static final FunctionDescriptor clang_isAttribute$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_isAttribute$MH = RuntimeHelper.downcallHandle(\n-        \"clang_isAttribute\",\n-        constants$6.clang_isAttribute$FUNC\n-    );\n-    static final FunctionDescriptor clang_isInvalid$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_isInvalid$MH = RuntimeHelper.downcallHandle(\n-        \"clang_isInvalid\",\n-        constants$6.clang_isInvalid$FUNC\n-    );\n-    static final FunctionDescriptor clang_isPreprocessing$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_isPreprocessing$MH = RuntimeHelper.downcallHandle(\n-        \"clang_isPreprocessing\",\n-        constants$6.clang_isPreprocessing$FUNC\n-    );\n-    static final FunctionDescriptor clang_getCursorLinkage$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorLinkage$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorLinkage\",\n-        constants$6.clang_getCursorLinkage$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$6.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$7 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$7() {}\n-    static final FunctionDescriptor clang_getCursorLanguage$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorLanguage$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorLanguage\",\n-        constants$7.clang_getCursorLanguage$FUNC\n-    );\n-    static final FunctionDescriptor clang_Cursor_getTranslationUnit$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Cursor_getTranslationUnit$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_getTranslationUnit\",\n-        constants$7.clang_Cursor_getTranslationUnit$FUNC\n-    );\n-    static final FunctionDescriptor clang_getCursorLocation$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"int_data\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorLocation$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorLocation\",\n-        constants$7.clang_getCursorLocation$FUNC\n-    );\n-    static final FunctionDescriptor clang_getCursorExtent$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"ptr_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"begin_int_data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"end_int_data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorExtent$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorExtent\",\n-        constants$7.clang_getCursorExtent$FUNC\n-    );\n-    static final FunctionDescriptor clang_getCursorType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        MemoryLayout.paddingLayout(4),\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCursorType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCursorType\",\n-        constants$7.clang_getCursorType$FUNC\n-    );\n-    static final FunctionDescriptor clang_getTypeSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_POINTER$LAYOUT.withName(\"data\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"private_flags\"),\n-        MemoryLayout.paddingLayout(4)\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getTypeSpelling$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getTypeSpelling\",\n-        constants$7.clang_getTypeSpelling$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$7.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -1,115 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$8 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$8() {}\n-    static final FunctionDescriptor clang_getTypedefDeclUnderlyingType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        MemoryLayout.paddingLayout(4),\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getTypedefDeclUnderlyingType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getTypedefDeclUnderlyingType\",\n-        constants$8.clang_getTypedefDeclUnderlyingType$FUNC\n-    );\n-    static final FunctionDescriptor clang_getEnumDeclIntegerType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        MemoryLayout.paddingLayout(4),\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getEnumDeclIntegerType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getEnumDeclIntegerType\",\n-        constants$8.clang_getEnumDeclIntegerType$FUNC\n-    );\n-    static final FunctionDescriptor clang_getEnumConstantDeclValue$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getEnumConstantDeclValue$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getEnumConstantDeclValue\",\n-        constants$8.clang_getEnumConstantDeclValue$FUNC\n-    );\n-    static final FunctionDescriptor clang_getEnumConstantDeclUnsignedValue$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getEnumConstantDeclUnsignedValue$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getEnumConstantDeclUnsignedValue\",\n-        constants$8.clang_getEnumConstantDeclUnsignedValue$FUNC\n-    );\n-    static final FunctionDescriptor clang_getFieldDeclBitWidth$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getFieldDeclBitWidth$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getFieldDeclBitWidth\",\n-        constants$8.clang_getFieldDeclBitWidth$FUNC\n-    );\n-    static final FunctionDescriptor clang_Cursor_getNumArguments$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Cursor_getNumArguments$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_getNumArguments\",\n-        constants$8.clang_Cursor_getNumArguments$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$8.java","additions":0,"deletions":115,"binary":false,"changes":115,"status":"deleted"},{"patch":"@@ -1,121 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package org.openjdk.jextract.clang.libclang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$9 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$9() {}\n-    static final FunctionDescriptor clang_Cursor_getArgument$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-        MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        ),\n-        Constants$root.C_INT$LAYOUT\n-    );\n-    static final MethodHandle clang_Cursor_getArgument$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_getArgument\",\n-        constants$9.clang_Cursor_getArgument$FUNC\n-    );\n-    static final FunctionDescriptor clang_equalTypes$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_equalTypes$MH = RuntimeHelper.downcallHandle(\n-        \"clang_equalTypes\",\n-        constants$9.clang_equalTypes$FUNC\n-    );\n-    static final FunctionDescriptor clang_getCanonicalType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n-        Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-        MemoryLayout.paddingLayout(4),\n-        MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-    ),\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_getCanonicalType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_getCanonicalType\",\n-        constants$9.clang_getCanonicalType$FUNC\n-    );\n-    static final FunctionDescriptor clang_isConstQualifiedType$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            MemoryLayout.paddingLayout(4),\n-            MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_isConstQualifiedType$MH = RuntimeHelper.downcallHandle(\n-        \"clang_isConstQualifiedType\",\n-        constants$9.clang_isConstQualifiedType$FUNC\n-    );\n-    static final FunctionDescriptor clang_Cursor_isMacroFunctionLike$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Cursor_isMacroFunctionLike$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_isMacroFunctionLike\",\n-        constants$9.clang_Cursor_isMacroFunctionLike$FUNC\n-    );\n-    static final FunctionDescriptor clang_Cursor_isFunctionInlined$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,\n-        MemoryLayout.structLayout(\n-            Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n-            Constants$root.C_INT$LAYOUT.withName(\"xdata\"),\n-            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n-        )\n-    );\n-    static final MethodHandle clang_Cursor_isFunctionInlined$MH = RuntimeHelper.downcallHandle(\n-        \"clang_Cursor_isFunctionInlined\",\n-        constants$9.clang_Cursor_isFunctionInlined$FUNC\n-    );\n-}\n-\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$9.java","additions":0,"deletions":121,"binary":false,"changes":121,"status":"deleted"},{"patch":"@@ -5,0 +5,1 @@\n+* remove the src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang folder\n@@ -8,0 +9,1 @@\n+* set LIBCLANG_HOME to point to the home of the LLVM distribution\n@@ -12,1 +14,1 @@\n-File: RuntimeHelper.java\n+File: Index_h.java\n","filename":"updateclang\/README.md","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -16,0 +16,1 @@\n+--include-typedef CXCursor\n@@ -18,0 +19,2 @@\n+--include-typedef CXSourceRange\n+--include-typedef CXSourceLocation\n@@ -547,0 +550,1 @@\n+--include-function clang_Type_getAlignOf\n@@ -549,0 +553,1 @@\n+--include-function clang_Type_getValueType\n","filename":"updateclang\/clang.symbols","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"updateclang\/cp_header.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,2 @@\n+echo \"Extracting libclang headers...\"\n+\n@@ -11,0 +13,2 @@\n+echo \"Adding copyrights...\"\n+\n@@ -12,2 +16,2 @@\n-head -$COPYRIGHTLEN $x | diff cp_header.txt - || ( ( cat cp_header.txt; echo; cat $x) > \/tmp\/file;\n-mv \/tmp\/file $x )\n+(cat cp_header.txt; echo; cat $x) > \/tmp\/file;\n+mv \/tmp\/file $x\n@@ -15,0 +19,2 @@\n+\n+echo \"Done!\"\n","filename":"updateclang\/extract.sh","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"}]}