{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,0 +163,9 @@\n+    final void emitPrivateConstructor() {\n+        appendIndentedLines(\"\"\"\n+\n+            private %1$s() {\n+                \/\/ Should not be called directly\n+            }\n+            \"\"\", className);\n+    }\n+\n@@ -203,2 +212,4 @@\n-            case Declared d when Utils.isStructOrUnion(d) -> alignIfNeeded(JavaName.getFullNameOrThrow(d.tree()) + \".layout()\", ClangAlignOf.getOrThrow(d.tree()) \/ 8, align);\n-            case Delegated d when d.kind() == Delegated.Kind.POINTER -> alignIfNeeded(runtimeHelperName() + \".C_POINTER\", 8, align);\n+            case Declared d when Utils.isStructOrUnion(d) ->\n+                    alignIfNeeded(JavaName.getFullNameOrThrow(d.tree()) + \".layout()\", ClangAlignOf.getOrThrow(d.tree()) \/ 8, align);\n+            case Delegated d when d.kind() == Delegated.Kind.POINTER ->\n+                    alignIfNeeded(sb.layoutUtilsName() + \"C_POINTER\", 8, align);\n@@ -206,2 +217,3 @@\n-            case Function _ -> alignIfNeeded(runtimeHelperName() + \".C_POINTER\", 8, align);\n-            case Array a -> String.format(\"MemoryLayout.sequenceLayout(%1$d, %2$s)\", a.elementCount().orElse(0L), layoutString(a.elementType(), align));\n+            case Function _ -> alignIfNeeded(sb.layoutUtilsName() + \"C_POINTER\", 8, align);\n+            case Array a ->\n+                    String.format(\"MemoryLayout.sequenceLayout(%1$d, %2$s)\", a.elementCount().orElse(0L), layoutString(a.elementType(), align));\n@@ -246,8 +258,8 @@\n-            case Bool -> runtimeHelperName() + \".C_BOOL\";\n-            case Char -> runtimeHelperName() + \".C_CHAR\";\n-            case Short -> alignIfNeeded(runtimeHelperName() + \".C_SHORT\", 2, align);\n-            case Int -> alignIfNeeded(runtimeHelperName() + \".C_INT\", 4, align);\n-            case Long -> alignIfNeeded(runtimeHelperName() + \".C_LONG\", TypeImpl.IS_WINDOWS ? 4 : 8, align);\n-            case LongLong -> alignIfNeeded(runtimeHelperName() + \".C_LONG_LONG\", 8, align);\n-            case Float -> alignIfNeeded(runtimeHelperName() + \".C_FLOAT\", 4, align);\n-            case Double -> alignIfNeeded(runtimeHelperName() + \".C_DOUBLE\", 8, align);\n+            case Bool -> sb.layoutUtilsName() + \"C_BOOL\";\n+            case Char -> sb.layoutUtilsName() + \"C_CHAR\";\n+            case Short -> alignIfNeeded(sb.layoutUtilsName() + \"C_SHORT\", 2, align);\n+            case Int -> alignIfNeeded(sb.layoutUtilsName() + \"C_INT\", 4, align);\n+            case Long -> alignIfNeeded(sb.layoutUtilsName() + \"C_LONG\", TypeImpl.IS_WINDOWS ? 4 : 8, align);\n+            case LongLong -> alignIfNeeded(sb.layoutUtilsName() + \"C_LONG_LONG\", 8, align);\n+            case Float -> alignIfNeeded(sb.layoutUtilsName() + \"C_FLOAT\", 4, align);\n+            case Double -> alignIfNeeded(sb.layoutUtilsName() + \"C_DOUBLE\", 8, align);\n@@ -255,1 +267,1 @@\n-                    alignIfNeeded(runtimeHelperName() + \".C_LONG_DOUBLE\", 8, align) :\n+                    alignIfNeeded(sb.layoutUtilsName() + \"C_LONG_DOUBLE\", 8, align) :\n@@ -265,1 +277,1 @@\n-                String.format(\"%1$s.align(%2$s, %3$d)\", runtimeHelperName(), layoutPrefix, expectedAlign) :\n+                String.format(\"%3$salign(%1$s, %2$d)\", layoutPrefix, expectedAlign, sourceFileBuilder().FFMUtilsName()) :\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ClassSourceBuilder.java","additions":27,"deletions":15,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Moving common layouts and static methods not relevant to component areas into a centralized location\n+ *\/\n+\n+final class CommonBindingsBuilder extends ClassSourceBuilder {\n+    private CommonBindingsBuilder(SourceFileBuilder builder, String className, String runtimeHelperName) {\n+        super(builder, \"public final\", Kind.CLASS, className, null, null, runtimeHelperName);\n+    }\n+\n+    public static void generate(SourceFileBuilder builder, String className, String runtimeHelperName) {\n+        CommonBindingsBuilder cbd = new CommonBindingsBuilder(builder, className, runtimeHelperName);\n+        cbd.appendBlankLine();\n+        cbd.classBegin();\n+        cbd.emitPrivateConstructor();\n+        cbd.appendBlankLine();\n+        cbd.emitPrimitiveTypes();\n+        cbd.classEnd();\n+    }\n+\n+    public static void generate(SourceFileBuilder builder, String className, String runtimeHelperName, List<Options.Library> libs, Boolean useSystemLoadLibrary) {\n+        CommonBindingsBuilder cbd = new CommonBindingsBuilder(builder, className, runtimeHelperName);\n+        cbd.appendBlankLine();\n+        cbd.classBegin();\n+        cbd.emitPrivateConstructor();\n+        cbd.emitCommonFinalFields();\n+        cbd.emitFirstHeaderPreamble(libs, useSystemLoadLibrary);\n+        cbd.appendBlankLine();\n+        cbd.emitRuntimeHelperMethods();\n+        cbd.classEnd();\n+    }\n+\n+    \/\/ emit basic primitive types\n+    private void emitPrimitiveTypes() {\n+        appendIndentedLines(\"\"\"\n+            public static final ValueLayout.OfBoolean C_BOOL = (ValueLayout.OfBoolean) Linker.nativeLinker().canonicalLayouts().get(\"bool\");\n+            public static final ValueLayout.OfByte C_CHAR =(ValueLayout.OfByte)Linker.nativeLinker().canonicalLayouts().get(\"char\");\n+            public static final ValueLayout.OfShort C_SHORT = (ValueLayout.OfShort) Linker.nativeLinker().canonicalLayouts().get(\"short\");\n+            public static final ValueLayout.OfInt C_INT = (ValueLayout.OfInt) Linker.nativeLinker().canonicalLayouts().get(\"int\");\n+            public static final ValueLayout.OfLong C_LONG_LONG = (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long long\");\n+            public static final ValueLayout.OfFloat C_FLOAT = (ValueLayout.OfFloat) Linker.nativeLinker().canonicalLayouts().get(\"float\");\n+            public static final ValueLayout.OfDouble C_DOUBLE = (ValueLayout.OfDouble) Linker.nativeLinker().canonicalLayouts().get(\"double\");\n+            public static final AddressLayout C_POINTER = ((AddressLayout) Linker.nativeLinker().canonicalLayouts().get(\"void*\"))\n+                    .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, C_CHAR));\n+            \"\"\");\n+        if (TypeImpl.IS_WINDOWS) {\n+            appendIndentedLines(\"public static final ValueLayout.OfInt C_LONG = (ValueLayout.OfInt) Linker.nativeLinker().canonicalLayouts().get(\\\"long\\\");\");\n+            appendIndentedLines(\"public static final ValueLayout.OfDouble C_LONG_DOUBLE = (ValueLayout.OfDouble) Linker.nativeLinker().canonicalLayouts().get(\\\"double\\\");\");\n+        } else {\n+            appendIndentedLines(\"public static final ValueLayout.OfLong C_LONG = (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get(\\\"long\\\");\");\n+        }\n+    }\n+\n+    void emitFirstHeaderPreamble(List<Options.Library> libraries, boolean useSystemLoadLibrary) {\n+        List<String> lookups = new ArrayList<>();\n+        \/\/ if legacy library loading is selected, load libraries (if any) into current loader\n+        if (useSystemLoadLibrary) {\n+            appendBlankLine();\n+            appendIndentedLines(\"\"\"\n+\n+                static {\n+                \"\"\");\n+            incrAlign();\n+            for (Options.Library lib : libraries) {\n+                String method = lib.specKind() == Options.Library.SpecKind.PATH ? \"load\" : \"loadLibrary\";\n+                appendIndentedLines(\"System.%1$s(\\\"%2$s\\\");\", method, lib.toQuotedName());\n+            }\n+            decrAlign();\n+            appendIndentedLines(\"\"\"\n+                }\n+                \"\"\");\n+        } else {\n+            \/\/ otherwise, add a library lookup per library (if any)\n+            libraries.stream() \/\/ add library lookups (if any)\n+                    .map(l -> l.specKind() == Options.Library.SpecKind.PATH ?\n+                            String.format(\"SymbolLookup.libraryLookup(\\\"%1$s\\\", LIBRARY_ARENA)\", l.toQuotedName()) :\n+                            String.format(\"SymbolLookup.libraryLookup(System.mapLibraryName(\\\"%1$s\\\"), LIBRARY_ARENA)\", l.toQuotedName()))\n+                    .collect(Collectors.toCollection(() -> lookups));\n+        }\n+\n+        lookups.add(\"SymbolLookup.loaderLookup()\"); \/\/ fallback to loader lookup\n+        lookups.add(\"Linker.nativeLinker().defaultLookup()\"); \/\/ fallback to native lookup\n+\n+        \/\/ wrap all lookups (but the first) with \".or(...)\"\n+        List<String> lookupCalls = new ArrayList<>();\n+        boolean isFirst = true;\n+        for (String lookup : lookups) {\n+            lookupCalls.add(isFirst ? lookup : String.format(\".or(%1$s)\", lookup));\n+            isFirst = false;\n+        }\n+\n+        \/\/ chain all the calls together into a combined symbol lookup\n+        appendBlankLine();\n+        appendIndentedLines(lookupCalls.stream()\n+                .collect(Collectors.joining(String.format(\"\\n%1$s\", indentString(2)), \"static final SymbolLookup SYMBOL_LOOKUP = \", \";\")));\n+    }\n+\n+    private void emitCommonFinalFields() {\n+        appendIndentedLines(\"\"\"\n+            static final Arena LIBRARY_ARENA = Arena.ofAuto();\n+            static final boolean TRACE_DOWNCALLS = Boolean.getBoolean(\"jextract.trace.downcalls\");\n+\n+                \"\"\");\n+    }\n+    private void emitRuntimeHelperMethods() {\n+        appendIndentedLines(\"\"\"\n+            static void traceDowncall(String name, Object... args) {\n+                 String traceArgs = Arrays.stream(args)\n+                               .map(Object::toString)\n+                               .collect(Collectors.joining(\", \"));\n+                 System.out.printf(\"%s(%s)\\\\n\", name, traceArgs);\n+            }\n+\n+            static MemorySegment findOrThrow(String symbol) {\n+                return SYMBOL_LOOKUP.findOrThrow(symbol);\n+            }\n+\n+            static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n+                try {\n+                    return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());\n+                } catch (ReflectiveOperationException ex) {\n+                    throw new AssertionError(ex);\n+                }\n+            }\n+\n+            static MemoryLayout align(MemoryLayout layout, long align) {\n+                return switch (layout) {\n+                    case PaddingLayout p -> p;\n+                    case ValueLayout v -> v.withByteAlignment(align);\n+                    case GroupLayout g -> {\n+                        MemoryLayout[] alignedMembers = g.memberLayouts().stream()\n+                                .map(m -> align(m, align)).toArray(MemoryLayout[]::new);\n+                        yield g instanceof StructLayout ?\n+                                MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);\n+                    }\n+                    case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));\n+                };\n+            }\n+            \"\"\");\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/CommonBindingsBuilder.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-            private static final MethodHandle UP$MH = %1$s.upcallHandle(%2$s.%3$s.class, \"apply\", $DESC);\n+            private static final MethodHandle UP$MH = %1$supcallHandle(%2$s.%3$s.class, \"apply\", $DESC);\n@@ -95,1 +95,1 @@\n-            \"\"\", runtimeHelperName(), className(), fiName);\n+            \"\"\", sourceFileBuilder().FFMUtilsName(), className(), fiName);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-                    public static final MemorySegment ADDR = %3$s.findOrThrow(\"%4$s\");\n+                    public static final MemorySegment ADDR = %4$sfindOrThrow(\"%3$s\");\n@@ -188,1 +188,1 @@\n-                    runtimeHelperName(), lookupName(decl));\n+                    lookupName(decl), sourceFileBuilder().FFMUtilsName());\n@@ -216,2 +216,2 @@\n-                    if (TRACE_DOWNCALLS) {\n-                        traceDowncall(%5$s);\n+                    if (%8$sTRACE_DOWNCALLS) {\n+                        %8$straceDowncall(%5$s);\n@@ -226,1 +226,2 @@\n-            holderClass, traceArgList, returnWithCast, paramList);\n+            holderClass, traceArgList, returnWithCast, paramList,\n+            sourceFileBuilder().FFMUtilsName());\n@@ -235,1 +236,1 @@\n-                    private static final MemorySegment ADDR = %3$s.findOrThrow(\"%4$s\");\n+                    private static final MemorySegment ADDR = %4$sfindOrThrow(\"%3$s\");\n@@ -241,1 +242,1 @@\n-                    private %5$s(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {\n+                    private %1$s(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {\n@@ -247,1 +248,1 @@\n-                    runtimeHelperName(), lookupName(decl), invokerClassName);\n+                    lookupName(decl), sourceFileBuilder().FFMUtilsName());\n@@ -286,2 +287,2 @@\n-                            if (TRACE_DOWNCALLS) {\n-                                traceDowncall(%3$s);\n+                            if (%6$sTRACE_DOWNCALLS) {\n+                                %6$straceDowncall(%3$s);\n@@ -297,1 +298,2 @@\n-                \"\"\", retType, paramExprs, traceArgList, returnWithCast, paramList);\n+                \"\"\", retType, paramExprs, traceArgList,\n+                    returnWithCast, paramList, sourceFileBuilder().FFMUtilsName());\n@@ -310,85 +312,0 @@\n-    void emitFirstHeaderPreamble(List<Options.Library> libraries, boolean useSystemLoadLibrary) {\n-        List<String> lookups = new ArrayList<>();\n-        \/\/ if legacy library loading is selected, load libraries (if any) into current loader\n-        if (useSystemLoadLibrary) {\n-            appendBlankLine();\n-            appendIndentedLines(\"\"\"\n-\n-                static {\n-                \"\"\");\n-            incrAlign();\n-            for (Options.Library lib : libraries) {\n-                String method = lib.specKind() == Options.Library.SpecKind.PATH ? \"load\" : \"loadLibrary\";\n-                appendIndentedLines(\"System.%1$s(\\\"%2$s\\\");\", method, lib.toQuotedName());\n-            }\n-            decrAlign();\n-            appendIndentedLines(\"\"\"\n-                }\n-                \"\"\");\n-        } else {\n-            \/\/ otherwise, add a library lookup per library (if any)\n-            libraries.stream() \/\/ add library lookups (if any)\n-                    .map(l -> l.specKind() == Options.Library.SpecKind.PATH ?\n-                            String.format(\"SymbolLookup.libraryLookup(\\\"%1$s\\\", LIBRARY_ARENA)\", l.toQuotedName()) :\n-                            String.format(\"SymbolLookup.libraryLookup(System.mapLibraryName(\\\"%1$s\\\"), LIBRARY_ARENA)\", l.toQuotedName()))\n-                    .collect(Collectors.toCollection(() -> lookups));\n-        }\n-\n-        lookups.add(\"SymbolLookup.loaderLookup()\"); \/\/ fallback to loader lookup\n-        lookups.add(\"Linker.nativeLinker().defaultLookup()\"); \/\/ fallback to native lookup\n-\n-        \/\/ wrap all lookups (but the first) with \".or(...)\"\n-        List<String> lookupCalls = new ArrayList<>();\n-        boolean isFirst = true;\n-        for (String lookup : lookups) {\n-            lookupCalls.add(isFirst ? lookup : String.format(\".or(%1$s)\", lookup));\n-            isFirst = false;\n-        }\n-\n-        \/\/ chain all the calls together into a combined symbol lookup\n-        appendBlankLine();\n-        appendIndentedLines(lookupCalls.stream()\n-                .collect(Collectors.joining(String.format(\"\\n%1$s\", indentString(2)), \"static final SymbolLookup SYMBOL_LOOKUP = \", \";\")));\n-    }\n-\n-    void emitRuntimeHelperMethods() {\n-        appendIndentedLines(\"\"\"\n-\n-            static final Arena LIBRARY_ARENA = Arena.ofAuto();\n-            static final boolean TRACE_DOWNCALLS = Boolean.getBoolean(\"jextract.trace.downcalls\");\n-\n-            static void traceDowncall(String name, Object... args) {\n-                 String traceArgs = Arrays.stream(args)\n-                               .map(Object::toString)\n-                               .collect(Collectors.joining(\", \"));\n-                 System.out.printf(\"%s(%s)\\\\n\", name, traceArgs);\n-            }\n-\n-            static MemorySegment findOrThrow(String symbol) {\n-                return SYMBOL_LOOKUP.findOrThrow(symbol);\n-            }\n-\n-            static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n-                try {\n-                    return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());\n-                } catch (ReflectiveOperationException ex) {\n-                    throw new AssertionError(ex);\n-                }\n-            }\n-\n-            static MemoryLayout align(MemoryLayout layout, long align) {\n-                return switch (layout) {\n-                    case PaddingLayout p -> p;\n-                    case ValueLayout v -> v.withByteAlignment(align);\n-                    case GroupLayout g -> {\n-                        MemoryLayout[] alignedMembers = g.memberLayouts().stream()\n-                                .map(m -> align(m, align)).toArray(MemoryLayout[]::new);\n-                        yield g instanceof StructLayout ?\n-                                MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);\n-                    }\n-                    case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));\n-                };\n-            }\n-            \"\"\");\n-    }\n-\n@@ -518,3 +435,3 @@\n-                    public static final MemorySegment SEGMENT = %4$s.findOrThrow(\"%5$s\").reinterpret(LAYOUT.byteSize());\n-                %6$s\n-                    public static final long[] DIMS = { %7$s };\n+                    public static final MemorySegment SEGMENT = %7$sfindOrThrow(\"%4$s\").reinterpret(LAYOUT.byteSize());\n+                %5$s\n+                    public static final long[] DIMS = { %6$s };\n@@ -522,2 +439,2 @@\n-                \"\"\", mangledName, layoutType, layoutString(varType), runtimeHelperName(),\n-                    lookupName(var), accessHandle, dimsString);\n+                \"\"\", mangledName, layoutType, layoutString(varType), lookupName(var),\n+                    accessHandle, dimsString, sourceFileBuilder().FFMUtilsName());\n@@ -528,1 +445,1 @@\n-                    public static final MemorySegment SEGMENT = %4$s.findOrThrow(\"%5$s\").reinterpret(LAYOUT.byteSize());\n+                    public static final MemorySegment SEGMENT = %5$sfindOrThrow(\"%4$s\").reinterpret(LAYOUT.byteSize());\n@@ -530,1 +447,2 @@\n-                \"\"\", mangledName, layoutType, layoutString(varType), runtimeHelperName(), lookupName(var));\n+                \"\"\", mangledName, layoutType, layoutString(varType),\n+                    lookupName(var), sourceFileBuilder().FFMUtilsName());\n@@ -570,1 +488,1 @@\n-                            = %3$s.LIBRARY_ARENA.allocateFrom(\"%4$s\");\n+                            = %4$sLIBRARY_ARENA.allocateFrom(\"%3$s\");\n@@ -577,2 +495,2 @@\n-                runtimeHelperName(),\n-                Utils.quote(Objects.toString(value)));\n+                Utils.quote(Objects.toString(value)),\n+                sourceFileBuilder().FFMUtilsName());\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":24,"deletions":106,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -52,0 +52,12 @@\n+    public String getPackageName(){\n+        return packageName;\n+    }\n+\n+    public String layoutUtilsName() {\n+        return getPackageName().isEmpty() ? ToplevelBuilder.LAYOUT_UTILS + \".\" : \"\";\n+    }\n+\n+    public String FFMUtilsName() {\n+        return getPackageName().isEmpty() ? ToplevelBuilder.FFM_UTILS + \".\" : \"\";\n+    }\n+\n@@ -56,0 +68,3 @@\n+        if (!className.equals(\"FFMUtils\") && !className.equals(\"LayoutUtils\") && !packageName.isEmpty()){\n+            sfb.emitStaticImportSection();\n+        }\n@@ -84,0 +99,1 @@\n+\n@@ -87,0 +103,6 @@\n+    void emitStaticImportSection() {\n+        appendLines(String.format(\"\"\"\n+            import static %1$s.FFMUtils.*;\n+            import static %1$s.LayoutUtils.*;\n+            \"\"\", packageName));\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/SourceFileBuilder.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    public static final String PREV_SUFFIX = \"#{PREV_SUFFIX}\";\n+    private static final String PREV_SUFFIX = \"#{PREV_SUFFIX}\";\n@@ -46,0 +46,2 @@\n+    public static final String LAYOUT_UTILS = \"LayoutUtils\";\n+    public static final String FFM_UTILS = \"FFMUtils\";\n@@ -50,0 +52,1 @@\n+    private final List<SourceFileBuilder> commonUtilsBuilders = new ArrayList<>();\n@@ -58,1 +61,2 @@\n-        lastHeader = createFirstHeader(sfb, libs, useSystemLoadLibrary);\n+        lastHeader = createFirstHeader(sfb);\n+        generateCommonBindings(libs, useSystemLoadLibrary);\n@@ -61,2 +65,12 @@\n-    private static HeaderFileBuilder createFirstHeader(SourceFileBuilder sfb, List<Options.Library> libs, boolean useSystemLoadLibrary) {\n-        HeaderFileBuilder first = new HeaderFileBuilder(sfb, String.format(\"%1$s#{SUFFIX}\",sfb.className()), null, sfb.className());\n+    private void generateCommonBindings(List<Options.Library> libs, boolean useSystemLoadLibrary) {\n+        var sfb = SourceFileBuilder.newSourceFile(packageName(), LAYOUT_UTILS);\n+        commonUtilsBuilders.add(sfb);\n+        CommonBindingsBuilder.generate(sfb, LAYOUT_UTILS, mainHeaderClassName());\n+\n+        sfb = SourceFileBuilder.newSourceFile(packageName(), FFM_UTILS);\n+        commonUtilsBuilders.add(sfb);\n+        CommonBindingsBuilder.generate(sfb, FFM_UTILS, mainHeaderClassName(), libs, useSystemLoadLibrary);\n+    }\n+\n+    private static HeaderFileBuilder createFirstHeader(SourceFileBuilder sfb) {\n+        HeaderFileBuilder first = new HeaderFileBuilder(sfb, String.format(\"%1$s%2$s\", sfb.className(), SUFFIX), null, sfb.className());\n@@ -66,21 +80,0 @@\n-        first.emitRuntimeHelperMethods();\n-        first.emitFirstHeaderPreamble(libs, useSystemLoadLibrary);\n-        \/\/ emit basic primitive types\n-        first.appendIndentedLines(\"\"\"\n-\n-            public static final ValueLayout.OfBoolean C_BOOL = (ValueLayout.OfBoolean) Linker.nativeLinker().canonicalLayouts().get(\"bool\");\n-            public static final ValueLayout.OfByte C_CHAR =(ValueLayout.OfByte)Linker.nativeLinker().canonicalLayouts().get(\"char\");\n-            public static final ValueLayout.OfShort C_SHORT = (ValueLayout.OfShort) Linker.nativeLinker().canonicalLayouts().get(\"short\");\n-            public static final ValueLayout.OfInt C_INT = (ValueLayout.OfInt) Linker.nativeLinker().canonicalLayouts().get(\"int\");\n-            public static final ValueLayout.OfLong C_LONG_LONG = (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long long\");\n-            public static final ValueLayout.OfFloat C_FLOAT = (ValueLayout.OfFloat) Linker.nativeLinker().canonicalLayouts().get(\"float\");\n-            public static final ValueLayout.OfDouble C_DOUBLE = (ValueLayout.OfDouble) Linker.nativeLinker().canonicalLayouts().get(\"double\");\n-            public static final AddressLayout C_POINTER = ((AddressLayout) Linker.nativeLinker().canonicalLayouts().get(\"void*\"))\n-                    .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, C_CHAR));\n-            \"\"\");\n-        if (TypeImpl.IS_WINDOWS) {\n-            first.appendIndentedLines(\"public static final ValueLayout.OfInt C_LONG = (ValueLayout.OfInt) Linker.nativeLinker().canonicalLayouts().get(\\\"long\\\");\");\n-            first.appendIndentedLines(\"public static final ValueLayout.OfDouble C_LONG_DOUBLE = (ValueLayout.OfDouble) Linker.nativeLinker().canonicalLayouts().get(\\\"double\\\");\");\n-        } else {\n-            first.appendIndentedLines(\"public static final ValueLayout.OfLong C_LONG = (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get(\\\"long\\\");\");\n-        }\n@@ -121,0 +114,3 @@\n+        \/\/add common bindings files\n+        files.addAll(commonUtilsBuilders.stream()\n+                .map(SourceFileBuilder::toFile).toList());\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ToplevelBuilder.java","additions":21,"deletions":25,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/* Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/* Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-        ValueLayout layout = clinit_global_h.C_INT;\n+        ValueLayout layout = LayoutUtils.C_INT;\n","filename":"test\/jtreg\/generator\/clinitCycles\/TestGlobal.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/* Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/* Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import static test.jextract.clinit.LayoutUtils.*;\n@@ -43,1 +44,1 @@\n-        ValueLayout layout = clinit_struct_h.C_INT;\n+        ValueLayout layout = C_INT;\n","filename":"test\/jtreg\/generator\/clinitCycles\/TestStruct.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/* Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/* Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-        ValueLayout layout = clinit_typedef_h.C_INT;\n+        ValueLayout layout = LayoutUtils.C_INT;\n","filename":"test\/jtreg\/generator\/clinitCycles\/TestTypedef.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,2 +49,2 @@\n-        assertEquals(layout.memberLayouts().get(0), macro_fields_h.C_INT.withName(\"x\"));\n-        assertEquals(layout.memberLayouts().get(1), macro_fields_h.C_INT.withName(\"y\"));\n+        assertEquals(layout.memberLayouts().get(0), LayoutUtils.C_INT.withName(\"x\"));\n+        assertEquals(layout.memberLayouts().get(1), LayoutUtils.C_INT.withName(\"y\"));\n","filename":"test\/jtreg\/generator\/dedup\/TestDedup.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-        assertEquals(layout.memberLayouts().get(0), nestedStructTypedef_h.C_INT.withName(\"x\"));\n+        assertEquals(layout.memberLayouts().get(0), LayoutUtils.C_INT.withName(\"x\"));\n","filename":"test\/jtreg\/generator\/nestedStructTypedef\/TestNestedStructTypedef.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-    static final MemoryLayout ELEM_NESTED_LAYOUT = MemoryLayout.structLayout(nested_types_h.C_INT.withName(\"x\"));\n+    static final MemoryLayout ELEM_NESTED_LAYOUT = MemoryLayout.structLayout(LayoutUtils.C_INT.withName(\"x\"));\n","filename":"test\/jtreg\/generator\/nestedTypes\/TestNestedTypes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-        nested_types_names_h.C_INT.withName(\"y\")\n+            LayoutUtils.C_INT.withName(\"y\")\n@@ -48,1 +48,1 @@\n-        nested_types_names_h.C_INT.withName(\"x\")\n+            LayoutUtils.C_INT.withName(\"x\")\n","filename":"test\/jtreg\/generator\/nestedTypes\/TestNestedTypesNames.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-            MemoryLayout.paddingLayout(nested_types_unsupported_h.C_POINTER.byteSize())\n+            MemoryLayout.paddingLayout(LayoutUtils.C_POINTER.byteSize())\n","filename":"test\/jtreg\/generator\/nestedTypes\/TestNestedTypesUnsupported.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import static test.jextract.test8244412.LayoutUtils.*;\n","filename":"test\/jtreg\/generator\/test8244412\/LibTest8244412Test.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,2 +62,2 @@\n-        assertEquals(seg.byteSize(), C_INT.byteSize()*5);\n-        int[] arr = seg.toArray(C_INT);\n+        assertEquals(seg.byteSize(), LayoutUtils.C_INT.byteSize()*5);\n+        int[] arr = seg.toArray(LayoutUtils.C_INT);\n@@ -75,1 +75,1 @@\n-        byte[] barr = greeting.toArray(C_CHAR);\n+        byte[] barr = greeting.toArray(LayoutUtils.C_CHAR);\n","filename":"test\/jtreg\/generator\/test8245003\/Test8245003.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import static test.jextract.test8246341.LayoutUtils.*;\n","filename":"test\/jtreg\/generator\/test8246341\/LibTest8246341Test.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-            MemorySegment seg = arena.allocateFrom(C_INT, array);\n+            MemorySegment seg = arena.allocateFrom(LayoutUtils.C_INT, array);\n","filename":"test\/jtreg\/generator\/test8252121\/Test8252121.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+import static test.jextract.unsupported.LayoutUtils.*;\n+import static test.jextract.unsupported.FFMUtils.*;\n","filename":"test\/jtreg\/generator\/test8257892\/LibUnsupportedTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import static test.jextract.printf.LayoutUtils.*;\n","filename":"test\/jtreg\/generator\/testPrintf\/TestPrintf.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import static test.jextract.struct.LayoutUtils.*;\n+import static test.jextract.struct.FFMUtils.*;\n","filename":"test\/jtreg\/generator\/testStruct\/LibStructTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}