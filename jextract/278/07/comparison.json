{"files":[{"patch":"@@ -978,14 +978,15 @@\n-| Option                                                       | Meaning                                                      |\n-| :----------------------------------------------------------- | ------------------------------------------------------------ |\n-| `-D --define-macro <macro>=<value>`                          | define `<macro>` to `<value>` (or 1 if `<value>` omitted)          |\n-| `--header-class-name <name>`                                 | name of the generated header class. If this option is not specified, then header class name is derived from the header file name. For example, class \"foo_h\" for header \"foo.h\". If multiple headers are specified, then this option is mandatory. |\n-| `-t, --target-package <package>`                             | target package name for the generated classes. If this option is not specified, then unnamed package is used.  |\n-| `-I, --include-dir <dir>`                                    | append directory to the include search paths. Include search paths are searched in order. For example, if `-I foo -I bar` is specified, header files will be searched in \"foo\" first, then (if nothing is found) in \"bar\".|\n-| `-l, --library <name \\| path>`                               | specify a shared library that should be loaded by the generated header class. If <libspec> starts with `:`, then what follows is interpreted as a library path. Otherwise, `<libspec>` denotes a library name. Examples: <br>`-l GL`<br>`-l :libGL.so.1`<br>`-l :\/usr\/lib\/libGL.so.1`|\n-| `--use-system-load-library`                                  | libraries specified using `-l` are loaded in the loader symbol lookup (using either `System::loadLibrary`, or `System::load`). Useful if the libraries must be loaded from one of the paths in `java.library.path`.|\n-| `--output <path>`                                            | specify where to place generated files                       |\n-| `--dump-includes <String>`                                   | dump included symbols into specified file (see below)        |\n-| `--include-[function,constant,struct,union,typedef,var]<String>` | Include a symbol of the given name and kind in the generated bindings. When one of these options is specified, any symbol that is not matched by any specified filters is omitted from the generated bindings. |\n-| `--version`                                                  | print version information and exit |\n-| `-F <dir>` (macOs only)                                          | specify the framework directory include files. Defaults to the current Mac OS X SDK dir.|\n-| `--framework <framework>` (macOs only)                           | specify the name of the library, path will be expanded to that of the framework folder.|\n+| Option                                                           | Meaning                                                                                                                                                                                                                                                                               |\n+|:-----------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| `-D --define-macro <macro>=<value>`                              | define `<macro>` to `<value>` (or 1 if `<value>` omitted)                                                                                                                                                                                                                             |\n+| `--header-class-name <name>`                                     | name of the generated header class. If this option is not specified, then header class name is derived from the header file name. For example, class \"foo_h\" for header \"foo.h\". If multiple headers are specified, then this option is mandatory.                                    |\n+| `-t, --target-package <package>`                                 | target package name for the generated classes. If this option is not specified, then unnamed package is used.                                                                                                                                                                         |\n+| `-I, --include-dir <dir>`                                        | append directory to the include search paths. Include search paths are searched in order. For example, if `-I foo -I bar` is specified, header files will be searched in \"foo\" first, then (if nothing is found) in \"bar\".                                                            |\n+| `-l, --library <name \\| path>`                                   | specify a shared library that should be loaded by the generated header class. If <libspec> starts with `:`, then what follows is interpreted as a library path. Otherwise, `<libspec>` denotes a library name. Examples: <br>`-l GL`<br>`-l :libGL.so.1`<br>`-l :\/usr\/lib\/libGL.so.1` |\n+| `--use-system-load-library`                                      | libraries specified using `-l` are loaded in the loader symbol lookup (using either `System::loadLibrary`, or `System::load`). Useful if the libraries must be loaded from one of the paths in `java.library.path`.                                                                   |\n+| `--output <path>`                                                | specify where to place generated files                                                                                                                                                                                                                                                |\n+| `--dump-includes <String>`                                       | dump included symbols into specified file (see below)                                                                                                                                                                                                                                 |\n+| `--include-[function,constant,struct,union,typedef,var]<String>` | Include a symbol of the given name and kind in the generated bindings. When one of these options is specified, any symbol that is not matched by any specified filters is omitted from the generated bindings.                                                                        |\n+| `--symbols-class-name <name>`                                          | override the name of the root header class                                                                                                                                                                                                                                            |\n+| `--version`                                                      | print version information and exit                                                                                                                                                                                                                                                    |\n+| `-F <dir>` (macOs only)                                          | specify the framework directory include files. Defaults to the current Mac OS X SDK dir.                                                                                                                                                                                              |\n+| `--framework <framework>` (macOs only)                           | specify the name of the library, path will be expanded to that of the framework folder.                                                                                                                                                                                               |\n","filename":"doc\/GUIDE.md","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -140,1 +140,2 @@\n-                List.of(OutputFactory.generateWrapped(transformedDecl, targetPkg, libs, useSystemLoadLibrary));\n+                List.of(OutputFactory.generateWrapped(transformedDecl, targetPkg, libs, useSystemLoadLibrary,\n+                        includeHelper.getSharedSymbolsFile()));\n@@ -337,1 +338,1 @@\n-                   for (String alias : spec.aliases()) {\n+                   for (String _ : spec.aliases()) {\n@@ -359,0 +360,1 @@\n+        parser.accepts(\"--symbols-class-name\", \"help.shared.symbols\", true);\n@@ -402,1 +404,1 @@\n-                Files.lines(compileFlagsTxt).forEach(opt -> builder.addClangArg(opt));\n+                Files.lines(compileFlagsTxt).forEach(builder::addClangArg);\n@@ -442,0 +444,4 @@\n+        if (optionSet.has(\"--symbols-class-name\")) {\n+            builder.setSharedUtilsName(optionSet.valueOf(\"--symbols-class-name\"));\n+        }\n+\n@@ -474,1 +480,1 @@\n-        if (optionSet.nonOptionArguments().size() == 0) {\n+        if (optionSet.nonOptionArguments().isEmpty()) {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/JextractTool.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,0 +163,9 @@\n+    final void emitPrivateConstructor() {\n+        appendIndentedLines(\"\"\"\n+\n+            private %1$s() {\n+                \/\/ Should not be called directly\n+            }\n+            \"\"\", className);\n+    }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ClassSourceBuilder.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        super(builder, isNested ? \"public static\" : \"public\", Kind.CLASS, className, null, enclosing, runtimeHelperName);\n+        super(builder, isNested ? \"public final static\" : \"public final\", Kind.CLASS, className, null, enclosing, runtimeHelperName);\n@@ -58,1 +58,1 @@\n-        fib.emitDefaultConstructor();\n+        fib.emitPrivateConstructor();\n@@ -102,1 +102,1 @@\n-        String paramStr = methodType.parameterCount() != 0 ? String.format(\",%1$s\", paramExprs()) : \"\";\n+        String paramStr = methodType.parameterCount() != 0 ? String.format(\", %1$s\", paramExprs()) : \"\";\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -354,0 +354,5 @@\n+    void emitLibaryArena(){appendIndentedLines(\"\"\"\n+\n+            static final Arena LIBRARY_ARENA = Arena.ofAuto();\"\"\");\n+    }\n+\n@@ -357,1 +362,0 @@\n-            static final Arena LIBRARY_ARENA = Arena.ofAuto();\n@@ -391,0 +395,20 @@\n+    void emitBasicPrimitiveTypes(){\n+        appendIndentedLines(\"\"\"\n+\n+            public static final ValueLayout.OfBoolean C_BOOL = (ValueLayout.OfBoolean) Linker.nativeLinker().canonicalLayouts().get(\"bool\");\n+            public static final ValueLayout.OfByte C_CHAR =(ValueLayout.OfByte)Linker.nativeLinker().canonicalLayouts().get(\"char\");\n+            public static final ValueLayout.OfShort C_SHORT = (ValueLayout.OfShort) Linker.nativeLinker().canonicalLayouts().get(\"short\");\n+            public static final ValueLayout.OfInt C_INT = (ValueLayout.OfInt) Linker.nativeLinker().canonicalLayouts().get(\"int\");\n+            public static final ValueLayout.OfLong C_LONG_LONG = (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long long\");\n+            public static final ValueLayout.OfFloat C_FLOAT = (ValueLayout.OfFloat) Linker.nativeLinker().canonicalLayouts().get(\"float\");\n+            public static final ValueLayout.OfDouble C_DOUBLE = (ValueLayout.OfDouble) Linker.nativeLinker().canonicalLayouts().get(\"double\");\n+            public static final AddressLayout C_POINTER = ((AddressLayout) Linker.nativeLinker().canonicalLayouts().get(\"void*\"))\n+                    .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, C_CHAR));\n+            \"\"\");\n+        if (TypeImpl.IS_WINDOWS) {\n+            appendIndentedLines(\"public static final ValueLayout.OfInt C_LONG = (ValueLayout.OfInt) Linker.nativeLinker().canonicalLayouts().get(\\\"long\\\");\");\n+            appendIndentedLines(\"public static final ValueLayout.OfDouble C_LONG_DOUBLE = (ValueLayout.OfDouble) Linker.nativeLinker().canonicalLayouts().get(\\\"double\\\");\");\n+        } else {\n+            appendIndentedLines(\"public static final ValueLayout.OfLong C_LONG = (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get(\\\"long\\\");\");\n+        }\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,0 +87,5 @@\n+    public String sharedSymbolsFile;\n+\n+    public String getSharedSymbolsFile() {\n+        return sharedSymbolsFile;\n+    }\n@@ -125,1 +130,1 @@\n-            Set<String> names = includesSymbolNamesByKind.computeIfAbsent(kind, (_unused) -> new HashSet<>());\n+            Set<String> names = includesSymbolNamesByKind.computeIfAbsent(kind, _unused -> new HashSet<>());\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/IncludeHelper.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,0 +105,4 @@\n+        public void setSharedUtilsName(String sharedSymbolsFile) {\n+            includeHelper.sharedSymbolsFile = sharedSymbolsFile;\n+        }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Options.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,3 @@\n-                                                   List<Options.Library> libs, boolean useSystemLoadLibrary) {\n+                                                   List<Options.Library> libs,\n+                                                   boolean useSystemLoadLibrary,\n+                                                   String sharedSymbolsFile) {\n@@ -50,1 +52,2 @@\n-        ToplevelBuilder toplevelBuilder = new ToplevelBuilder(pkgName, clsName, libs, useSystemLoadLibrary);\n+        ToplevelBuilder toplevelBuilder = new ToplevelBuilder(pkgName, clsName,\n+                libs, useSystemLoadLibrary, sharedSymbolsFile);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+    private static String SHARED;\n@@ -53,2 +54,2 @@\n-    ToplevelBuilder(String packageName, String headerClassName,\n-                    List<Options.Library> libs, boolean useSystemLoadLibrary) {\n+    ToplevelBuilder(String packageName, String headerClassName, List<Options.Library> libs,\n+                    boolean useSystemLoadLibrary, String sharedSymbolsFile) {\n@@ -56,1 +57,20 @@\n-        SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName, headerClassName);\n+        SHARED = sharedSymbolsFile != null ?\n+                sharedSymbolsFile :\n+                headerDesc.displayName() + \"$shared\";\n+\n+        initSharedClass();\n+        initFirstHeader(libs, useSystemLoadLibrary);\n+    }\n+\n+    private void initSharedClass() {\n+        SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName(), SHARED);\n+        HeaderFileBuilder shared = initHeader(sfb, SHARED, null, null);\n+        otherBuilders.add(sfb);\n+        shared.emitBasicPrimitiveTypes();\n+        shared.emitRuntimeHelperMethods();\n+        shared.classEnd();\n+    }\n+\n+    private void initFirstHeader(List<Options.Library> libs, boolean useSystemLoadLibrary) {\n+        String base = headerDesc.displayName();\n+        SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName(), base);\n@@ -58,1 +78,9 @@\n-        lastHeader = createFirstHeader(sfb, libs, useSystemLoadLibrary);\n+\n+        lastHeader = initHeader(\n+                sfb,\n+                base + SUFFIX,\n+                SHARED,\n+                base\n+        );\n+        lastHeader.emitLibaryArena();\n+        lastHeader.emitFirstHeaderPreamble(libs, useSystemLoadLibrary);\n@@ -61,27 +89,27 @@\n-    private static HeaderFileBuilder createFirstHeader(SourceFileBuilder sfb, List<Options.Library> libs, boolean useSystemLoadLibrary) {\n-        HeaderFileBuilder first = new HeaderFileBuilder(sfb, String.format(\"%1$s#{SUFFIX}\",sfb.className()), null, sfb.className());\n-        first.appendBlankLine();\n-        first.classBegin();\n-        first.emitDefaultConstructor();\n-        first.emitRuntimeHelperMethods();\n-        first.emitFirstHeaderPreamble(libs, useSystemLoadLibrary);\n-        \/\/ emit basic primitive types\n-        first.appendIndentedLines(\"\"\"\n-\n-            public static final ValueLayout.OfBoolean C_BOOL = (ValueLayout.OfBoolean) Linker.nativeLinker().canonicalLayouts().get(\"bool\");\n-            public static final ValueLayout.OfByte C_CHAR =(ValueLayout.OfByte)Linker.nativeLinker().canonicalLayouts().get(\"char\");\n-            public static final ValueLayout.OfShort C_SHORT = (ValueLayout.OfShort) Linker.nativeLinker().canonicalLayouts().get(\"short\");\n-            public static final ValueLayout.OfInt C_INT = (ValueLayout.OfInt) Linker.nativeLinker().canonicalLayouts().get(\"int\");\n-            public static final ValueLayout.OfLong C_LONG_LONG = (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long long\");\n-            public static final ValueLayout.OfFloat C_FLOAT = (ValueLayout.OfFloat) Linker.nativeLinker().canonicalLayouts().get(\"float\");\n-            public static final ValueLayout.OfDouble C_DOUBLE = (ValueLayout.OfDouble) Linker.nativeLinker().canonicalLayouts().get(\"double\");\n-            public static final AddressLayout C_POINTER = ((AddressLayout) Linker.nativeLinker().canonicalLayouts().get(\"void*\"))\n-                    .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, C_CHAR));\n-            \"\"\");\n-        if (TypeImpl.IS_WINDOWS) {\n-            first.appendIndentedLines(\"public static final ValueLayout.OfInt C_LONG = (ValueLayout.OfInt) Linker.nativeLinker().canonicalLayouts().get(\\\"long\\\");\");\n-            first.appendIndentedLines(\"public static final ValueLayout.OfDouble C_LONG_DOUBLE = (ValueLayout.OfDouble) Linker.nativeLinker().canonicalLayouts().get(\\\"double\\\");\");\n-        } else {\n-            first.appendIndentedLines(\"public static final ValueLayout.OfLong C_LONG = (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get(\\\"long\\\");\");\n-        }\n-        return first;\n+    \/**\n+     * Shared boilerplate: blank line + classBegin + default constructor\n+     *\/\n+    private HeaderFileBuilder initHeader(SourceFileBuilder sfb, String classNameWithSuffix,\n+                                         String superClass, String extendsClass) {\n+        HeaderFileBuilder hfb = new HeaderFileBuilder(sfb, classNameWithSuffix,\n+                superClass, extendsClass);\n+        hfb.appendBlankLine();\n+        hfb.classBegin();\n+        hfb.emitDefaultConstructor();\n+        return hfb;\n+    }\n+\n+    \/**\n+     * Creates a new header file chunk\n+     *\/\n+    private HeaderFileBuilder newHeaderChunk() {\n+        String base = headerDesc.displayName();\n+        SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName(), base);\n+        HeaderFileBuilder hfb = initHeader(\n+                sfb,\n+                base + SUFFIX,\n+                base + PREV_SUFFIX,\n+                base\n+        );\n+        headerBuilders.add(sfb);\n+        return hfb;\n@@ -181,4 +209,0 @@\n-            SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName(), mainHeaderClassName());\n-            String className = mainHeaderClassName() + SUFFIX;\n-            HeaderFileBuilder headerFileBuilder = new HeaderFileBuilder(sfb, className,\n-                    mainHeaderClassName() + PREV_SUFFIX, mainHeaderClassName());\n@@ -186,5 +210,1 @@\n-            headerFileBuilder.appendBlankLine();\n-            headerFileBuilder.classBegin();\n-            headerFileBuilder.emitDefaultConstructor();\n-            headerBuilders.add(sfb);\n-            lastHeader = headerFileBuilder;\n+            lastHeader = newHeaderChunk();\n@@ -192,1 +212,0 @@\n-            return headerFileBuilder;\n@@ -195,1 +214,0 @@\n-            return lastHeader;\n@@ -197,0 +215,1 @@\n+        return lastHeader;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ToplevelBuilder.java","additions":61,"deletions":42,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-#  Copyright (c) 2020, 2025 Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+help.shared.symbols=override the name of the root header class\n@@ -87,0 +88,1 @@\n+--symbols-class-name <name>            override the name of the root header class                   \\n\\\n","filename":"src\/main\/resources\/org\/openjdk\/jextract\/impl\/resources\/Messages.properties","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import java.nio.file.Path;\n+import testlib.TestUtils;\n+import testlib.JextractToolRunner;\n+import test.jextract.sharedSymbolsHeader.*;\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @bug 7903933\n+ * @summary check that header containg the shared symbols was created with the specified name\n+ * @library \/lib\n+ * @build testlib.JextractToolRunner testlib.TestUtils\n+ * @run main\/othervm JtregJextract -t test.jextract.sharedSymbolsHeader sharedSymbolsHeader.h\n+ * @run testng\/othervm TestSharedSymbolsHeader\n+ *\/\n+public class TestSharedSymbolsHeader extends JextractToolRunner {\n+    @Test\n+    public void testSplit() {\n+        Path splitOutput = getOutputFilePath(\"sharedSymbolsHeader\");\n+        Path splitH = getInputFilePath(\"sharedSymbolsHeader.h\");\n+        runAndCompile(splitOutput, splitH.toString());\n+        try(TestUtils.Loader loader = TestUtils.classLoader(splitOutput)) {\n+            assertNotNull(loader.loadClass(\"sharedSymbolsHeader_h$shared\"));\n+        } finally {\n+            TestUtils.deleteDir(splitOutput);\n+        }\n+    }\n+}\n","filename":"test\/jtreg\/generator\/sharedSymbolsHeader\/TestSharedSymbolsHeader.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,2 @@\n-void func(int);\n+typedef int T;\n+typedef char* P1;\n","filename":"test\/jtreg\/generator\/sharedSymbolsHeader\/sharedSymbolsHeader.h","additions":3,"deletions":2,"binary":false,"changes":5,"previous_filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/JDK-8248474.h","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -195,1 +195,1 @@\n-        checkDefaultConstructor(fpClass);\n+        checkPrivateConstructor(fpClass);\n@@ -231,0 +231,9 @@\n+\n+    private void checkPrivateConstructor(Class<?> cls) {\n+        try {\n+            Constructor<?> c = cls.getDeclaredConstructor();\n+            assertEquals(c.getModifiers(), Modifier.PRIVATE, \"Unexpected constructor modifiers\");\n+        } catch (ReflectiveOperationException ex) {\n+            fail(\"Private constructor not found!\");\n+        }\n+    }\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/TestClassGeneration.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"}]}