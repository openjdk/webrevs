{"files":[{"patch":"@@ -989,0 +989,1 @@\n+| `--sharable-utils <name>`                                        | generate shared utility class for common layouts and methods |\n@@ -991,1 +992,1 @@\n-| `-framework <framework>` (macOs only)                            | specify the name of the library, path will be expanded to that of the framework folder.|\n+| `--framework <framework>` (macOs only)                           | specify the name of the library, path will be expanded to that of the framework folder.|\n","filename":"doc\/GUIDE.md","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-jextract -t opengl -framework GLUT \\\n-  -framework OpenGL \\\n+jextract -t opengl --framework GLUT \\\n+  --framework OpenGL \\\n","filename":"samples\/opengl\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -140,1 +140,2 @@\n-                List.of(OutputFactory.generateWrapped(transformedDecl, targetPkg, libs, useSystemLoadLibrary));\n+                List.of(OutputFactory.generateWrapped(transformedDecl, targetPkg,\n+                        libs, useSystemLoadLibrary, includeHelper.getSharableItems()));\n@@ -337,1 +338,1 @@\n-                   for (String alias : spec.aliases()) {\n+                   for (String _ : spec.aliases()) {\n@@ -359,0 +360,1 @@\n+        parser.accepts(\"--sharable-items\", \"help.sharable.items\", true);\n@@ -373,1 +375,1 @@\n-            parser.accepts(\"-framework\", \"help.framework.library.path\", true);\n+            parser.accepts(\"--framework\", \"help.framework.library.path\", true);\n@@ -402,1 +404,1 @@\n-                Files.lines(compileFlagsTxt).forEach(opt -> builder.addClangArg(opt));\n+                Files.lines(compileFlagsTxt).forEach(builder::addClangArg);\n@@ -442,0 +444,4 @@\n+        if (optionSet.has(\"--sharable-items\")) {\n+            builder.useSharableItems(optionSet.valueOf(\"--sharable-items\"));\n+        }\n+\n@@ -474,1 +480,1 @@\n-        if (optionSet.nonOptionArguments().size() == 0) {\n+        if (optionSet.nonOptionArguments().isEmpty()) {\n@@ -517,1 +523,1 @@\n-            if (options.includeHelper.dumpIncludesFile != null) {\n+            if (options.includeHelper.getDumpIncludesFile() != null) {\n@@ -539,2 +545,5 @@\n-        if (optionSet.has(\"-\" + optionString)) {\n-            for (String lib : optionSet.valuesOf(\"-\" + optionString)) {\n+        String cmdOption = optionString.length() < 3 ?\n+                \"-\" + optionString :\n+                \"--\" + optionString;\n+        if (optionSet.has(cmdOption)) {\n+            for (String lib : optionSet.valuesOf(cmdOption)) {\n@@ -542,1 +551,1 @@\n-                    String spec = optionString.equals(\"framework\") ?\n+                    String spec = cmdOption.equals(\"--framework\") ?\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/JextractTool.java","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,9 +163,0 @@\n-    final void emitPrivateConstructor() {\n-        appendIndentedLines(\"\"\"\n-\n-            private %1$s() {\n-                \/\/ Should not be called directly\n-            }\n-            \"\"\", className);\n-    }\n-\n@@ -212,4 +203,2 @@\n-            case Declared d when Utils.isStructOrUnion(d) ->\n-                    alignIfNeeded(JavaName.getFullNameOrThrow(d.tree()) + \".layout()\", ClangAlignOf.getOrThrow(d.tree()) \/ 8, align);\n-            case Delegated d when d.kind() == Delegated.Kind.POINTER ->\n-                    alignIfNeeded(sb.layoutUtilsName() + \"C_POINTER\", 8, align);\n+            case Declared d when Utils.isStructOrUnion(d) -> alignIfNeeded(JavaName.getFullNameOrThrow(d.tree()) + \".layout()\", ClangAlignOf.getOrThrow(d.tree()) \/ 8, align);\n+            case Delegated d when d.kind() == Delegated.Kind.POINTER -> alignIfNeeded(runtimeHelperName() + \".C_POINTER\", 8, align);\n@@ -217,3 +206,2 @@\n-            case Function _ -> alignIfNeeded(sb.layoutUtilsName() + \"C_POINTER\", 8, align);\n-            case Array a ->\n-                    String.format(\"MemoryLayout.sequenceLayout(%1$d, %2$s)\", a.elementCount().orElse(0L), layoutString(a.elementType(), align));\n+            case Function _ -> alignIfNeeded(runtimeHelperName() + \".C_POINTER\", 8, align);\n+            case Array a -> String.format(\"MemoryLayout.sequenceLayout(%1$d, %2$s)\", a.elementCount().orElse(0L), layoutString(a.elementType(), align));\n@@ -258,8 +246,8 @@\n-            case Bool -> sb.layoutUtilsName() + \"C_BOOL\";\n-            case Char -> sb.layoutUtilsName() + \"C_CHAR\";\n-            case Short -> alignIfNeeded(sb.layoutUtilsName() + \"C_SHORT\", 2, align);\n-            case Int -> alignIfNeeded(sb.layoutUtilsName() + \"C_INT\", 4, align);\n-            case Long -> alignIfNeeded(sb.layoutUtilsName() + \"C_LONG\", TypeImpl.IS_WINDOWS ? 4 : 8, align);\n-            case LongLong -> alignIfNeeded(sb.layoutUtilsName() + \"C_LONG_LONG\", 8, align);\n-            case Float -> alignIfNeeded(sb.layoutUtilsName() + \"C_FLOAT\", 4, align);\n-            case Double -> alignIfNeeded(sb.layoutUtilsName() + \"C_DOUBLE\", 8, align);\n+            case Bool -> runtimeHelperName() + \".C_BOOL\";\n+            case Char -> runtimeHelperName() + \".C_CHAR\";\n+            case Short -> alignIfNeeded(runtimeHelperName() + \".C_SHORT\", 2, align);\n+            case Int -> alignIfNeeded(runtimeHelperName() + \".C_INT\", 4, align);\n+            case Long -> alignIfNeeded(runtimeHelperName() + \".C_LONG\", TypeImpl.IS_WINDOWS ? 4 : 8, align);\n+            case LongLong -> alignIfNeeded(runtimeHelperName() + \".C_LONG_LONG\", 8, align);\n+            case Float -> alignIfNeeded(runtimeHelperName() + \".C_FLOAT\", 4, align);\n+            case Double -> alignIfNeeded(runtimeHelperName() + \".C_DOUBLE\", 8, align);\n@@ -267,1 +255,1 @@\n-                    alignIfNeeded(sb.layoutUtilsName() + \"C_LONG_DOUBLE\", 8, align) :\n+                    alignIfNeeded(runtimeHelperName() + \".C_LONG_DOUBLE\", 8, align) :\n@@ -277,1 +265,1 @@\n-                String.format(\"%3$salign(%1$s, %2$d)\", layoutPrefix, expectedAlign, sourceFileBuilder().FFMUtilsName()) :\n+                String.format(\"%1$s.align(%2$s, %3$d)\", runtimeHelperName(), layoutPrefix, expectedAlign) :\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ClassSourceBuilder.java","additions":15,"deletions":27,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1,171 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.jextract.impl;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-\/**\n- * Moving common layouts and static methods not relevant to component areas into a centralized location\n- *\/\n-\n-final class CommonBindingsBuilder extends ClassSourceBuilder {\n-    private CommonBindingsBuilder(SourceFileBuilder builder, String className, String runtimeHelperName) {\n-        super(builder, \"public final\", Kind.CLASS, className, null, null, runtimeHelperName);\n-    }\n-\n-    public static void generate(SourceFileBuilder builder, String className, String runtimeHelperName) {\n-        CommonBindingsBuilder cbd = new CommonBindingsBuilder(builder, className, runtimeHelperName);\n-        cbd.appendBlankLine();\n-        cbd.classBegin();\n-        cbd.emitPrivateConstructor();\n-        cbd.appendBlankLine();\n-        cbd.emitPrimitiveTypes();\n-        cbd.classEnd();\n-    }\n-\n-    public static void generate(SourceFileBuilder builder, String className, String runtimeHelperName, List<Options.Library> libs, Boolean useSystemLoadLibrary) {\n-        CommonBindingsBuilder cbd = new CommonBindingsBuilder(builder, className, runtimeHelperName);\n-        cbd.appendBlankLine();\n-        cbd.classBegin();\n-        cbd.emitPrivateConstructor();\n-        cbd.emitCommonFinalFields();\n-        cbd.emitFirstHeaderPreamble(libs, useSystemLoadLibrary);\n-        cbd.appendBlankLine();\n-        cbd.emitRuntimeHelperMethods();\n-        cbd.classEnd();\n-    }\n-\n-    \/\/ emit basic primitive types\n-    private void emitPrimitiveTypes() {\n-        appendIndentedLines(\"\"\"\n-            public static final ValueLayout.OfBoolean C_BOOL = (ValueLayout.OfBoolean) Linker.nativeLinker().canonicalLayouts().get(\"bool\");\n-            public static final ValueLayout.OfByte C_CHAR =(ValueLayout.OfByte)Linker.nativeLinker().canonicalLayouts().get(\"char\");\n-            public static final ValueLayout.OfShort C_SHORT = (ValueLayout.OfShort) Linker.nativeLinker().canonicalLayouts().get(\"short\");\n-            public static final ValueLayout.OfInt C_INT = (ValueLayout.OfInt) Linker.nativeLinker().canonicalLayouts().get(\"int\");\n-            public static final ValueLayout.OfLong C_LONG_LONG = (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long long\");\n-            public static final ValueLayout.OfFloat C_FLOAT = (ValueLayout.OfFloat) Linker.nativeLinker().canonicalLayouts().get(\"float\");\n-            public static final ValueLayout.OfDouble C_DOUBLE = (ValueLayout.OfDouble) Linker.nativeLinker().canonicalLayouts().get(\"double\");\n-            public static final AddressLayout C_POINTER = ((AddressLayout) Linker.nativeLinker().canonicalLayouts().get(\"void*\"))\n-                    .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, C_CHAR));\n-            \"\"\");\n-        if (TypeImpl.IS_WINDOWS) {\n-            appendIndentedLines(\"public static final ValueLayout.OfInt C_LONG = (ValueLayout.OfInt) Linker.nativeLinker().canonicalLayouts().get(\\\"long\\\");\");\n-            appendIndentedLines(\"public static final ValueLayout.OfDouble C_LONG_DOUBLE = (ValueLayout.OfDouble) Linker.nativeLinker().canonicalLayouts().get(\\\"double\\\");\");\n-        } else {\n-            appendIndentedLines(\"public static final ValueLayout.OfLong C_LONG = (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get(\\\"long\\\");\");\n-        }\n-    }\n-\n-    void emitFirstHeaderPreamble(List<Options.Library> libraries, boolean useSystemLoadLibrary) {\n-        List<String> lookups = new ArrayList<>();\n-        \/\/ if legacy library loading is selected, load libraries (if any) into current loader\n-        if (useSystemLoadLibrary) {\n-            appendBlankLine();\n-            appendIndentedLines(\"\"\"\n-\n-                static {\n-                \"\"\");\n-            incrAlign();\n-            for (Options.Library lib : libraries) {\n-                String method = lib.specKind() == Options.Library.SpecKind.PATH ? \"load\" : \"loadLibrary\";\n-                appendIndentedLines(\"System.%1$s(\\\"%2$s\\\");\", method, lib.toQuotedName());\n-            }\n-            decrAlign();\n-            appendIndentedLines(\"\"\"\n-                }\n-                \"\"\");\n-        } else {\n-            \/\/ otherwise, add a library lookup per library (if any)\n-            libraries.stream() \/\/ add library lookups (if any)\n-                    .map(l -> l.specKind() == Options.Library.SpecKind.PATH ?\n-                            String.format(\"SymbolLookup.libraryLookup(\\\"%1$s\\\", LIBRARY_ARENA)\", l.toQuotedName()) :\n-                            String.format(\"SymbolLookup.libraryLookup(System.mapLibraryName(\\\"%1$s\\\"), LIBRARY_ARENA)\", l.toQuotedName()))\n-                    .collect(Collectors.toCollection(() -> lookups));\n-        }\n-\n-        lookups.add(\"SymbolLookup.loaderLookup()\"); \/\/ fallback to loader lookup\n-        lookups.add(\"Linker.nativeLinker().defaultLookup()\"); \/\/ fallback to native lookup\n-\n-        \/\/ wrap all lookups (but the first) with \".or(...)\"\n-        List<String> lookupCalls = new ArrayList<>();\n-        boolean isFirst = true;\n-        for (String lookup : lookups) {\n-            lookupCalls.add(isFirst ? lookup : String.format(\".or(%1$s)\", lookup));\n-            isFirst = false;\n-        }\n-\n-        \/\/ chain all the calls together into a combined symbol lookup\n-        appendBlankLine();\n-        appendIndentedLines(lookupCalls.stream()\n-                .collect(Collectors.joining(String.format(\"\\n%1$s\", indentString(2)), \"static final SymbolLookup SYMBOL_LOOKUP = \", \";\")));\n-    }\n-\n-    private void emitCommonFinalFields() {\n-        appendIndentedLines(\"\"\"\n-            static final Arena LIBRARY_ARENA = Arena.ofAuto();\n-            static final boolean TRACE_DOWNCALLS = Boolean.getBoolean(\"jextract.trace.downcalls\");\n-\n-                \"\"\");\n-    }\n-    private void emitRuntimeHelperMethods() {\n-        appendIndentedLines(\"\"\"\n-            static void traceDowncall(String name, Object... args) {\n-                 String traceArgs = Arrays.stream(args)\n-                               .map(Object::toString)\n-                               .collect(Collectors.joining(\", \"));\n-                 System.out.printf(\"%s(%s)\\\\n\", name, traceArgs);\n-            }\n-\n-            static MemorySegment findOrThrow(String symbol) {\n-                return SYMBOL_LOOKUP.findOrThrow(symbol);\n-            }\n-\n-            static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n-                try {\n-                    return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());\n-                } catch (ReflectiveOperationException ex) {\n-                    throw new AssertionError(ex);\n-                }\n-            }\n-\n-            static MemoryLayout align(MemoryLayout layout, long align) {\n-                return switch (layout) {\n-                    case PaddingLayout p -> p;\n-                    case ValueLayout v -> v.withByteAlignment(align);\n-                    case GroupLayout g -> {\n-                        MemoryLayout[] alignedMembers = g.memberLayouts().stream()\n-                                .map(m -> align(m, align)).toArray(MemoryLayout[]::new);\n-                        yield g instanceof StructLayout ?\n-                                MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);\n-                    }\n-                    case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));\n-                };\n-            }\n-            \"\"\");\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/CommonBindingsBuilder.java","additions":0,"deletions":171,"binary":false,"changes":171,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-            private static final MethodHandle UP$MH = %1$supcallHandle(%2$s.%3$s.class, \"apply\", $DESC);\n+            private static final MethodHandle UP$MH = %1$s.upcallHandle(%2$s.%3$s.class, \"apply\", $DESC);\n@@ -95,1 +95,1 @@\n-            \"\"\", sourceFileBuilder().FFMUtilsName(), className(), fiName);\n+            \"\"\", runtimeHelperName(), className(), fiName);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-                    public static final MemorySegment ADDR = %4$sfindOrThrow(\"%3$s\");\n+                    public static final MemorySegment ADDR = %3$s.findOrThrow(\"%4$s\");\n@@ -188,1 +188,1 @@\n-                    lookupName(decl), sourceFileBuilder().FFMUtilsName());\n+                    runtimeHelperName(), lookupName(decl));\n@@ -216,2 +216,2 @@\n-                    if (%8$sTRACE_DOWNCALLS) {\n-                        %8$straceDowncall(%5$s);\n+                    if (TRACE_DOWNCALLS) {\n+                        traceDowncall(%5$s);\n@@ -226,2 +226,1 @@\n-            holderClass, traceArgList, returnWithCast, paramList,\n-            sourceFileBuilder().FFMUtilsName());\n+            holderClass, traceArgList, returnWithCast, paramList);\n@@ -236,1 +235,1 @@\n-                    private static final MemorySegment ADDR = %4$sfindOrThrow(\"%3$s\");\n+                    private static final MemorySegment ADDR = %3$s.findOrThrow(\"%4$s\");\n@@ -242,1 +241,1 @@\n-                    private %1$s(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {\n+                    private %5$s(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {\n@@ -248,1 +247,1 @@\n-                    lookupName(decl), sourceFileBuilder().FFMUtilsName());\n+                    runtimeHelperName(), lookupName(decl), invokerClassName);\n@@ -287,2 +286,2 @@\n-                            if (%6$sTRACE_DOWNCALLS) {\n-                                %6$straceDowncall(%3$s);\n+                            if (TRACE_DOWNCALLS) {\n+                                traceDowncall(%3$s);\n@@ -298,2 +297,1 @@\n-                \"\"\", retType, paramExprs, traceArgList,\n-                    returnWithCast, paramList, sourceFileBuilder().FFMUtilsName());\n+                \"\"\", retType, paramExprs, traceArgList, returnWithCast, paramList);\n@@ -312,0 +310,105 @@\n+    void emitFirstHeaderPreamble(List<Options.Library> libraries, boolean useSystemLoadLibrary) {\n+        List<String> lookups = new ArrayList<>();\n+        \/\/ if legacy library loading is selected, load libraries (if any) into current loader\n+        if (useSystemLoadLibrary) {\n+            appendBlankLine();\n+            appendIndentedLines(\"\"\"\n+\n+                static {\n+                \"\"\");\n+            incrAlign();\n+            for (Options.Library lib : libraries) {\n+                String method = lib.specKind() == Options.Library.SpecKind.PATH ? \"load\" : \"loadLibrary\";\n+                appendIndentedLines(\"System.%1$s(\\\"%2$s\\\");\", method, lib.toQuotedName());\n+            }\n+            decrAlign();\n+            appendIndentedLines(\"\"\"\n+                }\n+                \"\"\");\n+        } else {\n+            \/\/ otherwise, add a library lookup per library (if any)\n+            libraries.stream() \/\/ add library lookups (if any)\n+                    .map(l -> l.specKind() == Options.Library.SpecKind.PATH ?\n+                            String.format(\"SymbolLookup.libraryLookup(\\\"%1$s\\\", LIBRARY_ARENA)\", l.toQuotedName()) :\n+                            String.format(\"SymbolLookup.libraryLookup(System.mapLibraryName(\\\"%1$s\\\"), LIBRARY_ARENA)\", l.toQuotedName()))\n+                    .collect(Collectors.toCollection(() -> lookups));\n+        }\n+\n+        lookups.add(\"SymbolLookup.loaderLookup()\"); \/\/ fallback to loader lookup\n+        lookups.add(\"Linker.nativeLinker().defaultLookup()\"); \/\/ fallback to native lookup\n+\n+        \/\/ wrap all lookups (but the first) with \".or(...)\"\n+        List<String> lookupCalls = new ArrayList<>();\n+        boolean isFirst = true;\n+        for (String lookup : lookups) {\n+            lookupCalls.add(isFirst ? lookup : String.format(\".or(%1$s)\", lookup));\n+            isFirst = false;\n+        }\n+\n+        \/\/ chain all the calls together into a combined symbol lookup\n+        appendBlankLine();\n+        appendIndentedLines(lookupCalls.stream()\n+                .collect(Collectors.joining(String.format(\"\\n%1$s\", indentString(2)), \"static final SymbolLookup SYMBOL_LOOKUP = \", \";\")));\n+    }\n+\n+    void emitRuntimeHelperMethods() {\n+        appendIndentedLines(\"\"\"\n+\n+            static final Arena LIBRARY_ARENA = Arena.ofAuto();\n+            static final boolean TRACE_DOWNCALLS = Boolean.getBoolean(\"jextract.trace.downcalls\");\n+\n+            static void traceDowncall(String name, Object... args) {\n+                 String traceArgs = Arrays.stream(args)\n+                               .map(Object::toString)\n+                               .collect(Collectors.joining(\", \"));\n+                 System.out.printf(\"%s(%s)\\\\n\", name, traceArgs);\n+            }\n+\n+            static MemorySegment findOrThrow(String symbol) {\n+                return SYMBOL_LOOKUP.findOrThrow(symbol);\n+            }\n+\n+            static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n+                try {\n+                    return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());\n+                } catch (ReflectiveOperationException ex) {\n+                    throw new AssertionError(ex);\n+                }\n+            }\n+\n+            static MemoryLayout align(MemoryLayout layout, long align) {\n+                return switch (layout) {\n+                    case PaddingLayout p -> p;\n+                    case ValueLayout v -> v.withByteAlignment(align);\n+                    case GroupLayout g -> {\n+                        MemoryLayout[] alignedMembers = g.memberLayouts().stream()\n+                                .map(m -> align(m, align)).toArray(MemoryLayout[]::new);\n+                        yield g instanceof StructLayout ?\n+                                MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);\n+                    }\n+                    case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));\n+                };\n+            }\n+            \"\"\");\n+    }\n+\n+    void emitBasicPrimitiveTypes(){\n+        appendIndentedLines(\"\"\"\n+\n+            public static final ValueLayout.OfBoolean C_BOOL = (ValueLayout.OfBoolean) Linker.nativeLinker().canonicalLayouts().get(\"bool\");\n+            public static final ValueLayout.OfByte C_CHAR =(ValueLayout.OfByte)Linker.nativeLinker().canonicalLayouts().get(\"char\");\n+            public static final ValueLayout.OfShort C_SHORT = (ValueLayout.OfShort) Linker.nativeLinker().canonicalLayouts().get(\"short\");\n+            public static final ValueLayout.OfInt C_INT = (ValueLayout.OfInt) Linker.nativeLinker().canonicalLayouts().get(\"int\");\n+            public static final ValueLayout.OfLong C_LONG_LONG = (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long long\");\n+            public static final ValueLayout.OfFloat C_FLOAT = (ValueLayout.OfFloat) Linker.nativeLinker().canonicalLayouts().get(\"float\");\n+            public static final ValueLayout.OfDouble C_DOUBLE = (ValueLayout.OfDouble) Linker.nativeLinker().canonicalLayouts().get(\"double\");\n+            public static final AddressLayout C_POINTER = ((AddressLayout) Linker.nativeLinker().canonicalLayouts().get(\"void*\"))\n+                    .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, C_CHAR));\n+            \"\"\");\n+        if (TypeImpl.IS_WINDOWS) {\n+            appendIndentedLines(\"public static final ValueLayout.OfInt C_LONG = (ValueLayout.OfInt) Linker.nativeLinker().canonicalLayouts().get(\\\"long\\\");\");\n+            appendIndentedLines(\"public static final ValueLayout.OfDouble C_LONG_DOUBLE = (ValueLayout.OfDouble) Linker.nativeLinker().canonicalLayouts().get(\\\"double\\\");\");\n+        } else {\n+            appendIndentedLines(\"public static final ValueLayout.OfLong C_LONG = (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get(\\\"long\\\");\");\n+        }\n+    }\n@@ -435,3 +538,3 @@\n-                    public static final MemorySegment SEGMENT = %7$sfindOrThrow(\"%4$s\").reinterpret(LAYOUT.byteSize());\n-                %5$s\n-                    public static final long[] DIMS = { %6$s };\n+                    public static final MemorySegment SEGMENT = %4$s.findOrThrow(\"%5$s\").reinterpret(LAYOUT.byteSize());\n+                %6$s\n+                    public static final long[] DIMS = { %7$s };\n@@ -439,2 +542,2 @@\n-                \"\"\", mangledName, layoutType, layoutString(varType), lookupName(var),\n-                    accessHandle, dimsString, sourceFileBuilder().FFMUtilsName());\n+                \"\"\", mangledName, layoutType, layoutString(varType), runtimeHelperName(),\n+                    lookupName(var), accessHandle, dimsString);\n@@ -445,1 +548,1 @@\n-                    public static final MemorySegment SEGMENT = %5$sfindOrThrow(\"%4$s\").reinterpret(LAYOUT.byteSize());\n+                    public static final MemorySegment SEGMENT = %4$s.findOrThrow(\"%5$s\").reinterpret(LAYOUT.byteSize());\n@@ -447,2 +550,1 @@\n-                \"\"\", mangledName, layoutType, layoutString(varType),\n-                    lookupName(var), sourceFileBuilder().FFMUtilsName());\n+                \"\"\", mangledName, layoutType, layoutString(varType), runtimeHelperName(), lookupName(var));\n@@ -488,1 +590,1 @@\n-                            = %4$sLIBRARY_ARENA.allocateFrom(\"%3$s\");\n+                            = %3$s.LIBRARY_ARENA.allocateFrom(\"%4$s\");\n@@ -495,2 +597,2 @@\n-                Utils.quote(Objects.toString(value)),\n-                sourceFileBuilder().FFMUtilsName());\n+                runtimeHelperName(),\n+                Utils.quote(Objects.toString(value)));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":126,"deletions":24,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,18 @@\n-    public String dumpIncludesFile;\n+\n+    private String dumpIncludesFile;\n+    private String sharableItems;\n+\n+    public String getDumpIncludesFile() {\n+        return dumpIncludesFile;\n+    }\n+\n+    public void setDumpIncludesFile(String dumpIncludesFile) {\n+        this.dumpIncludesFile = dumpIncludesFile;\n+    }\n+\n+    public void setSharableItems(String sharableItems) {\n+        this.sharableItems = sharableItems;\n+    }\n+    public String getSharableItems() {\n+        return sharableItems;\n+    }\n@@ -89,1 +106,1 @@\n-        Set<String> names = includesSymbolNamesByKind.computeIfAbsent(kind, (_unused) -> new HashSet<>());\n+        Set<String> names = includesSymbolNamesByKind.computeIfAbsent(kind, _unused -> new HashSet<>());\n@@ -125,1 +142,1 @@\n-            Set<String> names = includesSymbolNamesByKind.computeIfAbsent(kind, (_unused) -> new HashSet<>());\n+            Set<String> names = includesSymbolNamesByKind.computeIfAbsent(kind, _unused -> new HashSet<>());\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/IncludeHelper.java","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,1 +102,5 @@\n-            includeHelper.dumpIncludesFile = dumpIncludesFile;\n+            includeHelper.setDumpIncludesFile(dumpIncludesFile);\n+        }\n+\n+        public void useSharableItems(String name) {\n+            includeHelper.setSharableItems(name);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Options.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025 Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,3 @@\n-                                                   List<Options.Library> libs, boolean useSystemLoadLibrary) {\n+                                                   List<Options.Library> libs,\n+                                                   boolean useSystemLoadLibrary,\n+                                                   String generateShareableItems) {\n@@ -50,1 +52,7 @@\n-        ToplevelBuilder toplevelBuilder = new ToplevelBuilder(pkgName, clsName, libs, useSystemLoadLibrary);\n+        ToplevelBuilder toplevelBuilder = new ToplevelBuilder(\n+                pkgName,\n+                clsName,\n+                libs,\n+                useSystemLoadLibrary,\n+                generateShareableItems\n+        );\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -52,12 +52,0 @@\n-    public String getPackageName(){\n-        return packageName;\n-    }\n-\n-    public String layoutUtilsName() {\n-        return getPackageName().isEmpty() ? ToplevelBuilder.LAYOUT_UTILS + \".\" : \"\";\n-    }\n-\n-    public String FFMUtilsName() {\n-        return getPackageName().isEmpty() ? ToplevelBuilder.FFM_UTILS + \".\" : \"\";\n-    }\n-\n@@ -68,4 +56,0 @@\n-        if (!className.equals(ToplevelBuilder.FFM_UTILS) && !className.equals(ToplevelBuilder.LAYOUT_UTILS)\n-                && !packageName.isEmpty()) {\n-            sfb.emitStaticImportSection();\n-        }\n@@ -100,1 +84,0 @@\n-\n@@ -104,6 +87,0 @@\n-    void emitStaticImportSection() {\n-        appendLines(String.format(\"\"\"\n-            import static %1$s.FFMUtils.*;\n-            import static %1$s.LayoutUtils.*;\n-            \"\"\", packageName));\n-    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/SourceFileBuilder.java","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    private static final String PREV_SUFFIX = \"#{PREV_SUFFIX}\";\n+    public static final String PREV_SUFFIX = \"#{PREV_SUFFIX}\";\n@@ -46,2 +46,1 @@\n-    public static final String LAYOUT_UTILS = \"LayoutUtils\";\n-    public static final String FFM_UTILS = \"FFMUtils\";\n+    private final String jextractUTILS;\n@@ -52,1 +51,0 @@\n-    private final List<SourceFileBuilder> commonUtilsBuilders = new ArrayList<>();\n@@ -55,0 +53,1 @@\n+    private SourceFileBuilder jextractUtilsBuilder;\n@@ -57,1 +56,4 @@\n-                    List<Options.Library> libs, boolean useSystemLoadLibrary) {\n+                    List<Options.Library> libs,\n+                    boolean useSystemLoadLibrary,\n+                    String generateShareableItems) {\n+        jextractUTILS = generateShareableItems;\n@@ -59,5 +61,0 @@\n-        SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName, headerClassName);\n-        headerBuilders.add(sfb);\n-        lastHeader = createFirstHeader(sfb);\n-        generateCommonBindings(libs, useSystemLoadLibrary);\n-    }\n@@ -65,4 +62,3 @@\n-    private void generateCommonBindings(List<Options.Library> libs, boolean useSystemLoadLibrary) {\n-        var sfb = SourceFileBuilder.newSourceFile(packageName(), LAYOUT_UTILS);\n-        commonUtilsBuilders.add(sfb);\n-        CommonBindingsBuilder.generate(sfb, LAYOUT_UTILS, mainHeaderClassName());\n+        if (jextractUTILS != null) {\n+            jextractUtilsBuilder = createJextractUtilsBuilder(packageName,libs,useSystemLoadLibrary);\n+        }\n@@ -70,3 +66,3 @@\n-        sfb = SourceFileBuilder.newSourceFile(packageName(), FFM_UTILS);\n-        commonUtilsBuilders.add(sfb);\n-        CommonBindingsBuilder.generate(sfb, FFM_UTILS, mainHeaderClassName(), libs, useSystemLoadLibrary);\n+        SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName, headerClassName);\n+        headerBuilders.add(sfb);\n+        lastHeader = createFirstHeader(sfb, libs, useSystemLoadLibrary, jextractUTILS);\n@@ -75,2 +71,8 @@\n-    private static HeaderFileBuilder createFirstHeader(SourceFileBuilder sfb) {\n-        HeaderFileBuilder first = new HeaderFileBuilder(sfb, String.format(\"%1$s%2$s\", sfb.className(), SUFFIX), null, sfb.className());\n+    private static HeaderFileBuilder createFirstHeader(SourceFileBuilder sfb,\n+                                                       List<Options.Library> libs,\n+                                                       boolean useSystemLoadLibrary,\n+                                                       String generateShareableItems) {\n+        HeaderFileBuilder first = new HeaderFileBuilder(sfb,\n+                String.format(\"%1$s#{SUFFIX}\", sfb.className()),\n+                generateShareableItems,\n+                sfb.className());\n@@ -80,0 +82,7 @@\n+\n+        if (generateShareableItems == null) {\n+            first.emitRuntimeHelperMethods();\n+            first.emitFirstHeaderPreamble(libs, useSystemLoadLibrary);\n+            first.emitBasicPrimitiveTypes();\n+        }\n+\n@@ -83,0 +92,16 @@\n+    private SourceFileBuilder createJextractUtilsBuilder(String packageName, List<Options.Library> libs, boolean useSystemLoadLibrary) {\n+        SourceFileBuilder utilsBuilder = SourceFileBuilder.newSourceFile(packageName, jextractUTILS);\n+        HeaderFileBuilder utilsHeader = new HeaderFileBuilder(utilsBuilder, jextractUTILS, null, jextractUTILS);\n+\n+        utilsHeader.appendBlankLine();\n+        utilsHeader.classBegin();\n+        utilsHeader.emitDefaultConstructor();\n+\n+        utilsHeader.emitRuntimeHelperMethods();\n+        utilsHeader.emitFirstHeaderPreamble(libs, useSystemLoadLibrary);\n+        utilsHeader.emitBasicPrimitiveTypes();\n+        utilsHeader.classEnd();\n+\n+        return utilsBuilder;\n+    }\n+\n@@ -88,0 +113,4 @@\n+        if (jextractUTILS != null && jextractUtilsBuilder != null) {\n+            files.add(jextractUtilsBuilder.toFile());\n+        }\n+\n@@ -114,3 +143,0 @@\n-        \/\/add common bindings files\n-        files.addAll(commonUtilsBuilders.stream()\n-                .map(SourceFileBuilder::toFile).toList());\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ToplevelBuilder.java","additions":48,"deletions":22,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+help.sharable.items=generate shared utility class for common layouts and methods\n@@ -87,0 +88,1 @@\n+--sharable-items <name>            generate shared utility class for common layouts and methods \\n\\\n@@ -91,1 +93,1 @@\n--framework <framework>                     specify framework library. -framework libGL is equivalent to         \\n\\\n+--framework <framework>                     specify framework library. --framework libGL is equivalent to         \\n\\\n","filename":"src\/main\/resources\/org\/openjdk\/jextract\/impl\/resources\/Messages.properties","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/* Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+\/* Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-        ValueLayout layout = LayoutUtils.C_INT;\n+        ValueLayout layout = clinit_global_h.C_INT;\n","filename":"test\/jtreg\/generator\/clinitCycles\/TestGlobal.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/* Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+\/* Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-import static test.jextract.clinit.LayoutUtils.*;\n@@ -44,1 +43,1 @@\n-        ValueLayout layout = C_INT;\n+        ValueLayout layout = clinit_struct_h.C_INT;\n","filename":"test\/jtreg\/generator\/clinitCycles\/TestStruct.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/* Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+\/* Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-        ValueLayout layout = LayoutUtils.C_INT;\n+        ValueLayout layout = clinit_typedef_h.C_INT;\n","filename":"test\/jtreg\/generator\/clinitCycles\/TestTypedef.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,2 +49,2 @@\n-        assertEquals(layout.memberLayouts().get(0), LayoutUtils.C_INT.withName(\"x\"));\n-        assertEquals(layout.memberLayouts().get(1), LayoutUtils.C_INT.withName(\"y\"));\n+        assertEquals(layout.memberLayouts().get(0), macro_fields_h.C_INT.withName(\"x\"));\n+        assertEquals(layout.memberLayouts().get(1), macro_fields_h.C_INT.withName(\"y\"));\n","filename":"test\/jtreg\/generator\/dedup\/TestDedup.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-        assertEquals(layout.memberLayouts().get(0), LayoutUtils.C_INT.withName(\"x\"));\n+        assertEquals(layout.memberLayouts().get(0), nestedStructTypedef_h.C_INT.withName(\"x\"));\n","filename":"test\/jtreg\/generator\/nestedStructTypedef\/TestNestedStructTypedef.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-    static final MemoryLayout ELEM_NESTED_LAYOUT = MemoryLayout.structLayout(LayoutUtils.C_INT.withName(\"x\"));\n+    static final MemoryLayout ELEM_NESTED_LAYOUT = MemoryLayout.structLayout(nested_types_h.C_INT.withName(\"x\"));\n","filename":"test\/jtreg\/generator\/nestedTypes\/TestNestedTypes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-            LayoutUtils.C_INT.withName(\"y\")\n+        nested_types_names_h.C_INT.withName(\"y\")\n@@ -48,1 +48,1 @@\n-            LayoutUtils.C_INT.withName(\"x\")\n+        nested_types_names_h.C_INT.withName(\"x\")\n","filename":"test\/jtreg\/generator\/nestedTypes\/TestNestedTypesNames.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-            MemoryLayout.paddingLayout(LayoutUtils.C_POINTER.byteSize())\n+            MemoryLayout.paddingLayout(nested_types_unsupported_h.C_POINTER.byteSize())\n","filename":"test\/jtreg\/generator\/nestedTypes\/TestNestedTypesUnsupported.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.sharableItems.*;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.sharableItems.sharableItems_h.*;\n+\n+\/*\n+ * @test\n+ * @bug 7903933\n+ * @summary This is verbatim copy of TestNestedInsideAnon except for the `@run` command, used to test the `--sharable-items` option\n+ * @library \/lib\n+ * @build testlib.TestUtils\n+ * @run main\/othervm JtregJextract --sharable-items FFM_UTILS -t test.jextract.sharableItems sharableItems.h\n+ * @build TestSharableItems\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestSharableItems\n+ *\/\n+public class TestSharableItems {\n+    @Test\n+    public void testAnonField() {\n+        checkLayout(S.layout());\n+    }\n+\n+    void checkLayout(GroupLayout layout) {\n+        assertEquals(((GroupLayout)layout.memberLayouts().get(0)).memberLayouts().get(0).withoutName(),\n+                S.Flags.layout().withoutName());\n+    }\n+}\n","filename":"test\/jtreg\/generator\/sharableItems\/TestSharableItems.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-} P;\n+} S;\n","filename":"test\/jtreg\/generator\/sharableItems\/sharableItems.h","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/jtreg\/generator\/nestedInsideAnon\/nestedInsideAnon.h","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import static test.jextract.test8244412.LayoutUtils.*;\n","filename":"test\/jtreg\/generator\/test8244412\/LibTest8244412Test.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,2 +62,2 @@\n-        assertEquals(seg.byteSize(), LayoutUtils.C_INT.byteSize()*5);\n-        int[] arr = seg.toArray(LayoutUtils.C_INT);\n+        assertEquals(seg.byteSize(), C_INT.byteSize()*5);\n+        int[] arr = seg.toArray(C_INT);\n@@ -75,1 +75,1 @@\n-        byte[] barr = greeting.toArray(LayoutUtils.C_CHAR);\n+        byte[] barr = greeting.toArray(C_CHAR);\n","filename":"test\/jtreg\/generator\/test8245003\/Test8245003.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import static test.jextract.test8246341.LayoutUtils.*;\n","filename":"test\/jtreg\/generator\/test8246341\/LibTest8246341Test.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-            MemorySegment seg = arena.allocateFrom(LayoutUtils.C_INT, array);\n+            MemorySegment seg = arena.allocateFrom(C_INT, array);\n","filename":"test\/jtreg\/generator\/test8252121\/Test8252121.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,0 @@\n-import static test.jextract.unsupported.LayoutUtils.*;\n-import static test.jextract.unsupported.FFMUtils.*;\n","filename":"test\/jtreg\/generator\/test8257892\/LibUnsupportedTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import static test.jextract.printf.LayoutUtils.*;\n","filename":"test\/jtreg\/generator\/testPrintf\/TestPrintf.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,0 @@\n-import static test.jextract.struct.LayoutUtils.*;\n-import static test.jextract.struct.FFMUtils.*;\n","filename":"test\/jtreg\/generator\/testStruct\/LibStructTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}