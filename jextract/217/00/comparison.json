{"files":[{"patch":"@@ -35,0 +35,1 @@\n+import org.openjdk.jextract.impl.MissingDepWarner;\n@@ -124,1 +125,2 @@\n-                .map(new IncludeFilter(includeHelper, logger)::scan)\n+                \/\/ process phases that add Skips first\n+                .map(new IncludeFilter(includeHelper)::scan)\n@@ -126,1 +128,0 @@\n-                .map(new NameMangler(headerName)::scan)\n@@ -128,0 +129,3 @@\n+                \/\/ then do the rest\n+                .map(new MissingDepWarner(logger)::scan)\n+                .map(new NameMangler(headerName)::scan)\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/JextractTool.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-    private final Logger logger;\n@@ -39,1 +38,1 @@\n-    public IncludeFilter(IncludeHelper includeHelper, Logger logger) {\n+    public IncludeFilter(IncludeHelper includeHelper) {\n@@ -41,1 +40,0 @@\n-        this.logger = logger;\n@@ -45,3 +43,0 @@\n-        \/\/ Process all header declarations are collect potential\n-        \/\/ declarations that will go into transformed HeaderTree\n-        \/\/ into the this.decls field.\n@@ -67,2 +62,0 @@\n-        warnMissingDep(funcTree, funcTree.type().returnType());\n-        funcTree.type().argumentTypes().forEach(p -> warnMissingDep(funcTree, p));\n@@ -93,1 +86,0 @@\n-        warnMissingDep(tree, tree.type());\n@@ -103,1 +95,0 @@\n-        warnMissingDep(parent != null ? parent : tree, tree.type());\n@@ -111,14 +102,0 @@\n-\n-    void warnMissingDep(Declaration decl, Type type) {\n-        if (type instanceof Type.Declared declared) {\n-            \/\/ we only have to check for missing structs because (a) pointers to missing structs can still lead\n-            \/\/ to valid code and (b) missing typedefs to existing structs are resolved correctly, as typedefs are never\n-            \/\/ referred to by name in the generated code (because of libclang limitations).\n-            if (Skip.isPresent(declared.tree())) {\n-                logger.err(\"jextract.bad.include\", decl.name(), declared.tree().name());\n-            }\n-        } else if (type instanceof Type.Delegated delegated &&\n-                        delegated.kind() == Delegated.Kind.TYPEDEF) {\n-            warnMissingDep(decl, delegated.type());\n-        }\n-    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/IncludeFilter.java","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.impl;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Type;\n+import org.openjdk.jextract.Type.Delegated;\n+import org.openjdk.jextract.impl.DeclarationImpl.Skip;\n+\n+\/*\n+ * This visitor marks declarations to be skipped, based on --include options specified.\n+ *\/\n+public final class MissingDepWarner implements Declaration.Visitor<Void, Declaration> {\n+    private final Logger logger;\n+\n+    public MissingDepWarner(Logger logger) {\n+        this.logger = logger;\n+    }\n+\n+    public Declaration.Scoped scan(Declaration.Scoped header) {\n+        header.members().forEach(fieldTree -> fieldTree.accept(this, null));\n+        return header;\n+    }\n+\n+    @Override\n+    public Void visitFunction(Declaration.Function funcTree, Declaration parent) {\n+        if (Skip.isPresent(funcTree)) return null;\n+\n+        warnMissingDep(funcTree, funcTree.type().returnType());\n+        funcTree.type().argumentTypes().forEach(p -> warnMissingDep(funcTree, p));\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitScoped(Declaration.Scoped d, Declaration parent) {\n+        if (Skip.isPresent(d)) return null;\n+\n+        d.members().forEach(fieldTree -> fieldTree.accept(this, d));\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitTypedef(Declaration.Typedef tree, Declaration parent) {\n+        if (Skip.isPresent(tree)) return null;\n+\n+        warnMissingDep(tree, tree.type());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitVariable(Declaration.Variable tree, Declaration parent) {\n+        if (Skip.isPresent(tree)) return null;\n+\n+        if (parent != null && !Skip.isPresent(parent))  {\n+            warnMissingDep(parent, tree.type());\n+        } else {\n+            warnMissingDep(tree, tree.type());\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitDeclaration(Declaration decl, Declaration parent) {\n+        return null;\n+    }\n+\n+    void warnMissingDep(Declaration decl, Type type) {\n+        if (type instanceof Type.Declared declared) {\n+            \/\/ we only have to check for missing structs because (a) pointers to missing structs can still lead\n+            \/\/ to valid code and (b) missing typedefs to existing structs are resolved correctly, as typedefs are never\n+            \/\/ referred to by name in the generated code (because of libclang limitations).\n+            if (Skip.isPresent(declared.tree())) {\n+                logger.err(\"jextract.bad.include\", decl.name(), declared.tree().name());\n+            }\n+        } else if (type instanceof Delegated delegated &&\n+                        delegated.kind() == Delegated.Kind.TYPEDEF) {\n+            warnMissingDep(decl, delegated.type());\n+        } else if (type instanceof Type.Array arrayType) {\n+            warnMissingDep(decl, arrayType.elementType());\n+        }\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/MissingDepWarner.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -73,0 +73,2 @@\n+        if(Skip.isPresent(funcTree)) return null;\n+\n@@ -109,0 +111,2 @@\n+        if(Skip.isPresent(varTree)) return null;\n+\n@@ -130,0 +134,2 @@\n+        if(Skip.isPresent(scoped)) return null;\n+\n@@ -157,0 +163,2 @@\n+        if(Skip.isPresent(typedefTree)) return null;\n+\n@@ -178,0 +186,2 @@\n+        if(Skip.isPresent(d)) return null;\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnsupportedFilter.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import static org.testng.Assert.assertFalse;\n@@ -136,0 +137,6 @@\n+        public JextractResult checkDoesNotContainOutput(String expected) {\n+            Objects.requireNonNull(expected);\n+            assertFalse(output.contains(expected), \"Output contains string: \" + expected);\n+            return this;\n+        }\n+\n","filename":"test\/lib\/testlib\/JextractToolRunner.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,1 +41,2 @@\n-        \"--include-struct\", \"B\",\n+                \"--include-var\", \"a\",\n+                \"--include-struct\", \"B\",\n@@ -61,1 +62,2 @@\n-            {\"a\",   \"A\" }\n+            {\"a\",   \"A\" },\n+            {\"C\",   \"A\" }\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/includeDeps\/TestBadIncludes.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.toolprovider.includeDeps;\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import testlib.JextractToolRunner;\n+\n+import java.nio.file.Path;\n+\n+public class TestSkippedBadIncludes extends JextractToolRunner {\n+\n+    @Test\n+    public void run() {\n+        Path output = getOutputFilePath(\"TestBadIncludes-badIncludes.h\");\n+        Path outputH = getInputFilePath(\"bad_includes.h\");\n+        JextractResult result = run(output,\n+                \/\/ some random includes so that we don't include everything\n+                \"--include-function\", \"n\",\n+                outputH.toString());\n+        \/\/ if nothing that depends on struct A is included\n+        \/\/ there should be no errors\n+        result.checkSuccess();\n+    }\n+}\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/includeDeps\/TestSkippedBadIncludes.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+struct C { int x; struct A arr[]; };\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/includeDeps\/bad_includes.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.toolprovider.unsupported;\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import testlib.JextractToolRunner;\n+\n+import java.nio.file.Path;\n+\n+public class TestSkipped extends JextractToolRunner {\n+\n+    JextractResult result;\n+\n+    @BeforeClass\n+    public void before() {\n+        Path output = getOutputFilePath(\"TestUnsupportedTypes-unsupportedTypes.h\");\n+        Path outputH = getInputFilePath(\"unsupportedTypes.h\");\n+        result = run(output,\n+                \/\/ dummy include to turn on exclusions\n+                \"--include-function\", \"nonexistent\",\n+                outputH.toString());\n+    }\n+\n+    @Test(dataProvider = \"cases\")\n+    public void testUnsupportedTypes(String skippedName) {\n+        result.checkDoesNotContainOutput(\"WARNING: Skipping \" + skippedName);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] cases() {\n+        return new Object[][]{\n+            {\"returns_unsupported\"              },\n+            {\"accepts_unsupported\"              },\n+            {\"unsupported_t\"                    },\n+            {\"unsupported_func_t\"               },\n+            {\"returns_unsupported_func\"         },\n+            {\"accepts_unsupported_func\"         },\n+            {\"accepts_unsupported_func_varargs\" },\n+            {\"GLOBAL_UNSUPPORTED\"               },\n+            {\"GLOBAL_UNSUPPORTED_FUNC\"          },\n+            {\"accepts_undefined\"                },\n+            {\"returns_undefined\"                },\n+            {\"accepts_undefined_func\"           },\n+            {\"GLOBAL_UNDECLARED\"                },\n+            {\"undefined_typedef\"                },\n+            {\"INT_128_NUM\"                      }\n+        };\n+    }\n+}\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/unsupported\/TestSkipped.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"}]}