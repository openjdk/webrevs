{"files":[{"patch":"@@ -1,1 +1,1 @@\n-jextract --source -D FORCE_OPENBLAS_COMPLEX_STRUCT \\\n+jextract --output src --source -D FORCE_OPENBLAS_COMPLEX_STRUCT \\\n@@ -4,1 +4,1 @@\n-javac --enable-preview --source=22 blas\/*.java\n+javac --enable-preview --source=22 -d . src\/blas\/*.java\n","filename":"samples\/cblas\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+rm -rf src\n@@ -6,0 +7,1 @@\n+rm -rf src\n@@ -10,0 +12,1 @@\n+rm -rf src\n@@ -14,0 +17,1 @@\n+rm -rf src\n@@ -18,0 +22,1 @@\n+rm -rf src\n@@ -21,0 +26,1 @@\n+rm -rf src\n@@ -24,0 +30,1 @@\n+rm -rf src\n@@ -27,0 +34,2 @@\n+rm -rf src\n+rm -rf frame*.ppm\n@@ -33,0 +42,1 @@\n+rm -rf src\n@@ -36,0 +46,1 @@\n+rm -rf src\n@@ -39,0 +50,1 @@\n+rm -rf src\n@@ -42,0 +54,1 @@\n+rm -rf src\n@@ -45,0 +58,1 @@\n+rm -rf src\n@@ -48,0 +62,1 @@\n+rm -rf src\n@@ -51,0 +66,1 @@\n+rm -rf src\n@@ -54,0 +70,1 @@\n+rm -rf src\n@@ -58,0 +75,1 @@\n+rm -rf src\n@@ -61,0 +79,1 @@\n+rm -rf src\n@@ -64,0 +83,1 @@\n+rm -rf src\n@@ -67,0 +87,1 @@\n+rm -rf src\n","filename":"samples\/cleanall.sh","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-jextract --source -t org.unix \\\n+jextract --output src --source -t org.unix \\\n@@ -6,1 +6,1 @@\n-javac --enable-preview --source=22 org\/unix\/*.java\n+javac --enable-preview --source=22 -d . src\/org\/unix\/*.java\n","filename":"samples\/dlopen\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n-jextract --source -t org.hello -lhelloworld helloworld.h\n-javac --enable-preview --source=22 org\/hello\/*.java\n+jextract --output src --source -t org.hello -lhelloworld helloworld.h\n+javac --enable-preview --source=22 -d . src\/org\/hello\/*.java\n","filename":"samples\/helloworld\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-jextract --source \\\n+jextract --output src --source \\\n@@ -5,1 +5,1 @@\n-javac --enable-preview --source=22 lapack\/*.java\n+javac --enable-preview --source=22 -d . src\/lapack\/*.java\n","filename":"samples\/lapack\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-jextract --source -t org.llvm.clang -lclang \\\n+jextract --output src --source -t org.llvm.clang -lclang \\\n@@ -5,1 +5,1 @@\n-javac --enable-preview --source=22 org\/llvm\/clang\/*.java\n+javac --enable-preview --source=22 -d . src\/org\/llvm\/clang\/*.java\n","filename":"samples\/libclang\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-jextract --source -t org.jextract -lcurl \\\n+jextract --output src --source -t org.jextract -lcurl \\\n@@ -4,1 +4,1 @@\n-javac --enable-preview --source=22 org\/jextract\/*.java\n+javac --enable-preview --source=22 -d . src\/org\/jextract\/*.java\n","filename":"samples\/libcurl\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-  -I \/usr\/local\/Cellar\/ffmpeg@4\/4.4.4\/include \\\n+  -I \/usr\/local\/Cellar\/ffmpeg@4\/4.4.4_4\/include \\\n","filename":"samples\/libffmpeg\/compile.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-jextract --source -t libffmpeg \\\n-  -I \/usr\/local\/Cellar\/ffmpeg@4\/4.4.4\/include \\\n+jextract --output src --source -t libffmpeg \\\n+  -I \/usr\/local\/Cellar\/ffmpeg@4\/4.4.4_4\/include \\\n@@ -10,1 +10,1 @@\n-javac --enable-preview --source=22 libffmpeg\/*.java\n+javac --enable-preview --source=22 -d . src\/libffmpeg\/*.java\n","filename":"samples\/libffmpeg\/compilesource.sh","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-   -Djava.library.path=\/usr\/local\/Cellar\/ffmpeg@4\/4.4.4\/lib LibffmpegMain.java $*\n+   -Djava.library.path=\/usr\/local\/Cellar\/ffmpeg@4\/4.4.4_4\/lib LibffmpegMain.java $*\n","filename":"samples\/libffmpeg\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-jextract --source -t com.github -lgit2 \\\n+jextract --output src --source -t com.github -lgit2 \\\n@@ -7,1 +7,1 @@\n-javac --enable-preview --source=22 com\/github\/*.java\n+javac --enable-preview --source=22 -d . src\/com\/github\/*.java\n","filename":"samples\/libgit2\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/\/ Generated by jextract\n+\n+package org.openjdk;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.lang.foreign.*;\n+import static java.lang.foreign.ValueLayout.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * JImageResourceVisitor_t visitor\n+ * }\n+ *\/\n+public interface JIMAGE_ResourceIterator$visitor {\n+\n+    int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6);\n+\n+    FunctionDescriptor $DESC = FunctionDescriptor.of(\n+        jimage_h.C_INT,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER\n+    );\n+\n+    MethodHandle UP$MH = jimage_h.upcallHandle(JIMAGE_ResourceIterator$visitor.class, \"apply\", $DESC);\n+\n+    static MemorySegment allocate(JIMAGE_ResourceIterator$visitor fi, Arena scope) {\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n+    }\n+\n+    MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+    static JIMAGE_ResourceIterator$visitor ofAddress(MemorySegment addr, Arena arena) {\n+        MemorySegment symbol = addr.reinterpret(arena, null);\n+        return (MemorySegment __x0, MemorySegment __x1, MemorySegment __x2, MemorySegment __x3, MemorySegment __x4, MemorySegment __x5, MemorySegment __x6) -> {\n+            try {\n+                return (int) DOWN$MH.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4, __x5, __x6);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        };\n+    }\n+}\n+\n","filename":"samples\/libjimage\/org\/openjdk\/JIMAGE_ResourceIterator$visitor.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -6,0 +6,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -10,0 +11,1 @@\n+\n@@ -11,2 +13,2 @@\n- * {@snippet :\n- * void (*JImageClose_t)(struct JImageFile* jimage);\n+ * {@snippet lang=c :\n+ * typedef void (*JImageClose_t)(JImageFile *)\n@@ -17,1 +19,8 @@\n-    void apply(java.lang.foreign.MemorySegment jimage);\n+    void apply(MemorySegment jimage);\n+\n+    FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+        jimage_h.C_POINTER\n+    );\n+\n+    MethodHandle UP$MH = jimage_h.upcallHandle(JImageClose_t.class, \"apply\", $DESC);\n+\n@@ -19,1 +28,1 @@\n-        return RuntimeHelper.upcallStub(constants$1.const$0, fi, constants$0.const$4, scope);\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n@@ -21,0 +30,3 @@\n+\n+    MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n@@ -23,1 +35,1 @@\n-        return (java.lang.foreign.MemorySegment _jimage) -> {\n+        return (MemorySegment _jimage) -> {\n@@ -25,1 +37,1 @@\n-                constants$1.const$1.invokeExact(symbol, _jimage);\n+                 DOWN$MH.invokeExact(symbol, _jimage);\n@@ -33,1 +45,0 @@\n-\n","filename":"samples\/libjimage\/org\/openjdk\/JImageClose_t.java","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -10,0 +11,1 @@\n+\n@@ -11,2 +13,2 @@\n- * {@snippet :\n- * long long (*JImageFindResource_t)(struct JImageFile* jimage,char* module_name,char* version,char* name,long long* size);\n+ * {@snippet lang=c :\n+ * typedef JImageLocationRef (*JImageFindResource_t)(JImageFile *, const char *, const char *, const char *, jlong *)\n@@ -17,1 +19,13 @@\n-    long apply(java.lang.foreign.MemorySegment jimage, java.lang.foreign.MemorySegment module_name, java.lang.foreign.MemorySegment version, java.lang.foreign.MemorySegment name, java.lang.foreign.MemorySegment size);\n+    long apply(MemorySegment jimage, MemorySegment module_name, MemorySegment version, MemorySegment name, MemorySegment size);\n+\n+    FunctionDescriptor $DESC = FunctionDescriptor.of(\n+        jimage_h.C_LONG_LONG,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER\n+    );\n+\n+    MethodHandle UP$MH = jimage_h.upcallHandle(JImageFindResource_t.class, \"apply\", $DESC);\n+\n@@ -19,1 +33,1 @@\n-        return RuntimeHelper.upcallStub(constants$2.const$0, fi, constants$1.const$4, scope);\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n@@ -21,0 +35,3 @@\n+\n+    MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n@@ -23,1 +40,1 @@\n-        return (java.lang.foreign.MemorySegment _jimage, java.lang.foreign.MemorySegment _module_name, java.lang.foreign.MemorySegment _version, java.lang.foreign.MemorySegment _name, java.lang.foreign.MemorySegment _size) -> {\n+        return (MemorySegment _jimage, MemorySegment _module_name, MemorySegment _version, MemorySegment _name, MemorySegment _size) -> {\n@@ -25,1 +42,1 @@\n-                return (long)constants$2.const$1.invokeExact(symbol, _jimage, _module_name, _version, _name, _size);\n+                return (long) DOWN$MH.invokeExact(symbol, _jimage, _module_name, _version, _name, _size);\n@@ -33,1 +50,0 @@\n-\n","filename":"samples\/libjimage\/org\/openjdk\/JImageFindResource_t.java","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -10,0 +11,1 @@\n+\n@@ -11,2 +13,2 @@\n- * {@snippet :\n- * long long (*JImageGetResource_t)(struct JImageFile* jimage,long long location,char* buffer,long long size);\n+ * {@snippet lang=c :\n+ * typedef jlong (*JImageGetResource_t)(JImageFile *, JImageLocationRef, char *, jlong)\n@@ -17,1 +19,12 @@\n-    long apply(java.lang.foreign.MemorySegment jimage, long location, java.lang.foreign.MemorySegment buffer, long size);\n+    long apply(MemorySegment jimage, long location, MemorySegment buffer, long size);\n+\n+    FunctionDescriptor $DESC = FunctionDescriptor.of(\n+        jimage_h.C_LONG_LONG,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_LONG_LONG,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_LONG_LONG\n+    );\n+\n+    MethodHandle UP$MH = jimage_h.upcallHandle(JImageGetResource_t.class, \"apply\", $DESC);\n+\n@@ -19,1 +32,1 @@\n-        return RuntimeHelper.upcallStub(constants$2.const$4, fi, constants$2.const$2, scope);\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n@@ -21,0 +34,3 @@\n+\n+    MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n@@ -23,1 +39,1 @@\n-        return (java.lang.foreign.MemorySegment _jimage, long _location, java.lang.foreign.MemorySegment _buffer, long _size) -> {\n+        return (MemorySegment _jimage, long _location, MemorySegment _buffer, long _size) -> {\n@@ -25,1 +41,1 @@\n-                return (long)constants$2.const$5.invokeExact(symbol, _jimage, _location, _buffer, _size);\n+                return (long) DOWN$MH.invokeExact(symbol, _jimage, _location, _buffer, _size);\n@@ -33,1 +49,0 @@\n-\n","filename":"samples\/libjimage\/org\/openjdk\/JImageGetResource_t.java","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -10,0 +11,1 @@\n+\n@@ -11,2 +13,2 @@\n- * {@snippet :\n- * struct JImageFile* (*JImageOpen_t)(char* name,int* error);\n+ * {@snippet lang=c :\n+ * typedef JImageFile *(*JImageOpen_t)(const char *, jint *)\n@@ -17,1 +19,10 @@\n-    java.lang.foreign.MemorySegment apply(java.lang.foreign.MemorySegment jimage, java.lang.foreign.MemorySegment package_name);\n+    MemorySegment apply(MemorySegment name, MemorySegment error);\n+\n+    FunctionDescriptor $DESC = FunctionDescriptor.of(\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER\n+    );\n+\n+    MethodHandle UP$MH = jimage_h.upcallHandle(JImageOpen_t.class, \"apply\", $DESC);\n+\n@@ -19,1 +30,1 @@\n-        return RuntimeHelper.upcallStub(constants$0.const$2, fi, constants$0.const$0, scope);\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n@@ -21,0 +32,3 @@\n+\n+    MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n@@ -23,1 +37,1 @@\n-        return (java.lang.foreign.MemorySegment _jimage, java.lang.foreign.MemorySegment _package_name) -> {\n+        return (MemorySegment _name, MemorySegment _error) -> {\n@@ -25,1 +39,1 @@\n-                return (java.lang.foreign.MemorySegment)constants$0.const$3.invokeExact(symbol, _jimage, _package_name);\n+                return (MemorySegment) DOWN$MH.invokeExact(symbol, _name, _error);\n@@ -33,1 +47,0 @@\n-\n","filename":"samples\/libjimage\/org\/openjdk\/JImageOpen_t.java","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -10,0 +11,1 @@\n+\n@@ -11,2 +13,2 @@\n- * {@snippet :\n- * char* (*JImagePackageToModule_t)(struct JImageFile* jimage,char* package_name);\n+ * {@snippet lang=c :\n+ * typedef const char *(*JImagePackageToModule_t)(JImageFile *, const char *)\n@@ -17,1 +19,10 @@\n-    java.lang.foreign.MemorySegment apply(java.lang.foreign.MemorySegment jimage, java.lang.foreign.MemorySegment package_name);\n+    MemorySegment apply(MemorySegment jimage, MemorySegment package_name);\n+\n+    FunctionDescriptor $DESC = FunctionDescriptor.of(\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER\n+    );\n+\n+    MethodHandle UP$MH = jimage_h.upcallHandle(JImagePackageToModule_t.class, \"apply\", $DESC);\n+\n@@ -19,1 +30,1 @@\n-        return RuntimeHelper.upcallStub(constants$1.const$3, fi, constants$0.const$0, scope);\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n@@ -21,0 +32,3 @@\n+\n+    MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n@@ -23,1 +37,1 @@\n-        return (java.lang.foreign.MemorySegment _jimage, java.lang.foreign.MemorySegment _package_name) -> {\n+        return (MemorySegment _jimage, MemorySegment _package_name) -> {\n@@ -25,1 +39,1 @@\n-                return (java.lang.foreign.MemorySegment)constants$0.const$3.invokeExact(symbol, _jimage, _package_name);\n+                return (MemorySegment) DOWN$MH.invokeExact(symbol, _jimage, _package_name);\n@@ -33,1 +47,0 @@\n-\n","filename":"samples\/libjimage\/org\/openjdk\/JImagePackageToModule_t.java","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -10,0 +11,1 @@\n+\n@@ -11,2 +13,2 @@\n- * {@snippet :\n- * void (*JImageResourceIterator_t)(struct JImageFile* jimage,int (*visitor)(struct JImageFile*,char*,char*,char*,char*,char*,void*),void* arg);\n+ * {@snippet lang=c :\n+ * typedef void (*JImageResourceIterator_t)(JImageFile *, JImageResourceVisitor_t, void *)\n@@ -17,1 +19,10 @@\n-    void apply(java.lang.foreign.MemorySegment jimage, java.lang.foreign.MemorySegment visitor, java.lang.foreign.MemorySegment arg);\n+    void apply(MemorySegment jimage, MemorySegment visitor, MemorySegment arg);\n+\n+    FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER\n+    );\n+\n+    MethodHandle UP$MH = jimage_h.upcallHandle(JImageResourceIterator_t.class, \"apply\", $DESC);\n+\n@@ -19,1 +30,1 @@\n-        return RuntimeHelper.upcallStub(constants$3.const$5, fi, constants$3.const$3, scope);\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n@@ -21,0 +32,3 @@\n+\n+    MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n@@ -23,1 +37,1 @@\n-        return (java.lang.foreign.MemorySegment _jimage, java.lang.foreign.MemorySegment _visitor, java.lang.foreign.MemorySegment _arg) -> {\n+        return (MemorySegment _jimage, MemorySegment _visitor, MemorySegment _arg) -> {\n@@ -25,1 +39,1 @@\n-                constants$4.const$0.invokeExact(symbol, _jimage, _visitor, _arg);\n+                 DOWN$MH.invokeExact(symbol, _jimage, _visitor, _arg);\n@@ -33,1 +47,0 @@\n-\n","filename":"samples\/libjimage\/org\/openjdk\/JImageResourceIterator_t.java","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -10,0 +11,1 @@\n+\n@@ -11,2 +13,2 @@\n- * {@snippet :\n- * int (*JImageResourceVisitor_t)(struct JImageFile* jimage,char* module_name,char* version,char* package,char* name,char* extension,void* arg);\n+ * {@snippet lang=c :\n+ * typedef int (*JImageResourceVisitor_t)(JImageFile *, const char *, const char *, const char *, const char *, const char *, void *)\n@@ -17,1 +19,15 @@\n-    int apply(java.lang.foreign.MemorySegment jimage, java.lang.foreign.MemorySegment module_name, java.lang.foreign.MemorySegment version, java.lang.foreign.MemorySegment package_, java.lang.foreign.MemorySegment name, java.lang.foreign.MemorySegment extension, java.lang.foreign.MemorySegment arg);\n+    int apply(MemorySegment jimage, MemorySegment module_name, MemorySegment version, MemorySegment package_, MemorySegment name, MemorySegment extension, MemorySegment arg);\n+\n+    FunctionDescriptor $DESC = FunctionDescriptor.of(\n+        jimage_h.C_INT,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER,\n+        jimage_h.C_POINTER\n+    );\n+\n+    MethodHandle UP$MH = jimage_h.upcallHandle(JImageResourceVisitor_t.class, \"apply\", $DESC);\n+\n@@ -19,1 +35,1 @@\n-        return RuntimeHelper.upcallStub(constants$3.const$1, fi, constants$3.const$0, scope);\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n@@ -21,0 +37,3 @@\n+\n+    MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n@@ -23,1 +42,1 @@\n-        return (java.lang.foreign.MemorySegment _jimage, java.lang.foreign.MemorySegment _module_name, java.lang.foreign.MemorySegment _version, java.lang.foreign.MemorySegment _package_, java.lang.foreign.MemorySegment _name, java.lang.foreign.MemorySegment _extension, java.lang.foreign.MemorySegment _arg) -> {\n+        return (MemorySegment _jimage, MemorySegment _module_name, MemorySegment _version, MemorySegment _package_, MemorySegment _name, MemorySegment _extension, MemorySegment _arg) -> {\n@@ -25,1 +44,1 @@\n-                return (int)constants$3.const$2.invokeExact(symbol, _jimage, _module_name, _version, _package_, _name, _extension, _arg);\n+                return (int) DOWN$MH.invokeExact(symbol, _jimage, _module_name, _version, _package_, _name, _extension, _arg);\n@@ -33,1 +52,0 @@\n-\n","filename":"samples\/libjimage\/org\/openjdk\/JImageResourceVisitor_t.java","additions":25,"deletions":7,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1,255 +0,0 @@\n-package org.openjdk;\n-\/\/ Generated by jextract\n-\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.SymbolLookup;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.io.File;\n-import java.nio.file.Path;\n-import java.nio.charset.StandardCharsets;\n-import java.util.Arrays;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-import java.lang.foreign.AddressLayout;\n-import java.lang.foreign.MemoryLayout;\n-\n-import static java.lang.foreign.Linker.*;\n-import static java.lang.foreign.ValueLayout.*;\n-import static java.lang.Long.MAX_VALUE;\n-\n-final class RuntimeHelper {\n-\n-    private static final Linker LINKER = Linker.nativeLinker();\n-    private static final ClassLoader LOADER = RuntimeHelper.class.getClassLoader();\n-    private static final MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();\n-    private static final SymbolLookup SYMBOL_LOOKUP;\n-    private static final SegmentAllocator THROWING_ALLOCATOR = (x, y) -> { throw new AssertionError(\"should not reach here\"); };\n-    static final AddressLayout POINTER = ValueLayout.ADDRESS.withTargetLayout(MemoryLayout.sequenceLayout(MAX_VALUE, JAVA_BYTE));\n-\n-    final static SegmentAllocator CONSTANT_ALLOCATOR =\n-            (size, align) -> Arena.ofAuto().allocate(size, align);\n-\n-    static {\n-        \/\/ manual change\n-        var libPath = System.getProperty(\"java.home\");\n-        var OS = System.getProperty(\"os.name\");\n-        if (OS.contains(\"Mac OS X\")) {\n-            libPath += \"\/lib\/libjimage.dylib\";\n-        } else if (OS.contains(\"Windows\")) {\n-            libPath = \"\/bin\/jimage.dll\";\n-        } else {\n-            libPath = \"\/lib\/libjimage.so\"; \/\/ some Unix\n-        }\n-        SymbolLookup loaderLookup = SymbolLookup.libraryLookup(libPath, Arena.global());\n-        SYMBOL_LOOKUP = name -> loaderLookup.find(name).or(() -> LINKER.defaultLookup().find(name));\n-    }\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private RuntimeHelper() {}\n-\n-    static <T> T requireNonNull(T obj, String symbolName) {\n-        if (obj == null) {\n-            throw new UnsatisfiedLinkError(\"unresolved symbol: \" + symbolName);\n-        }\n-        return obj;\n-    }\n-\n-    static MemorySegment lookupGlobalVariable(String name, MemoryLayout layout) {\n-        return SYMBOL_LOOKUP.find(name)\n-                .map(s -> s.reinterpret(layout.byteSize()))\n-                .orElse(null);\n-    }\n-\n-    static MethodHandle downcallHandle(String name, FunctionDescriptor fdesc) {\n-        return SYMBOL_LOOKUP.find(name).\n-                map(addr -> LINKER.downcallHandle(addr, fdesc)).\n-                orElse(null);\n-    }\n-\n-    static MethodHandle downcallHandle(FunctionDescriptor fdesc) {\n-        return LINKER.downcallHandle(fdesc);\n-    }\n-\n-    static MethodHandle downcallHandleVariadic(String name, FunctionDescriptor fdesc) {\n-        return SYMBOL_LOOKUP.find(name).\n-                map(addr -> VarargsInvoker.make(addr, fdesc)).\n-                orElse(null);\n-    }\n-\n-    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n-        try {\n-            return MH_LOOKUP.findVirtual(fi, name, fdesc.toMethodType());\n-        } catch (Throwable ex) {\n-            throw new AssertionError(ex);\n-        }\n-    }\n-\n-    static <Z> MemorySegment upcallStub(MethodHandle fiHandle, Z z, FunctionDescriptor fdesc, Arena scope) {\n-        try {\n-            fiHandle = fiHandle.bindTo(z);\n-            return LINKER.upcallStub(fiHandle, fdesc, scope);\n-        } catch (Throwable ex) {\n-            throw new AssertionError(ex);\n-        }\n-    }\n-\n-    static MemorySegment asArray(MemorySegment addr, MemoryLayout layout, int numElements, Arena arena) {\n-         return addr.reinterpret(numElements * layout.byteSize(), arena, null);\n-    }\n-\n-    \/\/ Internals only below this point\n-\n-    private static final class VarargsInvoker {\n-        private static final MethodHandle INVOKE_MH;\n-        private final MemorySegment symbol;\n-        private final FunctionDescriptor function;\n-\n-        private VarargsInvoker(MemorySegment symbol, FunctionDescriptor function) {\n-            this.symbol = symbol;\n-            this.function = function;\n-        }\n-\n-        static {\n-            try {\n-                INVOKE_MH = MethodHandles.lookup().findVirtual(VarargsInvoker.class, \"invoke\", MethodType.methodType(Object.class, SegmentAllocator.class, Object[].class));\n-            } catch (ReflectiveOperationException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        static MethodHandle make(MemorySegment symbol, FunctionDescriptor function) {\n-            VarargsInvoker invoker = new VarargsInvoker(symbol, function);\n-            MethodHandle handle = INVOKE_MH.bindTo(invoker).asCollector(Object[].class, function.argumentLayouts().size() + 1);\n-            MethodType mtype = MethodType.methodType(function.returnLayout().isPresent() ? carrier(function.returnLayout().get(), true) : void.class);\n-            for (MemoryLayout layout : function.argumentLayouts()) {\n-                mtype = mtype.appendParameterTypes(carrier(layout, false));\n-            }\n-            mtype = mtype.appendParameterTypes(Object[].class);\n-            boolean needsAllocator = function.returnLayout().isPresent() &&\n-                                function.returnLayout().get() instanceof GroupLayout;\n-            if (needsAllocator) {\n-                mtype = mtype.insertParameterTypes(0, SegmentAllocator.class);\n-            } else {\n-                handle = MethodHandles.insertArguments(handle, 0, THROWING_ALLOCATOR);\n-            }\n-            return handle.asType(mtype);\n-        }\n-\n-        static Class<?> carrier(MemoryLayout layout, boolean ret) {\n-            if (layout instanceof ValueLayout valueLayout) {\n-                return valueLayout.carrier();\n-            } else if (layout instanceof GroupLayout) {\n-                return MemorySegment.class;\n-            } else {\n-                throw new AssertionError(\"Cannot get here!\");\n-            }\n-        }\n-\n-        private Object invoke(SegmentAllocator allocator, Object[] args) throws Throwable {\n-            \/\/ one trailing Object[]\n-            int nNamedArgs = function.argumentLayouts().size();\n-            assert(args.length == nNamedArgs + 1);\n-            \/\/ The last argument is the array of vararg collector\n-            Object[] unnamedArgs = (Object[]) args[args.length - 1];\n-\n-            int argsCount = nNamedArgs + unnamedArgs.length;\n-            Class<?>[] argTypes = new Class<?>[argsCount];\n-            MemoryLayout[] argLayouts = new MemoryLayout[nNamedArgs + unnamedArgs.length];\n-\n-            int pos = 0;\n-            for (pos = 0; pos < nNamedArgs; pos++) {\n-                argLayouts[pos] = function.argumentLayouts().get(pos);\n-            }\n-\n-            assert pos == nNamedArgs;\n-            for (Object o: unnamedArgs) {\n-                argLayouts[pos] = variadicLayout(normalize(o.getClass()));\n-                pos++;\n-            }\n-            assert pos == argsCount;\n-\n-            FunctionDescriptor f = (function.returnLayout().isEmpty()) ?\n-                    FunctionDescriptor.ofVoid(argLayouts) :\n-                    FunctionDescriptor.of(function.returnLayout().get(), argLayouts);\n-            MethodHandle mh = LINKER.downcallHandle(symbol, f);\n-            boolean needsAllocator = function.returnLayout().isPresent() &&\n-                                            function.returnLayout().get() instanceof GroupLayout;\n-            if (needsAllocator) {\n-                mh = mh.bindTo(allocator);\n-            }\n-            \/\/ flatten argument list so that it can be passed to an asSpreader MH\n-            Object[] allArgs = new Object[nNamedArgs + unnamedArgs.length];\n-            System.arraycopy(args, 0, allArgs, 0, nNamedArgs);\n-            System.arraycopy(unnamedArgs, 0, allArgs, nNamedArgs, unnamedArgs.length);\n-\n-            return mh.asSpreader(Object[].class, argsCount).invoke(allArgs);\n-        }\n-\n-        private static Class<?> unboxIfNeeded(Class<?> clazz) {\n-            if (clazz == Boolean.class) {\n-                return boolean.class;\n-            } else if (clazz == Void.class) {\n-                return void.class;\n-            } else if (clazz == Byte.class) {\n-                return byte.class;\n-            } else if (clazz == Character.class) {\n-                return char.class;\n-            } else if (clazz == Short.class) {\n-                return short.class;\n-            } else if (clazz == Integer.class) {\n-                return int.class;\n-            } else if (clazz == Long.class) {\n-                return long.class;\n-            } else if (clazz == Float.class) {\n-                return float.class;\n-            } else if (clazz == Double.class) {\n-                return double.class;\n-            } else {\n-                return clazz;\n-            }\n-        }\n-\n-        private Class<?> promote(Class<?> c) {\n-            if (c == byte.class || c == char.class || c == short.class || c == int.class) {\n-                return long.class;\n-            } else if (c == float.class) {\n-                return double.class;\n-            } else {\n-                return c;\n-            }\n-        }\n-\n-        private Class<?> normalize(Class<?> c) {\n-            c = unboxIfNeeded(c);\n-            if (c.isPrimitive()) {\n-                return promote(c);\n-            }\n-            if (c == MemorySegment.class) {\n-                return MemorySegment.class;\n-            }\n-            throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n-        }\n-\n-        private MemoryLayout variadicLayout(Class<?> c) {\n-            if (c == long.class) {\n-                return JAVA_LONG;\n-            } else if (c == double.class) {\n-                return JAVA_DOUBLE;\n-            } else if (c == MemorySegment.class) {\n-                return ADDRESS;\n-            } else {\n-                throw new IllegalArgumentException(\"Unhandled variadic argument class: \" + c);\n-            }\n-        }\n-    }\n-}\n","filename":"samples\/libjimage\/org\/openjdk\/RuntimeHelper.java","additions":0,"deletions":255,"binary":false,"changes":255,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/\/ Generated by jextract\n-\n-package org.openjdk;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$0 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$0() {}\n-    static final FunctionDescriptor const$0 = FunctionDescriptor.of(RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER\n-    );\n-    static final MethodHandle const$1 = RuntimeHelper.downcallHandle(\n-        \"JIMAGE_Open\",\n-        constants$0.const$0\n-    );\n-    static final MethodHandle const$2 = RuntimeHelper.upcallHandle(JImageOpen_t.class, \"apply\", constants$0.const$0);\n-    static final MethodHandle const$3 = RuntimeHelper.downcallHandle(\n-        constants$0.const$0\n-    );\n-    static final FunctionDescriptor const$4 = FunctionDescriptor.ofVoid(\n-        RuntimeHelper.POINTER\n-    );\n-    static final MethodHandle const$5 = RuntimeHelper.downcallHandle(\n-        \"JIMAGE_Close\",\n-        constants$0.const$4\n-    );\n-}\n-\n-\n","filename":"samples\/libjimage\/org\/openjdk\/constants$0.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/\/ Generated by jextract\n-\n-package org.openjdk;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$1 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$1() {}\n-    static final MethodHandle const$0 = RuntimeHelper.upcallHandle(JImageClose_t.class, \"apply\", constants$0.const$4);\n-    static final MethodHandle const$1 = RuntimeHelper.downcallHandle(\n-        constants$0.const$4\n-    );\n-    static final MethodHandle const$2 = RuntimeHelper.downcallHandle(\n-        \"JIMAGE_PackageToModule\",\n-        constants$0.const$0\n-    );\n-    static final MethodHandle const$3 = RuntimeHelper.upcallHandle(JImagePackageToModule_t.class, \"apply\", constants$0.const$0);\n-    static final FunctionDescriptor const$4 = FunctionDescriptor.of(JAVA_LONG,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER\n-    );\n-    static final MethodHandle const$5 = RuntimeHelper.downcallHandle(\n-        \"JIMAGE_FindResource\",\n-        constants$1.const$4\n-    );\n-}\n-\n-\n","filename":"samples\/libjimage\/org\/openjdk\/constants$1.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/\/ Generated by jextract\n-\n-package org.openjdk;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$2 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$2() {}\n-    static final MethodHandle const$0 = RuntimeHelper.upcallHandle(JImageFindResource_t.class, \"apply\", constants$1.const$4);\n-    static final MethodHandle const$1 = RuntimeHelper.downcallHandle(\n-        constants$1.const$4\n-    );\n-    static final FunctionDescriptor const$2 = FunctionDescriptor.of(JAVA_LONG,\n-        RuntimeHelper.POINTER,\n-        JAVA_LONG,\n-        RuntimeHelper.POINTER,\n-        JAVA_LONG\n-    );\n-    static final MethodHandle const$3 = RuntimeHelper.downcallHandle(\n-        \"JIMAGE_GetResource\",\n-        constants$2.const$2\n-    );\n-    static final MethodHandle const$4 = RuntimeHelper.upcallHandle(JImageGetResource_t.class, \"apply\", constants$2.const$2);\n-    static final MethodHandle const$5 = RuntimeHelper.downcallHandle(\n-        constants$2.const$2\n-    );\n-}\n-\n-\n","filename":"samples\/libjimage\/org\/openjdk\/constants$2.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/\/ Generated by jextract\n-\n-package org.openjdk;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$3 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$3() {}\n-    static final FunctionDescriptor const$0 = FunctionDescriptor.of(JAVA_INT,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER\n-    );\n-    static final MethodHandle const$1 = RuntimeHelper.upcallHandle(JImageResourceVisitor_t.class, \"apply\", constants$3.const$0);\n-    static final MethodHandle const$2 = RuntimeHelper.downcallHandle(\n-        constants$3.const$0\n-    );\n-    static final FunctionDescriptor const$3 = FunctionDescriptor.ofVoid(\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER,\n-        RuntimeHelper.POINTER\n-    );\n-    static final MethodHandle const$4 = RuntimeHelper.downcallHandle(\n-        \"JIMAGE_ResourceIterator\",\n-        constants$3.const$3\n-    );\n-    static final MethodHandle const$5 = RuntimeHelper.upcallHandle(JImageResourceIterator_t.class, \"apply\", constants$3.const$3);\n-}\n-\n-\n","filename":"samples\/libjimage\/org\/openjdk\/constants$3.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,19 +0,0 @@\n-\/\/ Generated by jextract\n-\n-package org.openjdk;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.lang.foreign.*;\n-import static java.lang.foreign.ValueLayout.*;\n-final class constants$4 {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private constants$4() {}\n-    static final MethodHandle const$0 = RuntimeHelper.downcallHandle(\n-        constants$3.const$3\n-    );\n-}\n-\n-\n","filename":"samples\/libjimage\/org\/openjdk\/constants$4.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"deleted"},{"patch":"@@ -6,0 +6,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -10,10 +11,83 @@\n-public class jimage_h  {\n-\n-    public static final OfByte C_CHAR = JAVA_BYTE;\n-    public static final OfShort C_SHORT = JAVA_SHORT;\n-    public static final OfInt C_INT = JAVA_INT;\n-    public static final OfLong C_LONG = JAVA_LONG;\n-    public static final OfLong C_LONG_LONG = JAVA_LONG;\n-    public static final OfFloat C_FLOAT = JAVA_FLOAT;\n-    public static final OfDouble C_DOUBLE = JAVA_DOUBLE;\n-    public static final AddressLayout C_POINTER = RuntimeHelper.POINTER;\n+\n+public class jimage_h {\n+\n+    static final SymbolLookup SYMBOL_LOOKUP;\n+    \/\/ manual change\n+    static {\n+        var libPath = System.getProperty(\"java.home\");\n+        var OS = System.getProperty(\"os.name\");\n+        if (OS.contains(\"Mac OS X\")) {\n+            libPath += \"\/lib\/libjimage.dylib\";\n+        } else if (OS.contains(\"Windows\")) {\n+            libPath = \"\/bin\/jimage.dll\";\n+        } else {\n+            libPath = \"\/lib\/libjimage.so\"; \/\/ some Unix\n+        }\n+        SymbolLookup loaderLookup = SymbolLookup.libraryLookup(libPath, Arena.global());\n+        SYMBOL_LOOKUP = name -> loaderLookup.find(name).or(() -> Linker.nativeLinker().defaultLookup().find(name));\n+    }\n+\n+    jimage_h() {\n+        \/\/ Suppresses public default constructor, ensuring non-instantiability,\n+        \/\/ but allows generated subclasses in same package.\n+    }\n+\n+    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n+    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n+    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n+    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n+    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS\n+            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));\n+    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;\n+\n+    static MemorySegment findOrThrow(String symbol) {\n+        return SYMBOL_LOOKUP.find(symbol)\n+            .orElseThrow(() -> new UnsatisfiedLinkError(\"unresolved symbol: \" + symbol));\n+    }\n+\n+    static MemoryLayout[] inferVariadicLayouts(Object[] varargs) {\n+        MemoryLayout[] result = new MemoryLayout[varargs.length];\n+        for (int i = 0; i < varargs.length; i++) {\n+            result[i] = variadicLayout(varargs[i].getClass());\n+        }\n+        return result;\n+    }\n+\n+    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n+        try {\n+            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static MethodHandle downcallHandleVariadic(String name, FunctionDescriptor baseDesc, MemoryLayout[] variadicLayouts) {\n+        FunctionDescriptor variadicDesc = baseDesc.appendArgumentLayouts(variadicLayouts);\n+        Linker.Option fva = Linker.Option.firstVariadicArg(baseDesc.argumentLayouts().size());\n+        return SYMBOL_LOOKUP.find(name)\n+                .map(addr -> Linker.nativeLinker().downcallHandle(addr, variadicDesc, fva)\n+                        .asSpreader(Object[].class, variadicLayouts.length))\n+                .orElse(null);\n+    }\n+\n+    \/\/ Internals only below this point\n+\n+    private static MemoryLayout variadicLayout(Class<?> c) {\n+        \/\/ apply default argument promotions per C spec\n+        \/\/ note that all primitives are boxed, since they are passed through an Object[]\n+        if (c == Boolean.class || c == Byte.class || c == Character.class || c == Short.class || c == Integer.class) {\n+            return JAVA_INT;\n+        } else if (c == Long.class) {\n+            return JAVA_LONG;\n+        } else if (c == Float.class || c == Double.class) {\n+            return JAVA_DOUBLE;\n+        } else if (MemorySegment.class.isAssignableFrom(c)) {\n+            return ADDRESS;\n+        }\n+        throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n+    }\n+    private static final int JIMAGE_MAX_PATH = (int)4096L;\n+\n@@ -21,1 +95,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -26,1 +100,1 @@\n-        return (int)4096L;\n+        return JIMAGE_MAX_PATH;\n@@ -29,2 +103,2 @@\n-     * {@snippet :\n-     * typedef long long jlong;\n+     * {@snippet lang=c :\n+     * typedef long long jlong\n@@ -33,1 +107,1 @@\n-    public static final OfLong jlong = JAVA_LONG;\n+    public static final OfLong jlong = jimage_h.C_LONG_LONG;\n@@ -35,2 +109,2 @@\n-     * {@snippet :\n-     * typedef int jint;\n+     * {@snippet lang=c :\n+     * typedef int jint\n@@ -39,1 +113,1 @@\n-    public static final OfInt jint = JAVA_INT;\n+    public static final OfInt jint = jimage_h.C_INT;\n@@ -41,2 +115,2 @@\n-     * {@snippet :\n-     * typedef long long JImageLocationRef;\n+     * {@snippet lang=c :\n+     * typedef jlong JImageLocationRef\n@@ -45,4 +119,1 @@\n-    public static final OfLong JImageLocationRef = JAVA_LONG;\n-    public static MethodHandle JIMAGE_Open$MH() {\n-        return RuntimeHelper.requireNonNull(constants$0.const$1,\"JIMAGE_Open\");\n-    }\n+    public static final OfLong JImageLocationRef = jimage_h.C_LONG_LONG;\n@@ -50,2 +121,2 @@\n-     * {@snippet :\n-     * JImageFile* JIMAGE_Open(char* name, jint* error);\n+     * {@snippet lang=c :\n+     * JImageFile *JIMAGE_Open(const char *name, jint *error)\n@@ -54,0 +125,15 @@\n+    public static MethodHandle JIMAGE_Open$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                jimage_h.C_POINTER,\n+                jimage_h.C_POINTER,\n+                jimage_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    jimage_h.findOrThrow(\"JIMAGE_Open\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -57,1 +143,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(name, error);\n+            return (MemorySegment) mh$.invokeExact(name, error);\n@@ -59,1 +145,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -62,3 +148,0 @@\n-    public static MethodHandle JIMAGE_Close$MH() {\n-        return RuntimeHelper.requireNonNull(constants$0.const$5,\"JIMAGE_Close\");\n-    }\n@@ -66,2 +149,2 @@\n-     * {@snippet :\n-     * void JIMAGE_Close(JImageFile* jimage);\n+     * {@snippet lang=c :\n+     * void JIMAGE_Close(JImageFile *jimage)\n@@ -70,0 +153,13 @@\n+    public static MethodHandle JIMAGE_Close$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+                jimage_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    jimage_h.findOrThrow(\"JIMAGE_Close\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -75,1 +171,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -78,3 +174,0 @@\n-    public static MethodHandle JIMAGE_PackageToModule$MH() {\n-        return RuntimeHelper.requireNonNull(constants$1.const$2,\"JIMAGE_PackageToModule\");\n-    }\n@@ -82,2 +175,2 @@\n-     * {@snippet :\n-     * char* JIMAGE_PackageToModule(JImageFile* jimage, char* package_name);\n+     * {@snippet lang=c :\n+     * const char *JIMAGE_PackageToModule(JImageFile *jimage, const char *package_name)\n@@ -86,0 +179,15 @@\n+    public static MethodHandle JIMAGE_PackageToModule$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                jimage_h.C_POINTER,\n+                jimage_h.C_POINTER,\n+                jimage_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    jimage_h.findOrThrow(\"JIMAGE_PackageToModule\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -89,1 +197,1 @@\n-            return (java.lang.foreign.MemorySegment)mh$.invokeExact(jimage, package_name);\n+            return (MemorySegment) mh$.invokeExact(jimage, package_name);\n@@ -91,1 +199,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -94,3 +202,0 @@\n-    public static MethodHandle JIMAGE_FindResource$MH() {\n-        return RuntimeHelper.requireNonNull(constants$1.const$5,\"JIMAGE_FindResource\");\n-    }\n@@ -98,2 +203,2 @@\n-     * {@snippet :\n-     * JImageLocationRef JIMAGE_FindResource(JImageFile* jimage, char* module_name, char* version, char* name, jlong* size);\n+     * {@snippet lang=c :\n+     * JImageLocationRef JIMAGE_FindResource(JImageFile *jimage, const char *module_name, const char *version, const char *name, jlong *size)\n@@ -102,0 +207,18 @@\n+    public static MethodHandle JIMAGE_FindResource$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                jimage_h.C_LONG_LONG,\n+                jimage_h.C_POINTER,\n+                jimage_h.C_POINTER,\n+                jimage_h.C_POINTER,\n+                jimage_h.C_POINTER,\n+                jimage_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    jimage_h.findOrThrow(\"JIMAGE_FindResource\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -105,1 +228,1 @@\n-            return (long)mh$.invokeExact(jimage, module_name, version, name, size);\n+            return (long) mh$.invokeExact(jimage, module_name, version, name, size);\n@@ -107,1 +230,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -110,3 +233,0 @@\n-    public static MethodHandle JIMAGE_GetResource$MH() {\n-        return RuntimeHelper.requireNonNull(constants$2.const$3,\"JIMAGE_GetResource\");\n-    }\n@@ -114,2 +234,2 @@\n-     * {@snippet :\n-     * jlong JIMAGE_GetResource(JImageFile* jimage, JImageLocationRef location, char* buffer, jlong size);\n+     * {@snippet lang=c :\n+     * jlong JIMAGE_GetResource(JImageFile *jimage, JImageLocationRef location, char *buffer, jlong size)\n@@ -118,0 +238,17 @@\n+    public static MethodHandle JIMAGE_GetResource$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                jimage_h.C_LONG_LONG,\n+                jimage_h.C_POINTER,\n+                jimage_h.C_LONG_LONG,\n+                jimage_h.C_POINTER,\n+                jimage_h.C_LONG_LONG\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    jimage_h.findOrThrow(\"JIMAGE_GetResource\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -121,1 +258,1 @@\n-            return (long)mh$.invokeExact(jimage, location, buffer, size);\n+            return (long) mh$.invokeExact(jimage, location, buffer, size);\n@@ -123,1 +260,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -126,3 +263,0 @@\n-    public static MethodHandle JIMAGE_ResourceIterator$MH() {\n-        return RuntimeHelper.requireNonNull(constants$3.const$4,\"JIMAGE_ResourceIterator\");\n-    }\n@@ -130,2 +264,2 @@\n-     * {@snippet :\n-     * void JIMAGE_ResourceIterator(JImageFile* jimage, JImageResourceVisitor_t visitor, void* arg);\n+     * {@snippet lang=c :\n+     * void JIMAGE_ResourceIterator(JImageFile *jimage, JImageResourceVisitor_t visitor, void *arg)\n@@ -134,0 +268,15 @@\n+    public static MethodHandle JIMAGE_ResourceIterator$MH() {\n+        class Holder {\n+            static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+                jimage_h.C_POINTER,\n+                jimage_h.C_POINTER,\n+                jimage_h.C_POINTER\n+            );\n+\n+            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                    jimage_h.findOrThrow(\"JIMAGE_ResourceIterator\"),\n+                    DESC);\n+        }\n+        return Holder.MH;\n+    }\n+\n@@ -139,1 +288,1 @@\n-            throw new AssertionError(\"should not reach here\", ex$);\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -142,0 +291,2 @@\n+    private static final int JIMAGE_NOT_FOUND = (int)0L;\n+\n@@ -143,1 +294,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -148,1 +299,1 @@\n-        return (int)0L;\n+        return JIMAGE_NOT_FOUND;\n@@ -150,0 +301,2 @@\n+    private static final int JIMAGE_BAD_MAGIC = (int)-1L;\n+\n@@ -151,1 +304,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -156,1 +309,1 @@\n-        return (int)-1L;\n+        return JIMAGE_BAD_MAGIC;\n@@ -158,0 +311,2 @@\n+    private static final int JIMAGE_BAD_VERSION = (int)-2L;\n+\n@@ -159,1 +314,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -164,1 +319,1 @@\n-        return (int)-2L;\n+        return JIMAGE_BAD_VERSION;\n@@ -166,0 +321,2 @@\n+    private static final int JIMAGE_CORRUPTED = (int)-3L;\n+\n@@ -167,1 +324,1 @@\n-     * {@snippet :\n+     * {@snippet lang=c :\n@@ -172,1 +329,1 @@\n-        return (int)-3L;\n+        return JIMAGE_CORRUPTED;\n@@ -176,1 +333,0 @@\n-\n","filename":"samples\/libjimage\/org\/openjdk\/jimage_h.java","additions":226,"deletions":70,"binary":false,"changes":296,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-jextract --source -t org.unix \\\n+jextract --output src --source -t org.unix \\\n@@ -4,1 +4,1 @@\n-javac --enable-preview --source=22 org\/unix\/*.java\n+javac --enable-preview --source=22 -d . src\/org\/unix\/*.java\n","filename":"samples\/libproc\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-jextract --source -t libzstd \\\n+jextract --output src --source -t libzstd \\\n@@ -7,1 +7,1 @@\n-javac --enable-preview --source=22 libzstd\/*.java\n+javac --enable-preview --source=22 -d . src\/libzstd\/*.java\n","filename":"samples\/libzstd\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5,0 +5,1 @@\n+  --output src \\\n@@ -10,1 +11,1 @@\n-javac --enable-preview --source=22 net\/sourceforge\/lpsolve\/*.java\n+javac --enable-preview --source=22 -d . src\/net\/sourceforge\/lpsolve\/*.java\n","filename":"samples\/lp_solve\/compilesource.sh","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-jextract -t org.pcre \\\n+jextract --output src -t org.pcre \\\n@@ -9,1 +9,1 @@\n-javac --enable-preview --source=22 org\/pcre\/*.java\n+javac --enable-preview --source=22 -d . src\/org\/pcre\/*.java\n","filename":"samples\/pcre2\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,3 @@\n-ANACONDA3_HOME=\/opt\/anaconda3\n+if [[ -z \"${ANACONDA3_HOME}\" ]]; then\n+    ANACONDA3_HOME=\/opt\/anaconda3\n+fi\n@@ -3,2 +5,2 @@\n-jextract -l python3.8 \\\n-  -I ${ANACONDA3_HOME}\/include\/python3.8 \\\n+jextract -l python3.11 \\\n+  -I ${ANACONDA3_HOME}\/include\/python3.11 \\\n@@ -6,1 +8,1 @@\n-  ${ANACONDA3_HOME}\/include\/python3.8\/Python.h\n+  ${ANACONDA3_HOME}\/include\/python3.11\/Python.h\n","filename":"samples\/python3\/compile.sh","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,3 @@\n-ANACONDA3_HOME=\/opt\/anaconda3\n+if [[ -z \"${ANACONDA3_HOME}\" ]]; then\n+    ANACONDA3_HOME=\/opt\/anaconda3\n+fi\n@@ -3,2 +5,2 @@\n-jextract --source -l python3.8 \\\n-  -I ${ANACONDA3_HOME}\/include\/python3.8 \\\n+jextract --output src --source -l python3.11 \\\n+  -I ${ANACONDA3_HOME}\/include\/python3.11 \\\n@@ -6,1 +8,1 @@\n-  ${ANACONDA3_HOME}\/include\/python3.8\/Python.h\n+  ${ANACONDA3_HOME}\/include\/python3.11\/Python.h\n@@ -8,1 +10,1 @@\n-javac --enable-preview --source=22 org\/python\/*.java\n+javac --enable-preview --source=22 -d . src\/org\/python\/*.java\n","filename":"samples\/python3\/compilesource.sh","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,1 +1,3 @@\n-ANACONDA3_HOME=\/opt\/anaconda3\n+if [[ -z \"${ANACONDA3_HOME}\" ]]; then\n+    ANACONDA3_HOME=\/opt\/anaconda3\n+fi\n","filename":"samples\/python3\/run.sh","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-jextract --source -l readline -t org.unix \\\n+jextract --output src --source -l readline -t org.unix \\\n@@ -7,1 +7,1 @@\n-javac --enable-preview --source=22 org\/unix\/*.java\n+javac --enable-preview --source=22 -d . src\/org\/unix\/*.java\n","filename":"samples\/readline\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-jextract --source \\\n+jextract --output src --source \\\n@@ -5,1 +5,1 @@\n-javac --enable-preview --source=22 org\/sqlite\/*.java\n+javac --enable-preview --source=22 -d . src\/org\/sqlite\/*.java\n","filename":"samples\/sqlite\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-jextract --source -l tcl -t org.tcl \\\n+jextract --output src --source -l tcl -t org.tcl \\\n@@ -4,1 +4,1 @@\n-javac --enable-preview --source=22 org\/tcl\/*.java\n+javac --enable-preview --source=22 -d . src\/org\/tcl\/*.java\n","filename":"samples\/tcl\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-jextract --source \\\n+jextract --output src --source \\\n@@ -7,1 +7,1 @@\n-javac --enable-preview --source=22 org\/tensorflow\/*.java\n+javac --enable-preview --source=22 -d . src\/org\/tensorflow\/*.java\n","filename":"samples\/tensorflow\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-jextract --source -t org.unix \\\n+jextract --output src --source -t org.unix \\\n@@ -4,1 +4,1 @@\n-javac --enable-preview --source=22 org\/unix\/*.java\n+javac --enable-preview --source=22 -d . src\/org\/unix\/*.java\n","filename":"samples\/time\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -178,0 +178,8 @@\n+        Type unsupportedType = firstUnsupportedType(d.type(), false);\n+        String name = fieldName(firstNamedParent, d);\n+        if (unsupportedType != null) {\n+            warnSkip(name, STR.\"unsupported type usage: \\{unsupportedType}\");\n+            Skip.with(d);\n+            return null;\n+        }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnsupportedFilter.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+            {\"LONG_DOUBLE_PI\",                   REASON_UNSUPPORTED_TYPE}\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/unsupported\/TestUnsupportedTypes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,3 @@\n+\n+#define LONG_DOUBLE_PI 3.1415926535897932384626433832795029L\n+\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/unsupported\/unsupportedTypes.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}