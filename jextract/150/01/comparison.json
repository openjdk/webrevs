{"files":[{"patch":"@@ -61,0 +61,1 @@\n+    private final String runtimeHelperName;\n@@ -62,1 +63,2 @@\n-    ClassSourceBuilder(SourceFileBuilder builder, String modifiers, Kind kind, String className, String superName, ClassSourceBuilder enclosing) {\n+    ClassSourceBuilder(SourceFileBuilder builder, String modifiers, Kind kind, String className, String superName,\n+                       ClassSourceBuilder enclosing, String runtimeHelperName) {\n@@ -69,0 +71,1 @@\n+        this.runtimeHelperName = runtimeHelperName;\n@@ -81,0 +84,4 @@\n+    final String runtimeHelperName() {\n+        return runtimeHelperName;\n+    }\n+\n@@ -247,1 +254,1 @@\n-    private static String valueLayoutString(ValueLayout vl) {\n+    private String valueLayoutString(ValueLayout vl) {\n@@ -265,1 +272,1 @@\n-            return \"RuntimeHelper.POINTER\";\n+            return STR.\"\\{runtimeHelperName}.C_POINTER\";\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ClassSourceBuilder.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -46,2 +46,3 @@\n-                                       FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n-        super(builder, \"public\", Kind.INTERFACE, className, null, enclosing);\n+                                       String runtimeHelperName, FunctionDescriptor descriptor,\n+                                       Optional<List<String>> parameterNames) {\n+        super(builder, \"public\", Kind.INTERFACE, className, null, enclosing, runtimeHelperName);\n@@ -54,1 +55,1 @@\n-    public static void generate(SourceFileBuilder builder, String className, ClassSourceBuilder enclosing,\n+    public static void generate(SourceFileBuilder builder, String className, ClassSourceBuilder enclosing, String runtimeHelperName,\n@@ -56,1 +57,1 @@\n-        FunctionalInterfaceBuilder fib = new FunctionalInterfaceBuilder(builder, className, enclosing,\n+        FunctionalInterfaceBuilder fib = new FunctionalInterfaceBuilder(builder, className, enclosing, runtimeHelperName,\n@@ -75,1 +76,1 @@\n-            MethodHandle UP$MH = RuntimeHelper.upcallHandle(\\{className()}.class, \\\"apply\\\", $DESC);\n+            MethodHandle UP$MH = \\{runtimeHelperName()}.upcallHandle(\\{className()}.class, \\\"apply\\\", $DESC);\n@@ -78,1 +79,1 @@\n-                return RuntimeHelper.upcallStub(UP$MH, fi, $DESC, scope);\n+                return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, scope);\n@@ -85,1 +86,1 @@\n-            MethodHandle DOWN$MH = RuntimeHelper.downcallHandle($DESC);\n+            MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.io.File;\n@@ -57,2 +58,2 @@\n-    HeaderFileBuilder(SourceFileBuilder builder, String className, String superName) {\n-        super(builder, \"public\", Kind.CLASS, className, superName, null);\n+    HeaderFileBuilder(SourceFileBuilder builder, String className, String superName, String runtimeHelperName) {\n+        super(builder, \"public\", Kind.CLASS, className, superName, null, runtimeHelperName);\n@@ -161,1 +162,3 @@\n-                    static final MethodHandle MH = RuntimeHelper.downcallHandle(\\\"\\{nativeName}\\\", DESC);\n+                    static final MethodHandle MH = Linker.nativeLinker().downcallHandle(\n+                            \\{runtimeHelperName()}.findOrThrow(\"\\{nativeName}\"),\n+                            DESC);\n@@ -163,1 +166,1 @@\n-                return RuntimeHelper.requireNonNull(Holder.MH, \\\"\\{javaName}\\\");\n+                return Holder.MH;\n@@ -189,1 +192,1 @@\n-                    var mh$ = RuntimeHelper.downcallHandleVariadic(\"\\{nativeName}\", baseDesc$, layouts);\n+                    var mh$ = \\{runtimeHelperName()}.downcallHandleVariadic(\"\\{nativeName}\", baseDesc$, layouts);\n@@ -206,1 +209,1 @@\n-                    MemoryLayout[] inferredLayouts$ = RuntimeHelper.inferVariadicLayouts(\\{varargsParam});\n+                    MemoryLayout[] inferredLayouts$ = \\{runtimeHelperName()}.inferVariadicLayouts(\\{varargsParam});\n@@ -241,0 +244,70 @@\n+    void emitFirstHeaderPreamble(List<String> libraries) {\n+        incrAlign();\n+        appendLines(\"static final SymbolLookup SYMBOL_LOOKUP;\");\n+        appendLines(\"static {\");\n+        for (String lib : libraries) {\n+            String quotedLibName = lib.replace(\"\\\\\", \"\\\\\\\\\"); \/\/ double up slashes\n+            String method = quotedLibName.indexOf(File.separatorChar) != -1 ? \"load\" : \"loadLibrary\";\n+            appendIndentedLines(STR.\"System.\\{method}(\\\"\\{quotedLibName}\\\");\");\n+        }\n+        appendLines(\"\"\"\n+\n+            SymbolLookup loaderLookup = SymbolLookup.loaderLookup();\n+            Linker linker = Linker.nativeLinker();\n+            SYMBOL_LOOKUP = name -> loaderLookup.find(name).or(() -> linker.defaultLookup().find(name));\n+            \"\"\");\n+        appendLines(\"}\");\n+        decrAlign();\n+    }\n+\n+    void emitRuntimeHelperMethods() {\n+        appendIndentedLines(\"\"\"\n+            static MemorySegment findOrThrow(String symbol) {\n+                return SYMBOL_LOOKUP.find(symbol)\n+                    .orElseThrow(() -> new UnsatisfiedLinkError(\"unresolved symbol: \" + symbol));\n+            }\n+\n+            static MemoryLayout[] inferVariadicLayouts(Object[] varargs) {\n+                MemoryLayout[] result = new MemoryLayout[varargs.length];\n+                for (int i = 0; i < varargs.length; i++) {\n+                    result[i] = variadicLayout(varargs[i].getClass());\n+                }\n+                return result;\n+            }\n+\n+            static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n+                try {\n+                    return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());\n+                } catch (ReflectiveOperationException ex) {\n+                    throw new AssertionError(ex);\n+                }\n+            }\n+\n+            static MethodHandle downcallHandleVariadic(String name, FunctionDescriptor baseDesc, MemoryLayout[] variadicLayouts) {\n+                FunctionDescriptor variadicDesc = baseDesc.appendArgumentLayouts(variadicLayouts);\n+                Linker.Option fva = Linker.Option.firstVariadicArg(baseDesc.argumentLayouts().size());\n+                return SYMBOL_LOOKUP.find(name)\n+                        .map(addr -> Linker.nativeLinker().downcallHandle(addr, variadicDesc, fva)\n+                                .asSpreader(Object[].class, variadicLayouts.length))\n+                        .orElse(null);\n+            }\n+\n+            \/\/ Internals only below this point\n+\n+            private static MemoryLayout variadicLayout(Class<?> c) {\n+                \/\/ apply default argument promotions per C spec\n+                \/\/ note that all primitives are boxed, since they are passed through an Object[]\n+                if (c == Boolean.class || c == Byte.class || c == Character.class || c == Short.class || c == Integer.class) {\n+                    return JAVA_INT;\n+                } else if (c == Long.class) {\n+                    return JAVA_LONG;\n+                } else if (c == Float.class || c == Double.class) {\n+                    return JAVA_DOUBLE;\n+                } else if (MemorySegment.class.isAssignableFrom(c)) {\n+                    return ADDRESS;\n+                }\n+                throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n+            }\n+            \"\"\");\n+    }\n+\n@@ -254,1 +327,1 @@\n-                return (\\{type.getSimpleName()}) \\{vhConstant}.get(RuntimeHelper.requireNonNull(\\{segmentConstant}, \"\\{nativeName}\"), 0L);\n+                return (\\{type.getSimpleName()}) \\{vhConstant}.get(\\{segmentConstant}(), 0L);\n@@ -266,1 +339,1 @@\n-                \\{vhConstant}.set(RuntimeHelper.requireNonNull(\\{segmentConstant}, \"\\{nativeName}\"), 0L, x);\n+                \\{vhConstant}.set(\\{segmentConstant}(), 0L, x);\n@@ -275,4 +348,0 @@\n-        appendLines(STR.\"\"\"\n-            private static final MemorySegment \\{mangledName} = RuntimeHelper.lookupGlobalVariable(\\\"\\{nativeName}\\\", \\{layout});\n-\n-            \"\"\");\n@@ -284,1 +353,5 @@\n-                return RuntimeHelper.requireNonNull(\\{mangledName}, \\\"\\{javaName}\\\");\n+                class Holder {\n+                    static final MemorySegment SEGMENT = \\{runtimeHelperName()}.findOrThrow(\"\\{nativeName}\")\n+                        .reinterpret(\\{layout}.byteSize());\n+                }\n+                return Holder.SEGMENT;\n@@ -334,1 +407,1 @@\n-            return STR.\"RuntimeHelper.CONSTANT_ALLOCATOR.allocateFrom(\\\"\\{Utils.quote(Objects.toString(value))}\\\");\";\n+            return STR.\"Arena.ofAuto().allocateFrom(\\\"\\{Utils.quote(Objects.toString(value))}\\\");\";\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":87,"deletions":14,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -267,2 +267,2 @@\n-                \"Arena\", \"NativeArena\", \"MemorySegment\", \"ValueLayout\",\n-                \"RuntimeHelper\" -> true;\n+                \"Arena\", \"NativeArena\", \"MemorySegment\", \"ValueLayout\"\n+                    -> true;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/NameMangler.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-        ToplevelBuilder toplevelBuilder = new ToplevelBuilder(pkgName, clsName);\n+        ToplevelBuilder toplevelBuilder = new ToplevelBuilder(pkgName, clsName, libraryNames);\n@@ -94,1 +94,1 @@\n-            generate(decl, libraryNames.toArray(new String[0]));\n+            generate(decl);\n@@ -103,1 +103,1 @@\n-    JavaFileObject[] generate(Declaration.Scoped decl, String[] libs) {\n+    JavaFileObject[] generate(Declaration.Scoped decl) {\n@@ -111,29 +111,2 @@\n-        try {\n-            List<JavaFileObject> files = new ArrayList<>(toplevelBuilder.toFiles());\n-            files.add(jfoFromString(pkgName,\"RuntimeHelper\", getRuntimeHelperSource(libs)));\n-            return files.toArray(new JavaFileObject[0]);\n-        } catch (IOException ex) {\n-            throw new UncheckedIOException(ex);\n-        } catch (URISyntaxException ex2) {\n-            throw new RuntimeException(ex2);\n-        }\n-    }\n-\n-    private String getRuntimeHelperSource(String[] libraries) throws URISyntaxException, IOException {\n-        URL runtimeHelper = OutputFactory.class.getResource(\"resources\/RuntimeHelper.java.template\");\n-        String template = (pkgName.isEmpty()? \"\" : \"package \" + pkgName + \";\\n\") +\n-                        String.join(\"\\n\", Files.readAllLines(Paths.get(runtimeHelper.toURI())));\n-        List<String> loadLibrariesStr = new ArrayList<>();\n-        for (String lib : libraries) {\n-            String quotedLibName = quoteLibraryName(lib);\n-            if (quotedLibName.indexOf(File.separatorChar) != -1) {\n-                loadLibrariesStr.add(\"System.load(\\\"\" + quotedLibName + \"\\\");\");\n-            } else {\n-                loadLibrariesStr.add(\"System.loadLibrary(\\\"\" + quotedLibName + \"\\\");\");\n-            }\n-        }\n-        return template.replace(\"#LOAD_LIBRARIES#\", loadLibrariesStr.stream().collect(Collectors.joining(\" \")));\n-    }\n-\n-    private String quoteLibraryName(String lib) {\n-        return lib.replace(\"\\\\\", \"\\\\\\\\\"); \/\/ double up slashes\n+        List<JavaFileObject> files = new ArrayList<>(toplevelBuilder.toFiles());\n+        return files.toArray(new JavaFileObject[0]);\n@@ -186,3 +159,1 @@\n-            currentBuilder = structBuilder = currentBuilder.addStruct(\n-                d,\n-                layout);\n+            currentBuilder = structBuilder = currentBuilder.addStruct(d, layout);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":6,"deletions":35,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+            import java.lang.invoke.MethodHandles;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/SourceFileBuilder.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,2 +61,3 @@\n-                  ClassSourceBuilder enclosing, Declaration.Scoped structTree, GroupLayout structLayout) {\n-        super(builder, modifiers, Kind.CLASS, className, null, enclosing);\n+                  ClassSourceBuilder enclosing, String runtimeHelperName, Declaration.Scoped structTree,\n+                  GroupLayout structLayout) {\n+        super(builder, modifiers, Kind.CLASS, className, null, enclosing, runtimeHelperName);\n@@ -128,1 +129,1 @@\n-                    JavaName.getOrThrow(tree), this, tree, layout);\n+                    JavaName.getOrThrow(tree), this, runtimeHelperName(), tree, layout);\n@@ -139,1 +140,1 @@\n-                this, funcType, descriptor, JavaParameterNames.get(funcType));\n+                this, runtimeHelperName(), funcType, descriptor, JavaParameterNames.get(funcType));\n@@ -248,1 +249,1 @@\n-                return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope);\n+                return addr.reinterpret($LAYOUT().byteSize(), scope, null);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructBuilder.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    ToplevelBuilder(String packageName, String headerClassName) {\n+    ToplevelBuilder(String packageName, String headerClassName, List<String> libraries) {\n@@ -60,1 +60,1 @@\n-        lastHeader = firstHeader = createFirstHeader(sfb);\n+        lastHeader = firstHeader = createFirstHeader(sfb, libraries);\n@@ -63,2 +63,2 @@\n-    private static HeaderFileBuilder createFirstHeader(SourceFileBuilder sfb) {\n-        HeaderFileBuilder first = new HeaderFileBuilder(sfb, sfb.className(), \"#{SUPER}\");\n+    private static HeaderFileBuilder createFirstHeader(SourceFileBuilder sfb, List<String> libraries) {\n+        HeaderFileBuilder first = new HeaderFileBuilder(sfb, sfb.className(), \"#{SUPER}\", sfb.className());\n@@ -66,0 +66,1 @@\n+        first.emitFirstHeaderPreamble(libraries);\n@@ -75,1 +76,6 @@\n-        first.emitPointerTypedef(\"C_POINTER\");\n+\n+        \/\/ we don't use 'emitPrimitiveTypedef' so we can attach the target layout\n+        first.appendIndentedLines(\"\"\"\n+            public static final AddressLayout C_POINTER = ValueLayout.ADDRESS\n+                    .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));\n+            \"\"\");\n@@ -80,0 +86,4 @@\n+        boolean hasOneHeader = lastHeader == firstHeader;\n+        if (hasOneHeader) {\n+            firstHeader.emitRuntimeHelperMethods();\n+        }\n@@ -84,1 +94,1 @@\n-                lastHeader != firstHeader ? \"extends \" + lastHeader.className() : \"\")));\n+                hasOneHeader ? \"\" : \"extends \" + lastHeader.className())));\n@@ -120,1 +130,1 @@\n-            TypedefBuilder.generate(sfb, sfb.className(), superClass, typedefTree);\n+            TypedefBuilder.generate(sfb, sfb.className(), superClass, firstHeader.className(), typedefTree);\n@@ -129,1 +139,1 @@\n-        StructBuilder structBuilder = new StructBuilder(sfb, \"public\", sfb.className(), null, tree, layout);\n+        StructBuilder structBuilder = new StructBuilder(sfb, \"public\", sfb.className(), null, firstHeader.className(), tree, layout);\n@@ -138,1 +148,1 @@\n-        FunctionalInterfaceBuilder.generate(sfb, sfb.className(), null, funcType, descriptor, JavaParameterNames.get(funcType));\n+        FunctionalInterfaceBuilder.generate(sfb, sfb.className(), null, firstHeader.className(), funcType, descriptor, JavaParameterNames.get(funcType));\n@@ -143,1 +153,4 @@\n-            boolean hasSuper = lastHeader != firstHeader;\n+            boolean wasFirstHeader = lastHeader == firstHeader;\n+            if (wasFirstHeader) {\n+                firstHeader.emitRuntimeHelperMethods();\n+            }\n@@ -147,1 +160,1 @@\n-                    hasSuper ? lastHeader.className() : null);\n+                    wasFirstHeader ? null : lastHeader.className(), firstHeader.className());\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ToplevelBuilder.java","additions":24,"deletions":11,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-    private TypedefBuilder(SourceFileBuilder builder, String className, String superClass) {\n-        super(builder, \"public\", Kind.CLASS, className, superClass, null);\n+    private TypedefBuilder(SourceFileBuilder builder, String className, String superClass, String runtimeHelperName) {\n+        super(builder, \"public\", Kind.CLASS, className, superClass, null, runtimeHelperName);\n@@ -38,3 +38,3 @@\n-    public static void generate(SourceFileBuilder builder, String className, String superClass,\n-                          Declaration.Typedef typedefTree) {\n-        TypedefBuilder tdb = new TypedefBuilder(builder, className, superClass);\n+    public static void generate(SourceFileBuilder builder, String className, String superClass, String runtimeHelperName,\n+                                Declaration.Typedef typedefTree) {\n+        TypedefBuilder tdb = new TypedefBuilder(builder, className, superClass, runtimeHelperName);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypedefBuilder.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,127 +0,0 @@\n-\/\/ Generated by jextract\n-\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.SymbolLookup;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.io.File;\n-import java.nio.file.Path;\n-import java.nio.charset.StandardCharsets;\n-import java.util.Arrays;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-import java.lang.foreign.AddressLayout;\n-import java.lang.foreign.MemoryLayout;\n-\n-import static java.lang.foreign.Linker.*;\n-import static java.lang.foreign.ValueLayout.*;\n-import static java.lang.Long.MAX_VALUE;\n-\n-final class RuntimeHelper {\n-\n-    private static final Linker LINKER = Linker.nativeLinker();\n-    private static final ClassLoader LOADER = RuntimeHelper.class.getClassLoader();\n-    private static final MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();\n-    private static final SymbolLookup SYMBOL_LOOKUP;\n-    private static final SegmentAllocator THROWING_ALLOCATOR = (x, y) -> { throw new AssertionError(\"should not reach here\"); };\n-    static final AddressLayout POINTER = ValueLayout.ADDRESS.withTargetLayout(MemoryLayout.sequenceLayout(MAX_VALUE, JAVA_BYTE));\n-\n-    final static SegmentAllocator CONSTANT_ALLOCATOR =\n-            (size, align) -> Arena.ofAuto().allocate(size, align);\n-\n-    static {\n-        #LOAD_LIBRARIES#\n-        SymbolLookup loaderLookup = SymbolLookup.loaderLookup();\n-        SYMBOL_LOOKUP = name -> loaderLookup.find(name).or(() -> LINKER.defaultLookup().find(name));\n-    }\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private RuntimeHelper() {}\n-\n-    static <T> T requireNonNull(T obj, String symbolName) {\n-        if (obj == null) {\n-            throw new UnsatisfiedLinkError(\"unresolved symbol: \" + symbolName);\n-        }\n-        return obj;\n-    }\n-\n-    static MemorySegment lookupGlobalVariable(String name, MemoryLayout layout) {\n-        return SYMBOL_LOOKUP.find(name)\n-                .map(s -> s.reinterpret(layout.byteSize()))\n-                .orElse(null);\n-    }\n-\n-    static MethodHandle downcallHandle(String name, FunctionDescriptor fdesc) {\n-        return SYMBOL_LOOKUP.find(name).\n-                map(addr -> LINKER.downcallHandle(addr, fdesc)).\n-                orElse(null);\n-    }\n-\n-    static MethodHandle downcallHandle(FunctionDescriptor fdesc) {\n-        return LINKER.downcallHandle(fdesc);\n-    }\n-\n-    static MethodHandle downcallHandleVariadic(String name, FunctionDescriptor baseDesc, MemoryLayout[] variadicLayouts) {\n-        FunctionDescriptor variadicDesc = baseDesc.appendArgumentLayouts(variadicLayouts);\n-        Linker.Option fva = Linker.Option.firstVariadicArg(baseDesc.argumentLayouts().size());\n-        return SYMBOL_LOOKUP.find(name)\n-                .map(addr -> LINKER.downcallHandle(addr, variadicDesc, fva)\n-                        .asSpreader(Object[].class, variadicLayouts.length))\n-                .orElse(null);\n-    }\n-\n-    static MemoryLayout[] inferVariadicLayouts(Object[] varargs) {\n-        MemoryLayout[] result = new MemoryLayout[varargs.length];\n-        for (int i = 0; i < varargs.length; i++) {\n-            result[i] = variadicLayout(varargs[i].getClass());\n-        }\n-        return result;\n-    }\n-\n-    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n-        try {\n-            return MH_LOOKUP.findVirtual(fi, name, fdesc.toMethodType());\n-        } catch (Throwable ex) {\n-            throw new AssertionError(ex);\n-        }\n-    }\n-\n-    static <Z> MemorySegment upcallStub(MethodHandle fiHandle, Z z, FunctionDescriptor fdesc, Arena scope) {\n-        try {\n-            fiHandle = fiHandle.bindTo(z);\n-            return LINKER.upcallStub(fiHandle, fdesc, scope);\n-        } catch (Throwable ex) {\n-            throw new AssertionError(ex);\n-        }\n-    }\n-\n-    static MemorySegment asArray(MemorySegment addr, MemoryLayout layout, int numElements, Arena arena) {\n-         return addr.reinterpret(numElements * layout.byteSize(), arena, null);\n-    }\n-\n-    \/\/ Internals only below this point\n-\n-    private static MemoryLayout variadicLayout(Class<?> c) {\n-        \/\/ apply default argument promotions per C spec\n-        \/\/ note that all primitives are boxed, since they are passed through an Object[]\n-        if (c == Boolean.class || c == Byte.class || c == Character.class || c == Short.class || c == Integer.class) {\n-            return JAVA_INT;\n-        } else if (c == Long.class) {\n-            return JAVA_LONG;\n-        } else if (c == Float.class || c == Double.class) {\n-            return JAVA_DOUBLE;\n-        } else if (MemorySegment.class.isAssignableFrom(c)) {\n-            return ADDRESS;\n-        }\n-        throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n-    }\n-}\n","filename":"src\/main\/resources\/org\/openjdk\/jextract\/impl\/resources\/RuntimeHelper.java.template","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.MemorySegment;\n-import org.testng.annotations.Test;\n-import test.jextract.test8259473.*;\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-import static test.jextract.test8259473.test8259473_h.*;\n-\n-\/*\n- * @test id=classes\n- * @bug 8259473\n- * @summary jextract generated code should throw exception for unfound native symbols from calls, variable access, set immediately\n- * @library \/lib\n- * @run main\/othervm JtregJextract -t test.jextract.test8259473 test8259473.h\n- * @build LibTest8259473Test\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8259473Test\n- *\/\n-\/*\n- * @test id=sources\n- * @bug 8259473\n- * @summary jextract generated code should throw exception for unfound native symbols from calls, variable access, set immediately\n- * @library \/lib\n- * @run main\/othervm JtregJextractSources -t test.jextract.test8259473 test8259473.h\n- * @build LibTest8259473Test\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8259473Test\n- *\/\n-public class LibTest8259473Test {\n-    @Test\n-    public void nullChecksTest() {\n-        try {\n-            func();\n-            throw new AssertionError(\"should not reach here\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            assertTrue(ule.getMessage().contains(\"unresolved symbol: func\"));\n-        }\n-\n-        try {\n-            func$MH();\n-            throw new AssertionError(\"should not reach here\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            assertTrue(ule.getMessage().contains(\"unresolved symbol: func\"));\n-        }\n-\n-        try {\n-            x$get();\n-            throw new AssertionError(\"should not reach here\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            assertTrue(ule.getMessage().contains(\"unresolved symbol: x\"));\n-        }\n-\n-        try {\n-            x$set(1);\n-            throw new AssertionError(\"should not reach here\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            assertTrue(ule.getMessage().contains(\"unresolved symbol: x\"));\n-        }\n-\n-        try {\n-            x$SEGMENT();\n-            throw new AssertionError(\"should not reach here\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            assertTrue(ule.getMessage().contains(\"unresolved symbol: x\"));\n-        }\n-\n-        try {\n-            y$SEGMENT();\n-            throw new AssertionError(\"should not reach here\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            assertTrue(ule.getMessage().contains(\"unresolved symbol: y\"));\n-        }\n-\n-        try {\n-            pt$SEGMENT();\n-            throw new AssertionError(\"should not reach here\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            assertTrue(ule.getMessage().contains(\"unresolved symbol: pt\"));\n-        }\n-    }\n-}\n","filename":"test\/jtreg\/generator\/test8259473\/LibTest8259473Test.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.testLinkageErrors.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static test.jextract.testLinkageErrors.testLinkageErrors_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8259473\n+ * @summary jextract generated code should throw exception for unfound native symbols from calls, variable access, set immediately\n+ * @library \/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.testLinkageErrors testLinkageErrors.h\n+ * @build TestLinkageErrors\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestLinkageErrors\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8259473\n+ * @summary jextract generated code should throw exception for unfound native symbols from calls, variable access, set immediately\n+ * @library \/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.testLinkageErrors testLinkageErrors.h\n+ * @build TestLinkageErrors\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestLinkageErrors\n+ *\/\n+public class TestLinkageErrors {\n+\n+    static void assertThrowsULE(Runnable action, String symbol) {\n+        try {\n+            action.run();\n+            throw new AssertionError(\"should not reach here\");\n+        } catch (Throwable t) {\n+            while (t.getCause() != null) {\n+                t = t.getCause();\n+            }\n+            assertTrue(t.getMessage().contains(\"unresolved symbol: \" + symbol));\n+        }\n+    }\n+\n+    @Test\n+    public void nullChecksTest() {\n+        assertThrowsULE(() -> func(), \"func\");\n+        assertThrowsULE(() -> func$MH(), \"func\");\n+        assertThrowsULE(() -> x$get(), \"x\");\n+        assertThrowsULE(() -> x$set(1), \"x\");\n+        assertThrowsULE(() -> x$SEGMENT(), \"x\");\n+        assertThrowsULE(() -> y$SEGMENT(), \"y\");\n+        assertThrowsULE(() -> pt$SEGMENT(), \"pt\");\n+    }\n+}\n","filename":"test\/jtreg\/generator\/testLinkageErrors\/TestLinkageErrors.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"","filename":"test\/jtreg\/generator\/testLinkageErrors\/testLinkageErrors.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jtreg\/generator\/test8259473\/test8259473.h","status":"renamed"},{"patch":"@@ -46,1 +46,0 @@\n-            assertNotNull(loader.loadClass(\"RuntimeHelper_\"));\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8262825.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}