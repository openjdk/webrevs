{"files":[{"patch":"@@ -19,1 +19,1 @@\n-The samples under the [`samples`](samples) direcotry are also a good source of examples.\n+The samples under the [`samples`](..\/samples) direcotry are also a good source of examples.\n@@ -611,0 +611,60 @@\n+### Array Types\n+\n+Jextract treats variables (global variables or struct\/union fields) with an array type\n+specially. For instance, if we have a header file with the following declaration:\n+\n+```c\n+\/\/ mylib.h\n+\n+int FOO_ARRAY[3][5];\n+```\n+\n+Jextract generates a few extra methods that are useful for working with arrays:\n+\n+```java\n+\/\/ mylib_h.java\n+\n+public static MemorySegment FOO_ARRAY() { ... } \/\/ 1\n+public static void FOO_ARRAY(MemorySegment varValue) { ... } \/\/ 1\n+\n+public static int FOO_ARRAY(long index0, long index1) { ... } \/\/ 2\n+public static void FOO_ARRAY(long index0, long index1, int varValue) { ... } \/\/ 2\n+\n+public static SequenceLayout FOO_ARRAY$layout() { ... } \/\/ 3\n+public static long[] FOO_ARRAY$dimensions() { ... } \/\/ 4\n+```\n+\n+Jextract generates:\n+\n+1. a getter and setter pair for the array variable. Note that the getter replaces the usual\n+  `XYZ$segment` method that jextract generates for global variables, as the results of the\n+  two methods would be identical.\n+2. a pair of _indexed_ getter and setter methods. These methods can be used to get or set\n+  a single element of the array. Each leading `long` parameter represents an index of one\n+  of the dimensions of the array.\n+3. a layout accessor, just like we have for a regular variable, but note that the return\n+  type is [`SequenceLayout`].\n+4. a `$dimensions` meta-data accessor, which returns the _dimensions_ of the array type.\n+  This method returns a `long[]` where each element represents the length of a dimension\n+  of the array type. For instance, in the example `FOO_ARRAY` has two dimensions - `3` and\n+  `5` respectively - so the `FOO_ARRAY$dimensions` method will return a `long[]`\n+  with two elements whose values are `3` and `5` in that order.\n+\n+For struct and union fields, the generate methods are comparable, with an additional\n+leading `MemorySegment` parameter for the getters and setters, representing the struct or\n+union instance.\n+\n+Using the generated methods, we can access the elements of `FOO_ARRAY` as follows:\n+\n+```java\n+\/\/ Main.java\n+\n+for (long i = 0; i < FOO_ARRAY$dimensions()[0]; i++) {\n+    for (long j = 0; j < FOO_ARRAY$dimensions()[1]; j++) {\n+        \/\/ print out element at FOO_ARRAY[i][j]\n+        int e = FOO_ARRAY(i, j);\n+        System.out.println(\"FOO_ARRAY[\" + i + \"][\" + j + \"] = \" + e);\n+    }\n+}\n+```\n+\n@@ -933,0 +993,1 @@\n+[`SequenceLayout`]: https:\/\/docs.oracle.com\/en\/java\/javase\/22\/docs\/api\/java.base\/java\/lang\/foreign\/SequenceLayout.html\n","filename":"doc\/GUIDE.md","additions":62,"deletions":1,"binary":false,"changes":63,"status":"modified"}]}