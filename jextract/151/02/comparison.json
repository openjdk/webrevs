{"files":[{"patch":"@@ -33,1 +33,0 @@\n-import org.openjdk.jextract.impl.UnsupportedLayouts;\n@@ -106,1 +105,1 @@\n-            Char16(\"char16\", UnsupportedLayouts.CHAR16),\n+            Char16(\"char16\", unsupportedLayout(2, \"char16\")),\n@@ -128,1 +127,1 @@\n-            Int128(\"__int128\", UnsupportedLayouts.__INT128),\n+            Int128(\"__int128\", unsupportedLayout(16, \"__int128\")),\n@@ -142,1 +141,1 @@\n-                    UnsupportedLayouts.LONG_DOUBLE),\n+                    unsupportedLayout(16, \"long double\")),\n@@ -146,1 +145,1 @@\n-            Float128(\"float128\", UnsupportedLayouts._FLOAT128),\n+            Float128(\"float128\", unsupportedLayout(16, \"_float128\")),\n@@ -150,1 +149,1 @@\n-            HalfFloat(\"__fp16\", UnsupportedLayouts.__FP16),\n+            HalfFloat(\"__fp16\", unsupportedLayout(2, \"__fp16\")),\n@@ -154,1 +153,1 @@\n-            WChar(\"wchar_t\", UnsupportedLayouts.WCHAR_T);\n+            WChar(\"wchar_t\", unsupportedLayout(2, \"wchar_t\"));\n@@ -175,0 +174,4 @@\n+\n+            private static MemoryLayout unsupportedLayout(long size, String name) {\n+                return MemoryLayout.paddingLayout(size).withByteAlignment(size).withName(name);\n+            }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Type.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -38,6 +38,7 @@\n-        var transformedDecl = Stream.of(decl).\n-            map(new IncludeFilter(includeHelper)::process).\n-            map(new EnumConstantLifter()::transform).\n-            map(new DuplicateFilter()::transform).\n-            map(new NameMangler(headerName)::scan).\n-            findFirst().get();\n+        var transformedDecl = Stream.of(decl)\n+                .map(new IncludeFilter(includeHelper)::scan)\n+                .map(new EnumConstantLifter()::scan)\n+                .map(new DuplicateFilter()::scan)\n+                .map(new NameMangler(headerName)::scan)\n+                .map(new UnsupportedFilter()::scan)\n+                .findFirst().get();\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/CodeGenerator.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+\n@@ -385,0 +386,4 @@\n+        public static void with(Type type) {\n+            type.addAttribute(INSTANCE);\n+        }\n+\n@@ -388,0 +393,4 @@\n+\n+        public static boolean isPresent(Type type) {\n+            return type.getAttribute(Skip.class).isPresent();\n+        }\n@@ -393,3 +402,3 @@\n-    record JavaName(String name) {\n-        public static void with(Declaration declaration, String javaName) {\n-            declaration.addAttribute(new JavaName(javaName));\n+    record JavaName(List<String> names) {\n+        public static void with(Declaration declaration, List<String> names) {\n+            declaration.addAttribute(new JavaName(names));\n@@ -400,1 +409,6 @@\n-                    .map(JavaName::name).get();\n+                    .map(javaName -> javaName.names.getLast()).get();\n+        }\n+\n+        public static String getFullNameOrThrow(Declaration declaration) {\n+            return declaration.getAttribute(JavaName.class)\n+                    .map(javaName -> String.join(\".\", javaName.names)).get();\n@@ -430,0 +444,5 @@\n+        public static Optional<String> get(Declaration declaration) {\n+            return declaration.getAttribute(JavaFunctionalInterfaceName.class)\n+                    .map(JavaFunctionalInterfaceName::fiName);\n+        }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/DeclarationImpl.java","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    public Declaration.Scoped transform(Declaration.Scoped header) {\n+    public Declaration.Scoped scan(Declaration.Scoped header) {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/DuplicateFilter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    public Declaration.Scoped transform(Declaration.Scoped header) {\n+    public Declaration.Scoped scan(Declaration.Scoped header) {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/EnumConstantLifter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    public Declaration.Scoped process(Declaration.Scoped header) {\n+    public Declaration.Scoped scan(Declaration.Scoped header) {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/IncludeFilter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jextract.Type.Delegated;\n@@ -33,0 +34,2 @@\n+import java.util.ArrayList;\n+import java.util.HashMap;\n@@ -34,0 +37,2 @@\n+import java.util.List;\n+import java.util.Map;\n@@ -45,0 +50,6 @@\n+    \/*\n+     * This map is needed because there is no way to share attributes between a typedef declaration\n+     * and the typedef type pointing to that declaration. As such, we need to store typedef names in a map\n+     * so that we can recover them later when we see a variable decl whose type is a typedef.\n+     *\/\n+    private final Map<Type, String> functionTypeDefNames = new HashMap<>();\n@@ -88,0 +99,10 @@\n+\n+         List<String> fullName() {\n+             List<String> names = new ArrayList<>();\n+             Scope current = this;\n+             while (current != null && current.isStruct) {\n+                 names.add(0, current.className);\n+                 current = current.parent;\n+             }\n+             return names;\n+         }\n@@ -100,1 +121,1 @@\n-        JavaName.with(header, javaName);\n+        JavaName.with(header, List.of(javaName));\n@@ -149,1 +170,1 @@\n-            JavaName.with(scoped, curScope.className());\n+            JavaName.with(scoped, curScope.fullName());\n@@ -175,1 +196,1 @@\n-        JavaName.with(typedef, javaName);\n+        JavaName.with(typedef, List.of(javaName));\n@@ -189,0 +210,1 @@\n+           functionTypeDefNames.put(typedef.type(), javaName);\n@@ -205,0 +227,5 @@\n+        } else if (variable.type() instanceof Delegated delegatedType) {\n+            String typedefName = functionTypeDefNames.get(delegatedType.type());\n+            if (typedefName != null) {\n+                JavaFunctionalInterfaceName.with(variable, typedefName);\n+            }\n@@ -214,2 +241,4 @@\n-    private String makeJavaName(Declaration decl) {\n-        return decl.name().isEmpty()? decl.name() : javaSafeIdentifier(decl.name());\n+    private List<String> makeJavaName(Declaration decl) {\n+        return decl.name().isEmpty() ?\n+                List.of(decl.name()) :\n+                List.of(javaSafeIdentifier(decl.name()));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/NameMangler.java","additions":34,"deletions":5,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-import java.util.HashMap;\n-import java.util.HashSet;\n@@ -47,1 +45,0 @@\n-import java.util.Map;\n@@ -49,1 +46,0 @@\n-import java.util.Set;\n@@ -61,27 +57,0 @@\n-    private final Map<Declaration.Scoped, String> structClassNames = new HashMap<>();\n-    private final Set<Declaration.Typedef> unresolvedStructTypedefs = new HashSet<>();\n-    private final Map<Type.Delegated, String> functionTypeDefNames = new HashMap<>();\n-\n-    private void addStructDefinition(Declaration.Scoped decl, String name) {\n-        structClassNames.put(decl, name);\n-    }\n-\n-    private boolean structDefinitionSeen(Declaration.Scoped decl) {\n-        return structClassNames.containsKey(decl);\n-    }\n-\n-    private String structDefinitionName(Declaration.Scoped decl) {\n-        return structClassNames.get(decl);\n-    }\n-\n-    private void addFunctionTypedef(Declaration declaration, Type.Delegated typedef) {\n-        functionTypeDefNames.put(typedef, JavaFunctionalInterfaceName.getOrThrow(declaration));\n-    }\n-\n-    private boolean functionTypedefSeen(Type.Delegated typedef) {\n-        return functionTypeDefNames.containsKey(typedef);\n-    }\n-\n-    private String functionTypedefName(Type.Delegated decl) {\n-        return functionTypeDefNames.get(decl);\n-    }\n@@ -106,5 +75,0 @@\n-        \/\/ check if unresolved typedefs can be resolved now!\n-        for (Declaration.Typedef td : unresolvedStructTypedefs) {\n-            Declaration.Scoped structDef = ((Type.Declared) td.type()).tree();\n-            toplevelBuilder.addTypedef(td, structDefinitionName(structDef));\n-        }\n@@ -162,4 +126,0 @@\n-        if (clazz == null) {\n-            warn(\"skipping \" + constant.name() + \" because of unsupported type usage\");\n-            return null;\n-        }\n@@ -175,4 +135,0 @@\n-        if (d.layout().isEmpty() || structDefinitionSeen(d)) {\n-            \/\/skip decl\n-            return null;\n-        }\n@@ -180,0 +136,1 @@\n+        Skip.with(d); \/\/ do not generate twice\n@@ -189,6 +146,0 @@\n-            if (!d.name().isEmpty()) {\n-                addStructDefinition(d, structBuilder.fullName());\n-            }\n-            if (parent instanceof Declaration.Typedef) {\n-                addStructDefinition(d, structBuilder.fullName());\n-            }\n@@ -207,21 +158,3 @@\n-    private boolean generateFunctionalInterface(Declaration decl, Type.Function func) {\n-        String unsupportedType = UnsupportedLayouts.firstUnsupportedType(func);\n-        if (unsupportedType != null) {\n-            warn(\"skipping \" + JavaName.getOrThrow(decl) + \" because of unsupported type usage: \" +\n-                    unsupportedType);\n-            return false;\n-        }\n-\n-        FunctionDescriptor descriptor = Type.descriptorFor(func).orElse(null);\n-        if (descriptor == null) {\n-            return false;\n-        }\n-\n-        \/\/generate functional interface\n-        if (func.varargs() && !func.argumentTypes().isEmpty()) {\n-            warn(\"varargs in callbacks is not supported: \" + CDeclarationPrinter.declaration(func, JavaName.getOrThrow(decl)));\n-            return false;\n-        }\n-\n-        currentBuilder.addFunctionalInterface(decl, func, descriptor);\n-        return true;\n+    private void generateFunctionalInterface(String name, Type.Function func) {\n+        FunctionDescriptor descriptor = Type.descriptorFor(func).get();\n+        currentBuilder.addFunctionalInterface(name, func, descriptor);\n@@ -235,12 +168,0 @@\n-        \/\/generate static wrapper for function\n-        String unsupportedType = UnsupportedLayouts.firstUnsupportedType(funcTree.type());\n-        if (unsupportedType != null) {\n-            warn(\"skipping \" + funcTree.name() + \" because of unsupported type usage: \" +\n-                    unsupportedType);\n-            return null;\n-        }\n-\n-        FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).orElse(null);\n-        if (descriptor == null) {\n-            return null;\n-        }\n@@ -249,1 +170,0 @@\n-        int i = 0;\n@@ -253,4 +173,1 @@\n-                if (! generateFunctionalInterface(param, f)) {\n-                    return null;\n-                }\n-                i++;\n+                generateFunctionalInterface(JavaFunctionalInterfaceName.getOrThrow(param), f);\n@@ -263,3 +180,1 @@\n-             if (! generateFunctionalInterface(funcTree, returnFunc)) {\n-                 return null;\n-             }\n+             generateFunctionalInterface(JavaFunctionalInterfaceName.getOrThrow(funcTree), returnFunc);\n@@ -268,0 +183,1 @@\n+        FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).get();\n@@ -272,10 +188,0 @@\n-    Optional<String> getAsFunctionPointerTypedef(Type type) {\n-        if (type instanceof Type.Delegated delegated &&\n-                delegated.kind() == Type.Delegated.Kind.TYPEDEF &&\n-                functionTypedefSeen(delegated)) {\n-            return Optional.of(functionTypedefName(delegated));\n-        } else {\n-            return Optional.empty();\n-        }\n-    }\n-\n@@ -307,9 +213,1 @@\n-                            if (structDefinitionSeen(s)) {\n-                                toplevelBuilder.addTypedef(tree, structDefinitionName(s));\n-                            } else {\n-                                \/*\n-                                 * Definition of typedef'ed struct\/union not seen yet. May be the definition comes later.\n-                                 * Save it to visit at the end of all declarations.\n-                                 *\/\n-                                unresolvedStructTypedefs.add(tree);\n-                            }\n+                            toplevelBuilder.addTypedef(tree, s.layout().isEmpty() ? null : JavaName.getFullNameOrThrow(s));\n@@ -326,4 +224,1 @@\n-                boolean funcIntfGen = generateFunctionalInterface(tree, func);\n-                if (funcIntfGen) {\n-                    addFunctionTypedef(tree, Type.typedef(tree.name(), tree.type()));\n-                }\n+                generateFunctionalInterface(JavaFunctionalInterfaceName.getOrThrow(tree), func);\n@@ -354,12 +249,0 @@\n-        MemoryLayout layout = Type.layoutFor(type).orElse(null);\n-        if (layout == null) {\n-            \/\/no layout - abort\n-            return null;\n-        }\n-\n-        if (tree.kind() == Declaration.Variable.Kind.BITFIELD ||\n-                (layout instanceof ValueLayout && layout.byteSize() > 8)) {\n-            \/\/skip\n-            return null;\n-        }\n-\n@@ -369,18 +252,1 @@\n-        String unsupportedType = UnsupportedLayouts.firstUnsupportedType(type);\n-        if (unsupportedType != null) {\n-            String name = parent != null? parent.name() + \".\" : \"\";\n-            name += fieldName;\n-            warn(\"skipping \" + name + \" because of unsupported type usage: \" +\n-                    unsupportedType);\n-            return null;\n-        }\n-\n-        Class<?> clazz = getJavaType(type);\n-        if (clazz == null) {\n-            String name = parent != null? parent.name() + \".\" : \"\";\n-            name += fieldName;\n-            warn(\"skipping \" + name + \" because of unsupported type usage\");\n-            return null;\n-        }\n-\n-\n+        Optional<String> fiName = JavaFunctionalInterfaceName.get(tree);\n@@ -388,1 +254,0 @@\n-        String fiName = null;\n@@ -390,9 +255,1 @@\n-            fiName = JavaFunctionalInterfaceName.getOrThrow(tree);\n-            if (! generateFunctionalInterface(tree, func)) {\n-                fiName = null;\n-            }\n-        } else {\n-            Optional<String> funcTypedef = getAsFunctionPointerTypedef(type);\n-            if (funcTypedef.isPresent()) {\n-                fiName = funcTypedef.get();\n-            }\n+            generateFunctionalInterface(fiName.get(), func);\n@@ -401,2 +258,2 @@\n-        currentBuilder.addVar(tree, layout, Optional.ofNullable(fiName));\n-\n+        MemoryLayout layout = Type.layoutFor(type).get();\n+        currentBuilder.addVar(tree, layout, fiName);\n@@ -417,4 +274,0 @@\n-    static void warn(String msg) {\n-        System.err.println(\"WARNING: \" + msg);\n-    }\n-\n@@ -459,1 +312,1 @@\n-        default void addFunctionalInterface(Declaration declaration, Type.Function funcType, FunctionDescriptor descriptor) {\n+        default void addFunctionalInterface(String name, Type.Function funcType, FunctionDescriptor descriptor) {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":14,"deletions":161,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+            indent();\n@@ -66,1 +67,0 @@\n-                incr();\n@@ -68,0 +68,2 @@\n+                incr();\n+                indent();\n@@ -72,0 +74,1 @@\n+            builder.append(\"\\n\");\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/PrettyPrinter.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-    public void addFunctionalInterface(Declaration declaration, Type.Function funcType, FunctionDescriptor descriptor) {\n+    public void addFunctionalInterface(String name, Type.Function funcType, FunctionDescriptor descriptor) {\n@@ -138,1 +138,1 @@\n-        FunctionalInterfaceBuilder.generate(sourceFileBuilder(), JavaFunctionalInterfaceName.getOrThrow(declaration),\n+        FunctionalInterfaceBuilder.generate(sourceFileBuilder(), name,\n@@ -147,7 +147,0 @@\n-        try {\n-            structLayout.byteOffset(elementPaths(nativeName));\n-        } catch (UnsupportedOperationException uoe) {\n-            \/\/ bad layout - do nothing\n-            OutputFactory.warn(\"skipping '\" + className() + \".\" + nativeName + \"' : \" + uoe.toString());\n-            return;\n-        }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructBuilder.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -135,2 +135,2 @@\n-    public void addFunctionalInterface(Declaration declaration, Type.Function funcType, FunctionDescriptor descriptor) {\n-        SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName(), JavaFunctionalInterfaceName.getOrThrow(declaration));\n+    public void addFunctionalInterface(String name, Type.Function funcType, FunctionDescriptor descriptor) {\n+        SourceFileBuilder sfb = SourceFileBuilder.newSourceFile(packageName(), name);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ToplevelBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.foreign.PaddingLayout;\n@@ -41,0 +42,1 @@\n+import org.openjdk.jextract.impl.DeclarationImpl.Skip;\n@@ -78,0 +80,4 @@\n+            if (kind.layout().isPresent() && kind.layout().get() instanceof PaddingLayout) {\n+                \/\/ this type is unsupported, add a Skip attribute\n+                Skip.with(this);\n+            }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypeImpl.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,244 @@\n+\/*\n+ * Copyright (c) 2023 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Declaration.Constant;\n+import org.openjdk.jextract.Declaration.Function;\n+import org.openjdk.jextract.Declaration.Scoped;\n+import org.openjdk.jextract.Declaration.Typedef;\n+import org.openjdk.jextract.Declaration.Variable;\n+import org.openjdk.jextract.Type;\n+import org.openjdk.jextract.Type.Declared;\n+import org.openjdk.jextract.impl.DeclarationImpl.JavaName;\n+import org.openjdk.jextract.impl.DeclarationImpl.Skip;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n+\n+\/*\n+ * This visitor marks a number of unsupported construct so that they are skipped by code generation.\n+ * Unsupported constructs are:\n+ * - declarations containing an unsupported type (e.g. \"long128\")\n+ * - structs\/unions.variables for which no layout exists\n+ * - functions\/function pointer for which no descriptor exists\n+ * - variadic function pointers\n+ * - bitfields struct members\n+ *\/\n+public class UnsupportedFilter implements Declaration.Visitor<Void, Declaration> {\n+    static String firstUnsupportedType(Type type) {\n+        return type.accept(UNSUPPORTED_VISITOR, null);\n+    }\n+\n+    public Declaration.Scoped scan(Declaration.Scoped header) {\n+        header.members().forEach(fieldTree -> fieldTree.accept(this, null));\n+        return header;\n+    }\n+\n+    @Override\n+    public Void visitFunction(Function funcTree, Declaration parent) {\n+        \/\/generate static wrapper for function\n+        String unsupportedType = firstUnsupportedType(funcTree.type());\n+        if (unsupportedType != null) {\n+            warn(\"skipping \" + funcTree.name() + \" because of unsupported type usage: \" +\n+                    unsupportedType);\n+            Skip.with(funcTree);\n+        } else {\n+            FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).orElse(null);\n+            if (descriptor == null) {\n+                Skip.with(funcTree);\n+            }\n+        }\n+\n+        \/\/ check function pointers in parameters and return types\n+        for (Declaration.Variable param : funcTree.parameters()) {\n+            Type.Function f = Utils.getAsFunctionPointer(param.type());\n+            if (f != null && !checkFunctionTypeSupported(param, f)) {\n+                Skip.with(funcTree);\n+            }\n+        }\n+\n+        Type.Function returnFunc = Utils.getAsFunctionPointer(funcTree.type().returnType());\n+        if (returnFunc != null && !checkFunctionTypeSupported(funcTree, returnFunc)) {\n+            Skip.with(funcTree);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitVariable(Variable varTree, Declaration parent) {\n+        String unsupportedType = firstUnsupportedType(varTree.type());\n+        if (unsupportedType != null) {\n+            String name = parent != null ? parent.name() + \".\" : \"\";\n+            name += varTree.name();\n+            warn(\"skipping \" + name + \" because of unsupported type usage: \" +\n+                    unsupportedType);\n+            Skip.with(varTree);\n+        } else {\n+            MemoryLayout layout = Type.layoutFor(varTree.type()).orElse(null);\n+            if (layout == null) {\n+                \/\/no layout - skip\n+                Skip.with(varTree);\n+            }\n+\n+            if (varTree.kind() == Declaration.Variable.Kind.BITFIELD ||\n+                    (layout instanceof ValueLayout && layout.byteSize() > 8)) {\n+                \/\/skip\n+                Skip.with(varTree);\n+            }\n+        }\n+\n+        \/\/ check\n+        Type.Function func = Utils.getAsFunctionPointer(varTree.type());\n+        if (func != null) {\n+            checkFunctionTypeSupported(varTree, func);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitScoped(Scoped scoped, Declaration declaration) {\n+        if (scoped.layout().isEmpty()) {\n+            \/\/ skip\n+            Skip.with(scoped);\n+        }\n+        \/\/ propagate\n+        scoped.members().forEach(fieldTree -> {\n+            fieldTree.accept(this, scoped);\n+        });\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitTypedef(Typedef typedefTree, Declaration declaration) {\n+        Type.Function func = Utils.getAsFunctionPointer(typedefTree.type());\n+        if (func != null && !checkFunctionTypeSupported(typedefTree, func)) {\n+            Skip.with(typedefTree);\n+        }\n+        \/\/ propagate\n+        if (typedefTree.type() instanceof Declared declared) {\n+            visitScoped(declared.tree(), null);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitConstant(Constant d, Declaration declaration) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitDeclaration(Declaration d, Declaration declaration) {\n+        return null;\n+    }\n+\n+    private boolean checkFunctionTypeSupported(Declaration decl, Type.Function func) {\n+        String unsupportedType = firstUnsupportedType(func);\n+        if (unsupportedType != null) {\n+            warn(\"skipping \" + JavaName.getOrThrow(decl) + \" because of unsupported type usage: \" +\n+                    unsupportedType);\n+            return false;\n+        } else {\n+            FunctionDescriptor descriptor = Type.descriptorFor(func).orElse(null);\n+            if (descriptor == null) {\n+                return false;\n+            }\n+\n+            \/\/generate functional interface\n+            if (func.varargs() && !func.argumentTypes().isEmpty()) {\n+                warn(\"varargs in callbacks is not supported: \" + CDeclarationPrinter.declaration(func, JavaName.getOrThrow(decl)));\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private static final Type.Visitor<String, Void> UNSUPPORTED_VISITOR = new Type.Visitor<>() {\n+        @Override\n+        public String visitPrimitive(Type.Primitive t, Void unused) {\n+            if (Skip.isPresent(t)) {\n+                return t.kind().layout().get().name().get();\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public String visitFunction(Type.Function t, Void unused) {\n+            for (Type arg : t.argumentTypes()) {\n+                String unsupported = firstUnsupportedType(arg);\n+                if (unsupported != null) {\n+                    return unsupported;\n+                }\n+            }\n+            String unsupported = firstUnsupportedType(t.returnType());\n+            if (unsupported != null) {\n+                return unsupported;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public String visitDeclared(Type.Declared t, Void unused) {\n+            for (Declaration d : t.tree().members()) {\n+                if (d instanceof Declaration.Variable variable) {\n+                    String unsupported = firstUnsupportedType(variable.type());\n+                    if (unsupported != null) {\n+                        return unsupported;\n+                    }\n+                }\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public String visitDelegated(Type.Delegated t, Void unused) {\n+            return t.kind() != Type.Delegated.Kind.POINTER ?\n+                    firstUnsupportedType(t.type()) :\n+                    null;\n+            \/\/in principle we should always do this:\n+            \/\/ return firstUnsupportedType(t.type());\n+            \/\/ but if we do that, we might end up with infinite recursion (because of pointer types).\n+            \/\/ Unsupported pointer types (e.g. *long double) are not detected, but they are not problematic layout-wise\n+            \/\/ (e.g. they are always 32- or 64-bits, depending on the platform).\n+        }\n+\n+        @Override\n+        public String visitArray(Type.Array t, Void unused) {\n+            return firstUnsupportedType(t.elementType());\n+        }\n+\n+        @Override\n+        public String visitType(Type t, Void unused) {\n+            return null;\n+        }\n+    };\n+\n+    private static void warn(String msg) {\n+        System.err.println(\"WARNING: \" + msg);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnsupportedFilter.java","additions":244,"deletions":0,"binary":false,"changes":244,"status":"added"},{"patch":"@@ -1,120 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.jextract.impl;\n-\n-import java.lang.foreign.MemoryLayout;\n-import org.openjdk.jextract.Declaration;\n-import org.openjdk.jextract.Type;\n-\n-import java.nio.ByteOrder;\n-\n-\/*\n- * Layouts for the primitive types not supported by ABI implementations.\n- *\/\n-public final class UnsupportedLayouts {\n-    private UnsupportedLayouts() {}\n-\n-    public static final MemoryLayout __INT128 = makeUnsupportedLayout(16, \"__int128\");\n-\n-    public static final MemoryLayout LONG_DOUBLE = makeUnsupportedLayout(16, \"long double\");\n-\n-    public static final MemoryLayout _FLOAT128 = makeUnsupportedLayout(16, \"_float128\");\n-\n-    public static final MemoryLayout __FP16 = makeUnsupportedLayout(2, \"__fp16\");\n-\n-    public static final MemoryLayout CHAR16 = makeUnsupportedLayout(2, \"char16\");\n-\n-    public static final MemoryLayout WCHAR_T = makeUnsupportedLayout(2, \"wchar_t\");\n-\n-    static String firstUnsupportedType(Type type) {\n-        return type.accept(unsupportedVisitor, null);\n-    }\n-\n-    private static MemoryLayout makeUnsupportedLayout(long size, String name) {\n-        return MemoryLayout.paddingLayout(size).withByteAlignment(size).withName(name);\n-    }\n-\n-    static Type.Visitor<String, Void> unsupportedVisitor = new Type.Visitor<>() {\n-        @Override\n-        public String visitPrimitive(Type.Primitive t, Void unused) {\n-            MemoryLayout layout = t.kind().layout().orElse(MemoryLayout.paddingLayout(8));\n-            if (layout.equals(__INT128) || layout.equals(LONG_DOUBLE) || layout.equals(_FLOAT128) || layout.equals(__FP16)) {\n-                return layout.name().get();\n-            } else {\n-                return null;\n-            }\n-        }\n-\n-        @Override\n-        public String visitFunction(Type.Function t, Void unused) {\n-            for (Type arg : t.argumentTypes()) {\n-                String unsupported = firstUnsupportedType(arg);\n-                if (unsupported != null) {\n-                    return unsupported;\n-                }\n-            }\n-            String unsupported = firstUnsupportedType(t.returnType());\n-            if (unsupported != null) {\n-                return unsupported;\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public String visitDeclared(Type.Declared t, Void unused) {\n-            for (Declaration d : t.tree().members()) {\n-                if (d instanceof Declaration.Variable variable) {\n-                    String unsupported = firstUnsupportedType(variable.type());\n-                    if (unsupported != null) {\n-                        return unsupported;\n-                    }\n-                }\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public String visitDelegated(Type.Delegated t, Void unused) {\n-            return t.kind() != Type.Delegated.Kind.POINTER ?\n-                    firstUnsupportedType(t.type()) :\n-                    null;\n-            \/\/in principle we should always do this:\n-            \/\/ return firstUnsupportedType(t.type());\n-            \/\/ but if we do that, we might end up with infinite recursion (because of pointer types).\n-            \/\/ Unsupported pointer types (e.g. *long double) are not detected, but they are not problematic layout-wise\n-            \/\/ (e.g. they are always 32- or 64-bits, depending on the platform).\n-        }\n-\n-        @Override\n-        public String visitArray(Type.Array t, Void unused) {\n-            return firstUnsupportedType(t.elementType());\n-        }\n-\n-        @Override\n-        public String visitType(Type t, Void unused) {\n-            return null;\n-        }\n-    };\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnsupportedLayouts.java","additions":0,"deletions":120,"binary":false,"changes":120,"status":"deleted"}]}