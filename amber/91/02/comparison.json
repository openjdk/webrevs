{"files":[{"patch":"@@ -0,0 +1,280 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.runtime;\n+\n+\/**\n+ * Exactness methods to test whether a conversion between types would be\n+ * exact when not enough static information is present. These methods may\n+ * be used, for example, by Java compiler implementations to implement checks\n+ * for instanceof and pattern matching runtime implementations.\n+ *\n+ * @since 21\n+ *\/\n+public class ExactnessMethods {\n+\n+    private ExactnessMethods() { }\n+\n+    \/** Exactness method from byte to char\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean byte_char(byte n)    {return n == (char) n;}\n+\n+    \/** Exactness method from short to byte\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean short_byte(short n)  {return n == (short)(byte)(n);}\n+\n+    \/** Exactness method from short to char\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean short_char(short n)  {return n == (char)(n);}\n+\n+    \/** Exactness method from char to byte\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean char_byte(char n)    {return n == (byte)(n);}\n+\n+    \/** Exactness method from char to short\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean char_short(char n)   {return n == (short)(n);}\n+\n+     \/** Exactness method from int to byte\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean int_byte(int n)      {return n == (int)(byte)(n);}\n+\n+    \/** Exactness method from int to short\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean int_short(int n)     {return n == (int)(short)(n);}\n+\n+    \/** Exactness method from int to char\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean int_char(int n)      {return n == (char)(n);}\n+\n+    \/** Exactness method from int to float\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean int_float(int n) { return n == (int)(float)n && n != Integer.MAX_VALUE; }\n+\n+    \/** Exactness method from long to byte\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean long_byte(long n)    {return n == (long)(byte)(n);}\n+\n+    \/** Exactness method from long to short\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean long_short(long n)   {return n == (long)(short)(n);}\n+\n+    \/** Exactness method from long to char\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean long_char(long n)    {return n == (char)(n);}\n+\n+    \/** Exactness method from long to int\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean long_int(long n)     {return n == (long)(int)(n);}\n+\n+    \/** Exactness method from long to float\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean long_float(long n) {\n+        return n == (long)(float)n && n != Long.MAX_VALUE;\n+    }\n+\n+    \/** Exactness method from long to double\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean long_double(long n) {\n+        return n == (long)(double)n && n != Long.MAX_VALUE;\n+    }\n+\n+    \/** Exactness method from float to byte\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean float_byte(float n)  {\n+        return n == (float)(byte)n && !isNegativeZero(n);\n+    }\n+\n+    \/** Exactness method from float to short\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean float_short(float n) {\n+        return n == (float)(short)n && !isNegativeZero(n);\n+    }\n+\n+    \/** Exactness method from float to char\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean float_char(float n)  {\n+        return n == (float)(char)n && !isNegativeZero(n);\n+    }\n+\n+    \/** Exactness method from float to int\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean float_int(float n) {\n+        return n == (float)(int)n && n != 0x1p31f && !isNegativeZero(n);\n+    }\n+\n+    \/** Exactness method from float to long\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean float_long(float n) {\n+        return n == (float)(long)n && n != 0x1p63f && !isNegativeZero(n);\n+    }\n+\n+    \/** Exactness method from double to byte\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean double_byte(double n) {\n+        return n == (double)(byte)n && !isNegativeZero(n);\n+    }\n+\n+    \/** Exactness method from double to short\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean double_short(double n){\n+        return n == (double)(short)n && !isNegativeZero(n);\n+    }\n+\n+    \/** Exactness method from double to char\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean double_char(double n) {\n+        return n == (double)(char)n && !isNegativeZero(n);\n+    }\n+\n+    \/** Exactness method from double to int\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean double_int(double n)  {\n+        return n == (double)(int)n && !isNegativeZero(n);\n+    }\n+\n+    \/** Exactness method from double to long\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean double_long(double n) {\n+        return n == (double)(long)n && n != 0x1p63 && !isNegativeZero(n);\n+    }\n+\n+    \/** Exactness method from double to float\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean double_float(double n) {\n+        return n == (double)(float)n || n != n;\n+    }\n+\n+    private static boolean isNegativeZero(float n) {\n+        return Float.floatToRawIntBits(n) == Integer.MIN_VALUE;\n+    }\n+\n+    private static boolean isNegativeZero(double n) {\n+        return Double.doubleToRawLongBits(n) == Long.MIN_VALUE;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ExactnessMethods.java","additions":280,"deletions":0,"binary":false,"changes":280,"status":"added"},{"patch":"@@ -138,6 +138,0 @@\n-        Class<?> labelClass = label.getClass();\n-        if (labelClass != Class.class &&\n-            labelClass != String.class &&\n-            labelClass != Integer.class) {\n-            throw new IllegalArgumentException(\"label with illegal type found: \" + label.getClass());\n-        }\n@@ -152,1 +146,5 @@\n-        for (int i = startIndex; i < labels.length; i++) {\n+\n+        \/\/ The last item in the `labels` array is used to pass the selector type\n+        Object selector = labels[labels.length - 1];\n+\n+        for (int i = startIndex; i < labels.length - 1; i++) {\n@@ -155,0 +153,41 @@\n+                if (c.isPrimitive()) {\n+                    try {\n+                        \/\/ selector instanceof p         \/\/ where selector: Object , p: primitive\n+                        \/\/ =>\n+                        \/\/ selector instanceof Primitive \/\/ where selector: Object , p: box of primitive\n+                        if (((Class<?>) selector).isInstance(Object.class)) {\n+                            if ((c.isAssignableFrom(byte.class) && target instanceof Byte) ||\n+                                 (c.isAssignableFrom(short.class) && target instanceof Short) ||\n+                                 (c.isAssignableFrom(char.class) && target instanceof Character) ||\n+                                 (c.isAssignableFrom(int.class) && target instanceof Integer) ||\n+                                 (c.isAssignableFrom(double.class) && target instanceof Double) ||\n+                                 (c.isAssignableFrom(float.class) && target instanceof Float) ||\n+                                 (c.isAssignableFrom(long.class) && target instanceof Long)) return i;\n+                        }\n+                        else if (!((Class<?>) selector).isPrimitive()) {\n+                            if ((c.equals(byte.class) && target instanceof Byte) ||\n+                                (c.equals(short.class) && target instanceof Short) ||\n+                                (c.equals(char.class) && target instanceof Character) ||\n+                                (c.equals(int.class) && target instanceof Integer) ||\n+                                (c.equals(double.class) && target instanceof Double) ||\n+                                (c.equals(float.class) && target instanceof Float)||\n+                                (c.equals(long.class) && target instanceof Long))\n+                                return i;\n+                        } else if (c.equals(selector) ||\n+                                (selector.equals(byte.class) && !c.equals(char.class)   ||\n+                                (selector.equals(short.class) && (c.equals(int.class)   || c.equals(long.class) || c.equals(float.class) || c.equals(double.class)))||\n+                                (selector.equals(char.class)  && (c.equals(int.class)   || c.equals(long.class) || c.equals(float.class) || c.equals(double.class))) ||\n+                                (selector.equals(long.class) && (c.equals(long.class))) ||\n+                                (selector.equals(int.class) && (c.equals(double.class)  || c.equals(long.class))) ||\n+                                (selector.equals(float.class) && (c.equals(double.class))))) {\n+                            return i;\n+                        }\n+                        else {\n+                            if (exactnessCheck(target, selector, c)) {\n+                                return i;\n+                            }\n+                        }\n+                    } catch (Throwable e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n@@ -163,0 +202,3 @@\n+                else if (target instanceof Boolean input && constant.intValue() == (input.booleanValue()?1:0)) {\n+                    return i;\n+                }\n@@ -171,0 +213,11 @@\n+    private static boolean exactnessCheck(Object target, Object selector, Class<?> c) throws Throwable {\n+        \/\/ selector instanceof p    \/\/ where selector: p1 , p: p2\n+        \/\/ =>\n+        \/\/ ExactnessMethods.p1_p2()\n+        String methodName = selector.toString().substring(selector.toString().lastIndexOf(\".\") + 1) + \"_\" + c;\n+        MethodType methodType = MethodType.methodType(boolean.class, (Class<?>) selector);\n+        MethodHandle meth = MethodHandles.lookup().findStatic(ExactnessMethods.class, methodName, methodType);\n+        boolean ret = (boolean) meth.invoke(target);\n+        return ret;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":60,"deletions":7,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+            case PRIMITIVE_PATTERNS -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -239,0 +239,1 @@\n+        PRIMITIVE_PATTERNS(JDK20, Fragments.FeaturePrimitivePatterns, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -166,0 +166,1 @@\n+    public final Type exactnessMethodsType;\n@@ -226,0 +227,1 @@\n+    public final Type constantBootstrapsType;\n@@ -534,0 +536,1 @@\n+        exactnessMethodsType = enterClass(\"java.lang.runtime.ExactnessMethods\");\n@@ -603,0 +606,2 @@\n+        constantBootstrapsType = enterClass(\"java.lang.invoke.ConstantBootstraps\");\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -5011,0 +5011,48 @@\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"Unconditionality\">\n+    \/** Check unconditionality between any combination of reference or primitive types.\n+     *\n+     *  Rules:\n+     *  - widening from one reference type to another,\n+     *  - boxing.\n+     *\n+     *  @param source     Source primitive or reference type\n+     *  @param target     Target primitive or reference type\n+     *\/\n+    public boolean checkUnconditionallyExact(Type source, Type target) {\n+        if (isSameType(source, target)) {\n+            return true;\n+        }\n+\n+        if (target.isPrimitive()) {\n+            return (source.isReference() && isSubtype(boxedTypeOrType(erasure(source)), target)) ||\n+                    (source.isReference() && isExactPrimitiveWidening(unboxedType(source), target) ) ||\n+                    isExactPrimitiveWidening(source, target);\n+        } else {\n+            return isSubtype(boxedTypeOrType(erasure(source)), target);\n+        }\n+    }\n+\n+    \/** Check unconditionality between primitive types.\n+     *\n+     *  - widening from one integral type to another,\n+     *  - widening from one floating point type to another,\n+     *  - widening from byte, short, or char to a floating point type,\n+     *  - widening from int to double.\n+     *\n+     *  @param source     Source primitive type\n+     *  @param target     Target primitive type\n+     *\/\n+    public boolean isExactPrimitiveWidening(Type source, Type target) {\n+        if (isSameType(source, target)) {\n+            return true;\n+        }\n+\n+        return (source.isPrimitive() && target.isPrimitive()) &&\n+                ((source.hasTag(BYTE) && !target.hasTag(CHAR) ||\n+                        (source.hasTag(SHORT) && (target.hasTag(INT) || target.hasTag(LONG) || target.hasTag(FLOAT) || target.hasTag(DOUBLE)))||\n+                        (source.hasTag(CHAR)  && (target.hasTag(INT) || target.hasTag(LONG) || target.hasTag(FLOAT) || target.hasTag(DOUBLE))) ||\n+                        (source.hasTag(LONG) && (target.hasTag(LONG))) ||\n+                        (source.hasTag(INT) && (target.hasTag(DOUBLE) || target.hasTag(LONG))) ||\n+                        (source.hasTag(FLOAT) && (target.hasTag(DOUBLE)))));\n+    }\n+    \/\/ <\/editor-fold>\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -176,0 +176,2 @@\n+        allowPrimitivePatterns = (preview.isEnabled() || !preview.isPreview(Feature.PRIMITIVE_PATTERNS)) &&\n+                Feature.PRIMITIVE_PATTERNS.allowedInSource(source);\n@@ -204,0 +206,4 @@\n+    \/** Are primitive patterns in instanceof allowed\n+     *\/\n+    private final boolean allowPrimitivePatterns;\n+\n@@ -1709,0 +1715,1 @@\n+            JCCaseLabel unconditionalCaseLabel = null;\n@@ -1764,1 +1771,9 @@\n-                                } else if (!stringSwitch && !types.isAssignable(seltype, syms.intType)) {\n+                                } else if ((types.isSameType(pattype, syms.longType) && !(types.isSameType(seltype, syms.longType) || types.isSameType(seltype, types.boxedTypeOrType(syms.longType)))) ||\n+                                        (types.isSameType(pattype, syms.floatType) && !(types.isSameType(seltype, syms.floatType) || types.isSameType(seltype, types.boxedTypeOrType(syms.floatType)))) ||\n+                                        (types.isSameType(pattype, syms.doubleType) && !(types.isSameType(seltype, syms.doubleType) || types.isSameType(seltype, types.boxedTypeOrType(syms.doubleType)))) ||\n+                                        (types.isSameType(pattype, syms.booleanType) && !(types.isSameType(seltype, syms.booleanType) || types.isSameType(seltype, types.boxedTypeOrType(syms.booleanType))))) {\n+                                    log.error(label.pos(), Errors.ConstantLabelNotCompatible(pattype, seltype));\n+                                } else if (!stringSwitch && !(types.isSameType(pattype, syms.longType) ||\n+                                        types.isSameType(pattype, syms.floatType) ||\n+                                        types.isSameType(pattype, syms.doubleType) ||\n+                                        types.isSameType(pattype, syms.booleanType)) && !types.isAssignable(seltype, syms.intType)) {\n@@ -1766,1 +1781,2 @@\n-                                } else if (!constants.add(pattype.constValue())) {\n+                                }\n+                                else if (!constants.add(pattype.constValue())) {\n@@ -1784,1 +1800,2 @@\n-                        if (!primaryType.hasTag(TYPEVAR)) {\n+\n+                        if (!primaryType.hasTag(TYPEVAR) && !primaryType.isPrimitive() && !allowPrimitivePatterns) {\n@@ -1786,0 +1803,8 @@\n+                        } else if (preview.isPreview(Feature.PRIMITIVE_PATTERNS)) {\n+                            if ((pat.hasTag(BINDINGPATTERN) &&\n+                                    ((JCBindingPattern) pat).var.vartype == null)) {\n+                                primaryType = types.createErrorType(syms.errType);\n+                                if (preview.isPreview(Feature.PRIMITIVE_PATTERNS)) {\n+                                    preview.warnPreview(pat.pos(), Feature.PRIMITIVE_PATTERNS);\n+                                }\n+                            }\n@@ -1787,0 +1812,1 @@\n+\n@@ -1805,5 +1831,4 @@\n-                        boolean unconditional =\n-                                unguarded &&\n-                                !patternType.isErroneous() &&\n-                                types.isSubtype(types.boxedTypeOrType(types.erasure(seltype)),\n-                                                patternType);\n+                        boolean unconditional = unguarded && !patternType.isErroneous();\n+\n+                        unconditional &= types.checkUnconditionallyExact(seltype, patternType);\n+\n@@ -1817,0 +1842,1 @@\n+                            unconditionalCaseLabel = label;\n@@ -1839,1 +1865,1 @@\n-                chk.checkSwitchCaseLabelDominated(cases);\n+                chk.checkSwitchCaseLabelDominated(unconditionalCaseLabel, cases);\n@@ -4099,2 +4125,7 @@\n-        Type exprtype = chk.checkNullOrRefType(\n-                tree.expr.pos(), attribExpr(tree.expr, env));\n+        Type exprtype = attribExpr(tree.expr, env);\n+        if(!allowPrimitivePatterns) {\n+            exprtype = chk.checkNullOrRefType(\n+                    tree.expr.pos(), exprtype);\n+        } else if (tree.pattern.type != null && exprtype.isPrimitive() && preview.isPreview(Feature.PRIMITIVE_PATTERNS)) {\n+            preview.warnPreview(tree.pattern.pos(), Feature.PRIMITIVE_PATTERNS);\n+        }\n@@ -4121,13 +4152,2 @@\n-            chk.validate(typeTree, env, false);\n-        }\n-        if (!clazztype.hasTag(TYPEVAR)) {\n-            clazztype = chk.checkClassOrArrayType(typeTree.pos(), clazztype);\n-        }\n-        if (!clazztype.isErroneous() && !types.isReifiable(clazztype)) {\n-            boolean valid = false;\n-            if (allowReifiableTypesInInstanceof) {\n-                valid = checkCastablePattern(tree.expr.pos(), exprtype, clazztype);\n-            } else {\n-                log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n-                          Feature.REIFIABLE_TYPES_INSTANCEOF.error(this.sourceName));\n-                allowReifiableTypesInInstanceof = true;\n+            if (!clazztype.isPrimitive()  || !allowPrimitivePatterns) {\n+                chk.validate(typeTree, env, false);\n@@ -4135,2 +4155,14 @@\n-            if (!valid) {\n-                clazztype = types.createErrorType(clazztype);\n+        }\n+        if(!clazztype.isPrimitive() || !allowPrimitivePatterns) {\n+            if (!clazztype.isErroneous() && !types.isReifiable(clazztype)) {\n+                boolean valid = false;\n+                if (allowReifiableTypesInInstanceof) {\n+                    valid = checkCastablePattern(tree.expr.pos(), exprtype, clazztype);\n+                } else {\n+                    log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n+                            Feature.REIFIABLE_TYPES_INSTANCEOF.error(this.sourceName));\n+                    allowReifiableTypesInInstanceof = true;\n+                }\n+                if (!valid) {\n+                    clazztype = types.createErrorType(clazztype);\n+                }\n@@ -4138,0 +4170,2 @@\n+        } else if (clazztype.isPrimitive() && preview.isPreview(Feature.PRIMITIVE_PATTERNS)) {\n+            preview.warnPreview(tree.pattern.pos(), Feature.PRIMITIVE_PATTERNS);\n@@ -4140,0 +4174,1 @@\n+\n@@ -4155,7 +4190,0 @@\n-        } else if ((exprType.isPrimitive() || pattType.isPrimitive()) &&\n-                   (!exprType.isPrimitive() ||\n-                    !pattType.isPrimitive() ||\n-                    !types.isSameType(exprType, pattType))) {\n-            chk.basicHandler.report(pos,\n-                    diags.fragment(Fragments.NotApplicableTypes(exprType, pattType)));\n-            return false;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":61,"deletions":33,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-import javax.lang.model.element.ExecutableElement;\n@@ -85,2 +84,0 @@\n-import javax.lang.model.type.TypeMirror;\n-import javax.lang.model.util.ElementFilter;\n@@ -4602,1 +4599,1 @@\n-    void checkSwitchCaseLabelDominated(List<JCCase> cases) {\n+    void checkSwitchCaseLabelDominated(JCCaseLabel unconditionalCaseLabel, List<JCCase> cases) {\n@@ -4607,0 +4604,2 @@\n+        boolean unconditionalFound = false;\n+\n@@ -4632,1 +4631,3 @@\n-                    if (types.isSubtype(currentType, testType) &&\n+                    boolean dominated = false;\n+                    if (unconditionalCaseLabel == testCaseLabel) unconditionalFound = true;\n+                    if (types.checkUnconditionallyExact(currentType, testType) &&\n@@ -4635,1 +4636,0 @@\n-                        boolean dominated = false;\n@@ -4644,3 +4644,9 @@\n-                        if (dominated) {\n-                            log.error(label.pos(), Errors.PatternDominated);\n-                        }\n+                    }\n+\n+                    \/\/ Domination can occur even when we have not an unconditional pair between case labels.\n+                    if (unconditionalFound && unconditionalCaseLabel != label) {\n+                        dominated = true;\n+                    }\n+\n+                    if (dominated) {\n+                        log.error(label.pos(), Errors.PatternDominated);\n@@ -4664,1 +4670,3 @@\n-            if (existingPatternType.isPrimitive() ^ currentPatternType.isPrimitive()) {\n+\n+            boolean unconditionallyExact = types.checkUnconditionallyExact(currentPatternType, existingPatternType);\n+            if (!unconditionallyExact) {\n@@ -4667,7 +4675,1 @@\n-            if (existingPatternType.isPrimitive()) {\n-                return types.isSameType(existingPatternType, currentPatternType);\n-            } else {\n-                if (!types.isSubtype(currentPatternType, existingPatternType)) {\n-                    return false;\n-                }\n-            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":19,"deletions":17,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -62,0 +62,2 @@\n+\n+import static com.sun.tools.javac.code.TypeTag.*;\n@@ -654,1 +656,1 @@\n-                        coveredSymbols(jcRecordPattern.pos(), List.of(jcRecordPattern));\n+                        coveredSymbols(jcRecordPattern.pos(), tree.elementType, List.of(jcRecordPattern));\n@@ -706,1 +708,1 @@\n-                Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.cases);\n+                Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.selector, tree.cases);\n@@ -741,4 +743,23 @@\n-            Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.cases);\n-            tree.isExhaustive = tree.hasUnconditionalPattern ||\n-                                TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases) ||\n-                                isExhaustive(tree.selector.pos(), tree.selector.type, coveredSymbols);\n+\n+            if (tree.selector.type.hasTag(TypeTag.BOOLEAN)) {\n+                HashSet<JCTree> labelValues = tree.cases.stream()\n+                        .flatMap(c -> c.labels.stream())\n+                        .filter(TreeInfo::unguardedCaseLabel)\n+                        .filter(l -> !l.hasTag(DEFAULTCASELABEL))\n+                        .map(l -> l.hasTag(CONSTANTCASELABEL) ? ((JCConstantCaseLabel) l).expr\n+                                : ((JCPatternCaseLabel) l).pat)\n+                        .collect(Collectors.toCollection(HashSet::new));\n+\n+                boolean hasBothTrueAndFalse = labelValues.stream().filter(l -> l.hasTag(Tag.LITERAL)).map(l -> ((JCLiteral)l).value).distinct().count() == 2;\n+\n+                tree.isExhaustive = hasBothTrueAndFalse || tree.hasUnconditionalPattern;\n+\n+                if (hasBothTrueAndFalse && tree.hasUnconditionalPattern) {\n+                    log.error(tree, Errors.DefaultLabelNotAllowed);\n+                }\n+            } else {\n+                Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.selector, tree.cases);\n+                tree.isExhaustive = tree.hasUnconditionalPattern ||\n+                        TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases) ||\n+                        isExhaustive(tree.selector.pos(), tree.selector.type, coveredSymbols);\n+            }\n@@ -753,0 +774,1 @@\n+                                                   JCExpression selector,\n@@ -761,1 +783,1 @@\n-            return coveredSymbols(pos, labelValues);\n+            return coveredSymbols(pos, selector.type, labelValues);\n@@ -765,0 +787,1 @@\n+                                           Type targetType,\n@@ -775,0 +798,10 @@\n+                            if (primaryPatternType.tsym.type.isPrimitive()) {\n+                                \/\/ if it is primitive, it covers its wrapper type\n+                                coveredSymbols.add(types.boxedClass(primaryPatternType.tsym.type));\n+                                \/\/ if the target is unconditionally exact to the pattern, target is covered\n+                                if (types.checkUnconditionallyExact(targetType, primaryPatternType.tsym.type)) {\n+                                    coveredSymbols.add(targetType.tsym);\n+                                }\n+                            } else if (primaryPatternType.tsym.type.isReference() && targetType.isPrimitive() && types.isCastable(primaryPatternType.tsym.type, targetType)) {\n+                                coveredSymbols.add(types.unboxedType(primaryPatternType).tsym);\n+                            }\n@@ -831,1 +864,1 @@\n-            Set<Symbol> coveredSymbolsForComponent = coveredSymbols(pos,\n+            Set<Symbol> coveredSymbolsForComponent = coveredSymbols(pos, instantiatedComponentType,\n@@ -855,2 +888,2 @@\n-                    if (types.isSubtype(types.erasure(currentType.type),\n-                                        types.erasure(componentPatternType.type))) {\n+                    if (types.checkUnconditionallyExact(currentType.type, componentPatternType.type) ||\n+                            types.isConvertible(currentType.type, componentPatternType.type)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":43,"deletions":10,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.reflect.Method;\n@@ -2825,0 +2826,115 @@\n+    public void visitTypeTest(JCInstanceOf tree) {\n+        if (tree.expr.type.equals(syms.objectType) && tree.pattern.type.isPrimitive()) {\n+            \/\/ Object v = ...\n+            \/\/ v instanceof float\n+            \/\/ =>\n+            \/\/ v instanceof Float\n+            result = make.at(tree.pos()).TypeTest(tree.expr, make.Type(types.boxedClass(tree.pattern.type).type)).setType(syms.booleanType);\n+        }\n+        else if (!(tree.expr.type.isNullOrReference() && tree.pattern.type.isReference())) {\n+            JCExpression exactnessCheck = null;\n+\n+            \/\/ translate tree.expr to resolve potential statically qualified names, etc\n+            JCExpression instanceOfExpr = translate(tree.expr);\n+\n+            \/\/ We regard Wrapper instanceof p as unconditional if the underlying primitive of Wrapper is unconditional to p.\n+            \/\/ However, we still need to emit a null check.\n+            \/\/ This branch covers true unconditionality for the underlying type as well.\n+            if (types.checkUnconditionallyExact(tree.expr.type, tree.pattern.type) &&\n+                !(tree.expr.type.isReference() && types.isExactPrimitiveWidening(types.unboxedType(tree.expr.type), tree.pattern.type))) {\n+                if (types.isConvertible(tree.expr.type, tree.pattern.type)) {\n+                    exactnessCheck = make.Literal(BOOLEAN, 1).setType(syms.booleanType);\n+                }\n+            } else if (tree.pattern.type.isPrimitive()) {\n+                \/\/ Covers cases where the Type of the pattern is primitive e.g., v instanceof int\n+                \/\/ - case type of v is ReferenceType, null check and unbox\n+                \/\/ - case type of v is PrimitiveType\n+\n+                \/\/ rewrite instanceof if expr : wrapper reference type\n+                \/\/\n+                \/\/ Integer v = ...\n+                \/\/ if (v instanceof float)\n+                \/\/ =>\n+                \/\/ if (let tmp$123 = v; tmp$123 != null <&& if not unconditionally exact> ExactnessChecks.int_float(tmp$123.intValue()))\n+                VarSymbol dollar_s = new VarSymbol(FINAL | SYNTHETIC,\n+                        names.fromString(\"tmp\" + tree.pos + this.target.syntheticNameChar()),\n+                        tree.expr.type,\n+                        currentMethodSym);\n+\n+                JCStatement var = make.at(tree.pos()).VarDef(dollar_s, instanceOfExpr).setType(dollar_s.type);\n+\n+                if (tree.expr.type.isReference()) {\n+                    JCExpression nullCheck = makeBinary(NE,\n+                            make.Ident(dollar_s),\n+                            makeNull());\n+\n+                    if (types.checkUnconditionallyExact(types.unboxedType(tree.expr.type), tree.pattern.type)) {\n+                        exactnessCheck = make.Literal(BOOLEAN, 1).setType(syms.booleanType);                                          \/\/ emit no exactness check\n+                    } else {\n+                        \/\/ if expression type is Byte, Short, Integer, ...\n+                        \/\/ an unboxing conversion followed by a widening primitive conversion\n+                        if (types.unboxedType(tree.expr.type).isPrimitive()) {\n+                            exactnessCheck = getExactnessCheck(tree, boxIfNeeded(make.Ident(dollar_s), types.unboxedType(tree.expr.type))); \/\/ emit the exactness call\n+                        } else {\n+                            \/\/ if expression type is a supertype: Number, ..\n+                            \/\/ a narrowing reference conversion followed by an unboxing conversion\n+                            exactnessCheck = make.at(tree.pos()).TypeTest(tree.expr, make.Type(types.boxedClass(tree.pattern.type).type)).setType(syms.booleanType);;\n+                        }\n+                    }\n+\n+                    JCBinary nullCheckFollowedByExactnessCheckCall = makeBinary(AND,\n+                            nullCheck,\n+                            exactnessCheck);\n+\n+                    exactnessCheck = make.LetExpr(List.of(var), nullCheckFollowedByExactnessCheckCall)\n+                            .setType(syms.booleanType);\n+                } else {\n+                    \/\/ rewrite instanceof if expr : primitive\n+                    \/\/ int v = ...\n+                    \/\/ if (v instanceof float)\n+                    \/\/ =>\n+                    \/\/ if (let tmp$123 = v; ExactnessChecks.int_float(tmp$123))\n+                    JCIdent argument = make.Ident(dollar_s);\n+\n+                    JCExpression exactnessCheckCall =\n+                            getExactnessCheck(tree, argument);\n+\n+                    exactnessCheck = make.LetExpr(List.of(var), exactnessCheckCall)\n+                            .setType(syms.booleanType);\n+                }\n+            }\n+\n+            result = exactnessCheck;\n+        }\n+        else {\n+            tree.expr = translate(tree.expr);\n+            tree.pattern = translate(tree.pattern);\n+            result = tree;\n+        }\n+    }\n+\n+    private JCExpression getExactnessCheck(JCInstanceOf tree, JCExpression argument) {\n+        Name exactnessFunction = names.fromString(types.unboxedTypeOrType(tree.expr.type).tsym.name.toString() + \"_\"+ tree.pattern.type.toString());\n+\n+        \/\/ Resolve the exactness method\n+        Symbol ecsym = rs.resolveQualifiedMethod(null,\n+                attrEnv,\n+                syms.exactnessMethodsType,\n+                exactnessFunction,\n+                List.of(tree.expr.type),\n+                List.nil());\n+\n+        \/\/ Generate the method call ExactnessChecks.<exactness method>(<argument>);\n+        JCFieldAccess select = make.Select(\n+                make.QualIdent(syms.exactnessMethodsType.tsym),\n+                exactnessFunction);\n+        select.sym = ecsym;\n+        select.setType(syms.booleanType);\n+\n+        JCExpression exactnessCheck = make.Apply(List.nil(),\n+                select,\n+                List.of(argument));\n+        exactnessCheck.setType(syms.booleanType);\n+        return exactnessCheck;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -62,5 +62,2 @@\n-import com.sun.tools.javac.util.Context;\n-import com.sun.tools.javac.util.ListBuffer;\n-import com.sun.tools.javac.util.Name;\n-import com.sun.tools.javac.util.Names;\n-\n+import com.sun.tools.javac.util.*;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n@@ -73,0 +70,1 @@\n+import java.util.stream.Stream;\n@@ -74,1 +72,0 @@\n-\n@@ -107,2 +104,0 @@\n-import com.sun.tools.javac.util.Assert;\n-import com.sun.tools.javac.util.List;\n@@ -236,1 +231,1 @@\n-                if (!tree.allowNull && !principalType.isPrimitive()) {\n+                if (!tree.allowNull || !types.isSubtype(currentValue.type, principalType)) {\n@@ -483,0 +478,13 @@\n+\n+            \/\/ The boolean flag `hasUnconditionalPattern` is true when either there\n+            \/\/ is a default case or an unconditional pattern. Consequently, we\n+            \/\/ disambiguate. The last should be the one before the unconditional or the default case.\n+            Stream<JCCase> effectiveCases = null;\n+            if (cases.stream().flatMap(c -> c.labels.stream()).noneMatch(p -> p.hasTag(Tag.DEFAULTCASELABEL))) {\n+                effectiveCases = cases.stream()\n+                        .limit(hasUnconditionalPattern ? cases.size() - 1 : cases.size());\n+            } else {\n+                effectiveCases = cases.stream()\n+                        .limit(cases.size());\n+            }\n+\n@@ -484,1 +492,1 @@\n-                    cases.stream()\n+                    effectiveCases\n@@ -488,1 +496,9 @@\n-                         .toArray(s -> new LoadableConstant[s]);\n+                         .toArray(s -> new LoadableConstant[s + 1]);\n+\n+            \/\/ The last item in the `labels` array is used to pass the selector type (potentially primitive)\n+            if (seltype.isPrimitive()) {\n+                staticArgValues[staticArgValues.length - 1] = makePrimitive(tree.pos(), seltype);\n+            }\n+            else {\n+                staticArgValues[staticArgValues.length - 1] = (LoadableConstant) types.skipTypeVars(seltype, false);\n+            }\n@@ -650,0 +666,55 @@\n+    private Symbol.DynamicVarSymbol makePrimitive(DiagnosticPosition pos, Type primitiveType) {\n+        Assert.checkNonNull(currentClass);\n+\n+        List<Type> bsm_staticArgs = List.of(syms.methodHandleLookupType,\n+                syms.stringType,\n+                new ClassType(syms.classType.getEnclosingType(),\n+                        List.of(syms.constantBootstrapsType),\n+                        syms.classType.tsym));\n+\n+        Name bootstrapName = names.fromString(\"primitiveClass\");\n+        MethodSymbol bsm = rs.resolveInternalMethod(pos, env, syms.constantBootstrapsType,\n+                bootstrapName, bsm_staticArgs, List.nil());\n+\n+        PrimitiveGenerator primitiveGenerator = new PrimitiveGenerator();\n+        primitiveGenerator.assembleSig(primitiveType);\n+        return new Symbol.DynamicVarSymbol(names.fromString(primitiveGenerator.sb.toString()),\n+                syms.noSymbol,\n+                new Symbol.MethodHandleSymbol(bsm),\n+                syms.classType,\n+                new LoadableConstant[]{});\n+    }\n+\n+    private class PrimitiveGenerator extends Types.SignatureGenerator {\n+\n+        \/**\n+         * An output buffer for type signatures.\n+         *\/\n+        StringBuilder sb = new StringBuilder();\n+\n+        PrimitiveGenerator() {\n+            super(types);\n+        }\n+\n+        @Override\n+        protected void append(char ch) {\n+            sb.append(ch);\n+        }\n+\n+        @Override\n+        protected void append(byte[] ba) {\n+            sb.append(new String(ba));\n+        }\n+\n+        @Override\n+        protected void append(Name name) {\n+            sb.append(name.toString());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return sb.toString();\n+        }\n+    }\n+\n+\n@@ -738,1 +809,2 @@\n-                                instanceofCheck.allowNull &&\n+                                (!types.erasure(binding.type).isPrimitive() ? instanceofCheck.allowNull :\n+                                types.checkUnconditionallyExact(commonNestedExpression.type, types.erasure(binding.type))) &&\n@@ -764,0 +836,1 @@\n+                    newSwitch.hasUnconditionalPattern = hasUnconditional;\n@@ -838,0 +911,3 @@\n+        if (p instanceof JCPattern jcp && jcp.type.isPrimitive()) {\n+            return jcp.type;\n+        }\n@@ -844,2 +920,6 @@\n-            if (types.isSubtype(selector, principalType)) {\n-                return (LoadableConstant) selector;\n+            if (((JCPatternCaseLabel) l).pat.type.isReference()) {\n+                if (types.isSubtype(selector, principalType)) {\n+                    return (LoadableConstant) selector;\n+                } else {\n+                    return (LoadableConstant) principalType;\n+                }\n@@ -847,1 +927,1 @@\n-                return (LoadableConstant) principalType;\n+                return makePrimitive(l.pos(), principalType);\n@@ -857,2 +937,4 @@\n-                    case BYTE, CHAR,\n-                         SHORT, INT -> LoadableConstant.Int((Integer) expr.type.constValue());\n+                    case BYTE, CHAR, SHORT, INT, BOOLEAN -> LoadableConstant.Int((Integer) expr.type.constValue());\n+                    case LONG -> LoadableConstant.Long((Long) expr.type.constValue());\n+                    case FLOAT -> LoadableConstant.Float((Float) expr.type.constValue());\n+                    case DOUBLE -> LoadableConstant.Double((Double) expr.type.constValue());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":99,"deletions":17,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -29,4 +29,1 @@\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.LinkedHashSet;\n+import java.util.*;\n@@ -932,1 +929,13 @@\n-        databuf.appendChar(poolWriter.bootstrapMethods.size());\n+        \/\/ensure all bootstrap methods are entered into the map:\n+        int size;\n+        do {\n+            size = poolWriter.bootstrapMethods.size();\n+            for (BsmKey bsmKey : new HashSet<>(poolWriter.bootstrapMethods.keySet())) {\n+                \/\/ensure all static args are in pool:\n+                LoadableConstant[] uniqueArgs = bsmKey.staticArgs;\n+                for (LoadableConstant arg : uniqueArgs) {\n+                    poolWriter.putConstant(arg);\n+                }\n+            }\n+        } while (size != poolWriter.bootstrapMethods.size());\n+        databuf.appendChar(size);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2554,4 +2554,0 @@\n-# 0: type, 1: type\n-compiler.misc.not.applicable.types=\\\n-    pattern of type {1} is not applicable at {0}\n-\n@@ -3086,0 +3082,3 @@\n+compiler.misc.feature.primitive.patterns=\\\n+    primitive patterns\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -212,8 +212,8 @@\n-        BOOLEAN(TokenKind.BOOLEAN, XEXPR1|XDECL1),  \/\/  boolean\n-        BYTE(TokenKind.BYTE, XEXPR1|XDECL1),  \/\/  byte\n-        CHAR(TokenKind.CHAR, XEXPR1|XDECL1),  \/\/  char\n-        DOUBLE(TokenKind.DOUBLE, XEXPR1|XDECL1),  \/\/  double\n-        FLOAT(TokenKind.FLOAT, XEXPR1|XDECL1),  \/\/  float\n-        INT(TokenKind.INT, XEXPR1|XDECL1),  \/\/  int\n-        LONG(TokenKind.LONG, XEXPR1|XDECL1),  \/\/  long\n-        SHORT(TokenKind.SHORT, XEXPR1|XDECL1),  \/\/  short\n+        BOOLEAN(TokenKind.BOOLEAN, XEXPR1|XDECL1|XTERM),  \/\/  boolean\n+        BYTE(TokenKind.BYTE, XEXPR1|XDECL1|XTERM),  \/\/  byte\n+        CHAR(TokenKind.CHAR, XEXPR1|XDECL1|XTERM),  \/\/  char\n+        DOUBLE(TokenKind.DOUBLE, XEXPR1|XDECL1|XTERM),  \/\/  double\n+        FLOAT(TokenKind.FLOAT, XEXPR1|XDECL1|XTERM),  \/\/  float\n+        INT(TokenKind.INT, XEXPR1|XDECL1|XTERM),  \/\/  int\n+        LONG(TokenKind.LONG, XEXPR1|XDECL1|XTERM),  \/\/  long\n+        SHORT(TokenKind.SHORT, XEXPR1|XDECL1|XTERM),  \/\/  short\n@@ -799,1 +799,2 @@\n-            while (token.kind.isExpression())\n+            while (token.kind.isExpression()) {\n+                CT prevToken = in.prevCT;\n@@ -801,0 +802,15 @@\n+                \/\/ primitive types can only appear in the end of an `instanceof` expression\n+                switch (token.kind) {\n+                    case EOF:\n+                        switch (in.prevCT.kind) {\n+                            case BYTE, SHORT, CHAR, INT, LONG, FLOAT, DOUBLE, BOOLEAN:\n+                                switch (prevToken.kind) {\n+                                    case INSTANCEOF:\n+                                        return Completeness.COMPLETE;\n+                                    default:\n+                                        return Completeness.DEFINITELY_INCOMPLETE;\n+                                }\n+                        }\n+                }\n+            }\n+\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/CompletenessAnalyzer.java","additions":25,"deletions":9,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -388,0 +388,5 @@\n+\n+    public void testInstanceOf() {\n+        assertStatus(\"i instanceof Integer\", COMPLETE, \"i instanceof Integer\");\n+        assertStatus(\"i instanceof int\", COMPLETE, \"i instanceof int\");\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/CompletenessTest.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tests for primitive instanceof expressions\n+ * @build KullaTesting TestingInputStream\n+ * @run testng PrimitiveInstanceOfTest\n+ *\/\n+\n+import jdk.jshell.JShell;\n+import org.testng.annotations.Test;\n+\n+import java.util.function.Consumer;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+@Test\n+public class PrimitiveInstanceOfTest extends KullaTesting {\n+\n+    public void testInstanceOf() {\n+        assertEval(\"int i = 42;\");\n+        assertEval(\"i instanceof Integer\");\n+        assertEval(\"i instanceof int\");\n+    }\n+\n+    public void testInstanceOfRef() {\n+        assertEval(\"Integer i = 42;\");\n+        assertEval(\"i instanceof Integer\");\n+        assertEval(\"i instanceof Number\");\n+    }\n+\n+    @org.testng.annotations.BeforeMethod\n+    public void setUp() {\n+        super.setUp(bc -> bc.compilerOptions(\"--source\", System.getProperty(\"java.specification.version\"), \"--enable-preview\").remoteVMOptions(\"--enable-preview\"));\n+    }\n+}\n","filename":"test\/langtools\/jdk\/jshell\/PrimitiveInstanceOfTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.misc.not.applicable.types\n-\/\/ key: compiler.err.prob.found.req\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview --source ${jdk.version}\n-\n-class NotApplicableTypes {\n-    void t(int i) {\n-        switch (i) {\n-            case Integer j -> {}\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NotApplicableTypes.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.misc.feature.primitive.patterns\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class PrimitivePatternMatchingInstanceof {\n+    boolean m(Object o) {\n+        return o instanceof int s;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PrimitivePatternMatchingInstanceof.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n-    boolean b = (this instanceof int);\n+    Object o = int::new;\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/TypeReqClassArray.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,4 @@\n-    int i;\n-    boolean b = (i instanceof Object);\n+    {\n+        int i;\n+        synchronized (i) {}\n+    }\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/TypeReqRef.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * @compile\/fail\/ref=CastConversionMatch.out -XDrawDiagnostics CastConversionMatch.java\n+ * @compile -XDrawDiagnostics CastConversionMatch.java\n","filename":"test\/langtools\/tools\/javac\/patterns\/CastConversionMatch.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-CastConversionMatch.java:11:26: compiler.err.type.found.req: int, (compiler.misc.type.req.class.array)\n-1 error\n","filename":"test\/langtools\/tools\/javac\/patterns\/CastConversionMatch.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -31,7 +31,0 @@\n-        if (p instanceof P7(byte b)); \/\/incorrect pattern type\n-        if (p instanceof P7(long l)); \/\/incorrect pattern type\n-        switch (p) {\n-            case P7(byte b) -> {} \/\/incorrect pattern type - no exception should occur\n-            case P7(long l) -> {} \/\/incorrect pattern type - no exception should occur\n-            default -> {}\n-        }\n@@ -58,1 +51,0 @@\n-    public record P7(int i) {}\n@@ -60,1 +52,0 @@\n-\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,4 +3,4 @@\n-DeconstructionPatternErrors.java:43:37: compiler.err.illegal.start.of.type\n-DeconstructionPatternErrors.java:45:28: compiler.err.illegal.start.of.type\n-DeconstructionPatternErrors.java:47:42: compiler.err.expected: ';'\n-DeconstructionPatternErrors.java:47:43: compiler.err.not.stmt\n+DeconstructionPatternErrors.java:36:37: compiler.err.illegal.start.of.type\n+DeconstructionPatternErrors.java:38:28: compiler.err.illegal.start.of.type\n+DeconstructionPatternErrors.java:40:42: compiler.err.expected: ';'\n+DeconstructionPatternErrors.java:40:43: compiler.err.not.stmt\n@@ -25,5 +25,1 @@\n-DeconstructionPatternErrors.java:31:29: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, byte)\n-DeconstructionPatternErrors.java:32:29: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, long)\n-DeconstructionPatternErrors.java:34:21: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, byte)\n-DeconstructionPatternErrors.java:35:21: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, long)\n-DeconstructionPatternErrors.java:44:9: compiler.err.not.exhaustive.statement\n+DeconstructionPatternErrors.java:37:9: compiler.err.not.exhaustive.statement\n@@ -32,1 +28,1 @@\n-29 errors\n+25 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.out","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Check behavior of instanceof for primitives\n+ * @compile -g --enable-preview -source ${jdk.version} PrimitiveInstanceOf.java\n+ * @run main\/othervm --enable-preview PrimitiveInstanceOf\n+ *\/\n+public class PrimitiveInstanceOf {\n+\n+    public static void main(String[] args) {\n+        assertEquals(true,  identityPrimitiveConversion());\n+        assertEquals(true,  wideningPrimitiveConversion());\n+        assertEquals(true,  narrowingPrimitiveConversion());\n+        assertEquals(true,  wideningAndNarrowingPrimitiveConversion());\n+        assertEquals(true,  boxingConversion());\n+        assertEquals(true,  boxingAndWideningReferenceConversion());\n+        assertEquals(true,  unboxing());\n+        assertEquals(true,  unboxingWithObject());\n+        assertEquals(true,  wideningReferenceConversionUnboxing(42));\n+        assertEquals(true,  wideningReferenceConversionUnboxingAndWideningPrimitive(42));\n+        assertEquals(true,  unboxingAndWideningPrimitiveExact());\n+        assertEquals(false, unboxingAndWideningPrimitiveNotExact());\n+        assertEquals(true,  unboxingWhenNullAndWideningPrimitive());\n+        assertEquals(true,  narrowingAndUnboxing());\n+        assertEquals(true,  patternExtractRecordComponent());\n+        assertEquals(true,  exprMethod());\n+        assertEquals(true,  exprStaticallyQualified());\n+    }\n+\n+    public static boolean identityPrimitiveConversion() {\n+        int i = 42;\n+        return i instanceof int;\n+    }\n+\n+    public static boolean wideningPrimitiveConversion() {\n+        byte b = (byte) 42;\n+        short s = (short) 42;\n+        char c = 'a';\n+\n+        return b instanceof int && s instanceof int && c instanceof int;\n+    }\n+\n+    public static boolean narrowingPrimitiveConversion() {\n+        long l_within_int_range = 42L;\n+        long l_outside_int_range = 999999999999999999L;\n+\n+        return l_within_int_range instanceof int && !(l_outside_int_range instanceof int);\n+    }\n+\n+    public static boolean wideningAndNarrowingPrimitiveConversion() {\n+        byte b = (byte) 42;\n+        byte b2 = (byte) -42;\n+        char c = (char) 42;\n+        return b instanceof char && c instanceof byte && !(b2 instanceof char);\n+    }\n+\n+    public static boolean boxingConversion() {\n+        int i = 42;\n+\n+        return i instanceof Integer;\n+    }\n+\n+    public static boolean boxingAndWideningReferenceConversion() {\n+        int i = 42;\n+        return i instanceof Object &&\n+                i instanceof Number &&\n+                i instanceof Comparable;\n+    }\n+\n+    public static boolean unboxing() {\n+        Integer i = Integer.valueOf(1);\n+        return i instanceof int;\n+    }\n+\n+    public static boolean unboxingWithObject() {\n+        Object o1 = (int) 42;\n+        Object o2 = (byte) 42;\n+\n+        return o1 instanceof int i1 &&\n+                o2 instanceof byte b1 &&\n+                !(o1 instanceof byte b2 &&\n+                !(o2 instanceof int i2));\n+    }\n+\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxing(T i) {\n+        return i instanceof int;\n+    }\n+\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxingAndWideningPrimitive(T i) {\n+        return i instanceof double;\n+    }\n+\n+    public static boolean unboxingAndWideningPrimitiveExact() {\n+        Byte b = Byte.valueOf((byte)42);\n+        Short s = Short.valueOf((short)42);\n+        Character c = Character.valueOf('a');\n+\n+        return (b instanceof int) && (s instanceof int) && (c instanceof int);\n+    }\n+\n+    public static boolean unboxingAndWideningPrimitiveNotExact() {\n+        int smallestIntNotRepresentable = 16777217; \/\/ 2^24 + 1\n+        Integer i = Integer.valueOf(smallestIntNotRepresentable);\n+\n+        return i instanceof float;\n+    }\n+\n+    public static boolean unboxingWhenNullAndWideningPrimitive() {\n+        Byte b = null;\n+        Short s = null;\n+        Character c = null;\n+\n+        return !(b instanceof int) && !(s instanceof int) && !(c instanceof int);\n+    }\n+\n+    public static boolean narrowingAndUnboxing() {\n+        Number n = Byte.valueOf((byte) 42);\n+\n+        return n instanceof byte;\n+    }\n+\n+    public record P(int i) { }\n+    public static boolean patternExtractRecordComponent() {\n+        Object p = new P(42);\n+        if (p instanceof P(byte b)) {\n+            return b == 42;\n+        }\n+        return false;\n+    }\n+\n+    public static int meth() {return 42;}\n+    public static boolean exprMethod() {\n+        return meth() instanceof int;\n+    }\n+\n+    public class A1 {\n+        public static int i = 42;\n+    }\n+    public static boolean exprStaticallyQualified() {\n+        return A1.i instanceof int;\n+    }\n+\n+    static void assertEquals(boolean expected, boolean actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOf.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Check behavior of instanceof for primitives\n+ * @compile\/fail\/ref=PrimitiveInstanceOfErrors.out --enable-preview -source ${jdk.version} -XDrawDiagnostics -XDshould-stop.at=FLOW PrimitiveInstanceOfErrors.java\n+ *\/\n+public class PrimitiveInstanceOfErrors {\n+    public static boolean unboxingAndNarrowingPrimitiveNotAllowedPerCastingConversion() {\n+        Long l_within_int_range = 42L;\n+        Long l_outside_int_range = 999999999999999999L;\n+\n+        return l_within_int_range instanceof int && !(l_outside_int_range instanceof int);\n+    }\n+\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxingAndNarrowingPrimitive(T i) {\n+        return i instanceof byte;\n+    }\n+\n+    public static void boxingConversionsBetweenIncompatibleTypes() {\n+        int i = 42;\n+\n+        boolean ret1 = i instanceof Integer; \/\/ (Integer) i \/\/ OK and true\n+        boolean ret2 = i instanceof Double;  \/\/ error: incompatible types\n+        boolean ret3 = i instanceof Short;   \/\/ error: incompatible types\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfErrors.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+PrimitiveInstanceOfErrors.java:34:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Long, int)\n+PrimitiveInstanceOfErrors.java:34:55: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Long, int)\n+PrimitiveInstanceOfErrors.java:38:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: T, byte)\n+PrimitiveInstanceOfErrors.java:45:24: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.Double)\n+PrimitiveInstanceOfErrors.java:46:24: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.Short)\n+- compiler.note.preview.filename: PrimitiveInstanceOfErrors.java, DEFAULT\n+- compiler.note.preview.recompile\n+5 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfErrors.out","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,273 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Check behavior of instanceof for primitives\n+ * @compile -g --enable-preview -source ${jdk.version} PrimitiveInstanceOfNumericValueTests.java\n+ * @run main\/othervm --enable-preview PrimitiveInstanceOfNumericValueTests\n+ *\/\n+public class PrimitiveInstanceOfNumericValueTests {\n+\n+    public static void main(String[] args) {\n+        testByte();\n+        testShort();\n+        testChar();\n+        testInt();\n+        testLong();\n+        testFloat();\n+        testDouble();\n+    }\n+\n+    public static void testByte() {\n+        assertEquals(true,  ((byte) (Byte.MAX_VALUE)) instanceof byte);\n+        assertEquals(true,  ((byte) (0)) instanceof byte);\n+        assertEquals(true,  ((byte) (Byte.MIN_VALUE)) instanceof byte);\n+        assertEquals(false, ((short) (Short.MAX_VALUE)) instanceof byte);\n+        assertEquals(true,  ((short) (0)) instanceof byte);\n+        assertEquals(false, ((short) (Short.MIN_VALUE)) instanceof byte);\n+        assertEquals(false, ((char) (Character.MAX_VALUE)) instanceof byte);\n+        assertEquals(true,  ((char) (Character.MIN_VALUE)) instanceof byte);\n+        assertEquals(false, (Integer.MAX_VALUE) instanceof byte);\n+        assertEquals(true,  (0) instanceof byte);\n+        assertEquals(false, (Integer.MIN_VALUE) instanceof byte);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof byte);\n+        assertEquals(true,  (0) instanceof byte);\n+        assertEquals(false, (Long.MIN_VALUE) instanceof byte);\n+        assertEquals(false, (Float.MAX_VALUE) instanceof byte);\n+        assertEquals(true,  ((float) 0) instanceof byte);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof byte);\n+        assertEquals(false, (Float.NaN) instanceof byte);\n+        assertEquals(false, (Float.POSITIVE_INFINITY) instanceof byte);\n+        assertEquals(false, (Float.NEGATIVE_INFINITY) instanceof byte);\n+        assertEquals(false, (-0.0f) instanceof byte);\n+        assertEquals(true,  (+0.0f) instanceof byte);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof byte);\n+        assertEquals(true,  ((double) 0) instanceof byte);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof byte);\n+        assertEquals(false, (Double.NaN) instanceof byte);\n+        assertEquals(false, (Double.POSITIVE_INFINITY) instanceof byte);\n+        assertEquals(false, (Double.NEGATIVE_INFINITY) instanceof byte);\n+        assertEquals(false, (-0.0d) instanceof byte);\n+        assertEquals(true,  (+0.0d) instanceof byte);\n+    }\n+    public static void testShort() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof short);\n+        assertEquals(true, ((byte) (0)) instanceof short);\n+        assertEquals(true, ((byte) (Byte.MIN_VALUE)) instanceof short);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof short);\n+        assertEquals(true, ((short) (0)) instanceof short);\n+        assertEquals(true, ((short) (Short.MIN_VALUE)) instanceof short);\n+        assertEquals(false, ((char) (Character.MAX_VALUE)) instanceof short);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof short);\n+        assertEquals(false, (Integer.MAX_VALUE) instanceof short);\n+        assertEquals(true, (0) instanceof short);\n+        assertEquals(false, (Integer.MIN_VALUE) instanceof short);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof short);\n+        assertEquals(true, (0) instanceof short);\n+        assertEquals(false, (Long.MIN_VALUE) instanceof short);\n+        assertEquals(false, (Float.MAX_VALUE) instanceof short);\n+        assertEquals(true, ((float) 0) instanceof short);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof short);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof short);\n+        assertEquals(false, (Float.NaN) instanceof short);\n+        assertEquals(false, (Float.POSITIVE_INFINITY) instanceof short);\n+        assertEquals(false, (Float.NEGATIVE_INFINITY) instanceof short);\n+        assertEquals(false, (-0.0f) instanceof short);\n+        assertEquals(true, (+0.0f) instanceof short);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof short);\n+        assertEquals(true, ((double) 0) instanceof short);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof short);\n+        assertEquals(false, (Double.NaN) instanceof short);\n+        assertEquals(false, (Double.POSITIVE_INFINITY) instanceof short);\n+        assertEquals(false, (Double.NEGATIVE_INFINITY) instanceof short);\n+        assertEquals(false, (-0.0d) instanceof short);\n+        assertEquals(true, (+0.0d) instanceof short);\n+    }\n+    public static void testChar() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof char);\n+        assertEquals(true, ((byte) (0)) instanceof char);\n+        assertEquals(false, ((byte) (Byte.MIN_VALUE)) instanceof char);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof char);\n+        assertEquals(true, ((short) (0)) instanceof char);\n+        assertEquals(false, ((short) (Short.MIN_VALUE)) instanceof char);\n+        assertEquals(true, ((char) (Character.MAX_VALUE)) instanceof char);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof char);\n+        assertEquals(false, (Integer.MAX_VALUE) instanceof char);\n+        assertEquals(true, (0) instanceof char);\n+        assertEquals(false, (Integer.MIN_VALUE) instanceof char);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof char);\n+        assertEquals(true, (0) instanceof char);\n+        assertEquals(false, (Long.MIN_VALUE) instanceof char);\n+        assertEquals(false, (Float.MAX_VALUE) instanceof char);\n+        assertEquals(true, ((float) 0) instanceof char);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof char);\n+        assertEquals(false, (Float.NaN) instanceof char);\n+        assertEquals(false, (Float.POSITIVE_INFINITY) instanceof char);\n+        assertEquals(false, (Float.NEGATIVE_INFINITY) instanceof char);\n+        assertEquals(false, (-0.0f) instanceof char);\n+        assertEquals(true, (+0.0f) instanceof char);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof char);\n+        assertEquals(true, ((double) 0) instanceof char);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof char);\n+        assertEquals(false, (Double.NaN) instanceof char);\n+        assertEquals(false, (Double.POSITIVE_INFINITY) instanceof char);\n+        assertEquals(false, (Double.NEGATIVE_INFINITY) instanceof char);\n+        assertEquals(false, (-0.0d) instanceof char);\n+        assertEquals(true, (+0.0d) instanceof char);\n+    }\n+    public static void testInt() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof int);\n+        assertEquals(true, ((byte) (0)) instanceof int);\n+        assertEquals(true, ((byte) (Byte.MIN_VALUE)) instanceof int);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof int);\n+        assertEquals(true, ((short) (0)) instanceof int);\n+        assertEquals(true, ((short) (Short.MIN_VALUE)) instanceof int);\n+        assertEquals(true, ((char) (Character.MAX_VALUE)) instanceof int);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof int);\n+        assertEquals(true, (Integer.MAX_VALUE) instanceof int);\n+        assertEquals(true, (0) instanceof int);\n+        assertEquals(true, (Integer.MIN_VALUE) instanceof int);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof int);\n+        assertEquals(true, (0) instanceof int);\n+        assertEquals(false, (Long.MIN_VALUE) instanceof int);\n+        assertEquals(false, (Float.MAX_VALUE) instanceof int);\n+        assertEquals(true, ((float) 0) instanceof int);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof int);\n+        assertEquals(false, (Float.NaN) instanceof int);\n+        assertEquals(false, (Float.POSITIVE_INFINITY) instanceof int);\n+        assertEquals(false, (Float.NEGATIVE_INFINITY) instanceof int);\n+        assertEquals(false, (-0.0f) instanceof int);\n+        assertEquals(true, (+0.0f) instanceof int);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof int);\n+        assertEquals(true, ((double) 0) instanceof int);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof int);\n+        assertEquals(false, (Double.NaN) instanceof int);\n+        assertEquals(false, (Double.POSITIVE_INFINITY) instanceof int);\n+        assertEquals(false, (Double.NEGATIVE_INFINITY) instanceof int);\n+        assertEquals(false, (-0.0d) instanceof int);\n+        assertEquals(true, (+0.0d) instanceof int);\n+    }\n+    public static void testLong() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof long);\n+        assertEquals(true, ((byte) (0)) instanceof long);\n+        assertEquals(true, ((byte) (Byte.MIN_VALUE)) instanceof long);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof long);\n+        assertEquals(true, ((short) (0)) instanceof long);\n+        assertEquals(true, ((short) (Short.MIN_VALUE)) instanceof long);\n+        assertEquals(true, ((char) (Character.MAX_VALUE)) instanceof long);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof long);\n+        assertEquals(true, (Integer.MAX_VALUE) instanceof long);\n+        assertEquals(true, (0) instanceof long);\n+        assertEquals(true, (Integer.MIN_VALUE) instanceof long);\n+        assertEquals(true, (Long.MAX_VALUE) instanceof long);\n+        assertEquals(true, (0) instanceof long);\n+        assertEquals(true, (Long.MIN_VALUE) instanceof long);\n+        assertEquals(false, (Float.MAX_VALUE) instanceof long);\n+        assertEquals(true, ((float) 0) instanceof long);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof long);\n+        assertEquals(false, (Float.NaN) instanceof long);\n+        assertEquals(false, (Float.POSITIVE_INFINITY) instanceof long);\n+        assertEquals(false, (Float.NEGATIVE_INFINITY) instanceof long);\n+        assertEquals(false, (-0.0f) instanceof long);\n+        assertEquals(true, (+0.0f) instanceof long);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof long);\n+        assertEquals(true, ((double) 0) instanceof long);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof long);\n+        assertEquals(false, (Double.NaN) instanceof long);\n+        assertEquals(false, (Double.POSITIVE_INFINITY) instanceof long);\n+        assertEquals(false, (Double.NEGATIVE_INFINITY) instanceof long);\n+        assertEquals(false, (-0.0d) instanceof long);\n+        assertEquals(true, (+0.0d) instanceof long);\n+    }\n+    public static void testFloat() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof float);\n+        assertEquals(true, ((byte) (0) instanceof float));\n+        assertEquals(true, ((byte) (Byte.MIN_VALUE)) instanceof float);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof float);\n+        assertEquals(true, ((short) (0)) instanceof float);\n+        assertEquals(true, ((short) (Short.MIN_VALUE)) instanceof float);\n+        assertEquals(true, ((char) (Character.MAX_VALUE)) instanceof float);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof float);\n+        assertEquals(false, (Integer.MAX_VALUE) instanceof float);\n+        assertEquals(true, (0) instanceof float);\n+        assertEquals(true, (Integer.MIN_VALUE) instanceof float);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof float);\n+        assertEquals(true, (0) instanceof float);\n+        assertEquals(true, (Long.MIN_VALUE) instanceof float);\n+        assertEquals(true, (Float.MAX_VALUE) instanceof float);\n+        assertEquals(true, ((float) 0) instanceof float);\n+        assertEquals(true, (Float.MIN_VALUE) instanceof float);\n+        assertEquals(true, (Float.NaN) instanceof float);\n+        assertEquals(true, (Float.POSITIVE_INFINITY) instanceof float);\n+        assertEquals(true, (Float.NEGATIVE_INFINITY) instanceof float);\n+        assertEquals(true, (-0.0f) instanceof float);\n+        assertEquals(true, (+0.0f) instanceof float);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof float);\n+        assertEquals(true, ((double) 0) instanceof float);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof float);\n+        assertEquals(true, (Double.NaN) instanceof float);\n+        assertEquals(true, (Double.POSITIVE_INFINITY) instanceof float);\n+        assertEquals(true, (Double.NEGATIVE_INFINITY) instanceof float);\n+        assertEquals(true, (-0.0d) instanceof float);\n+        assertEquals(true, (+0.0d) instanceof float);\n+    }\n+    public static void testDouble() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof double);\n+        assertEquals(true, ((byte) (0)) instanceof double);\n+        assertEquals(true, ((byte) (Byte.MIN_VALUE)) instanceof double);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof double);\n+        assertEquals(true, ((short) (0)) instanceof double);\n+        assertEquals(true, ((short) (Short.MIN_VALUE)) instanceof double);\n+        assertEquals(true, ((char) (Character.MAX_VALUE)) instanceof double);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof double);\n+        assertEquals(true, (Integer.MAX_VALUE) instanceof double);\n+        assertEquals(true, (0) instanceof double);\n+        assertEquals(true, (Integer.MIN_VALUE) instanceof double);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof double);\n+        assertEquals(true, (0) instanceof double);\n+        assertEquals(true, (Long.MIN_VALUE) instanceof double);\n+        assertEquals(true, (Float.MAX_VALUE) instanceof double);\n+        assertEquals(true, ((float) 0) instanceof double);\n+        assertEquals(true, (Float.MIN_VALUE) instanceof double);\n+        assertEquals(true, (Float.NaN) instanceof double);\n+        assertEquals(true, (Float.POSITIVE_INFINITY) instanceof double);\n+        assertEquals(true, (Float.NEGATIVE_INFINITY) instanceof double);\n+        assertEquals(true, (-0.0f) instanceof double);\n+        assertEquals(true, (+0.0f) instanceof double);\n+        assertEquals(true, (Double.MAX_VALUE) instanceof double);\n+        assertEquals(true, ((double) 0) instanceof double);\n+        assertEquals(true, (Double.MIN_VALUE) instanceof double);\n+        assertEquals(true, (Double.NaN) instanceof double);\n+        assertEquals(true, (Double.POSITIVE_INFINITY) instanceof double);\n+        assertEquals(true, (Double.NEGATIVE_INFINITY) instanceof double);\n+        assertEquals(true, (-0.0d) instanceof double);\n+        assertEquals(true, (+0.0d) instanceof double);\n+    }\n+\n+    static void assertEquals(boolean expected, boolean actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfNumericValueTests.java","additions":273,"deletions":0,"binary":false,"changes":273,"status":"added"},{"patch":"@@ -0,0 +1,311 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.List;\n+\n+\/**\n+ * @test\n+ * @summary Check behavior of instanceof for primitives\n+ * @compile -g --enable-preview -source ${jdk.version} PrimitivePatterns.java\n+ * @run main\/othervm --enable-preview PrimitivePatterns\n+ *\/\n+public class PrimitivePatterns {\n+    public static void main(String[] args) {\n+        assertEquals(42, primitivePattern());\n+        assertEquals(1,  primitiveSwitch(42));\n+        assertEquals(2,  primitiveSwitch(123));\n+        assertEquals(42, primitiveSwitch2());\n+        assertEquals(42, primitiveSwitch3());\n+        assertEquals(1,  primitiveSwitch4(0.0f));\n+        assertEquals(2,  primitiveSwitch4(1.0f));\n+        assertEquals(42, exhaustive0());\n+        assertEquals(1,  exhaustive1WithDefault());\n+        assertEquals(2,  exhaustive2WithDefault());\n+        assertEquals(1,  exhaustive1());\n+        assertEquals(1,  exhaustive2());\n+        assertEquals(1,  exhaustive3());\n+        assertEquals(1,  exhaustive4());\n+        assertEquals(2,  exhaustive5());\n+        assertEquals(1,  exhaustive6());\n+        assertEquals(1,  exhaustiveWithRecords1());\n+        assertEquals(1,  exhaustiveWithRecords2());\n+        assertEquals(1,  exhaustiveWithRecords4());\n+        assertEquals(1,  exhaustiveWithRecords5());\n+        assertEquals(1,  exhaustiveWithRecords6());\n+        assertEquals(2,  ensureProperSelectionWithRecords());\n+        assertEquals(1,  ensureProperSelectionWithRecords2());\n+        assertEquals(3,  ensureProperSelectionWithRecords3());\n+        assertEquals(42, switchAndDowncastFromObjectPrimitive());\n+        assertEquals(42, dominationBetweenBoxedAndPrimitive());\n+        assertEquals(2,  wideningAndUnboxing());\n+        assertEquals(2,  wideningAndUnboxingInRecord());\n+        assertEquals(2,  wideningAndInferredUnboxingInRecord());\n+        assertEquals(3,  inferredUnboxingInRecordInEnhancedFor());\n+    }\n+\n+    public static int primitivePattern() {\n+        int i = 42;\n+        if (i instanceof int p) {\n+            return p;\n+        }\n+        return -1;\n+    }\n+\n+    public static int primitiveSwitch(int i) {\n+        return switch (i) {\n+            case int j when j == 42-> 1;\n+            case int j -> 2;\n+        };\n+    }\n+\n+    public static int primitiveSwitch2() {\n+        Object o = Integer.valueOf(42);\n+        switch (o) {\n+            case int i: return i;\n+            default: break;\n+        }\n+        return -1;\n+    }\n+\n+    public static int primitiveSwitch3() {\n+        int i = 42;\n+        switch (i) {\n+            case Integer ii: return ii;\n+        }\n+    }\n+\n+    public static int primitiveSwitch4(float f) {\n+        return switch (f) {\n+            case 0f -> 1;\n+            case Float fi when fi == 1f -> 2;\n+            case Float fi -> 3;\n+        };\n+    }\n+\n+    public static int exhaustive0() {\n+        Integer i = 42;\n+        switch (i) {\n+            case int j: return j;\n+        }\n+    }\n+\n+    public static int exhaustive1WithDefault() {\n+        int i = 42;\n+        return switch (i) {\n+            case byte  b -> 1;\n+            default -> 2;\n+        };\n+    }\n+\n+    public static int exhaustive2WithDefault() {\n+        int i = 30000;\n+        return switch (i) {\n+            case byte  b -> 1;\n+            case short s -> 2;\n+            default -> 3;\n+        };\n+    }\n+\n+    public static int exhaustive1() {\n+        int i = 42;\n+        return switch (i) {\n+            case Integer p -> 1;\n+        };\n+    }\n+\n+    public static int exhaustive2() {\n+        int i = 42;\n+        return switch (i) {\n+            case long d -> 1;\n+        };\n+    }\n+\n+    public static int exhaustive3() {\n+        int i = 42;\n+        return switch (i) {\n+            case double d -> 1;\n+        };\n+    }\n+\n+    public static int exhaustive4() {\n+        int i = 127;\n+        return switch (i) {\n+            case byte b -> 1;\n+            case double d -> 2;\n+        };\n+    }\n+\n+    public static int exhaustive5() {\n+        int i = 127 + 1;\n+        return switch (i) {\n+            case byte b -> 1;\n+            case double d -> 2;\n+        };\n+    }\n+\n+    public static int exhaustive6() {\n+        Integer i = Integer.valueOf(42);\n+        return switch (i) {\n+            case int p -> 1;\n+        };\n+    }\n+\n+    public static int exhaustiveWithRecords1() {\n+        R_int r = new R_int(42);\n+        return switch (r) {\n+            \/\/ exhaustive, because Integer exhaustive at type int\n+            case R_int(Integer x) -> 1;\n+        };\n+    }\n+\n+    public static int exhaustiveWithRecords2() {\n+        R_int r = new R_int(42);\n+        return switch (r) {\n+            \/\/ exhaustive, because double unconditional at int\n+            case R_int(double x) -> 1;\n+        };\n+    }\n+\n+    public static int exhaustiveWithRecords4() {\n+        R_Integer r = new R_Integer(42);\n+        return switch (r) {\n+            \/\/ exhaustive, because R_Integer(int) exhaustive at type R_Integer(Integer), because int exhaustive at type Integer\n+            case R_Integer(int x) -> 1;\n+        };\n+    }\n+\n+    public static int exhaustiveWithRecords5() {\n+        R_Integer r = new R_Integer(42);\n+        return switch (r) {\n+            \/\/ exhaustive, because double exhaustive at Integer\n+            case R_Integer(double x) -> 1;\n+        };\n+    }\n+\n+    public static int exhaustiveWithRecords6() {\n+        R_int r = new R_int(42);\n+        return switch (r) {\n+            case R_int(byte x) -> 1;\n+            case R_int(int x) -> 2;\n+        };\n+    }\n+\n+    public static int ensureProperSelectionWithRecords() {\n+        R_int r = new R_int(4242);\n+        return switch (r) {\n+            case R_int(byte x) -> 1;\n+            case R_int(int x) -> 2;\n+        };\n+    }\n+\n+    public static int ensureProperSelectionWithRecords2() {\n+        R_double r = new R_double(42);\n+        switch (r) {\n+            case R_double(int i):\n+                return meth_int(i);\n+            case R_double(double x):\n+                return meth_double(x);\n+        }\n+    }\n+\n+    public static int ensureProperSelectionWithRecords3() {\n+        R_int r = new R_int(4242);\n+        return switch (r) {\n+            case R_int(byte x) -> 1;\n+            case R_int(int x) when x == 236 -> 2;\n+            case R_int(int x) -> 3;\n+        };\n+    }\n+\n+    public static int meth_int(int i) { return 1; }\n+    public static int meth_double(double d) { return 2;}\n+\n+    public static int switchAndDowncastFromObjectPrimitive() {\n+        Object i = 42;\n+        return switch (i) {\n+            case Integer ib  -> ib;\n+            default -> -1;\n+        };\n+    }\n+\n+    public static int dominationBetweenBoxedAndPrimitive() {\n+        Object i = 42;\n+        return switch (i) {\n+            case Integer ib  -> ib;\n+            case byte ip     -> ip;\n+            default -> -1;\n+        };\n+    }\n+\n+    static int wideningAndUnboxing() {\n+        Number o = Integer.valueOf(42);\n+        return switch (o) {\n+            case byte b -> 1;\n+            case int i -> 2;\n+            case float f -> 3;\n+            default -> 4;\n+        };\n+    }\n+\n+    static int wideningAndUnboxingInRecord() {\n+        Box<Number> box = new Box<>(Integer.valueOf(42));\n+        return switch (box) {\n+            case Box<Number>(byte b) -> 1;\n+            case Box<Number>(int i) -> 2;\n+            case Box<Number>(float f) -> 3;\n+            default -> 4;\n+        };\n+    }\n+\n+    static int wideningAndInferredUnboxingInRecord() {\n+        Box<Number> box = new Box<>(Integer.valueOf(42));\n+        return switch (box) {\n+            case Box(byte b) -> 1;\n+            case Box(int i) -> 2;\n+            case Box(float f) -> 3;\n+            default -> 4;\n+        };\n+    }\n+\n+    static int inferredUnboxingInRecordInEnhancedFor() {\n+        List<Box<Integer>> numbers = List.of(new Box<>(1), new Box<>(2));\n+\n+        int acc = 0;\n+        for(Box(long b) : numbers) {\n+            acc += b;\n+        }\n+\n+        return acc;\n+    }\n+\n+    record R_Integer(Integer x) {}\n+    record R_int(int x) {}\n+    record R_double(double x) {}\n+    record Box<N extends Number>(N num) {}\n+\n+    static void assertEquals(int expected, int actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatterns.java","additions":311,"deletions":0,"binary":false,"changes":311,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Check behavior of instanceof for primitives\n+ * @compile\/fail\/ref=PrimitivePatternsErrors.out --enable-preview -source ${jdk.version} -XDrawDiagnostics -XDshould-stop.at=FLOW PrimitivePatternsErrors.java\n+ *\/\n+public class PrimitivePatternsErrors {\n+    record R_int(int x) {}\n+\n+    public static void dominationBetweenPrimitivePatterns() {\n+        int i = 42;\n+        switch (i) {\n+            case short s -> System.out.println(\"its a short\");\n+            case byte b  -> System.out.println(\"its a byte\"); \/\/ Error - dominated!\n+            default      -> System.out.println(\"any other integral value\");\n+        }\n+    }\n+\n+    public static int dominationWithRecordPatterns() {\n+        R_int r = new R_int(42);\n+        return switch (r) {\n+            case R_int(int x) -> 1;\n+            case R_int(byte x) -> 2;  \/\/ Error - dominated!\n+        };\n+    }\n+\n+    public static int inconvertibleNestedComponent() {\n+        R_int r = new R_int(42);\n+        return switch (r) {\n+            case R_int(Long x) -> 1; \/\/ inconvertible\n+        };\n+    }\n+\n+    public static int nonExhaustive1() {\n+        int i = 42;\n+        return switch (i) {  \/\/ Error - not exhaustive\n+            case short s -> s;\n+        };\n+    }\n+\n+    public static int nonExhaustive2() {\n+        int i = 42;\n+        return switch (i) { \/\/ Error - not exhaustive\n+            case byte  b -> 1;\n+            case short s -> 2;\n+        };\n+    }\n+\n+    public static int nonExhaustive3() {\n+        int i = 42;\n+        return switch (i) { \/\/ Error - not exhaustive\n+            case byte  b -> 1;\n+            case float f -> 2;\n+        };\n+    }\n+\n+    public static int dominationBetweenBoxedAndPrimitive() {\n+        int i = 42;\n+        return switch (i) {\n+            case Integer ib  -> ib;\n+            case byte ip     -> ip; \/\/ Error - dominated!\n+        };\n+    }\n+\n+    public static int constantDominatedWithPrimitivePattern() {\n+        int i = 42;\n+        return switch (i) {\n+            case int j -> 42;\n+            case 43    -> -1;   \/\/ Error - dominated!\n+        };\n+    }\n+\n+    public static int constantDominatedWithFloatPrimitivePattern() {\n+        float f = 42.0f;\n+        return switch (f) {\n+            case Float ff -> 42;\n+            case 43.0f    -> -1;   \/\/ Error - dominated!\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsErrors.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+PrimitivePatternsErrors.java:36:18: compiler.err.pattern.dominated\n+PrimitivePatternsErrors.java:45:18: compiler.err.pattern.dominated\n+PrimitivePatternsErrors.java:52:24: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.Long)\n+PrimitivePatternsErrors.java:83:18: compiler.err.pattern.dominated\n+PrimitivePatternsErrors.java:91:18: compiler.err.pattern.dominated\n+PrimitivePatternsErrors.java:99:18: compiler.err.pattern.dominated\n+PrimitivePatternsErrors.java:51:16: compiler.err.not.exhaustive\n+PrimitivePatternsErrors.java:58:16: compiler.err.not.exhaustive\n+PrimitivePatternsErrors.java:65:16: compiler.err.not.exhaustive\n+PrimitivePatternsErrors.java:73:16: compiler.err.not.exhaustive\n+- compiler.note.preview.filename: PrimitivePatternsErrors.java, DEFAULT\n+- compiler.note.preview.recompile\n+10 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsErrors.out","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -5,2 +5,1 @@\n- * @enablePreview\n- * @compile\/fail\/ref=SwitchErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW SwitchErrors.java\n+ * @compile\/fail\/ref=SwitchErrors.out --enable-preview -source ${jdk.version} -XDrawDiagnostics -XDshould-stop.at=FLOW SwitchErrors.java\n@@ -130,6 +129,0 @@\n-    void primitivePattern(Object o) {\n-        switch (o) {\n-            case int i: break;\n-            default: break;\n-        }\n-    }\n@@ -242,10 +235,0 @@\n-    void primitiveToReference(int i) {\n-        switch (i) {\n-            case Integer j: break;\n-        }\n-    }\n-    void referenceToPrimitive(Integer i) {\n-        switch (i) {\n-            case int j: break;\n-        }\n-    }\n@@ -280,0 +263,37 @@\n+\n+    void switchLongOverByte(byte b) {\n+        switch (b) {\n+            case 0L: return ;\n+        }\n+    }\n+\n+    void switchOverPrimitiveFloatFromInt(float f) {\n+        switch (f) {\n+            case 16777216:\n+                break;\n+            case 16777217:\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    void switchOverNotRepresentableFloat(Float f) {\n+        switch (f) {\n+            case 1.0f:\n+                break;\n+            case 0.999999999f:\n+                break;\n+            case Float fi:\n+                break;\n+        }\n+    }\n+\n+    int switchOverPrimitiveBooleanExhaustiveWithNonPermittedDefault(boolean b) {\n+        return switch (b) {\n+            case true -> 1;\n+            case false -> 2;\n+            default -> 3;\n+        };\n+    }\n+\n@@ -288,0 +308,1 @@\n+\n@@ -296,0 +317,1 @@\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.java","additions":40,"deletions":18,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1,8 +1,9 @@\n-SwitchErrors.java:66:18: compiler.err.default.label.not.allowed\n-SwitchErrors.java:72:18: compiler.err.default.label.not.allowed\n-SwitchErrors.java:72:27: compiler.err.default.label.not.allowed\n-SwitchErrors.java:138:28: compiler.err.default.label.not.allowed\n-SwitchErrors.java:144:18: compiler.err.default.label.not.allowed\n-SwitchErrors.java:149:18: compiler.err.default.label.not.allowed\n-SwitchErrors.java:154:18: compiler.err.default.label.not.allowed\n-SwitchErrors.java:213:29: compiler.err.default.label.not.allowed\n+SwitchErrors.java:65:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:71:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:71:27: compiler.err.default.label.not.allowed\n+SwitchErrors.java:131:28: compiler.err.default.label.not.allowed\n+SwitchErrors.java:137:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:142:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:147:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:206:29: compiler.err.default.label.not.allowed\n+SwitchErrors.java:213:47: compiler.err.default.label.not.allowed\n@@ -10,60 +11,61 @@\n-SwitchErrors.java:227:47: compiler.err.default.label.not.allowed\n-SwitchErrors.java:283:20: compiler.err.illegal.start.of.type\n-SwitchErrors.java:286:28: compiler.err.illegal.start.of.type\n-SwitchErrors.java:11:18: compiler.err.constant.label.not.compatible: java.lang.String, java.lang.Object\n-SwitchErrors.java:17:18: compiler.err.constant.label.not.compatible: int, java.lang.Object\n-SwitchErrors.java:23:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, java.lang.Integer)\n-SwitchErrors.java:24:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Integer, java.lang.CharSequence)\n-SwitchErrors.java:29:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, int)\n-SwitchErrors.java:30:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, int)\n-SwitchErrors.java:31:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.CharSequence)\n-SwitchErrors.java:37:13: compiler.err.unconditional.pattern.and.default\n-SwitchErrors.java:43:24: compiler.err.unconditional.pattern.and.default\n-SwitchErrors.java:49:18: compiler.err.unconditional.pattern.and.default\n-SwitchErrors.java:55:18: compiler.err.duplicate.unconditional.pattern\n-SwitchErrors.java:61:13: compiler.err.duplicate.default.label\n-SwitchErrors.java:67:13: compiler.err.duplicate.default.label\n-SwitchErrors.java:78:18: compiler.err.duplicate.case.label\n-SwitchErrors.java:83:24: compiler.err.duplicate.case.label\n-SwitchErrors.java:88:28: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:93:18: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:94:18: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:101:18: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:108:18: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:113:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, java.lang.Integer)\n-SwitchErrors.java:119:18: compiler.err.instanceof.reifiable.not.safe: java.util.List, java.util.List<java.lang.Integer>\n-SwitchErrors.java:125:18: compiler.err.cant.resolve.location: kindname.class, Undefined, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n-SwitchErrors.java:132:18: compiler.err.type.found.req: int, (compiler.misc.type.req.class.array)\n-SwitchErrors.java:143:18: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:149:27: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:155:18: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:167:18: compiler.err.pattern.expected\n-SwitchErrors.java:173:78: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n-SwitchErrors.java:179:73: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n-SwitchErrors.java:186:21: compiler.err.invalid.case.label.combination\n-SwitchErrors.java:195:44: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:204:24: compiler.err.invalid.case.label.combination\n-SwitchErrors.java:220:21: compiler.err.invalid.case.label.combination\n-SwitchErrors.java:227:44: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:239:18: compiler.err.duplicate.unconditional.pattern\n-SwitchErrors.java:244:18: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, java.lang.Integer)\n-SwitchErrors.java:249:18: compiler.err.type.found.req: int, (compiler.misc.type.req.class.array)\n-SwitchErrors.java:255:24: compiler.err.invalid.case.label.combination\n-SwitchErrors.java:262:24: compiler.err.invalid.case.label.combination\n-SwitchErrors.java:269:18: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:276:18: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:292:49: compiler.err.cant.resolve.location.args: kindname.method, length, , , (compiler.misc.location: kindname.class, java.lang.Object, null)\n-SwitchErrors.java:294:55: compiler.err.cant.resolve.location.args: kindname.method, length, , , (compiler.misc.location: kindname.class, java.lang.Object, null)\n-SwitchErrors.java:300:26: compiler.err.pattern.type.cannot.infer\n-SwitchErrors.java:10:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:16:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:22:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:28:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:76:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:82:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:87:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:92:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:98:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:105:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:159:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:232:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:303:20: compiler.err.illegal.start.of.type\n+SwitchErrors.java:306:28: compiler.err.illegal.start.of.type\n+SwitchErrors.java:10:18: compiler.err.constant.label.not.compatible: java.lang.String, java.lang.Object\n+SwitchErrors.java:16:18: compiler.err.constant.label.not.compatible: int, java.lang.Object\n+SwitchErrors.java:22:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, java.lang.Integer)\n+SwitchErrors.java:23:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Integer, java.lang.CharSequence)\n+SwitchErrors.java:28:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, int)\n+SwitchErrors.java:29:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, int)\n+SwitchErrors.java:30:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.CharSequence)\n+SwitchErrors.java:36:13: compiler.err.unconditional.pattern.and.default\n+SwitchErrors.java:42:24: compiler.err.unconditional.pattern.and.default\n+SwitchErrors.java:48:18: compiler.err.unconditional.pattern.and.default\n+SwitchErrors.java:54:18: compiler.err.duplicate.unconditional.pattern\n+SwitchErrors.java:60:13: compiler.err.duplicate.default.label\n+SwitchErrors.java:66:13: compiler.err.duplicate.default.label\n+SwitchErrors.java:77:18: compiler.err.duplicate.case.label\n+SwitchErrors.java:82:24: compiler.err.duplicate.case.label\n+SwitchErrors.java:87:28: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:92:18: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:93:18: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:100:18: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:107:18: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:112:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, java.lang.Integer)\n+SwitchErrors.java:118:18: compiler.err.instanceof.reifiable.not.safe: java.util.List, java.util.List<java.lang.Integer>\n+SwitchErrors.java:124:18: compiler.err.cant.resolve.location: kindname.class, Undefined, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n+SwitchErrors.java:136:18: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:142:27: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:148:18: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:160:18: compiler.err.pattern.expected\n+SwitchErrors.java:166:78: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n+SwitchErrors.java:172:73: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n+SwitchErrors.java:179:21: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:188:44: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:197:24: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:213:21: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:220:44: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:232:18: compiler.err.duplicate.unconditional.pattern\n+SwitchErrors.java:238:24: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:245:24: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:252:18: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:259:18: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:266:18: compiler.err.prob.found.req: (compiler.misc.possible.loss.of.precision: long, byte)\n+SwitchErrors.java:272:18: compiler.err.constant.label.not.compatible: int, float\n+SwitchErrors.java:274:18: compiler.err.constant.label.not.compatible: int, float\n+SwitchErrors.java:285:13: compiler.err.duplicate.case.label\n+SwitchErrors.java:313:49: compiler.err.cant.resolve.location.args: kindname.method, length, , , (compiler.misc.location: kindname.class, java.lang.Object, null)\n+SwitchErrors.java:315:55: compiler.err.cant.resolve.location.args: kindname.method, length, , , (compiler.misc.location: kindname.class, java.lang.Object, null)\n+SwitchErrors.java:322:26: compiler.err.pattern.type.cannot.infer\n+SwitchErrors.java:9:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:15:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:21:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:27:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:75:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:81:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:86:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:91:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:97:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:104:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:152:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:225:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:293:16: compiler.err.default.label.not.allowed\n@@ -72,1 +74,1 @@\n-69 errors\n+71 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.out","additions":71,"deletions":69,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n- * @enablePreview\n+ * @compile -g --enable-preview -source ${jdk.version} Switches.java\n+ * @run main\/othervm --enable-preview Switches\n@@ -89,0 +90,20 @@\n+        assertEquals(5f, switchOverBoxedFloat(0f));\n+        assertEquals(7f, switchOverBoxedFloat(1f));\n+        assertEquals(9f, switchOverBoxedFloat(2f));\n+        assertEquals(9f, switchOverBoxedFloat(2f));\n+        assertEquals(5f, switchOverPrimitiveDouble(0d));\n+        assertEquals(7f, switchOverPrimitiveDouble(1d));\n+        assertEquals(9f, switchOverPrimitiveDouble(2d));\n+        assertEquals(1, switchOverPrimitiveChar('a'));\n+        assertEquals(-1, switchOverPrimitiveChar('x'));\n+        assertTrue(switchOverBoxedBooleanWithUnconditional(Boolean.valueOf(true)));\n+        assertTrue(switchOverBoxedBooleanWithUnconditional(true));\n+        assertTrue(!switchOverBoxedBooleanWithUnconditional(false));\n+        assertEquals(1, switchOverPrimitiveBooleanWithDefault(true));\n+        assertEquals(2, switchOverPrimitiveBooleanWithDefault(false));\n+        assertEquals(1, switchOverPrimitiveBoolean(true));\n+        assertEquals(2, switchOverPrimitiveBoolean(false));\n+        assertEquals(1, switchOverPrimitiveFloat(0.0f\/0.0f));\n+        assertEquals(2, switchOverPrimitiveFloat((float) Math.pow(0.0f\/0.0f, 0)));\n+        assertEquals(3, switchOverPrimitiveFloat(0.0f));\n+        assertEquals(4, switchOverPrimitiveFloat(-0.0f));\n@@ -629,0 +650,55 @@\n+    private float switchOverBoxedFloat(Float f) {\n+        return switch (f) {\n+            case 0f -> 5f + 0f;\n+            case Float fi when fi == 1f -> 6f + fi;\n+            case Float fi -> 7f + fi;\n+        };\n+    }\n+\n+    private double switchOverPrimitiveDouble(Double d) {\n+        return switch (d) {\n+            case 0d -> 5d + 0d;\n+            case Double di when di == 1d -> 6d + di;\n+            case Double di -> 7d + di;\n+        };\n+    }\n+\n+    private boolean switchOverBoxedBooleanWithUnconditional(Boolean b) {\n+        return switch (b) {\n+            case true -> true;\n+            case Boolean bi -> bi;\n+        };\n+    }\n+\n+    private int switchOverPrimitiveBooleanWithDefault(boolean b) {\n+        return switch (b) {\n+            case true -> 1;\n+            default -> 2;\n+        };\n+    }\n+\n+    private int switchOverPrimitiveBoolean(boolean b) {\n+        return switch (b) {\n+            case true -> 1;\n+            case false -> 2;\n+        };\n+    }\n+\n+    private int switchOverPrimitiveChar(char c) {\n+        return switch (c) {\n+            case 'a' -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n+    final float NaNconstant = Float.NaN;\n+    private int switchOverPrimitiveFloat(float f) {\n+        return switch (f) {\n+            case NaNconstant -> 1;\n+            case 1.0f -> 2;\n+            case 0.0f -> 3;\n+            case -0.0f -> 4;\n+            default -> -1;\n+        };\n+    }\n+\n@@ -710,0 +786,12 @@\n+    void assertEquals(float expected, float actual) {\n+        if (Float.compare(expected, actual) != 0) {\n+            throw new AssertionError(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n+    void assertEquals(double expected, double actual) {\n+        if (Double.compare(expected, actual) != 0) {\n+            throw new AssertionError(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Switches.java","additions":89,"deletions":1,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * @summary Verify switch over boolean\/long\/float\/double is not allowed.\n+ * @summary Verify switch over boolean\/long\/float\/double without matching primitive constant expressions is not allowed.\n@@ -8,7 +8,1 @@\n-public class SwitchNoExtraTypes {\n-\n-    private void switchBoolean(boolean b) {\n-        switch (b) {\n-            case true: return ;\n-        }\n-    }\n+public class SwitchExtraTypes {\n","filename":"test\/langtools\/tools\/javac\/switchextra\/SwitchNoExtraTypes.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+SwitchNoExtraTypes.java:8:8: compiler.err.class.public.should.be.in.file: kindname.class, SwitchExtraTypes\n@@ -2,5 +3,4 @@\n-SwitchNoExtraTypes.java:12:18: compiler.err.constant.label.not.compatible: boolean, boolean\n-SwitchNoExtraTypes.java:18:18: compiler.err.constant.label.not.compatible: int, long\n-SwitchNoExtraTypes.java:24:18: compiler.err.constant.label.not.compatible: int, float\n-SwitchNoExtraTypes.java:30:18: compiler.err.constant.label.not.compatible: int, double\n-5 errors\n+SwitchNoExtraTypes.java:12:18: compiler.err.constant.label.not.compatible: int, long\n+SwitchNoExtraTypes.java:18:18: compiler.err.constant.label.not.compatible: int, float\n+SwitchNoExtraTypes.java:24:18: compiler.err.constant.label.not.compatible: int, double\n+5 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/switchextra\/SwitchNoExtraTypes.out","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2023, red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.preview.patterns;\n+\n+import static java.lang.runtime.ExactnessMethods.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+\/**\n+ * Tests Exactness methods\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations=5, time=1)\n+@Measurement(iterations=5, time=1)\n+@Threads(2)\n+@Fork(value = 1,\n+      jvmArgsPrepend = {\"-Djmh.blackhole.mode=COMPILER\",\n+                        \"--enable-preview\"})\n+@State(Scope.Thread)\n+@SuppressWarnings(\"preview\")\n+public class Exactness {\n+\n+    private static boolean int_float_based_on_leading_trailing(int n) {\n+        if (n == Integer.MIN_VALUE)\n+            return true;\n+        n = Math.abs(n);\n+        return Float.PRECISION >= \/\/ 24\n+                (32 - (Integer.numberOfLeadingZeros(n) +\n+                        Integer.numberOfTrailingZeros(n))) ;\n+    }\n+    @Benchmark\n+    public void test_int_float_based_on_leading_trailing(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(int_float_based_on_leading_trailing(n));\n+        }\n+    }\n+\n+    private static boolean int_float_based_on_filtering(int n) {\n+        return n == (int)(float)n && n != Integer.MAX_VALUE;\n+    }\n+    @Benchmark\n+    public void test_int_float_based_on_filtering(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(int_float_based_on_filtering(n));\n+        }\n+    }\n+\n+    private static boolean long_float_based_on_leading_trailing(long n) {\n+        if (n == Long.MIN_VALUE)\n+            return true;\n+        n = Math.abs(n);\n+        return Float.PRECISION >= \/\/ 24\n+                (64 - (Long.numberOfLeadingZeros(n) +\n+                        Long.numberOfTrailingZeros(n))) ;\n+    }\n+    @Benchmark\n+    public void test_long_float_based_on_leading_trailing(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(long_float_based_on_leading_trailing(n));\n+        }\n+    }\n+\n+    private static boolean long_float_based_on_filtering(long n) {\n+        return n == (long)(float)n && n != Long.MAX_VALUE;\n+    }\n+    @Benchmark\n+    public void test_long_float_based_on_filtering(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(long_float_based_on_filtering(n));\n+        }\n+    }\n+\n+    private static boolean long_double_based_on_leading_trailing(long n) {\n+        if (n == Long.MIN_VALUE)\n+            return true;\n+        n = Math.abs(n);\n+        return Double.PRECISION >= \/\/ 53\n+                (64 - (Long.numberOfLeadingZeros(n) +\n+                        Long.numberOfTrailingZeros(n))) ;\n+    }\n+    @Benchmark\n+    public void test_long_double_based_on_leading_trailing(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(long_double_based_on_leading_trailing(n));\n+        }\n+    }\n+\n+    private static boolean long_double_based_on_filtering(long n) {\n+        return n == (long)(double)n && n != Long.MAX_VALUE;\n+    }\n+    @Benchmark\n+    public void test_long_double_based_on_filtering(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(long_double_based_on_filtering(n));\n+        }\n+    }\n+\n+    private static boolean float_int_based_on_compare(float n) {\n+        return Double.compare((double)n, (double)((int)n)) == 0;\n+    }\n+    @Benchmark\n+    public void test_float_int_based_on_compare(Blackhole bh) {\n+        float n = -Float.MAX_VALUE;\n+        while (n <= Float.MAX_VALUE) {\n+            bh.consume(float_int_based_on_compare(n));\n+            n = Math.nextUp(n);\n+        }\n+    }\n+\n+    private static boolean isNegativeZero(float n) {\n+        return Float.floatToRawIntBits(n) == Integer.MIN_VALUE;\n+    }\n+    private static boolean float_int_based_on_filtering(float n) {\n+        return n == (float)(int)n && n != 0x1p31f && !isNegativeZero(n);\n+    }\n+    @Benchmark\n+    public void test_float_int_based_on_filtering(Blackhole bh) {\n+        float n = -Float.MAX_VALUE;\n+        while (n <= Float.MAX_VALUE) {\n+            bh.consume(float_int_based_on_filtering(n));\n+            n = Math.nextUp(n);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/preview\/patterns\/Exactness.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"}]}