{"files":[{"patch":"@@ -169,1 +169,3 @@\n-    public static boolean float_byte(float n)  {return Float.compare(n, (float)(byte)(n)) == 0;}\n+    public static boolean float_byte(float n)  {\n+        return n == (float)(byte)n && !isNegativeZero(n);\n+    }\n@@ -177,1 +179,3 @@\n-    public static boolean float_short(float n) {return Float.compare(n, (float)(short)(n)) == 0;}\n+    public static boolean float_short(float n) {\n+        return n == (float)(short)n && !isNegativeZero(n);\n+    }\n@@ -185,1 +189,3 @@\n-    public static boolean float_char(float n)  {return Float.compare(n, (float)(char)(n)) == 0;}\n+    public static boolean float_char(float n)  {\n+        return n == (float)(char)n && !isNegativeZero(n);\n+    }\n@@ -194,1 +200,1 @@\n-        return Double.compare((double)n, (double)((int)n)) == 0;\n+        return n == (float)(int)n && n != 0x1p31f && !isNegativeZero(n);\n@@ -204,5 +210,1 @@\n-        if (Float.compare(n, -0.0f) == 0 ||\n-                Float.compare(n, Float.NaN) == 0 ||\n-                Float.compare(n, Float.NEGATIVE_INFINITY) == 0 ||\n-                Float.compare(n, Float.POSITIVE_INFINITY) == 0) return false;\n-        return n == (long)n && n != (float)Long.MAX_VALUE + 1;\n+        return n == (float)(long)n && n != 0x1p63f && !isNegativeZero(n);\n@@ -217,1 +219,3 @@\n-    public static boolean double_byte(double n) {return Double.compare(n, (double)(byte)(n)) == 0;}\n+    public static boolean double_byte(double n) {\n+        return n == (double)(byte)n && !isNegativeZero(n);\n+    }\n@@ -225,1 +229,3 @@\n-    public static boolean double_short(double n){return Double.compare(n, (double)(short)(n)) == 0;}\n+    public static boolean double_short(double n){\n+        return n == (double)(short)n && !isNegativeZero(n);\n+    }\n@@ -233,1 +239,3 @@\n-    public static boolean double_char(double n) {return Double.compare(n, (double)(char)(n)) == 0;}\n+    public static boolean double_char(double n) {\n+        return n == (double)(char)n && !isNegativeZero(n);\n+    }\n@@ -241,1 +249,3 @@\n-    public static boolean double_int(double n)  {return Double.compare(n, (double)(int)(n)) == 0;}\n+    public static boolean double_int(double n)  {\n+        return n == (double)(int)n && !isNegativeZero(n);\n+    }\n@@ -250,5 +260,1 @@\n-        if (Double.compare(n, -0.0f) == 0 ||\n-                Double.compare(n, Double.NaN) == 0 ||\n-                Double.compare(n, Double.NEGATIVE_INFINITY) == 0 ||\n-                Double.compare(n, Double.POSITIVE_INFINITY) == 0) return false;\n-        return n == (long)n && n != (double)Long.MAX_VALUE + 1;\n+        return n == (double)(long)n && n != 0x1p63 && !isNegativeZero(n);\n@@ -263,1 +269,11 @@\n-    public static boolean double_float(double n) {return Double.compare(n, (double)(float)(n)) == 0;}\n+    public static boolean double_float(double n) {\n+        return n == (double)(float)n || n != n;\n+    }\n+\n+    private static boolean isNegativeZero(float n) {\n+        return Float.floatToRawIntBits(n) == Integer.MIN_VALUE;\n+    }\n+\n+    private static boolean isNegativeZero(double n) {\n+        return Double.doubleToRawLongBits(n) == Long.MIN_VALUE;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ExactnessMethods.java","additions":35,"deletions":19,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2023, red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.preview.patterns;\n+\n+import static java.lang.runtime.ExactnessMethods.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+\/**\n+ * Tests Exactness methods\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations=5, time=1)\n+@Measurement(iterations=5, time=1)\n+@Threads(2)\n+@Fork(value = 1,\n+      jvmArgsPrepend = {\"-Djmh.blackhole.mode=COMPILER\",\n+                        \"--enable-preview\"})\n+@State(Scope.Thread)\n+@SuppressWarnings(\"preview\")\n+public class Exactness {\n+\n+    private static boolean int_float_based_on_leading_trailing(int n) {\n+        if (n == Integer.MIN_VALUE)\n+            return true;\n+        n = Math.abs(n);\n+        return Float.PRECISION >= \/\/ 24\n+                (32 - (Integer.numberOfLeadingZeros(n) +\n+                        Integer.numberOfTrailingZeros(n))) ;\n+    }\n+    @Benchmark\n+    public void test_int_float_based_on_leading_trailing(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(int_float_based_on_leading_trailing(n));\n+        }\n+    }\n+\n+    private static boolean int_float_based_on_filtering(int n) {\n+        return n == (int)(float)n && n != Integer.MAX_VALUE;\n+    }\n+    @Benchmark\n+    public void test_int_float_based_on_filtering(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(int_float_based_on_filtering(n));\n+        }\n+    }\n+\n+    private static boolean long_float_based_on_leading_trailing(long n) {\n+        if (n == Long.MIN_VALUE)\n+            return true;\n+        n = Math.abs(n);\n+        return Float.PRECISION >= \/\/ 24\n+                (64 - (Long.numberOfLeadingZeros(n) +\n+                        Long.numberOfTrailingZeros(n))) ;\n+    }\n+    @Benchmark\n+    public void test_long_float_based_on_leading_trailing(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(long_float_based_on_leading_trailing(n));\n+        }\n+    }\n+\n+    private static boolean long_float_based_on_filtering(long n) {\n+        return n == (long)(float)n && n != Long.MAX_VALUE;\n+    }\n+    @Benchmark\n+    public void test_long_float_based_on_filtering(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(long_float_based_on_filtering(n));\n+        }\n+    }\n+\n+    private static boolean long_double_based_on_leading_trailing(long n) {\n+        if (n == Long.MIN_VALUE)\n+            return true;\n+        n = Math.abs(n);\n+        return Double.PRECISION >= \/\/ 53\n+                (64 - (Long.numberOfLeadingZeros(n) +\n+                        Long.numberOfTrailingZeros(n))) ;\n+    }\n+    @Benchmark\n+    public void test_long_double_based_on_leading_trailing(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(long_double_based_on_leading_trailing(n));\n+        }\n+    }\n+\n+    private static boolean long_double_based_on_filtering(long n) {\n+        return n == (long)(double)n && n != Long.MAX_VALUE;\n+    }\n+    @Benchmark\n+    public void test_long_double_based_on_filtering(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(long_double_based_on_filtering(n));\n+        }\n+    }\n+\n+    private static boolean float_int_based_on_compare(float n) {\n+        return Double.compare((double)n, (double)((int)n)) == 0;\n+    }\n+    @Benchmark\n+    public void test_float_int_based_on_compare(Blackhole bh) {\n+        float n = -Float.MAX_VALUE;\n+        while (n <= Float.MAX_VALUE) {\n+            bh.consume(float_int_based_on_compare(n));\n+            n = Math.nextUp(n);\n+        }\n+    }\n+\n+    private static boolean isNegativeZero(float n) {\n+        return Float.floatToRawIntBits(n) == Integer.MIN_VALUE;\n+    }\n+    private static boolean float_int_based_on_filtering(float n) {\n+        return n == (float)(int)n && n != 0x1p31f && !isNegativeZero(n);\n+    }\n+    @Benchmark\n+    public void test_float_int_based_on_filtering(Blackhole bh) {\n+        float n = -Float.MAX_VALUE;\n+        while (n <= Float.MAX_VALUE) {\n+            bh.consume(float_int_based_on_filtering(n));\n+            n = Math.nextUp(n);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/preview\/patterns\/Exactness.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"}]}