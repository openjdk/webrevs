{"files":[{"patch":"@@ -96,4 +96,0 @@\n-\t\tif (value == null && builtin != TypesImpl.Builtin.STRING) {\n-\t\t\t\/\/ skip the non-string built-in values\n-\t\t\treturn;\n-\t\t}\n@@ -117,1 +113,1 @@\n-\t\t\twriter.writeByte((byte) value);\n+\t\t\twriter.writeByte(value == null ? (byte) 0 : (byte) value);\n@@ -121,1 +117,1 @@\n-\t\t\twriter.writeChar((char) value);\n+\t\t\twriter.writeChar(value == null ? (char) 0 : (char) value);\n@@ -125,1 +121,1 @@\n-\t\t\twriter.writeShort((short) value);\n+\t\t\twriter.writeShort(value == null ? (short) 0 : (short) value);\n@@ -129,1 +125,1 @@\n-\t\t\twriter.writeInt((int) value);\n+\t\t\twriter.writeInt(value == null ? 0 : (int) value);\n@@ -133,1 +129,1 @@\n-\t\t\twriter.writeLong((long) value);\n+\t\t\twriter.writeLong(value == null ? 0L : (long) value);\n@@ -137,1 +133,1 @@\n-\t\t\twriter.writeFloat((float) value);\n+\t\t\twriter.writeFloat(value == null ? 0.0f : (float) value);\n@@ -141,1 +137,1 @@\n-\t\t\twriter.writeDouble((double) value);\n+\t\t\twriter.writeDouble(value == null ? 0.0 : (double) value);\n@@ -145,1 +141,1 @@\n-\t\t\twriter.writeBoolean((boolean) value);\n+\t\t\twriter.writeBoolean(value != null && (boolean) value);\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/Chunk.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import org.openjdk.jmc.flightrecorder.writer.api.Annotation;\n@@ -145,1 +146,1 @@\n-\t\t\t\tvalue = new TypedFieldValueImpl(field, field.getType().nullValue());\n+\t\t\t\tvalue = new TypedFieldValueImpl(field, getDefaultImplicitFieldValue(field));\n@@ -152,0 +153,55 @@\n+\t\/**\n+\t * Gets the default value for a field when not explicitly provided by the user.\n+\t * <p>\n+\t * For event types (jdk.jfr.Event):\n+\t * <ul>\n+\t * <li>Fields annotated with {@code @Timestamp} receive {@link System#nanoTime()} as default,\n+\t * providing a monotonic timestamp that will be >= the chunk's startTicks<\/li>\n+\t * <li>Other fields receive null values<\/li>\n+\t * <\/ul>\n+\t * <p>\n+\t * Note: JFR timestamps are stored as ticks relative to the chunk start, so the parser will\n+\t * convert this absolute tick value to chunk-relative during reading.\n+\t * <p>\n+\t * <strong>Tick Frequency Assumption:<\/strong> This implementation assumes a 1:1 tick frequency\n+\t * (1 tick = 1 nanosecond) as currently hardcoded in {@code RecordingImpl}. If the tick\n+\t * frequency becomes configurable in the future, {@link System#nanoTime()} values will need to\n+\t * be converted to ticks using: {@code nanoTime * ticksPerSecond \/ 1_000_000_000L}.\n+\t *\n+\t * @param field\n+\t *            the field to get default value for\n+\t * @return the default value for the field\n+\t *\/\n+\tprivate TypedValueImpl getDefaultImplicitFieldValue(TypedFieldImpl field) {\n+\t\tif (!\"jdk.jfr.Event\".equals(type.getSupertype())) {\n+\t\t\treturn field.getType().nullValue();\n+\t\t}\n+\n+\t\t\/\/ Check if field is annotated with @Timestamp (any value means it's chunk-relative)\n+\t\tif (hasTimestampAnnotation(field)) {\n+\t\t\t\/\/ Use current nanoTime as default - will be valid and >= chunk startTicks\n+\t\t\t\/\/ NOTE: Assumes 1:1 tick frequency (1 tick = 1 ns) as per RecordingImpl line 280\n+\t\t\treturn field.getType().asValue(System.nanoTime());\n+\t\t}\n+\n+\t\t\/\/ For all other fields, return null value\n+\t\t\/\/ Null builtin values are handled properly by Chunk.writeBuiltinType()\n+\t\treturn field.getType().nullValue();\n+\t}\n+\n+\t\/**\n+\t * Checks if a field has the {@code @Timestamp} annotation.\n+\t *\n+\t * @param field\n+\t *            the field to check\n+\t * @return true if the field is annotated with @Timestamp\n+\t *\/\n+\tprivate boolean hasTimestampAnnotation(TypedFieldImpl field) {\n+\t\tfor (Annotation annotation : field.getAnnotations()) {\n+\t\t\tif (\"jdk.jfr.Timestamp\".equals(annotation.getType().getTypeName())) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypedValueImpl.java","additions":57,"deletions":1,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -204,0 +204,28 @@\n+\t * Creates a typed null value for this type.\n+\t * <p>\n+\t * Use this method when you need to pass a null value for optional or missing complex-type\n+\t * fields. Passing {@code null} directly to\n+\t * {@link TypedValueBuilder#putField(String, TypedValue)} causes compilation ambiguity because\n+\t * the method is overloaded with multiple parameter types.\n+\t * <p>\n+\t * For primitive types (int, long, String, etc.), you can pass primitive default\/null values\n+\t * directly. For complex types (Thread, StackTrace, custom types), use this method to create a\n+\t * properly typed null value.\n+\t * <p>\n+\t * <strong>Example:<\/strong>\n+\t *\n+\t * <pre>\n+\t * {\n+\t * \t&#64;code\n+\t * \tTypes types = recording.getTypes();\n+\t * \tType stackTraceType = types.getType(Types.JDK.STACK_TRACE);\n+\t * \tType threadType = types.getType(Types.JDK.THREAD);\n+\t *\n+\t * \tType eventType = recording.registerEventType(\"custom.Event\");\n+\t * \trecording.writeEvent(eventType.asValue(builder -> {\n+\t * \t\tbuilder.putField(\"startTime\", System.nanoTime()).putField(\"stackTrace\", stackTraceType.nullValue()) \/\/ typed null\n+\t * \t\t\t\t.putField(\"eventThread\", threadType.nullValue()); \/\/ typed null\n+\t * \t}));\n+\t * }\n+\t * <\/pre>\n+\t *\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/Type.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -39,1 +39,34 @@\n-\/** A fluent API for lazy initialization of a composite type value *\/\n+\/**\n+ * A fluent API for lazy initialization of a composite type value.\n+ * <p>\n+ * This builder provides a chainable interface for setting field values in complex types. Use it\n+ * with {@link Type#asValue(java.util.function.Consumer)} to construct typed values.\n+ * <h2>Handling Null Values<\/h2>\n+ * <p>\n+ * When setting field values, avoid passing {@code null} directly as it causes compilation ambiguity\n+ * due to overloaded methods. Instead:\n+ * <ul>\n+ * <li>For primitive types (String, int, long, etc.): cast to the specific type, e.g.,\n+ * {@code (String) null}<\/li>\n+ * <li>For complex types (Thread, StackTrace, custom types): use {@link Type#nullValue()}<\/li>\n+ * <\/ul>\n+ * <p>\n+ * <strong>Example:<\/strong>\n+ *\n+ * <pre>\n+ * {\n+ * \t&#64;code\n+ * \tTypes types = recording.getTypes();\n+ * \tType threadType = types.getType(Types.JDK.THREAD);\n+ *\n+ * \tType eventType = recording.registerEventType(\"custom.Event\", builder -> {\n+ * \t\tbuilder.addField(\"message\", Types.Builtin.STRING).addField(\"thread\", Types.JDK.THREAD);\n+ * \t});\n+ *\n+ * \trecording.writeEvent(eventType.asValue(builder -> {\n+ * \t\tbuilder.putField(\"message\", (String) null) \/\/ primitive null with cast\n+ * \t\t\t\t.putField(\"thread\", threadType.nullValue()); \/\/ complex type null\n+ * \t}));\n+ * }\n+ * <\/pre>\n+ *\/\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/TypedValueBuilder.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,299 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.openjdk.jmc.common.item.Attribute;\n+import org.openjdk.jmc.common.item.IItem;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.item.IMemberAccessor;\n+import org.openjdk.jmc.common.unit.IQuantity;\n+import org.openjdk.jmc.common.unit.UnitLookup;\n+import org.openjdk.jmc.flightrecorder.JfrAttributes;\n+import org.openjdk.jmc.flightrecorder.JfrLoaderToolkit;\n+import org.openjdk.jmc.flightrecorder.writer.api.Recording;\n+import org.openjdk.jmc.flightrecorder.writer.api.Recordings;\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+import org.openjdk.jmc.flightrecorder.writer.api.Types;\n+\n+\/**\n+ * Tests for implicit event fields (stackTrace, eventThread, startTime) handling.\n+ * <p>\n+ * These tests verify that events can be written without explicitly providing values for implicit\n+ * fields, and that the Writer API automatically provides default values for them.\n+ *\/\n+@SuppressWarnings(\"restriction\")\n+class ImplicitEventFieldsTest {\n+\tprivate Recording recording;\n+\tprivate Path jfrPath;\n+\n+\t@BeforeEach\n+\tvoid setup() throws Exception {\n+\t\tjfrPath = Files.createTempFile(\"jfr-writer-test-implicit-\", \".jfr\");\n+\t\trecording = Recordings.newRecording(jfrPath);\n+\t}\n+\n+\t@AfterEach\n+\tvoid teardown() throws Exception {\n+\t\tif (recording != null) {\n+\t\t\trecording.close();\n+\t\t}\n+\t\tif (jfrPath != null) {\n+\t\t\tFiles.deleteIfExists(jfrPath);\n+\t\t}\n+\t}\n+\n+\t\/**\n+\t * Tests that an event can be written without implicit fields explicitly set.\n+\t * <p>\n+\t * This test reproduces the issue where field values appear shifted when implicit fields are not\n+\t * provided. After the fix, this should pass.\n+\t *\/\n+\t@Test\n+\tvoid eventWithoutImplicitFields() throws Exception {\n+\t\tType eventType = recording.registerEventType(\"test.MinimalEvent\", builder -> {\n+\t\t\tbuilder.addField(\"customField\", Types.Builtin.LONG);\n+\t\t});\n+\n+\t\t\/\/ Write event WITHOUT setting implicit fields\n+\t\trecording.writeEvent(eventType.asValue(builder -> {\n+\t\t\tbuilder.putField(\"customField\", 12345L);\n+\t\t})).close();\n+\n+\t\t\/\/ Verify recording parses correctly\n+\t\tIItemCollection events = JfrLoaderToolkit.loadEvents(jfrPath.toFile());\n+\t\tassertTrue(events.hasItems(), \"Recording should contain events\");\n+\n+\t\tevents.forEach(itemType -> {\n+\t\t\titemType.forEach(item -> {\n+\t\t\t\t\/\/ Verify implicit fields have defaults\n+\t\t\t\tIQuantity startTime = JfrAttributes.START_TIME.getAccessor(itemType.getType()).getMember(item);\n+\t\t\t\tassertNotNull(startTime, \"startTime should have a default value\");\n+\n+\t\t\t\t\/\/ Verify custom field has correct value (not shifted to startTime)\n+\t\t\t\tIMemberAccessor<Number, IItem> accessor = Attribute\n+\t\t\t\t\t\t.attr(\"customField\", \"customField\", UnitLookup.RAW_NUMBER).getAccessor(itemType.getType());\n+\t\t\t\tassertNotNull(accessor, \"Accessor for customField should not be null\");\n+\t\t\t\tNumber customFieldValue = accessor.getMember(item);\n+\t\t\t\tassertNotNull(customFieldValue, \"customField should have a value\");\n+\t\t\t\tassertEquals(12345L, customFieldValue.longValue(),\n+\t\t\t\t\t\t\"customField should be 12345, not shifted to startTime\");\n+\t\t\t});\n+\t\t});\n+\t}\n+\n+\t\/**\n+\t * Tests that explicit startTime values are respected and not overridden by the default.\n+\t * <p>\n+\t * Note: JFR stores timestamps as ticks relative to the chunk start, so the parser converts the\n+\t * stored tick value to absolute epoch nanoseconds using the chunk header. We verify that the\n+\t * timestamp is reasonable (positive epoch time) rather than checking for exact equality.\n+\t *\/\n+\t@Test\n+\tvoid eventWithExplicitStartTime() throws Exception {\n+\t\tlong explicitTime = System.nanoTime();\n+\t\tType eventType = recording.registerEventType(\"test.ExplicitTime\");\n+\n+\t\trecording.writeEvent(eventType.asValue(builder -> {\n+\t\t\tbuilder.putField(\"startTime\", explicitTime);\n+\t\t})).close();\n+\n+\t\tIItemCollection events = JfrLoaderToolkit.loadEvents(jfrPath.toFile());\n+\t\tassertTrue(events.hasItems(), \"Recording should contain events\");\n+\n+\t\tevents.forEach(itemType -> {\n+\t\t\titemType.forEach(item -> {\n+\t\t\t\tIQuantity time = JfrAttributes.START_TIME.getAccessor(itemType.getType()).getMember(item);\n+\t\t\t\tassertNotNull(time, \"startTime should not be null\");\n+\t\t\t\t\/\/ Verify that the timestamp is reasonable (epoch time in nanoseconds)\n+\t\t\t\t\/\/ Should be a recent positive timestamp, not negative or zero\n+\t\t\t\tlong epochNanos = time.longValue();\n+\t\t\t\tassertTrue(epochNanos > 0L, \"Timestamp should be positive (epoch nanos)\");\n+\t\t\t});\n+\t\t});\n+\t}\n+\n+\t\/**\n+\t * Tests an event with only implicit fields and no custom fields.\n+\t *\/\n+\t@Test\n+\tvoid eventWithOnlyImplicitFields() throws Exception {\n+\t\tType eventType = recording.registerEventType(\"test.ImplicitOnly\");\n+\n+\t\trecording.writeEvent(eventType.asValue(builder -> {\n+\t\t\t\/\/ Don't set any fields - rely on defaults\n+\t\t})).close();\n+\n+\t\tIItemCollection events = JfrLoaderToolkit.loadEvents(jfrPath.toFile());\n+\t\tassertTrue(events.hasItems(), \"Recording should contain events\");\n+\n+\t\tevents.forEach(itemType -> {\n+\t\t\titemType.forEach(item -> {\n+\t\t\t\tIQuantity startTime = JfrAttributes.START_TIME.getAccessor(itemType.getType()).getMember(item);\n+\t\t\t\tassertNotNull(startTime, \"startTime should have a default value\");\n+\t\t\t});\n+\t\t});\n+\t}\n+\n+\t\/**\n+\t * Tests that multiple custom fields maintain correct alignment when implicit fields are not\n+\t * provided.\n+\t *\/\n+\t@Test\n+\tvoid eventWithMultipleCustomFields() throws Exception {\n+\t\tType eventType = recording.registerEventType(\"test.MultiField\", builder -> {\n+\t\t\tbuilder.addField(\"field1\", Types.Builtin.LONG).addField(\"field2\", Types.Builtin.STRING).addField(\"field3\",\n+\t\t\t\t\tTypes.Builtin.INT);\n+\t\t});\n+\n+\t\trecording.writeEvent(eventType.asValue(builder -> {\n+\t\t\tbuilder.putField(\"field1\", 111L).putField(\"field2\", \"test-string\").putField(\"field3\", 333);\n+\t\t})).close();\n+\n+\t\tIItemCollection events = JfrLoaderToolkit.loadEvents(jfrPath.toFile());\n+\t\tassertTrue(events.hasItems(), \"Recording should contain events\");\n+\n+\t\tevents.forEach(itemType -> {\n+\t\t\titemType.forEach(item -> {\n+\t\t\t\t\/\/ Verify all custom fields have correct values\n+\t\t\t\t\/\/ field1 is LONG → raw number\n+\t\t\t\tIMemberAccessor<Number, IItem> field1Accessor = Attribute\n+\t\t\t\t\t\t.attr(\"field1\", \"field1\", UnitLookup.RAW_NUMBER).getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(111L, field1Accessor.getMember(item).longValue(), \"field1 should be 111\");\n+\n+\t\t\t\tIMemberAccessor<String, IItem> field2Accessor = Attribute\n+\t\t\t\t\t\t.attr(\"field2\", \"field2\", UnitLookup.PLAIN_TEXT).getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(\"test-string\", field2Accessor.getMember(item), \"field2 should be 'test-string'\");\n+\n+\t\t\t\t\/\/ field3 is INT → linear number\n+\t\t\t\tIMemberAccessor<IQuantity, IItem> field3Accessor = Attribute.attr(\"field3\", \"field3\", UnitLookup.NUMBER)\n+\t\t\t\t\t\t.getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(333, field3Accessor.getMember(item).longValue(), \"field3 should be 333\");\n+\t\t\t});\n+\t\t});\n+\t}\n+\n+\t\/**\n+\t * Tests that all builtin types receive proper default values when not explicitly set.\n+\t * <p>\n+\t * This test verifies the fix for builtin type field skipping. When builtin fields are not\n+\t * explicitly set, they should receive type-appropriate defaults (0 for numbers, false for\n+\t * boolean, null for String) instead of being skipped during serialization, which would cause\n+\t * field alignment issues.\n+\t * <p>\n+\t * The test includes a final field with an explicit value to verify that field alignment remains\n+\t * correct after all the default builtin fields.\n+\t *\/\n+\t@Test\n+\tvoid eventWithAllBuiltinFieldsUnset() throws Exception {\n+\t\tType eventType = recording.registerEventType(\"test.AllBuiltins\", builder -> {\n+\t\t\tbuilder.addField(\"byteField\", Types.Builtin.BYTE).addField(\"charField\", Types.Builtin.CHAR)\n+\t\t\t\t\t.addField(\"shortField\", Types.Builtin.SHORT).addField(\"intField\", Types.Builtin.INT)\n+\t\t\t\t\t.addField(\"longField\", Types.Builtin.LONG).addField(\"floatField\", Types.Builtin.FLOAT)\n+\t\t\t\t\t.addField(\"doubleField\", Types.Builtin.DOUBLE).addField(\"booleanField\", Types.Builtin.BOOLEAN)\n+\t\t\t\t\t.addField(\"stringField\", Types.Builtin.STRING).addField(\"finalField\", Types.Builtin.LONG);\n+\t\t});\n+\n+\t\t\/\/ Write event WITHOUT setting builtin field values - all should get defaults\n+\t\t\/\/ Set finalField to verify field alignment is correct\n+\t\trecording.writeEvent(eventType.asValue(builder -> {\n+\t\t\tbuilder.putField(\"finalField\", 99999L);\n+\t\t})).close();\n+\n+\t\t\/\/ Verify recording parses correctly and contains the event\n+\t\tIItemCollection events = JfrLoaderToolkit.loadEvents(jfrPath.toFile());\n+\t\tassertTrue(events.hasItems(), \"Recording should contain events\");\n+\n+\t\tevents.forEach(itemType -> {\n+\t\t\titemType.forEach(item -> {\n+\t\t\t\t\/\/ Verify all builtin fields have appropriate default values\n+\t\t\t\t\/\/ BYTE → linear number\n+\t\t\t\tIMemberAccessor<IQuantity, IItem> byteAccessor = Attribute\n+\t\t\t\t\t\t.attr(\"byteField\", \"byteField\", UnitLookup.NUMBER).getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(0, byteAccessor.getMember(item).longValue(), \"byteField should default to 0\");\n+\n+\t\t\t\t\/\/ SHORT → linear number\n+\t\t\t\tIMemberAccessor<IQuantity, IItem> shortAccessor = Attribute\n+\t\t\t\t\t\t.attr(\"shortField\", \"shortField\", UnitLookup.NUMBER).getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(0, shortAccessor.getMember(item).longValue(), \"shortField should default to 0\");\n+\n+\t\t\t\t\/\/ INT → linear number\n+\t\t\t\tIMemberAccessor<IQuantity, IItem> intAccessor = Attribute\n+\t\t\t\t\t\t.attr(\"intField\", \"intField\", UnitLookup.NUMBER).getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(0, intAccessor.getMember(item).longValue(), \"intField should default to 0\");\n+\n+\t\t\t\t\/\/ LONG → raw number\n+\t\t\t\tIMemberAccessor<Number, IItem> longAccessor = Attribute\n+\t\t\t\t\t\t.attr(\"longField\", \"longField\", UnitLookup.RAW_NUMBER).getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(0L, longAccessor.getMember(item).longValue(), \"longField should default to 0\");\n+\n+\t\t\t\t\/\/ FLOAT → linear number\n+\t\t\t\tIMemberAccessor<IQuantity, IItem> floatAccessor = Attribute\n+\t\t\t\t\t\t.attr(\"floatField\", \"floatField\", UnitLookup.NUMBER).getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(0.0, floatAccessor.getMember(item).doubleValue(), 0.001,\n+\t\t\t\t\t\t\"floatField should default to 0.0\");\n+\n+\t\t\t\t\/\/ DOUBLE → linear number\n+\t\t\t\tIMemberAccessor<IQuantity, IItem> doubleAccessor = Attribute\n+\t\t\t\t\t\t.attr(\"doubleField\", \"doubleField\", UnitLookup.NUMBER).getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(0.0, doubleAccessor.getMember(item).doubleValue(), 0.001,\n+\t\t\t\t\t\t\"doubleField should default to 0.0\");\n+\n+\t\t\t\tIMemberAccessor<Boolean, IItem> booleanAccessor = Attribute\n+\t\t\t\t\t\t.attr(\"booleanField\", \"booleanField\", UnitLookup.FLAG).getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(false, booleanAccessor.getMember(item), \"booleanField should default to false\");\n+\n+\t\t\t\tIMemberAccessor<String, IItem> stringAccessor = Attribute\n+\t\t\t\t\t\t.attr(\"stringField\", \"stringField\", UnitLookup.PLAIN_TEXT).getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(null, stringAccessor.getMember(item), \"stringField should default to null\");\n+\n+\t\t\t\t\/\/ Verify the explicit field value is read correctly (proves field alignment is correct)\n+\t\t\t\t\/\/ LONG → raw number\n+\t\t\t\tIMemberAccessor<Number, IItem> finalAccessor = Attribute\n+\t\t\t\t\t\t.attr(\"finalField\", \"finalField\", UnitLookup.RAW_NUMBER).getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(99999L, finalAccessor.getMember(item).longValue(),\n+\t\t\t\t\t\t\"finalField should be 99999, confirming correct field alignment after all default builtin fields\");\n+\t\t\t});\n+\t\t});\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/ImplicitEventFieldsTest.java","additions":299,"deletions":0,"binary":false,"changes":299,"status":"added"}]}