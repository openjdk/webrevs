{"files":[{"patch":"@@ -71,0 +71,3 @@\n+\tpublic static String ChartComposite_SHOW_ALL;\n+\tpublic static String ChartComposite_SHOW_CUSTOM_LAST;\n+\tpublic static String ChartComposite_SHOW_CUSTOM_RANGE;\n@@ -73,0 +76,10 @@\n+\tpublic static String CustomTimeInputDialog_TITLE;\n+\tpublic static String CustomTimeInputDialog_MESSAGE;\n+\tpublic static String CustomTimeInputDialog_TIME_FIELD_LABEL;\n+\tpublic static String CustomTimeInputDialog_ERROR_INVALID_FORMAT;\n+\tpublic static String CustomTimeInputDialog_ERROR_INVALID_VALUE;\n+\tpublic static String CustomTimeRangeDialog_TITLE;\n+\tpublic static String CustomTimeRangeDialog_MESSAGE;\n+\tpublic static String CustomTimeRangeDialog_FROM_FIELD_LABEL;\n+\tpublic static String CustomTimeRangeDialog_TO_FIELD_LABEL;\n+\tpublic static String CustomTimeRangeDialog_ERROR_FROM_AFTER_TO;\n","filename":"application\/org.openjdk.jmc.greychart.ui\/src\/main\/java\/org\/openjdk\/jmc\/greychart\/ui\/messages\/internal\/Messages.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -59,2 +59,0 @@\n-import org.openjdk.jmc.common.util.Environment;\n-import org.openjdk.jmc.common.util.Environment.OSType;\n@@ -105,15 +103,0 @@\n-\tprivate static final String DRAW_PROPERTY = \"org.openjdk.jmc.rjmx.ui.chart.immediatedraw\"; \/\/$NON-NLS-1$\n-\tprivate static final boolean IMMEDIATE_DRAWING;\n-\n-\tstatic {\n-\t\t\/\/ Workaround for slow SWT redraw on Cocoa.\n-\t\tboolean drawImmediately;\n-\t\tif (System.getProperty(DRAW_PROPERTY) != null) {\n-\t\t\tdrawImmediately = Boolean.getBoolean(DRAW_PROPERTY);\n-\t\t} else {\n-\t\t\t\/\/ Enable on OS X due to https:\/\/bugs.eclipse.org\/bugs\/show_bug.cgi?id=410293\n-\t\t\tdrawImmediately = (Environment.getOSType() == OSType.MAC);\n-\t\t}\n-\t\tIMMEDIATE_DRAWING = drawImmediately;\n-\t}\n-\n@@ -146,1 +129,1 @@\n-\tprivate long m_viewWidth;\n+\tprivate long m_viewWidth = ONE_MINUTE;\n@@ -148,2 +131,0 @@\n-\tprivate long m_dataStart = Long.MAX_VALUE;\n-\tprivate long m_dataEnd = Long.MIN_VALUE;\n@@ -151,0 +132,1 @@\n+\tprivate boolean m_showAllMode = false;\n@@ -156,0 +138,2 @@\n+\t * Constructs a ChartComposite on the provided parent and with the provided widget style.\n+\t *\n@@ -188,2 +172,0 @@\n-\t\t\t((NanosXAxis) getChart().getXAxis()).setRange(m_viewEnd - m_viewWidth, m_viewEnd);\n-\t\t\tm_chart.setXAxis(m_chart.getXAxis());\n@@ -336,2 +318,1 @@\n-\t\tNanosXAxis xAxis = (NanosXAxis) getChart().getXAxis();\n-\t\txAxis.setTitle(getChartModel().getXAxis().getTitle());\n+\t\tgetXAxis().setTitle(getChartModel().getXAxis().getTitle());\n@@ -476,6 +457,8 @@\n-\t\tif (m_enableUpdatesCallback != null) {\n-\t\t\tm_enableUpdatesCallback.accept(true);\n-\t\t}\n-\t\tif (m_dataEnd > 0) {\n-\t\t\tm_viewEnd = m_dataEnd;\n-\t\t}\n+\t\tm_showAllMode = false;\n+\n+\t\t\/\/ Enable auto-range with fixed range\n+\t\tNanosXAxis xAxis = getXAxis();\n+\t\txAxis.setAutoRangeEnabled(true);\n+\t\txAxis.setFixedRange(viewWidth);\n+\n+\t\tsetUpdatesEnabled(true);\n@@ -486,1 +469,1 @@\n-\t * Show all values in the data series. Depends on that the data range is set correctly.\n+\t * Show all values in the data series. Uses provider data bounds for the complete range.\n@@ -489,2 +472,30 @@\n-\t\tm_viewWidth = m_dataEnd - m_dataStart;\n-\t\tm_viewEnd = m_dataEnd;\n+\t\tm_showAllMode = true;\n+\n+\t\t\/\/ Enable auto-range with no fixed range - axis will show full data range\n+\t\tNanosXAxis xAxis = getXAxis();\n+\t\txAxis.setAutoRangeEnabled(true);\n+\t\t\/\/ Clear fixed range to show all data\n+\t\txAxis.setFixedRange(0);\n+\n+\t\tsetUpdatesEnabled(true);\n+\t\trefresh();\n+\t}\n+\n+\t\/**\n+\t * Show a specific time range and disable live updates.\n+\t *\n+\t * @param fromTimeNanos\n+\t *            Start time in nanoseconds\n+\t * @param toTimeNanos\n+\t *            End time in nanoseconds\n+\t *\/\n+\tpublic void showTimeRange(long fromTimeNanos, long toTimeNanos) {\n+\t\tm_showAllMode = false;\n+\n+\t\t\/\/ Use manual range for custom time ranges\n+\t\tNanosXAxis xAxis = getXAxis();\n+\t\txAxis.setAutoRangeEnabled(false);\n+\t\txAxis.setRange(fromTimeNanos, toTimeNanos);\n+\n+\t\tm_viewWidth = toTimeNanos - fromTimeNanos;\n+\t\tsetUpdatesEnabled(false);\n@@ -495,1 +506,48 @@\n-\t\tsetDataRange(Math.min(m_dataStart, timestamp), Math.max(m_dataEnd, timestamp));\n+\t\t\/\/ Simply trigger a data update - no need to maintain separate bounds\n+\t\tonDataUpdated();\n+\t}\n+\n+\t\/**\n+\t * Get the start timestamp of the available data range.\n+\t *\n+\t * @return Start timestamp in nanoseconds\n+\t *\/\n+\tpublic long getDataStartTime() {\n+\t\treturn getProviderMinTime();\n+\t}\n+\n+\t\/**\n+\t * Get the end timestamp of the available data range.\n+\t *\n+\t * @return End timestamp in nanoseconds\n+\t *\/\n+\tpublic long getDataEndTime() {\n+\t\treturn getProviderMaxTime();\n+\t}\n+\n+\t\/**\n+\t * Get the full available data range minimum timestamp. This returns the true dataset bounds\n+\t * regardless of current view restrictions.\n+\t *\n+\t * @return Minimum timestamp in nanoseconds from the full dataset\n+\t *\/\n+\tpublic long getProviderMinTime() {\n+\t\tOptimizingProvider provider = m_chart.getOptimizingProvider();\n+\t\tif (provider != null) {\n+\t\t\treturn provider.getDataMinX();\n+\t\t}\n+\t\treturn System.currentTimeMillis() * 1000 * 1000 - (60 * 1000 * 1000 * 1000L);\n+\t}\n+\n+\t\/**\n+\t * Get the full available data range maximum timestamp. This returns the true dataset bounds\n+\t * regardless of current view restrictions.\n+\t *\n+\t * @return Maximum timestamp in nanoseconds from the full dataset\n+\t *\/\n+\tpublic long getProviderMaxTime() {\n+\t\tOptimizingProvider provider = m_chart.getOptimizingProvider();\n+\t\tif (provider != null) {\n+\t\t\treturn provider.getDataMaxX();\n+\t\t}\n+\t\treturn System.currentTimeMillis() * 1000 * 1000;\n@@ -507,1 +565,2 @@\n-\t\tif (dataEnd > 0 && (m_enableUpdates || m_dataEnd < 0)) {\n+\t\t\/\/ Update view end for live updates (if enabled)\n+\t\tif (dataEnd > 0 && m_enableUpdates) {\n@@ -510,2 +569,24 @@\n-\t\tm_dataStart = dataStart;\n-\t\tm_dataEnd = dataEnd;\n+\n+\t\tonDataUpdated();\n+\t}\n+\n+\t\/**\n+\t * Called when data has been updated (either incrementally or wholesale). Handles both \"All\"\n+\t * mode dynamic expansion and regular refreshes.\n+\t *\/\n+\tprivate void onDataUpdated() {\n+\t\t\/\/ Force provider rebuild to incorporate new data\n+\t\tm_chart.markProviderRebuildNeeded();\n+\t\tm_chart.rebuildOptimizingProvider();\n+\n+\t\tif (m_showAllMode) {\n+\t\t\t\/\/ Use provider data bounds - want to see all available data\n+\t\t\tlong dataMin = getProviderMinTime();\n+\t\t\tlong dataMax = getProviderMaxTime();\n+\n+\t\t\tif (dataMax > dataMin) {\n+\t\t\t\tm_viewWidth = dataMax - dataMin;\n+\t\t\t\tm_viewEnd = dataMax;\n+\t\t\t}\n+\t\t}\n+\n@@ -516,0 +597,5 @@\n+\t\t\/\/ Only proceed if state is actually changing to avoid infinite recursion\n+\t\tif (m_enableUpdates == enabled) {\n+\t\t\treturn;\n+\t\t}\n+\n@@ -519,3 +605,11 @@\n-\t\tif (m_enableUpdates && m_dataEnd > 0) {\n-\t\t\tm_viewEnd = m_dataEnd;\n-\t\t\trefresh();\n+\t\tif (m_enableUpdates) {\n+\t\t\tlong currentDataEnd = getProviderMaxTime();\n+\t\t\tif (currentDataEnd > Long.MIN_VALUE) {\n+\t\t\t\tm_viewEnd = currentDataEnd;\n+\t\t\t\trefresh();\n+\t\t\t}\n+\t\t}\n+\n+\t\t\/\/ Notify the callback about the state change\n+\t\tif (m_enableUpdatesCallback != null) {\n+\t\t\tm_enableUpdatesCallback.accept(enabled);\n@@ -526,1 +620,4 @@\n-\t\tif (m_dataEnd > m_dataStart) {\n+\t\tlong dataStart = getProviderMinTime();\n+\t\tlong dataEnd = getProviderMaxTime();\n+\n+\t\tif (dataEnd > dataStart) {\n@@ -534,2 +631,2 @@\n-\t\t\tm_viewEnd = (long) Math.min(Math.max(m_viewEnd, m_dataEnd + padding), newWorldEnd);\n-\t\t\tnewWorldStart = Math.max(Math.min(worldStart, m_dataStart - padding), newWorldStart);\n+\t\t\tm_viewEnd = (long) Math.min(Math.max(m_viewEnd, dataEnd + padding), newWorldEnd);\n+\t\t\tnewWorldStart = Math.max(Math.min(worldStart, dataStart - padding), newWorldStart);\n","filename":"application\/org.openjdk.jmc.greychart.ui\/src\/main\/java\/org\/openjdk\/jmc\/greychart\/ui\/views\/ChartComposite.java","additions":140,"deletions":43,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -54,0 +54,5 @@\n+import static org.openjdk.jmc.common.unit.UnitLookup.EPOCH_MS;\n+import static org.openjdk.jmc.common.unit.UnitLookup.EPOCH_NS;\n+import static org.openjdk.jmc.common.unit.UnitLookup.NANOSECOND;\n+import static org.openjdk.jmc.common.unit.UnitLookup.TIMESPAN;\n+\n@@ -60,0 +65,1 @@\n+import org.openjdk.jmc.ui.misc.DateTimeChooser;\n@@ -77,0 +83,3 @@\n+\t\tm.add(createShowAll(chart));\n+\t\tm.add(createShowCustomLast(chart));\n+\t\tm.add(createShowCustomRange(chart));\n@@ -89,0 +98,33 @@\n+\tprivate static Action createShowAll(final ChartComposite chart) {\n+\t\treturn new Action(Messages.ChartComposite_SHOW_ALL) {\n+\t\t\t@Override\n+\t\t\tpublic void run() {\n+\t\t\t\tchart.showAll();\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static Action createShowCustomLast(final ChartComposite chart) {\n+\t\treturn new Action(Messages.ChartComposite_SHOW_CUSTOM_LAST) {\n+\t\t\t@Override\n+\t\t\tpublic void run() {\n+\t\t\t\tCustomTimeInputDialog dialog = new CustomTimeInputDialog(Display.getCurrent().getActiveShell());\n+\t\t\t\tif (dialog.open() == Window.OK) {\n+\t\t\t\t\tchart.showLast(dialog.getTimeInNanoSeconds());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static Action createShowCustomRange(final ChartComposite chart) {\n+\t\treturn new Action(Messages.ChartComposite_SHOW_CUSTOM_RANGE) {\n+\t\t\t@Override\n+\t\t\tpublic void run() {\n+\t\t\t\tCustomTimeRangeDialog dialog = new CustomTimeRangeDialog(Display.getCurrent().getActiveShell(), chart);\n+\t\t\t\tif (dialog.open() == Window.OK) {\n+\t\t\t\t\tchart.showTimeRange(dialog.getFromTimeNanos(), dialog.getToTimeNanos());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t};\n+\t}\n+\n@@ -303,0 +345,197 @@\n+\tpublic static class CustomTimeInputDialog extends TitleAreaDialog {\n+\t\tprivate Text timeText;\n+\t\tprivate long timeInNanoSeconds;\n+\n+\t\tpublic CustomTimeInputDialog(Shell parentShell) {\n+\t\t\tsuper(parentShell);\n+\t\t}\n+\n+\t\tprivate void validateInput() {\n+\t\t\tString errorMessage = validateTimespan(timeText.getText());\n+\t\t\tgetButton(IDialogConstants.OK_ID).setEnabled(errorMessage == null);\n+\t\t\tsetErrorMessage(errorMessage);\n+\t\t}\n+\n+\t\tprivate String validateTimespan(String text) {\n+\t\t\ttry {\n+\t\t\t\tIQuantity timespan = TIMESPAN.parseInteractive(text);\n+\t\t\t\tif (timespan.doubleValue() <= 0.0) {\n+\t\t\t\t\treturn Messages.CustomTimeInputDialog_ERROR_INVALID_VALUE;\n+\t\t\t\t}\n+\t\t\t\ttimeInNanoSeconds = timespan.longValueIn(NANOSECOND);\n+\t\t\t} catch (QuantityConversionException e) {\n+\t\t\t\treturn e.getLocalizedMessage();\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected Control createContents(Composite parent) {\n+\t\t\tgetShell().setText(Messages.CustomTimeInputDialog_TITLE);\n+\t\t\tControl contents = super.createContents(parent);\n+\t\t\tcontents.getShell().setSize(400, 200);\n+\t\t\tDisplayToolkit.placeDialogInCenter(getParentShell(), getShell());\n+\t\t\tsetMessage(Messages.CustomTimeInputDialog_MESSAGE);\n+\t\t\tsetTitle(Messages.CustomTimeInputDialog_TITLE);\n+\t\t\tvalidateInput();\n+\t\t\treturn contents;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected Control createDialogArea(Composite parent) {\n+\t\t\tComposite composite = (Composite) super.createDialogArea(parent);\n+\t\t\tcreateCustomArea(composite);\n+\t\t\tapplyDialogFont(composite);\n+\t\t\treturn composite;\n+\t\t}\n+\n+\t\tprivate Control createCustomArea(Composite parent) {\n+\t\t\tComposite timeFields = new Composite(parent, SWT.NONE);\n+\t\t\ttimeFields.setLayout(new GridLayout(2, false));\n+\t\t\tGridData gd = new GridData(SWT.FILL, SWT.FILL, true, false);\n+\t\t\tgd.widthHint = 120;\n+\t\t\tLabel timeLabel = new Label(timeFields, SWT.NONE);\n+\t\t\ttimeLabel.setText(Messages.CustomTimeInputDialog_TIME_FIELD_LABEL);\n+\t\t\ttimeLabel.setLayoutData(new GridData(SWT.FILL, SWT.FILL, false, false));\n+\t\t\ttimeText = new Text(timeFields, SWT.SINGLE | SWT.BORDER);\n+\t\t\ttimeText.setLayoutData(gd);\n+\t\t\ttimeText.setFocus();\n+\t\t\ttimeText.setText(\"1 h\");\n+\t\t\ttimeText.addModifyListener(new ModifyListener() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void modifyText(ModifyEvent e) {\n+\t\t\t\t\tvalidateInput();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tQuantityKindProposal.install(timeText, TIMESPAN);\n+\t\t\treturn timeFields;\n+\t\t}\n+\n+\t\tpublic long getTimeInNanoSeconds() {\n+\t\t\treturn timeInNanoSeconds;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected void okPressed() {\n+\t\t\tString errorMessage = validateTimespan(timeText.getText());\n+\t\t\tif (errorMessage == null) {\n+\t\t\t\tsuper.okPressed();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static class CustomTimeRangeDialog extends TitleAreaDialog {\n+\t\tprivate DateTimeChooser startTimeChooser;\n+\t\tprivate DateTimeChooser endTimeChooser;\n+\t\tprivate final ChartComposite chart;\n+\t\tprivate long fromTimeNanos;\n+\t\tprivate long toTimeNanos;\n+\n+\t\tpublic CustomTimeRangeDialog(Shell parentShell, ChartComposite chart) {\n+\t\t\tsuper(parentShell);\n+\t\t\tthis.chart = chart;\n+\t\t}\n+\n+\t\tprivate void validateInput() {\n+\t\t\tString errorMessage = validateTimeRange();\n+\t\t\tgetButton(IDialogConstants.OK_ID).setEnabled(errorMessage == null);\n+\t\t\tsetErrorMessage(errorMessage);\n+\t\t}\n+\n+\t\tprivate String validateTimeRange() {\n+\t\t\tlong startTimeMs = startTimeChooser.getTimestamp();\n+\t\t\tlong endTimeMs = endTimeChooser.getTimestamp();\n+\n+\t\t\ttry {\n+\t\t\t\t\/\/ Convert milliseconds to nanoseconds\n+\t\t\t\tfromTimeNanos = EPOCH_MS.quantity(startTimeMs).longValueIn(EPOCH_NS);\n+\t\t\t\ttoTimeNanos = EPOCH_MS.quantity(endTimeMs).longValueIn(EPOCH_NS);\n+\t\t\t} catch (QuantityConversionException e) {\n+\t\t\t\t\/\/ This should rarely happen since we're converting between well-defined epoch units\n+\t\t\t\treturn e.getLocalizedMessage();\n+\t\t\t}\n+\n+\t\t\tif (fromTimeNanos >= toTimeNanos) {\n+\t\t\t\treturn Messages.CustomTimeRangeDialog_ERROR_FROM_AFTER_TO;\n+\t\t\t}\n+\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected Control createContents(Composite parent) {\n+\t\t\tgetShell().setText(Messages.CustomTimeRangeDialog_TITLE);\n+\t\t\tControl contents = super.createContents(parent);\n+\t\t\tcontents.getShell().setSize(550, 300);\n+\t\t\tDisplayToolkit.placeDialogInCenter(getParentShell(), getShell());\n+\t\t\tsetMessage(Messages.CustomTimeRangeDialog_MESSAGE);\n+\t\t\tsetTitle(Messages.CustomTimeRangeDialog_TITLE);\n+\t\t\tvalidateInput();\n+\t\t\treturn contents;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected Control createDialogArea(Composite parent) {\n+\t\t\tComposite composite = (Composite) super.createDialogArea(parent);\n+\t\t\tcreateCustomArea(composite);\n+\t\t\tapplyDialogFont(composite);\n+\t\t\treturn composite;\n+\t\t}\n+\n+\t\tprivate Control createCustomArea(Composite parent) {\n+\t\t\tComposite timeFields = new Composite(parent, SWT.NONE);\n+\t\t\ttimeFields.setLayout(new GridLayout(2, false));\n+\t\t\ttimeFields.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));\n+\n+\t\t\t\/\/ Start time\n+\t\t\tLabel startLabel = new Label(timeFields, SWT.NONE);\n+\t\t\tstartLabel.setText(Messages.CustomTimeRangeDialog_FROM_FIELD_LABEL);\n+\t\t\tstartLabel.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, false, false));\n+\n+\t\t\tstartTimeChooser = new DateTimeChooser(timeFields, SWT.NONE);\n+\t\t\tstartTimeChooser.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, false));\n+\n+\t\t\t\/\/ End time\n+\t\t\tLabel endLabel = new Label(timeFields, SWT.NONE);\n+\t\t\tendLabel.setText(Messages.CustomTimeRangeDialog_TO_FIELD_LABEL);\n+\t\t\tendLabel.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, false, false));\n+\n+\t\t\tendTimeChooser = new DateTimeChooser(timeFields, SWT.NONE);\n+\t\t\tendTimeChooser.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, false));\n+\n+\t\t\t\/\/ Prefill with actual provider data range\n+\t\t\tlong dataStart = chart.getProviderMinTime();\n+\t\t\tlong dataEnd = chart.getProviderMaxTime();\n+\t\t\tif (dataStart != Long.MAX_VALUE && dataEnd != Long.MIN_VALUE) {\n+\t\t\t\t\/\/ Convert nanoseconds to milliseconds for DateTimeChooser\n+\t\t\t\tlong startMs = EPOCH_NS.quantity(dataStart).clampedLongValueIn(EPOCH_MS);\n+\t\t\t\tlong endMs = EPOCH_NS.quantity(dataEnd).clampedLongValueIn(EPOCH_MS);\n+\t\t\t\tstartTimeChooser.setTimestamp(startMs);\n+\t\t\t\tendTimeChooser.setTimestamp(endMs);\n+\t\t\t}\n+\n+\t\t\treturn timeFields;\n+\t\t}\n+\n+\t\tpublic long getFromTimeNanos() {\n+\t\t\treturn fromTimeNanos;\n+\t\t}\n+\n+\t\tpublic long getToTimeNanos() {\n+\t\t\treturn toTimeNanos;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected boolean isResizable() {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected void okPressed() {\n+\t\t\tString errorMessage = validateTimeRange();\n+\t\t\tif (errorMessage == null) {\n+\t\t\t\tsuper.okPressed();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n","filename":"application\/org.openjdk.jmc.greychart.ui\/src\/main\/java\/org\/openjdk\/jmc\/greychart\/ui\/views\/ChartMenuBuilder.java","additions":239,"deletions":0,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -64,0 +64,3 @@\n+ChartComposite_SHOW_ALL=All\n+ChartComposite_SHOW_CUSTOM_LAST=Custom Last...\n+ChartComposite_SHOW_CUSTOM_RANGE=Custom Time Range...\n@@ -67,0 +70,12 @@\n+CustomTimeInputDialog_TITLE=Custom Time Range\n+CustomTimeInputDialog_MESSAGE=Enter the time duration to show\n+CustomTimeInputDialog_TIME_FIELD_LABEL=Duration:\n+CustomTimeInputDialog_ERROR_INVALID_FORMAT=Invalid time format. Use format like '5m', '2h', '30s', '1d'\n+CustomTimeInputDialog_ERROR_INVALID_VALUE=Time value must be positive\n+\n+CustomTimeRangeDialog_TITLE=Custom Time Range\n+CustomTimeRangeDialog_MESSAGE=Specify the exact time range to display\n+CustomTimeRangeDialog_FROM_FIELD_LABEL=Start Time:\n+CustomTimeRangeDialog_TO_FIELD_LABEL=End Time:\n+CustomTimeRangeDialog_ERROR_FROM_AFTER_TO=Start time must be before end time\n+\n","filename":"application\/org.openjdk.jmc.greychart.ui\/src\/main\/resources\/org\/openjdk\/jmc\/greychart\/ui\/messages\/internal\/messages.properties","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -65,1 +65,2 @@\n-\tpublic AbstractAliasingLongAxis(SeriesGreyChart owner, long[] aliasingArray, long defaultRange, long defaultDiff) {\n+\tpublic AbstractAliasingLongAxis(SeriesGreyChart<?> owner, long[] aliasingArray, long defaultRange,\n+\t\t\tlong defaultDiff) {\n@@ -167,0 +168,5 @@\n+\t\t\/\/ Avoid unnecessary fireAxisChange() calls by checking if values actually changed\n+\t\tif (m_min != null && m_max != null && m_min.longValue() == min.longValue()\n+\t\t\t\t&& m_max.longValue() == max.longValue()) {\n+\t\t\treturn; \/\/ No change, skip update\n+\t\t}\n@@ -170,1 +176,0 @@\n-\t\t\/\/ FIXME: Notify chart of change!\n","filename":"application\/org.openjdk.jmc.greychart\/src\/main\/java\/org\/openjdk\/jmc\/greychart\/impl\/AbstractAliasingLongAxis.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import org.openjdk.jmc.common.xydata.IXYData;\n@@ -64,3 +65,4 @@\n- * The default little XY chart. This class currently implements rather much. Whenever there is a\n- * need for other kinds of charts, abstract superclasses will be created and functionality will be\n- * moved up the hierarchy. It currently lays out the chart in the following fashion.\n+ * The default little XY chart for data that extends IXYData&lt;Long, Number&gt;. This class\n+ * currently implements rather much. Whenever there is a need for other kinds of charts, abstract\n+ * superclasses will be created and functionality will be moved up the hierarchy. It currently lays\n+ * out the chart in the following fashion.\n@@ -82,1 +84,2 @@\n-public class DefaultXYGreyChart<XYData> extends AbstractGreyChart<XYData> implements XYGreyChart<XYData>, AxisListener {\n+public class DefaultXYGreyChart<T extends IXYData<Long, Number>> extends AbstractGreyChart<T>\n+\t\timplements XYGreyChart<T>, AxisListener {\n@@ -97,0 +100,1 @@\n+\tprivate boolean m_needsProviderRebuild = true;\n@@ -127,1 +131,6 @@\n-\t\trebuildOptimizingProvider(getDataProvider());\n+\t\t\/\/ Only rebuild if we have a data provider, otherwise mark for later rebuild\n+\t\tif (getDataProvider() != null) {\n+\t\t\trebuildOptimizingProvider(getDataProvider());\n+\t\t} else {\n+\t\t\tm_needsProviderRebuild = true;\n+\t\t}\n@@ -185,1 +194,0 @@\n-\n@@ -401,1 +409,1 @@\n-\tpublic void setDataProvider(DataSeriesProvider<XYData> dataProvider) {\n+\tpublic void setDataProvider(DataSeriesProvider<T> dataProvider) {\n@@ -406,1 +414,1 @@\n-\tprivate void rebuildOptimizingProvider(DataSeriesProvider<XYData> sp) {\n+\tprivate void rebuildOptimizingProvider(DataSeriesProvider<T> sp) {\n@@ -410,1 +418,1 @@\n-\t\tDataSeries[] series = sp.getDataSeries();\n+\t\tDataSeries<T>[] series = sp.getDataSeries();\n@@ -432,1 +440,2 @@\n-\tprivate OptimizingProvider createOptimizingProvider(DataSeries series, double yMultiplier, RenderingMode mode) {\n+\t@SuppressWarnings(\"unchecked\")\n+\tprivate OptimizingProvider createOptimizingProvider(DataSeries<T> series, double yMultiplier, RenderingMode mode) {\n@@ -434,0 +443,2 @@\n+\t\t\/\/ Safe cast: T extends IXYData<Long, Number>, so DataSeries<T> can be cast to DataSeries<IXYData<Long, Number>>\n+\t\tDataSeries<IXYData<Long, Number>> typedSeries = (DataSeries<IXYData<Long, Number>>) series;\n@@ -437,1 +448,1 @@\n-\t\t\treturn new SampleCountingProvider(series, yMultiplier, getXAxis(), m_cancelService, integrating);\n+\t\t\treturn new SampleCountingProvider(typedSeries, yMultiplier, getXAxis(), m_cancelService, integrating);\n@@ -439,1 +450,1 @@\n-\t\t\treturn new AveragingProvider(series, yMultiplier, getXAxis(), m_cancelService);\n+\t\t\treturn new AveragingProvider(typedSeries, yMultiplier, getXAxis(), m_cancelService);\n@@ -443,1 +454,1 @@\n-\t\t\treturn new SubsamplingProvider(series, yMultiplier, getXAxis(), m_cancelService, integrating);\n+\t\t\treturn new SubsamplingProvider(typedSeries, yMultiplier, getXAxis(), m_cancelService, integrating);\n@@ -448,1 +459,1 @@\n-\t\tDataSeries[] series, OptimizingProvider[] optimizingProviders, OptimizingProvider[][] stacks) {\n+\t\tDataSeries<T>[] series, OptimizingProvider[] optimizingProviders, OptimizingProvider[][] stacks) {\n@@ -457,1 +468,1 @@\n-\tprivate void buildLeftAndRightProviders(DataSeries[] series, OptimizingProvider[] optimizingProviders) {\n+\tprivate void buildLeftAndRightProviders(DataSeries<T>[] series, OptimizingProvider[] optimizingProviders) {\n@@ -525,0 +536,23 @@\n+\tpublic OptimizingProvider getXAxisProvider() {\n+\t\treturn m_optimizingProvider;\n+\t}\n+\n+\t\/**\n+\t * Rebuilds the optimizing provider when data or axis configuration changes. Only rebuilds if\n+\t * changes have occurred that require it.\n+\t *\/\n+\tpublic void rebuildOptimizingProvider() {\n+\t\t\/\/ Always rebuild if provider is null (defensive) or if changes occurred\n+\t\tif (m_optimizingProvider == null || m_needsProviderRebuild) {\n+\t\t\trebuildOptimizingProvider(getDataProvider());\n+\t\t\tm_needsProviderRebuild = false;\n+\t\t}\n+\t}\n+\n+\t\/**\n+\t * Marks that the optimizing provider needs rebuilding on the next refresh call.\n+\t *\/\n+\tpublic void markProviderRebuildNeeded() {\n+\t\tm_needsProviderRebuild = true;\n+\t}\n+\n","filename":"application\/org.openjdk.jmc.greychart\/src\/main\/java\/org\/openjdk\/jmc\/greychart\/impl\/DefaultXYGreyChart.java","additions":49,"deletions":15,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-import org.openjdk.jmc.greychart.SeriesGreyChart;\n-\n@@ -42,2 +40,1 @@\n-\t\/\/ The aliasing array is used to find the right tick starting value and\n-\t\/\/ distance.\n+\t\/\/ The aliasing array is used to find the right tick starting value and distance.\n@@ -53,0 +50,2 @@\n+\tprivate boolean m_autoRangeEnabled = false;\n+\n@@ -63,1 +62,1 @@\n-\tpublic NanosXAxis(SeriesGreyChart owner) {\n+\tpublic NanosXAxis(DefaultXYGreyChart<?> owner) {\n@@ -69,0 +68,67 @@\n+\n+\t\/**\n+\t * Sets whether auto-range is enabled for this axis. When enabled, the axis will automatically\n+\t * determine its range based on the actual data. If a fixed range is set\n+\t * ({@link #setFixedRange(long)}), the axis will use [dataMax - fixedRange, dataMax].\n+\t *\n+\t * @param enable\n+\t *            true to enable auto-range, false to use fixed range\n+\t *\/\n+\tpublic void setAutoRangeEnabled(boolean enable) {\n+\t\tm_autoRangeEnabled = enable;\n+\t\tif (enable) {\n+\t\t\t\/\/ Update fields immediately to avoid null pointer issues\n+\t\t\tupdateAutoRangeFields();\n+\t\t}\n+\t}\n+\n+\t\/**\n+\t * @return true if auto-range is enabled\n+\t *\/\n+\tpublic boolean isAutoRangeEnabled() {\n+\t\treturn m_autoRangeEnabled;\n+\t}\n+\n+\t@Override\n+\tprotected DefaultXYGreyChart<?> getOwner() {\n+\t\treturn (DefaultXYGreyChart<?>) super.getOwner();\n+\t}\n+\n+\t@Override\n+\tpublic Number getMin() {\n+\t\tif (isAutoRangeEnabled()) {\n+\t\t\tupdateAutoRangeFields();\n+\t\t}\n+\t\treturn super.getMin();\n+\t}\n+\n+\t@Override\n+\tpublic Number getMax() {\n+\t\tif (isAutoRangeEnabled()) {\n+\t\t\tupdateAutoRangeFields();\n+\t\t}\n+\t\treturn super.getMax();\n+\t}\n+\n+\tprivate void updateAutoRangeFields() {\n+\t\tDefaultXYGreyChart<?> chart = getOwner();\n+\t\tif (chart != null) {\n+\t\t\tOptimizingProvider provider = chart.getXAxisProvider();\n+\t\t\tif (provider != null) {\n+\t\t\t\tlong minValue = provider.getDataMinX();\n+\t\t\t\tlong maxValue = provider.getDataMaxX();\n+\n+\t\t\t\tif (minValue != Long.MAX_VALUE && maxValue != Long.MIN_VALUE && minValue != maxValue) {\n+\t\t\t\t\tif (getFixedRange() > 0) {\n+\t\t\t\t\t\tsetRange(maxValue);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tsetRange(minValue, maxValue);\n+\t\t\t\t\t}\n+\t\t\t\t} else if (m_min == null || m_max == null) {\n+\t\t\t\t\tsetRange(0L, DEFAULT_RANGE);\n+\t\t\t\t}\n+\t\t\t} else if (m_min == null || m_max == null) {\n+\t\t\t\tsetRange(0L, DEFAULT_RANGE);\n+\t\t\t}\n+\t\t}\n+\t}\n","filename":"application\/org.openjdk.jmc.greychart\/src\/main\/java\/org\/openjdk\/jmc\/greychart\/impl\/NanosXAxis.java","additions":71,"deletions":5,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import org.openjdk.jmc.common.xydata.IXYData;\n@@ -68,1 +69,1 @@\n-\tpublic DataSeries getDataSeries();\n+\tpublic DataSeries<IXYData<Long, Number>> getDataSeries();\n@@ -73,1 +74,1 @@\n-\t * @return the minimum Y value in world coordinates\n+\t * @return the minimum Y value in the current range\/view in world coordinates\n@@ -78,1 +79,1 @@\n-\t * @return the maximum Y value in world coordinates\n+\t * @return the maximum Y value in the current range\/view in world coordinates\n@@ -84,0 +85,3 @@\n+\t\/**\n+\t * @return the minimum X value in the current range\/view\n+\t *\/\n@@ -86,0 +90,3 @@\n+\t\/**\n+\t * @return the maximum X value in the current range\/view\n+\t *\/\n@@ -88,0 +95,20 @@\n+\t\/**\n+\t * @return the minimum X value in the entire dataset (regardless of current range)\n+\t *\/\n+\tpublic long getDataMinX();\n+\n+\t\/**\n+\t * @return the maximum X value in the entire dataset (regardless of current range)\n+\t *\/\n+\tpublic long getDataMaxX();\n+\n+\t\/**\n+\t * @return the minimum Y value in the entire dataset (regardless of current range)\n+\t *\/\n+\tpublic double getDataMinY();\n+\n+\t\/**\n+\t * @return the maximum Y value in the entire dataset (regardless of current range)\n+\t *\/\n+\tpublic double getDataMaxY();\n+\n","filename":"application\/org.openjdk.jmc.greychart\/src\/main\/java\/org\/openjdk\/jmc\/greychart\/impl\/OptimizingProvider.java","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-\tpublic SimpleXAxis(SeriesGreyChart owner) {\n+\tpublic SimpleXAxis(SeriesGreyChart<?> owner) {\n","filename":"application\/org.openjdk.jmc.greychart\/src\/main\/java\/org\/openjdk\/jmc\/greychart\/impl\/SimpleXAxis.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.greychart.providers;\n+\n+import java.util.Iterator;\n+\n+import org.openjdk.jmc.common.xydata.DataSeries;\n+import org.openjdk.jmc.common.xydata.IXYData;\n+import org.openjdk.jmc.greychart.impl.OptimizingProvider;\n+\n+\/**\n+ * Abstract base class for OptimizingProvider implementations that provides common functionality for\n+ * tracking full data bounds independent of current range restrictions.\n+ *\/\n+public abstract class AbstractOptimizingProvider implements OptimizingProvider {\n+\tprivate long m_dataMinX = Long.MAX_VALUE;\n+\tprivate long m_dataMaxX = Long.MIN_VALUE;\n+\tprivate double m_dataMinY = Double.POSITIVE_INFINITY;\n+\tprivate double m_dataMaxY = Double.NEGATIVE_INFINITY;\n+\tprivate boolean m_dataBoundsComputed = false;\n+\n+\t@Override\n+\tpublic void setDataChanged(boolean changed) {\n+\t\tif (changed) {\n+\t\t\tm_dataBoundsComputed = false;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic long getDataMinX() {\n+\t\tcomputeDataBounds();\n+\t\treturn m_dataMinX;\n+\t}\n+\n+\t@Override\n+\tpublic long getDataMaxX() {\n+\t\tcomputeDataBounds();\n+\t\treturn m_dataMaxX;\n+\t}\n+\n+\t@Override\n+\tpublic double getDataMinY() {\n+\t\tcomputeDataBounds();\n+\t\treturn m_dataMinY;\n+\t}\n+\n+\t@Override\n+\tpublic double getDataMaxY() {\n+\t\tcomputeDataBounds();\n+\t\treturn m_dataMaxY;\n+\t}\n+\n+\t\/**\n+\t * Computes the full data bounds by iterating through all data in the series. This method is\n+\t * called lazily and caches the results until data changes. Subclasses can override this method\n+\t * to provide custom bounds computation.\n+\t *\/\n+\tprotected void computeDataBounds() {\n+\t\tif (m_dataBoundsComputed) {\n+\t\t\treturn;\n+\t\t}\n+\t\tm_dataMinX = Long.MAX_VALUE;\n+\t\tm_dataMaxX = Long.MIN_VALUE;\n+\t\tm_dataMinY = Double.POSITIVE_INFINITY;\n+\t\tm_dataMaxY = Double.NEGATIVE_INFINITY;\n+\n+\t\tDataSeries<IXYData<Long, Number>> dataSeries = getDataSeries();\n+\t\tif (dataSeries != null) {\n+\t\t\t\/\/ Iterate through all data to find true bounds\n+\t\t\tIterator<IXYData<Long, Number>> it = dataSeries.createIterator(Long.MIN_VALUE, Long.MAX_VALUE);\n+\t\t\twhile (it.hasNext()) {\n+\t\t\t\tIXYData<Long, Number> data = it.next();\n+\t\t\t\tlong x = data.getX();\n+\t\t\t\tdouble y = data.getY().doubleValue();\n+\n+\t\t\t\tm_dataMinX = Math.min(m_dataMinX, x);\n+\t\t\t\tm_dataMaxX = Math.max(m_dataMaxX, x);\n+\t\t\t\tm_dataMinY = Math.min(m_dataMinY, y);\n+\t\t\t\tm_dataMaxY = Math.max(m_dataMaxY, y);\n+\t\t\t}\n+\t\t}\n+\t\tm_dataBoundsComputed = true;\n+\t}\n+}\n","filename":"application\/org.openjdk.jmc.greychart\/src\/main\/java\/org\/openjdk\/jmc\/greychart\/providers\/AbstractOptimizingProvider.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -52,3 +52,2 @@\n-\n-public final class AveragingProvider implements OptimizingProvider {\n-\tprivate final DataSeries<IXYData> m_dataSeries;\n+public final class AveragingProvider extends AbstractOptimizingProvider {\n+\tprivate final DataSeries<IXYData<Long, Number>> m_dataSeries;\n@@ -66,1 +65,2 @@\n-\tpublic AveragingProvider(DataSeries<IXYData> s, double yMultiplier, XAxis xAxis, CancelService cancelService) {\n+\tpublic AveragingProvider(DataSeries<IXYData<Long, Number>> s, double yMultiplier, XAxis xAxis,\n+\t\t\tCancelService cancelService) {\n@@ -134,1 +134,1 @@\n-\t\tIterator<IXYData> it = m_dataSeries.createIterator(m_requestedStartX, m_requestedEndX);\n+\t\tIterator<IXYData<Long, Number>> it = m_dataSeries.createIterator(m_requestedStartX, m_requestedEndX);\n@@ -142,1 +142,1 @@\n-\t\tIXYData data = addFirstBoundaryPoint(sampleBuffer, it, worldWidth, leftEdge);\n+\t\tIXYData<Long, Number> data = addFirstBoundaryPoint(sampleBuffer, it, worldWidth, leftEdge);\n@@ -144,2 +144,2 @@\n-\t\tlong x = getXAsLong(data);\n-\t\tlong oldx = getXAsLong(data);\n+\t\tlong x = data.getX();\n+\t\tlong oldx = data.getX();\n@@ -151,2 +151,2 @@\n-\t\t\tIXYData newData = it.next();\n-\t\t\tx = getXAsLong(newData);\n+\t\t\tIXYData<Long, Number> newData = it.next();\n+\t\t\tx = newData.getX();\n@@ -168,7 +168,3 @@\n-\tprivate long getXAsLong(IXYData data) {\n-\t\treturn ((Number) data.getX()).longValue();\n-\t}\n-\n-\tprivate IXYData addFirstBoundaryPoint(\n-\t\tAveragingSampleBuffer sampleBuffer, Iterator<IXYData> it, long worldWidth, long leftEdge) {\n-\t\tIXYData firstDataPoint = null;\n+\tprivate IXYData<Long, Number> addFirstBoundaryPoint(\n+\t\tAveragingSampleBuffer sampleBuffer, Iterator<IXYData<Long, Number>> it, long worldWidth, long leftEdge) {\n+\t\tIXYData<Long, Number> firstDataPoint = null;\n@@ -177,1 +173,1 @@\n-\t\t\tlong x = getXAsLong(firstDataPoint);\n+\t\t\tlong x = firstDataPoint.getX();\n@@ -185,2 +181,2 @@\n-\t\t\tIXYData data = it.next();\n-\t\t\tlong x = getXAsLong(data);\n+\t\t\tIXYData<Long, Number> data = it.next();\n+\t\t\tlong x = data.getX();\n@@ -203,2 +199,2 @@\n-\t\tAveragingSampleBuffer sampleBuffer, double boundary, IXYData beforeData, IXYData afterData, long worldWidth,\n-\t\tlong leftEdge) {\n+\t\tAveragingSampleBuffer sampleBuffer, double boundary, IXYData<Long, Number> beforeData,\n+\t\tIXYData<Long, Number> afterData, long worldWidth, long leftEdge) {\n@@ -207,2 +203,2 @@\n-\t\tdouble y1 = getY(beforeData);\n-\t\tdouble y2 = getY(afterData);\n+\t\tdouble y1 = beforeData.getY().doubleValue();\n+\t\tdouble y2 = afterData.getY().doubleValue();\n@@ -214,5 +210,2 @@\n-\tprivate double getY(IXYData data) {\n-\t\treturn ((Number) data.getY()).doubleValue();\n-\t}\n-\n-\tprivate void addXYDataPoint(AveragingSampleBuffer sampleBuffer, long worldWidth, long leftEdge, IXYData data) {\n+\tprivate void addXYDataPoint(\n+\t\tAveragingSampleBuffer sampleBuffer, long worldWidth, long leftEdge, IXYData<Long, Number> data) {\n@@ -224,2 +217,2 @@\n-\tprivate double getNormalizedX(IXYData data, long worldWidth, long leftEdge) {\n-\t\treturn ((double) (getXAsLong(data) - leftEdge)) \/ ((double) worldWidth);\n+\tprivate double getNormalizedX(IXYData<Long, Number> data, long worldWidth, long leftEdge) {\n+\t\treturn ((double) (data.getX() - leftEdge)) \/ ((double) worldWidth);\n@@ -229,1 +222,1 @@\n-\tpublic DataSeries getDataSeries() {\n+\tpublic DataSeries<IXYData<Long, Number>> getDataSeries() {\n","filename":"application\/org.openjdk.jmc.greychart\/src\/main\/java\/org\/openjdk\/jmc\/greychart\/providers\/AveragingProvider.java","additions":25,"deletions":32,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import org.openjdk.jmc.common.xydata.IXYData;\n@@ -98,1 +99,1 @@\n-\tpublic DataSeries getDataSeries() {\n+\tpublic DataSeries<IXYData<Long, Number>> getDataSeries() {\n@@ -162,0 +163,48 @@\n+\t@Override\n+\tpublic long getDataMinX() {\n+\t\tlong min = Long.MAX_VALUE;\n+\t\tfor (OptimizingProvider provider : providers) {\n+\t\t\tlong dataMinX = provider.getDataMinX();\n+\t\t\tif (dataMinX != Long.MAX_VALUE) {\n+\t\t\t\tmin = Math.min(dataMinX, min);\n+\t\t\t}\n+\t\t}\n+\t\treturn min;\n+\t}\n+\n+\t@Override\n+\tpublic long getDataMaxX() {\n+\t\tlong max = Long.MIN_VALUE;\n+\t\tfor (OptimizingProvider provider : providers) {\n+\t\t\tlong dataMaxX = provider.getDataMaxX();\n+\t\t\tif (dataMaxX != Long.MIN_VALUE) {\n+\t\t\t\tmax = Math.max(dataMaxX, max);\n+\t\t\t}\n+\t\t}\n+\t\treturn max;\n+\t}\n+\n+\t@Override\n+\tpublic double getDataMinY() {\n+\t\tdouble min = Double.POSITIVE_INFINITY;\n+\t\tfor (OptimizingProvider provider : providers) {\n+\t\t\tdouble dataMinY = provider.getDataMinY();\n+\t\t\tif (!Double.isNaN(dataMinY)) {\n+\t\t\t\tmin = Math.min(dataMinY, min);\n+\t\t\t}\n+\t\t}\n+\t\treturn min;\n+\t}\n+\n+\t@Override\n+\tpublic double getDataMaxY() {\n+\t\tdouble max = Double.NEGATIVE_INFINITY;\n+\t\tfor (OptimizingProvider provider : providers) {\n+\t\t\tdouble dataMaxY = provider.getDataMaxY();\n+\t\t\tif (!Double.isNaN(dataMaxY)) {\n+\t\t\t\tmax = Math.max(dataMaxY, max);\n+\t\t\t}\n+\t\t}\n+\t\treturn max;\n+\t}\n+\n","filename":"application\/org.openjdk.jmc.greychart\/src\/main\/java\/org\/openjdk\/jmc\/greychart\/providers\/CompositeOptimizingProvider.java","additions":50,"deletions":1,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-\n+import org.openjdk.jmc.common.xydata.IXYData;\n@@ -52,2 +52,1 @@\n-\n-public class IntermediateStackingProvider implements OptimizingProvider {\n+public class IntermediateStackingProvider extends AbstractOptimizingProvider {\n@@ -217,1 +216,1 @@\n-\tpublic DataSeries getDataSeries() {\n+\tpublic DataSeries<IXYData<Long, Number>> getDataSeries() {\n","filename":"application\/org.openjdk.jmc.greychart\/src\/main\/java\/org\/openjdk\/jmc\/greychart\/providers\/IntermediateStackingProvider.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -54,3 +54,2 @@\n-\n-public class SampleCountingProvider implements OptimizingProvider {\n-\tprivate final DataSeries<IXYData> m_dataSeries;\n+public class SampleCountingProvider extends AbstractOptimizingProvider {\n+\tprivate final DataSeries<IXYData<Long, Number>> m_dataSeries;\n@@ -72,2 +71,2 @@\n-\tpublic SampleCountingProvider(DataSeries<IXYData> s, double yMultiplier, XAxis xAxis, CancelService cancelService,\n-\t\t\tboolean integrate) {\n+\tpublic SampleCountingProvider(DataSeries<IXYData<Long, Number>> s, double yMultiplier, XAxis xAxis,\n+\t\t\tCancelService cancelService, boolean integrate) {\n@@ -163,1 +162,1 @@\n-\t\tIterator<IXYData> it = m_dataSeries.createIterator(m_requestedStartX, m_requestedEndX);\n+\t\tIterator<IXYData<Long, Number>> it = m_dataSeries.createIterator(m_requestedStartX, m_requestedEndX);\n@@ -171,1 +170,1 @@\n-\t\tIXYData data = findFirstPoint(sampleBuffer, it, worldWidth, leftEdge);\n+\t\tIXYData<Long, Number> data = findFirstPoint(sampleBuffer, it, worldWidth, leftEdge);\n@@ -173,1 +172,1 @@\n-\t\tlong x = getXAsLong(data);\n+\t\tlong x = data.getX();\n@@ -180,1 +179,1 @@\n-\t\t\tx = getXAsLong(data);\n+\t\t\tx = data.getX();\n@@ -193,3 +192,4 @@\n-\tprivate void addLeftEdgeCrossingValue(AbstractSampler sampleBuffer, long worldWidth, long leftEdge, IXYData data) {\n-\t\tlong x = getXAsLong(data);\n-\t\tlong y = getYAsLong(data);\n+\tprivate void addLeftEdgeCrossingValue(\n+\t\tAbstractSampler sampleBuffer, long worldWidth, long leftEdge, IXYData<Long, Number> data) {\n+\t\tlong x = data.getX();\n+\t\tlong y = data.getY().longValue();\n@@ -202,10 +202,3 @@\n-\tprivate long getXAsLong(IXYData data) {\n-\t\treturn ((Number) data.getX()).longValue();\n-\t}\n-\n-\tprivate long getYAsLong(IXYData data) {\n-\t\treturn ((Number) data.getY()).longValue();\n-\t}\n-\n-\tprivate IXYData findFirstPoint(AbstractSampler sampleBuffer, Iterator<IXYData> it, long worldWidth, long leftEdge) {\n-\t\tIXYData firstDataPoint = null;\n+\tprivate IXYData<Long, Number> findFirstPoint(\n+\t\tAbstractSampler sampleBuffer, Iterator<IXYData<Long, Number>> it, long worldWidth, long leftEdge) {\n+\t\tIXYData<Long, Number> firstDataPoint = null;\n@@ -214,1 +207,1 @@\n-\t\t\tlong x = getXAsLong(firstDataPoint);\n+\t\t\tlong x = firstDataPoint.getX();\n@@ -222,2 +215,2 @@\n-\t\t\tIXYData data = it.next();\n-\t\t\tlong x = getXAsLong(data);\n+\t\t\tIXYData<Long, Number> data = it.next();\n+\t\t\tlong x = data.getX();\n@@ -237,1 +230,2 @@\n-\tprivate void addXYDataPoint(AbstractSampler sampleBuffer, long worldWidth, long leftEdge, IXYData data) {\n+\tprivate void addXYDataPoint(\n+\t\tAbstractSampler sampleBuffer, long worldWidth, long leftEdge, IXYData<Long, Number> data) {\n@@ -245,3 +239,4 @@\n-\tprivate void addNormalXYDataPoint(SampleCountingBuffer sampleBuffer, long worldWidth, long leftEdge, IXYData data) {\n-\t\tdouble n = getNormalizedX(getXAsLong(data), worldWidth, leftEdge);\n-\t\tdouble y = ((Number) data.getY()).doubleValue();\n+\tprivate void addNormalXYDataPoint(\n+\t\tSampleCountingBuffer sampleBuffer, long worldWidth, long leftEdge, IXYData<Long, Number> data) {\n+\t\tdouble n = getNormalizedX(data.getX(), worldWidth, leftEdge);\n+\t\tdouble y = data.getY().doubleValue();\n@@ -259,2 +254,3 @@\n-\t\tIntegratingSampleCountingBuffer sampleBuffer, long worldWidth, long leftEdge, IXYData data) {\n-\t\taddIntegratedValue(sampleBuffer, worldWidth, leftEdge, getXAsLong(data), getYAsLong(data), getYAsLong(data));\n+\t\tIntegratingSampleCountingBuffer sampleBuffer, long worldWidth, long leftEdge, IXYData<Long, Number> data) {\n+\t\taddIntegratedValue(sampleBuffer, worldWidth, leftEdge, data.getX(), data.getY().longValue(),\n+\t\t\t\tdata.getY().longValue());\n@@ -268,1 +264,1 @@\n-\tpublic DataSeries getDataSeries() {\n+\tpublic DataSeries<IXYData<Long, Number>> getDataSeries() {\n","filename":"application\/org.openjdk.jmc.greychart\/src\/main\/java\/org\/openjdk\/jmc\/greychart\/providers\/SampleCountingProvider.java","additions":28,"deletions":32,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -59,2 +59,2 @@\n-public final class SubsamplingProvider implements OptimizingProvider {\n-\tprivate final DataSeries<IXYData> m_dataSeries;\n+public final class SubsamplingProvider extends AbstractOptimizingProvider {\n+\tprivate final DataSeries<IXYData<Long, Number>> m_dataSeries;\n@@ -74,2 +74,2 @@\n-\tpublic SubsamplingProvider(DataSeries<IXYData> s, double yMultiplier, XAxis xAxis, CancelService cancelService,\n-\t\t\tboolean integrate) {\n+\tpublic SubsamplingProvider(DataSeries<IXYData<Long, Number>> s, double yMultiplier, XAxis xAxis,\n+\t\t\tCancelService cancelService, boolean integrate) {\n@@ -104,0 +104,1 @@\n+\t\tsuper.setDataChanged(changed);\n@@ -195,1 +196,1 @@\n-\t\tIterator<IXYData> it = m_dataSeries.createIterator(m_requestedStartX, m_requestedEndX);\n+\t\tIterator<IXYData<Long, Number>> it = m_dataSeries.createIterator(m_requestedStartX, m_requestedEndX);\n@@ -206,4 +207,4 @@\n-\t\tIXYData leftMost = null;\n-\t\tIXYData rightMost = null;\n-\t\tIXYData rightMostWithin = null;\n-\t\tIXYData leftMostWithin = null;\n+\t\tIXYData<Long, Number> leftMost = null;\n+\t\tIXYData<Long, Number> rightMost = null;\n+\t\tIXYData<Long, Number> rightMostWithin = null;\n+\t\tIXYData<Long, Number> leftMostWithin = null;\n@@ -212,3 +213,3 @@\n-\t\t\tIXYData newData = it.next();\n-\t\t\tlong x = getXAsLong(newData);\n-\t\t\tif (x < leftEdge && (leftMost == null || x >= getXAsLong(leftMost))) {\n+\t\t\tIXYData<Long, Number> newData = it.next();\n+\t\t\tlong x = newData.getX();\n+\t\t\tif (x < leftEdge && (leftMost == null || x >= leftMost.getX())) {\n@@ -216,1 +217,1 @@\n-\t\t\t} else if (x > rightEdge && (rightMost == null || x < getXAsLong(rightMost))) {\n+\t\t\t} else if (x > rightEdge && (rightMost == null || x < rightMost.getX())) {\n@@ -225,1 +226,1 @@\n-\t\t\t\t\tif (getXAsLong(leftMostWithin) > x) {\n+\t\t\t\t\tif (leftMostWithin.getX() > x) {\n@@ -227,1 +228,1 @@\n-\t\t\t\t\t} else if (getXAsLong(rightMostWithin) <= x) {\n+\t\t\t\t\t} else if (rightMostWithin.getX() <= x) {\n@@ -241,2 +242,2 @@\n-\t\t\tif (leftMost != null && leftMostWithin != null && getXAsLong(leftMostWithin) != leftEdge\n-\t\t\t\t\t&& getXAsLong(leftMost) < leftEdge) {\n+\t\t\tif (leftMost != null && leftMostWithin != null && leftMostWithin.getX() != leftEdge\n+\t\t\t\t\t&& leftMost.getX() < leftEdge) {\n@@ -246,2 +247,2 @@\n-\t\t\tif (rightMost != null && rightMostWithin != null && getXAsLong(rightMostWithin) != rightEdge\n-\t\t\t\t\t&& getXAsLong(rightMost) > rightEdge) {\n+\t\t\tif (rightMost != null && rightMostWithin != null && rightMostWithin.getX() != rightEdge\n+\t\t\t\t\t&& rightMost.getX() > rightEdge) {\n@@ -255,8 +256,0 @@\n-\tprivate long getXAsLong(IXYData data) {\n-\t\treturn ((Number) data.getX()).longValue();\n-\t}\n-\n-\tprivate long getYAsLong(IXYData data) {\n-\t\treturn ((Number) data.getY()).longValue();\n-\t}\n-\n@@ -264,2 +257,2 @@\n-\t\tSubsamplingBuffer sampleBuffer, double boundary, IXYData beforeData, IXYData afterData, long worldWidth,\n-\t\tlong leftEdge) {\n+\t\tSubsamplingBuffer sampleBuffer, double boundary, IXYData<Long, Number> beforeData,\n+\t\tIXYData<Long, Number> afterData, long worldWidth, long leftEdge) {\n@@ -269,2 +262,2 @@\n-\t\tdouble y1 = getY(beforeData);\n-\t\tdouble y2 = getY(afterData);\n+\t\tdouble y1 = beforeData.getY().doubleValue();\n+\t\tdouble y2 = afterData.getY().doubleValue();\n@@ -276,5 +269,2 @@\n-\tprivate double getY(IXYData data) {\n-\t\treturn ((Number) data.getY()).doubleValue();\n-\t}\n-\n-\tprivate void addXYDataPoint(AbstractSampler sampleBuffer, long worldWidth, long leftEdge, IXYData data) {\n+\tprivate void addXYDataPoint(\n+\t\tAbstractSampler sampleBuffer, long worldWidth, long leftEdge, IXYData<Long, Number> data) {\n@@ -288,1 +278,2 @@\n-\tprivate void addNormalXYDataPoint(SubsamplingBuffer sampleBuffer, long worldWidth, long leftEdge, IXYData data) {\n+\tprivate void addNormalXYDataPoint(\n+\t\tSubsamplingBuffer sampleBuffer, long worldWidth, long leftEdge, IXYData<Long, Number> data) {\n@@ -290,1 +281,1 @@\n-\t\tdouble y = ((Number) data.getY()).doubleValue();\n+\t\tdouble y = data.getY().doubleValue();\n@@ -295,1 +286,1 @@\n-\t\tIntegratingSubsamplingBuffer sampleBuffer, long worldWidth, long leftEdge, long x, long y, long duration) {\n+\t\tIntegratingSubsamplingBuffer sampleBuffer, long worldWidth, long leftEdge, long x, double y, long duration) {\n@@ -302,2 +293,3 @@\n-\t\tIntegratingSubsamplingBuffer sampleBuffer, long worldWidth, long leftEdge, IXYData data) {\n-\t\taddIntegratedValue(sampleBuffer, worldWidth, leftEdge, getXAsLong(data), getYAsLong(data), getYAsLong(data));\n+\t\tIntegratingSubsamplingBuffer sampleBuffer, long worldWidth, long leftEdge, IXYData<Long, Number> data) {\n+\t\taddIntegratedValue(sampleBuffer, worldWidth, leftEdge, data.getX(), data.getY().longValue(),\n+\t\t\t\tdata.getY().longValue());\n@@ -306,2 +298,2 @@\n-\tprivate double getNormalizedX(IXYData data, long worldWidth, long leftEdge) {\n-\t\treturn ((double) (getXAsLong(data) - leftEdge)) \/ ((double) worldWidth);\n+\tprivate double getNormalizedX(IXYData<Long, Number> data, long worldWidth, long leftEdge) {\n+\t\treturn ((double) (data.getX() - leftEdge)) \/ ((double) worldWidth);\n@@ -315,1 +307,1 @@\n-\tpublic DataSeries getDataSeries() {\n+\tpublic DataSeries<IXYData<Long, Number>> getDataSeries() {\n@@ -366,0 +358,4 @@\n+\tprotected double transformY(IXYData<Long, Number> data) {\n+\t\treturn data.getY().doubleValue() * m_yMultiplier;\n+\t}\n+\n","filename":"application\/org.openjdk.jmc.greychart\/src\/main\/java\/org\/openjdk\/jmc\/greychart\/providers\/SubsamplingProvider.java","additions":40,"deletions":44,"binary":false,"changes":84,"status":"modified"}]}