{"files":[{"patch":"@@ -205,5 +205,0 @@\n-\t\t<dependency>\n-\t\t\t<groupId>org.openjdk.jmc<\/groupId>\n-\t\t\t<artifactId>org.openjdk.jmc.flightrecorder.configuration<\/artifactId>\n-\t\t\t<version>${project.version}<\/version>\n-\t\t<\/dependency>\n","filename":"application\/coverage\/pom.xml","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-\t\t\t\tSyntheticRepositoryInitializer.intializeAttributeEntries(),\n+\t\t\t\tSyntheticRepositoryInitializer.initializeAttributeEntries(),\n","filename":"application\/org.openjdk.jmc.rjmx\/src\/main\/java\/org\/openjdk\/jmc\/rjmx\/internal\/ServerHandle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-\tpublic static List<SyntheticAttributeEntry> intializeAttributeEntries() {\n+\tpublic static List<SyntheticAttributeEntry> initializeAttributeEntries() {\n","filename":"application\/org.openjdk.jmc.rjmx\/src\/main\/java\/org\/openjdk\/jmc\/rjmx\/internal\/SyntheticRepositoryInitializer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,3 +35,0 @@\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n@@ -47,1 +44,0 @@\n-import org.eclipse.osgi.util.NLS;\n@@ -50,4 +46,0 @@\n-import org.openjdk.jmc.rjmx.common.subscription.IMRIMetadata;\n-import org.openjdk.jmc.rjmx.common.subscription.IMRIMetadataProvider;\n-import org.openjdk.jmc.rjmx.common.subscription.IMRIMetadataService;\n-import org.openjdk.jmc.rjmx.common.subscription.IMRITransformation;\n@@ -55,1 +47,1 @@\n-import org.openjdk.jmc.rjmx.common.subscription.MRI;\n+import org.openjdk.jmc.rjmx.common.subscription.internal.MRITransformationBaseToolkit;\n@@ -62,11 +54,1 @@\n-public class MRITransformationToolkit {\n-\n-\tstatic final String TRANSFORMATION_EXTENSION_NAME = \"org.openjdk.jmc.rjmx.attributeTransformation\"; \/\/$NON-NLS-1$\n-\tstatic final String TRANSFORMATION_ELEMENT = \"attributeTransformation\"; \/\/$NON-NLS-1$\n-\tpublic static final String TRANSFORMATION_NAME_ATTRIBUTE = \"transformationName\"; \/\/$NON-NLS-1$\n-\tstatic final String TRANSFORMATION_PROPERTY_ELEMENT = \"property\"; \/\/$NON-NLS-1$\n-\tstatic final String TRANSFORMATION_PROPERTY_NAME = \"name\"; \/\/$NON-NLS-1$\n-\tstatic final String TRANSFORMATION_PROPERTY_VALUE = \"value\"; \/\/$NON-NLS-1$\n-\tstatic final String TRANSFORMATION_PROPERTIES_ELEMENT = \"transformationProperties\"; \/\/$NON-NLS-1$\n-\n-\tprivate static final Map<String, IMRITransformationFactory> TRANSFORMATION_FACTORIES = new HashMap<>();\n+public class MRITransformationToolkit extends MRITransformationBaseToolkit {\n@@ -121,61 +103,0 @@\n-\t\/**\n-\t * Creates a new transformation with given transformation MRI for given connection.\n-\t *\n-\t * @param mri\n-\t *            the transformation MRI\n-\t * @return the corresponding transformation object\n-\t *\/\n-\tpublic static IMRITransformation createTransformation(MRI mri) {\n-\t\tString transformationName = getTransformationName(mri);\n-\t\tif (TRANSFORMATION_FACTORIES.containsKey(transformationName)) {\n-\t\t\tProperties properties = createProperties(mri);\n-\t\t\treturn TRANSFORMATION_FACTORIES.get(transformationName).createTransformation(properties);\n-\t\t}\n-\t\tRJMXPlugin.getDefault().getLogger().log(Level.SEVERE,\n-\t\t\t\t\"Could not instantiate unknown transformation type \" + transformationName + \"!\"); \/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n-\t\treturn null;\n-\t}\n-\n-\t\/**\n-\t * Returns the different available transformation factories.\n-\t *\n-\t * @return the set of transformation factories\n-\t *\/\n-\tpublic static Iterable<IMRITransformationFactory> getFactories() {\n-\t\treturn Collections.unmodifiableCollection(TRANSFORMATION_FACTORIES.values());\n-\t}\n-\n-\tprivate static String getTransformationName(MRI mri) {\n-\t\tString path = mri.getDataPath();\n-\t\tint partitionIndex = path.indexOf('?');\n-\t\tif (partitionIndex >= 0) {\n-\t\t\treturn path.substring(0, partitionIndex);\n-\t\t}\n-\t\treturn path;\n-\t}\n-\n-\tprivate static Properties createProperties(MRI mri) {\n-\t\tProperties properties = new Properties();\n-\t\tString path = mri.getDataPath();\n-\t\tint partitionIndex = path.indexOf('?');\n-\t\tif (partitionIndex >= 0) {\n-\t\t\tpath = path.substring(partitionIndex + 1);\n-\t\t\tfor (String property : path.split(\"&\")) { \/\/$NON-NLS-1$\n-\t\t\t\tint equalIndex = property.indexOf('=');\n-\t\t\t\tproperties.put(property.substring(0, equalIndex), property.substring(equalIndex + 1));\n-\t\t\t}\n-\t\t}\n-\t\treturn properties;\n-\t}\n-\n-\tpublic static void forwardMetadata(\n-\t\tIMRIMetadataService metadataService, MRI mri, IMRIMetadata attributeMetadata, String textPattern) {\n-\t\tmetadataService.setMetadata(mri, IMRIMetadataProvider.KEY_DISPLAY_NAME,\n-\t\t\t\tNLS.bind(textPattern, attributeMetadata.getMetadata(IMRIMetadataProvider.KEY_DISPLAY_NAME)));\n-\t\tmetadataService.setMetadata(mri, IMRIMetadataProvider.KEY_DESCRIPTION,\n-\t\t\t\tNLS.bind(textPattern, attributeMetadata.getMetadata(IMRIMetadataProvider.KEY_DESCRIPTION)));\n-\t\tmetadataService.setMetadata(mri, IMRIMetadataProvider.KEY_UPDATE_TIME,\n-\t\t\t\t(String) attributeMetadata.getMetadata(IMRIMetadataProvider.KEY_UPDATE_TIME));\n-\t\tmetadataService.setMetadata(mri, IMRIMetadataProvider.KEY_UNIT_STRING,\n-\t\t\t\t(String) attributeMetadata.getMetadata(IMRIMetadataProvider.KEY_UNIT_STRING));\n-\t}\n","filename":"application\/org.openjdk.jmc.rjmx\/src\/main\/java\/org\/openjdk\/jmc\/rjmx\/subscription\/internal\/MRITransformationToolkit.java","additions":2,"deletions":81,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -183,1 +183,0 @@\n-\/\/\t\t\t\tnull, SyntheticRepositoryInitializer.intializeAttributeEntries(), SyntheticRepositoryInitializer.initializeNotificationEntries());\n@@ -290,1 +289,1 @@\n-\t\t\t\tnull, SyntheticRepositoryInitializer.intializeAttributeEntries(),\n+\t\t\t\tnull, SyntheticRepositoryInitializer.initializeAttributeEntries(),\n","filename":"application\/tests\/org.openjdk.jmc.rjmx.test\/src\/test\/java\/org\/openjdk\/jmc\/rjmx\/test\/RjmxTestCase.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -338,1 +338,1 @@\n-\t\t\tIMRITransformation transformation = MRITransformationToolkit.createTransformation(info.getMRI());\n+\t\t\tIMRITransformation transformation = MRITransformationBaseToolkit.createTransformation(info.getMRI());\n","filename":"core\/org.openjdk.jmc.rjmx.common\/src\/main\/java\/org\/openjdk\/jmc\/rjmx\/common\/subscription\/internal\/DefaultAttributeSubscriptionService.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-\t\tIMRITransformation transformation = MRITransformationToolkit.createTransformation(mri);\n+\t\tIMRITransformation transformation = MRITransformationBaseToolkit.createTransformation(mri);\n","filename":"core\/org.openjdk.jmc.rjmx.common\/src\/main\/java\/org\/openjdk\/jmc\/rjmx\/common\/subscription\/internal\/MBeanMRIMetadataDB.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.rjmx.common.subscription.internal;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.logging.Level;\n+\n+import org.openjdk.jmc.rjmx.common.RJMXCorePlugin;\n+import org.openjdk.jmc.rjmx.common.subscription.IMRIMetadata;\n+import org.openjdk.jmc.rjmx.common.subscription.IMRIMetadataProvider;\n+import org.openjdk.jmc.rjmx.common.subscription.IMRIMetadataService;\n+import org.openjdk.jmc.rjmx.common.subscription.IMRITransformation;\n+import org.openjdk.jmc.rjmx.common.subscription.IMRITransformationFactory;\n+import org.openjdk.jmc.rjmx.common.subscription.MRI;\n+\n+\/**\n+ * An MRI transformation toolkit responsible for creating transformations from MRI, finding\n+ * attributes they depend on, etc.\n+ *\/\n+public class MRITransformationBaseToolkit {\n+\n+\tprotected static final String TRANSFORMATION_EXTENSION_NAME = \"org.openjdk.jmc.rjmx.attributeTransformation\"; \/\/$NON-NLS-1$\n+\tprotected static final String TRANSFORMATION_ELEMENT = \"attributeTransformation\"; \/\/$NON-NLS-1$\n+\tpublic static final String TRANSFORMATION_NAME_ATTRIBUTE = \"transformationName\"; \/\/$NON-NLS-1$\n+\tprotected static final String TRANSFORMATION_PROPERTY_ELEMENT = \"property\"; \/\/$NON-NLS-1$\n+\tprotected static final String TRANSFORMATION_PROPERTY_NAME = \"name\"; \/\/$NON-NLS-1$\n+\tprotected static final String TRANSFORMATION_PROPERTY_VALUE = \"value\"; \/\/$NON-NLS-1$\n+\tprotected static final String TRANSFORMATION_PROPERTIES_ELEMENT = \"transformationProperties\"; \/\/$NON-NLS-1$\n+\n+\tprotected static final Map<String, IMRITransformationFactory> TRANSFORMATION_FACTORIES = new HashMap<>();\n+\n+\tpublic void initializeFromExtensions(Map<String, IMRITransformationFactory> transformationFactories) {\n+\t\tTRANSFORMATION_FACTORIES.clear();\n+\t\tfor (Map.Entry<String, IMRITransformationFactory> factory : transformationFactories.entrySet()) {\n+\t\t\tTRANSFORMATION_FACTORIES.put(factory.getKey(), factory.getValue());\n+\t\t}\n+\t}\n+\n+\tpublic static void addTransformationsFactory(\n+\t\tString transformationName, IMRITransformationFactory transformationFactory) {\n+\t\tTRANSFORMATION_FACTORIES.put(transformationName, transformationFactory);\n+\t}\n+\n+\t\/**\n+\t * Creates a new transformation with given transformation MRI for given connection.\n+\t *\n+\t * @param mri\n+\t *            the transformation MRI\n+\t * @return the corresponding transformation object\n+\t *\/\n+\tpublic static IMRITransformation createTransformation(MRI mri) {\n+\t\tString transformationName = getTransformationName(mri);\n+\t\tif (TRANSFORMATION_FACTORIES.containsKey(transformationName)) {\n+\t\t\tProperties properties = createProperties(mri);\n+\t\t\treturn TRANSFORMATION_FACTORIES.get(transformationName).createTransformation(properties);\n+\t\t}\n+\t\tRJMXCorePlugin.getDefault().getLogger().log(Level.SEVERE,\n+\t\t\t\t\"Could not instantiate unknown transformation type \" + transformationName + \"!\"); \/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n+\t\treturn null;\n+\t}\n+\n+\t\/**\n+\t * Returns the different available transformation factories.\n+\t *\n+\t * @return the set of transformation factories\n+\t *\/\n+\tpublic static Iterable<IMRITransformationFactory> getFactories() {\n+\t\treturn Collections.unmodifiableCollection(TRANSFORMATION_FACTORIES.values());\n+\t}\n+\n+\tprivate static String getTransformationName(MRI mri) {\n+\t\tString path = mri.getDataPath();\n+\t\tint partitionIndex = path.indexOf('?');\n+\t\tif (partitionIndex >= 0) {\n+\t\t\treturn path.substring(0, partitionIndex);\n+\t\t}\n+\t\treturn path;\n+\t}\n+\n+\tprivate static Properties createProperties(MRI mri) {\n+\t\tProperties properties = new Properties();\n+\t\tString path = mri.getDataPath();\n+\t\tint partitionIndex = path.indexOf('?');\n+\t\tif (partitionIndex >= 0) {\n+\t\t\tpath = path.substring(partitionIndex + 1);\n+\t\t\tfor (String property : path.split(\"&\")) { \/\/$NON-NLS-1$\n+\t\t\t\tint equalIndex = property.indexOf('=');\n+\t\t\t\tproperties.put(property.substring(0, equalIndex), property.substring(equalIndex + 1));\n+\t\t\t}\n+\t\t}\n+\t\treturn properties;\n+\t}\n+\n+\tpublic static void forwardMetadata(\n+\t\tIMRIMetadataService metadataService, MRI mri, IMRIMetadata attributeMetadata, String textPattern) {\n+\t\tmetadataService.setMetadata(mri, IMRIMetadataProvider.KEY_DISPLAY_NAME,\n+\t\t\t\tString.format(textPattern, attributeMetadata.getMetadata(IMRIMetadataProvider.KEY_DISPLAY_NAME)));\n+\t\tmetadataService.setMetadata(mri, IMRIMetadataProvider.KEY_DESCRIPTION,\n+\t\t\t\tString.format(textPattern, attributeMetadata.getMetadata(IMRIMetadataProvider.KEY_DESCRIPTION)));\n+\t\tmetadataService.setMetadata(mri, IMRIMetadataProvider.KEY_UPDATE_TIME,\n+\t\t\t\t(String) attributeMetadata.getMetadata(IMRIMetadataProvider.KEY_UPDATE_TIME));\n+\t\tmetadataService.setMetadata(mri, IMRIMetadataProvider.KEY_UNIT_STRING,\n+\t\t\t\t(String) attributeMetadata.getMetadata(IMRIMetadataProvider.KEY_UNIT_STRING));\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.rjmx.common\/src\/main\/java\/org\/openjdk\/jmc\/rjmx\/common\/subscription\/internal\/MRITransformationBaseToolkit.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -1,195 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * \n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * The contents of this file are subject to the terms of either the Universal Permissive License\n- * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n- *\n- * or the following license:\n- *\n- * Redistribution and use in source and binary forms, with or without modification, are permitted\n- * provided that the following conditions are met:\n- * \n- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n- * and the following disclaimer.\n- * \n- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n- * conditions and the following disclaimer in the documentation and\/or other materials provided with\n- * the distribution.\n- * \n- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n- * endorse or promote products derived from this software without specific prior written permission.\n- * \n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n- * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-package org.openjdk.jmc.rjmx.common.subscription.internal;\n-\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Properties;\n-import java.util.logging.Level;\n-\n-import org.openjdk.jmc.rjmx.common.RJMXCorePlugin;\n-import org.openjdk.jmc.rjmx.common.subscription.IMRIMetadata;\n-import org.openjdk.jmc.rjmx.common.subscription.IMRIMetadataProvider;\n-import org.openjdk.jmc.rjmx.common.subscription.IMRIMetadataService;\n-import org.openjdk.jmc.rjmx.common.subscription.IMRITransformation;\n-import org.openjdk.jmc.rjmx.common.subscription.IMRITransformationFactory;\n-import org.openjdk.jmc.rjmx.common.subscription.MRI;\n-\n-\/**\n- * An MRI transformation toolkit responsible for creating transformations from MRI, finding\n- * attributes they depend on, etc. Will read available transformation factories from the extension\n- * \"org.openjdk.jmc.rjmx.attributeTransformation\".\n- *\/\n-public class MRITransformationToolkit {\n-\n-\tstatic final String TRANSFORMATION_EXTENSION_NAME = \"org.openjdk.jmc.rjmx.attributeTransformation\"; \/\/$NON-NLS-1$\n-\tstatic final String TRANSFORMATION_ELEMENT = \"attributeTransformation\"; \/\/$NON-NLS-1$\n-\tpublic static final String TRANSFORMATION_NAME_ATTRIBUTE = \"transformationName\"; \/\/$NON-NLS-1$\n-\tstatic final String TRANSFORMATION_PROPERTY_ELEMENT = \"property\"; \/\/$NON-NLS-1$\n-\tstatic final String TRANSFORMATION_PROPERTY_NAME = \"name\"; \/\/$NON-NLS-1$\n-\tstatic final String TRANSFORMATION_PROPERTY_VALUE = \"value\"; \/\/$NON-NLS-1$\n-\tstatic final String TRANSFORMATION_PROPERTIES_ELEMENT = \"transformationProperties\"; \/\/$NON-NLS-1$\n-\n-\tprivate static final Map<String, IMRITransformationFactory> TRANSFORMATION_FACTORIES = new HashMap<>();\n-\n-\tprivate MRITransformationToolkit() {\n-\t\tthrow new AssertionError(\"Not to be instantiated!\"); \/\/$NON-NLS-1$\n-\t}\n-\n-\tstatic {\n-\t\tinitialize();\n-\t}\n-\n-\tprivate static void initialize() {\n-\t\tIMRITransformationFactory transformationFactory = new SingleMRITransformationFactory();\n-\t\tString transformationName = \"difference\";\n-\t\tProperties props = new Properties();\n-\t\tprops.put(\"visualizeLabel\", \"Visualize difference...\");\n-\t\tprops.put(\"transformationClass\", \"org.openjdk.jmc.rjmx.common.subscription.internal.DifferenceTransformation\");\n-\t\tProperties transProps = new Properties();\n-\t\ttransProps.put(\"displayName\", \"%s (difference)\");\n-\t\tprops.put(TRANSFORMATION_NAME_ATTRIBUTE, transformationName);\n-\t\ttransformationFactory.setFactoryProperties(props, transProps);\n-\t\tTRANSFORMATION_FACTORIES.put(transformationName, transformationFactory);\n-\n-\t\ttransformationFactory = new SingleMRITransformationFactory();\n-\t\ttransformationName = \"rate\";\n-\t\tprops = new Properties();\n-\t\tprops.put(\"visualizeLabel\", \"Visualize rate per second...\");\n-\t\tprops.put(\"transformationClass\", \"org.openjdk.jmc.rjmx.common.subscription.internal.DifferenceTransformation\");\n-\t\ttransProps = new Properties();\n-\t\ttransProps.put(\"displayName\", \"%s (rate per second)\");\n-\t\ttransProps.put(\"rate\", \"1000\");\n-\t\tprops.put(TRANSFORMATION_NAME_ATTRIBUTE, transformationName);\n-\t\ttransformationFactory.setFactoryProperties(props, transProps);\n-\t\tTRANSFORMATION_FACTORIES.put(transformationName, transformationFactory);\n-\n-\t\ttransformationFactory = new SingleMRITransformationFactory();\n-\t\ttransformationName = \"average\";\n-\t\tprops = new Properties();\n-\t\tprops.put(\"visualizeLabel\", \"Visualize average...\");\n-\t\tprops.put(\"transformationClass\", \"org.openjdk.jmc.rjmx.common.subscription.internal.AverageTransformation\");\n-\t\ttransProps = new Properties();\n-\t\ttransProps.put(\"terms\", \"30\");\n-\t\ttransProps.put(\"displayName\", \"%%s (average over %s samples)\");\n-\t\tprops.put(TRANSFORMATION_NAME_ATTRIBUTE, transformationName);\n-\t\ttransformationFactory.setFactoryProperties(props, transProps);\n-\t\tTRANSFORMATION_FACTORIES.put(transformationName, transformationFactory);\n-\n-\t\ttransformationFactory = new SingleMRITransformationFactory();\n-\t\ttransformationName = \"delta\";\n-\t\tprops = new Properties();\n-\t\tprops.put(\"visualizeLabel\", \"Visualize delta...\");\n-\t\tprops.put(\"transformationClass\", \"org.openjdk.jmc.rjmx.common.subscription.internal.DeltaTransformation\");\n-\t\ttransProps = new Properties();\n-\t\ttransProps.put(\"displayName\", \"%s (delta)\");\n-\t\tprops.put(TRANSFORMATION_NAME_ATTRIBUTE, transformationName);\n-\t\ttransformationFactory.setFactoryProperties(props, transProps);\n-\t\tTRANSFORMATION_FACTORIES.put(transformationName, transformationFactory);\n-\t}\n-\n-\tpublic void initializeFromExtensions(Map<String, IMRITransformationFactory> transformationFactories) {\n-\t\tTRANSFORMATION_FACTORIES.clear();\n-\t\tfor (Map.Entry<String, IMRITransformationFactory> factory : transformationFactories.entrySet()) {\n-\t\t\tTRANSFORMATION_FACTORIES.put(factory.getKey(), factory.getValue());\n-\t\t}\n-\t}\n-\n-\tpublic static void addTransformationsFactory(\n-\t\tString transformationName, IMRITransformationFactory transformationFactory) {\n-\t\tTRANSFORMATION_FACTORIES.put(transformationName, transformationFactory);\n-\t}\n-\n-\t\/**\n-\t * Creates a new transformation with given transformation MRI for given connection.\n-\t *\n-\t * @param mri\n-\t *            the transformation MRI\n-\t * @return the corresponding transformation object\n-\t *\/\n-\tpublic static IMRITransformation createTransformation(MRI mri) {\n-\t\tString transformationName = getTransformationName(mri);\n-\t\tif (TRANSFORMATION_FACTORIES.containsKey(transformationName)) {\n-\t\t\tProperties properties = createProperties(mri);\n-\t\t\treturn TRANSFORMATION_FACTORIES.get(transformationName).createTransformation(properties);\n-\t\t}\n-\t\tRJMXCorePlugin.getDefault().getLogger().log(Level.SEVERE,\n-\t\t\t\t\"Could not instantiate unknown transformation type \" + transformationName + \"!\"); \/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n-\t\treturn null;\n-\t}\n-\n-\t\/**\n-\t * Returns the different available transformation factories.\n-\t *\n-\t * @return the set of transformation factories\n-\t *\/\n-\tpublic static Iterable<IMRITransformationFactory> getFactories() {\n-\t\treturn Collections.unmodifiableCollection(TRANSFORMATION_FACTORIES.values());\n-\t}\n-\n-\tprivate static String getTransformationName(MRI mri) {\n-\t\tString path = mri.getDataPath();\n-\t\tint partitionIndex = path.indexOf('?');\n-\t\tif (partitionIndex >= 0) {\n-\t\t\treturn path.substring(0, partitionIndex);\n-\t\t}\n-\t\treturn path;\n-\t}\n-\n-\tprivate static Properties createProperties(MRI mri) {\n-\t\tProperties properties = new Properties();\n-\t\tString path = mri.getDataPath();\n-\t\tint partitionIndex = path.indexOf('?');\n-\t\tif (partitionIndex >= 0) {\n-\t\t\tpath = path.substring(partitionIndex + 1);\n-\t\t\tfor (String property : path.split(\"&\")) { \/\/$NON-NLS-1$\n-\t\t\t\tint equalIndex = property.indexOf('=');\n-\t\t\t\tproperties.put(property.substring(0, equalIndex), property.substring(equalIndex + 1));\n-\t\t\t}\n-\t\t}\n-\t\treturn properties;\n-\t}\n-\n-\tpublic static void forwardMetadata(\n-\t\tIMRIMetadataService metadataService, MRI mri, IMRIMetadata attributeMetadata, String textPattern) {\n-\t\tmetadataService.setMetadata(mri, IMRIMetadataProvider.KEY_DISPLAY_NAME,\n-\t\t\t\tString.format(textPattern, attributeMetadata.getMetadata(IMRIMetadataProvider.KEY_DISPLAY_NAME)));\n-\t\tmetadataService.setMetadata(mri, IMRIMetadataProvider.KEY_DESCRIPTION,\n-\t\t\t\tString.format(textPattern, attributeMetadata.getMetadata(IMRIMetadataProvider.KEY_DESCRIPTION)));\n-\t\tmetadataService.setMetadata(mri, IMRIMetadataProvider.KEY_UPDATE_TIME,\n-\t\t\t\t(String) attributeMetadata.getMetadata(IMRIMetadataProvider.KEY_UPDATE_TIME));\n-\t\tmetadataService.setMetadata(mri, IMRIMetadataProvider.KEY_UNIT_STRING,\n-\t\t\t\t(String) attributeMetadata.getMetadata(IMRIMetadataProvider.KEY_UNIT_STRING));\n-\t}\n-}\n","filename":"core\/org.openjdk.jmc.rjmx.common\/src\/main\/java\/org\/openjdk\/jmc\/rjmx\/common\/subscription\/internal\/MRITransformationToolkit.java","additions":0,"deletions":195,"binary":false,"changes":195,"status":"deleted"},{"patch":"@@ -92,1 +92,2 @@\n-\t\tString transformationName = m_properties.getProperty(MRITransformationToolkit.TRANSFORMATION_NAME_ATTRIBUTE);\n+\t\tString transformationName = m_properties\n+\t\t\t\t.getProperty(MRITransformationBaseToolkit.TRANSFORMATION_NAME_ATTRIBUTE);\n","filename":"core\/org.openjdk.jmc.rjmx.common\/src\/main\/java\/org\/openjdk\/jmc\/rjmx\/common\/subscription\/internal\/SingleMRITransformationFactory.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}