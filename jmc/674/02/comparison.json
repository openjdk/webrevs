{"files":[{"patch":"@@ -61,0 +61,1 @@\n+import org.openjdk.jmc.flightrecorder.JfrAttributes;\n@@ -76,0 +77,3 @@\n+import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator;\n+import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceFormatToolkit;\n+import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceFrame;\n@@ -111,0 +115,2 @@\n+\tpublic static final TypedResult<String> MOST_COMMON_ERROR_MESSAGE = new TypedResult<>(\"mostCommonErrorMessage\", \/\/$NON-NLS-1$\n+\t\t\t\"Most Common Error Message\", \"The most common error message.\", UnitLookup.PLAIN_TEXT, String.class);\n@@ -113,0 +119,4 @@\n+\tpublic static final TypedResult<String> MOST_COMMON_ERROR_STACKTRACE = new TypedResult<>(\n+\t\t\t\"mostCommonErrorStacktrace\", \/\/$NON-NLS-1$\n+\t\t\t\"Most Common Error Stack Trace\", \"The most common error stack trace frames.\", UnitLookup.PLAIN_TEXT,\n+\t\t\tString.class);\n@@ -116,1 +126,1 @@\n-\t\t\tMOST_COMMON_ERROR_COUNT);\n+\t\t\tMOST_COMMON_ERROR_COUNT, MOST_COMMON_ERROR_MESSAGE, MOST_COMMON_ERROR_STACKTRACE);\n@@ -170,0 +180,1 @@\n+\t\t\tResultBuilder resultBuilder = ResultBuilder.createFor(this, vp);\n@@ -176,1 +187,0 @@\n-\t\t\t\/\/ FIXME: List some frames of the most common stack trace\n@@ -180,1 +190,38 @@\n-\t\t\treturn ResultBuilder.createFor(this, vp).setSeverity(Severity.get(score))\n+\t\t\tif (mostCommonError != null) {\n+\t\t\t\tIItemCollection mostCommonErrorItems = errorItems\n+\t\t\t\t\t\t.apply(ItemFilters.equals(JdkAttributes.EXCEPTION_THROWNCLASS, mostCommonError));\n+\t\t\t\tIItemCollection itemsWithMessage = mostCommonErrorItems\n+\t\t\t\t\t\t.apply(ItemFilters.notEquals(JdkAttributes.EXCEPTION_MESSAGE, null));\n+\t\t\t\tif (itemsWithMessage.hasItems()) {\n+\t\t\t\t\tList<IntEntry<String>> mostCommonErrorMessageGrouping = RulesToolkit\n+\t\t\t\t\t\t\t.calculateGroupingScore(itemsWithMessage, JdkAttributes.EXCEPTION_MESSAGE);\n+\t\t\t\t\tString mostCommonErrorMessage = mostCommonErrorMessageGrouping\n+\t\t\t\t\t\t\t.get(mostCommonErrorMessageGrouping.size() - 1).getKey();\n+\t\t\t\t\tlongMessage += \"\\n\" + Messages.getString(Messages.ErrorRule_TEXT_WARN_MOST_COMMON_ERROR_MESSAGE);\n+\t\t\t\t\tresultBuilder.addResult(MOST_COMMON_ERROR_MESSAGE, mostCommonErrorMessage);\n+\t\t\t\t}\n+\t\t\t\tIItemCollection itemsWithStackTrace = mostCommonErrorItems\n+\t\t\t\t\t\t.apply(ItemFilters.notEquals(JfrAttributes.EVENT_STACKTRACE, null));\n+\t\t\t\tif (itemsWithStackTrace.hasItems()) {\n+\t\t\t\t\tList<StacktraceFrame> mostCommonErrorStacktraceFrames = RulesToolkit\n+\t\t\t\t\t\t\t.getTopNFramesInMostCommonTrace(itemsWithStackTrace, 10);\n+\t\t\t\t\tList<String> formattedFrames = new ArrayList<>(mostCommonErrorStacktraceFrames.size());\n+\t\t\t\t\t\/*\n+\t\t\t\t\t * FIXME: Consider defining the method formatting based on preferences.\n+\t\t\t\t\t *\n+\t\t\t\t\t * Currently it's a compromise between keeping the length short, but still being\n+\t\t\t\t\t * able to identify the actual method, even if the line number is a bit\n+\t\t\t\t\t * incorrect.\n+\t\t\t\t\t *\/\n+\t\t\t\t\tFrameSeparator sep = new FrameSeparator(FrameSeparator.FrameCategorization.LINE, false);\n+\t\t\t\t\tfor (int i = 0; i < mostCommonErrorStacktraceFrames.size(); i++) {\n+\t\t\t\t\t\tformattedFrames.add(\n+\t\t\t\t\t\t\t\tStacktraceFormatToolkit.formatFrame(mostCommonErrorStacktraceFrames.get(i).getFrame(),\n+\t\t\t\t\t\t\t\t\t\tsep, false, false, true, true, true, false));\n+\t\t\t\t\t}\n+\t\t\t\t\tString mostCommonErrorStacktraceFormattedFrames = String.join(\"\\n\", formattedFrames);\n+\t\t\t\t\tlongMessage += \"\\n\" + Messages.getString(Messages.ErrorRule_TEXT_WARN_MOST_COMMON_ERROR_STACKTRACE);\n+\t\t\t\t\tresultBuilder.addResult(MOST_COMMON_ERROR_STACKTRACE, mostCommonErrorStacktraceFormattedFrames);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn resultBuilder.setSeverity(Severity.get(score))\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/exceptions\/ErrorRule.java","additions":50,"deletions":3,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.ArrayList;\n@@ -46,0 +47,2 @@\n+import org.openjdk.jmc.common.IMCType;\n+import org.openjdk.jmc.common.collection.MapToolkit.IntEntry;\n@@ -47,0 +50,1 @@\n+import org.openjdk.jmc.common.item.ItemFilters;\n@@ -71,0 +75,3 @@\n+import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator;\n+import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceFormatToolkit;\n+import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceFrame;\n@@ -95,0 +102,8 @@\n+\tpublic static final TypedResult<IMCType> MOST_COMMON_EXCEPTION = new TypedResult<>(\"mostCommonException\", \/\/$NON-NLS-1$\n+\t\t\t\"Most Common Exception\", \"The most common exception thrown.\", UnitLookup.CLASS, IMCType.class);\n+\tpublic static final TypedResult<String> MOST_COMMON_EXCEPTION_MESSAGE = new TypedResult<>(\n+\t\t\t\"mostCommonExceptionMessage\", \/\/$NON-NLS-1$\n+\t\t\t\"Most Common Exception Message\", \"The most common exception message.\", UnitLookup.PLAIN_TEXT, String.class);\n+\tpublic static final TypedResult<String> MOST_COMMON_EXCEPTION_STACKTRACE = new TypedResult<>(\n+\t\t\t\"mostCommonExceptionStacktrace\", \"Most Common Exception Stack Trace\", \/\/$NON-NLS-1$\n+\t\t\t\"The most common exception stack trace frames.\", UnitLookup.PLAIN_TEXT, String.class);\n@@ -96,2 +111,3 @@\n-\tprivate static final Collection<TypedResult<?>> RESULT_ATTRIBUTES = Arrays\n-\t\t\t.<TypedResult<?>> asList(TypedResult.SCORE, EXCEPTION_RATE, EXCEPTION_WINDOW);\n+\tprivate static final Collection<TypedResult<?>> RESULT_ATTRIBUTES = Arrays.<TypedResult<?>> asList(\n+\t\t\tTypedResult.SCORE, EXCEPTION_RATE, EXCEPTION_WINDOW, MOST_COMMON_EXCEPTION, MOST_COMMON_EXCEPTION_MESSAGE,\n+\t\t\tMOST_COMMON_EXCEPTION_STACKTRACE);\n@@ -113,3 +129,55 @@\n-\t\t\treturn ResultBuilder.createFor(this, vp).setSeverity(Severity.get(score))\n-\t\t\t\t\t.setSummary(Messages.getString(Messages.ExceptionRule_TEXT_MESSAGE))\n-\t\t\t\t\t.setExplanation(Messages.getString(Messages.ExceptionRule_TEXT_INFO_LONG))\n+\t\t\tResultBuilder resultBuilder = ResultBuilder.createFor(this, vp);\n+\t\t\tString explanation = Messages.getString(Messages.ExceptionRule_TEXT_INFO_LONG);\n+\t\t\tEventAvailability exceptionsThrownEventAvailability = RulesToolkit.getEventAvailability(items,\n+\t\t\t\t\tJdkTypeIDs.EXCEPTIONS_THROWN);\n+\t\t\tif (exceptionsThrownEventAvailability == EventAvailability.AVAILABLE) {\n+\t\t\t\tIItemCollection exceptionItems = items.apply(JdkFilters.EXCEPTIONS);\n+\t\t\t\tList<IntEntry<IMCType>> exceptionGrouping = RulesToolkit.calculateGroupingScore(exceptionItems,\n+\t\t\t\t\t\tJdkAttributes.EXCEPTION_THROWNCLASS);\n+\t\t\t\tIMCType mostCommonException = exceptionGrouping.get(exceptionGrouping.size() - 1).getKey();\n+\t\t\t\texplanation = Messages.getString(Messages.ExceptionRule_TEXT_MOST_COMMON_EXCEPTION) + explanation;\n+\t\t\t\tresultBuilder.addResult(MOST_COMMON_EXCEPTION, mostCommonException);\n+\t\t\t\tif (mostCommonException != null) {\n+\t\t\t\t\tIItemCollection mostCommonExceptionItems = exceptionItems\n+\t\t\t\t\t\t\t.apply(ItemFilters.equals(JdkAttributes.EXCEPTION_THROWNCLASS, mostCommonException));\n+\t\t\t\t\tIItemCollection itemsWithMessage = mostCommonExceptionItems\n+\t\t\t\t\t\t\t.apply(ItemFilters.notEquals(JdkAttributes.EXCEPTION_MESSAGE, null));\n+\t\t\t\t\tif (itemsWithMessage.hasItems()) {\n+\t\t\t\t\t\tList<IntEntry<String>> mostCommonExceptionMessageGrouping = RulesToolkit\n+\t\t\t\t\t\t\t\t.calculateGroupingScore(itemsWithMessage, JdkAttributes.EXCEPTION_MESSAGE);\n+\t\t\t\t\t\tString mostCommonExceptionMessage = mostCommonExceptionMessageGrouping\n+\t\t\t\t\t\t\t\t.get(mostCommonExceptionMessageGrouping.size() - 1).getKey();\n+\t\t\t\t\t\texplanation += \"\\n\"\n+\t\t\t\t\t\t\t\t+ Messages.getString(Messages.ExceptionRule_TEXT_MOST_COMMON_EXCEPTION_MESSAGE);\n+\t\t\t\t\t\tresultBuilder.addResult(MOST_COMMON_EXCEPTION_MESSAGE, mostCommonExceptionMessage);\n+\t\t\t\t\t}\n+\t\t\t\t\tIItemCollection itemsWithStackTrace = mostCommonExceptionItems\n+\t\t\t\t\t\t\t.apply(ItemFilters.notEquals(JfrAttributes.EVENT_STACKTRACE, null));\n+\t\t\t\t\tif (itemsWithStackTrace.hasItems()) {\n+\t\t\t\t\t\tList<StacktraceFrame> mostCommonExceptionStacktraceFrames = RulesToolkit\n+\t\t\t\t\t\t\t\t.getTopNFramesInMostCommonTrace(itemsWithStackTrace, 10);\n+\t\t\t\t\t\tList<String> formattedFrames = new ArrayList<String>(\n+\t\t\t\t\t\t\t\tmostCommonExceptionStacktraceFrames.size());\n+\t\t\t\t\t\t\/*\n+\t\t\t\t\t\t * FIXME: Consider defining the method formatting based on preferences.\n+\t\t\t\t\t\t *\n+\t\t\t\t\t\t * Currently it's a compromise between keeping the length short, but still\n+\t\t\t\t\t\t * being able to identify the actual method, even if the line number is a\n+\t\t\t\t\t\t * bit incorrect.\n+\t\t\t\t\t\t *\/\n+\t\t\t\t\t\tFrameSeparator sep = new FrameSeparator(FrameSeparator.FrameCategorization.LINE, false);\n+\t\t\t\t\t\tfor (int i = 0; i < mostCommonExceptionStacktraceFrames.size(); i++) {\n+\t\t\t\t\t\t\tformattedFrames.add(StacktraceFormatToolkit.formatFrame(\n+\t\t\t\t\t\t\t\t\tmostCommonExceptionStacktraceFrames.get(i).getFrame(), sep, false, false, true,\n+\t\t\t\t\t\t\t\t\ttrue, true, false));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tString mostCommonExceptionStacktraceFormattedFrames = String.join(\"\\n\", formattedFrames);\n+\t\t\t\t\t\texplanation += \"\\n\"\n+\t\t\t\t\t\t\t\t+ Messages.getString(Messages.ExceptionRule_TEXT_MOST_COMMON_EXCEPTION_STACKTRACE);\n+\t\t\t\t\t\tresultBuilder.addResult(MOST_COMMON_EXCEPTION_STACKTRACE,\n+\t\t\t\t\t\t\t\tmostCommonExceptionStacktraceFormattedFrames);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn resultBuilder.setSeverity(Severity.get(score))\n+\t\t\t\t\t.setSummary(Messages.getString(Messages.ExceptionRule_TEXT_MESSAGE)).setExplanation(explanation)\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/exceptions\/ExceptionRule.java","additions":73,"deletions":5,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.util.stream.StreamSupport;\n@@ -51,0 +52,1 @@\n+import org.openjdk.jmc.common.item.ItemCollectionToolkit;\n@@ -72,1 +74,0 @@\n-import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceModel.Branch;\n@@ -197,10 +198,4 @@\n-\t\t\t\t\tStacktraceFrame secondFrame = null;\n-\t\t\t\t\tBranch firstBranch = stacktraceFrame.getBranch();\n-\t\t\t\t\tif (firstBranch.getTailFrames().length > 0) {\n-\t\t\t\t\t\tsecondFrame = firstBranch.getTailFrames()[0];\n-\t\t\t\t\t} else if (firstBranch.getEndFork().getBranchCount() > 0) {\n-\t\t\t\t\t\tsecondFrame = firstBranch.getEndFork().getBranch(0).getFirstFrame();\n-\t\t\t\t\t}\n-\t\t\t\t\tif (secondFrame != null) {\n-\t\t\t\t\t\tsecondFrameFromMostAllocated = secondFrame.getFrame();\n-\t\t\t\t\t}\n+\t\t\t\t\tIItemCollection itemsFromMostAllocate = ItemCollectionToolkit\n+\t\t\t\t\t\t\t.build(StreamSupport.stream(itemArray.spliterator(), false));\n+\t\t\t\t\tsecondFrameFromMostAllocated = RulesToolkit.getTopNFramesInMostCommonTrace(itemsFromMostAllocate, 2)\n+\t\t\t\t\t\t\t.get(1).getFrame();\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/memory\/AutoBoxingRule.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -234,0 +234,2 @@\n+\tpublic static final String ErrorRule_TEXT_WARN_MOST_COMMON_ERROR_MESSAGE = \"ErrorRule_TEXT_WARN_MOST_COMMON_ERROR_MESSAGE\"; \/\/$NON-NLS-1$\n+\tpublic static final String ErrorRule_TEXT_WARN_MOST_COMMON_ERROR_STACKTRACE = \"ErrorRule_TEXT_WARN_MOST_COMMON_ERROR_STACKTRACE\"; \/\/$NON-NLS-1$\n@@ -240,0 +242,3 @@\n+\tpublic static final String ExceptionRule_TEXT_MOST_COMMON_EXCEPTION = \"ExceptionRule_TEXT_MOST_COMMON_EXCEPTION\"; \/\/$NON-NLS-1$\n+\tpublic static final String ExceptionRule_TEXT_MOST_COMMON_EXCEPTION_MESSAGE = \"ExceptionRule_TEXT_MOST_COMMON_EXCEPTION_MESSAGE\"; \/\/$NON-NLS-1$\n+\tpublic static final String ExceptionRule_TEXT_MOST_COMMON_EXCEPTION_STACKTRACE = \"ExceptionRule_TEXT_MOST_COMMON_EXCEPTION_STACKTRACE\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/Messages.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -235,0 +235,4 @@\n+# {mostCommonErrorMessage} is a string.\n+ErrorRule_TEXT_WARN_MOST_COMMON_ERROR_MESSAGE=The most common error message was: \\n {mostCommonErrorMessage}\n+# {mostCommonErrorStacktrace} is a string.\n+ErrorRule_TEXT_WARN_MOST_COMMON_ERROR_STACKTRACE=The most common error stack trace was: \\n {mostCommonErrorStacktrace}\n@@ -240,0 +244,2 @@\n+# {mostCommonException} is an exception class name\n+ExceptionRule_TEXT_MOST_COMMON_EXCEPTION=The most common exception was ''{mostCommonException}''.\n@@ -243,0 +249,4 @@\n+#{mostCommonExceptionMessage} is a string\n+ExceptionRule_TEXT_MOST_COMMON_EXCEPTION_MESSAGE=The most common exception message was: \\n {mostCommonExceptionMessage}\n+#{mostCommonExceptionStacktrace} is a string.\n+ExceptionRule_TEXT_MOST_COMMON_EXCEPTION_STACKTRACE=The most common exception stack trace was: \\n {mostCommonExceptionStacktrace}\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/messages.properties","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import org.openjdk.jmc.common.IMCFrame;\n@@ -1443,1 +1444,38 @@\n-\t * Gets the second frame in the most common stack trace. Useful when showing what called a\n+\t * Returns up to {@code n} frames from the single most frequent branch in the aggregated stack\n+\t * traces for the provided {@code items}.\n+\t * <p>\n+\t * The result starts at the frame where the event(s) occurred and includes successive caller\n+\t * frames, up to the requested number. This is useful to see the most frequent path leading to\n+\t * an interesting method, such as {@code java.lang.Integer.valueOf} (autoboxing).\n+\t *\n+\t * @param items\n+\t *            the events for which to aggregate stack traces\n+\t * @param n\n+\t *            the maximum number of frames to return\n+\t * @return a List of {@code n} frames, starting at the event site and moving toward the callers\n+\t *\/\n+\tpublic static List<StacktraceFrame> getTopNFramesInMostCommonTrace(IItemCollection items, int n) {\n+\t\tFrameSeparator sep = new FrameSeparator(FrameSeparator.FrameCategorization.LINE, false);\n+\t\tStacktraceModel stacktraceModel = new StacktraceModel(false, sep, items);\n+\t\tBranch currentBranch = stacktraceModel.getRootFork().getBranch(0);\n+\t\tList<StacktraceFrame> frames = new ArrayList<>();\n+\t\twhile (currentBranch != null && frames.size() < n) {\n+\t\t\tframes.add(currentBranch.getFirstFrame());\n+\t\t\tfor (StacktraceFrame tf : currentBranch.getTailFrames()) {\n+\t\t\t\tif (frames.size() == n)\n+\t\t\t\t\tbreak;\n+\t\t\t\tframes.add(tf);\n+\t\t\t}\n+\t\t\tif (frames.size() == n)\n+\t\t\t\tbreak;\n+\t\t\tif (currentBranch.getEndFork().getBranchCount() > 0) {\n+\t\t\t\tcurrentBranch = currentBranch.getEndFork().getBranch(0);\n+\t\t\t} else {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\treturn frames;\n+\t}\n+\n+\t\/**\n+\t * Gets the second frame in the most common stack trace. Useful when showing what called an\n@@ -1449,0 +1487,1 @@\n+\t * @deprecated Use {@link #getTopNFramesInMostCommonTrace(IItemCollection, int)} instead.\n@@ -1450,1 +1489,0 @@\n-\t\/\/ FIXME: Generalize this a bit, get the top N frames\n@@ -1452,9 +1490,2 @@\n-\t\tFrameSeparator sep = new FrameSeparator(FrameSeparator.FrameCategorization.LINE, false);\n-\t\tStacktraceModel stacktraceModel = new StacktraceModel(false, sep, items);\n-\t\tBranch firstBranch = stacktraceModel.getRootFork().getBranch(0);\n-\t\tStacktraceFrame secondFrame = null;\n-\t\tif (firstBranch.getTailFrames().length > 0) {\n-\t\t\tsecondFrame = firstBranch.getTailFrames()[0];\n-\t\t} else if (firstBranch.getEndFork().getBranchCount() > 0) {\n-\t\t\tsecondFrame = firstBranch.getEndFork().getBranch(0).getFirstFrame();\n-\t\t} else {\n+\t\tList<StacktraceFrame> frames = getTopNFramesInMostCommonTrace(items, 2);\n+\t\tif (frames.size() < 2) {\n@@ -1463,0 +1494,2 @@\n+\t\tIMCFrame secondFrame = frames.get(1).getFrame();\n+\t\tFrameSeparator sep = new FrameSeparator(FrameSeparator.FrameCategorization.LINE, false);\n@@ -1469,1 +1502,1 @@\n-\t\treturn StacktraceFormatToolkit.formatFrame(secondFrame.getFrame(), sep, false, false, true, true, true, false);\n+\t\treturn StacktraceFormatToolkit.formatFrame(secondFrame, sep, false, false, true, true, true, false);\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/util\/RulesToolkit.java","additions":45,"deletions":12,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -6292,1 +6292,14 @@\n-            <explanation>17 errors were thrown in total. The most common error was ''java.lang.NoSuchMethodError'', which was thrown 13 times. Investigate the thrown errors to see if they can be avoided. Errors indicate that something went wrong with the code execution and should never be used for flow control. The following regular expression was used to exclude 381 errors from this rule: ''(com.sun.el.parser.ELParser\\$LookaheadSuccess)''.<\/explanation>\n+            <explanation>17 errors were thrown in total. The most common error was ''java.lang.NoSuchMethodError'', which was thrown 13 times. Investigate the thrown errors to see if they can be avoided. Errors indicate that something went wrong with the code execution and should never be used for flow control. The following regular expression was used to exclude 381 errors from this rule: ''(com.sun.el.parser.ELParser\\$LookaheadSuccess)''.\n+The most common error message was: \n+ &amp;lt;clinit&amp;gt;\n+The most common error stack trace was: \n+ java.lang.Error.&amp;lt;init&amp;gt;(String):71\n+java.lang.LinkageError.&amp;lt;init&amp;gt;(String):55\n+java.lang.IncompatibleClassChangeError.&amp;lt;init&amp;gt;(String):55\n+java.lang.NoSuchMethodError.&amp;lt;init&amp;gt;(String):58\n+java.io.ObjectStreamClass.hasStaticInitializer(Class):-1\n+java.io.ObjectStreamClass.computeDefaultSUID(Class):1743\n+java.io.ObjectStreamClass.access$100(Class):72\n+java.io.ObjectStreamClass$1.run():250\n+java.io.ObjectStreamClass$1.run():248\n+java.security.AccessController.doPrivileged(PrivilegedAction):-1<\/explanation>\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/baseline\/JfrRuleBaseline.xml","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"}]}