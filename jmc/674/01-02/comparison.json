{"files":[{"patch":"@@ -77,0 +77,3 @@\n+import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator;\n+import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceFormatToolkit;\n+import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceFrame;\n@@ -118,1 +121,1 @@\n-\t\t\t\"Most Common Error Stacktrace\", \"The most common error stacktrace frames.\", UnitLookup.PLAIN_TEXT,\n+\t\t\t\"Most Common Error Stack Trace\", \"The most common error stack trace frames.\", UnitLookup.PLAIN_TEXT,\n@@ -203,1 +206,1 @@\n-\t\t\t\t\tString mostCommonErrorStacktraceFrames = RulesToolkit\n+\t\t\t\t\tList<StacktraceFrame> mostCommonErrorStacktraceFrames = RulesToolkit\n@@ -205,0 +208,15 @@\n+\t\t\t\t\tList<String> formattedFrames = new ArrayList<>(mostCommonErrorStacktraceFrames.size());\n+\t\t\t\t\t\/*\n+\t\t\t\t\t * FIXME: Consider defining the method formatting based on preferences.\n+\t\t\t\t\t *\n+\t\t\t\t\t * Currently it's a compromise between keeping the length short, but still being\n+\t\t\t\t\t * able to identify the actual method, even if the line number is a bit\n+\t\t\t\t\t * incorrect.\n+\t\t\t\t\t *\/\n+\t\t\t\t\tFrameSeparator sep = new FrameSeparator(FrameSeparator.FrameCategorization.LINE, false);\n+\t\t\t\t\tfor (int i = 0; i < mostCommonErrorStacktraceFrames.size(); i++) {\n+\t\t\t\t\t\tformattedFrames.add(\n+\t\t\t\t\t\t\t\tStacktraceFormatToolkit.formatFrame(mostCommonErrorStacktraceFrames.get(i).getFrame(),\n+\t\t\t\t\t\t\t\t\t\tsep, false, false, true, true, true, false));\n+\t\t\t\t\t}\n+\t\t\t\t\tString mostCommonErrorStacktraceFormattedFrames = String.join(\"\\n\", formattedFrames);\n@@ -206,1 +224,1 @@\n-\t\t\t\t\tresultBuilder.addResult(MOST_COMMON_ERROR_STACKTRACE, mostCommonErrorStacktraceFrames);\n+\t\t\t\t\tresultBuilder.addResult(MOST_COMMON_ERROR_STACKTRACE, mostCommonErrorStacktraceFormattedFrames);\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/exceptions\/ErrorRule.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.ArrayList;\n@@ -74,0 +75,3 @@\n+import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator;\n+import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceFormatToolkit;\n+import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceFrame;\n@@ -104,2 +108,2 @@\n-\t\t\t\"mostCommonExceptionStacktrace\", \"Most Common Exception Stacktrace\", \/\/$NON-NLS-1$\n-\t\t\t\"The most common exception stacktrace frames.\", UnitLookup.PLAIN_TEXT, String.class);\n+\t\t\t\"mostCommonExceptionStacktrace\", \"Most Common Exception Stack Trace\", \/\/$NON-NLS-1$\n+\t\t\t\"The most common exception stack trace frames.\", UnitLookup.PLAIN_TEXT, String.class);\n@@ -153,1 +157,1 @@\n-\t\t\t\t\t\tString mostCommonExceptionstackTraceFrames = RulesToolkit\n+\t\t\t\t\t\tList<StacktraceFrame> mostCommonExceptionStacktraceFrames = RulesToolkit\n@@ -155,0 +159,16 @@\n+\t\t\t\t\t\tList<String> formattedFrames = new ArrayList<String>(\n+\t\t\t\t\t\t\t\tmostCommonExceptionStacktraceFrames.size());\n+\t\t\t\t\t\t\/*\n+\t\t\t\t\t\t * FIXME: Consider defining the method formatting based on preferences.\n+\t\t\t\t\t\t *\n+\t\t\t\t\t\t * Currently it's a compromise between keeping the length short, but still\n+\t\t\t\t\t\t * being able to identify the actual method, even if the line number is a\n+\t\t\t\t\t\t * bit incorrect.\n+\t\t\t\t\t\t *\/\n+\t\t\t\t\t\tFrameSeparator sep = new FrameSeparator(FrameSeparator.FrameCategorization.LINE, false);\n+\t\t\t\t\t\tfor (int i = 0; i < mostCommonExceptionStacktraceFrames.size(); i++) {\n+\t\t\t\t\t\t\tformattedFrames.add(StacktraceFormatToolkit.formatFrame(\n+\t\t\t\t\t\t\t\t\tmostCommonExceptionStacktraceFrames.get(i).getFrame(), sep, false, false, true,\n+\t\t\t\t\t\t\t\t\ttrue, true, false));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tString mostCommonExceptionStacktraceFormattedFrames = String.join(\"\\n\", formattedFrames);\n@@ -157,1 +177,2 @@\n-\t\t\t\t\t\tresultBuilder.addResult(MOST_COMMON_EXCEPTION_STACKTRACE, mostCommonExceptionstackTraceFrames);\n+\t\t\t\t\t\tresultBuilder.addResult(MOST_COMMON_EXCEPTION_STACKTRACE,\n+\t\t\t\t\t\t\t\tmostCommonExceptionStacktraceFormattedFrames);\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/exceptions\/ExceptionRule.java","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.util.stream.StreamSupport;\n@@ -51,0 +52,1 @@\n+import org.openjdk.jmc.common.item.ItemCollectionToolkit;\n@@ -72,1 +74,0 @@\n-import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceModel.Branch;\n@@ -197,10 +198,4 @@\n-\t\t\t\t\tStacktraceFrame secondFrame = null;\n-\t\t\t\t\tBranch firstBranch = stacktraceFrame.getBranch();\n-\t\t\t\t\tif (firstBranch.getTailFrames().length > 0) {\n-\t\t\t\t\t\tsecondFrame = firstBranch.getTailFrames()[0];\n-\t\t\t\t\t} else if (firstBranch.getEndFork().getBranchCount() > 0) {\n-\t\t\t\t\t\tsecondFrame = firstBranch.getEndFork().getBranch(0).getFirstFrame();\n-\t\t\t\t\t}\n-\t\t\t\t\tif (secondFrame != null) {\n-\t\t\t\t\t\tsecondFrameFromMostAllocated = secondFrame.getFrame();\n-\t\t\t\t\t}\n+\t\t\t\t\tIItemCollection itemsFromMostAllocate = ItemCollectionToolkit\n+\t\t\t\t\t\t\t.build(StreamSupport.stream(itemArray.spliterator(), false));\n+\t\t\t\t\tsecondFrameFromMostAllocated = RulesToolkit.getTopNFramesInMostCommonTrace(itemsFromMostAllocate, 2)\n+\t\t\t\t\t\t\t.get(1).getFrame();\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/memory\/AutoBoxingRule.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-ErrorRule_TEXT_WARN_MOST_COMMON_ERROR_MESSAGE=The most common error message was : \\n {mostCommonErrorMessage}\n+ErrorRule_TEXT_WARN_MOST_COMMON_ERROR_MESSAGE=The most common error message was: \\n {mostCommonErrorMessage}\n@@ -238,1 +238,1 @@\n-ErrorRule_TEXT_WARN_MOST_COMMON_ERROR_STACKTRACE=The most common error stackrace was : \\n {mostCommonErrorStacktrace}\n+ErrorRule_TEXT_WARN_MOST_COMMON_ERROR_STACKTRACE=The most common error stack trace was: \\n {mostCommonErrorStacktrace}\n@@ -250,1 +250,1 @@\n-ExceptionRule_TEXT_MOST_COMMON_EXCEPTION_MESSAGE=The most common exception message was : \\n {mostCommonExceptionMessage}\n+ExceptionRule_TEXT_MOST_COMMON_EXCEPTION_MESSAGE=The most common exception message was: \\n {mostCommonExceptionMessage}\n@@ -252,1 +252,1 @@\n-ExceptionRule_TEXT_MOST_COMMON_EXCEPTION_STACKTRACE=The most common exception stacktrace was : \\n {mostCommonExceptionStacktrace}\n+ExceptionRule_TEXT_MOST_COMMON_EXCEPTION_STACKTRACE=The most common exception stack trace was: \\n {mostCommonExceptionStacktrace}\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/messages.properties","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import org.openjdk.jmc.common.IMCFrame;\n@@ -1443,2 +1444,6 @@\n-\t * Gets the top n frame in the most common stack trace. Useful when showing what called a\n-\t * interesting method, like for example java.lang.Integer.valueOf (aka autoboxing)\n+\t * Returns up to {@code n} frames from the single most frequent branch in the aggregated stack\n+\t * traces for the provided {@code items}.\n+\t * <p>\n+\t * The result starts at the frame where the event(s) occurred and includes successive caller\n+\t * frames, up to the requested number. This is useful to see the most frequent path leading to\n+\t * an interesting method, such as {@code java.lang.Integer.valueOf} (autoboxing).\n@@ -1447,2 +1452,4 @@\n-\t *            the item collection to build the aggregated stack trace on\n-\t * @return stack trace frames\n+\t *            the events for which to aggregate stack traces\n+\t * @param n\n+\t *            the maximum number of frames to return\n+\t * @return a List of {@code n} frames, starting at the event site and moving toward the callers\n@@ -1450,1 +1457,1 @@\n-\tpublic static String getTopNFramesInMostCommonTrace(IItemCollection items, int n) {\n+\tpublic static List<StacktraceFrame> getTopNFramesInMostCommonTrace(IItemCollection items, int n) {\n@@ -1470,11 +1477,16 @@\n-\t\tint countToPrint = Math.min(n, frames.size());\n-\t\tList<String> formattedFrames = new ArrayList<>(countToPrint);\n-\t\tfor (int i = 0; i < countToPrint; i++) {\n-\t\t\t\/*\n-\t\t\t * FIXME: Consider defining the method formatting based on preferences.\n-\t\t\t *\n-\t\t\t * Currently it's a compromise between keeping the length short, but still being able to\n-\t\t\t * identify the actual method, even if the line number is a bit incorrect.\n-\t\t\t *\/\n-\t\t\tformattedFrames.add(StacktraceFormatToolkit.formatFrame(frames.get(i).getFrame(), sep, false, false, true,\n-\t\t\t\t\ttrue, true, false));\n+\t\treturn frames;\n+\t}\n+\n+\t\/**\n+\t * Gets the second frame in the most common stack trace. Useful when showing what called an\n+\t * interesting method, like for example java.lang.Integer.valueOf (aka autoboxing)\n+\t *\n+\t * @param items\n+\t *            the item collection to build the aggregated stack trace on\n+\t * @return a stack trace frame\n+\t * @deprecated Use {@link #getTopNFramesInMostCommonTrace(IItemCollection, int)} instead.\n+\t *\/\n+\tpublic static String getSecondFrameInMostCommonTrace(IItemCollection items) {\n+\t\tList<StacktraceFrame> frames = getTopNFramesInMostCommonTrace(items, 2);\n+\t\tif (frames.size() < 2) {\n+\t\t\treturn null;\n@@ -1482,1 +1494,9 @@\n-\t\treturn String.join(\"\\n\", formattedFrames);\n+\t\tIMCFrame secondFrame = frames.get(1).getFrame();\n+\t\tFrameSeparator sep = new FrameSeparator(FrameSeparator.FrameCategorization.LINE, false);\n+\t\t\/*\n+\t\t * FIXME: Consider defining the method formatting based on preferences.\n+\t\t *\n+\t\t * Currently it's a compromise between keeping the length short, but still being able to\n+\t\t * identify the actual method, even if the line number is a bit incorrect.\n+\t\t *\/\n+\t\treturn StacktraceFormatToolkit.formatFrame(secondFrame, sep, false, false, true, true, true, false);\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/util\/RulesToolkit.java","additions":37,"deletions":17,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -6293,1 +6293,1 @@\n-The most common error message was : \n+The most common error message was: \n@@ -6295,1 +6295,1 @@\n-The most common error stackrace was : \n+The most common error stack trace was: \n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/baseline\/JfrRuleBaseline.xml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}