{"files":[{"patch":"@@ -113,0 +113,4 @@\n+\tpublic static final TypedResult<String> MOST_COMMON_ERROR_STACKTRACE = new TypedResult<>(\n+\t\t\t\"mostCommonErrorStacktrace\", \/\/$NON-NLS-1$\n+\t\t\t\"Most Common Error Stacktrace\", \"The most common error stacktrace frames.\", UnitLookup.PLAIN_TEXT,\n+\t\t\tString.class);\n@@ -116,1 +120,1 @@\n-\t\t\tMOST_COMMON_ERROR_COUNT);\n+\t\t\tMOST_COMMON_ERROR_COUNT, MOST_COMMON_ERROR_STACKTRACE);\n@@ -176,1 +180,0 @@\n-\t\t\t\/\/ FIXME: List some frames of the most common stack trace\n@@ -180,0 +183,7 @@\n+\t\t\tString stackTraceFrames = \"\"; \/\/$NON-NLS-1$\n+\t\t\tif (mostCommonError != null) {\n+\t\t\t\tIItemFilter errorTypeFilter = ItemFilters.equals(JdkAttributes.EXCEPTION_THROWNCLASS, mostCommonError);\n+\t\t\t\tIItemCollection mostCommonErrorItems = errorItems.apply(errorTypeFilter);\n+\t\t\t\tstackTraceFrames = RulesToolkit.getTopNFramesInMostCommonTrace(mostCommonErrorItems, 10);\n+\t\t\t\tlongMessage += \"\\n\" + Messages.getString(Messages.ErrorRule_TEXT_WARN_MOST_COMMON_STACKTRACE); \/\/$NON-NLS-1$\n+\t\t\t}\n@@ -186,1 +196,2 @@\n-\t\t\t\t\t.addResult(MOST_COMMON_ERROR_COUNT, UnitLookup.NUMBER_UNITY.quantity(errorsThrown)).build();\n+\t\t\t\t\t.addResult(MOST_COMMON_ERROR_COUNT, UnitLookup.NUMBER_UNITY.quantity(errorsThrown))\n+\t\t\t\t\t.addResult(MOST_COMMON_ERROR_STACKTRACE, stackTraceFrames).build();\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/exceptions\/ErrorRule.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import org.openjdk.jmc.common.IMCType;\n+import org.openjdk.jmc.common.collection.MapToolkit.IntEntry;\n@@ -47,0 +49,2 @@\n+import org.openjdk.jmc.common.item.IItemFilter;\n+import org.openjdk.jmc.common.item.ItemFilters;\n@@ -95,0 +99,5 @@\n+\tpublic static final TypedResult<IMCType> MOST_COMMON_EXCEPTION = new TypedResult<>(\"mostCommonException\", \/\/$NON-NLS-1$\n+\t\t\t\"Most Common Exception\", \"The most common exception thrown.\", UnitLookup.CLASS, IMCType.class);\n+\tpublic static final TypedResult<String> MOST_COMMON_EXCEPTION_STACKTRACE = new TypedResult<>(\n+\t\t\t\"mostCommonExceptionStacktrace\", \"Most Common Exception Stacktrace\", \/\/$NON-NLS-1$\n+\t\t\t\"The most common exception stacktrace frames.\", UnitLookup.PLAIN_TEXT, String.class);\n@@ -96,2 +105,3 @@\n-\tprivate static final Collection<TypedResult<?>> RESULT_ATTRIBUTES = Arrays\n-\t\t\t.<TypedResult<?>> asList(TypedResult.SCORE, EXCEPTION_RATE, EXCEPTION_WINDOW);\n+\tprivate static final Collection<TypedResult<?>> RESULT_ATTRIBUTES = Arrays.<TypedResult<?>> asList(\n+\t\t\tTypedResult.SCORE, EXCEPTION_RATE, EXCEPTION_WINDOW, MOST_COMMON_EXCEPTION,\n+\t\t\tMOST_COMMON_EXCEPTION_STACKTRACE);\n@@ -113,3 +123,25 @@\n-\t\t\treturn ResultBuilder.createFor(this, vp).setSeverity(Severity.get(score))\n-\t\t\t\t\t.setSummary(Messages.getString(Messages.ExceptionRule_TEXT_MESSAGE))\n-\t\t\t\t\t.setExplanation(Messages.getString(Messages.ExceptionRule_TEXT_INFO_LONG))\n+\t\t\tResultBuilder resultBuilder = ResultBuilder.createFor(this, vp);\n+\t\t\tString explanation = Messages.getString(Messages.ExceptionRule_TEXT_INFO_LONG);\n+\t\t\tEventAvailability exceptionsThrownEventAvailability = RulesToolkit.getEventAvailability(items,\n+\t\t\t\t\tJdkTypeIDs.EXCEPTIONS_THROWN);\n+\t\t\tif (exceptionsThrownEventAvailability == EventAvailability.AVAILABLE) {\n+\t\t\t\tIItemCollection exceptionItems = items.apply(JdkFilters.EXCEPTIONS);\n+\t\t\t\tList<IntEntry<IMCType>> exceptionGrouping = RulesToolkit.calculateGroupingScore(exceptionItems,\n+\t\t\t\t\t\tJdkAttributes.EXCEPTION_THROWNCLASS);\n+\t\t\t\tIMCType mostCommonException = exceptionGrouping.get(exceptionGrouping.size() - 1).getKey();\n+\t\t\t\texplanation = Messages.getString(Messages.ExceptionRule_TEXT_MOST_COMMON_EXCEPTION) + explanation;\n+\t\t\t\tresultBuilder.addResult(MOST_COMMON_EXCEPTION, mostCommonException);\n+\t\t\t\tString stackTraceFrames = \"\"; \/\/$NON-NLS-1$\n+\t\t\t\tif (mostCommonException != null) {\n+\t\t\t\t\tIItemFilter exceptionTypeFilter = ItemFilters.equals(JdkAttributes.EXCEPTION_THROWNCLASS,\n+\t\t\t\t\t\t\tmostCommonException);\n+\t\t\t\t\tIItemCollection mostCommonExceptionItems = exceptionItems.apply(exceptionTypeFilter);\n+\t\t\t\t\tstackTraceFrames = RulesToolkit.getTopNFramesInMostCommonTrace(mostCommonExceptionItems, 10);\n+\t\t\t\t}\n+\t\t\t\texplanation = Messages.getString(Messages.ExceptionRule_TEXT_MOST_COMMON_EXCEPTION) + explanation + \"\\n\" \/\/$NON-NLS-1$\n+\t\t\t\t\t\t+ Messages.getString(Messages.ExceptionRule_TEXT_MOST_COMMON_STACKTRACE);\n+\t\t\t\tresultBuilder.addResult(MOST_COMMON_EXCEPTION, mostCommonException)\n+\t\t\t\t\t\t.addResult(MOST_COMMON_EXCEPTION_STACKTRACE, stackTraceFrames);\n+\t\t\t}\n+\t\t\treturn resultBuilder.setSeverity(Severity.get(score))\n+\t\t\t\t\t.setSummary(Messages.getString(Messages.ExceptionRule_TEXT_MESSAGE)).setExplanation(explanation)\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/exceptions\/ExceptionRule.java","additions":37,"deletions":5,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -234,0 +234,1 @@\n+\tpublic static final String ErrorRule_TEXT_WARN_MOST_COMMON_STACKTRACE = \"ErrorRule_TEXT_WARN_MOST_COMMON_STACKTRACE\"; \/\/$NON-NLS-1$\n@@ -240,0 +241,2 @@\n+\tpublic static final String ExceptionRule_TEXT_MOST_COMMON_EXCEPTION = \"ExceptionRule_TEXT_MOST_COMMON_EXCEPTION\"; \/\/$NON-NLS-1$\n+\tpublic static final String ExceptionRule_TEXT_MOST_COMMON_STACKTRACE = \"ExceptionRule_TEXT_MOST_COMMON_STACKTRACE\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/Messages.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -235,0 +235,2 @@\n+# {mostCommonErrorStacktrace} is a string.\n+ErrorRule_TEXT_WARN_MOST_COMMON_STACKTRACE=The most common error stackrace was : \\n {mostCommonErrorStacktrace}\n@@ -240,0 +242,2 @@\n+# {mostCommonException} is an exception class name\n+ExceptionRule_TEXT_MOST_COMMON_EXCEPTION=The most common exception was ''{mostCommonException}''.\n@@ -243,0 +247,2 @@\n+{mostCommonExceptionStacktrace} is a string.\n+ExceptionRule_TEXT_MOST_COMMON_STACKTRACE=The most common exception stacktrace was : \\n {mostCommonExceptionStacktrace}\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/messages.properties","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1443,1 +1443,1 @@\n-\t * Gets the second frame in the most common stack trace. Useful when showing what called a\n+\t * Gets the top n frame in the most common stack trace. Useful when showing what called a\n@@ -1448,1 +1448,1 @@\n-\t * @return a stack trace frame\n+\t * @return stack trace frames\n@@ -1450,2 +1450,1 @@\n-\t\/\/ FIXME: Generalize this a bit, get the top N frames\n-\tpublic static String getSecondFrameInMostCommonTrace(IItemCollection items) {\n+\tpublic static String getTopNFramesInMostCommonTrace(IItemCollection items, int n) {\n@@ -1454,8 +1453,16 @@\n-\t\tBranch firstBranch = stacktraceModel.getRootFork().getBranch(0);\n-\t\tStacktraceFrame secondFrame = null;\n-\t\tif (firstBranch.getTailFrames().length > 0) {\n-\t\t\tsecondFrame = firstBranch.getTailFrames()[0];\n-\t\t} else if (firstBranch.getEndFork().getBranchCount() > 0) {\n-\t\t\tsecondFrame = firstBranch.getEndFork().getBranch(0).getFirstFrame();\n-\t\t} else {\n-\t\t\treturn null;\n+\t\tBranch currentBranch = stacktraceModel.getRootFork().getBranch(0);\n+\t\tList<StacktraceFrame> frames = new ArrayList<>();\n+\t\twhile (currentBranch != null && frames.size() < n) {\n+\t\t\tframes.add(currentBranch.getFirstFrame());\n+\t\t\tfor (StacktraceFrame tf : currentBranch.getTailFrames()) {\n+\t\t\t\tif (frames.size() == n)\n+\t\t\t\t\tbreak;\n+\t\t\t\tframes.add(tf);\n+\t\t\t}\n+\t\t\tif (frames.size() == n)\n+\t\t\t\tbreak;\n+\t\t\tif (currentBranch.getEndFork().getBranchCount() > 0) {\n+\t\t\t\tcurrentBranch = currentBranch.getEndFork().getBranch(0);\n+\t\t\t} else {\n+\t\t\t\tbreak;\n+\t\t\t}\n@@ -1463,7 +1470,13 @@\n-\t\t\/*\n-\t\t * FIXME: Consider defining the method formatting based on preferences.\n-\t\t *\n-\t\t * Currently it's a compromise between keeping the length short, but still being able to\n-\t\t * identify the actual method, even if the line number is a bit incorrect.\n-\t\t *\/\n-\t\treturn StacktraceFormatToolkit.formatFrame(secondFrame.getFrame(), sep, false, false, true, true, true, false);\n+\t\tint countToPrint = Math.min(n, frames.size());\n+\t\tList<String> formattedFrames = new ArrayList<>(countToPrint);\n+\t\tfor (int i = 0; i < countToPrint; i++) {\n+\t\t\t\/*\n+\t\t\t * FIXME: Consider defining the method formatting based on preferences.\n+\t\t\t *\n+\t\t\t * Currently it's a compromise between keeping the length short, but still being able to\n+\t\t\t * identify the actual method, even if the line number is a bit incorrect.\n+\t\t\t *\/\n+\t\t\tformattedFrames.add(StacktraceFormatToolkit.formatFrame(frames.get(i).getFrame(), sep, false, false, true,\n+\t\t\t\t\ttrue, true, false));\n+\t\t}\n+\t\treturn String.join(\"\\n\", formattedFrames);\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/util\/RulesToolkit.java","additions":32,"deletions":19,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -6292,1 +6292,12 @@\n-            <explanation>17 errors were thrown in total. The most common error was ''java.lang.NoSuchMethodError'', which was thrown 13 times. Investigate the thrown errors to see if they can be avoided. Errors indicate that something went wrong with the code execution and should never be used for flow control. The following regular expression was used to exclude 381 errors from this rule: ''(com.sun.el.parser.ELParser\\$LookaheadSuccess)''.<\/explanation>\n+            <explanation>17 errors were thrown in total. The most common error was ''java.lang.NoSuchMethodError'', which was thrown 13 times. Investigate the thrown errors to see if they can be avoided. Errors indicate that something went wrong with the code execution and should never be used for flow control. The following regular expression was used to exclude 381 errors from this rule: ''(com.sun.el.parser.ELParser\\$LookaheadSuccess)''.\n+The most common error stackrace was : \n+ java.lang.Error.&amp;lt;init&amp;gt;(String):71\n+java.lang.LinkageError.&amp;lt;init&amp;gt;(String):55\n+java.lang.IncompatibleClassChangeError.&amp;lt;init&amp;gt;(String):55\n+java.lang.NoSuchMethodError.&amp;lt;init&amp;gt;(String):58\n+java.io.ObjectStreamClass.hasStaticInitializer(Class):-1\n+java.io.ObjectStreamClass.computeDefaultSUID(Class):1743\n+java.io.ObjectStreamClass.access$100(Class):72\n+java.io.ObjectStreamClass$1.run():250\n+java.io.ObjectStreamClass$1.run():248\n+java.security.AccessController.doPrivileged(PrivilegedAction):-1<\/explanation>\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/baseline\/JfrRuleBaseline.xml","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"}]}