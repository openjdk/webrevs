{"files":[{"patch":"@@ -103,0 +103,1 @@\n+\t\t\t\t\tIOToolkit.closeSilently(connection);\n@@ -121,0 +122,1 @@\n+\t\t\t\tIOToolkit.closeSilently(connection);\n","filename":"application\/org.openjdk.jmc.console.ui\/src\/main\/java\/org\/openjdk\/jmc\/console\/ui\/editor\/internal\/ConsoleEditor.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -848,0 +848,3 @@\n+\t\t\tList<Pair<String, IAttribute<IQuantity>>> attrList = AttributeSelection.extractAttributes(itemsToShow);\n+\t\t\tString attrName = currentAttribute != null ? currentAttribute.getName() : null;\n+\t\t\tcreateAttributeSelection(attrName, attrList);\n@@ -849,3 +852,0 @@\n-\t\tList<Pair<String, IAttribute<IQuantity>>> attrList = AttributeSelection.extractAttributes(itemsToShow);\n-\t\tString attrName = currentAttribute != null ? currentAttribute.getName() : null;\n-\t\tcreateAttributeSelection(attrName, attrList);\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/views\/stacktrace\/StacktraceView.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.ref.Cleaner;\n@@ -47,0 +48,1 @@\n+import org.openjdk.jmc.rjmx.common.ConnectionToolkit;\n@@ -55,0 +57,7 @@\n+\/**\n+ * Implementation of {@link IServerHandle} that manages JMX server connections.\n+ * <p>\n+ * This class implements automatic resource cleanup using the {@link Cleaner} API. While the cleaner\n+ * provides a safety net for resource cleanup, it is strongly recommended to explicitly call\n+ * {@link #dispose()} for predictable resource management.\n+ *\/\n@@ -61,0 +70,1 @@\n+\tprivate final Cleaner.Cleanable cleanable;\n@@ -87,0 +97,1 @@\n+\t\tthis.cleanable = ConnectionToolkit.CLEANER.register(this, new CleanupAction(connection, connectionHandles));\n@@ -153,2 +164,5 @@\n-\t\tsynchronized (this) {\n-\t\t\tif (!isDisposed()) {\n+\t\ttry {\n+\t\t\tsynchronized (this) {\n+\t\t\t\tif (isDisposed()) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n@@ -157,0 +171,3 @@\n+\t\t\tdisconnect();\n+\t\t} finally {\n+\t\t\tcleanable.clean();\n@@ -158,1 +175,0 @@\n-\t\tdisconnect();\n@@ -210,4 +226,25 @@\n-\t@Override\n-\tprotected void finalize() throws Throwable {\n-\t\tdisconnect();\n-\t\tsuper.finalize();\n+\tprivate static class CleanupAction implements Runnable {\n+\t\tprivate final List<DefaultConnectionHandle> connectionHandles;\n+\n+\t\tCleanupAction(RJMXConnection connection, List<DefaultConnectionHandle> connectionHandles) {\n+\t\t\tthis.connectionHandles = new ArrayList<>(connectionHandles);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void run() {\n+\t\t\ttry {\n+\t\t\t\tdisconnectQuietly();\n+\t\t\t} catch (Exception e) {\n+\t\t\t\t\/\/ Ignore all exceptions during cleanup\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate void disconnectQuietly() {\n+\t\t\tfor (DefaultConnectionHandle handle : connectionHandles) {\n+\t\t\t\ttry {\n+\t\t\t\t\tIOToolkit.closeSilently(handle);\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\t\/\/ Ignore exceptions during cleanup\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n","filename":"application\/org.openjdk.jmc.rjmx\/src\/main\/java\/org\/openjdk\/jmc\/rjmx\/internal\/ServerHandle.java","additions":44,"deletions":7,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.lang.ref.Cleaner;\n@@ -67,1 +68,5 @@\n-\t * The default port JMX\n+\t * Shared cleaner instance for RJMX resource management.\n+\t *\/\n+\tpublic static final Cleaner CLEANER = Cleaner.create();\n+\t\/**\n+\t * The default port.\n","filename":"core\/org.openjdk.jmc.rjmx.common\/src\/main\/java\/org\/openjdk\/jmc\/rjmx\/common\/ConnectionToolkit.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.ref.Cleaner;\n@@ -47,0 +48,1 @@\n+import org.openjdk.jmc.rjmx.common.ConnectionToolkit;\n@@ -58,0 +60,4 @@\n+ * <p>\n+ * This class implements automatic resource cleanup using the {@link Cleaner} API. While the cleaner\n+ * provides a safety net for resource cleanup, it is strongly recommended to explicitly call\n+ * {@link #close()} or use try-with-resources for predictable resource management.\n@@ -73,0 +79,1 @@\n+\tprivate final Cleaner.Cleanable cleanable;\n@@ -85,0 +92,1 @@\n+\t\tthis.cleanable = ConnectionToolkit.CLEANER.register(this, new CleanupAction(services, connection));\n@@ -104,4 +112,9 @@\n-\t\tsynchronized (services) {\n-\t\t\tif (closeDownThreadId != null) {\n-\t\t\t\t\/\/ Already closed\n-\t\t\t\treturn;\n+\t\ttry {\n+\t\t\tsynchronized (services) {\n+\t\t\t\tif (closeDownThreadId != null) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\t\/\/ Allow disposing services to get other services, but refuse all other\n+\t\t\t\tcloseDownThreadId = Thread.currentThread().getId();\n+\t\t\t\tshutdownServices();\n+\t\t\t\tcloseDownThreadId = -1L; \/\/ No more access, refuse all\n@@ -109,11 +122,7 @@\n-\t\t\t\/\/ Allow disposing services to get other services, but refuse all other\n-\t\t\tcloseDownThreadId = Thread.currentThread().getId();\n-\t\t\tshutdownServices();\n-\t\t\tcloseDownThreadId = -1L; \/\/ No more access, refuse all\n-\t\t}\n-\t\tfor (IConnectionListener l : listeners) {\n-\t\t\ttry {\n-\t\t\t\tl.onConnectionChange(this);\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tRJMXCorePlugin.getDefault().getLogger().log(Level.WARNING,\n-\t\t\t\t\t\t\"DefaultConnectionHandle listener \" + l + \" failed\", e); \/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n+\t\t\tfor (IConnectionListener l : listeners) {\n+\t\t\t\ttry {\n+\t\t\t\t\tl.onConnectionChange(this);\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tRJMXCorePlugin.getDefault().getLogger().log(Level.WARNING,\n+\t\t\t\t\t\t\t\"DefaultConnectionHandle listener \" + l + \" failed\", e); \/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n+\t\t\t\t}\n@@ -121,0 +130,4 @@\n+\t\t} catch (RuntimeException e) {\n+\t\t\tthrow new IOException(\"Failed to close connection\", e);\n+\t\t} finally {\n+\t\t\tcleanable.clean();\n@@ -142,12 +155,0 @@\n-\t\/**\n-\t * Free external resources.\n-\t *\n-\t * @see java.lang.Object#finalize()\n-\t *\/\n-\t@Override\n-\tprotected void finalize() throws Throwable {\n-\t\t\/\/ Make sure that external resources are freed upon GC.\n-\t\tclose();\n-\t\tsuper.finalize();\n-\t}\n-\n@@ -240,0 +241,35 @@\n+\n+\tprivate static class CleanupAction implements Runnable {\n+\t\tprivate final Map<Class<?>, Object> services;\n+\t\tprivate final RJMXConnection connection;\n+\n+\t\tCleanupAction(Map<Class<?>, Object> services, RJMXConnection connection) {\n+\t\t\tthis.services = new LinkedHashMap<>(services);\n+\t\t\tthis.connection = connection;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void run() {\n+\t\t\ttry {\n+\t\t\t\tshutdownServicesQuietly(services);\n+\t\t\t\tconnection.close();\n+\t\t\t} catch (Exception e) {\n+\t\t\t\t\/\/ Ignore all exceptions during cleanup\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate static void shutdownServicesQuietly(Map<Class<?>, Object> services) {\n+\t\t\tObject[] servicesArray = services.values().toArray();\n+\t\t\tfor (int i = 0; i < servicesArray.length; i++) {\n+\t\t\t\tObject service = servicesArray[servicesArray.length - i - 1];\n+\t\t\t\tif (service instanceof IDisposableService) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\t((IDisposableService) service).dispose();\n+\t\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\t\t\/\/ Ignore exceptions during cleanup\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tservices.clear();\n+\t\t}\n+\t}\n","filename":"core\/org.openjdk.jmc.rjmx.common\/src\/main\/java\/org\/openjdk\/jmc\/rjmx\/common\/internal\/DefaultConnectionHandle.java","additions":63,"deletions":27,"binary":false,"changes":90,"status":"modified"}]}