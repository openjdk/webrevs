{"files":[{"patch":"@@ -78,1 +78,1 @@\n-\t\t\tJdkAggregators.ZGC_ALLOCATION_STALL_COUNT, UnitLookup.NUMBER, IQuantity.class);\n+\t\t\tJdkAggregators.ZGC_ALLOCATION_STALL_COUNT, UnitLookup.TIMESPAN, IQuantity.class);\n@@ -82,1 +82,1 @@\n-\t\t\tJdkAggregators.ZGC_ALLOCATION_STALL_COUNT, UnitLookup.NUMBER, IQuantity.class);\n+\t\t\tJdkAggregators.ZGC_ALLOCATION_STALL_COUNT, UnitLookup.TIMESPAN, IQuantity.class);\n@@ -151,2 +151,2 @@\n-\t\t\t\t\t.setSummary(Messages.getString(Messages.ZgcAllocationStall_TEXT_INFO)\n-\t\t\t\t\t\t\t.concat(Messages.getString(Messages.ZgcAllocationStall_TEXT_WARN)))\n+\t\t\t\t\t.setSummary(Messages.getString(Messages.ZGCAllocationStall_TEXT_INFO)\n+\t\t\t\t\t\t\t.concat(Messages.getString(Messages.ZGCAllocationStall_TEXT_WARN)))\n@@ -161,2 +161,2 @@\n-\t\t\t\t.setSummary(Messages.getString(Messages.ZgcAllocationStall_TEXT_INFO)\n-\t\t\t\t\t\t.concat(Messages.getString(Messages.ZgcAllocationStall_TEXT_OK)))\n+\t\t\t\t.setSummary(Messages.getString(Messages.ZGCAllocationStall_TEXT_INFO)\n+\t\t\t\t\t\t.concat(Messages.getString(Messages.ZGCAllocationStall_TEXT_OK)))\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/memory\/ZGCAllocationStallRule.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -513,3 +513,3 @@\n-\tpublic static final String ZgcAllocationStall_TEXT_INFO = \"ZgcAllocationStall_TEXT_INFO\"; \/\/$NON-NLS-1$\n-\tpublic static final String ZgcAllocationStall_TEXT_WARN = \"ZgcAllocationStall_TEXT_WARN\"; \/\/$NON-NLS-1$\n-\tpublic static final String ZgcAllocationStall_TEXT_OK = \"ZgcAllocationStall_TEXT_OK\"; \/\/$NON-NLS-1$\n+\tpublic static final String ZGCAllocationStall_TEXT_INFO = \"ZGCAllocationStall_TEXT_INFO\"; \/\/$NON-NLS-1$\n+\tpublic static final String ZGCAllocationStall_TEXT_WARN = \"ZGCAllocationStall_TEXT_WARN\"; \/\/$NON-NLS-1$\n+\tpublic static final String ZGCAllocationStall_TEXT_OK = \"ZGCAllocationStall_TEXT_OK\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/Messages.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -755,3 +755,3 @@\n-ZgcAllocationStall_TEXT_INFO=In ZGC, a type of concurrent Garbage Collection (GC) algorithm, GC threads run concurrently with application threads, resulting in minimal stop-the-world pauses. However application threads can overrun the GC threads, allocating objects faster than GC threads can reclaim memory. in such cases, the JVM temporarily stops allocating application threads. This is called \"Allocation Stall\".\\n Allocation Stalls occurs due to the following reasons:\\n 1. High Object Allocation Rate: if your application creates objects at a very high rate, it can overwhelm the GC's ability to reclaim memory quickly enough, leading to stalls\\n 2. Java Heap size is not sufficient: Having more free room in the heap can give more time for GC threads to perform their GC cycle and reclaim memory to satisfy new allocations happening concurrently.\\n 3. Insufficient resources available for the GC threads: number of GC threads or the CPU allocated for them is not enough to finish the GC cycle and reclaim the memory compared to allocations done by application threads.\\n\n-ZgcAllocationStall_TEXT_WARN=\\n{zgcAllocationStallCount} Allocation Stall events observed. Total time spent in waiting for memory to become available is {zgcAllocationStallTotalDuration} and the maximum duration is {zgcAllocationStallLongestDuration}. Stall time rate per minute is {zgcAllocationStallPerMinute}.\n-ZgcAllocationStall_TEXT_OK=There are no occurrence of Allocation Stall Events.\n+ZGCAllocationStall_TEXT_INFO=In ZGC, a type of concurrent Garbage Collection (GC) algorithm, GC threads run concurrently with application threads, resulting in minimal stop-the-world pauses. However application threads can overrun the GC threads, allocating objects faster than GC threads can reclaim memory. in such cases, the JVM temporarily stops allocating application threads. This is called \"Allocation Stall\".\\n Allocation Stalls occurs due to the following reasons:\\n 1. High Object Allocation Rate: if your application creates objects at a very high rate, it can overwhelm the GC's ability to reclaim memory quickly enough, leading to stalls\\n 2. Java Heap size is not sufficient: Having more free room in the heap can give more time for GC threads to perform their GC cycle and reclaim memory to satisfy new allocations happening concurrently.\\n 3. Insufficient resources available for the GC threads: number of GC threads or the CPU allocated for them is not enough to finish the GC cycle and reclaim the memory compared to allocations done by application threads.\\n\n+ZGCAllocationStall_TEXT_WARN=\\n{zgcAllocationStallCount} Allocation Stall events observed. Total time spent in waiting for memory to become available is {zgcAllocationStallTotalDuration} and the maximum duration is {zgcAllocationStallLongestDuration}. Stall time rate per minute is {zgcAllocationStallPerMinute}.\n+ZGCAllocationStall_TEXT_OK=There are no occurrence of Allocation Stall Events.\n@@ -763,1 +763,1 @@\n-ZGCAllocationStallRule_RATE_LONG=The rate of ZGC Allocation Stall duration based on the time from when JVM was started\n\\ No newline at end of file\n+ZGCAllocationStallRule_RATE_LONG=Average ZGC allocation stalls per minute over the recording period\n\\ No newline at end of file\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/messages.properties","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}