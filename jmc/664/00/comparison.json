{"files":[{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.rules.jdk.memory;\n+\n+import static org.openjdk.jmc.common.unit.UnitLookup.NUMBER;\n+import static org.openjdk.jmc.common.unit.UnitLookup.NUMBER_UNITY;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RunnableFuture;\n+\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.unit.IQuantity;\n+import org.openjdk.jmc.common.unit.UnitLookup;\n+import org.openjdk.jmc.common.util.IPreferenceValueProvider;\n+import org.openjdk.jmc.common.util.TypedPreference;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkAggregators;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;\n+import org.openjdk.jmc.flightrecorder.rules.IResult;\n+import org.openjdk.jmc.flightrecorder.rules.IResultValueProvider;\n+import org.openjdk.jmc.flightrecorder.rules.IRule;\n+import org.openjdk.jmc.flightrecorder.rules.ResultBuilder;\n+import org.openjdk.jmc.flightrecorder.rules.Severity;\n+import org.openjdk.jmc.flightrecorder.rules.TypedResult;\n+import org.openjdk.jmc.flightrecorder.rules.jdk.messages.internal.Messages;\n+import org.openjdk.jmc.flightrecorder.rules.util.JfrRuleTopics;\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit;\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit.EventAvailability;\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit.RequiredEventsBuilder;\n+\n+public class ZGCAllocationStallRule implements IRule {\n+\n+\tprivate static final String ZGC_RESULT_ID = \"ZGCAllocationStallRule\"; \/\/$NON-NLS-1$\n+\n+\tprivate static final Map<String, EventAvailability> REQUIRED_EVENTS = RequiredEventsBuilder.create()\n+\t\t\t.addEventType(JdkTypeIDs.ZGC_ALLOCATION_STALL, EventAvailability.AVAILABLE).build();\n+\n+\tpublic static final TypedResult<IQuantity> ZGC_ALLOCATION_STALL_EVENTS = new TypedResult<>(\n+\t\t\t\"zgcAllocationStallCount\", \/\/$NON-NLS-1$\n+\t\t\tJdkAggregators.ZGC_ALLOCATION_STALL_COUNT, UnitLookup.NUMBER, IQuantity.class);\n+\n+\tpublic static final TypedResult<IQuantity> ZGC_ALLOCATION_STALL_LONGEST_DURATION = new TypedResult<>(\n+\t\t\t\"zgcAllocationStallLongestDuration\", \/\/$NON-NLS-1$\n+\t\t\tJdkAggregators.ZGC_ALLOCATION_STALL_COUNT, UnitLookup.NUMBER, IQuantity.class);\n+\n+\tpublic static final TypedResult<IQuantity> ZGC_ALLOCATION_STALL_TOTAL_DURATION = new TypedResult<>(\n+\t\t\t\"zgcAllocationStallTotalDuration\", \/\/$NON-NLS-1$\n+\t\t\tJdkAggregators.ZGC_ALLOCATION_STALL_COUNT, UnitLookup.NUMBER, IQuantity.class);\n+\n+\tpublic static final TypedPreference<IQuantity> ALLOCATION_STALL_INFO_LIMIT = new TypedPreference<>(\n+\t\t\t\"allocation.stall.info.limit\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ZGCAllocationStallRule_CONFIG_INFO_LIMIT),\n+\t\t\tMessages.getString(Messages.ZGCAllocationStallRule_CONFIG_INFO_LIMIT_LONG), NUMBER,\n+\t\t\tNUMBER_UNITY.quantity(10));\n+\n+\tpublic static final TypedPreference<IQuantity> ALLOCATION_STALL_WARNING_LIMIT = new TypedPreference<>(\n+\t\t\t\"allocation.stall.warning.limit\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ZGCAllocationStallRule_CONFIG_WARN_LIMIT),\n+\t\t\tMessages.getString(Messages.ZGCAllocationStallRule_CONFIG_WARN_LIMIT_LONG), NUMBER,\n+\t\t\tNUMBER_UNITY.quantity(100));\n+\n+\tprivate static final List<TypedPreference<?>> CONFIG_ATTRIBUTES = Arrays\n+\t\t\t.<TypedPreference<?>> asList(ALLOCATION_STALL_INFO_LIMIT, ALLOCATION_STALL_WARNING_LIMIT);\n+\n+\tprivate static final Collection<TypedResult<?>> RESULT_ATTRIBUTES = Arrays.<TypedResult<?>> asList(\n+\t\t\tTypedResult.SCORE, ZGC_ALLOCATION_STALL_EVENTS, ZGC_ALLOCATION_STALL_LONGEST_DURATION,\n+\t\t\tZGC_ALLOCATION_STALL_TOTAL_DURATION);\n+\n+\t@Override\n+\tpublic String getId() {\n+\t\treturn ZGC_RESULT_ID;\n+\t}\n+\n+\t@Override\n+\tpublic String getTopic() {\n+\t\treturn JfrRuleTopics.GARBAGE_COLLECTION;\n+\t}\n+\n+\t@Override\n+\tpublic String getName() {\n+\t\treturn Messages.getString(Messages.ZGCAllocationStall_RULE_NAME);\n+\t}\n+\n+\t@Override\n+\tpublic Map<String, EventAvailability> getRequiredEvents() {\n+\t\treturn REQUIRED_EVENTS;\n+\t}\n+\n+\tprivate IResult getResult(\n+\t\tIItemCollection items, IPreferenceValueProvider valueProvider, IResultValueProvider resultProvider) {\n+\t\tlong infoLimit = valueProvider.getPreferenceValue(ALLOCATION_STALL_INFO_LIMIT).clampedLongValueIn(NUMBER_UNITY);\n+\t\tlong warningLimit = valueProvider.getPreferenceValue(ALLOCATION_STALL_WARNING_LIMIT)\n+\t\t\t\t.clampedLongValueIn(NUMBER_UNITY);\n+\n+\t\tIQuantity zgcAllocationStallCount = items.getAggregate(JdkAggregators.ZGC_ALLOCATION_STALL_COUNT);\n+\t\tIQuantity zgcAllocationStallTotalDuration = items.getAggregate(JdkAggregators.TOTAL_ZGC_ALLOCATION_STALL);\n+\t\tIQuantity zgcAllocationStallLongestDuration = items.getAggregate(JdkAggregators.LONGEST_ZGC_ALLOCATION_STALL);\n+\t\tif (zgcAllocationStallCount != null && zgcAllocationStallCount.doubleValue() > 0) {\n+\t\t\tdouble score = RulesToolkit.mapExp100(zgcAllocationStallCount.clampedLongValueIn(UnitLookup.NUMBER_UNITY),\n+\t\t\t\t\tinfoLimit, warningLimit);\n+\n+\t\t\treturn ResultBuilder.createFor(ZGCAllocationStallRule.this, valueProvider).setSeverity(Severity.get(score))\n+\t\t\t\t\t.setSummary(Messages.getString(Messages.ZgcAllocationStall_TEXT_INFO)\n+\t\t\t\t\t\t\t.concat(Messages.getString(Messages.ZgcAllocationStall_TEXT_WARN)))\n+\t\t\t\t\t.addResult(TypedResult.SCORE, UnitLookup.NUMBER_UNITY.quantity(score))\n+\t\t\t\t\t.addResult(ZGC_ALLOCATION_STALL_EVENTS, zgcAllocationStallCount)\n+\t\t\t\t\t.addResult(ZGC_ALLOCATION_STALL_TOTAL_DURATION, zgcAllocationStallTotalDuration)\n+\t\t\t\t\t.addResult(ZGC_ALLOCATION_STALL_LONGEST_DURATION, zgcAllocationStallLongestDuration).build();\n+\n+\t\t}\n+\t\treturn ResultBuilder.createFor(ZGCAllocationStallRule.this, valueProvider).setSeverity(Severity.OK)\n+\t\t\t\t.setSummary(Messages.getString(Messages.ZgcAllocationStall_TEXT_INFO)\n+\t\t\t\t\t\t.concat(Messages.getString(Messages.ZgcAllocationStall_TEXT_OK)))\n+\t\t\t\t.build();\n+\t}\n+\n+\t@Override\n+\tpublic RunnableFuture<IResult> createEvaluation(\n+\t\tfinal IItemCollection items, final IPreferenceValueProvider preferenceValueProvider,\n+\t\tfinal IResultValueProvider dependencyResults) {\n+\t\tFutureTask<IResult> evaluationTask = new FutureTask<>(new Callable<IResult>() {\n+\t\t\t@Override\n+\t\t\tpublic IResult call() throws Exception {\n+\t\t\t\treturn getResult(items, preferenceValueProvider, dependencyResults);\n+\t\t\t}\n+\t\t});\n+\t\treturn evaluationTask;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<TypedPreference<?>> getConfigurationAttributes() {\n+\t\treturn CONFIG_ATTRIBUTES;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<TypedResult<?>> getResults() {\n+\t\treturn RESULT_ATTRIBUTES;\n+\t}\n+\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/memory\/ZGCAllocationStallRule.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -322,0 +322,5 @@\n+\tpublic static final String ZGCAllocationStall_RULE_NAME = \"ZGCAllocationStall_RULE_NAME\"; \/\/$NON-NLS-1$\n+\tpublic static final String ZGCAllocationStallRule_CONFIG_INFO_LIMIT = \"ZGCAllocationStallRule_CONFIG_INFO_LIMIT\"; \/\/$NON-NLS-1$\n+\tpublic static final String ZGCAllocationStallRule_CONFIG_INFO_LIMIT_LONG = \"ZGCAllocationStallRule_CONFIG_INFO_LIMIT_LONG\"; \/\/$NON-NLS-1$\n+\tpublic static final String ZGCAllocationStallRule_CONFIG_WARN_LIMIT = \"ZGCAllocationStallRule_CONFIG_WARN_LIMIT\"; \/\/$NON-NLS-1$\n+\tpublic static final String ZGCAllocationStallRule_CONFIG_WARN_LIMIT_LONG = \"ZGCAllocationStallRule_CONFIG_WARN_LIMIT_LONG\"; \/\/$NON-NLS-1$\n@@ -479,1 +484,1 @@\n-\tpublic static final String MetaspaceOomRuleFactory_TEXT_CAUSE = \"MetaspaceOomRuleFactory_TEXT_CAUSE\"; \/\/$NON-NLS-1$\n+\tpublic static final String MetaspaceOomRuleFactory_TEXT_CAUSE = \"MetaspaceOomRuleFactory_TEXT_CAUSE\"; \/\/$NON-NLS-1$\t\n@@ -506,0 +511,3 @@\n+\tpublic static final String ZgcAllocationStall_TEXT_INFO = \"ZgcAllocationStall_TEXT_INFO\"; \/\/$NON-NLS-1$\n+\tpublic static final String ZgcAllocationStall_TEXT_WARN = \"ZgcAllocationStall_TEXT_WARN\"; \/\/$NON-NLS-1$\n+\tpublic static final String ZgcAllocationStall_TEXT_OK = \"ZgcAllocationStall_TEXT_OK\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/Messages.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-#  Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,1 @@\n+org.openjdk.jmc.flightrecorder.rules.jdk.memory.ZGCAllocationStallRule\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/resources\/META-INF\/services\/org.openjdk.jmc.flightrecorder.rules.IRule","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -754,0 +754,8 @@\n+ZGCAllocationStall_RULE_NAME=ZGC Allocation Stall\n+ZgcAllocationStall_TEXT_INFO=In ZGC, a type of concurrent Garbage Collection (GC) algorithm, GC threads run concurrently with application threads, resulting in minimal stop-the-world pauses. However, because these pauses are so brief, application threads may create objects faster than GC threads can reclaim memory. In such cases, the JVM temporarily stops the application threads from creating new objects. This 'stopping of object creation' is known as an \"Allocation Stall.\" \\n Allocation Stall occurs due to following reasons: \\n 1. Inefficient GC Algorithm: This is often the primary cause of Allocation Stall. Using a non-optimal GC algorithm or improper GC settings for your application's workload can lead to stalling. Earlier versions of ZGC (i.e. single-generation ZGC algorithm), are more prone to Allocation Stalls. \\n 2. High Object Allocation Rate: If your application creates objects at a very high rate, it can overwhelm the GC's ability to reclaim memory quickly enough, leading to stalls.\\n 3. Memory Fragmentation: Even if there is free memory, fragmentation in the heap can prevent large objects from being allocated, contributing to Allocation Stalls.\\n\n+ZgcAllocationStall_TEXT_WARN=\\nThere are {zgcAllocationStallCount} occurrence of Allocation Stall Events. Total time spent in waiting for memory to become available is {zgcAllocationStallTotalDuration} and the maximum duration is {zgcAllocationStallLongestDuration}\n+ZgcAllocationStall_TEXT_OK=There are no occurrence of Allocation Stall Events.\n+ZGCAllocationStallRule_CONFIG_INFO_LIMIT=ZGC Allocation Stall info limit\n+ZGCAllocationStallRule_CONFIG_INFO_LIMIT_LONG=The number of ZGC Allocation Stall events needed to trigger an info notice\n+ZGCAllocationStallRule_CONFIG_WARN_LIMIT=ZGC Allocation Stall warning limit\n+ZGCAllocationStallRule_CONFIG_WARN_LIMIT_LONG=The number of ZGC Allocation Stall events needed to trigger a warning\n\\ No newline at end of file\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/messages.properties","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+import static org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs.ZGC_ALLOCATION_STALL;\n@@ -162,0 +163,8 @@\n+\t\/\/ZGC\n+\tpublic static final IAggregator<IQuantity, ?> ZGC_ALLOCATION_STALL_COUNT = Aggregators.count(\n+\t\t\tMessages.getString(Messages.AGGR_ZGC_ALLOCATION_STALL_COUNT),\n+\t\t\tMessages.getString(Messages.AGGR_ZGC_ALLOCATION_STALL_COUNT_DESC), JdkFilters.ZGC_ALLOCATION_STALL);\n+\tpublic static final IAggregator<IQuantity, ?> LONGEST_ZGC_ALLOCATION_STALL = Aggregators.max(ZGC_ALLOCATION_STALL,\n+\t\t\tDURATION);\n+\tpublic static final IAggregator<IQuantity, ?> TOTAL_ZGC_ALLOCATION_STALL = Aggregators.sum(ZGC_ALLOCATION_STALL,\n+\t\t\tDURATION);\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkAggregators.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+\tpublic static final IItemFilter ZGC_ALLOCATION_STALL = ItemFilters.type(JdkTypeIDs.ZGC_ALLOCATION_STALL);\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkFilters.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -111,0 +111,2 @@\n+\tpublic static final String ZGC_ALLOCATION_STALL = PREFIX + \"ZAllocationStall\";\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkTypeIDs.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,1 +141,3 @@\n-\tpublic static final String AGGR_ALL_COLLECTION_GC_COUNT_DESC = \"AGGR_ALL_COLLECTION_GC_COUNT_DESC\"; \/\/$NON-NLS-1$\t\n+\tpublic static final String AGGR_ALL_COLLECTION_GC_COUNT_DESC = \"AGGR_ALL_COLLECTION_GC_COUNT_DESC\"; \/\/$NON-NLS-1$\n+\tpublic static final String AGGR_ZGC_ALLOCATION_STALL_COUNT = \"AGGR_ZGC_ALLOCATION_STALL_COUNT\"; \/\/$NON-NLS-1$\n+\tpublic static final String AGGR_ZGC_ALLOCATION_STALL_COUNT_DESC = \"AGGR_ZGC_ALLOCATION_STALL_COUNT_DESC\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/messages\/internal\/Messages.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -470,0 +470,2 @@\n+AGGR_ZGC_ALLOCATION_STALL_COUNT=ZGC Allocation Stall Count\n+AGGR_ZGC_ALLOCATION_STALL_COUNT_DESC=The count of ZGC Allocation Stall.\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/jdk\/messages\/internal\/messages.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-            <summary>Java class metadata is allocated in native memory (metaspace). When the amount of native memory needed for a class metadata exceeds MaxMetaSpaceSize, a java.lang.OutOfMemoryError exception with a detail MetaSpace is thrown. The amount of metaspace that can be used for class metadata is limited by the parameter MaxMetaSpaceSize, which is specified on the command line.The metaspace was not exhausted during this recording.<\/summary>\n+            <summary>Java class metadata is allocated in native memory (metaspace). When the amount of native memory needed for a class metadata exceeds MaxMetaspaceSize, a java.lang.OutOfMemoryError exception with a detail Metaspace is thrown. The amount of metaspace that can be used for class metadata is limited by the parameter MaxMetaspaceSize, which is specified on the command line.The metaspace was not exhausted during this recording.<\/summary>\n@@ -322,0 +322,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/baseline\/Generated_One_JfrRuleBaseline.xml","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -331,0 +331,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -633,0 +637,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -907,0 +915,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -1179,0 +1191,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -1471,0 +1487,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -1742,0 +1762,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -2011,0 +2035,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -2334,0 +2362,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -2630,0 +2662,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -2915,0 +2951,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -3200,0 +3240,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -3487,0 +3531,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -3752,0 +3800,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -4016,0 +4068,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -4336,0 +4392,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -4606,0 +4666,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -4876,0 +4940,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -5195,0 +5263,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -5513,0 +5585,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -5787,0 +5863,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -6109,0 +6189,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -6475,0 +6559,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -6751,0 +6839,4 @@\n+        <rule>\n+            <id>ZGCAllocationStallRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/baseline\/JfrRuleBaseline.xml","additions":92,"deletions":0,"binary":false,"changes":92,"status":"modified"}]}