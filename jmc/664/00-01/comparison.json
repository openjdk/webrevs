{"files":[{"patch":"@@ -84,0 +84,4 @@\n+\tpublic static final TypedResult<IQuantity> ZGC_ALLOCATION_STALL_PER_MINUTE = new TypedResult<>(\n+\t\t\t\"zgcAllocationStallPerMinute\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ZGCAllocationStallRule_RATE),\n+\t\t\tMessages.getString(Messages.ZGCAllocationStallRule_RATE_LONG), UnitLookup.NUMBER, IQuantity.class);\n@@ -85,1 +89,1 @@\n-\t\t\t\"allocation.stall.info.limit\", \/\/$NON-NLS-1$\n+\t\t\t\"allocation.stall.rate.info.limit\", \/\/$NON-NLS-1$\n@@ -91,1 +95,1 @@\n-\t\t\t\"allocation.stall.warning.limit\", \/\/$NON-NLS-1$\n+\t\t\t\"allocation.stall.rate.warning.limit\", \/\/$NON-NLS-1$\n@@ -101,1 +105,1 @@\n-\t\t\tZGC_ALLOCATION_STALL_TOTAL_DURATION);\n+\t\t\tZGC_ALLOCATION_STALL_TOTAL_DURATION, ZGC_ALLOCATION_STALL_PER_MINUTE);\n@@ -133,2 +137,12 @@\n-\t\t\tdouble score = RulesToolkit.mapExp100(zgcAllocationStallCount.clampedLongValueIn(UnitLookup.NUMBER_UNITY),\n-\t\t\t\t\tinfoLimit, warningLimit);\n+\n+\t\t\t\/\/Calculate time after JVM Start\n+\t\t\tIQuantity timeAfterJVMStart = RulesToolkit.getEarliestStartTime(items)\n+\t\t\t\t\t.subtract(items.getAggregate(JdkAggregators.JVM_START_TIME));\n+\n+\t\t\t\/\/Calculate Stall Per minute\n+\t\t\tIQuantity stallPerMinute = UnitLookup.NUMBER_UNITY\n+\t\t\t\t\t.quantity(zgcAllocationStallTotalDuration.doubleValueIn(UnitLookup.MINUTE)\n+\t\t\t\t\t\t\t\/ timeAfterJVMStart.doubleValueIn(UnitLookup.MINUTE));\n+\n+\t\t\tdouble score = RulesToolkit.mapExp100(stallPerMinute.clampedLongValueIn(UnitLookup.NUMBER_UNITY), infoLimit,\n+\t\t\t\t\twarningLimit);\n@@ -142,1 +156,2 @@\n-\t\t\t\t\t.addResult(ZGC_ALLOCATION_STALL_LONGEST_DURATION, zgcAllocationStallLongestDuration).build();\n+\t\t\t\t\t.addResult(ZGC_ALLOCATION_STALL_LONGEST_DURATION, zgcAllocationStallLongestDuration)\n+\t\t\t\t\t.addResult(ZGC_ALLOCATION_STALL_PER_MINUTE, stallPerMinute).build();\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/memory\/ZGCAllocationStallRule.java","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -325,0 +325,2 @@\n+\tpublic static final String ZGCAllocationStallRule_RATE = \"ZGCAllocationStallRule_RATE\"; \/\/$NON-NLS-1$\n+\tpublic static final String ZGCAllocationStallRule_RATE_LONG = \"ZGCAllocationStallRule_RATE_LONG\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/Messages.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -754,3 +754,3 @@\n-ZGCAllocationStall_RULE_NAME=ZGC Allocation Stall\n-ZgcAllocationStall_TEXT_INFO=In ZGC, a type of concurrent Garbage Collection (GC) algorithm, GC threads run concurrently with application threads, resulting in minimal stop-the-world pauses. However, because these pauses are so brief, application threads may create objects faster than GC threads can reclaim memory. In such cases, the JVM temporarily stops the application threads from creating new objects. This 'stopping of object creation' is known as an \"Allocation Stall.\" \\n Allocation Stall occurs due to following reasons: \\n 1. Inefficient GC Algorithm: This is often the primary cause of Allocation Stall. Using a non-optimal GC algorithm or improper GC settings for your application's workload can lead to stalling. Earlier versions of ZGC (i.e. single-generation ZGC algorithm), are more prone to Allocation Stalls. \\n 2. High Object Allocation Rate: If your application creates objects at a very high rate, it can overwhelm the GC's ability to reclaim memory quickly enough, leading to stalls.\\n 3. Memory Fragmentation: Even if there is free memory, fragmentation in the heap can prevent large objects from being allocated, contributing to Allocation Stalls.\\n\n-ZgcAllocationStall_TEXT_WARN=\\nThere are {zgcAllocationStallCount} occurrence of Allocation Stall Events. Total time spent in waiting for memory to become available is {zgcAllocationStallTotalDuration} and the maximum duration is {zgcAllocationStallLongestDuration}\n+ZGCAllocationStall_RULE_NAME=ZGC Allocation Stall Rate\n+ZgcAllocationStall_TEXT_INFO=In ZGC, a type of concurrent Garbage Collection (GC) algorithm, GC threads run concurrently with application threads, resulting in minimal stop-the-world pauses. However application threads can overrun the GC threads, allocating objects faster than GC threads can reclaim memory. in such cases, the JVM temporarily stops allocating application threads. This is called \"Allocation Stall\".\\n Allocation Stalls occurs due to the following reasons:\\n 1. High Object Allocation Rate: if your application creates objects at a very high rate, it can overwhelm the GC's ability to reclaim memory quickly enough, leading to stalls\\n 2. Java Heap size is not sufficient: Having more free room in the heap can give more time for GC threads to perform their GC cycle and reclaim memory to satisfy new allocations happening concurrently.\\n 3. Insufficient resources available for the GC threads: number of GC threads or the CPU allocated for them is not enough to finish the GC cycle and reclaim the memory compared to allocations done by application threads.\\n\n+ZgcAllocationStall_TEXT_WARN=\\nThere are {zgcAllocationStallCount} occurrence of Allocation Stall Events. Total time spent in waiting for memory to become available is {zgcAllocationStallTotalDuration} and the maximum duration is {zgcAllocationStallLongestDuration}. The rate of allocation stall per minute is {zgcAllocationStallPerMinute}.\n@@ -758,4 +758,6 @@\n-ZGCAllocationStallRule_CONFIG_INFO_LIMIT=ZGC Allocation Stall info limit\n-ZGCAllocationStallRule_CONFIG_INFO_LIMIT_LONG=The number of ZGC Allocation Stall events needed to trigger an info notice\n-ZGCAllocationStallRule_CONFIG_WARN_LIMIT=ZGC Allocation Stall warning limit\n-ZGCAllocationStallRule_CONFIG_WARN_LIMIT_LONG=The number of ZGC Allocation Stall events needed to trigger a warning\n\\ No newline at end of file\n+ZGCAllocationStallRule_CONFIG_INFO_LIMIT=ZGC Allocation Stall Rate info limit\n+ZGCAllocationStallRule_CONFIG_INFO_LIMIT_LONG=The rate of ZGC Allocation Stall events needed to trigger an info notice\n+ZGCAllocationStallRule_CONFIG_WARN_LIMIT=ZGC Allocation Stall Rate warning limit\n+ZGCAllocationStallRule_CONFIG_WARN_LIMIT_LONG=The rate of ZGC Allocation Stall events needed to trigger a warning\n+ZGCAllocationStallRule_RATE=Allocation Stall per minute\n+ZGCAllocationStallRule_RATE_LONG=The rate of ZGC Allocation Stall duration based on the time from when JVM was started\n\\ No newline at end of file\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/messages.properties","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"}]}