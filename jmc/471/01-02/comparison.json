{"files":[{"patch":"@@ -1,114 +1,114 @@\n-\/*\r\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\r\n- * Copyright (c) 2023 SAP SE. All rights reserved.\r\n- *\r\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n- *\r\n- * The contents of this file are subject to the terms of either the Universal Permissive License\r\n- * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\r\n- *\r\n- * or the following license:\r\n- *\r\n- * Redistribution and use in source and binary forms, with or without modification, are permitted\r\n- * provided that the following conditions are met:\r\n- *\r\n- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\r\n- * and the following disclaimer.\r\n- *\r\n- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\r\n- * conditions and the following disclaimer in the documentation and\/or other materials provided with\r\n- * the distribution.\r\n- *\r\n- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\r\n- * endorse or promote products derived from this software without specific prior written permission.\r\n- *\r\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\r\n- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\r\n- * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\r\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\r\n- * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n- *\/\r\n-\r\n-package org.openjdk.jmc.agent.test;\r\n-\r\n-import java.io.IOException;\r\n-import java.lang.management.ManagementFactory;\r\n-import java.lang.reflect.Method;\r\n-\r\n-import javax.management.JMX;\r\n-import javax.management.ObjectName;\r\n-\r\n-import org.junit.Assert;\r\n-import org.junit.Test;\r\n-import org.openjdk.jmc.agent.jmx.AgentControllerMXBean;\r\n-import org.openjdk.jmc.agent.test.util.TestToolkit;\r\n-\r\n-public class TestDynamicallyLoadedClasses {\r\n-\r\n-\tprivate static final String AGENT_OBJECT_NAME = \"org.openjdk.jmc.jfr.agent:type=AgentController\";\r\n-\r\n-\tprivate static final String XML_TEST_DESCRIPTION = \"<jfragent>\" + \"<config>\" + \"<classprefix>\"\r\n-\t\t\t+ \"__JFRTestDynamicallyLoadedClasses\" + \"<\/classprefix>\" + \"<allowconverter>\" + true + \"<\/allowconverter>\"\r\n-\t\t\t+ \"<\/config>\" + \"<events>\" + \"<event id=\\\"demo.jfr.test.dynamic\\\">\"\t+ \"<label>\" + \"JFR Dynamic\" + \"<\/label>\"\r\n-\t\t\t+ \"<description>\" + \"desc\" + \"<\/description>\" + \"<path>\" + \"demo\/dynamic\" + \"<\/path>\" +  \"<class>\"\r\n-\t\t\t+ Target.class.getName() + \"<\/class>\" + \"<method>\" + \"<name>\" + \"testStaticWithParameter\" + \"<\/name>\"\r\n-\t\t\t+ \"<descriptor>\" + \"(I)Ljava\/lang\/Object;\" + \"<\/descriptor>\" + \"<returnvalue>\" + \"<name>\" + \"val\"\r\n-\t\t\t+ \"<\/name>\"\t+ \"<description>\" + \"value\" + \"<\/description>\" + \"<converter>\"\r\n-\t\t\t+ TestDynamicallyLoadedClasses.class.getName() + \"<\/converter>\" + \"<\/returnvalue>\" + \"<\/method>\"\r\n-\t\t\t+ \"<location>\" + \"WRAP\" + \"<\/location>\" + \"<\/event>\" + \"<\/events>\" + \"<\/jfragent>\";\r\n-\r\n-\tprivate static int sum = 0;\r\n-\r\n-\t@Test\r\n-\tpublic void testIntrumentationOfDynamicallyLoadedClass() throws Exception {\r\n-\t\t\/\/ Load the class when we are not tracking it yet.\r\n-\t\tClassLoader c = new TargetLoader();\r\n-\t\tClass<?> cls = c.loadClass(Target.class.getName());\r\n-\t\tMethod m = cls.getDeclaredMethod(\"testStaticWithParameter\", int.class);\r\n-\r\n-\t\tAssert.assertNotEquals(Target.class.getClassLoader(), cls.getClassLoader());\r\n-\t\t\r\n-\t\tAgentControllerMXBean mbean = JMX.newMXBeanProxy(ManagementFactory.getPlatformMBeanServer(),\r\n-\t\t\t\tnew ObjectName(AGENT_OBJECT_NAME), AgentControllerMXBean.class, false);\r\n-\t\tmbean.defineEventProbes(XML_TEST_DESCRIPTION);\r\n-\r\n-\t\t\/\/ Use the convert method to determine if we instrumented both classes.\r\n-\t\tm.invoke(null, Integer.valueOf(1));\r\n-\t\tTarget.testStaticWithParameter(2);\r\n-\r\n-\t\t\/\/ Check both calls were tracked\r\n-\t\tAssert.assertEquals(3, sum);\r\n-\t}\r\n-\r\n-\tpublic static int convert(Object o) {\r\n-\t\tint v = ((Integer) o).intValue();\r\n-\t\tsum += v;\r\n-\t\treturn v;\r\n-\t}\r\n-\r\n-\tprivate static class TargetLoader extends ClassLoader {\r\n-\t\t@Override\r\n-\t\tpublic Class<?> loadClass(String name) throws ClassNotFoundException {\r\n-\t\t\tif (name.equals(Target.class.getName())) {\r\n-\t\t\t\ttry {\r\n-\t\t\t\t\treturn defineClass(Target.class.getName(), TestToolkit.getByteCode(Target.class), 0,\r\n-\t\t\t\t\t\t\tTestToolkit.getByteCode(Target.class).length);\r\n-\t\t\t\t} catch (ClassFormatError | IOException e) {\r\n-\t\t\t\t\tthrow new ClassNotFoundException();\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\r\n-\t\t\treturn TargetLoader.class.getClassLoader().loadClass(name);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tpublic static class Target {\r\n-\t\tpublic static Object testStaticWithParameter(int p) {\r\n-\t\t\tSystem.out.println(\"Called with parameter \" + p);\r\n-\t\t\treturn Integer.valueOf(p);\r\n-\t\t}\r\n-\t}\r\n-}\r\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+package org.openjdk.jmc.agent.test;\n+\n+import java.io.IOException;\n+import java.lang.management.ManagementFactory;\n+import java.lang.reflect.Method;\n+\n+import javax.management.JMX;\n+import javax.management.ObjectName;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.openjdk.jmc.agent.jmx.AgentControllerMXBean;\n+import org.openjdk.jmc.agent.test.util.TestToolkit;\n+\n+public class TestDynamicallyLoadedClasses {\n+\n+\tprivate static final String AGENT_OBJECT_NAME = \"org.openjdk.jmc.jfr.agent:type=AgentController\";\n+\n+\tprivate static final String XML_TEST_DESCRIPTION = \"<jfragent>\" + \"<config>\" + \"<classprefix>\"\n+\t\t\t+ \"__JFRTestDynamicallyLoadedClasses\" + \"<\/classprefix>\" + \"<allowconverter>\" + true + \"<\/allowconverter>\"\n+\t\t\t+ \"<\/config>\" + \"<events>\" + \"<event id=\\\"demo.jfr.test.dynamic\\\">\" + \"<label>\" + \"JFR Dynamic\" + \"<\/label>\"\n+\t\t\t+ \"<description>\" + \"desc\" + \"<\/description>\" + \"<path>\" + \"demo\/dynamic\" + \"<\/path>\" + \"<class>\"\n+\t\t\t+ Target.class.getName() + \"<\/class>\" + \"<method>\" + \"<name>\" + \"testStaticWithParameter\" + \"<\/name>\"\n+\t\t\t+ \"<descriptor>\" + \"(I)Ljava\/lang\/Object;\" + \"<\/descriptor>\" + \"<returnvalue>\" + \"<name>\" + \"val\"\n+\t\t\t+ \"<\/name>\" + \"<description>\" + \"value\" + \"<\/description>\" + \"<converter>\"\n+\t\t\t+ TestDynamicallyLoadedClasses.class.getName() + \"<\/converter>\" + \"<\/returnvalue>\" + \"<\/method>\"\n+\t\t\t+ \"<location>\" + \"WRAP\" + \"<\/location>\" + \"<\/event>\" + \"<\/events>\" + \"<\/jfragent>\";\n+\n+\tprivate static int sum = 0;\n+\n+\t@Test\n+\tpublic void testIntrumentationOfDynamicallyLoadedClass() throws Exception {\n+\t\t\/\/ Load the class when we are not tracking it yet.\n+\t\tClassLoader c = new TargetLoader();\n+\t\tClass<?> cls = c.loadClass(Target.class.getName());\n+\t\tMethod m = cls.getDeclaredMethod(\"testStaticWithParameter\", int.class);\n+\n+\t\tAssert.assertNotEquals(Target.class.getClassLoader(), cls.getClassLoader());\n+\n+\t\tAgentControllerMXBean mbean = JMX.newMXBeanProxy(ManagementFactory.getPlatformMBeanServer(),\n+\t\t\t\tnew ObjectName(AGENT_OBJECT_NAME), AgentControllerMXBean.class, false);\n+\t\tmbean.defineEventProbes(XML_TEST_DESCRIPTION);\n+\n+\t\t\/\/ Use the convert method to determine if we instrumented both classes.\n+\t\tm.invoke(null, Integer.valueOf(1));\n+\t\tTarget.testStaticWithParameter(2);\n+\n+\t\t\/\/ Check both calls were tracked\n+\t\tAssert.assertEquals(3, sum);\n+\t}\n+\n+\tpublic static int convert(Object o) {\n+\t\tint v = ((Integer) o).intValue();\n+\t\tsum += v;\n+\t\treturn v;\n+\t}\n+\n+\tprivate static class TargetLoader extends ClassLoader {\n+\t\t@Override\n+\t\tpublic Class<?> loadClass(String name) throws ClassNotFoundException {\n+\t\t\tif (name.equals(Target.class.getName())) {\n+\t\t\t\ttry {\n+\t\t\t\t\treturn defineClass(Target.class.getName(), TestToolkit.getByteCode(Target.class), 0,\n+\t\t\t\t\t\t\tTestToolkit.getByteCode(Target.class).length);\n+\t\t\t\t} catch (ClassFormatError | IOException e) {\n+\t\t\t\t\tthrow new ClassNotFoundException();\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn TargetLoader.class.getClassLoader().loadClass(name);\n+\t\t}\n+\t}\n+\n+\tpublic static class Target {\n+\t\tpublic static Object testStaticWithParameter(int p) {\n+\t\t\tSystem.out.println(\"Called with parameter \" + p);\n+\t\t\treturn Integer.valueOf(p);\n+\t\t}\n+\t}\n+}\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/test\/TestDynamicallyLoadedClasses.java","additions":114,"deletions":114,"binary":false,"changes":228,"status":"modified"}]}