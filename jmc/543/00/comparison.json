{"files":[{"patch":"@@ -3,1 +3,1 @@\n-   Copyright (c) 2018, 2021 Oracle and\/or its affiliates. All rights reserved.\n+   Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -976,0 +976,16 @@\n+\t\t\t\t<\/table>\n+\t\t\t\t<filter showFilter=\"false\" showSearch=\"true\" \/>\n+\t\t\t<\/state>\n+\t\t<\/page>\n+\t\t<page factory=\"org.openjdk.jmc.flightrecorder.ui.agents\"\n+\t\t\tid=\"org.openjdk.jmc.flightrecorder.ui.agents\">\n+\t\t\t<state>\n+\t\t\t\t<table sortColumn=\"initializationTime:timestamp\">\n+\t\t\t\t\t<column id=\"initializationTime:timestamp\" width=\"150\" sortAscending=\"true\"\/>\n+\t\t\t\t\t<column id=\"startTime:timestamp\" hidden=\"true\" width=\"150\" \/>\n+\t\t\t\t\t<column id=\"(endTime):timestamp\" hidden=\"true\" width=\"150\" \/>\n+\t\t\t\t\t<column id=\"(eventType):type\" width=\"100\" \/>\n+\t\t\t\t\t<column id=\"name:text\" width=\"410\"\/>\n+\t\t\t\t\t<column id=\"options:text\" width=\"160\"\/>\n+\t\t\t\t\t<column id=\"dynamic:boolean\" width=\"100\"\/>\n+\t\t\t\t\t<column id=\"initializationDuration:timespan\" width=\"130\"\/>\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/defaultPages.xml","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/icons\/pages\/agent.png","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"application\/org.openjdk.jmc.console.agent\/icons\/agent.png","status":"copied"},{"patch":"","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/icons\/pages\/agent@2x.png","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"application\/org.openjdk.jmc.console.agent\/icons\/agent@2x.png","status":"copied"},{"patch":"@@ -3,1 +3,1 @@\n-   Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+   Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -313,0 +313,4 @@\n+      <factory\n+            class=\"org.openjdk.jmc.flightrecorder.ui.pages.AgentsPage$AgentsPageFactory\"\n+            id=\"org.openjdk.jmc.flightrecorder.ui.agents\">\n+      <\/factory>\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/plugin.xml","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -815,0 +815,2 @@\n+\t\tcase IGNORE:\n+\t\t\treturn ResultOverview.ICON_IGNORE;\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/common\/DataPageToolkit.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,0 +140,1 @@\n+\tpublic static final String PAGE_AGENT = \"pages\/agent.png\"; \/\/$NON-NLS-1$\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/common\/ImageConstants.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+\tpublic static String AgentsPage_PAGE_NAME;\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/messages\/internal\/Messages.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.ui.pages;\n+\n+import org.eclipse.jface.resource.ImageDescriptor;\n+import org.openjdk.jmc.common.IState;\n+import org.openjdk.jmc.common.item.IItemFilter;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkFilters;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkQueries;\n+import org.openjdk.jmc.flightrecorder.rules.util.JfrRuleTopics;\n+import org.openjdk.jmc.flightrecorder.ui.FlightRecorderUI;\n+import org.openjdk.jmc.flightrecorder.ui.IDataPageFactory;\n+import org.openjdk.jmc.flightrecorder.ui.IDisplayablePage;\n+import org.openjdk.jmc.flightrecorder.ui.IPageContainer;\n+import org.openjdk.jmc.flightrecorder.ui.IPageDefinition;\n+import org.openjdk.jmc.flightrecorder.ui.StreamModel;\n+import org.openjdk.jmc.flightrecorder.ui.common.ImageConstants;\n+import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;\n+\n+public class AgentsPage extends DistinctItemsPage {\n+\tpublic static class AgentsPageFactory implements IDataPageFactory {\n+\n+\t\t@Override\n+\t\tpublic String getName(IState state) {\n+\t\t\treturn Messages.AgentsPage_PAGE_NAME;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic ImageDescriptor getImageDescriptor(IState state) {\n+\t\t\treturn FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.PAGE_AGENT);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String[] getTopics(IState state) {\n+\t\t\treturn new String[] {JfrRuleTopics.AGENT_INFORMATION};\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic IDisplayablePage createPage(IPageDefinition dpd, StreamModel items, IPageContainer editor) {\n+\t\t\treturn new AgentsPage(dpd, items, editor);\n+\t\t}\n+\t}\n+\n+\tpublic AgentsPage(IPageDefinition dpd, StreamModel items, IPageContainer editor) {\n+\t\tsuper(dpd, items, editor);\n+\t\tsetTableDefinition(JdkQueries.AGENTS);\n+\t}\n+\n+\t@Override\n+\tpublic IItemFilter getDefaultSelectionFilter() {\n+\t\treturn JdkFilters.AGENTS;\n+\t}\n+}\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/pages\/AgentsPage.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-#  Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+AgentsPage_PAGE_NAME=Agents\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/ui\/messages\/internal\/messages.properties","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import static org.openjdk.jmc.common.unit.UnitLookup.NUMBER_UNITY;\n+\n@@ -36,0 +38,1 @@\n+\tprivate final static ITypedQuantity<LinearUnit> ZERO = NUMBER_UNITY.quantity(0);\n@@ -56,0 +59,8 @@\n+\n+\tpublic static IQuantity nullSafe(IQuantity quantity) {\n+\t\tif (quantity != null) {\n+\t\t\treturn quantity;\n+\t\t} else {\n+\t\t\treturn ZERO;\n+\t\t}\n+\t}\n","filename":"core\/org.openjdk.jmc.common\/src\/main\/java\/org\/openjdk\/jmc\/common\/unit\/QuantitiesToolkit.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.rules.jdk.agent;\n+\n+import static org.openjdk.jmc.common.unit.UnitLookup.NUMBER;\n+import static org.openjdk.jmc.common.unit.UnitLookup.NUMBER_UNITY;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RunnableFuture;\n+\n+import org.openjdk.jmc.common.item.Aggregators;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.item.ItemFilters;\n+import org.openjdk.jmc.common.item.PersistableItemFilter.Kind;\n+import org.openjdk.jmc.common.unit.IQuantity;\n+import org.openjdk.jmc.common.unit.QuantitiesToolkit;\n+import org.openjdk.jmc.common.unit.UnitLookup;\n+import org.openjdk.jmc.common.util.IPreferenceValueProvider;\n+import org.openjdk.jmc.common.util.TypedPreference;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkAttributes;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;\n+import org.openjdk.jmc.flightrecorder.rules.IResult;\n+import org.openjdk.jmc.flightrecorder.rules.IResultValueProvider;\n+import org.openjdk.jmc.flightrecorder.rules.IRule;\n+import org.openjdk.jmc.flightrecorder.rules.ResultBuilder;\n+import org.openjdk.jmc.flightrecorder.rules.Severity;\n+import org.openjdk.jmc.flightrecorder.rules.TypedResult;\n+import org.openjdk.jmc.flightrecorder.rules.jdk.messages.internal.Messages;\n+import org.openjdk.jmc.flightrecorder.rules.util.JfrRuleTopics;\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit.EventAvailability;\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit.RequiredEventsBuilder;\n+\n+public class DynamicallyLoadedAgentsRule implements IRule {\n+\tprivate static final String MULTIPLE_AGENTS_RESULT_ID = \"DynamicAgents\"; \/\/$NON-NLS-1$\n+\n+\tpublic static final TypedPreference<IQuantity> JAVA_WARNING_LIMIT = new TypedPreference<>(\n+\t\t\t\"agents.dynamic.java.warning.limit\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.DynamicallyLoadedAgentsRule_JAVA_WARNING_LIMIT),\n+\t\t\tMessages.getString(Messages.DynamicallyLoadedAgentsRule_JAVA_WARNING_LIMIT_LONG), NUMBER,\n+\t\t\tNUMBER_UNITY.quantity(0));\n+\n+\tpublic static final TypedPreference<IQuantity> NATIVE_WARNING_LIMIT = new TypedPreference<>(\n+\t\t\t\"agents.dynamic.native.warning.limit\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.DynamicallyLoadedAgentsRule_JAVA_WARNING_LIMIT),\n+\t\t\tMessages.getString(Messages.DynamicallyLoadedAgentsRule_JAVA_WARNING_LIMIT_LONG), NUMBER,\n+\t\t\tNUMBER_UNITY.quantity(0));\n+\n+\tprivate static final List<TypedPreference<?>> CONFIG_ATTRIBUTES = Arrays\n+\t\t\t.<TypedPreference<?>> asList(JAVA_WARNING_LIMIT, NATIVE_WARNING_LIMIT);\n+\n+\tprivate static final Map<String, EventAvailability> REQUIRED_EVENTS = RequiredEventsBuilder.create()\n+\t\t\t.addEventType(JdkTypeIDs.JAVA_AGENT, EventAvailability.ENABLED)\n+\t\t\t.addEventType(JdkTypeIDs.NATIVE_AGENT, EventAvailability.ENABLED).build();\n+\n+\tpublic static final TypedResult<IQuantity> JAVA_AGENT_COUNT = new TypedResult<>(\"javaDynamicAgentCount\", \/\/$NON-NLS-1$\n+\t\t\t\"Java Dynamic Agent Count\", \"The number of active dynamically loaded Java Agents.\", \/\/$NON-NLS-1$\n+\t\t\tUnitLookup.NUMBER, IQuantity.class);\n+\tpublic static final TypedResult<IQuantity> NATIVE_AGENT_COUNT = new TypedResult<>(\"nativeDynamicAgentCount\", \/\/$NON-NLS-1$\n+\t\t\t\"Native Dynamic Agent Count\", \"The number of active dynamically loaded native Agents.\", \/\/$NON-NLS-1$\n+\t\t\tUnitLookup.TIMESTAMP, IQuantity.class);\n+\tpublic static final TypedResult<IQuantity> TOTAL_AGENT_COUNT = new TypedResult<>(\"totalDynamicAgentCount\", \/\/$NON-NLS-1$\n+\t\t\t\"Total Dynamic Agent Count\", \"The total number of active dynamically loaded Agents.\", \/\/$NON-NLS-1$\n+\t\t\tUnitLookup.TIMESTAMP, IQuantity.class);\n+\n+\tprivate static final Collection<TypedResult<?>> RESULT_ATTRIBUTES = Arrays\n+\t\t\t.<TypedResult<?>> asList(TypedResult.SCORE, JAVA_AGENT_COUNT, NATIVE_AGENT_COUNT, TOTAL_AGENT_COUNT);\n+\n+\tprivate IResult getResult(\n+\t\tIItemCollection items, IPreferenceValueProvider valueProvider, IResultValueProvider resultProvider) {\n+\t\tIItemCollection dynamicEvents = items\n+\t\t\t\t.apply(ItemFilters.and(ItemFilters.type(JdkTypeIDs.JAVA_AGENT, JdkTypeIDs.NATIVE_AGENT),\n+\t\t\t\t\t\tItemFilters.buildComparisonFilter(Kind.EQUALS, JdkAttributes.AGENT_DYNAMIC, Boolean.TRUE)));\n+\n+\t\tIQuantity javaCountQuantity = QuantitiesToolkit.nullSafe(\n+\t\t\t\tdynamicEvents.apply(ItemFilters.type(JdkTypeIDs.JAVA_AGENT)).getAggregate(Aggregators.count()));\n+\t\tIQuantity nativeCountQuantity = QuantitiesToolkit.nullSafe(\n+\t\t\t\tdynamicEvents.apply(ItemFilters.type(JdkTypeIDs.NATIVE_AGENT)).getAggregate(Aggregators.count()));\n+\t\tIQuantity totalCountQuantity = javaCountQuantity.add(nativeCountQuantity);\n+\n+\t\tlong javaWarningLimit = valueProvider.getPreferenceValue(JAVA_WARNING_LIMIT).clampedFloorIn(NUMBER_UNITY);\n+\t\tlong nativeWarningLimit = valueProvider.getPreferenceValue(JAVA_WARNING_LIMIT).clampedFloorIn(NUMBER_UNITY);\n+\t\tlong javaCount = javaCountQuantity.longValue();\n+\t\tlong nativeCount = nativeCountQuantity.longValue();\n+\n+\t\tif (javaCount > javaWarningLimit || nativeCount > nativeWarningLimit) {\n+\t\t\treturn ResultBuilder.createFor(this, valueProvider).setSeverity(Severity.WARNING)\n+\t\t\t\t\t.setSummary(Messages.getString(Messages.DynamicallyLoadedAgentsRule_TEXT_SUMMARY))\n+\t\t\t\t\t.setExplanation(Messages.getString(Messages.DynamicallyLoadedAgentsRule_TEXT_EXPLANATION))\n+\t\t\t\t\t.setSolution(Messages.getString(Messages.DynamicallyLoadedAgentsRule_TEXT_SOLUTION))\n+\t\t\t\t\t.addResult(JAVA_AGENT_COUNT, javaCountQuantity).addResult(NATIVE_AGENT_COUNT, nativeCountQuantity)\n+\t\t\t\t\t.addResult(TOTAL_AGENT_COUNT, totalCountQuantity)\n+\t\t\t\t\t.addResult(TypedResult.SCORE, NUMBER_UNITY.quantity(75)).build();\n+\t\t}\n+\t\treturn ResultBuilder.createFor(this, valueProvider).setSeverity(Severity.OK)\n+\t\t\t\t.setSummary(Messages.getString(Messages.DynamicallyLoadedAgentsRule_TEXT_OK))\n+\t\t\t\t.addResult(JAVA_AGENT_COUNT, javaCountQuantity).addResult(NATIVE_AGENT_COUNT, nativeCountQuantity)\n+\t\t\t\t.addResult(TOTAL_AGENT_COUNT, totalCountQuantity).build();\n+\t}\n+\n+\t@Override\n+\tpublic RunnableFuture<IResult> createEvaluation(\n+\t\tfinal IItemCollection items, final IPreferenceValueProvider valueProvider,\n+\t\tfinal IResultValueProvider resultProvider) {\n+\t\tFutureTask<IResult> evaluationTask = new FutureTask<>(new Callable<IResult>() {\n+\t\t\t@Override\n+\t\t\tpublic IResult call() throws Exception {\n+\t\t\t\treturn getResult(items, valueProvider, resultProvider);\n+\t\t\t}\n+\t\t});\n+\t\treturn evaluationTask;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<TypedPreference<?>> getConfigurationAttributes() {\n+\t\treturn CONFIG_ATTRIBUTES;\n+\t}\n+\n+\t@Override\n+\tpublic String getId() {\n+\t\treturn MULTIPLE_AGENTS_RESULT_ID;\n+\t}\n+\n+\t@Override\n+\tpublic String getName() {\n+\t\treturn Messages.getString(Messages.DynamicallyLoadedAgentsRule_RULE_NAME);\n+\t}\n+\n+\t@Override\n+\tpublic String getTopic() {\n+\t\treturn JfrRuleTopics.AGENT_INFORMATION;\n+\t}\n+\n+\t@Override\n+\tpublic Map<String, EventAvailability> getRequiredEvents() {\n+\t\treturn REQUIRED_EVENTS;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<TypedResult<?>> getResults() {\n+\t\treturn RESULT_ATTRIBUTES;\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/agent\/DynamicallyLoadedAgentsRule.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.rules.jdk.agent;\n+\n+import static org.openjdk.jmc.common.unit.UnitLookup.NUMBER;\n+import static org.openjdk.jmc.common.unit.UnitLookup.NUMBER_UNITY;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RunnableFuture;\n+\n+import org.openjdk.jmc.common.item.Aggregators;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.item.ItemFilters;\n+import org.openjdk.jmc.common.unit.IQuantity;\n+import org.openjdk.jmc.common.unit.QuantitiesToolkit;\n+import org.openjdk.jmc.common.unit.UnitLookup;\n+import org.openjdk.jmc.common.util.IPreferenceValueProvider;\n+import org.openjdk.jmc.common.util.TypedPreference;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;\n+import org.openjdk.jmc.flightrecorder.rules.IResult;\n+import org.openjdk.jmc.flightrecorder.rules.IResultValueProvider;\n+import org.openjdk.jmc.flightrecorder.rules.IRule;\n+import org.openjdk.jmc.flightrecorder.rules.ResultBuilder;\n+import org.openjdk.jmc.flightrecorder.rules.Severity;\n+import org.openjdk.jmc.flightrecorder.rules.TypedResult;\n+import org.openjdk.jmc.flightrecorder.rules.jdk.messages.internal.Messages;\n+import org.openjdk.jmc.flightrecorder.rules.util.JfrRuleTopics;\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit.EventAvailability;\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit.RequiredEventsBuilder;\n+\n+public class MultipleAgentsRule implements IRule {\n+\tprivate static final String MULTIPLE_AGENTS_RESULT_ID = \"MultipleAgents\"; \/\/$NON-NLS-1$\n+\n+\tpublic static final TypedPreference<IQuantity> JAVA_WARNING_LIMIT = new TypedPreference<>(\n+\t\t\t\"agents.muliple.java.warning.limit\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.MultipleAgentsRule_JAVA_WARNING_LIMIT),\n+\t\t\tMessages.getString(Messages.MultipleAgentsRule_JAVA_WARNING_LIMIT_LONG), NUMBER, NUMBER_UNITY.quantity(1));\n+\n+\tpublic static final TypedPreference<IQuantity> NATIVE_WARNING_LIMIT = new TypedPreference<>(\n+\t\t\t\"agents.muliple.native.warning.limit\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.MultipleAgentsRule_JAVA_WARNING_LIMIT),\n+\t\t\tMessages.getString(Messages.MultipleAgentsRule_JAVA_WARNING_LIMIT_LONG), NUMBER, NUMBER_UNITY.quantity(1));\n+\n+\tprivate static final List<TypedPreference<?>> CONFIG_ATTRIBUTES = Arrays\n+\t\t\t.<TypedPreference<?>> asList(JAVA_WARNING_LIMIT, NATIVE_WARNING_LIMIT);\n+\n+\tprivate static final Map<String, EventAvailability> REQUIRED_EVENTS = RequiredEventsBuilder.create()\n+\t\t\t.addEventType(JdkTypeIDs.JAVA_AGENT, EventAvailability.ENABLED)\n+\t\t\t.addEventType(JdkTypeIDs.NATIVE_AGENT, EventAvailability.ENABLED).build();\n+\n+\tpublic static final TypedResult<IQuantity> JAVA_AGENT_COUNT = new TypedResult<>(\"javaAgentCount\", \/\/$NON-NLS-1$\n+\t\t\t\"Java Agent Count\", \"The number of active Java Agents.\", \/\/$NON-NLS-1$\n+\t\t\tUnitLookup.NUMBER, IQuantity.class);\n+\tpublic static final TypedResult<IQuantity> NATIVE_AGENT_COUNT = new TypedResult<>(\"nativeAgentCount\", \/\/$NON-NLS-1$\n+\t\t\t\"Native Agent Count\", \"The number of active Native Agents.\", \/\/$NON-NLS-1$\n+\t\t\tUnitLookup.TIMESTAMP, IQuantity.class);\n+\tpublic static final TypedResult<IQuantity> TOTAL_AGENT_COUNT = new TypedResult<>(\"totalAgentCount\", \/\/$NON-NLS-1$\n+\t\t\t\"Total Agent Count\", \"The total number of active Agents.\", \/\/$NON-NLS-1$\n+\t\t\tUnitLookup.TIMESTAMP, IQuantity.class);\n+\n+\tprivate static final Collection<TypedResult<?>> RESULT_ATTRIBUTES = Arrays\n+\t\t\t.<TypedResult<?>> asList(TypedResult.SCORE, JAVA_AGENT_COUNT, NATIVE_AGENT_COUNT, TOTAL_AGENT_COUNT);\n+\n+\tprivate IResult getResult(\n+\t\tIItemCollection items, IPreferenceValueProvider valueProvider, IResultValueProvider resultProvider) {\n+\t\tIQuantity javaCountQuantity = QuantitiesToolkit\n+\t\t\t\t.nullSafe(items.apply(ItemFilters.type(JdkTypeIDs.JAVA_AGENT)).getAggregate(Aggregators.count()));\n+\t\tIQuantity nativeCountQuantity = QuantitiesToolkit\n+\t\t\t\t.nullSafe(items.apply(ItemFilters.type(JdkTypeIDs.NATIVE_AGENT)).getAggregate(Aggregators.count()));\n+\t\tIQuantity totalCountQuantity = javaCountQuantity.add(nativeCountQuantity);\n+\n+\t\tlong javaWarningLimit = valueProvider.getPreferenceValue(JAVA_WARNING_LIMIT).clampedFloorIn(NUMBER_UNITY);\n+\t\tlong nativeWarningLimit = valueProvider.getPreferenceValue(JAVA_WARNING_LIMIT).clampedFloorIn(NUMBER_UNITY);\n+\t\tlong javaCount = javaCountQuantity.longValue();\n+\t\tlong nativeCount = nativeCountQuantity.longValue();\n+\n+\t\tif (javaCount > javaWarningLimit || nativeCount > nativeWarningLimit) {\n+\t\t\treturn ResultBuilder.createFor(this, valueProvider).setSeverity(Severity.WARNING)\n+\t\t\t\t\t.setSummary(Messages.getString(Messages.MultipleAgentsRule_TEXT_SUMMARY))\n+\t\t\t\t\t.setExplanation(Messages.getString(Messages.MultipleAgentsRule_TEXT_EXPLANATION))\n+\t\t\t\t\t.setSolution(Messages.getString(Messages.MultipleAgentsRule_TEXT_SOLUTION))\n+\t\t\t\t\t.addResult(JAVA_AGENT_COUNT, javaCountQuantity).addResult(NATIVE_AGENT_COUNT, nativeCountQuantity)\n+\t\t\t\t\t.addResult(TOTAL_AGENT_COUNT, totalCountQuantity)\n+\t\t\t\t\t.addResult(TypedResult.SCORE, NUMBER_UNITY.quantity(55)).build();\n+\t\t}\n+\t\treturn ResultBuilder.createFor(this, valueProvider).setSeverity(Severity.OK)\n+\t\t\t\t.setSummary(Messages.getString(Messages.MultipleAgentsRule_TEXT_OK))\n+\t\t\t\t.addResult(JAVA_AGENT_COUNT, javaCountQuantity).addResult(NATIVE_AGENT_COUNT, nativeCountQuantity)\n+\t\t\t\t.addResult(TOTAL_AGENT_COUNT, totalCountQuantity).build();\n+\t}\n+\n+\t@Override\n+\tpublic RunnableFuture<IResult> createEvaluation(\n+\t\tfinal IItemCollection items, final IPreferenceValueProvider valueProvider,\n+\t\tfinal IResultValueProvider resultProvider) {\n+\t\tFutureTask<IResult> evaluationTask = new FutureTask<>(new Callable<IResult>() {\n+\t\t\t@Override\n+\t\t\tpublic IResult call() throws Exception {\n+\t\t\t\treturn getResult(items, valueProvider, resultProvider);\n+\t\t\t}\n+\t\t});\n+\t\treturn evaluationTask;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<TypedPreference<?>> getConfigurationAttributes() {\n+\t\treturn CONFIG_ATTRIBUTES;\n+\t}\n+\n+\t@Override\n+\tpublic String getId() {\n+\t\treturn MULTIPLE_AGENTS_RESULT_ID;\n+\t}\n+\n+\t@Override\n+\tpublic String getName() {\n+\t\treturn Messages.getString(Messages.MultipleAgentsRule_RULE_NAME);\n+\t}\n+\n+\t@Override\n+\tpublic String getTopic() {\n+\t\treturn JfrRuleTopics.AGENT_INFORMATION;\n+\t}\n+\n+\t@Override\n+\tpublic Map<String, EventAvailability> getRequiredEvents() {\n+\t\treturn REQUIRED_EVENTS;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<TypedResult<?>> getResults() {\n+\t\treturn RESULT_ATTRIBUTES;\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/agent\/MultipleAgentsRule.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -212,0 +212,9 @@\n+\tpublic static final String DynamicallyLoadedAgentsRule_RULE_NAME = \"DynamicallyLoadedAgentsRule_RULE_NAME\"; \/\/$NON-NLS-1$\n+\tpublic static final String DynamicallyLoadedAgentsRule_TEXT_EXPLANATION = \"DynamicallyLoadedAgentsRule_TEXT_EXPLANATION\"; \/\/$NON-NLS-1$\n+\tpublic static final String DynamicallyLoadedAgentsRule_TEXT_OK = \"DynamicallyLoadedAgentsRule_TEXT_OK\"; \/\/$NON-NLS-1$\n+\tpublic static final String DynamicallyLoadedAgentsRule_TEXT_SOLUTION = \"DynamicallyLoadedAgentsRule_TEXT_SOLUTION\"; \/\/$NON-NLS-1$\n+\tpublic static final String DynamicallyLoadedAgentsRule_TEXT_SUMMARY = \"DynamicallyLoadedAgentsRule_TEXT_SUMMARY\"; \/\/$NON-NLS-1$\n+\tpublic static final String DynamicallyLoadedAgentsRule_JAVA_WARNING_LIMIT = \"DynamicallyLoadedAgentsRule_JAVA_WARNING_LIMIT\"; \/\/$NON-NLS-1$;\n+\tpublic static final String DynamicallyLoadedAgentsRule_JAVA_WARNING_LIMIT_LONG = \"DynamicallyLoadedAgentsRule_JAVA_WARNING_LIMIT_LONG\"; \/\/$NON-NLS-1$;\n+\tpublic static final String DynamicallyLoadedAgentsRule_NATIVE_WARNING_LIMIT = \"DynamicallyLoadedAgentsRule_NATIVE_WARNING_LIMIT\"; \/\/$NON-NLS-1$;\n+\tpublic static final String DynamicallyLoadedAgentsRule_NATIVE_WARNING_LIMIT_LONG = \"DynamicallyLoadedAgentsRule_NATIVE_WARNING_LIMIT_LONG\"; \/\/$NON-NLS-1$;\n@@ -483,0 +492,9 @@\n+\tpublic static final String MultipleAgentsRule_RULE_NAME = \"MultipleAgentsRule_RULE_NAME\"; \/\/$NON-NLS-1$\n+\tpublic static final String MultipleAgentsRule_TEXT_EXPLANATION = \"MultipleAgentsRule_TEXT_EXPLANATION\"; \/\/$NON-NLS-1$\n+\tpublic static final String MultipleAgentsRule_TEXT_OK = \"MultipleAgentsRule_TEXT_OK\"; \/\/$NON-NLS-1$\n+\tpublic static final String MultipleAgentsRule_TEXT_SOLUTION = \"MultipleAgentsRule_TEXT_SOLUTION\"; \/\/$NON-NLS-1$\n+\tpublic static final String MultipleAgentsRule_TEXT_SUMMARY = \"MultipleAgentsRule_TEXT_SUMMARY\"; \/\/$NON-NLS-1$\n+\tpublic static final String MultipleAgentsRule_JAVA_WARNING_LIMIT = \"MultipleAgentsRule_JAVA_WARNING_LIMIT\"; \/\/$NON-NLS-1$;\n+\tpublic static final String MultipleAgentsRule_JAVA_WARNING_LIMIT_LONG = \"MultipleAgentsRule_JAVA_WARNING_LIMIT_LONG\"; \/\/$NON-NLS-1$;\n+\tpublic static final String MultipleAgentsRule_NATIVE_WARNING_LIMIT = \"MultipleAgentsRule_NATIVE_WARNING_LIMIT\"; \/\/$NON-NLS-1$;\n+\tpublic static final String MultipleAgentsRule_NATIVE_WARNING_LIMIT_LONG = \"MultipleAgentsRule_NATIVE_WARNING_LIMIT_LONG\"; \/\/$NON-NLS-1$;\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/Messages.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-#  Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+org.openjdk.jmc.flightrecorder.rules.jdk.agent.DynamicallyLoadedAgentsRule\n+org.openjdk.jmc.flightrecorder.rules.jdk.agent.MultipleAgentsRule\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/resources\/META-INF\/services\/org.openjdk.jmc.flightrecorder.rules.IRule","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-#  Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,0 +210,9 @@\n+DynamicallyLoadedAgentsRule_JAVA_WARNING_LIMIT=Java Dynamic Agent Limit\n+DynamicallyLoadedAgentsRule_JAVA_WARNING_LIMIT_LONG=The maximum allowed amount of dynamically loaded java agents active before warning.\n+DynamicallyLoadedAgentsRule_NATIVE_WARNING_LIMIT=Native Dynamic Agent Limit\n+DynamicallyLoadedAgentsRule_NATIVE_WARNING_LIMIT_LONG=The maximum allowed amount of dynamically loaded native agents active before warning.\n+DynamicallyLoadedAgentsRule_RULE_NAME=Dynamically Loaded Agents\n+DynamicallyLoadedAgentsRule_TEXT_EXPLANATION=There are {totalDynamicAgentCount} dynamically loaded agents active ({javaDynamicAgentCount} java, {nativeDynamicAgentCount} native). Ensure their intentional loading on the agents page and investigate their origins.\n+DynamicallyLoadedAgentsRule_TEXT_OK=An acceptable number of java and native agents ({totalDynamicAgentCount} total) were dynamically loaded!\n+DynamicallyLoadedAgentsRule_TEXT_SOLUTION=Remove any unnecessary agents, and configure any remaining agents to be loaded at startup. Dynamic agent loading can pose a security risk. Disable it with -XX:-EnableDynamicAgentLoading.\n+DynamicallyLoadedAgentsRule_TEXT_SUMMARY=More agents dynamically loaded than allowed in the rule configuration!\t\n@@ -528,0 +537,9 @@\n+MultipleAgentsRule_JAVA_WARNING_LIMIT=Java Agent Limit\n+MultipleAgentsRule_JAVA_WARNING_LIMIT_LONG=The maximum allowed amount of java agents active before warning.\n+MultipleAgentsRule_NATIVE_WARNING_LIMIT=Native Agent Limit\n+MultipleAgentsRule_NATIVE_WARNING_LIMIT_LONG=The maximum allowed amount of native agents active before warning.\n+MultipleAgentsRule_RULE_NAME=Multiple Agents\n+MultipleAgentsRule_TEXT_EXPLANATION=There are {totalAgentCount} agents active ({javaAgentCount} java, {nativeAgentCount} native). Please confirm that loading these agents was intentional on the agents page.\n+MultipleAgentsRule_TEXT_OK=An acceptable number of java and native agents ({totalAgentCount} total) were loaded!\n+MultipleAgentsRule_TEXT_SOLUTION=Remove any agents that are not necessary.\n+MultipleAgentsRule_TEXT_SUMMARY=More agents loaded than allowed in the rule configuration!\t\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/messages.properties","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+\tpublic static final String AGENT_INFORMATION = \"agent_information\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/util\/JfrRuleTopics.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1330,0 +1330,15 @@\n+\n+\tpublic static final IAttribute<Boolean> AGENT_DYNAMIC = attr(\"dynamic\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_AGENT_DYNAMIC), Messages.getString(Messages.ATTR_AGENT_DYNAMIC_DESC),\n+\t\t\tFLAG);\n+\tpublic static final IAttribute<String> AGENT_NAME = attr(\"name\", Messages.getString(Messages.ATTR_AGENT_NAME), \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_AGENT_NAME_DESC), PLAIN_TEXT);\n+\tpublic static final IAttribute<String> AGENT_OPTIONS = attr(\"options\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_AGENT_OPTIONS), Messages.getString(Messages.ATTR_AGENT_OPTIONS_DESC),\n+\t\t\tPLAIN_TEXT);\n+\tpublic static final IAttribute<IQuantity> AGENT_INITIALIZATION_TIME = attr(\"initializationTime\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_AGENT_INITIALIZATION_TIME),\n+\t\t\tMessages.getString(Messages.ATTR_AGENT_INITIALIZATION_TIME_DESC), TIMESTAMP);\n+\tpublic static final IAttribute<IQuantity> AGENT_INITIALIZATION_DURATION = attr(\"initializationDuration\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_AGENT_INITIALIZATION_DURATION),\n+\t\t\tMessages.getString(Messages.ATTR_AGENT_INITIALIZATION_DURATION_DESC), TIMESPAN);\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkAttributes.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,0 +158,1 @@\n+\tpublic static final IItemFilter AGENTS = ItemFilters.type(JdkTypeIDs.JAVA_AGENT, JdkTypeIDs.NATIVE_AGENT);\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkFilters.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,5 @@\n+import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.AGENT_DYNAMIC;\n+import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.AGENT_INITIALIZATION_DURATION;\n+import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.AGENT_INITIALIZATION_TIME;\n+import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.AGENT_NAME;\n+import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.AGENT_OPTIONS;\n@@ -133,0 +138,1 @@\n+import org.openjdk.jmc.flightrecorder.JfrAttributes;\n@@ -240,1 +246,4 @@\n-\n+\tpublic static final IItemQuery AGENTS = fromWhere(JdkFilters.AGENTS)\n+\t\t\t.select(AGENT_INITIALIZATION_TIME, AGENT_NAME, AGENT_OPTIONS, AGENT_DYNAMIC, AGENT_INITIALIZATION_DURATION,\n+\t\t\t\t\tJfrAttributes.START_TIME, JfrAttributes.END_TIME, JfrAttributes.EVENT_TYPE)\n+\t\t\t.build();\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkQueries.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -214,0 +214,3 @@\n+\tpublic static final String JAVA_AGENT = PREFIX + \"JavaAgent\";\n+\tpublic static final String NATIVE_AGENT = PREFIX + \"NativeAgent\";\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkTypeIDs.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -208,0 +208,10 @@\n+\tpublic static final String ATTR_AGENT_DYNAMIC = \"ATTR_AGENT_DYNAMIC\"; \/\/$NON-NLS-1$\n+\tpublic static final String ATTR_AGENT_DYNAMIC_DESC = \"ATTR_AGENT_DYNAMIC_DESC\"; \/\/$NON-NLS-1$;\n+\tpublic static final String ATTR_AGENT_INITIALIZATION_TIME = \"ATTR_AGENT_INITIALIZATION_TIME\"; \/\/$NON-NLS-1$\n+\tpublic static final String ATTR_AGENT_INITIALIZATION_TIME_DESC = \"ATTR_AGENT_INITIALIZATION_TIME_DESC\"; \/\/$NON-NLS-1$;\n+\tpublic static final String ATTR_AGENT_INITIALIZATION_DURATION = \"ATTR_AGENT_INITIALIZATION_DURATION\"; \/\/$NON-NLS-1$;\n+\tpublic static final String ATTR_AGENT_INITIALIZATION_DURATION_DESC = \"ATTR_AGENT_INITIALIZATION_DURATION_DESC\"; \/\/$NON-NLS-1$;\n+\tpublic static final String ATTR_AGENT_NAME = \"ATTR_AGENT_NAME\";\n+\tpublic static final String ATTR_AGENT_NAME_DESC = \"ATTR_AGENT_NAME_DESC\";\n+\tpublic static final String ATTR_AGENT_OPTIONS = \"ATTR_AGENT_OPTIONS\"; \/\/$NON-NLS-1$;\n+\tpublic static final String ATTR_AGENT_OPTIONS_DESC = \"ATTR_AGENT_OPTIONS_DESC\"; \/\/$NON-NLS-1$;\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/messages\/internal\/Messages.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-#  Copyright (c) 2018, 2023 Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,11 @@\n+\n+ATTR_AGENT_DYNAMIC=Dynamic\n+ATTR_AGENT_DYNAMIC_DESC=If the agent attached to the JVM dynamically after startup\n+ATTR_AGENT_INITIALIZATION_TIME=Initialization Time\n+ATTR_AGENT_INITIALIZATION_TIME_DESC=The time the JVM initialized the agent\n+ATTR_AGENT_INITIALIZATION_DURATION=Initialization Duration\n+ATTR_AGENT_INITIALIZATION_DURATION_DESC=For a Java agent, the time it took to initialize the agent (i.e. run the premain or agentmain method). For a native agent, the time it took to run the VMInit event callback. For a dynamically loaded native agent, the time it took to run Agent_OnAttach.\n+ATTR_AGENT_NAME=Name\n+ATTR_AGENT_NAME_DESC=The name of the agent (normally the path to the agent)\n+ATTR_AGENT_OPTIONS=Options\n+ATTR_AGENT_OPTIONS_DESC=Options provided to the agent\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/jdk\/messages\/internal\/messages.properties","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,326 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<reportcollection>\n+    <report>\n+        <file>allocation_10s_before.jfr<\/file>\n+        <rule>\n+            <id>Allocations.class<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The most allocated type is likely ''java.lang.Integer'', most commonly allocated by: &lt;ul&gt;&lt;li&gt;Integer java.lang.Integer.valueOf(int)&lt;\/li&gt;&lt;li&gt;void Allocator.go()&lt;\/li&gt;&lt;li&gt;void Allocator.main(String[])&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Frequently allocated types are good places to start when trying to reduce garbage collections. Look at where the most common types are being allocated to see if many instances are created along the same call path. Try to reduce the number of instances created by invoking the most commonly taken paths less.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>Allocations.thread<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The most allocations were likely done by thread ''main'' at: &lt;ul&gt;&lt;li&gt;Integer java.lang.Integer.valueOf(int)&lt;\/li&gt;&lt;li&gt;void Allocator.go()&lt;\/li&gt;&lt;li&gt;void Allocator.main(String[])&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Many allocations performed by the same thread might indicate a problem in a multi-threaded program. Look at the stack traces for the thread with the highest allocation rate. See if the allocation rate can be brought down, or balanced among the active threads.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>ApplicationHalts<\/id>\n+            <severity>OK<\/severity>\n+            <summary>Application efficiency was not highly affected by halts.<\/summary>\n+            <explanation>The highest ratio of application halts to execution time was 0.192 % during 4\/26\/2018 12:10:29.000 PM – 12:11:29 PM. 28.1 % of the halts were for reasons other than GC. The halts ratio for the entire recording was 1.16 %. 28.1 % of the total halts were for reasons other than GC.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>BufferLost<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No Flight Recorder buffers were lost during the recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>BytecodeVerification<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The application ran with bytecode verification enabled.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLeak<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLoading<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CodeCache<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CompareCpu<\/id>\n+            <severity>OK<\/severity>\n+            <summary>An average CPU load of 1 % was caused by other processes for during 4\/26\/2018 12:10:33.000 PM – 12:10:34 PM.<\/summary>\n+            <explanation>The application performance can be affected when the machine is under heavy load and there are other processes that use CPU or other resources on the same computer. To profile representatively or get higher throughput, shut down other resource intensive processes running on the machine.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>CompressedOops<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The settings for Compressed Oops were OK.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>ContextSwitch<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DMSIncident<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DebugNonSafepoints<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DiscouragedVmOptions<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No problems were found with the VM options.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>DumpReason<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DuplicateFlags<\/id>\n+            <severity>OK<\/severity>\n+            <summary>There were no duplicate JVM flags on the command line.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>DynamicAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Exceptions<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The program generated 0 exceptions per second during 4\/26\/2018 12:10:30.000 PM – 12:10:31 PM.<\/summary>\n+            <explanation>Throwing exceptions is more expensive than normal code execution, which means that they should only be used for exceptional situations. Investigate the thrown exceptions to see if any of them can be avoided with a non-exceptional control flow.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>Fatal Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FewSampledThreads<\/id>\n+            <severity>Information<\/severity>\n+            <summary>There are fewer sampled threads than the total number of hardware threads (cores).<\/summary>\n+            <explanation>1 threads with at least 4 method samples were found, but the machine has 32 hardware threads (cores). The application might benefit from a higher level of parallelism. This could also be caused by threads doing something else than running Java code, for example running native code or spending time in the JVM internals.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FileRead<\/id>\n+            <severity>OK<\/severity>\n+            <summary>There are no file read events in this recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>FileWrite<\/id>\n+            <severity>OK<\/severity>\n+            <summary>There are no file write events in this recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>FinalizersRun<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FlightRecordingSupport<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The JVM version used for this recording has full Flight Recorder support.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>FullGc<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No Stop-the-World, Full GC events detected.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>GarbageCollectionInfoRule<\/id>\n+            <severity>OK<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcFreedRatio<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The ratio between memory freed by garbage collections per second and liveset is 6,501 %. This may be excessive.<\/summary>\n+            <explanation>242 MiB per second was freed by garbage collections during 4\/26\/2018 12:10:29.000 PM – 12:10:39 PM. The average liveset was 3.72 MiB. This may be excessive.\n+If the garbage collector can free a lot of memory, it may be because the application allocates a lot of short lived objects. Investigate the allocation stack traces to see which code paths cause the most allocations, and see if they can be reduced.\n+This recording is only 9.903 s long, consider creating a recording longer than 20 s for improved rule accuracy.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcLocker<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No GCs were affected by the GC Locker.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>GcOptions<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No problems were found with the GC configuration.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseRatio<\/id>\n+            <severity>OK<\/severity>\n+            <summary>Application efficiency was not highly affected by GC pauses.<\/summary>\n+            <explanation>The highest ratio between garbage collection pauses and execution time was 0.138 % during 4\/26\/2018 12:10:29.000 PM – 12:11:29 PM. The garbage collection pause ratio of the entire recording was 0.836 %.<\/explanation>\n+            <solution>Pause times may be reduced by increasing the heap size or by trying to reduce allocation.<\/solution>\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>OK<\/severity>\n+            <summary>All GCs completed before the GC pause target time of 200 ms.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>GcStall<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No indications that the garbage collector could not keep up with the workload were detected.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>HeapContent<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HeapDump<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HeapInspectionGc<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The JVM did not perform any heap inspection GCs.<\/summary>\n+            <explanation>This is good since they usually take a lot of time.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>HighGc<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The JVM was paused for 100 % during 4\/26\/2018 12:10:36.933.000 PM – .944<\/summary>\n+            <explanation>The time spent performing garbage collection may be reduced by increasing the heap size or by trying to reduce allocation.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>HighJvmCpu<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The JVM does not seem to cause a lot of CPU load.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingLiveSet<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No memory leaks were detected.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingMetaSpaceLiveSet<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The class data does not seem to increase during the recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>JavaBlocking<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>LongGcPause<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The longest GC pause was 11.003 ms.<\/summary>\n+            <explanation\/>\n+        <\/rule>\n+        <rule>\n+            <id>LowOnPhysicalMemory<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The system did not run low on physical memory during this recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>ManagementAgent<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ManyRunningProcesses<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MetaspaceOom<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The metaspace was not exhausted during this recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>MethodProfiling<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No methods where optimization would be particularly efficient could be detected.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>MultipleAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Options<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No undocumented, deprecated or non-recommended option flags were detected.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>OverAggressiveRecordingSetting<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInArguments<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The recording does not seem to contain passwords in the application arguments.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInEnvironment<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInSystemProperties<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PrimitiveToObjectConversion<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ProcessStarted<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SocketRead<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SocketWrite<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>StackdepthSetting<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No stack traces were truncated in this recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>StringDeduplication<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SystemGc<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No garbage collections were caused by System.gc().<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>TlabAllocationRatio<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No object allocations outside of TLABs detected.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>VMOperations<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No excessively long VM operations were found in this recording (the longest was 30.318 ms).<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocation<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocationPause<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No revocation of biased locks found.<\/summary>\n+        <\/rule>\n+    <\/report>\n+<\/reportcollection>\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/baseline\/Generated_One_JfrRuleBaseline.xml","additions":326,"deletions":0,"binary":false,"changes":326,"status":"added"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2020, 2023 Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Datadog, Inc. All rights reserved.\n@@ -48,0 +48,1 @@\n+import org.openjdk.jmc.flightrecorder.rules.jdk.io.FileForceRule;\n@@ -50,1 +51,0 @@\n-import org.openjdk.jmc.flightrecorder.rules.jdk.io.FileForceRule;\n@@ -52,1 +52,0 @@\n-@SuppressWarnings(\"restriction\")\n@@ -84,1 +83,0 @@\n-\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/rules\/jdk\/TestFileReadWriteForceRule.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.test.rules.jdk.agent;\n+\n+import org.openjdk.jmc.common.item.IAccessorKey;\n+import org.openjdk.jmc.common.item.IItem;\n+import org.openjdk.jmc.common.item.IMemberAccessor;\n+import org.openjdk.jmc.common.util.MemberAccessorToolkit;\n+import org.openjdk.jmc.flightrecorder.test.rules.jdk.TestEvent;\n+\n+public class AgentTestEvent extends TestEvent {\n+\tprivate final boolean dynamic;\n+\tprivate final String name;\n+\tprivate final String options;\n+\n+\tpublic AgentTestEvent(String id, boolean dynamic, String name, String options) {\n+\t\tsuper(id);\n+\t\tthis.dynamic = dynamic;\n+\t\tthis.name = name;\n+\t\tthis.options = options;\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\t@Override\n+\tpublic <M> IMemberAccessor<M, IItem> getAccessor(IAccessorKey<M> attribute) {\n+\t\tif (\"dynamic\".equals(attribute.getIdentifier())) {\n+\t\t\treturn (IMemberAccessor<M, IItem>) MemberAccessorToolkit.<IItem, Boolean, Boolean> constant(dynamic);\n+\t\t} else if (\"name\".equals(attribute.getIdentifier())) {\n+\t\t\treturn (IMemberAccessor<M, IItem>) MemberAccessorToolkit.<IItem, String, String> constant(name);\n+\t\t} else if (\"options\".equals(attribute.getIdentifier())) {\n+\t\t\treturn (IMemberAccessor<M, IItem>) MemberAccessorToolkit.<IItem, String, String> constant(options);\n+\t\t}\n+\t\treturn null;\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/rules\/jdk\/agent\/AgentTestEvent.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.test.rules.jdk.agent;\n+\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.RunnableFuture;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.util.IPreferenceValueProvider;\n+import org.openjdk.jmc.flightrecorder.rules.IResult;\n+import org.openjdk.jmc.flightrecorder.rules.ResultProvider;\n+import org.openjdk.jmc.flightrecorder.rules.ResultToolkit;\n+import org.openjdk.jmc.flightrecorder.rules.Severity;\n+import org.openjdk.jmc.flightrecorder.rules.jdk.agent.DynamicallyLoadedAgentsRule;\n+import org.openjdk.jmc.flightrecorder.test.rules.jdk.MockEventCollection;\n+import org.openjdk.jmc.flightrecorder.test.rules.jdk.TestEvent;\n+\n+public class DynamicallyLoadedAgentsRuleTest {\n+\tprivate final static JavaAgentTestEvent JAVA_DYNAMIC_EVENT = new JavaAgentTestEvent(true,\n+\t\t\t\"\/my\/agent\/path\/java-agent.jar\", \"-my -options\");\n+\tprivate final static JavaAgentTestEvent JAVA_NON_DYNAMIC_EVENT = new JavaAgentTestEvent(false,\n+\t\t\t\"\/my\/agent\/path\/java-agent.jar\", \"-my -options\");\n+\tprivate final static NativeAgentTestEvent NATIVE_DYNAMIC_EVENT = new NativeAgentTestEvent(true,\n+\t\t\t\"\/my\/agent\/path\/native-agent.jar\", \"-some -other -options\");\n+\tprivate final static NativeAgentTestEvent NATIVE_NON_DYNAMIC_EVENT = new NativeAgentTestEvent(false,\n+\t\t\t\"\/my\/agent\/path\/native-agent.jar\", \"-some -other -options\");\n+\n+\t@Test\n+\tpublic void noAgentEvents() {\n+\t\tTestEvent[] testEvents = new TestEvent[] {};\n+\t\ttestDynamicallyLoadedAgentsRule(testEvents,\n+\t\t\t\t\"An acceptable number of java and native agents (0 total) were dynamically loaded!\");\n+\t}\n+\n+\t@Test\n+\tpublic void oneJavaDynamicAgent() {\n+\t\tTestEvent[] testEvents = new TestEvent[] {JAVA_DYNAMIC_EVENT};\n+\t\ttestDynamicallyLoadedAgentsRule(testEvents,\n+\t\t\t\t\"There are 1 dynamically loaded agents active (1 java, 0 native). Ensure their intentional loading on the agents page and investigate their origins.\");\n+\t}\n+\n+\t@Test\n+\tpublic void oneJavaNonDynamicAgent() {\n+\t\tTestEvent[] testEvents = new TestEvent[] {JAVA_NON_DYNAMIC_EVENT};\n+\t\ttestDynamicallyLoadedAgentsRule(testEvents,\n+\t\t\t\t\"An acceptable number of java and native agents (0 total) were dynamically loaded!\");\n+\t}\n+\n+\t@Test\n+\tpublic void oneNativeDynamicAgent() {\n+\t\tTestEvent[] testEvents = new TestEvent[] {NATIVE_DYNAMIC_EVENT};\n+\t\ttestDynamicallyLoadedAgentsRule(testEvents,\n+\t\t\t\t\"There are 1 dynamically loaded agents active (0 java, 1 native). Ensure their intentional loading on the agents page and investigate their origins.\");\n+\t}\n+\n+\t@Test\n+\tpublic void oneNativeNonDynamicAgent() {\n+\t\tTestEvent[] testEvents = new TestEvent[] {NATIVE_NON_DYNAMIC_EVENT};\n+\t\ttestDynamicallyLoadedAgentsRule(testEvents,\n+\t\t\t\t\"An acceptable number of java and native agents (0 total) were dynamically loaded!\");\n+\t}\n+\n+\t@Test\n+\tpublic void manyAgents() {\n+\t\tTestEvent[] testEvents = new TestEvent[] {JAVA_DYNAMIC_EVENT, JAVA_NON_DYNAMIC_EVENT, NATIVE_DYNAMIC_EVENT,\n+\t\t\t\tNATIVE_NON_DYNAMIC_EVENT};\n+\t\ttestDynamicallyLoadedAgentsRule(testEvents,\n+\t\t\t\t\"There are 2 dynamically loaded agents active (1 java, 1 native). Ensure their intentional loading on the agents page and investigate their origins.\");\n+\t}\n+\n+\tprivate void testDynamicallyLoadedAgentsRule(TestEvent[] testEvents, String descriptionExpected) {\n+\t\tIItemCollection events = new MockEventCollection(testEvents);\n+\t\tDynamicallyLoadedAgentsRule dynamicAgentsRule = new DynamicallyLoadedAgentsRule();\n+\t\tRunnableFuture<IResult> future = dynamicAgentsRule.createEvaluation(events,\n+\t\t\t\tIPreferenceValueProvider.DEFAULT_VALUES, new ResultProvider());\n+\t\ttry {\n+\t\t\tfuture.run();\n+\t\t\tIResult res = future.get();\n+\t\t\tString message;\n+\t\t\tif (res.getSeverity() == Severity.OK) {\n+\t\t\t\tmessage = ResultToolkit.populateMessage(res, res.getSummary(), false);\n+\t\t\t} else {\n+\t\t\t\tmessage = ResultToolkit.populateMessage(res, res.getExplanation(), false);\n+\t\t\t}\n+\t\t\tAssert.assertEquals(descriptionExpected, message);\n+\t\t} catch (InterruptedException | ExecutionException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t}\n+\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/rules\/jdk\/agent\/DynamicallyLoadedAgentsRuleTest.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.test.rules.jdk.agent;\n+\n+import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;\n+\n+public class JavaAgentTestEvent extends AgentTestEvent {\n+\tpublic JavaAgentTestEvent(boolean dynamic, String name, String options) {\n+\t\tsuper(JdkTypeIDs.JAVA_AGENT, dynamic, name, options);\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/rules\/jdk\/agent\/JavaAgentTestEvent.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.test.rules.jdk.agent;\n+\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.RunnableFuture;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.util.IPreferenceValueProvider;\n+import org.openjdk.jmc.flightrecorder.rules.IResult;\n+import org.openjdk.jmc.flightrecorder.rules.ResultProvider;\n+import org.openjdk.jmc.flightrecorder.rules.ResultToolkit;\n+import org.openjdk.jmc.flightrecorder.rules.Severity;\n+import org.openjdk.jmc.flightrecorder.rules.jdk.agent.MultipleAgentsRule;\n+import org.openjdk.jmc.flightrecorder.test.rules.jdk.MockEventCollection;\n+import org.openjdk.jmc.flightrecorder.test.rules.jdk.TestEvent;\n+\n+public class MultipleAgentsRuleTest {\n+\tprivate final static JavaAgentTestEvent JAVA_EVENT = new JavaAgentTestEvent(true, \"\/my\/agent\/path\/java-agent.jar\",\n+\t\t\t\"-my -options\");\n+\tprivate final static JavaAgentTestEvent ANOTHER_JAVA_EVENT = new JavaAgentTestEvent(true,\n+\t\t\t\"\/my\/otheragent\/path\/java-agent.jar\", \"\");\n+\tprivate final static NativeAgentTestEvent NATIVE_EVENT = new NativeAgentTestEvent(true,\n+\t\t\t\"\/my\/agent\/path\/native-agent.jar\", \"-some -other -options\");\n+\n+\t@Test\n+\tpublic void noAgentEvents() {\n+\t\tTestEvent[] testEvents = new TestEvent[] {};\n+\t\ttestMultipleAgentsRule(testEvents, \"An acceptable number of java and native agents (0 total) were loaded!\");\n+\t}\n+\n+\t@Test\n+\tpublic void oneJavaAgent() {\n+\t\tTestEvent[] testEvents = new TestEvent[] {JAVA_EVENT};\n+\t\ttestMultipleAgentsRule(testEvents, \"An acceptable number of java and native agents (1 total) were loaded!\");\n+\t}\n+\n+\t@Test\n+\tpublic void oneJavaOneNativeAgent() {\n+\t\tTestEvent[] testEvents = new TestEvent[] {JAVA_EVENT, NATIVE_EVENT};\n+\t\ttestMultipleAgentsRule(testEvents, \"An acceptable number of java and native agents (2 total) were loaded!\");\n+\t}\n+\n+\t@Test\n+\tpublic void manyAgents() {\n+\t\tTestEvent[] testEvents = new TestEvent[] {JAVA_EVENT, ANOTHER_JAVA_EVENT, NATIVE_EVENT};\n+\t\ttestMultipleAgentsRule(testEvents,\n+\t\t\t\t\"There are 3 agents active (2 java, 1 native). Please confirm that loading these agents was intentional on the agents page.\");\n+\t}\n+\n+\tprivate void testMultipleAgentsRule(TestEvent[] testEvents, String descriptionExpected) {\n+\t\tIItemCollection events = new MockEventCollection(testEvents);\n+\t\tMultipleAgentsRule multipleAgentsRule = new MultipleAgentsRule();\n+\t\tRunnableFuture<IResult> future = multipleAgentsRule.createEvaluation(events,\n+\t\t\t\tIPreferenceValueProvider.DEFAULT_VALUES, new ResultProvider());\n+\t\ttry {\n+\t\t\tfuture.run();\n+\t\t\tIResult res = future.get();\n+\t\t\tString message;\n+\t\t\tif (res.getSeverity() == Severity.OK) {\n+\t\t\t\tmessage = ResultToolkit.populateMessage(res, res.getSummary(), false);\n+\t\t\t} else {\n+\t\t\t\tmessage = ResultToolkit.populateMessage(res, res.getExplanation(), false);\n+\t\t\t}\n+\t\t\tAssert.assertEquals(descriptionExpected, message);\n+\t\t} catch (InterruptedException | ExecutionException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t}\n+\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/rules\/jdk\/agent\/MultipleAgentsRuleTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.test.rules.jdk.agent;\n+\n+import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;\n+\n+public class NativeAgentTestEvent extends AgentTestEvent {\n+\tpublic NativeAgentTestEvent(boolean dynamic, String name, String options) {\n+\t\tsuper(JdkTypeIDs.NATIVE_AGENT, dynamic, name, options);\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/rules\/jdk\/agent\/NativeAgentTestEvent.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -82,0 +82,4 @@\n+        <rule>\n+            <id>DynamicAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -102,1 +106,1 @@\n-\t\t<rule>\n+        <rule>\n@@ -125,5 +129,0 @@\n-        <rule>\n-            <id>JfrPeriodicEventsFix<\/id>\n-            <severity>OK<\/severity>\n-            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n-        <\/rule>\n@@ -217,0 +216,5 @@\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n+        <\/rule>\n@@ -246,0 +250,4 @@\n+        <rule>\n+            <id>MultipleAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -397,0 +405,4 @@\n+        <rule>\n+            <id>DynamicAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -417,1 +429,1 @@\n-\t\t<rule>\n+        <rule>\n@@ -440,5 +452,0 @@\n-        <rule>\n-            <id>JfrPeriodicEventsFix<\/id>\n-            <severity>OK<\/severity>\n-            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n-        <\/rule>\n@@ -511,0 +518,5 @@\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n+        <\/rule>\n@@ -539,0 +551,4 @@\n+        <rule>\n+            <id>MultipleAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -681,0 +697,4 @@\n+        <rule>\n+            <id>DynamicAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -697,1 +717,1 @@\n-\t\t<rule>\n+        <rule>\n@@ -720,5 +740,0 @@\n-        <rule>\n-            <id>JfrPeriodicEventsFix<\/id>\n-            <severity>OK<\/severity>\n-            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n-        <\/rule>\n@@ -789,0 +804,5 @@\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n+        <\/rule>\n@@ -818,0 +838,4 @@\n+        <rule>\n+            <id>MultipleAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -885,1 +909,1 @@\n-        <file>flight_recording_hidden.jfr<\/file>\n+        <file>flight_recording_17eaMonitoredVM10440_3.jfr<\/file>\n@@ -889,1 +913,1 @@\n-            <summary>The most allocated type is likely ''byte[]'', most commonly allocated by: &lt;ul&gt;&lt;li&gt;void java.io.ByteArrayOutputStream.&amp;lt;init&amp;gt;(int)&lt;\/li&gt;&lt;li&gt;void java.io.ByteArrayOutputStream.&amp;lt;init&amp;gt;()&lt;\/li&gt;&lt;li&gt;void sun.management.jdp.JdpPacketWriter.&amp;lt;init&amp;gt;()&lt;\/li&gt;&lt;li&gt;byte[] sun.management.jdp.JdpJmxPacket.getPacketData()&lt;\/li&gt;&lt;li&gt;void sun.management.jdp.JdpBroadcaster.sendPacket(JdpPacket)&lt;\/li&gt;&lt;li&gt;void sun.management.jdp.JdpController$JDPControllerRunner.run()&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <summary>The most allocated type is likely ''java.lang.Object[]'', most commonly allocated by: &lt;ul&gt;&lt;li&gt;void java.io.ObjectOutputStream$HandleTable.growEntries()&lt;\/li&gt;&lt;li&gt;int java.io.ObjectOutputStream$HandleTable.assign(Object)&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n@@ -895,1 +919,1 @@\n-            <summary>The most allocations were likely done by thread ''AWT-EventQueue-0'' at: &lt;ul&gt;&lt;li&gt;void java.awt.EventQueue.dispatchEvent(AWTEvent)&lt;\/li&gt;&lt;li&gt;void java.awt.EventDispatchThread.pumpOneEventForFilters(int)&lt;\/li&gt;&lt;li&gt;void java.awt.EventDispatchThread.pumpEventsForFilter(int, Conditional, EventFilter)&lt;\/li&gt;&lt;li&gt;void java.awt.EventDispatchThread.pumpEventsForHierarchy(int, Conditional, Component)&lt;\/li&gt;&lt;li&gt;void java.awt.EventDispatchThread.pumpEvents(int, Conditional)&lt;\/li&gt;&lt;li&gt;void java.awt.EventDispatchThread.pumpEvents(Conditional)&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <summary>The most allocations were likely done by thread ''RMI TCP Connection(19)-192.168.29.191'' at: &lt;ul&gt;&lt;li&gt;void java.io.ObjectOutputStream$HandleTable.growEntries()&lt;\/li&gt;&lt;li&gt;int java.io.ObjectOutputStream$HandleTable.assign(Object)&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n@@ -900,1 +924,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>Application efficiency was not highly affected by halts.<\/summary>\n+            <explanation>The highest ratio of application halts to execution time was 0.123 % during 7\/13\/2021 6:23:54.000 AM – 6:24:54 AM. 74.7 % of the halts were for reasons other than GC. The halts ratio for the entire recording was 0.00705 %. 74.7 % of the total halts were for reasons other than GC.<\/explanation>\n@@ -909,2 +935,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The application ran with bytecode verification enabled.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -914,1 +939,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No classes with identical names have been loaded more times than the limit.<\/summary>\n@@ -918,1 +944,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No significant time was spent loading new classes during this recording.<\/summary>\n@@ -926,3 +953,1 @@\n-            <severity>Warning<\/severity>\n-            <summary>An average CPU load of 60 % was caused by other processes for during 4\/25\/2018 11:38:36.000 AM – 11:38:44 AM.<\/summary>\n-            <explanation>The application performance can be affected when the machine is under heavy load and there are other processes that use CPU or other resources on the same computer. To profile representatively or get higher throughput, shut down other resource intensive processes running on the machine.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -936,2 +961,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The program did not context switch excessively during the recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -945,4 +969,1 @@\n-            <severity>Information<\/severity>\n-            <summary>DebugNonSafepoints was not enabled.<\/summary>\n-            <explanation>If DebugNonSafepoints is not enabled, the method profiling data will be less accurate as threads that are not at safepoints will not be correctly sampled. There is a slight performance overhead when enabling these flags. For more information see [HotSpot Runtime Overview\/Thread Management](http:\/\/openjdk.java.net\/groups\/hotspot\/docs\/RuntimeOverview.html#Thread%20Management|outline]).<\/explanation>\n-            <solution>Use the following JVM flags to enable this: '-XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints'.<\/solution>\n+            <severity>Not Applicable<\/severity>\n@@ -960,2 +981,5 @@\n-            <severity>OK<\/severity>\n-            <summary>There were no duplicate JVM flags on the command line.<\/summary>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DynamicAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -969,3 +993,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The program generated 0 exceptions per second during 4\/25\/2018 11:38:36.000 AM – 11:38:37 AM.<\/summary>\n-            <explanation>Throwing exceptions is more expensive than normal code execution, which means that they should only be used for exceptional situations. Investigate the thrown exceptions to see if any of them can be avoided with a non-exceptional control flow.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -981,1 +1003,1 @@\n-\t\t<rule>\n+        <rule>\n@@ -991,1 +1013,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No long file write pauses were found in this recording (the longest was 22.875 μs).<\/summary>\n@@ -999,7 +1022,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The JVM version used for this recording has full Flight Recorder support.<\/summary>\n-        <\/rule>\n-        <rule>\n-            <id>JfrPeriodicEventsFix<\/id>\n-            <severity>OK<\/severity>\n-            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -1014,1 +1031,1 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n@@ -1018,1 +1035,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>Only 6 heap summary events were found, this rule requires at least 10 events to be able to calculate a relevant result. This likely means that only a few garbage collections occurred during the recording. Having few garbage collections is generally a good sign.<\/summary>\n@@ -1025,1 +1043,1 @@\n-            <id>GcOptions<\/id>\n+            <id>GcLocker<\/id>\n@@ -1027,1 +1045,1 @@\n-            <summary>No problems were found with the GC configuration.<\/summary>\n+            <summary>No GCs were affected by the GC Locker.<\/summary>\n@@ -1030,1 +1048,1 @@\n-            <id>GcPauseRatio<\/id>\n+            <id>GcOptions<\/id>\n@@ -1033,0 +1051,7 @@\n+        <rule>\n+            <id>GcPauseRatio<\/id>\n+            <severity>OK<\/severity>\n+            <summary>Application efficiency was not highly affected by GC pauses.<\/summary>\n+            <explanation>The highest ratio between garbage collection pauses and execution time was 0.0311 % during 7\/13\/2021 6:23:54.000 AM – 6:24:54 AM. The garbage collection pause ratio of the entire recording was 0.00178 %.<\/explanation>\n+            <solution>Pause times may be reduced by increasing the heap size or by trying to reduce allocation.<\/solution>\n+        <\/rule>\n@@ -1035,1 +1060,7 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>All GCs completed before the GC pause target time of 200 ms.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>GcStall<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No indications that the garbage collector could not keep up with the workload were detected.<\/summary>\n@@ -1039,1 +1070,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>Warning<\/severity>\n+            <summary>Most of the heap was used by only a few classes.<\/summary>\n+            <explanation>If the heap usage needs to be reduced, then this would be a good place to start.<\/explanation>\n@@ -1043,1 +1076,8 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No heap dump performed.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>HeapInspectionGc<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The JVM did not perform any heap inspection GCs.<\/summary>\n+            <explanation>This is good since they usually take a lot of time.<\/explanation>\n@@ -1047,1 +1087,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The JVM was paused for 100 % during 7\/13\/2021 6:23:56.617.000 AM – .630<\/summary>\n+            <explanation>The time spent performing garbage collection may be reduced by increasing the heap size or by trying to reduce allocation.<\/explanation>\n@@ -1051,2 +1093,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The JVM does not seem to cause a lot of CPU load.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -1057,0 +1098,1 @@\n+            <summary>Too few events to calculate the result.<\/summary>\n@@ -1060,1 +1102,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The class data does not seem to increase during the recording.<\/summary>\n@@ -1064,0 +1107,6 @@\n+            <severity>OK<\/severity>\n+            <summary>No excessive problems with lock contention found.<\/summary>\n+            <explanation>The following regular expression was used to exclude threads from this rule: ''(.*weblogic\\.socket\\.Muxer.*)''<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n@@ -1068,1 +1117,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The longest GC pause was 13.480 ms.<\/summary>\n+            <explanation\/>\n@@ -1072,3 +1123,2 @@\n-            <severity>Warning<\/severity>\n-            <summary>The maximum amount of used memory was 99.8 % of the physical memory available.<\/summary>\n-            <explanation>The maximum amount of memory used was 16 GiB. This is 99.8 % of the 16 GiB of physical memory available. Having little free memory may lead to swapping, which is very expensive. To avoid this, either decrease the memory usage or increase the amount of available memory.<\/explanation>\n+            <severity>OK<\/severity>\n+            <summary>The system did not run low on physical memory during this recording.<\/summary>\n@@ -1078,2 +1128,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No problems were found with the management agent settings.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -1087,1 +1136,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The metaspace was not exhausted during this recording.<\/summary>\n@@ -1094,0 +1144,4 @@\n+        <rule>\n+            <id>MultipleAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -1096,2 +1150,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No undocumented, deprecated or non-recommended option flags were detected.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -1101,2 +1154,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No problems were found with the recording settings.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -1106,2 +1158,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The recording does not seem to contain passwords in the application arguments.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -1111,4 +1162,1 @@\n-            <severity>Warning<\/severity>\n-            <summary>The environment variables in the recording may contain passwords.<\/summary>\n-            <explanation>The following suspicious environment variables were found in this recording: &lt;ul&gt;&lt;li&gt;P4PASSWD&lt;\/li&gt;&lt;\/ul&gt;. The following regular expression was used to exclude strings from this rule: ''(passworld|passwise)''.<\/explanation>\n-            <solution>If you wish to keep having passwords in your environment variables, but want to be able to share recordings without also sharing the passwords, please disable the ''Initial Environment Variable'' event.<\/solution>\n+            <severity>Not Applicable<\/severity>\n@@ -1118,2 +1166,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The recording does not seem to contain passwords in the system properties.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -1123,1 +1170,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No allocation was caused by conversion from primitive types to the corresponding object types.<\/summary>\n@@ -1131,1 +1179,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>SocketReadRuleFactory_TEXT_NO_EVENTS<\/summary>\n+            <explanation>Note that there are some socket read patterns with high duration reads that we consider to be normal and are therefore excluded. Such patterns include JMX RMI communication and MQ series.<\/explanation>\n@@ -1135,1 +1185,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>There are no socket write events in this recording.<\/summary>\n+            <explanation>Note that there are some socket write patterns with high duration writes that we consider to be normal and are therefore excluded. Such patterns include JMX RMI communication.<\/explanation>\n@@ -1139,2 +1191,4 @@\n-            <severity>OK<\/severity>\n-            <summary>No stack traces were truncated in this recording.<\/summary>\n+            <severity>Warning<\/severity>\n+            <summary>Some stack traces were truncated in this recording.<\/summary>\n+            <explanation>The Flight Recorder is configured with a maximum captured stack depth of 64. 10.5 % of all traces were larger than this option, and were therefore truncated. If more detailed traces are required, increase the ''-XX:FlightRecorderOptions=stackdepth=&lt;value&gt;'' value.\n+Events of the following types have truncated stack traces: &lt;ul&gt;&lt;li&gt;Allocation in new TLAB (2.41 % truncated traces)&lt;\/li&gt;&lt;li&gt;Allocation outside TLAB (1.45 % truncated traces)&lt;\/li&gt;&lt;li&gt;Object Allocation Sample (3.06 % truncated traces)&lt;\/li&gt;&lt;li&gt;Old Object Sample (44.4 % truncated traces)&lt;\/li&gt;&lt;li&gt;Socket Write (48.1 % truncated traces)&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n@@ -1146,0 +1200,5 @@\n+        <rule>\n+            <id>SystemGc<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No garbage collections were caused by System.gc().<\/summary>\n+        <\/rule>\n@@ -1149,1 +1208,2 @@\n-            <summary>No object allocations outside of TLABs detected.<\/summary>\n+            <summary>The program allocated 3.08 % of the memory outside of TLABs.<\/summary>\n+            <solution>Allocating objects outside of Thread Local Allocation Buffers (TLABs) is more expensive than allocating inside TLABs. This may be acceptable if the individual allocations are intended to be larger than a reasonable TLAB. It may be possible to avoid this by decreasing the size of the individual allocations. There are some TLAB related JVM flags that you can experiment with, but it is usually better to let the JVM manage TLAB sizes automatically.<\/solution>\n@@ -1154,1 +1214,1 @@\n-            <summary>No excessively long VM operations were found in this recording (the longest was 67.887 ms).<\/summary>\n+            <summary>No excessively long VM operations were found in this recording (the longest was 54.343 ms).<\/summary>\n@@ -1158,1 +1218,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No revocation of biased locks found.<\/summary>\n@@ -1167,1 +1228,1 @@\n-        <file>full_gc_cms.jfr<\/file>\n+        <file>flight_recording_hidden.jfr<\/file>\n@@ -1170,1 +1231,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The most allocated type is likely ''byte[]'', most commonly allocated by: &lt;ul&gt;&lt;li&gt;void java.io.ByteArrayOutputStream.&amp;lt;init&amp;gt;(int)&lt;\/li&gt;&lt;li&gt;void java.io.ByteArrayOutputStream.&amp;lt;init&amp;gt;()&lt;\/li&gt;&lt;li&gt;void sun.management.jdp.JdpPacketWriter.&amp;lt;init&amp;gt;()&lt;\/li&gt;&lt;li&gt;byte[] sun.management.jdp.JdpJmxPacket.getPacketData()&lt;\/li&gt;&lt;li&gt;void sun.management.jdp.JdpBroadcaster.sendPacket(JdpPacket)&lt;\/li&gt;&lt;li&gt;void sun.management.jdp.JdpController$JDPControllerRunner.run()&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Frequently allocated types are good places to start when trying to reduce garbage collections. Look at where the most common types are being allocated to see if many instances are created along the same call path. Try to reduce the number of instances created by invoking the most commonly taken paths less.<\/explanation>\n@@ -1174,1 +1237,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The most allocations were likely done by thread ''AWT-EventQueue-0'' at: &lt;ul&gt;&lt;li&gt;void java.awt.EventQueue.dispatchEvent(AWTEvent)&lt;\/li&gt;&lt;li&gt;void java.awt.EventDispatchThread.pumpOneEventForFilters(int)&lt;\/li&gt;&lt;li&gt;void java.awt.EventDispatchThread.pumpEventsForFilter(int, Conditional, EventFilter)&lt;\/li&gt;&lt;li&gt;void java.awt.EventDispatchThread.pumpEventsForHierarchy(int, Conditional, Component)&lt;\/li&gt;&lt;li&gt;void java.awt.EventDispatchThread.pumpEvents(int, Conditional)&lt;\/li&gt;&lt;li&gt;void java.awt.EventDispatchThread.pumpEvents(Conditional)&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Many allocations performed by the same thread might indicate a problem in a multi-threaded program. Look at the stack traces for the thread with the highest allocation rate. See if the allocation rate can be brought down, or balanced among the active threads.<\/explanation>\n@@ -1187,1 +1252,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The application ran with bytecode verification enabled.<\/summary>\n@@ -1203,1 +1269,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>Warning<\/severity>\n+            <summary>An average CPU load of 60 % was caused by other processes for during 4\/25\/2018 11:38:36.000 AM – 11:38:44 AM.<\/summary>\n+            <explanation>The application performance can be affected when the machine is under heavy load and there are other processes that use CPU or other resources on the same computer. To profile representatively or get higher throughput, shut down other resource intensive processes running on the machine.<\/explanation>\n@@ -1211,1 +1279,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The program did not context switch excessively during the recording.<\/summary>\n@@ -1219,1 +1288,4 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>Information<\/severity>\n+            <summary>DebugNonSafepoints was not enabled.<\/summary>\n+            <explanation>If DebugNonSafepoints is not enabled, the method profiling data will be less accurate as threads that are not at safepoints will not be correctly sampled. There is a slight performance overhead when enabling these flags. For more information see [HotSpot Runtime Overview\/Thread Management](http:\/\/openjdk.java.net\/groups\/hotspot\/docs\/RuntimeOverview.html#Thread%20Management|outline]).<\/explanation>\n+            <solution>Use the following JVM flags to enable this: '-XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints'.<\/solution>\n@@ -1231,0 +1303,5 @@\n+            <severity>OK<\/severity>\n+            <summary>There were no duplicate JVM flags on the command line.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>DynamicAgents<\/id>\n@@ -1239,1 +1316,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The program generated 0 exceptions per second during 4\/25\/2018 11:38:36.000 AM – 11:38:37 AM.<\/summary>\n+            <explanation>Throwing exceptions is more expensive than normal code execution, which means that they should only be used for exceptional situations. Investigate the thrown exceptions to see if any of them can be avoided with a non-exceptional control flow.<\/explanation>\n@@ -1249,1 +1328,1 @@\n-\t\t<rule>\n+        <rule>\n@@ -1267,5 +1346,2 @@\n-            <severity>Not Applicable<\/severity>\n-        <\/rule>\n-        <rule>\n-            <id>JfrPeriodicEventsFix<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The JVM version used for this recording has full Flight Recorder support.<\/summary>\n@@ -1275,3 +1351,2 @@\n-            <severity>Warning<\/severity>\n-            <summary>Full GC detected.<\/summary>\n-            <explanation>At least one Full, Stop-The-World Garbage Collection occurred during this recording. For the CMS and G1 collectors, Full GC events are a strong negative performance indicator. Tunable GC parameters can be used to allow the collector to operate in concurrent mode, avoiding Stop-The-World pauses and increasing GC and application performance.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n+            <summary>This rule is only valid for CMS and G1 Garbage Collectors, neither of which were detected for this JVM.<\/summary>\n@@ -1281,1 +1356,1 @@\n-            <severity>OK<\/severity>\n+            <severity>Not Applicable<\/severity>\n@@ -1291,5 +1366,0 @@\n-        <rule>\n-            <id>GcLocker<\/id>\n-            <severity>OK<\/severity>\n-            <summary>No GCs were affected by the GC Locker.<\/summary>\n-        <\/rule>\n@@ -1298,1 +1368,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No problems were found with the GC configuration.<\/summary>\n@@ -1308,6 +1379,0 @@\n-        <rule>\n-            <id>GcStall<\/id>\n-            <severity>Warning<\/severity>\n-            <summary>The CMS garbage collector was used, but the JVM had to revert to do a Serial Old Collection.<\/summary>\n-            <explanation>The application used the Concurrent Mark Sweep garbage collector, but the JVM had to revert to a Serial Old Collection, which takes more time. This is because the Concurrent Collector could not keep up with the object allocations that happened during the collection. You can decrease the risk of this by lowering the value of [-XX:CMSInitiatingOccupancyFraction](https:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/guides\/vm\/gctuning\/cms.html).<\/explanation>\n-        <\/rule>\n@@ -1322,6 +1387,0 @@\n-        <rule>\n-            <id>HeapInspectionGc<\/id>\n-            <severity>OK<\/severity>\n-            <summary>The JVM did not perform any heap inspection GCs.<\/summary>\n-            <explanation>This is good since they usually take a lot of time.<\/explanation>\n-        <\/rule>\n@@ -1334,1 +1393,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The JVM does not seem to cause a lot of CPU load.<\/summary>\n@@ -1348,0 +1408,5 @@\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n+        <\/rule>\n@@ -1354,1 +1419,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>Warning<\/severity>\n+            <summary>The maximum amount of used memory was 99.8 % of the physical memory available.<\/summary>\n+            <explanation>The maximum amount of memory used was 16 GiB. This is 99.8 % of the 16 GiB of physical memory available. Having little free memory may lead to swapping, which is very expensive. To avoid this, either decrease the memory usage or increase the amount of available memory.<\/explanation>\n@@ -1358,1 +1425,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No problems were found with the management agent settings.<\/summary>\n@@ -1370,0 +1438,5 @@\n+            <severity>OK<\/severity>\n+            <summary>No methods where optimization would be particularly efficient could be detected.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>MultipleAgents<\/id>\n@@ -1374,1 +1447,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No undocumented, deprecated or non-recommended option flags were detected.<\/summary>\n@@ -1378,1 +1452,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No problems were found with the recording settings.<\/summary>\n@@ -1382,1 +1457,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The recording does not seem to contain passwords in the application arguments.<\/summary>\n@@ -1386,1 +1462,4 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>Warning<\/severity>\n+            <summary>The environment variables in the recording may contain passwords.<\/summary>\n+            <explanation>The following suspicious environment variables were found in this recording: &lt;ul&gt;&lt;li&gt;P4PASSWD&lt;\/li&gt;&lt;\/ul&gt;. The following regular expression was used to exclude strings from this rule: ''(passworld|passwise)''.<\/explanation>\n+            <solution>If you wish to keep having passwords in your environment variables, but want to be able to share recordings without also sharing the passwords, please disable the ''Initial Environment Variable'' event.<\/solution>\n@@ -1390,1 +1469,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The recording does not seem to contain passwords in the system properties.<\/summary>\n@@ -1417,5 +1497,0 @@\n-        <rule>\n-            <id>SystemGc<\/id>\n-            <severity>OK<\/severity>\n-            <summary>No garbage collections were caused by System.gc().<\/summary>\n-        <\/rule>\n@@ -1424,1 +1499,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No object allocations outside of TLABs detected.<\/summary>\n@@ -1428,1 +1504,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No excessively long VM operations were found in this recording (the longest was 67.887 ms).<\/summary>\n@@ -1436,1 +1513,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No revocation of biased locks found.<\/summary>\n@@ -1440,1 +1518,1 @@\n-        <file>full_gc_g1.jfr<\/file>\n+        <file>full_gc_cms.jfr<\/file>\n@@ -1506,0 +1584,4 @@\n+        <rule>\n+            <id>DynamicAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -1522,1 +1604,1 @@\n-\t\t<rule>\n+        <rule>\n@@ -1542,4 +1624,0 @@\n-        <rule>\n-            <id>JfrPeriodicEventsFix<\/id>\n-            <severity>Not Applicable<\/severity>\n-        <\/rule>\n@@ -1584,2 +1662,2 @@\n-            <summary>There occurred Concurrent Mode failures during certain garbage collections.<\/summary>\n-            <explanation>Concurrent Mode failures means that the Garbage Collector hasn't been able to keep up with the Java Program. Try lowering the value of [-XX:InitiatingHeapOccupancyPercent](http:\/\/www.oracle.com\/technetwork\/articles\/java\/vmoptions-jsp-140102.html).<\/explanation>\n+            <summary>The CMS garbage collector was used, but the JVM had to revert to do a Serial Old Collection.<\/summary>\n+            <explanation>The application used the Concurrent Mark Sweep garbage collector, but the JVM had to revert to a Serial Old Collection, which takes more time. This is because the Concurrent Collector could not keep up with the object allocations that happened during the collection. You can decrease the risk of this by lowering the value of [-XX:CMSInitiatingOccupancyFraction](https:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/guides\/vm\/gctuning\/cms.html).<\/explanation>\n@@ -1621,0 +1699,4 @@\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -1645,0 +1727,4 @@\n+        <rule>\n+            <id>MultipleAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -1713,1 +1799,1 @@\n-        <file>jdk15.jfr<\/file>\n+        <file>full_gc_g1.jfr<\/file>\n@@ -1779,0 +1865,4 @@\n+        <rule>\n+            <id>DynamicAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -1795,1 +1885,1 @@\n-\t\t<rule>\n+        <rule>\n@@ -1815,4 +1905,0 @@\n-        <rule>\n-            <id>JfrPeriodicEventsFix<\/id>\n-            <severity>Not Applicable<\/severity>\n-        <\/rule>\n@@ -1866,2 +1952,1 @@\n-            <severity>Information<\/severity>\n-            <summary>2 heap dump(s) performed.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -1895,0 +1980,4 @@\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -1919,0 +2008,4 @@\n+        <rule>\n+            <id>MultipleAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -1945,2 +2038,1 @@\n-            <severity>Information<\/severity>\n-            <summary>1 process(es) started.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -1988,1 +2080,1 @@\n-        <file>parallel-gc_cpu.jfr<\/file>\n+        <file>jdk15.jfr<\/file>\n@@ -1991,3 +2083,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The most allocated type is likely ''java.util.ArrayList'', most commonly allocated by: &lt;ul&gt;&lt;li&gt;Collection oracle.jrockit.jfr.JFRImpl.getRecordings()&lt;\/li&gt;&lt;li&gt;void oracle.jrockit.jfr.MetaProducer.onNewChunk()&lt;\/li&gt;&lt;li&gt;void oracle.jrockit.jfr.JFRImpl.onNewChunk()&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n-            <explanation>Frequently allocated types are good places to start when trying to reduce garbage collections. Look at where the most common types are being allocated to see if many instances are created along the same call path. Try to reduce the number of instances created by invoking the most commonly taken paths less.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -1997,3 +2087,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The most allocations were likely done by thread ''RMI TCP Connection(1)-127.0.0.1'' at: &lt;ul&gt;&lt;li&gt;void java.io.ObjectInputStream$BlockDataInputStream.&amp;lt;init&amp;gt;(ObjectInputStream, InputStream)&lt;\/li&gt;&lt;li&gt;void java.io.ObjectInputStream.&amp;lt;init&amp;gt;(InputStream)&lt;\/li&gt;&lt;li&gt;void sun.rmi.server.MarshalInputStream.&amp;lt;init&amp;gt;(InputStream)&lt;\/li&gt;&lt;li&gt;void sun.rmi.transport.ConnectionInputStream.&amp;lt;init&amp;gt;(InputStream)&lt;\/li&gt;&lt;li&gt;ObjectInput sun.rmi.transport.StreamRemoteCall.getInputStream()&lt;\/li&gt;&lt;li&gt;boolean sun.rmi.transport.Transport.serviceCall(RemoteCall)&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n-            <explanation>Many allocations performed by the same thread might indicate a problem in a multi-threaded program. Look at the stack traces for the thread with the highest allocation rate. See if the allocation rate can be brought down, or balanced among the active threads.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2003,4 +2091,1 @@\n-            <severity>OK<\/severity>\n-            <summary>Application efficiency was not highly affected by halts.<\/summary>\n-            <explanation>The highest ratio of application halts to execution time was 0 % during 4\/4\/2014 11:17:05.000 AM – 11:18:05 AM. 0 % of the halts were for reasons other than GC. The halts ratio for the entire recording was 0 %. 0 % of the total halts were for reasons other than GC.\n-Enabling the following event types would improve the accuracy of this rule: jdk.SafepointBegin<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2015,2 +2100,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The application ran with bytecode verification enabled.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2032,3 +2116,1 @@\n-            <severity>OK<\/severity>\n-            <summary>An average CPU load of 0 % was caused by other processes for during 4\/4\/2014 11:17:07.000 AM – 11:17:08 AM.<\/summary>\n-            <explanation>The application performance can be affected when the machine is under heavy load and there are other processes that use CPU or other resources on the same computer. To profile representatively or get higher throughput, shut down other resource intensive processes running on the machine.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2038,2 +2120,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The settings for Compressed Oops were OK.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2051,4 +2132,1 @@\n-            <severity>Information<\/severity>\n-            <summary>DebugNonSafepoints was not enabled.<\/summary>\n-            <explanation>If DebugNonSafepoints is not enabled, the method profiling data will be less accurate as threads that are not at safepoints will not be correctly sampled. There is a slight performance overhead when enabling these flags. For more information see [HotSpot Runtime Overview\/Thread Management](http:\/\/openjdk.java.net\/groups\/hotspot\/docs\/RuntimeOverview.html#Thread%20Management|outline]).<\/explanation>\n-            <solution>Use the following JVM flags to enable this: '-XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints'.<\/solution>\n+            <severity>Not Applicable<\/severity>\n@@ -2058,2 +2136,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No problems were found with the VM options.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2067,2 +2144,5 @@\n-            <severity>OK<\/severity>\n-            <summary>There were no duplicate JVM flags on the command line.<\/summary>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DynamicAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -2076,3 +2156,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The program generated 0 exceptions per second during 4\/4\/2014 11:17:06.152.000 AM – 11:17:07.152 AM.<\/summary>\n-            <explanation>Throwing exceptions is more expensive than normal code execution, which means that they should only be used for exceptional situations. Investigate the thrown exceptions to see if any of them can be avoided with a non-exceptional control flow.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2086,3 +2164,1 @@\n-            <severity>OK<\/severity>\n-            <summary>There were no problems with the amount of sampled threads.<\/summary>\n-            <explanation>There are more sampled threads than the amount of hardware threads. This indicates that the application has enough parallelism for the available hardware.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2090,1 +2166,1 @@\n-\t\t<rule>\n+        <rule>\n@@ -2096,2 +2172,1 @@\n-            <severity>OK<\/severity>\n-            <summary>There are no file read events in this recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2101,2 +2176,1 @@\n-            <severity>OK<\/severity>\n-            <summary>There are no file write events in this recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2110,8 +2184,1 @@\n-            <severity>Warning<\/severity>\n-            <summary>The recording is from an early access build.<\/summary>\n-            <explanation>This recording is from an early access build of the JRE (Java HotSpot(TM) Client VM (25.20-b08) for linux-x86 JRE (1.8.0_20-ea-b08), built on Apr  1 2014 19:40:24 by &amp;#34;java_re&amp;#34; with gcc 4.3.0 20080428 (Red Hat 4.3.0-8)). The automated analysis is not supported, and you may see errors when attempting to analyze the recording.<\/explanation>\n-        <\/rule>\n-        <rule>\n-            <id>JfrPeriodicEventsFix<\/id>\n-            <severity>OK<\/severity>\n-            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2121,2 +2188,3 @@\n-            <severity>OK<\/severity>\n-            <summary>No Stop-the-World, Full GC events detected.<\/summary>\n+            <severity>Warning<\/severity>\n+            <summary>Full GC detected.<\/summary>\n+            <explanation>At least one Full, Stop-The-World Garbage Collection occurred during this recording. For the CMS and G1 collectors, Full GC events are a strong negative performance indicator. Tunable GC parameters can be used to allow the collector to operate in concurrent mode, avoiding Stop-The-World pauses and increasing GC and application performance.<\/explanation>\n@@ -2126,1 +2194,1 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n@@ -2130,2 +2198,1 @@\n-            <severity>OK<\/severity>\n-            <summary>Only 0 heap summary events were found, this rule requires at least 10 events to be able to calculate a relevant result. This likely means that only a few garbage collections occurred during the recording. Having few garbage collections is generally a good sign.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2137,0 +2204,5 @@\n+        <rule>\n+            <id>GcLocker<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No GCs were affected by the GC Locker.<\/summary>\n+        <\/rule>\n@@ -2139,3 +2211,1 @@\n-            <severity>Information<\/severity>\n-            <summary>The runtime used 2 GC threads on a machine with 1 CPU cores.<\/summary>\n-            <explanation>It's suboptimal to use more GC threads than available cores. Removing the '-XX:ParallelGCThreads' flag will allow the JVM to set the number of GC threads automatically.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2145,4 +2215,1 @@\n-            <severity>OK<\/severity>\n-            <summary>Application efficiency was not highly affected by GC pauses.<\/summary>\n-            <explanation>The highest ratio between garbage collection pauses and execution time was 0 % during 4\/4\/2014 11:17:05.000 AM – 11:18:05 AM. The garbage collection pause ratio of the entire recording was 0 %.<\/explanation>\n-            <solution>Pause times may be reduced by increasing the heap size or by trying to reduce allocation.<\/solution>\n+            <severity>Not Applicable<\/severity>\n@@ -2154,0 +2221,6 @@\n+        <rule>\n+            <id>GcStall<\/id>\n+            <severity>Warning<\/severity>\n+            <summary>There occurred Concurrent Mode failures during certain garbage collections.<\/summary>\n+            <explanation>Concurrent Mode failures means that the Garbage Collector hasn't been able to keep up with the Java Program. Try lowering the value of [-XX:InitiatingHeapOccupancyPercent](http:\/\/www.oracle.com\/technetwork\/articles\/java\/vmoptions-jsp-140102.html).<\/explanation>\n+        <\/rule>\n@@ -2160,1 +2233,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>Information<\/severity>\n+            <summary>2 heap dump(s) performed.<\/summary>\n@@ -2163,1 +2237,1 @@\n-            <id>HighGc<\/id>\n+            <id>HeapInspectionGc<\/id>\n@@ -2165,1 +2239,6 @@\n-            <summary>The runtime did not spend much time performing garbage collections.<\/summary>\n+            <summary>The JVM did not perform any heap inspection GCs.<\/summary>\n+            <explanation>This is good since they usually take a lot of time.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>HighGc<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -2169,3 +2248,1 @@\n-            <severity>Information<\/severity>\n-            <summary>This recording contains few profiling samples even though the CPU load is high.<\/summary>\n-            <explanation>The profiling data is thus likely not relevant. This might be because the application is running a lot JNI code or that the JVM is spending a lot of time in GC, class loading, JIT compilation etc.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2176,1 +2253,0 @@\n-            <summary>Too few events to calculate the result.<\/summary>\n@@ -2180,2 +2256,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The class data does not seem to increase during the recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2187,0 +2262,4 @@\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -2189,2 +2268,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The application did not cause any long GC pause times.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2194,2 +2272,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The system did not run low on physical memory during this recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2199,2 +2276,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No problems were found with the management agent settings.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2204,4 +2280,1 @@\n-            <severity>OK<\/severity>\n-            <summary>137 processes were running while this Flight Recording was made.<\/summary>\n-            <explanation>At 4\/4\/14 11:17:10.326 AM, a total of 137 other processes were running on the host machine that this Flight Recording was made on.<\/explanation>\n-            <solution>If this is a server environment, it may be good to only run other critical processes on that machine.<\/solution>\n+            <severity>Not Applicable<\/severity>\n@@ -2215,2 +2288,5 @@\n-            <severity>OK<\/severity>\n-            <summary>No methods where optimization would be particularly efficient could be detected.<\/summary>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MultipleAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -2220,2 +2296,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No undocumented, deprecated or non-recommended option flags were detected.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2225,2 +2300,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No problems were found with the recording settings.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2230,2 +2304,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The recording does not seem to contain passwords in the application arguments.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2235,2 +2308,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The recording does not seem to contain passwords in the environment variables.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2240,2 +2312,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The recording does not seem to contain passwords in the system properties.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2249,1 +2320,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>Information<\/severity>\n+            <summary>1 process(es) started.<\/summary>\n@@ -2253,3 +2325,1 @@\n-            <severity>OK<\/severity>\n-            <summary>SocketReadRuleFactory_TEXT_NO_EVENTS<\/summary>\n-            <explanation>Note that there are some socket read patterns with high duration reads that we consider to be normal and are therefore excluded. Such patterns include JMX RMI communication and MQ series.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2259,3 +2329,1 @@\n-            <severity>OK<\/severity>\n-            <summary>There are no socket write events in this recording.<\/summary>\n-            <explanation>Note that there are some socket write patterns with high duration writes that we consider to be normal and are therefore excluded. Such patterns include JMX RMI communication.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2273,1 +2341,1 @@\n-            <id>TlabAllocationRatio<\/id>\n+            <id>SystemGc<\/id>\n@@ -2275,1 +2343,5 @@\n-            <summary>No object allocations outside of TLABs detected.<\/summary>\n+            <summary>No garbage collections were caused by System.gc().<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>TlabAllocationRatio<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -2279,2 +2351,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No excessively long VM operations were found in this recording (the longest was 0 s).<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2288,2 +2359,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No revocation of biased locks found.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2293,1 +2363,1 @@\n-        <file>parallel-on-singlecpu.jfr<\/file>\n+        <file>jdk18-finalizers.jfr<\/file>\n@@ -2296,3 +2366,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The most allocated type is likely ''java.lang.Object[]'', most commonly allocated by: &lt;ul&gt;&lt;li&gt;Object[] java.util.AbstractCollection.toArray()&lt;\/li&gt;&lt;li&gt;void java.util.ArrayList.&amp;lt;init&amp;gt;(Collection)&lt;\/li&gt;&lt;li&gt;Collection oracle.jrockit.jfr.JFRImpl.getRecordings()&lt;\/li&gt;&lt;li&gt;void oracle.jrockit.jfr.MetaProducer.onNewChunk()&lt;\/li&gt;&lt;li&gt;void oracle.jrockit.jfr.JFRImpl.onNewChunk()&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n-            <explanation>Frequently allocated types are good places to start when trying to reduce garbage collections. Look at where the most common types are being allocated to see if many instances are created along the same call path. Try to reduce the number of instances created by invoking the most commonly taken paths less.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2302,3 +2370,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The most allocations were likely done by thread ''RMI TCP Connection(1)-127.0.0.1'' at: &lt;ul&gt;&lt;li&gt;Throwable java.lang.Throwable.fillInStackTrace(int)&lt;\/li&gt;&lt;li&gt;Throwable java.lang.Throwable.fillInStackTrace()&lt;\/li&gt;&lt;li&gt;void java.lang.Throwable.&amp;lt;init&amp;gt;(String)&lt;\/li&gt;&lt;li&gt;void java.lang.Exception.&amp;lt;init&amp;gt;(String)&lt;\/li&gt;&lt;li&gt;void java.lang.ReflectiveOperationException.&amp;lt;init&amp;gt;(String)&lt;\/li&gt;&lt;li&gt;void java.lang.NoSuchFieldException.&amp;lt;init&amp;gt;(String)&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n-            <explanation>Many allocations performed by the same thread might indicate a problem in a multi-threaded program. Look at the stack traces for the thread with the highest allocation rate. See if the allocation rate can be brought down, or balanced among the active threads.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2308,4 +2374,1 @@\n-            <severity>OK<\/severity>\n-            <summary>Application efficiency was not highly affected by halts.<\/summary>\n-            <explanation>The highest ratio of application halts to execution time was 0 % during 4\/4\/2014 8:54:33.000 AM – 8:55:33 AM. 0 % of the halts were for reasons other than GC. The halts ratio for the entire recording was 0 %. 0 % of the total halts were for reasons other than GC.\n-Enabling the following event types would improve the accuracy of this rule: jdk.SafepointBegin<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2320,2 +2383,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The application ran with bytecode verification enabled.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2337,3 +2399,1 @@\n-            <severity>OK<\/severity>\n-            <summary>An average CPU load of 0 % was caused by other processes for during 4\/4\/2014 8:54:36.000 AM – 8:54:37 AM.<\/summary>\n-            <explanation>The application performance can be affected when the machine is under heavy load and there are other processes that use CPU or other resources on the same computer. To profile representatively or get higher throughput, shut down other resource intensive processes running on the machine.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2343,2 +2403,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The settings for Compressed Oops were OK.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2348,2 +2407,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The program did not context switch excessively during the recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2357,4 +2415,1 @@\n-            <severity>Information<\/severity>\n-            <summary>DebugNonSafepoints was not enabled.<\/summary>\n-            <explanation>If DebugNonSafepoints is not enabled, the method profiling data will be less accurate as threads that are not at safepoints will not be correctly sampled. There is a slight performance overhead when enabling these flags. For more information see [HotSpot Runtime Overview\/Thread Management](http:\/\/openjdk.java.net\/groups\/hotspot\/docs\/RuntimeOverview.html#Thread%20Management|outline]).<\/explanation>\n-            <solution>Use the following JVM flags to enable this: '-XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints'.<\/solution>\n+            <severity>Not Applicable<\/severity>\n@@ -2364,2 +2419,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No problems were found with the VM options.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2373,2 +2427,5 @@\n-            <severity>OK<\/severity>\n-            <summary>There were no duplicate JVM flags on the command line.<\/summary>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DynamicAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -2382,3 +2439,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The program generated 0 exceptions per second during 4\/4\/2014 8:54:34.000 AM – 8:54:35 AM.<\/summary>\n-            <explanation>Throwing exceptions is more expensive than normal code execution, which means that they should only be used for exceptional situations. Investigate the thrown exceptions to see if any of them can be avoided with a non-exceptional control flow.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2392,3 +2447,1 @@\n-            <severity>OK<\/severity>\n-            <summary>There were no problems with the amount of sampled threads.<\/summary>\n-            <explanation>There are more sampled threads than the amount of hardware threads. This indicates that the application has enough parallelism for the available hardware.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2396,1 +2449,1 @@\n-\t\t<rule>\n+        <rule>\n@@ -2402,2 +2455,1 @@\n-            <severity>OK<\/severity>\n-            <summary>There are no file read events in this recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2407,5 +2459,0 @@\n-            <severity>OK<\/severity>\n-            <summary>There are no file write events in this recording.<\/summary>\n-        <\/rule>\n-         <rule>\n-            <id>FinalizersRun<\/id>\n@@ -2415,4 +2462,5 @@\n-            <id>FlightRecordingSupport<\/id>\n-            <severity>Warning<\/severity>\n-            <summary>The recording is from an early access build.<\/summary>\n-            <explanation>This recording is from an early access build of the JRE (Java HotSpot(TM) Client VM (25.20-b08) for linux-x86 JRE (1.8.0_20-ea-b08), built on Apr  1 2014 19:40:24 by &amp;#34;java_re&amp;#34; with gcc 4.3.0 20080428 (Red Hat 4.3.0-8)). The automated analysis is not supported, and you may see errors when attempting to analyze the recording.<\/explanation>\n+            <id>FinalizersRun<\/id>\n+            <severity>Information<\/severity>\n+            <summary>26.5 ×10⁶ finalizers were run.<\/summary>\n+            <explanation>Finalization can lead to performance issues, deadlocks, or hangs, and has been marked for removal in a future Java version. The following finalizable classes have been detected: &lt;ul&gt;&lt;li&gt;my_package.Main$MyFinalizableObject&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n+            <solution>Remove finalize method implementations from your application, and consider making use of the [Cleaner API](https:\/\/docs.oracle.com\/en\/java\/javase\/17\/docs\/api\/java.base\/java\/lang\/ref\/Cleaner.html) instead.<\/solution>\n@@ -2421,3 +2469,2 @@\n-            <id>JfrPeriodicEventsFix<\/id>\n-            <severity>OK<\/severity>\n-            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n+            <id>FlightRecordingSupport<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -2436,2 +2483,1 @@\n-            <severity>OK<\/severity>\n-            <summary>Only 0 heap summary events were found, this rule requires at least 10 events to be able to calculate a relevant result. This likely means that only a few garbage collections occurred during the recording. Having few garbage collections is generally a good sign.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2445,3 +2491,1 @@\n-            <severity>Information<\/severity>\n-            <summary>The runtime used a parallel GC on a single-core machine.<\/summary>\n-            <explanation>The runtime used a parallel GC on a single-core machine. This is not optimal. Use the [Serial Collector](https:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/guides\/vm\/gctuning\/collectors.html) instead, which is optimized for single-core machines.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2451,4 +2495,1 @@\n-            <severity>OK<\/severity>\n-            <summary>Application efficiency was not highly affected by GC pauses.<\/summary>\n-            <explanation>The highest ratio between garbage collection pauses and execution time was 0 % during 4\/4\/2014 8:54:33.000 AM – 8:55:33 AM. The garbage collection pause ratio of the entire recording was 0 %.<\/explanation>\n-            <solution>Pause times may be reduced by increasing the heap size or by trying to reduce allocation.<\/solution>\n+            <severity>Not Applicable<\/severity>\n@@ -2470,2 +2511,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The runtime did not spend much time performing garbage collections.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2475,3 +2515,1 @@\n-            <severity>Information<\/severity>\n-            <summary>This recording contains few profiling samples even though the CPU load is high.<\/summary>\n-            <explanation>The profiling data is thus likely not relevant. This might be because the application is running a lot JNI code or that the JVM is spending a lot of time in GC, class loading, JIT compilation etc.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2482,1 +2520,0 @@\n-            <summary>Too few events to calculate the result.<\/summary>\n@@ -2486,2 +2523,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The class data does not seem to increase during the recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2493,0 +2529,4 @@\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -2495,2 +2535,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The application did not cause any long GC pause times.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2500,2 +2539,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The system did not run low on physical memory during this recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2505,2 +2543,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No problems were found with the management agent settings.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2510,4 +2547,1 @@\n-            <severity>OK<\/severity>\n-            <summary>137 processes were running while this Flight Recording was made.<\/summary>\n-            <explanation>At 4\/4\/14 8:54:38.623 AM, a total of 137 other processes were running on the host machine that this Flight Recording was made on.<\/explanation>\n-            <solution>If this is a server environment, it may be good to only run other critical processes on that machine.<\/solution>\n+            <severity>Not Applicable<\/severity>\n@@ -2521,2 +2555,5 @@\n-            <severity>OK<\/severity>\n-            <summary>No methods where optimization would be particularly efficient could be detected.<\/summary>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MultipleAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -2526,2 +2563,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No undocumented, deprecated or non-recommended option flags were detected.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2531,2 +2567,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No problems were found with the recording settings.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2536,2 +2571,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The recording does not seem to contain passwords in the application arguments.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2541,2 +2575,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The recording does not seem to contain passwords in the environment variables.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2546,2 +2579,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The recording does not seem to contain passwords in the system properties.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2559,3 +2591,1 @@\n-            <severity>OK<\/severity>\n-            <summary>SocketReadRuleFactory_TEXT_NO_EVENTS<\/summary>\n-            <explanation>Note that there are some socket read patterns with high duration reads that we consider to be normal and are therefore excluded. Such patterns include JMX RMI communication and MQ series.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2569,2 +2599,2 @@\n-            <severity>OK<\/severity>\n-            <summary>No stack traces were truncated in this recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n+            <summary>No events with stack traces were recorded.<\/summary>\n@@ -2578,2 +2608,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No object allocations outside of TLABs detected.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2583,2 +2612,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No excessively long VM operations were found in this recording (the longest was 0 s).<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2592,2 +2620,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No revocation of biased locks found.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2597,1 +2624,1 @@\n-        <file>stringdedup_enabled_jdk9.jfr<\/file>\n+        <file>jdk21-inverted-parallelism.jfr<\/file>\n@@ -2608,3 +2635,1 @@\n-            <severity>OK<\/severity>\n-            <summary>Application efficiency was not highly affected by halts.<\/summary>\n-            <explanation>The highest ratio of application halts to execution time was 0.0819 % during 4\/24\/2018 10:08:52.000 AM – 10:09:52 AM. 51.6 % of the halts were for reasons other than GC. The halts ratio for the entire recording was 1 %. 51.6 % of the total halts were for reasons other than GC.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2619,2 +2644,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The application ran with bytecode verification enabled.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2636,3 +2660,1 @@\n-            <severity>OK<\/severity>\n-            <summary>An average CPU load of 15 % was caused by other processes for during 4\/24\/2018 10:08:54.000 AM – 10:08:55 AM.<\/summary>\n-            <explanation>The application performance can be affected when the machine is under heavy load and there are other processes that use CPU or other resources on the same computer. To profile representatively or get higher throughput, shut down other resource intensive processes running on the machine.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2642,2 +2664,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The settings for Compressed Oops were OK.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2659,2 +2680,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No problems were found with the VM options.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2668,2 +2688,5 @@\n-            <severity>OK<\/severity>\n-            <summary>There were no duplicate JVM flags on the command line.<\/summary>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DynamicAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -2677,3 +2700,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The program generated 0 exceptions per second during 4\/24\/2018 10:08:53.000 AM – 10:08:54 AM.<\/summary>\n-            <explanation>Throwing exceptions is more expensive than normal code execution, which means that they should only be used for exceptional situations. Investigate the thrown exceptions to see if any of them can be avoided with a non-exceptional control flow.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2687,3 +2708,1 @@\n-            <severity>Information<\/severity>\n-            <summary>There are fewer sampled threads than the total number of hardware threads (cores).<\/summary>\n-            <explanation>1 threads with at least 4 method samples were found, but the machine has 32 hardware threads (cores). The application might benefit from a higher level of parallelism. This could also be caused by threads doing something else than running Java code, for example running native code or spending time in the JVM internals.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2691,1 +2710,1 @@\n-\t\t<rule>\n+        <rule>\n@@ -2697,2 +2716,1 @@\n-            <severity>OK<\/severity>\n-            <summary>There are no file read events in this recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2702,2 +2720,1 @@\n-            <severity>OK<\/severity>\n-            <summary>There are no file write events in this recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2711,7 +2728,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The JVM version used for this recording has full Flight Recorder support.<\/summary>\n-        <\/rule>\n-        <rule>\n-            <id>JfrPeriodicEventsFix<\/id>\n-            <severity>OK<\/severity>\n-            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2726,1 +2737,1 @@\n-            <severity>OK<\/severity>\n+            <severity>Not Applicable<\/severity>\n@@ -2734,0 +2745,6 @@\n+            <severity>Warning<\/severity>\n+            <summary>Inverted Parallelism detected 1 times out of 11 recorded events.<\/summary>\n+            <explanation>There is evidence of inverted parallelism. With parallel (multi-threaded) collector events, the \"user\" + \"sys\" time should be approximately equal to the \"real\" (wall) time multiplied by the # of GC threads. For example, if there are 3 GC threads we would expect a parallel collection that takes 1 second of \"real\" time to take approximately 3 seconds of \"user\" + \"sys\" time. The parallelism is 3x. If the parallelism is 1x (\"user\" + \"sys\" = \"real\"), the parallel collection is not offering any efficiency over a serial (single-threaded) collection. When \"user\" + \"sys\" &lt; \"real\", the parallelism is inverted. Inverted parallelism can be a sign of high i\/o (e.g. disk or network access) or not enough CPU (e.g. GC threads competing with each other or other processes). Check for swapping and if the number of GC threads (-XX:ParallelGCThreads=&lt;n&gt;) is appropriate for the number of cpu\/cores and any processes sharing cpu.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>GcOptions<\/id>\n@@ -2736,10 +2753,0 @@\n-        <rule>\n-            <id>GcLocker<\/id>\n-            <severity>OK<\/severity>\n-            <summary>No GCs were affected by the GC Locker.<\/summary>\n-        <\/rule>\n-        <rule>\n-            <id>GcOptions<\/id>\n-            <severity>OK<\/severity>\n-            <summary>No problems were found with the GC configuration.<\/summary>\n-        <\/rule>\n@@ -2748,4 +2755,1 @@\n-            <severity>OK<\/severity>\n-            <summary>Application efficiency was not highly affected by GC pauses.<\/summary>\n-            <explanation>The highest ratio between garbage collection pauses and execution time was 0.0397 % during 4\/24\/2018 10:08:52.000 AM – 10:09:52 AM. The garbage collection pause ratio of the entire recording was 0.486 %.<\/explanation>\n-            <solution>Pause times may be reduced by increasing the heap size or by trying to reduce allocation.<\/solution>\n+            <severity>Not Applicable<\/severity>\n@@ -2755,7 +2759,1 @@\n-            <severity>OK<\/severity>\n-            <summary>All GCs completed before the GC pause target time of 200 ms.<\/summary>\n-        <\/rule>\n-        <rule>\n-            <id>GcStall<\/id>\n-            <severity>OK<\/severity>\n-            <summary>No indications that the garbage collector could not keep up with the workload were detected.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2771,6 +2769,0 @@\n-        <rule>\n-            <id>HeapInspectionGc<\/id>\n-            <severity>OK<\/severity>\n-            <summary>The JVM did not perform any heap inspection GCs.<\/summary>\n-            <explanation>This is good since they usually take a lot of time.<\/explanation>\n-        <\/rule>\n@@ -2779,4 +2771,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The JVM was paused for 100 % during 4\/24\/2018 10:08:53.973.000 AM – .982<\/summary>\n-            <explanation>The time spent performing garbage collection may be reduced by increasing the heap size or by trying to reduce allocation.\n-To improve rule accuracy and\/or get more details for further investigation, it is recommended to enable the following event types: 'Allocation in new TLAB', 'Allocation outside TLAB'.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2786,2 +2775,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The JVM does not seem to cause a lot of CPU load.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2792,1 +2780,0 @@\n-            <summary>Too few events to calculate the result.<\/summary>\n@@ -2796,2 +2783,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The class data does not seem to increase during the recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2803,0 +2789,4 @@\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -2805,3 +2795,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The longest GC pause was 9.017 ms.<\/summary>\n-            <explanation\/>\n+            <severity>Not Applicable<\/severity>\n@@ -2811,3 +2799,1 @@\n-            <severity>Information<\/severity>\n-            <summary>The maximum amount of used memory was 91.8 % of the physical memory available.<\/summary>\n-            <explanation>The maximum amount of memory used was 29.3 GiB. This is 91.8 % of the 31.9 GiB of physical memory available. Having little free memory may lead to swapping, which is very expensive. To avoid this, either decrease the memory usage or increase the amount of available memory.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2825,2 +2811,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The metaspace was not exhausted during this recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2830,2 +2815,5 @@\n-            <severity>OK<\/severity>\n-            <summary>No methods where optimization would be particularly efficient could be detected.<\/summary>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MultipleAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -2835,2 +2823,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No undocumented, deprecated or non-recommended option flags were detected.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2844,2 +2831,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The recording does not seem to contain passwords in the application arguments.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2873,2 +2859,2 @@\n-            <severity>OK<\/severity>\n-            <summary>No stack traces were truncated in this recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n+            <summary>No events with stack traces were recorded.<\/summary>\n@@ -2880,5 +2866,0 @@\n-        <rule>\n-            <id>SystemGc<\/id>\n-            <severity>OK<\/severity>\n-            <summary>No garbage collections were caused by System.gc().<\/summary>\n-        <\/rule>\n@@ -2891,2 +2872,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No excessively long VM operations were found in this recording (the longest was 25.346 ms).<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2900,2 +2880,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No revocation of biased locks found.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2905,1 +2884,1 @@\n-        <file>wldf.jfr<\/file>\n+        <file>jdk21.jfr<\/file>\n@@ -2908,3 +2887,1 @@\n-            <severity>Information<\/severity>\n-            <summary>The most allocated type is likely ''char[]'', most commonly allocated by: &lt;ul&gt;&lt;li&gt;char[] java.util.Arrays.copyOfRange(char[], int, int)&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n-            <explanation>Frequently allocated types are good places to start when trying to reduce garbage collections. Look at where the most common types are being allocated to see if many instances are created along the same call path. Try to reduce the number of instances created by invoking the most commonly taken paths less.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2914,3 +2891,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The most allocations were likely done by thread ''[ACTIVE] ExecuteThread: &amp;#39;5&amp;#39; for queue: &amp;#39;weblogic.kernel.Default (self-tuning)&amp;#39;'' at: &lt;ul&gt;&lt;li&gt;char[] java.util.Arrays.copyOfRange(char[], int, int)&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n-            <explanation>Many allocations performed by the same thread might indicate a problem in a multi-threaded program. Look at the stack traces for the thread with the highest allocation rate. See if the allocation rate can be brought down, or balanced among the active threads.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2922,2 +2897,1 @@\n-            <explanation>The highest ratio of application halts to execution time was 2.22 % during 9\/24\/2015 10:08:56.000 AM – 10:09:56 AM. 0.0271 % of the halts were for reasons other than GC. The halts ratio for the entire recording was 1.88 %. 0.0212 % of the total halts were for reasons other than GC.\n-Enabling the following event types would improve the accuracy of this rule: jdk.SafepointBegin<\/explanation>\n+            <explanation>The highest ratio of application halts to execution time was 0.172 % during 11\/20\/2023 4:22:52.000 PM – 4:23:52 PM. 0.118 % of the halts were for reasons other than GC. The halts ratio for the entire recording was 0.275 %. 0.114 % of the total halts were for reasons other than GC.<\/explanation>\n@@ -2932,3 +2906,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The application ran WebLogic Server with bytecode verification disabled.<\/summary>\n-            <explanation>The application ran WebLogic Server with bytecode verification disabled. While not generally recommended, it is considered OK for WLS.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2938,3 +2910,2 @@\n-            <severity>Information<\/severity>\n-            <summary>java.lang.Object was loaded 258 time(s) without being unloaded<\/summary>\n-            <explanation>Some classes have been loaded multiple times, and the difference between the number of times a class have been loaded and the number of times it has been unloaded has exceeded the user specified limit. This in itself need not be a problem, but check to see if you expect these classes to be loaded multiple times to make sure that you do not have a class loader leak. The following classes were detected as potential problems: &lt;ul&gt;&lt;li&gt;java.lang.Object (258)&lt;\/li&gt;&lt;li&gt;java.lang.String (95)&lt;\/li&gt;&lt;li&gt;java.lang.Class (81)&lt;\/li&gt;&lt;li&gt;java.lang.Integer (52)&lt;\/li&gt;&lt;li&gt;oracle.jrockit.jfr.VMJFR (46)&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n+            <severity>OK<\/severity>\n+            <summary>No classes with identical names have been loaded more times than the limit.<\/summary>\n@@ -2953,3 +2924,1 @@\n-            <severity>Warning<\/severity>\n-            <summary>An average CPU load of 54 % was caused by other processes for during 9\/24\/2015 10:08:17.000 AM – 10:08:22 AM.<\/summary>\n-            <explanation>The application performance can be affected when the machine is under heavy load and there are other processes that use CPU or other resources on the same computer. To profile representatively or get higher throughput, shut down other resource intensive processes running on the machine.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -2959,2 +2928,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The settings for Compressed Oops were OK.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2964,2 +2932,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The program did not context switch excessively during the recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -2973,4 +2940,1 @@\n-            <severity>Information<\/severity>\n-            <summary>DebugNonSafepoints was not enabled.<\/summary>\n-            <explanation>If DebugNonSafepoints is not enabled, the method profiling data will be less accurate as threads that are not at safepoints will not be correctly sampled. There is a slight performance overhead when enabling these flags. For more information see [HotSpot Runtime Overview\/Thread Management](http:\/\/openjdk.java.net\/groups\/hotspot\/docs\/RuntimeOverview.html#Thread%20Management|outline]).<\/explanation>\n-            <solution>Use the following JVM flags to enable this: '-XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints'.<\/solution>\n+            <severity>Not Applicable<\/severity>\n@@ -2989,4 +2953,1 @@\n-            <severity>Information<\/severity>\n-            <summary>2 duplicated JVM flags found.<\/summary>\n-            <explanation>Duplicated JVM flags may be caused by multiple layers of scripts used when launching the application. Having duplicate flags is dangerous as changing one of the flags in one of the scripts may not have the intended effect. This can be especially dangerous for security related system properties. The following flags were duplicated: &lt;ul&gt;&lt;li&gt;-Djava.endorsed.dirs=c:\\java\\JDK18~1.0_6\\jre\\lib\\endorsed;C:\\tmp\\WLS-JFR\\oracle_common\\modules\\endorsed,-Djava.endorsed.dirs=c:\\java\\JDK18~1.0_6\\jre\\lib\\endorsed;C:\\tmp\\WLS-JFR\\oracle_common\\modules\\endorsed&lt;\/li&gt;&lt;li&gt;-Xverify:none,-Xverify:none&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n-            <solution>Try to find all the places where the flag is defined and keep only one.<\/solution>\n+            <severity>Not Applicable<\/severity>\n@@ -2995,1 +2956,1 @@\n-            <id>Errors<\/id>\n+            <id>DynamicAgents<\/id>\n@@ -2997,2 +2958,5 @@\n-            <summary>The program generated an average of 17 errors per minute during 9\/24\/2015 10:08:14.000 AM – 10:09:14 AM.<\/summary>\n-            <explanation>17 errors were thrown in total. The most common error was ''java.lang.NoSuchMethodError'', which was thrown 13 times. Investigate the thrown errors to see if they can be avoided. Errors indicate that something went wrong with the code execution and should never be used for flow control. The following regular expression was used to exclude 381 errors from this rule: ''(com.sun.el.parser.ELParser\\$LookaheadSuccess)''.<\/explanation>\n+            <summary>An acceptable number of java and native agents (0 total) were dynamically loaded!<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -3002,3 +2966,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The program generated 515 exceptions per second during 9\/24\/2015 10:08:58.000 AM – 10:09:27 AM.<\/summary>\n-            <explanation>Throwing exceptions is more expensive than normal code execution, which means that they should only be used for exceptional situations. Investigate the thrown exceptions to see if any of them can be avoided with a non-exceptional control flow.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -3012,3 +2974,1 @@\n-            <severity>OK<\/severity>\n-            <summary>There were no problems with the amount of sampled threads.<\/summary>\n-            <explanation>There are more sampled threads than the amount of hardware threads. This indicates that the application has enough parallelism for the available hardware.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -3016,1 +2976,1 @@\n-\t\t<rule>\n+        <rule>\n@@ -3023,1 +2983,1 @@\n-            <summary>No long file read pauses were found in this recording (the longest was 16.269 ms).<\/summary>\n+            <summary>There are no file read events in this recording.<\/summary>\n@@ -3028,1 +2988,1 @@\n-            <summary>No long file write pauses were found in this recording (the longest was 172.408 ms).<\/summary>\n+            <summary>There are no file write events in this recording.<\/summary>\n@@ -3032,1 +2992,4 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>Information<\/severity>\n+            <summary>80 finalizers were run.<\/summary>\n+            <explanation>Finalization can lead to performance issues, deadlocks, or hangs, and has been marked for removal in a future Java version. The following finalizable classes have been detected: &lt;ul&gt;&lt;li&gt;org.openjdk.jmc.rjmx.internal.DefaultConnectionHandle&lt;\/li&gt;&lt;li&gt;org.openjdk.jmc.rjmx.internal.ServerHandle&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n+            <solution>Remove finalize method implementations from your application, and consider making use of the [Cleaner API](https:\/\/docs.oracle.com\/en\/java\/javase\/17\/docs\/api\/java.base\/java\/lang\/ref\/Cleaner.html) instead.<\/solution>\n@@ -3036,7 +2999,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The JVM version used for this recording has full Flight Recorder support.<\/summary>\n-        <\/rule>\n-        <rule>\n-            <id>JfrPeriodicEventsFix<\/id>\n-            <severity>OK<\/severity>\n-            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -3046,2 +3003,3 @@\n-            <severity>Not Applicable<\/severity>\n-            <summary>This rule is only valid for CMS and G1 Garbage Collectors, neither of which were detected for this JVM.<\/summary>\n+            <severity>Warning<\/severity>\n+            <summary>Full GC detected.<\/summary>\n+            <explanation>At least one Full, Stop-The-World Garbage Collection occurred during this recording. For the CMS and G1 collectors, Full GC events are a strong negative performance indicator. Tunable GC parameters can be used to allow the collector to operate in concurrent mode, avoiding Stop-The-World pauses and increasing GC and application performance.<\/explanation>\n@@ -3056,2 +3014,1 @@\n-            <summary>The ratio between memory freed by garbage collections per second and liveset is 47.4 %. This is likely a reasonable amount.<\/summary>\n-            <explanation>61.4 MiB per second was freed by garbage collections during 9\/24\/2015 10:09:18.000 AM – 10:09:28 AM. The average liveset was 130 MiB. This is likely a reasonable amount.<\/explanation>\n+            <summary>Only 4 heap summary events were found, this rule requires at least 10 events to be able to calculate a relevant result. This likely means that only a few garbage collections occurred during the recording. Having few garbage collections is generally a good sign.<\/summary>\n@@ -3061,1 +3018,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>OK<\/summary>\n@@ -3070,2 +3028,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No problems were found with the GC configuration.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -3077,1 +3034,1 @@\n-            <explanation>The highest ratio between garbage collection pauses and execution time was 2.22 % during 9\/24\/2015 10:08:56.000 AM – 10:09:56 AM. The garbage collection pause ratio of the entire recording was 1.88 %.<\/explanation>\n+            <explanation>The highest ratio between garbage collection pauses and execution time was 0.172 % during 11\/20\/2023 4:22:52.000 PM – 4:23:52 PM. The garbage collection pause ratio of the entire recording was 0.275 %.<\/explanation>\n@@ -3097,1 +3054,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No heap dump performed.<\/summary>\n@@ -3102,1 +3060,1 @@\n-            <summary>The JVM performed 4 heap inspection garbage collections.<\/summary>\n+            <summary>The JVM performed 2 heap inspection garbage collections.<\/summary>\n@@ -3108,2 +3066,2 @@\n-            <severity>Information<\/severity>\n-            <summary>The JVM was paused for 100 % during 9\/24\/2015 10:07:58.865.000 AM – 10:07:59.432 AM<\/summary>\n+            <severity>OK<\/severity>\n+            <summary>The JVM was paused for 100 % during 11\/20\/2023 4:23:22.169.000 PM – .272<\/summary>\n@@ -3114,2 +3072,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The JVM does not seem to cause a lot of CPU load.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -3119,3 +3076,2 @@\n-            <severity>Information<\/severity>\n-            <summary>The live set on the heap seems to increase with a speed of about 638 KiB per second during the recording.<\/summary>\n-            <explanation>This may be due to a memory leak in the application or it may be an artifact of a short recording if the JVM has recently been started. The recording began 3.249 s after the JVM was started. More information can be gathered by using the 'Old Object Sample' event, if available.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n+            <summary>Too few events to calculate the result.<\/summary>\n@@ -3125,3 +3081,2 @@\n-            <severity>Information<\/severity>\n-            <summary>The class data seems to increase constantly in the metaspace during the recording.<\/summary>\n-            <explanation>This behavior may indicate a memory leak in the metaspace, this could be due to the application not unloading classes as needed.<\/explanation>\n+            <severity>OK<\/severity>\n+            <summary>The class data does not seem to increase during the recording.<\/summary>\n@@ -3131,3 +3086,7 @@\n-            <severity>Information<\/severity>\n-            <summary>Threads in the application were blocked on locks for a total of 1 min 26 s.<\/summary>\n-            <explanation>The most blocking monitor class was ''org.apache.log4j.Logger'', which was blocked 1,612 times for a total of 1 min 23 s.The following regular expression was used to exclude threads from this rule: ''(.*weblogic\\.socket\\.Muxer.*)''<\/explanation>\n+            <severity>OK<\/severity>\n+            <summary>No excessive problems with lock contention found.<\/summary>\n+            <explanation>The following regular expression was used to exclude threads from this rule: ''(.*weblogic\\.socket\\.Muxer.*)''<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -3138,1 +3097,1 @@\n-            <summary>The longest GC pause was 576.207 ms.<\/summary>\n+            <summary>The longest GC pause was 103.247 ms.<\/summary>\n@@ -3143,2 +3102,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The system did not run low on physical memory during this recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -3148,2 +3106,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No problems were found with the management agent settings.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -3165,0 +3122,5 @@\n+        <rule>\n+            <id>MultipleAgents<\/id>\n+            <severity>OK<\/severity>\n+            <summary>An acceptable number of java and native agents (0 total) were loaded!<\/summary>\n+        <\/rule>\n@@ -3167,3 +3129,1 @@\n-            <severity>Information<\/severity>\n-            <summary>Deprecated option flags were detected.<\/summary>\n-            <explanation>The following option flags are or will be deprecated. &lt;ul&gt;&lt;li&gt;-XX:PermSize=128m: Ignored in Java 8 and removed in Java 9. PermGen was removed in JDK 8, since Java users should not need to know up front how much memory to reserve for class metadata etc. Just like in the JRockit and J9 JVMs, native memory is now used for class metadata, and it will dynamically grow as needed. The equivalent of java.lang.OutOfMemoryError: PermGen will be much harder to provoke. To influence when to start attempting to reclaim metaspace memory, check out the [MaxMetaspaceSize flag](https:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/tools\/unix\/java.html).&lt;\/li&gt;&lt;li&gt;-XX:MaxPermSize=256m: Ignored in Java 8 and removed in Java 9. PermGen was removed in JDK 8, since Java users should not need to know up front how much memory to reserve for class metadata etc. Just like in the JRockit and J9 JVMs, native memory is now used for class metadata, and it will dynamically grow as needed. The equivalent of java.lang.OutOfMemoryError: PermGen will be much harder to provoke. To influence when to start attempting to reclaim metaspace memory, check out the [MaxMetaspaceSize flag](https:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/tools\/unix\/java.html).&lt;\/li&gt;&lt;\/ul&gt; Deprecated option flags should be avoided. In some cases they enable legacy code and in other cases they are ignored completely. They will usually be removed in a later Java release.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -3173,2 +3133,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No problems were found with the recording settings.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -3178,2 +3137,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The recording does not seem to contain passwords in the application arguments.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -3187,2 +3145,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The recording does not seem to contain passwords in the system properties.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -3193,4 +3150,1 @@\n-            <summary>0.089 % of the total allocation (2.07 GiB) is caused by conversion from primitive types to object types. The most common object type that primitives are converted into is ''java.lang.Integer''.<\/summary>\n-            <explanation>\n-The most common object type that primitives are converted into is ''java.lang.Integer'', which causes 1.11 MiB to be allocated. The most common call site is ''weblogic.socket.NIOSocketMuxer$DirectBufferPool weblogic.socket.NIOSocketMuxer$NIOOutputStream.initPool():887''.\n-Conversion from primitives to the corresponding object types can either be done explicitly, or be caused by autoboxing. If a considerable amount of the total allocation is caused by such conversions, consider changing the application source code to avoid this behavior. Look at the allocation stack traces to see which parts of the code to change. This rule finds the calls to the valueOf method for any of the eight object types that have primitive counterparts.<\/explanation>\n+            <summary>No allocation was caused by conversion from primitive types to the corresponding object types.<\/summary>\n@@ -3204,3 +3158,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No long socket read pauses were found in this recording (the longest was 105.982 ms).<\/summary>\n-            <explanation>Note that there are some socket read patterns with high duration reads that we consider to be normal and are therefore excluded. Such patterns include JMX RMI communication and MQ series.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -3210,3 +3162,1 @@\n-            <severity>Information<\/severity>\n-            <summary>There are long socket write pauses in this recording (the longest is 349.745 ms).<\/summary>\n-            <explanation>The longest recorded socket write took 349.745 ms to write 81 B to the host at 10.161.190.213. Average time of recorded IO: 37.121 ms. Total time of recorded IO: 1.077 s. Total time of recorded IO for the host 10.161.190.213: 398.835 ms. Note that there are some socket write patterns with high duration writes that we consider to be normal and are therefore excluded. Such patterns include JMX RMI communication.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -3216,4 +3166,2 @@\n-            <severity>Warning<\/severity>\n-            <summary>Some stack traces were truncated in this recording.<\/summary>\n-            <explanation>The Flight Recorder is configured with a maximum captured stack depth of 64. 35.7 % of all traces were larger than this option, and were therefore truncated. If more detailed traces are required, increase the ''-XX:FlightRecorderOptions=stackdepth=&lt;value&gt;'' value.\n-Events of the following types have truncated stack traces: &lt;ul&gt;&lt;li&gt;Allocation Requiring GC (31.6 % truncated traces)&lt;\/li&gt;&lt;li&gt;Allocation in new TLAB (42.4 % truncated traces)&lt;\/li&gt;&lt;li&gt;Allocation outside TLAB (60.7 % truncated traces)&lt;\/li&gt;&lt;li&gt;Class Load (42.8 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Business Method Invoke (47.1 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Business Method Post Invoke (44.4 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Business Method Post Invoke Cleanup (47.1 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Business Method Pre Invoke (44.4 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Pool Manager Post Invoke (47.1 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Pool Manager Pre Invoke (47.1 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB PoolManager Create (32.7 % truncated traces)&lt;\/li&gt;&lt;li&gt;File Read (100 % truncated traces)&lt;\/li&gt;&lt;li&gt;File Write (32.6 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Connection Close (73 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Connection Prepare (54.4 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Connection Release (65 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Statement Creation (54.4 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Statement Execute (54.4 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Statement Execute Begin (54.4 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Transaction Commit (65 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Transaction End (65.6 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Transaction Is Same RM (6.59 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Transaction Start (100 % truncated traces)&lt;\/li&gt;&lt;li&gt;JTA Transaction Commit (51 % truncated traces)&lt;\/li&gt;&lt;li&gt;JTA Transaction End (51.5 % truncated traces)&lt;\/li&gt;&lt;li&gt;JTA Transaction Start (80 % truncated traces)&lt;\/li&gt;&lt;li&gt;Java Error (29.1 % truncated traces)&lt;\/li&gt;&lt;li&gt;Java Monitor Blocked (1.09 % truncated traces)&lt;\/li&gt;&lt;li&gt;Java Monitor Wait (0.134 % truncated traces)&lt;\/li&gt;&lt;li&gt;Java Thread Park (0.223 % truncated traces)&lt;\/li&gt;&lt;li&gt;Java Thread Sleep (33.3 % truncated traces)&lt;\/li&gt;&lt;li&gt;Method Profiling Sample (24.3 % truncated traces)&lt;\/li&gt;&lt;li&gt;Servlet Execute (26.2 % truncated traces)&lt;\/li&gt;&lt;li&gt;Servlet Request Dispatch (45 % truncated traces)&lt;\/li&gt;&lt;li&gt;Servlet Response Write Headers (0.753 % truncated traces)&lt;\/li&gt;&lt;li&gt;Socket Read (41.6 % truncated traces)&lt;\/li&gt;&lt;li&gt;Socket Write (20.6 % truncated traces)&lt;\/li&gt;&lt;li&gt;Webservices JAXRPC Client Request (45.4 % truncated traces)&lt;\/li&gt;&lt;li&gt;Webservices JAXRPC Client Response (100 % truncated traces)&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n+            <severity>OK<\/severity>\n+            <summary>No stack traces were truncated in this recording.<\/summary>\n@@ -3223,7 +3171,1 @@\n-            <severity>OK<\/severity>\n-            <summary>Approximately 1,746 % of the live set consists of the internal array type of strings (''char[]'' for this JDK version).\n-The heap is around 22.3 % full. There is likely no big benefit from enabling string deduplication.<\/summary>\n-            <explanation>String deduplication is enabled using the JVM flag '-XX:+UseStringDeduplication'. This flag can be used together with the G1 garbage collector in JDK 8u20 or later, or with the Shenandoah garbage collector.\n-To validate if this gives a performance improvement for your application, create flight recordings both with and without string deduplication. For the run with string deduplication enabled, also enable statistics with '-XX:+PrintStringDeduplicationStatistics' for JDK 8 or '-Xlog:stringdedup*=debug' for JDK 9. Check if the heap live set decrease in the recording with string deduplication enabled is larger than the size of the string deduplication metadata table. The size of the metadata table is printed in the statistics output as 'Table\/Memory Usage: XX MB'\n-You can read more about string deduplication in the java options documentation or in [JEP 192](https:\/\/openjdk.java.net\/jeps\/192).\n-String deduplication is only supported when using the G1 (JDK 8u20+) or Shenandoah garbage collectors. If you want to use this feature you can enable G1 by using '-XX:+UseG1GC', or enable Shenandoah by using '-XX:+UseShenandoahGC'.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -3239,1 +3181,1 @@\n-            <summary>The program allocated 2.39 % of the memory outside of TLABs.<\/summary>\n+            <summary>The program allocated 4.04 % of the memory outside of TLABs.<\/summary>\n@@ -3245,1 +3187,1 @@\n-            <summary>No excessively long VM operations were found in this recording (the longest was 592.965 ms).<\/summary>\n+            <summary>No excessively long VM operations were found in this recording (the longest was 103.369 ms).<\/summary>\n@@ -3258,1 +3200,1 @@\n-        <file>wls-medrec-jdk9.jfr<\/file>\n+        <file>openjdk8u292.jfr<\/file>\n@@ -3323,4 +3265,6 @@\n-            <severity>Information<\/severity>\n-            <summary>5 duplicated JVM flags found.<\/summary>\n-            <explanation>Duplicated JVM flags may be caused by multiple layers of scripts used when launching the application. Having duplicate flags is dangerous as changing one of the flags in one of the scripts may not have the intended effect. This can be especially dangerous for security related system properties. The following flags were duplicated: &lt;ul&gt;&lt;li&gt;-XX:NewSize=65m,-XX:NewSize=65m&lt;\/li&gt;&lt;li&gt;-Dweblogic.home=C:\\weblogic\\src122130_build\\Oracle_Home\\wlserver\/server,-Dweblogic.home=C:\\weblogic\\SRC122~1\\ORACLE~1\\wlserver\\server&lt;\/li&gt;&lt;li&gt;-Xmx500m,-Xmx500m&lt;\/li&gt;&lt;li&gt;-Xms160m,-Xms160m&lt;\/li&gt;&lt;li&gt;-XX:MaxNewSize=65m,-XX:MaxNewSize=65m&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n-            <solution>Try to find all the places where the flag is defined and keep only one.<\/solution>\n+            <severity>OK<\/severity>\n+            <summary>There were no duplicate JVM flags on the command line.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>DynamicAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -3344,1 +3288,1 @@\n-\t\t<rule>\n+        <rule>\n@@ -3362,6 +3306,0 @@\n-            <severity>Warning<\/severity>\n-            <summary>The recording is from an early access build.<\/summary>\n-            <explanation>This recording is from an early access build of the JRE (Java HotSpot(TM) 64-Bit Server VM (9-ea+148) for windows-amd64 JRE (9-ea+148), built on Dec  7 2016 18:47:38 by &amp;#34;javare&amp;#34; with MS VC++ 12.0 (VS2013)). The automated analysis is not supported, and you may see errors when attempting to analyze the recording.<\/explanation>\n-        <\/rule>\n-        <rule>\n-            <id>JfrPeriodicEventsFix<\/id>\n@@ -3369,1 +3307,1 @@\n-            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n+            <summary>The JVM version used for this recording has full Flight Recorder support.<\/summary>\n@@ -3391,1 +3329,0 @@\n-            <summary>Too few events to calculate the result.<\/summary>\n@@ -3429,0 +3366,6 @@\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>Warning<\/severity>\n+            <summary>The version of OpenJDK 8 you are running is lacking an important performance fix.<\/summary>\n+            <explanation>The version of OpenJDK (OpenJDK 64-Bit Server VM (25.292-b10) for linux-amd64 JRE (1.8.0_292-b10), built on Apr  9 2021 02:15:01 by &amp;#34;openjdk&amp;#34; with gcc 4.4.7 20120313 (Red Hat 4.4.7-23)) you are running is lacking an important performance fix. Upgrading to version 8u302 or later can, in some cases, improve your performance quite radically. See JDK-8266723 for more information. An alternative can be to disable any periodic events not needed, such as the NativeExecutionSample event.<\/explanation>\n+        <\/rule>\n@@ -3453,0 +3396,4 @@\n+        <rule>\n+            <id>MultipleAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -3455,2 +3402,2 @@\n-            <severity>OK<\/severity>\n-            <summary>No undocumented, deprecated or non-recommended option flags were detected.<\/summary>\n+            <severity>Not Applicable<\/severity>\n+            <summary>No events with JVM arguments were recorded.<\/summary>\n@@ -3493,4 +3440,2 @@\n-            <severity>Warning<\/severity>\n-            <summary>Some stack traces were truncated in this recording.<\/summary>\n-            <explanation>The Flight Recorder is configured with a maximum captured stack depth of 64. 17.5 % of all traces were larger than this option, and were therefore truncated. If more detailed traces are required, increase the ''-XX:FlightRecorderOptions=stackdepth=&lt;value&gt;'' value.\n-Events of the following types have truncated stack traces: &lt;ul&gt;&lt;li&gt;Debug (1.59 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Business Method Invoke (71.3 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Business Method Post Invoke (71.3 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Business Method Post Invoke Cleanup (71.3 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Business Method Pre Invoke (71.3 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Pool Manager Create (75 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Pool Manager Post Invoke (71.3 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Pool Manager Pre Invoke (71.3 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Connection Close (96.8 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Connection Prepare (100 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Connection Release (85.7 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Statement Creation (100 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Statement Execute (96.7 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Statement Execute Begin (96.7 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Transaction Commit (45 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Transaction End (45 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Transaction Is Same RM (1.79 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Transaction Start (100 % truncated traces)&lt;\/li&gt;&lt;li&gt;JTA Transaction Commit (36.4 % truncated traces)&lt;\/li&gt;&lt;li&gt;JTA Transaction End (6.06 % truncated traces)&lt;\/li&gt;&lt;li&gt;JTA Transaction Start (16.7 % truncated traces)&lt;\/li&gt;&lt;li&gt;Servlet Response Write Headers (1.87 % truncated traces)&lt;\/li&gt;&lt;li&gt;Webservices JAXRPC Client Request (50 % truncated traces)&lt;\/li&gt;&lt;li&gt;Webservices JAXRPC Client Response (100 % truncated traces)&lt;\/li&gt;&lt;li&gt;Webservices JAXWS Endpoint (100 % truncated traces)&lt;\/li&gt;&lt;li&gt;Webservices JAXWS Resource (50 % truncated traces)&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n+            <severity>Not Applicable<\/severity>\n+            <summary>No events with stack traces were recorded.<\/summary>\n@@ -3522,1 +3467,1 @@\n-            <id>biasedLockingRevocationPause<\/id>\n+            <id>Allocations.class<\/id>\n@@ -3526,1 +3471,1 @@\n-            <id>VMOperations<\/id>\n+            <id>Allocations.thread<\/id>\n@@ -3530,1 +3475,1 @@\n-            <id>TlabAllocationRatio<\/id>\n+            <id>ApplicationHalts<\/id>\n@@ -3534,1 +3479,11 @@\n-            <id>StackdepthSetting<\/id>\n+            <id>BufferLost<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No Flight Recorder buffers were lost during the recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>BytecodeVerification<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The application ran with bytecode verification enabled.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLeak<\/id>\n@@ -3536,1 +3491,0 @@\n-            <summary>No events with stack traces were recorded.<\/summary>\n@@ -3539,1 +3493,1 @@\n-            <id>PasswordsInSystemProperties<\/id>\n+            <id>ClassLoading<\/id>\n@@ -3543,1 +3497,1 @@\n-            <id>PasswordsInEnvironment<\/id>\n+            <id>CodeCache<\/id>\n@@ -3547,1 +3501,1 @@\n-            <id>OverAggressiveRecordingSetting<\/id>\n+            <id>CompareCpu<\/id>\n@@ -3551,1 +3505,1 @@\n-            <id>ManyRunningProcesses<\/id>\n+            <id>CompressedOops<\/id>\n@@ -3555,1 +3509,1 @@\n-            <id>ManagementAgent<\/id>\n+            <id>ContextSwitch<\/id>\n@@ -3559,1 +3513,1 @@\n-            <id>LowOnPhysicalMemory<\/id>\n+            <id>DMSIncident<\/id>\n@@ -3563,1 +3517,1 @@\n-            <id>IncreasingMetaSpaceLiveSet<\/id>\n+            <id>DebugNonSafepoints<\/id>\n@@ -3567,1 +3521,1 @@\n-            <id>IncreasingLiveSet<\/id>\n+            <id>DiscouragedVmOptions<\/id>\n@@ -3571,1 +3525,1 @@\n-            <id>HighJvmCpu<\/id>\n+            <id>DumpReason<\/id>\n@@ -3575,1 +3529,6 @@\n-            <id>HighGc<\/id>\n+            <id>DuplicateFlags<\/id>\n+            <severity>OK<\/severity>\n+            <summary>There were no duplicate JVM flags on the command line.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>DynamicAgents<\/id>\n@@ -3579,1 +3538,1 @@\n-            <id>GcPauseRatio<\/id>\n+            <id>Errors<\/id>\n@@ -3583,1 +3542,1 @@\n-            <id>GcPauseTargetRule<\/id>\n+            <id>Exceptions<\/id>\n@@ -3587,1 +3546,1 @@\n-            <id>GcOptions<\/id>\n+            <id>Fatal Errors<\/id>\n@@ -3591,1 +3550,1 @@\n-            <id>GcFreedRatio<\/id>\n+            <id>FewSampledThreads<\/id>\n@@ -3595,1 +3554,1 @@\n-            <id>GcInvertedParallelism<\/id>\n+            <id>FileForce<\/id>\n@@ -3599,1 +3558,1 @@\n-            <id>GarbageCollectionInfoRule<\/id>\n+            <id>FileRead<\/id>\n@@ -3603,1 +3562,5 @@\n-            <id>FullGc<\/id>\n+            <id>FileWrite<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FinalizersRun<\/id>\n@@ -3605,1 +3568,0 @@\n-            <summary>This rule is only valid for CMS and G1 Garbage Collectors, neither of which were detected for this JVM.<\/summary>\n@@ -3614,1 +3576,1 @@\n-            <id>FileWrite<\/id>\n+            <id>FullGc<\/id>\n@@ -3616,0 +3578,1 @@\n+            <summary>This rule is only valid for CMS and G1 Garbage Collectors, neither of which were detected for this JVM.<\/summary>\n@@ -3618,1 +3581,1 @@\n-            <id>FileRead<\/id>\n+            <id>GarbageCollectionInfoRule<\/id>\n@@ -3622,1 +3585,1 @@\n-            <id>FinalizersRun<\/id>\n+            <id>GcFreedRatio<\/id>\n@@ -3626,1 +3589,1 @@\n-            <id>FewSampledThreads<\/id>\n+            <id>GcInvertedParallelism<\/id>\n@@ -3629,2 +3592,2 @@\n-\t\t<rule>\n-            <id>FileForce<\/id>\n+        <rule>\n+            <id>GcOptions<\/id>\n@@ -3634,1 +3597,1 @@\n-            <id>Exceptions<\/id>\n+            <id>GcPauseRatio<\/id>\n@@ -3638,1 +3601,1 @@\n-            <id>DiscouragedVmOptions<\/id>\n+            <id>GcPauseTargetRule<\/id>\n@@ -3642,1 +3605,1 @@\n-            <id>CompressedOops<\/id>\n+            <id>HeapContent<\/id>\n@@ -3646,1 +3609,1 @@\n-            <id>CompareCpu<\/id>\n+            <id>HeapDump<\/id>\n@@ -3650,1 +3613,1 @@\n-            <id>ApplicationHalts<\/id>\n+            <id>HighGc<\/id>\n@@ -3654,1 +3617,1 @@\n-            <id>Allocations.thread<\/id>\n+            <id>HighJvmCpu<\/id>\n@@ -3658,1 +3621,1 @@\n-            <id>Allocations.class<\/id>\n+            <id>IncreasingLiveSet<\/id>\n@@ -3662,1 +3625,1 @@\n-            <id>biasedLockingRevocation<\/id>\n+            <id>IncreasingMetaSpaceLiveSet<\/id>\n@@ -3666,1 +3629,1 @@\n-            <id>StringDeduplication<\/id>\n+            <id>JavaBlocking<\/id>\n@@ -3670,2 +3633,3 @@\n-            <id>SocketWrite<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n@@ -3674,1 +3638,1 @@\n-            <id>SocketRead<\/id>\n+            <id>LongGcPause<\/id>\n@@ -3678,1 +3642,1 @@\n-            <id>ProcessStarted<\/id>\n+            <id>LowOnPhysicalMemory<\/id>\n@@ -3682,1 +3646,1 @@\n-            <id>PrimitiveToObjectConversion<\/id>\n+            <id>ManagementAgent<\/id>\n@@ -3686,3 +3650,2 @@\n-            <id>PasswordsInArguments<\/id>\n-            <severity>OK<\/severity>\n-            <summary>The recording does not seem to contain passwords in the application arguments.<\/summary>\n+            <id>ManyRunningProcesses<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -3691,1 +3654,1 @@\n-            <id>Options<\/id>\n+            <id>MetaspaceOom<\/id>\n@@ -3693,1 +3656,0 @@\n-            <summary>No events with JVM arguments were recorded.<\/summary>\n@@ -3700,1 +3662,1 @@\n-            <id>MetaspaceOom<\/id>\n+            <id>MultipleAgents<\/id>\n@@ -3704,1 +3666,1 @@\n-            <id>LongGcPause<\/id>\n+            <id>Options<\/id>\n@@ -3706,0 +3668,1 @@\n+            <summary>No events with JVM arguments were recorded.<\/summary>\n@@ -3708,1 +3671,5 @@\n-            <id>JfrPeriodicEventsFix<\/id>\n+            <id>OverAggressiveRecordingSetting<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInArguments<\/id>\n@@ -3710,1 +3677,1 @@\n-            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n+            <summary>The recording does not seem to contain passwords in the application arguments.<\/summary>\n@@ -3713,1 +3680,1 @@\n-            <id>JavaBlocking<\/id>\n+            <id>PasswordsInEnvironment<\/id>\n@@ -3717,1 +3684,1 @@\n-            <id>HeapDump<\/id>\n+            <id>PasswordsInSystemProperties<\/id>\n@@ -3721,1 +3688,1 @@\n-            <id>HeapContent<\/id>\n+            <id>PrimitiveToObjectConversion<\/id>\n@@ -3725,1 +3692,1 @@\n-            <id>Fatal Errors<\/id>\n+            <id>ProcessStarted<\/id>\n@@ -3729,1 +3696,1 @@\n-            <id>Errors<\/id>\n+            <id>SocketRead<\/id>\n@@ -3733,3 +3700,2 @@\n-            <id>DuplicateFlags<\/id>\n-            <severity>OK<\/severity>\n-            <summary>There were no duplicate JVM flags on the command line.<\/summary>\n+            <id>SocketWrite<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -3738,1 +3704,1 @@\n-            <id>DumpReason<\/id>\n+            <id>StackdepthSetting<\/id>\n@@ -3740,0 +3706,1 @@\n+            <summary>No events with stack traces were recorded.<\/summary>\n@@ -3742,1 +3709,1 @@\n-            <id>DebugNonSafepoints<\/id>\n+            <id>StringDeduplication<\/id>\n@@ -3746,1 +3713,1 @@\n-            <id>DMSIncident<\/id>\n+            <id>TlabAllocationRatio<\/id>\n@@ -3750,1 +3717,1 @@\n-            <id>ContextSwitch<\/id>\n+            <id>VMOperations<\/id>\n@@ -3754,1 +3721,1 @@\n-            <id>CodeCache<\/id>\n+            <id>biasedLockingRevocation<\/id>\n@@ -3758,1 +3725,1 @@\n-            <id>ClassLoading<\/id>\n+            <id>biasedLockingRevocationPause<\/id>\n@@ -3761,0 +3728,3 @@\n+    <\/report>\n+    <report>\n+        <file>parallel-gc_cpu.jfr<\/file>\n@@ -3762,2 +3732,4 @@\n-            <id>ClassLeak<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>Allocations.class<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The most allocated type is likely ''java.util.ArrayList'', most commonly allocated by: &lt;ul&gt;&lt;li&gt;Collection oracle.jrockit.jfr.JFRImpl.getRecordings()&lt;\/li&gt;&lt;li&gt;void oracle.jrockit.jfr.MetaProducer.onNewChunk()&lt;\/li&gt;&lt;li&gt;void oracle.jrockit.jfr.JFRImpl.onNewChunk()&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Frequently allocated types are good places to start when trying to reduce garbage collections. Look at where the most common types are being allocated to see if many instances are created along the same call path. Try to reduce the number of instances created by invoking the most commonly taken paths less.<\/explanation>\n@@ -3766,1 +3738,1 @@\n-            <id>BytecodeVerification<\/id>\n+            <id>Allocations.thread<\/id>\n@@ -3768,1 +3740,9 @@\n-            <summary>The application ran with bytecode verification enabled.<\/summary>\n+            <summary>The most allocations were likely done by thread ''RMI TCP Connection(1)-127.0.0.1'' at: &lt;ul&gt;&lt;li&gt;void java.io.ObjectInputStream$BlockDataInputStream.&amp;lt;init&amp;gt;(ObjectInputStream, InputStream)&lt;\/li&gt;&lt;li&gt;void java.io.ObjectInputStream.&amp;lt;init&amp;gt;(InputStream)&lt;\/li&gt;&lt;li&gt;void sun.rmi.server.MarshalInputStream.&amp;lt;init&amp;gt;(InputStream)&lt;\/li&gt;&lt;li&gt;void sun.rmi.transport.ConnectionInputStream.&amp;lt;init&amp;gt;(InputStream)&lt;\/li&gt;&lt;li&gt;ObjectInput sun.rmi.transport.StreamRemoteCall.getInputStream()&lt;\/li&gt;&lt;li&gt;boolean sun.rmi.transport.Transport.serviceCall(RemoteCall)&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Many allocations performed by the same thread might indicate a problem in a multi-threaded program. Look at the stack traces for the thread with the highest allocation rate. See if the allocation rate can be brought down, or balanced among the active threads.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>ApplicationHalts<\/id>\n+            <severity>OK<\/severity>\n+            <summary>Application efficiency was not highly affected by halts.<\/summary>\n+            <explanation>The highest ratio of application halts to execution time was 0 % during 4\/4\/2014 11:17:05.000 AM – 11:18:05 AM. 0 % of the halts were for reasons other than GC. The halts ratio for the entire recording was 0 %. 0 % of the total halts were for reasons other than GC.\n+Enabling the following event types would improve the accuracy of this rule: jdk.SafepointBegin<\/explanation>\n@@ -3775,3 +3755,0 @@\n-    <\/report>\n-    <report>\n-        <file>openjdk8u292.jfr<\/file>\n@@ -3779,2 +3756,3 @@\n-            <id>biasedLockingRevocationPause<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>BytecodeVerification<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The application ran with bytecode verification enabled.<\/summary>\n@@ -3783,1 +3761,1 @@\n-            <id>VMOperations<\/id>\n+            <id>ClassLeak<\/id>\n@@ -3787,1 +3765,1 @@\n-            <id>TlabAllocationRatio<\/id>\n+            <id>ClassLoading<\/id>\n@@ -3791,1 +3769,1 @@\n-            <id>StackdepthSetting<\/id>\n+            <id>CodeCache<\/id>\n@@ -3793,1 +3771,0 @@\n-            <summary>No events with stack traces were recorded.<\/summary>\n@@ -3796,2 +3773,4 @@\n-            <id>PasswordsInSystemProperties<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>CompareCpu<\/id>\n+            <severity>OK<\/severity>\n+            <summary>An average CPU load of 0 % was caused by other processes for during 4\/4\/2014 11:17:07.000 AM – 11:17:08 AM.<\/summary>\n+            <explanation>The application performance can be affected when the machine is under heavy load and there are other processes that use CPU or other resources on the same computer. To profile representatively or get higher throughput, shut down other resource intensive processes running on the machine.<\/explanation>\n@@ -3800,2 +3779,3 @@\n-            <id>PasswordsInEnvironment<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>CompressedOops<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The settings for Compressed Oops were OK.<\/summary>\n@@ -3804,1 +3784,1 @@\n-            <id>OverAggressiveRecordingSetting<\/id>\n+            <id>ContextSwitch<\/id>\n@@ -3808,1 +3788,1 @@\n-            <id>ManyRunningProcesses<\/id>\n+            <id>DMSIncident<\/id>\n@@ -3812,2 +3792,5 @@\n-            <id>ManagementAgent<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>DebugNonSafepoints<\/id>\n+            <severity>Information<\/severity>\n+            <summary>DebugNonSafepoints was not enabled.<\/summary>\n+            <explanation>If DebugNonSafepoints is not enabled, the method profiling data will be less accurate as threads that are not at safepoints will not be correctly sampled. There is a slight performance overhead when enabling these flags. For more information see [HotSpot Runtime Overview\/Thread Management](http:\/\/openjdk.java.net\/groups\/hotspot\/docs\/RuntimeOverview.html#Thread%20Management|outline]).<\/explanation>\n+            <solution>Use the following JVM flags to enable this: '-XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints'.<\/solution>\n@@ -3816,3 +3799,4 @@\n-            <id>LowOnPhysicalMemory<\/id>\n-            <severity>Not Applicable<\/severity>\n-        <\/rule>\n+            <id>DiscouragedVmOptions<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No problems were found with the VM options.<\/summary>\n+        <\/rule>\n@@ -3820,1 +3804,1 @@\n-            <id>IncreasingMetaSpaceLiveSet<\/id>\n+            <id>DumpReason<\/id>\n@@ -3824,2 +3808,3 @@\n-            <id>IncreasingLiveSet<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>DuplicateFlags<\/id>\n+            <severity>OK<\/severity>\n+            <summary>There were no duplicate JVM flags on the command line.<\/summary>\n@@ -3828,1 +3813,1 @@\n-            <id>HighJvmCpu<\/id>\n+            <id>DynamicAgents<\/id>\n@@ -3832,1 +3817,1 @@\n-            <id>HighGc<\/id>\n+            <id>Errors<\/id>\n@@ -3836,2 +3821,4 @@\n-            <id>GcPauseRatio<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>Exceptions<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The program generated 0 exceptions per second during 4\/4\/2014 11:17:06.152.000 AM – 11:17:07.152 AM.<\/summary>\n+            <explanation>Throwing exceptions is more expensive than normal code execution, which means that they should only be used for exceptional situations. Investigate the thrown exceptions to see if any of them can be avoided with a non-exceptional control flow.<\/explanation>\n@@ -3840,1 +3827,1 @@\n-            <id>GcPauseTargetRule<\/id>\n+            <id>Fatal Errors<\/id>\n@@ -3844,2 +3831,4 @@\n-            <id>GcOptions<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>FewSampledThreads<\/id>\n+            <severity>OK<\/severity>\n+            <summary>There were no problems with the amount of sampled threads.<\/summary>\n+            <explanation>There are more sampled threads than the amount of hardware threads. This indicates that the application has enough parallelism for the available hardware.<\/explanation>\n@@ -3848,1 +3837,1 @@\n-            <id>GcFreedRatio<\/id>\n+            <id>FileForce<\/id>\n@@ -3852,2 +3841,3 @@\n-            <id>GcInvertedParallelism<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>FileRead<\/id>\n+            <severity>OK<\/severity>\n+            <summary>There are no file read events in this recording.<\/summary>\n@@ -3856,2 +3846,3 @@\n-            <id>GarbageCollectionInfoRule<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>FileWrite<\/id>\n+            <severity>OK<\/severity>\n+            <summary>There are no file write events in this recording.<\/summary>\n@@ -3860,1 +3851,1 @@\n-            <id>FullGc<\/id>\n+            <id>FinalizersRun<\/id>\n@@ -3862,1 +3853,0 @@\n-            <summary>This rule is only valid for CMS and G1 Garbage Collectors, neither of which were detected for this JVM.<\/summary>\n@@ -3866,2 +3856,3 @@\n-            <severity>OK<\/severity>\n-            <summary>The JVM version used for this recording has full Flight Recorder support.<\/summary>\n+            <severity>Warning<\/severity>\n+            <summary>The recording is from an early access build.<\/summary>\n+            <explanation>This recording is from an early access build of the JRE (Java HotSpot(TM) Client VM (25.20-b08) for linux-x86 JRE (1.8.0_20-ea-b08), built on Apr  1 2014 19:40:24 by &amp;#34;java_re&amp;#34; with gcc 4.3.0 20080428 (Red Hat 4.3.0-8)). The automated analysis is not supported, and you may see errors when attempting to analyze the recording.<\/explanation>\n@@ -3870,2 +3861,3 @@\n-            <id>FileWrite<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>FullGc<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No Stop-the-World, Full GC events detected.<\/summary>\n@@ -3874,1 +3866,1 @@\n-            <id>FileRead<\/id>\n+            <id>GarbageCollectionInfoRule<\/id>\n@@ -3878,2 +3870,3 @@\n-            <id>FinalizersRun<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>GcFreedRatio<\/id>\n+            <severity>OK<\/severity>\n+            <summary>Only 0 heap summary events were found, this rule requires at least 10 events to be able to calculate a relevant result. This likely means that only a few garbage collections occurred during the recording. Having few garbage collections is generally a good sign.<\/summary>\n@@ -3882,1 +3875,1 @@\n-            <id>FewSampledThreads<\/id>\n+            <id>GcInvertedParallelism<\/id>\n@@ -3885,3 +3878,5 @@\n-\t\t<rule>\n-            <id>FileForce<\/id>\n-            <severity>Not Applicable<\/severity>\n+        <rule>\n+            <id>GcOptions<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The runtime used 2 GC threads on a machine with 1 CPU cores.<\/summary>\n+            <explanation>It's suboptimal to use more GC threads than available cores. Removing the '-XX:ParallelGCThreads' flag will allow the JVM to set the number of GC threads automatically.<\/explanation>\n@@ -3890,2 +3885,5 @@\n-            <id>Exceptions<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>GcPauseRatio<\/id>\n+            <severity>OK<\/severity>\n+            <summary>Application efficiency was not highly affected by GC pauses.<\/summary>\n+            <explanation>The highest ratio between garbage collection pauses and execution time was 0 % during 4\/4\/2014 11:17:05.000 AM – 11:18:05 AM. The garbage collection pause ratio of the entire recording was 0 %.<\/explanation>\n+            <solution>Pause times may be reduced by increasing the heap size or by trying to reduce allocation.<\/solution>\n@@ -3894,1 +3892,1 @@\n-            <id>DiscouragedVmOptions<\/id>\n+            <id>GcPauseTargetRule<\/id>\n@@ -3898,1 +3896,1 @@\n-            <id>CompressedOops<\/id>\n+            <id>HeapContent<\/id>\n@@ -3902,1 +3900,1 @@\n-            <id>CompareCpu<\/id>\n+            <id>HeapDump<\/id>\n@@ -3906,2 +3904,3 @@\n-            <id>ApplicationHalts<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>HighGc<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The runtime did not spend much time performing garbage collections.<\/summary>\n@@ -3910,2 +3909,4 @@\n-            <id>Allocations.thread<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>HighJvmCpu<\/id>\n+            <severity>Information<\/severity>\n+            <summary>This recording contains few profiling samples even though the CPU load is high.<\/summary>\n+            <explanation>The profiling data is thus likely not relevant. This might be because the application is running a lot JNI code or that the JVM is spending a lot of time in GC, class loading, JIT compilation etc.<\/explanation>\n@@ -3914,1 +3915,1 @@\n-            <id>Allocations.class<\/id>\n+            <id>IncreasingLiveSet<\/id>\n@@ -3916,0 +3917,1 @@\n+            <summary>Too few events to calculate the result.<\/summary>\n@@ -3918,2 +3920,3 @@\n-            <id>biasedLockingRevocation<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>IncreasingMetaSpaceLiveSet<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The class data does not seem to increase during the recording.<\/summary>\n@@ -3922,1 +3925,1 @@\n-            <id>StringDeduplication<\/id>\n+            <id>JavaBlocking<\/id>\n@@ -3926,2 +3929,3 @@\n-            <id>SocketWrite<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n@@ -3930,2 +3934,3 @@\n-            <id>SocketRead<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>LongGcPause<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The application did not cause any long GC pause times.<\/summary>\n@@ -3934,2 +3939,3 @@\n-            <id>ProcessStarted<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>LowOnPhysicalMemory<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The system did not run low on physical memory during this recording.<\/summary>\n@@ -3938,2 +3944,3 @@\n-            <id>PrimitiveToObjectConversion<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>ManagementAgent<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No problems were found with the management agent settings.<\/summary>\n@@ -3942,1 +3949,1 @@\n-            <id>PasswordsInArguments<\/id>\n+            <id>ManyRunningProcesses<\/id>\n@@ -3944,1 +3951,3 @@\n-            <summary>The recording does not seem to contain passwords in the application arguments.<\/summary>\n+            <summary>137 processes were running while this Flight Recording was made.<\/summary>\n+            <explanation>At 4\/4\/14 11:17:10.326 AM, a total of 137 other processes were running on the host machine that this Flight Recording was made on.<\/explanation>\n+            <solution>If this is a server environment, it may be good to only run other critical processes on that machine.<\/solution>\n@@ -3947,1 +3956,1 @@\n-            <id>Options<\/id>\n+            <id>MetaspaceOom<\/id>\n@@ -3949,1 +3958,0 @@\n-            <summary>No events with JVM arguments were recorded.<\/summary>\n@@ -3953,1 +3961,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No methods where optimization would be particularly efficient could be detected.<\/summary>\n@@ -3956,1 +3965,1 @@\n-            <id>MetaspaceOom<\/id>\n+            <id>MultipleAgents<\/id>\n@@ -3960,2 +3969,3 @@\n-            <id>LongGcPause<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>Options<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No undocumented, deprecated or non-recommended option flags were detected.<\/summary>\n@@ -3964,4 +3974,3 @@\n-            <id>JfrPeriodicEventsFix<\/id>\n-            <severity>Warning<\/severity>\n-            <summary>The version of OpenJDK 8 you are running is lacking an important performance fix.<\/summary>\n-            <explanation>The version of OpenJDK (OpenJDK 64-Bit Server VM (25.292-b10) for linux-amd64 JRE (1.8.0_292-b10), built on Apr  9 2021 02:15:01 by &amp;#34;openjdk&amp;#34; with gcc 4.4.7 20120313 (Red Hat 4.4.7-23)) you are running is lacking an important performance fix. Upgrading to version 8u302 or later can, in some cases, improve your performance quite radically. See JDK-8266723 for more information. An alternative can be to disable any periodic events not needed, such as the NativeExecutionSample event.<\/explanation>\n+            <id>OverAggressiveRecordingSetting<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No problems were found with the recording settings.<\/summary>\n@@ -3970,2 +3979,3 @@\n-            <id>JavaBlocking<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>PasswordsInArguments<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The recording does not seem to contain passwords in the application arguments.<\/summary>\n@@ -3974,2 +3984,3 @@\n-            <id>HeapDump<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>PasswordsInEnvironment<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The recording does not seem to contain passwords in the environment variables.<\/summary>\n@@ -3978,2 +3989,3 @@\n-            <id>HeapContent<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>PasswordsInSystemProperties<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The recording does not seem to contain passwords in the system properties.<\/summary>\n@@ -3982,1 +3994,1 @@\n-            <id>Fatal Errors<\/id>\n+            <id>PrimitiveToObjectConversion<\/id>\n@@ -3986,1 +3998,1 @@\n-            <id>Errors<\/id>\n+            <id>ProcessStarted<\/id>\n@@ -3990,1 +4002,1 @@\n-            <id>DuplicateFlags<\/id>\n+            <id>SocketRead<\/id>\n@@ -3992,5 +4004,2 @@\n-            <summary>There were no duplicate JVM flags on the command line.<\/summary>\n-        <\/rule>\n-        <rule>\n-            <id>DumpReason<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <summary>SocketReadRuleFactory_TEXT_NO_EVENTS<\/summary>\n+            <explanation>Note that there are some socket read patterns with high duration reads that we consider to be normal and are therefore excluded. Such patterns include JMX RMI communication and MQ series.<\/explanation>\n@@ -3999,2 +4008,4 @@\n-            <id>DebugNonSafepoints<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>SocketWrite<\/id>\n+            <severity>OK<\/severity>\n+            <summary>There are no socket write events in this recording.<\/summary>\n+            <explanation>Note that there are some socket write patterns with high duration writes that we consider to be normal and are therefore excluded. Such patterns include JMX RMI communication.<\/explanation>\n@@ -4003,2 +4014,3 @@\n-            <id>DMSIncident<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>StackdepthSetting<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No stack traces were truncated in this recording.<\/summary>\n@@ -4007,1 +4019,1 @@\n-            <id>ContextSwitch<\/id>\n+            <id>StringDeduplication<\/id>\n@@ -4011,2 +4023,3 @@\n-            <id>CodeCache<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>TlabAllocationRatio<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No object allocations outside of TLABs detected.<\/summary>\n@@ -4015,2 +4028,3 @@\n-            <id>ClassLoading<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>VMOperations<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No excessively long VM operations were found in this recording (the longest was 0 s).<\/summary>\n@@ -4019,1 +4033,1 @@\n-            <id>ClassLeak<\/id>\n+            <id>biasedLockingRevocation<\/id>\n@@ -4023,6 +4037,1 @@\n-            <id>BytecodeVerification<\/id>\n-            <severity>OK<\/severity>\n-            <summary>The application ran with bytecode verification enabled.<\/summary>\n-        <\/rule>\n-        <rule>\n-            <id>BufferLost<\/id>\n+            <id>biasedLockingRevocationPause<\/id>\n@@ -4030,1 +4039,1 @@\n-            <summary>No Flight Recorder buffers were lost during the recording.<\/summary>\n+            <summary>No revocation of biased locks found.<\/summary>\n@@ -4034,3 +4043,3 @@\n-        <file>flight_recording_17eaMonitoredVM10440_3.jfr<\/file>\n-         <rule>\n-            <id>biasedLockingRevocationPause<\/id>\n+        <file>parallel-on-singlecpu.jfr<\/file>\n+        <rule>\n+            <id>Allocations.class<\/id>\n@@ -4038,1 +4047,2 @@\n-            <summary>No revocation of biased locks found.<\/summary>\n+            <summary>The most allocated type is likely ''java.lang.Object[]'', most commonly allocated by: &lt;ul&gt;&lt;li&gt;Object[] java.util.AbstractCollection.toArray()&lt;\/li&gt;&lt;li&gt;void java.util.ArrayList.&amp;lt;init&amp;gt;(Collection)&lt;\/li&gt;&lt;li&gt;Collection oracle.jrockit.jfr.JFRImpl.getRecordings()&lt;\/li&gt;&lt;li&gt;void oracle.jrockit.jfr.MetaProducer.onNewChunk()&lt;\/li&gt;&lt;li&gt;void oracle.jrockit.jfr.JFRImpl.onNewChunk()&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Frequently allocated types are good places to start when trying to reduce garbage collections. Look at where the most common types are being allocated to see if many instances are created along the same call path. Try to reduce the number of instances created by invoking the most commonly taken paths less.<\/explanation>\n@@ -4041,1 +4051,1 @@\n-            <id>SystemGc<\/id>\n+            <id>Allocations.thread<\/id>\n@@ -4043,1 +4053,2 @@\n-            <summary>No garbage collections were caused by System.gc().<\/summary>\n+            <summary>The most allocations were likely done by thread ''RMI TCP Connection(1)-127.0.0.1'' at: &lt;ul&gt;&lt;li&gt;Throwable java.lang.Throwable.fillInStackTrace(int)&lt;\/li&gt;&lt;li&gt;Throwable java.lang.Throwable.fillInStackTrace()&lt;\/li&gt;&lt;li&gt;void java.lang.Throwable.&amp;lt;init&amp;gt;(String)&lt;\/li&gt;&lt;li&gt;void java.lang.Exception.&amp;lt;init&amp;gt;(String)&lt;\/li&gt;&lt;li&gt;void java.lang.ReflectiveOperationException.&amp;lt;init&amp;gt;(String)&lt;\/li&gt;&lt;li&gt;void java.lang.NoSuchFieldException.&amp;lt;init&amp;gt;(String)&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Many allocations performed by the same thread might indicate a problem in a multi-threaded program. Look at the stack traces for the thread with the highest allocation rate. See if the allocation rate can be brought down, or balanced among the active threads.<\/explanation>\n@@ -4046,1 +4057,1 @@\n-            <id>VMOperations<\/id>\n+            <id>ApplicationHalts<\/id>\n@@ -4048,1 +4059,3 @@\n-            <summary>No excessively long VM operations were found in this recording (the longest was 54.343 ms).<\/summary>\n+            <summary>Application efficiency was not highly affected by halts.<\/summary>\n+            <explanation>The highest ratio of application halts to execution time was 0 % during 4\/4\/2014 8:54:33.000 AM – 8:55:33 AM. 0 % of the halts were for reasons other than GC. The halts ratio for the entire recording was 0 %. 0 % of the total halts were for reasons other than GC.\n+Enabling the following event types would improve the accuracy of this rule: jdk.SafepointBegin<\/explanation>\n@@ -4051,1 +4064,1 @@\n-            <id>TlabAllocationRatio<\/id>\n+            <id>BufferLost<\/id>\n@@ -4053,2 +4066,1 @@\n-            <summary>The program allocated 3.08 % of the memory outside of TLABs.<\/summary>\n-            <solution>Allocating objects outside of Thread Local Allocation Buffers (TLABs) is more expensive than allocating inside TLABs. This may be acceptable if the individual allocations are intended to be larger than a reasonable TLAB. It may be possible to avoid this by decreasing the size of the individual allocations. There are some TLAB related JVM flags that you can experiment with, but it is usually better to let the JVM manage TLAB sizes automatically.<\/solution>\n+            <summary>No Flight Recorder buffers were lost during the recording.<\/summary>\n@@ -4057,5 +4069,3 @@\n-            <id>StackdepthSetting<\/id>\n-            <severity>Warning<\/severity>\n-            <summary>Some stack traces were truncated in this recording.<\/summary>\n-            <explanation>The Flight Recorder is configured with a maximum captured stack depth of 64. 10.5&#xA0;% of all traces were larger than this option, and were therefore truncated. If more detailed traces are required, increase the &#x27;&#x27;-XX:FlightRecorderOptions=stackdepth=&#x3C;value&#x3E;&#x27;&#x27; value.\n-Events of the following types have truncated stack traces: &#x3C;ul&#x3E;&#x3C;li&#x3E;Allocation in new TLAB (2.41&#xA0;% truncated traces)&#x3C;\/li&#x3E;&#x3C;li&#x3E;Allocation outside TLAB (1.45&#xA0;% truncated traces)&#x3C;\/li&#x3E;&#x3C;li&#x3E;Object Allocation Sample (3.06&#xA0;% truncated traces)&#x3C;\/li&#x3E;&#x3C;li&#x3E;Old Object Sample (44.4&#xA0;% truncated traces)&#x3C;\/li&#x3E;&#x3C;li&#x3E;Socket Write (48.1&#xA0;% truncated traces)&#x3C;\/li&#x3E;&#x3C;\/ul&#x3E;<\/explanation>\n+            <id>BytecodeVerification<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The application ran with bytecode verification enabled.<\/summary>\n@@ -4064,1 +4074,1 @@\n-            <id>PasswordsInSystemProperties<\/id>\n+            <id>ClassLeak<\/id>\n@@ -4068,1 +4078,1 @@\n-            <id>PasswordsInEnvironment<\/id>\n+            <id>ClassLoading<\/id>\n@@ -4072,1 +4082,1 @@\n-            <id>OverAggressiveRecordingSetting<\/id>\n+            <id>CodeCache<\/id>\n@@ -4076,2 +4086,4 @@\n-            <id>ManyRunningProcesses<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>CompareCpu<\/id>\n+            <severity>OK<\/severity>\n+            <summary>An average CPU load of 0 % was caused by other processes for during 4\/4\/2014 8:54:36.000 AM – 8:54:37 AM.<\/summary>\n+            <explanation>The application performance can be affected when the machine is under heavy load and there are other processes that use CPU or other resources on the same computer. To profile representatively or get higher throughput, shut down other resource intensive processes running on the machine.<\/explanation>\n@@ -4080,1 +4092,11 @@\n-            <id>ManagementAgent<\/id>\n+            <id>CompressedOops<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The settings for Compressed Oops were OK.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>ContextSwitch<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The program did not context switch excessively during the recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>DMSIncident<\/id>\n@@ -4084,1 +4106,8 @@\n-            <id>LowOnPhysicalMemory<\/id>\n+            <id>DebugNonSafepoints<\/id>\n+            <severity>Information<\/severity>\n+            <summary>DebugNonSafepoints was not enabled.<\/summary>\n+            <explanation>If DebugNonSafepoints is not enabled, the method profiling data will be less accurate as threads that are not at safepoints will not be correctly sampled. There is a slight performance overhead when enabling these flags. For more information see [HotSpot Runtime Overview\/Thread Management](http:\/\/openjdk.java.net\/groups\/hotspot\/docs\/RuntimeOverview.html#Thread%20Management|outline]).<\/explanation>\n+            <solution>Use the following JVM flags to enable this: '-XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints'.<\/solution>\n+        <\/rule>\n+        <rule>\n+            <id>DiscouragedVmOptions<\/id>\n@@ -4086,1 +4115,1 @@\n-            <summary>The system did not run low on physical memory during this recording.<\/summary>\n+            <summary>No problems were found with the VM options.<\/summary>\n@@ -4089,1 +4118,5 @@\n-            <id>IncreasingMetaSpaceLiveSet<\/id>\n+            <id>DumpReason<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DuplicateFlags<\/id>\n@@ -4091,1 +4124,1 @@\n-            <summary>The class data does not seem to increase during the recording.<\/summary>\n+            <summary>There were no duplicate JVM flags on the command line.<\/summary>\n@@ -4094,1 +4127,1 @@\n-            <id>IncreasingLiveSet<\/id>\n+            <id>DynamicAgents<\/id>\n@@ -4096,1 +4129,0 @@\n-            <summary>Too few events to calculate the result.<\/summary>\n@@ -4099,1 +4131,1 @@\n-            <id>HighJvmCpu<\/id>\n+            <id>Errors<\/id>\n@@ -4103,1 +4135,1 @@\n-            <id>HighGc<\/id>\n+            <id>Exceptions<\/id>\n@@ -4105,2 +4137,2 @@\n-            <summary>The JVM was paused for 100 % during 7\/13\/2021 6:23:56.617.000 AM – .630<\/summary>\n-            <explanation>The time spent performing garbage collection may be reduced by increasing the heap size or by trying to reduce allocation.<\/explanation>\n+            <summary>The program generated 0 exceptions per second during 4\/4\/2014 8:54:34.000 AM – 8:54:35 AM.<\/summary>\n+            <explanation>Throwing exceptions is more expensive than normal code execution, which means that they should only be used for exceptional situations. Investigate the thrown exceptions to see if any of them can be avoided with a non-exceptional control flow.<\/explanation>\n@@ -4109,5 +4141,2 @@\n-            <id>GcPauseRatio<\/id>\n-            <severity>OK<\/severity>\n-            <summary>Application efficiency was not highly affected by GC pauses.<\/summary>\n-            <explanation>The highest ratio between garbage collection pauses and execution time was 0.0311 % during 7\/13\/2021 6:23:54.000 AM – 6:24:54 AM. The garbage collection pause ratio of the entire recording was 0.00178 %.<\/explanation>\n-            <solution>Pause times may be reduced by increasing the heap size or by trying to reduce allocation.<\/solution>\n+            <id>Fatal Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -4116,1 +4145,1 @@\n-            <id>GcPauseTargetRule<\/id>\n+            <id>FewSampledThreads<\/id>\n@@ -4118,1 +4147,2 @@\n-            <summary>All GCs completed before the GC pause target time of 200 ms.<\/summary>\n+            <summary>There were no problems with the amount of sampled threads.<\/summary>\n+            <explanation>There are more sampled threads than the amount of hardware threads. This indicates that the application has enough parallelism for the available hardware.<\/explanation>\n@@ -4121,1 +4151,1 @@\n-            <id>GcOptions<\/id>\n+            <id>FileForce<\/id>\n@@ -4125,1 +4155,1 @@\n-            <id>GcFreedRatio<\/id>\n+            <id>FileRead<\/id>\n@@ -4127,1 +4157,1 @@\n-            <summary>Only 6 heap summary events were found, this rule requires at least 10 events to be able to calculate a relevant result. This likely means that only a few garbage collections occurred during the recording. Having few garbage collections is generally a good sign.<\/summary>\n+            <summary>There are no file read events in this recording.<\/summary>\n@@ -4130,1 +4160,6 @@\n-            <id>GcInvertedParallelism<\/id>\n+            <id>FileWrite<\/id>\n+            <severity>OK<\/severity>\n+            <summary>There are no file write events in this recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>FinalizersRun<\/id>\n@@ -4134,2 +4169,4 @@\n-            <id>GarbageCollectionInfoRule<\/id>\n-            <severity>OK<\/severity>\n+            <id>FlightRecordingSupport<\/id>\n+            <severity>Warning<\/severity>\n+            <summary>The recording is from an early access build.<\/summary>\n+            <explanation>This recording is from an early access build of the JRE (Java HotSpot(TM) Client VM (25.20-b08) for linux-x86 JRE (1.8.0_20-ea-b08), built on Apr  1 2014 19:40:24 by &amp;#34;java_re&amp;#34; with gcc 4.3.0 20080428 (Red Hat 4.3.0-8)). The automated analysis is not supported, and you may see errors when attempting to analyze the recording.<\/explanation>\n@@ -4143,1 +4180,1 @@\n-            <id>FlightRecordingSupport<\/id>\n+            <id>GarbageCollectionInfoRule<\/id>\n@@ -4147,1 +4184,1 @@\n-            <id>FileWrite<\/id>\n+            <id>GcFreedRatio<\/id>\n@@ -4149,1 +4186,1 @@\n-            <summary>No long file write pauses were found in this recording (the longest was 22.875 μs).<\/summary>\n+            <summary>Only 0 heap summary events were found, this rule requires at least 10 events to be able to calculate a relevant result. This likely means that only a few garbage collections occurred during the recording. Having few garbage collections is generally a good sign.<\/summary>\n@@ -4152,1 +4189,1 @@\n-            <id>FileRead<\/id>\n+            <id>GcInvertedParallelism<\/id>\n@@ -4156,2 +4193,4 @@\n-            <id>FinalizersRun<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>GcOptions<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The runtime used a parallel GC on a single-core machine.<\/summary>\n+            <explanation>The runtime used a parallel GC on a single-core machine. This is not optimal. Use the [Serial Collector](https:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/guides\/vm\/gctuning\/collectors.html) instead, which is optimized for single-core machines.<\/explanation>\n@@ -4160,6 +4199,5 @@\n-            <id>FewSampledThreads<\/id>\n-            <severity>Not Applicable<\/severity>\n-        <\/rule>\n-\t\t<rule>\n-            <id>FileForce<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>GcPauseRatio<\/id>\n+            <severity>OK<\/severity>\n+            <summary>Application efficiency was not highly affected by GC pauses.<\/summary>\n+            <explanation>The highest ratio between garbage collection pauses and execution time was 0 % during 4\/4\/2014 8:54:33.000 AM – 8:55:33 AM. The garbage collection pause ratio of the entire recording was 0 %.<\/explanation>\n+            <solution>Pause times may be reduced by increasing the heap size or by trying to reduce allocation.<\/solution>\n@@ -4168,1 +4206,1 @@\n-            <id>Exceptions<\/id>\n+            <id>GcPauseTargetRule<\/id>\n@@ -4172,1 +4210,1 @@\n-            <id>DiscouragedVmOptions<\/id>\n+            <id>HeapContent<\/id>\n@@ -4176,1 +4214,1 @@\n-            <id>CompressedOops<\/id>\n+            <id>HeapDump<\/id>\n@@ -4180,2 +4218,3 @@\n-            <id>CompareCpu<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>HighGc<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The runtime did not spend much time performing garbage collections.<\/summary>\n@@ -4184,4 +4223,4 @@\n-            <id>ApplicationHalts<\/id>\n-            <severity>OK<\/severity>\n-            <summary>Application efficiency was not highly affected by halts.<\/summary>\n-            <explanation>The highest ratio of application halts to execution time was 0.123 % during 7\/13\/2021 6:23:54.000 AM – 6:24:54 AM. 74.7 % of the halts were for reasons other than GC. The halts ratio for the entire recording was 0.00705 %. 74.7 % of the total halts were for reasons other than GC.<\/explanation>\n+            <id>HighJvmCpu<\/id>\n+            <severity>Information<\/severity>\n+            <summary>This recording contains few profiling samples even though the CPU load is high.<\/summary>\n+            <explanation>The profiling data is thus likely not relevant. This might be because the application is running a lot JNI code or that the JVM is spending a lot of time in GC, class loading, JIT compilation etc.<\/explanation>\n@@ -4190,4 +4229,3 @@\n-            <id>Allocations.thread<\/id>\n-            <severity>OK<\/severity>\n-            <summary>The most allocations were likely done by thread &#x27;&#x27;RMI TCP Connection(19)-192.168.29.191&#x27;&#x27; at: &#x3C;ul&#x3E;&#x3C;li&#x3E;void java.io.ObjectOutputStream$HandleTable.growEntries()&#x3C;\/li&#x3E;&#x3C;li&#x3E;int java.io.ObjectOutputStream$HandleTable.assign(Object)&#x3C;\/li&#x3E;&#x3C;\/ul&#x3E;<\/summary>\n-            <explanation>Many allocations performed by the same thread might indicate a problem in a multi-threaded program. Look at the stack traces for the thread with the highest allocation rate. See if the allocation rate can be brought down, or balanced among the active threads.<\/explanation>\n+            <id>IncreasingLiveSet<\/id>\n+            <severity>Not Applicable<\/severity>\n+            <summary>Too few events to calculate the result.<\/summary>\n@@ -4196,1 +4234,1 @@\n-            <id>Allocations.class<\/id>\n+            <id>IncreasingMetaSpaceLiveSet<\/id>\n@@ -4198,2 +4236,1 @@\n-            <summary>The most allocated type is likely &#x27;&#x27;java.lang.Object[]&#x27;&#x27;, most commonly allocated by: &#x3C;ul&#x3E;&#x3C;li&#x3E;void java.io.ObjectOutputStream$HandleTable.growEntries()&#x3C;\/li&#x3E;&#x3C;li&#x3E;int java.io.ObjectOutputStream$HandleTable.assign(Object)&#x3C;\/li&#x3E;&#x3C;\/ul&#x3E;<\/summary>\n-            <explanation>Frequently allocated types are good places to start when trying to reduce garbage collections. Look at where the most common types are being allocated to see if many instances are created along the same call path. Try to reduce the number of instances created by invoking the most commonly taken paths less.<\/explanation>\n+            <summary>The class data does not seem to increase during the recording.<\/summary>\n@@ -4202,1 +4239,1 @@\n-            <id>StringDeduplication<\/id>\n+            <id>JavaBlocking<\/id>\n@@ -4206,1 +4243,1 @@\n-            <id>SocketWrite<\/id>\n+            <id>JfrPeriodicEventsFix<\/id>\n@@ -4208,2 +4245,1 @@\n-            <summary>There are no socket write events in this recording.<\/summary>\n-            <explanation>Note that there are some socket write patterns with high duration writes that we consider to be normal and are therefore excluded. Such patterns include JMX RMI communication.<\/explanation>\n+            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n@@ -4212,1 +4248,1 @@\n-            <id>SocketRead<\/id>\n+            <id>LongGcPause<\/id>\n@@ -4214,2 +4250,1 @@\n-            <summary>SocketReadRuleFactory_TEXT_NO_EVENTS<\/summary>\n-            <explanation>Note that there are some socket read patterns with high duration reads that we consider to be normal and are therefore excluded. Such patterns include JMX RMI communication and MQ series.<\/explanation>\n+            <summary>The application did not cause any long GC pause times.<\/summary>\n@@ -4218,2 +4253,3 @@\n-            <id>ProcessStarted<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>LowOnPhysicalMemory<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The system did not run low on physical memory during this recording.<\/summary>\n@@ -4222,1 +4258,1 @@\n-            <id>PrimitiveToObjectConversion<\/id>\n+            <id>ManagementAgent<\/id>\n@@ -4224,1 +4260,1 @@\n-            <summary>No allocation was caused by conversion from primitive types to the corresponding object types.<\/summary>\n+            <summary>No problems were found with the management agent settings.<\/summary>\n@@ -4227,2 +4263,5 @@\n-            <id>PasswordsInArguments<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>ManyRunningProcesses<\/id>\n+            <severity>OK<\/severity>\n+            <summary>137 processes were running while this Flight Recording was made.<\/summary>\n+            <explanation>At 4\/4\/14 8:54:38.623 AM, a total of 137 other processes were running on the host machine that this Flight Recording was made on.<\/explanation>\n+            <solution>If this is a server environment, it may be good to only run other critical processes on that machine.<\/solution>\n@@ -4231,1 +4270,1 @@\n-            <id>Options<\/id>\n+            <id>MetaspaceOom<\/id>\n@@ -4240,12 +4279,1 @@\n-            <id>MetaspaceOom<\/id>\n-            <severity>OK<\/severity>\n-            <summary>The metaspace was not exhausted during this recording.<\/summary>\n-        <\/rule>\n-        <rule>\n-            <id>LongGcPause<\/id>\n-            <severity>OK<\/severity>\n-            <summary>The longest GC pause was 13.480 ms.<\/summary>\n-            <explanation\/>\n-        <\/rule>\n-        <rule>\n-            <id>JfrPeriodicEventsFix<\/id>\n+            <id>MultipleAgents<\/id>\n@@ -4255,1 +4283,1 @@\n-            <id>JavaBlocking<\/id>\n+            <id>Options<\/id>\n@@ -4257,2 +4285,1 @@\n-            <summary>No excessive problems with lock contention found.<\/summary>\n-            <explanation>The following regular expression was used to exclude threads from this rule: ''(.*weblogic\\.socket\\.Muxer.*)''<\/explanation>\n+            <summary>No undocumented, deprecated or non-recommended option flags were detected.<\/summary>\n@@ -4261,1 +4288,1 @@\n-            <id>HeapDump<\/id>\n+            <id>OverAggressiveRecordingSetting<\/id>\n@@ -4263,1 +4290,1 @@\n-            <summary>No heap dump performed.<\/summary>\n+            <summary>No problems were found with the recording settings.<\/summary>\n@@ -4266,4 +4293,3 @@\n-            <id>HeapContent<\/id>\n-            <severity>Warning<\/severity>\n-            <summary>Most of the heap was used by only a few classes.<\/summary>\n-            <explanation>If the heap usage needs to be reduced, then this would be a good place to start.<\/explanation>\n+            <id>PasswordsInArguments<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The recording does not seem to contain passwords in the application arguments.<\/summary>\n@@ -4272,2 +4298,3 @@\n-            <id>Fatal Errors<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>PasswordsInEnvironment<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The recording does not seem to contain passwords in the environment variables.<\/summary>\n@@ -4276,2 +4303,3 @@\n-            <id>Errors<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>PasswordsInSystemProperties<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The recording does not seem to contain passwords in the system properties.<\/summary>\n@@ -4280,1 +4308,1 @@\n-            <id>DuplicateFlags<\/id>\n+            <id>PrimitiveToObjectConversion<\/id>\n@@ -4284,1 +4312,1 @@\n-            <id>DumpReason<\/id>\n+            <id>ProcessStarted<\/id>\n@@ -4288,2 +4316,4 @@\n-            <id>DebugNonSafepoints<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>SocketRead<\/id>\n+            <severity>OK<\/severity>\n+            <summary>SocketReadRuleFactory_TEXT_NO_EVENTS<\/summary>\n+            <explanation>Note that there are some socket read patterns with high duration reads that we consider to be normal and are therefore excluded. Such patterns include JMX RMI communication and MQ series.<\/explanation>\n@@ -4292,1 +4322,1 @@\n-            <id>DMSIncident<\/id>\n+            <id>SocketWrite<\/id>\n@@ -4296,2 +4326,3 @@\n-            <id>ContextSwitch<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>StackdepthSetting<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No stack traces were truncated in this recording.<\/summary>\n@@ -4300,1 +4331,1 @@\n-            <id>CodeCache<\/id>\n+            <id>StringDeduplication<\/id>\n@@ -4304,1 +4335,1 @@\n-            <id>ClassLoading<\/id>\n+            <id>TlabAllocationRatio<\/id>\n@@ -4306,1 +4337,1 @@\n-            <summary>No significant time was spent loading new classes during this recording.<\/summary>\n+            <summary>No object allocations outside of TLABs detected.<\/summary>\n@@ -4309,1 +4340,1 @@\n-            <id>ClassLeak<\/id>\n+            <id>VMOperations<\/id>\n@@ -4311,1 +4342,1 @@\n-            <summary>No classes with identical names have been loaded more times than the limit.<\/summary>\n+            <summary>No excessively long VM operations were found in this recording (the longest was 0 s).<\/summary>\n@@ -4314,1 +4345,1 @@\n-            <id>BytecodeVerification<\/id>\n+            <id>biasedLockingRevocation<\/id>\n@@ -4318,1 +4349,1 @@\n-            <id>BufferLost<\/id>\n+            <id>biasedLockingRevocationPause<\/id>\n@@ -4320,1 +4351,1 @@\n-            <summary>No Flight Recorder buffers were lost during the recording.<\/summary>\n+            <summary>No revocation of biased locks found.<\/summary>\n@@ -4322,0 +4353,3 @@\n+    <\/report>\n+    <report>\n+        <file>stringdedup_enabled_jdk9.jfr<\/file>\n@@ -4323,4 +4357,2 @@\n-            <id>HeapInspectionGc<\/id>\n-            <severity>OK<\/severity>\n-            <summary>The JVM did not perform any heap inspection GCs.<\/summary>\n-            <explanation>This is good since they usually take a lot of time.<\/explanation>\n+            <id>Allocations.class<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -4329,3 +4361,2 @@\n-            <id>GcStall<\/id>\n-            <severity>OK<\/severity>\n-            <summary>No indications that the garbage collector could not keep up with the workload were detected.<\/summary>\n+            <id>Allocations.thread<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -4334,1 +4365,1 @@\n-            <id>GcLocker<\/id>\n+            <id>ApplicationHalts<\/id>\n@@ -4336,1 +4367,2 @@\n-            <summary>No GCs were affected by the GC Locker.<\/summary>\n+            <summary>Application efficiency was not highly affected by halts.<\/summary>\n+            <explanation>The highest ratio of application halts to execution time was 0.0819 % during 4\/24\/2018 10:08:52.000 AM – 10:09:52 AM. 51.6 % of the halts were for reasons other than GC. The halts ratio for the entire recording was 1 %. 51.6 % of the total halts were for reasons other than GC.<\/explanation>\n@@ -4339,1 +4371,1 @@\n-            <id>biasedLockingRevocation<\/id>\n+            <id>BufferLost<\/id>\n@@ -4341,1 +4373,1 @@\n-            <summary>No revocation of biased locks found.<\/summary>\n+            <summary>No Flight Recorder buffers were lost during the recording.<\/summary>\n@@ -4343,3 +4375,0 @@\n-    <\/report>\n-    <report>\n-        <file>jdk18-finalizers.jfr<\/file>\n@@ -4347,5 +4376,3 @@\n-            <id>FinalizersRun<\/id>\n-            <severity>Information<\/severity>\n-            <summary>26.5 ×10⁶ finalizers were run.<\/summary>\n-            <explanation>Finalization can lead to performance issues, deadlocks, or hangs, and has been marked for removal in a future Java version. The following finalizable classes have been detected: &lt;ul&gt;&lt;li&gt;my_package.Main$MyFinalizableObject&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n-            <solution>Remove finalize method implementations from your application, and consider making use of the [Cleaner API](https:\/\/docs.oracle.com\/en\/java\/javase\/17\/docs\/api\/java.base\/java\/lang\/ref\/Cleaner.html) instead.<\/solution>\n+            <id>BytecodeVerification<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The application ran with bytecode verification enabled.<\/summary>\n@@ -4354,1 +4381,1 @@\n-            <id>biasedLockingRevocationPause<\/id>\n+            <id>ClassLeak<\/id>\n@@ -4358,1 +4385,1 @@\n-            <id>VMOperations<\/id>\n+            <id>ClassLoading<\/id>\n@@ -4362,1 +4389,1 @@\n-            <id>TlabAllocationRatio<\/id>\n+            <id>CodeCache<\/id>\n@@ -4366,3 +4393,4 @@\n-            <id>StackdepthSetting<\/id>\n-            <severity>Not Applicable<\/severity>\n-            <summary>No events with stack traces were recorded.<\/summary>\n+            <id>CompareCpu<\/id>\n+            <severity>OK<\/severity>\n+            <summary>An average CPU load of 15 % was caused by other processes for during 4\/24\/2018 10:08:54.000 AM – 10:08:55 AM.<\/summary>\n+            <explanation>The application performance can be affected when the machine is under heavy load and there are other processes that use CPU or other resources on the same computer. To profile representatively or get higher throughput, shut down other resource intensive processes running on the machine.<\/explanation>\n@@ -4371,2 +4399,3 @@\n-            <id>PasswordsInSystemProperties<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>CompressedOops<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The settings for Compressed Oops were OK.<\/summary>\n@@ -4375,1 +4404,1 @@\n-            <id>PasswordsInEnvironment<\/id>\n+            <id>ContextSwitch<\/id>\n@@ -4379,1 +4408,1 @@\n-            <id>OverAggressiveRecordingSetting<\/id>\n+            <id>DMSIncident<\/id>\n@@ -4383,1 +4412,1 @@\n-            <id>ManyRunningProcesses<\/id>\n+            <id>DebugNonSafepoints<\/id>\n@@ -4387,2 +4416,3 @@\n-            <id>ManagementAgent<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>DiscouragedVmOptions<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No problems were found with the VM options.<\/summary>\n@@ -4391,1 +4421,1 @@\n-            <id>LowOnPhysicalMemory<\/id>\n+            <id>DumpReason<\/id>\n@@ -4395,2 +4425,3 @@\n-            <id>IncreasingMetaSpaceLiveSet<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>DuplicateFlags<\/id>\n+            <severity>OK<\/severity>\n+            <summary>There were no duplicate JVM flags on the command line.<\/summary>\n@@ -4399,1 +4430,1 @@\n-            <id>IncreasingLiveSet<\/id>\n+            <id>DynamicAgents<\/id>\n@@ -4403,1 +4434,1 @@\n-            <id>HighJvmCpu<\/id>\n+            <id>Errors<\/id>\n@@ -4407,2 +4438,4 @@\n-            <id>HighGc<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>Exceptions<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The program generated 0 exceptions per second during 4\/24\/2018 10:08:53.000 AM – 10:08:54 AM.<\/summary>\n+            <explanation>Throwing exceptions is more expensive than normal code execution, which means that they should only be used for exceptional situations. Investigate the thrown exceptions to see if any of them can be avoided with a non-exceptional control flow.<\/explanation>\n@@ -4411,1 +4444,1 @@\n-            <id>GcPauseRatio<\/id>\n+            <id>Fatal Errors<\/id>\n@@ -4415,2 +4448,4 @@\n-            <id>GcPauseTargetRule<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>FewSampledThreads<\/id>\n+            <severity>Information<\/severity>\n+            <summary>There are fewer sampled threads than the total number of hardware threads (cores).<\/summary>\n+            <explanation>1 threads with at least 4 method samples were found, but the machine has 32 hardware threads (cores). The application might benefit from a higher level of parallelism. This could also be caused by threads doing something else than running Java code, for example running native code or spending time in the JVM internals.<\/explanation>\n@@ -4419,1 +4454,1 @@\n-            <id>GcOptions<\/id>\n+            <id>FileForce<\/id>\n@@ -4423,2 +4458,3 @@\n-            <id>GcFreedRatio<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>FileRead<\/id>\n+            <severity>OK<\/severity>\n+            <summary>There are no file read events in this recording.<\/summary>\n@@ -4427,2 +4463,3 @@\n-            <id>GcInvertedParallelism<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>FileWrite<\/id>\n+            <severity>OK<\/severity>\n+            <summary>There are no file write events in this recording.<\/summary>\n@@ -4431,1 +4468,1 @@\n-            <id>GarbageCollectionInfoRule<\/id>\n+            <id>FinalizersRun<\/id>\n@@ -4434,0 +4471,5 @@\n+        <rule>\n+            <id>FlightRecordingSupport<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The JVM version used for this recording has full Flight Recorder support.<\/summary>\n+        <\/rule>\n@@ -4436,2 +4478,2 @@\n-            <severity>Not Applicable<\/severity>\n-            <summary>This rule is only valid for CMS and G1 Garbage Collectors, neither of which were detected for this JVM.<\/summary>\n+            <severity>OK<\/severity>\n+            <summary>No Stop-the-World, Full GC events detected.<\/summary>\n@@ -4440,2 +4482,2 @@\n-            <id>FlightRecordingSupport<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>GarbageCollectionInfoRule<\/id>\n+            <severity>OK<\/severity>\n@@ -4444,1 +4486,1 @@\n-            <id>FileWrite<\/id>\n+            <id>GcFreedRatio<\/id>\n@@ -4448,1 +4490,1 @@\n-            <id>FileRead<\/id>\n+            <id>GcInvertedParallelism<\/id>\n@@ -4452,2 +4494,3 @@\n-            <id>FewSampledThreads<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>GcLocker<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No GCs were affected by the GC Locker.<\/summary>\n@@ -4455,3 +4498,4 @@\n-\t\t<rule>\n-            <id>FileForce<\/id>\n-            <severity>Not Applicable<\/severity>\n+        <rule>\n+            <id>GcOptions<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No problems were found with the GC configuration.<\/summary>\n@@ -4460,2 +4504,5 @@\n-            <id>Exceptions<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>GcPauseRatio<\/id>\n+            <severity>OK<\/severity>\n+            <summary>Application efficiency was not highly affected by GC pauses.<\/summary>\n+            <explanation>The highest ratio between garbage collection pauses and execution time was 0.0397 % during 4\/24\/2018 10:08:52.000 AM – 10:09:52 AM. The garbage collection pause ratio of the entire recording was 0.486 %.<\/explanation>\n+            <solution>Pause times may be reduced by increasing the heap size or by trying to reduce allocation.<\/solution>\n@@ -4464,2 +4511,3 @@\n-            <id>DiscouragedVmOptions<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>OK<\/severity>\n+            <summary>All GCs completed before the GC pause target time of 200 ms.<\/summary>\n@@ -4468,2 +4516,3 @@\n-            <id>CompressedOops<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>GcStall<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No indications that the garbage collector could not keep up with the workload were detected.<\/summary>\n@@ -4472,1 +4521,1 @@\n-            <id>CompareCpu<\/id>\n+            <id>HeapContent<\/id>\n@@ -4476,1 +4525,1 @@\n-            <id>ApplicationHalts<\/id>\n+            <id>HeapDump<\/id>\n@@ -4480,2 +4529,4 @@\n-            <id>Allocations.thread<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>HeapInspectionGc<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The JVM did not perform any heap inspection GCs.<\/summary>\n+            <explanation>This is good since they usually take a lot of time.<\/explanation>\n@@ -4484,2 +4535,5 @@\n-            <id>Allocations.class<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>HighGc<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The JVM was paused for 100 % during 4\/24\/2018 10:08:53.973.000 AM – .982<\/summary>\n+            <explanation>The time spent performing garbage collection may be reduced by increasing the heap size or by trying to reduce allocation.\n+To improve rule accuracy and\/or get more details for further investigation, it is recommended to enable the following event types: 'Allocation in new TLAB', 'Allocation outside TLAB'.<\/explanation>\n@@ -4488,2 +4542,3 @@\n-            <id>biasedLockingRevocation<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>HighJvmCpu<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The JVM does not seem to cause a lot of CPU load.<\/summary>\n@@ -4492,1 +4547,1 @@\n-            <id>StringDeduplication<\/id>\n+            <id>IncreasingLiveSet<\/id>\n@@ -4494,0 +4549,1 @@\n+            <summary>Too few events to calculate the result.<\/summary>\n@@ -4496,2 +4552,3 @@\n-            <id>SocketWrite<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>IncreasingMetaSpaceLiveSet<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The class data does not seem to increase during the recording.<\/summary>\n@@ -4500,1 +4557,1 @@\n-            <id>SocketRead<\/id>\n+            <id>JavaBlocking<\/id>\n@@ -4504,2 +4561,3 @@\n-            <id>ProcessStarted<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n@@ -4508,2 +4566,4 @@\n-            <id>PrimitiveToObjectConversion<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>LongGcPause<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The longest GC pause was 9.017 ms.<\/summary>\n+            <explanation\/>\n@@ -4512,2 +4572,4 @@\n-            <id>PasswordsInArguments<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>LowOnPhysicalMemory<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The maximum amount of used memory was 91.8 % of the physical memory available.<\/summary>\n+            <explanation>The maximum amount of memory used was 29.3 GiB. This is 91.8 % of the 31.9 GiB of physical memory available. Having little free memory may lead to swapping, which is very expensive. To avoid this, either decrease the memory usage or increase the amount of available memory.<\/explanation>\n@@ -4516,1 +4578,1 @@\n-            <id>Options<\/id>\n+            <id>ManagementAgent<\/id>\n@@ -4520,1 +4582,1 @@\n-            <id>MethodProfiling<\/id>\n+            <id>ManyRunningProcesses<\/id>\n@@ -4525,1 +4587,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The metaspace was not exhausted during this recording.<\/summary>\n@@ -4528,2 +4591,3 @@\n-            <id>LongGcPause<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>MethodProfiling<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No methods where optimization would be particularly efficient could be detected.<\/summary>\n@@ -4532,1 +4596,1 @@\n-            <id>JfrPeriodicEventsFix<\/id>\n+            <id>MultipleAgents<\/id>\n@@ -4536,2 +4600,3 @@\n-            <id>JavaBlocking<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>Options<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No undocumented, deprecated or non-recommended option flags were detected.<\/summary>\n@@ -4540,1 +4605,1 @@\n-            <id>HeapDump<\/id>\n+            <id>OverAggressiveRecordingSetting<\/id>\n@@ -4544,2 +4609,3 @@\n-            <id>HeapContent<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>PasswordsInArguments<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The recording does not seem to contain passwords in the application arguments.<\/summary>\n@@ -4548,1 +4614,1 @@\n-            <id>Fatal Errors<\/id>\n+            <id>PasswordsInEnvironment<\/id>\n@@ -4552,1 +4618,1 @@\n-            <id>Errors<\/id>\n+            <id>PasswordsInSystemProperties<\/id>\n@@ -4556,1 +4622,1 @@\n-            <id>DuplicateFlags<\/id>\n+            <id>PrimitiveToObjectConversion<\/id>\n@@ -4560,1 +4626,1 @@\n-            <id>DumpReason<\/id>\n+            <id>ProcessStarted<\/id>\n@@ -4564,1 +4630,1 @@\n-            <id>DebugNonSafepoints<\/id>\n+            <id>SocketRead<\/id>\n@@ -4568,1 +4634,1 @@\n-            <id>DMSIncident<\/id>\n+            <id>SocketWrite<\/id>\n@@ -4572,2 +4638,3 @@\n-            <id>ContextSwitch<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>StackdepthSetting<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No stack traces were truncated in this recording.<\/summary>\n@@ -4576,1 +4643,1 @@\n-            <id>CodeCache<\/id>\n+            <id>StringDeduplication<\/id>\n@@ -4580,2 +4647,3 @@\n-            <id>ClassLoading<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <id>SystemGc<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No garbage collections were caused by System.gc().<\/summary>\n@@ -4584,1 +4652,1 @@\n-            <id>ClassLeak<\/id>\n+            <id>TlabAllocationRatio<\/id>\n@@ -4588,1 +4656,6 @@\n-            <id>BytecodeVerification<\/id>\n+            <id>VMOperations<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No excessively long VM operations were found in this recording (the longest was 25.346 ms).<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocation<\/id>\n@@ -4592,1 +4665,1 @@\n-            <id>BufferLost<\/id>\n+            <id>biasedLockingRevocationPause<\/id>\n@@ -4594,1 +4667,1 @@\n-            <summary>No Flight Recorder buffers were lost during the recording.<\/summary>\n+            <summary>No revocation of biased locks found.<\/summary>\n@@ -4598,1 +4671,1 @@\n-        <file>jdk21-inverted-parallelism.jfr<\/file>\n+        <file>wldf.jfr<\/file>\n@@ -4601,1 +4674,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>Information<\/severity>\n+            <summary>The most allocated type is likely ''char[]'', most commonly allocated by: &lt;ul&gt;&lt;li&gt;char[] java.util.Arrays.copyOfRange(char[], int, int)&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Frequently allocated types are good places to start when trying to reduce garbage collections. Look at where the most common types are being allocated to see if many instances are created along the same call path. Try to reduce the number of instances created by invoking the most commonly taken paths less.<\/explanation>\n@@ -4605,1 +4680,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The most allocations were likely done by thread ''[ACTIVE] ExecuteThread: &amp;#39;5&amp;#39; for queue: &amp;#39;weblogic.kernel.Default (self-tuning)&amp;#39;'' at: &lt;ul&gt;&lt;li&gt;char[] java.util.Arrays.copyOfRange(char[], int, int)&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Many allocations performed by the same thread might indicate a problem in a multi-threaded program. Look at the stack traces for the thread with the highest allocation rate. See if the allocation rate can be brought down, or balanced among the active threads.<\/explanation>\n@@ -4609,1 +4686,4 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>Application efficiency was not highly affected by halts.<\/summary>\n+            <explanation>The highest ratio of application halts to execution time was 2.22 % during 9\/24\/2015 10:08:56.000 AM – 10:09:56 AM. 0.0271 % of the halts were for reasons other than GC. The halts ratio for the entire recording was 1.88 %. 0.0212 % of the total halts were for reasons other than GC.\n+Enabling the following event types would improve the accuracy of this rule: jdk.SafepointBegin<\/explanation>\n@@ -4618,1 +4698,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The application ran WebLogic Server with bytecode verification disabled.<\/summary>\n+            <explanation>The application ran WebLogic Server with bytecode verification disabled. While not generally recommended, it is considered OK for WLS.<\/explanation>\n@@ -4622,1 +4704,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>Information<\/severity>\n+            <summary>java.lang.Object was loaded 258 time(s) without being unloaded<\/summary>\n+            <explanation>Some classes have been loaded multiple times, and the difference between the number of times a class have been loaded and the number of times it has been unloaded has exceeded the user specified limit. This in itself need not be a problem, but check to see if you expect these classes to be loaded multiple times to make sure that you do not have a class loader leak. The following classes were detected as potential problems: &lt;ul&gt;&lt;li&gt;java.lang.Object (258)&lt;\/li&gt;&lt;li&gt;java.lang.String (95)&lt;\/li&gt;&lt;li&gt;java.lang.Class (81)&lt;\/li&gt;&lt;li&gt;java.lang.Integer (52)&lt;\/li&gt;&lt;li&gt;oracle.jrockit.jfr.VMJFR (46)&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n@@ -4626,1 +4710,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No significant time was spent loading new classes during this recording.<\/summary>\n@@ -4634,1 +4719,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>Warning<\/severity>\n+            <summary>An average CPU load of 54 % was caused by other processes for during 9\/24\/2015 10:08:17.000 AM – 10:08:22 AM.<\/summary>\n+            <explanation>The application performance can be affected when the machine is under heavy load and there are other processes that use CPU or other resources on the same computer. To profile representatively or get higher throughput, shut down other resource intensive processes running on the machine.<\/explanation>\n@@ -4638,1 +4725,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The settings for Compressed Oops were OK.<\/summary>\n@@ -4642,1 +4730,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The program did not context switch excessively during the recording.<\/summary>\n@@ -4650,1 +4739,4 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>Information<\/severity>\n+            <summary>DebugNonSafepoints was not enabled.<\/summary>\n+            <explanation>If DebugNonSafepoints is not enabled, the method profiling data will be less accurate as threads that are not at safepoints will not be correctly sampled. There is a slight performance overhead when enabling these flags. For more information see [HotSpot Runtime Overview\/Thread Management](http:\/\/openjdk.java.net\/groups\/hotspot\/docs\/RuntimeOverview.html#Thread%20Management|outline]).<\/explanation>\n+            <solution>Use the following JVM flags to enable this: '-XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints'.<\/solution>\n@@ -4654,1 +4746,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No problems were found with the VM options.<\/summary>\n@@ -4662,0 +4755,7 @@\n+            <severity>Information<\/severity>\n+            <summary>2 duplicated JVM flags found.<\/summary>\n+            <explanation>Duplicated JVM flags may be caused by multiple layers of scripts used when launching the application. Having duplicate flags is dangerous as changing one of the flags in one of the scripts may not have the intended effect. This can be especially dangerous for security related system properties. The following flags were duplicated: &lt;ul&gt;&lt;li&gt;-Djava.endorsed.dirs=c:\\java\\JDK18~1.0_6\\jre\\lib\\endorsed;C:\\tmp\\WLS-JFR\\oracle_common\\modules\\endorsed,-Djava.endorsed.dirs=c:\\java\\JDK18~1.0_6\\jre\\lib\\endorsed;C:\\tmp\\WLS-JFR\\oracle_common\\modules\\endorsed&lt;\/li&gt;&lt;li&gt;-Xverify:none,-Xverify:none&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n+            <solution>Try to find all the places where the flag is defined and keep only one.<\/solution>\n+        <\/rule>\n+        <rule>\n+            <id>DynamicAgents<\/id>\n@@ -4666,1 +4766,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The program generated an average of 17 errors per minute during 9\/24\/2015 10:08:14.000 AM – 10:09:14 AM.<\/summary>\n+            <explanation>17 errors were thrown in total. The most common error was ''java.lang.NoSuchMethodError'', which was thrown 13 times. Investigate the thrown errors to see if they can be avoided. Errors indicate that something went wrong with the code execution and should never be used for flow control. The following regular expression was used to exclude 381 errors from this rule: ''(com.sun.el.parser.ELParser\\$LookaheadSuccess)''.<\/explanation>\n@@ -4670,1 +4772,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The program generated 515 exceptions per second during 9\/24\/2015 10:08:58.000 AM – 10:09:27 AM.<\/summary>\n+            <explanation>Throwing exceptions is more expensive than normal code execution, which means that they should only be used for exceptional situations. Investigate the thrown exceptions to see if any of them can be avoided with a non-exceptional control flow.<\/explanation>\n@@ -4678,0 +4782,6 @@\n+            <severity>OK<\/severity>\n+            <summary>There were no problems with the amount of sampled threads.<\/summary>\n+            <explanation>There are more sampled threads than the amount of hardware threads. This indicates that the application has enough parallelism for the available hardware.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>FileForce<\/id>\n@@ -4682,1 +4792,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No long file read pauses were found in this recording (the longest was 16.269 ms).<\/summary>\n@@ -4686,5 +4797,2 @@\n-            <severity>Not Applicable<\/severity>\n-        <\/rule>\n-\t\t<rule>\n-            <id>FileForce<\/id>\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No long file write pauses were found in this recording (the longest was 172.408 ms).<\/summary>\n@@ -4698,1 +4806,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The JVM version used for this recording has full Flight Recorder support.<\/summary>\n@@ -4702,2 +4811,2 @@\n-            <severity>OK<\/severity>\n-            <summary>No Stop-the-World, Full GC events detected.<\/summary>\n+            <severity>Not Applicable<\/severity>\n+            <summary>This rule is only valid for CMS and G1 Garbage Collectors, neither of which were detected for this JVM.<\/summary>\n@@ -4707,1 +4816,1 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n@@ -4711,1 +4820,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The ratio between memory freed by garbage collections per second and liveset is 47.4 %. This is likely a reasonable amount.<\/summary>\n+            <explanation>61.4 MiB per second was freed by garbage collections during 9\/24\/2015 10:09:18.000 AM – 10:09:28 AM. The average liveset was 130 MiB. This is likely a reasonable amount.<\/explanation>\n@@ -4715,3 +4826,6 @@\n-            <severity>Warning<\/severity>\n-            <summary>Inverted Parallelism detected 1 times out of 11 recorded events.<\/summary>\n-            <explanation>There is evidence of inverted parallelism. With parallel (multi-threaded) collector events, the \"user\" + \"sys\" time should be approximately equal to the \"real\" (wall) time multiplied by the # of GC threads. For example, if there are 3 GC threads we would expect a parallel collection that takes 1 second of \"real\" time to take approximately 3 seconds of \"user\" + \"sys\" time. The parallelism is 3x. If the parallelism is 1x (\"user\" + \"sys\" = \"real\"), the parallel collection is not offering any efficiency over a serial (single-threaded) collection. When \"user\" + \"sys\" &lt; \"real\", the parallelism is inverted. Inverted parallelism can be a sign of high i\/o (e.g. disk or network access) or not enough CPU (e.g. GC threads competing with each other or other processes). Check for swapping and if the number of GC threads (-XX:ParallelGCThreads=&lt;n&gt;) is appropriate for the number of cpu\/cores and any processes sharing cpu.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcLocker<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No GCs were affected by the GC Locker.<\/summary>\n@@ -4721,1 +4835,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No problems were found with the GC configuration.<\/summary>\n@@ -4725,1 +4840,4 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>Application efficiency was not highly affected by GC pauses.<\/summary>\n+            <explanation>The highest ratio between garbage collection pauses and execution time was 2.22 % during 9\/24\/2015 10:08:56.000 AM – 10:09:56 AM. The garbage collection pause ratio of the entire recording was 1.88 %.<\/explanation>\n+            <solution>Pause times may be reduced by increasing the heap size or by trying to reduce allocation.<\/solution>\n@@ -4731,0 +4849,5 @@\n+        <rule>\n+            <id>GcStall<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No indications that the garbage collector could not keep up with the workload were detected.<\/summary>\n+        <\/rule>\n@@ -4733,1 +4856,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>Warning<\/severity>\n+            <summary>Most of the heap was used by only a few classes.<\/summary>\n+            <explanation>If the heap usage needs to be reduced, then this would be a good place to start.<\/explanation>\n@@ -4739,0 +4864,7 @@\n+        <rule>\n+            <id>HeapInspectionGc<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The JVM performed 4 heap inspection garbage collections.<\/summary>\n+            <explanation>Performing heap inspection garbage collections may be a problem since they usually take a lot of time.\n+Some of these inspections were caused by the 'Object Count' JFR event. It triggers a full garbage collection at the beginning and end of every recording where that event is enabled. If recordings are only made on demand or not too often, then these garbage collections are usually not a problem since the resulting pauses are not part of the normal application behavior. If recordings are collected often, for example by automatic scripts, or if the application is sensitive to pauses, then it might become an issue. In that case you can consider disabling the 'Object Count' event.<\/explanation>\n+        <\/rule>\n@@ -4741,1 +4873,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>Information<\/severity>\n+            <summary>The JVM was paused for 100 % during 9\/24\/2015 10:07:58.865.000 AM – 10:07:59.432 AM<\/summary>\n+            <explanation>The time spent performing garbage collection may be reduced by increasing the heap size or by trying to reduce allocation.<\/explanation>\n@@ -4745,1 +4879,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The JVM does not seem to cause a lot of CPU load.<\/summary>\n@@ -4749,1 +4884,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>Information<\/severity>\n+            <summary>The live set on the heap seems to increase with a speed of about 638 KiB per second during the recording.<\/summary>\n+            <explanation>This may be due to a memory leak in the application or it may be an artifact of a short recording if the JVM has recently been started. The recording began 3.249 s after the JVM was started. More information can be gathered by using the 'Old Object Sample' event, if available.<\/explanation>\n@@ -4753,1 +4890,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>Information<\/severity>\n+            <summary>The class data seems to increase constantly in the metaspace during the recording.<\/summary>\n+            <explanation>This behavior may indicate a memory leak in the metaspace, this could be due to the application not unloading classes as needed.<\/explanation>\n@@ -4757,1 +4896,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>Information<\/severity>\n+            <summary>Threads in the application were blocked on locks for a total of 1 min 26 s.<\/summary>\n+            <explanation>The most blocking monitor class was ''org.apache.log4j.Logger'', which was blocked 1,612 times for a total of 1 min 23 s.The following regular expression was used to exclude threads from this rule: ''(.*weblogic\\.socket\\.Muxer.*)''<\/explanation>\n@@ -4761,1 +4902,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n@@ -4765,1 +4907,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The longest GC pause was 576.207 ms.<\/summary>\n+            <explanation\/>\n@@ -4769,1 +4913,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The system did not run low on physical memory during this recording.<\/summary>\n@@ -4773,1 +4918,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No problems were found with the management agent settings.<\/summary>\n@@ -4781,1 +4927,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The metaspace was not exhausted during this recording.<\/summary>\n@@ -4785,0 +4932,5 @@\n+            <severity>OK<\/severity>\n+            <summary>No methods where optimization would be particularly efficient could be detected.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>MultipleAgents<\/id>\n@@ -4789,1 +4941,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>Information<\/severity>\n+            <summary>Deprecated option flags were detected.<\/summary>\n+            <explanation>The following option flags are or will be deprecated. &lt;ul&gt;&lt;li&gt;-XX:PermSize=128m: Ignored in Java 8 and removed in Java 9. PermGen was removed in JDK 8, since Java users should not need to know up front how much memory to reserve for class metadata etc. Just like in the JRockit and J9 JVMs, native memory is now used for class metadata, and it will dynamically grow as needed. The equivalent of java.lang.OutOfMemoryError: PermGen will be much harder to provoke. To influence when to start attempting to reclaim metaspace memory, check out the [MaxMetaspaceSize flag](https:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/tools\/unix\/java.html).&lt;\/li&gt;&lt;li&gt;-XX:MaxPermSize=256m: Ignored in Java 8 and removed in Java 9. PermGen was removed in JDK 8, since Java users should not need to know up front how much memory to reserve for class metadata etc. Just like in the JRockit and J9 JVMs, native memory is now used for class metadata, and it will dynamically grow as needed. The equivalent of java.lang.OutOfMemoryError: PermGen will be much harder to provoke. To influence when to start attempting to reclaim metaspace memory, check out the [MaxMetaspaceSize flag](https:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/tools\/unix\/java.html).&lt;\/li&gt;&lt;\/ul&gt; Deprecated option flags should be avoided. In some cases they enable legacy code and in other cases they are ignored completely. They will usually be removed in a later Java release.<\/explanation>\n@@ -4793,1 +4947,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No problems were found with the recording settings.<\/summary>\n@@ -4797,1 +4952,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The recording does not seem to contain passwords in the application arguments.<\/summary>\n@@ -4805,1 +4961,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The recording does not seem to contain passwords in the system properties.<\/summary>\n@@ -4809,1 +4966,5 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>0.089 % of the total allocation (2.07 GiB) is caused by conversion from primitive types to object types. The most common object type that primitives are converted into is ''java.lang.Integer''.<\/summary>\n+            <explanation>\n+The most common object type that primitives are converted into is ''java.lang.Integer'', which causes 1.11 MiB to be allocated. The most common call site is ''weblogic.socket.NIOSocketMuxer$DirectBufferPool weblogic.socket.NIOSocketMuxer$NIOOutputStream.initPool():887''.\n+Conversion from primitives to the corresponding object types can either be done explicitly, or be caused by autoboxing. If a considerable amount of the total allocation is caused by such conversions, consider changing the application source code to avoid this behavior. Look at the allocation stack traces to see which parts of the code to change. This rule finds the calls to the valueOf method for any of the eight object types that have primitive counterparts.<\/explanation>\n@@ -4817,1 +4978,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No long socket read pauses were found in this recording (the longest was 105.982 ms).<\/summary>\n+            <explanation>Note that there are some socket read patterns with high duration reads that we consider to be normal and are therefore excluded. Such patterns include JMX RMI communication and MQ series.<\/explanation>\n@@ -4821,1 +4984,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>Information<\/severity>\n+            <summary>There are long socket write pauses in this recording (the longest is 349.745 ms).<\/summary>\n+            <explanation>The longest recorded socket write took 349.745 ms to write 81 B to the host at 10.161.190.213. Average time of recorded IO: 37.121 ms. Total time of recorded IO: 1.077 s. Total time of recorded IO for the host 10.161.190.213: 398.835 ms. Note that there are some socket write patterns with high duration writes that we consider to be normal and are therefore excluded. Such patterns include JMX RMI communication.<\/explanation>\n@@ -4825,2 +4990,4 @@\n-            <severity>Not Applicable<\/severity>\n-            <summary>No events with stack traces were recorded.<\/summary>\n+            <severity>Warning<\/severity>\n+            <summary>Some stack traces were truncated in this recording.<\/summary>\n+            <explanation>The Flight Recorder is configured with a maximum captured stack depth of 64. 35.7 % of all traces were larger than this option, and were therefore truncated. If more detailed traces are required, increase the ''-XX:FlightRecorderOptions=stackdepth=&lt;value&gt;'' value.\n+Events of the following types have truncated stack traces: &lt;ul&gt;&lt;li&gt;Allocation Requiring GC (31.6 % truncated traces)&lt;\/li&gt;&lt;li&gt;Allocation in new TLAB (42.4 % truncated traces)&lt;\/li&gt;&lt;li&gt;Allocation outside TLAB (60.7 % truncated traces)&lt;\/li&gt;&lt;li&gt;Class Load (42.8 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Business Method Invoke (47.1 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Business Method Post Invoke (44.4 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Business Method Post Invoke Cleanup (47.1 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Business Method Pre Invoke (44.4 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Pool Manager Post Invoke (47.1 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Pool Manager Pre Invoke (47.1 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB PoolManager Create (32.7 % truncated traces)&lt;\/li&gt;&lt;li&gt;File Read (100 % truncated traces)&lt;\/li&gt;&lt;li&gt;File Write (32.6 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Connection Close (73 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Connection Prepare (54.4 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Connection Release (65 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Statement Creation (54.4 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Statement Execute (54.4 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Statement Execute Begin (54.4 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Transaction Commit (65 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Transaction End (65.6 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Transaction Is Same RM (6.59 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Transaction Start (100 % truncated traces)&lt;\/li&gt;&lt;li&gt;JTA Transaction Commit (51 % truncated traces)&lt;\/li&gt;&lt;li&gt;JTA Transaction End (51.5 % truncated traces)&lt;\/li&gt;&lt;li&gt;JTA Transaction Start (80 % truncated traces)&lt;\/li&gt;&lt;li&gt;Java Error (29.1 % truncated traces)&lt;\/li&gt;&lt;li&gt;Java Monitor Blocked (1.09 % truncated traces)&lt;\/li&gt;&lt;li&gt;Java Monitor Wait (0.134 % truncated traces)&lt;\/li&gt;&lt;li&gt;Java Thread Park (0.223 % truncated traces)&lt;\/li&gt;&lt;li&gt;Java Thread Sleep (33.3 % truncated traces)&lt;\/li&gt;&lt;li&gt;Method Profiling Sample (24.3 % truncated traces)&lt;\/li&gt;&lt;li&gt;Servlet Execute (26.2 % truncated traces)&lt;\/li&gt;&lt;li&gt;Servlet Request Dispatch (45 % truncated traces)&lt;\/li&gt;&lt;li&gt;Servlet Response Write Headers (0.753 % truncated traces)&lt;\/li&gt;&lt;li&gt;Socket Read (41.6 % truncated traces)&lt;\/li&gt;&lt;li&gt;Socket Write (20.6 % truncated traces)&lt;\/li&gt;&lt;li&gt;Webservices JAXRPC Client Request (45.4 % truncated traces)&lt;\/li&gt;&lt;li&gt;Webservices JAXRPC Client Response (100 % truncated traces)&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n@@ -4830,1 +4997,12 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>Approximately 1,746 % of the live set consists of the internal array type of strings (''char[]'' for this JDK version).\n+The heap is around 22.3 % full. There is likely no big benefit from enabling string deduplication.<\/summary>\n+            <explanation>String deduplication is enabled using the JVM flag '-XX:+UseStringDeduplication'. This flag can be used together with the G1 garbage collector in JDK 8u20 or later, or with the Shenandoah garbage collector.\n+To validate if this gives a performance improvement for your application, create flight recordings both with and without string deduplication. For the run with string deduplication enabled, also enable statistics with '-XX:+PrintStringDeduplicationStatistics' for JDK 8 or '-Xlog:stringdedup*=debug' for JDK 9. Check if the heap live set decrease in the recording with string deduplication enabled is larger than the size of the string deduplication metadata table. The size of the metadata table is printed in the statistics output as 'Table\/Memory Usage: XX MB'\n+You can read more about string deduplication in the java options documentation or in [JEP 192](https:\/\/openjdk.java.net\/jeps\/192).\n+String deduplication is only supported when using the G1 (JDK 8u20+) or Shenandoah garbage collectors. If you want to use this feature you can enable G1 by using '-XX:+UseG1GC', or enable Shenandoah by using '-XX:+UseShenandoahGC'.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>SystemGc<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No garbage collections were caused by System.gc().<\/summary>\n@@ -4834,1 +5012,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The program allocated 2.39 % of the memory outside of TLABs.<\/summary>\n+            <solution>Allocating objects outside of Thread Local Allocation Buffers (TLABs) is more expensive than allocating inside TLABs. This may be acceptable if the individual allocations are intended to be larger than a reasonable TLAB. It may be possible to avoid this by decreasing the size of the individual allocations. There are some TLAB related JVM flags that you can experiment with, but it is usually better to let the JVM manage TLAB sizes automatically.<\/solution>\n@@ -4838,1 +5018,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No excessively long VM operations were found in this recording (the longest was 592.965 ms).<\/summary>\n@@ -4846,1 +5027,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No revocation of biased locks found.<\/summary>\n@@ -4850,1 +5032,1 @@\n-        <file>jdk21.jfr<\/file>\n+        <file>wls-medrec-jdk9.jfr<\/file>\n@@ -4861,3 +5043,1 @@\n-            <severity>OK<\/severity>\n-            <summary>Application efficiency was not highly affected by halts.<\/summary>\n-            <explanation>The highest ratio of application halts to execution time was 0.172 % during 11\/20\/2023 4:22:52.000 PM – 4:23:52 PM. 0.118 % of the halts were for reasons other than GC. The halts ratio for the entire recording was 0.275 %. 0.114 % of the total halts were for reasons other than GC.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -4872,1 +5052,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The application ran with bytecode verification enabled.<\/summary>\n@@ -4876,2 +5057,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No classes with identical names have been loaded more times than the limit.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -4881,2 +5061,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No significant time was spent loading new classes during this recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -4910,2 +5089,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No problems were found with the VM options.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -4919,0 +5097,7 @@\n+            <severity>Information<\/severity>\n+            <summary>5 duplicated JVM flags found.<\/summary>\n+            <explanation>Duplicated JVM flags may be caused by multiple layers of scripts used when launching the application. Having duplicate flags is dangerous as changing one of the flags in one of the scripts may not have the intended effect. This can be especially dangerous for security related system properties. The following flags were duplicated: &lt;ul&gt;&lt;li&gt;-XX:NewSize=65m,-XX:NewSize=65m&lt;\/li&gt;&lt;li&gt;-Dweblogic.home=C:\\weblogic\\src122130_build\\Oracle_Home\\wlserver\/server,-Dweblogic.home=C:\\weblogic\\SRC122~1\\ORACLE~1\\wlserver\\server&lt;\/li&gt;&lt;li&gt;-Xmx500m,-Xmx500m&lt;\/li&gt;&lt;li&gt;-Xms160m,-Xms160m&lt;\/li&gt;&lt;li&gt;-XX:MaxNewSize=65m,-XX:MaxNewSize=65m&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n+            <solution>Try to find all the places where the flag is defined and keep only one.<\/solution>\n+        <\/rule>\n+        <rule>\n+            <id>DynamicAgents<\/id>\n@@ -4937,0 +5122,4 @@\n+        <rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -4939,2 +5128,1 @@\n-            <severity>OK<\/severity>\n-            <summary>There are no file read events in this recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -4944,5 +5132,0 @@\n-            <severity>OK<\/severity>\n-            <summary>There are no file write events in this recording.<\/summary>\n-        <\/rule>\n-\t\t<rule>\n-            <id>FileForce<\/id>\n@@ -4953,4 +5136,1 @@\n-            <severity>Information<\/severity>\n-            <summary>80 finalizers were run.<\/summary>\n-            <explanation>Finalization can lead to performance issues, deadlocks, or hangs, and has been marked for removal in a future Java version. The following finalizable classes have been detected: &lt;ul&gt;&lt;li&gt;org.openjdk.jmc.rjmx.internal.DefaultConnectionHandle&lt;\/li&gt;&lt;li&gt;org.openjdk.jmc.rjmx.internal.ServerHandle&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n-            <solution>Remove finalize method implementations from your application, and consider making use of the [Cleaner API](https:\/\/docs.oracle.com\/en\/java\/javase\/17\/docs\/api\/java.base\/java\/lang\/ref\/Cleaner.html) instead.<\/solution>\n+            <severity>Not Applicable<\/severity>\n@@ -4960,1 +5140,3 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>Warning<\/severity>\n+            <summary>The recording is from an early access build.<\/summary>\n+            <explanation>This recording is from an early access build of the JRE (Java HotSpot(TM) 64-Bit Server VM (9-ea+148) for windows-amd64 JRE (9-ea+148), built on Dec  7 2016 18:47:38 by &amp;#34;javare&amp;#34; with MS VC++ 12.0 (VS2013)). The automated analysis is not supported, and you may see errors when attempting to analyze the recording.<\/explanation>\n@@ -4964,3 +5146,2 @@\n-            <severity>Warning<\/severity>\n-            <summary>Full GC detected.<\/summary>\n-            <explanation>At least one Full, Stop-The-World Garbage Collection occurred during this recording. For the CMS and G1 collectors, Full GC events are a strong negative performance indicator. Tunable GC parameters can be used to allow the collector to operate in concurrent mode, avoiding Stop-The-World pauses and increasing GC and application performance.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n+            <summary>This rule is only valid for CMS and G1 Garbage Collectors, neither of which were detected for this JVM.<\/summary>\n@@ -4970,1 +5151,1 @@\n-            <severity>OK<\/severity>\n+            <severity>Not Applicable<\/severity>\n@@ -4974,2 +5155,1 @@\n-            <severity>OK<\/severity>\n-            <summary>Only 4 heap summary events were found, this rule requires at least 10 events to be able to calculate a relevant result. This likely means that only a few garbage collections occurred during the recording. Having few garbage collections is generally a good sign.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -4979,7 +5159,1 @@\n-            <severity>OK<\/severity>\n-            <summary>OK<\/summary>\n-        <\/rule>\n-        <rule>\n-            <id>GcLocker<\/id>\n-            <severity>OK<\/severity>\n-            <summary>No GCs were affected by the GC Locker.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -4990,0 +5164,1 @@\n+            <summary>Too few events to calculate the result.<\/summary>\n@@ -4993,4 +5168,1 @@\n-            <severity>OK<\/severity>\n-            <summary>Application efficiency was not highly affected by GC pauses.<\/summary>\n-            <explanation>The highest ratio between garbage collection pauses and execution time was 0.172 % during 11\/20\/2023 4:22:52.000 PM – 4:23:52 PM. The garbage collection pause ratio of the entire recording was 0.275 %.<\/explanation>\n-            <solution>Pause times may be reduced by increasing the heap size or by trying to reduce allocation.<\/solution>\n+            <severity>Not Applicable<\/severity>\n@@ -5002,5 +5174,0 @@\n-        <rule>\n-            <id>GcStall<\/id>\n-            <severity>OK<\/severity>\n-            <summary>No indications that the garbage collector could not keep up with the workload were detected.<\/summary>\n-        <\/rule>\n@@ -5009,3 +5176,1 @@\n-            <severity>Warning<\/severity>\n-            <summary>Most of the heap was used by only a few classes.<\/summary>\n-            <explanation>If the heap usage needs to be reduced, then this would be a good place to start.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -5015,9 +5180,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No heap dump performed.<\/summary>\n-        <\/rule>\n-        <rule>\n-            <id>HeapInspectionGc<\/id>\n-            <severity>Information<\/severity>\n-            <summary>The JVM performed 2 heap inspection garbage collections.<\/summary>\n-            <explanation>Performing heap inspection garbage collections may be a problem since they usually take a lot of time.\n-Some of these inspections were caused by the 'Object Count' JFR event. It triggers a full garbage collection at the beginning and end of every recording where that event is enabled. If recordings are only made on demand or not too often, then these garbage collections are usually not a problem since the resulting pauses are not part of the normal application behavior. If recordings are collected often, for example by automatic scripts, or if the application is sensitive to pauses, then it might become an issue. In that case you can consider disabling the 'Object Count' event.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -5027,3 +5184,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The JVM was paused for 100 % during 11\/20\/2023 4:23:22.169.000 PM – .272<\/summary>\n-            <explanation>The time spent performing garbage collection may be reduced by increasing the heap size or by trying to reduce allocation.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -5038,1 +5193,0 @@\n-            <summary>Too few events to calculate the result.<\/summary>\n@@ -5042,2 +5196,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The class data does not seem to increase during the recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -5047,3 +5200,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No excessive problems with lock contention found.<\/summary>\n-            <explanation>The following regular expression was used to exclude threads from this rule: ''(.*weblogic\\.socket\\.Muxer.*)''<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -5053,1 +5204,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n@@ -5057,3 +5209,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The longest GC pause was 103.247 ms.<\/summary>\n-            <explanation\/>\n+            <severity>Not Applicable<\/severity>\n@@ -5075,2 +5225,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The metaspace was not exhausted during this recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -5080,2 +5229,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No methods where optimization would be particularly efficient could be detected.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -5084,1 +5232,1 @@\n-            <id>Options<\/id>\n+            <id>MultipleAgents<\/id>\n@@ -5087,0 +5235,5 @@\n+        <rule>\n+            <id>Options<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No undocumented, deprecated or non-recommended option flags were detected.<\/summary>\n+        <\/rule>\n@@ -5093,1 +5246,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>The recording does not seem to contain passwords in the application arguments.<\/summary>\n@@ -5105,2 +5259,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No allocation was caused by conversion from primitive types to the corresponding object types.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -5122,2 +5275,4 @@\n-            <severity>OK<\/severity>\n-            <summary>No stack traces were truncated in this recording.<\/summary>\n+            <severity>Warning<\/severity>\n+            <summary>Some stack traces were truncated in this recording.<\/summary>\n+            <explanation>The Flight Recorder is configured with a maximum captured stack depth of 64. 17.5 % of all traces were larger than this option, and were therefore truncated. If more detailed traces are required, increase the ''-XX:FlightRecorderOptions=stackdepth=&lt;value&gt;'' value.\n+Events of the following types have truncated stack traces: &lt;ul&gt;&lt;li&gt;Debug (1.59 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Business Method Invoke (71.3 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Business Method Post Invoke (71.3 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Business Method Post Invoke Cleanup (71.3 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Business Method Pre Invoke (71.3 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Pool Manager Create (75 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Pool Manager Post Invoke (71.3 % truncated traces)&lt;\/li&gt;&lt;li&gt;EJB Pool Manager Pre Invoke (71.3 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Connection Close (96.8 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Connection Prepare (100 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Connection Release (85.7 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Statement Creation (100 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Statement Execute (96.7 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Statement Execute Begin (96.7 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Transaction Commit (45 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Transaction End (45 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Transaction Is Same RM (1.79 % truncated traces)&lt;\/li&gt;&lt;li&gt;JDBC Transaction Start (100 % truncated traces)&lt;\/li&gt;&lt;li&gt;JTA Transaction Commit (36.4 % truncated traces)&lt;\/li&gt;&lt;li&gt;JTA Transaction End (6.06 % truncated traces)&lt;\/li&gt;&lt;li&gt;JTA Transaction Start (16.7 % truncated traces)&lt;\/li&gt;&lt;li&gt;Servlet Response Write Headers (1.87 % truncated traces)&lt;\/li&gt;&lt;li&gt;Webservices JAXRPC Client Request (50 % truncated traces)&lt;\/li&gt;&lt;li&gt;Webservices JAXRPC Client Response (100 % truncated traces)&lt;\/li&gt;&lt;li&gt;Webservices JAXWS Endpoint (100 % truncated traces)&lt;\/li&gt;&lt;li&gt;Webservices JAXWS Resource (50 % truncated traces)&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n@@ -5129,5 +5284,0 @@\n-        <rule>\n-            <id>SystemGc<\/id>\n-            <severity>OK<\/severity>\n-            <summary>No garbage collections were caused by System.gc().<\/summary>\n-        <\/rule>\n@@ -5136,3 +5286,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The program allocated 4.04 % of the memory outside of TLABs.<\/summary>\n-            <solution>Allocating objects outside of Thread Local Allocation Buffers (TLABs) is more expensive than allocating inside TLABs. This may be acceptable if the individual allocations are intended to be larger than a reasonable TLAB. It may be possible to avoid this by decreasing the size of the individual allocations. There are some TLAB related JVM flags that you can experiment with, but it is usually better to let the JVM manage TLAB sizes automatically.<\/solution>\n+            <severity>Not Applicable<\/severity>\n@@ -5142,2 +5290,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No excessively long VM operations were found in this recording (the longest was 103.369 ms).<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -5151,2 +5298,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No revocation of biased locks found.<\/summary>\n+            <severity>Not Applicable<\/severity>\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/baseline\/JfrRuleBaseline.xml","additions":1293,"deletions":1147,"binary":false,"changes":2440,"status":"modified"}]}