{"files":[{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.rjmx.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.management.remote.JMXConnector;\n+import javax.management.remote.JMXConnectorFactory;\n+import javax.management.remote.JMXConnectorProvider;\n+import javax.management.remote.JMXConnectorServerFactory;\n+import javax.management.remote.JMXServiceURL;\n+\n+import org.eclipse.core.runtime.CoreException;\n+import org.eclipse.core.runtime.IConfigurationElement;\n+import org.eclipse.core.runtime.IExtensionRegistry;\n+import org.eclipse.core.runtime.Platform;\n+import org.openjdk.jmc.rjmx.RJMXPlugin;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.InvalidSyntaxException;\n+import org.osgi.framework.ServiceReference;\n+\n+public class ProtocolInitializer {\n+\tprivate final static String EXTENSION_POINT = \"org.openjdk.jmc.rjmx.jmxProtocols\";\/\/$NON-NLS-1$\n+\tprivate final static String EXTENSION_ELEMENT_CLIENT = \"client\";\/\/$NON-NLS-1$\n+\tprivate final static String EXTENSION_ATTRIBUTE_CLASS = \"class\";\/\/$NON-NLS-1$\n+\tprivate final static String EXTENSION_ATTRIBUTE_PROTOCOL = \"protocol\";\/\/$NON-NLS-1$\n+\tprivate final static String ATTRIBUTE_KEY = \"name\"; \/\/$NON-NLS-1$\n+\tprivate final static String TAG_SYSPROPERTY = \"sysproperty\"; \/\/$NON-NLS-1$\n+\tprivate final static String ATTRIBUTE_INCLUDE = \"include\"; \/\/$NON-NLS-1$\n+\tprivate final static String ATTRIBUTE_SEPARATOR = \"separator\"; \/\/$NON-NLS-1$\n+\n+\tpublic JMXConnector newJMXConnector(JMXServiceURL serviceURL, Map<String, ?> environment) throws IOException {\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tJMXConnectorProvider realProvider = extendEnv(serviceURL, (Map<String, Object>) environment);\n+\t\tif (realProvider == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn realProvider.newJMXConnector(serviceURL, environment);\n+\t}\n+\n+\tpublic JMXConnectorProvider extendEnv(JMXServiceURL serviceURL, Map<String, Object> environment) {\n+\t\tString filter = '(' + EXTENSION_ATTRIBUTE_PROTOCOL + '=' + serviceURL.getProtocol() + ')';\n+\t\ttry {\n+\t\t\tfinal BundleContext context = FrameworkUtil.getBundle(getClass()).getBundleContext();\n+\t\t\tCollection<ServiceReference<JMXConnectorProvider>> refs;\n+\t\t\trefs = context.getServiceReferences(JMXConnectorProvider.class, filter);\n+\n+\t\t\tfor (ServiceReference<JMXConnectorProvider> ref : refs) {\n+\t\t\t\tJMXConnectorProvider provider = context.getService(ref);\n+\t\t\t\tif (provider != null) {\n+\t\t\t\t\tfor (String key : ref.getPropertyKeys()) {\n+\t\t\t\t\t\tObject value = ref.getProperty(key);\n+\n+\t\t\t\t\t\tString property = getIfPrefixed(\"environment:\", key); \/\/$NON-NLS-1$\n+\t\t\t\t\t\tif (property != null) {\n+\t\t\t\t\t\t\tenvironment.put(property, value);\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tproperty = getIfPrefixed(\"system:\", key); \/\/$NON-NLS-1$\n+\t\t\t\t\t\tif (property != null) {\n+\t\t\t\t\t\t\tensureSystemProperty(property, value.toString(), \"|\"); \/\/$NON-NLS-1$\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tClassLoader loader = provider.getClass().getClassLoader();\n+\t\t\t\t\tenvironment.put(JMXConnectorFactory.DEFAULT_CLASS_LOADER, loader);\n+\t\t\t\t\t\/\/ Used by MX4J.\n+\t\t\t\t\tenvironment.put(JMXConnectorServerFactory.PROTOCOL_PROVIDER_CLASS_LOADER, loader);\n+\n+\t\t\t\t\t\/\/ FIXME: Add WeakRef\/ReferenceQueue or listener to \"unget\" service?\n+\t\t\t\t\t\/\/ return provider.newJMXConnector(serviceURL, environment);\n+\t\t\t\t\treturn provider;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (InvalidSyntaxException e) {\n+\t\t\t\/\/ Assume this is a bad protocol name. At least we don't support it.\n+\t\t\tLogger.getLogger(\"org.openjdk.jmc.rjmx.ext\").log(Level.WARNING, \"Bad protocol syntax\", e); \/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n+\t\t}\n+\n+\t\treturn null;\n+\t}\n+\n+\tprivate static String getIfPrefixed(String prefix, String candidate) {\n+\t\tif (candidate.startsWith(prefix)) {\n+\t\t\treturn candidate.substring(prefix.length());\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprivate static void ensureSystemProperty(String key, String include, String separator) {\n+\t\tString org = System.getProperty(key);\n+\t\tif (org == null) {\n+\t\t\tSystem.setProperty(key, include);\n+\t\t\treturn;\n+\t\t}\n+\t\tif ((separator + org + separator).indexOf(separator + include + separator) < 0) {\n+\t\t\tSystem.setProperty(key, org + separator + include);\n+\t\t}\n+\t}\n+\n+\tpublic static List<JMXConnectorProvider> initializeFromExtensions() {\n+\t\tList<JMXConnectorProvider> providers = new ArrayList<>();\n+\t\tIExtensionRegistry registry = Platform.getExtensionRegistry();\n+\t\tfor (IConfigurationElement config : registry.getConfigurationElementsFor(EXTENSION_POINT)) {\n+\t\t\tif (config.getName().equals(EXTENSION_ELEMENT_CLIENT)) {\n+\t\t\t\ttry {\n+\t\t\t\t\tJMXConnectorProvider provider = (JMXConnectorProvider) config\n+\t\t\t\t\t\t\t.createExecutableExtension(EXTENSION_ATTRIBUTE_CLASS);\n+\t\t\t\t\tproviders.add(provider);\n+\t\t\t\t\tfor (IConfigurationElement prop : config.getChildren(TAG_SYSPROPERTY)) {\n+\t\t\t\t\t\tensureSystemProperty(prop.getAttribute(ATTRIBUTE_KEY), prop.getAttribute(ATTRIBUTE_INCLUDE),\n+\t\t\t\t\t\t\t\tprop.getAttribute(ATTRIBUTE_SEPARATOR));\n+\t\t\t\t\t}\n+\t\t\t\t} catch (CoreException e) {\n+\t\t\t\t\tRJMXPlugin.getDefault().getLogger().log(Level.SEVERE,\n+\t\t\t\t\t\t\t\"Could not instantiate JMX protocol provider!\", e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn providers;\n+\t}\n+\n+}\n","filename":"application\/org.openjdk.jmc.rjmx\/src\/main\/java\/org\/openjdk\/jmc\/rjmx\/internal\/ProtocolInitializer.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -35,0 +35,1 @@\n+import java.io.IOException;\n@@ -38,0 +39,4 @@\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.management.remote.JMXConnector;\n@@ -121,0 +126,4 @@\n+\t\t\tJMXConnector overriddenConnection = this.checkForProtocolSpecificConnectorExtension();\n+\t\t\tif (overriddenConnection != null) {\n+\t\t\t\tconnection.specifyConnector(overriddenConnection);\n+\t\t\t}\n@@ -132,0 +141,11 @@\n+\tprivate JMXConnector checkForProtocolSpecificConnectorExtension() {\n+\t\tfinal IConnectionDescriptor descriptor = this.connection.getConnectionDescriptor();\n+\t\ttry {\n+\t\t\treturn new ProtocolInitializer().newJMXConnector(descriptor.createJMXServiceURL(),\n+\t\t\t\t\tdescriptor.getEnvironment());\n+\t\t} catch (IOException e) {\n+\t\t\tLogger.getLogger(getClass().getName()).log(Level.INFO, \"Error attempting JMX protocol extensions\", e);\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n","filename":"application\/org.openjdk.jmc.rjmx\/src\/main\/java\/org\/openjdk\/jmc\/rjmx\/internal\/ServerHandle.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -591,1 +591,4 @@\n-\t\tm_jmxc = JMXConnectorFactory.newJMXConnector(serviceURL, env);\n+\t\tif (m_jmxc == null) {\n+\t\t\t\/\/This will use Java's standard connector, which will not take JMC extensions into account\n+\t\t\tm_jmxc = JMXConnectorFactory.newJMXConnector(serviceURL, env);\n+\t\t}\n@@ -616,0 +619,4 @@\n+\tpublic void specifyConnector(final JMXConnector specificConnector) {\n+\t\tthis.m_jmxc = specificConnector;\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.rjmx.common\/src\/main\/java\/org\/openjdk\/jmc\/rjmx\/common\/internal\/RJMXConnection.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}