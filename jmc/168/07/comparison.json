{"files":[{"patch":"@@ -47,1 +47,4 @@\n-*.log\n\\ No newline at end of file\n+*.log\n+\n+# Ignore the generated test baseline\n+core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/baseline\/Generated_JfrRuleBaseline.xml\n\\ No newline at end of file\n","filename":".gitignore","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,5 +33,1 @@\n-\t<classpathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER\/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType\/JavaSE-1.8\">\n-\t\t<attributes>\n-\t\t\t<attribute name=\"maven.pomderived\" value=\"true\"\/>\n-\t\t<\/attributes>\n-\t<\/classpathentry>\n+\t<classpathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER\/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType\/JavaSE-11\"\/>\n","filename":"agent\/.classpath","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8\n+org.eclipse.jdt.core.compiler.codegen.targetPlatform=11\n@@ -6,1 +6,1 @@\n-org.eclipse.jdt.core.compiler.compliance=1.8\n+org.eclipse.jdt.core.compiler.compliance=11\n@@ -20,2 +20,2 @@\n-org.eclipse.jdt.core.compiler.release=disabled\n-org.eclipse.jdt.core.compiler.source=1.8\n+org.eclipse.jdt.core.compiler.release=enabled\n+org.eclipse.jdt.core.compiler.source=11\n","filename":"agent\/.settings\/org.eclipse.jdt.core.prefs","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -18,0 +18,1 @@\n+    <stringAttribute key=\"org.eclipse.jdt.launching.MODULE_NAME\" value=\"org.openjdk.jmc.agent\"\/>\n","filename":"agent\/launchers\/InstrumentMe.launch","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -18,0 +18,1 @@\n+    <stringAttribute key=\"org.eclipse.jdt.launching.MODULE_NAME\" value=\"org.openjdk.jmc.agent\"\/>\n","filename":"agent\/launchers\/InstrumentMeConverter.launch","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,19 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<launchConfiguration type=\"org.eclipse.jdt.junit.launchconfig\">\n+    <listAttribute key=\"org.eclipse.debug.core.MAPPED_RESOURCE_PATHS\">\n+        <listEntry value=\"\/org.openjdk.jmc.agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/test\/TestRetrieveCurrentTransforms.java\"\/>\n+    <\/listAttribute>\n+    <listAttribute key=\"org.eclipse.debug.core.MAPPED_RESOURCE_TYPES\">\n+        <listEntry value=\"1\"\/>\n+    <\/listAttribute>\n+    <stringAttribute key=\"org.eclipse.jdt.junit.CONTAINER\" value=\"\"\/>\n+    <booleanAttribute key=\"org.eclipse.jdt.junit.KEEPRUNNING_ATTR\" value=\"false\"\/>\n+    <stringAttribute key=\"org.eclipse.jdt.junit.TESTNAME\" value=\"\"\/>\n+    <stringAttribute key=\"org.eclipse.jdt.junit.TEST_KIND\" value=\"org.eclipse.jdt.junit.loader.junit4\"\/>\n+    <booleanAttribute key=\"org.eclipse.jdt.launching.ATTR_USE_CLASSPATH_ONLY_JAR\" value=\"false\"\/>\n+    <stringAttribute key=\"org.eclipse.jdt.launching.CLASSPATH_PROVIDER\" value=\"org.eclipse.m2e.launchconfig.classpathProvider\"\/>\n+    <stringAttribute key=\"org.eclipse.jdt.launching.MAIN_TYPE\" value=\"org.openjdk.jmc.agent.test.TestRetrieveCurrentTransforms\"\/>\n+    <stringAttribute key=\"org.eclipse.jdt.launching.PROJECT_ATTR\" value=\"org.openjdk.jmc.agent\"\/>\n+    <stringAttribute key=\"org.eclipse.jdt.launching.SOURCE_PATH_PROVIDER\" value=\"org.eclipse.m2e.launchconfig.sourcepathProvider\"\/>\n+    <stringAttribute key=\"org.eclipse.jdt.launching.VM_ARGUMENTS\" value=\"--add-opens java.base\/jdk.internal.misc=ALL-UNNAMED -XX:+FlightRecorder -javaagent:${resource_loc:\/org.openjdk.jmc.agent\/target\/org.openjdk.jmc.agent-1.0.0-SNAPSHOT.jar}=${resource_loc:\/org.openjdk.jmc.agent\/src\/test\/resources\/org\/openjdk\/jmc\/agent\/test\/jfrprobes_simple.xml}\"\/>\n+<\/launchConfiguration>\n","filename":"agent\/launchers\/TestRetrieveCurrentTransforms.launch","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<launchConfiguration type=\"org.eclipse.jdt.junit.launchconfig\">\n+    <listAttribute key=\"org.eclipse.debug.core.MAPPED_RESOURCE_PATHS\">\n+        <listEntry value=\"\/org.openjdk.jmc.agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/test\/TestRetrieveEventProbes.java\"\/>\n+    <\/listAttribute>\n+    <listAttribute key=\"org.eclipse.debug.core.MAPPED_RESOURCE_TYPES\">\n+        <listEntry value=\"1\"\/>\n+    <\/listAttribute>\n+    <stringAttribute key=\"org.eclipse.jdt.junit.CONTAINER\" value=\"\"\/>\n+    <booleanAttribute key=\"org.eclipse.jdt.junit.KEEPRUNNING_ATTR\" value=\"false\"\/>\n+    <stringAttribute key=\"org.eclipse.jdt.junit.TESTNAME\" value=\"\"\/>\n+    <stringAttribute key=\"org.eclipse.jdt.junit.TEST_KIND\" value=\"org.eclipse.jdt.junit.loader.junit4\"\/>\n+    <booleanAttribute key=\"org.eclipse.jdt.launching.ATTR_USE_CLASSPATH_ONLY_JAR\" value=\"false\"\/>\n+    <stringAttribute key=\"org.eclipse.jdt.launching.CLASSPATH_PROVIDER\" value=\"org.eclipse.m2e.launchconfig.classpathProvider\"\/>\n+    <stringAttribute key=\"org.eclipse.jdt.launching.MAIN_TYPE\" value=\"org.openjdk.jmc.agent.test.TestRetrieveEventProbes\"\/>\n+    <stringAttribute key=\"org.eclipse.jdt.launching.PROJECT_ATTR\" value=\"org.openjdk.jmc.agent\"\/>\n+    <stringAttribute key=\"org.eclipse.jdt.launching.SOURCE_PATH_PROVIDER\" value=\"org.eclipse.m2e.launchconfig.sourcepathProvider\"\/>\n+    <stringAttribute key=\"org.eclipse.jdt.launching.VM_ARGUMENTS\" value=\"--add-opens java.base\/jdk.internal.misc=ALL-UNNAMED -XX:+FlightRecorder -javaagent:${resource_loc:\/org.openjdk.jmc.agent\/target\/org.openjdk.jmc.agent-1.0.0-SNAPSHOT.jar}=${resource_loc:\/org.openjdk.jmc.agent\/src\/test\/resources\/org\/openjdk\/jmc\/agent\/test\/jfrprobes_simple.xml}\"\/>\n+<\/launchConfiguration>\n","filename":"agent\/launchers\/TestRetrieveEventProbes.launch","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -60,1 +60,1 @@\n-\tpublic final static String VERSION = \"0.0.2\"; \/\/$NON-NLS-1$\n+\tpublic static final String VERSION = \"0.9.0\"; \/\/$NON-NLS-1$\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/Agent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-public interface Attribute {\n+public interface Attribute extends Convertable {\n@@ -45,2 +45,0 @@\n-\n-\tString getConverterClassName();\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/Attribute.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.agent;\n+\n+\/**\n+ * Interface for something that can use a converter to translate a value.\n+ *\/\n+public interface Convertable {\n+\t\/**\n+\t * @return true if this is convertable, false otherwise.\n+\t *\/\n+\tdefault boolean hasConverter() {\n+\t\treturn getConverterDefinition() != null;\n+\t}\n+\n+\t\/**\n+\t * The class name of the converter to use.\n+\t *\n+\t * @return the class name of the converter to use, or null, if no converter should be used.\n+\t *\/\n+\tString getConverterDefinition();\n+}\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/Convertable.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -41,0 +41,1 @@\n+import org.openjdk.jmc.agent.impl.AbstractConvertable;\n@@ -43,1 +44,1 @@\n-public class Field implements Attribute {\n+public class Field extends AbstractConvertable implements Attribute {\n@@ -51,1 +52,0 @@\n-\tprivate final String converterClassName;\n@@ -58,0 +58,1 @@\n+\t\tsuper(converterClassName);\n@@ -63,1 +64,0 @@\n-\t\tthis.converterClassName = converterClassName;\n@@ -69,1 +69,1 @@\n-\t\t\t\t(String) cd.get(\"contentType\"), (String) cd.get(\"relationKey\"), (String) cd.get(\"converterClassName\"));\n+\t\t\t\t(String) cd.get(\"contentType\"), (String) cd.get(\"relationKey\"), (String) cd.get(\"converterDefinition\"));\n@@ -101,5 +101,0 @@\n-\t@Override\n-\tpublic String getConverterClassName() {\n-\t\treturn this.converterClassName;\n-\t}\n-\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/Field.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import org.openjdk.jmc.agent.impl.AbstractConvertable;\n@@ -42,1 +43,1 @@\n-public final class Parameter implements Attribute {\n+public final class Parameter extends AbstractConvertable implements Attribute {\n@@ -51,1 +52,0 @@\n-\tprivate final String converterClassName;\n@@ -55,0 +55,1 @@\n+\t\tsuper(converterClassName);\n@@ -60,1 +61,0 @@\n-\t\tthis.converterClassName = converterClassName;\n@@ -66,1 +66,1 @@\n-\t\t\t\t(String) cd.get(\"contentType\"), (String) cd.get(\"relationKey\"), (String) cd.get(\"converterClassName\"));\n+\t\t\t\t(String) cd.get(\"contentType\"), (String) cd.get(\"relationKey\"), (String) cd.get(\"converterDefinition\"));\n@@ -96,4 +96,0 @@\n-\n-\tpublic String getConverterClassName() {\n-\t\treturn converterClassName;\n-\t}\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/Parameter.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import org.openjdk.jmc.agent.impl.AbstractConvertable;\n@@ -42,1 +43,1 @@\n-public final class ReturnValue implements Attribute {\n+public final class ReturnValue extends AbstractConvertable implements Attribute {\n@@ -48,1 +49,0 @@\n-\tprivate final String converterClassName;\n@@ -52,0 +52,1 @@\n+\t\tsuper(converterClassName);\n@@ -56,1 +57,0 @@\n-\t\tthis.converterClassName = converterClassName;\n@@ -85,5 +85,0 @@\n-\t@Override\n-\tpublic String getConverterClassName() {\n-\t\treturn converterClassName;\n-\t}\n-\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/ReturnValue.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -49,2 +49,1 @@\n-import org.openjdk.jmc.agent.jfrnext.impl.JFRNextClassVisitor;\n-import org.openjdk.jmc.agent.util.InspectionClassLoader;\n+import org.openjdk.jmc.agent.jfrlegacy.impl.JFRLegacyClassVisitor;\n@@ -64,2 +63,0 @@\n-\t\t\/\/ We need a class instance for reflective inspection, so create a InspectionClassLoader if the class if not yet \n-\t\t\/\/ loaded.\n@@ -67,1 +64,1 @@\n-\t\t\t\tprotectionDomain, classBeingRedefined != null ? null : new InspectionClassLoader(loader));\n+\t\t\t\tprotectionDomain);\n@@ -72,1 +69,4 @@\n-\t\tClass<?> classBeingRedefined, ProtectionDomain protectionDomain, InspectionClassLoader inspectionClassLoader) {\n+\t\tClass<?> classBeingRedefined, ProtectionDomain protectionDomain) {\n+\t\tif (transformDataList == null) {\n+\t\t\treturn null;\n+\t\t}\n@@ -76,1 +76,1 @@\n-\t\t\t\t\tprotectionDomain, inspectionClassLoader);\n+\t\t\t\t\tprotectionDomain);\n@@ -84,1 +84,1 @@\n-\t\tProtectionDomain protectionDomain, InspectionClassLoader inspectionClassLoader) {\n+\t\tProtectionDomain protectionDomain) {\n@@ -86,1 +86,1 @@\n-\t\t\t\tprotectionDomain, inspectionClassLoader);\n+\t\t\t\tprotectionDomain);\n@@ -91,1 +91,1 @@\n-\t\tClass<?> classBeingRedefined, ProtectionDomain protectionDomain, InspectionClassLoader inspectionClassLoader) {\n+\t\tClass<?> classBeingRedefined, ProtectionDomain protectionDomain) {\n@@ -100,4 +100,3 @@\n-\t\t\t\t\t? new JFRNextClassVisitor(classWriter, td, definingClassLoader, classBeingRedefined,\n-\t\t\t\t\t\t\tprotectionDomain, inspectionClassLoader)\n-\t\t\t\t\t: new JFRClassVisitor(classWriter, td, definingClassLoader, classBeingRedefined, protectionDomain,\n-\t\t\t\t\t\t\tinspectionClassLoader);\n+\t\t\t\t\t? new JFRClassVisitor(classWriter, td, definingClassLoader, classBeingRedefined, protectionDomain)\n+\t\t\t\t\t: new JFRLegacyClassVisitor(classWriter, td, definingClassLoader, classBeingRedefined,\n+\t\t\t\t\t\t\tprotectionDomain);\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/Transformer.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,2 @@\n- * The default converter used if nothing has been specified.\n+ * The default converter used if nothing has been specified on reference types. The default use is\n+ * opt-in, but it can also just be used as a converter if opted out.\n@@ -40,5 +41,2 @@\n-public final class DefaultStringConverter implements StringConverter<Object> {\n-\tprivate final static DefaultStringConverter INSTANCE = new DefaultStringConverter();\n-\n-\t@Override\n-\tpublic String convert(Object o) {\n+public final class DefaultStringConverter {\n+\tpublic static String convert(Object o) {\n@@ -47,4 +45,0 @@\n-\n-\tpublic static DefaultStringConverter getInstance() {\n-\t\treturn INSTANCE;\n-\t}\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/converters\/DefaultStringConverter.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * \n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * The contents of this file are subject to the terms of either the Universal Permissive License\n- * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n- *\n- * or the following license:\n- *\n- * Redistribution and use in source and binary forms, with or without modification, are permitted\n- * provided that the following conditions are met:\n- * \n- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n- * and the following disclaimer.\n- * \n- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n- * conditions and the following disclaimer in the documentation and\/or other materials provided with\n- * the distribution.\n- * \n- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n- * endorse or promote products derived from this software without specific prior written permission.\n- * \n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n- * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-package org.openjdk.jmc.agent.converters;\n-\n-\/**\n- * Interface for converting an object to a double.\n- *\/\n-public interface DoubleConverter<T> {\n-\t\/**\n-\t * Converts an object to a double.\n-\t * \n-\t * @param o\n-\t *            the object to convert.\n-\t * @return the object converted to a double.\n-\t *\/\n-\tdouble convert(T o);\n-}\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/converters\/DoubleConverter.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.agent.converters;\n+\n+import java.io.File;\n+import java.util.logging.Level;\n+\n+import org.openjdk.jmc.agent.Agent;\n+\n+\/**\n+ * A converter which converts files into their canonical path.\n+ *\/\n+public final class FileConverter {\n+\tpublic static String convert(File file) {\n+\t\tif (file == null) {\n+\t\t\treturn \"null\";\n+\t\t}\n+\t\ttry {\n+\t\t\treturn file.getCanonicalPath();\n+\t\t} catch (Throwable e) {\n+\t\t\tAgent.getLogger().log(Level.WARNING,\n+\t\t\t\t\t\"Agent failed to convert file to String, will use path. File was: \" + file.toString(), e);\n+\t\t}\n+\t\treturn file.getPath();\n+\t}\n+}\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/converters\/FileConverter.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * \n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * The contents of this file are subject to the terms of either the Universal Permissive License\n- * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n- *\n- * or the following license:\n- *\n- * Redistribution and use in source and binary forms, with or without modification, are permitted\n- * provided that the following conditions are met:\n- * \n- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n- * and the following disclaimer.\n- * \n- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n- * conditions and the following disclaimer in the documentation and\/or other materials provided with\n- * the distribution.\n- * \n- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n- * endorse or promote products derived from this software without specific prior written permission.\n- * \n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n- * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-package org.openjdk.jmc.agent.converters;\n-\n-\/**\n- * Interface for converting an object to a float.\n- *\/\n-public interface FloatConverter<T> {\n-\t\/**\n-\t * Converts an object to a float.\n-\t * \n-\t * @param o\n-\t *            the object to convert.\n-\t * @return the object converted to a float.\n-\t *\/\n-\tfloat convert(T o);\n-}\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/converters\/FloatConverter.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * \n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * The contents of this file are subject to the terms of either the Universal Permissive License\n- * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n- *\n- * or the following license:\n- *\n- * Redistribution and use in source and binary forms, with or without modification, are permitted\n- * provided that the following conditions are met:\n- * \n- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n- * and the following disclaimer.\n- * \n- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n- * conditions and the following disclaimer in the documentation and\/or other materials provided with\n- * the distribution.\n- * \n- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n- * endorse or promote products derived from this software without specific prior written permission.\n- * \n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n- * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-package org.openjdk.jmc.agent.converters;\n-\n-\/**\n- * Interface for converting an object to an int.\n- *\/\n-public interface IntConverter<T> {\n-\t\/**\n-\t * Converts an object to an int.\n-\t * \n-\t * @param o\n-\t *            the object to convert.\n-\t * @return the object converted to a int.\n-\t *\/\n-\tint convert(T o);\n-}\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/converters\/IntConverter.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * \n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * The contents of this file are subject to the terms of either the Universal Permissive License\n- * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n- *\n- * or the following license:\n- *\n- * Redistribution and use in source and binary forms, with or without modification, are permitted\n- * provided that the following conditions are met:\n- * \n- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n- * and the following disclaimer.\n- * \n- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n- * conditions and the following disclaimer in the documentation and\/or other materials provided with\n- * the distribution.\n- * \n- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n- * endorse or promote products derived from this software without specific prior written permission.\n- * \n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n- * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-package org.openjdk.jmc.agent.converters;\n-\n-\/**\n- * Interface for converting an object to a long.\n- *\/\n-public interface LongConverter<T> {\n-\t\/**\n-\t * Converts an object to a long.\n-\t * \n-\t * @param o\n-\t *            the object to convert.\n-\t * @return the object converted to a long.\n-\t *\/\n-\tlong convert(T o);\n-}\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/converters\/LongConverter.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * \n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * The contents of this file are subject to the terms of either the Universal Permissive License\n- * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n- *\n- * or the following license:\n- *\n- * Redistribution and use in source and binary forms, with or without modification, are permitted\n- * provided that the following conditions are met:\n- * \n- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n- * and the following disclaimer.\n- * \n- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n- * conditions and the following disclaimer in the documentation and\/or other materials provided with\n- * the distribution.\n- * \n- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n- * endorse or promote products derived from this software without specific prior written permission.\n- * \n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n- * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-package org.openjdk.jmc.agent.converters;\n-\n-\/**\n- * Interface for converting objects to Strings.\n- *\/\n-public interface StringConverter<T> {\n-\t\/**\n-\t * Converts an object to a String.\n-\t * \n-\t * @param o\n-\t *            the object to convert.\n-\t * @return the object converted to a String.\n-\t *\/\n-\tString convert(T o);\n-}\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/converters\/StringConverter.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,5 +36,6 @@\n- * This package contains converter interfaces and implementations. A converter will convert an\n- * object into one of the types that the recorder can record. Note that the converter will be called\n- * from the event site, so make sure your code performs. If your converter has a static getInstance\n- * method, it will be assumed that your converter is thread safe, and no converter field will be\n- * generated into the event class - the singleton will be used instead.\n+ * This package contains converter implementations. A converter will convert an object into one of\n+ * the types that the recorder can record. Note that the converter will be called from the event\n+ * site, so make sure your code performs and that no exceptions can escape. For a converter to\n+ * function, it must contain a static method named convert, and take as a single argument of the\n+ * type of the parameter\/return value\/field it is supposed to convert. It must return one of the JFR\n+ * supported field types.\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/converters\/package-info.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.agent.impl;\n+\n+import org.openjdk.jmc.agent.Convertable;\n+\n+public abstract class AbstractConvertable implements Convertable {\n+\tprivate final String converterDefinition;\n+\n+\tpublic AbstractConvertable(String converterDefinition) {\n+\t\tthis.converterDefinition = converterDefinition;\n+\t}\n+\n+\t@Override\n+\tpublic String getConverterDefinition() {\n+\t\treturn converterDefinition;\n+\t}\n+}\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/impl\/AbstractConvertable.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -69,0 +69,1 @@\n+import org.openjdk.jmc.agent.Agent;\n@@ -190,1 +191,1 @@\n-\t\t\tSystem.err.println(\"Encountered probe without associated class! Check probe definitions!\"); \/\/$NON-NLS-1$\n+\t\t\tAgent.getLogger().warning(\"Encountered probe without associated class! Check probe definitions!\"); \/\/$NON-NLS-1$\n@@ -194,1 +195,1 @@\n-\t\t\tSystem.err.println(\"Encountered probe without associated id! Check probe definitions!\"); \/\/$NON-NLS-1$\n+\t\t\tAgent.getLogger().warning(\"Encountered probe without associated id! Check probe definitions!\"); \/\/$NON-NLS-1$\n@@ -204,2 +205,2 @@\n-\t\t\t\t\tSystem.err.println(\"Encountered probe with an event class name that already exists. \"\n-\t\t\t\t\t\t\t+ \"Check probe definitions!\"); \/\/$NON-NLS-1$\n+\t\t\t\t\tAgent.getLogger().warning(\"Encountered probe with an event class name that already exists: \"\n+\t\t\t\t\t\t\t+ tdEventClassName + \"Check probe definitions!\"); \/\/$NON-NLS-1$\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/impl\/DefaultTransformRegistry.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.agent.impl;\n+\n+public final class MalformedConverterException extends Exception {\n+\tprivate static final long serialVersionUID = 1L;\n+\n+\tpublic MalformedConverterException(String message) {\n+\t\tsuper(message);\n+\t}\n+\n+\tpublic MalformedConverterException(Throwable t) {\n+\t\tsuper(t);\n+\t}\n+\n+\tpublic MalformedConverterException(String message, Throwable t) {\n+\t\tsuper(message, t);\n+\t}\n+}\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/impl\/MalformedConverterException.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.agent.impl;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Parameter;\n+\n+import org.objectweb.asm.Type;\n+import org.openjdk.jmc.agent.Convertable;\n+\n+public final class ResolvedConvertable extends AbstractConvertable implements Convertable {\n+\tpublic static final String DEFAULT_CONVERTER_METHOD = \"convert\";\n+\tprivate final Method converterMethod;\n+\n+\tpublic ResolvedConvertable(String converterDefinition, Class<?> typeToConvert) throws MalformedConverterException {\n+\t\tsuper(converterDefinition);\n+\t\tif (typeToConvert == null) {\n+\t\t\tthrow new MalformedConverterException(\"Type to convert cannot be null!\");\n+\t\t}\n+\t\tString className = resolveClassName(converterDefinition);\n+\t\tClass<?> tmpClass = null;\n+\t\ttry {\n+\t\t\tif (converterDefinition != null) {\n+\t\t\t\ttmpClass = Class.forName(className);\n+\t\t\t}\n+\t\t} catch (ClassNotFoundException e) {\n+\t\t\tthrow new MalformedConverterException(\"Converter must convert to an existing class!\", e);\n+\t\t}\n+\t\tthis.converterMethod = getConvertMethod(tmpClass, converterDefinition, typeToConvert);\n+\t}\n+\n+\tpublic ResolvedConvertable(String converterDefinition, Type type) throws MalformedConverterException {\n+\t\tthis(converterDefinition, getClassFromType(type));\n+\t}\n+\n+\tpublic Class<?> getConverterClass() {\n+\t\treturn converterMethod.getDeclaringClass();\n+\t}\n+\n+\tpublic Method getConverterMethod() {\n+\t\treturn converterMethod;\n+\t}\n+\n+\tprivate static Method getConvertMethod(Class<?> converterClass, String converterDefinition, Class<?> originalType)\n+\t\t\tthrows MalformedConverterException {\n+\t\tString methodName = resolveMethodName(converterDefinition);\n+\n+\t\tif (converterClass == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tfor (Method m : converterClass.getDeclaredMethods()) {\n+\t\t\tif (methodName.equals(m.getName())) {\n+\t\t\t\tif (!isValidMethod(m)) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tif (parameterIsAssignableType(m.getParameters()[0], originalType)) {\n+\t\t\t\t\treturn m;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tthrow new MalformedConverterException(\"Could not find the convert method to use in \" + converterDefinition\n+\t\t\t\t+ \" to convert \" + originalType.getName());\n+\t}\n+\n+\tprivate static boolean isValidMethod(Method m) {\n+\t\treturn Modifier.isStatic(m.getModifiers())\n+\t\t\t\t&& !(Modifier.isAbstract(m.getModifiers()) || Modifier.isInterface(m.getModifiers()))\n+\t\t\t\t&& m.getParameterCount() == 1;\n+\t}\n+\n+\tprivate static boolean parameterIsAssignableType(Parameter p, Class<?> originalType) {\n+\t\tif (p.getType().isAssignableFrom(originalType)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprivate static String resolveClassName(String converterDefinition) throws MalformedConverterException {\n+\t\tif (!converterDefinition.contains(\"(\")) {\n+\t\t\treturn converterDefinition;\n+\t\t}\n+\t\tint lastDotIndex = converterDefinition.lastIndexOf('.');\n+\t\tif (lastDotIndex == -1) {\n+\t\t\tthrow new MalformedConverterException(\n+\t\t\t\t\t\"Converter with method declaration must contain method: \" + converterDefinition);\n+\t\t}\n+\t\treturn converterDefinition.substring(0, lastDotIndex);\n+\t}\n+\n+\tprivate static String resolveMethodName(String converterDefinition) throws MalformedConverterException {\n+\t\tif (!converterDefinition.contains(\"(\")) {\n+\t\t\treturn DEFAULT_CONVERTER_METHOD;\n+\t\t}\n+\t\tint lastDotIndex = converterDefinition.lastIndexOf('.');\n+\t\tif (lastDotIndex == -1) {\n+\t\t\tthrow new MalformedConverterException(\n+\t\t\t\t\t\"Converter with method declaration must contain method: \" + converterDefinition);\n+\t\t}\n+\t\tint firstParenIndex = converterDefinition.lastIndexOf('(');\n+\t\tif (firstParenIndex < lastDotIndex) {\n+\t\t\tthrow new MalformedConverterException(\"No dots in the formal descriptor allowed: \" + converterDefinition);\n+\t\t}\n+\t\treturn converterDefinition.substring(lastDotIndex + 1, firstParenIndex);\n+\t}\n+\n+\tprivate static Class<?> getClassFromType(Type type) throws MalformedConverterException {\n+\t\ttry {\n+\t\t\treturn Class.forName(type.getClassName());\n+\t\t} catch (ClassNotFoundException e) {\n+\t\t\tthrow new MalformedConverterException(\"The type to transform could not be found\", e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"Resolved \" + getConverterDefinition() + \":\\nClass: \" + getConverterClass() + \"\\nMethod: \"\n+\t\t\t\t+ getConverterMethod();\n+\t}\n+\n+}\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/impl\/ResolvedConvertable.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -46,0 +46,1 @@\n+import org.openjdk.jmc.agent.Convertable;\n@@ -54,5 +55,5 @@\n-\tprivate final static String ATTRIBUTE_EVENT_NAME = \"name\"; \/\/$NON-NLS-1$\n-\tprivate final static String ATTRIBUTE_JFR_EVENT_DESCRIPTION = \"description\"; \/\/$NON-NLS-1$\n-\tprivate final static String ATTRIBUTE_JFR_EVENT_PATH = \"path\"; \/\/$NON-NLS-1$\n-\tprivate final static String ATTRIBUTE_STACK_TRACE = \"stacktrace\"; \/\/$NON-NLS-1$\n-\tprivate final static String ATTRIBUTE_RETHROW = \"rethrow\"; \/\/$NON-NLS-1$\n+\tprivate static final String ATTRIBUTE_EVENT_NAME = \"name\"; \/\/$NON-NLS-1$\n+\tprivate static final String ATTRIBUTE_JFR_EVENT_DESCRIPTION = \"description\"; \/\/$NON-NLS-1$\n+\tprivate static final String ATTRIBUTE_JFR_EVENT_PATH = \"path\"; \/\/$NON-NLS-1$\n+\tprivate static final String ATTRIBUTE_STACK_TRACE = \"stacktrace\"; \/\/$NON-NLS-1$\n+\tprivate static final String ATTRIBUTE_RETHROW = \"rethrow\"; \/\/$NON-NLS-1$\n@@ -233,1 +234,1 @@\n-\tpublic boolean isAllowedFieldType(Type type) {\n+\tpublic boolean isAllowedEventFieldType(Convertable convertable, Type type) {\n@@ -237,0 +238,4 @@\n+\t\t\/\/ FIXME: Add better validation, such as checking the class is available\n+\t\tif (isAllowConverter() && convertable.hasConverter()) {\n+\t\t\treturn true;\n+\t\t}\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfr\/JFRTransformDescriptor.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-\tprivate final static JFRVersion availableJFRVersion;\n+\tprivate static final JFRVersion availableJFRVersion;\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfr\/VersionResolver.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.reflect.Method;\n@@ -47,1 +48,5 @@\n-public class JFRClassVisitor extends ClassVisitor implements Opcodes {\n+\/**\n+ * This class visits a class to be instrumented, discovers methods to be visited and visits them. It\n+ * will also kick off the generation of the event class and register the created event class.\n+ *\/\n+public class JFRClassVisitor extends ClassVisitor {\n@@ -54,2 +59,1 @@\n-\t\t\tClass<?> classBeingRedefined, ProtectionDomain protectionDomain,\n-\t\t\tInspectionClassLoader inspectionClassLoader) {\n+\t\t\tClass<?> classBeingRedefined, ProtectionDomain protectionDomain) {\n@@ -62,0 +66,2 @@\n+\t\t\tInspectionClassLoader inspectionClassLoader = classBeingRedefined != null ? null\n+\t\t\t\t\t: new InspectionClassLoader(definingClassLoader);\n@@ -83,3 +89,2 @@\n-\t\t\tClass<?> c = generateEventClass();\n-\t\t\tAgent.getLogger().log(Level.FINE, \"Generated \" + c);\n-\t\t} catch (Throwable t) {\n+\t\t\treflectiveRegister(generateEventClass());\n+\t\t} catch (Exception e) {\n@@ -87,1 +92,1 @@\n-\t\t\t\t\tt);\n+\t\t\t\t\te);\n@@ -93,1 +98,0 @@\n-\n@@ -97,0 +101,7 @@\n+\t\/\/ NOTE: multi-release jars should let us compile against jdk9 and do a direct call here\n+\tprivate void reflectiveRegister(Class<?> generateEventClass) throws Exception {\n+\t\tClass<?> jfr = Class.forName(\"jdk.jfr.FlightRecorder\"); \/\/$NON-NLS-1$\n+\t\tMethod registerMethod = jfr.getDeclaredMethod(\"register\", Class.class); \/\/$NON-NLS-1$\n+\t\tregisterMethod.invoke(null, generateEventClass);\n+\t}\n+\n@@ -102,1 +113,0 @@\n-\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfr\/impl\/JFRClassVisitor.java","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.logging.Level;\n@@ -44,0 +45,1 @@\n+import org.openjdk.jmc.agent.Agent;\n@@ -45,1 +47,0 @@\n-import org.openjdk.jmc.agent.Field;\n@@ -47,0 +48,1 @@\n+import org.openjdk.jmc.agent.Field;\n@@ -48,0 +50,2 @@\n+import org.openjdk.jmc.agent.impl.MalformedConverterException;\n+import org.openjdk.jmc.agent.impl.ResolvedConvertable;\n@@ -52,0 +56,4 @@\n+\/**\n+ * This class is responsible for generating the JFR event class described by the transform\n+ * descriptor.\n+ *\/\n@@ -53,13 +61,2 @@\n-\tprivate static final String CLASS_NAME_INSTANT_EVENT = \"com\/oracle\/jrockit\/jfr\/InstantEvent\"; \/\/$NON-NLS-1$\n-\tprivate static final String CLASS_NAME_DURATION_EVENT = \"com\/oracle\/jrockit\/jfr\/DurationEvent\"; \/\/$NON-NLS-1$\n-\tprivate static final String CLASS_NAME_TIMED_EVENT = \"com\/oracle\/jrockit\/jfr\/TimedEvent\"; \/\/$NON-NLS-1$\n-\n-\t\/**\n-\t * Generates an event class.\n-\t * \n-\t * @param td\n-\t *            the transform descriptor describing the transform.\n-\t * @return returns the byte code for the generated class.\n-\t * @throws Exception\n-\t *             if the event class could not be generated.\n-\t *\/\n+\tprivate static final String CLASS_EVENT = \"jdk\/jfr\/Event\"; \/\/$NON-NLS-1$\n+\n@@ -68,3 +65,2 @@\n-\t\t\/\/ TODO: Add support for different locations\n-\t\tcw.visit(Opcodes.V1_7, Opcodes.ACC_PUBLIC + Opcodes.ACC_SUPER, td.getEventClassName(), null,\n-\t\t\t\tgetEventTypeName(JFREventType.TIMED), null);\n+\t\t\/\/ FIXME: Perhaps switch to Opcodes V9 when there is one.\n+\t\tcw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC + Opcodes.ACC_SUPER, td.getEventClassName(), null, CLASS_EVENT, null);\n@@ -76,1 +72,0 @@\n-\t\tgenerateTokenField(cw);\n@@ -78,1 +73,0 @@\n-\t\tgenerateClinit(cw, td.getEventClassName(), parameterizedClassName);\n@@ -81,1 +75,0 @@\n-\n@@ -101,1 +94,1 @@\n-\t\tif (!td.isAllowedFieldType(type)) {\n+\t\tif (!td.isAllowedEventFieldType(attribute, type)) {\n@@ -103,1 +96,1 @@\n-\t\t\t\t\t.warning(\"Skipped generating field in event class for parameter \" + attribute + \" and type \" + type \/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n+\t\t\t\t\t.warning(\"Skipped generating field in event class for attribute \" + attribute + \" and type \" + type \/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n@@ -108,1 +101,1 @@\n-\t\tString fieldType = getFieldType(type);\n+\t\tString fieldType = null;\n@@ -110,13 +103,15 @@\n-\t\tFieldVisitor fv = cw.visitField(Opcodes.ACC_PUBLIC, attribute.getFieldName(), fieldType, null, null);\n-\t\tAnnotationVisitor av = fv.visitAnnotation(\"Lcom\/oracle\/jrockit\/jfr\/ValueDefinition;\", true); \/\/$NON-NLS-1$\n-\t\tif (attribute.getName() != null) {\n-\t\t\tav.visit(\"name\", attribute.getName()); \/\/$NON-NLS-1$\n-\t\t}\n-\t\tif (attribute.getDescription() != null) {\n-\t\t\tav.visit(\"description\", attribute.getDescription()); \/\/$NON-NLS-1$\n-\t\t}\n-\t\tif (attribute.getContentType() != null) {\n-\t\t\tav.visitEnum(\"contentType\", \"Lcom\/oracle\/jrockit\/jfr\/ContentType;\", attribute.getContentType()); \/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n-\t\t}\n-\t\tif (attribute.getRelationKey() != null) {\n-\t\t\tav.visit(\"relationKey\", attribute.getRelationKey()); \/\/$NON-NLS-1$\n+\t\tif (attribute.hasConverter()) {\n+\t\t\tResolvedConvertable resolved;\n+\t\t\ttry {\n+\t\t\t\tresolved = new ResolvedConvertable(attribute.getConverterDefinition(), type);\n+\t\t\t\tfieldType = getFieldType(Type.getType(resolved.getConverterMethod().getReturnType()));\n+\t\t\t} catch (MalformedConverterException e) {\n+\t\t\t\tAgent.getLogger()\n+\t\t\t\t\t\t.log(Level.SEVERE,\n+\t\t\t\t\t\t\t\t\"Failed to load specified converter class \" + attribute.getConverterDefinition()\n+\t\t\t\t\t\t\t\t\t\t+ \" - will not use that converter! Skipped generating field in event class.\",\n+\t\t\t\t\t\t\t\te);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfieldType = getFieldType(type);\n@@ -124,0 +119,6 @@\n+\n+\t\tFieldVisitor fv = cw.visitField(Opcodes.ACC_PROTECTED, attribute.getFieldName(), fieldType, null, null);\n+\n+\t\t\/\/ Name\n+\t\tAnnotationVisitor av = fv.visitAnnotation(\"Ljdk\/jfr\/Label;\", true);\n+\t\tav.visit(\"value\", attribute.getName());\n@@ -125,0 +126,20 @@\n+\n+\t\t\/\/ Description\n+\t\tav = fv.visitAnnotation(\"Ljdk\/jfr\/Description;\", true);\n+\t\tav.visit(\"value\", attribute.getDescription());\n+\t\tav.visitEnd();\n+\n+\t\t\/\/ \"ContentType\"\n+\t\t\/\/ We support the old JDK 7 style content types transparently.\n+\t\t\/\/ We also support user defined content types and a single string value annotation parameter to the annotation.\n+\t\tString contentTypeAnnotation = getContentTypeAnnotation(attribute.getContentType());\n+\t\tif (contentTypeAnnotation != null) {\n+\t\t\tString[] contentTypeAnnotationInfo = contentTypeAnnotation.split(\";\");\n+\t\t\tav = fv.visitAnnotation(contentTypeAnnotationInfo[0] + \";\", true);\n+\t\t\tif (contentTypeAnnotationInfo.length > 1) {\n+\t\t\t\tav.visit(\"value\", contentTypeAnnotationInfo[1]);\n+\t\t\t}\n+\t\t\tav.visitEnd();\n+\t\t}\n+\n+\t\t\/\/ FIXME: RelKey\n@@ -130,1 +151,1 @@\n-\t\tif (!td.isAllowedFieldType(type)) {\n+\t\tif (!td.isAllowedEventFieldType(returnValue, type)) {\n@@ -139,4 +160,23 @@\n-\t\tFieldVisitor fv = cw.visitField(Opcodes.ACC_PUBLIC, returnValue.getFieldName(), fieldType, null, null);\n-\t\tAnnotationVisitor av = fv.visitAnnotation(\"Lcom\/oracle\/jrockit\/jfr\/ValueDefinition;\", true); \/\/$NON-NLS-1$\n-\t\tif (returnValue.getName() != null) {\n-\t\t\tav.visit(\"name\", returnValue.getName()); \/\/$NON-NLS-1$\n+\t\tFieldVisitor fv = cw.visitField(Opcodes.ACC_PROTECTED, returnValue.getFieldName(), fieldType, null, null);\n+\n+\t\t\/\/ Name\n+\t\tAnnotationVisitor av = fv.visitAnnotation(\"Ljdk\/jfr\/Label;\", true);\n+\t\tav.visit(\"value\", returnValue.getName());\n+\t\tav.visitEnd();\n+\n+\t\t\/\/ Description\n+\t\tav = fv.visitAnnotation(\"Ljdk\/jfr\/Description;\", true);\n+\t\tav.visit(\"value\", returnValue.getDescription());\n+\t\tav.visitEnd();\n+\n+\t\t\/\/ \"ContentType\"\n+\t\t\/\/ We support the old JDK 7 style content types transparently.\n+\t\t\/\/ We also support user defined content types and a single string value annotation parameter to the annotation.\n+\t\tString contentTypeAnnotation = getContentTypeAnnotation(returnValue.getContentType());\n+\t\tif (contentTypeAnnotation != null) {\n+\t\t\tString[] contentTypeAnnotationInfo = contentTypeAnnotation.split(\";\");\n+\t\t\tav = fv.visitAnnotation(contentTypeAnnotationInfo[0] + \";\", true);\n+\t\t\tif (contentTypeAnnotationInfo.length > 1) {\n+\t\t\t\tav.visit(\"value\", contentTypeAnnotationInfo[1]);\n+\t\t\t}\n+\t\t\tav.visitEnd();\n@@ -144,2 +184,8 @@\n-\t\tif (returnValue.getDescription() != null) {\n-\t\t\tav.visit(\"description\", returnValue.getDescription()); \/\/$NON-NLS-1$\n+\n+\t\t\/\/ FIXME: RelKey\n+\t\tfv.visitEnd();\n+\t}\n+\n+\tprivate static String getContentTypeAnnotation(String contentType) {\n+\t\tif (contentType == null) {\n+\t\t\treturn null;\n@@ -147,2 +193,27 @@\n-\t\tif (returnValue.getContentType() != null) {\n-\t\t\tav.visitEnum(\"contentType\", \"Lcom\/oracle\/jrockit\/jfr\/ContentType;\", returnValue.getContentType()); \/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n+\t\tswitch (contentType) {\n+\t\tcase \"None\":\n+\t\t\treturn null;\n+\t\tcase \"Address\":\n+\t\t\treturn \"Ljdk\/jfr\/MemoryAddress;\";\n+\t\tcase \"Bytes\":\n+\t\t\treturn \"Ljdk\/jfr\/DataAmount;\";\n+\t\tcase \"Timestamp\":\n+\t\t\treturn \"Ljdk\/jfr\/Timestamp;\";\n+\t\tcase \"Millis\":\n+\t\t\treturn \"Ljdk\/jfr\/Timespan;\" + \"MILLISECONDS\";\n+\t\tcase \"Nanos\":\n+\t\t\treturn \"Ljdk\/jfr\/Timespan;\" + \"NANOSECONDS\";\n+\t\tcase \"Ticks\":\n+\t\t\treturn \"Ljdk\/jfr\/Timespan;\" + \"TICKS\";\n+\t\tcase \"Percentage\":\n+\t\t\treturn \"Ljdk\/jfr\/Percentage;\";\n+\n+\t\tdefault:\n+\t\t\tif (contentType.startsWith(\"L\") && contentType.endsWith(\";\")) {\n+\t\t\t\tAgent.getLogger()\n+\t\t\t\t\t\t.fine(\"Using user defined content type. Note that this only works with JDK 9 and later!\");\n+\t\t\t\treturn contentType;\n+\t\t\t}\n+\t\t\tAgent.getLogger().severe(\"Unsupported content type \" + contentType\n+\t\t\t\t\t+ \". Either use a JDK 7\/8 content type, or specify the class of the annotation specifying the content type, e.g. Ljdk\/jfr\/DataAmount;. If specifying the content type annotation explicitly, it will only work on JDK 9 or later.\");\n+\t\t\treturn null;\n@@ -150,2 +221,0 @@\n-\t\tav.visitEnd();\n-\t\tfv.visitEnd();\n@@ -158,1 +227,0 @@\n-\n@@ -162,0 +230,7 @@\n+\t\/*\n+\t * In JDK 9 the event types do not really need to be registered. There are also no tokens to\n+\t * track to optimize lookup. So no need for a clinit.\n+\t *\n+\t * That said, once the class has been defined, we will still register it, to make sure that the\n+\t * metadata is visible to all consumers, even though no event has been emitted.\n+\t *\/\n@@ -163,1 +238,1 @@\n-\t\tMethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \"<init>\", \"()V\", null, null); \/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n+\t\tMethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n@@ -167,1 +242,0 @@\n-\t\tmv.visitLineNumber(19, l0);\n@@ -169,3 +243,2 @@\n-\t\tmv.visitFieldInsn(Opcodes.GETSTATIC, className, \"token\", \"Lcom\/oracle\/jrockit\/jfr\/EventToken;\"); \/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n-\t\tmv.visitMethodInsn(Opcodes.INVOKESPECIAL, CLASS_NAME_TIMED_EVENT, \"<init>\", \/\/$NON-NLS-1$\n-\t\t\t\t\"(Lcom\/oracle\/jrockit\/jfr\/EventToken;)V\", false); \/\/$NON-NLS-1$\n+\t\tmv.visitMethodInsn(Opcodes.INVOKESPECIAL, \"jdk\/jfr\/Event\", \"<init>\", \"()V\", false);\n+\t\tmv.visitInsn(Opcodes.RETURN);\n@@ -174,19 +247,2 @@\n-\t\tmv.visitLineNumber(20, l1);\n-\t\tmv.visitInsn(Opcodes.RETURN);\n-\t\tLabel l2 = new Label();\n-\t\tmv.visitLabel(l2);\n-\t\tmv.visitLocalVariable(\"this\", parameterizedClassName, null, l0, l2, 0); \/\/$NON-NLS-1$\n-\t\tmv.visitMaxs(2, 1);\n-\t\tmv.visitEnd();\n-\t}\n-\n-\tprivate static void generateClinit(ClassWriter cw, String className, String parameterizedClassName) {\n-\t\tMethodVisitor mv = cw.visitMethod(Opcodes.ACC_STATIC, \"<clinit>\", \"()V\", null, null); \/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n-\t\tmv.visitCode();\n-\t\tmv.visitLdcInsn(Type.getType(parameterizedClassName));\n-\t\tmv.visitMethodInsn(Opcodes.INVOKESTATIC, JFRUtils.INAME, \"register\", \/\/$NON-NLS-1$\n-\t\t\t\t\"(Ljava\/lang\/Class;)Ljava\/lang\/Object;\", false); \/\/$NON-NLS-1$\n-\t\tmv.visitTypeInsn(Opcodes.CHECKCAST, \"com\/oracle\/jrockit\/jfr\/EventToken\");\n-\t\tmv.visitFieldInsn(Opcodes.PUTSTATIC, className, \"token\", \"Lcom\/oracle\/jrockit\/jfr\/EventToken;\"); \/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n-\t\tmv.visitInsn(Opcodes.RETURN);\n-\t\tmv.visitMaxs(1, 0);\n+\t\tmv.visitLocalVariable(\"this\", parameterizedClassName, null, l0, l1, 0);\n+\t\tmv.visitMaxs(1, 1);\n@@ -196,6 +252,0 @@\n-\tprivate static void generateTokenField(ClassWriter cw) {\n-\t\tFieldVisitor fv = cw.visitField(Opcodes.ACC_FINAL + Opcodes.ACC_STATIC, \"token\", \/\/$NON-NLS-1$\n-\t\t\t\t\"Lcom\/oracle\/jrockit\/jfr\/EventToken;\", null, null); \/\/$NON-NLS-1$\n-\t\tfv.visitEnd();\n-\t}\n-\n@@ -203,8 +253,4 @@\n-\t\tAnnotationVisitor av0 = cw.visitAnnotation(\"Lcom\/oracle\/jrockit\/jfr\/EventDefinition;\", true); \/\/$NON-NLS-1$\n-\t\tav0.visit(\"name\", td.getEventName()); \/\/$NON-NLS-1$\n-\t\tav0.visit(\"description\", td.getEventDescription()); \/\/$NON-NLS-1$\n-\t\tav0.visit(\"path\", td.getEventPath()); \/\/$NON-NLS-1$\n-\t\tav0.visit(\"stacktrace\", td.isRecordStackTrace()); \/\/$NON-NLS-1$\n-\t\tav0.visit(\"thread\", true); \/\/$NON-NLS-1$\n-\t\tav0.visitEnd();\n-\t}\n+\t\t\/\/ Label\n+\t\tAnnotationVisitor av = cw.visitAnnotation(\"Ljdk\/jfr\/Label;\", true);\n+\t\tav.visit(\"value\", td.getEventName());\n+\t\tav.visitEnd();\n@@ -212,9 +258,11 @@\n-\tprivate static String getEventTypeName(JFREventType eventType) {\n-\t\tswitch (eventType) {\n-\t\tcase DURATION:\n-\t\t\treturn CLASS_NAME_DURATION_EVENT;\n-\t\tcase TIMED:\n-\t\t\treturn CLASS_NAME_TIMED_EVENT;\n-\t\tcase INSTANT:\n-\t\t\treturn CLASS_NAME_INSTANT_EVENT;\n-\t\tcase UNDEFINED:\n+\t\t\/\/ Description\n+\t\tav = cw.visitAnnotation(\"Ljdk\/jfr\/Description;\", true);\n+\t\tav.visit(\"value\", td.getEventDescription());\n+\t\tav.visitEnd();\n+\n+\t\t\/\/ Category (path)\n+\t\tString[] pathElements = td.getEventPath().split(\"\/\");\n+\t\tav = cw.visitAnnotation(\"Ljdk\/jfr\/Category;\", true);\n+\t\tAnnotationVisitor arrayVisitor = av.visitArray(\"value\");\n+\t\tfor (String pathElement : pathElements) {\n+\t\t\tarrayVisitor.visit(null, pathElement);\n@@ -222,1 +270,9 @@\n-\t\treturn CLASS_NAME_TIMED_EVENT;\n+\t\tarrayVisitor.visitEnd();\n+\t\tav.visitEnd();\n+\n+\t\t\/\/ Stacktrace on\/off\n+\t\tav = cw.visitAnnotation(\"Ljdk\/jfr\/StackTrace;\", true);\n+\t\tav.visit(\"value\", td.isRecordStackTrace());\n+\t\tav.visitEnd();\n+\n+\t\t\/\/ Note that thread is always recorded these days\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfr\/impl\/JFREventClassGenerator.java","additions":152,"deletions":96,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -35,0 +35,4 @@\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n@@ -44,0 +48,2 @@\n+import org.openjdk.jmc.agent.impl.MalformedConverterException;\n+import org.openjdk.jmc.agent.impl.ResolvedConvertable;\n@@ -50,4 +56,0 @@\n-import java.lang.reflect.Modifier;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n@@ -55,1 +57,2 @@\n- * Code emitter for JFR distributed with pre-JDK 9 releases. Probably works with JRockit too. ;)\n+ * This class is responsible for transforming the method to be instrumented. Code emitter for JFR\n+ * next, i.e. the version of JFR distributed with JDK 9 and later.\n@@ -69,0 +72,1 @@\n+\tprivate Label catchBegin = new Label();\n@@ -82,1 +86,1 @@\n-\t\tthis.shouldInstrumentThrow = !transformDescriptor.isUseRethrow(); \/\/ don't instrument inner throws if rethrow is enabled\n+\t\tthis.shouldInstrumentThrow = !transformDescriptor.isUseRethrow() || !transformDescriptor.isEmitOnException(); \/\/ don't instrument inner throws if rethrow is enabled\n@@ -89,1 +93,1 @@\n-\t\tif (transformDescriptor.isUseRethrow()) {\n+\t\tif (transformDescriptor.isUseRethrow() || transformDescriptor.isEmitOnException()) {\n@@ -96,1 +100,1 @@\n-\t\tif (transformDescriptor.isUseRethrow()) {\n+\t\tif (transformDescriptor.isUseRethrow() && !transformDescriptor.isEmitOnException()) {\n@@ -105,0 +109,11 @@\n+\t\t} else if (transformDescriptor.isEmitOnException()) {\n+\t\t\tvisitLabel(tryEnd);\n+\t\t\tvisitTryCatchBlock(tryBegin, tryEnd, catchBegin, THROWABLE_BINARY_NAME);\n+\t\t\tif (!transformDescriptor.isUseRethrow()) {\n+\t\t\t\tvisitFrame(Opcodes.F_NEW, 0, null, 1, new Object[] {THROWABLE_BINARY_NAME});\n+\t\t\t\tvisitInsn(RETURN);\n+\t\t\t} else {\n+\t\t\t\tvisitFrame(Opcodes.F_NEW, 0, null, 1, new Object[] {THROWABLE_BINARY_NAME});\n+\t\t\t\tshouldInstrumentThrow = true;\n+\t\t\t\tvisitInsn(ATHROW);\n+\t\t\t}\n@@ -106,1 +121,0 @@\n-\n@@ -114,1 +128,1 @@\n-\t\t} catch (IllegalSyntaxException e) {\n+\t\t} catch (Exception e) {\n@@ -119,1 +133,1 @@\n-\tprivate void createEvent() throws IllegalSyntaxException {\n+\tprivate void createEvent() throws IllegalSyntaxException, MalformedConverterException {\n@@ -126,1 +140,2 @@\n-\t\t\tif (transformDescriptor.isAllowedFieldType(argumentType)) {\n+\t\t\tif (transformDescriptor.isAllowedEventFieldType(param, argumentType)) {\n+\t\t\t\t\/\/ Top of the stack is the event instance object reference.\n@@ -129,0 +144,8 @@\n+\t\t\t\tif (param.hasConverter()) {\n+\t\t\t\t\targumentType = convertify(mv, param, argumentType);\n+\t\t\t\t} else {\n+\t\t\t\t\tif (TypeUtils.shouldStringify(param, argumentType)) {\n+\t\t\t\t\t\tTypeUtils.stringify(mv);\n+\t\t\t\t\t\targumentType = TypeUtils.STRING_TYPE;\n+\t\t\t\t\t}\n+\t\t\t\t}\n@@ -141,1 +164,1 @@\n-\t\t\tif (transformDescriptor.isAllowedFieldType(refChain.getType())) {\n+\t\t\tif (transformDescriptor.isAllowedEventFieldType(field, refChain.getType())) {\n@@ -224,4 +247,0 @@\n-\t\tif (TypeUtils.shouldStringify(type)) {\n-\t\t\tTypeUtils.stringify(mv);\n-\t\t\ttype = TypeUtils.STRING_TYPE;\n-\t\t}\n@@ -231,0 +250,8 @@\n+\tprivate Type convertify(MethodVisitor mv, Attribute convertable, Type type) throws MalformedConverterException {\n+\t\tResolvedConvertable resolvedConvertable = new ResolvedConvertable(convertable.getConverterDefinition(), type);\n+\t\tmv.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(resolvedConvertable.getConverterClass()),\n+\t\t\t\tresolvedConvertable.getConverterMethod().getName(),\n+\t\t\t\tType.getMethodDescriptor(resolvedConvertable.getConverterMethod()), false);\n+\t\treturn Type.getType(resolvedConvertable.getConverterMethod().getReturnType());\n+\t}\n+\n@@ -233,0 +260,3 @@\n+\t\tif (transformDescriptor.isEmitOnException()) {\n+\t\t\tvisitLabel(catchBegin);\n+\t\t}\n@@ -236,1 +266,0 @@\n-\n@@ -262,2 +291,0 @@\n-\t\tmv.visitInsn(DUP);\n-\t\tmv.visitMethodInsn(INVOKEVIRTUAL, transformDescriptor.getEventClassName(), \"end\", \"()V\", false); \/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfr\/impl\/JFRMethodAdvisor.java","additions":47,"deletions":20,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -1,101 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * \n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * The contents of this file are subject to the terms of either the Universal Permissive License\n- * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n- *\n- * or the following license:\n- *\n- * Redistribution and use in source and binary forms, with or without modification, are permitted\n- * provided that the following conditions are met:\n- * \n- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n- * and the following disclaimer.\n- * \n- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n- * conditions and the following disclaimer in the documentation and\/or other materials provided with\n- * the distribution.\n- * \n- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n- * endorse or promote products derived from this software without specific prior written permission.\n- * \n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n- * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-package org.openjdk.jmc.agent.jfr.impl;\n-\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Method;\n-import java.net.URI;\n-import java.util.logging.Level;\n-import java.util.logging.Logger;\n-\n-import org.objectweb.asm.Type;\n-\n-\/**\n- * Utility class to support JDK 7 and JDK 8 style JFR.\n- *\/\n-@SuppressWarnings(\"deprecation\")\n-public class JFRUtils {\n-\tpublic final static String INAME = Type.getInternalName(JFRUtils.class);\n-\tpublic final static Object PRODUCER;\n-\tpublic final static Method REGISTER_METHOD;\n-\n-\tstatic {\n-\t\tURI producerURI = URI.create(\"http:\/\/jmc.openjdk.org\/jfragent\/\"); \/\/$NON-NLS-1$\n-\t\tPRODUCER = createProducerReflectively(\"JMC Dynamic JFR Producer\",\n-\t\t\t\t\"A byte code instrumentation based JFR event producer.\", producerURI);\n-\t\tREGISTER_METHOD = getRegisterMethod(PRODUCER.getClass());\n-\t}\n-\n-\tpublic static Object register(Class<?> clazz) {\n-\t\ttry {\n-\t\t\tif (REGISTER_METHOD != null) {\n-\t\t\t\treturn REGISTER_METHOD.invoke(PRODUCER, clazz);\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\tLogger.getLogger(JFRUtils.class.getName()).log(Level.SEVERE,\n-\t\t\t\t\t\"Failed to register the event class \" + clazz.getName() \/\/$NON-NLS-1$\n-\t\t\t\t\t\t\t+ \". Event will not be available. Please check your configuration.\", \/\/$NON-NLS-1$\n-\t\t\t\t\te);\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tprivate static Method getRegisterMethod(Class<?> producerClass) {\n-\t\ttry {\n-\t\t\treturn producerClass.getDeclaredMethod(\"addEvent\", Class.class);\n-\t\t} catch (NoSuchMethodException | SecurityException e) {\n-\t\t\t\/\/ This should never happen\n-\t\t\tSystem.err.println(\"Failed to find the addEvent method of the producer.\");\n-\t\t\tSystem.err.println(\"No BCI generated JFR events will be available.\");\n-\t\t\te.printStackTrace();\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tprivate static Object createProducerReflectively(String name, String description, URI producerURI) {\n-\t\ttry {\n-\t\t\tClass<?> producerClass = Class.forName(\"com.oracle.jrockit.jfr.Producer\");\n-\t\t\tConstructor<?> constructor = producerClass.getConstructor(String.class, String.class, String.class);\n-\t\t\tObject producer = constructor.newInstance(name, description, producerURI.toString());\n-\t\t\tMethod registerMethod = producerClass.getDeclaredMethod(\"register\");\n-\t\t\tregisterMethod.invoke(producer);\n-\t\t\treturn producer;\n-\t\t} catch (Exception e) {\n-\t\t\tSystem.err.println(\n-\t\t\t\t\t\"Failed to create producer for Oracle JDK7\/8 JVM. Ensure that the JVM was started with -XX:+UnlockCommercialFeatures and -XX:+FlightRecorder.\");\n-\t\t\tSystem.err.println(\"No BCI generated JFR events will be available.\");\n-\t\t\te.printStackTrace();\n-\t\t}\n-\t\treturn null;\n-\t}\n-}\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfr\/impl\/JFRUtils.java","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.agent.jfr.impl;\n+\n+\/**\n+ * This package contains classes related to adding JFR events for more recent versions of JFR\n+ * (Oracle JDK 9 and above, OpenJDK 8 and above).\n+ *\/\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfr\/impl\/package-info.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.agent.jfrlegacy.impl;\n+\n+import java.security.ProtectionDomain;\n+import java.util.logging.Level;\n+\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+import org.openjdk.jmc.agent.Agent;\n+import org.openjdk.jmc.agent.jfr.JFRTransformDescriptor;\n+import org.openjdk.jmc.agent.util.InspectionClassLoader;\n+import org.openjdk.jmc.agent.util.TypeUtils;\n+\n+public class JFRLegacyClassVisitor extends ClassVisitor implements Opcodes {\n+\tprivate final JFRTransformDescriptor transformDescriptor;\n+\tprivate final ClassLoader definingClassLoader;\n+\tprivate final Class<?> inspectionClass;\n+\tprivate final ProtectionDomain protectionDomain;\n+\n+\tpublic JFRLegacyClassVisitor(ClassWriter cv, JFRTransformDescriptor descriptor, ClassLoader definingLoader,\n+\t\t\tClass<?> classBeingRedefined, ProtectionDomain protectionDomain) {\n+\t\tsuper(Opcodes.ASM8, cv);\n+\t\tthis.transformDescriptor = descriptor;\n+\t\tthis.definingClassLoader = definingLoader;\n+\t\tthis.protectionDomain = protectionDomain;\n+\n+\t\ttry {\n+\t\t\tInspectionClassLoader inspectionClassLoader = classBeingRedefined != null ? null\n+\t\t\t\t\t: new InspectionClassLoader(definingClassLoader);\n+\t\t\tthis.inspectionClass = classBeingRedefined != null || descriptor.getFields().isEmpty() ? classBeingRedefined\n+\t\t\t\t\t: inspectionClassLoader.loadClass(TypeUtils.getCanonicalName(transformDescriptor.getClassName()));\n+\t\t} catch (ClassNotFoundException e) {\n+\t\t\tthrow new IllegalStateException(e); \/\/ This should not happen\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\t\tMethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+\t\tif (name.equals(transformDescriptor.getMethod().getName())\n+\t\t\t\t&& desc.equals(transformDescriptor.getMethod().getSignature())) {\n+\t\t\ttransformDescriptor.matchFound(true);\n+\t\t\treturn new JFRLegacyMethodAdvisor(transformDescriptor, inspectionClass, Opcodes.ASM8, mv, access, name,\n+\t\t\t\t\tdesc);\n+\t\t}\n+\t\treturn mv;\n+\t}\n+\n+\t@Override\n+\tpublic void visitEnd() {\n+\t\ttry {\n+\t\t\tClass<?> c = generateEventClass();\n+\t\t\tAgent.getLogger().log(Level.FINE, \"Generated \" + c);\n+\t\t} catch (Throwable t) {\n+\t\t\tAgent.getLogger().log(Level.SEVERE, \"Failed to generate event class for \" + transformDescriptor.toString(), \/\/$NON-NLS-1$\n+\t\t\t\t\tt);\n+\t\t}\n+\t\tif (!transformDescriptor.isMatchFound()) {\n+\t\t\tAgent.getLogger().warning(\"Method \" + transformDescriptor.getMethod().getName() + \" \"\n+\t\t\t\t\t+ transformDescriptor.getMethod().getSignature() + \" not found.\"); \/\/ $NON-NLS-1$\n+\t\t}\n+\n+\t\tsuper.visitEnd();\n+\t}\n+\n+\tprivate Class<?> generateEventClass() throws Exception {\n+\t\tbyte[] eventClass = JFRLegacyEventClassGenerator.generateEventClass(transformDescriptor, inspectionClass);\n+\t\treturn TypeUtils.defineClass(transformDescriptor.getEventClassName(), eventClass, 0, eventClass.length,\n+\t\t\t\tdefiningClassLoader, protectionDomain);\n+\t}\n+\n+}\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfrlegacy\/impl\/JFRLegacyClassVisitor.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -33,1 +33,1 @@\n-package org.openjdk.jmc.agent.jfr.impl;\n+package org.openjdk.jmc.agent.jfrlegacy.impl;\n@@ -52,1 +52,1 @@\n-public class JFREventClassGenerator {\n+public class JFRLegacyEventClassGenerator {\n@@ -70,1 +70,1 @@\n-\t\t\t\tgetEventTypeName(JFREventType.TIMED), null);\n+\t\t\t\tgetEventTypeName(JFRLegacyEventType.TIMED), null);\n@@ -101,2 +101,2 @@\n-\t\tif (!td.isAllowedFieldType(type)) {\n-\t\t\tLogger.getLogger(JFREventClassGenerator.class.getName())\n+\t\tif (!td.isAllowedEventFieldType(attribute, type)) {\n+\t\t\tLogger.getLogger(JFRLegacyEventClassGenerator.class.getName())\n@@ -130,2 +130,2 @@\n-\t\tif (!td.isAllowedFieldType(type)) {\n-\t\t\tLogger.getLogger(JFREventClassGenerator.class.getName())\n+\t\tif (!td.isAllowedEventFieldType(returnValue, type)) {\n+\t\t\tLogger.getLogger(JFRLegacyEventClassGenerator.class.getName())\n@@ -212,1 +212,1 @@\n-\tprivate static String getEventTypeName(JFREventType eventType) {\n+\tprivate static String getEventTypeName(JFRLegacyEventType eventType) {\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfrlegacy\/impl\/JFRLegacyEventClassGenerator.java","additions":8,"deletions":8,"binary":false,"changes":16,"previous_filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfr\/impl\/JFREventClassGenerator.java","status":"copied"},{"patch":"@@ -33,1 +33,1 @@\n-package org.openjdk.jmc.agent.jfr.impl;\n+package org.openjdk.jmc.agent.jfrlegacy.impl;\n@@ -35,1 +35,1 @@\n-public enum JFREventType {\n+public enum JFRLegacyEventType {\n@@ -38,1 +38,1 @@\n-\tpublic static JFREventType parse(String string) {\n+\tpublic static JFRLegacyEventType parse(String string) {\n@@ -42,1 +42,1 @@\n-\t\tJFREventType et = JFREventType.valueOf(string.toUpperCase().trim());\n+\t\tJFRLegacyEventType et = JFRLegacyEventType.valueOf(string.toUpperCase().trim());\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfrlegacy\/impl\/JFRLegacyEventType.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfr\/impl\/JFREventType.java","status":"renamed"},{"patch":"@@ -33,1 +33,1 @@\n-package org.openjdk.jmc.agent.jfr.impl;\n+package org.openjdk.jmc.agent.jfrlegacy.impl;\n@@ -57,1 +57,1 @@\n-public class JFRMethodAdvisor extends AdviceAdapter {\n+public class JFRLegacyMethodAdvisor extends AdviceAdapter {\n@@ -72,1 +72,1 @@\n-\tprotected JFRMethodAdvisor(JFRTransformDescriptor transformDescriptor, Class<?> inspectionClass, int api,\n+\tprotected JFRLegacyMethodAdvisor(JFRTransformDescriptor transformDescriptor, Class<?> inspectionClass, int api,\n@@ -126,1 +126,1 @@\n-\t\t\tif (transformDescriptor.isAllowedFieldType(argumentType)) {\n+\t\t\tif (transformDescriptor.isAllowedEventFieldType(param, argumentType)) {\n@@ -141,1 +141,1 @@\n-\t\t\tif (transformDescriptor.isAllowedFieldType(refChain.getType())) {\n+\t\t\tif (transformDescriptor.isAllowedEventFieldType(field, refChain.getType())) {\n@@ -224,1 +224,1 @@\n-\t\tif (TypeUtils.shouldStringify(type)) {\n+\t\tif (TypeUtils.shouldStringify(param, type)) {\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfrlegacy\/impl\/JFRLegacyMethodAdvisor.java","additions":6,"deletions":6,"binary":false,"changes":12,"previous_filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfr\/impl\/JFRMethodAdvisor.java","status":"copied"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.agent.jfrlegacy.impl;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import org.objectweb.asm.Type;\n+import org.openjdk.jmc.agent.Agent;\n+\n+\/**\n+ * Utility class to support Oracle JDK 7 and JDK 8 style JFR.\n+ *\/\n+@SuppressWarnings(\"deprecation\")\n+public class JFRUtils {\n+\tpublic static final String INAME = Type.getInternalName(JFRUtils.class);\n+\tpublic static final Object PRODUCER;\n+\tpublic static final Method REGISTER_METHOD;\n+\n+\tstatic {\n+\t\tURI producerURI = URI.create(\"http:\/\/jmc.openjdk.org\/jfragent\/\"); \/\/$NON-NLS-1$\n+\t\tPRODUCER = createProducerReflectively(\"JMC Dynamic JFR Producer\",\n+\t\t\t\t\"A byte code instrumentation based JFR event producer.\", producerURI);\n+\t\tREGISTER_METHOD = getRegisterMethod(PRODUCER.getClass());\n+\t}\n+\n+\tpublic static Object register(Class<?> clazz) {\n+\t\ttry {\n+\t\t\tif (REGISTER_METHOD != null) {\n+\t\t\t\treturn REGISTER_METHOD.invoke(PRODUCER, clazz);\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tLogger.getLogger(JFRUtils.class.getName()).log(Level.SEVERE,\n+\t\t\t\t\t\"Failed to register the event class \" + clazz.getName() \/\/$NON-NLS-1$\n+\t\t\t\t\t\t\t+ \". Event will not be available. Please check your configuration.\", \/\/$NON-NLS-1$\n+\t\t\t\t\te);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprivate static Method getRegisterMethod(Class<?> producerClass) {\n+\t\ttry {\n+\t\t\treturn producerClass.getDeclaredMethod(\"addEvent\", Class.class);\n+\t\t} catch (NoSuchMethodException | SecurityException e) {\n+\t\t\t\/\/ This should never happen\n+\t\t\tAgent.getLogger().severe(\"Failed to find the addEvent method of the producer.\");\n+\t\t\tAgent.getLogger().severe(\"No BCI generated JFR events will be available.\");\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprivate static Object createProducerReflectively(String name, String description, URI producerURI) {\n+\t\ttry {\n+\t\t\tClass<?> producerClass = Class.forName(\"com.oracle.jrockit.jfr.Producer\");\n+\t\t\tConstructor<?> constructor = producerClass.getConstructor(String.class, String.class, String.class);\n+\t\t\tObject producer = constructor.newInstance(name, description, producerURI.toString());\n+\t\t\tMethod registerMethod = producerClass.getDeclaredMethod(\"register\");\n+\t\t\tregisterMethod.invoke(producer);\n+\t\t\treturn producer;\n+\t\t} catch (Exception e) {\n+\t\t\tAgent.getLogger().severe(\n+\t\t\t\t\t\"Failed to create producer for Oracle JDK7\/8 JVM. Ensure that the JVM was started with -XX:+UnlockCommercialFeatures and -XX:+FlightRecorder.\");\n+\t\t\tAgent.getLogger().severe(\"No BCI generated JFR events will be available.\");\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t\treturn null;\n+\t}\n+}\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfrlegacy\/impl\/JFRUtils.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.agent.jfrlegacy.impl;\n+\n+\/**\n+ * This package contains classes related to adding JFR events for the early versions of JFR in the\n+ * Oracle JDK 7 and the Oracle JDK 8.\n+ *\/\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfrlegacy\/impl\/package-info.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * \n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * The contents of this file are subject to the terms of either the Universal Permissive License\n- * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n- *\n- * or the following license:\n- *\n- * Redistribution and use in source and binary forms, with or without modification, are permitted\n- * provided that the following conditions are met:\n- * \n- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n- * and the following disclaimer.\n- * \n- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n- * conditions and the following disclaimer in the documentation and\/or other materials provided with\n- * the distribution.\n- * \n- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n- * endorse or promote products derived from this software without specific prior written permission.\n- * \n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n- * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-package org.openjdk.jmc.agent.jfrnext.impl;\n-\n-import java.lang.reflect.Method;\n-import java.security.ProtectionDomain;\n-import java.util.logging.Level;\n-\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.MethodVisitor;\n-import org.objectweb.asm.Opcodes;\n-import org.openjdk.jmc.agent.Agent;\n-import org.openjdk.jmc.agent.jfr.JFRTransformDescriptor;\n-import org.openjdk.jmc.agent.util.InspectionClassLoader;\n-import org.openjdk.jmc.agent.util.TypeUtils;\n-\n-public class JFRNextClassVisitor extends ClassVisitor {\n-\tprivate final JFRTransformDescriptor transformDescriptor;\n-\tprivate final ClassLoader definingClassLoader;\n-\tprivate final Class<?> inspectionClass;\n-\tprivate final ProtectionDomain protectionDomain;\n-\n-\tpublic JFRNextClassVisitor(ClassWriter cv, JFRTransformDescriptor descriptor, ClassLoader definingLoader,\n-\t\t\tClass<?> classBeingRedefined, ProtectionDomain protectionDomain,\n-\t\t\tInspectionClassLoader inspectionClassLoader) {\n-\t\tsuper(Opcodes.ASM8, cv);\n-\t\tthis.transformDescriptor = descriptor;\n-\t\tthis.definingClassLoader = definingLoader;\n-\t\tthis.protectionDomain = protectionDomain;\n-\n-\t\ttry {\n-\t\t\tthis.inspectionClass = classBeingRedefined != null || descriptor.getFields().isEmpty() ? classBeingRedefined\n-\t\t\t\t\t: inspectionClassLoader.loadClass(TypeUtils.getCanonicalName(transformDescriptor.getClassName()));\n-\t\t} catch (ClassNotFoundException e) {\n-\t\t\tthrow new IllegalStateException(e); \/\/ This should not happen\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-\t\tMethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n-\t\tif (name.equals(transformDescriptor.getMethod().getName())\n-\t\t\t\t&& desc.equals(transformDescriptor.getMethod().getSignature())) {\n-\t\t\ttransformDescriptor.matchFound(true);\n-\t\t\treturn new JFRNextMethodAdvisor(transformDescriptor, inspectionClass, Opcodes.ASM8, mv, access, name, desc);\n-\t\t}\n-\t\treturn mv;\n-\t}\n-\n-\t@Override\n-\tpublic void visitEnd() {\n-\t\ttry {\n-\t\t\treflectiveRegister(generateEventClass());\n-\t\t} catch (Exception e) {\n-\t\t\tAgent.getLogger().log(Level.SEVERE, \"Failed to generate event class for \" + transformDescriptor.toString(), \/\/$NON-NLS-1$\n-\t\t\t\t\te);\n-\t\t}\n-\t\tif (!transformDescriptor.isMatchFound()) {\n-\t\t\tAgent.getLogger().warning(\"Method \" + transformDescriptor.getMethod().getName() + \" \"\n-\t\t\t\t\t+ transformDescriptor.getMethod().getSignature() + \" not found.\"); \/\/ $NON-NLS-1$\n-\t\t}\n-\t\tsuper.visitEnd();\n-\t}\n-\n-\t\/\/ NOTE: multi-release jars should let us compile against jdk9 and do a direct call here\n-\tprivate void reflectiveRegister(Class<?> generateEventClass) throws Exception {\n-\t\tClass<?> jfr = Class.forName(\"jdk.jfr.FlightRecorder\"); \/\/$NON-NLS-1$\n-\t\tMethod registerMethod = jfr.getDeclaredMethod(\"register\", Class.class); \/\/$NON-NLS-1$\n-\t\tregisterMethod.invoke(null, generateEventClass);\n-\t}\n-\n-\tprivate Class<?> generateEventClass() throws Exception {\n-\t\tbyte[] eventClass = JFRNextEventClassGenerator.generateEventClass(transformDescriptor, inspectionClass);\n-\t\treturn TypeUtils.defineClass(transformDescriptor.getEventClassName(), eventClass, 0, eventClass.length,\n-\t\t\t\tdefiningClassLoader, protectionDomain);\n-\t}\n-}\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfrnext\/impl\/JFRNextClassVisitor.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,256 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * \n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * The contents of this file are subject to the terms of either the Universal Permissive License\n- * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n- *\n- * or the following license:\n- *\n- * Redistribution and use in source and binary forms, with or without modification, are permitted\n- * provided that the following conditions are met:\n- * \n- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n- * and the following disclaimer.\n- * \n- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n- * conditions and the following disclaimer in the documentation and\/or other materials provided with\n- * the distribution.\n- * \n- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n- * endorse or promote products derived from this software without specific prior written permission.\n- * \n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n- * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-package org.openjdk.jmc.agent.jfrnext.impl;\n-\n-import java.util.logging.Logger;\n-\n-import org.objectweb.asm.AnnotationVisitor;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.FieldVisitor;\n-import org.objectweb.asm.Label;\n-import org.objectweb.asm.MethodVisitor;\n-import org.objectweb.asm.Opcodes;\n-import org.objectweb.asm.Type;\n-import org.openjdk.jmc.agent.Agent;\n-import org.openjdk.jmc.agent.Attribute;\n-import org.openjdk.jmc.agent.Parameter;\n-import org.openjdk.jmc.agent.Field;\n-import org.openjdk.jmc.agent.ReturnValue;\n-import org.openjdk.jmc.agent.jfr.JFRTransformDescriptor;\n-import org.openjdk.jmc.agent.util.TypeUtils;\n-import org.openjdk.jmc.agent.util.expression.IllegalSyntaxException;\n-\n-public class JFRNextEventClassGenerator {\n-\tprivate static final String CLASS_EVENT = \"jdk\/jfr\/Event\"; \/\/$NON-NLS-1$\n-\n-\tpublic static byte[] generateEventClass(JFRTransformDescriptor td, Class<?> classBeingRedefined) throws Exception {\n-\t\tClassWriter cw = new ClassWriter(0);\n-\t\t\/\/ FIXME: Perhaps switch to Opcodes V9 when there is one.\n-\t\tcw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC + Opcodes.ACC_SUPER, td.getEventClassName(), null, CLASS_EVENT, null);\n-\n-\t\tcw.visitSource(TypeUtils.getNamePart(td.getEventClassName()) + TypeUtils.JAVA_FILE_EXTENSION, null);\n-\n-\t\tString parameterizedClassName = TypeUtils.parameterize(td.getEventClassName());\n-\t\tgenerateClassAnnotations(cw, td);\n-\t\tgenerateAttributeFields(cw, td, classBeingRedefined);\n-\t\tgenerateInit(cw, td.getEventClassName(), parameterizedClassName);\n-\t\tcw.visitEnd();\n-\t\treturn cw.toByteArray();\n-\t}\n-\n-\tprivate static void generateAttributeFields(ClassWriter cw, JFRTransformDescriptor td, Class<?> classBeingRedefined)\n-\t\t\tthrows IllegalSyntaxException {\n-\t\tType[] args = Type.getArgumentTypes(td.getMethod().getSignature());\n-\t\tfor (Parameter param : td.getParameters()) {\n-\t\t\tcreateField(cw, td, param, args[param.getIndex()]);\n-\t\t}\n-\t\tif (td.getReturnValue() != null) {\n-\t\t\tcreateField(cw, td, Type.getReturnType(td.getMethod().getSignature()));\n-\t\t}\n-\n-\t\tfor (Field field : td.getFields()) {\n-\t\t\tcreateField(cw, td, field, field.resolveReferenceChain(classBeingRedefined).getType());\n-\t\t}\n-\t}\n-\n-\tprivate static void createField(ClassWriter cw, JFRTransformDescriptor td, Attribute attribute, Type type) {\n-\t\tif (!td.isAllowedFieldType(type)) {\n-\t\t\tLogger.getLogger(JFRNextEventClassGenerator.class.getName())\n-\t\t\t\t\t.warning(\"Skipped generating field in event class for attribute \" + attribute + \" and type \" + type \/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n-\t\t\t\t\t\t\t+ \" because of configuration settings!\"); \/\/$NON-NLS-1$\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tString fieldType = getFieldType(type);\n-\n-\t\tFieldVisitor fv = cw.visitField(Opcodes.ACC_PROTECTED, attribute.getFieldName(), fieldType, null, null);\n-\n-\t\t\/\/ Name\n-\t\tAnnotationVisitor av = fv.visitAnnotation(\"Ljdk\/jfr\/Label;\", true);\n-\t\tav.visit(\"value\", attribute.getName());\n-\t\tav.visitEnd();\n-\n-\t\t\/\/ Description\n-\t\tav = fv.visitAnnotation(\"Ljdk\/jfr\/Description;\", true);\n-\t\tav.visit(\"value\", attribute.getDescription());\n-\t\tav.visitEnd();\n-\n-\t\t\/\/ \"ContentType\"\n-\t\t\/\/ We support the old JDK 7 style content types transparently.\n-\t\t\/\/ We also support user defined content types and a single string value annotation parameter to the annotation.\n-\t\tString contentTypeAnnotation = getContentTypeAnnotation(attribute.getContentType());\n-\t\tif (contentTypeAnnotation != null) {\n-\t\t\tString[] contentTypeAnnotationInfo = contentTypeAnnotation.split(\";\");\n-\t\t\tav = fv.visitAnnotation(contentTypeAnnotationInfo[0] + \";\", true);\n-\t\t\tif (contentTypeAnnotationInfo.length > 1) {\n-\t\t\t\tav.visit(\"value\", contentTypeAnnotationInfo[1]);\n-\t\t\t}\n-\t\t\tav.visitEnd();\n-\t\t}\n-\n-\t\t\/\/ FIXME: RelKey\n-\t\tfv.visitEnd();\n-\t}\n-\n-\tprivate static void createField(ClassWriter cw, JFRTransformDescriptor td, Type type) {\n-\t\tReturnValue returnValue = td.getReturnValue();\n-\t\tif (!td.isAllowedFieldType(type)) {\n-\t\t\tLogger.getLogger(JFRNextEventClassGenerator.class.getName())\n-\t\t\t\t\t.warning(\"Skipped generating field in event class for return value \" + returnValue + \" and type \" \/\/$NON-NLS-1$\/\/$NON-NLS-2$\n-\t\t\t\t\t\t\t+ type + \" because of configuration settings!\"); \/\/$NON-NLS-1$\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tString fieldType = getFieldType(type);\n-\n-\t\tFieldVisitor fv = cw.visitField(Opcodes.ACC_PROTECTED, returnValue.getFieldName(), fieldType, null, null);\n-\n-\t\t\/\/ Name\n-\t\tAnnotationVisitor av = fv.visitAnnotation(\"Ljdk\/jfr\/Label;\", true);\n-\t\tav.visit(\"value\", returnValue.getName());\n-\t\tav.visitEnd();\n-\n-\t\t\/\/ Description\n-\t\tav = fv.visitAnnotation(\"Ljdk\/jfr\/Description;\", true);\n-\t\tav.visit(\"value\", returnValue.getDescription());\n-\t\tav.visitEnd();\n-\n-\t\t\/\/ \"ContentType\"\n-\t\t\/\/ We support the old JDK 7 style content types transparently.\n-\t\t\/\/ We also support user defined content types and a single string value annotation parameter to the annotation.\n-\t\tString contentTypeAnnotation = getContentTypeAnnotation(returnValue.getContentType());\n-\t\tif (contentTypeAnnotation != null) {\n-\t\t\tString[] contentTypeAnnotationInfo = contentTypeAnnotation.split(\";\");\n-\t\t\tav = fv.visitAnnotation(contentTypeAnnotationInfo[0] + \";\", true);\n-\t\t\tif (contentTypeAnnotationInfo.length > 1) {\n-\t\t\t\tav.visit(\"value\", contentTypeAnnotationInfo[1]);\n-\t\t\t}\n-\t\t\tav.visitEnd();\n-\t\t}\n-\n-\t\t\/\/ FIXME: RelKey\n-\t\tfv.visitEnd();\n-\t}\n-\n-\tprivate static String getContentTypeAnnotation(String contentType) {\n-\t\tif (contentType == null) {\n-\t\t\treturn null;\n-\t\t}\n-\t\tswitch (contentType) {\n-\t\tcase \"None\":\n-\t\t\treturn null;\n-\t\tcase \"Address\":\n-\t\t\treturn \"Ljdk\/jfr\/MemoryAddress;\";\n-\t\tcase \"Bytes\":\n-\t\t\treturn \"Ljdk\/jfr\/DataAmount;\";\n-\t\tcase \"Timestamp\":\n-\t\t\treturn \"Ljdk\/jfr\/Timestamp;\";\n-\t\tcase \"Millis\":\n-\t\t\treturn \"Ljdk\/jfr\/Timespan;\" + \"MILLISECONDS\";\n-\t\tcase \"Nanos\":\n-\t\t\treturn \"Ljdk\/jfr\/Timespan;\" + \"NANOSECONDS\";\n-\t\tcase \"Ticks\":\n-\t\t\treturn \"Ljdk\/jfr\/Timespan;\" + \"TICKS\";\n-\t\tcase \"Percentage\":\n-\t\t\treturn \"Ljdk\/jfr\/Percentage;\";\n-\n-\t\tdefault:\n-\t\t\tif (contentType.startsWith(\"L\") && contentType.endsWith(\";\")) {\n-\t\t\t\tAgent.getLogger()\n-\t\t\t\t\t\t.fine(\"Using user defined content type. Note that this only works with JDK 9 and later!\");\n-\t\t\t\treturn contentType;\n-\t\t\t}\n-\t\t\tAgent.getLogger().severe(\"Unsupported content type \" + contentType\n-\t\t\t\t\t+ \". Either use a JDK 7\/8 content type, or specify the class of the annotation specifying the content type, e.g. Ljdk\/jfr\/DataAmount;. If specifying the content type annotation explicitly, it will only work on JDK 9 or later.\");\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\n-\tprivate static String getFieldType(Type type) {\n-\t\tif (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY) {\n-\t\t\treturn \"Ljava\/lang\/String;\"; \/\/$NON-NLS-1$\n-\t\t}\n-\t\treturn type.getDescriptor();\n-\t}\n-\n-\t\/*\n-\t * In JDK 9 the event types do not really need to be registered. There are also no tokens to\n-\t * track to optimize lookup. So no need for a clinit.\n-\t *\n-\t * That said, once the class has been defined, we will still register it, to make sure that the\n-\t * metadata is visible to all consumers, even though no event has been emitted.\n-\t *\/\n-\tprivate static void generateInit(ClassWriter cw, String className, String parameterizedClassName) {\n-\t\tMethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-\t\tmv.visitCode();\n-\t\tLabel l0 = new Label();\n-\t\tmv.visitLabel(l0);\n-\t\tmv.visitVarInsn(Opcodes.ALOAD, 0);\n-\t\tmv.visitMethodInsn(Opcodes.INVOKESPECIAL, \"jdk\/jfr\/Event\", \"<init>\", \"()V\", false);\n-\t\tmv.visitInsn(Opcodes.RETURN);\n-\t\tLabel l1 = new Label();\n-\t\tmv.visitLabel(l1);\n-\t\tmv.visitLocalVariable(\"this\", parameterizedClassName, null, l0, l1, 0);\n-\t\tmv.visitMaxs(1, 1);\n-\t\tmv.visitEnd();\n-\t}\n-\n-\tprivate static void generateClassAnnotations(ClassWriter cw, JFRTransformDescriptor td) {\n-\t\t\/\/ Label\n-\t\tAnnotationVisitor av = cw.visitAnnotation(\"Ljdk\/jfr\/Label;\", true);\n-\t\tav.visit(\"value\", td.getEventName());\n-\t\tav.visitEnd();\n-\n-\t\t\/\/ Description\n-\t\tav = cw.visitAnnotation(\"Ljdk\/jfr\/Description;\", true);\n-\t\tav.visit(\"value\", td.getEventDescription());\n-\t\tav.visitEnd();\n-\n-\t\t\/\/ Category (path)\n-\t\tString[] pathElements = td.getEventPath().split(\"\/\");\n-\t\tav = cw.visitAnnotation(\"Ljdk\/jfr\/Category;\", true);\n-\t\tAnnotationVisitor arrayVisitor = av.visitArray(\"value\");\n-\t\tfor (String pathElement : pathElements) {\n-\t\t\tarrayVisitor.visit(null, pathElement);\n-\t\t}\n-\t\tarrayVisitor.visitEnd();\n-\t\tav.visitEnd();\n-\n-\t\t\/\/ Stacktrace on\/off\n-\t\tav = cw.visitAnnotation(\"Ljdk\/jfr\/StackTrace;\", true);\n-\t\tav.visit(\"value\", td.isRecordStackTrace());\n-\t\tav.visitEnd();\n-\n-\t\t\/\/ Note that thread is always recorded these days\n-\t}\n-}\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfrnext\/impl\/JFRNextEventClassGenerator.java","additions":0,"deletions":256,"binary":false,"changes":256,"status":"deleted"},{"patch":"@@ -1,277 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * \n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * The contents of this file are subject to the terms of either the Universal Permissive License\n- * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n- *\n- * or the following license:\n- *\n- * Redistribution and use in source and binary forms, with or without modification, are permitted\n- * provided that the following conditions are met:\n- * \n- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n- * and the following disclaimer.\n- * \n- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n- * conditions and the following disclaimer in the documentation and\/or other materials provided with\n- * the distribution.\n- * \n- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n- * endorse or promote products derived from this software without specific prior written permission.\n- * \n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n- * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-package org.openjdk.jmc.agent.jfrnext.impl;\n-\n-import org.objectweb.asm.Label;\n-import org.objectweb.asm.MethodVisitor;\n-import org.objectweb.asm.Opcodes;\n-import org.objectweb.asm.Type;\n-import org.objectweb.asm.commons.AdviceAdapter;\n-import org.openjdk.jmc.agent.Field;\n-import org.openjdk.jmc.agent.Attribute;\n-import org.openjdk.jmc.agent.Parameter;\n-import org.openjdk.jmc.agent.ReturnValue;\n-import org.openjdk.jmc.agent.jfr.JFRTransformDescriptor;\n-import org.openjdk.jmc.agent.util.TypeUtils;\n-import org.openjdk.jmc.agent.util.expression.ReferenceChainElement;\n-import org.openjdk.jmc.agent.util.expression.IllegalSyntaxException;\n-import org.openjdk.jmc.agent.util.expression.ReferenceChain;\n-\n-import java.lang.reflect.Modifier;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\/**\n- * Code emitter for JFR next, i.e. the version of JFR distributed with JDK 9 and later.\n- *\/\n-public class JFRNextMethodAdvisor extends AdviceAdapter {\n-\tprivate static final String THROWABLE_BINARY_NAME = \"java\/lang\/Throwable\"; \/\/$NON-NLS-1$\n-\n-\tprivate final JFRTransformDescriptor transformDescriptor;\n-\tprivate final Class<?> inspectionClass;\n-\tprivate final Type[] argumentTypesRef;\n-\tprivate final Type returnTypeRef;\n-\tprivate final Type eventType;\n-\tprivate int eventLocal = -1;\n-\n-\tprivate Label tryBegin = new Label();\n-\tprivate Label tryEnd = new Label();\n-\tprivate Label catchBegin = new Label();\n-\n-\tprivate boolean shouldInstrumentThrow;\n-\n-\tprotected JFRNextMethodAdvisor(JFRTransformDescriptor transformDescriptor, Class<?> inspectionClass, int api,\n-\t\t\tMethodVisitor mv, int access, String name, String desc) {\n-\t\tsuper(api, mv, access, name, desc);\n-\t\tthis.transformDescriptor = transformDescriptor;\n-\t\tthis.inspectionClass = inspectionClass;\n-\t\t\/\/ These are not accessible from the super type (made private), so must save an extra reference. :\/\n-\t\tthis.argumentTypesRef = Type.getArgumentTypes(desc);\n-\t\tthis.returnTypeRef = Type.getReturnType(desc);\n-\t\tthis.eventType = Type.getObjectType(transformDescriptor.getEventClassName());\n-\n-\t\tthis.shouldInstrumentThrow = !transformDescriptor.isUseRethrow() || !transformDescriptor.isEmitOnException(); \/\/ don't instrument inner throws if rethrow is enabled\n-\t}\n-\n-\t@Override\n-\tpublic void visitCode() {\n-\t\tsuper.visitCode();\n-\n-\t\tif (transformDescriptor.isUseRethrow() || transformDescriptor.isEmitOnException()) {\n-\t\t\tvisitLabel(tryBegin);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void visitEnd() {\n-\t\tif (transformDescriptor.isUseRethrow() && !transformDescriptor.isEmitOnException()) {\n-\t\t\tvisitLabel(tryEnd);\n-\t\t\tvisitTryCatchBlock(tryBegin, tryEnd, tryEnd, THROWABLE_BINARY_NAME);\n-\n-\t\t\tvisitFrame(Opcodes.F_NEW, 0, null, 1, new Object[] {THROWABLE_BINARY_NAME});\n-\n-\t\t\t\/\/ Simply rethrow. Event commits are instrumented by onMethodExit()\n-\t\t\tshouldInstrumentThrow = true;\n-\t\t\tvisitInsn(ATHROW);\n-\t\t} else if (transformDescriptor.isEmitOnException()) {\n-\t\t\tvisitLabel(tryEnd);\n-\t\t\tvisitTryCatchBlock(tryBegin, tryEnd, catchBegin, THROWABLE_BINARY_NAME);\n-\t\t\tif (!transformDescriptor.isUseRethrow()) {\n-\t\t\t\tvisitFrame(Opcodes.F_NEW, 0, null, 1, new Object[] {THROWABLE_BINARY_NAME});\n-\t\t\t\tvisitInsn(RETURN);\n-\t\t\t} else {\n-\t\t\t\tvisitFrame(Opcodes.F_NEW, 0, null, 1, new Object[] {THROWABLE_BINARY_NAME});\n-\t\t\t\tshouldInstrumentThrow = true;\n-\t\t\t\tvisitInsn(ATHROW);\n-\t\t\t}\n-\t\t}\n-\t\tsuper.visitEnd();\n-\t}\n-\n-\t@Override\n-\tprotected void onMethodEnter() {\n-\t\ttry {\n-\t\t\tcreateEvent();\n-\t\t} catch (IllegalSyntaxException e) {\n-\t\t\tthrow new RuntimeException(e);\n-\t\t}\n-\t}\n-\n-\tprivate void createEvent() throws IllegalSyntaxException {\n-\t\tmv.visitTypeInsn(NEW, transformDescriptor.getEventClassName());\n-\t\tmv.visitInsn(DUP);\n-\t\tmv.visitInsn(DUP);\n-\t\tmv.visitMethodInsn(INVOKESPECIAL, transformDescriptor.getEventClassName(), \"<init>\", \"()V\", false); \/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n-\t\tfor (Parameter param : transformDescriptor.getParameters()) {\n-\t\t\tType argumentType = argumentTypesRef[param.getIndex()];\n-\t\t\tif (transformDescriptor.isAllowedFieldType(argumentType)) {\n-\t\t\t\tmv.visitInsn(DUP);\n-\t\t\t\tloadArg(param.getIndex());\n-\t\t\t\twriteAttribute(param, argumentType);\n-\t\t\t}\n-\t\t}\n-\n-\t\tfor (Field field : transformDescriptor.getFields()) {\n-\t\t\tReferenceChain refChain = field.resolveReferenceChain(inspectionClass).normalize();\n-\n-\t\t\tif (!refChain.isStatic() && Modifier.isStatic(getAccess())) {\n-\t\t\t\tthrow new IllegalSyntaxException(\n-\t\t\t\t\t\t\"Illegal non-static reference from a static context: \" + field.getExpression());\n-\t\t\t}\n-\n-\t\t\tif (transformDescriptor.isAllowedFieldType(refChain.getType())) {\n-\t\t\t\tmv.visitInsn(DUP);\n-\t\t\t\tloadField(refChain);\n-\t\t\t\twriteAttribute(field, refChain.getType());\n-\t\t\t}\n-\t\t}\n-\n-\t\tmv.visitMethodInsn(INVOKEVIRTUAL, transformDescriptor.getEventClassName(), \"begin\", \"()V\", false); \/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n-\t\teventLocal = newLocal(eventType);\n-\t\tmv.visitVarInsn(ASTORE, eventLocal);\n-\t}\n-\n-\tprivate void loadField(ReferenceChain refChain) {\n-\t\tType type = refChain.getType();\n-\t\tboolean isStatic = Modifier.isStatic(getAccess());\n-\t\tLabel nullCase = new Label();\n-\t\tLabel continueCase = new Label();\n-\t\tList<Object> localVarVerifications = new ArrayList<>();\n-\t\tif (!isStatic) {\n-\t\t\tlocalVarVerifications.add(Type.getInternalName(inspectionClass)); \/\/ \"this\"\n-\t\t}\n-\t\tfor (Type argType : argumentTypesRef) {\n-\t\t\tlocalVarVerifications.add(TypeUtils.getFrameVerificationType(argType));\n-\t\t}\n-\n-\t\t\/\/ Assumes the reference chain is normalized already. See ReferenceChain.normalize()\n-\t\tList<ReferenceChainElement> refs = refChain.getReferences();\n-\t\tfor (int i = 0; i < refs.size(); i++) {\n-\t\t\tReferenceChainElement ref = refs.get(i);\n-\n-\t\t\tif (ref instanceof ReferenceChainElement.ThisReference) {\n-\t\t\t\tmv.visitVarInsn(ALOAD, 0); \/\/ load \"this\"\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tif (ref instanceof ReferenceChainElement.FieldReference) {\n-\t\t\t\tmv.visitFieldInsn(ref.isStatic() ? GETSTATIC : GETFIELD, ref.getMemberingType().getInternalName(),\n-\t\t\t\t\t\t((ReferenceChainElement.FieldReference) ref).getName(),\n-\t\t\t\t\t\tref.getReferencedType().getDescriptor());\n-\n-\t\t\t\t\/\/ null check for field references\n-\t\t\t\tif (i < refs.size() - 1) { \/\/ Skip null check for final reference. Null is acceptable here\n-\t\t\t\t\tmv.visitInsn(DUP);\n-\t\t\t\t\tmv.visitJumpInsn(IFNULL, nullCase);\n-\t\t\t\t}\n-\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tif (ref instanceof ReferenceChainElement.QualifiedThisReference) {\n-\t\t\t\tint suffix = ((ReferenceChainElement.QualifiedThisReference) ref).getDepth();\n-\t\t\t\tClass<?> c = ref.getMemberingClass();\n-\t\t\t\twhile (!ref.getReferencedClass().equals(c)) {\n-\t\t\t\t\tmv.visitFieldInsn(GETFIELD, Type.getType(c).getInternalName(), \"this$\" + (suffix--),\n-\t\t\t\t\t\t\tType.getType(c.getEnclosingClass()).getDescriptor());\n-\t\t\t\t\tc = c.getEnclosingClass();\n-\t\t\t\t}\n-\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tthrow new UnsupportedOperationException(\"Unsupported reference chain element type\");\n-\t\t}\n-\n-\t\t\/\/ loaded a value, jump to writing attribute\n-\t\tmv.visitJumpInsn(GOTO, continueCase);\n-\n-\t\t\/\/ null reference on path, load zero value\n-\t\tmv.visitLabel(nullCase);\n-\t\tmv.visitFrame(F_NEW, localVarVerifications.size(), localVarVerifications.toArray(), 4,\n-\t\t\t\tnew Object[] {eventType.getInternalName(), eventType.getInternalName(), eventType.getInternalName(),\n-\t\t\t\t\t\tType.getInternalName(Object.class)});\n-\t\tmv.visitInsn(POP);\n-\t\tmv.visitInsn(TypeUtils.getConstZeroOpcode(type));\n-\n-\t\t\/\/ must verify frame for jump targets\n-\t\tmv.visitLabel(continueCase);\n-\t\tmv.visitFrame(F_NEW, localVarVerifications.size(), localVarVerifications.toArray(), 4,\n-\t\t\t\tnew Object[] {eventType.getInternalName(), eventType.getInternalName(), eventType.getInternalName(),\n-\t\t\t\t\t\tTypeUtils.getFrameVerificationType(type)});\n-\t}\n-\n-\tprivate void writeAttribute(Attribute param, Type type) {\n-\t\tif (TypeUtils.shouldStringify(type)) {\n-\t\t\tTypeUtils.stringify(mv);\n-\t\t\ttype = TypeUtils.STRING_TYPE;\n-\t\t}\n-\t\tputField(Type.getObjectType(transformDescriptor.getEventClassName()), param.getFieldName(), type);\n-\t}\n-\n-\t@Override\n-\tprotected void onMethodExit(int opcode) {\n-\t\tif (transformDescriptor.isEmitOnException()) {\n-\t\t\tvisitLabel(catchBegin);\n-\t\t}\n-\t\tif (opcode == ATHROW && !shouldInstrumentThrow) {\n-\t\t\treturn;\n-\t\t}\n-\t\tif (returnTypeRef.getSort() != Type.VOID && opcode != ATHROW) {\n-\t\t\tReturnValue returnValue = transformDescriptor.getReturnValue();\n-\t\t\tif (returnValue != null) {\n-\t\t\t\temitSettingReturnParam(opcode, returnValue);\n-\t\t\t}\n-\t\t}\n-\t\tcommitEvent();\n-\t}\n-\n-\tprivate void emitSettingReturnParam(int opcode, ReturnValue returnValue) {\n-\t\tif (returnTypeRef.getSize() == 1) {\n-\t\t\tdup();\n-\t\t\tmv.visitVarInsn(ALOAD, eventLocal);\n-\t\t\tswap();\n-\t\t} else {\n-\t\t\tdup2();\n-\t\t\tmv.visitVarInsn(ALOAD, eventLocal);\n-\t\t\tdupX2();\n-\t\t\tpop();\n-\t\t}\n-\t\twriteAttribute(returnValue, returnTypeRef);\n-\t}\n-\n-\tprivate void commitEvent() {\n-\t\tmv.visitVarInsn(ALOAD, eventLocal);\n-\t\tmv.visitMethodInsn(INVOKEVIRTUAL, transformDescriptor.getEventClassName(), \"commit\", \"()V\", false); \/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n-\t}\n-}\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfrnext\/impl\/JFRNextMethodAdvisor.java","additions":0,"deletions":277,"binary":false,"changes":277,"status":"deleted"},{"patch":"@@ -47,1 +47,2 @@\n-import org.openjdk.jmc.agent.jfr.impl.JFRUtils;\n+import org.openjdk.jmc.agent.Convertable;\n+import org.openjdk.jmc.agent.jfrlegacy.impl.JFRUtils;\n@@ -64,2 +65,2 @@\n-\tprivate final static String UNSAFE_JDK_7_CLASS = \"sun.misc.Unsafe\"; \/\/$NON-NLS-1$\n-\tprivate final static String UNSAFE_JDK_11_CLASS = \"jdk.internal.misc.Unsafe\"; \/\/$NON-NLS-1$\n+\tprivate static final String UNSAFE_JDK_7_CLASS = \"sun.misc.Unsafe\"; \/\/$NON-NLS-1$\n+\tprivate static final String UNSAFE_JDK_11_CLASS = \"jdk.internal.misc.Unsafe\"; \/\/$NON-NLS-1$\n@@ -220,1 +221,1 @@\n-\tpublic static boolean shouldStringify(Type argumentType) {\n+\tpublic static boolean shouldStringify(Convertable convertable, Type argumentType) {\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/util\/TypeUtils.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+\t@SuppressWarnings(\"deprecation\")\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/util\/expression\/ExpressionResolver.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n-<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\">\n+<xs:schema elementFormDefault=\"qualified\"\n+\txmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\">\n@@ -18,1 +19,2 @@\n-\t\t\t<xs:element type=\"xs:string\" name=\"classprefix\" minOccurs=\"0\">\n+\t\t\t<xs:element type=\"xs:string\" name=\"classprefix\"\n+\t\t\t\tminOccurs=\"0\">\n@@ -20,1 +22,15 @@\n-\t\t\t\t\t<xs:documentation>This is the prefix to use when generating event class names<\/xs:documentation>\n+\t\t\t\t\t<xs:documentation>This is the prefix to use when generating event\n+\t\t\t\t\t\tclass names\n+\t\t\t\t\t<\/xs:documentation>\n+\t\t\t\t<\/xs:annotation>\n+\t\t\t<\/xs:element>\n+\t\t\t<xs:element type=\"xs:boolean\" name=\"allowtostring\"\n+\t\t\t\tminOccurs=\"0\">\n+\t\t\t\t<xs:annotation>\n+\t\t\t\t\t<xs:documentation>\n+\t\t\t\t\t\tWill allow the recording of arrays and object\n+\t\t\t\t\t\tparameters as Strings. This will cause toString to be called for\n+\t\t\t\t\t\tarray elements and objects other than strings, which in turn can\n+\t\t\t\t\t\tcause trouble if the toString method is badly implemented. Use\n+\t\t\t\t\t\twith care.\n+\t\t\t\t\t<\/xs:documentation>\n@@ -23,1 +39,2 @@\n-\t\t\t<xs:element type=\"xs:boolean\" name=\"allowtostring\" minOccurs=\"0\">\n+\t\t\t<xs:element type=\"xs:boolean\" name=\"allowconverter\"\n+\t\t\t\tminOccurs=\"0\">\n@@ -25,4 +42,3 @@\n-\t\t\t\t\t<xs:documentation> \n-\t\t\t\t\t\tWill allow the recording of arrays and object parameters as Strings. This will cause toString to\n-\t\t\t\t\t\tbe called for array elements and objects other than strings, which in turn can cause trouble if\n-\t\t\t\t\t\tthe toString method is badly implemented. Use with care.\n+\t\t\t\t\t<xs:documentation>\n+\t\t\t\t\t\tAllows converters to be used. If a converter is\n+\t\t\t\t\t\tbadly implemented, you are on your own.\n@@ -32,1 +48,2 @@\n-\t\t\t<xs:element type=\"xs:boolean\" name=\"allowconverter\" minOccurs=\"0\">\n+\t\t\t<xs:element type=\"xs:boolean\"\n+\t\t\t\tname=\"enabledefaultconverters\" minOccurs=\"0\">\n@@ -35,1 +52,2 @@\n-\t\t\t\t\t\tAllows converters to be used. If a converter is badly implemented, you are on your own.\n+\t\t\t\t\t\tEnables a set of pre-packaged converters,\n+\t\t\t\t\t\tconverting some commonly found types to Strings.\n@@ -39,1 +57,2 @@\n-\t\t\t<xs:element type=\"xs:boolean\" name=\"emitonexception\" minOccurs=\"0\">\n+\t\t\t<xs:element type=\"xs:boolean\" name=\"emitonexception\"\n+\t\t\t\tminOccurs=\"0\">\n@@ -42,1 +61,2 @@\n-\t\t\t\t\t\tCauses events to only be emitted if the instrmented method throws an exception\n+\t\t\t\t\t\tCauses events to only be emitted if the\n+\t\t\t\t\t\tinstrumented method throws an exception\n@@ -51,1 +71,2 @@\n-\t\t\t<xs:element type=\"eventType\" name=\"event\" maxOccurs=\"unbounded\" minOccurs=\"0\" \/>\n+\t\t\t<xs:element type=\"eventType\" name=\"event\"\n+\t\t\t\tmaxOccurs=\"unbounded\" minOccurs=\"0\" \/>\n@@ -60,1 +81,2 @@\n-\t\t\t<xs:element type=\"xs:string\" name=\"description\" minOccurs=\"0\" \/>\n+\t\t\t<xs:element type=\"xs:string\" name=\"description\"\n+\t\t\t\tminOccurs=\"0\" \/>\n@@ -62,1 +84,2 @@\n-\t\t\t<xs:element type=\"xs:boolean\" name=\"stacktrace\" minOccurs=\"0\" \/>\n+\t\t\t<xs:element type=\"xs:boolean\" name=\"stacktrace\"\n+\t\t\t\tminOccurs=\"0\" \/>\n@@ -64,1 +87,2 @@\n-\t\t\t<xs:element type=\"locationType\" name=\"location\" minOccurs=\"0\" \/>\n+\t\t\t<xs:element type=\"locationType\" name=\"location\"\n+\t\t\t\tminOccurs=\"0\" \/>\n@@ -72,1 +96,3 @@\n-\t\t\t<xs:documentation>the fully qualified class name (FQCN) of the class to be transformed<\/xs:documentation>\n+\t\t\t<xs:documentation>the fully qualified class name (FQCN) of the class\n+\t\t\t\tto be transformed\n+\t\t\t<\/xs:documentation>\n@@ -75,1 +101,2 @@\n-\t\t\t<xs:pattern value=\"([a-zA-Z_$][a-zA-Z0-9_$]*\\.)*([a-zA-Z_$][a-zA-Z0-9_$]*)\" \/>\n+\t\t\t<xs:pattern\n+\t\t\t\tvalue=\"([a-zA-Z_$][a-zA-Z0-9_$]*\\.)*([a-zA-Z_$][a-zA-Z0-9_$]*)\" \/>\n@@ -84,2 +111,4 @@\n-\t\t\t<xs:element type=\"parametersType\" name=\"parameters\" minOccurs=\"0\" \/>\n-\t\t\t<xs:element type=\"returnValueType\" name=\"returnvalue\" minOccurs=\"0\" \/>\n+\t\t\t<xs:element type=\"parametersType\" name=\"parameters\"\n+\t\t\t\tminOccurs=\"0\" \/>\n+\t\t\t<xs:element type=\"returnValueType\" name=\"returnvalue\"\n+\t\t\t\tminOccurs=\"0\" \/>\n@@ -98,1 +127,2 @@\n-\t\t\t<xs:documentation>see 4.3.3 in Java Virtual Machine Specification<\/xs:documentation>\n+\t\t\t<xs:documentation>see 4.3.3 in Java Virtual Machine Specification\n+\t\t\t<\/xs:documentation>\n@@ -101,1 +131,2 @@\n-\t\t\t<xs:pattern value=\"\\((\\[*([BCDFIJSZ]|L([a-zA-Z_$][a-zA-Z0-9_$]*\/)*[a-zA-Z_$][a-zA-Z0-9_$]*;))*\\)(V|\\[*([BCDFIJSZ]|L([a-zA-Z_$][a-zA-Z0-9_$]*\/)*[a-zA-Z_$][a-zA-Z0-9_$]*;))\" \/>\n+\t\t\t<xs:pattern\n+\t\t\t\tvalue=\"\\((\\[*([BCDFIJSZ]|L([a-zA-Z_$][a-zA-Z0-9_$]*\/)*[a-zA-Z_$][a-zA-Z0-9_$]*;))*\\)(V|\\[*([BCDFIJSZ]|L([a-zA-Z_$][a-zA-Z0-9_$]*\/)*[a-zA-Z_$][a-zA-Z0-9_$]*;))\" \/>\n@@ -111,1 +142,2 @@\n-\t\t\t<xs:element type=\"parameterType\" name=\"parameter\" maxOccurs=\"unbounded\" minOccurs=\"0\" \/>\n+\t\t\t<xs:element type=\"parameterType\" name=\"parameter\"\n+\t\t\t\tmaxOccurs=\"unbounded\" minOccurs=\"0\" \/>\n@@ -118,4 +150,8 @@\n-\t\t\t<xs:element type=\"xs:string\" name=\"description\" minOccurs=\"0\" \/>\n-\t\t\t<xs:element type=\"contentTypeType\" name=\"contenttype\" minOccurs=\"0\" \/>\n-\t\t\t<xs:element type=\"relationKeyType\" name=\"relationkey\" minOccurs=\"0\" \/>\n-\t\t\t<xs:element type=\"converterType\" name=\"converter\" minOccurs=\"0\" \/>\n+\t\t\t<xs:element type=\"xs:string\" name=\"description\"\n+\t\t\t\tminOccurs=\"0\" \/>\n+\t\t\t<xs:element type=\"contentTypeType\" name=\"contenttype\"\n+\t\t\t\tminOccurs=\"0\" \/>\n+\t\t\t<xs:element type=\"relationKeyType\" name=\"relationkey\"\n+\t\t\t\tminOccurs=\"0\" \/>\n+\t\t\t<xs:element type=\"converterDefinition\" name=\"converter\"\n+\t\t\t\tminOccurs=\"0\" \/>\n@@ -123,1 +159,2 @@\n-\t\t<xs:attribute type=\"xs:nonNegativeInteger\" name=\"index\" use=\"required\" \/>\n+\t\t<xs:attribute type=\"xs:nonNegativeInteger\" name=\"index\"\n+\t\t\tuse=\"required\" \/>\n@@ -128,1 +165,2 @@\n-\t\t\t<xs:documentation>see com.oracle.jrockit.jfr.ContentType<\/xs:documentation>\n+\t\t\t<xs:documentation>see com.oracle.jrockit.jfr.ContentType\n+\t\t\t<\/xs:documentation>\n@@ -150,1 +188,2 @@\n-\t\t\t\ta unique URI signifying a relationship between different events based on the values of specific\n+\t\t\t\ta unique URI signifying a relationship between\n+\t\t\t\tdifferent events based on the values of specific\n@@ -157,1 +196,1 @@\n-\t<xs:simpleType name=\"converterType\">\n+\t<xs:simpleType name=\"converterDefinition\">\n@@ -159,1 +198,4 @@\n-\t\t\t<xs:documentation>the fully qualified class name (FQCN) of the converter used<\/xs:documentation>\n+\t\t\t<xs:documentation>either the fully qualified class name (FQCN) of the\n+\t\t\t\tconverter used, or the FQN followed by .method and the formal\n+\t\t\t\tdescriptor.\n+\t\t\t<\/xs:documentation>\n@@ -161,1 +203,5 @@\n-\t\t<xs:restriction base=\"classType\" \/>\n+\t\t<xs:restriction base=\"xs:normalizedString\">\n+\t\t\t<xs:whiteSpace value=\"collapse\" \/>\n+\t\t\t<xs:pattern\n+\t\t\t\tvalue=\"([a-zA-Z_$][a-zA-Z0-9_$]*\\.)+([a-zA-Z_$][a-zA-Z0-9_$]+)(\\((\\[*([BCDFIJSZ]|L([a-zA-Z_$][a-zA-Z0-9_$]*\/)*[a-zA-Z_$][a-zA-Z0-9_$]*;))*\\)(V|\\[*([BCDFIJSZ]|L([a-zA-Z_$][a-zA-Z0-9_$]*\/)*[a-zA-Z_$][a-zA-Z0-9_$]*;)))?\" \/>\n+\t\t<\/xs:restriction>\n@@ -166,1 +212,2 @@\n-\t\t\t<xs:documentation>This will only work if we allow toString<\/xs:documentation>\n+\t\t\t<xs:documentation>This will only work if we allow toString\n+\t\t\t<\/xs:documentation>\n@@ -170,4 +217,8 @@\n-\t\t\t<xs:element type=\"xs:string\" name=\"description\" minOccurs=\"0\" \/>\n-\t\t\t<xs:element type=\"contentTypeType\" name=\"contenttype\" minOccurs=\"0\" \/>\n-\t\t\t<xs:element type=\"relationKeyType\" name=\"relationkey\" minOccurs=\"0\" \/>\n-\t\t\t<xs:element type=\"converterType\" name=\"converter\" minOccurs=\"0\" \/>\n+\t\t\t<xs:element type=\"xs:string\" name=\"description\"\n+\t\t\t\tminOccurs=\"0\" \/>\n+\t\t\t<xs:element type=\"contentTypeType\" name=\"contenttype\"\n+\t\t\t\tminOccurs=\"0\" \/>\n+\t\t\t<xs:element type=\"relationKeyType\" name=\"relationkey\"\n+\t\t\t\tminOccurs=\"0\" \/>\n+\t\t\t<xs:element type=\"converterDefinition\" name=\"converter\"\n+\t\t\t\tminOccurs=\"0\" \/>\n@@ -198,1 +249,2 @@\n-\t\t\t<xs:element type=\"fieldType\" name=\"field\" maxOccurs=\"unbounded\" minOccurs=\"0\" \/>\n+\t\t\t<xs:element type=\"fieldType\" name=\"field\"\n+\t\t\t\tmaxOccurs=\"unbounded\" minOccurs=\"0\" \/>\n@@ -206,4 +258,8 @@\n-\t\t\t<xs:element type=\"xs:string\" name=\"description\" minOccurs=\"0\" \/>\n-\t\t\t<xs:element type=\"contentTypeType\" name=\"contenttype\" minOccurs=\"0\" \/>\n-\t\t\t<xs:element type=\"relationKeyType\" name=\"relationkey\" minOccurs=\"0\" \/>\n-\t\t\t<xs:element type=\"converterType\" name=\"converter\" minOccurs=\"0\" \/>\n+\t\t\t<xs:element type=\"xs:string\" name=\"description\"\n+\t\t\t\tminOccurs=\"0\" \/>\n+\t\t\t<xs:element type=\"contentTypeType\" name=\"contenttype\"\n+\t\t\t\tminOccurs=\"0\" \/>\n+\t\t\t<xs:element type=\"relationKeyType\" name=\"relationkey\"\n+\t\t\t\tminOccurs=\"0\" \/>\n+\t\t\t<xs:element type=\"converterDefinition\" name=\"converter\"\n+\t\t\t\tminOccurs=\"0\" \/>\n@@ -216,1 +272,2 @@\n-\t\t\t\tan expression in a subset of primary expressions (see 15.8 in Java Language Specification) to be\n+\t\t\t\tan expression in a subset of primary expressions\n+\t\t\t\t(see 15.8 in Java Language Specification) to be\n@@ -221,1 +278,2 @@\n-\t\t\t<xs:pattern value=\"([a-zA-Z_$][a-zA-Z0-9_$]*\\.)*([a-zA-Z_$][a-zA-Z0-9_$]*)(\\.[a-zA-Z_$][a-zA-Z_$]*)*\" \/>\n+\t\t\t<xs:pattern\n+\t\t\t\tvalue=\"([a-zA-Z_$][a-zA-Z0-9_$]*\\.)*([a-zA-Z_$][a-zA-Z0-9_$]*)(\\.[a-zA-Z_$][a-zA-Z_$]*)*\" \/>\n","filename":"agent\/src\/main\/resources\/org\/openjdk\/jmc\/agent\/impl\/jfrprobes_schema.xsd","additions":103,"deletions":45,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.agent.converters.test;\n+\n+\/**\n+ * Converts a {@link Number} to long.\n+ *\/\n+public class ConverterNumber {\n+\tpublic static long convert(Number number) {\n+\t\treturn number.longValue();\n+\t}\n+}\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/ConverterNumber.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n@@ -3,1 +36,0 @@\n-import org.openjdk.jmc.agent.converters.DoubleConverter;\n@@ -7,1 +39,1 @@\n- * Converts a {@link Gurka} to long, by taking the ID and casting it to a double.\n+ * Converts a {@link Gurka} to double by taking the ID and casting it.\n@@ -9,3 +41,2 @@\n-public class GurkConverterDouble implements DoubleConverter<Gurka> {\n-\t@Override\n-\tpublic double convert(Gurka gurka) {\n+public class GurkConverterDouble {\n+\tpublic static double convert(Gurka gurka) {\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/GurkConverterDouble.java","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n@@ -3,1 +36,0 @@\n-import org.openjdk.jmc.agent.converters.FloatConverter;\n@@ -7,1 +39,1 @@\n- * Converts a {@link Gurka} to long, by taking the ID and casting it to a double.\n+ * Converts a {@link Gurka} to float by taking the ID and casting it.\n@@ -9,3 +41,2 @@\n-public class GurkConverterFloat implements FloatConverter<Gurka> {\n-\t@Override\n-\tpublic float convert(Gurka gurka) {\n+public class GurkConverterFloat {\n+\tpublic static float convert(Gurka gurka) {\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/GurkConverterFloat.java","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n@@ -3,1 +36,0 @@\n-import org.openjdk.jmc.agent.converters.IntConverter;\n@@ -7,1 +39,1 @@\n- * Converts a {@link Gurka} to an int, by taking the ID.\n+ * Converts a {@link Gurka} to an int by taking the ID and casting it.\n@@ -9,3 +41,2 @@\n-public class GurkConverterInt implements IntConverter<Gurka> {\n-\t@Override\n-\tpublic int convert(Gurka gurka) {\n+public class GurkConverterInt {\n+\tpublic static int convert(Gurka gurka) {\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/GurkConverterInt.java","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n@@ -3,1 +36,0 @@\n-import org.openjdk.jmc.agent.converters.LongConverter;\n@@ -7,1 +39,1 @@\n- * Converts a {@link Gurka} to long, by taking the ID and casting it to a long.\n+ * Converts a {@link Gurka} to long by taking the ID and casting it.\n@@ -9,4 +41,3 @@\n-public class GurkConverterLong implements LongConverter<Gurka> {\n-\t@Override\n-\tpublic long convert(Gurka o) {\n-\t\treturn (long) o.getID();\n+public class GurkConverterLong {\n+\tpublic static long convert(Gurka gurka) {\n+\t\treturn (long) gurka.getID();\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/GurkConverterLong.java","additions":37,"deletions":6,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n@@ -3,1 +36,0 @@\n-import org.openjdk.jmc.agent.converters.StringConverter;\n@@ -9,4 +41,3 @@\n-public class GurkConverterString implements StringConverter<Gurka> {\n-\t@Override\n-\tpublic String convert(Gurka o) {\n-\t\treturn \"StringGurka \" + o.getID();\n+public class GurkConverterString {\n+\tpublic static String convert(Gurka gurka) {\n+\t\treturn \"StringGurka \" + gurka.getID();\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/GurkConverterString.java","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.agent.converters.test;\n+\n+import org.openjdk.jmc.agent.test.Gurka;\n+\n+\/**\n+ * Converts a {@link Gurka} to int by taking the ID and casting it, using a non standard method\n+ * name.\n+ *\/\n+public class GurkCustomConverterInt {\n+\tpublic static int convertCustom(Gurka gurka) {\n+\t\treturn (int) gurka.getID();\n+\t}\n+}\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/GurkCustomConverterInt.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.agent.converters.test;\n+\n+import org.openjdk.jmc.agent.test.Gurka;\n+\n+\/**\n+ * Converts a {@link Gurka} to various different types.\n+ *\/\n+public class GurkMultiCustomConverter {\n+\tpublic static int convertCustomInt(Gurka gurka) {\n+\t\treturn (int) gurka.getID();\n+\t}\n+\n+\tpublic static double convertCustomDouble(Gurka gurka) {\n+\t\treturn (double) gurka.getID();\n+\t}\n+\n+\tpublic static String convertCustomString(Gurka gurka) {\n+\t\treturn \"StringGurka \" + gurka.getID();\n+\t}\n+}\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/GurkMultiCustomConverter.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.agent.converters.test;\n+\n+import org.openjdk.jmc.agent.test.Gurka;\n+\n+\/**\n+ * Converts a {@link Gurka} to various different types.\n+ *\/\n+public class GurkMultiDefaultConverter {\n+\tpublic static int convert(Gurka gurka) {\n+\t\treturn (int) gurka.getID();\n+\t}\n+\n+\tpublic static int convert(String string) {\n+\t\treturn (int) Integer.valueOf(string);\n+\t}\n+\n+\tpublic static String convert(Exception exception) {\n+\t\treturn exception.getMessage();\n+\t}\n+\n+\tpublic static int convert(Double value) {\n+\t\treturn value.intValue();\n+\t}\n+\n+\tpublic static int convert(Integer value) {\n+\t\treturn value.intValue();\n+\t}\n+\n+\tpublic static int convert(Long value) {\n+\t\treturn value.intValue();\n+\t}\n+}\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/GurkMultiDefaultConverter.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n@@ -3,0 +36,1 @@\n+import java.io.File;\n@@ -4,0 +38,2 @@\n+import java.net.URI;\n+import java.net.URISyntaxException;\n@@ -6,0 +42,1 @@\n+import org.openjdk.jmc.agent.test.util.TestToolkit;\n@@ -18,1 +55,1 @@\n-\tprivate final static class Runner implements Runnable {\n+\tprivate static final class Runner implements Runnable {\n@@ -27,0 +64,7 @@\n+\t\t\t\t\tprintFileToString(new File(TestToolkit.randomString().toLowerCase() + \".tmp\"));\n+\t\t\t\t\tprintUriToString(new URI(\"http:\/\/localhost:7777\/\" + TestToolkit.randomString()));\n+\t\t\t\t\tprintNumber(TestToolkit.randomLong());\n+\t\t\t\t\tprintIntMultiCustom(Gurka.createGurka());\n+\t\t\t\t\tprintDoubleMultiCustom(Gurka.createGurka());\n+\t\t\t\t\tprintLongMultiDefault(TestToolkit.randomLong());\n+\t\t\t\t\tprintDoubleMultiDefault(TestToolkit.randomLong() \/ 2.0d);\n@@ -28,0 +72,1 @@\n+\t\t\t\t} catch (URISyntaxException e) {\n@@ -34,1 +79,1 @@\n-\t\tSystem.out.println(\"String: \" + gurka);\n+\t\tSystem.out.println(\"C String: \" + gurka);\n@@ -39,1 +84,1 @@\n-\t\tSystem.out.println(\"Int: \" + gurka);\n+\t\tSystem.out.println(\"C Int: \" + gurka);\n@@ -44,1 +89,1 @@\n-\t\tSystem.out.println(\"Long: \" + gurka);\n+\t\tSystem.out.println(\"C Long: \" + gurka);\n@@ -49,1 +94,1 @@\n-\t\tSystem.out.println(\"Float: \" + gurka);\n+\t\tSystem.out.println(\"C Float: \" + gurka);\n@@ -54,1 +99,36 @@\n-\t\tSystem.out.println(\"Double: \" + gurka);\n+\t\tSystem.out.println(\"C Double: \" + gurka);\n+\t\tThread.sleep(1000);\n+\t}\n+\n+\tpublic static void printFileToString(File file) throws InterruptedException {\n+\t\tSystem.out.println(\"C File: \" + file);\n+\t\tThread.sleep(1000);\n+\t}\n+\n+\tpublic static void printUriToString(URI someUri) throws InterruptedException {\n+\t\tSystem.out.println(\"C URI: \" + someUri);\n+\t\tThread.sleep(1000);\n+\t}\n+\n+\tpublic static void printNumber(Number number) throws InterruptedException {\n+\t\tSystem.out.println(\"C Number: \" + number.doubleValue());\n+\t\tThread.sleep(1000);\n+\t}\n+\n+\tprivate static void printIntMultiCustom(Gurka gurka) throws InterruptedException {\n+\t\tSystem.out.println(\"C int MC: \" + gurka);\n+\t\tThread.sleep(1000);\n+\t}\n+\n+\tpublic static void printDoubleMultiCustom(Gurka gurka) throws InterruptedException {\n+\t\tSystem.out.println(\"C Long MC: \" + gurka);\n+\t\tThread.sleep(1000);\n+\t}\n+\n+\tpublic static void printLongMultiDefault(Long value) throws InterruptedException {\n+\t\tSystem.out.println(\"C Long MD: \" + value.longValue());\n+\t\tThread.sleep(1000);\n+\t}\n+\n+\tpublic static void printDoubleMultiDefault(Double value) throws InterruptedException {\n+\t\tSystem.out.println(\"C Long MD: \" + value.doubleValue());\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/InstrumentMeConverter.java","additions":86,"deletions":6,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n@@ -37,0 +39,2 @@\n+import java.io.BufferedOutputStream;\n+import java.io.ByteArrayOutputStream;\n@@ -38,0 +42,1 @@\n+import java.io.PrintWriter;\n@@ -44,0 +49,1 @@\n+import org.objectweb.asm.ClassReader;\n@@ -45,0 +51,2 @@\n+import org.objectweb.asm.util.CheckClassAdapter;\n+import org.objectweb.asm.util.TraceClassVisitor;\n@@ -46,0 +54,1 @@\n+import org.openjdk.jmc.agent.Transformer;\n@@ -62,0 +71,35 @@\n+\n+\t\tTransformer jfrTransformer = new Transformer(registry);\n+\t\tbyte[] transformedClass = jfrTransformer.transform(InstrumentMeConverter.class.getClassLoader(),\n+\t\t\t\tType.getInternalName(InstrumentMeConverter.class), InstrumentMeConverter.class, null,\n+\t\t\t\tTestToolkit.getByteCode(InstrumentMeConverter.class));\n+\n+\t\tassertNotNull(transformedClass);\n+\t\tassertFalse(registry.hasPendingTransforms(Type.getInternalName(InstrumentMeConverter.class)));\n+\n+\t\tTraceClassVisitor visitor = new TraceClassVisitor(\n+\t\t\t\tnew PrintWriter(new BufferedOutputStream(new ByteArrayOutputStream())));\n+\t\tCheckClassAdapter checkAdapter = new CheckClassAdapter(visitor);\n+\t\tClassReader reader = new ClassReader(transformedClass);\n+\t\treader.accept(checkAdapter, 0);\n+\t}\n+\n+\tpublic static void main(String[] args) throws XMLStreamException, IOException, IllegalClassFormatException {\n+\t\tTransformRegistry registry = DefaultTransformRegistry.from(TestToolkit.getProbesXMLFromTemplate(getTemplate(),\n+\t\t\t\t\"testRunConverterTransforms\" + runCount.getAndIncrement())); \/\/$NON-NLS-1$\n+\n+\t\tassertTrue(registry.hasPendingTransforms(Type.getInternalName(InstrumentMeConverter.class)));\n+\n+\t\tTransformer jfrTransformer = new Transformer(registry);\n+\t\tbyte[] transformedClass = jfrTransformer.transform(InstrumentMeConverter.class.getClassLoader(),\n+\t\t\t\tType.getInternalName(InstrumentMeConverter.class), InstrumentMeConverter.class, null,\n+\t\t\t\tTestToolkit.getByteCode(InstrumentMeConverter.class));\n+\n+\t\tassertNotNull(transformedClass);\n+\t\tassertFalse(registry.hasPendingTransforms(Type.getInternalName(InstrumentMeConverter.class)));\n+\n+\t\tTraceClassVisitor visitor = new TraceClassVisitor(new PrintWriter(System.out));\n+\t\tCheckClassAdapter checkAdapter = new CheckClassAdapter(visitor);\n+\t\tClassReader reader = new ClassReader(transformedClass);\n+\t\treader.accept(checkAdapter, 0);\n+\t\tSystem.out.println(registry);\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/TestConverterTransforms.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,242 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.agent.converters.test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.junit.Test;\n+import org.openjdk.jmc.agent.impl.MalformedConverterException;\n+import org.openjdk.jmc.agent.impl.ResolvedConvertable;\n+import org.openjdk.jmc.agent.test.Gurka;\n+\n+public class TestResolver {\n+\tprivate static final String CLASS_GURK_INT = GurkConverterInt.class.getName();\n+\tprivate static final String CLASS_NUMBER_CONVERTER = ConverterNumber.class.getName();\n+\tprivate static final String CLASS_MALFORMED = \"notavalidtransformer\";\n+\tprivate static final String CLASS_CUSTOM_INT = GurkCustomConverterInt.class.getName();\n+\tprivate static final String CLASS_MULTI_CUSTOM = GurkMultiCustomConverter.class.getName();\n+\tprivate static final String CLASS_MULTI_DEFAULT = GurkMultiDefaultConverter.class.getName();\n+\n+\tprivate static final String DEFINITION_GURK_INT_DEFAULT_METHOD = CLASS_GURK_INT\n+\t\t\t+ \".convert(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)I\";\n+\tprivate static final String DEFINITION_CUSTOM_INT = CLASS_CUSTOM_INT\n+\t\t\t+ \".convertCustom(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)I\";\n+\tprivate static final String DEFINITION_MULTI_CUSTOM_INT = CLASS_MULTI_CUSTOM\n+\t\t\t+ \".convertCustomInt(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)I\";\n+\tprivate static final String DEFINITION_MULTI_CUSTOM_DOUBLE = CLASS_MULTI_CUSTOM\n+\t\t\t+ \".convertCustomDouble(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)D\";\n+\tprivate static final String DEFINITION_MULTI_CUSTOM_STRING = CLASS_MULTI_CUSTOM\n+\t\t\t+ \".convertCustomString(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)Ljava\/lang\/String;\";\n+\tprivate static final String DEFINITION_MULTI_DEFAULT_GURKA = CLASS_MULTI_DEFAULT\n+\t\t\t+ \".convert(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)I\";\n+\tprivate static final String DEFINITION_MULTI_DEFAULT_STRING = CLASS_MULTI_DEFAULT + \".convert(Ljava\/lang\/String;)I\";\n+\tprivate static final String DEFINITION_MULTI_DEFAULT_DOUBLE = CLASS_MULTI_DEFAULT + \".convert(Ljava\/lang\/Double;)I\";\n+\tprivate static final String DEFINITION_MULTI_DEFAULT_INTEGER = CLASS_MULTI_DEFAULT\n+\t\t\t+ \".convert(Ljava\/lang\/Integer;)I\";\n+\tprivate static final String DEFINITION_MULTI_DEFAULT_EXCEPTION = CLASS_MULTI_DEFAULT\n+\t\t\t+ \".convert(java\/lang\/Exception;)I\";\n+\n+\tpublic static int convert(Gurka gurka) {\n+\t\treturn (int) gurka.getID();\n+\t}\n+\n+\tpublic static int convert(String string) {\n+\t\treturn (int) Integer.valueOf(string);\n+\t}\n+\n+\tpublic static String convert(Exception exception) {\n+\t\treturn exception.getMessage();\n+\t}\n+\n+\t@Test\n+\tpublic void testResolveDefault() throws MalformedConverterException {\n+\t\tResolvedConvertable convertable = new ResolvedConvertable(CLASS_GURK_INT, Gurka.class);\n+\t\tassertEquals(CLASS_GURK_INT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t}\n+\n+\t@Test\n+\tpublic void testResolveDefaultSpecified() throws MalformedConverterException {\n+\t\tResolvedConvertable convertable = new ResolvedConvertable(DEFINITION_GURK_INT_DEFAULT_METHOD, Gurka.class);\n+\t\tassertEquals(CLASS_GURK_INT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t}\n+\n+\t@Test\n+\tpublic void testResolveCustom() throws MalformedConverterException {\n+\t\tResolvedConvertable convertable = new ResolvedConvertable(DEFINITION_CUSTOM_INT, Gurka.class);\n+\t\tassertEquals(CLASS_CUSTOM_INT, convertable.getConverterClass().getName());\n+\t\tassertEquals(\"convertCustom\", convertable.getConverterMethod().getName());\n+\t}\n+\n+\t@Test\n+\tpublic void testResolveMulti() throws MalformedConverterException {\n+\t\tResolvedConvertable convertable = new ResolvedConvertable(DEFINITION_MULTI_CUSTOM_INT, Gurka.class);\n+\t\tassertEquals(CLASS_MULTI_CUSTOM, convertable.getConverterClass().getName());\n+\t\tassertEquals(\"convertCustomInt\", convertable.getConverterMethod().getName());\n+\n+\t\tconvertable = new ResolvedConvertable(DEFINITION_MULTI_CUSTOM_DOUBLE, Gurka.class);\n+\t\tassertEquals(CLASS_MULTI_CUSTOM, convertable.getConverterClass().getName());\n+\t\tassertEquals(\"convertCustomDouble\", convertable.getConverterMethod().getName());\n+\n+\t\tconvertable = new ResolvedConvertable(DEFINITION_MULTI_CUSTOM_STRING, Gurka.class);\n+\t\tassertEquals(CLASS_MULTI_CUSTOM, convertable.getConverterClass().getName());\n+\t\tassertEquals(\"convertCustomString\", convertable.getConverterMethod().getName());\n+\n+\t\ttry {\n+\t\t\tnew ResolvedConvertable(CLASS_MULTI_CUSTOM, Gurka.class);\n+\t\t\tassertTrue(\"Should have reached an exception\", false);\n+\t\t} catch (MalformedConverterException e) {\n+\t\t}\n+\t}\n+\n+\t\/*\n+\t * public static int convert(Gurka gurka) { return (int) gurka.getID(); }\n+\t * \n+\t * public static int convert(String string) { return (int) Integer.valueOf(string); }\n+\t * \n+\t * public static String convert(Exception exception) { return exception.getMessage(); }\n+\t * \n+\t * public static int convert(Double value) { return value.intValue(); }\n+\t * \n+\t * public static int convert(Integer value) { return value.intValue(); } }\n+\t *\/\n+\t@Test\n+\tpublic void testResolveMultiDefaults() throws MalformedConverterException {\n+\t\tResolvedConvertable convertable = new ResolvedConvertable(DEFINITION_MULTI_DEFAULT_GURKA, Gurka.class);\n+\t\tassertEquals(CLASS_MULTI_DEFAULT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t\tassertEquals(int.class, convertable.getConverterMethod().getReturnType());\n+\n+\t\tconvertable = new ResolvedConvertable(CLASS_MULTI_DEFAULT, Gurka.class);\n+\t\tassertEquals(CLASS_MULTI_DEFAULT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t\tassertEquals(int.class, convertable.getConverterMethod().getReturnType());\n+\n+\t\tconvertable = new ResolvedConvertable(DEFINITION_MULTI_DEFAULT_STRING, String.class);\n+\t\tassertEquals(CLASS_MULTI_DEFAULT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t\tassertEquals(int.class, convertable.getConverterMethod().getReturnType());\n+\n+\t\tconvertable = new ResolvedConvertable(CLASS_MULTI_DEFAULT, String.class);\n+\t\tassertEquals(CLASS_MULTI_DEFAULT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t\tassertEquals(int.class, convertable.getConverterMethod().getReturnType());\n+\n+\t\tconvertable = new ResolvedConvertable(DEFINITION_MULTI_DEFAULT_EXCEPTION, Exception.class);\n+\t\tassertEquals(CLASS_MULTI_DEFAULT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t\tassertEquals(String.class, convertable.getConverterMethod().getReturnType());\n+\n+\t\tconvertable = new ResolvedConvertable(CLASS_MULTI_DEFAULT, Exception.class);\n+\t\tassertEquals(CLASS_MULTI_DEFAULT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t\tassertEquals(String.class, convertable.getConverterMethod().getReturnType());\n+\n+\t\tconvertable = new ResolvedConvertable(DEFINITION_MULTI_DEFAULT_INTEGER, Integer.class);\n+\t\tassertEquals(CLASS_MULTI_DEFAULT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t\tassertEquals(int.class, convertable.getConverterMethod().getReturnType());\n+\n+\t\tconvertable = new ResolvedConvertable(CLASS_MULTI_DEFAULT, Integer.class);\n+\t\tassertEquals(CLASS_MULTI_DEFAULT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t\tassertEquals(int.class, convertable.getConverterMethod().getReturnType());\n+\n+\t\tconvertable = new ResolvedConvertable(DEFINITION_MULTI_DEFAULT_DOUBLE, Double.class);\n+\t\tassertEquals(CLASS_MULTI_DEFAULT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t\tassertEquals(int.class, convertable.getConverterMethod().getReturnType());\n+\n+\t\tconvertable = new ResolvedConvertable(CLASS_MULTI_DEFAULT, Double.class);\n+\t\tassertEquals(CLASS_MULTI_DEFAULT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t\tassertEquals(int.class, convertable.getConverterMethod().getReturnType());\n+\t}\n+\n+\t@Test\n+\tpublic void testResolveMultiDefaultsWrongReturnType() throws MalformedConverterException {\n+\t\ttry {\n+\t\t\tnew ResolvedConvertable(DEFINITION_MULTI_DEFAULT_EXCEPTION, Class.class);\n+\t\t\tassertTrue(\"Should have reached an exception\", false);\n+\t\t} catch (MalformedConverterException e) {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testResolveSubclass() throws MalformedConverterException {\n+\t\tResolvedConvertable convertable = new ResolvedConvertable(CLASS_NUMBER_CONVERTER, Double.class);\n+\t\tassertEquals(CLASS_NUMBER_CONVERTER, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t\tassertEquals(long.class, convertable.getConverterMethod().getReturnType());\n+\t}\n+\n+\t@Test\n+\tpublic void testResolveCustomWithoutMethodSpecified() throws MalformedConverterException {\n+\t\ttry {\n+\t\t\tnew ResolvedConvertable(CLASS_CUSTOM_INT, Gurka.class);\n+\t\t\tassertTrue(\"Should have reached an exception\", false);\n+\t\t} catch (MalformedConverterException e) {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testResolveDefaultWrongArgumentType() throws MalformedConverterException {\n+\t\ttry {\n+\t\t\tnew ResolvedConvertable(CLASS_GURK_INT, Double.class);\n+\t\t\tassertTrue(\"Should have reached an exception\", false);\n+\t\t} catch (MalformedConverterException e) {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testResolveNoType() throws MalformedConverterException {\n+\t\ttry {\n+\t\t\tnew ResolvedConvertable(CLASS_GURK_INT, (Class<?>) null);\n+\t\t\tassertTrue(\"Should have reached an exception\", false);\n+\t\t} catch (MalformedConverterException e) {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testResolveMalformed() throws MalformedConverterException {\n+\t\ttry {\n+\t\t\tnew ResolvedConvertable(CLASS_MALFORMED, int.class);\n+\t\t\tassertTrue(\"Should have reached an exception\", false);\n+\t\t} catch (MalformedConverterException e) {\n+\t\t}\n+\t}\n+\n+}\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/TestResolver.java","additions":242,"deletions":0,"binary":false,"changes":242,"status":"added"},{"patch":"@@ -52,1 +52,1 @@\n-\tpublic final static Gurka createGurka() {\n+\tpublic static final Gurka createGurka() {\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/test\/Gurka.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-\tprivate final static class Runner implements Runnable {\n+\tprivate static final class Runner implements Runnable {\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/test\/InstrumentMe.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2020 Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020 Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n@@ -37,5 +37,0 @@\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertTrue;\n-\n-import java.io.ByteArrayInputStream;\n@@ -43,2 +38,0 @@\n-import java.lang.management.ManagementFactory;\n-import java.util.List;\n@@ -47,3 +40,0 @@\n-import javax.management.JMX;\n-import javax.management.ObjectName;\n-\n@@ -51,1 +41,0 @@\n-import org.junit.Before;\n@@ -53,7 +42,0 @@\n-import org.objectweb.asm.Type;\n-import org.openjdk.jmc.agent.TransformDescriptor;\n-import org.openjdk.jmc.agent.TransformRegistry;\n-import org.openjdk.jmc.agent.Transformer;\n-import org.openjdk.jmc.agent.impl.DefaultTransformRegistry;\n-import org.openjdk.jmc.agent.jfr.JFRTransformDescriptor;\n-import org.openjdk.jmc.agent.jmx.AgentControllerMXBean;\n@@ -73,15 +55,0 @@\n-\tprivate static final String AGENT_OBJECT_NAME = \"org.openjdk.jmc.jfr.agent:type=AgentController\"; \/\/$NON-NLS-1$\n-\tprivate static final String EVENT_ID = \"demo.jfr.test6\";\n-\tprivate static final String EVENT_NAME = \"JFR Hello World Event 1 %TEST_NAME%\";\n-\tprivate static final String EVENT_DESCRIPTION = \"JFR Hello World Event 1 %TEST_NAME%\";\n-\tprivate static final String EVENT_PATH = \"demo\/jfrhelloworldevent\";\n-\tprivate static final String EVENT_CLASS_NAME = \"org.openjdk.jmc.agent.test.TestDummy\";\n-\tprivate static final String METHOD_NAME = \"testWithoutException\";\n-\tprivate static final String METHOD_DESCRIPTOR = \"()V\";\n-\n-\tprivate static final String XML_DESCRIPTION = \"<jfragent>\" + \"<events>\" + \"<event id=\\\"\" + EVENT_ID + \"\\\">\"\n-\t\t\t+ \"<name>\" + EVENT_NAME + \"<\/name>\" + \"<description>\" + EVENT_DESCRIPTION + \"<\/description>\" + \"<path>\"\n-\t\t\t+ EVENT_PATH + \"<\/path>\" + \"<stacktrace>true<\/stacktrace>\" + \"<class>\" + EVENT_CLASS_NAME + \"<\/class>\"\n-\t\t\t+ \"<method>\" + \"<name>\" + METHOD_NAME + \"<\/name>\" + \"<descriptor>\" + METHOD_DESCRIPTOR + \"<\/descriptor>\"\n-\t\t\t+ \"<\/method>\" + \"<location>WRAP<\/location>\" + \"<\/event>\" + \"<\/events>\" + \"<\/jfragent>\";\n-\n@@ -92,1 +59,1 @@\n-\t\t\tClass reproducer = c.loadClass(TestDummy.class.getName());\n+\t\t\tClass<?> reproducer = c.loadClass(TestDummy.class.getName());\n@@ -103,6 +70,0 @@\n-\tprivate void doDefineEventProbes(String xmlDescription) throws Exception {\n-\t\tAgentControllerMXBean mbean = JMX.newMXBeanProxy(ManagementFactory.getPlatformMBeanServer(),\n-\t\t\t\tnew ObjectName(AGENT_OBJECT_NAME), AgentControllerMXBean.class, false);\n-\t\tmbean.defineEventProbes(xmlDescription);\n-\t}\n-\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/test\/TestCustomClassloader.java","additions":3,"deletions":42,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-import org.openjdk.jmc.agent.jfrnext.impl.JFRNextEventClassGenerator;\n+import org.openjdk.jmc.agent.jfr.impl.JFREventClassGenerator;\n@@ -150,1 +150,1 @@\n-\t\tbyte[] eventClass = JFRNextEventClassGenerator.generateEventClass(eventTd, InstrumentMe.class);\n+\t\tbyte[] eventClass = JFREventClassGenerator.generateEventClass(eventTd, InstrumentMe.class);\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/test\/TestDefineEventProbes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import static org.junit.Assert.assertEquals;\n+\n@@ -56,1 +58,1 @@\n-\t\tAssert.assertTrue(jfrTds.length == 1);\n+\t\tassertEquals(1, jfrTds.length);\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/test\/TestRetrieveCurrentTransforms.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,1 +74,5 @@\n-\t\tmbean.defineEventProbes(invalidConfiguration);\n+\t\ttry {\n+\t\t\tmbean.defineEventProbes(invalidConfiguration);\n+\t\t} catch (Exception e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/test\/TestRetrieveEventProbes.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-\t\t\tbuilder.append(Character.toString((char) (RND.nextInt(26) + 64)));\n+\t\t\tbuilder.append(Character.toString((char) (RND.nextInt(26) + 65)));\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/test\/util\/TestToolkit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,3 +40,3 @@\n-\t\t\t This will cause toString to be called for array elements and objects other \n-\t\t\t than strings, which in turn can cause trouble if the toString method is badly \n-\t\t\t implemented. Use with care. -->\n+\t\t\tThis will cause toString to be called for array elements and objects other \n+\t\t\tthan strings, which in turn can cause trouble if the toString method is badly \n+\t\t\timplemented. Use with care. -->\n@@ -44,2 +44,2 @@\n-\t\t<!-- Allows converters to be used. \n-\t\t     See the org.openjdk.jmc.agent.converters package for more information. -->\n+\t\t<!-- Allows converters to be used. See the org.openjdk.jmc.agent.converters \n+\t\t\tpackage for more information. -->\n@@ -48,1 +48,2 @@\n-\t<!-- Event probe declarations -->\n+\n+\t<!-- Converter test event probes -->\n@@ -51,2 +52,3 @@\n-\t\t\t<name>ConverterEventString-%TEST_NAME%<\/name>\n-\t\t\t<description>Defined in the xml file and added by the agent. Should transform the Gurka parameter to\n+\t\t\t<name>ConverterEventString<\/name>\n+\t\t\t<description>Defined in the xml file and added by the agent. Should\n+\t\t\t\ttransform the Gurka parameter to\n@@ -61,1 +63,1 @@\n-\t\t\t\t<descriptor>(Lorg\/openjdk\/jmc\/bciagent\/test\/Gurka;)V<\/descriptor>\n+\t\t\t\t<descriptor>(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)V<\/descriptor>\n@@ -64,2 +66,3 @@\n-\t\t\t\t\t\t<name>Gurka Attribute<\/name>\n-\t\t\t\t\t\t<description>The one and only converted Gurk-parameter<\/description>\n+\t\t\t\t\t\t<name>String Gurka<\/name>\n+\t\t\t\t\t\t<description>The one and only converted Gurk-parameter\n+\t\t\t\t\t\t<\/description>\n@@ -67,1 +70,2 @@\n-\t\t\t\t\t\t<converter>org.openjdk.jmc.agent.converters.test.GurkConverterString<\/converter>\n+\t\t\t\t\t\t<converter>org.openjdk.jmc.agent.converters.test.GurkConverterString\n+\t\t\t\t\t\t<\/converter>\n@@ -73,2 +77,3 @@\n-\t\t\t<name>ConverterEventInt-%TEST_NAME%<\/name>\n-\t\t\t<description>Defined in the xml file and added by the agent. Should transform the Gurka parameter to an\n+\t\t\t<name>ConverterEventInt<\/name>\n+\t\t\t<description>Defined in the xml file and added by the agent. Should\n+\t\t\t\ttransform the Gurka parameter to an\n@@ -79,1 +84,2 @@\n-\t\t\t<class>org.openjdk.jmc.agent.converters.test.InstrumentMeConverter<\/class>\n+\t\t\t<class>org.openjdk.jmc.agent.converters.test.InstrumentMeConverter\n+\t\t\t<\/class>\n@@ -82,1 +88,1 @@\n-\t\t\t\t<descriptor>(Lorg\/openjdk\/jmc\/bciagent\/test\/Gurka;)V<\/descriptor>\n+\t\t\t\t<descriptor>(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)V<\/descriptor>\n@@ -85,2 +91,3 @@\n-\t\t\t\t\t\t<name>Gurka Attribute<\/name>\n-\t\t\t\t\t\t<description>The one and only converted Gurk-parameter<\/description>\n+\t\t\t\t\t\t<name>Int Gurka<\/name>\n+\t\t\t\t\t\t<description>The one and only converted Gurk-parameter\n+\t\t\t\t\t\t<\/description>\n@@ -88,1 +95,2 @@\n-\t\t\t\t\t\t<converter>org.openjdk.jmc.agent.converters.test.GurkConverterInt<\/converter>\n+\t\t\t\t\t\t<converter>org.openjdk.jmc.agent.converters.test.GurkConverterInt\n+\t\t\t\t\t\t<\/converter>\n@@ -95,2 +103,3 @@\n-\t\t\t<name>ConverterEventLong-%TEST_NAME%<\/name>\n-\t\t\t<description>Defined in the xml file and added by the agent. Should transform the Gurka parameter to a\n+\t\t\t<name>ConverterEventLong<\/name>\n+\t\t\t<description>Defined in the xml file and added by the agent. Should\n+\t\t\t\ttransform the Gurka parameter to a\n@@ -101,1 +110,2 @@\n-\t\t\t<class>org.openjdk.jmc.agent.converters.test.InstrumentMeConverter<\/class>\n+\t\t\t<class>org.openjdk.jmc.agent.converters.test.InstrumentMeConverter\n+\t\t\t<\/class>\n@@ -104,1 +114,1 @@\n-\t\t\t\t<descriptor>(Lorg\/openjdk\/jmc\/bciagent\/test\/Gurka;)V<\/descriptor>\n+\t\t\t\t<descriptor>(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)V<\/descriptor>\n@@ -107,2 +117,3 @@\n-\t\t\t\t\t\t<name>Gurka Attribute<\/name>\n-\t\t\t\t\t\t<description>The one and only converted Gurk-parameter<\/description>\n+\t\t\t\t\t\t<name>Long Gurka<\/name>\n+\t\t\t\t\t\t<description>The one and only converted Gurk-parameter\n+\t\t\t\t\t\t<\/description>\n@@ -110,1 +121,2 @@\n-\t\t\t\t\t\t<converter>org.openjdk.jmc.agent.converters.test.GurkConverterLong<\/converter>\n+\t\t\t\t\t\t<converter>org.openjdk.jmc.agent.converters.test.GurkConverterLong\n+\t\t\t\t\t\t<\/converter>\n@@ -117,2 +129,3 @@\n-\t\t\t<name>ConverterEventFloat-%TEST_NAME%<\/name>\n-\t\t\t<description>Defined in the xml file and added by the agent. Should transform the Gurka parameter to a\n+\t\t\t<name>ConverterEventFloat<\/name>\n+\t\t\t<description>Defined in the xml file and added by the agent. Should\n+\t\t\t\ttransform the Gurka parameter to a\n@@ -122,1 +135,2 @@\n-\t\t\t<class>org.openjdk.jmc.agent.converters.test.InstrumentMeConverter<\/class>\n+\t\t\t<class>org.openjdk.jmc.agent.converters.test.InstrumentMeConverter\n+\t\t\t<\/class>\n@@ -125,1 +139,1 @@\n-\t\t\t\t<descriptor>(Lorg\/openjdk\/jmc\/bciagent\/test\/Gurka;)V<\/descriptor>\n+\t\t\t\t<descriptor>(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)V<\/descriptor>\n@@ -128,2 +142,3 @@\n-\t\t\t\t\t\t<name>Gurka Attribute<\/name>\n-\t\t\t\t\t\t<description>The one and only converted Gurk-parameter<\/description>\n+\t\t\t\t\t\t<name>Float Gurka<\/name>\n+\t\t\t\t\t\t<description>The one and only converted Gurk-parameter\n+\t\t\t\t\t\t<\/description>\n@@ -131,1 +146,2 @@\n-\t\t\t\t\t\t<converter>org.openjdk.jmc.agent.converters.test.GurkConverterFloat<\/converter>\n+\t\t\t\t\t\t<converter>org.openjdk.jmc.agent.converters.test.GurkConverterFloat\n+\t\t\t\t\t\t<\/converter>\n@@ -138,3 +154,4 @@\n-\t\t\t<name>ConverterEventDouble-%TEST_NAME%<\/name>\n-\t\t\t<description>Defined in the xml file and added by the agent. Should transform the Gurka parameter to a\n-\t\t\t\tfloat.\n+\t\t\t<name>ConverterEventDouble<\/name>\n+\t\t\t<description>Defined in the xml file and added by the agent. Should\n+\t\t\t\ttransform the Gurka parameter to a\n+\t\t\t\tdouble.\n@@ -144,1 +161,2 @@\n-\t\t\t<class>org.openjdk.jmc.agent.converters.test.InstrumentMeConverter<\/class>\n+\t\t\t<class>org.openjdk.jmc.agent.converters.test.InstrumentMeConverter\n+\t\t\t<\/class>\n@@ -146,2 +164,171 @@\n-\t\t\t\t<name>printGurkaToFloat<\/name>\n-\t\t\t\t<descriptor>(Lorg\/openjdk\/jmc\/bciagent\/test\/Gurka;)V<\/descriptor>\n+\t\t\t\t<name>printGurkaToDouble<\/name>\n+\t\t\t\t<descriptor>(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)V<\/descriptor>\n+\t\t\t\t<parameters>\n+\t\t\t\t\t<parameter index=\"0\">\n+\t\t\t\t\t\t<name>Double Gurka<\/name>\n+\t\t\t\t\t\t<description>The one and only converted Gurk-parameter\n+\t\t\t\t\t\t<\/description>\n+\t\t\t\t\t\t<contenttype>None<\/contenttype>\n+\t\t\t\t\t\t<converter>org.openjdk.jmc.agent.converters.test.GurkConverterDouble\n+\t\t\t\t\t\t<\/converter>\n+\t\t\t\t\t<\/parameter>\n+\t\t\t\t<\/parameters>\n+\t\t\t<\/method>\n+\t\t\t<location>WRAP<\/location>\n+\t\t<\/event>\n+\t\t<event id=\"demo.jfr.convertertest.File\">\n+\t\t\t<name>ConverterEventFile<\/name>\n+\t\t\t<description>Defined in the xml file and added by the agent. Should\n+\t\t\t\ttransform the File parameter to a\n+\t\t\t\tString.\n+\t\t\t<\/description>\n+\t\t\t<path>demo\/converterevents<\/path>\n+\t\t\t<stacktrace>true<\/stacktrace>\n+\t\t\t<class>org.openjdk.jmc.agent.converters.test.InstrumentMeConverter\n+\t\t\t<\/class>\n+\t\t\t<method>\n+\t\t\t\t<name>printFileToString<\/name>\n+\t\t\t\t<descriptor>(Ljava\/io\/File;)V<\/descriptor>\n+\t\t\t\t<parameters>\n+\t\t\t\t\t<parameter index=\"0\">\n+\t\t\t\t\t\t<name>Default File<\/name>\n+\t\t\t\t\t\t<description>The converted File-parameter<\/description>\n+\t\t\t\t\t\t<contenttype>None<\/contenttype>\n+\t\t\t\t\t\t<converter>org.openjdk.jmc.agent.converters.FileConverter\n+\t\t\t\t\t\t<\/converter>\n+\t\t\t\t\t<\/parameter>\n+\t\t\t\t<\/parameters>\n+\t\t\t<\/method>\n+\t\t\t<location>WRAP<\/location>\n+\t\t<\/event>\n+\t\t<event id=\"demo.jfr.convertertest.URI\">\n+\t\t\t<name>ConverterEventUri<\/name>\n+\t\t\t<description>Defined in the xml file and added by the agent. Should\n+\t\t\t\ttransform the URI parameter to a\n+\t\t\t\tString using the standard toString\n+\t\t\t\tbehaviour.\n+\t\t\t<\/description>\n+\t\t\t<path>demo\/converterevents<\/path>\n+\t\t\t<stacktrace>true<\/stacktrace>\n+\t\t\t<class>org.openjdk.jmc.agent.converters.test.InstrumentMeConverter\n+\t\t\t<\/class>\n+\t\t\t<method>\n+\t\t\t\t<name>printUriToString<\/name>\n+\t\t\t\t<descriptor>(Ljava\/net\/URI;)V<\/descriptor>\n+\t\t\t\t<parameters>\n+\t\t\t\t\t<parameter index=\"0\">\n+\t\t\t\t\t\t<name>String URI<\/name>\n+\t\t\t\t\t\t<description>The converted URI-parameter<\/description>\n+\t\t\t\t\t\t<contenttype>None<\/contenttype>\n+\t\t\t\t\t<\/parameter>\n+\t\t\t\t<\/parameters>\n+\t\t\t<\/method>\n+\t\t\t<location>WRAP<\/location>\n+\t\t<\/event>\n+\t\t<event id=\"demo.jfr.convertertest.URI\">\n+\t\t\t<name>ConverterEventNumber<\/name>\n+\t\t\t<description>Defined in the xml file and added by the agent. Should\n+\t\t\t\ttransform the Number parameter to a\n+\t\t\t\tdouble.\n+\t\t\t<\/description>\n+\t\t\t<path>demo\/converterevents<\/path>\n+\t\t\t<stacktrace>true<\/stacktrace>\n+\t\t\t<class>org.openjdk.jmc.agent.converters.test.InstrumentMeConverter\n+\t\t\t<\/class>\n+\t\t\t<method>\n+\t\t\t\t<name>printNumber<\/name>\n+\t\t\t\t<descriptor>(Ljava\/lang\/Number;)V<\/descriptor>\n+\t\t\t\t<parameters>\n+\t\t\t\t\t<parameter index=\"0\">\n+\t\t\t\t\t\t<name>Number<\/name>\n+\t\t\t\t\t\t<description>The converted Number-parameter<\/description>\n+\t\t\t\t\t\t<contenttype>None<\/contenttype>\n+\t\t\t\t\t\t<converter>org.openjdk.jmc.agent.converters.test.ConverterNumber\n+\t\t\t\t\t\t<\/converter>\n+\t\t\t\t\t<\/parameter>\n+\t\t\t\t<\/parameters>\n+\t\t\t<\/method>\n+\t\t\t<location>WRAP<\/location>\n+\t\t<\/event>\n+\n+\t\t<!-- Multi and custom converters -->\n+\t\t<event id=\"demo.jfr.convertertest.URI\">\n+\t\t\t<name>ConverterEventMultiCustomInt<\/name>\n+\t\t\t<description>Testing picking the right method.\n+\t\t\t<\/description>\n+\t\t\t<path>demo\/converterevents<\/path>\n+\t\t\t<stacktrace>true<\/stacktrace>\n+\t\t\t<class>org.openjdk.jmc.agent.converters.test.InstrumentMeConverter\n+\t\t\t<\/class>\n+\t\t\t<method>\n+\t\t\t\t<name>printIntMultiCustom<\/name>\n+\t\t\t\t<descriptor>(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)V<\/descriptor>\n+\t\t\t\t<parameters>\n+\t\t\t\t\t<parameter index=\"0\">\n+\t\t\t\t\t\t<name>Number as Int<\/name>\n+\t\t\t\t\t\t<description>The converted Gurk-parameter<\/description>\n+\t\t\t\t\t\t<contenttype>None<\/contenttype>\n+\t\t\t\t\t\t<converter>org.openjdk.jmc.agent.converters.test.GurkMultiCustomConverter.convertCustomInt(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)I\n+\t\t\t\t\t\t<\/converter>\n+\t\t\t\t\t<\/parameter>\n+\t\t\t\t<\/parameters>\n+\t\t\t<\/method>\n+\t\t\t<location>WRAP<\/location>\n+\t\t<\/event>\n+\t\t<event id=\"demo.jfr.convertertest.URI\">\n+\t\t\t<name>ConverterEventMultiCustomDouble<\/name>\n+\t\t\t<description>Testing picking the right method.\n+\t\t\t<\/description>\n+\t\t\t<path>demo\/converterevents<\/path>\n+\t\t\t<stacktrace>true<\/stacktrace>\n+\t\t\t<class>org.openjdk.jmc.agent.converters.test.InstrumentMeConverter\n+\t\t\t<\/class>\n+\t\t\t<method>\n+\t\t\t\t<name>printDoubleMultiCustom<\/name>\n+\t\t\t\t<descriptor>(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)V<\/descriptor>\n+\t\t\t\t<parameters>\n+\t\t\t\t\t<parameter index=\"0\">\n+\t\t\t\t\t\t<name>Number as Double<\/name>\n+\t\t\t\t\t\t<description>The converted Gurk-parameter<\/description>\n+\t\t\t\t\t\t<contenttype>None<\/contenttype>\n+\t\t\t\t\t\t<converter>org.openjdk.jmc.agent.converters.test.GurkMultiCustomConverter.convertCustomDouble(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)D\n+\t\t\t\t\t\t<\/converter>\n+\t\t\t\t\t<\/parameter>\n+\t\t\t\t<\/parameters>\n+\t\t\t<\/method>\n+\t\t\t<location>WRAP<\/location>\n+\t\t<\/event>\n+\t\t<event id=\"demo.jfr.convertertest.URI\">\n+\t\t\t<name>ConverterEventMultiDefaultLong<\/name>\n+\t\t\t<description>Testing picking the right method.\n+\t\t\t<\/description>\n+\t\t\t<path>demo\/converterevents<\/path>\n+\t\t\t<stacktrace>true<\/stacktrace>\n+\t\t\t<class>org.openjdk.jmc.agent.converters.test.InstrumentMeConverter\n+\t\t\t<\/class>\n+\t\t\t<method>\n+\t\t\t\t<name>printLongMultiDefault<\/name>\n+\t\t\t\t<descriptor>(Ljava\/lang\/Long;)V<\/descriptor>\n+\t\t\t\t<parameters>\n+\t\t\t\t\t<parameter index=\"0\">\n+\t\t\t\t\t\t<name>Long as int<\/name>\n+\t\t\t\t\t\t<description>The converted Long-parameter<\/description>\n+\t\t\t\t\t\t<contenttype>None<\/contenttype>\n+\t\t\t\t\t\t<converter>org.openjdk.jmc.agent.converters.test.GurkMultiDefaultConverter\n+\t\t\t\t\t\t<\/converter>\n+\t\t\t\t\t<\/parameter>\n+\t\t\t\t<\/parameters>\n+\t\t\t<\/method>\n+\t\t\t<location>WRAP<\/location>\n+\t\t<\/event>\n+\t\t<event id=\"demo.jfr.convertertest.URI\">\n+\t\t\t<name>ConverterEventMultiDefaultDouble<\/name>\n+\t\t\t<description>Testing picking the right method.\n+\t\t\t<\/description>\n+\t\t\t<path>demo\/converterevents<\/path>\n+\t\t\t<stacktrace>true<\/stacktrace>\n+\t\t\t<class>org.openjdk.jmc.agent.converters.test.InstrumentMeConverter\n+\t\t\t<\/class>\n+\t\t\t<method>\n+\t\t\t\t<name>printDoubleMultiDefault<\/name>\n+\t\t\t\t<descriptor>(Ljava\/lang\/Double;)V<\/descriptor>\n@@ -150,2 +337,2 @@\n-\t\t\t\t\t\t<name>Gurka Attribute<\/name>\n-\t\t\t\t\t\t<description>The one and only converted Gurk-parameter<\/description>\n+\t\t\t\t\t\t<name>Double as Int<\/name>\n+\t\t\t\t\t\t<description>The converted Double-parameter<\/description>\n@@ -153,1 +340,2 @@\n-\t\t\t\t\t\t<converter>org.openjdk.jmc.agent.converters.test.GurkConverterFloat<\/converter>\n+\t\t\t\t\t\t<converter>org.openjdk.jmc.agent.converters.test.GurkMultiDefaultConverter\n+\t\t\t\t\t\t<\/converter>\n@@ -160,1 +348,1 @@\n-<\/jfragent>\n\\ No newline at end of file\n+<\/jfragent>\n","filename":"agent\/src\/test\/resources\/org\/openjdk\/jmc\/agent\/converters\/test\/jfrprobes_template.xml","additions":231,"deletions":43,"binary":false,"changes":274,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+datadog\n","filename":"configuration\/ide\/eclipse\/dictionary\/dictionary.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}