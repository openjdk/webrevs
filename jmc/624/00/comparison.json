{"files":[{"patch":"@@ -2,1 +2,1 @@\n-#  Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-copyright=Copyright \\u00A9 2018, 2022, Oracle and\/or its affiliates.\n+copyright=Copyright \\u00A9 2018, 2025, Oracle and\/or its affiliates.\n","filename":"application\/org.openjdk.jmc.feature.console.ui.subscriptions\/feature.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-#  Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-copyright=Copyright \\u00A9 2018, 2022, Oracle and\/or its affiliates.\n+copyright=Copyright \\u00A9 2018, 2025, Oracle and\/or its affiliates.\n","filename":"application\/org.openjdk.jmc.feature.flightrecorder.ext.jfx\/feature.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -454,0 +454,22 @@\n+\tpublic static class EndsWith extends AttributeValue<String> {\n+\t\tEndsWith(String substring, ICanonicalAccessorFactory<String> attribute) {\n+\t\t\tsuper(Kind.ENDS_WITH, attribute, substring);\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected Predicate<IItem> getPredicate(IMemberAccessor<? extends String, IItem> accessor, String substring) {\n+\t\t\treturn PredicateToolkit.endsWith(accessor, substring);\n+\t\t}\n+\t}\n+\n+\tpublic static class NotEndsWith extends AttributeValue<String> {\n+\t\tNotEndsWith(String substring, ICanonicalAccessorFactory<String> attribute) {\n+\t\t\tsuper(Kind.NOT_ENDS_WITH, attribute, substring);\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected Predicate<IItem> getPredicate(IMemberAccessor<? extends String, IItem> accessor, String substring) {\n+\t\t\treturn PredicateToolkit.not(PredicateToolkit.endsWith(accessor, substring));\n+\t\t}\n+\t}\n+\n@@ -594,0 +616,8 @@\n+\tpublic static IItemFilter endsWith(ICanonicalAccessorFactory<String> attribute, String substring) {\n+\t\treturn new EndsWith(substring, attribute);\n+\t}\n+\n+\tpublic static IItemFilter notEndsWith(ICanonicalAccessorFactory<String> attribute, String substring) {\n+\t\treturn new NotEndsWith(substring, attribute);\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.common\/src\/main\/java\/org\/openjdk\/jmc\/common\/item\/ItemFilters.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,2 @@\n+\t\tENDS_WITH,\n+\t\tNOT_ENDS_WITH(ENDS_WITH),\n@@ -164,0 +166,4 @@\n+\t\tcase ENDS_WITH:\n+\t\t\treturn ItemFilters.endsWith(readStringAttribute(memento), memento.getAttribute(KEY_VALUE));\n+\t\tcase NOT_ENDS_WITH:\n+\t\t\treturn ItemFilters.notEndsWith(readStringAttribute(memento), memento.getAttribute(KEY_VALUE));\n","filename":"core\/org.openjdk.jmc.common\/src\/main\/java\/org\/openjdk\/jmc\/common\/item\/PersistableItemFilter.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -644,0 +644,23 @@\n+\t\/**\n+\t * Create a predicate that checks if a string value ends with a specified substring.\n+\t * <p>\n+\t * The predicate takes an input object as argument but the value that is checked is extracted\n+\t * from the input object using a member accessor.\n+\t *\n+\t * @param valueAccessor\n+\t *            string accessor used to get the value to check from the input type\n+\t * @param substring\n+\t *            the substring to look for\n+\t * @return a predicate that tests to {@code true} if the string value contains the substring\n+\t *\/\n+\tpublic static <T> Predicate<T> endsWith(\n+\t\tfinal IMemberAccessor<? extends String, T> valueAccessor, final String substring) {\n+\t\treturn new Predicate<T>() {\n+\t\t\t@Override\n+\t\t\tpublic boolean test(T o) {\n+\t\t\t\tString value = valueAccessor.getMember(o);\n+\t\t\t\treturn value == null ? false : value.endsWith(substring);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.common\/src\/main\/java\/org\/openjdk\/jmc\/common\/util\/PredicateToolkit.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import static org.openjdk.jmc.common.unit.UnitLookup.PLAIN_TEXT;\n+\n@@ -46,0 +48,1 @@\n+import org.openjdk.jmc.common.item.IItemFilter;\n@@ -75,1 +78,4 @@\n-\n+\tpublic static final TypedPreference<String> EXCLUDED_FILES = new TypedPreference<>(\"io.file.read.exclude.files\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.FileReadRule_CONFIG_EXCLUDED_FILES),\n+\t\t\tMessages.getString(Messages.FileReadRule_CONFIG_EXCLUDED_FILES_LONG), PLAIN_TEXT.getPersister(),\n+\t\t\t\".jfr,\/proc\/self\/smaps\"); \/\/$NON-NLS-1$\n@@ -77,1 +83,1 @@\n-\t\t\t.<TypedPreference<?>> asList(READ_WARNING_LIMIT);\n+\t\t\t.<TypedPreference<?>> asList(READ_WARNING_LIMIT, EXCLUDED_FILES);\n@@ -106,0 +112,1 @@\n+\t\tString excludedFiles = vp.getPreferenceValue(EXCLUDED_FILES);\n@@ -107,1 +114,2 @@\n-\t\tIItemCollection fileReadEvents = items.apply(JdkFilters.FILE_READ);\n+\t\tIItemCollection fileReadEvents = items\n+\t\t\t\t.apply(ItemFilters.and(JdkFilters.FILE_READ, createExcludeFilter(excludedFiles)));\n@@ -146,0 +154,12 @@\n+\tprivate IItemFilter createExcludeFilter(String excludedFiles) {\n+\t\tif (excludedFiles.isBlank()) {\n+\t\t\treturn ItemFilters.all();\n+\t\t}\n+\t\tString[] files = excludedFiles.split(\",\");\n+\t\tIItemFilter[] filters = new IItemFilter[files.length];\n+\t\tfor (int i = 0; i < files.length; i++) {\n+\t\t\tfilters[i] = ItemFilters.notEndsWith(JdkAttributes.IO_PATH, files[i].trim());\n+\t\t}\n+\t\treturn ItemFilters.and(filters);\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/io\/FileReadRule.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -274,0 +274,2 @@\n+\tpublic static final String FileReadRule_CONFIG_EXCLUDED_FILES = \"FileReadRule_CONFIG_EXCLUDED_FILES\"; \/\/$NON-NLS-1$\n+\tpublic static final String FileReadRule_CONFIG_EXCLUDED_FILES_LONG = \"FileReadRule_CONFIG_EXCLUDED_FILES_LONG\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/Messages.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-#  Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -274,0 +274,2 @@\n+FileReadRule_CONFIG_EXCLUDED_FILES=Files to exclude\n+FileReadRule_CONFIG_EXCLUDED_FILES_LONG=The files to exclude. Will do an endsWith check, so can use extensions like .jfr.\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/messages.properties","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}