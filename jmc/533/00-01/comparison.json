{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/common\/TypeLabelProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/pages\/FileIOPage.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,5 +70,4 @@\n-\tpublic static final TypedPreference<IQuantity> FORCE_WARNING_LIMIT = new TypedPreference<>(\n-\t\t\t\"io.file.force.warning.limit\", \/\/$NON-NLS-1$\n-\t\t\tMessages.getString(Messages.FileForceRule_CONFIG_WARNING_LIMIT),\n-\t\t\tMessages.getString(Messages.FileForceRule_CONFIG_WARNING_LIMIT_LONG), UnitLookup.TIMESPAN,\n-\t\t\tUnitLookup.MILLISECOND.quantity(4000));\n+\tpublic static final TypedPreference<IQuantity> FORCE_INFO_LIMIT = new TypedPreference<>(\"io.file.force.info.limit\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.FileForceRule_CONFIG_INFO_LIMIT),\n+\t\t\tMessages.getString(Messages.FileForceRule_CONFIG_INFO_LIMIT_LONG), UnitLookup.TIMESPAN,\n+\t\t\tUnitLookup.MILLISECOND.quantity(50));\n@@ -77,1 +76,1 @@\n-\t\t\t.<TypedPreference<?>> asList(FORCE_WARNING_LIMIT);\n+\t\t\t.<TypedPreference<?>> asList(FORCE_INFO_LIMIT);\n@@ -81,1 +80,1 @@\n-\t\t\t.addEventType(JdkTypeIDs.FILE_FORCE, EventAvailability.ENABLED).build();\n+\t\t\t.addEventType(JdkTypeIDs.FILE_FORCE, EventAvailability.AVAILABLE).build();\n@@ -83,2 +82,0 @@\n-\t\/\/public static final TypedResult<IQuantity> LONGEST_FORCE_AMOUNT = new TypedResult<>(\"longestForceAmount\", \/\/$NON-NLS-1$\n-\t\/\/\t\"Longest Force (Amount)\", \"The amount force for the longest file force.\", UnitLookup.MEMORY, IQuantity.class);\n@@ -104,2 +101,1 @@\n-\t\tIQuantity warningLimit = vp.getPreferenceValue(FORCE_WARNING_LIMIT);\n-\t\tIQuantity infoLimit = warningLimit.multiply(0.5);\n+\t\tlong infoLimit = vp.getPreferenceValue(FORCE_INFO_LIMIT).longValue();\n@@ -110,5 +106,0 @@\n-\t\t\/\/ Aggregate of all file forced events - if null, then we had no events\n-\t\tif (longestEvent == null) {\n-\t\t\treturn ResultBuilder.createFor(this, vp).setSeverity(Severity.OK)\n-\t\t\t\t\t.setSummary(Messages.getString(Messages.FileForceRuleFactory_TEXT_NO_EVENTS)).build();\n-\t\t}\n@@ -116,3 +107,1 @@\n-\t\tdouble score = RulesToolkit.mapExp100(longestDuration.doubleValueIn(UnitLookup.SECOND),\n-\t\t\t\tinfoLimit.doubleValueIn(UnitLookup.SECOND), warningLimit.doubleValueIn(UnitLookup.SECOND));\n-\n+\t\tdouble score = RulesToolkit.mapExp74(longestDuration.doubleValueIn(UnitLookup.MILLISECOND), infoLimit);\n@@ -120,1 +109,1 @@\n-\t\tif (severity == Severity.WARNING || severity == Severity.INFO) {\n+\t\tif (score >= infoLimit) {\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/io\/FileForceRule.java","additions":9,"deletions":20,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -277,2 +277,2 @@\n-\tpublic static final String FileForceRule_CONFIG_WARNING_LIMIT = \"FileForceRule_CONFIG_WARNING_LIMIT\"; \/\/$NON-NLS-1$\n-\tpublic static final String FileForceRule_CONFIG_WARNING_LIMIT_LONG = \"FileForceRule_CONFIG_WARNING_LIMIT_LONG\"; \/\/$NON-NLS-1$\n+\tpublic static final String FileForceRule_CONFIG_INFO_LIMIT = \"FileForceRule_CONFIG_INFO_LIMIT\"; \/\/$NON-NLS-1$\n+\tpublic static final String FileForceRule_CONFIG_INFO_LIMIT_LONG = \"FileForceRule_CONFIG_INFO_LIMIT_LONG\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/Messages.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -283,2 +283,2 @@\n-FileForceRule_CONFIG_WARNING_LIMIT=File force duration warning limit\n-FileForceRule_CONFIG_WARNING_LIMIT_LONG=The shortest file force duration that should trigger a warning\n+FileForceRule_CONFIG_INFO_LIMIT=File force duration info limit\n+FileForceRule_CONFIG_INFO_LIMIT_LONG=The shortest file force duration that should trigger a info\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/messages.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkAggregators.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -99,1 +99,0 @@\n-\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/messages\/internal\/Messages.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2020, 2023 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.test.rules.jdk;\n+\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.RunnableFuture;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.util.IPreferenceValueProvider;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;\n+import org.openjdk.jmc.flightrecorder.rules.IResult;\n+import org.openjdk.jmc.flightrecorder.rules.IRule;\n+import org.openjdk.jmc.flightrecorder.rules.ResultProvider;\n+import org.openjdk.jmc.flightrecorder.rules.ResultToolkit;\n+import org.openjdk.jmc.flightrecorder.rules.jdk.io.FileReadRule;\n+import org.openjdk.jmc.flightrecorder.rules.jdk.io.FileWriteRule;\n+import org.openjdk.jmc.flightrecorder.rules.jdk.io.FileForceRule;\n+\n+@SuppressWarnings(\"restriction\")\n+public class TestFileReadWriteForceRule {\n+\tprivate static final String FILE_NAME_1 = \"\/user\/dir\/file1.dat\";\n+\tprivate static final String FILE_NAME_2 = \"\/user\/dir\/file2.dat\";\n+\n+\t@Test\n+\tpublic void testReadRule() {\n+\t\ttestFileRule(JdkTypeIDs.FILE_READ, new FileReadRule(),\n+\t\t\t\t\"The longest recorded file read took 5 s to read 4 KiB from \/user\/dir\/file1.dat. Average time of recorded IO: 4.500 s. Total time of recorded IO: 13.500 s. Total time of recorded IO for the file \/user\/dir\/file1.dat: 9.500 s.\"); \/\/$NON-NLS-1$\n+\t}\n+\n+\t@Test\n+\tpublic void testWriteRule() {\n+\t\ttestFileRule(JdkTypeIDs.FILE_WRITE, new FileWriteRule(),\n+\t\t\t\t\"The longest recorded file write took 5 s to write 4 KiB to \/user\/dir\/file1.dat. Average time of recorded IO: 4.500 s. Total time of recorded IO: 13.500 s. Total time of recorded IO for the file \/user\/dir\/file1.dat: 9.500 s.\"); \/\/$NON-NLS-1$\n+\t}\n+\n+\t@Test\n+\tpublic void testForceRuleOK() {\n+\t\tTestEvent[] testEvents = new TestEvent[] {new FileTestEvent(JdkTypeIDs.FILE_FORCE, FILE_NAME_1, 50, 4096)};\n+\t\tIItemCollection events = new MockEventCollection(testEvents);\n+\t\tRunnableFuture<IResult> future = new FileForceRule().createEvaluation(events,\n+\t\t\t\tIPreferenceValueProvider.DEFAULT_VALUES, new ResultProvider());\n+\t\ttry {\n+\t\t\tfuture.run();\n+\t\t\tIResult res = future.get();\n+\t\t\tString summary = ResultToolkit.populateMessage(res, res.getSummary(), false);\n+\t\t\tAssert.assertEquals(\"No long file force pauses were found in this recording (the longest was 50 ms).\", \/\/$NON-NLS-1$\n+\t\t\t\t\tsummary);\n+\t\t} catch (InterruptedException | ExecutionException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\n+\t}\n+\n+\t@Test\n+\tpublic void testForceRuleINFO() {\n+\t\tTestEvent[] testEvents = new TestEvent[] {new FileTestEvent(JdkTypeIDs.FILE_FORCE, FILE_NAME_1, 5000, 4096)};\n+\t\tIItemCollection events = new MockEventCollection(testEvents);\n+\t\tRunnableFuture<IResult> future = new FileForceRule().createEvaluation(events,\n+\t\t\t\tIPreferenceValueProvider.DEFAULT_VALUES, new ResultProvider());\n+\t\ttry {\n+\t\t\tfuture.run();\n+\t\t\tIResult res = future.get();\n+\t\t\tString longDesc = ResultToolkit.populateMessage(res, res.getExplanation(), false);\n+\t\t\tAssert.assertEquals(\n+\t\t\t\t\t\"The longest recorded file force took 5 s from \/user\/dir\/file1.dat. Average time of recorded IO: 5 s. Total time of recorded IO: 5 s. Total time of recorded IO for the file \/user\/dir\/file1.dat: 5 s.\", \/\/$NON-NLS-1$\n+\t\t\t\t\tlongDesc);\n+\t\t} catch (InterruptedException | ExecutionException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\n+\t}\n+\n+\tprivate void testFileRule(String eventType, IRule rule, String expectedLongDesc) {\n+\t\tTestEvent[] testEvents = new TestEvent[] {new FileTestEvent(eventType, FILE_NAME_1, 4500, 4096),\n+\t\t\t\tnew FileTestEvent(eventType, FILE_NAME_1, 5000, 4096),\n+\t\t\t\tnew FileTestEvent(eventType, FILE_NAME_2, 4000, 4096)};\n+\t\tIItemCollection events = new MockEventCollection(testEvents);\n+\t\tRunnableFuture<IResult> future = rule.createEvaluation(events, IPreferenceValueProvider.DEFAULT_VALUES,\n+\t\t\t\tnew ResultProvider());\n+\t\ttry {\n+\t\t\tfuture.run();\n+\t\t\tIResult res = future.get();\n+\t\t\tString longDesc = ResultToolkit.populateMessage(res, res.getExplanation(), false);\n+\t\t\tAssert.assertEquals(expectedLongDesc, longDesc);\n+\t\t} catch (InterruptedException | ExecutionException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/rules\/jdk\/TestFileReadWriteForceRule.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n- *\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * The contents of this file are subject to the terms of either the Universal Permissive License\n- * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n- *\n- * or the following license:\n- *\n- * Redistribution and use in source and binary forms, with or without modification, are permitted\n- * provided that the following conditions are met:\n- *\n- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n- * and the following disclaimer.\n- *\n- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n- * conditions and the following disclaimer in the documentation and\/or other materials provided with\n- * the distribution.\n- *\n- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n- * endorse or promote products derived from this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n- * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-package org.openjdk.jmc.flightrecorder.test.rules.jdk;\n-\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.RunnableFuture;\n-\n-import org.junit.Assert;\n-import org.junit.Test;\n-import org.openjdk.jmc.common.item.IItemCollection;\n-import org.openjdk.jmc.common.util.IPreferenceValueProvider;\n-import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;\n-import org.openjdk.jmc.flightrecorder.rules.IResult;\n-import org.openjdk.jmc.flightrecorder.rules.IRule;\n-import org.openjdk.jmc.flightrecorder.rules.ResultProvider;\n-import org.openjdk.jmc.flightrecorder.rules.ResultToolkit;\n-import org.openjdk.jmc.flightrecorder.rules.jdk.io.FileReadRule;\n-import org.openjdk.jmc.flightrecorder.rules.jdk.io.FileWriteRule;\n-\n-@SuppressWarnings(\"restriction\")\n-public class TestFileReadWriteRule {\n-\tprivate static final String FILE_NAME_1 = \"\/user\/dir\/file1.dat\";\n-\tprivate static final String FILE_NAME_2 = \"\/user\/dir\/file2.dat\";\n-\n-\t@Test\n-\tpublic void testReadRule() {\n-\t\ttestFileRule(JdkTypeIDs.FILE_READ, new FileReadRule(),\n-\t\t\t\t\"The longest recorded file read took 5 s to read 4 KiB from \/user\/dir\/file1.dat. Average time of recorded IO: 4.500 s. Total time of recorded IO: 13.500 s. Total time of recorded IO for the file \/user\/dir\/file1.dat: 9.500 s.\"); \/\/$NON-NLS-1$\n-\t}\n-\n-\t@Test\n-\tpublic void testWriteRule() {\n-\t\ttestFileRule(JdkTypeIDs.FILE_WRITE, new FileWriteRule(),\n-\t\t\t\t\"The longest recorded file write took 5 s to write 4 KiB to \/user\/dir\/file1.dat. Average time of recorded IO: 4.500 s. Total time of recorded IO: 13.500 s. Total time of recorded IO for the file \/user\/dir\/file1.dat: 9.500 s.\"); \/\/$NON-NLS-1$\n-\t}\n-\n-\tprivate void testFileRule(String eventType, IRule rule, String expectedLongDesc) {\n-\t\tTestEvent[] testEvents = new TestEvent[] {new FileTestEvent(eventType, FILE_NAME_1, 4500, 4096),\n-\t\t\t\tnew FileTestEvent(eventType, FILE_NAME_1, 5000, 4096),\n-\t\t\t\tnew FileTestEvent(eventType, FILE_NAME_2, 4000, 4096)};\n-\t\tIItemCollection events = new MockEventCollection(testEvents);\n-\t\tRunnableFuture<IResult> future = rule.createEvaluation(events, IPreferenceValueProvider.DEFAULT_VALUES,\n-\t\t\t\tnew ResultProvider());\n-\t\ttry {\n-\t\t\tfuture.run();\n-\t\t\tIResult res = future.get();\n-\t\t\tString longDesc = ResultToolkit.populateMessage(res, res.getExplanation(), false);\n-\t\t\tAssert.assertEquals(expectedLongDesc, longDesc);\n-\t\t} catch (InterruptedException | ExecutionException e) {\n-\t\t\te.printStackTrace();\n-\t\t}\n-\n-\t}\n-}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/rules\/jdk\/TestFileReadWriteRule.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"}]}