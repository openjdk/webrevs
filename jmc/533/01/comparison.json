{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,2 @@\n+\t\tcase JdkTypeIDs.FILE_FORCE:\n+\t\t\treturn Palette.PF_RED_500.getAWTColor();\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/common\/TypeLabelProvider.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -169,0 +169,1 @@\n+\tpublic static String FileIOPage_ROW_FILE_FORCE;\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/messages\/internal\/Messages.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,0 +131,1 @@\n+\tprivate static final Color FORCE_COLOR = TypeLabelProvider.getColor(JdkTypeIDs.FILE_FORCE);\n@@ -133,1 +134,3 @@\n-\tprivate static final IItemFilter TABLE_ITEMS = ItemFilters.type(JdkTypeIDs.FILE_READ, JdkTypeIDs.FILE_WRITE);\n+\tprivate static final Color FORCE_ALPHA_COLOR = ColorToolkit.withAlpha(FORCE_COLOR, 80);\n+\tprivate static final IItemFilter TABLE_ITEMS = ItemFilters.type(JdkTypeIDs.FILE_READ, JdkTypeIDs.FILE_WRITE,\n+\t\t\tJdkTypeIDs.FILE_FORCE);\n@@ -140,0 +143,1 @@\n+\tprivate static final String FORCE_COUNT = \"forceCount\"; \/\/$NON-NLS-1$\n@@ -142,0 +146,1 @@\n+\tprivate static final String FORCE_SIZE = \"forceSize\"; \/\/$NON-NLS-1$\n@@ -147,0 +152,2 @@\n+\tprivate static final String PERCENTILE_FORCE_TIME = \"percentileForceTime\"; \/\/$NON-NLS-1$\n+\tprivate static final String PERCENTILE_FORCE_COUNT = \"percentileForceCount\"; \/\/$NON-NLS-1$\n@@ -160,0 +167,1 @@\n+\t\tHISTOGRAM.addColumn(FORCE_COUNT, JdkAggregators.FILE_FORCE_COUNT);\n@@ -162,0 +170,1 @@\n+\t\tHISTOGRAM.addColumn(FORCE_SIZE, JdkAggregators.FILE_FORCE_METADATA);\n@@ -175,0 +184,2 @@\n+\t\tPERCENTILES.addSeries(PERCENTILE_FORCE_TIME, Messages.FileIOPage_ROW_FILE_FORCE, PERCENTILE_FORCE_COUNT,\n+\t\t\t\tJdkAggregators.FILE_FORCE_COUNT.getName(), JdkTypeIDs.FILE_FORCE);\n@@ -392,0 +403,12 @@\n+\t\t\tIItemCollection forceItems = selectedItems.apply(JdkFilters.FILE_FORCE);\n+\t\t\tif (forceItems.hasItems()) {\n+\t\t\t\ttimelineRows.add(DataPageToolkit.buildSizeRow(Messages.FileIOPage_ROW_FILE_FORCE + pathCount,\n+\t\t\t\t\t\tJdkAggregators.FILE_FORCE_COUNT.getDescription(), forceItems, JdkAggregators.FILE_FORCE_COUNT,\n+\t\t\t\t\t\tFORCE_COLOR, FileIOPage::getColor));\n+\t\t\t\tdurationRows.add(DataPageToolkit.buildDurationHistogram(Messages.FileIOPage_ROW_FILE_FORCE + pathCount,\n+\t\t\t\t\t\tJdkAggregators.FILE_FORCE_COUNT.getDescription(), forceItems, JdkAggregators.FILE_FORCE_COUNT,\n+\t\t\t\t\t\tFORCE_COLOR));\n+\t\t\t\tsizeRows.add(DataPageToolkit.buildSizeHistogram(Messages.FileIOPage_ROW_FILE_FORCE + pathCount,\n+\t\t\t\t\t\tJdkAggregators.FILE_FORCE_COUNT.getDescription(), forceItems, JdkAggregators.FILE_FORCE_COUNT,\n+\t\t\t\t\t\tFORCE_COLOR, JdkAttributes.IO_FILE_BYTES_READ));\n+\t\t\t}\n@@ -472,1 +495,11 @@\n-\t\treturn JdkTypeIDs.FILE_READ.equals(item.getType().getIdentifier()) ? READ_ALPHA_COLOR : WRITE_ALPHA_COLOR;\n+\n+\t\tswitch (item.getType().getIdentifier()) {\n+\t\tcase JdkTypeIDs.FILE_READ:\n+\t\t\treturn READ_ALPHA_COLOR;\n+\t\tcase JdkTypeIDs.FILE_WRITE:\n+\t\t\treturn WRITE_ALPHA_COLOR;\n+\t\tcase JdkTypeIDs.FILE_FORCE:\n+\t\t\treturn FORCE_ALPHA_COLOR;\n+\t\tdefault:\n+\t\t\treturn null;\n+\t\t}\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/pages\/FileIOPage.java","additions":36,"deletions":3,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -245,0 +245,1 @@\n+FileIOPage_ROW_FILE_FORCE=File Force\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/ui\/messages\/internal\/messages.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.rules.jdk.io;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RunnableFuture;\n+\n+import org.openjdk.jmc.common.item.Aggregators;\n+import org.openjdk.jmc.common.item.IItem;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.item.ItemFilters;\n+import org.openjdk.jmc.common.unit.IQuantity;\n+import org.openjdk.jmc.common.unit.UnitLookup;\n+import org.openjdk.jmc.common.util.IPreferenceValueProvider;\n+import org.openjdk.jmc.common.util.TypedPreference;\n+import org.openjdk.jmc.flightrecorder.JfrAttributes;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkAttributes;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkFilters;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;\n+import org.openjdk.jmc.flightrecorder.rules.IResult;\n+import org.openjdk.jmc.flightrecorder.rules.IResultValueProvider;\n+import org.openjdk.jmc.flightrecorder.rules.IRule;\n+import org.openjdk.jmc.flightrecorder.rules.ResultBuilder;\n+import org.openjdk.jmc.flightrecorder.rules.Severity;\n+import org.openjdk.jmc.flightrecorder.rules.TypedResult;\n+import org.openjdk.jmc.flightrecorder.rules.jdk.messages.internal.Messages;\n+import org.openjdk.jmc.flightrecorder.rules.util.JfrRuleTopics;\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit;\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit.EventAvailability;\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit.RequiredEventsBuilder;\n+import org.owasp.encoder.Encode;\n+\n+public class FileForceRule implements IRule {\n+\n+\tpublic static final TypedPreference<IQuantity> FORCE_INFO_LIMIT = new TypedPreference<>(\"io.file.force.info.limit\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.FileForceRule_CONFIG_INFO_LIMIT),\n+\t\t\tMessages.getString(Messages.FileForceRule_CONFIG_INFO_LIMIT_LONG), UnitLookup.TIMESPAN,\n+\t\t\tUnitLookup.MILLISECOND.quantity(50));\n+\n+\tprivate static final List<TypedPreference<?>> CONFIG_ATTRIBUTES = Arrays\n+\t\t\t.<TypedPreference<?>> asList(FORCE_INFO_LIMIT);\n+\tprivate static final String RESULT_ID = \"FileForce\"; \/\/$NON-NLS-1$\n+\n+\tprivate static final Map<String, EventAvailability> REQUIRED_EVENTS = RequiredEventsBuilder.create()\n+\t\t\t.addEventType(JdkTypeIDs.FILE_FORCE, EventAvailability.AVAILABLE).build();\n+\n+\tpublic static final TypedResult<IQuantity> LONGEST_FORCE_TIME = new TypedResult<>(\"longestForceTime\", \/\/$NON-NLS-1$\n+\t\t\t\"Longest Force (Time)\", \"The longest time it took to perform a file force.\", UnitLookup.TIMESPAN,\n+\t\t\tIQuantity.class);\n+\tpublic static final TypedResult<String> LONGEST_FORCE_PATH = new TypedResult<>(\"longestForcePath\", \/\/$NON-NLS-1$\n+\t\t\t\"Longest Force (Path)\", \"The path of the file force that took the longest time.\", UnitLookup.PLAIN_TEXT,\n+\t\t\tString.class);\n+\tpublic static final TypedResult<IQuantity> LONGEST_TOTAL_FORCE = new TypedResult<>(\"totalForceForLongest\", \/\/$NON-NLS-1$ \n+\t\t\t\"Total Force (Top File)\", \"The total duration of all file forced for the file with the longest force.\",\n+\t\t\tUnitLookup.TIMESPAN, IQuantity.class);\n+\tpublic static final TypedResult<IQuantity> AVERAGE_FILE_FORCE = new TypedResult<>(\"averageFileForce\", \/\/$NON-NLS-1$\n+\t\t\t\"Average File Force\", \"The average duration of all file force.\", UnitLookup.TIMESPAN, IQuantity.class);\n+\tpublic static final TypedResult<IQuantity> TOTAL_FILE_FORCE = new TypedResult<>(\"totalFileForce\", \/\/$NON-NLS-1$\n+\t\t\t\"Total File Force\", \"The total duration of all file forced.\", UnitLookup.TIMESPAN, IQuantity.class);\n+\n+\tprivate static final Collection<TypedResult<?>> RESULT_ATTRIBUTES = Arrays.<TypedResult<?>> asList(\n+\t\t\tTypedResult.SCORE, LONGEST_FORCE_PATH, LONGEST_FORCE_TIME, LONGEST_TOTAL_FORCE, AVERAGE_FILE_FORCE,\n+\t\t\tTOTAL_FILE_FORCE);\n+\n+\tprivate IResult getResult(IItemCollection items, IPreferenceValueProvider vp, IResultValueProvider resultProvider) {\n+\t\tlong infoLimit = vp.getPreferenceValue(FORCE_INFO_LIMIT).longValue();\n+\n+\t\tIItemCollection fileForceEvents = items.apply(JdkFilters.FILE_FORCE);\n+\t\tIItem longestEvent = fileForceEvents.getAggregate(Aggregators.itemWithMax(JfrAttributes.DURATION));\n+\n+\t\tIQuantity longestDuration = RulesToolkit.getValue(longestEvent, JfrAttributes.DURATION);\n+\t\tdouble score = RulesToolkit.mapExp74(longestDuration.doubleValueIn(UnitLookup.MILLISECOND), infoLimit);\n+\t\tSeverity severity = Severity.get(score);\n+\t\tif (score >= infoLimit) {\n+\t\t\tString longestIOPath = RulesToolkit.getValue(longestEvent, JdkAttributes.IO_PATH);\n+\t\t\tString fileName = sanitizeFileName(longestIOPath);\n+\t\t\tIQuantity avgDuration = fileForceEvents\n+\t\t\t\t\t.getAggregate(Aggregators.avg(JdkTypeIDs.FILE_FORCE, JfrAttributes.DURATION));\n+\t\t\tIQuantity totalDuration = fileForceEvents\n+\t\t\t\t\t.getAggregate(Aggregators.sum(JdkTypeIDs.FILE_FORCE, JfrAttributes.DURATION));\n+\t\t\tIItemCollection eventsFromLongestIOPath = fileForceEvents\n+\t\t\t\t\t.apply(ItemFilters.equals(JdkAttributes.IO_PATH, longestIOPath));\n+\t\t\tIQuantity totalLongestIOPath = eventsFromLongestIOPath\n+\t\t\t\t\t.getAggregate(Aggregators.sum(JdkTypeIDs.FILE_FORCE, JfrAttributes.DURATION));\n+\t\t\treturn ResultBuilder.createFor(this, vp).setSeverity(severity)\n+\t\t\t\t\t.setSummary(Messages.getString(Messages.FileForceRuleFactory_TEXT_WARN))\n+\t\t\t\t\t.setExplanation(Messages.getString(Messages.FileForceRuleFactory_TEXT_WARN_LONG))\n+\t\t\t\t\t.addResult(TypedResult.SCORE, UnitLookup.NUMBER_UNITY.quantity(score))\n+\t\t\t\t\t.addResult(LONGEST_FORCE_TIME, longestDuration).addResult(AVERAGE_FILE_FORCE, avgDuration)\n+\t\t\t\t\t.addResult(TOTAL_FILE_FORCE, totalDuration).addResult(LONGEST_TOTAL_FORCE, totalLongestIOPath)\n+\t\t\t\t\t.addResult(LONGEST_FORCE_PATH, fileName).build();\n+\t\t}\n+\t\treturn ResultBuilder.createFor(this, vp).setSeverity(severity)\n+\t\t\t\t.setSummary(Messages.getString(Messages.FileForceRuleFactory_TEXT_OK))\n+\t\t\t\t.addResult(TypedResult.SCORE, UnitLookup.NUMBER_UNITY.quantity(score))\n+\t\t\t\t.addResult(LONGEST_FORCE_TIME, longestDuration).build();\n+\t}\n+\n+\tstatic String sanitizeFileName(String fileName) {\n+\t\tif (fileName == null || fileName.isEmpty()) {\n+\t\t\treturn Encode.forHtml(Messages.getString(Messages.General_UNKNOWN_FILE_NAME));\n+\t\t}\n+\t\treturn Encode.forHtml(fileName);\n+\t}\n+\n+\t@Override\n+\tpublic RunnableFuture<IResult> createEvaluation(\n+\t\tfinal IItemCollection items, final IPreferenceValueProvider valueProvider,\n+\t\tfinal IResultValueProvider resultProvider) {\n+\t\tFutureTask<IResult> evaluationTask = new FutureTask<>(new Callable<IResult>() {\n+\t\t\t@Override\n+\t\t\tpublic IResult call() throws Exception {\n+\t\t\t\treturn getResult(items, valueProvider, resultProvider);\n+\t\t\t}\n+\t\t});\n+\t\treturn evaluationTask;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<TypedPreference<?>> getConfigurationAttributes() {\n+\t\treturn CONFIG_ATTRIBUTES;\n+\t}\n+\n+\t@Override\n+\tpublic String getId() {\n+\t\treturn RESULT_ID;\n+\t}\n+\n+\t@Override\n+\tpublic String getName() {\n+\t\treturn Messages.getString(Messages.FileForceRuleFactory_RULE_NAME);\n+\t}\n+\n+\t@Override\n+\tpublic String getTopic() {\n+\t\treturn JfrRuleTopics.FILE_IO;\n+\t}\n+\n+\t@Override\n+\tpublic Map<String, EventAvailability> getRequiredEvents() {\n+\t\treturn REQUIRED_EVENTS;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<TypedResult<?>> getResults() {\n+\t\treturn RESULT_ATTRIBUTES;\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/io\/FileForceRule.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -272,0 +272,7 @@\n+\tpublic static final String FileForceRuleFactory_RULE_NAME = \"FileForceRuleFactory_RULE_NAME\"; \/\/$NON-NLS-1$\n+\tpublic static final String FileForceRuleFactory_TEXT_NO_EVENTS = \"FileForceRuleFactory_TEXT_NO_EVENTS\"; \/\/$NON-NLS-1$\n+\tpublic static final String FileForceRuleFactory_TEXT_OK = \"FileForceRuleFactory_TEXT_OK\"; \/\/$NON-NLS-1$\n+\tpublic static final String FileForceRuleFactory_TEXT_WARN = \"FileForceRuleFactory_TEXT_WARN\"; \/\/$NON-NLS-1$\n+\tpublic static final String FileForceRuleFactory_TEXT_WARN_LONG = \"FileForceRuleFactory_TEXT_WARN_LONG\"; \/\/$NON-NLS-1$\n+\tpublic static final String FileForceRule_CONFIG_INFO_LIMIT = \"FileForceRule_CONFIG_INFO_LIMIT\"; \/\/$NON-NLS-1$\n+\tpublic static final String FileForceRule_CONFIG_INFO_LIMIT_LONG = \"FileForceRule_CONFIG_INFO_LIMIT_LONG\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/Messages.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+org.openjdk.jmc.flightrecorder.rules.jdk.io.FileForceRule\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/resources\/META-INF\/services\/org.openjdk.jmc.flightrecorder.rules.IRule","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -283,0 +283,10 @@\n+FileForceRule_CONFIG_INFO_LIMIT=File force duration info limit\n+FileForceRule_CONFIG_INFO_LIMIT_LONG=The shortest file force duration that should trigger a info\n+FileForceRuleFactory_RULE_NAME=File Force Peak Duration\n+# {longestForceTime} is a time period\n+FileForceRuleFactory_TEXT_OK=No long file force pauses were found in this recording (the longest was {longestForceTime}).\n+FileForceRuleFactory_TEXT_NO_EVENTS=There are no file force events in this recording.\n+# {longestForceTime} is a time period\n+FileForceRuleFactory_TEXT_WARN=There are long file force pauses in this recording (the longest is {longestForceTime}).\n+# {longestForceTime} is a time period, {longestForcePath} is a file path\n+FileForceRuleFactory_TEXT_WARN_LONG=The longest recorded file force took {longestForceTime} from {longestForcePath}. Average time of recorded IO: {averageFileForce}. Total time of recorded IO: {totalFileForce}. Total time of recorded IO for the file {longestForcePath}: {totalForceForLongest}.\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/messages.properties","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,1 @@\n+import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.IO_FILE_FORCE_METADATA;\n@@ -80,0 +81,1 @@\n+import static org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs.FILE_FORCE;\n@@ -253,0 +255,1 @@\n+\tpublic static final IAggregator<Boolean, ?> FILE_FORCE_METADATA = or(FILE_FORCE, IO_FILE_FORCE_METADATA);\n@@ -259,0 +262,3 @@\n+\tpublic static final IAggregator<IQuantity, ?> FILE_FORCE_COUNT = Aggregators.count(\n+\t\t\tMessages.getString(Messages.AGGR_FILE_FORCE_COUNT), Messages.getString(Messages.AGGR_FILE_FORCE_COUNT_DESC),\n+\t\t\tJdkFilters.FILE_FORCE);\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkAggregators.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -474,0 +474,3 @@\n+\tpublic static final IAttribute<Boolean> IO_FILE_FORCE_METADATA = attr(\"metaData\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_IO_FILE_FORCE_METADATA),\n+\t\t\tMessages.getString(Messages.ATTR_IO_FILE_FORCE_METADATA_DESC), FLAG);\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkAttributes.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+\tpublic static final IItemFilter FILE_FORCE = ItemFilters.type(JdkTypeIDs.FILE_FORCE);\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkFilters.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+\tpublic static final String FILE_FORCE = PREFIX + \"FileForce\";\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkTypeIDs.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -97,0 +97,2 @@\n+\tpublic static final String AGGR_FILE_FORCE_COUNT = \"AGGR_FILE_FORCE_COUNT\"; \/\/$NON-NLS-1$\n+\tpublic static final String AGGR_FILE_FORCE_COUNT_DESC = \"AGGR_FILE_FORCE_COUNT_DESC\"; \/\/$NON-NLS-1$\n@@ -366,0 +368,2 @@\n+\tpublic static final String ATTR_IO_FILE_FORCE_METADATA = \"ATTR_IO_FILE_FORCE_METADATA\"; \/\/$NON-NLS-1$\n+\tpublic static final String ATTR_IO_FILE_FORCE_METADATA_DESC = \"ATTR_IO_FILE_FORCE_METADATA_DESC\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/messages\/internal\/Messages.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+ATTR_IO_FILE_FORCE_METADATA=Update Metadata\n+ATTR_IO_FILE_FORCE_METADATA_DESC=Whether the file metadata is updated\n@@ -383,0 +385,2 @@\n+AGGR_FILE_FORCE_COUNT=Force Count\n+AGGR_FILE_FORCE_COUNT_DESC=The total number of file forces\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/jdk\/messages\/internal\/messages.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2020, 2023 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.test.rules.jdk;\n+\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.RunnableFuture;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.util.IPreferenceValueProvider;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;\n+import org.openjdk.jmc.flightrecorder.rules.IResult;\n+import org.openjdk.jmc.flightrecorder.rules.IRule;\n+import org.openjdk.jmc.flightrecorder.rules.ResultProvider;\n+import org.openjdk.jmc.flightrecorder.rules.ResultToolkit;\n+import org.openjdk.jmc.flightrecorder.rules.jdk.io.FileReadRule;\n+import org.openjdk.jmc.flightrecorder.rules.jdk.io.FileWriteRule;\n+import org.openjdk.jmc.flightrecorder.rules.jdk.io.FileForceRule;\n+\n+@SuppressWarnings(\"restriction\")\n+public class TestFileReadWriteForceRule {\n+\tprivate static final String FILE_NAME_1 = \"\/user\/dir\/file1.dat\";\n+\tprivate static final String FILE_NAME_2 = \"\/user\/dir\/file2.dat\";\n+\n+\t@Test\n+\tpublic void testReadRule() {\n+\t\ttestFileRule(JdkTypeIDs.FILE_READ, new FileReadRule(),\n+\t\t\t\t\"The longest recorded file read took 5 s to read 4 KiB from \/user\/dir\/file1.dat. Average time of recorded IO: 4.500 s. Total time of recorded IO: 13.500 s. Total time of recorded IO for the file \/user\/dir\/file1.dat: 9.500 s.\"); \/\/$NON-NLS-1$\n+\t}\n+\n+\t@Test\n+\tpublic void testWriteRule() {\n+\t\ttestFileRule(JdkTypeIDs.FILE_WRITE, new FileWriteRule(),\n+\t\t\t\t\"The longest recorded file write took 5 s to write 4 KiB to \/user\/dir\/file1.dat. Average time of recorded IO: 4.500 s. Total time of recorded IO: 13.500 s. Total time of recorded IO for the file \/user\/dir\/file1.dat: 9.500 s.\"); \/\/$NON-NLS-1$\n+\t}\n+\n+\t@Test\n+\tpublic void testForceRuleOK() {\n+\t\tTestEvent[] testEvents = new TestEvent[] {new FileTestEvent(JdkTypeIDs.FILE_FORCE, FILE_NAME_1, 50, 4096)};\n+\t\tIItemCollection events = new MockEventCollection(testEvents);\n+\t\tRunnableFuture<IResult> future = new FileForceRule().createEvaluation(events,\n+\t\t\t\tIPreferenceValueProvider.DEFAULT_VALUES, new ResultProvider());\n+\t\ttry {\n+\t\t\tfuture.run();\n+\t\t\tIResult res = future.get();\n+\t\t\tString summary = ResultToolkit.populateMessage(res, res.getSummary(), false);\n+\t\t\tAssert.assertEquals(\"No long file force pauses were found in this recording (the longest was 50 ms).\", \/\/$NON-NLS-1$\n+\t\t\t\t\tsummary);\n+\t\t} catch (InterruptedException | ExecutionException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\n+\t}\n+\n+\t@Test\n+\tpublic void testForceRuleINFO() {\n+\t\tTestEvent[] testEvents = new TestEvent[] {new FileTestEvent(JdkTypeIDs.FILE_FORCE, FILE_NAME_1, 5000, 4096)};\n+\t\tIItemCollection events = new MockEventCollection(testEvents);\n+\t\tRunnableFuture<IResult> future = new FileForceRule().createEvaluation(events,\n+\t\t\t\tIPreferenceValueProvider.DEFAULT_VALUES, new ResultProvider());\n+\t\ttry {\n+\t\t\tfuture.run();\n+\t\t\tIResult res = future.get();\n+\t\t\tString longDesc = ResultToolkit.populateMessage(res, res.getExplanation(), false);\n+\t\t\tAssert.assertEquals(\n+\t\t\t\t\t\"The longest recorded file force took 5 s from \/user\/dir\/file1.dat. Average time of recorded IO: 5 s. Total time of recorded IO: 5 s. Total time of recorded IO for the file \/user\/dir\/file1.dat: 5 s.\", \/\/$NON-NLS-1$\n+\t\t\t\t\tlongDesc);\n+\t\t} catch (InterruptedException | ExecutionException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\n+\t}\n+\n+\tprivate void testFileRule(String eventType, IRule rule, String expectedLongDesc) {\n+\t\tTestEvent[] testEvents = new TestEvent[] {new FileTestEvent(eventType, FILE_NAME_1, 4500, 4096),\n+\t\t\t\tnew FileTestEvent(eventType, FILE_NAME_1, 5000, 4096),\n+\t\t\t\tnew FileTestEvent(eventType, FILE_NAME_2, 4000, 4096)};\n+\t\tIItemCollection events = new MockEventCollection(testEvents);\n+\t\tRunnableFuture<IResult> future = rule.createEvaluation(events, IPreferenceValueProvider.DEFAULT_VALUES,\n+\t\t\t\tnew ResultProvider());\n+\t\ttry {\n+\t\t\tfuture.run();\n+\t\t\tIResult res = future.get();\n+\t\t\tString longDesc = ResultToolkit.populateMessage(res, res.getExplanation(), false);\n+\t\t\tAssert.assertEquals(expectedLongDesc, longDesc);\n+\t\t} catch (InterruptedException | ExecutionException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/rules\/jdk\/TestFileReadWriteForceRule.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n- *\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * The contents of this file are subject to the terms of either the Universal Permissive License\n- * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n- *\n- * or the following license:\n- *\n- * Redistribution and use in source and binary forms, with or without modification, are permitted\n- * provided that the following conditions are met:\n- *\n- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n- * and the following disclaimer.\n- *\n- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n- * conditions and the following disclaimer in the documentation and\/or other materials provided with\n- * the distribution.\n- *\n- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n- * endorse or promote products derived from this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n- * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-package org.openjdk.jmc.flightrecorder.test.rules.jdk;\n-\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.RunnableFuture;\n-\n-import org.junit.Assert;\n-import org.junit.Test;\n-import org.openjdk.jmc.common.item.IItemCollection;\n-import org.openjdk.jmc.common.util.IPreferenceValueProvider;\n-import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;\n-import org.openjdk.jmc.flightrecorder.rules.IResult;\n-import org.openjdk.jmc.flightrecorder.rules.IRule;\n-import org.openjdk.jmc.flightrecorder.rules.ResultProvider;\n-import org.openjdk.jmc.flightrecorder.rules.ResultToolkit;\n-import org.openjdk.jmc.flightrecorder.rules.jdk.io.FileReadRule;\n-import org.openjdk.jmc.flightrecorder.rules.jdk.io.FileWriteRule;\n-\n-@SuppressWarnings(\"restriction\")\n-public class TestFileReadWriteRule {\n-\tprivate static final String FILE_NAME_1 = \"\/user\/dir\/file1.dat\";\n-\tprivate static final String FILE_NAME_2 = \"\/user\/dir\/file2.dat\";\n-\n-\t@Test\n-\tpublic void testReadRule() {\n-\t\ttestFileRule(JdkTypeIDs.FILE_READ, new FileReadRule(),\n-\t\t\t\t\"The longest recorded file read took 5 s to read 4 KiB from \/user\/dir\/file1.dat. Average time of recorded IO: 4.500 s. Total time of recorded IO: 13.500 s. Total time of recorded IO for the file \/user\/dir\/file1.dat: 9.500 s.\"); \/\/$NON-NLS-1$\n-\t}\n-\n-\t@Test\n-\tpublic void testWriteRule() {\n-\t\ttestFileRule(JdkTypeIDs.FILE_WRITE, new FileWriteRule(),\n-\t\t\t\t\"The longest recorded file write took 5 s to write 4 KiB to \/user\/dir\/file1.dat. Average time of recorded IO: 4.500 s. Total time of recorded IO: 13.500 s. Total time of recorded IO for the file \/user\/dir\/file1.dat: 9.500 s.\"); \/\/$NON-NLS-1$\n-\t}\n-\n-\tprivate void testFileRule(String eventType, IRule rule, String expectedLongDesc) {\n-\t\tTestEvent[] testEvents = new TestEvent[] {new FileTestEvent(eventType, FILE_NAME_1, 4500, 4096),\n-\t\t\t\tnew FileTestEvent(eventType, FILE_NAME_1, 5000, 4096),\n-\t\t\t\tnew FileTestEvent(eventType, FILE_NAME_2, 4000, 4096)};\n-\t\tIItemCollection events = new MockEventCollection(testEvents);\n-\t\tRunnableFuture<IResult> future = rule.createEvaluation(events, IPreferenceValueProvider.DEFAULT_VALUES,\n-\t\t\t\tnew ResultProvider());\n-\t\ttry {\n-\t\t\tfuture.run();\n-\t\t\tIResult res = future.get();\n-\t\t\tString longDesc = ResultToolkit.populateMessage(res, res.getExplanation(), false);\n-\t\t\tAssert.assertEquals(expectedLongDesc, longDesc);\n-\t\t} catch (InterruptedException | ExecutionException e) {\n-\t\t\te.printStackTrace();\n-\t\t}\n-\n-\t}\n-}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/rules\/jdk\/TestFileReadWriteRule.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -101,0 +101,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -408,0 +412,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -680,0 +688,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -956,0 +968,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -1216,0 +1232,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -1481,0 +1501,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -1746,0 +1770,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -2033,0 +2061,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -2331,0 +2363,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -2618,0 +2654,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -2935,0 +2975,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -3255,0 +3299,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -3528,0 +3576,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -3776,0 +3828,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -4046,0 +4102,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -4330,0 +4390,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/baseline\/JfrRuleBaseline.xml","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"}]}