{"files":[{"patch":"@@ -730,0 +730,24 @@\n+\n+\t\t<page factory=\"org.openjdk.jmc.flightrecorder.ui.security\" id=\"org.openjdk.jmc.flightrecorder.ui.security\">\n+\t\t\t<state>\n+\t\t\t\t<sash \/>\n+\t\t\t\t<securityX509AlgorithmTable sortColumn=\"cryptoIcon\">\n+\t\t\t\t\t<column id=\"cryptoIcon\" width=\"100\" sortAscending=\"true\" \/>\n+\t\t\t\t\t<column id=\"cryptoRemark\" hidden=\"false\"\/>\n+\t\t\t\t\t<column id=\"algorithm\" hidden=\"false\"\/>\n+\t\t\t\t\t<column id=\"keyType\" hidden=\"false\"\/>\n+\t\t\t\t\t<column id=\"keyLength\" hidden=\"false\" \/>\n+\t\t\t\t\t<column id=\"serialNumber\" hidden=\"false\"\/>\n+\t\t\t\t\t<column id=\"subject\" hidden=\"false\" \/>\n+\t\t\t\t\t<column id=\"validFrom\" hidden=\"false\" \/>\n+\t\t\t\t\t<column id=\"validUntil\" hidden=\"false\"\/>\n+\t\t\t\t\t<column id=\"thread\" hidden=\"false\" \/>\n+\t\t\t\t\t<column id=\"certificateId\" hidden=\"false\" \/>\n+\t\t\t\t\t<column id=\"issuer\" hidden=\"false\"\/>\n+\t\t\t\t<\/securityX509AlgorithmTable>\n+\t\t\t\t<chart>\n+\t\t\t\t\t<series id=\"x509CertificateCount\" \/>\n+\t\t\t\t<\/chart>\n+\t\t\t<\/state>\n+\t\t<\/page>\n+\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/defaultPages.xml","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"filename":"application\/org.openjdk.jmc.flightrecorder.ui\/icons\/pages\/security16.png","binary":true,"status":"added"},{"patch":"@@ -148,0 +148,5 @@\n+   \n+   <context id=\"security\">\n+      <description><\/description>\n+      <topic href=\"PLUGINS_ROOT\/org.openjdk.jmc.docs\/html\/GUID-4F885E48-A548-4140-B985-74B1685BEDEA.htm\" label=\"Using the Security Page\" \/>\n+   <\/context>\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/org.openjdk.jmc.flightrecorder.ui_contexts.xml","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -321,0 +321,4 @@\n+      <factory\n+            class=\"org.openjdk.jmc.flightrecorder.ui.pages.SecurityPage$SecurityPageFactory\"\n+            id=\"org.openjdk.jmc.flightrecorder.ui.security\">\n+      <\/factory>\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/plugin.xml","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -135,0 +135,1 @@\n+\tpublic static final String PAGE_SECURITY = \"pages\/security16.png\"; \/\/$NON-NLS-1$\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/common\/ImageConstants.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import org.eclipse.jface.viewers.ColumnLabelProvider;\n@@ -86,0 +87,15 @@\n+\t\tpublic void addColumn(IAttribute<?> a, ColumnLabelProvider iconProvider) {\n+\t\t\t@SuppressWarnings(\"deprecation\")\n+\t\t\tIMemberAccessor<?, IItem> accessor = ItemToolkit.accessor(a);\n+\t\t\taddColumn(a.getIdentifier(), a.getName(), a.getDescription(),\n+\t\t\t\t\ta.getContentType() instanceof LinearKindOfQuantity, accessor, iconProvider);\n+\t\t}\n+\n+\t\tprivate void addColumn(\n+\t\t\tString columnId, String name, String description, boolean right, IMemberAccessor<?, IItem> accessor,\n+\t\t\tColumnLabelProvider iconProvider) {\n+\t\t\tcolumns.add(new ColumnBuilder(name, columnId, accessor, iconProvider).description(description)\n+\t\t\t\t\t.style(right ? SWT.RIGHT : SWT.NONE).build());\n+\n+\t\t}\n+\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/common\/ItemList.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -526,0 +526,5 @@\n+\tpublic static String SecurityPage_PAGE_NAME;\n+\tpublic static String SecurityPage_TIMELINE_SELECTION;\n+\tpublic static String SecurityPage_TABLE_SELECTION;\n+\tpublic static String SecurityPage_SECTION_X509_CERTIFICATES;\n+\tpublic static String SecurityPage_SECTION_X509_ALGORITHMS;\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/messages\/internal\/Messages.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,389 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.ui.pages;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.eclipse.jface.resource.ImageDescriptor;\n+import org.eclipse.jface.viewers.ArrayContentProvider;\n+import org.eclipse.jface.viewers.CheckboxTableViewer;\n+import org.eclipse.jface.viewers.ColumnLabelProvider;\n+import org.eclipse.jface.viewers.ColumnViewerToolTipSupport;\n+import org.eclipse.swt.SWT;\n+import org.eclipse.swt.custom.SashForm;\n+import org.eclipse.swt.graphics.Image;\n+import org.eclipse.swt.layout.GridData;\n+import org.eclipse.swt.layout.GridLayout;\n+import org.eclipse.swt.widgets.Composite;\n+import org.eclipse.ui.forms.widgets.Form;\n+import org.eclipse.ui.forms.widgets.FormToolkit;\n+import org.eclipse.ui.forms.widgets.Section;\n+import org.openjdk.jmc.common.IDescribable;\n+import org.openjdk.jmc.common.IState;\n+import org.openjdk.jmc.common.IWritableState;\n+import org.openjdk.jmc.common.item.IAggregator;\n+import org.openjdk.jmc.common.item.IItem;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.item.IItemFilter;\n+import org.openjdk.jmc.common.item.IMemberAccessor;\n+import org.openjdk.jmc.common.item.ItemCollectionToolkit;\n+import org.openjdk.jmc.common.item.ItemFilters;\n+import org.openjdk.jmc.common.unit.IQuantity;\n+import org.openjdk.jmc.common.unit.IRange;\n+import org.openjdk.jmc.flightrecorder.JfrAttributes;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkAggregators;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkAttributes;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkFilters;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;\n+import org.openjdk.jmc.flightrecorder.rules.util.JfrRuleTopics;\n+import org.openjdk.jmc.flightrecorder.ui.FlightRecorderUI;\n+import org.openjdk.jmc.flightrecorder.ui.IDataPageFactory;\n+import org.openjdk.jmc.flightrecorder.ui.IDisplayablePage;\n+import org.openjdk.jmc.flightrecorder.ui.IPageContainer;\n+import org.openjdk.jmc.flightrecorder.ui.IPageDefinition;\n+import org.openjdk.jmc.flightrecorder.ui.IPageUI;\n+import org.openjdk.jmc.flightrecorder.ui.StreamModel;\n+import org.openjdk.jmc.flightrecorder.ui.common.AbstractDataPage;\n+import org.openjdk.jmc.flightrecorder.ui.common.DataPageToolkit;\n+import org.openjdk.jmc.flightrecorder.ui.common.FilterComponent;\n+import org.openjdk.jmc.flightrecorder.ui.common.FlavorSelector;\n+import org.openjdk.jmc.flightrecorder.ui.common.FlavorSelector.FlavorSelectorState;\n+import org.openjdk.jmc.flightrecorder.ui.common.ImageConstants;\n+import org.openjdk.jmc.flightrecorder.ui.common.ItemList;\n+import org.openjdk.jmc.flightrecorder.ui.common.ItemList.ItemListBuilder;\n+import org.openjdk.jmc.flightrecorder.ui.common.ItemRow;\n+import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;\n+import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStoreActionToolkit;\n+import org.openjdk.jmc.ui.UIPlugin;\n+import org.openjdk.jmc.ui.charts.IXDataRenderer;\n+import org.openjdk.jmc.ui.charts.RendererToolkit;\n+import org.openjdk.jmc.ui.charts.XYChart;\n+import org.openjdk.jmc.ui.column.ColumnManager.SelectionState;\n+import org.openjdk.jmc.ui.column.ColumnMenusFactory;\n+import org.openjdk.jmc.ui.column.TableSettings;\n+import org.openjdk.jmc.ui.handlers.MCContextMenuManager;\n+import org.openjdk.jmc.ui.misc.ChartCanvas;\n+import org.openjdk.jmc.ui.misc.CompositeToolkit;\n+import org.openjdk.jmc.ui.misc.PersistableSashForm;\n+import org.openjdk.jmc.ui.misc.SWTColorToolkit;\n+\n+public class SecurityPage extends AbstractDataPage {\n+\n+\tpublic static class SecurityPageFactory implements IDataPageFactory {\n+\n+\t\t@Override\n+\t\tpublic String getName(IState state) {\n+\t\t\treturn Messages.SecurityPage_PAGE_NAME;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic ImageDescriptor getImageDescriptor(IState state) {\n+\t\t\treturn FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.PAGE_SECURITY);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String[] getTopics(IState state) {\n+\t\t\treturn new String[] {JfrRuleTopics.SECURITY};\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic IDisplayablePage createPage(IPageDefinition definition, StreamModel items, IPageContainer editor) {\n+\t\t\treturn new SecurityPage(definition, items, editor);\n+\t\t}\n+\n+\t}\n+\n+\tprivate static ColumnLabelProvider LEGEND_LP = new ColumnLabelProvider() {\n+\n+\t\t@Override\n+\t\tpublic String getText(Object element) {\n+\t\t\treturn getText(element, IDescribable::getName);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getToolTipText(Object element) {\n+\t\t\treturn getText(element, IDescribable::getDescription);\n+\t\t};\n+\n+\t\tprivate String getText(Object element, Function<IDescribable, String> accessor) {\n+\t\t\treturn accessor.apply(JdkAggregators.X509_CERTIFICATE_COUNT);\n+\t\t};\n+\n+\t\t@Override\n+\t\tpublic Image getImage(Object element) {\n+\t\t\treturn SWTColorToolkit\n+\t\t\t\t\t.getColorThumbnail(SWTColorToolkit.asRGB(DataPageToolkit.getFieldColor((String) element)));\n+\n+\t\t};\n+\t};\n+\n+\tprivate static ColumnLabelProvider ICON_LP = new ColumnLabelProvider() {\n+\t\t@Override\n+\t\tpublic String getText(Object element) {\n+\t\t\treturn \"\"; \/\/ Return empty string for image-only column\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\t@Override\n+\t\tpublic Image getImage(Object element) {\n+\t\t\tif (element instanceof IItem) {\n+\t\t\t\tIItem iItem = (IItem) element;\n+\t\t\t\tIMemberAccessor<? extends String, IItem> iconAccessor = (IMemberAccessor<? extends String, IItem>) JdkAttributes.CRYPTO_ICON\n+\t\t\t\t\t\t.getAccessor(iItem.getType());\n+\n+\t\t\t\tImageDescriptor descriptor;\n+\t\t\t\tif (iconAccessor != null) {\n+\t\t\t\t\tString iconText = iconAccessor.getMember(iItem);\n+\t\t\t\t\tif (iconText.contains(\"ACTION\"))\n+\t\t\t\t\t\tdescriptor = UIPlugin.getDefault().getMCImageDescriptor(UIPlugin.ICON_CRYPTO_ACTION);\n+\t\t\t\t\telse if (iconText.contains(\"ATTENTION\"))\n+\t\t\t\t\t\tdescriptor = UIPlugin.getDefault().getMCImageDescriptor(UIPlugin.ICON_CRYPTO_ATTENTION);\n+\t\t\t\t\telse\n+\t\t\t\t\t\tdescriptor = UIPlugin.getDefault().getMCImageDescriptor(UIPlugin.ICON_CRYPTO_OK);\n+\n+\t\t\t\t\tif (descriptor != null) {\n+\t\t\t\t\t\treturn descriptor.createImage();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t}\n+\t};\n+\n+\tprivate static final ItemListBuilder SECURITY_X509_ALGORITHM_LIST = new ItemListBuilder();\n+\n+\tstatic {\n+\n+\t\tSECURITY_X509_ALGORITHM_LIST.addColumn(JdkAttributes.CRYPTO_ICON, ICON_LP);\n+\t\tSECURITY_X509_ALGORITHM_LIST.addColumn(JdkAttributes.CRYPTO_REMARK);\n+\t\tSECURITY_X509_ALGORITHM_LIST.addColumn(JdkAttributes.SIGNATURE_ALGORITHM);\n+\t\tSECURITY_X509_ALGORITHM_LIST.addColumn(JdkAttributes.KEY_TYPE);\n+\t\tSECURITY_X509_ALGORITHM_LIST.addColumn(JdkAttributes.KEY_LENGTH);\n+\t\tSECURITY_X509_ALGORITHM_LIST.addColumn(JdkAttributes.SERIAL_NUMBER);\n+\t\tSECURITY_X509_ALGORITHM_LIST.addColumn(JdkAttributes.SUBJECT);\n+\t\tSECURITY_X509_ALGORITHM_LIST.addColumn(JdkAttributes.VALID_FROM);\n+\t\tSECURITY_X509_ALGORITHM_LIST.addColumn(JdkAttributes.VALID_UNTIL);\n+\t\tSECURITY_X509_ALGORITHM_LIST.addColumn(JfrAttributes.EVENT_THREAD);\n+\t\tSECURITY_X509_ALGORITHM_LIST.addColumn(JdkAttributes.CERTIFICATE_ISSUER);\n+\n+\t}\n+\n+\tprivate static final String SASH = \"sash\"; \/\/$NON-NLS-1$\n+\tprivate static final String SECURITY_X509_ALGORITHM_TABLE = \"securityX509AlgorithmTable\"; \/\/$NON-NLS-1$\n+\tprivate static final String SECURITY_X509_ALGORITHM_FILTER = \"securityX509AlgorithmFilter\"; \/\/$NON-NLS-1$\n+\tprivate static final String CHART = \"chart\"; \/\/$NON-NLS-1$\n+\tprivate static final String SERIES = \"series\"; \/\/$NON-NLS-1$\n+\tprivate static final String ID_ATTRIBUTE = \"id\"; \/\/$NON-NLS-1$\n+\tprivate static final String X509_CERTIFICATE_COUNT = \"x509CertificateCount\"; \/\/$NON-NLS-1$\n+\n+\tprivate class SecurityPageUI implements IPageUI {\n+\n+\t\tprivate final SashForm sash;\n+\t\tprivate final IPageContainer pageContainer;\n+\t\tprivate final CheckboxTableViewer chartLegend;\n+\t\tprivate final ChartCanvas chartCanvas;\n+\t\tprivate final ItemList securityX509AlgorithmTable;\n+\t\tprivate final FilterComponent securityX509AlgorithmFilter;\n+\t\tprivate IItemCollection selectionItems;\n+\t\tprivate XYChart chart;\n+\t\tprivate IRange<IQuantity> currentRange;\n+\t\tprivate FlavorSelector flavorSelector;\n+\n+\t\tSecurityPageUI(Composite parent, FormToolkit toolkit, IPageContainer pageContainer, IState state) {\n+\t\t\tthis.pageContainer = pageContainer;\n+\t\t\tForm form = DataPageToolkit.createForm(parent, toolkit, getName(), getIcon());\n+\t\t\tsash = new SashForm(form.getBody(), SWT.VERTICAL);\n+\t\t\ttoolkit.adapt(sash);\n+\n+\t\t\tBoolean isCertificateIdQty = getDataSource().getItems().getAggregate(JdkAggregators.IS_CERTIFICATE_ID_QTY);\n+\n+\t\t\tif (isCertificateIdQty)\n+\t\t\t\tSECURITY_X509_ALGORITHM_LIST.addColumn(JdkAttributes.CERTIFICATE_ID_QTY);\n+\t\t\telse\n+\t\t\t\tSECURITY_X509_ALGORITHM_LIST.addColumn(JdkAttributes.CERTIFICATE_ID);\n+\n+\t\t\t\/\/Algorithm table\n+\t\t\tSection s2 = CompositeToolkit.createSection(sash, toolkit, Messages.SecurityPage_SECTION_X509_ALGORITHMS);\n+\t\t\tsecurityX509AlgorithmTable = SECURITY_X509_ALGORITHM_LIST.buildWithoutBorder(s2,\n+\t\t\t\t\tTableSettings.forState(state.getChild(SECURITY_X509_ALGORITHM_TABLE)));\n+\n+\t\t\tsecurityX509AlgorithmTable.getManager().getViewer().addSelectionChangedListener(e -> pageContainer\n+\t\t\t\t\t.showSelection(ItemCollectionToolkit.build(securityX509AlgorithmTable.getSelection().get())));\n+\t\t\tsecurityX509AlgorithmFilter = FilterComponent.createFilterComponent(securityX509AlgorithmTable,\n+\t\t\t\t\tsecurityX509AlgorithmFilterState, getDataSource().getItems().apply(JdkFilters.SECURITY),\n+\t\t\t\t\tpageContainer.getSelectionStore()::getSelections, this::onAlgorithmFilterChange);\n+\t\t\tMCContextMenuManager mm1 = MCContextMenuManager\n+\t\t\t\t\t.create(securityX509AlgorithmTable.getManager().getViewer().getControl());\n+\t\t\tColumnMenusFactory.addDefaultMenus(securityX509AlgorithmTable.getManager(), mm1);\n+\t\t\tSelectionStoreActionToolkit.addSelectionStoreActions(pageContainer.getSelectionStore(),\n+\t\t\t\t\tsecurityX509AlgorithmTable, Messages.SecurityPage_TABLE_SELECTION, mm1);\n+\t\t\tmm1.add(securityX509AlgorithmFilter.getShowFilterAction());\n+\t\t\tmm1.add(securityX509AlgorithmFilter.getShowSearchAction());\n+\t\t\tsecurityX509AlgorithmFilter.loadState(state.getChild(SECURITY_X509_ALGORITHM_FILTER));\n+\t\t\ts2.setClient(securityX509AlgorithmFilter.getComponent());\n+\n+\t\t\tPersistableSashForm.loadState(sash, state.getChild(SASH));\n+\t\t\tflavorSelector = FlavorSelector.itemsWithTimerange(form, JdkFilters.SECURITY, getDataSource().getItems(),\n+\t\t\t\t\tpageContainer, this::onInputSelected, this::onShow, flavorSelectorState);\n+\t\t\taddResultActions(form);\n+\t\t\tonAlgorithmFilterChange(securityX509AlgorithmFilterState);\n+\t\t\tsecurityX509AlgorithmTable.getManager().setSelectionState(securityX509AlgorithmSelectionState);\n+\n+\t\t\t\/\/Create Chart\n+\t\t\tComposite chartContainer = toolkit.createComposite(sash);\n+\t\t\tchartContainer.setLayout(new GridLayout(2, false));\n+\t\t\tchartCanvas = new ChartCanvas(chartContainer);\n+\t\t\tchart = new XYChart(pageContainer.getRecordingRange(), RendererToolkit.empty(), 120);\n+\t\t\tchart.setVisibleRange(timelineRange.getStart(), timelineRange.getEnd());\n+\t\t\tchart.addVisibleRangeListener(r -> timelineRange = r);\n+\t\t\tchartCanvas.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));\n+\t\t\tDataPageToolkit.setChart(chartCanvas, chart, pageContainer::showSelection);\n+\t\t\tSelectionStoreActionToolkit.addSelectionStoreRangeActions(pageContainer.getSelectionStore(), chart,\n+\t\t\t\t\tJfrAttributes.LIFETIME, Messages.SecurityPage_TIMELINE_SELECTION, chartCanvas.getContextMenu());\n+\t\t\tDataPageToolkit.createChartTimestampTooltip(chartCanvas);\n+\n+\t\t\tchartLegend = CheckboxTableViewer.newCheckList(chartContainer, SWT.BORDER);\n+\t\t\tGridData gd = new GridData(SWT.FILL, SWT.FILL, false, true);\n+\t\t\tgd.widthHint = 120;\n+\t\t\tchartLegend.getTable().setLayoutData(gd);\n+\t\t\tchartLegend.setContentProvider(ArrayContentProvider.getInstance());\n+\t\t\tchartLegend.setLabelProvider(LEGEND_LP);\n+\t\t\tchartLegend.addCheckStateListener(e -> buildChart());\n+\t\t\tchartLegend.addSelectionChangedListener(e -> buildChart());\n+\t\t\tColumnViewerToolTipSupport.enableFor(chartLegend);\n+\t\t\tList<Object> chartSeries = new ArrayList<>();\n+\t\t\tchartSeries.addAll(Arrays.asList(X509_CERTIFICATE_COUNT));\n+\t\t\tchartLegend.setInput(chartSeries.toArray());\n+\t\t\tIState chartState = state.getChild(CHART);\n+\t\t\tif (chartState != null) {\n+\t\t\t\tfor (IState c : chartState.getChildren()) {\n+\t\t\t\t\tchartLegend.setChecked(c.getAttribute(ID_ATTRIBUTE), true);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tonShow(true);\n+\t\t}\n+\n+\t\tprivate Optional<ItemRow> buildBarChart(\n+\t\t\tIItemCollection items, IAggregator<IQuantity, ?> aggregator, String id) {\n+\t\t\tif (chartLegend.getChecked(id)) {\n+\t\t\t\treturn Optional.of(DataPageToolkit.buildTimestampHistogram(aggregator.getName(),\n+\t\t\t\t\t\taggregator.getDescription(), items, aggregator, DataPageToolkit.getFieldColor(id)));\n+\t\t\t}\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\n+\t\tprivate void buildChart() {\n+\t\t\tIItemCollection itemsInRange = getItems();\n+\t\t\tList<IXDataRenderer> rows = new ArrayList<>();\n+\t\t\tIItemCollection securityEvents = itemsInRange.apply(JdkFilters.SECURITY);\n+\t\t\tbuildBarChart(securityEvents, JdkAggregators.X509_CERTIFICATE_COUNT, X509_CERTIFICATE_COUNT)\n+\t\t\t\t\t.ifPresent(rows::add);\n+\n+\t\t\tIXDataRenderer root = RendererToolkit.uniformRows(rows);\n+\t\t\tchartCanvas.replaceRenderer(root);\n+\t\t}\n+\n+\t\tprivate void onShow(Boolean show) {\n+\t\t\tIRange<IQuantity> range = show ? currentRange : pageContainer.getRecordingRange();\n+\t\t\tchart.setVisibleRange(range.getStart(), range.getEnd());\n+\t\t\tif (chartLegend != null)\n+\t\t\t\tbuildChart();\n+\t\t}\n+\n+\t\tprivate void onInputSelected(IItemCollection items, IRange<IQuantity> timeRange) {\n+\t\t\tthis.currentRange = timeRange;\n+\t\t\tselectionItems = items;\n+\t\t\tsecurityX509AlgorithmTable.show(getItems().apply(JdkFilters.SECURITY));\n+\t\t\tif (chartLegend != null)\n+\t\t\t\tbuildChart();\n+\t\t}\n+\n+\t\tprivate IItemCollection getItems() {\n+\t\t\treturn selectionItems != null ? selectionItems.apply(JdkFilters.SECURITY)\n+\t\t\t\t\t: getDataSource().getItems().apply(JdkFilters.SECURITY);\n+\t\t}\n+\n+\t\tprivate void onAlgorithmFilterChange(IItemFilter filter) {\n+\t\t\tsecurityX509AlgorithmFilter.filterChangeHelper(filter, securityX509AlgorithmTable,\n+\t\t\t\t\tgetDataSource().getItems().apply(JdkFilters.SECURITY));\n+\t\t\tsecurityX509AlgorithmFilterState = filter;\n+\t\t\tif (chartLegend != null)\n+\t\t\t\tbuildChart();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void saveTo(IWritableState state) {\n+\t\t\tPersistableSashForm.saveState(sash, state.createChild(SASH));\n+\t\t\tIWritableState chartState = state.createChild(CHART);\n+\t\t\tsecurityX509AlgorithmTable.getManager().getSettings()\n+\t\t\t\t\t.saveState(state.createChild(SECURITY_X509_ALGORITHM_TABLE));\n+\t\t\tsecurityX509AlgorithmFilter.saveState(state.createChild(SECURITY_X509_ALGORITHM_FILTER));\n+\t\t\tfor (Object o : chartLegend.getCheckedElements()) {\n+\t\t\t\tchartState.createChild(SERIES).putString(ID_ATTRIBUTE, ((String) o));\n+\t\t\t}\n+\n+\t\t\tsaveToLocal();\n+\t\t}\n+\n+\t\tprivate void saveToLocal() {\n+\t\t\tsecurityX509AlgorithmSelectionState = securityX509AlgorithmTable.getManager().getSelectionState();\n+\t\t\tflavorSelectorState = flavorSelector.getFlavorSelectorState();\n+\t\t}\n+\t}\n+\n+\tprivate IRange<IQuantity> timelineRange;\n+\tprivate FlavorSelectorState flavorSelectorState;\n+\tprivate IItemFilter securityX509AlgorithmFilterState;\n+\tprivate SelectionState securityX509AlgorithmSelectionState;\n+\n+\tpublic SecurityPage(IPageDefinition defintion, StreamModel items, IPageContainer editor) {\n+\t\tsuper(defintion, items, editor);\n+\t\ttimelineRange = editor.getRecordingRange();\n+\t}\n+\n+\t@Override\n+\tpublic IItemFilter getDefaultSelectionFilter() {\n+\t\treturn ItemFilters.type(JdkTypeIDs.X509_CERTIFICATE);\n+\t}\n+\n+\t@Override\n+\tpublic IPageUI display(Composite parent, FormToolkit toolkit, IPageContainer editor, IState state) {\n+\t\treturn new SecurityPageUI(parent, toolkit, editor, state);\n+\t}\n+\n+}\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/pages\/SecurityPage.java","additions":389,"deletions":0,"binary":false,"changes":389,"status":"added"},{"patch":"@@ -614,0 +614,6 @@\n+SecurityPage_PAGE_NAME=Security\n+SecurityPage_TIMELINE_SELECTION=Security X509\n+SecurityPage_TABLE_SELECTION=Security X509 Selection\n+SecurityPage_SECTION_X509_CERTIFICATES=X509 Certificates\n+SecurityPage_SECTION_X509_ALGORITHMS=Signature Algorithms\n+\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/ui\/messages\/internal\/messages.properties","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,5 @@\n+<svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+  <circle cx=\"8\" cy=\"8\" r=\"7\" fill=\"#8B0000\"\/>\n+  <line x1=\"4.5\" y1=\"4.5\" x2=\"11.5\" y2=\"11.5\" stroke=\"white\" stroke-width=\"2.5\" stroke-linecap=\"round\"\/>\n+  <line x1=\"11.5\" y1=\"4.5\" x2=\"4.5\" y2=\"11.5\" stroke=\"white\" stroke-width=\"2.5\" stroke-linecap=\"round\"\/>\n+<\/svg>\n\\ No newline at end of file\n","filename":"application\/org.openjdk.jmc.ui\/icons\/crypto_action.svg","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+<svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+  <circle cx=\"8\" cy=\"8\" r=\"7\" fill=\"#FFB84D\"\/>\n+  <line x1=\"4.5\" y1=\"4.5\" x2=\"11.5\" y2=\"11.5\" stroke=\"white\" stroke-width=\"2.5\" stroke-linecap=\"round\"\/>\n+  <line x1=\"11.5\" y1=\"4.5\" x2=\"4.5\" y2=\"11.5\" stroke=\"white\" stroke-width=\"2.5\" stroke-linecap=\"round\"\/>\n+<\/svg>\n\\ No newline at end of file\n","filename":"application\/org.openjdk.jmc.ui\/icons\/crypto_attention.svg","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+<svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+  <circle cx=\"8\" cy=\"8\" r=\"7\" fill=\"#00CC00\"\/>\n+  <path d=\"M5 8.5 L7 10.5 L11 5.5\" stroke=\"white\" stroke-width=\"2.5\" fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\"\/>\n+<\/svg>\n\\ No newline at end of file\n","filename":"application\/org.openjdk.jmc.ui\/icons\/crypto_ok.svg","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -195,0 +195,6 @@\n+\tpublic static final String ICON_CRYPTO_ACTION = \"crypto_action.svg\"; \/\/$NON-NLS-1$\n+\n+\tpublic static final String ICON_CRYPTO_ATTENTION = \"crypto_attention.svg\"; \/\/$NON-NLS-1$\n+\n+\tpublic static final String ICON_CRYPTO_OK = \"crypto_ok.svg\"; \/\/$NON-NLS-1$\n+\n","filename":"application\/org.openjdk.jmc.ui\/src\/main\/java\/org\/openjdk\/jmc\/ui\/UIPlugin.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1047,0 +1047,4 @@\n+\tpublic static IAggregator<String, ?> distinctAttribute(String typeId, IAttribute<String> attribute) {\n+\t\treturn filter(distinctAsString(attribute, \"~ \"), ItemFilters.type(typeId)); \/\/$NON-NLS-1$\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.common\/src\/main\/java\/org\/openjdk\/jmc\/common\/item\/Aggregators.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,0 +88,14 @@\n+\tpublic static final String Crypto_ACTION = \"Crypto_ACTION\"; \/\/$NON-NLS-1$\n+\tpublic static final String Crypto_ATTENTION = \"Crypto_ATTENTION\"; \/\/$NON-NLS-1$\n+\tpublic static final String Crypto_OK = \"Crypto_OK\"; \/\/$NON-NLS-1$\n+\tpublic static final String Crypto_SHA1 = \"Crypto_SHA1\"; \/\/$NON-NLS-1$\n+\tpublic static final String Crypto_MD2 = \"Crypto_MD2\"; \/\/$NON-NLS-1$\n+\tpublic static final String Crypto_MD5 = \"Crypto_MD5\"; \/\/$NON-NLS-1$\n+\tpublic static final String Crypto_RSA_INSUFFICIENT_KEY_SIZE = \"Crypto_RSA_INSUFFICIENT_KEY_SIZE\"; \/\/$NON-NLS-1$\n+\tpublic static final String Crypto_RSA_KEY_SIZE_1024 = \"Crypto_RSA_KEY_SIZE_1024\"; \/\/$NON-NLS-1$\n+\tpublic static final String Crypto_RSA_KEY_SIZE_LESS_2048 = \"Crypto_RSA_KEY_SIZE_LESS_2048\"; \/\/$NON-NLS-1$\n+\tpublic static final String Crypto_DSA_INSUFFICIENT_KEY_SIZE = \"Crypto_DSA_INSUFFICIENT_KEY_SIZE\"; \/\/$NON-NLS-1$\n+\tpublic static final String Crypto_DSA_KEY_SIZE_LESS_2048 = \"Crypto_DSA_KEY_SIZE_LESS_2048\"; \/\/$NON-NLS-1$\n+\tpublic static final String Crypto_EC_INSUFFICIENT_KEY_SIZE = \"Crypto_EC_INSUFFICIENT_KEY_SIZE\"; \/\/$NON-NLS-1$\n+\tpublic static final String Crypto_Certificate_Expiring = \"Crypto_Certificate_Expiring\"; \/\/$NON-NLS-1$\n+\tpublic static final String Crypto_Certificate_Expired = \"Crypto_Certificate_Expired\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.common\/src\/main\/java\/org\/openjdk\/jmc\/common\/messages\/internal\/Messages.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.common.security;\n+\n+import java.text.MessageFormat;\n+import org.openjdk.jmc.common.messages.internal.Messages;\n+import org.openjdk.jmc.common.unit.IQuantity;\n+import org.openjdk.jmc.common.unit.UnitLookup;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+public class CryptoUtil {\n+\n+\tprivate static final String ACTION = Messages.getString(Messages.Crypto_ACTION);\n+\tprivate static final String ATTENTION = Messages.getString(Messages.Crypto_ATTENTION);\n+\tprivate static final String OK = Messages.getString(Messages.Crypto_OK);\n+\n+\tpublic static String getCryptoRemark(\n+\t\tString signatureAlgorithm, String keyType, Long keyLength, IQuantity expiryDate) {\n+\n+\t\tString remark = \"\";\n+\n+\t\tif (signatureAlgorithm.contains(\"SHA1\")) {\n+\t\t\tremark = ATTENTION.concat(Messages.getString(Messages.Crypto_SHA1));\n+\t\t} else if (signatureAlgorithm.contains(\"MD2\")) {\n+\t\t\tremark = ACTION.concat(Messages.getString(Messages.Crypto_MD2));\n+\t\t} else if (signatureAlgorithm.contains(\"MD5\")) {\n+\t\t\tremark = ACTION.concat(Messages.getString(Messages.Crypto_MD5));\n+\t\t}\n+\n+\t\tif (keyType.contains(\"RSA\")) {\n+\t\t\tif (keyLength < 1024) {\n+\t\t\t\tremark = ACTION.concat(Messages.getString(Messages.Crypto_RSA_INSUFFICIENT_KEY_SIZE)).concat(remark);\n+\t\t\t} else if (keyLength == 1024) {\n+\t\t\t\tremark = ACTION.concat(Messages.getString(Messages.Crypto_RSA_KEY_SIZE_1024)).concat(remark);\n+\t\t\t} else if (keyLength < 2048) {\n+\t\t\t\tremark = remark.concat(ATTENTION).concat(Messages.getString(Messages.Crypto_RSA_KEY_SIZE_LESS_2048));\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (keyType.contains(\"DSA\")) {\n+\t\t\tif (keyLength < 1024) {\n+\t\t\t\tremark = ACTION.concat(Messages.getString(Messages.Crypto_DSA_INSUFFICIENT_KEY_SIZE)).concat(remark);\n+\t\t\t} else if (keyLength < 2048) {\n+\t\t\t\tremark = remark.concat(ATTENTION).concat(Messages.getString(Messages.Crypto_DSA_KEY_SIZE_LESS_2048));\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (keyType.contains(\"EC\")) {\n+\t\t\tif (keyLength < 224) {\n+\t\t\t\tremark = ACTION.concat(Messages.getString(Messages.Crypto_EC_INSUFFICIENT_KEY_SIZE)).concat(remark);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (expiryDate != null) {\n+\n+\t\t\tIQuantity duration = expiryDate.subtract(UnitLookup.EPOCH_MS.quantity(System.currentTimeMillis()));\n+\t\t\tlong expiringInDays = TimeUnit.MILLISECONDS.toDays(duration.longValue());\n+\n+\t\t\tif ((expiringInDays > 0) && (expiringInDays < 90)) {\n+\t\t\t\tremark = remark.concat(ATTENTION).concat(\n+\t\t\t\t\t\tMessageFormat.format(Messages.getString(Messages.Crypto_Certificate_Expiring), expiringInDays));\n+\t\t\t} else if (expiringInDays < 0) {\n+\t\t\t\tremark = ACTION.concat(MessageFormat.format(Messages.getString(Messages.Crypto_Certificate_Expired),\n+\t\t\t\t\t\t(expiringInDays * -1))).concat(remark);\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\tif (remark.equals(\"\")) {\n+\t\t\tremark = OK;\n+\t\t}\n+\n+\t\treturn remark;\n+\t}\n+\n+\tpublic static String getCryptoIcon(\n+\t\tString signatureAlgorithm, String keyType, Long keyLength, IQuantity expiryDate) {\n+\n+\t\tString icon = \"\";\n+\n+\t\tif (signatureAlgorithm.contains(\"SHA1\")) {\n+\t\t\ticon = \"ATTENTION\";\n+\t\t} else if (signatureAlgorithm.contains(\"MD2\")) {\n+\t\t\ticon = \"ACTION\";\n+\t\t} else if (signatureAlgorithm.contains(\"MD5\")) {\n+\t\t\ticon = \"ACTION\";\n+\t\t}\n+\n+\t\tif (keyType.contains(\"RSA\")) {\n+\t\t\tif (keyLength < 1024) {\n+\t\t\t\ticon = \"ACTION\".concat(icon);\n+\t\t\t} else if (keyLength == 1024) {\n+\t\t\t\ticon = \"ACTION\".concat(icon);\n+\t\t\t} else if (keyLength < 2048) {\n+\t\t\t\ticon = icon.concat(\"ATTENTION\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (keyType.contains(\"DSA\")) {\n+\t\t\tif (keyLength < 1024) {\n+\t\t\t\ticon = \"ACTION\".concat(icon);\n+\t\t\t} else if (keyLength < 2048) {\n+\t\t\t\ticon = icon.concat(\"ATTENTION\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (keyType.contains(\"EC\")) {\n+\t\t\tif (keyLength < 224) {\n+\t\t\t\ticon = \"ACTION\".concat(icon);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (expiryDate != null) {\n+\n+\t\t\tIQuantity duration = expiryDate.subtract(UnitLookup.EPOCH_MS.quantity(System.currentTimeMillis()));\n+\t\t\tlong expiringInDays = TimeUnit.MILLISECONDS.toDays(duration.longValue());\n+\n+\t\t\tif ((expiringInDays > 0) && (expiringInDays < 90)) {\n+\t\t\t\ticon = icon.concat(\"ATTENTION\");\n+\t\t\t} else if (expiringInDays < 0) {\n+\t\t\t\ticon = \"ACTION\".concat(icon);\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\tif (icon.equals(\"\")) {\n+\t\t\ticon = \"OK\";\n+\t\t}\n+\n+\t\treturn icon;\n+\t}\n+\n+\tpublic static String getCryptoRuleResult(\n+\t\tString signatureAlgorithm, String keyType, Long keyLength, IQuantity expiryDate, Number certificateId) {\n+\n+\t\tList<Map.Entry<String, String>> remarks = new ArrayList<>();\n+\t\tString strCertificateId = \"\";\n+\t\tif (!certificateId.equals(0)) {\n+\t\t\tstrCertificateId = \"Certificate Id : \".concat(certificateId.toString()).concat(\" - \");\n+\t\t}\n+\n+\t\tif (signatureAlgorithm.contains(\"SHA1\")) {\n+\t\t\tremarks.add(Map.entry(ATTENTION, strCertificateId.concat(Messages.getString(Messages.Crypto_SHA1))));\n+\t\t} else if (signatureAlgorithm.contains(\"MD2\")) {\n+\t\t\tremarks.add(Map.entry(ACTION, strCertificateId.concat(Messages.getString(Messages.Crypto_MD2))));\n+\t\t} else if (signatureAlgorithm.contains(\"MD5\")) {\n+\t\t\tremarks.add(Map.entry(ACTION, strCertificateId.concat(Messages.getString(Messages.Crypto_MD5))));\n+\t\t}\n+\n+\t\tif (keyType.contains(\"RSA\")) {\n+\t\t\tif (keyLength < 1024) {\n+\t\t\t\tremarks.add(Map.entry(ACTION,\n+\t\t\t\t\t\tstrCertificateId.concat(Messages.getString(Messages.Crypto_RSA_INSUFFICIENT_KEY_SIZE))));\n+\t\t\t} else if (keyLength == 1024) {\n+\t\t\t\tremarks.add(Map.entry(ACTION,\n+\t\t\t\t\t\tstrCertificateId.concat(Messages.getString(Messages.Crypto_RSA_KEY_SIZE_1024))));\n+\t\t\t} else if (keyLength < 2048) {\n+\t\t\t\tremarks.add(Map.entry(ATTENTION,\n+\t\t\t\t\t\tstrCertificateId.concat(Messages.getString(Messages.Crypto_RSA_KEY_SIZE_LESS_2048))));\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (keyType.contains(\"DSA\")) {\n+\t\t\tif (keyLength < 1024) {\n+\t\t\t\tremarks.add(Map.entry(ACTION,\n+\t\t\t\t\t\tstrCertificateId.concat(Messages.getString(Messages.Crypto_DSA_INSUFFICIENT_KEY_SIZE))));\n+\t\t\t} else if (keyLength < 2048) {\n+\t\t\t\tremarks.add(Map.entry(ATTENTION,\n+\t\t\t\t\t\tstrCertificateId.concat(Messages.getString(Messages.Crypto_DSA_KEY_SIZE_LESS_2048))));\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (keyType.contains(\"EC\")) {\n+\t\t\tif (keyLength < 224) {\n+\t\t\t\tremarks.add(Map.entry(ACTION,\n+\t\t\t\t\t\tstrCertificateId.concat(Messages.getString(Messages.Crypto_EC_INSUFFICIENT_KEY_SIZE))));\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (expiryDate != null) {\n+\n+\t\t\tIQuantity duration = expiryDate.subtract(UnitLookup.EPOCH_MS.quantity(System.currentTimeMillis()));\n+\t\t\tlong expiringInDays = TimeUnit.MILLISECONDS.toDays(duration.longValue());\n+\n+\t\t\tif ((expiringInDays > 0) && (expiringInDays < 90)) {\n+\t\t\t\tremarks.add(Map.entry(ATTENTION, strCertificateId.concat(MessageFormat\n+\t\t\t\t\t\t.format(Messages.getString(Messages.Crypto_Certificate_Expiring), expiringInDays))));\n+\t\t\t} else if (expiringInDays < 0) {\n+\t\t\t\tremarks.add(Map.entry(ACTION, strCertificateId.concat(MessageFormat\n+\t\t\t\t\t\t.format(Messages.getString(Messages.Crypto_Certificate_Expired), (expiringInDays * -1)))));\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\tif (remarks.isEmpty()) {\n+\t\t\tremarks.add(Map.entry(OK, \"Everything is fine\"));\n+\t\t}\n+\n+\t\treturn convertRemarksToFormattedString(remarks);\n+\t}\n+\n+\tpublic static String convertRemarksToFormattedString(List<Map.Entry<String, String>> entries) {\n+\t\tMap<String, List<String>> groupedMap = new LinkedHashMap<>();\n+\t\tfor (Map.Entry<String, String> entry : entries) {\n+\t\t\tgroupedMap.computeIfAbsent(entry.getKey(), k -> new ArrayList<>())\n+\t\t\t\t\t.add(entry.getKey().concat(entry.getValue()));\n+\t\t}\n+\n+\t\tStringBuilder result = new StringBuilder();\n+\n+\t\tfor (Map.Entry<String, List<String>> entry : groupedMap.entrySet()) {\n+\t\t\tfor (String value : entry.getValue()) {\n+\t\t\t\tif (value.contains(\"Everything is fine\"))\n+\t\t\t\t\tcontinue;\n+\t\t\t\tresult.append(\"   â€¢ \").append(value).append(\"\\n\");\n+\t\t\t}\n+\t\t}\n+\t\treturn result.toString().trim();\n+\t}\n+\n+}\n","filename":"core\/org.openjdk.jmc.common\/src\/main\/java\/org\/openjdk\/jmc\/common\/security\/CryptoUtil.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -211,0 +211,15 @@\n+\n+Crypto_ACTION=Action Required.\n+Crypto_ATTENTION=Attention Needed.\n+Crypto_OK=Ok\n+Crypto_SHA1= SHA-1 signature. \n+Crypto_MD2= MD2 signature. \n+Crypto_MD5= MD5 signature. \n+Crypto_RSA_INSUFFICIENT_KEY_SIZE= RSA signature with insufficient key size. \n+Crypto_RSA_KEY_SIZE_1024= Removed root certificates with 1024-bit keys. \n+Crypto_RSA_KEY_SIZE_LESS_2048= Use RSA recommended key size. \n+Crypto_DSA_INSUFFICIENT_KEY_SIZE= DSA signature with insufficient key size. \n+Crypto_DSA_KEY_SIZE_LESS_2048= Use DSA recommended key size. \n+Crypto_EC_INSUFFICIENT_KEY_SIZE= EC signature with insufficient key size. \n+Crypto_Certificate_Expiring= The Certificate is expiring in  {0} days.\n+Crypto_Certificate_Expired= The Certificate has expired before {0} days.\n","filename":"core\/org.openjdk.jmc.common\/src\/main\/resources\/org\/openjdk\/jmc\/common\/messages\/internal\/messages.properties","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,261 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.rules.jdk.general;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RunnableFuture;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.util.IPreferenceValueProvider;\n+import org.openjdk.jmc.common.util.TypedPreference;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkAttributes;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;\n+import org.openjdk.jmc.flightrecorder.rules.IResult;\n+import org.openjdk.jmc.flightrecorder.rules.IResultValueProvider;\n+import org.openjdk.jmc.flightrecorder.rules.IRule;\n+import org.openjdk.jmc.flightrecorder.rules.ResultBuilder;\n+import org.openjdk.jmc.flightrecorder.rules.Severity;\n+import org.openjdk.jmc.flightrecorder.rules.TypedResult;\n+import org.openjdk.jmc.flightrecorder.rules.jdk.messages.internal.Messages;\n+import org.openjdk.jmc.flightrecorder.rules.util.JfrRuleTopics;\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit;\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit.EventAvailability;\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit.RequiredEventsBuilder;\n+\n+public class CryptoSecurityRule implements IRule {\n+\n+\tprivate static final String CRYPTO_SECURITY_RESULT_ID = \"CryptoSecurityRule\"; \/\/$NON-NLS-1$\n+\n+\tprivate static final Map<String, EventAvailability> REQUIRED_EVENTS = RequiredEventsBuilder.create()\n+\t\t\t.addEventType(JdkTypeIDs.X509_CERTIFICATE, EventAvailability.AVAILABLE).build();\n+\n+\tprivate static final String ACTION = Messages.getString(Messages.Crypto_ACTION);\n+\n+\tprivate static final String ATTENTION = Messages.getString(Messages.Crypto_ATTENTION);\n+\n+\tprivate static final Collection<TypedResult<?>> RESULT_ATTRIBUTES = Arrays\n+\t\t\t.<TypedResult<?>> asList(TypedResult.SCORE);\n+\n+\t@Override\n+\tpublic String getId() {\n+\t\treturn CRYPTO_SECURITY_RESULT_ID;\n+\t}\n+\n+\t@Override\n+\tpublic String getTopic() {\n+\t\treturn JfrRuleTopics.SECURITY;\n+\t}\n+\n+\t@Override\n+\tpublic String getName() {\n+\t\treturn Messages.getString(Messages.CryptoSecurity_RULE_NAME);\n+\t}\n+\n+\t@Override\n+\tpublic Map<String, EventAvailability> getRequiredEvents() {\n+\t\treturn REQUIRED_EVENTS;\n+\t}\n+\n+\tprivate IResult getResult(\n+\t\tIItemCollection items, IPreferenceValueProvider valueProvider, IResultValueProvider resultProvider) {\n+\n+\t\tboolean actionNeeded = (RulesToolkit.findMatches(JdkTypeIDs.X509_CERTIFICATE, items,\n+\t\t\t\tJdkAttributes.CRYPTO_REMARK, Messages.getString(Messages.Crypto_ACTION), false) != null); \/\/$NON-NLS-1$\n+\t\tboolean attentionNeeded = (RulesToolkit.findMatches(JdkTypeIDs.X509_CERTIFICATE, items,\n+\t\t\t\tJdkAttributes.CRYPTO_REMARK, Messages.getString(Messages.Crypto_ATTENTION), false) != null); \/\/$NON-NLS-1$\n+\n+\t\tString ruleResult = RulesToolkit.findAttribute(JdkTypeIDs.X509_CERTIFICATE, items,\n+\t\t\t\tJdkAttributes.CRYPTO_RULE_RESULT);\n+\t\tResult processedResult = processResult(ruleResult);\n+\n+\t\truleResult = processedResult.cleanedAllActions + \"\\n\" + processedResult.cleanedAllAttentions;\n+\n+\t\tif (actionNeeded) {\n+\t\t\tif (attentionNeeded) {\n+\t\t\t\treturn ResultBuilder.createFor(CryptoSecurityRule.this, valueProvider).setSeverity(Severity.WARNING)\n+\t\t\t\t\t\t.setSummary(Messages.getString(Messages.Crypto_ACTION_ATTENTION_INFO)\n+\t\t\t\t\t\t\t\t+ MessageFormat.format(Messages.getString(Messages.Crypto_REFERENCE_INFO), ruleResult))\n+\t\t\t\t\t\t.build();\n+\t\t\t} else {\n+\t\t\t\treturn ResultBuilder.createFor(CryptoSecurityRule.this, valueProvider).setSeverity(Severity.WARNING)\n+\t\t\t\t\t\t.setSummary(Messages.getString(Messages.Crypto_ACTION_INFO)\n+\t\t\t\t\t\t\t\t+ MessageFormat.format(Messages.getString(Messages.Crypto_REFERENCE_INFO), ruleResult))\n+\t\t\t\t\t\t.build();\n+\t\t\t}\n+\t\t} else if (attentionNeeded) {\n+\t\t\treturn ResultBuilder.createFor(CryptoSecurityRule.this, valueProvider).setSeverity(Severity.WARNING)\n+\t\t\t\t\t.setSummary(Messages.getString(Messages.Crypto_ATTENTION_INFO)\n+\t\t\t\t\t\t\t+ MessageFormat.format(Messages.getString(Messages.Crypto_REFERENCE_INFO), ruleResult))\n+\t\t\t\t\t.build();\n+\t\t} else {\n+\t\t\treturn ResultBuilder.createFor(CryptoSecurityRule.this, valueProvider).setSeverity(Severity.OK)\n+\t\t\t\t\t.setSummary(\"OK\").build();\n+\t\t}\n+\n+\t}\n+\n+\tpublic static class Result {\n+\t\tpublic final String allActions; \/\/ joined by '~'\n+\t\tpublic final String allAttentions; \/\/ joined by '~'\n+\t\tpublic final int allActionCount;\n+\t\tpublic final int allAttentionCount;\n+\t\tpublic final String cleanedAllActions; \/\/ allActions with \"Action Required.\" removed\n+\t\tpublic final String cleanedAllAttentions;\/\/ allAttentions with \"Attention Needed.\" removed\n+\n+\t\tpublic Result(String allActions, String allAttentions, int allActionCount, int allAttentionCount,\n+\t\t\t\tString cleanedAllActions, String cleanedAllAttentions) {\n+\t\t\tthis.allActions = allActions;\n+\t\t\tthis.allAttentions = allAttentions;\n+\t\t\tthis.allActionCount = allActionCount;\n+\t\t\tthis.allAttentionCount = allAttentionCount;\n+\t\t\tthis.cleanedAllActions = cleanedAllActions;\n+\t\t\tthis.cleanedAllAttentions = cleanedAllAttentions;\n+\t\t}\n+\t}\n+\n+\tprivate Result processResult(String input) {\n+\n+\t\tif (input == null)\n+\t\t\tinput = \"\";\n+\n+\t\tfinal String ACTION_BULLET = \"ðŸ”´ \";\n+\t\tfinal String ATTENTION_BULLET = \"ðŸŸ  \";\n+\n+\t\tString[] tokens = input.split(\"~\", -1);\n+\n+\t\tList<String> actionFragments = new ArrayList<>();\n+\t\tList<String> attentionFragments = new ArrayList<>();\n+\t\tList<String> originalFragments = new ArrayList<>();\n+\n+\t\tString bulletChars = \"[\\\\u2022\\\\u2023\\\\u2027â€¢\\\\*]\";\n+\t\tString patternString = \"(?s)\\\\b(?:Action Required\\\\.|Attention Needed\\\\.).*?(?=(?:\" + bulletChars + \")|$)\";\n+\t\tPattern fragmentPattern = Pattern.compile(patternString);\n+\n+\t\tfor (String token : tokens) {\n+\t\t\tif (token == null || token.trim().isEmpty())\n+\t\t\t\tcontinue;\n+\n+\t\t\tMatcher m = fragmentPattern.matcher(token);\n+\t\t\twhile (m.find()) {\n+\t\t\t\tString frag = m.group().trim();\n+\t\t\t\tfrag = frag.replaceAll(\"^[\\\\s\\\\u2022\\\\u2023\\\\u2027â€¢\\\\*]+\", \"\").trim();\n+\n+\t\t\t\tif (frag.isEmpty())\n+\t\t\t\t\tcontinue;\n+\n+\t\t\t\tboolean isAction = frag.contains(ACTION);\n+\t\t\t\tboolean isAttention = frag.contains(ATTENTION);\n+\n+\t\t\t\tif (isAction) {\n+\t\t\t\t\tactionFragments.add(ACTION_BULLET + frag);\n+\t\t\t\t}\n+\t\t\t\tif (isAttention) {\n+\t\t\t\t\tattentionFragments.add(ATTENTION_BULLET + frag);\n+\t\t\t\t}\n+\n+\t\t\t\tString prefix;\n+\t\t\t\tif (isAction && isAttention)\n+\t\t\t\t\tprefix = ACTION_BULLET + ATTENTION_BULLET;\n+\t\t\t\telse if (isAction)\n+\t\t\t\t\tprefix = ACTION_BULLET;\n+\t\t\t\telse if (isAttention)\n+\t\t\t\t\tprefix = ATTENTION_BULLET;\n+\t\t\t\telse\n+\t\t\t\t\tprefix = \"\";\n+\n+\t\t\t\tString fragClean = frag.replace(ACTION, \"\").replace(ATTENTION, \"\").trim();\n+\n+\t\t\t\tif (!fragClean.isEmpty()) {\n+\t\t\t\t\toriginalFragments.add(prefix + fragClean);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tint allActionCount = actionFragments.size();\n+\t\tint allAttentionCount = attentionFragments.size();\n+\n+\t\t\/\/ Build titled sections\n+\t\tString allActions = \"\\nAction Required (\" + allActionCount + \")\\n\\n\"\n+\t\t\t\t+ (actionFragments.isEmpty() ? \"\" : String.join(\"\\n\", actionFragments)) + \"\\n\";\n+\n+\t\tString allAttentions = \"\\nAttention Needed (\" + allAttentionCount + \")\\n\\n\"\n+\t\t\t\t+ (attentionFragments.isEmpty() ? \"\" : String.join(\"\\n\", attentionFragments)) + \"\\n\";\n+\n+\t\t\/\/ Clean versions\n+\t\tString cleanedAllActions = \"\\n\\nAction Required (\" + allActionCount + \")\\n\\n\" + actionFragments.stream()\n+\t\t\t\t.map(s -> s.replace(ACTION, \"\").trim()).filter(s -> !s.isEmpty()).collect(Collectors.joining(\"\\n\"))\n+\t\t\t\t+ \"\\n\";\n+\n+\t\tString cleanedAllAttentions = \"\\nAttention Needed (\" + allAttentionCount + \")\\n\\n\" + attentionFragments.stream()\n+\t\t\t\t.map(s -> s.replace(ATTENTION, \"\").trim()).filter(s -> !s.isEmpty()).collect(Collectors.joining(\"\\n\"))\n+\t\t\t\t+ \"\\n\";\n+\n+\t\treturn new Result(allActions, allAttentions, allActionCount, allAttentionCount, cleanedAllActions,\n+\t\t\t\tcleanedAllAttentions);\n+\t}\n+\n+\t@Override\n+\tpublic RunnableFuture<IResult> createEvaluation(\n+\t\tfinal IItemCollection items, final IPreferenceValueProvider preferenceValueProvider,\n+\t\tfinal IResultValueProvider dependencyResults) {\n+\t\tFutureTask<IResult> evaluationTask = new FutureTask<>(new Callable<IResult>() {\n+\t\t\t@Override\n+\t\t\tpublic IResult call() throws Exception {\n+\t\t\t\treturn getResult(items, preferenceValueProvider, dependencyResults);\n+\t\t\t}\n+\t\t});\n+\t\treturn evaluationTask;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<TypedPreference<?>> getConfigurationAttributes() {\n+\t\treturn Collections.emptyList();\n+\t}\n+\n+\t@Override\n+\tpublic Collection<TypedResult<?>> getResults() {\n+\t\treturn RESULT_ATTRIBUTES;\n+\t}\n+\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/general\/CryptoSecurityRule.java","additions":261,"deletions":0,"binary":false,"changes":261,"status":"added"},{"patch":"@@ -328,0 +328,7 @@\n+\tpublic static final String CryptoSecurity_RULE_NAME = \"CryptoSecurity_RULE_NAME\"; \/\/$NON-NLS-1$\n+\tpublic static final String Crypto_ACTION = \"Crypto_ACTION\"; \/\/$NON-NLS-1$\n+\tpublic static final String Crypto_ATTENTION = \"Crypto_ATTENTION\"; \/\/$NON-NLS-1$\n+\tpublic static final String Crypto_ACTION_INFO = \"Crypto_ACTION_INFO\"; \/\/$NON-NLS-1$\n+\tpublic static final String Crypto_ATTENTION_INFO = \"Crypto_ATTENTION_INFO\"; \/\/$NON-NLS-1$\n+\tpublic static final String Crypto_ACTION_ATTENTION_INFO = \"Crypto_ACTION_ATTENTION_INFO\"; \/\/$NON-NLS-1$\n+\tpublic static final String Crypto_REFERENCE_INFO = \"Crypto_REFERENCE_INFO\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/Messages.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+org.openjdk.jmc.flightrecorder.rules.jdk.general.CryptoSecurityRule\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/resources\/META-INF\/services\/org.openjdk.jmc.flightrecorder.rules.IRule","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -175,0 +175,7 @@\n+CryptoSecurity_RULE_NAME=Crypto Security Rule\n+Crypto_ACTION=Action Required.\n+Crypto_ATTENTION=Attention Needed.\n+Crypto_ACTION_INFO=Action Required in specific domains.\n+Crypto_ATTENTION_INFO=Attention Needed in specific domains.\n+Crypto_ACTION_ATTENTION_INFO=Observations indicate action and attention are needed in specific domains.\n+Crypto_REFERENCE_INFO={0} \\n Please refer Security screen for more details.\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/messages.properties","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+\tpublic static final String SECURITY = \"security\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/util\/JfrRuleTopics.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -290,0 +290,6 @@\n+\tpublic static String findAttribute(String typeId, IItemCollection items, IAttribute<String> attribute) {\n+\n+\t\treturn items.getAggregate((IAggregator<String, ?>) Aggregators\n+\t\t\t\t.filter(Aggregators.distinctAttribute(typeId, attribute), ItemFilters.and(ItemFilters.type(typeId))));\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/util\/RulesToolkit.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -527,0 +527,6 @@\n+\tpublic static final IAggregator<IQuantity, ?> X509_CERTIFICATE_COUNT = Aggregators\n+\t\t\t.count(Messages.getString(Messages.AGGR_X509_CERTIFICATES_COUNT), JdkTypeIDs.X509_CERTIFICATE);\n+\n+\tpublic static final IAggregator<Boolean, ?> IS_CERTIFICATE_ID_QTY = or(JdkTypeIDs.X509_CERTIFICATE,\n+\t\t\tJdkAttributes.IS_CERTIFICATE_ID_QTY);\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkAggregators.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+import org.openjdk.jmc.common.security.CryptoUtil;\n@@ -1440,0 +1441,177 @@\n+\n+\t\/\/Security related attributes\n+\tpublic static final IAttribute<String> SIGNATURE_ALGORITHM = new Attribute<String>(\"algorithm\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_SIGNATURE_ALGORITHM),\n+\t\t\tMessages.getString(Messages.ATTR_SIGNATURE_ALGORITHM), PLAIN_TEXT) {\n+\t};\n+\n+\tpublic static final IAttribute<Number> CERTIFICATE_ID = new Attribute<Number>(\"certificateId\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_CERTIFICATE_ID), Messages.getString(Messages.ATTR_CERTIFICATE_ID),\n+\t\t\tRAW_NUMBER) {\n+\t};\n+\n+\tpublic static final IAttribute<IQuantity> CERTIFICATE_ID_QTY = new Attribute<IQuantity>(\"certificateId\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_CERTIFICATE_ID), Messages.getString(Messages.ATTR_CERTIFICATE_ID),\n+\t\t\tNUMBER) {\n+\t};\n+\n+\tpublic static final IAttribute<Boolean> IS_CERTIFICATE_ID_QTY = Attribute.canonicalize(new Attribute<Boolean>(\n+\t\t\t\"isCertificateIdQty\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_CRYPTO_ICON), Messages.getString(Messages.ATTR_CRYPTO_ICON_DESC), FLAG) {\n+\t\t@Override\n+\t\tpublic <U> IMemberAccessor<Boolean, U> customAccessor(IType<U> type) {\n+\t\t\tfinal IMemberAccessor<Number, U> certificateIdAccessor = type.getAccessor(CERTIFICATE_ID.getKey());\n+\t\t\tfinal IMemberAccessor<IQuantity, U> certificateIdPre9Accessor = type\n+\t\t\t\t\t.getAccessor(CERTIFICATE_ID_QTY.getKey());\n+\t\t\treturn new IMemberAccessor<Boolean, U>() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic Boolean getMember(U i) {\n+\t\t\t\t\tif (certificateIdAccessor != null) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t} else if (certificateIdPre9Accessor != null) {\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t};\n+\t\t}\n+\t});\n+\n+\tpublic static final IAttribute<String> CERTIFICATE_ISSUER = new Attribute<String>(\"issuer\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_CERTIFICATE_ISSUER), Messages.getString(Messages.ATTR_CERTIFICATE_ISSUER),\n+\t\t\tPLAIN_TEXT) {\n+\t};\n+\n+\tpublic static final IAttribute<IQuantity> KEY_LENGTH = new Attribute<IQuantity>(\"keyLength\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_KEY_LENGTH), Messages.getString(Messages.ATTR_KEY_LENGTH), NUMBER) {\n+\t};\n+\n+\tpublic static final IAttribute<String> KEY_TYPE = new Attribute<String>(\"keyType\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_KEY_TYPE), Messages.getString(Messages.ATTR_KEY_TYPE), PLAIN_TEXT) {\n+\t};\n+\n+\tpublic static final IAttribute<String> SERIAL_NUMBER = new Attribute<String>(\"serialNumber\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_SERIAL_NUMBER), Messages.getString(Messages.ATTR_SERIAL_NUMBER),\n+\t\t\tPLAIN_TEXT) {\n+\t};\n+\n+\tpublic static final IAttribute<String> SUBJECT = new Attribute<String>(\"subject\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_SUBJECT), Messages.getString(Messages.ATTR_SUBJECT), PLAIN_TEXT) {\n+\t};\n+\n+\tpublic static final IAttribute<IQuantity> VALID_FROM = new Attribute<IQuantity>(\"validFrom\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_VALID_FROM), Messages.getString(Messages.ATTR_RSS_PEAK_DESC), TIMESTAMP) {\n+\t};\n+\n+\tpublic static final IAttribute<IQuantity> VALID_UNTIL = new Attribute<IQuantity>(\"validUntil\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_VALID_UNTIL), Messages.getString(Messages.ATTR_RSS_PEAK_DESC), TIMESTAMP) {\n+\t};\n+\n+\tpublic static final IAttribute<String> CRYPTO_REMARK = Attribute.canonicalize(new Attribute<String>(\"cryptoRemark\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_CRYPTO_REMARK), Messages.getString(Messages.ATTR_CRYPTO_REMARK_DESC),\n+\t\t\tPLAIN_TEXT) {\n+\t\t@Override\n+\t\tpublic <U> IMemberAccessor<String, U> customAccessor(IType<U> type) {\n+\t\t\tfinal IMemberAccessor<String, U> signatureAlgorithmAccessor = type\n+\t\t\t\t\t.getAccessor(SIGNATURE_ALGORITHM.getKey());\n+\t\t\tfinal IMemberAccessor<String, U> keyTypeAccessor = type.getAccessor(KEY_TYPE.getKey());\n+\t\t\tfinal IMemberAccessor<IQuantity, U> keyLengthAccessor = type.getAccessor(KEY_LENGTH.getKey());\n+\t\t\tfinal IMemberAccessor<IQuantity, U> expiryDateAccessor = type.getAccessor(VALID_UNTIL.getKey());\n+\t\t\tif ((signatureAlgorithmAccessor == null) || (keyTypeAccessor == null) || (keyLengthAccessor == null)) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treturn new IMemberAccessor<String, U>() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic String getMember(U i) {\n+\t\t\t\t\tString signatureAlgorithm = signatureAlgorithmAccessor.getMember(i);\n+\t\t\t\t\tString keyType = keyTypeAccessor.getMember(i);\n+\t\t\t\t\tIQuantity keyLength = keyLengthAccessor.getMember(i);\n+\t\t\t\t\tIQuantity expiryDate = null;\n+\t\t\t\t\tif (expiryDateAccessor != null) {\n+\t\t\t\t\t\texpiryDate = expiryDateAccessor.getMember(i);\n+\t\t\t\t\t}\n+\t\t\t\t\treturn signatureAlgorithm != null && keyType != null && keyLength != null\n+\t\t\t\t\t\t\t? CryptoUtil.getCryptoRemark(signatureAlgorithm, keyType, keyLength.longValue(), expiryDate)\n+\t\t\t\t\t\t\t: null;\n+\t\t\t\t}\n+\t\t\t};\n+\t\t}\n+\t});\n+\n+\tpublic static final IAttribute<String> CRYPTO_ICON = Attribute.canonicalize(new Attribute<String>(\"cryptoIcon\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_CRYPTO_ICON), Messages.getString(Messages.ATTR_CRYPTO_ICON_DESC),\n+\t\t\tPLAIN_TEXT) {\n+\t\t@Override\n+\t\tpublic <U> IMemberAccessor<String, U> customAccessor(IType<U> type) {\n+\t\t\tfinal IMemberAccessor<String, U> signatureAlgorithmAccessor = type\n+\t\t\t\t\t.getAccessor(SIGNATURE_ALGORITHM.getKey());\n+\t\t\tfinal IMemberAccessor<String, U> keyTypeAccessor = type.getAccessor(KEY_TYPE.getKey());\n+\t\t\tfinal IMemberAccessor<IQuantity, U> keyLengthAccessor = type.getAccessor(KEY_LENGTH.getKey());\n+\t\t\tfinal IMemberAccessor<IQuantity, U> expiryDateAccessor = type.getAccessor(VALID_UNTIL.getKey());\n+\t\t\tif ((signatureAlgorithmAccessor == null) || (keyTypeAccessor == null) || (keyLengthAccessor == null)) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treturn new IMemberAccessor<String, U>() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic String getMember(U i) {\n+\t\t\t\t\tString signatureAlgorithm = signatureAlgorithmAccessor.getMember(i);\n+\t\t\t\t\tString keyType = keyTypeAccessor.getMember(i);\n+\t\t\t\t\tIQuantity keyLength = keyLengthAccessor.getMember(i);\n+\t\t\t\t\tIQuantity expiryDate = null;\n+\t\t\t\t\tif (expiryDateAccessor != null) {\n+\t\t\t\t\t\texpiryDate = expiryDateAccessor.getMember(i);\n+\t\t\t\t\t}\n+\t\t\t\t\treturn signatureAlgorithm != null && keyType != null && keyLength != null\n+\t\t\t\t\t\t\t? CryptoUtil.getCryptoIcon(signatureAlgorithm, keyType, keyLength.longValue(), expiryDate)\n+\t\t\t\t\t\t\t: null;\n+\t\t\t\t}\n+\t\t\t};\n+\t\t}\n+\t});\n+\n+\tpublic static final IAttribute<String> CRYPTO_RULE_RESULT = Attribute\n+\t\t\t.canonicalize(new Attribute<String>(\"cryptoRuleResult\", \/\/$NON-NLS-1$\n+\t\t\t\t\tMessages.getString(Messages.ATTR_CRYPTO_ICON), Messages.getString(Messages.ATTR_CRYPTO_ICON_DESC),\n+\t\t\t\t\tPLAIN_TEXT) {\n+\t\t\t\t@Override\n+\t\t\t\tpublic <U> IMemberAccessor<String, U> customAccessor(IType<U> type) {\n+\t\t\t\t\tfinal IMemberAccessor<String, U> signatureAlgorithmAccessor = type\n+\t\t\t\t\t\t\t.getAccessor(SIGNATURE_ALGORITHM.getKey());\n+\t\t\t\t\tfinal IMemberAccessor<String, U> keyTypeAccessor = type.getAccessor(KEY_TYPE.getKey());\n+\t\t\t\t\tfinal IMemberAccessor<IQuantity, U> keyLengthAccessor = type.getAccessor(KEY_LENGTH.getKey());\n+\t\t\t\t\tfinal IMemberAccessor<IQuantity, U> expiryDateAccessor = type.getAccessor(VALID_UNTIL.getKey());\n+\t\t\t\t\tfinal IMemberAccessor<Number, U> certificateIdAccessor = type.getAccessor(CERTIFICATE_ID.getKey());\n+\t\t\t\t\tfinal IMemberAccessor<IQuantity, U> certificateIdPre9Accessor = type\n+\t\t\t\t\t\t\t.getAccessor(CERTIFICATE_ID_QTY.getKey());\n+\t\t\t\t\tif ((signatureAlgorithmAccessor == null) || (keyTypeAccessor == null)\n+\t\t\t\t\t\t\t|| (keyLengthAccessor == null)) {\n+\t\t\t\t\t\treturn null;\n+\t\t\t\t\t}\n+\t\t\t\t\treturn new IMemberAccessor<String, U>() {\n+\t\t\t\t\t\t@Override\n+\t\t\t\t\t\tpublic String getMember(U i) {\n+\t\t\t\t\t\t\tString signatureAlgorithm = signatureAlgorithmAccessor.getMember(i);\n+\t\t\t\t\t\t\tString keyType = keyTypeAccessor.getMember(i);\n+\t\t\t\t\t\t\tIQuantity keyLength = keyLengthAccessor.getMember(i);\n+\t\t\t\t\t\t\tIQuantity expiryDate = null;\n+\t\t\t\t\t\t\tif (expiryDateAccessor != null) {\n+\t\t\t\t\t\t\t\texpiryDate = expiryDateAccessor.getMember(i);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tNumber certificateId = 0;\n+\t\t\t\t\t\t\tIQuantity qtyCertificate = null;\n+\t\t\t\t\t\t\tif (certificateIdAccessor != null) {\n+\t\t\t\t\t\t\t\tcertificateId = certificateIdAccessor.getMember(i);\n+\t\t\t\t\t\t\t} else if (certificateIdPre9Accessor != null) {\n+\t\t\t\t\t\t\t\tqtyCertificate = certificateIdPre9Accessor.getMember(i);\n+\t\t\t\t\t\t\t\tcertificateId = qtyCertificate.numberValue();\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\treturn signatureAlgorithm != null && keyType != null && keyLength != null\n+\t\t\t\t\t\t\t\t\t? CryptoUtil.getCryptoRuleResult(signatureAlgorithm, keyType, keyLength.longValue(),\n+\t\t\t\t\t\t\t\t\t\t\texpiryDate, certificateId)\n+\t\t\t\t\t\t\t\t\t: null;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t};\n+\t\t\t\t}\n+\t\t\t});\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkAttributes.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+\tpublic static final IItemFilter SECURITY = ItemFilters.type(JdkTypeIDs.X509_CERTIFICATE);\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkFilters.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -114,0 +114,2 @@\n+\tpublic static final String X509_CERTIFICATE = PREFIX + \"X509Certificate\";\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkTypeIDs.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -210,0 +210,1 @@\n+\tpublic static final String AGGR_X509_CERTIFICATES_COUNT = \"AGGR_X509_CERTIFICATES_COUNT\"; \/\/$NON-NLS-1$\n@@ -569,0 +570,13 @@\n+\tpublic static final String ATTR_SIGNATURE_ALGORITHM = \"ATTR_SIGNATURE_ALGORITHM\"; \/\/$NON-NLS-1$\n+\tpublic static final String ATTR_CERTIFICATE_ID = \"ATTR_CERTIFICATE_ID\"; \/\/$NON-NLS-1$\n+\tpublic static final String ATTR_CERTIFICATE_ISSUER = \"ATTR_CERTIFICATE_ISSUER\"; \/\/$NON-NLS-1$\n+\tpublic static final String ATTR_KEY_LENGTH = \"ATTR_KEY_LENGTH\"; \/\/$NON-NLS-1$\n+\tpublic static final String ATTR_KEY_TYPE = \"ATTR_KEY_TYPE\"; \/\/$NON-NLS-1$\n+\tpublic static final String ATTR_SERIAL_NUMBER = \"ATTR_SERIAL_NUMBER\"; \/\/$NON-NLS-1$\n+\tpublic static final String ATTR_SUBJECT = \"ATTR_SUBJECT\"; \/\/$NON-NLS-1$\n+\tpublic static final String ATTR_VALID_FROM = \"ATTR_VALID_FROM\"; \/\/$NON-NLS-1$\n+\tpublic static final String ATTR_VALID_UNTIL = \"ATTR_VALID_UNTIL\"; \/\/$NON-NLS-1$\n+\tpublic static final String ATTR_CRYPTO_REMARK = \"ATTR_CRYPTO_REMARK\"; \/\/$NON-NLS-1$\n+\tpublic static final String ATTR_CRYPTO_REMARK_DESC = \"ATTR_CRYPTO_REMARK_DESC\"; \/\/$NON-NLS-1$\n+\tpublic static final String ATTR_CRYPTO_ICON = \"ATTR_CRYPTO_ICON\"; \/\/$NON-NLS-1$\n+\tpublic static final String ATTR_CRYPTO_ICON_DESC = \"ATTR_CRYPTO_ICON_DESC\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/messages\/internal\/Messages.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -121,0 +121,2 @@\n+\tprivate final static String X509_CERTIFICATE = JDK_EVENT_ID_ROOT + \"java\/x509_certificate\";\n+\n@@ -419,0 +421,2 @@\n+\t\tcase X509_CERTIFICATE:\n+\t\t\treturn JdkTypeIDs.X509_CERTIFICATE;\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/parser\/synthetic\/OracleJdkTypeIDsPre11.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -378,0 +378,13 @@\n+ATTR_SIGNATURE_ALGORITHM=Signature Algorithm\n+ATTR_CERTIFICATE_ID=Certificate Id\n+ATTR_CERTIFICATE_ISSUER=Certificate Issuer\n+ATTR_KEY_LENGTH=Key Length\n+ATTR_KEY_TYPE=Key Type\n+ATTR_SERIAL_NUMBER=Serial Number\n+ATTR_SUBJECT=Subject\n+ATTR_VALID_FROM=Valid From\n+ATTR_VALID_UNTIL=Valid Until\n+ATTR_CRYPTO_REMARK=Crypto Remark\n+ATTR_CRYPTO_REMARK_DESC=Crypto Remarks based on the signature algorithm, key type and key length\n+ATTR_CRYPTO_ICON=Status\n+ATTR_CRYPTO_ICON_DESC=Crypto Icon will be used to show the action \/ attention needed in specific domain\n@@ -541,0 +554,1 @@\n+AGGR_X509_CERTIFICATES_COUNT=X509 Certificates\n\\ No newline at end of file\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/jdk\/messages\/internal\/messages.properties","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -334,0 +334,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>CryptoSecurityRule<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -640,0 +644,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>CryptoSecurityRule<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -918,0 +926,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>CryptoSecurityRule<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -1194,0 +1206,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>CryptoSecurityRule<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -1490,0 +1506,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>CryptoSecurityRule<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -1765,0 +1785,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>CryptoSecurityRule<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -2038,0 +2062,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>CryptoSecurityRule<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -2365,0 +2393,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>CryptoSecurityRule<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -2665,0 +2697,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>CryptoSecurityRule<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -2954,0 +2990,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>CryptoSecurityRule<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -3243,0 +3283,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>CryptoSecurityRule<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -3534,0 +3578,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>CryptoSecurityRule<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -3803,0 +3851,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>CryptoSecurityRule<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -4071,0 +4123,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>CryptoSecurityRule<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -4395,0 +4451,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>CryptoSecurityRule<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -4669,0 +4729,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>CryptoSecurityRule<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -4943,0 +5007,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>CryptoSecurityRule<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -5266,0 +5334,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>CryptoSecurityRule<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -5588,0 +5660,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>CryptoSecurityRule<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -5866,0 +5942,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>CryptoSecurityRule<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -6192,0 +6272,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>CryptoSecurityRule<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -6575,0 +6659,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>CryptoSecurityRule<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -6855,0 +6943,4 @@\n+        <\/rule>\n+\t\t<rule>\n+            <id>CryptoSecurityRule<\/id>\n+            <severity>Not Applicable<\/severity>\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/baseline\/JfrRuleBaseline.xml","additions":92,"deletions":0,"binary":false,"changes":92,"status":"modified"}]}