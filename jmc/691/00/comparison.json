{"files":[{"patch":"@@ -0,0 +1,979 @@\n+[\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.AllocationRateBenchmark.measureBatchEventWriteAllocations\",\n+        \"mode\" : \"thrpt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"5 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"10 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"primaryMetric\" : {\n+            \"score\" : 7197.757761698836,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 6940.520777445677,\n+                \"50.0\" : 7197.757761698836,\n+                \"90.0\" : 7454.994745951994,\n+                \"95.0\" : 7454.994745951994,\n+                \"99.0\" : 7454.994745951994,\n+                \"99.9\" : 7454.994745951994,\n+                \"99.99\" : 7454.994745951994,\n+                \"99.999\" : 7454.994745951994,\n+                \"99.9999\" : 7454.994745951994,\n+                \"100.0\" : 7454.994745951994\n+            },\n+            \"scoreUnit\" : \"ops\/s\",\n+            \"rawData\" : [\n+                [\n+                    7454.994745951994,\n+                    6940.520777445677\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.AllocationRateBenchmark.measureEventWriteAllocations\",\n+        \"mode\" : \"thrpt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"5 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"10 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"primaryMetric\" : {\n+            \"score\" : 899178.7551576358,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 886326.6018194918,\n+                \"50.0\" : 899178.7551576358,\n+                \"90.0\" : 912030.9084957796,\n+                \"95.0\" : 912030.9084957796,\n+                \"99.0\" : 912030.9084957796,\n+                \"99.9\" : 912030.9084957796,\n+                \"99.99\" : 912030.9084957796,\n+                \"99.999\" : 912030.9084957796,\n+                \"99.9999\" : 912030.9084957796,\n+                \"100.0\" : 912030.9084957796\n+            },\n+            \"scoreUnit\" : \"ops\/s\",\n+            \"rawData\" : [\n+                [\n+                    912030.9084957796,\n+                    886326.6018194918\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.EventWriteThroughputBenchmark.writeMultiFieldEvent\",\n+        \"mode\" : \"thrpt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"5 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"10 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"primaryMetric\" : {\n+            \"score\" : 862335.4129249394,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 839770.7011609187,\n+                \"50.0\" : 862335.4129249394,\n+                \"90.0\" : 884900.1246889601,\n+                \"95.0\" : 884900.1246889601,\n+                \"99.0\" : 884900.1246889601,\n+                \"99.9\" : 884900.1246889601,\n+                \"99.99\" : 884900.1246889601,\n+                \"99.999\" : 884900.1246889601,\n+                \"99.9999\" : 884900.1246889601,\n+                \"100.0\" : 884900.1246889601\n+            },\n+            \"scoreUnit\" : \"ops\/s\",\n+            \"rawData\" : [\n+                [\n+                    884900.1246889601,\n+                    839770.7011609187\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.EventWriteThroughputBenchmark.writeRepeatedStringsEvent\",\n+        \"mode\" : \"thrpt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"5 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"10 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"primaryMetric\" : {\n+            \"score\" : 861751.3614186794,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 850584.9265245523,\n+                \"50.0\" : 861751.3614186794,\n+                \"90.0\" : 872917.7963128064,\n+                \"95.0\" : 872917.7963128064,\n+                \"99.0\" : 872917.7963128064,\n+                \"99.9\" : 872917.7963128064,\n+                \"99.99\" : 872917.7963128064,\n+                \"99.999\" : 872917.7963128064,\n+                \"99.9999\" : 872917.7963128064,\n+                \"100.0\" : 872917.7963128064\n+            },\n+            \"scoreUnit\" : \"ops\/s\",\n+            \"rawData\" : [\n+                [\n+                    872917.7963128064,\n+                    850584.9265245523\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.EventWriteThroughputBenchmark.writeSimpleEvent\",\n+        \"mode\" : \"thrpt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"5 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"10 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"primaryMetric\" : {\n+            \"score\" : 986095.2370549459,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 979671.0668974728,\n+                \"50.0\" : 986095.2370549459,\n+                \"90.0\" : 992519.407212419,\n+                \"95.0\" : 992519.407212419,\n+                \"99.0\" : 992519.407212419,\n+                \"99.9\" : 992519.407212419,\n+                \"99.99\" : 992519.407212419,\n+                \"99.999\" : 992519.407212419,\n+                \"99.9999\" : 992519.407212419,\n+                \"100.0\" : 992519.407212419\n+            },\n+            \"scoreUnit\" : \"ops\/s\",\n+            \"rawData\" : [\n+                [\n+                    992519.407212419,\n+                    979671.0668974728\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.EventWriteThroughputBenchmark.writeStringHeavyEvent\",\n+        \"mode\" : \"thrpt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"5 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"10 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"primaryMetric\" : {\n+            \"score\" : 866022.4295841993,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 852934.6996319862,\n+                \"50.0\" : 866022.4295841993,\n+                \"90.0\" : 879110.1595364123,\n+                \"95.0\" : 879110.1595364123,\n+                \"99.0\" : 879110.1595364123,\n+                \"99.9\" : 879110.1595364123,\n+                \"99.99\" : 879110.1595364123,\n+                \"99.999\" : 879110.1595364123,\n+                \"99.9999\" : 879110.1595364123,\n+                \"100.0\" : 879110.1595364123\n+            },\n+            \"scoreUnit\" : \"ops\/s\",\n+            \"rawData\" : [\n+                [\n+                    879110.1595364123,\n+                    852934.6996319862\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.StringEncodingBenchmark.encodeMixedStrings\",\n+        \"mode\" : \"thrpt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"5 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"10 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"primaryMetric\" : {\n+            \"score\" : 177723.13242352506,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 177723.13242352506,\n+                \"50.0\" : 177723.13242352506,\n+                \"90.0\" : 177723.13242352506,\n+                \"95.0\" : 177723.13242352506,\n+                \"99.0\" : 177723.13242352506,\n+                \"99.9\" : 177723.13242352506,\n+                \"99.99\" : 177723.13242352506,\n+                \"99.999\" : 177723.13242352506,\n+                \"99.9999\" : 177723.13242352506,\n+                \"100.0\" : 177723.13242352506\n+            },\n+            \"scoreUnit\" : \"ops\/s\",\n+            \"rawData\" : [\n+                [\n+                    177723.13242352506\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.StringEncodingBenchmark.encodeRepeatedStrings\",\n+        \"mode\" : \"thrpt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"5 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"10 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"primaryMetric\" : {\n+            \"score\" : 866965.5138697355,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 864798.7125068279,\n+                \"50.0\" : 866965.5138697355,\n+                \"90.0\" : 869132.3152326432,\n+                \"95.0\" : 869132.3152326432,\n+                \"99.0\" : 869132.3152326432,\n+                \"99.9\" : 869132.3152326432,\n+                \"99.99\" : 869132.3152326432,\n+                \"99.999\" : 869132.3152326432,\n+                \"99.9999\" : 869132.3152326432,\n+                \"100.0\" : 869132.3152326432\n+            },\n+            \"scoreUnit\" : \"ops\/s\",\n+            \"rawData\" : [\n+                [\n+                    864798.7125068279,\n+                    869132.3152326432\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.StringEncodingBenchmark.encodeUniqueStrings\",\n+        \"mode\" : \"thrpt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"5 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"10 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"primaryMetric\" : {\n+            \"score\" : 72763.64376438508,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 72763.64376438508,\n+                \"50.0\" : 72763.64376438508,\n+                \"90.0\" : 72763.64376438508,\n+                \"95.0\" : 72763.64376438508,\n+                \"99.0\" : 72763.64376438508,\n+                \"99.9\" : 72763.64376438508,\n+                \"99.99\" : 72763.64376438508,\n+                \"99.999\" : 72763.64376438508,\n+                \"99.9999\" : 72763.64376438508,\n+                \"100.0\" : 72763.64376438508\n+            },\n+            \"scoreUnit\" : \"ops\/s\",\n+            \"rawData\" : [\n+                [\n+                    72763.64376438508\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.StringEncodingBenchmark.encodeUtf8Strings\",\n+        \"mode\" : \"thrpt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"5 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"10 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"primaryMetric\" : {\n+            \"score\" : 890130.4474937392,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 887438.9861902855,\n+                \"50.0\" : 890130.4474937392,\n+                \"90.0\" : 892821.9087971927,\n+                \"95.0\" : 892821.9087971927,\n+                \"99.0\" : 892821.9087971927,\n+                \"99.9\" : 892821.9087971927,\n+                \"99.99\" : 892821.9087971927,\n+                \"99.999\" : 892821.9087971927,\n+                \"99.9999\" : 892821.9087971927,\n+                \"100.0\" : 892821.9087971927\n+            },\n+            \"scoreUnit\" : \"ops\/s\",\n+            \"rawData\" : [\n+                [\n+                    892821.9087971927,\n+                    887438.9861902855\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.ConstantPoolBenchmark.buildConstantPoolMixed\",\n+        \"mode\" : \"avgt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"3 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"5 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"params\" : {\n+            \"poolSize\" : \"100\"\n+        },\n+        \"primaryMetric\" : {\n+            \"score\" : 0.1118520596714827,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 0.11041214804438464,\n+                \"50.0\" : 0.1118520596714827,\n+                \"90.0\" : 0.11329197129858078,\n+                \"95.0\" : 0.11329197129858078,\n+                \"99.0\" : 0.11329197129858078,\n+                \"99.9\" : 0.11329197129858078,\n+                \"99.99\" : 0.11329197129858078,\n+                \"99.999\" : 0.11329197129858078,\n+                \"99.9999\" : 0.11329197129858078,\n+                \"100.0\" : 0.11329197129858078\n+            },\n+            \"scoreUnit\" : \"ms\/op\",\n+            \"rawData\" : [\n+                [\n+                    0.11041214804438464,\n+                    0.11329197129858078\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.ConstantPoolBenchmark.buildConstantPoolMixed\",\n+        \"mode\" : \"avgt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"3 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"5 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"params\" : {\n+            \"poolSize\" : \"500\"\n+        },\n+        \"primaryMetric\" : {\n+            \"score\" : 0.5625647438601789,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 0.559422147982564,\n+                \"50.0\" : 0.5625647438601789,\n+                \"90.0\" : 0.5657073397377939,\n+                \"95.0\" : 0.5657073397377939,\n+                \"99.0\" : 0.5657073397377939,\n+                \"99.9\" : 0.5657073397377939,\n+                \"99.99\" : 0.5657073397377939,\n+                \"99.999\" : 0.5657073397377939,\n+                \"99.9999\" : 0.5657073397377939,\n+                \"100.0\" : 0.5657073397377939\n+            },\n+            \"scoreUnit\" : \"ms\/op\",\n+            \"rawData\" : [\n+                [\n+                    0.5657073397377939,\n+                    0.559422147982564\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.ConstantPoolBenchmark.buildConstantPoolMixed\",\n+        \"mode\" : \"avgt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"3 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"5 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"params\" : {\n+            \"poolSize\" : \"1000\"\n+        },\n+        \"primaryMetric\" : {\n+            \"score\" : 1.1046746108336705,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 1.093938292522956,\n+                \"50.0\" : 1.1046746108336705,\n+                \"90.0\" : 1.115410929144385,\n+                \"95.0\" : 1.115410929144385,\n+                \"99.0\" : 1.115410929144385,\n+                \"99.9\" : 1.115410929144385,\n+                \"99.99\" : 1.115410929144385,\n+                \"99.999\" : 1.115410929144385,\n+                \"99.9999\" : 1.115410929144385,\n+                \"100.0\" : 1.115410929144385\n+            },\n+            \"scoreUnit\" : \"ms\/op\",\n+            \"rawData\" : [\n+                [\n+                    1.115410929144385,\n+                    1.093938292522956\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.ConstantPoolBenchmark.buildConstantPoolWithRepeatedStrings\",\n+        \"mode\" : \"avgt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"3 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"5 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"params\" : {\n+            \"poolSize\" : \"100\"\n+        },\n+        \"primaryMetric\" : {\n+            \"score\" : 0.10848030115347368,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 0.10809573802993326,\n+                \"50.0\" : 0.10848030115347368,\n+                \"90.0\" : 0.1088648642770141,\n+                \"95.0\" : 0.1088648642770141,\n+                \"99.0\" : 0.1088648642770141,\n+                \"99.9\" : 0.1088648642770141,\n+                \"99.99\" : 0.1088648642770141,\n+                \"99.999\" : 0.1088648642770141,\n+                \"99.9999\" : 0.1088648642770141,\n+                \"100.0\" : 0.1088648642770141\n+            },\n+            \"scoreUnit\" : \"ms\/op\",\n+            \"rawData\" : [\n+                [\n+                    0.10809573802993326,\n+                    0.1088648642770141\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.ConstantPoolBenchmark.buildConstantPoolWithRepeatedStrings\",\n+        \"mode\" : \"avgt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"3 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"5 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"params\" : {\n+            \"poolSize\" : \"500\"\n+        },\n+        \"primaryMetric\" : {\n+            \"score\" : 0.5270260178151316,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 0.5244431318105616,\n+                \"50.0\" : 0.5270260178151316,\n+                \"90.0\" : 0.5296089038197016,\n+                \"95.0\" : 0.5296089038197016,\n+                \"99.0\" : 0.5296089038197016,\n+                \"99.9\" : 0.5296089038197016,\n+                \"99.99\" : 0.5296089038197016,\n+                \"99.999\" : 0.5296089038197016,\n+                \"99.9999\" : 0.5296089038197016,\n+                \"100.0\" : 0.5296089038197016\n+            },\n+            \"scoreUnit\" : \"ms\/op\",\n+            \"rawData\" : [\n+                [\n+                    0.5296089038197016,\n+                    0.5244431318105616\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.ConstantPoolBenchmark.buildConstantPoolWithRepeatedStrings\",\n+        \"mode\" : \"avgt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"3 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"5 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"params\" : {\n+            \"poolSize\" : \"1000\"\n+        },\n+        \"primaryMetric\" : {\n+            \"score\" : 1.0598695509536045,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 1.0426289054363673,\n+                \"50.0\" : 1.0598695509536045,\n+                \"90.0\" : 1.0771101964708414,\n+                \"95.0\" : 1.0771101964708414,\n+                \"99.0\" : 1.0771101964708414,\n+                \"99.9\" : 1.0771101964708414,\n+                \"99.99\" : 1.0771101964708414,\n+                \"99.999\" : 1.0771101964708414,\n+                \"99.9999\" : 1.0771101964708414,\n+                \"100.0\" : 1.0771101964708414\n+            },\n+            \"scoreUnit\" : \"ms\/op\",\n+            \"rawData\" : [\n+                [\n+                    1.0771101964708414,\n+                    1.0426289054363673\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.ConstantPoolBenchmark.buildConstantPoolWithUniqueStrings\",\n+        \"mode\" : \"avgt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"3 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"5 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"params\" : {\n+            \"poolSize\" : \"100\"\n+        },\n+        \"primaryMetric\" : {\n+            \"score\" : 0.10810993516568879,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 0.10728512533224728,\n+                \"50.0\" : 0.10810993516568879,\n+                \"90.0\" : 0.10893474499913028,\n+                \"95.0\" : 0.10893474499913028,\n+                \"99.0\" : 0.10893474499913028,\n+                \"99.9\" : 0.10893474499913028,\n+                \"99.99\" : 0.10893474499913028,\n+                \"99.999\" : 0.10893474499913028,\n+                \"99.9999\" : 0.10893474499913028,\n+                \"100.0\" : 0.10893474499913028\n+            },\n+            \"scoreUnit\" : \"ms\/op\",\n+            \"rawData\" : [\n+                [\n+                    0.10728512533224728,\n+                    0.10893474499913028\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.ConstantPoolBenchmark.buildConstantPoolWithUniqueStrings\",\n+        \"mode\" : \"avgt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"3 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"5 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"params\" : {\n+            \"poolSize\" : \"500\"\n+        },\n+        \"primaryMetric\" : {\n+            \"score\" : 0.5419391121231041,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 0.5392549859853385,\n+                \"50.0\" : 0.5419391121231041,\n+                \"90.0\" : 0.5446232382608696,\n+                \"95.0\" : 0.5446232382608696,\n+                \"99.0\" : 0.5446232382608696,\n+                \"99.9\" : 0.5446232382608696,\n+                \"99.99\" : 0.5446232382608696,\n+                \"99.999\" : 0.5446232382608696,\n+                \"99.9999\" : 0.5446232382608696,\n+                \"100.0\" : 0.5446232382608696\n+            },\n+            \"scoreUnit\" : \"ms\/op\",\n+            \"rawData\" : [\n+                [\n+                    0.5392549859853385,\n+                    0.5446232382608696\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.ConstantPoolBenchmark.buildConstantPoolWithUniqueStrings\",\n+        \"mode\" : \"avgt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"3 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"5 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"params\" : {\n+            \"poolSize\" : \"1000\"\n+        },\n+        \"primaryMetric\" : {\n+            \"score\" : 1.0210908570363653,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 1.0209848693610941,\n+                \"50.0\" : 1.0210908570363653,\n+                \"90.0\" : 1.0211968447116364,\n+                \"95.0\" : 1.0211968447116364,\n+                \"99.0\" : 1.0211968447116364,\n+                \"99.9\" : 1.0211968447116364,\n+                \"99.99\" : 1.0211968447116364,\n+                \"99.999\" : 1.0211968447116364,\n+                \"99.9999\" : 1.0211968447116364,\n+                \"100.0\" : 1.0211968447116364\n+            },\n+            \"scoreUnit\" : \"ms\/op\",\n+            \"rawData\" : [\n+                [\n+                    1.0211968447116364,\n+                    1.0209848693610941\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    }\n+]\n+\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/doc\/baseline-quick.json","additions":979,"deletions":0,"binary":false,"changes":979,"status":"added"},{"patch":"@@ -0,0 +1,186 @@\n+# Memory-Mapped File Implementation for JFR Writer\n+\n+## Overview\n+\n+This document describes the memory-mapped file (mmap) implementation for the JFR Writer, which provides bounded memory usage during recording creation.\n+\n+## Architecture\n+\n+### Components\n+\n+1. **LEB128MappedWriter** - Fixed-size memory-mapped file writer\n+   - Location: `org.openjdk.jmc.flightrecorder.writer.LEB128MappedWriter`\n+   - Fixed capacity (no dynamic remapping)\n+   - Extends `AbstractLEB128Writer` for LEB128 encoding support\n+   - Key methods:\n+     - `canFit(int bytes)` - Check available space\n+     - `reset()` - Reset for buffer reuse\n+     - `force()` - Flush to disk\n+     - `copyTo(OutputStream)` - Export data\n+\n+2. **ThreadMmapManager** - Per-thread double-buffer management\n+   - Location: `org.openjdk.jmc.flightrecorder.writer.ThreadMmapManager`\n+   - Manages two buffers per thread (active\/inactive)\n+   - Background flushing via ExecutorService\n+   - File naming:\n+     - Buffers: `thread-{threadId}-buffer-{0|1}.mmap` (reused)\n+     - Flushed chunks: `chunk-{threadId}-{sequence}.dat` (persistent)\n+\n+3. **Chunk** - Event serialization with automatic rotation\n+   - Modified to accept `LEB128Writer` and `ThreadMmapManager`\n+   - Checks `canFit()` before each event write\n+   - Triggers rotation when buffer full\n+   - Backward compatible with heap-based mode\n+\n+4. **RecordingImpl** - Dual-mode recording implementation\n+   - Supports both mmap and legacy heap modes\n+   - Sequential finalization: header → chunks → checkpoint → metadata\n+   - Proper cleanup of temporary files\n+\n+### Configuration\n+\n+Enable mmap mode via system properties:\n+\n+```bash\n+-Dorg.openjdk.jmc.flightrecorder.writer.mmap.enabled=true\n+-Dorg.openjdk.jmc.flightrecorder.writer.mmap.chunkSize=4194304  # 4MB default\n+```\n+\n+### Memory Usage\n+\n+**Mmap mode:**\n+- Per-thread memory: 2 × chunk size (default 8MB per thread)\n+- Metadata\/checkpoint: ~6MB heap (bounded)\n+- Total heap: ~6MB + O(threads)\n+\n+**Legacy heap mode:**\n+- All event data in heap\n+- Unbounded growth with event count\n+\n+## Implementation Details\n+\n+### Buffer Rotation Flow\n+\n+1. Thread writes events to active mmap buffer\n+2. Before each write, `canFit()` checks available space\n+3. When full:\n+   - Swap active ↔ inactive buffers\n+   - Submit inactive buffer for background flush\n+   - Continue writing to new active buffer\n+4. Background thread:\n+   - Flushes buffer to chunk file\n+   - Resets buffer for reuse\n+\n+### Finalization Flow\n+\n+**Mmap mode:**\n+1. Call `mmapManager.finalFlush()` - flush all active buffers\n+2. Collect all flushed chunk files\n+3. Calculate offsets:\n+   - Checkpoint offset = header size (68 bytes) + total chunks size\n+   - Metadata offset = checkpoint offset + checkpoint event size\n+4. Write sequentially:\n+   - Header with correct offsets\n+   - All chunk files (via Files.copy)\n+   - Checkpoint event\n+   - Metadata event\n+5. Cleanup temp files\n+\n+**Legacy heap mode:**\n+- Unchanged - writes globalWriter.export() with in-place offset patching\n+\n+## Testing\n+\n+### Unit Tests\n+\n+**LEB128MappedWriter** (22 tests)\n+- Basic write operations\n+- LEB128 encoding\n+- Buffer capacity checking\n+- Reset and reuse\n+- Force and copyTo\n+- Large writes\n+- Edge cases\n+\n+**ThreadMmapManager** (13 tests)\n+- Active writer creation\n+- Multiple threads\n+- Buffer rotation\n+- Background flushing\n+- Final flush\n+- Cleanup\n+- Concurrent access\n+\n+### Integration Tests\n+\n+**MmapRecordingIntegrationTest** (5 tests)\n+- Basic recording (100 events)\n+- Multi-threaded recording (4 threads, 1000 events)\n+- Large events triggering rotation (>512KB)\n+- File output verification\n+- Mmap vs heap comparison (same size ±10%)\n+\n+All tests pass successfully.\n+\n+## Performance Benchmarking\n+\n+### Existing Benchmarks\n+\n+JMH benchmarks exist in `tests\/org.openjdk.jmc.flightrecorder.writer.benchmarks`:\n+\n+- `EventWriteThroughputBenchmark` - Events per second for various event types\n+- `AllocationRateBenchmark` - Allocation rates during event writing\n+- `ConstantPoolBenchmark` - Constant pool performance\n+- `StringEncodingBenchmark` - String encoding performance\n+\n+### Running Benchmarks\n+\n+To compare mmap vs heap performance:\n+\n+```bash\n+# Build benchmark uberjar\n+cd tests\/org.openjdk.jmc.flightrecorder.writer.benchmarks\n+mvn clean package\n+\n+# Run with heap mode (baseline)\n+java -jar target\/benchmarks.jar EventWriteThroughputBenchmark\n+\n+# Run with mmap mode\n+java -Dorg.openjdk.jmc.flightrecorder.writer.mmap.enabled=true \\\n+     -Dorg.openjdk.jmc.flightrecorder.writer.mmap.chunkSize=4194304 \\\n+     -jar target\/benchmarks.jar EventWriteThroughputBenchmark\n+\n+# Compare results\n+```\n+\n+### Performance Goals\n+\n+- **Throughput**: < 5% regression vs heap mode\n+- **Memory**: Bounded at ~6MB + (threads × 8MB)\n+- **Latency**: No significant increase in p99 event write time\n+\n+## Backward Compatibility\n+\n+The implementation maintains full backward compatibility:\n+\n+- **Default behavior unchanged**: Mmap mode is opt-in via system property\n+- **API unchanged**: No public API changes\n+- **File format unchanged**: Generated JFR files identical to legacy mode\n+- **All existing tests pass**: No regressions in functionality\n+\n+The legacy heap-based code path (`chunkDataQueue`, `chunkDataMergingService`) is preserved and used when mmap is disabled.\n+\n+## Future Improvements\n+\n+Potential optimizations (not implemented):\n+\n+1. **Adaptive chunk sizing**: Adjust chunk size based on workload\n+2. **Zero-copy finalization**: Direct file concatenation without intermediate copies\n+3. **Compression**: On-the-fly compression of flushed chunks\n+4. **Lock-free rotation**: Further reduce contention during buffer swaps\n+\n+## References\n+\n+- JFR File Format: [JEP 328](https:\/\/openjdk.org\/jeps\/328)\n+- LEB128 Encoding: [Wikipedia](https:\/\/en.wikipedia.org\/wiki\/LEB128)\n+- Memory-Mapped Files: `java.nio.MappedByteBuffer`\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/doc\/mmap-implementation.md","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,306 @@\n+# JFR Writer Performance Benchmarks\n+\n+## Overview\n+\n+This document describes the JMH (Java Microbenchmark Harness) benchmarks created for the JFR Writer module to measure and track performance improvements, particularly focusing on allocation reduction and throughput optimization.\n+\n+## Benchmark Module Location\n+\n+```\n+core\/tests\/org.openjdk.jmc.flightrecorder.writer.benchmarks\/\n+```\n+\n+## Building the Benchmarks\n+\n+### Prerequisites\n+- Maven 3.6+\n+- JDK 17+\n+\n+### Build Steps\n+\n+1. **Build the entire core module** (required to install dependencies):\n+   ```bash\n+   cd core\n+   mvn clean install -DskipTests\n+   ```\n+\n+2. **Build the benchmark module**:\n+   ```bash\n+   cd tests\/org.openjdk.jmc.flightrecorder.writer.benchmarks\n+   mvn clean package -DskipTests\n+   ```\n+\n+3. **Verify the benchmark JAR was created**:\n+   ```bash\n+   ls -lh target\/benchmarks.jar\n+   ```\n+   Expected: ~4.7MB executable JAR\n+\n+## Running Benchmarks\n+\n+### Quick Test Run (Fast, for validation)\n+```bash\n+cd core\/tests\/org.openjdk.jmc.flightrecorder.writer.benchmarks\n+java -jar target\/benchmarks.jar -wi 1 -i 2 -f 1\n+```\n+- `-wi 1`: 1 warmup iteration\n+- `-i 2`: 2 measurement iterations\n+- `-f 1`: 1 fork\n+\n+### Full Baseline Run (Recommended for accurate measurements)\n+```bash\n+java -jar target\/benchmarks.jar -rf json -rff baseline.json\n+```\n+- Uses default: 3 warmup iterations, 5 measurement iterations\n+- Outputs JSON results to `baseline.json`\n+\n+### Run Specific Benchmark\n+```bash\n+# Event throughput benchmarks\n+java -jar target\/benchmarks.jar EventWriteThroughput\n+\n+# Allocation benchmarks (with GC profiler)\n+java -jar target\/benchmarks.jar AllocationRate -prof gc\n+\n+# String encoding benchmarks\n+java -jar target\/benchmarks.jar StringEncoding\n+\n+# Constant pool benchmarks\n+java -jar target\/benchmarks.jar ConstantPool\n+```\n+\n+### Advanced Options\n+\n+#### With Allocation Profiling\n+```bash\n+java -jar target\/benchmarks.jar -prof gc\n+```\n+\n+#### With JFR Profiling\n+```bash\n+java -jar target\/benchmarks.jar -prof jfr\n+```\n+\n+#### List All Benchmarks\n+```bash\n+java -jar target\/benchmarks.jar -l\n+```\n+\n+#### Get Help\n+```bash\n+java -jar target\/benchmarks.jar -h\n+```\n+\n+## Benchmark Descriptions\n+\n+### 1. EventWriteThroughputBenchmark\n+**Purpose**: Measures events\/second for different event types.\n+\n+**Benchmarks**:\n+- `writeSimpleEvent`: Single long field event\n+- `writeMultiFieldEvent`: Event with 5 fields (long, string, int, double, boolean)\n+- `writeStringHeavyEvent`: Event with 4 unique string fields\n+- `writeRepeatedStringsEvent`: Event with repeated strings (tests caching)\n+\n+**Metric**: Throughput (ops\/sec) - Higher is better\n+\n+**Use Case**: Validates improvements from LEB128Writer pooling and field value caching\n+\n+### 2. AllocationRateBenchmark\n+**Purpose**: Measures allocation rate (MB\/sec) during event writing.\n+\n+**Benchmarks**:\n+- `measureEventWriteAllocations`: Single event write\n+- `measureBatchEventWriteAllocations`: Batch of 100 events\n+\n+**Metric**: Allocation rate (MB\/sec) - Lower is better\n+\n+**Use Case**: Primary metric for allocation reduction optimizations\n+\n+**Recommended Run**:\n+```bash\n+java -jar target\/benchmarks.jar AllocationRate -prof gc\n+```\n+\n+### 3. StringEncodingBenchmark\n+**Purpose**: Measures UTF-8 encoding performance.\n+\n+**Benchmarks**:\n+- `encodeRepeatedStrings`: Same strings repeatedly (tests cache hits)\n+- `encodeUniqueStrings`: Unique strings each time (tests cache misses)\n+- `encodeMixedStrings`: Mix of cached and uncached\n+- `encodeUtf8Strings`: Multi-byte UTF-8 characters\n+\n+**Metric**: Throughput (ops\/sec) - Higher is better\n+\n+**Use Case**: Validates UTF-8 caching effectiveness\n+\n+### 4. ConstantPoolBenchmark\n+**Purpose**: Measures constant pool buildup and lookup performance.\n+\n+**Benchmarks**:\n+- `buildConstantPoolWithUniqueStrings`: Tests HashMap growth (100\/500\/1000 events)\n+- `buildConstantPoolWithRepeatedStrings`: Tests deduplication\n+- `buildConstantPoolMixed`: Mix of unique and repeated\n+\n+**Metric**: Average time (ms) - Lower is better\n+\n+**Use Case**: Validates HashMap initial capacity optimization\n+\n+## Baseline Results\n+\n+### Test Environment\n+- **Date**: 2025-12-03\n+- **JDK**: OpenJDK 21.0.5+11-LTS\n+- **OS**: macOS 14.6 (Darwin 24.6.0)\n+- **CPU**: Apple M1 Max\n+- **Heap**: 2GB (-Xms2G -Xmx2G)\n+- **Branch**: jb\/JMC-7992 (pre-optimization)\n+\n+### Results Summary\n+\n+**Note**: This is a quick baseline run using `-wi 1 -i 2 -f 1` for faster validation. For production benchmarking, use the full configuration with 3 warmup iterations and 5 measurement iterations.\n+\n+#### Event Throughput Benchmarks (ops\/sec - Higher is Better)\n+```\n+Benchmark                                               Mode  Cnt       Score  Units\n+EventWriteThroughputBenchmark.writeSimpleEvent         thrpt    2  986,095.2  ops\/s\n+EventWriteThroughputBenchmark.writeMultiFieldEvent     thrpt    2  862,335.4  ops\/s\n+EventWriteThroughputBenchmark.writeStringHeavyEvent    thrpt    2  866,022.4  ops\/s\n+EventWriteThroughputBenchmark.writeRepeatedStringsEvent thrpt    2  861,751.4  ops\/s\n+```\n+\n+**Key Insights**:\n+- Simple events (single long field): ~986K ops\/s\n+- Multi-field events (5 fields): ~862K ops\/s (12.5% slower)\n+- String-heavy events show similar performance, indicating effective constant pool deduplication\n+- Repeated strings perform nearly identically to unique strings in throughput\n+\n+#### Allocation Benchmarks (ops\/sec - Higher is Better)\n+```\n+Benchmark                                              Mode  Cnt       Score  Units\n+AllocationRateBenchmark.measureEventWriteAllocations  thrpt    2  899,178.8  ops\/s\n+AllocationRateBenchmark.measureBatchEventWriteAllocations thrpt    2    7,197.8  ops\/s\n+```\n+\n+**Key Insights**:\n+- Single event write: ~899K ops\/s\n+- Batch of 100 events: ~7.2K ops\/s (equivalent to ~720K single events\/s)\n+- Batch performance is 20% slower than single events, indicating per-batch overhead\n+- **Recommendation**: Run with `-prof gc` to measure actual allocation rates in MB\/sec\n+\n+#### String Encoding Benchmarks (ops\/sec - Higher is Better)\n+```\n+Benchmark                                           Mode  Cnt       Score  Units\n+StringEncodingBenchmark.encodeUtf8Strings          thrpt    2  890,130.4  ops\/s\n+StringEncodingBenchmark.encodeRepeatedStrings      thrpt    2  866,965.5  ops\/s\n+StringEncodingBenchmark.encodeMixedStrings         thrpt    1  177,723.1  ops\/s*\n+StringEncodingBenchmark.encodeUniqueStrings        thrpt    1   72,763.6  ops\/s*\n+```\n+\n+**Key Insights**:\n+- UTF-8 strings with multi-byte characters: ~890K ops\/s (no performance penalty vs ASCII)\n+- Repeated strings (cache hits): ~867K ops\/s\n+- Mixed strings: ~178K ops\/s\n+- Unique strings: ~73K ops\/s (11.9x slower than repeated strings)\n+\n+**\\*Warning**: Both `encodeMixedStrings` and `encodeUniqueStrings` encountered OutOfMemoryError during iteration 2 in the teardown phase. The constant pool grew too large during the 10-second measurement iterations (accumulating millions of unique strings). This indicates:\n+1. A potential performance issue with unbounded constant pool growth\n+2. The benchmarks may need to periodically close and reopen recordings to clear the constant pool\n+3. These numbers are based on only 1 iteration instead of 2\n+\n+#### Constant Pool Benchmarks (ms\/op - Lower is Better)\n+```\n+Benchmark                                                    (poolSize)  Mode  Cnt   Score  Units\n+ConstantPoolBenchmark.buildConstantPoolWithUniqueStrings          100  avgt    2   0.108  ms\/op\n+ConstantPoolBenchmark.buildConstantPoolWithUniqueStrings          500  avgt    2   0.542  ms\/op\n+ConstantPoolBenchmark.buildConstantPoolWithUniqueStrings         1000  avgt    2   1.021  ms\/op\n+\n+ConstantPoolBenchmark.buildConstantPoolWithRepeatedStrings        100  avgt    2   0.108  ms\/op\n+ConstantPoolBenchmark.buildConstantPoolWithRepeatedStrings        500  avgt    2   0.527  ms\/op\n+ConstantPoolBenchmark.buildConstantPoolWithRepeatedStrings       1000  avgt    2   1.060  ms\/op\n+\n+ConstantPoolBenchmark.buildConstantPoolMixed                      100  avgt    2   0.112  ms\/op\n+ConstantPoolBenchmark.buildConstantPoolMixed                      500  avgt    2   0.563  ms\/op\n+ConstantPoolBenchmark.buildConstantPoolMixed                     1000  avgt    2   1.105  ms\/op\n+```\n+\n+**Key Insights**:\n+- Constant pool buildup scales approximately linearly with pool size\n+- 100 events: ~0.11 ms\n+- 500 events: ~0.54 ms (5x)\n+- 1000 events: ~1.03 ms (9.4x)\n+- Repeated strings are slightly faster (2.7% at 500 events) but within measurement variance\n+- Mixed workload shows similar performance to unique strings\n+\n+### Performance Bottlenecks Identified\n+\n+1. **Unique String Handling**: 11.9x performance degradation when writing unique strings vs repeated strings\n+2. **Constant Pool Memory Growth**: OutOfMemoryError with 2GB heap during long-running string encoding benchmarks\n+3. **Batch Overhead**: 20% throughput reduction when writing events in batches\n+4. **Multi-field Events**: 12.5% slower than simple events\n+\n+## Performance Optimization Plan\n+\n+The benchmark results establish a baseline for the following planned optimizations:\n+\n+### Phase 1: Critical Allocation Hotspots\n+1. **LEB128Writer pooling** (Chunk.java:155)\n+   - Expected: 70-80% allocation reduction\n+   - Benchmark: AllocationRateBenchmark, EventWriteThroughputBenchmark\n+\n+2. **Field values caching** (TypedValueImpl.java:142)\n+   - Expected: 60% allocation reduction for multi-field events\n+   - Benchmark: EventWriteThroughputBenchmark.writeMultiFieldEvent\n+\n+### Phase 2: String & Constant Pool\n+3. **UTF-8 encoding cache** (AbstractLEB128Writer.java)\n+   - Expected: 40% CPU reduction, 20% allocation reduction\n+   - Benchmark: StringEncodingBenchmark.encodeRepeatedStrings\n+\n+4. **HashMap capacity hints** (ConstantPool.java)\n+   - Expected: 30% allocation reduction during pool buildup\n+   - Benchmark: ConstantPoolBenchmark\n+\n+### Phase 3: CPU Optimizations\n+5. **Reflection caching** (RecordingImpl.java)\n+   - Expected: 50% startup improvement\n+   - Manual measurement required\n+\n+6. **LEB128 encoding optimization**\n+   - Expected: 15% encoding CPU reduction\n+   - Benchmark: EventWriteThroughputBenchmark\n+\n+## Comparing Results\n+\n+### Before vs After\n+```bash\n+# Run baseline before optimizations\n+java -jar target\/benchmarks.jar -rf json -rff baseline.json\n+\n+# After implementing optimizations\n+java -jar target\/benchmarks.jar -rf json -rff optimized.json\n+\n+# Compare (using JMH compare tool or manual analysis)\n+```\n+\n+### Expected Improvements\n+- **Allocation Rate**: 60-70% reduction\n+- **Event Throughput**: 40-50% increase\n+- **String Encoding (cached)**: 2-3x faster\n+- **Constant Pool Buildup**: 30% faster\n+\n+## Troubleshooting\n+\n+### Build Issues\n+- **Missing dependencies**: Run `mvn clean install -DskipTests` from `core\/` directory first\n+- **Compilation errors**: Ensure JDK 17+ is being used\n+\n+### Runtime Issues\n+- **OutOfMemoryError**: Increase heap size: `-Xms4G -Xmx4G`\n+- **Benchmarks take too long**: Use quick mode: `-wi 1 -i 1`\n+\n+## References\n+\n+- JMH Documentation: https:\/\/github.com\/openjdk\/jmh\n+- Performance Optimization Plan: `~\/.claude\/plans\/snug-growing-horizon.md`\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/doc\/performance-benchmarks.md","additions":306,"deletions":0,"binary":false,"changes":306,"status":"added"},{"patch":"@@ -36,0 +36,1 @@\n+import java.io.IOException;\n@@ -42,1 +43,3 @@\n-\tprivate final LEB128Writer writer = LEB128Writer.getInstance();\n+\tprivate final LEB128Writer writer;\n+\tprivate final ThreadMmapManager mmapManager;\n+\tprivate final long threadId;\n@@ -47,0 +50,7 @@\n+\t\tthis(LEB128Writer.getInstance(), null);\n+\t}\n+\n+\tChunk(LEB128Writer writer, ThreadMmapManager mmapManager) {\n+\t\tthis.writer = writer;\n+\t\tthis.mmapManager = mmapManager;\n+\t\tthis.threadId = Thread.currentThread().getId();\n@@ -96,4 +106,0 @@\n-\t\tif (value == null && builtin != TypesImpl.Builtin.STRING) {\n-\t\t\t\/\/ skip the non-string built-in values\n-\t\t\treturn;\n-\t\t}\n@@ -117,1 +123,1 @@\n-\t\t\twriter.writeByte((byte) value);\n+\t\t\twriter.writeByte(value == null ? (byte) 0 : (byte) value);\n@@ -121,1 +127,1 @@\n-\t\t\twriter.writeChar((char) value);\n+\t\t\twriter.writeChar(value == null ? (char) 0 : (char) value);\n@@ -125,1 +131,1 @@\n-\t\t\twriter.writeShort((short) value);\n+\t\t\twriter.writeShort(value == null ? (short) 0 : (short) value);\n@@ -129,1 +135,1 @@\n-\t\t\twriter.writeInt((int) value);\n+\t\t\twriter.writeInt(value == null ? 0 : (int) value);\n@@ -133,1 +139,1 @@\n-\t\t\twriter.writeLong((long) value);\n+\t\t\twriter.writeLong(value == null ? 0L : (long) value);\n@@ -137,1 +143,1 @@\n-\t\t\twriter.writeFloat((float) value);\n+\t\t\twriter.writeFloat(value == null ? 0.0f : (float) value);\n@@ -141,1 +147,1 @@\n-\t\t\twriter.writeDouble((double) value);\n+\t\t\twriter.writeDouble(value == null ? 0.0 : (double) value);\n@@ -145,1 +151,1 @@\n-\t\t\twriter.writeBoolean((boolean) value);\n+\t\t\twriter.writeBoolean(value != null && (boolean) value);\n@@ -159,0 +165,1 @@\n+\t\t\/\/ Serialize event to temporary heap-based buffer\n@@ -165,1 +172,31 @@\n-\t\twriter.writeInt(eventWriter.length()) \/\/ write event size\n+\t\tint eventSize = eventWriter.length();\n+\n+\t\t\/\/ Check if active buffer has space (size prefix + event data)\n+\t\t\/\/ LEB128 encoding uses at most 5 bytes for int32\n+\t\tint requiredSpace = 5 + eventSize;\n+\n+\t\t\/\/ Get current active writer (may change after rotation)\n+\t\tLEB128Writer activeWriter;\n+\t\tif (mmapManager != null) {\n+\t\t\ttry {\n+\t\t\t\t\/\/ Always get the current active writer in mmap mode\n+\t\t\t\tactiveWriter = mmapManager.getActiveWriter(threadId);\n+\t\t\t\tif (activeWriter instanceof LEB128MappedWriter) {\n+\t\t\t\t\tLEB128MappedWriter mmapWriter = (LEB128MappedWriter) activeWriter;\n+\t\t\t\t\tif (!mmapWriter.canFit(requiredSpace)) {\n+\t\t\t\t\t\t\/\/ Trigger rotation - swap buffers and flush inactive in background\n+\t\t\t\t\t\tmmapManager.rotateChunk(threadId);\n+\t\t\t\t\t\t\/\/ Get the NEW active writer after rotation\n+\t\t\t\t\t\tactiveWriter = mmapManager.getActiveWriter(threadId);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new RuntimeException(\"Chunk rotation failed for thread \" + threadId, e);\n+\t\t\t}\n+\t\t} else {\n+\t\t\t\/\/ Heap mode - use the fixed writer\n+\t\t\tactiveWriter = writer;\n+\t\t}\n+\n+\t\t\/\/ Write event to active writer (might be rotated)\n+\t\tactiveWriter.writeInt(eventSize) \/\/ write event size\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/Chunk.java","additions":51,"deletions":14,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -0,0 +1,228 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * Memory-mapped file writer with fixed-size buffer and support for LEB128 encoded integer types.\n+ * This implementation uses a memory-mapped file for off-heap storage with bounded memory usage.\n+ *\/\n+final class LEB128MappedWriter extends AbstractLEB128Writer {\n+\tprivate final FileChannel channel;\n+\tprivate MappedByteBuffer buffer;\n+\tprivate final Path mmapFile;\n+\tprivate final int capacity;\n+\tprivate int position;\n+\n+\tLEB128MappedWriter(Path file, int capacity) throws IOException {\n+\t\tthis.mmapFile = file;\n+\t\tthis.capacity = capacity;\n+\t\tthis.position = 0;\n+\n+\t\t\/\/ Create file and map it\n+\t\tthis.channel = FileChannel.open(file, StandardOpenOption.CREATE, StandardOpenOption.READ,\n+\t\t\t\tStandardOpenOption.WRITE);\n+\t\tthis.buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, capacity);\n+\t}\n+\n+\t@Override\n+\tpublic void reset() {\n+\t\tposition = 0;\n+\t\tbuffer.position(0);\n+\t}\n+\n+\t\/**\n+\t * Check if the buffer can fit the specified number of bytes.\n+\t *\n+\t * @param bytes\n+\t *            the number of bytes to check\n+\t * @return true if the bytes can fit, false otherwise\n+\t *\/\n+\tboolean canFit(int bytes) {\n+\t\treturn position + bytes <= capacity;\n+\t}\n+\n+\t\/**\n+\t * Flush pending writes to disk.\n+\t *\/\n+\tvoid force() {\n+\t\tif (buffer != null) {\n+\t\t\tbuffer.force();\n+\t\t}\n+\t}\n+\n+\t\/**\n+\t * Get the current data size (number of bytes written).\n+\t *\n+\t * @return the current position\/size\n+\t *\/\n+\tint getDataSize() {\n+\t\treturn position;\n+\t}\n+\n+\t\/**\n+\t * Copy current data to output stream.\n+\t *\n+\t * @param out\n+\t *            the output stream to copy to\n+\t * @throws IOException\n+\t *             if an I\/O error occurs\n+\t *\/\n+\tvoid copyTo(OutputStream out) throws IOException {\n+\t\tbyte[] data = new byte[position];\n+\t\tbuffer.position(0);\n+\t\tbuffer.get(data);\n+\t\tout.write(data);\n+\t}\n+\n+\t\/**\n+\t * Get the path to the memory-mapped file.\n+\t *\n+\t * @return the file path\n+\t *\/\n+\tPath getFilePath() {\n+\t\treturn mmapFile;\n+\t}\n+\n+\t@Override\n+\tpublic int position() {\n+\t\treturn position;\n+\t}\n+\n+\t@Override\n+\tpublic int capacity() {\n+\t\treturn capacity;\n+\t}\n+\n+\t@Override\n+\tpublic long writeFloat(long offset, float data) {\n+\t\treturn writeIntRaw(offset, Float.floatToIntBits(data));\n+\t}\n+\n+\t@Override\n+\tpublic long writeDouble(long offset, double data) {\n+\t\treturn writeLongRaw(offset, Double.doubleToLongBits(data));\n+\t}\n+\n+\t@Override\n+\tpublic long writeByte(long offset, byte data) {\n+\t\tint off = (int) offset;\n+\t\tbuffer.put(off, data);\n+\t\tposition = Math.max(position, off + 1);\n+\t\treturn off + 1;\n+\t}\n+\n+\t@Override\n+\tpublic long writeBytes(long offset, byte ... data) {\n+\t\tif (data == null) {\n+\t\t\treturn offset;\n+\t\t}\n+\t\tint off = (int) offset;\n+\t\tbuffer.position(off);\n+\t\tbuffer.put(data);\n+\t\tposition = Math.max(position, off + data.length);\n+\t\treturn off + data.length;\n+\t}\n+\n+\t@Override\n+\tpublic long writeShortRaw(long offset, short data) {\n+\t\tint off = (int) offset;\n+\t\tbuffer.putShort(off, data);\n+\t\tposition = Math.max(position, off + 2);\n+\t\treturn off + 2;\n+\t}\n+\n+\t@Override\n+\tpublic long writeIntRaw(long offset, int data) {\n+\t\tint off = (int) offset;\n+\t\tbuffer.putInt(off, data);\n+\t\tposition = Math.max(position, off + 4);\n+\t\treturn off + 4;\n+\t}\n+\n+\t@Override\n+\tpublic long writeLongRaw(long offset, long data) {\n+\t\tint off = (int) offset;\n+\t\tbuffer.putLong(off, data);\n+\t\tposition = Math.max(position, off + 8);\n+\t\treturn off + 8;\n+\t}\n+\n+\t@Override\n+\tpublic void export(Consumer<ByteBuffer> consumer) {\n+\t\t\/\/ Create a read-only view of the data written so far\n+\t\tByteBuffer view = buffer.asReadOnlyBuffer();\n+\t\tview.position(0);\n+\t\tview.limit(position);\n+\t\tconsumer.accept(view);\n+\t}\n+\n+\t\/**\n+\t * Export the current data as a byte array.\n+\t *\n+\t * @return byte array containing the data\n+\t *\/\n+\tbyte[] exportBytes() {\n+\t\tbyte[] data = new byte[position];\n+\t\tbuffer.position(0);\n+\t\tbuffer.get(data);\n+\t\treturn data;\n+\t}\n+\n+\t\/**\n+\t * Close the writer and release resources. Note: The backing file is NOT deleted - caller is\n+\t * responsible for cleanup.\n+\t *\n+\t * @throws IOException\n+\t *             if an I\/O error occurs\n+\t *\/\n+\tvoid close() throws IOException {\n+\t\tif (buffer != null) {\n+\t\t\tforce();\n+\t\t\t\/\/ Help GC by clearing reference\n+\t\t\tbuffer = null;\n+\t\t}\n+\t\tif (channel != null && channel.isOpen()) {\n+\t\t\tchannel.close();\n+\t\t}\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/LEB128MappedWriter.java","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"},{"patch":"@@ -39,0 +39,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -92,0 +94,3 @@\n+\tprivate final ThreadMmapManager mmapManager;\n+\tprivate final boolean useMmap;\n+\n@@ -95,1 +100,13 @@\n-\t\t\tChunk chunk = new Chunk();\n+\t\t\tChunk chunk;\n+\t\t\tif (useMmap && mmapManager != null) {\n+\t\t\t\ttry {\n+\t\t\t\t\tlong threadId = Thread.currentThread().getId();\n+\t\t\t\t\tLEB128MappedWriter mmapWriter = mmapManager.getActiveWriter(threadId);\n+\t\t\t\t\tchunk = new Chunk(mmapWriter, mmapManager);\n+\t\t\t\t} catch (IOException e) {\n+\t\t\t\t\tthrow new RuntimeException(\n+\t\t\t\t\t\t\t\"Failed to create mmap writer for thread \" + Thread.currentThread().getId(), e);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tchunk = new Chunk();\n+\t\t\t}\n@@ -115,1 +132,1 @@\n-\tprivate final ExecutorService chunkDataMergingService = Executors.newSingleThreadExecutor();\n+\tprivate final ExecutorService chunkDataMergingService;\n@@ -135,1 +152,0 @@\n-\t\twriteFileHeader();\n@@ -137,1 +153,3 @@\n-\t\tchunkDataMergingService.submit(() -> {\n+\t\t\/\/ Initialize mmap support if enabled via settings\n+\t\tthis.useMmap = settings.useMmap();\n+\t\tif (useMmap) {\n@@ -139,7 +157,4 @@\n-\t\t\t\twhile (!chunkDataMergingService.isShutdown()) {\n-\t\t\t\t\tprocessChunkDataQueue(500, TimeUnit.MILLISECONDS);\n-\t\t\t\t}\n-\t\t\t\t\/\/ process any outstanding elements in the queue\n-\t\t\t\tprocessChunkDataQueue(1, TimeUnit.NANOSECONDS);\n-\t\t\t} catch (InterruptedException e) {\n-\t\t\t\tThread.currentThread().interrupt();\n+\t\t\t\tPath tempDir = Files.createTempDirectory(\"jfr-writer-mmap-\");\n+\t\t\t\tthis.mmapManager = new ThreadMmapManager(tempDir, settings.getMmapChunkSize());\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new RuntimeException(\"Failed to initialize mmap manager\", e);\n@@ -147,1 +162,19 @@\n-\t\t});\n+\t\t\tthis.chunkDataMergingService = null;\n+\t\t} else {\n+\t\t\tthis.mmapManager = null;\n+\t\t\t\/\/ Only create and start background merging service for heap mode\n+\t\t\tthis.chunkDataMergingService = Executors.newSingleThreadExecutor();\n+\t\t\tchunkDataMergingService.submit(() -> {\n+\t\t\t\ttry {\n+\t\t\t\t\twhile (!chunkDataMergingService.isShutdown()) {\n+\t\t\t\t\t\tprocessChunkDataQueue(500, TimeUnit.MILLISECONDS);\n+\t\t\t\t\t}\n+\t\t\t\t\t\/\/ process any outstanding elements in the queue\n+\t\t\t\t\tprocessChunkDataQueue(1, TimeUnit.NANOSECONDS);\n+\t\t\t\t} catch (InterruptedException e) {\n+\t\t\t\t\tThread.currentThread().interrupt();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\twriteFileHeader();\n@@ -183,12 +216,11 @@\n-\t\t\t\t\/*\n-\t\t\t\t * All active chunks are stable here - no new data will be added there so we can get\n-\t\t\t\t * away with slightly racy code ....\n-\t\t\t\t *\/\n-\t\t\t\tfor (Chunk chunk : activeChunks) {\n-\t\t\t\t\tchunk.finish(writer -> {\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tchunkDataQueue.put(writer);\n-\t\t\t\t\t\t} catch (InterruptedException ignored) {\n-\t\t\t\t\t\t\tThread.currentThread().interrupt();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t});\n+\t\t\t\tif (useMmap && mmapManager != null) {\n+\t\t\t\t\t\/\/ Mmap-based finalization\n+\t\t\t\t\tcloseMmapRecording();\n+\t\t\t\t} else {\n+\t\t\t\t\t\/\/ Legacy heap-based finalization\n+\t\t\t\t\tcloseHeapRecording();\n+\t\t\t\t}\n+\t\t\t} finally {\n+\t\t\t\toutputStream.close();\n+\t\t\t\tif (mmapManager != null) {\n+\t\t\t\t\tmmapManager.cleanup();\n@@ -196,1 +228,3 @@\n-\t\t\t\tactiveChunks.clear();\n+\t\t\t}\n+\t\t}\n+\t}\n@@ -198,2 +232,7 @@\n-\t\t\t\tchunkDataMergingService.shutdown();\n-\t\t\t\tboolean flushed = false;\n+\tprivate void closeHeapRecording() throws IOException {\n+\t\t\/*\n+\t\t * All active chunks are stable here - no new data will be added there so we can get away\n+\t\t * with slightly racy code ....\n+\t\t *\/\n+\t\tfor (Chunk chunk : activeChunks) {\n+\t\t\tchunk.finish(writer -> {\n@@ -201,2 +240,2 @@\n-\t\t\t\t\tflushed = chunkDataMergingService.awaitTermination(5, TimeUnit.SECONDS);\n-\t\t\t\t} catch (InterruptedException e) {\n+\t\t\t\t\tchunkDataQueue.put(writer);\n+\t\t\t\t} catch (InterruptedException ignored) {\n@@ -205,4 +244,3 @@\n-\t\t\t\tif (!flushed) {\n-\t\t\t\t\tthrow new RuntimeException(\"Unable to flush dangling JFR chunks\");\n-\t\t\t\t}\n-\t\t\t\tfinalizeRecording();\n+\t\t\t});\n+\t\t}\n+\t\tactiveChunks.clear();\n@@ -210,3 +248,10 @@\n-\t\t\t\toutputStream.write(globalWriter.export());\n-\t\t\t} finally {\n-\t\t\t\toutputStream.close();\n+\t\tif (chunkDataMergingService != null) {\n+\t\t\tchunkDataMergingService.shutdown();\n+\t\t\tboolean flushed = false;\n+\t\t\ttry {\n+\t\t\t\tflushed = chunkDataMergingService.awaitTermination(5, TimeUnit.SECONDS);\n+\t\t\t} catch (InterruptedException e) {\n+\t\t\t\tThread.currentThread().interrupt();\n+\t\t\t}\n+\t\t\tif (!flushed) {\n+\t\t\t\tthrow new RuntimeException(\"Unable to flush dangling JFR chunks\");\n@@ -215,0 +260,14 @@\n+\t\tfinalizeRecording();\n+\n+\t\toutputStream.write(globalWriter.export());\n+\t}\n+\n+\tprivate void closeMmapRecording() throws IOException {\n+\t\t\/\/ Flush all active buffers\n+\t\tmmapManager.finalFlush();\n+\t\tactiveChunks.clear();\n+\n+\t\t\/\/ chunkDataMergingService was never started in mmap mode, so no need to shut it down\n+\n+\t\t\/\/ Sequential write: header → chunks → checkpoint → metadata\n+\t\tfinalizeRecordingMmap();\n@@ -676,0 +735,62 @@\n+\tprivate void finalizeRecordingMmap() throws IOException {\n+\t\tlong recDuration = duration > 0 ? duration : System.nanoTime() - startTicks;\n+\t\ttypes.resolveAll();\n+\n+\t\t\/\/ Create checkpoint and metadata in heap-based writer\n+\t\tLEB128Writer cpWriter = LEB128Writer.getInstance();\n+\t\tcpWriter.writeLong(1L) \/\/ checkpoint event ID\n+\t\t\t\t.writeLong(startNanos) \/\/ start timestamp\n+\t\t\t\t.writeLong(recDuration) \/\/ duration till now\n+\t\t\t\t.writeLong(0L) \/\/ fake delta-to-next\n+\t\t\t\t.writeInt(1) \/\/ all checkpoints are flush for now\n+\t\t\t\t.writeInt(metadata.getConstantPools().size()); \/\/ start writing constant pools array\n+\n+\t\tfor (ConstantPool cp : metadata.getConstantPools()) {\n+\t\t\tcp.writeTo(cpWriter);\n+\t\t}\n+\n+\t\t\/\/ Prepare checkpoint event with size prefix\n+\t\tLEB128Writer cpEventWriter = LEB128Writer.getInstance();\n+\t\tcpEventWriter.writeInt(cpWriter.length());\n+\t\tcpEventWriter.writeBytes(cpWriter.export());\n+\n+\t\t\/\/ Create metadata event\n+\t\tLEB128Writer mdWriter = LEB128Writer.getInstance();\n+\t\tmetadata.writeMetaEvent(mdWriter, startTicks, recDuration);\n+\n+\t\t\/\/ Calculate offsets\n+\t\tlong headerSize = 68; \/\/ Fixed JFR header size\n+\t\tList<Path> flushedChunks = mmapManager.getFlushedChunks();\n+\t\tlong chunksSize = 0;\n+\t\tfor (Path chunk : flushedChunks) {\n+\t\t\tchunksSize += Files.size(chunk);\n+\t\t}\n+\n+\t\tlong checkpointOffset = headerSize + chunksSize;\n+\t\tlong metadataOffset = checkpointOffset + cpEventWriter.length();\n+\t\tlong totalSize = metadataOffset + mdWriter.length();\n+\n+\t\t\/\/ Write header with correct offsets\n+\t\tLEB128Writer headerWriter = LEB128Writer.getInstance();\n+\t\theaderWriter.writeBytes(MAGIC).writeShortRaw(MAJOR_VERSION).writeShortRaw(MINOR_VERSION).writeLongRaw(totalSize) \/\/ total file size\n+\t\t\t\t.writeLongRaw(checkpointOffset) \/\/ CP event offset\n+\t\t\t\t.writeLongRaw(metadataOffset) \/\/ meta event offset\n+\t\t\t\t.writeLongRaw(startNanos) \/\/ start time in nanoseconds\n+\t\t\t\t.writeLongRaw(recDuration) \/\/ duration\n+\t\t\t\t.writeLongRaw(startTicks) \/\/ start time in ticks\n+\t\t\t\t.writeLongRaw(1_000_000_000L) \/\/ 1 tick = 1 ns\n+\t\t\t\t.writeIntRaw(1); \/\/ use compressed integers\n+\n+\t\t\/\/ Sequential write: header → chunks → checkpoint → metadata\n+\t\toutputStream.write(headerWriter.export());\n+\n+\t\t\/\/ Write all flushed chunks\n+\t\tfor (Path chunkFile : flushedChunks) {\n+\t\t\tFiles.copy(chunkFile, outputStream);\n+\t\t}\n+\n+\t\t\/\/ Write checkpoint and metadata\n+\t\toutputStream.write(cpEventWriter.export());\n+\t\toutputStream.write(mdWriter.export());\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/RecordingImpl.java","additions":157,"deletions":36,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+\tprivate boolean useMmap = false;\n+\tprivate int mmapChunkSize = 4 * 1024 * 1024; \/\/ 4MB default\n@@ -69,0 +71,13 @@\n+\t@Override\n+\tpublic RecordingSettingsBuilder withMmap() {\n+\t\tthis.useMmap = true;\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic RecordingSettingsBuilder withMmap(int chunkSize) {\n+\t\tthis.useMmap = true;\n+\t\tthis.mmapChunkSize = chunkSize;\n+\t\treturn this;\n+\t}\n+\n@@ -72,1 +87,1 @@\n-\t\t\t\tstartTicks > 0 ? startTicks : System.nanoTime(), duration, initializeJdkTypes);\n+\t\t\t\tstartTicks > 0 ? startTicks : System.nanoTime(), duration, initializeJdkTypes, useMmap, mmapChunkSize);\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/RecordingSettingsBuilderImpl.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,264 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\/**\n+ * Manages double-buffered memory-mapped files per thread with background flushing. Each thread gets\n+ * two fixed-size mmap buffers (active and inactive) for lock-free writes. When the active buffer\n+ * fills, buffers are swapped and the inactive buffer is flushed to disk in the background.\n+ *\/\n+final class ThreadMmapManager {\n+\tprivate final Path tempDir;\n+\tprivate final int chunkSize;\n+\tprivate final ConcurrentHashMap<Long, ThreadBufferState> threadStates;\n+\tprivate final ExecutorService flushExecutor;\n+\tprivate final ConcurrentLinkedQueue<Path> flushedChunks;\n+\n+\tThreadMmapManager(Path tempDir, int chunkSize) throws IOException {\n+\t\tthis.tempDir = tempDir;\n+\t\tthis.chunkSize = chunkSize;\n+\t\tthis.threadStates = new ConcurrentHashMap<>();\n+\t\t\/\/ Create thread pool with daemon threads so they don't prevent JVM shutdown\n+\t\tthis.flushExecutor = Executors.newFixedThreadPool(Math.min(4, Runtime.getRuntime().availableProcessors()),\n+\t\t\t\tr -> {\n+\t\t\t\t\tThread t = new Thread(r);\n+\t\t\t\t\tt.setDaemon(true);\n+\t\t\t\t\treturn t;\n+\t\t\t\t});\n+\t\tthis.flushedChunks = new ConcurrentLinkedQueue<>();\n+\n+\t\t\/\/ Ensure temp directory exists\n+\t\tif (!Files.exists(tempDir)) {\n+\t\t\tFiles.createDirectories(tempDir);\n+\t\t}\n+\t}\n+\n+\t\/**\n+\t * Get the active writer for the specified thread. Creates double-buffered mmap files on first\n+\t * access.\n+\t *\n+\t * @param threadId\n+\t *            the thread ID\n+\t * @return the active LEB128MappedWriter for this thread\n+\t * @throws IOException\n+\t *             if mmap file creation fails\n+\t *\/\n+\tLEB128MappedWriter getActiveWriter(long threadId) throws IOException {\n+\t\tThreadBufferState state = threadStates.computeIfAbsent(threadId, id -> {\n+\t\t\ttry {\n+\t\t\t\treturn createThreadBuffers(id);\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new RuntimeException(\"Failed to create thread buffers for thread \" + id, e);\n+\t\t\t}\n+\t\t});\n+\t\treturn state.getActiveWriter();\n+\t}\n+\n+\t\/**\n+\t * Rotate chunk for the specified thread: swap active\/inactive buffers and flush the old active\n+\t * buffer to disk in the background.\n+\t *\n+\t * @param threadId\n+\t *            the thread ID\n+\t * @throws IOException\n+\t *             if rotation fails\n+\t *\/\n+\tvoid rotateChunk(long threadId) throws IOException {\n+\t\tThreadBufferState state = threadStates.get(threadId);\n+\t\tif (state == null) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t\/\/ Swap buffers - get old active for flushing\n+\t\tLEB128MappedWriter oldActive = state.swapBuffers();\n+\n+\t\t\/\/ Flush old active to disk in background\n+\t\tint sequence = state.nextSequence();\n+\t\tPath chunkFile = tempDir.resolve(\"chunk-\" + threadId + \"-\" + sequence + \".dat\");\n+\n+\t\tflushExecutor.submit(() -> {\n+\t\t\ttry {\n+\t\t\t\toldActive.force();\n+\t\t\t\t\/\/ Copy to persistent file\n+\t\t\t\ttry (FileOutputStream fos = new FileOutputStream(chunkFile.toFile())) {\n+\t\t\t\t\toldActive.copyTo(fos);\n+\t\t\t\t}\n+\t\t\t\tflushedChunks.add(chunkFile);\n+\t\t\t\t\/\/ Reset buffer for reuse\n+\t\t\t\toldActive.reset();\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new RuntimeException(\"Failed to flush chunk for thread \" + threadId, e);\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\t\/**\n+\t * Get all flushed chunk files for finalization.\n+\t *\n+\t * @return list of flushed chunk file paths\n+\t *\/\n+\tList<Path> getFlushedChunks() {\n+\t\treturn new ArrayList<>(flushedChunks);\n+\t}\n+\n+\t\/**\n+\t * Final flush: force flush any active buffers before close.\n+\t *\n+\t * @throws IOException\n+\t *             if flush fails\n+\t *\/\n+\tvoid finalFlush() throws IOException {\n+\t\tfor (ThreadBufferState state : threadStates.values()) {\n+\t\t\tLEB128MappedWriter active = state.getActiveWriter();\n+\t\t\tif (active.getDataSize() > 0) {\n+\t\t\t\t\/\/ Flush final active buffer\n+\t\t\t\tlong threadId = state.threadId;\n+\t\t\t\tint sequence = state.nextSequence();\n+\t\t\t\tPath chunkFile = tempDir.resolve(\"chunk-\" + threadId + \"-\" + sequence + \".dat\");\n+\n+\t\t\t\tactive.force();\n+\t\t\t\ttry (FileOutputStream fos = new FileOutputStream(chunkFile.toFile())) {\n+\t\t\t\t\tactive.copyTo(fos);\n+\t\t\t\t}\n+\t\t\t\tflushedChunks.add(chunkFile);\n+\t\t\t}\n+\t\t}\n+\n+\t\t\/\/ Wait for background flushes to complete\n+\t\tflushExecutor.shutdown();\n+\t\ttry {\n+\t\t\tif (!flushExecutor.awaitTermination(10, TimeUnit.SECONDS)) {\n+\t\t\t\tflushExecutor.shutdownNow();\n+\t\t\t}\n+\t\t} catch (InterruptedException e) {\n+\t\t\tflushExecutor.shutdownNow();\n+\t\t\tThread.currentThread().interrupt();\n+\t\t}\n+\t}\n+\n+\t\/**\n+\t * Cleanup: close all mmap files and delete temporary files.\n+\t *\n+\t * @throws IOException\n+\t *             if cleanup fails\n+\t *\/\n+\tvoid cleanup() throws IOException {\n+\t\t\/\/ Close all mmap files\n+\t\tfor (ThreadBufferState state : threadStates.values()) {\n+\t\t\tstate.close();\n+\t\t}\n+\n+\t\t\/\/ Delete chunk files\n+\t\tfor (Path chunk : flushedChunks) {\n+\t\t\tFiles.deleteIfExists(chunk);\n+\t\t}\n+\n+\t\t\/\/ Delete buffer files and temp directory\n+\t\tif (Files.exists(tempDir)) {\n+\t\t\tFiles.walk(tempDir).sorted((a, b) -> b.compareTo(a)) \/\/ Reverse order for depth-first deletion\n+\t\t\t\t\t.forEach(path -> {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tFiles.deleteIfExists(path);\n+\t\t\t\t\t\t} catch (IOException e) {\n+\t\t\t\t\t\t\t\/\/ Best effort\n+\t\t\t\t\t\t}\n+\t\t\t\t\t});\n+\t\t}\n+\t}\n+\n+\tprivate ThreadBufferState createThreadBuffers(long threadId) throws IOException {\n+\t\tPath buffer0 = tempDir.resolve(\"thread-\" + threadId + \"-buffer-0.mmap\");\n+\t\tPath buffer1 = tempDir.resolve(\"thread-\" + threadId + \"-buffer-1.mmap\");\n+\t\treturn new ThreadBufferState(threadId, new LEB128MappedWriter(buffer0, chunkSize),\n+\t\t\t\tnew LEB128MappedWriter(buffer1, chunkSize));\n+\t}\n+\n+\t\/**\n+\t * Per-thread state managing double-buffered mmap files.\n+\t *\/\n+\tstatic final class ThreadBufferState {\n+\t\tfinal long threadId;\n+\t\tprivate final LEB128MappedWriter buffer0;\n+\t\tprivate final LEB128MappedWriter buffer1;\n+\t\tprivate volatile boolean activeIsBuffer0 = true;\n+\t\tprivate final AtomicInteger sequence = new AtomicInteger(0);\n+\n+\t\tThreadBufferState(long threadId, LEB128MappedWriter buffer0, LEB128MappedWriter buffer1) {\n+\t\t\tthis.threadId = threadId;\n+\t\t\tthis.buffer0 = buffer0;\n+\t\t\tthis.buffer1 = buffer1;\n+\t\t}\n+\n+\t\tLEB128MappedWriter getActiveWriter() {\n+\t\t\treturn activeIsBuffer0 ? buffer0 : buffer1;\n+\t\t}\n+\n+\t\tLEB128MappedWriter getInactiveWriter() {\n+\t\t\treturn activeIsBuffer0 ? buffer1 : buffer0;\n+\t\t}\n+\n+\t\t\/**\n+\t\t * Swap active\/inactive buffers, returning the old active buffer for flushing.\n+\t\t *\n+\t\t * @return the old active buffer\n+\t\t *\/\n+\t\tsynchronized LEB128MappedWriter swapBuffers() {\n+\t\t\tLEB128MappedWriter oldActive = getActiveWriter();\n+\t\t\tactiveIsBuffer0 = !activeIsBuffer0;\n+\t\t\treturn oldActive;\n+\t\t}\n+\n+\t\tint nextSequence() {\n+\t\t\treturn sequence.getAndIncrement();\n+\t\t}\n+\n+\t\tvoid close() throws IOException {\n+\t\t\tbuffer0.close();\n+\t\t\tbuffer1.close();\n+\t\t}\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/ThreadMmapManager.java","additions":264,"deletions":0,"binary":false,"changes":264,"status":"added"},{"patch":"@@ -36,0 +36,1 @@\n+import org.openjdk.jmc.flightrecorder.writer.api.Annotation;\n@@ -145,1 +146,1 @@\n-\t\t\t\tvalue = new TypedFieldValueImpl(field, field.getType().nullValue());\n+\t\t\t\tvalue = new TypedFieldValueImpl(field, getDefaultImplicitFieldValue(field));\n@@ -152,0 +153,55 @@\n+\t\/**\n+\t * Gets the default value for a field when not explicitly provided by the user.\n+\t * <p>\n+\t * For event types (jdk.jfr.Event):\n+\t * <ul>\n+\t * <li>Fields annotated with {@code @Timestamp} receive {@link System#nanoTime()} as default,\n+\t * providing a monotonic timestamp that will be >= the chunk's startTicks<\/li>\n+\t * <li>Other fields receive null values<\/li>\n+\t * <\/ul>\n+\t * <p>\n+\t * Note: JFR timestamps are stored as ticks relative to the chunk start, so the parser will\n+\t * convert this absolute tick value to chunk-relative during reading.\n+\t * <p>\n+\t * <strong>Tick Frequency Assumption:<\/strong> This implementation assumes a 1:1 tick frequency\n+\t * (1 tick = 1 nanosecond) as currently hardcoded in {@code RecordingImpl}. If the tick\n+\t * frequency becomes configurable in the future, {@link System#nanoTime()} values will need to\n+\t * be converted to ticks using: {@code nanoTime * ticksPerSecond \/ 1_000_000_000L}.\n+\t *\n+\t * @param field\n+\t *            the field to get default value for\n+\t * @return the default value for the field\n+\t *\/\n+\tprivate TypedValueImpl getDefaultImplicitFieldValue(TypedFieldImpl field) {\n+\t\tif (!\"jdk.jfr.Event\".equals(type.getSupertype())) {\n+\t\t\treturn field.getType().nullValue();\n+\t\t}\n+\n+\t\t\/\/ Check if field is annotated with @Timestamp (any value means it's chunk-relative)\n+\t\tif (hasTimestampAnnotation(field)) {\n+\t\t\t\/\/ Use current nanoTime as default - will be valid and >= chunk startTicks\n+\t\t\t\/\/ NOTE: Assumes 1:1 tick frequency (1 tick = 1 ns) as per RecordingImpl line 280\n+\t\t\treturn field.getType().asValue(System.nanoTime());\n+\t\t}\n+\n+\t\t\/\/ For all other fields, return null value\n+\t\t\/\/ Null builtin values are handled properly by Chunk.writeBuiltinType()\n+\t\treturn field.getType().nullValue();\n+\t}\n+\n+\t\/**\n+\t * Checks if a field has the {@code @Timestamp} annotation.\n+\t *\n+\t * @param field\n+\t *            the field to check\n+\t * @return true if the field is annotated with @Timestamp\n+\t *\/\n+\tprivate boolean hasTimestampAnnotation(TypedFieldImpl field) {\n+\t\tfor (Annotation annotation : field.getAnnotations()) {\n+\t\t\tif (\"jdk.jfr.Timestamp\".equals(annotation.getType().getTypeName())) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypedValueImpl.java","additions":57,"deletions":1,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+\tprivate final boolean useMmap;\n+\tprivate final int mmapChunkSize;\n@@ -57,0 +59,5 @@\n+\t * @param useMmap\n+\t *            use memory-mapped files for off-heap event storage\n+\t * @param mmapChunkSize\n+\t *            size of each memory-mapped buffer chunk in bytes (only used if useMmap is true)\n+\t * @since 10.0.0\n@@ -58,1 +65,2 @@\n-\tpublic RecordingSettings(long startTimestamp, long startTicks, long duration, boolean initializeJDKTypes) {\n+\tpublic RecordingSettings(long startTimestamp, long startTicks, long duration, boolean initializeJDKTypes,\n+\t\t\tboolean useMmap, int mmapChunkSize) {\n@@ -63,0 +71,19 @@\n+\t\tthis.useMmap = useMmap;\n+\t\tthis.mmapChunkSize = mmapChunkSize;\n+\t}\n+\n+\t\/**\n+\t * @param startTimestamp\n+\t *            the recording start timestamp in epoch nanoseconds (nanoseconds since 1970-01-01)\n+\t *            or -1 to use {@linkplain System#currentTimeMillis()} * 1_000_000\n+\t * @param startTicks\n+\t *            the recording start timestamp in ticks or -1 to use {@linkplain System#nanoTime()}\n+\t * @param duration\n+\t *            the recording duration in ticks or -1 to use the current\n+\t *            {@linkplain System#nanoTime()} to compute the diff from {@linkplain #startTicks}\n+\t * @param initializeJDKTypes\n+\t *            should the {@linkplain org.openjdk.jmc.flightrecorder.writer.api.Types.JDK} types\n+\t *            be initialized\n+\t *\/\n+\tpublic RecordingSettings(long startTimestamp, long startTicks, long duration, boolean initializeJDKTypes) {\n+\t\tthis(startTimestamp, startTicks, duration, initializeJDKTypes, false, 4 * 1024 * 1024);\n@@ -135,0 +162,16 @@\n+\n+\t\/**\n+\t * @return {@literal true} if memory-mapped files should be used for off-heap event storage\n+\t * @since 10.0.0\n+\t *\/\n+\tpublic boolean useMmap() {\n+\t\treturn useMmap;\n+\t}\n+\n+\t\/**\n+\t * @return size of each memory-mapped buffer chunk in bytes\n+\t * @since 10.0.0\n+\t *\/\n+\tpublic int getMmapChunkSize() {\n+\t\treturn mmapChunkSize;\n+\t}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/RecordingSettings.java","additions":44,"deletions":1,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-\t * \n+\t *\n@@ -81,0 +81,24 @@\n+\t\/**\n+\t * Enable memory-mapped files for off-heap event storage. This reduces heap pressure by storing\n+\t * event data in memory-mapped files instead of on-heap byte arrays.\n+\t *\n+\t * @return this instance for chaining\n+\t * @since 10.0.0\n+\t *\/\n+\tdefault RecordingSettingsBuilder withMmap() {\n+\t\treturn this;\n+\t}\n+\n+\t\/**\n+\t * Enable memory-mapped files with a custom chunk size. Each thread gets double-buffered chunks\n+\t * of this size for lock-free writes with automatic rotation.\n+\t *\n+\t * @param chunkSize\n+\t *            size of each memory-mapped buffer chunk in bytes (default: 4MB)\n+\t * @return this instance for chaining\n+\t * @since 10.0.0\n+\t *\/\n+\tdefault RecordingSettingsBuilder withMmap(int chunkSize) {\n+\t\treturn this;\n+\t}\n+\n@@ -83,1 +107,1 @@\n-\t * \n+\t *\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/RecordingSettingsBuilder.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -204,0 +204,28 @@\n+\t * Creates a typed null value for this type.\n+\t * <p>\n+\t * Use this method when you need to pass a null value for optional or missing complex-type\n+\t * fields. Passing {@code null} directly to\n+\t * {@link TypedValueBuilder#putField(String, TypedValue)} causes compilation ambiguity because\n+\t * the method is overloaded with multiple parameter types.\n+\t * <p>\n+\t * For primitive types (int, long, String, etc.), you can pass primitive default\/null values\n+\t * directly. For complex types (Thread, StackTrace, custom types), use this method to create a\n+\t * properly typed null value.\n+\t * <p>\n+\t * <strong>Example:<\/strong>\n+\t *\n+\t * <pre>\n+\t * {\n+\t * \t&#64;code\n+\t * \tTypes types = recording.getTypes();\n+\t * \tType stackTraceType = types.getType(Types.JDK.STACK_TRACE);\n+\t * \tType threadType = types.getType(Types.JDK.THREAD);\n+\t *\n+\t * \tType eventType = recording.registerEventType(\"custom.Event\");\n+\t * \trecording.writeEvent(eventType.asValue(builder -> {\n+\t * \t\tbuilder.putField(\"startTime\", System.nanoTime()).putField(\"stackTrace\", stackTraceType.nullValue()) \/\/ typed null\n+\t * \t\t\t\t.putField(\"eventThread\", threadType.nullValue()); \/\/ typed null\n+\t * \t}));\n+\t * }\n+\t * <\/pre>\n+\t *\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/Type.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -39,1 +39,34 @@\n-\/** A fluent API for lazy initialization of a composite type value *\/\n+\/**\n+ * A fluent API for lazy initialization of a composite type value.\n+ * <p>\n+ * This builder provides a chainable interface for setting field values in complex types. Use it\n+ * with {@link Type#asValue(java.util.function.Consumer)} to construct typed values.\n+ * <h2>Handling Null Values<\/h2>\n+ * <p>\n+ * When setting field values, avoid passing {@code null} directly as it causes compilation ambiguity\n+ * due to overloaded methods. Instead:\n+ * <ul>\n+ * <li>For primitive types (String, int, long, etc.): cast to the specific type, e.g.,\n+ * {@code (String) null}<\/li>\n+ * <li>For complex types (Thread, StackTrace, custom types): use {@link Type#nullValue()}<\/li>\n+ * <\/ul>\n+ * <p>\n+ * <strong>Example:<\/strong>\n+ *\n+ * <pre>\n+ * {\n+ * \t&#64;code\n+ * \tTypes types = recording.getTypes();\n+ * \tType threadType = types.getType(Types.JDK.THREAD);\n+ *\n+ * \tType eventType = recording.registerEventType(\"custom.Event\", builder -> {\n+ * \t\tbuilder.addField(\"message\", Types.Builtin.STRING).addField(\"thread\", Types.JDK.THREAD);\n+ * \t});\n+ *\n+ * \trecording.writeEvent(eventType.asValue(builder -> {\n+ * \t\tbuilder.putField(\"message\", (String) null) \/\/ primitive null with cast\n+ * \t\t\t\t.putField(\"thread\", threadType.nullValue()); \/\/ complex type null\n+ * \t}));\n+ * }\n+ * <\/pre>\n+ *\/\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/TypedValueBuilder.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,313 @@\n+# JFR Writer Performance Benchmarks\n+\n+This module contains JMH (Java Microbenchmark Harness) benchmarks for measuring the performance of the JFR Writer API.\n+\n+## Building\n+\n+Build the benchmark JAR from the benchmark module directory:\n+\n+```bash\n+cd tests\/org.openjdk.jmc.flightrecorder.writer.benchmarks\n+mvn clean package\n+```\n+\n+Or from the core root directory:\n+\n+```bash\n+mvn clean package -DskipTests -f tests\/org.openjdk.jmc.flightrecorder.writer.benchmarks\/pom.xml\n+```\n+\n+This creates an executable uber-JAR: `target\/benchmarks.jar` (~4.7MB)\n+\n+## Running Benchmarks\n+\n+### List Available Benchmarks\n+\n+```bash\n+java -jar target\/benchmarks.jar -l\n+```\n+\n+### Run All Benchmarks\n+\n+Warning: This will take several hours as each benchmark runs multiple iterations with warmup.\n+\n+```bash\n+java -jar target\/benchmarks.jar\n+```\n+\n+### Run Specific Benchmark Class\n+\n+```bash\n+java -jar target\/benchmarks.jar EventWriteThroughputBenchmark\n+```\n+\n+### Run Single Benchmark Method\n+\n+```bash\n+java -jar target\/benchmarks.jar EventWriteThroughputBenchmark.writeSimpleEvent\n+```\n+\n+### Quick Test Run (1 iteration, no warmup, 1 fork)\n+\n+For quick verification or testing:\n+\n+```bash\n+java -jar target\/benchmarks.jar EventWriteThroughputBenchmark.writeSimpleEvent -i 1 -wi 0 -f 1\n+```\n+\n+### Pattern Matching\n+\n+Use regex patterns to run related benchmarks:\n+\n+```bash\n+# Run all throughput benchmarks\n+java -jar target\/benchmarks.jar \".*Throughput.*\"\n+\n+# Run all string encoding benchmarks\n+java -jar target\/benchmarks.jar \".*StringEncoding.*\"\n+\n+# Exclude benchmarks\n+java -jar target\/benchmarks.jar -e \".*Allocation.*\"\n+```\n+\n+## Profiling\n+\n+### List Available Profilers\n+\n+```bash\n+java -jar target\/benchmarks.jar -lprof\n+```\n+\n+### Run with GC Profiler\n+\n+Measure allocation rates and GC pressure:\n+\n+```bash\n+java -jar target\/benchmarks.jar AllocationRateBenchmark -prof gc\n+```\n+\n+### Run with Stack Profiler\n+\n+Identify hotspots:\n+\n+```bash\n+java -jar target\/benchmarks.jar EventWriteThroughputBenchmark -prof stack\n+```\n+\n+### Run with Async Profiler (if available)\n+\n+Requires async-profiler to be installed:\n+\n+```bash\n+java -jar target\/benchmarks.jar EventWriteThroughputBenchmark -prof async:libPath=\/path\/to\/libasyncProfiler.so\n+```\n+\n+## Output Formats\n+\n+### JSON Output\n+\n+```bash\n+java -jar target\/benchmarks.jar EventWriteThroughputBenchmark -rf json -rff results.json\n+```\n+\n+### CSV Output\n+\n+```bash\n+java -jar target\/benchmarks.jar EventWriteThroughputBenchmark -rf csv -rff results.csv\n+```\n+\n+### Multiple Formats\n+\n+```bash\n+java -jar target\/benchmarks.jar EventWriteThroughputBenchmark -rf json -rff results.json -rf text -rff results.txt\n+```\n+\n+## Common Options\n+\n+Run `java -jar target\/benchmarks.jar -h` for all options. Most commonly used:\n+\n+| Option | Description | Example |\n+|--------|-------------|---------|\n+| `-i N` | Number of measurement iterations | `-i 5` |\n+| `-wi N` | Number of warmup iterations | `-wi 3` |\n+| `-f N` | Number of forks | `-f 3` |\n+| `-t N` | Number of threads | `-t 4` |\n+| `-w TIME` | Warmup time per iteration | `-w 10s` |\n+| `-r TIME` | Measurement time per iteration | `-r 10s` |\n+| `-prof PROF` | Enable profiler | `-prof gc` |\n+| `-rf FORMAT` | Result format (json\/csv\/text) | `-rf json` |\n+| `-rff FILE` | Result output file | `-rff results.json` |\n+| `-p PARAM=V` | Override parameter value | `-p poolSize=1000` |\n+\n+## Available Benchmarks\n+\n+### EventWriteThroughputBenchmark\n+\n+Measures event write throughput (operations per second) for different event types:\n+\n+- `writeSimpleEvent` - Event with single long field\n+- `writeMultiFieldEvent` - Event with 5 mixed-type fields (long, int, double, boolean, String)\n+- `writeStringHeavyEvent` - Event with 4 string fields\n+- `writeRepeatedStringsEvent` - Event with repeated strings (tests string pool caching)\n+\n+**Example:**\n+```bash\n+java -jar target\/benchmarks.jar EventWriteThroughputBenchmark\n+```\n+\n+### AllocationRateBenchmark\n+\n+Measures allocation rates during event writing. Designed to be used with GC profiler:\n+\n+- `measureEventWriteAllocations` - Single event write allocation\n+- `measureBatchEventWriteAllocations` - Batch of 100 events allocation\n+\n+**Example:**\n+```bash\n+java -jar target\/benchmarks.jar AllocationRateBenchmark -prof gc\n+```\n+\n+### StringEncodingBenchmark\n+\n+Isolates UTF-8 string encoding performance:\n+\n+- `encodeRepeatedStrings` - Same strings each iteration (cache-friendly)\n+- `encodeUniqueStrings` - Unique strings with counter (uncached)\n+- `encodeMixedStrings` - Mix of cached and unique strings (realistic)\n+- `encodeUtf8Strings` - Multi-byte UTF-8 characters (CJK, Cyrillic, Arabic, emoji)\n+\n+**Example:**\n+```bash\n+java -jar target\/benchmarks.jar StringEncodingBenchmark\n+```\n+\n+### ConstantPoolBenchmark\n+\n+Tests constant pool HashMap performance with parameterized pool sizes:\n+\n+- `buildConstantPoolWithUniqueStrings` - Tests HashMap growth and rehashing\n+- `buildConstantPoolWithRepeatedStrings` - Tests lookup performance\n+- `buildConstantPoolMixed` - Realistic mix pattern (70% cached, 30% unique)\n+\n+**Parameters:** `poolSize=100,500,1000` (default: 100)\n+\n+**Example:**\n+```bash\n+# Run with all parameter combinations\n+java -jar target\/benchmarks.jar ConstantPoolBenchmark\n+\n+# Run with specific pool size\n+java -jar target\/benchmarks.jar ConstantPoolBenchmark -p poolSize=1000\n+```\n+\n+## Comparing Results\n+\n+Use the included `compare.py` Python script to compare two benchmark runs and see performance differences:\n+\n+```bash\n+# Run baseline\n+java -jar target\/benchmarks.jar EventWriteThroughputBenchmark -rf json -rff baseline.json\n+\n+# Run after changes\n+java -jar target\/benchmarks.jar EventWriteThroughputBenchmark -rf json -rff optimized.json\n+\n+# Compare with custom title\n+python3 compare.py baseline.json optimized.json \"My Optimization\"\n+```\n+\n+**Example Output:**\n+```\n+================================================================================\n+My Optimization\n+================================================================================\n+\n+writeSimpleEvent\n+  Baseline:       943526.800 ops\/s\n+  Optimized:      984670.381 ops\/s\n+  Change:    ↑   4.36%\n+\n+writeMultiFieldEvent\n+  Baseline:       787089.123 ops\/s\n+  Optimized:      880622.456 ops\/s\n+  Change:    ↑  11.88%\n+```\n+\n+The script automatically detects benchmark mode and calculates improvements correctly:\n+- **Throughput modes** (ops\/s): Higher is better, shows ↑ for improvements\n+- **Average time modes** (ms\/op): Lower is better, shows ↓ for improvements\n+\n+**Usage:**\n+```bash\n+python3 compare.py <baseline.json> <optimized.json> [optional_title]\n+```\n+\n+## Configuration\n+\n+Benchmarks use the following JVM settings by default (configured in `@Fork` annotations):\n+\n+- Heap: `-Xms2G -Xmx2G`\n+- Threads: 1 (single-threaded by default)\n+- Forks: 2 (for statistical reliability)\n+\n+Override these with command-line options:\n+\n+```bash\n+# Custom heap size\n+java -Xms4G -Xmx4G -jar target\/benchmarks.jar EventWriteThroughputBenchmark\n+\n+# Or via JMH options\n+java -jar target\/benchmarks.jar EventWriteThroughputBenchmark -jvmArgs \"-Xms4G -Xmx4G\"\n+```\n+\n+## Interpreting Results\n+\n+JMH reports several metrics:\n+\n+- **Score**: Mean performance (ops\/s for throughput, ms\/op for average time)\n+- **Error**: Margin of error (99.9% confidence interval)\n+- **Units**: ops\/s (operations per second), ms\/op (milliseconds per operation), etc.\n+\n+Higher ops\/s = better performance\n+Lower ms\/op = better performance\n+\n+Always:\n+1. Run with multiple forks (`-f 3`) for statistical reliability\n+2. Ensure adequate warmup iterations (`-wi 5`)\n+3. Use profilers to understand *why* performance changes\n+4. Compare against baselines, not absolute numbers\n+5. Be aware of JVM optimizations (see JMH warnings about Blackholes)\n+\n+## Troubleshooting\n+\n+### Build Fails\n+\n+If `mvn clean package` fails with MANIFEST.MF errors, ensure you're using the latest pom.xml which correctly configures the maven-jar-plugin to read the manifest from resources.\n+\n+### Benchmark Hangs\n+\n+Some benchmarks create temporary JFR files. If interrupted, clean up:\n+\n+```bash\n+rm -rf \/tmp\/jfr-writer-mmap-*\n+```\n+\n+### Out of Memory\n+\n+Increase heap size:\n+\n+```bash\n+java -Xms4G -Xmx4G -jar target\/benchmarks.jar ...\n+```\n+\n+### Inconsistent Results\n+\n+- Ensure stable system load (close other applications)\n+- Increase forks: `-f 5`\n+- Increase iterations: `-i 10 -wi 5`\n+- Disable dynamic frequency scaling if possible\n+\n+## References\n+\n+- [JMH Documentation](https:\/\/github.com\/openjdk\/jmh)\n+- [JMH Samples](https:\/\/github.com\/openjdk\/jmh\/tree\/master\/jmh-samples\/src\/main\/java\/org\/openjdk\/jmh\/samples)\n+- [JMH Visualizer](https:\/\/jmh.morethan.io\/) - Upload JSON results for visualization\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.benchmarks\/README.md","additions":313,"deletions":0,"binary":false,"changes":313,"status":"added"},{"patch":"@@ -0,0 +1,979 @@\n+[\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.AllocationRateBenchmark.measureBatchEventWriteAllocations\",\n+        \"mode\" : \"thrpt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"5 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"10 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"primaryMetric\" : {\n+            \"score\" : 7197.757761698836,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 6940.520777445677,\n+                \"50.0\" : 7197.757761698836,\n+                \"90.0\" : 7454.994745951994,\n+                \"95.0\" : 7454.994745951994,\n+                \"99.0\" : 7454.994745951994,\n+                \"99.9\" : 7454.994745951994,\n+                \"99.99\" : 7454.994745951994,\n+                \"99.999\" : 7454.994745951994,\n+                \"99.9999\" : 7454.994745951994,\n+                \"100.0\" : 7454.994745951994\n+            },\n+            \"scoreUnit\" : \"ops\/s\",\n+            \"rawData\" : [\n+                [\n+                    7454.994745951994,\n+                    6940.520777445677\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.AllocationRateBenchmark.measureEventWriteAllocations\",\n+        \"mode\" : \"thrpt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"5 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"10 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"primaryMetric\" : {\n+            \"score\" : 899178.7551576358,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 886326.6018194918,\n+                \"50.0\" : 899178.7551576358,\n+                \"90.0\" : 912030.9084957796,\n+                \"95.0\" : 912030.9084957796,\n+                \"99.0\" : 912030.9084957796,\n+                \"99.9\" : 912030.9084957796,\n+                \"99.99\" : 912030.9084957796,\n+                \"99.999\" : 912030.9084957796,\n+                \"99.9999\" : 912030.9084957796,\n+                \"100.0\" : 912030.9084957796\n+            },\n+            \"scoreUnit\" : \"ops\/s\",\n+            \"rawData\" : [\n+                [\n+                    912030.9084957796,\n+                    886326.6018194918\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.EventWriteThroughputBenchmark.writeMultiFieldEvent\",\n+        \"mode\" : \"thrpt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"5 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"10 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"primaryMetric\" : {\n+            \"score\" : 862335.4129249394,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 839770.7011609187,\n+                \"50.0\" : 862335.4129249394,\n+                \"90.0\" : 884900.1246889601,\n+                \"95.0\" : 884900.1246889601,\n+                \"99.0\" : 884900.1246889601,\n+                \"99.9\" : 884900.1246889601,\n+                \"99.99\" : 884900.1246889601,\n+                \"99.999\" : 884900.1246889601,\n+                \"99.9999\" : 884900.1246889601,\n+                \"100.0\" : 884900.1246889601\n+            },\n+            \"scoreUnit\" : \"ops\/s\",\n+            \"rawData\" : [\n+                [\n+                    884900.1246889601,\n+                    839770.7011609187\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.EventWriteThroughputBenchmark.writeRepeatedStringsEvent\",\n+        \"mode\" : \"thrpt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"5 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"10 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"primaryMetric\" : {\n+            \"score\" : 861751.3614186794,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 850584.9265245523,\n+                \"50.0\" : 861751.3614186794,\n+                \"90.0\" : 872917.7963128064,\n+                \"95.0\" : 872917.7963128064,\n+                \"99.0\" : 872917.7963128064,\n+                \"99.9\" : 872917.7963128064,\n+                \"99.99\" : 872917.7963128064,\n+                \"99.999\" : 872917.7963128064,\n+                \"99.9999\" : 872917.7963128064,\n+                \"100.0\" : 872917.7963128064\n+            },\n+            \"scoreUnit\" : \"ops\/s\",\n+            \"rawData\" : [\n+                [\n+                    872917.7963128064,\n+                    850584.9265245523\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.EventWriteThroughputBenchmark.writeSimpleEvent\",\n+        \"mode\" : \"thrpt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"5 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"10 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"primaryMetric\" : {\n+            \"score\" : 986095.2370549459,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 979671.0668974728,\n+                \"50.0\" : 986095.2370549459,\n+                \"90.0\" : 992519.407212419,\n+                \"95.0\" : 992519.407212419,\n+                \"99.0\" : 992519.407212419,\n+                \"99.9\" : 992519.407212419,\n+                \"99.99\" : 992519.407212419,\n+                \"99.999\" : 992519.407212419,\n+                \"99.9999\" : 992519.407212419,\n+                \"100.0\" : 992519.407212419\n+            },\n+            \"scoreUnit\" : \"ops\/s\",\n+            \"rawData\" : [\n+                [\n+                    992519.407212419,\n+                    979671.0668974728\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.EventWriteThroughputBenchmark.writeStringHeavyEvent\",\n+        \"mode\" : \"thrpt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"5 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"10 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"primaryMetric\" : {\n+            \"score\" : 866022.4295841993,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 852934.6996319862,\n+                \"50.0\" : 866022.4295841993,\n+                \"90.0\" : 879110.1595364123,\n+                \"95.0\" : 879110.1595364123,\n+                \"99.0\" : 879110.1595364123,\n+                \"99.9\" : 879110.1595364123,\n+                \"99.99\" : 879110.1595364123,\n+                \"99.999\" : 879110.1595364123,\n+                \"99.9999\" : 879110.1595364123,\n+                \"100.0\" : 879110.1595364123\n+            },\n+            \"scoreUnit\" : \"ops\/s\",\n+            \"rawData\" : [\n+                [\n+                    879110.1595364123,\n+                    852934.6996319862\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.StringEncodingBenchmark.encodeMixedStrings\",\n+        \"mode\" : \"thrpt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"5 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"10 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"primaryMetric\" : {\n+            \"score\" : 177723.13242352506,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 177723.13242352506,\n+                \"50.0\" : 177723.13242352506,\n+                \"90.0\" : 177723.13242352506,\n+                \"95.0\" : 177723.13242352506,\n+                \"99.0\" : 177723.13242352506,\n+                \"99.9\" : 177723.13242352506,\n+                \"99.99\" : 177723.13242352506,\n+                \"99.999\" : 177723.13242352506,\n+                \"99.9999\" : 177723.13242352506,\n+                \"100.0\" : 177723.13242352506\n+            },\n+            \"scoreUnit\" : \"ops\/s\",\n+            \"rawData\" : [\n+                [\n+                    177723.13242352506\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.StringEncodingBenchmark.encodeRepeatedStrings\",\n+        \"mode\" : \"thrpt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"5 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"10 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"primaryMetric\" : {\n+            \"score\" : 866965.5138697355,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 864798.7125068279,\n+                \"50.0\" : 866965.5138697355,\n+                \"90.0\" : 869132.3152326432,\n+                \"95.0\" : 869132.3152326432,\n+                \"99.0\" : 869132.3152326432,\n+                \"99.9\" : 869132.3152326432,\n+                \"99.99\" : 869132.3152326432,\n+                \"99.999\" : 869132.3152326432,\n+                \"99.9999\" : 869132.3152326432,\n+                \"100.0\" : 869132.3152326432\n+            },\n+            \"scoreUnit\" : \"ops\/s\",\n+            \"rawData\" : [\n+                [\n+                    864798.7125068279,\n+                    869132.3152326432\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.StringEncodingBenchmark.encodeUniqueStrings\",\n+        \"mode\" : \"thrpt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"5 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"10 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"primaryMetric\" : {\n+            \"score\" : 72763.64376438508,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 72763.64376438508,\n+                \"50.0\" : 72763.64376438508,\n+                \"90.0\" : 72763.64376438508,\n+                \"95.0\" : 72763.64376438508,\n+                \"99.0\" : 72763.64376438508,\n+                \"99.9\" : 72763.64376438508,\n+                \"99.99\" : 72763.64376438508,\n+                \"99.999\" : 72763.64376438508,\n+                \"99.9999\" : 72763.64376438508,\n+                \"100.0\" : 72763.64376438508\n+            },\n+            \"scoreUnit\" : \"ops\/s\",\n+            \"rawData\" : [\n+                [\n+                    72763.64376438508\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.StringEncodingBenchmark.encodeUtf8Strings\",\n+        \"mode\" : \"thrpt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"5 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"10 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"primaryMetric\" : {\n+            \"score\" : 890130.4474937392,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 887438.9861902855,\n+                \"50.0\" : 890130.4474937392,\n+                \"90.0\" : 892821.9087971927,\n+                \"95.0\" : 892821.9087971927,\n+                \"99.0\" : 892821.9087971927,\n+                \"99.9\" : 892821.9087971927,\n+                \"99.99\" : 892821.9087971927,\n+                \"99.999\" : 892821.9087971927,\n+                \"99.9999\" : 892821.9087971927,\n+                \"100.0\" : 892821.9087971927\n+            },\n+            \"scoreUnit\" : \"ops\/s\",\n+            \"rawData\" : [\n+                [\n+                    892821.9087971927,\n+                    887438.9861902855\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.ConstantPoolBenchmark.buildConstantPoolMixed\",\n+        \"mode\" : \"avgt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"3 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"5 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"params\" : {\n+            \"poolSize\" : \"100\"\n+        },\n+        \"primaryMetric\" : {\n+            \"score\" : 0.1118520596714827,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 0.11041214804438464,\n+                \"50.0\" : 0.1118520596714827,\n+                \"90.0\" : 0.11329197129858078,\n+                \"95.0\" : 0.11329197129858078,\n+                \"99.0\" : 0.11329197129858078,\n+                \"99.9\" : 0.11329197129858078,\n+                \"99.99\" : 0.11329197129858078,\n+                \"99.999\" : 0.11329197129858078,\n+                \"99.9999\" : 0.11329197129858078,\n+                \"100.0\" : 0.11329197129858078\n+            },\n+            \"scoreUnit\" : \"ms\/op\",\n+            \"rawData\" : [\n+                [\n+                    0.11041214804438464,\n+                    0.11329197129858078\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.ConstantPoolBenchmark.buildConstantPoolMixed\",\n+        \"mode\" : \"avgt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"3 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"5 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"params\" : {\n+            \"poolSize\" : \"500\"\n+        },\n+        \"primaryMetric\" : {\n+            \"score\" : 0.5625647438601789,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 0.559422147982564,\n+                \"50.0\" : 0.5625647438601789,\n+                \"90.0\" : 0.5657073397377939,\n+                \"95.0\" : 0.5657073397377939,\n+                \"99.0\" : 0.5657073397377939,\n+                \"99.9\" : 0.5657073397377939,\n+                \"99.99\" : 0.5657073397377939,\n+                \"99.999\" : 0.5657073397377939,\n+                \"99.9999\" : 0.5657073397377939,\n+                \"100.0\" : 0.5657073397377939\n+            },\n+            \"scoreUnit\" : \"ms\/op\",\n+            \"rawData\" : [\n+                [\n+                    0.5657073397377939,\n+                    0.559422147982564\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.ConstantPoolBenchmark.buildConstantPoolMixed\",\n+        \"mode\" : \"avgt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"3 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"5 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"params\" : {\n+            \"poolSize\" : \"1000\"\n+        },\n+        \"primaryMetric\" : {\n+            \"score\" : 1.1046746108336705,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 1.093938292522956,\n+                \"50.0\" : 1.1046746108336705,\n+                \"90.0\" : 1.115410929144385,\n+                \"95.0\" : 1.115410929144385,\n+                \"99.0\" : 1.115410929144385,\n+                \"99.9\" : 1.115410929144385,\n+                \"99.99\" : 1.115410929144385,\n+                \"99.999\" : 1.115410929144385,\n+                \"99.9999\" : 1.115410929144385,\n+                \"100.0\" : 1.115410929144385\n+            },\n+            \"scoreUnit\" : \"ms\/op\",\n+            \"rawData\" : [\n+                [\n+                    1.115410929144385,\n+                    1.093938292522956\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.ConstantPoolBenchmark.buildConstantPoolWithRepeatedStrings\",\n+        \"mode\" : \"avgt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"3 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"5 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"params\" : {\n+            \"poolSize\" : \"100\"\n+        },\n+        \"primaryMetric\" : {\n+            \"score\" : 0.10848030115347368,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 0.10809573802993326,\n+                \"50.0\" : 0.10848030115347368,\n+                \"90.0\" : 0.1088648642770141,\n+                \"95.0\" : 0.1088648642770141,\n+                \"99.0\" : 0.1088648642770141,\n+                \"99.9\" : 0.1088648642770141,\n+                \"99.99\" : 0.1088648642770141,\n+                \"99.999\" : 0.1088648642770141,\n+                \"99.9999\" : 0.1088648642770141,\n+                \"100.0\" : 0.1088648642770141\n+            },\n+            \"scoreUnit\" : \"ms\/op\",\n+            \"rawData\" : [\n+                [\n+                    0.10809573802993326,\n+                    0.1088648642770141\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.ConstantPoolBenchmark.buildConstantPoolWithRepeatedStrings\",\n+        \"mode\" : \"avgt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"3 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"5 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"params\" : {\n+            \"poolSize\" : \"500\"\n+        },\n+        \"primaryMetric\" : {\n+            \"score\" : 0.5270260178151316,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 0.5244431318105616,\n+                \"50.0\" : 0.5270260178151316,\n+                \"90.0\" : 0.5296089038197016,\n+                \"95.0\" : 0.5296089038197016,\n+                \"99.0\" : 0.5296089038197016,\n+                \"99.9\" : 0.5296089038197016,\n+                \"99.99\" : 0.5296089038197016,\n+                \"99.999\" : 0.5296089038197016,\n+                \"99.9999\" : 0.5296089038197016,\n+                \"100.0\" : 0.5296089038197016\n+            },\n+            \"scoreUnit\" : \"ms\/op\",\n+            \"rawData\" : [\n+                [\n+                    0.5296089038197016,\n+                    0.5244431318105616\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.ConstantPoolBenchmark.buildConstantPoolWithRepeatedStrings\",\n+        \"mode\" : \"avgt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"3 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"5 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"params\" : {\n+            \"poolSize\" : \"1000\"\n+        },\n+        \"primaryMetric\" : {\n+            \"score\" : 1.0598695509536045,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 1.0426289054363673,\n+                \"50.0\" : 1.0598695509536045,\n+                \"90.0\" : 1.0771101964708414,\n+                \"95.0\" : 1.0771101964708414,\n+                \"99.0\" : 1.0771101964708414,\n+                \"99.9\" : 1.0771101964708414,\n+                \"99.99\" : 1.0771101964708414,\n+                \"99.999\" : 1.0771101964708414,\n+                \"99.9999\" : 1.0771101964708414,\n+                \"100.0\" : 1.0771101964708414\n+            },\n+            \"scoreUnit\" : \"ms\/op\",\n+            \"rawData\" : [\n+                [\n+                    1.0771101964708414,\n+                    1.0426289054363673\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.ConstantPoolBenchmark.buildConstantPoolWithUniqueStrings\",\n+        \"mode\" : \"avgt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"3 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"5 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"params\" : {\n+            \"poolSize\" : \"100\"\n+        },\n+        \"primaryMetric\" : {\n+            \"score\" : 0.10810993516568879,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 0.10728512533224728,\n+                \"50.0\" : 0.10810993516568879,\n+                \"90.0\" : 0.10893474499913028,\n+                \"95.0\" : 0.10893474499913028,\n+                \"99.0\" : 0.10893474499913028,\n+                \"99.9\" : 0.10893474499913028,\n+                \"99.99\" : 0.10893474499913028,\n+                \"99.999\" : 0.10893474499913028,\n+                \"99.9999\" : 0.10893474499913028,\n+                \"100.0\" : 0.10893474499913028\n+            },\n+            \"scoreUnit\" : \"ms\/op\",\n+            \"rawData\" : [\n+                [\n+                    0.10728512533224728,\n+                    0.10893474499913028\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.ConstantPoolBenchmark.buildConstantPoolWithUniqueStrings\",\n+        \"mode\" : \"avgt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"3 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"5 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"params\" : {\n+            \"poolSize\" : \"500\"\n+        },\n+        \"primaryMetric\" : {\n+            \"score\" : 0.5419391121231041,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 0.5392549859853385,\n+                \"50.0\" : 0.5419391121231041,\n+                \"90.0\" : 0.5446232382608696,\n+                \"95.0\" : 0.5446232382608696,\n+                \"99.0\" : 0.5446232382608696,\n+                \"99.9\" : 0.5446232382608696,\n+                \"99.99\" : 0.5446232382608696,\n+                \"99.999\" : 0.5446232382608696,\n+                \"99.9999\" : 0.5446232382608696,\n+                \"100.0\" : 0.5446232382608696\n+            },\n+            \"scoreUnit\" : \"ms\/op\",\n+            \"rawData\" : [\n+                [\n+                    0.5392549859853385,\n+                    0.5446232382608696\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    },\n+    {\n+        \"jmhVersion\" : \"1.37\",\n+        \"benchmark\" : \"org.openjdk.jmc.flightrecorder.writer.benchmarks.ConstantPoolBenchmark.buildConstantPoolWithUniqueStrings\",\n+        \"mode\" : \"avgt\",\n+        \"threads\" : 1,\n+        \"forks\" : 1,\n+        \"jvm\" : \"\/Users\/jaroslav.bachorik\/.sdkman\/candidates\/java\/21.0.5-tem\/bin\/java\",\n+        \"jvmArgs\" : [\n+            \"-Xms2G\",\n+            \"-Xmx2G\"\n+        ],\n+        \"jdkVersion\" : \"21.0.5\",\n+        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n+        \"vmVersion\" : \"21.0.5+11-LTS\",\n+        \"warmupIterations\" : 1,\n+        \"warmupTime\" : \"3 s\",\n+        \"warmupBatchSize\" : 1,\n+        \"measurementIterations\" : 2,\n+        \"measurementTime\" : \"5 s\",\n+        \"measurementBatchSize\" : 1,\n+        \"params\" : {\n+            \"poolSize\" : \"1000\"\n+        },\n+        \"primaryMetric\" : {\n+            \"score\" : 1.0210908570363653,\n+            \"scoreError\" : \"NaN\",\n+            \"scoreConfidence\" : [\n+                \"NaN\",\n+                \"NaN\"\n+            ],\n+            \"scorePercentiles\" : {\n+                \"0.0\" : 1.0209848693610941,\n+                \"50.0\" : 1.0210908570363653,\n+                \"90.0\" : 1.0211968447116364,\n+                \"95.0\" : 1.0211968447116364,\n+                \"99.0\" : 1.0211968447116364,\n+                \"99.9\" : 1.0211968447116364,\n+                \"99.99\" : 1.0211968447116364,\n+                \"99.999\" : 1.0211968447116364,\n+                \"99.9999\" : 1.0211968447116364,\n+                \"100.0\" : 1.0211968447116364\n+            },\n+            \"scoreUnit\" : \"ms\/op\",\n+            \"rawData\" : [\n+                [\n+                    1.0211968447116364,\n+                    1.0209848693610941\n+                ]\n+            ]\n+        },\n+        \"secondaryMetrics\" : {\n+        }\n+    }\n+]\n+\n+\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.benchmarks\/baseline-quick.json","additions":979,"deletions":0,"binary":false,"changes":979,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+#!\/usr\/bin\/env python3\n+\"\"\"\n+JMH Benchmark Comparison Tool\n+\n+Compares two JMH JSON result files and displays performance differences.\n+\n+Usage:\n+    python3 compare.py <baseline.json> <optimized.json> [title]\n+\n+Example:\n+    python3 compare.py baseline-quick.json phase1-simple.json \"Phase 1 Results\"\n+\"\"\"\n+import json\n+import sys\n+\n+if len(sys.argv) < 3:\n+    print(__doc__)\n+    sys.exit(1)\n+\n+baseline_file = sys.argv[1]\n+optimized_file = sys.argv[2]\n+title = sys.argv[3] if len(sys.argv) > 3 else \"Performance Comparison\"\n+\n+with open(baseline_file) as f:\n+    baseline = json.load(f)\n+with open(optimized_file) as f:\n+    optimized = json.load(f)\n+\n+# Create maps for easier lookup\n+baseline_map = {b['benchmark']: b for b in baseline}\n+optimized_map = {p['benchmark']: p for p in optimized}\n+\n+print(\"=\" * 80)\n+print(f\"{title}\")\n+print(\"=\" * 80)\n+print()\n+\n+for bench_name in sorted(optimized_map.keys()):\n+    if bench_name not in baseline_map:\n+        continue\n+\n+    b = baseline_map[bench_name]\n+    p = optimized_map[bench_name]\n+    \n+    # Extract score\n+    b_score = b['primaryMetric']['score']\n+    p_score = p['primaryMetric']['score']\n+    \n+    # Calculate improvement\n+    if b['mode'] in ['thrpt', 'sample']:  # Higher is better\n+        improvement = ((p_score - b_score) \/ b_score) * 100\n+        direction = \"↑\" if improvement > 0 else \"↓\"\n+    else:  # avgt, ss - lower is better\n+        improvement = ((b_score - p_score) \/ b_score) * 100\n+        direction = \"↓\" if improvement > 0 else \"↑\"\n+    \n+    # Format scores\n+    unit = b['primaryMetric']['scoreUnit']\n+    \n+    bench_short = bench_name.split('.')[-1]\n+    params = b.get('params', {})\n+    param_str = f\"({params})\" if params else \"\"\n+    \n+    print(f\"{bench_short:50s} {param_str:15s}\")\n+    print(f\"  Baseline:  {b_score:15.3f} {unit}\")\n+    print(f\"  Optimized: {p_score:15.3f} {unit}\")\n+    print(f\"  Change:    {direction} {abs(improvement):6.2f}%\")\n+    print()\n+\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.benchmarks\/compare.py","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+   Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+   Copyright (c) 2021, 2025, Datadog, Inc. All rights reserved.\n+\n+   DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+   The contents of this file are subject to the terms of either the Universal Permissive License\n+   v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\n+\n+   or the following license:\n+\n+   Redistribution and use in source and binary forms, with or without modification, are permitted\n+   provided that the following conditions are met:\n+\n+   1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+   and the disclaimer.\n+\n+   2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+   conditions and the following disclaimer in the documentation and\/or other materials provided with\n+   the distribution.\n+\n+   3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+   endorse or promote products derived from this software without specific prior written permission.\n+\n+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+   FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+   WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+-->\n+<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+\t<modelVersion>4.0.0<\/modelVersion>\n+\t<parent>\n+\t\t<groupId>org.openjdk.jmc<\/groupId>\n+\t\t<artifactId>missioncontrol.core.tests<\/artifactId>\n+\t\t<version>${revision}${changelist}<\/version>\n+\t<\/parent>\n+\t<artifactId>flightrecorder.writer.benchmarks<\/artifactId>\n+\t<properties>\n+\t\t<jmc.config.path>${project.basedir}\/..\/..\/..\/configuration<\/jmc.config.path>\n+\t\t<jmh.version>1.37<\/jmh.version>\n+\t\t<uberjar.name>benchmarks<\/uberjar.name>\n+\t<\/properties>\n+\t<dependencies>\n+\t\t<dependency>\n+\t\t\t<groupId>org.openjdk.jmc<\/groupId>\n+\t\t\t<artifactId>flightrecorder.writer<\/artifactId>\n+\t\t\t<version>${project.version}<\/version>\n+\t\t<\/dependency>\n+\t\t<dependency>\n+\t\t\t<groupId>org.openjdk.jmc<\/groupId>\n+\t\t\t<artifactId>flightrecorder<\/artifactId>\n+\t\t\t<version>${project.version}<\/version>\n+\t\t<\/dependency>\n+\t\t<dependency>\n+\t\t\t<groupId>org.openjdk.jmh<\/groupId>\n+\t\t\t<artifactId>jmh-core<\/artifactId>\n+\t\t\t<version>${jmh.version}<\/version>\n+\t\t<\/dependency>\n+\t\t<dependency>\n+\t\t\t<groupId>org.openjdk.jmh<\/groupId>\n+\t\t\t<artifactId>jmh-generator-annprocess<\/artifactId>\n+\t\t\t<version>${jmh.version}<\/version>\n+\t\t\t<scope>provided<\/scope>\n+\t\t<\/dependency>\n+\t<\/dependencies>\n+\t<build>\n+\t\t<sourceDirectory>${project.basedir}\/src\/main\/java<\/sourceDirectory>\n+\t\t<plugins>\n+\t\t\t<plugin>\n+\t\t\t\t<groupId>org.apache.maven.plugins<\/groupId>\n+\t\t\t\t<artifactId>maven-jar-plugin<\/artifactId>\n+\t\t\t\t<configuration>\n+\t\t\t\t\t<archive>\n+\t\t\t\t\t\t<manifestFile>${project.build.outputDirectory}\/META-INF\/MANIFEST.MF<\/manifestFile>\n+\t\t\t\t\t\t<manifest>\n+\t\t\t\t\t\t\t<addDefaultImplementationEntries>true<\/addDefaultImplementationEntries>\n+\t\t\t\t\t\t<\/manifest>\n+\t\t\t\t\t<\/archive>\n+\t\t\t\t<\/configuration>\n+\t\t\t\t<executions>\n+\t\t\t\t\t<execution>\n+\t\t\t\t\t\t<id>default-jar<\/id>\n+\t\t\t\t\t\t<phase>package<\/phase>\n+\t\t\t\t\t\t<goals>\n+\t\t\t\t\t\t\t<goal>jar<\/goal>\n+\t\t\t\t\t\t<\/goals>\n+\t\t\t\t\t<\/execution>\n+\t\t\t\t<\/executions>\n+\t\t\t<\/plugin>\n+\t\t\t<plugin>\n+\t\t\t\t<groupId>org.apache.maven.plugins<\/groupId>\n+\t\t\t\t<artifactId>maven-shade-plugin<\/artifactId>\n+\t\t\t\t<version>3.5.1<\/version>\n+\t\t\t\t<executions>\n+\t\t\t\t\t<execution>\n+\t\t\t\t\t\t<phase>package<\/phase>\n+\t\t\t\t\t\t<goals>\n+\t\t\t\t\t\t\t<goal>shade<\/goal>\n+\t\t\t\t\t\t<\/goals>\n+\t\t\t\t\t\t<configuration>\n+\t\t\t\t\t\t\t<finalName>${uberjar.name}<\/finalName>\n+\t\t\t\t\t\t\t<createDependencyReducedPom>false<\/createDependencyReducedPom>\n+\t\t\t\t\t\t\t<transformers>\n+\t\t\t\t\t\t\t\t<transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n+\t\t\t\t\t\t\t\t\t<mainClass>org.openjdk.jmh.Main<\/mainClass>\n+\t\t\t\t\t\t\t\t<\/transformer>\n+\t\t\t\t\t\t\t\t<transformer implementation=\"org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\"\/>\n+\t\t\t\t\t\t\t<\/transformers>\n+\t\t\t\t\t\t\t<filters>\n+\t\t\t\t\t\t\t\t<filter>\n+\t\t\t\t\t\t\t\t\t<artifact>*:*<\/artifact>\n+\t\t\t\t\t\t\t\t\t<excludes>\n+\t\t\t\t\t\t\t\t\t\t<exclude>META-INF\/*.SF<\/exclude>\n+\t\t\t\t\t\t\t\t\t\t<exclude>META-INF\/*.DSA<\/exclude>\n+\t\t\t\t\t\t\t\t\t\t<exclude>META-INF\/*.RSA<\/exclude>\n+\t\t\t\t\t\t\t\t\t<\/excludes>\n+\t\t\t\t\t\t\t\t<\/filter>\n+\t\t\t\t\t\t\t<\/filters>\n+\t\t\t\t\t\t<\/configuration>\n+\t\t\t\t\t<\/execution>\n+\t\t\t\t<\/executions>\n+\t\t\t<\/plugin>\n+\t\t<\/plugins>\n+\t<\/build>\n+<\/project>\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.benchmarks\/pom.xml","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer.benchmarks;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmc.flightrecorder.writer.api.Recording;\n+import org.openjdk.jmc.flightrecorder.writer.api.Recordings;\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+import org.openjdk.jmc.flightrecorder.writer.api.Types;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+\/**\n+ * Benchmark for measuring allocation rate during event writing.\n+ * <p>\n+ * Uses JMH's gc.alloc.rate profiler to measure MB\/sec of allocations. This is critical for\n+ * identifying allocation hotspots and validating optimization efforts.\n+ * <p>\n+ * Run with: {@code java -jar target\/benchmarks.jar AllocationRate -prof gc}\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\"-Xms2G\", \"-Xmx2G\"})\n+@Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 10, timeUnit = TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class AllocationRateBenchmark {\n+\n+\tprivate Recording recording;\n+\tprivate Type eventType;\n+\tprivate Path tempFile;\n+\n+\t@Setup(Level.Trial)\n+\tpublic void setup() throws Exception {\n+\t\ttempFile = Files.createTempFile(\"jfr-bench-alloc-\", \".jfr\");\n+\t\trecording = Recordings.newRecording(tempFile);\n+\n+\t\teventType = recording.registerEventType(\"bench.AllocTest\", builder -> {\n+\t\t\tbuilder.addField(\"field1\", Types.Builtin.LONG).addField(\"field2\", Types.Builtin.STRING)\n+\t\t\t\t\t.addField(\"field3\", Types.Builtin.INT).addField(\"field4\", Types.Builtin.DOUBLE);\n+\t\t});\n+\t}\n+\n+\t@TearDown(Level.Trial)\n+\tpublic void teardown() throws Exception {\n+\t\tif (recording != null) {\n+\t\t\trecording.close();\n+\t\t}\n+\t\tif (tempFile != null) {\n+\t\t\tFiles.deleteIfExists(tempFile);\n+\t\t}\n+\t}\n+\n+\t@Benchmark\n+\tpublic void measureEventWriteAllocations() throws Exception {\n+\t\t\/\/ This benchmark measures allocations per operation\n+\t\t\/\/ Run with -prof gc to see allocation rate\n+\t\trecording.writeEvent(eventType.asValue(builder -> {\n+\t\t\tbuilder.putField(\"field1\", 12345L).putField(\"field2\", \"test-string\").putField(\"field3\", 999)\n+\t\t\t\t\t.putField(\"field4\", 3.14159);\n+\t\t}));\n+\t}\n+\n+\t@Benchmark\n+\tpublic void measureBatchEventWriteAllocations() throws Exception {\n+\t\t\/\/ Batch write to amplify allocation patterns\n+\t\tfor (int i = 0; i < 100; i++) {\n+\t\t\tfinal int index = i;\n+\t\t\trecording.writeEvent(eventType.asValue(builder -> {\n+\t\t\t\tbuilder.putField(\"field1\", (long) index).putField(\"field2\", \"batch-string-\" + (index % 10))\n+\t\t\t\t\t\t.putField(\"field3\", index * 2).putField(\"field4\", index * 1.5);\n+\t\t\t}));\n+\t\t}\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.benchmarks\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/benchmarks\/AllocationRateBenchmark.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer.benchmarks;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmc.flightrecorder.writer.api.Recording;\n+import org.openjdk.jmc.flightrecorder.writer.api.Recordings;\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+import org.openjdk.jmc.flightrecorder.writer.api.Types;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+\/**\n+ * Benchmark for constant pool buildup performance.\n+ * <p>\n+ * Measures the performance of constant pool operations, including HashMap growth, value\n+ * deduplication, and lookup performance. This validates optimizations around HashMap initial\n+ * capacity and hash computation.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\"-Xms2G\", \"-Xmx2G\"})\n+@Warmup(iterations = 3, time = 3, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)\n+@State(Scope.Benchmark)\n+public class ConstantPoolBenchmark {\n+\n+\t@Param({\"100\", \"500\", \"1000\"})\n+\tprivate int poolSize;\n+\n+\tprivate Recording recording;\n+\tprivate Type eventType;\n+\tprivate Path tempFile;\n+\n+\t@Setup(Level.Trial)\n+\tpublic void setup() throws Exception {\n+\t\ttempFile = Files.createTempFile(\"jfr-bench-pool-\", \".jfr\");\n+\t\trecording = Recordings.newRecording(tempFile);\n+\n+\t\teventType = recording.registerEventType(\"bench.PoolTest\", builder -> {\n+\t\t\tbuilder.addField(\"str1\", Types.Builtin.STRING).addField(\"str2\", Types.Builtin.STRING).addField(\"value\",\n+\t\t\t\t\tTypes.Builtin.LONG);\n+\t\t});\n+\t}\n+\n+\t@TearDown(Level.Trial)\n+\tpublic void teardown() throws Exception {\n+\t\tif (recording != null) {\n+\t\t\trecording.close();\n+\t\t}\n+\t\tif (tempFile != null) {\n+\t\t\tFiles.deleteIfExists(tempFile);\n+\t\t}\n+\t}\n+\n+\t@Benchmark\n+\tpublic void buildConstantPoolWithUniqueStrings() throws Exception {\n+\t\t\/\/ Populate constant pool with unique strings\n+\t\t\/\/ This tests HashMap growth and rehashing behavior\n+\t\tfor (int i = 0; i < poolSize; i++) {\n+\t\t\tfinal int index = i;\n+\t\t\trecording.writeEvent(eventType.asValue(builder -> {\n+\t\t\t\tbuilder.putField(\"str1\", \"unique-string-\" + index).putField(\"str2\", \"another-unique-\" + index)\n+\t\t\t\t\t\t.putField(\"value\", (long) index);\n+\t\t\t}));\n+\t\t}\n+\t}\n+\n+\t@Benchmark\n+\tpublic void buildConstantPoolWithRepeatedStrings() throws Exception {\n+\t\t\/\/ Populate with repeated strings to test deduplication\n+\t\t\/\/ This tests constant pool lookup performance\n+\t\tfor (int i = 0; i < poolSize; i++) {\n+\t\t\tfinal int index = i;\n+\t\t\trecording.writeEvent(eventType.asValue(builder -> {\n+\t\t\t\tbuilder.putField(\"str1\", \"common-string-\" + (index % 10))\n+\t\t\t\t\t\t.putField(\"str2\", \"another-common-\" + (index % 20)).putField(\"value\", (long) index);\n+\t\t\t}));\n+\t\t}\n+\t}\n+\n+\t@Benchmark\n+\tpublic void buildConstantPoolMixed() throws Exception {\n+\t\t\/\/ Mix of unique and repeated strings\n+\t\tfor (int i = 0; i < poolSize; i++) {\n+\t\t\tfinal int index = i;\n+\t\t\tfinal boolean useCommon = index % 3 == 0;\n+\t\t\trecording.writeEvent(eventType.asValue(builder -> {\n+\t\t\t\tif (useCommon) {\n+\t\t\t\t\tbuilder.putField(\"str1\", \"common-\" + (index % 50)).putField(\"str2\", \"shared-\" + (index % 30))\n+\t\t\t\t\t\t\t.putField(\"value\", (long) index);\n+\t\t\t\t} else {\n+\t\t\t\t\tbuilder.putField(\"str1\", \"unique-\" + index).putField(\"str2\", \"solo-\" + index).putField(\"value\",\n+\t\t\t\t\t\t\t(long) index);\n+\t\t\t\t}\n+\t\t\t}));\n+\t\t}\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.benchmarks\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/benchmarks\/ConstantPoolBenchmark.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer.benchmarks;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmc.flightrecorder.writer.api.Recording;\n+import org.openjdk.jmc.flightrecorder.writer.api.Recordings;\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+import org.openjdk.jmc.flightrecorder.writer.api.Types;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+\/**\n+ * Benchmark for event write throughput.\n+ * <p>\n+ * Measures events per second for different event types to establish baseline performance and\n+ * identify improvements from allocation reduction optimizations.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\"-Xms2G\", \"-Xmx2G\"})\n+@Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 10, timeUnit = TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class EventWriteThroughputBenchmark {\n+\n+\tprivate Recording recording;\n+\tprivate Type simpleEvent;\n+\tprivate Type multiFieldEvent;\n+\tprivate Type stringHeavyEvent;\n+\tprivate Path tempFile;\n+\n+\t@Setup(Level.Trial)\n+\tpublic void setup() throws Exception {\n+\t\ttempFile = Files.createTempFile(\"jfr-bench-throughput-\", \".jfr\");\n+\t\trecording = Recordings.newRecording(tempFile);\n+\n+\t\t\/\/ Simple event with minimal fields\n+\t\tsimpleEvent = recording.registerEventType(\"bench.SimpleEvent\", builder -> {\n+\t\t\tbuilder.addField(\"value\", Types.Builtin.LONG);\n+\t\t});\n+\n+\t\t\/\/ Multi-field event with various types\n+\t\tmultiFieldEvent = recording.registerEventType(\"bench.MultiFieldEvent\", builder -> {\n+\t\t\tbuilder.addField(\"field1\", Types.Builtin.LONG).addField(\"field2\", Types.Builtin.STRING)\n+\t\t\t\t\t.addField(\"field3\", Types.Builtin.INT).addField(\"field4\", Types.Builtin.DOUBLE)\n+\t\t\t\t\t.addField(\"field5\", Types.Builtin.BOOLEAN);\n+\t\t});\n+\n+\t\t\/\/ String-heavy event\n+\t\tstringHeavyEvent = recording.registerEventType(\"bench.StringHeavyEvent\", builder -> {\n+\t\t\tbuilder.addField(\"str1\", Types.Builtin.STRING).addField(\"str2\", Types.Builtin.STRING)\n+\t\t\t\t\t.addField(\"str3\", Types.Builtin.STRING).addField(\"str4\", Types.Builtin.STRING);\n+\t\t});\n+\t}\n+\n+\t@TearDown(Level.Trial)\n+\tpublic void teardown() throws Exception {\n+\t\tif (recording != null) {\n+\t\t\trecording.close();\n+\t\t}\n+\t\tif (tempFile != null) {\n+\t\t\tFiles.deleteIfExists(tempFile);\n+\t\t}\n+\t}\n+\n+\t@Benchmark\n+\tpublic void writeSimpleEvent() throws Exception {\n+\t\trecording.writeEvent(simpleEvent.asValue(builder -> {\n+\t\t\tbuilder.putField(\"value\", 12345L);\n+\t\t}));\n+\t}\n+\n+\t@Benchmark\n+\tpublic void writeMultiFieldEvent() throws Exception {\n+\t\trecording.writeEvent(multiFieldEvent.asValue(builder -> {\n+\t\t\tbuilder.putField(\"field1\", 12345L).putField(\"field2\", \"test-value\").putField(\"field3\", 999)\n+\t\t\t\t\t.putField(\"field4\", 3.14159).putField(\"field5\", true);\n+\t\t}));\n+\t}\n+\n+\t@Benchmark\n+\tpublic void writeStringHeavyEvent() throws Exception {\n+\t\trecording.writeEvent(stringHeavyEvent.asValue(builder -> {\n+\t\t\tbuilder.putField(\"str1\", \"String value one\").putField(\"str2\", \"String value two\")\n+\t\t\t\t\t.putField(\"str3\", \"String value three\").putField(\"str4\", \"String value four\");\n+\t\t}));\n+\t}\n+\n+\t@Benchmark\n+\tpublic void writeRepeatedStringsEvent() throws Exception {\n+\t\t\/\/ Use same strings repeatedly to benefit from string caching\n+\t\trecording.writeEvent(stringHeavyEvent.asValue(builder -> {\n+\t\t\tbuilder.putField(\"str1\", \"common-string-1\").putField(\"str2\", \"common-string-2\")\n+\t\t\t\t\t.putField(\"str3\", \"common-string-1\").putField(\"str4\", \"common-string-2\");\n+\t\t}));\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.benchmarks\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/benchmarks\/EventWriteThroughputBenchmark.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer.benchmarks;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmc.flightrecorder.writer.api.Recording;\n+import org.openjdk.jmc.flightrecorder.writer.api.Recordings;\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+import org.openjdk.jmc.flightrecorder.writer.api.Types;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+\/**\n+ * Benchmark for UTF-8 string encoding performance.\n+ * <p>\n+ * Measures the impact of repeated string encoding, which is a hotspot identified in the analysis.\n+ * This benchmark validates the effectiveness of UTF-8 caching optimizations.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\"-Xms2G\", \"-Xmx2G\"})\n+@Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 10, timeUnit = TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class StringEncodingBenchmark {\n+\n+\tprivate Recording recording;\n+\tprivate Type eventType;\n+\tprivate Path tempFile;\n+\n+\t\/\/ Common strings that would benefit from caching\n+\tprivate static final String COMMON_STRING_1 = \"common.event.type\";\n+\tprivate static final String COMMON_STRING_2 = \"java.lang.Thread\";\n+\tprivate static final String COMMON_STRING_3 = \"org.example.MyClass\";\n+\tprivate static final String COMMON_STRING_4 = \"\/usr\/local\/bin\/java\";\n+\n+\t\/\/ Unique strings to test uncached path\n+\tprivate int counter = 0;\n+\n+\t@Setup(Level.Trial)\n+\tpublic void setup() throws Exception {\n+\t\ttempFile = Files.createTempFile(\"jfr-bench-string-\", \".jfr\");\n+\t\trecording = Recordings.newRecording(tempFile);\n+\n+\t\teventType = recording.registerEventType(\"bench.StringEvent\", builder -> {\n+\t\t\tbuilder.addField(\"str1\", Types.Builtin.STRING).addField(\"str2\", Types.Builtin.STRING)\n+\t\t\t\t\t.addField(\"str3\", Types.Builtin.STRING).addField(\"str4\", Types.Builtin.STRING);\n+\t\t});\n+\t}\n+\n+\t@TearDown(Level.Trial)\n+\tpublic void teardown() throws Exception {\n+\t\tif (recording != null) {\n+\t\t\trecording.close();\n+\t\t}\n+\t\tif (tempFile != null) {\n+\t\t\tFiles.deleteIfExists(tempFile);\n+\t\t}\n+\t}\n+\n+\t@Benchmark\n+\tpublic void encodeRepeatedStrings() throws Exception {\n+\t\t\/\/ Test caching effectiveness - same strings repeatedly encoded\n+\t\trecording.writeEvent(eventType.asValue(builder -> {\n+\t\t\tbuilder.putField(\"str1\", COMMON_STRING_1).putField(\"str2\", COMMON_STRING_2)\n+\t\t\t\t\t.putField(\"str3\", COMMON_STRING_3).putField(\"str4\", COMMON_STRING_4);\n+\t\t}));\n+\t}\n+\n+\t@Benchmark\n+\tpublic void encodeUniqueStrings() throws Exception {\n+\t\t\/\/ Test uncached path - unique strings each time\n+\t\trecording.writeEvent(eventType.asValue(builder -> {\n+\t\t\tbuilder.putField(\"str1\", \"unique-string-\" + counter++).putField(\"str2\", \"another-unique-\" + counter++)\n+\t\t\t\t\t.putField(\"str3\", \"yet-another-\" + counter++).putField(\"str4\", \"final-unique-\" + counter++);\n+\t\t}));\n+\t}\n+\n+\t@Benchmark\n+\tpublic void encodeMixedStrings() throws Exception {\n+\t\t\/\/ Test mix of cached and uncached\n+\t\trecording.writeEvent(eventType.asValue(builder -> {\n+\t\t\tbuilder.putField(\"str1\", COMMON_STRING_1).putField(\"str2\", \"unique-\" + counter++)\n+\t\t\t\t\t.putField(\"str3\", COMMON_STRING_3).putField(\"str4\", \"another-unique-\" + counter++);\n+\t\t}));\n+\t}\n+\n+\t@Benchmark\n+\tpublic void encodeUtf8Strings() throws Exception {\n+\t\t\/\/ Test UTF-8 encoding with multi-byte characters\n+\t\trecording.writeEvent(eventType.asValue(builder -> {\n+\t\t\tbuilder.putField(\"str1\", \"Hello 世界\").putField(\"str2\", \"Привет мир\").putField(\"str3\", \"مرحبا بالعالم\")\n+\t\t\t\t\t.putField(\"str4\", \"🌍🌎🌏\");\n+\t\t}));\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.benchmarks\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/benchmarks\/StringEncodingBenchmark.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+Manifest-Version: 1.0\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.benchmarks\/src\/main\/resources\/META-INF\/MANIFEST.MF","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,299 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.openjdk.jmc.common.item.Attribute;\n+import org.openjdk.jmc.common.item.IItem;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.item.IMemberAccessor;\n+import org.openjdk.jmc.common.unit.IQuantity;\n+import org.openjdk.jmc.common.unit.UnitLookup;\n+import org.openjdk.jmc.flightrecorder.JfrAttributes;\n+import org.openjdk.jmc.flightrecorder.JfrLoaderToolkit;\n+import org.openjdk.jmc.flightrecorder.writer.api.Recording;\n+import org.openjdk.jmc.flightrecorder.writer.api.Recordings;\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+import org.openjdk.jmc.flightrecorder.writer.api.Types;\n+\n+\/**\n+ * Tests for implicit event fields (stackTrace, eventThread, startTime) handling.\n+ * <p>\n+ * These tests verify that events can be written without explicitly providing values for implicit\n+ * fields, and that the Writer API automatically provides default values for them.\n+ *\/\n+@SuppressWarnings(\"restriction\")\n+class ImplicitEventFieldsTest {\n+\tprivate Recording recording;\n+\tprivate Path jfrPath;\n+\n+\t@BeforeEach\n+\tvoid setup() throws Exception {\n+\t\tjfrPath = Files.createTempFile(\"jfr-writer-test-implicit-\", \".jfr\");\n+\t\trecording = Recordings.newRecording(jfrPath);\n+\t}\n+\n+\t@AfterEach\n+\tvoid teardown() throws Exception {\n+\t\tif (recording != null) {\n+\t\t\trecording.close();\n+\t\t}\n+\t\tif (jfrPath != null) {\n+\t\t\tFiles.deleteIfExists(jfrPath);\n+\t\t}\n+\t}\n+\n+\t\/**\n+\t * Tests that an event can be written without implicit fields explicitly set.\n+\t * <p>\n+\t * This test reproduces the issue where field values appear shifted when implicit fields are not\n+\t * provided. After the fix, this should pass.\n+\t *\/\n+\t@Test\n+\tvoid eventWithoutImplicitFields() throws Exception {\n+\t\tType eventType = recording.registerEventType(\"test.MinimalEvent\", builder -> {\n+\t\t\tbuilder.addField(\"customField\", Types.Builtin.LONG);\n+\t\t});\n+\n+\t\t\/\/ Write event WITHOUT setting implicit fields\n+\t\trecording.writeEvent(eventType.asValue(builder -> {\n+\t\t\tbuilder.putField(\"customField\", 12345L);\n+\t\t})).close();\n+\n+\t\t\/\/ Verify recording parses correctly\n+\t\tIItemCollection events = JfrLoaderToolkit.loadEvents(jfrPath.toFile());\n+\t\tassertTrue(events.hasItems(), \"Recording should contain events\");\n+\n+\t\tevents.forEach(itemType -> {\n+\t\t\titemType.forEach(item -> {\n+\t\t\t\t\/\/ Verify implicit fields have defaults\n+\t\t\t\tIQuantity startTime = JfrAttributes.START_TIME.getAccessor(itemType.getType()).getMember(item);\n+\t\t\t\tassertNotNull(startTime, \"startTime should have a default value\");\n+\n+\t\t\t\t\/\/ Verify custom field has correct value (not shifted to startTime)\n+\t\t\t\tIMemberAccessor<Number, IItem> accessor = Attribute\n+\t\t\t\t\t\t.attr(\"customField\", \"customField\", UnitLookup.RAW_NUMBER).getAccessor(itemType.getType());\n+\t\t\t\tassertNotNull(accessor, \"Accessor for customField should not be null\");\n+\t\t\t\tNumber customFieldValue = accessor.getMember(item);\n+\t\t\t\tassertNotNull(customFieldValue, \"customField should have a value\");\n+\t\t\t\tassertEquals(12345L, customFieldValue.longValue(),\n+\t\t\t\t\t\t\"customField should be 12345, not shifted to startTime\");\n+\t\t\t});\n+\t\t});\n+\t}\n+\n+\t\/**\n+\t * Tests that explicit startTime values are respected and not overridden by the default.\n+\t * <p>\n+\t * Note: JFR stores timestamps as ticks relative to the chunk start, so the parser converts the\n+\t * stored tick value to absolute epoch nanoseconds using the chunk header. We verify that the\n+\t * timestamp is reasonable (positive epoch time) rather than checking for exact equality.\n+\t *\/\n+\t@Test\n+\tvoid eventWithExplicitStartTime() throws Exception {\n+\t\tlong explicitTime = System.nanoTime();\n+\t\tType eventType = recording.registerEventType(\"test.ExplicitTime\");\n+\n+\t\trecording.writeEvent(eventType.asValue(builder -> {\n+\t\t\tbuilder.putField(\"startTime\", explicitTime);\n+\t\t})).close();\n+\n+\t\tIItemCollection events = JfrLoaderToolkit.loadEvents(jfrPath.toFile());\n+\t\tassertTrue(events.hasItems(), \"Recording should contain events\");\n+\n+\t\tevents.forEach(itemType -> {\n+\t\t\titemType.forEach(item -> {\n+\t\t\t\tIQuantity time = JfrAttributes.START_TIME.getAccessor(itemType.getType()).getMember(item);\n+\t\t\t\tassertNotNull(time, \"startTime should not be null\");\n+\t\t\t\t\/\/ Verify that the timestamp is reasonable (epoch time in nanoseconds)\n+\t\t\t\t\/\/ Should be a recent positive timestamp, not negative or zero\n+\t\t\t\tlong epochNanos = time.longValue();\n+\t\t\t\tassertTrue(epochNanos > 0L, \"Timestamp should be positive (epoch nanos)\");\n+\t\t\t});\n+\t\t});\n+\t}\n+\n+\t\/**\n+\t * Tests an event with only implicit fields and no custom fields.\n+\t *\/\n+\t@Test\n+\tvoid eventWithOnlyImplicitFields() throws Exception {\n+\t\tType eventType = recording.registerEventType(\"test.ImplicitOnly\");\n+\n+\t\trecording.writeEvent(eventType.asValue(builder -> {\n+\t\t\t\/\/ Don't set any fields - rely on defaults\n+\t\t})).close();\n+\n+\t\tIItemCollection events = JfrLoaderToolkit.loadEvents(jfrPath.toFile());\n+\t\tassertTrue(events.hasItems(), \"Recording should contain events\");\n+\n+\t\tevents.forEach(itemType -> {\n+\t\t\titemType.forEach(item -> {\n+\t\t\t\tIQuantity startTime = JfrAttributes.START_TIME.getAccessor(itemType.getType()).getMember(item);\n+\t\t\t\tassertNotNull(startTime, \"startTime should have a default value\");\n+\t\t\t});\n+\t\t});\n+\t}\n+\n+\t\/**\n+\t * Tests that multiple custom fields maintain correct alignment when implicit fields are not\n+\t * provided.\n+\t *\/\n+\t@Test\n+\tvoid eventWithMultipleCustomFields() throws Exception {\n+\t\tType eventType = recording.registerEventType(\"test.MultiField\", builder -> {\n+\t\t\tbuilder.addField(\"field1\", Types.Builtin.LONG).addField(\"field2\", Types.Builtin.STRING).addField(\"field3\",\n+\t\t\t\t\tTypes.Builtin.INT);\n+\t\t});\n+\n+\t\trecording.writeEvent(eventType.asValue(builder -> {\n+\t\t\tbuilder.putField(\"field1\", 111L).putField(\"field2\", \"test-string\").putField(\"field3\", 333);\n+\t\t})).close();\n+\n+\t\tIItemCollection events = JfrLoaderToolkit.loadEvents(jfrPath.toFile());\n+\t\tassertTrue(events.hasItems(), \"Recording should contain events\");\n+\n+\t\tevents.forEach(itemType -> {\n+\t\t\titemType.forEach(item -> {\n+\t\t\t\t\/\/ Verify all custom fields have correct values\n+\t\t\t\t\/\/ field1 is LONG → raw number\n+\t\t\t\tIMemberAccessor<Number, IItem> field1Accessor = Attribute\n+\t\t\t\t\t\t.attr(\"field1\", \"field1\", UnitLookup.RAW_NUMBER).getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(111L, field1Accessor.getMember(item).longValue(), \"field1 should be 111\");\n+\n+\t\t\t\tIMemberAccessor<String, IItem> field2Accessor = Attribute\n+\t\t\t\t\t\t.attr(\"field2\", \"field2\", UnitLookup.PLAIN_TEXT).getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(\"test-string\", field2Accessor.getMember(item), \"field2 should be 'test-string'\");\n+\n+\t\t\t\t\/\/ field3 is INT → linear number\n+\t\t\t\tIMemberAccessor<IQuantity, IItem> field3Accessor = Attribute.attr(\"field3\", \"field3\", UnitLookup.NUMBER)\n+\t\t\t\t\t\t.getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(333, field3Accessor.getMember(item).longValue(), \"field3 should be 333\");\n+\t\t\t});\n+\t\t});\n+\t}\n+\n+\t\/**\n+\t * Tests that all builtin types receive proper default values when not explicitly set.\n+\t * <p>\n+\t * This test verifies the fix for builtin type field skipping. When builtin fields are not\n+\t * explicitly set, they should receive type-appropriate defaults (0 for numbers, false for\n+\t * boolean, null for String) instead of being skipped during serialization, which would cause\n+\t * field alignment issues.\n+\t * <p>\n+\t * The test includes a final field with an explicit value to verify that field alignment remains\n+\t * correct after all the default builtin fields.\n+\t *\/\n+\t@Test\n+\tvoid eventWithAllBuiltinFieldsUnset() throws Exception {\n+\t\tType eventType = recording.registerEventType(\"test.AllBuiltins\", builder -> {\n+\t\t\tbuilder.addField(\"byteField\", Types.Builtin.BYTE).addField(\"charField\", Types.Builtin.CHAR)\n+\t\t\t\t\t.addField(\"shortField\", Types.Builtin.SHORT).addField(\"intField\", Types.Builtin.INT)\n+\t\t\t\t\t.addField(\"longField\", Types.Builtin.LONG).addField(\"floatField\", Types.Builtin.FLOAT)\n+\t\t\t\t\t.addField(\"doubleField\", Types.Builtin.DOUBLE).addField(\"booleanField\", Types.Builtin.BOOLEAN)\n+\t\t\t\t\t.addField(\"stringField\", Types.Builtin.STRING).addField(\"finalField\", Types.Builtin.LONG);\n+\t\t});\n+\n+\t\t\/\/ Write event WITHOUT setting builtin field values - all should get defaults\n+\t\t\/\/ Set finalField to verify field alignment is correct\n+\t\trecording.writeEvent(eventType.asValue(builder -> {\n+\t\t\tbuilder.putField(\"finalField\", 99999L);\n+\t\t})).close();\n+\n+\t\t\/\/ Verify recording parses correctly and contains the event\n+\t\tIItemCollection events = JfrLoaderToolkit.loadEvents(jfrPath.toFile());\n+\t\tassertTrue(events.hasItems(), \"Recording should contain events\");\n+\n+\t\tevents.forEach(itemType -> {\n+\t\t\titemType.forEach(item -> {\n+\t\t\t\t\/\/ Verify all builtin fields have appropriate default values\n+\t\t\t\t\/\/ BYTE → linear number\n+\t\t\t\tIMemberAccessor<IQuantity, IItem> byteAccessor = Attribute\n+\t\t\t\t\t\t.attr(\"byteField\", \"byteField\", UnitLookup.NUMBER).getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(0, byteAccessor.getMember(item).longValue(), \"byteField should default to 0\");\n+\n+\t\t\t\t\/\/ SHORT → linear number\n+\t\t\t\tIMemberAccessor<IQuantity, IItem> shortAccessor = Attribute\n+\t\t\t\t\t\t.attr(\"shortField\", \"shortField\", UnitLookup.NUMBER).getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(0, shortAccessor.getMember(item).longValue(), \"shortField should default to 0\");\n+\n+\t\t\t\t\/\/ INT → linear number\n+\t\t\t\tIMemberAccessor<IQuantity, IItem> intAccessor = Attribute\n+\t\t\t\t\t\t.attr(\"intField\", \"intField\", UnitLookup.NUMBER).getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(0, intAccessor.getMember(item).longValue(), \"intField should default to 0\");\n+\n+\t\t\t\t\/\/ LONG → raw number\n+\t\t\t\tIMemberAccessor<Number, IItem> longAccessor = Attribute\n+\t\t\t\t\t\t.attr(\"longField\", \"longField\", UnitLookup.RAW_NUMBER).getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(0L, longAccessor.getMember(item).longValue(), \"longField should default to 0\");\n+\n+\t\t\t\t\/\/ FLOAT → linear number\n+\t\t\t\tIMemberAccessor<IQuantity, IItem> floatAccessor = Attribute\n+\t\t\t\t\t\t.attr(\"floatField\", \"floatField\", UnitLookup.NUMBER).getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(0.0, floatAccessor.getMember(item).doubleValue(), 0.001,\n+\t\t\t\t\t\t\"floatField should default to 0.0\");\n+\n+\t\t\t\t\/\/ DOUBLE → linear number\n+\t\t\t\tIMemberAccessor<IQuantity, IItem> doubleAccessor = Attribute\n+\t\t\t\t\t\t.attr(\"doubleField\", \"doubleField\", UnitLookup.NUMBER).getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(0.0, doubleAccessor.getMember(item).doubleValue(), 0.001,\n+\t\t\t\t\t\t\"doubleField should default to 0.0\");\n+\n+\t\t\t\tIMemberAccessor<Boolean, IItem> booleanAccessor = Attribute\n+\t\t\t\t\t\t.attr(\"booleanField\", \"booleanField\", UnitLookup.FLAG).getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(false, booleanAccessor.getMember(item), \"booleanField should default to false\");\n+\n+\t\t\t\tIMemberAccessor<String, IItem> stringAccessor = Attribute\n+\t\t\t\t\t\t.attr(\"stringField\", \"stringField\", UnitLookup.PLAIN_TEXT).getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(null, stringAccessor.getMember(item), \"stringField should default to null\");\n+\n+\t\t\t\t\/\/ Verify the explicit field value is read correctly (proves field alignment is correct)\n+\t\t\t\t\/\/ LONG → raw number\n+\t\t\t\tIMemberAccessor<Number, IItem> finalAccessor = Attribute\n+\t\t\t\t\t\t.attr(\"finalField\", \"finalField\", UnitLookup.RAW_NUMBER).getAccessor(itemType.getType());\n+\t\t\t\tassertEquals(99999L, finalAccessor.getMember(item).longValue(),\n+\t\t\t\t\t\t\"finalField should be 99999, confirming correct field alignment after all default builtin fields\");\n+\t\t\t});\n+\t\t});\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/ImplicitEventFieldsTest.java","additions":299,"deletions":0,"binary":false,"changes":299,"status":"added"},{"patch":"@@ -0,0 +1,273 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+\n+class LEB128MappedWriterTest {\n+\t@TempDir\n+\tPath tempDir;\n+\n+\tprivate LEB128MappedWriter writer;\n+\tprivate Path testFile;\n+\n+\t@BeforeEach\n+\tvoid setup() throws IOException {\n+\t\ttestFile = tempDir.resolve(\"test-mmap.dat\");\n+\t\twriter = new LEB128MappedWriter(testFile, 4 * 1024 * 1024); \/\/ 4MB\n+\t}\n+\n+\t@AfterEach\n+\tvoid cleanup() throws IOException {\n+\t\tif (writer != null) {\n+\t\t\twriter.close();\n+\t\t}\n+\t\tif (testFile != null && Files.exists(testFile)) {\n+\t\t\tFiles.deleteIfExists(testFile);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tvoid testBasicWrite() {\n+\t\twriter.writeByte((byte) 42);\n+\t\tassertEquals(1, writer.position());\n+\t\tassertEquals(4 * 1024 * 1024, writer.capacity());\n+\t}\n+\n+\t@Test\n+\tvoid testWriteMultipleBytes() {\n+\t\tbyte[] data = {1, 2, 3, 4, 5};\n+\t\twriter.writeBytes(data);\n+\t\tassertEquals(5, writer.position());\n+\t}\n+\n+\t@Test\n+\tvoid testWriteLEB128() {\n+\t\twriter.writeLong(127); \/\/ Fits in 1 byte\n+\t\tint pos1 = writer.position();\n+\t\tassertTrue(pos1 <= 2); \/\/ LEB128 encoded\n+\n+\t\twriter.writeLong(16383); \/\/ Needs 2 bytes\n+\t\tint pos2 = writer.position();\n+\t\tassertTrue(pos2 > pos1);\n+\t}\n+\n+\t@Test\n+\tvoid testWriteFloat() {\n+\t\twriter.writeFloat(3.14f);\n+\t\tassertEquals(4, writer.position());\n+\t}\n+\n+\t@Test\n+\tvoid testWriteDouble() {\n+\t\twriter.writeDouble(3.14159);\n+\t\tassertEquals(8, writer.position());\n+\t}\n+\n+\t@Test\n+\tvoid testWriteString() {\n+\t\twriter.writeUTF(\"Hello\");\n+\t\tassertTrue(writer.position() > 5); \/\/ Length prefix + data\n+\t}\n+\n+\t@Test\n+\tvoid testCanFit() {\n+\t\tassertTrue(writer.canFit(1000));\n+\t\tassertTrue(writer.canFit(4 * 1024 * 1024));\n+\t\tassertFalse(writer.canFit(4 * 1024 * 1024 + 1));\n+\t}\n+\n+\t@Test\n+\tvoid testCanFitAfterWrites() {\n+\t\tbyte[] data = new byte[1024];\n+\t\twriter.writeBytes(data);\n+\n+\t\tassertTrue(writer.canFit(1000));\n+\t\tassertFalse(writer.canFit(4 * 1024 * 1024));\n+\t}\n+\n+\t@Test\n+\tvoid testReset() {\n+\t\twriter.writeByte((byte) 42);\n+\t\tassertEquals(1, writer.position());\n+\n+\t\twriter.reset();\n+\t\tassertEquals(0, writer.position());\n+\t}\n+\n+\t@Test\n+\tvoid testResetAndReuse() {\n+\t\twriter.writeLong(127); \/\/ 1 byte in LEB128\n+\t\tint pos1 = writer.position();\n+\n+\t\twriter.reset();\n+\t\twriter.writeLong(127); \/\/ Same value, same encoded length\n+\t\tint pos2 = writer.position();\n+\n+\t\tassertEquals(pos1, pos2); \/\/ Same position after reset with same value\n+\t}\n+\n+\t@Test\n+\tvoid testCopyTo() throws IOException {\n+\t\tbyte[] testData = {1, 2, 3, 4, 5};\n+\t\twriter.writeBytes(testData);\n+\n+\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\twriter.copyTo(out);\n+\n+\t\tbyte[] result = out.toByteArray();\n+\t\tassertArrayEquals(testData, result);\n+\t}\n+\n+\t@Test\n+\tvoid testCopyToMultipleTimes() throws IOException {\n+\t\tbyte[] testData = {1, 2, 3, 4, 5};\n+\t\twriter.writeBytes(testData);\n+\n+\t\t\/\/ Copy multiple times - should be idempotent\n+\t\tByteArrayOutputStream out1 = new ByteArrayOutputStream();\n+\t\twriter.copyTo(out1);\n+\n+\t\tByteArrayOutputStream out2 = new ByteArrayOutputStream();\n+\t\twriter.copyTo(out2);\n+\n+\t\tassertArrayEquals(out1.toByteArray(), out2.toByteArray());\n+\t}\n+\n+\t@Test\n+\tvoid testForce() {\n+\t\twriter.writeByte((byte) 42);\n+\t\twriter.force(); \/\/ Should not throw\n+\t\tassertEquals(1, writer.position());\n+\t}\n+\n+\t@Test\n+\tvoid testGetDataSize() {\n+\t\tassertEquals(0, writer.getDataSize());\n+\n+\t\twriter.writeByte((byte) 1);\n+\t\tassertEquals(1, writer.getDataSize());\n+\n+\t\twriter.writeBytes(new byte[] {2, 3, 4});\n+\t\tassertEquals(4, writer.getDataSize());\n+\t}\n+\n+\t@Test\n+\tvoid testExportBytes() {\n+\t\tbyte[] testData = {1, 2, 3, 4, 5};\n+\t\twriter.writeBytes(testData);\n+\n+\t\tbyte[] exported = writer.exportBytes();\n+\t\tassertArrayEquals(testData, exported);\n+\t}\n+\n+\t@Test\n+\tvoid testFileExists() {\n+\t\tassertTrue(Files.exists(testFile));\n+\t}\n+\n+\t@Test\n+\tvoid testCloseReleasesResources() throws IOException {\n+\t\twriter.writeByte((byte) 42);\n+\t\twriter.close();\n+\n+\t\t\/\/ File should still exist (caller responsible for deletion)\n+\t\tassertTrue(Files.exists(testFile));\n+\t}\n+\n+\t@Test\n+\tvoid testWriteAtOffset() {\n+\t\twriter.writeByte(5, (byte) 99);\n+\t\tassertEquals(6, writer.position()); \/\/ Position updated\n+\n+\t\tbyte[] data = writer.exportBytes();\n+\t\tassertEquals(6, data.length);\n+\t\tassertEquals(99, data[5]);\n+\t}\n+\n+\t@Test\n+\tvoid testLargeWrite() {\n+\t\t\/\/ Write 1MB of data\n+\t\tbyte[] largeData = new byte[1024 * 1024];\n+\t\tfor (int i = 0; i < largeData.length; i++) {\n+\t\t\tlargeData[i] = (byte) (i % 256);\n+\t\t}\n+\n+\t\twriter.writeBytes(largeData);\n+\t\tassertEquals(1024 * 1024, writer.position());\n+\t\tassertTrue(writer.canFit(1024 * 1024)); \/\/ Still has room\n+\t}\n+\n+\t@Test\n+\tvoid testMultipleWrites() {\n+\t\twriter.writeByte((byte) 1);\n+\t\twriter.writeShort((short) 2);\n+\t\twriter.writeInt(3);\n+\t\twriter.writeLong(4L);\n+\t\twriter.writeFloat(5.0f);\n+\t\twriter.writeDouble(6.0);\n+\n+\t\tassertTrue(writer.position() > 0);\n+\t\tassertTrue(writer.position() < 100); \/\/ Reasonable size\n+\t}\n+\n+\t@Test\n+\tvoid testWriteNullBytes() {\n+\t\tlong offset = writer.writeBytes(0, null);\n+\t\tassertEquals(0, offset);\n+\t\tassertEquals(0, writer.position());\n+\t}\n+\n+\t@Test\n+\tvoid testCapacityUnchanged() {\n+\t\tint initialCapacity = writer.capacity();\n+\n+\t\twriter.writeByte((byte) 1);\n+\t\twriter.writeBytes(new byte[1000]);\n+\n+\t\tassertEquals(initialCapacity, writer.capacity()); \/\/ Capacity is fixed\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/LEB128MappedWriterTest.java","additions":273,"deletions":0,"binary":false,"changes":273,"status":"added"},{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.openjdk.jmc.flightrecorder.writer.api.Recordings;\n+\n+class MmapRecordingIntegrationTest {\n+\t@Label(\"Test Event\")\n+\tpublic static class TestEvent extends Event {\n+\t\t@Label(\"message\")\n+\t\tpublic String message;\n+\t\t@Label(\"value\")\n+\t\tpublic int value;\n+\t}\n+\n+\t@Label(\"Large Event\")\n+\tpublic static class LargeEvent extends Event {\n+\t\t@Label(\"payload\")\n+\t\tpublic String payload;\n+\t}\n+\n+\t@TempDir\n+\tPath tempDir;\n+\n+\t@Test\n+\tvoid testBasicMmapRecording() throws IOException {\n+\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\t\tRecordingImpl recording = (RecordingImpl) Recordings.newRecording(baos,\n+\t\t\t\tsettings -> settings.withMmap(512 * 1024).withJdkTypeInitialization());\n+\n+\t\t\/\/ Write some events\n+\t\tfor (int i = 0; i < 100; i++) {\n+\t\t\tTestEvent event = new TestEvent();\n+\t\t\tevent.message = \"Test \" + i;\n+\t\t\tevent.value = i;\n+\t\t\trecording.writeEvent(event);\n+\t\t}\n+\n+\t\trecording.close();\n+\n+\t\tbyte[] recordingData = baos.toByteArray();\n+\t\tassertTrue(recordingData.length > 0, \"Recording should contain data\");\n+\n+\t\t\/\/ Verify JFR magic bytes\n+\t\tassertEquals('F', recordingData[0]);\n+\t\tassertEquals('L', recordingData[1]);\n+\t\tassertEquals('R', recordingData[2]);\n+\t\tassertEquals(0, recordingData[3]);\n+\t}\n+\n+\t@Test\n+\tvoid testMultiThreadedMmapRecording() throws IOException, InterruptedException {\n+\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\t\tRecordingImpl recording = (RecordingImpl) Recordings.newRecording(baos,\n+\t\t\t\tsettings -> settings.withMmap(512 * 1024).withJdkTypeInitialization());\n+\n+\t\tint numThreads = 4;\n+\t\tint eventsPerThread = 250; \/\/ Total 1000 events\n+\t\tCountDownLatch latch = new CountDownLatch(numThreads);\n+\t\tExecutorService executor = Executors.newFixedThreadPool(numThreads);\n+\n+\t\tfor (int t = 0; t < numThreads; t++) {\n+\t\t\texecutor.submit(() -> {\n+\t\t\t\ttry {\n+\t\t\t\t\tfor (int i = 0; i < eventsPerThread; i++) {\n+\t\t\t\t\t\tTestEvent event = new TestEvent();\n+\t\t\t\t\t\tevent.message = \"Thread \" + Thread.currentThread().getId();\n+\t\t\t\t\t\tevent.value = i;\n+\t\t\t\t\t\trecording.writeEvent(event);\n+\t\t\t\t\t}\n+\t\t\t\t} finally {\n+\t\t\t\t\tlatch.countDown();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tassertTrue(latch.await(10, TimeUnit.SECONDS), \"All threads should complete\");\n+\t\texecutor.shutdown();\n+\t\trecording.close();\n+\n+\t\tbyte[] recordingData = baos.toByteArray();\n+\t\tassertTrue(recordingData.length > 0, \"Recording should contain data\");\n+\t}\n+\n+\t@Test\n+\tvoid testLargeEventsMmapRecording() throws IOException {\n+\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\t\tRecordingImpl recording = (RecordingImpl) Recordings.newRecording(baos,\n+\t\t\t\tsettings -> settings.withMmap(512 * 1024).withJdkTypeInitialization());\n+\n+\t\t\/\/ Create large events to trigger rotation\n+\t\tStringBuilder largePayload = new StringBuilder();\n+\t\tfor (int i = 0; i < 1000; i++) {\n+\t\t\tlargePayload.append(\"Large payload data segment \").append(i).append(\". \");\n+\t\t}\n+\t\tString payload = largePayload.toString();\n+\n+\t\t\/\/ Write enough large events to exceed one chunk (512KB)\n+\t\tfor (int i = 0; i < 20; i++) {\n+\t\t\tLargeEvent event = new LargeEvent();\n+\t\t\tevent.payload = payload + \" Event \" + i;\n+\t\t\trecording.writeEvent(event);\n+\t\t}\n+\n+\t\trecording.close();\n+\n+\t\tbyte[] recordingData = baos.toByteArray();\n+\t\tassertTrue(recordingData.length > 512 * 1024, \"Recording should be larger than one chunk\");\n+\t}\n+\n+\t@Test\n+\tvoid testMmapRecordingToFile() throws IOException {\n+\t\tPath outputFile = tempDir.resolve(\"test-recording.jfr\");\n+\t\tFileOutputStream fos = new FileOutputStream(outputFile.toFile());\n+\t\tRecordingImpl recording = (RecordingImpl) Recordings.newRecording(fos,\n+\t\t\t\tsettings -> settings.withMmap(512 * 1024).withJdkTypeInitialization());\n+\n+\t\tfor (int i = 0; i < 500; i++) {\n+\t\t\tTestEvent event = new TestEvent();\n+\t\t\tevent.message = \"File test\";\n+\t\t\tevent.value = i;\n+\t\t\trecording.writeEvent(event);\n+\t\t}\n+\n+\t\trecording.close();\n+\n+\t\tassertTrue(Files.exists(outputFile), \"Output file should exist\");\n+\t\tassertTrue(Files.size(outputFile) > 0, \"Output file should not be empty\");\n+\n+\t\t\/\/ Verify file is valid JFR\n+\t\tbyte[] header = new byte[4];\n+\t\tFiles.newInputStream(outputFile).read(header);\n+\t\tassertEquals('F', header[0]);\n+\t\tassertEquals('L', header[1]);\n+\t\tassertEquals('R', header[2]);\n+\t\tassertEquals(0, header[3]);\n+\t}\n+\n+\t@Test\n+\tvoid testComparisonMmapVsHeap() throws IOException {\n+\t\tint numEvents = 1000;\n+\n+\t\t\/\/ Test with mmap\n+\t\tByteArrayOutputStream mmapBaos = new ByteArrayOutputStream();\n+\t\tRecordingImpl mmapRecording = (RecordingImpl) Recordings.newRecording(mmapBaos,\n+\t\t\t\tsettings -> settings.withMmap(512 * 1024).withJdkTypeInitialization());\n+\n+\t\tfor (int i = 0; i < numEvents; i++) {\n+\t\t\tTestEvent event = new TestEvent();\n+\t\t\tevent.message = \"Compare test\";\n+\t\t\tevent.value = i;\n+\t\t\tmmapRecording.writeEvent(event);\n+\t\t}\n+\t\tmmapRecording.close();\n+\n+\t\t\/\/ Test with heap (no withMmap call)\n+\t\tByteArrayOutputStream heapBaos = new ByteArrayOutputStream();\n+\t\tRecordingImpl heapRecording = (RecordingImpl) Recordings.newRecording(heapBaos,\n+\t\t\t\tsettings -> settings.withJdkTypeInitialization());\n+\n+\t\tfor (int i = 0; i < numEvents; i++) {\n+\t\t\tTestEvent event = new TestEvent();\n+\t\t\tevent.message = \"Compare test\";\n+\t\t\tevent.value = i;\n+\t\t\theapRecording.writeEvent(event);\n+\t\t}\n+\t\theapRecording.close();\n+\n+\t\t\/\/ Both should produce valid JFR files\n+\t\tassertTrue(mmapBaos.size() > 0);\n+\t\tassertTrue(heapBaos.size() > 0);\n+\n+\t\t\/\/ Sizes should be reasonably similar (within 10%)\n+\t\tdouble mmapSize = mmapBaos.size();\n+\t\tdouble heapSize = heapBaos.size();\n+\t\tdouble ratio = mmapSize \/ heapSize;\n+\t\tassertTrue(ratio > 0.9 && ratio < 1.1,\n+\t\t\t\t\"Mmap and heap recordings should have similar sizes, got ratio: \" + ratio);\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/MmapRecordingIntegrationTest.java","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"},{"patch":"@@ -0,0 +1,322 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+\n+class ThreadMmapManagerTest {\n+\t@TempDir\n+\tPath tempDir;\n+\n+\tprivate ThreadMmapManager manager;\n+\tprivate Path mmapDir;\n+\n+\t@BeforeEach\n+\tvoid setup() throws IOException {\n+\t\tmmapDir = tempDir.resolve(\"mmap-test\");\n+\t\tmanager = new ThreadMmapManager(mmapDir, 1024 * 1024); \/\/ 1MB chunks\n+\t}\n+\n+\t@AfterEach\n+\tvoid cleanup() throws IOException {\n+\t\tif (manager != null) {\n+\t\t\tmanager.cleanup();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tvoid testGetActiveWriter() throws IOException {\n+\t\tlong threadId = Thread.currentThread().getId();\n+\t\tLEB128MappedWriter writer = manager.getActiveWriter(threadId);\n+\n+\t\tassertNotNull(writer);\n+\t\tassertEquals(1024 * 1024, writer.capacity());\n+\t}\n+\n+\t@Test\n+\tvoid testGetActiveWriterTwice() throws IOException {\n+\t\tlong threadId = Thread.currentThread().getId();\n+\t\tLEB128MappedWriter writer1 = manager.getActiveWriter(threadId);\n+\t\tLEB128MappedWriter writer2 = manager.getActiveWriter(threadId);\n+\n+\t\t\/\/ Should return the same writer instance\n+\t\tassertEquals(writer1, writer2);\n+\t}\n+\n+\t@Test\n+\tvoid testMultipleThreads() throws IOException {\n+\t\tlong thread1 = 100L;\n+\t\tlong thread2 = 200L;\n+\n+\t\tLEB128MappedWriter writer1 = manager.getActiveWriter(thread1);\n+\t\tLEB128MappedWriter writer2 = manager.getActiveWriter(thread2);\n+\n+\t\tassertNotNull(writer1);\n+\t\tassertNotNull(writer2);\n+\t\t\/\/ Different threads get different writers\n+\t\tassertTrue(writer1 != writer2);\n+\t}\n+\n+\t@Test\n+\tvoid testRotateChunk() throws IOException, InterruptedException {\n+\t\tlong threadId = Thread.currentThread().getId();\n+\t\tLEB128MappedWriter writer = manager.getActiveWriter(threadId);\n+\n+\t\t\/\/ Write some data\n+\t\twriter.writeByte((byte) 1);\n+\t\twriter.writeByte((byte) 2);\n+\t\twriter.writeByte((byte) 3);\n+\n+\t\t\/\/ Rotate\n+\t\tmanager.rotateChunk(threadId);\n+\n+\t\t\/\/ Give background flush time to complete\n+\t\tThread.sleep(100);\n+\n+\t\t\/\/ Should have flushed chunks\n+\t\tList<Path> flushed = manager.getFlushedChunks();\n+\t\tassertFalse(flushed.isEmpty());\n+\t}\n+\n+\t@Test\n+\tvoid testRotateChunkSwapsBuffers() throws IOException {\n+\t\tlong threadId = Thread.currentThread().getId();\n+\t\tLEB128MappedWriter writer1 = manager.getActiveWriter(threadId);\n+\n+\t\t\/\/ Write to first buffer\n+\t\twriter1.writeByte((byte) 1);\n+\n+\t\t\/\/ Rotate - should swap to second buffer\n+\t\tmanager.rotateChunk(threadId);\n+\n+\t\t\/\/ Get active writer again (should be the other buffer)\n+\t\tLEB128MappedWriter writer2 = manager.getActiveWriter(threadId);\n+\n+\t\t\/\/ Should still work (different buffer)\n+\t\twriter2.writeByte((byte) 2);\n+\t\tassertEquals(1, writer2.position());\n+\t}\n+\n+\t@Test\n+\tvoid testMultipleRotations() throws IOException, InterruptedException {\n+\t\tlong threadId = Thread.currentThread().getId();\n+\t\tLEB128MappedWriter writer = manager.getActiveWriter(threadId);\n+\n+\t\t\/\/ First rotation\n+\t\twriter.writeByte((byte) 1);\n+\t\tmanager.rotateChunk(threadId);\n+\n+\t\t\/\/ Second rotation\n+\t\twriter = manager.getActiveWriter(threadId);\n+\t\twriter.writeByte((byte) 2);\n+\t\tmanager.rotateChunk(threadId);\n+\n+\t\t\/\/ Third rotation\n+\t\twriter = manager.getActiveWriter(threadId);\n+\t\twriter.writeByte((byte) 3);\n+\t\tmanager.rotateChunk(threadId);\n+\n+\t\t\/\/ Give background flushes time to complete\n+\t\tThread.sleep(200);\n+\n+\t\t\/\/ Should have multiple flushed chunks\n+\t\tList<Path> flushed = manager.getFlushedChunks();\n+\t\tassertTrue(flushed.size() >= 3);\n+\t}\n+\n+\t@Test\n+\tvoid testFinalFlush() throws IOException {\n+\t\tlong threadId = Thread.currentThread().getId();\n+\t\tLEB128MappedWriter writer = manager.getActiveWriter(threadId);\n+\n+\t\t\/\/ Write data without rotating\n+\t\twriter.writeByte((byte) 42);\n+\n+\t\t\/\/ Final flush should flush active buffer\n+\t\tmanager.finalFlush();\n+\n+\t\tList<Path> flushed = manager.getFlushedChunks();\n+\t\tassertFalse(flushed.isEmpty());\n+\t}\n+\n+\t@Test\n+\tvoid testFinalFlushEmptyBuffer() throws IOException {\n+\t\tlong threadId = Thread.currentThread().getId();\n+\t\tmanager.getActiveWriter(threadId);\n+\n+\t\t\/\/ Don't write anything\n+\t\tmanager.finalFlush();\n+\n+\t\t\/\/ Should not create chunk file for empty buffer\n+\t\tList<Path> flushed = manager.getFlushedChunks();\n+\t\tassertTrue(flushed.isEmpty());\n+\t}\n+\n+\t@Test\n+\tvoid testFinalFlushMultipleThreads() throws IOException {\n+\t\tlong thread1 = 100L;\n+\t\tlong thread2 = 200L;\n+\n+\t\tLEB128MappedWriter writer1 = manager.getActiveWriter(thread1);\n+\t\tLEB128MappedWriter writer2 = manager.getActiveWriter(thread2);\n+\n+\t\twriter1.writeByte((byte) 1);\n+\t\twriter2.writeByte((byte) 2);\n+\n+\t\tmanager.finalFlush();\n+\n+\t\tList<Path> flushed = manager.getFlushedChunks();\n+\t\tassertEquals(2, flushed.size());\n+\t}\n+\n+\t@Test\n+\tvoid testCleanup() throws IOException {\n+\t\tlong threadId = Thread.currentThread().getId();\n+\t\tLEB128MappedWriter writer = manager.getActiveWriter(threadId);\n+\n+\t\twriter.writeByte((byte) 1);\n+\t\tmanager.rotateChunk(threadId);\n+\n+\t\t\/\/ Wait for flush\n+\t\ttry {\n+\t\t\tThread.sleep(100);\n+\t\t} catch (InterruptedException e) {\n+\t\t\tThread.currentThread().interrupt();\n+\t\t}\n+\n+\t\tList<Path> flushed = manager.getFlushedChunks();\n+\t\tassertFalse(flushed.isEmpty());\n+\n+\t\t\/\/ Cleanup should delete files\n+\t\tmanager.cleanup();\n+\n+\t\t\/\/ Files should be deleted\n+\t\tfor (Path path : flushed) {\n+\t\t\tassertFalse(Files.exists(path));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tvoid testFlushedChunkFilesExist() throws IOException, InterruptedException {\n+\t\tlong threadId = Thread.currentThread().getId();\n+\t\tLEB128MappedWriter writer = manager.getActiveWriter(threadId);\n+\n+\t\twriter.writeByte((byte) 42);\n+\t\tmanager.rotateChunk(threadId);\n+\n+\t\t\/\/ Wait for background flush\n+\t\tThread.sleep(200);\n+\n+\t\tList<Path> flushed = manager.getFlushedChunks();\n+\t\tassertFalse(flushed.isEmpty());\n+\n+\t\t\/\/ Check files actually exist\n+\t\tfor (Path path : flushed) {\n+\t\t\tassertTrue(Files.exists(path), \"Flushed chunk file should exist: \" + path);\n+\t\t\tassertTrue(Files.size(path) > 0, \"Flushed chunk file should not be empty\");\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tvoid testSequenceNumbering() throws IOException, InterruptedException {\n+\t\tlong threadId = Thread.currentThread().getId();\n+\n+\t\t\/\/ Perform multiple rotations\n+\t\tfor (int i = 0; i < 3; i++) {\n+\t\t\tLEB128MappedWriter writer = manager.getActiveWriter(threadId);\n+\t\t\twriter.writeByte((byte) i);\n+\t\t\tmanager.rotateChunk(threadId);\n+\t\t}\n+\n+\t\tThread.sleep(300);\n+\n+\t\tList<Path> flushed = manager.getFlushedChunks();\n+\t\tassertEquals(3, flushed.size());\n+\n+\t\t\/\/ Files should have sequence numbers in names\n+\t\tfor (Path path : flushed) {\n+\t\t\tassertTrue(path.getFileName().toString().contains(\"chunk-\" + threadId));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tvoid testConcurrentAccess() throws Exception {\n+\t\tThread thread1 = new Thread(() -> {\n+\t\t\ttry {\n+\t\t\t\tlong threadId = Thread.currentThread().getId();\n+\t\t\t\tLEB128MappedWriter writer = manager.getActiveWriter(threadId);\n+\t\t\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t\t\twriter.writeByte((byte) i);\n+\t\t\t\t}\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t}\n+\t\t});\n+\n+\t\tThread thread2 = new Thread(() -> {\n+\t\t\ttry {\n+\t\t\t\tlong threadId = Thread.currentThread().getId();\n+\t\t\t\tLEB128MappedWriter writer = manager.getActiveWriter(threadId);\n+\t\t\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t\t\twriter.writeByte((byte) (i + 10));\n+\t\t\t\t}\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t}\n+\t\t});\n+\n+\t\tthread1.start();\n+\t\tthread2.start();\n+\t\tthread1.join();\n+\t\tthread2.join();\n+\n+\t\tmanager.finalFlush();\n+\n+\t\t\/\/ Both threads should have produced data\n+\t\tList<Path> flushed = manager.getFlushedChunks();\n+\t\tassertEquals(2, flushed.size());\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/ThreadMmapManagerTest.java","additions":322,"deletions":0,"binary":false,"changes":322,"status":"added"},{"patch":"@@ -51,0 +51,1 @@\n+\t\t<module>org.openjdk.jmc.flightrecorder.writer.benchmarks<\/module>\n","filename":"core\/tests\/pom.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}