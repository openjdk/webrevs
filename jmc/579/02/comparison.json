{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,0 @@\n-import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit.RequiredEventsBuilder;\n@@ -77,4 +76,0 @@\n-\tprivate static final Map<String, EventAvailability> REQUIRED_EVENTS = RequiredEventsBuilder.create()\n-\t\t\t.addEventType(JdkTypeIDs.ALLOC_INSIDE_TLAB, EventAvailability.ENABLED)\n-\t\t\t.addEventType(JdkTypeIDs.ALLOC_OUTSIDE_TLAB, EventAvailability.ENABLED).build();\n-\n@@ -93,2 +88,19 @@\n-\t\tList<IntEntry<IMCType>> entries = RulesToolkit.calculateGroupingScore(items.apply(JdkFilters.ALLOC_ALL),\n-\t\t\t\tJdkAttributes.ALLOCATION_CLASS);\n+\t\tboolean preciseEvents = !RulesToolkit.getEventAvailability(items, JdkTypeIDs.ALLOC_INSIDE_TLAB)\n+\t\t\t\t.isLessAvailableThan(EventAvailability.ENABLED)\n+\t\t\t\t&& !RulesToolkit.getEventAvailability(items, JdkTypeIDs.ALLOC_OUTSIDE_TLAB)\n+\t\t\t\t\t\t.isLessAvailableThan(EventAvailability.ENABLED);\n+\t\tboolean sampledEvents = !RulesToolkit.getEventAvailability(items, JdkTypeIDs.OBJ_ALLOC_SAMPLE)\n+\t\t\t\t.isLessAvailableThan(EventAvailability.ENABLED);\n+\t\tif (!preciseEvents && !sampledEvents) {\n+\t\t\treturn RulesToolkit.getNotApplicableResult(this, valueProvider, null);\n+\t\t}\n+\n+\t\tIItemFilter filter = preciseEvents ? JdkFilters.ALLOC_ALL : JdkFilters.OBJ_ALLOC;\n+\t\tList<IntEntry<IMCType>> entries = preciseEvents\n+\t\t\t\t? RulesToolkit.calculateGroupingScore(items.apply(filter), JdkAttributes.ALLOCATION_CLASS)\n+\t\t\t\t\/\/ Using object allocation sample events we must calculate cores taking sample weight\n+\t\t\t\t\/\/ into account. The weight is based on both number of samples and the estimated allocation\n+\t\t\t\t\/\/ size, which we cannot decouple to exactly match the behavior of the more expensive and\n+\t\t\t\t\/\/ precise object allocation in new tlab\/outside tlab events.\n+\t\t\t\t: RulesToolkit.calculateGroupingScore(items.apply(filter), JdkAttributes.ALLOCATION_CLASS,\n+\t\t\t\t\t\tJdkAttributes.SAMPLE_WEIGHT);\n@@ -102,1 +114,1 @@\n-\t\t\tIItemFilter significantFilter = ItemFilters.and(JdkFilters.ALLOC_ALL,\n+\t\t\tIItemFilter significantFilter = ItemFilters.and(filter,\n@@ -156,1 +168,1 @@\n-\t\treturn REQUIRED_EVENTS;\n+\t\treturn Collections.emptyMap();\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/memory\/AllocationByClassRule.java","additions":22,"deletions":10,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,1 @@\n+import org.openjdk.jmc.flightrecorder.jdk.JdkAttributes;\n@@ -68,1 +69,0 @@\n-import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit.RequiredEventsBuilder;\n@@ -77,4 +77,0 @@\n-\tprivate static final Map<String, EventAvailability> REQUIRED_EVENTS = RequiredEventsBuilder.create()\n-\t\t\t.addEventType(JdkTypeIDs.ALLOC_INSIDE_TLAB, EventAvailability.ENABLED)\n-\t\t\t.addEventType(JdkTypeIDs.ALLOC_OUTSIDE_TLAB, EventAvailability.ENABLED).build();\n-\n@@ -93,2 +89,20 @@\n-\t\tList<IntEntry<IMCThread>> entries = RulesToolkit.calculateGroupingScore(items.apply(JdkFilters.ALLOC_ALL),\n-\t\t\t\tJfrAttributes.EVENT_THREAD);\n+\t\tboolean preciseEvents = !RulesToolkit.getEventAvailability(items, JdkTypeIDs.ALLOC_INSIDE_TLAB)\n+\t\t\t\t.isLessAvailableThan(EventAvailability.ENABLED)\n+\t\t\t\t&& !RulesToolkit.getEventAvailability(items, JdkTypeIDs.ALLOC_OUTSIDE_TLAB)\n+\t\t\t\t\t\t.isLessAvailableThan(EventAvailability.ENABLED);\n+\t\tboolean sampledEvents = !RulesToolkit.getEventAvailability(items, JdkTypeIDs.OBJ_ALLOC_SAMPLE)\n+\t\t\t\t.isLessAvailableThan(EventAvailability.ENABLED);\n+\t\tif (!preciseEvents && !sampledEvents) {\n+\t\t\treturn RulesToolkit.getNotApplicableResult(this, valueProvider, null);\n+\t\t}\n+\n+\t\tIItemFilter filter = preciseEvents ? JdkFilters.ALLOC_ALL : JdkFilters.OBJ_ALLOC;\n+\t\tIItemCollection allocationItems = items.apply(filter);\n+\t\tList<IntEntry<IMCThread>> entries = preciseEvents\n+\t\t\t\t? RulesToolkit.calculateGroupingScore(allocationItems, JfrAttributes.EVENT_THREAD)\n+\t\t\t\t\/\/ Using object allocation sample events we must calculate cores taking sample weight\n+\t\t\t\t\/\/ into account. The weight is based on both number of samples and the estimated allocation\n+\t\t\t\t\/\/ size, which we cannot decouple to exactly match the behavior of the more expensive and\n+\t\t\t\t\/\/ precise object allocation in new tlab\/outside tlab events.\n+\t\t\t\t: RulesToolkit.calculateGroupingScore(allocationItems, JfrAttributes.EVENT_THREAD,\n+\t\t\t\t\t\tJdkAttributes.SAMPLE_WEIGHT);\n@@ -102,1 +116,1 @@\n-\t\t\tIItemFilter significantFilter = ItemFilters.and(JdkFilters.ALLOC_ALL,\n+\t\t\tIItemFilter significantFilter = ItemFilters.and(filter,\n@@ -156,1 +170,1 @@\n-\t\treturn REQUIRED_EVENTS;\n+\t\treturn Collections.emptyMap();\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/memory\/AllocationByThreadRule.java","additions":24,"deletions":10,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.util.Collections;\n@@ -45,0 +46,2 @@\n+import org.openjdk.jmc.common.item.IAggregator;\n+import org.openjdk.jmc.common.item.IAttribute;\n@@ -47,0 +50,1 @@\n+import org.openjdk.jmc.common.item.IItemFilter;\n@@ -65,1 +69,0 @@\n-import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit.RequiredEventsBuilder;\n@@ -129,4 +132,0 @@\n-\tprivate static final Map<String, EventAvailability> REQUIRED_EVENTS = RequiredEventsBuilder.create()\n-\t\t\t.addEventType(JdkTypeIDs.ALLOC_INSIDE_TLAB, EventAvailability.ENABLED)\n-\t\t\t.addEventType(JdkTypeIDs.ALLOC_OUTSIDE_TLAB, EventAvailability.AVAILABLE).build();\n-\n@@ -154,1 +153,1 @@\n-\t\t\t\tJfrRuleTopics.HEAP, CONFIGURATION_ATTRIBUTES, RESULT_ATTRIBUTES, REQUIRED_EVENTS);\n+\t\t\t\tJfrRuleTopics.HEAP, CONFIGURATION_ATTRIBUTES, RESULT_ATTRIBUTES, Collections.emptyMap());\n@@ -159,0 +158,10 @@\n+\t\tboolean preciseEvents = !RulesToolkit.getEventAvailability(items, JdkTypeIDs.ALLOC_INSIDE_TLAB)\n+\t\t\t\t.isLessAvailableThan(EventAvailability.ENABLED)\n+\t\t\t\t&& !RulesToolkit.getEventAvailability(items, JdkTypeIDs.ALLOC_OUTSIDE_TLAB)\n+\t\t\t\t\t\t.isLessAvailableThan(EventAvailability.AVAILABLE);\n+\t\tboolean sampledEvents = !RulesToolkit.getEventAvailability(items, JdkTypeIDs.OBJ_ALLOC_SAMPLE)\n+\t\t\t\t.isLessAvailableThan(EventAvailability.AVAILABLE);\n+\t\tif (!preciseEvents && !sampledEvents) {\n+\t\t\treturn RulesToolkit.getNotApplicableResult(this, vp, null);\n+\t\t}\n+\n@@ -163,1 +172,6 @@\n-\t\tIItemCollection allocationItems = items.apply(JdkFilters.ALLOC_ALL);\n+\t\tIItemFilter filter = preciseEvents ? JdkFilters.ALLOC_ALL : JdkFilters.OBJ_ALLOC;\n+\t\tIAttribute<IQuantity> allocationAttribute = preciseEvents ? JdkAttributes.TOTAL_ALLOCATION_SIZE\n+\t\t\t\t: JdkAttributes.SAMPLE_WEIGHT;\n+\t\tIAggregator<IQuantity, ?> aggregator = preciseEvents ? JdkAggregators.ALLOCATION_TOTAL\n+\t\t\t\t: JdkAggregators.OBJ_ALLOC_TOTAL_SUM;\n+\t\tIItemCollection allocationItems = items.apply(filter);\n@@ -177,1 +191,1 @@\n-\t\t\t\t\ttotal = total.add(RulesToolkit.getValue(item, JdkAttributes.TOTAL_ALLOCATION_SIZE));\n+\t\t\t\t\ttotal = total.add(RulesToolkit.getValue(item, allocationAttribute));\n@@ -201,1 +215,1 @@\n-\t\tIQuantity totalAllocationSize = allocationItems.getAggregate(JdkAggregators.ALLOCATION_TOTAL);\n+\t\tIQuantity totalAllocationSize = allocationItems.getAggregate(aggregator);\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/memory\/AutoBoxingRule.java","additions":24,"deletions":10,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -862,0 +862,76 @@\n+\t\/**\n+\t * Each group is represented by the sum of the result of {@code weightAccessorFactory} belong in\n+\t * that group divided by the smallest value observed in {@code items}. Elements are grouped by\n+\t * the {@code groupAccessorFactory} value.\n+\t * <p>\n+\t * This is helpful for events like object allocation samples, where it's not clear how many\n+\t * unique allocations were measured based on the weight value alone. By dividing by the minimum\n+\t * observed weight, we can roughly estimate the number of allocations.\n+\t *\n+\t * @param items\n+\t *            input items\n+\t * @param groupAccessorFactory\n+\t *            a factory that provides accessors for the input item types\n+\t * @param weightAccessorFactory\n+\t *            a factory that provides accessors for the input item weights\n+\t * @return A sorted list of grouping scores, one for each unique value that the accessor\n+\t *         computes from the input items, that tells total weight across input items which gave\n+\t *         that accessor value, divided by the minimum observed value.\n+\t *\/\n+\tpublic static <T> List<IntEntry<T>> calculateGroupingScore(\n+\t\tIItemCollection items, IAccessorFactory<T> groupAccessorFactory,\n+\t\tIAccessorFactory<IQuantity> weightAccessorFactory) {\n+\t\tEntryHashMap<T, IntEntry<T>> map = MapToolkit.createIntMap(1000, 0.5f);\n+\t\tint valueShift = 0;\n+\t\tlong minWeight = 0;\n+\t\tfor (IItemIterable ii : items) {\n+\t\t\tIMemberAccessor<? extends T, IItem> groupByAccessor = groupAccessorFactory.getAccessor(ii.getType());\n+\t\t\tIMemberAccessor<? extends IQuantity, IItem> valueAccessor = weightAccessorFactory.getAccessor(ii.getType());\n+\t\t\tif (groupByAccessor == null || valueAccessor == null) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tfor (IItem item : ii) {\n+\t\t\t\tT member = groupByAccessor.getMember(item);\n+\t\t\t\tif (member != null) {\n+\t\t\t\t\tIntEntry<T> entry = map.get(member, true);\n+\n+\t\t\t\t\tint existingValue = entry.getValue();\n+\t\t\t\t\tlong itemValue = valueAccessor.getMember(item).longValue();\n+\t\t\t\t\tif (itemValue < 0) {\n+\t\t\t\t\t\tthrow new RuntimeException(\"Unexpected negative value: \" + itemValue);\n+\t\t\t\t\t}\n+\t\t\t\t\tlong scaledItemValue = Math.max(1, itemValue >> valueShift);\n+\t\t\t\t\tif (itemValue > 0 && (minWeight == 0 || scaledItemValue < minWeight)) {\n+\t\t\t\t\t\tminWeight = scaledItemValue;\n+\t\t\t\t\t}\n+\t\t\t\t\tlong sum = scaledItemValue + existingValue;\n+\t\t\t\t\tint newShift = 0;\n+\t\t\t\t\twhile (sum >= Integer.MAX_VALUE) {\n+\t\t\t\t\t\tsum = sum >> 1;\n+\t\t\t\t\t\tnewShift++;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (newShift > 0) {\n+\t\t\t\t\t\tfor (IntEntry<T> mapEntry : map) {\n+\t\t\t\t\t\t\tif (mapEntry.getValue() != 0) {\n+\t\t\t\t\t\t\t\tmapEntry.setValue(Math.max(1, mapEntry.getValue() >> newShift));\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tminWeight = Math.max(1, minWeight >> newShift);\n+\t\t\t\t\t\tvalueShift += newShift;\n+\t\t\t\t\t}\n+\t\t\t\t\tentry.setValue((int) sum);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif (minWeight > 0) {\n+\t\t\tfor (IntEntry<T> mapEntry : map) {\n+\t\t\t\tif (mapEntry.getValue() != 0) {\n+\t\t\t\t\tmapEntry.setValue(Math.max(1, mapEntry.getValue() \/ (int) minWeight));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tList<IntEntry<T>> array = IteratorToolkit.toList(map.iterator(), map.size());\n+\t\tarray.sort(null);\n+\t\treturn array;\n+\t}\n+\n@@ -873,1 +949,1 @@\n-\t\tint totalCount = 0;\n+\t\tlong totalCount = 0;\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/util\/RulesToolkit.java","additions":78,"deletions":2,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -624,0 +624,538 @@\n+    <report>\n+        <file>autobox_allocation.jfr<\/file>\n+        <rule>\n+            <id>Allocations.class<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The most allocated type is likely ''java.lang.Integer'', most commonly allocated by: &lt;ul&gt;&lt;li&gt;Integer java.lang.Integer.valueOf(int)&lt;\/li&gt;&lt;li&gt;void Main.main(String[])&lt;\/li&gt;&lt;li&gt;void java.lang.invoke.LambdaForm$DMH+0x0000009001001000.1751075886.invokeStatic(Object, Object)&lt;\/li&gt;&lt;li&gt;Object java.lang.invoke.LambdaForm$MH+0x0000009001199000.352598575.invoke(Object, Object, Object)&lt;\/li&gt;&lt;li&gt;Object java.lang.invoke.Invokers$Holder.invokeExact_MT(Object, Object, Object, Object)&lt;\/li&gt;&lt;li&gt;Object jdk.internal.reflect.DirectMethodHandleAccessor.invokeImpl(Object, Object[])&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Frequently allocated types are good places to start when trying to reduce garbage collections. Look at where the most common types are being allocated to see if many instances are created along the same call path. Try to reduce the number of instances created by invoking the most commonly taken paths less.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>Allocations.thread<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The most allocations were likely done by thread ''main'' at: &lt;ul&gt;&lt;li&gt;Integer java.lang.Integer.valueOf(int)&lt;\/li&gt;&lt;li&gt;void Main.main(String[])&lt;\/li&gt;&lt;li&gt;void java.lang.invoke.LambdaForm$DMH+0x0000009001001000.1751075886.invokeStatic(Object, Object)&lt;\/li&gt;&lt;li&gt;Object java.lang.invoke.LambdaForm$MH+0x0000009001199000.352598575.invoke(Object, Object, Object)&lt;\/li&gt;&lt;li&gt;Object java.lang.invoke.Invokers$Holder.invokeExact_MT(Object, Object, Object, Object)&lt;\/li&gt;&lt;li&gt;Object jdk.internal.reflect.DirectMethodHandleAccessor.invokeImpl(Object, Object[])&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Many allocations performed by the same thread might indicate a problem in a multi-threaded program. Look at the stack traces for the thread with the highest allocation rate. See if the allocation rate can be brought down, or balanced among the active threads.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>ApplicationHalts<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>BufferLost<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No Flight Recorder buffers were lost during the recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>BytecodeVerification<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLeak<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLoading<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CodeCache<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CompareCpu<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CompressedOops<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ContextSwitch<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DMSIncident<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DebugNonSafepoints<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DiscouragedVmOptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DumpReason<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DuplicateFlags<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DynamicAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Exceptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Fatal Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FewSampledThreads<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FileRead<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FileWrite<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FinalizersRun<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FlightRecordingSupport<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FullGc<\/id>\n+            <severity>Not Applicable<\/severity>\n+            <summary>This rule is only valid for CMS and G1 Garbage Collectors, neither of which were detected for this JVM.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>GarbageCollectionInfoRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcFreedRatio<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcOptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseRatio<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HeapContent<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HeapDump<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HighGc<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HighJvmCpu<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingLiveSet<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingMetaSpaceLiveSet<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>JavaBlocking<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>LongGcPause<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>LowOnPhysicalMemory<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ManagementAgent<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ManyRunningProcesses<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MetaspaceOom<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MethodProfiling<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MultipleAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Options<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>OverAggressiveRecordingSetting<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInArguments<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInEnvironment<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInSystemProperties<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PrimitiveToObjectConversion<\/id>\n+            <severity>Information<\/severity>\n+            <summary>52.3 % of the total allocation (29.4 MiB) is caused by conversion from primitive types to object types. The most common object type that primitives are converted into is ''java.lang.Integer''.<\/summary>\n+            <explanation>\n+The most common object type that primitives are converted into is ''java.lang.Integer'', which causes 15.4 MiB to be allocated. The most common call site is ''void Main.main(java.lang.String[]):6''.\n+Conversion from primitives to the corresponding object types can either be done explicitly, or be caused by autoboxing. If a considerable amount of the total allocation is caused by such conversions, consider changing the application source code to avoid this behavior. Look at the allocation stack traces to see which parts of the code to change. This rule finds the calls to the valueOf method for any of the eight object types that have primitive counterparts.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>ProcessStarted<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SocketRead<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SocketWrite<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>StackdepthSetting<\/id>\n+            <severity>Warning<\/severity>\n+            <summary>Some stack traces were truncated in this recording.<\/summary>\n+            <explanation>The Flight Recorder is configured with a maximum captured stack depth of 64. 7.5 % of all traces were larger than this option, and were therefore truncated. If more detailed traces are required, increase the ''-XX:FlightRecorderOptions=stackdepth=&lt;value&gt;'' value.\n+Events of the following types have truncated stack traces: &lt;ul&gt;&lt;li&gt;Allocation in new TLAB (7.76 % truncated traces)&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>StringDeduplication<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>TlabAllocationRatio<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The program allocated 1.49 % of the memory outside of TLABs.<\/summary>\n+            <solution>Allocating objects outside of Thread Local Allocation Buffers (TLABs) is more expensive than allocating inside TLABs. This may be acceptable if the individual allocations are intended to be larger than a reasonable TLAB. It may be possible to avoid this by decreasing the size of the individual allocations. There are some TLAB related JVM flags that you can experiment with, but it is usually better to let the JVM manage TLAB sizes automatically.<\/solution>\n+        <\/rule>\n+        <rule>\n+            <id>VMOperations<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocation<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocationPause<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+    <\/report>\n+    <report>\n+        <file>autobox_allocation_sample.jfr<\/file>\n+        <rule>\n+            <id>Allocations.class<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The most allocated type is likely ''byte[]'', most commonly allocated by: &lt;ul&gt;&lt;li&gt;byte[] java.util.Arrays.copyOfRangeByte(byte[], int, int)&lt;\/li&gt;&lt;li&gt;byte[] java.util.Arrays.copyOfRange(byte[], int, int)&lt;\/li&gt;&lt;li&gt;String java.lang.StringLatin1.newString(byte[], int, int)&lt;\/li&gt;&lt;li&gt;String java.lang.String.substring(int, int)&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Frequently allocated types are good places to start when trying to reduce garbage collections. Look at where the most common types are being allocated to see if many instances are created along the same call path. Try to reduce the number of instances created by invoking the most commonly taken paths less.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>Allocations.thread<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The most allocations were likely done by thread ''main'' at: &lt;ul&gt;&lt;li&gt;Integer java.lang.Integer.valueOf(int)&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Many allocations performed by the same thread might indicate a problem in a multi-threaded program. Look at the stack traces for the thread with the highest allocation rate. See if the allocation rate can be brought down, or balanced among the active threads.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>ApplicationHalts<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>BufferLost<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No Flight Recorder buffers were lost during the recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>BytecodeVerification<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLeak<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLoading<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CodeCache<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CompareCpu<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CompressedOops<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ContextSwitch<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DMSIncident<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DebugNonSafepoints<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DiscouragedVmOptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DumpReason<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DuplicateFlags<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DynamicAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Exceptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Fatal Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FewSampledThreads<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FileRead<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FileWrite<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FinalizersRun<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FlightRecordingSupport<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FullGc<\/id>\n+            <severity>Not Applicable<\/severity>\n+            <summary>This rule is only valid for CMS and G1 Garbage Collectors, neither of which were detected for this JVM.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>GarbageCollectionInfoRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcFreedRatio<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcOptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseRatio<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HeapContent<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HeapDump<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HighGc<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HighJvmCpu<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingLiveSet<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingMetaSpaceLiveSet<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>JavaBlocking<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>LongGcPause<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>LowOnPhysicalMemory<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ManagementAgent<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ManyRunningProcesses<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MetaspaceOom<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MethodProfiling<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MultipleAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Options<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>OverAggressiveRecordingSetting<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInArguments<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInEnvironment<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInSystemProperties<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PrimitiveToObjectConversion<\/id>\n+            <severity>Information<\/severity>\n+            <summary>33.6 % of the total allocation (45.6 MiB) is caused by conversion from primitive types to object types. The most common object type that primitives are converted into is ''java.lang.Integer''.<\/summary>\n+            <explanation>\n+The most common object type that primitives are converted into is ''java.lang.Integer'', which causes 15.3 MiB to be allocated. The most common call site is ''void Main.main(java.lang.String[]):6''.\n+Conversion from primitives to the corresponding object types can either be done explicitly, or be caused by autoboxing. If a considerable amount of the total allocation is caused by such conversions, consider changing the application source code to avoid this behavior. Look at the allocation stack traces to see which parts of the code to change. This rule finds the calls to the valueOf method for any of the eight object types that have primitive counterparts.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>ProcessStarted<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SocketRead<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SocketWrite<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>StackdepthSetting<\/id>\n+            <severity>Warning<\/severity>\n+            <summary>Some stack traces were truncated in this recording.<\/summary>\n+            <explanation>The Flight Recorder is configured with a maximum captured stack depth of 64. 7.96 % of all traces were larger than this option, and were therefore truncated. If more detailed traces are required, increase the ''-XX:FlightRecorderOptions=stackdepth=&lt;value&gt;'' value.\n+Events of the following types have truncated stack traces: &lt;ul&gt;&lt;li&gt;Object Allocation Sample (7.96 % truncated traces)&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>StringDeduplication<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>TlabAllocationRatio<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>VMOperations<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocation<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocationPause<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+    <\/report>\n@@ -627,1 +1165,377 @@\n-            <id>Allocations.class<\/id>\n+            <id>Allocations.class<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Allocations.thread<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ApplicationHalts<\/id>\n+            <severity>OK<\/severity>\n+            <summary>Application efficiency was not highly affected by halts.<\/summary>\n+            <explanation>The highest ratio of application halts to execution time was 0 % during 4\/24\/2018 10:16:27.000 AM – 10:17:27 AM. 0 % of the halts were for reasons other than GC. The halts ratio for the entire recording was 0 %. 0 % of the total halts were for reasons other than GC.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>BufferLost<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No Flight Recorder buffers were lost during the recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>BytecodeVerification<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The application ran with bytecode verification enabled.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLeak<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLoading<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CodeCache<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CompareCpu<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CompressedOops<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The settings for Compressed Oops were OK.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>ContextSwitch<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DMSIncident<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DebugNonSafepoints<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DiscouragedVmOptions<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No problems were found with the VM options.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>DumpReason<\/id>\n+            <severity>Warning<\/severity>\n+            <summary>This recording was dumped for an exceptional reason.<\/summary>\n+            <explanation>Recording was dumped due to a JVM crash. Some events are likely missing from the end of the recording.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>DuplicateFlags<\/id>\n+            <severity>OK<\/severity>\n+            <summary>There were no duplicate JVM flags on the command line.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>DynamicAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Exceptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Fatal Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FewSampledThreads<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FileRead<\/id>\n+            <severity>OK<\/severity>\n+            <summary>There are no file read events in this recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>FileWrite<\/id>\n+            <severity>OK<\/severity>\n+            <summary>There are no file write events in this recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>FinalizersRun<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FlightRecordingSupport<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The JVM version used for this recording has full Flight Recorder support.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>FullGc<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No Stop-the-World, Full GC events detected.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>GarbageCollectionInfoRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcFreedRatio<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcOptions<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No problems were found with the GC configuration.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseRatio<\/id>\n+            <severity>OK<\/severity>\n+            <summary>Application efficiency was not highly affected by GC pauses.<\/summary>\n+            <explanation>The highest ratio between garbage collection pauses and execution time was 0 % during 4\/24\/2018 10:16:27.000 AM – 10:17:27 AM. The garbage collection pause ratio of the entire recording was 0 %.<\/explanation>\n+            <solution>Pause times may be reduced by increasing the heap size or by trying to reduce allocation.<\/solution>\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HeapContent<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HeapDump<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HighGc<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The runtime did not spend much time performing garbage collections.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>HighJvmCpu<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingLiveSet<\/id>\n+            <severity>Not Applicable<\/severity>\n+            <summary>Too few events to calculate the result.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingMetaSpaceLiveSet<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The class data does not seem to increase during the recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>JavaBlocking<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>LongGcPause<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The application did not cause any long GC pause times.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>LowOnPhysicalMemory<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The maximum amount of used memory was 88.9 % of the physical memory available.<\/summary>\n+            <explanation>The maximum amount of memory used was 28.4 GiB. This is 88.9 % of the 31.9 GiB of physical memory available. Having little free memory may lead to swapping, which is very expensive. To avoid this, either decrease the memory usage or increase the amount of available memory.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>ManagementAgent<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ManyRunningProcesses<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MetaspaceOom<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The metaspace was not exhausted during this recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>MethodProfiling<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No methods where optimization would be particularly efficient could be detected.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>MultipleAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Options<\/id>\n+            <severity>OK<\/severity>\n+            <summary>Deprecated option flags were detected.<\/summary>\n+            <explanation>The following option flag is or will be deprecated. &lt;ul&gt;&lt;li&gt;-XX:+UnlockCommercialFeatures: Deprecated in Java 11.&lt;\/li&gt;&lt;\/ul&gt; Deprecated option flags should be avoided. In some cases they enable legacy code and in other cases they are ignored completely. They will usually be removed in a later Java release.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>OverAggressiveRecordingSetting<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInArguments<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The recording does not seem to contain passwords in the application arguments.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInEnvironment<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInSystemProperties<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PrimitiveToObjectConversion<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ProcessStarted<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SocketRead<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SocketWrite<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>StackdepthSetting<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No stack traces were truncated in this recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>StringDeduplication<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>TlabAllocationRatio<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>VMOperations<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No excessively long VM operations were found in this recording (the longest was 0 s).<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocation<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocationPause<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No revocation of biased locks found.<\/summary>\n+        <\/rule>\n+    <\/report>\n+    <report>\n+        <file>dominating_thread_allocation.jfr<\/file>\n+        <rule>\n+            <id>Allocations.class<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The most allocated type is likely ''byte[]'', most commonly allocated by: &lt;ul&gt;&lt;li&gt;void Main$AllocatingThread.run()&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Frequently allocated types are good places to start when trying to reduce garbage collections. Look at where the most common types are being allocated to see if many instances are created along the same call path. Try to reduce the number of instances created by invoking the most commonly taken paths less.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>Allocations.thread<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The most allocations were likely done by thread ''high-allocation'' at: &lt;ul&gt;&lt;li&gt;void Main$AllocatingThread.run()&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Many allocations performed by the same thread might indicate a problem in a multi-threaded program. Look at the stack traces for the thread with the highest allocation rate. See if the allocation rate can be brought down, or balanced among the active threads.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>ApplicationHalts<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>BufferLost<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No Flight Recorder buffers were lost during the recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>BytecodeVerification<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLeak<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLoading<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CodeCache<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CompareCpu<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CompressedOops<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ContextSwitch<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DMSIncident<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DebugNonSafepoints<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DiscouragedVmOptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DumpReason<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DuplicateFlags<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DynamicAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Exceptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Fatal Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FewSampledThreads<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FileForce<\/id>\n@@ -631,1 +1545,1 @@\n-            <id>Allocations.thread<\/id>\n+            <id>FileRead<\/id>\n@@ -635,1 +1549,122 @@\n-            <id>ApplicationHalts<\/id>\n+            <id>FileWrite<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FinalizersRun<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FlightRecordingSupport<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FullGc<\/id>\n+            <severity>Not Applicable<\/severity>\n+            <summary>This rule is only valid for CMS and G1 Garbage Collectors, neither of which were detected for this JVM.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>GarbageCollectionInfoRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcFreedRatio<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcOptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseRatio<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HeapContent<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HeapDump<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HighGc<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HighJvmCpu<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingLiveSet<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingMetaSpaceLiveSet<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>JavaBlocking<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>LongGcPause<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>LowOnPhysicalMemory<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ManagementAgent<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ManyRunningProcesses<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MetaspaceOom<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MethodProfiling<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MultipleAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Options<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>OverAggressiveRecordingSetting<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInArguments<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInEnvironment<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInSystemProperties<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PrimitiveToObjectConversion<\/id>\n@@ -637,2 +1672,61 @@\n-            <summary>Application efficiency was not highly affected by halts.<\/summary>\n-            <explanation>The highest ratio of application halts to execution time was 0 % during 4\/24\/2018 10:16:27.000 AM – 10:17:27 AM. 0 % of the halts were for reasons other than GC. The halts ratio for the entire recording was 0 %. 0 % of the total halts were for reasons other than GC.<\/explanation>\n+            <summary>No allocation was caused by conversion from primitive types to the corresponding object types.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>ProcessStarted<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SocketRead<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SocketWrite<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>StackdepthSetting<\/id>\n+            <severity>OK<\/severity>\n+            <summary>Some stack traces were truncated in this recording.<\/summary>\n+            <explanation>The Flight Recorder is configured with a maximum captured stack depth of 64. 0.0801 % of all traces were larger than this option, and were therefore truncated. If more detailed traces are required, increase the ''-XX:FlightRecorderOptions=stackdepth=&lt;value&gt;'' value.\n+Events of the following types have truncated stack traces: &lt;ul&gt;&lt;li&gt;Allocation in new TLAB (6.4 % truncated traces)&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>StringDeduplication<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>TlabAllocationRatio<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The program allocated 96.1 % of the memory outside of TLABs.<\/summary>\n+            <solution>Allocating objects outside of Thread Local Allocation Buffers (TLABs) is more expensive than allocating inside TLABs. This may be acceptable if the individual allocations are intended to be larger than a reasonable TLAB. It may be possible to avoid this by decreasing the size of the individual allocations. There are some TLAB related JVM flags that you can experiment with, but it is usually better to let the JVM manage TLAB sizes automatically.<\/solution>\n+        <\/rule>\n+        <rule>\n+            <id>VMOperations<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocation<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocationPause<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+    <\/report>\n+    <report>\n+        <file>dominating_thread_allocation_sample.jfr<\/file>\n+        <rule>\n+            <id>Allocations.class<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The most allocated type is likely ''byte[]'', most commonly allocated by: &lt;ul&gt;&lt;li&gt;void Main$AllocatingThread.run()&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Frequently allocated types are good places to start when trying to reduce garbage collections. Look at where the most common types are being allocated to see if many instances are created along the same call path. Try to reduce the number of instances created by invoking the most commonly taken paths less.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>Allocations.thread<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The most allocations were likely done by thread ''high-allocation'' at: &lt;ul&gt;&lt;li&gt;void Main$AllocatingThread.run()&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Many allocations performed by the same thread might indicate a problem in a multi-threaded program. Look at the stack traces for the thread with the highest allocation rate. See if the allocation rate can be brought down, or balanced among the active threads.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>ApplicationHalts<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -647,2 +1741,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The application ran with bytecode verification enabled.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -668,2 +1761,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The settings for Compressed Oops were OK.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -685,2 +1777,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No problems were found with the VM options.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -690,3 +1781,1 @@\n-            <severity>Warning<\/severity>\n-            <summary>This recording was dumped for an exceptional reason.<\/summary>\n-            <explanation>Recording was dumped due to a JVM crash. Some events are likely missing from the end of the recording.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -696,2 +1785,1 @@\n-            <severity>OK<\/severity>\n-            <summary>There were no duplicate JVM flags on the command line.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -725,2 +1813,1 @@\n-            <severity>OK<\/severity>\n-            <summary>There are no file read events in this recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -730,2 +1817,1 @@\n-            <severity>OK<\/severity>\n-            <summary>There are no file write events in this recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -739,2 +1825,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The JVM version used for this recording has full Flight Recorder support.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -744,2 +1829,2 @@\n-            <severity>OK<\/severity>\n-            <summary>No Stop-the-World, Full GC events detected.<\/summary>\n+            <severity>Not Applicable<\/severity>\n+            <summary>This rule is only valid for CMS and G1 Garbage Collectors, neither of which were detected for this JVM.<\/summary>\n@@ -761,2 +1846,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No problems were found with the GC configuration.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -766,4 +1850,1 @@\n-            <severity>OK<\/severity>\n-            <summary>Application efficiency was not highly affected by GC pauses.<\/summary>\n-            <explanation>The highest ratio between garbage collection pauses and execution time was 0 % during 4\/24\/2018 10:16:27.000 AM – 10:17:27 AM. The garbage collection pause ratio of the entire recording was 0 %.<\/explanation>\n-            <solution>Pause times may be reduced by increasing the heap size or by trying to reduce allocation.<\/solution>\n+            <severity>Not Applicable<\/severity>\n@@ -785,2 +1866,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The runtime did not spend much time performing garbage collections.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -795,1 +1875,0 @@\n-            <summary>Too few events to calculate the result.<\/summary>\n@@ -799,2 +1878,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The class data does not seem to increase during the recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -808,2 +1886,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -813,2 +1890,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The application did not cause any long GC pause times.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -818,3 +1894,1 @@\n-            <severity>Information<\/severity>\n-            <summary>The maximum amount of used memory was 88.9 % of the physical memory available.<\/summary>\n-            <explanation>The maximum amount of memory used was 28.4 GiB. This is 88.9 % of the 31.9 GiB of physical memory available. Having little free memory may lead to swapping, which is very expensive. To avoid this, either decrease the memory usage or increase the amount of available memory.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -832,2 +1906,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The metaspace was not exhausted during this recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -837,2 +1910,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No methods where optimization would be particularly efficient could be detected.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -846,3 +1918,1 @@\n-            <severity>OK<\/severity>\n-            <summary>Deprecated option flags were detected.<\/summary>\n-            <explanation>The following option flag is or will be deprecated. &lt;ul&gt;&lt;li&gt;-XX:+UnlockCommercialFeatures: Deprecated in Java 11.&lt;\/li&gt;&lt;\/ul&gt; Deprecated option flags should be avoided. In some cases they enable legacy code and in other cases they are ignored completely. They will usually be removed in a later Java release.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -856,2 +1926,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The recording does not seem to contain passwords in the application arguments.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -869,1 +1938,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No allocation was caused by conversion from primitive types to the corresponding object types.<\/summary>\n@@ -886,1 +1956,3 @@\n-            <summary>No stack traces were truncated in this recording.<\/summary>\n+            <summary>Some stack traces were truncated in this recording.<\/summary>\n+            <explanation>The Flight Recorder is configured with a maximum captured stack depth of 64. 0.22 % of all traces were larger than this option, and were therefore truncated. If more detailed traces are required, increase the ''-XX:FlightRecorderOptions=stackdepth=&lt;value&gt;'' value.\n+Events of the following types have truncated stack traces: &lt;ul&gt;&lt;li&gt;Object Allocation Sample (0.22 % truncated traces)&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n@@ -898,2 +1970,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No excessively long VM operations were found in this recording (the longest was 0 s).<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -907,2 +1978,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No revocation of biased locks found.<\/summary>\n+            <severity>Not Applicable<\/severity>\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/baseline\/JfrRuleBaseline.xml","additions":1127,"deletions":57,"binary":false,"changes":1184,"status":"modified"},{"filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/jfr\/autobox_allocation.jfr","binary":true,"status":"added"},{"filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/jfr\/autobox_allocation_sample.jfr","binary":true,"status":"added"},{"filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/jfr\/dominating_thread_allocation.jfr","binary":true,"status":"added"},{"filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/jfr\/dominating_thread_allocation_sample.jfr","binary":true,"status":"added"},{"patch":"@@ -3,0 +3,2 @@\n+autobox_allocation.jfr\n+autobox_allocation_sample.jfr\n@@ -4,0 +6,2 @@\n+dominating_thread_allocation.jfr\n+dominating_thread_allocation_sample.jfr\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/jfr\/index.txt","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import java.util.List;\n@@ -44,0 +45,2 @@\n+import org.openjdk.jmc.common.collection.EntryHashMap;\n+import org.openjdk.jmc.common.collection.MapToolkit;\n@@ -100,0 +103,17 @@\n+\n+\t@Test\n+\tpublic void testCalculateBalanceScoreLargeValues() {\n+\t\t\/\/ Validate the test using equal small values\n+\t\tdouble score = RulesToolkit.calculateBalanceScore(List.of(intEntry(5), intEntry(5)));\n+\t\tassertEquals(.75D, score, .01D);\n+\t\t\/\/ Large integer values should be no different\n+\t\tscore = RulesToolkit.calculateBalanceScore(List.of(intEntry(Integer.MAX_VALUE), intEntry(Integer.MAX_VALUE)));\n+\t\tassertEquals(.75D, score, .01D);\n+\t}\n+\n+\tprivate static MapToolkit.IntEntry<String> intEntry(int value) {\n+\t\tEntryHashMap<String, MapToolkit.IntEntry<String>> map = MapToolkit.createIntMap(1, 1);\n+\t\tMapToolkit.IntEntry<String> entry = map.get(\"stub\", true);\n+\t\tentry.setValue(value);\n+\t\treturn entry;\n+\t}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/RulesToolkitTest.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"}]}