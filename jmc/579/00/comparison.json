{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,0 @@\n-import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit.RequiredEventsBuilder;\n@@ -77,4 +76,0 @@\n-\tprivate static final Map<String, EventAvailability> REQUIRED_EVENTS = RequiredEventsBuilder.create()\n-\t\t\t.addEventType(JdkTypeIDs.ALLOC_INSIDE_TLAB, EventAvailability.ENABLED)\n-\t\t\t.addEventType(JdkTypeIDs.ALLOC_OUTSIDE_TLAB, EventAvailability.ENABLED).build();\n-\n@@ -93,2 +88,19 @@\n-\t\tList<IntEntry<IMCType>> entries = RulesToolkit.calculateGroupingScore(items.apply(JdkFilters.ALLOC_ALL),\n-\t\t\t\tJdkAttributes.ALLOCATION_CLASS);\n+\t\tboolean preciseEvents = !RulesToolkit.getEventAvailability(items, JdkTypeIDs.ALLOC_INSIDE_TLAB)\n+\t\t\t\t.isLessAvailableThan(EventAvailability.ENABLED)\n+\t\t\t\t&& !RulesToolkit.getEventAvailability(items, JdkTypeIDs.ALLOC_OUTSIDE_TLAB)\n+\t\t\t\t\t\t.isLessAvailableThan(EventAvailability.ENABLED);\n+\t\tboolean sampledEvents = !RulesToolkit.getEventAvailability(items, JdkTypeIDs.OBJ_ALLOC_SAMPLE)\n+\t\t\t\t.isLessAvailableThan(EventAvailability.ENABLED);\n+\t\tif (!preciseEvents && !sampledEvents) {\n+\t\t\treturn RulesToolkit.getNotApplicableResult(this, valueProvider, null);\n+\t\t}\n+\n+\t\tIItemFilter filter = preciseEvents ? JdkFilters.ALLOC_ALL : JdkFilters.OBJ_ALLOC;\n+\t\tList<IntEntry<IMCType>> entries = preciseEvents\n+\t\t\t\t? RulesToolkit.calculateGroupingScore(items.apply(filter), JdkAttributes.ALLOCATION_CLASS)\n+\t\t\t\t\/\/ Using object allocation sample events we must calculate cores taking sample weight\n+\t\t\t\t\/\/ into account. The weight is based on both number of samples and the estimated allocation\n+\t\t\t\t\/\/ size, which we cannot decouple to exactly match the behavior of the more expensive and\n+\t\t\t\t\/\/ precise object allocation in new tlab\/outside tlab events.\n+\t\t\t\t: RulesToolkit.calculateGroupingScore(items.apply(filter), JdkAttributes.ALLOCATION_CLASS,\n+\t\t\t\t\t\tJdkAttributes.SAMPLE_WEIGHT);\n@@ -102,1 +114,1 @@\n-\t\t\tIItemFilter significantFilter = ItemFilters.and(JdkFilters.ALLOC_ALL,\n+\t\t\tIItemFilter significantFilter = ItemFilters.and(filter,\n@@ -156,1 +168,1 @@\n-\t\treturn REQUIRED_EVENTS;\n+\t\treturn Collections.emptyMap();\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/memory\/AllocationByClassRule.java","additions":22,"deletions":10,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,1 @@\n+import org.openjdk.jmc.flightrecorder.jdk.JdkAttributes;\n@@ -68,1 +69,0 @@\n-import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit.RequiredEventsBuilder;\n@@ -77,4 +77,0 @@\n-\tprivate static final Map<String, EventAvailability> REQUIRED_EVENTS = RequiredEventsBuilder.create()\n-\t\t\t.addEventType(JdkTypeIDs.ALLOC_INSIDE_TLAB, EventAvailability.ENABLED)\n-\t\t\t.addEventType(JdkTypeIDs.ALLOC_OUTSIDE_TLAB, EventAvailability.ENABLED).build();\n-\n@@ -93,2 +89,20 @@\n-\t\tList<IntEntry<IMCThread>> entries = RulesToolkit.calculateGroupingScore(items.apply(JdkFilters.ALLOC_ALL),\n-\t\t\t\tJfrAttributes.EVENT_THREAD);\n+\t\tboolean preciseEvents = !RulesToolkit.getEventAvailability(items, JdkTypeIDs.ALLOC_INSIDE_TLAB)\n+\t\t\t\t.isLessAvailableThan(EventAvailability.ENABLED)\n+\t\t\t\t&& !RulesToolkit.getEventAvailability(items, JdkTypeIDs.ALLOC_OUTSIDE_TLAB)\n+\t\t\t\t\t\t.isLessAvailableThan(EventAvailability.ENABLED);\n+\t\tboolean sampledEvents = !RulesToolkit.getEventAvailability(items, JdkTypeIDs.OBJ_ALLOC_SAMPLE)\n+\t\t\t\t.isLessAvailableThan(EventAvailability.ENABLED);\n+\t\tif (!preciseEvents && !sampledEvents) {\n+\t\t\treturn RulesToolkit.getNotApplicableResult(this, valueProvider, null);\n+\t\t}\n+\n+\t\tIItemFilter filter = preciseEvents ? JdkFilters.ALLOC_ALL : JdkFilters.OBJ_ALLOC;\n+\t\tIItemCollection allocationItems = items.apply(filter);\n+\t\tList<IntEntry<IMCThread>> entries = preciseEvents\n+\t\t\t\t? RulesToolkit.calculateGroupingScore(allocationItems, JfrAttributes.EVENT_THREAD)\n+\t\t\t\t\/\/ Using object allocation sample events we must calculate cores taking sample weight\n+\t\t\t\t\/\/ into account. The weight is based on both number of samples and the estimated allocation\n+\t\t\t\t\/\/ size, which we cannot decouple to exactly match the behavior of the more expensive and\n+\t\t\t\t\/\/ precise object allocation in new tlab\/outside tlab events.\n+\t\t\t\t: RulesToolkit.calculateGroupingScore(allocationItems, JfrAttributes.EVENT_THREAD,\n+\t\t\t\t\t\tJdkAttributes.SAMPLE_WEIGHT);\n@@ -102,1 +116,1 @@\n-\t\t\tIItemFilter significantFilter = ItemFilters.and(JdkFilters.ALLOC_ALL,\n+\t\t\tIItemFilter significantFilter = ItemFilters.and(filter,\n@@ -156,1 +170,1 @@\n-\t\treturn REQUIRED_EVENTS;\n+\t\treturn Collections.emptyMap();\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/memory\/AllocationByThreadRule.java","additions":24,"deletions":10,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.util.Collections;\n@@ -45,0 +46,2 @@\n+import org.openjdk.jmc.common.item.IAggregator;\n+import org.openjdk.jmc.common.item.IAttribute;\n@@ -47,0 +50,1 @@\n+import org.openjdk.jmc.common.item.IItemFilter;\n@@ -65,1 +69,0 @@\n-import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit.RequiredEventsBuilder;\n@@ -129,4 +132,0 @@\n-\tprivate static final Map<String, EventAvailability> REQUIRED_EVENTS = RequiredEventsBuilder.create()\n-\t\t\t.addEventType(JdkTypeIDs.ALLOC_INSIDE_TLAB, EventAvailability.ENABLED)\n-\t\t\t.addEventType(JdkTypeIDs.ALLOC_OUTSIDE_TLAB, EventAvailability.AVAILABLE).build();\n-\n@@ -154,1 +153,1 @@\n-\t\t\t\tJfrRuleTopics.HEAP, CONFIGURATION_ATTRIBUTES, RESULT_ATTRIBUTES, REQUIRED_EVENTS);\n+\t\t\t\tJfrRuleTopics.HEAP, CONFIGURATION_ATTRIBUTES, RESULT_ATTRIBUTES, Collections.emptyMap());\n@@ -159,0 +158,10 @@\n+\t\tboolean preciseEvents = !RulesToolkit.getEventAvailability(items, JdkTypeIDs.ALLOC_INSIDE_TLAB)\n+\t\t\t\t.isLessAvailableThan(EventAvailability.ENABLED)\n+\t\t\t\t&& !RulesToolkit.getEventAvailability(items, JdkTypeIDs.ALLOC_OUTSIDE_TLAB)\n+\t\t\t\t\t\t.isLessAvailableThan(EventAvailability.AVAILABLE);\n+\t\tboolean sampledEvents = !RulesToolkit.getEventAvailability(items, JdkTypeIDs.OBJ_ALLOC_SAMPLE)\n+\t\t\t\t.isLessAvailableThan(EventAvailability.AVAILABLE);\n+\t\tif (!preciseEvents && !sampledEvents) {\n+\t\t\treturn RulesToolkit.getNotApplicableResult(this, vp, null);\n+\t\t}\n+\n@@ -163,1 +172,6 @@\n-\t\tIItemCollection allocationItems = items.apply(JdkFilters.ALLOC_ALL);\n+\t\tIItemFilter filter = preciseEvents ? JdkFilters.ALLOC_ALL : JdkFilters.OBJ_ALLOC;\n+\t\tIAttribute<IQuantity> allocationAttribute = preciseEvents ? JdkAttributes.TOTAL_ALLOCATION_SIZE\n+\t\t\t\t: JdkAttributes.SAMPLE_WEIGHT;\n+\t\tIAggregator<IQuantity, ?> aggregator = preciseEvents ? JdkAggregators.ALLOCATION_TOTAL\n+\t\t\t\t: JdkAggregators.OBJ_ALLOC_TOTAL_SUM;\n+\t\tIItemCollection allocationItems = items.apply(filter);\n@@ -177,1 +191,1 @@\n-\t\t\t\t\ttotal = total.add(RulesToolkit.getValue(item, JdkAttributes.TOTAL_ALLOCATION_SIZE));\n+\t\t\t\t\ttotal = total.add(RulesToolkit.getValue(item, allocationAttribute));\n@@ -201,1 +215,1 @@\n-\t\tIQuantity totalAllocationSize = allocationItems.getAggregate(JdkAggregators.ALLOCATION_TOTAL);\n+\t\tIQuantity totalAllocationSize = allocationItems.getAggregate(aggregator);\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/memory\/AutoBoxingRule.java","additions":24,"deletions":10,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -862,0 +862,76 @@\n+\t\/**\n+\t * Each group is represented by the sum of the result of {@code weightAccessorFactory} belong in\n+\t * that group divided by the smallest value observed in {@code items}. Elements are grouped by\n+\t * the {@code groupAccessorFactory} value.\n+\t * <p>\n+\t * This is helpful for events like object allocation samples, where it's not clear how many\n+\t * unique allocations were measured based on the weight value alone. By dividing by the minimum\n+\t * observed weight, we can roughly estimate the number of allocations.\n+\t *\n+\t * @param items\n+\t *            input items\n+\t * @param groupAccessorFactory\n+\t *            a factory that provides accessors for the input item types\n+\t * @param weightAccessorFactory\n+\t *            a factory that provides accessors for the input item weights\n+\t * @return A sorted list of grouping scores, one for each unique value that the accessor\n+\t *         computes from the input items, that tells total weight across input items which gave\n+\t *         that accessor value, divided by the minimum observed value.\n+\t *\/\n+\tpublic static <T> List<IntEntry<T>> calculateGroupingScore(\n+\t\tIItemCollection items, IAccessorFactory<T> groupAccessorFactory,\n+\t\tIAccessorFactory<IQuantity> weightAccessorFactory) {\n+\t\tEntryHashMap<T, IntEntry<T>> map = MapToolkit.createIntMap(1000, 0.5f);\n+\t\tint valueShift = 0;\n+\t\tlong minWeight = 0;\n+\t\tfor (IItemIterable ii : items) {\n+\t\t\tIMemberAccessor<? extends T, IItem> groupByAccessor = groupAccessorFactory.getAccessor(ii.getType());\n+\t\t\tIMemberAccessor<? extends IQuantity, IItem> valueAccessor = weightAccessorFactory.getAccessor(ii.getType());\n+\t\t\tif (groupByAccessor == null || valueAccessor == null) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tfor (IItem item : ii) {\n+\t\t\t\tT member = groupByAccessor.getMember(item);\n+\t\t\t\tif (member != null) {\n+\t\t\t\t\tIntEntry<T> entry = map.get(member, true);\n+\n+\t\t\t\t\tint existingValue = entry.getValue();\n+\t\t\t\t\tlong itemValue = valueAccessor.getMember(item).longValue();\n+\t\t\t\t\tif (itemValue < 0) {\n+\t\t\t\t\t\tthrow new RuntimeException(\"Unexpected negative value: \" + itemValue);\n+\t\t\t\t\t}\n+\t\t\t\t\tlong scaledItemValue = Math.max(1, itemValue >> valueShift);\n+\t\t\t\t\tif (itemValue > 0 && (minWeight == 0 || scaledItemValue < minWeight)) {\n+\t\t\t\t\t\tminWeight = scaledItemValue;\n+\t\t\t\t\t}\n+\t\t\t\t\tlong sum = scaledItemValue + existingValue;\n+\t\t\t\t\tint newShift = 0;\n+\t\t\t\t\twhile (sum >= Integer.MAX_VALUE) {\n+\t\t\t\t\t\tsum = sum >> 1;\n+\t\t\t\t\t\tnewShift++;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (newShift > 0) {\n+\t\t\t\t\t\tfor (IntEntry<T> mapEntry : map) {\n+\t\t\t\t\t\t\tif (mapEntry.getValue() != 0) {\n+\t\t\t\t\t\t\t\tmapEntry.setValue(Math.max(1, mapEntry.getValue() >> newShift));\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tminWeight = Math.max(1, minWeight >> newShift);\n+\t\t\t\t\t\tvalueShift += newShift;\n+\t\t\t\t\t}\n+\t\t\t\t\tentry.setValue((int) sum);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif (minWeight > 0) {\n+\t\t\tfor (IntEntry<T> mapEntry : map) {\n+\t\t\t\tif (mapEntry.getValue() != 0) {\n+\t\t\t\t\tmapEntry.setValue(Math.max(1, mapEntry.getValue() \/ (int) minWeight));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tList<IntEntry<T>> array = IteratorToolkit.toList(map.iterator(), map.size());\n+\t\tarray.sort(null);\n+\t\treturn array;\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/util\/RulesToolkit.java","additions":77,"deletions":1,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.test.util;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Objects;\n+import java.util.TimeZone;\n+\n+\/**\n+ * Test utility to produce a JFR recording for a simple java program. This allows us to validate\n+ * that JMC rules catch problems in a specific program in a way that's easy for developers to\n+ * follow, without checking in recording artifacts. These should be used judiciously because\n+ * executing these processes and capturing recordings while running tests is more expensive than\n+ * consuming stored recording data, and only provides feedback on JFRs from the active JDK version.\n+ *\/\n+public final class JfrGenerator {\n+\n+\tpublic static SourceStage create() {\n+\t\treturn new SourceStage();\n+\t}\n+\n+\tpublic static final class SourceStage {\n+\t\tprivate SourceStage() {\n+\t\t}\n+\n+\t\t\/**\n+\t\t * Provide source code as a string for a valid <a href=\"https:\/\/openjdk.org\/jeps\/330\">JEP\n+\t\t * 330<\/a> single-file source-code program, which will be profiled using JFR.\n+\t\t *\/\n+\t\tpublic ConfigurationStage source(String source) {\n+\t\t\treturn new ConfigurationStage(Objects.requireNonNull(source, \"Source is required\"));\n+\t\t}\n+\t}\n+\n+\tpublic static final class ConfigurationStage {\n+\t\tprivate final String source;\n+\n+\t\tprivate ConfigurationStage(String source) {\n+\t\t\tthis.source = source;\n+\t\t}\n+\n+\t\t\/**\n+\t\t * Name of a default configuration, for example {@code default} and {@code profile} are\n+\t\t * included in most OpenJDK builds.\n+\t\t *\/\n+\t\tpublic ExecutionStage configurationName(String configuration) {\n+\t\t\treturn new ExecutionStage(source, Objects.requireNonNull(configuration, \"Configuration is required\"), null);\n+\t\t}\n+\n+\t\t\/**\n+\t\t * Contents of a JFR configuration file.\n+\t\t *\/\n+\t\tpublic ExecutionStage configuration(String configuration) {\n+\t\t\treturn new ExecutionStage(source, null, Objects.requireNonNull(configuration, \"Configuration is required\"));\n+\t\t}\n+\t}\n+\n+\tpublic static final class ExecutionStage {\n+\n+\t\tprivate final String source;\n+\t\tprivate final String configurationName;\n+\t\tprivate final String configurationContents;\n+\n+\t\tprivate ExecutionStage(String source, String configurationName, String configurationContents) {\n+\t\t\tthis.source = source;\n+\t\t\tthis.configurationName = configurationName;\n+\t\t\tthis.configurationContents = configurationContents;\n+\t\t}\n+\n+\t\t\/**\n+\t\t * Executes the provided Java source with the specified recording configuration, then\n+\t\t * invokes {@code consumer} with the resulting recording.\n+\t\t *\/\n+\t\tpublic void execute(RecordingConsumer consumer) throws IOException {\n+\t\t\tObjects.requireNonNull(consumer, \"Consumer is required\");\n+\t\t\tPath temp = Files.createTempDirectory(\"jfr-generator\").toAbsolutePath();\n+\t\t\tPath sourcePath = temp.resolve(\"Source.java\");\n+\t\t\tPath configPath = temp.resolve(\"custom-config.jfc\");\n+\t\t\tPath jfrPath = temp.resolve(\"recording.jfr\");\n+\t\t\ttry {\n+\t\t\t\tFiles.writeString(sourcePath, source, StandardCharsets.UTF_8);\n+\t\t\t\tif (configurationContents != null) {\n+\t\t\t\t\tFiles.writeString(configPath, configurationContents, StandardCharsets.UTF_8);\n+\t\t\t\t}\n+\t\t\t\tString osName = System.getProperty(\"os.name\");\n+\t\t\t\tboolean isWindows = osName != null && osName.startsWith(\"Windows\");\n+\t\t\t\tPath javaBinary = Paths.get(System.getProperty(\"java.home\")).toAbsolutePath().resolve(\"bin\")\n+\t\t\t\t\t\t.resolve(isWindows ? \"java.exe\" : \"java\");\n+\t\t\t\tProcess process = new ProcessBuilder().directory(temp.toFile()).inheritIO().command(\n+\t\t\t\t\t\tjavaBinary.toString(),\n+\t\t\t\t\t\tString.format(\"-XX:StartFlightRecording=settings=%s,filename=%s,dumponexit=true\",\n+\t\t\t\t\t\t\t\tconfigurationName != null ? configurationName : configPath.toAbsolutePath(), jfrPath),\n+\t\t\t\t\t\t\/\/ Bound resource usage.\n+\t\t\t\t\t\t\/\/ We may want to make the JVM args configurable later on.\n+\t\t\t\t\t\t\"-Xmx64m\", \"-Xms64m\",\n+\t\t\t\t\t\t\/\/ Match current JVM timezone\n+\t\t\t\t\t\t\"-Duser.timezone=\" + TimeZone.getDefault().getID(), sourcePath.toString()).start();\n+\t\t\t\tint exitStatus = process.waitFor();\n+\t\t\t\tif (exitStatus != 0) {\n+\t\t\t\t\tthrow new RuntimeException(\"Process failed to exit successfully. Status: \" + exitStatus);\n+\t\t\t\t}\n+\t\t\t\tif (!Files.isRegularFile(jfrPath)) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to create a JFR\");\n+\t\t\t\t}\n+\t\t\t\tconsumer.acceptRecording(jfrPath);\n+\t\t\t} catch (InterruptedException e) {\n+\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t} finally {\n+\t\t\t\tFiles.deleteIfExists(sourcePath);\n+\t\t\t\tFiles.deleteIfExists(jfrPath);\n+\t\t\t\tFiles.deleteIfExists(configPath);\n+\t\t\t\tFiles.delete(temp);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface RecordingConsumer {\n+\t\tvoid acceptRecording(Path recording) throws IOException;\n+\t}\n+\n+\tprivate JfrGenerator() {\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.testlib\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/util\/JfrGenerator.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -95,0 +95,1 @@\n+import org.openjdk.jmc.flightrecorder.test.util.JfrGenerator;\n@@ -97,0 +98,1 @@\n+import org.openjdk.jmc.test.io.FileResource;\n@@ -144,0 +146,127 @@\n+\t@Test\n+\tpublic void allocationByThreadRule() throws IOException {\n+\t\tfor (JfrConfiguration config : allocationProfilingConfigurations()) {\n+\t\t\tJfrGenerator.create()\n+\t\t\t\t\t\/\/ language=Java\n+\t\t\t\t\t.source(\n+\t\t\t\t\t\"\"\"\n+\t\t\t\t\timport java.util.concurrent.atomic.AtomicReference;\n+\t\t\t\t\t\n+\t\t\t\t\tpublic final class Main {\n+\t\t\t\t\t\tprivate static final AtomicReference<Object> REF = new AtomicReference<>();\n+\t\t\t\t\t\n+\t\t\t\t\t\tstatic final class AllocatingThread extends Thread {\n+\t\t\t\t\t\t\tprivate final int iterations;\n+\t\t\t\t\t\n+\t\t\t\t\t\t\tAllocatingThread(int iterations, String name) {\n+\t\t\t\t\t\t\t\tthis.iterations = iterations;\n+\t\t\t\t\t\t\t\tsetName(name);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\n+\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\tpublic void run() {\n+\t\t\t\t\t\t\t\tfor (int i = 0; i < iterations; i++) {\n+\t\t\t\t\t\t\t\t\tREF.set(new byte[100_000]);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\n+\t\t\t\t\t\tpublic static void main(String[] args) {\n+\t\t\t\t\t\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t\t\t\t\t\tnew AllocatingThread(1, \"low-allocation\").start();\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tnew AllocatingThread(100_000, \"high-allocation\").start();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\t\"\"\")\n+\t\t\t\t\t.configuration(config.content())\n+\t\t\t\t\t.execute(recordingPath -> {\n+\t\t\t\t\t\tIOResource recording = new FileResource(recordingPath.toFile());\n+\t\t\t\t\t\tReport report = generateReport(recording, false, null);\n+\t\t\t\t\t\tRuleResult allocationByThreadResult = report.rules.get(\"Allocations.thread\");\n+\t\t\t\t\t\tString prefix = \"Configuration[\" + config.name() + \"] \";\n+\t\t\t\t\t\tAssert.assertNotNull(prefix + \"No results found for Allocations.thread\", allocationByThreadResult);\n+\t\t\t\t\t\tAssert.assertEquals(prefix, \"Information\", allocationByThreadResult.severity);\n+\t\t\t\t\t\tAssert.assertTrue(prefix + allocationByThreadResult.summary, allocationByThreadResult.summary\n+\t\t\t\t\t\t\t\t.contains(\"The most allocations were likely done by thread ''high-allocation''\"));\n+\n+\t\t\t\t\t\tRuleResult allocationByClassResult = report.rules.get(\"Allocations.class\");\n+\t\t\t\t\t\tAssert.assertNotNull(prefix + \"No results found for Allocations.class\", allocationByClassResult);\n+\t\t\t\t\t\tAssert.assertEquals(prefix, \"Information\", allocationByClassResult.severity);\n+\t\t\t\t\t\tAssert.assertTrue(prefix + allocationByClassResult.summary,\n+\t\t\t\t\t\t\t\tallocationByClassResult.summary.contains(\"The most allocated type is likely ''byte[]''\"));\n+\t\t\t\t\t});\n+\t\t}\n+\t}\n+\n+\tprivate static List<JfrConfiguration> allocationProfilingConfigurations() {\n+\t\treturn List.of(\n+\t\t\t\tnew JfrConfiguration(\n+\t\t\t\t\t\t\"ObjectAllocationInNewTLAB\/OutsideTLAB\",\n+\t\t\t\t\t\t\/\/ language=XML\n+\t\t\t\t\t\t\"\"\"\n+\t\t\t\t\t\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\t\t\t\t\t\t<configuration version=\"2.0\">\n+\t\t\t\t\t\t\t<event name=\"jdk.ObjectAllocationInNewTLAB\">\n+\t\t\t\t\t\t\t\t<setting name=\"enabled\">true<\/setting>\n+\t\t\t\t\t\t\t\t<setting name=\"stackTrace\">true<\/setting>\n+\t\t\t\t\t\t\t<\/event>\n+\t\t\t\t\t\t\t<event name=\"jdk.ObjectAllocationOutsideTLAB\">\n+\t\t\t\t\t\t\t\t<setting name=\"enabled\">true<\/setting>\n+\t\t\t\t\t\t\t\t<setting name=\"stackTrace\">true<\/setting>\n+\t\t\t\t\t\t\t<\/event>\n+\t\t\t\t\t\t<\/configuration>\n+\t\t\t\t\t\t\"\"\"),\n+\t\t\t\tnew JfrConfiguration(\n+\t\t\t\t\t\t\"ObjectAllocationSample\",\n+\t\t\t\t\t\t\/\/ language=XML\n+\t\t\t\t\t\t\"\"\"\n+\t\t\t\t\t\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\t\t\t\t\t\t<configuration version=\"2.0\">\n+\t\t\t\t\t\t\t<event name=\"jdk.ObjectAllocationSample\">\n+\t\t\t\t\t\t\t\t<setting name=\"enabled\">true<\/setting>\n+\t\t\t\t\t\t\t\t<setting name=\"stackTrace\">true<\/setting>\n+\t\t\t\t\t\t\t\t<!-- Effectively disable the throttle -->\n+\t\t\t\t\t\t\t\t<setting name=\"throttle\">1\/ns<\/setting>\n+\t\t\t\t\t\t\t<\/event>\n+\t\t\t\t\t\t<\/configuration>\n+\t\t\t\t\t\t\"\"\"));\n+\t}\n+\n+\trecord JfrConfiguration(String name, String content) {\n+\t}\n+\n+\t@Test\n+\tpublic void autoboxingRule() throws IOException {\n+\t\tfor (JfrConfiguration config : allocationProfilingConfigurations()) {\n+\t\tJfrGenerator.create()\n+\t\t\t\t.source(\n+\t\t\t\t\t\t\/\/ language=Java\n+\t\t\t\t\t\t\"\"\"\n+\t\t\t\t\t\timport java.util.concurrent.atomic.AtomicReference;\n+\t\t\t\t\t\t\n+\t\t\t\t\t\tpublic final class Main {\n+\t\t\t\t\t\t\tprivate static final AtomicReference<Object> REF = new AtomicReference<>();\n+\t\t\t\t\t\t\n+\t\t\t\t\t\t\tpublic static void main(String[] args) throws Exception {\n+\t\t\t\t\t\t\t\tfor (int i = 0; i < 1_000_000; i++) {\n+\t\t\t\t\t\t\t\t\tREF.set(i);\n+\t\t\t\t\t\t\t\t\t\/\/ Provide a small delay for the object allocation sampler\n+\t\t\t\t\t\t\t\t\tif (i % 1000 == 0) Thread.sleep(1);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\"\"\")\n+\t\t\t\t.configuration(config.content())\n+\t\t\t\t.execute(recordingPath -> {\n+\t\t\t\t\tIOResource recording = new FileResource(recordingPath.toFile());\n+\t\t\t\t\tReport report = generateReport(recording, false, null);\n+\t\t\t\t\tRuleResult allocationByThreadResult = report.rules.get(\"PrimitiveToObjectConversion\");\n+\t\t\t\t\tString prefix = \"Configuration[\" + config.name() + \"] \";\n+\t\t\t\t\tAssert.assertNotNull(prefix + \"No results found for PrimitiveToObjectConversion\", allocationByThreadResult);\n+\t\t\t\t\tAssert.assertEquals(prefix, \"Information\", allocationByThreadResult.severity);\n+\t\t\t\t\tAssert.assertTrue(prefix + allocationByThreadResult.summary, allocationByThreadResult.summary\n+\t\t\t\t\t\t\t.contains(\"The most common object type that primitives are converted into is ''java.lang.Integer''\"));\n+\t\t\t\t});\n+\t\t}\n+\t}\n+\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/rules\/jdk\/TestRulesWithJfr.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"modified"}]}