{"files":[{"patch":"@@ -1,158 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- *\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * The contents of this file are subject to the terms of either the Universal Permissive License\n- * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n- *\n- * or the following license:\n- *\n- * Redistribution and use in source and binary forms, with or without modification, are permitted\n- * provided that the following conditions are met:\n- *\n- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n- * and the following disclaimer.\n- *\n- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n- * conditions and the following disclaimer in the documentation and\/or other materials provided with\n- * the distribution.\n- *\n- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n- * endorse or promote products derived from this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n- * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-package org.openjdk.jmc.flightrecorder.test.util;\n-\n-import java.io.IOException;\n-import java.nio.charset.StandardCharsets;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.Objects;\n-import java.util.TimeZone;\n-\n-\/**\n- * Test utility to produce a JFR recording for a simple java program. This allows us to validate\n- * that JMC rules catch problems in a specific program in a way that's easy for developers to\n- * follow, without checking in recording artifacts. These should be used judiciously because\n- * executing these processes and capturing recordings while running tests is more expensive than\n- * consuming stored recording data, and only provides feedback on JFRs from the active JDK version.\n- *\/\n-public final class JfrGenerator {\n-\n-\tpublic static SourceStage create() {\n-\t\treturn new SourceStage();\n-\t}\n-\n-\tpublic static final class SourceStage {\n-\t\tprivate SourceStage() {\n-\t\t}\n-\n-\t\t\/**\n-\t\t * Provide source code as a string for a valid <a href=\"https:\/\/openjdk.org\/jeps\/330\">JEP\n-\t\t * 330<\/a> single-file source-code program, which will be profiled using JFR.\n-\t\t *\/\n-\t\tpublic ConfigurationStage source(String source) {\n-\t\t\treturn new ConfigurationStage(Objects.requireNonNull(source, \"Source is required\"));\n-\t\t}\n-\t}\n-\n-\tpublic static final class ConfigurationStage {\n-\t\tprivate final String source;\n-\n-\t\tprivate ConfigurationStage(String source) {\n-\t\t\tthis.source = source;\n-\t\t}\n-\n-\t\t\/**\n-\t\t * Name of a default configuration, for example {@code default} and {@code profile} are\n-\t\t * included in most OpenJDK builds.\n-\t\t *\/\n-\t\tpublic ExecutionStage configurationName(String configuration) {\n-\t\t\treturn new ExecutionStage(source, Objects.requireNonNull(configuration, \"Configuration is required\"), null);\n-\t\t}\n-\n-\t\t\/**\n-\t\t * Contents of a JFR configuration file.\n-\t\t *\/\n-\t\tpublic ExecutionStage configuration(String configuration) {\n-\t\t\treturn new ExecutionStage(source, null, Objects.requireNonNull(configuration, \"Configuration is required\"));\n-\t\t}\n-\t}\n-\n-\tpublic static final class ExecutionStage {\n-\n-\t\tprivate final String source;\n-\t\tprivate final String configurationName;\n-\t\tprivate final String configurationContents;\n-\n-\t\tprivate ExecutionStage(String source, String configurationName, String configurationContents) {\n-\t\t\tthis.source = source;\n-\t\t\tthis.configurationName = configurationName;\n-\t\t\tthis.configurationContents = configurationContents;\n-\t\t}\n-\n-\t\t\/**\n-\t\t * Executes the provided Java source with the specified recording configuration, then\n-\t\t * invokes {@code consumer} with the resulting recording.\n-\t\t *\/\n-\t\tpublic void execute(RecordingConsumer consumer) throws IOException {\n-\t\t\tObjects.requireNonNull(consumer, \"Consumer is required\");\n-\t\t\tPath temp = Files.createTempDirectory(\"jfr-generator\").toAbsolutePath();\n-\t\t\tPath sourcePath = temp.resolve(\"Source.java\");\n-\t\t\tPath configPath = temp.resolve(\"custom-config.jfc\");\n-\t\t\tPath jfrPath = temp.resolve(\"recording.jfr\");\n-\t\t\ttry {\n-\t\t\t\tFiles.writeString(sourcePath, source, StandardCharsets.UTF_8);\n-\t\t\t\tif (configurationContents != null) {\n-\t\t\t\t\tFiles.writeString(configPath, configurationContents, StandardCharsets.UTF_8);\n-\t\t\t\t}\n-\t\t\t\tString osName = System.getProperty(\"os.name\");\n-\t\t\t\tboolean isWindows = osName != null && osName.startsWith(\"Windows\");\n-\t\t\t\tPath javaBinary = Paths.get(System.getProperty(\"java.home\")).toAbsolutePath().resolve(\"bin\")\n-\t\t\t\t\t\t.resolve(isWindows ? \"java.exe\" : \"java\");\n-\t\t\t\tProcess process = new ProcessBuilder().directory(temp.toFile()).inheritIO().command(\n-\t\t\t\t\t\tjavaBinary.toString(),\n-\t\t\t\t\t\tString.format(\"-XX:StartFlightRecording=settings=%s,filename=%s,dumponexit=true\",\n-\t\t\t\t\t\t\t\tconfigurationName != null ? configurationName : configPath.toAbsolutePath(), jfrPath),\n-\t\t\t\t\t\t\/\/ Bound resource usage.\n-\t\t\t\t\t\t\/\/ We may want to make the JVM args configurable later on.\n-\t\t\t\t\t\t\"-Xmx64m\", \"-Xms64m\",\n-\t\t\t\t\t\t\/\/ Match current JVM timezone\n-\t\t\t\t\t\t\"-Duser.timezone=\" + TimeZone.getDefault().getID(), sourcePath.toString()).start();\n-\t\t\t\tint exitStatus = process.waitFor();\n-\t\t\t\tif (exitStatus != 0) {\n-\t\t\t\t\tthrow new RuntimeException(\"Process failed to exit successfully. Status: \" + exitStatus);\n-\t\t\t\t}\n-\t\t\t\tif (!Files.isRegularFile(jfrPath)) {\n-\t\t\t\t\tthrow new RuntimeException(\"Failed to create a JFR\");\n-\t\t\t\t}\n-\t\t\t\tconsumer.acceptRecording(jfrPath);\n-\t\t\t} catch (InterruptedException e) {\n-\t\t\t\tthrow new RuntimeException(e);\n-\t\t\t} finally {\n-\t\t\t\tFiles.deleteIfExists(sourcePath);\n-\t\t\t\tFiles.deleteIfExists(jfrPath);\n-\t\t\t\tFiles.deleteIfExists(configPath);\n-\t\t\t\tFiles.delete(temp);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@FunctionalInterface\n-\tpublic interface RecordingConsumer {\n-\t\tvoid acceptRecording(Path recording) throws IOException;\n-\t}\n-\n-\tprivate JfrGenerator() {\n-\t}\n-}\n","filename":"core\/org.openjdk.jmc.testlib\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/util\/JfrGenerator.java","additions":0,"deletions":158,"binary":false,"changes":158,"status":"deleted"},{"patch":"@@ -95,1 +95,0 @@\n-import org.openjdk.jmc.flightrecorder.test.util.JfrGenerator;\n@@ -98,1 +97,0 @@\n-import org.openjdk.jmc.test.io.FileResource;\n@@ -146,127 +144,0 @@\n-\t@Test\n-\tpublic void allocationByThreadRule() throws IOException {\n-\t\tfor (JfrConfiguration config : allocationProfilingConfigurations()) {\n-\t\t\tJfrGenerator.create()\n-\t\t\t\t\t\/\/ language=Java\n-\t\t\t\t\t.source(\n-\t\t\t\t\t\"\"\"\n-\t\t\t\t\timport java.util.concurrent.atomic.AtomicReference;\n-\t\t\t\t\t\n-\t\t\t\t\tpublic final class Main {\n-\t\t\t\t\t\tprivate static final AtomicReference<Object> REF = new AtomicReference<>();\n-\t\t\t\t\t\n-\t\t\t\t\t\tstatic final class AllocatingThread extends Thread {\n-\t\t\t\t\t\t\tprivate final int iterations;\n-\t\t\t\t\t\n-\t\t\t\t\t\t\tAllocatingThread(int iterations, String name) {\n-\t\t\t\t\t\t\t\tthis.iterations = iterations;\n-\t\t\t\t\t\t\t\tsetName(name);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\t\t\tfor (int i = 0; i < iterations; i++) {\n-\t\t\t\t\t\t\t\t\tREF.set(new byte[100_000]);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\n-\t\t\t\t\t\tpublic static void main(String[] args) {\n-\t\t\t\t\t\t\tfor (int i = 0; i < 10; i++) {\n-\t\t\t\t\t\t\t\tnew AllocatingThread(1, \"low-allocation\").start();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tnew AllocatingThread(100_000, \"high-allocation\").start();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\t\"\"\")\n-\t\t\t\t\t.configuration(config.content())\n-\t\t\t\t\t.execute(recordingPath -> {\n-\t\t\t\t\t\tIOResource recording = new FileResource(recordingPath.toFile());\n-\t\t\t\t\t\tReport report = generateReport(recording, false, null);\n-\t\t\t\t\t\tRuleResult allocationByThreadResult = report.rules.get(\"Allocations.thread\");\n-\t\t\t\t\t\tString prefix = \"Configuration[\" + config.name() + \"] \";\n-\t\t\t\t\t\tAssert.assertNotNull(prefix + \"No results found for Allocations.thread\", allocationByThreadResult);\n-\t\t\t\t\t\tAssert.assertEquals(prefix, \"Information\", allocationByThreadResult.severity);\n-\t\t\t\t\t\tAssert.assertTrue(prefix + allocationByThreadResult.summary, allocationByThreadResult.summary\n-\t\t\t\t\t\t\t\t.contains(\"The most allocations were likely done by thread ''high-allocation''\"));\n-\n-\t\t\t\t\t\tRuleResult allocationByClassResult = report.rules.get(\"Allocations.class\");\n-\t\t\t\t\t\tAssert.assertNotNull(prefix + \"No results found for Allocations.class\", allocationByClassResult);\n-\t\t\t\t\t\tAssert.assertEquals(prefix, \"Information\", allocationByClassResult.severity);\n-\t\t\t\t\t\tAssert.assertTrue(prefix + allocationByClassResult.summary,\n-\t\t\t\t\t\t\t\tallocationByClassResult.summary.contains(\"The most allocated type is likely ''byte[]''\"));\n-\t\t\t\t\t});\n-\t\t}\n-\t}\n-\n-\tprivate static List<JfrConfiguration> allocationProfilingConfigurations() {\n-\t\treturn List.of(\n-\t\t\t\tnew JfrConfiguration(\n-\t\t\t\t\t\t\"ObjectAllocationInNewTLAB\/OutsideTLAB\",\n-\t\t\t\t\t\t\/\/ language=XML\n-\t\t\t\t\t\t\"\"\"\n-\t\t\t\t\t\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-\t\t\t\t\t\t<configuration version=\"2.0\">\n-\t\t\t\t\t\t\t<event name=\"jdk.ObjectAllocationInNewTLAB\">\n-\t\t\t\t\t\t\t\t<setting name=\"enabled\">true<\/setting>\n-\t\t\t\t\t\t\t\t<setting name=\"stackTrace\">true<\/setting>\n-\t\t\t\t\t\t\t<\/event>\n-\t\t\t\t\t\t\t<event name=\"jdk.ObjectAllocationOutsideTLAB\">\n-\t\t\t\t\t\t\t\t<setting name=\"enabled\">true<\/setting>\n-\t\t\t\t\t\t\t\t<setting name=\"stackTrace\">true<\/setting>\n-\t\t\t\t\t\t\t<\/event>\n-\t\t\t\t\t\t<\/configuration>\n-\t\t\t\t\t\t\"\"\"),\n-\t\t\t\tnew JfrConfiguration(\n-\t\t\t\t\t\t\"ObjectAllocationSample\",\n-\t\t\t\t\t\t\/\/ language=XML\n-\t\t\t\t\t\t\"\"\"\n-\t\t\t\t\t\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-\t\t\t\t\t\t<configuration version=\"2.0\">\n-\t\t\t\t\t\t\t<event name=\"jdk.ObjectAllocationSample\">\n-\t\t\t\t\t\t\t\t<setting name=\"enabled\">true<\/setting>\n-\t\t\t\t\t\t\t\t<setting name=\"stackTrace\">true<\/setting>\n-\t\t\t\t\t\t\t\t<!-- Effectively disable the throttle -->\n-\t\t\t\t\t\t\t\t<setting name=\"throttle\">1\/ns<\/setting>\n-\t\t\t\t\t\t\t<\/event>\n-\t\t\t\t\t\t<\/configuration>\n-\t\t\t\t\t\t\"\"\"));\n-\t}\n-\n-\trecord JfrConfiguration(String name, String content) {\n-\t}\n-\n-\t@Test\n-\tpublic void autoboxingRule() throws IOException {\n-\t\tfor (JfrConfiguration config : allocationProfilingConfigurations()) {\n-\t\tJfrGenerator.create()\n-\t\t\t\t.source(\n-\t\t\t\t\t\t\/\/ language=Java\n-\t\t\t\t\t\t\"\"\"\n-\t\t\t\t\t\timport java.util.concurrent.atomic.AtomicReference;\n-\t\t\t\t\t\t\n-\t\t\t\t\t\tpublic final class Main {\n-\t\t\t\t\t\t\tprivate static final AtomicReference<Object> REF = new AtomicReference<>();\n-\t\t\t\t\t\t\n-\t\t\t\t\t\t\tpublic static void main(String[] args) throws Exception {\n-\t\t\t\t\t\t\t\tfor (int i = 0; i < 1_000_000; i++) {\n-\t\t\t\t\t\t\t\t\tREF.set(i);\n-\t\t\t\t\t\t\t\t\t\/\/ Provide a small delay for the object allocation sampler\n-\t\t\t\t\t\t\t\t\tif (i % 1000 == 0) Thread.sleep(1);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\"\"\")\n-\t\t\t\t.configuration(config.content())\n-\t\t\t\t.execute(recordingPath -> {\n-\t\t\t\t\tIOResource recording = new FileResource(recordingPath.toFile());\n-\t\t\t\t\tReport report = generateReport(recording, false, null);\n-\t\t\t\t\tRuleResult allocationByThreadResult = report.rules.get(\"PrimitiveToObjectConversion\");\n-\t\t\t\t\tString prefix = \"Configuration[\" + config.name() + \"] \";\n-\t\t\t\t\tAssert.assertNotNull(prefix + \"No results found for PrimitiveToObjectConversion\", allocationByThreadResult);\n-\t\t\t\t\tAssert.assertEquals(prefix, \"Information\", allocationByThreadResult.severity);\n-\t\t\t\t\tAssert.assertTrue(prefix + allocationByThreadResult.summary, allocationByThreadResult.summary\n-\t\t\t\t\t\t\t.contains(\"The most common object type that primitives are converted into is ''java.lang.Integer''\"));\n-\t\t\t\t});\n-\t\t}\n-\t}\n-\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/rules\/jdk\/TestRulesWithJfr.java","additions":0,"deletions":129,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -624,0 +624,538 @@\n+    <report>\n+        <file>autobox_allocation.jfr<\/file>\n+        <rule>\n+            <id>Allocations.class<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The most allocated type is likely ''java.lang.Integer'', most commonly allocated by: &lt;ul&gt;&lt;li&gt;Integer java.lang.Integer.valueOf(int)&lt;\/li&gt;&lt;li&gt;void Main.main(String[])&lt;\/li&gt;&lt;li&gt;void java.lang.invoke.LambdaForm$DMH+0x0000009001001000.1751075886.invokeStatic(Object, Object)&lt;\/li&gt;&lt;li&gt;Object java.lang.invoke.LambdaForm$MH+0x0000009001199000.352598575.invoke(Object, Object, Object)&lt;\/li&gt;&lt;li&gt;Object java.lang.invoke.Invokers$Holder.invokeExact_MT(Object, Object, Object, Object)&lt;\/li&gt;&lt;li&gt;Object jdk.internal.reflect.DirectMethodHandleAccessor.invokeImpl(Object, Object[])&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Frequently allocated types are good places to start when trying to reduce garbage collections. Look at where the most common types are being allocated to see if many instances are created along the same call path. Try to reduce the number of instances created by invoking the most commonly taken paths less.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>Allocations.thread<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The most allocations were likely done by thread ''main'' at: &lt;ul&gt;&lt;li&gt;Integer java.lang.Integer.valueOf(int)&lt;\/li&gt;&lt;li&gt;void Main.main(String[])&lt;\/li&gt;&lt;li&gt;void java.lang.invoke.LambdaForm$DMH+0x0000009001001000.1751075886.invokeStatic(Object, Object)&lt;\/li&gt;&lt;li&gt;Object java.lang.invoke.LambdaForm$MH+0x0000009001199000.352598575.invoke(Object, Object, Object)&lt;\/li&gt;&lt;li&gt;Object java.lang.invoke.Invokers$Holder.invokeExact_MT(Object, Object, Object, Object)&lt;\/li&gt;&lt;li&gt;Object jdk.internal.reflect.DirectMethodHandleAccessor.invokeImpl(Object, Object[])&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Many allocations performed by the same thread might indicate a problem in a multi-threaded program. Look at the stack traces for the thread with the highest allocation rate. See if the allocation rate can be brought down, or balanced among the active threads.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>ApplicationHalts<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>BufferLost<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No Flight Recorder buffers were lost during the recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>BytecodeVerification<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLeak<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLoading<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CodeCache<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CompareCpu<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CompressedOops<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ContextSwitch<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DMSIncident<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DebugNonSafepoints<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DiscouragedVmOptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DumpReason<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DuplicateFlags<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DynamicAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Exceptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Fatal Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FewSampledThreads<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FileRead<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FileWrite<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FinalizersRun<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FlightRecordingSupport<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FullGc<\/id>\n+            <severity>Not Applicable<\/severity>\n+            <summary>This rule is only valid for CMS and G1 Garbage Collectors, neither of which were detected for this JVM.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>GarbageCollectionInfoRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcFreedRatio<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcOptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseRatio<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HeapContent<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HeapDump<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HighGc<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HighJvmCpu<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingLiveSet<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingMetaSpaceLiveSet<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>JavaBlocking<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>LongGcPause<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>LowOnPhysicalMemory<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ManagementAgent<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ManyRunningProcesses<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MetaspaceOom<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MethodProfiling<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MultipleAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Options<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>OverAggressiveRecordingSetting<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInArguments<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInEnvironment<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInSystemProperties<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PrimitiveToObjectConversion<\/id>\n+            <severity>Information<\/severity>\n+            <summary>52.3 % of the total allocation (29.4 MiB) is caused by conversion from primitive types to object types. The most common object type that primitives are converted into is ''java.lang.Integer''.<\/summary>\n+            <explanation>\n+The most common object type that primitives are converted into is ''java.lang.Integer'', which causes 15.4 MiB to be allocated. The most common call site is ''void Main.main(java.lang.String[]):6''.\n+Conversion from primitives to the corresponding object types can either be done explicitly, or be caused by autoboxing. If a considerable amount of the total allocation is caused by such conversions, consider changing the application source code to avoid this behavior. Look at the allocation stack traces to see which parts of the code to change. This rule finds the calls to the valueOf method for any of the eight object types that have primitive counterparts.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>ProcessStarted<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SocketRead<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SocketWrite<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>StackdepthSetting<\/id>\n+            <severity>Warning<\/severity>\n+            <summary>Some stack traces were truncated in this recording.<\/summary>\n+            <explanation>The Flight Recorder is configured with a maximum captured stack depth of 64. 7.5 % of all traces were larger than this option, and were therefore truncated. If more detailed traces are required, increase the ''-XX:FlightRecorderOptions=stackdepth=&lt;value&gt;'' value.\n+Events of the following types have truncated stack traces: &lt;ul&gt;&lt;li&gt;Allocation in new TLAB (7.76 % truncated traces)&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>StringDeduplication<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>TlabAllocationRatio<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The program allocated 1.49 % of the memory outside of TLABs.<\/summary>\n+            <solution>Allocating objects outside of Thread Local Allocation Buffers (TLABs) is more expensive than allocating inside TLABs. This may be acceptable if the individual allocations are intended to be larger than a reasonable TLAB. It may be possible to avoid this by decreasing the size of the individual allocations. There are some TLAB related JVM flags that you can experiment with, but it is usually better to let the JVM manage TLAB sizes automatically.<\/solution>\n+        <\/rule>\n+        <rule>\n+            <id>VMOperations<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocation<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocationPause<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+    <\/report>\n+    <report>\n+        <file>autobox_allocation_sample.jfr<\/file>\n+        <rule>\n+            <id>Allocations.class<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The most allocated type is likely ''byte[]'', most commonly allocated by: &lt;ul&gt;&lt;li&gt;byte[] java.util.Arrays.copyOfRangeByte(byte[], int, int)&lt;\/li&gt;&lt;li&gt;byte[] java.util.Arrays.copyOfRange(byte[], int, int)&lt;\/li&gt;&lt;li&gt;String java.lang.StringLatin1.newString(byte[], int, int)&lt;\/li&gt;&lt;li&gt;String java.lang.String.substring(int, int)&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Frequently allocated types are good places to start when trying to reduce garbage collections. Look at where the most common types are being allocated to see if many instances are created along the same call path. Try to reduce the number of instances created by invoking the most commonly taken paths less.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>Allocations.thread<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The most allocations were likely done by thread ''main'' at: &lt;ul&gt;&lt;li&gt;Integer java.lang.Integer.valueOf(int)&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Many allocations performed by the same thread might indicate a problem in a multi-threaded program. Look at the stack traces for the thread with the highest allocation rate. See if the allocation rate can be brought down, or balanced among the active threads.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>ApplicationHalts<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>BufferLost<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No Flight Recorder buffers were lost during the recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>BytecodeVerification<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLeak<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLoading<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CodeCache<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CompareCpu<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CompressedOops<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ContextSwitch<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DMSIncident<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DebugNonSafepoints<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DiscouragedVmOptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DumpReason<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DuplicateFlags<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DynamicAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Exceptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Fatal Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FewSampledThreads<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FileRead<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FileWrite<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FinalizersRun<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FlightRecordingSupport<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FullGc<\/id>\n+            <severity>Not Applicable<\/severity>\n+            <summary>This rule is only valid for CMS and G1 Garbage Collectors, neither of which were detected for this JVM.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>GarbageCollectionInfoRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcFreedRatio<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcOptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseRatio<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HeapContent<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HeapDump<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HighGc<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HighJvmCpu<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingLiveSet<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingMetaSpaceLiveSet<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>JavaBlocking<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>LongGcPause<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>LowOnPhysicalMemory<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ManagementAgent<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ManyRunningProcesses<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MetaspaceOom<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MethodProfiling<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MultipleAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Options<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>OverAggressiveRecordingSetting<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInArguments<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInEnvironment<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInSystemProperties<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PrimitiveToObjectConversion<\/id>\n+            <severity>Information<\/severity>\n+            <summary>33.6 % of the total allocation (45.6 MiB) is caused by conversion from primitive types to object types. The most common object type that primitives are converted into is ''java.lang.Integer''.<\/summary>\n+            <explanation>\n+The most common object type that primitives are converted into is ''java.lang.Integer'', which causes 15.3 MiB to be allocated. The most common call site is ''void Main.main(java.lang.String[]):6''.\n+Conversion from primitives to the corresponding object types can either be done explicitly, or be caused by autoboxing. If a considerable amount of the total allocation is caused by such conversions, consider changing the application source code to avoid this behavior. Look at the allocation stack traces to see which parts of the code to change. This rule finds the calls to the valueOf method for any of the eight object types that have primitive counterparts.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>ProcessStarted<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SocketRead<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SocketWrite<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>StackdepthSetting<\/id>\n+            <severity>Warning<\/severity>\n+            <summary>Some stack traces were truncated in this recording.<\/summary>\n+            <explanation>The Flight Recorder is configured with a maximum captured stack depth of 64. 7.96 % of all traces were larger than this option, and were therefore truncated. If more detailed traces are required, increase the ''-XX:FlightRecorderOptions=stackdepth=&lt;value&gt;'' value.\n+Events of the following types have truncated stack traces: &lt;ul&gt;&lt;li&gt;Object Allocation Sample (7.96 % truncated traces)&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>StringDeduplication<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>TlabAllocationRatio<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>VMOperations<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocation<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocationPause<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+    <\/report>\n@@ -627,1 +1165,377 @@\n-            <id>Allocations.class<\/id>\n+            <id>Allocations.class<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Allocations.thread<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ApplicationHalts<\/id>\n+            <severity>OK<\/severity>\n+            <summary>Application efficiency was not highly affected by halts.<\/summary>\n+            <explanation>The highest ratio of application halts to execution time was 0 % during 4\/24\/2018 10:16:27.000 AM – 10:17:27 AM. 0 % of the halts were for reasons other than GC. The halts ratio for the entire recording was 0 %. 0 % of the total halts were for reasons other than GC.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>BufferLost<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No Flight Recorder buffers were lost during the recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>BytecodeVerification<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The application ran with bytecode verification enabled.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLeak<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLoading<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CodeCache<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CompareCpu<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CompressedOops<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The settings for Compressed Oops were OK.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>ContextSwitch<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DMSIncident<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DebugNonSafepoints<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DiscouragedVmOptions<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No problems were found with the VM options.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>DumpReason<\/id>\n+            <severity>Warning<\/severity>\n+            <summary>This recording was dumped for an exceptional reason.<\/summary>\n+            <explanation>Recording was dumped due to a JVM crash. Some events are likely missing from the end of the recording.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>DuplicateFlags<\/id>\n+            <severity>OK<\/severity>\n+            <summary>There were no duplicate JVM flags on the command line.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>DynamicAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Exceptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Fatal Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FewSampledThreads<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FileForce<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FileRead<\/id>\n+            <severity>OK<\/severity>\n+            <summary>There are no file read events in this recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>FileWrite<\/id>\n+            <severity>OK<\/severity>\n+            <summary>There are no file write events in this recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>FinalizersRun<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FlightRecordingSupport<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The JVM version used for this recording has full Flight Recorder support.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>FullGc<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No Stop-the-World, Full GC events detected.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>GarbageCollectionInfoRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcFreedRatio<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcOptions<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No problems were found with the GC configuration.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseRatio<\/id>\n+            <severity>OK<\/severity>\n+            <summary>Application efficiency was not highly affected by GC pauses.<\/summary>\n+            <explanation>The highest ratio between garbage collection pauses and execution time was 0 % during 4\/24\/2018 10:16:27.000 AM – 10:17:27 AM. The garbage collection pause ratio of the entire recording was 0 %.<\/explanation>\n+            <solution>Pause times may be reduced by increasing the heap size or by trying to reduce allocation.<\/solution>\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HeapContent<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HeapDump<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HighGc<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The runtime did not spend much time performing garbage collections.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>HighJvmCpu<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingLiveSet<\/id>\n+            <severity>Not Applicable<\/severity>\n+            <summary>Too few events to calculate the result.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingMetaSpaceLiveSet<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The class data does not seem to increase during the recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>JavaBlocking<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>LongGcPause<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The application did not cause any long GC pause times.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>LowOnPhysicalMemory<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The maximum amount of used memory was 88.9 % of the physical memory available.<\/summary>\n+            <explanation>The maximum amount of memory used was 28.4 GiB. This is 88.9 % of the 31.9 GiB of physical memory available. Having little free memory may lead to swapping, which is very expensive. To avoid this, either decrease the memory usage or increase the amount of available memory.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>ManagementAgent<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ManyRunningProcesses<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MetaspaceOom<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The metaspace was not exhausted during this recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>MethodProfiling<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No methods where optimization would be particularly efficient could be detected.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>MultipleAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Options<\/id>\n+            <severity>OK<\/severity>\n+            <summary>Deprecated option flags were detected.<\/summary>\n+            <explanation>The following option flag is or will be deprecated. &lt;ul&gt;&lt;li&gt;-XX:+UnlockCommercialFeatures: Deprecated in Java 11.&lt;\/li&gt;&lt;\/ul&gt; Deprecated option flags should be avoided. In some cases they enable legacy code and in other cases they are ignored completely. They will usually be removed in a later Java release.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>OverAggressiveRecordingSetting<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInArguments<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The recording does not seem to contain passwords in the application arguments.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInEnvironment<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInSystemProperties<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PrimitiveToObjectConversion<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ProcessStarted<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SocketRead<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SocketWrite<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>StackdepthSetting<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No stack traces were truncated in this recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>StringDeduplication<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>TlabAllocationRatio<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>VMOperations<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No excessively long VM operations were found in this recording (the longest was 0 s).<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocation<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocationPause<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No revocation of biased locks found.<\/summary>\n+        <\/rule>\n+    <\/report>\n+    <report>\n+        <file>dominating_thread_allocation.jfr<\/file>\n+        <rule>\n+            <id>Allocations.class<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The most allocated type is likely ''byte[]'', most commonly allocated by: &lt;ul&gt;&lt;li&gt;void Main$AllocatingThread.run()&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Frequently allocated types are good places to start when trying to reduce garbage collections. Look at where the most common types are being allocated to see if many instances are created along the same call path. Try to reduce the number of instances created by invoking the most commonly taken paths less.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>Allocations.thread<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The most allocations were likely done by thread ''high-allocation'' at: &lt;ul&gt;&lt;li&gt;void Main$AllocatingThread.run()&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Many allocations performed by the same thread might indicate a problem in a multi-threaded program. Look at the stack traces for the thread with the highest allocation rate. See if the allocation rate can be brought down, or balanced among the active threads.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>ApplicationHalts<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>BufferLost<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No Flight Recorder buffers were lost during the recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>BytecodeVerification<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLeak<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLoading<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CodeCache<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CompareCpu<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CompressedOops<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ContextSwitch<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DMSIncident<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DebugNonSafepoints<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DiscouragedVmOptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DumpReason<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DuplicateFlags<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DynamicAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Exceptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Fatal Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FewSampledThreads<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FileForce<\/id>\n@@ -631,1 +1545,1 @@\n-            <id>Allocations.thread<\/id>\n+            <id>FileRead<\/id>\n@@ -635,1 +1549,122 @@\n-            <id>ApplicationHalts<\/id>\n+            <id>FileWrite<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FinalizersRun<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FlightRecordingSupport<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FullGc<\/id>\n+            <severity>Not Applicable<\/severity>\n+            <summary>This rule is only valid for CMS and G1 Garbage Collectors, neither of which were detected for this JVM.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>GarbageCollectionInfoRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcFreedRatio<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcOptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseRatio<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HeapContent<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HeapDump<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HighGc<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HighJvmCpu<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingLiveSet<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingMetaSpaceLiveSet<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>JavaBlocking<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>LongGcPause<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>LowOnPhysicalMemory<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ManagementAgent<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ManyRunningProcesses<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MetaspaceOom<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MethodProfiling<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MultipleAgents<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Options<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>OverAggressiveRecordingSetting<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInArguments<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInEnvironment<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInSystemProperties<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PrimitiveToObjectConversion<\/id>\n@@ -637,2 +1672,61 @@\n-            <summary>Application efficiency was not highly affected by halts.<\/summary>\n-            <explanation>The highest ratio of application halts to execution time was 0 % during 4\/24\/2018 10:16:27.000 AM – 10:17:27 AM. 0 % of the halts were for reasons other than GC. The halts ratio for the entire recording was 0 %. 0 % of the total halts were for reasons other than GC.<\/explanation>\n+            <summary>No allocation was caused by conversion from primitive types to the corresponding object types.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>ProcessStarted<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SocketRead<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SocketWrite<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>StackdepthSetting<\/id>\n+            <severity>OK<\/severity>\n+            <summary>Some stack traces were truncated in this recording.<\/summary>\n+            <explanation>The Flight Recorder is configured with a maximum captured stack depth of 64. 0.0801 % of all traces were larger than this option, and were therefore truncated. If more detailed traces are required, increase the ''-XX:FlightRecorderOptions=stackdepth=&lt;value&gt;'' value.\n+Events of the following types have truncated stack traces: &lt;ul&gt;&lt;li&gt;Allocation in new TLAB (6.4 % truncated traces)&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>StringDeduplication<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>TlabAllocationRatio<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The program allocated 96.1 % of the memory outside of TLABs.<\/summary>\n+            <solution>Allocating objects outside of Thread Local Allocation Buffers (TLABs) is more expensive than allocating inside TLABs. This may be acceptable if the individual allocations are intended to be larger than a reasonable TLAB. It may be possible to avoid this by decreasing the size of the individual allocations. There are some TLAB related JVM flags that you can experiment with, but it is usually better to let the JVM manage TLAB sizes automatically.<\/solution>\n+        <\/rule>\n+        <rule>\n+            <id>VMOperations<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocation<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocationPause<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+    <\/report>\n+    <report>\n+        <file>dominating_thread_allocation_sample.jfr<\/file>\n+        <rule>\n+            <id>Allocations.class<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The most allocated type is likely ''byte[]'', most commonly allocated by: &lt;ul&gt;&lt;li&gt;void Main$AllocatingThread.run()&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Frequently allocated types are good places to start when trying to reduce garbage collections. Look at where the most common types are being allocated to see if many instances are created along the same call path. Try to reduce the number of instances created by invoking the most commonly taken paths less.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>Allocations.thread<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The most allocations were likely done by thread ''high-allocation'' at: &lt;ul&gt;&lt;li&gt;void Main$AllocatingThread.run()&lt;\/li&gt;&lt;\/ul&gt;<\/summary>\n+            <explanation>Many allocations performed by the same thread might indicate a problem in a multi-threaded program. Look at the stack traces for the thread with the highest allocation rate. See if the allocation rate can be brought down, or balanced among the active threads.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>ApplicationHalts<\/id>\n+            <severity>Not Applicable<\/severity>\n@@ -647,2 +1741,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The application ran with bytecode verification enabled.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -668,2 +1761,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The settings for Compressed Oops were OK.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -685,2 +1777,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No problems were found with the VM options.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -690,3 +1781,1 @@\n-            <severity>Warning<\/severity>\n-            <summary>This recording was dumped for an exceptional reason.<\/summary>\n-            <explanation>Recording was dumped due to a JVM crash. Some events are likely missing from the end of the recording.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -696,2 +1785,1 @@\n-            <severity>OK<\/severity>\n-            <summary>There were no duplicate JVM flags on the command line.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -725,2 +1813,1 @@\n-            <severity>OK<\/severity>\n-            <summary>There are no file read events in this recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -730,2 +1817,1 @@\n-            <severity>OK<\/severity>\n-            <summary>There are no file write events in this recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -739,2 +1825,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The JVM version used for this recording has full Flight Recorder support.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -744,2 +1829,2 @@\n-            <severity>OK<\/severity>\n-            <summary>No Stop-the-World, Full GC events detected.<\/summary>\n+            <severity>Not Applicable<\/severity>\n+            <summary>This rule is only valid for CMS and G1 Garbage Collectors, neither of which were detected for this JVM.<\/summary>\n@@ -761,2 +1846,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No problems were found with the GC configuration.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -766,4 +1850,1 @@\n-            <severity>OK<\/severity>\n-            <summary>Application efficiency was not highly affected by GC pauses.<\/summary>\n-            <explanation>The highest ratio between garbage collection pauses and execution time was 0 % during 4\/24\/2018 10:16:27.000 AM – 10:17:27 AM. The garbage collection pause ratio of the entire recording was 0 %.<\/explanation>\n-            <solution>Pause times may be reduced by increasing the heap size or by trying to reduce allocation.<\/solution>\n+            <severity>Not Applicable<\/severity>\n@@ -785,2 +1866,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The runtime did not spend much time performing garbage collections.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -795,1 +1875,0 @@\n-            <summary>Too few events to calculate the result.<\/summary>\n@@ -799,2 +1878,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The class data does not seem to increase during the recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -808,2 +1886,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The version of Java you are running is not affected by a performance issue related to periodic events.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -813,2 +1890,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The application did not cause any long GC pause times.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -818,3 +1894,1 @@\n-            <severity>Information<\/severity>\n-            <summary>The maximum amount of used memory was 88.9 % of the physical memory available.<\/summary>\n-            <explanation>The maximum amount of memory used was 28.4 GiB. This is 88.9 % of the 31.9 GiB of physical memory available. Having little free memory may lead to swapping, which is very expensive. To avoid this, either decrease the memory usage or increase the amount of available memory.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -832,2 +1906,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The metaspace was not exhausted during this recording.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -837,2 +1910,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No methods where optimization would be particularly efficient could be detected.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -846,3 +1918,1 @@\n-            <severity>OK<\/severity>\n-            <summary>Deprecated option flags were detected.<\/summary>\n-            <explanation>The following option flag is or will be deprecated. &lt;ul&gt;&lt;li&gt;-XX:+UnlockCommercialFeatures: Deprecated in Java 11.&lt;\/li&gt;&lt;\/ul&gt; Deprecated option flags should be avoided. In some cases they enable legacy code and in other cases they are ignored completely. They will usually be removed in a later Java release.<\/explanation>\n+            <severity>Not Applicable<\/severity>\n@@ -856,2 +1926,1 @@\n-            <severity>OK<\/severity>\n-            <summary>The recording does not seem to contain passwords in the application arguments.<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -869,1 +1938,2 @@\n-            <severity>Not Applicable<\/severity>\n+            <severity>OK<\/severity>\n+            <summary>No allocation was caused by conversion from primitive types to the corresponding object types.<\/summary>\n@@ -886,1 +1956,3 @@\n-            <summary>No stack traces were truncated in this recording.<\/summary>\n+            <summary>Some stack traces were truncated in this recording.<\/summary>\n+            <explanation>The Flight Recorder is configured with a maximum captured stack depth of 64. 0.22 % of all traces were larger than this option, and were therefore truncated. If more detailed traces are required, increase the ''-XX:FlightRecorderOptions=stackdepth=&lt;value&gt;'' value.\n+Events of the following types have truncated stack traces: &lt;ul&gt;&lt;li&gt;Object Allocation Sample (0.22 % truncated traces)&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n@@ -898,2 +1970,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No excessively long VM operations were found in this recording (the longest was 0 s).<\/summary>\n+            <severity>Not Applicable<\/severity>\n@@ -907,2 +1978,1 @@\n-            <severity>OK<\/severity>\n-            <summary>No revocation of biased locks found.<\/summary>\n+            <severity>Not Applicable<\/severity>\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/baseline\/JfrRuleBaseline.xml","additions":1127,"deletions":57,"binary":false,"changes":1184,"status":"modified"},{"filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/jfr\/autobox_allocation.jfr","binary":true,"status":"added"},{"filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/jfr\/autobox_allocation_sample.jfr","binary":true,"status":"added"},{"filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/jfr\/dominating_thread_allocation.jfr","binary":true,"status":"added"},{"filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/jfr\/dominating_thread_allocation_sample.jfr","binary":true,"status":"added"},{"patch":"@@ -3,0 +3,2 @@\n+autobox_allocation.jfr\n+autobox_allocation_sample.jfr\n@@ -4,0 +6,2 @@\n+dominating_thread_allocation.jfr\n+dominating_thread_allocation_sample.jfr\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/jfr\/index.txt","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}