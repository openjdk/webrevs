{"files":[{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+\n+final class AnnotationValueObject {\n+\tfinal Type annotationType;\n+\tfinal String annotationValue;\n+\n+\tpublic AnnotationValueObject(Type annotationType, String value) {\n+\t\tthis.annotationType = annotationType;\n+\t\tthis.annotationValue = value;\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/AnnotationValueObject.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Datadog, Inc. All rights reserved.\n@@ -39,0 +39,4 @@\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n@@ -40,0 +44,1 @@\n+import java.util.HashMap;\n@@ -41,0 +46,1 @@\n+import java.util.Map;\n@@ -50,0 +56,2 @@\n+import java.util.logging.Logger;\n+import java.util.logging.Level;\n@@ -54,0 +62,1 @@\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n@@ -55,0 +64,1 @@\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedFieldBuilder;\n@@ -56,0 +66,1 @@\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedValueBuilder;\n@@ -58,0 +69,5 @@\n+import jdk.jfr.Event;\n+import jdk.jfr.Name;\n+import jdk.jfr.StackTrace;\n+import jdk.jfr.Timestamp;\n+\n@@ -63,0 +79,2 @@\n+\tprivate static final Logger LOGGER = Logger.getLogger(RecordingImpl.class.getName());\n+\n@@ -103,0 +121,7 @@\n+\t\/\/ a cache to hold already computed stack frames\n+\tprivate final Map<StackTraceElement, TypedValue> frameCache = new HashMap<>(16000);\n+\t\/\/ a cache to hold already resolved class loaders\n+\tprivate final Map<String, TypedValue> classLoaderCache = new HashMap<>(128);\n+\t\/\/ a cache to hold already resolved modules\n+\tprivate final Map<String, TypedValue> moduleCache = new HashMap<>(4096);\n+\n@@ -273,0 +298,352 @@\n+\t@Override\n+\tpublic TypeImpl registerEventType(Class<? extends Event> eventType) {\n+\t\t\/*\n+\t\t * JMC implementation is slightly mishandling some event types - not using the special call\n+\t\t * and rather registering all implicit fields by hand.\n+\t\t *\/\n+\t\treturn registerType(getEventName(eventType), \"jdk.jfr.Event\", b -> {\n+\t\t\tField[] fields = eventType.getDeclaredFields();\n+\n+\t\t\tboolean eventThredOverride = false;\n+\t\t\tboolean stackTraceOverride = false;\n+\t\t\tboolean startTimeOverride = false;\n+\t\t\tfor (Field f : fields) {\n+\t\t\t\tif (Modifier.isTransient(f.getModifiers()) || Modifier.isStatic(f.getModifiers())) {\n+\t\t\t\t\t\/\/ skip static and transient fields\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\t\/\/ Add field definition\n+\t\t\t\tTypeImpl fieldType = types.getType(f.getType().getName());\n+\t\t\t\tif (fieldType != null) {\n+\t\t\t\t\tjava.lang.annotation.Annotation[] as = f.getAnnotations();\n+\t\t\t\t\tString fieldName = getFieldName(f);\n+\t\t\t\t\tif (fieldName.equals(\"startTime\")) {\n+\t\t\t\t\t\tstartTimeOverride = true;\n+\t\t\t\t\t} else if (fieldName.equals(\"eventThread\")) {\n+\t\t\t\t\t\teventThredOverride = true;\n+\t\t\t\t\t} else if (fieldName.equals(\"stackTrace\")) {\n+\t\t\t\t\t\tstackTraceOverride = true;\n+\t\t\t\t\t}\n+\t\t\t\t\tTypedFieldBuilder fieldTypeBuilder = types.fieldBuilder(fieldName, fieldType);\n+\n+\t\t\t\t\tboolean foundTimestampAnnotation = false;\n+\t\t\t\t\tfor (java.lang.annotation.Annotation a : as) {\n+\t\t\t\t\t\tif (a.getClass().equals(Timestamp.class)) {\n+\t\t\t\t\t\t\tfoundTimestampAnnotation = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tAnnotationValueObject val = processAnnotation(types, a);\n+\t\t\t\t\t\tif (val != null) {\n+\t\t\t\t\t\t\tfieldTypeBuilder = val.annotationValue != null\n+\t\t\t\t\t\t\t\t\t? fieldTypeBuilder.addAnnotation(val.annotationType, val.annotationValue)\n+\t\t\t\t\t\t\t\t\t: fieldTypeBuilder.addAnnotation(val.annotationType);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (fieldName.equals(\"startTime\") && !foundTimestampAnnotation) {\n+\t\t\t\t\t\t\/\/ make sure that even the overridden startTime field has a @Timestamp annotation\n+\t\t\t\t\t\tfieldTypeBuilder.addAnnotation(Types.JDK.ANNOTATION_TIMESTAMP, \"NANOSECONDS_SINCE_EPOCH\");\n+\t\t\t\t\t}\n+\t\t\t\t\tb.addField(fieldTypeBuilder.build());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (!startTimeOverride) {\n+\t\t\t\t\/\/ force 'startTime' field\n+\t\t\t\tb.addField(\"startTime\", Types.Builtin.LONG,\n+\t\t\t\t\t\tfield -> field.addAnnotation(Types.JDK.ANNOTATION_TIMESTAMP, \"NANOSECONDS_SINCE_EPOCH\"));\n+\t\t\t}\n+\t\t\tif (!eventThredOverride) {\n+\t\t\t\t\/\/ force 'eventThread' field\n+\t\t\t\tb.addField(\"eventThread\", Types.JDK.THREAD);\n+\t\t\t}\n+\t\t\tif (!stackTraceOverride) {\n+\t\t\t\t\/\/ force 'stackTrace' field if the event is collecting stacktraces\n+\t\t\t\tif (hasStackTrace(eventType)) {\n+\t\t\t\t\tb.addField(\"stackTrace\", Types.JDK.STACK_TRACE);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfor (java.lang.annotation.Annotation a : eventType.getAnnotations()) {\n+\t\t\t\tAnnotationValueObject val = processAnnotation(types, a);\n+\t\t\t\tif (val != null) {\n+\t\t\t\t\tb = val.annotationValue != null ? b.addAnnotation(val.annotationType, val.annotationValue)\n+\t\t\t\t\t\t\t: b.addAnnotation(val.annotationType);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\t@Override\n+\tpublic RecordingImpl writeEvent(Event event) {\n+\t\tregisterEventType(event.getClass());\n+\t\twriteEvent(createEventValue(event));\n+\t\treturn this;\n+\t}\n+\n+\tprivate String getEventName(Class<? extends Event> eventType) {\n+\t\tName nameAnnotation = eventType.getAnnotation(Name.class);\n+\t\tif (nameAnnotation != null) {\n+\t\t\treturn nameAnnotation.value();\n+\t\t}\n+\t\treturn eventType.getSimpleName();\n+\t}\n+\n+\tprivate String getFieldName(Field fld) {\n+\t\tName nameAnnotation = fld.getAnnotation(Name.class);\n+\t\tif (nameAnnotation != null) {\n+\t\t\treturn nameAnnotation.value();\n+\t\t}\n+\t\treturn fld.getName();\n+\t}\n+\n+\tprivate boolean hasStackTrace(Class<? extends Event> eventType) {\n+\t\tStackTrace stAnnotation = eventType.getAnnotation(StackTrace.class);\n+\t\tif (stAnnotation != null) {\n+\t\t\treturn stAnnotation.value();\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprivate TypedValue createEventValue(Event event) {\n+\t\tType eventType = getType(getEventName(event.getClass()));\n+\t\tField[] fields = event.getClass().getDeclaredFields();\n+\n+\t\tTypedValue typedValue = eventType.asValue(access -> {\n+\t\t\tboolean startTimeWritten = false;\n+\t\t\tboolean eventThreadWritten = false;\n+\t\t\tboolean stackTraceWritten = false;\n+\t\t\tfor (Field f : fields) {\n+\t\t\t\tf.setAccessible(true);\n+\n+\t\t\t\t\/*\n+\t\t\t\t * From jdk.jfr.Event.java: Supported field types are the Java primitives: {@code\n+\t\t\t\t * boolean}, {@code char}, {@code byte}, {@code short}, {@code int}, {@code long},\n+\t\t\t\t * {@code float}, and {@code double}. Supported reference types are: {@code String},\n+\t\t\t\t * {@code Thread} and {@code Class}. Arrays, enums, and other reference types are\n+\t\t\t\t * silently ignored and not included. Fields that are of the supported types can be\n+\t\t\t\t * excluded by using the transient modifier. Static fields, even of the supported\n+\t\t\t\t * types, are not included.\n+\t\t\t\t *\/\n+\t\t\t\t\/\/ Transient and static fields are excluded\n+\t\t\t\tif (Modifier.isTransient(f.getModifiers()) || Modifier.isStatic(f.getModifiers())) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tString fldName = getFieldName(f);\n+\t\t\t\tif (fldName.equals(\"startTime\")) {\n+\t\t\t\t\tstartTimeWritten = true;\n+\t\t\t\t} else if (fldName.equals(\"eventThread\")) {\n+\t\t\t\t\teventThreadWritten = true;\n+\t\t\t\t} else if (fldName.equals(\"stackTrace\")) {\n+\t\t\t\t\tstackTraceWritten = true;\n+\t\t\t\t}\n+\t\t\t\ttry {\n+\t\t\t\t\tswitch (f.getType().getName()) {\n+\t\t\t\t\tcase \"byte\": {\n+\t\t\t\t\t\tbyte byteValue = f.getByte(event);\n+\t\t\t\t\t\taccess.putField(fldName, byteValue);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase \"char\": {\n+\t\t\t\t\t\tchar charValue = f.getChar(event);\n+\t\t\t\t\t\taccess.putField(fldName, charValue);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase \"short\": {\n+\t\t\t\t\t\tshort shortValue = f.getShort(event);\n+\t\t\t\t\t\taccess.putField(fldName, shortValue);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase \"int\": {\n+\t\t\t\t\t\tint intValue = f.getInt(event);\n+\t\t\t\t\t\taccess.putField(fldName, intValue);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase \"long\": {\n+\t\t\t\t\t\tlong longValue = f.getLong(event);\n+\t\t\t\t\t\taccess.putField(fldName, longValue);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase \"float\": {\n+\t\t\t\t\t\tfloat floatValue = f.getFloat(event);\n+\t\t\t\t\t\taccess.putField(fldName, floatValue);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase \"double\": {\n+\t\t\t\t\t\tdouble doubleValue = f.getDouble(event);\n+\t\t\t\t\t\taccess.putField(fldName, doubleValue);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase \"boolean\": {\n+\t\t\t\t\t\tboolean booleanValue = f.getBoolean(event);\n+\t\t\t\t\t\taccess.putField(fldName, booleanValue);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase \"java.lang.String\": {\n+\t\t\t\t\t\tString stringValue = (String) f.get(event);\n+\t\t\t\t\t\taccess.putField(fldName, stringValue);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase \"java.lang.Class\": {\n+\t\t\t\t\t\tClass<?> clz = (Class<?>) f.get(event);\n+\t\t\t\t\t\taccess.putField(fldName, fldAccess -> {\n+\t\t\t\t\t\t\tfldAccess.putField(\"name\", nameAccess -> {\n+\t\t\t\t\t\t\t\tnameAccess.putField(\"string\", clz.getSimpleName());\n+\t\t\t\t\t\t\t}).putField(\"package\", clz.getPackage().getName()).putField(\"modifiers\",\n+\t\t\t\t\t\t\t\t\tclz.getModifiers());\n+\t\t\t\t\t\t});\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase \"java.lang.Thread\": {\n+\t\t\t\t\t\tThread thrd = (Thread) f.get(event);\n+\t\t\t\t\t\tputThreadField(access, fldName, thrd);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase \"java.lang.StackTraceElement[]\": {\n+\t\t\t\t\t\tStackTraceElement[] stackTrace = (StackTraceElement[]) f.get(event);\n+\t\t\t\t\t\tputStackTraceField(access, fldName, stackTrace);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tdefault: {\n+\t\t\t\t\t\tLOGGER.log(Level.WARNING, \"Cannot write type:\" + f.getType().getName());\n+\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t} catch (IllegalAccessException e) {\n+\t\t\t\t\tthrow new RuntimeException();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (!startTimeWritten) {\n+\t\t\t\t\/\/ default to 0\n+\t\t\t\taccess.putField(\"startTime\", 0L);\n+\t\t\t}\n+\t\t\tif (!eventThreadWritten) {\n+\t\t\t\t\/\/ default to current thread\n+\t\t\t\tputThreadField(access, \"eventThread\", Thread.currentThread());\n+\t\t\t}\n+\t\t\tif (!stackTraceWritten && hasStackTrace(event.getClass())) {\n+\t\t\t\tputStackTraceField(access, \"stackTrace\", Thread.currentThread().getStackTrace());\n+\t\t\t}\n+\t\t});\n+\n+\t\treturn typedValue;\n+\t}\n+\n+\tprivate void putThreadField(TypedValueBuilder access, String fldName, Thread thread) {\n+\t\taccess.putField(fldName, fldAccess -> {\n+\t\t\tfldAccess.putField(\"javaThreadId\", thread.getId()).putField(\"osThreadId\", thread.getId())\n+\t\t\t\t\t.putField(\"javaName\", thread.getName());\n+\t\t});\n+\t}\n+\n+\tprivate void putStackTraceField(TypedValueBuilder access, String fldName, StackTraceElement[] stackTrace) {\n+\t\tTypes types = access.getType().getTypes();\n+\t\tTypedValue[] frames = new TypedValue[stackTrace.length];\n+\t\tboolean[] truncated = new boolean[] {false};\n+\t\tfor (int i = 0; i < stackTrace.length; i++) {\n+\t\t\tframes[i] = asStackFrame(types, stackTrace[i]);\n+\t\t\tif (i >= 8192) {\n+\t\t\t\ttruncated[0] = true;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\taccess.putField(fldName, p -> {\n+\t\t\tp.putField(\"frames\", frames).putField(\"truncated\", truncated[0]);\n+\t\t});\n+\t}\n+\n+\tprivate TypedValue asStackFrame(Types types, StackTraceElement element) {\n+\t\treturn frameCache.computeIfAbsent(element, k -> types.getType(Types.JDK.STACK_FRAME).asValue(p -> {\n+\t\t\tp.putField(\"method\", methodValue(types, k)).putField(\"lineNumber\", k.getLineNumber())\n+\t\t\t\t\t.putField(\"bytecodeIndex\", -1).putField(\"type\", k.isNativeMethod() ? \"native\" : \"java\");\n+\t\t}));\n+\t}\n+\n+\tprivate TypedValue methodValue(Types types, StackTraceElement element) {\n+\t\treturn types.getType(Types.JDK.METHOD).asValue(p -> {\n+\t\t\tp.putField(\"type\", classValue(types, element)).putField(\"name\", element.getMethodName());\n+\t\t});\n+\t}\n+\n+\tprivate TypedValue classValue(Types types, StackTraceElement element) {\n+\t\treturn types.getType(Types.JDK.CLASS).asValue(p -> {\n+\t\t\tp.putField(\"classLoader\", classLoaderValue(types, element.getClassLoaderName()))\n+\t\t\t\t\t.putField(\"name\", getSimpleName(element.getClassName())).putField(\"package\",\n+\t\t\t\t\t\t\tpackageValue(types, getPackageName(element.getClassName()), element.getModuleName()));\n+\t\t});\n+\t}\n+\n+\tprivate TypedValue classLoaderValue(Types types, String classLoaderName) {\n+\t\treturn classLoaderCache.computeIfAbsent(classLoaderName,\n+\t\t\t\tk -> types.getType(Types.JDK.CLASS_LOADER).asValue(p -> {\n+\t\t\t\t\tp.putField(\"name\", k);\n+\t\t\t\t}));\n+\t}\n+\n+\tprivate TypedValue packageValue(Types types, String packageName, String module) {\n+\t\treturn types.getType(Types.JDK.PACKAGE).asValue(p -> {\n+\t\t\tp.putField(\"name\", packageName).putField(\"module\", moduleValue(types, module));\n+\t\t});\n+\t}\n+\n+\tprivate TypedValue moduleValue(Types types, String module) {\n+\t\treturn moduleCache.computeIfAbsent(module, k -> types.getType(Types.JDK.MODULE).asValue(p -> {\n+\t\t\tp.putField(\"name\", k);\n+\t\t}));\n+\t}\n+\n+\tprivate String getSimpleName(String className) {\n+\t\treturn className.substring(className.lastIndexOf('.') + 1);\n+\t}\n+\n+\tprivate String getPackageName(String className) {\n+\t\tint idx = className.lastIndexOf('.');\n+\t\tif (idx > -1) {\n+\t\t\treturn className.substring(0, idx);\n+\t\t}\n+\t\treturn \"\";\n+\t}\n+\n+\tprivate AnnotationValueObject processAnnotation(Types types, java.lang.annotation.Annotation annotation) {\n+\t\t\/\/ skip non-JFR related annotations\n+\t\tif (!isJfrAnnotation(annotation)) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tif (annotation instanceof Name) {\n+\t\t\t\/\/ skip @Name annotation\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tString value = null;\n+\t\ttry {\n+\t\t\tMethod m = annotation.getClass().getMethod(\"value\");\n+\t\t\tif (!String.class.isAssignableFrom(m.getReturnType())) {\n+\t\t\t\t\/\/ wrong value type\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tvalue = (String) m.invoke(annotation);\n+\t\t} catch (NoSuchMethodException ignored) {\n+\t\t\t\/\/ no-value annotations are also permitted\n+\t\t} catch (SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {\n+\t\t\t\/\/ error retrieving value attribute\n+\t\t\treturn null;\n+\t\t}\n+\t\tString annotationValue = value;\n+\t\tString annotationTypeName = annotation.annotationType().getTypeName();\n+\t\tType annotationType = types.getOrAdd(annotationTypeName, Annotation.ANNOTATION_SUPER_TYPE_NAME, builder -> {\n+\t\t\tif (annotationValue != null) {\n+\t\t\t\tbuilder.addField(\"value\", Types.Builtin.STRING);\n+\t\t\t}\n+\t\t});\n+\t\treturn new AnnotationValueObject(annotationType, annotationValue);\n+\t}\n+\n+\tprivate boolean isJfrAnnotation(java.lang.annotation.Annotation target) {\n+\t\tString typeName = target.annotationType().getName();\n+\t\tif (typeName.startsWith(\"jdk.jfr.\")) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tfor (java.lang.annotation.Annotation annotation : target.annotationType().getAnnotations()) {\n+\t\t\tif (isJfrAnnotation(annotation)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/RecordingImpl.java","additions":379,"deletions":2,"binary":false,"changes":381,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Datadog, Inc. All rights reserved.\n@@ -42,0 +42,2 @@\n+import jdk.jfr.Event;\n+\n@@ -56,0 +58,10 @@\n+\t\/**\n+\t * Write a custom event defined as an instance of a {@link jdk.jfr.Event jfr event} subclass. If\n+\t * the event type has not been registered yet, it will be registered.\n+\t * \n+\t * @param event\n+\t *            the event instance\n+\t * @return {@literal this} for chaining\n+\t *\/\n+\tpublic abstract RecordingImpl writeEvent(Event event);\n+\n@@ -66,0 +78,10 @@\n+\t\/**\n+\t * Try registering a user event type described by the custom {@link jdk.jfr.Event event} class.\n+\t * If a same-named event already exists it will be returned.\n+\t * \n+\t * @param eventType\n+\t *            the JFR event class\n+\t * @return a corresponding user event type\n+\t *\/\n+\tpublic abstract Type registerEventType(Class<? extends Event> eventType);\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/Recording.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Datadog, Inc. All rights reserved.\n@@ -39,0 +39,1 @@\n+import static org.junit.jupiter.api.Assertions.assertNull;\n@@ -45,0 +46,1 @@\n+import java.util.List;\n@@ -47,0 +49,9 @@\n+import jdk.jfr.Event;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.Registered;\n+import jdk.jfr.StackTrace;\n+import jdk.jfr.Timestamp;\n+import jdk.jfr.Timespan;\n+\n@@ -54,0 +65,9 @@\n+import org.openjdk.jmc.common.item.Attribute;\n+import org.openjdk.jmc.common.item.IAttribute;\n+import org.openjdk.jmc.common.item.IItem;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.item.IItemIterable;\n+import org.openjdk.jmc.common.item.IType;\n+import org.openjdk.jmc.common.unit.IQuantity;\n+import org.openjdk.jmc.common.unit.UnitLookup;\n+import org.openjdk.jmc.flightrecorder.JfrLoaderToolkit;\n@@ -59,0 +79,1 @@\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedField;\n@@ -63,0 +84,41 @@\n+\t@Label(\"Simple Test Event\")\n+\t@Registered(true)\n+\t@Enabled(false)\n+\tpublic static final class SimpleTestEvent extends Event {\n+\t\t@Label(\"field\")\n+\t\tpublic String fld;\n+\n+\t\t@Timestamp\n+\t\tpublic long timestamp;\n+\n+\t\t@Timespan\n+\t\tpublic long timespan;\n+\n+\t\t@Label(\"static\")\n+\t\tpublic static int staticFld;\n+\t\t@Label(\"transient\")\n+\t\tpublic transient char transientFld;\n+\t}\n+\n+\t@StackTrace(true)\n+\tpublic static final class EventWithStackTrace extends Event {\n+\n+\t}\n+\n+\t@Label(\"Named Test Event\")\n+\t@Name(\"jmc.TestEvent\")\n+\tpublic static final class TestEventWithName extends Event {\n+\t\t@Label(\"field\")\n+\t\tpublic String fld;\n+\t}\n+\n+\tpublic static final class EventWithOverrides extends Event {\n+\t\t@Name(\"startTime\")\n+\t\t@Label(\"overridden timestamp\")\n+\t\t@Timestamp\n+\t\tpublic long timestamp;\n+\n+\t\t@Label(\"overridden thread\")\n+\t\tpublic Thread eventThread;\n+\t}\n+\n@@ -108,1 +170,1 @@\n-\t\tassertThrows(IllegalArgumentException.class, () -> recording.registerEventType(null));\n+\t\tassertThrows(IllegalArgumentException.class, () -> recording.registerEventType((String) null));\n@@ -150,0 +212,128 @@\n+\t@Test\n+\tvoid registerSimpleJfrEvent() {\n+\t\tTypeImpl eventType = recording.registerEventType(SimpleTestEvent.class);\n+\t\tassertNotNull(eventType);\n+\t\tassertEquals(SimpleTestEvent.class.getSimpleName(), eventType.getTypeName());\n+\n+\t\t\/\/ make sure the following two fields are implicitly added and properly labelled\n+\t\tassertFieldAnnotatedBy(eventType, \"startTime\", Timestamp.class.getName());\n+\t\tassertNotNull(eventType.getField(\"eventThread\"));\n+\n+\t\tassertFieldAnnotatedBy(eventType, \"fld\", Label.class.getName());\n+\t\tassertFieldAnnotatedBy(eventType, \"timestamp\", Timestamp.class.getName());\n+\t\tassertFieldAnnotatedBy(eventType, \"timespan\", Timespan.class.getName());\n+\n+\t\t\/\/ make sure that static and transient fields are ignored\n+\t\tassertNull(eventType.getField(\"staticFld\"));\n+\t\tassertNull(eventType.getField(\"transientFld\"));\n+\t}\n+\n+\t@Test\n+\tvoid registerEventWithStackTrace() {\n+\t\tTypeImpl eventType = recording.registerEventType(EventWithStackTrace.class);\n+\t\tassertNotNull(eventType);\n+\t\tassertEquals(EventWithStackTrace.class.getSimpleName(), eventType.getTypeName());\n+\n+\t\tTypedField stackTrace = eventType.getField(\"stackTrace\");\n+\t\tassertNotNull(stackTrace);\n+\t\tassertEquals(Types.JDK.STACK_TRACE.getTypeName(), stackTrace.getType().getTypeName());\n+\t}\n+\n+\t@Test\n+\tvoid registerEventWithOverrides() {\n+\t\tTypeImpl eventType = recording.registerEventType(EventWithOverrides.class);\n+\t\tassertNotNull(eventType);\n+\n+\t\t\/\/ make sure the @Timestamp annotation is preserved here\n+\t\tassertFieldAnnotatedBy(eventType, \"startTime\", Timestamp.class.getName());\n+\n+\t\t\/\/ the overridden fields have extra @Label annotation\n+\t\tassertFieldAnnotatedBy(eventType, \"startTime\", Label.class.getName());\n+\t\tassertFieldAnnotatedBy(eventType, \"eventThread\", Label.class.getName());\n+\n+\t}\n+\n+\t@Test\n+\tvoid registerJfrEventTypeWithCustomName() {\n+\t\tTypeImpl eventType = recording.registerEventType(TestEventWithName.class);\n+\t\tassertNotNull(eventType);\n+\t\tassertEquals(\"jmc.TestEvent\", eventType.getTypeName());\n+\t\tList<Annotation> annotations = eventType.getAnnotations();\n+\t\tassertNotNull(annotations);\n+\n+\t\tassertTypeAnnotatedBy(eventType, Label.class.getName());\n+\t\tassertTypeNotAnnotatedBy(eventType, Name.class.getName());\n+\t}\n+\n+\tprivate static void assertTypeAnnotatedBy(TypeImpl eventType, String expectedAnnotationType) {\n+\t\tList<Annotation> annotations = eventType.getAnnotations();\n+\t\tassertNotNull(annotations);\n+\t\tassertTrue(annotations.stream().anyMatch(a -> a.getType().getTypeName().equals(expectedAnnotationType)),\n+\t\t\t\t\"Type '\" + eventType.getTypeName() + \"' is missing the expected @\" + expectedAnnotationType\n+\t\t\t\t\t\t+ \" annotation\");\n+\t}\n+\n+\tprivate static void assertTypeNotAnnotatedBy(TypeImpl eventType, String expectedAnnotationType) {\n+\t\tList<Annotation> annotations = eventType.getAnnotations();\n+\t\tassertNotNull(annotations);\n+\t\tassertTrue(annotations.stream().noneMatch(a -> a.getType().getTypeName().equals(expectedAnnotationType)),\n+\t\t\t\t\"Type '\" + eventType.getTypeName() + \"' is having unexpected @\" + expectedAnnotationType\n+\t\t\t\t\t\t+ \" annotation\");\n+\t}\n+\n+\tprivate static void assertFieldAnnotatedBy(TypeImpl eventType, String fldName, String expectedAnnotationType) {\n+\t\tTypedField fld = eventType.getField(fldName);\n+\t\tassertNotNull(fld);\n+\t\tList<Annotation> annotations = fld.getAnnotations();\n+\t\tassertNotNull(annotations);\n+\t\tassertTrue(annotations.stream().anyMatch(a -> a.getType().getTypeName().equals(expectedAnnotationType)),\n+\t\t\t\t\"Field '\" + eventType.getTypeName() + \"#\" + fldName + \"' is missing the expected @\"\n+\t\t\t\t\t\t+ expectedAnnotationType + \" annotation\");\n+\t}\n+\n+\t@Test\n+\tvoid writeJfrEvent() throws Exception {\n+\t\t\/\/ attempt to write a simple user defined event without registering its type first\n+\t\tSimpleTestEvent e = new SimpleTestEvent();\n+\t\te.fld = \"hello\";\n+\t\te.timespan = 10_000_000L;\n+\t\te.timestamp = 60_000_000L;\n+\t\te.transientFld = 'x';\n+\n+\t\trecording.writeEvent(e);\n+\t\trecording.close();\n+\n+\t\ttry (ByteArrayInputStream is = new ByteArrayInputStream(bos.toByteArray())) {\n+\t\t\tIItemCollection events = JfrLoaderToolkit.loadEvents(is);\n+\t\t\tassertNotNull(events);\n+\n+\t\t\tIAttribute<String> fldAttr = Attribute.attr(\"fld\", \"fld\", UnitLookup.PLAIN_TEXT);\n+\t\t\tIAttribute<IQuantity> timestampAttr = Attribute.attr(\"timestamp\", \"timestamp\", UnitLookup.TIMESTAMP);\n+\t\t\tIAttribute<IQuantity> timespanAttr = Attribute.attr(\"timespan\", \"timespan\", UnitLookup.TIMESPAN);\n+\t\t\tboolean eventTypeFound = false;\n+\t\t\tfor (IItemIterable lane : events) {\n+\t\t\t\tIType<IItem> type = lane.getType();\n+\t\t\t\tif (type.getIdentifier().equals(SimpleTestEvent.class.getSimpleName())) {\n+\t\t\t\t\tvar fldAccessor = fldAttr.getAccessor(type);\n+\t\t\t\t\tvar timestampAccessor = timestampAttr.getAccessor(type);\n+\t\t\t\t\tvar timespanAccessor = timespanAttr.getAccessor(type);\n+\n+\t\t\t\t\tassertNotNull(fldAccessor);\n+\t\t\t\t\tassertNotNull(timestampAccessor);\n+\t\t\t\t\tassertNotNull(timespanAccessor);\n+\n+\t\t\t\t\teventTypeFound = true;\n+\t\t\t\t\tassertEquals(1, lane.getItemCount());\n+\t\t\t\t\tfor (IItem event : lane) {\n+\t\t\t\t\t\tassertEquals(e.fld, fldAccessor.getMember(event));\n+\t\t\t\t\t\tassertEquals(e.timestamp, timestampAccessor.getMember(event).longValue());\n+\t\t\t\t\t\tassertEquals(e.timespan, timespanAccessor.getMember(event).longValue());\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tassertTrue(eventTypeFound,\n+\t\t\t\t\t\"The event type \" + SimpleTestEvent.class.getSimpleName() + \" was not found in the recording\");\n+\t\t}\n+\n+\t}\n+\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/RecordingImplTest.java","additions":193,"deletions":3,"binary":false,"changes":196,"status":"modified"}]}