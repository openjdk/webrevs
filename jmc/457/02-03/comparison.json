{"files":[{"patch":"@@ -56,0 +56,2 @@\n+import java.util.logging.Logger;\n+import java.util.logging.Level;\n@@ -70,0 +72,1 @@\n+import jdk.jfr.Timestamp;\n@@ -76,0 +79,2 @@\n+\tprivate static final Logger LOGGER = Logger.getLogger(RecordingImpl.class.getName());\n+\n@@ -301,0 +306,4 @@\n+\n+\t\t\tboolean eventThredOverride = false;\n+\t\t\tboolean stackTraceOverride = false;\n+\t\t\tboolean startTimeOverride = false;\n@@ -311,4 +320,6 @@\n-\t\t\t\t\tif (fieldName.equals(\"startTime\") || fieldName.equals(\"eventThread\")\n-\t\t\t\t\t\t\t|| fieldName.equals(\"stackTrace\")) {\n-\t\t\t\t\t\t\/\/ built-in fields; skip\n-\t\t\t\t\t\tcontinue;\n+\t\t\t\t\tif (fieldName.equals(\"startTime\")) {\n+\t\t\t\t\t\tstartTimeOverride = true;\n+\t\t\t\t\t} else if (fieldName.equals(\"eventThread\")) {\n+\t\t\t\t\t\teventThredOverride = true;\n+\t\t\t\t\t} else if (fieldName.equals(\"stackTrace\")) {\n+\t\t\t\t\t\tstackTraceOverride = true;\n@@ -318,0 +329,1 @@\n+\t\t\t\t\tboolean foundTimestampAnnotation = false;\n@@ -319,0 +331,3 @@\n+\t\t\t\t\t\tif (a.getClass().equals(Timestamp.class)) {\n+\t\t\t\t\t\t\tfoundTimestampAnnotation = true;\n+\t\t\t\t\t\t}\n@@ -326,0 +341,4 @@\n+\t\t\t\t\tif (fieldName.equals(\"startTime\") && !foundTimestampAnnotation) {\n+\t\t\t\t\t\t\/\/ make sure that even the overridden startTime field has a @Timestamp annotation\n+\t\t\t\t\t\tfieldTypeBuilder.addAnnotation(Types.JDK.ANNOTATION_TIMESTAMP, \"NANOSECONDS_SINCE_EPOCH\");\n+\t\t\t\t\t}\n@@ -329,9 +348,14 @@\n-\t\t\t\/\/ force 'startTime' field\n-\t\t\tb.addField(\"startTime\", Types.Builtin.LONG,\n-\t\t\t\t\tfield -> field.addAnnotation(Types.JDK.ANNOTATION_TIMESTAMP, \"NANOSECONDS_SINCE_EPOCH\"));\n-\t\t\t\/\/ force 'eventThread' field\n-\t\t\tb.addField(\"eventThread\", Types.JDK.THREAD);\n-\n-\t\t\t\/\/ force 'stackTrace' field if the event is collecting stacktraces\n-\t\t\tif (hasStackTrace(eventType)) {\n-\t\t\t\tb.addField(\"stackTrace\", Types.JDK.STACK_TRACE);\n+\t\t\tif (!startTimeOverride) {\n+\t\t\t\t\/\/ force 'startTime' field\n+\t\t\t\tb.addField(\"startTime\", Types.Builtin.LONG,\n+\t\t\t\t\t\tfield -> field.addAnnotation(Types.JDK.ANNOTATION_TIMESTAMP, \"NANOSECONDS_SINCE_EPOCH\"));\n+\t\t\t}\n+\t\t\tif (!eventThredOverride) {\n+\t\t\t\t\/\/ force 'eventThread' field\n+\t\t\t\tb.addField(\"eventThread\", Types.JDK.THREAD);\n+\t\t\t}\n+\t\t\tif (!stackTraceOverride) {\n+\t\t\t\t\/\/ force 'stackTrace' field if the event is collecting stacktraces\n+\t\t\t\tif (hasStackTrace(eventType)) {\n+\t\t\t\t\tb.addField(\"stackTrace\", Types.JDK.STACK_TRACE);\n+\t\t\t\t}\n@@ -481,1 +505,1 @@\n-\t\t\t\t\t\t\/\/System.err.println(\"Cannot write type:\" + f.getType().getName());\n+\t\t\t\t\t\tLOGGER.log(Level.WARNING, \"Cannot write type:\" + f.getType().getName());\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/RecordingImpl.java","additions":38,"deletions":14,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import static org.junit.jupiter.api.Assertions.assertNull;\n@@ -45,0 +46,1 @@\n+import java.util.List;\n@@ -47,0 +49,9 @@\n+import jdk.jfr.Event;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.Registered;\n+import jdk.jfr.StackTrace;\n+import jdk.jfr.Timestamp;\n+import jdk.jfr.Timespan;\n+\n@@ -54,0 +65,9 @@\n+import org.openjdk.jmc.common.item.Attribute;\n+import org.openjdk.jmc.common.item.IAttribute;\n+import org.openjdk.jmc.common.item.IItem;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.item.IItemIterable;\n+import org.openjdk.jmc.common.item.IType;\n+import org.openjdk.jmc.common.unit.IQuantity;\n+import org.openjdk.jmc.common.unit.UnitLookup;\n+import org.openjdk.jmc.flightrecorder.JfrLoaderToolkit;\n@@ -59,0 +79,1 @@\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedField;\n@@ -63,0 +84,41 @@\n+\t@Label(\"Simple Test Event\")\n+\t@Registered(true)\n+\t@Enabled(false)\n+\tpublic static final class SimpleTestEvent extends Event {\n+\t\t@Label(\"field\")\n+\t\tpublic String fld;\n+\n+\t\t@Timestamp\n+\t\tpublic long timestamp;\n+\n+\t\t@Timespan\n+\t\tpublic long timespan;\n+\n+\t\t@Label(\"static\")\n+\t\tpublic static int staticFld;\n+\t\t@Label(\"transient\")\n+\t\tpublic transient char transientFld;\n+\t}\n+\n+\t@StackTrace(true)\n+\tpublic static final class EventWithStackTrace extends Event {\n+\n+\t}\n+\n+\t@Label(\"Named Test Event\")\n+\t@Name(\"jmc.TestEvent\")\n+\tpublic static final class TestEventWithName extends Event {\n+\t\t@Label(\"field\")\n+\t\tpublic String fld;\n+\t}\n+\n+\tpublic static final class EventWithOverrides extends Event {\n+\t\t@Name(\"startTime\")\n+\t\t@Label(\"overridden timestamp\")\n+\t\t@Timestamp\n+\t\tpublic long timestamp;\n+\n+\t\t@Label(\"overridden thread\")\n+\t\tpublic Thread eventThread;\n+\t}\n+\n@@ -150,0 +212,128 @@\n+\t@Test\n+\tvoid registerSimpleJfrEvent() {\n+\t\tTypeImpl eventType = recording.registerEventType(SimpleTestEvent.class);\n+\t\tassertNotNull(eventType);\n+\t\tassertEquals(SimpleTestEvent.class.getSimpleName(), eventType.getTypeName());\n+\n+\t\t\/\/ make sure the following two fields are implicitly added and properly labelled\n+\t\tassertFieldAnnotatedBy(eventType, \"startTime\", Timestamp.class.getName());\n+\t\tassertNotNull(eventType.getField(\"eventThread\"));\n+\n+\t\tassertFieldAnnotatedBy(eventType, \"fld\", Label.class.getName());\n+\t\tassertFieldAnnotatedBy(eventType, \"timestamp\", Timestamp.class.getName());\n+\t\tassertFieldAnnotatedBy(eventType, \"timespan\", Timespan.class.getName());\n+\n+\t\t\/\/ make sure that static and transient fields are ignored\n+\t\tassertNull(eventType.getField(\"staticFld\"));\n+\t\tassertNull(eventType.getField(\"transientFld\"));\n+\t}\n+\n+\t@Test\n+\tvoid registerEventWithStackTrace() {\n+\t\tTypeImpl eventType = recording.registerEventType(EventWithStackTrace.class);\n+\t\tassertNotNull(eventType);\n+\t\tassertEquals(EventWithStackTrace.class.getSimpleName(), eventType.getTypeName());\n+\n+\t\tTypedField stackTrace = eventType.getField(\"stackTrace\");\n+\t\tassertNotNull(stackTrace);\n+\t\tassertEquals(Types.JDK.STACK_TRACE.getTypeName(), stackTrace.getType().getTypeName());\n+\t}\n+\n+\t@Test\n+\tvoid registerEventWithOverrides() {\n+\t\tTypeImpl eventType = recording.registerEventType(EventWithOverrides.class);\n+\t\tassertNotNull(eventType);\n+\n+\t\t\/\/ make sure the @Timestamp annotation is preserved here\n+\t\tassertFieldAnnotatedBy(eventType, \"startTime\", Timestamp.class.getName());\n+\n+\t\t\/\/ the overridden fields have extra @Label annotation\n+\t\tassertFieldAnnotatedBy(eventType, \"startTime\", Label.class.getName());\n+\t\tassertFieldAnnotatedBy(eventType, \"eventThread\", Label.class.getName());\n+\n+\t}\n+\n+\t@Test\n+\tvoid registerJfrEventTypeWithCustomName() {\n+\t\tTypeImpl eventType = recording.registerEventType(TestEventWithName.class);\n+\t\tassertNotNull(eventType);\n+\t\tassertEquals(\"jmc.TestEvent\", eventType.getTypeName());\n+\t\tList<Annotation> annotations = eventType.getAnnotations();\n+\t\tassertNotNull(annotations);\n+\n+\t\tassertTypeAnnotatedBy(eventType, Label.class.getName());\n+\t\tassertTypeNotAnnotatedBy(eventType, Name.class.getName());\n+\t}\n+\n+\tprivate static void assertTypeAnnotatedBy(TypeImpl eventType, String expectedAnnotationType) {\n+\t\tList<Annotation> annotations = eventType.getAnnotations();\n+\t\tassertNotNull(annotations);\n+\t\tassertTrue(annotations.stream().anyMatch(a -> a.getType().getTypeName().equals(expectedAnnotationType)),\n+\t\t\t\t\"Type '\" + eventType.getTypeName() + \"' is missing the expected @\" + expectedAnnotationType\n+\t\t\t\t\t\t+ \" annotation\");\n+\t}\n+\n+\tprivate static void assertTypeNotAnnotatedBy(TypeImpl eventType, String expectedAnnotationType) {\n+\t\tList<Annotation> annotations = eventType.getAnnotations();\n+\t\tassertNotNull(annotations);\n+\t\tassertTrue(annotations.stream().noneMatch(a -> a.getType().getTypeName().equals(expectedAnnotationType)),\n+\t\t\t\t\"Type '\" + eventType.getTypeName() + \"' is having unexpected @\" + expectedAnnotationType\n+\t\t\t\t\t\t+ \" annotation\");\n+\t}\n+\n+\tprivate static void assertFieldAnnotatedBy(TypeImpl eventType, String fldName, String expectedAnnotationType) {\n+\t\tTypedField fld = eventType.getField(fldName);\n+\t\tassertNotNull(fld);\n+\t\tList<Annotation> annotations = fld.getAnnotations();\n+\t\tassertNotNull(annotations);\n+\t\tassertTrue(annotations.stream().anyMatch(a -> a.getType().getTypeName().equals(expectedAnnotationType)),\n+\t\t\t\t\"Field '\" + eventType.getTypeName() + \"#\" + fldName + \"' is missing the expected @\"\n+\t\t\t\t\t\t+ expectedAnnotationType + \" annotation\");\n+\t}\n+\n+\t@Test\n+\tvoid writeJfrEvent() throws Exception {\n+\t\t\/\/ attempt to write a simple user defined event without registering its type first\n+\t\tSimpleTestEvent e = new SimpleTestEvent();\n+\t\te.fld = \"hello\";\n+\t\te.timespan = 10_000_000L;\n+\t\te.timestamp = 60_000_000L;\n+\t\te.transientFld = 'x';\n+\n+\t\trecording.writeEvent(e);\n+\t\trecording.close();\n+\n+\t\ttry (ByteArrayInputStream is = new ByteArrayInputStream(bos.toByteArray())) {\n+\t\t\tIItemCollection events = JfrLoaderToolkit.loadEvents(is);\n+\t\t\tassertNotNull(events);\n+\n+\t\t\tIAttribute<String> fldAttr = Attribute.attr(\"fld\", \"fld\", UnitLookup.PLAIN_TEXT);\n+\t\t\tIAttribute<IQuantity> timestampAttr = Attribute.attr(\"timestamp\", \"timestamp\", UnitLookup.TIMESTAMP);\n+\t\t\tIAttribute<IQuantity> timespanAttr = Attribute.attr(\"timespan\", \"timespan\", UnitLookup.TIMESPAN);\n+\t\t\tboolean eventTypeFound = false;\n+\t\t\tfor (IItemIterable lane : events) {\n+\t\t\t\tIType<IItem> type = lane.getType();\n+\t\t\t\tif (type.getIdentifier().equals(SimpleTestEvent.class.getSimpleName())) {\n+\t\t\t\t\tvar fldAccessor = fldAttr.getAccessor(type);\n+\t\t\t\t\tvar timestampAccessor = timestampAttr.getAccessor(type);\n+\t\t\t\t\tvar timespanAccessor = timespanAttr.getAccessor(type);\n+\n+\t\t\t\t\tassertNotNull(fldAccessor);\n+\t\t\t\t\tassertNotNull(timestampAccessor);\n+\t\t\t\t\tassertNotNull(timespanAccessor);\n+\n+\t\t\t\t\teventTypeFound = true;\n+\t\t\t\t\tassertEquals(1, lane.getItemCount());\n+\t\t\t\t\tfor (IItem event : lane) {\n+\t\t\t\t\t\tassertEquals(e.fld, fldAccessor.getMember(event));\n+\t\t\t\t\t\tassertEquals(e.timestamp, timestampAccessor.getMember(event).longValue());\n+\t\t\t\t\t\tassertEquals(e.timespan, timespanAccessor.getMember(event).longValue());\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tassertTrue(eventTypeFound,\n+\t\t\t\t\t\"The event type \" + SimpleTestEvent.class.getSimpleName() + \" was not found in the recording\");\n+\t\t}\n+\n+\t}\n+\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/RecordingImplTest.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"modified"}]}