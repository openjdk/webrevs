{"files":[{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+\n+final class AnnotationValueObject {\n+\tfinal Type annotationType;\n+\tfinal String annotationValue;\n+\n+\tpublic AnnotationValueObject(Type annotationType, String value) {\n+\t\tthis.annotationType = annotationType;\n+\t\tthis.annotationValue = value;\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/AnnotationValueObject.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Datadog, Inc. All rights reserved.\n@@ -39,0 +39,4 @@\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n@@ -40,0 +44,1 @@\n+import java.util.HashMap;\n@@ -41,0 +46,1 @@\n+import java.util.Map;\n@@ -54,0 +60,1 @@\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n@@ -55,0 +62,1 @@\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedFieldBuilder;\n@@ -56,0 +64,1 @@\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedValueBuilder;\n@@ -58,0 +67,4 @@\n+import jdk.jfr.Event;\n+import jdk.jfr.Name;\n+import jdk.jfr.StackTrace;\n+\n@@ -103,0 +116,4 @@\n+\tprivate final Map<StackTraceElement, TypedValue> frameCache = new HashMap<>(16000);\n+\tprivate final Map<String, TypedValue> classLoaderCache = new HashMap<>(128);\n+\tprivate final Map<String, TypedValue> moduleCache = new HashMap<>(4096);\n+\n@@ -273,0 +290,333 @@\n+\t@Override\n+\tpublic TypeImpl registerEventType(Class<? extends Event> eventType) {\n+\t\t\/*\n+\t\t * JMC implementation is slightly mishandling some event types - not using the special call\n+\t\t * and rather registering all implicit fields by hand.\n+\t\t *\/\n+\t\treturn registerType(getEventName(eventType), \"jdk.jfr.Event\", b -> {\n+\t\t\tField[] fields = eventType.getDeclaredFields();\n+\t\t\tfor (Field f : fields) {\n+\t\t\t\tif (Modifier.isTransient(f.getModifiers()) || Modifier.isStatic(f.getModifiers())) {\n+\t\t\t\t\t\/\/ skip static and transient fields\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\t\/\/ Add field definition\n+\t\t\t\tTypeImpl fieldType = types.getType(f.getType().getName());\n+\t\t\t\tif (fieldType != null) {\n+\t\t\t\t\tjava.lang.annotation.Annotation[] as = f.getAnnotations();\n+\t\t\t\t\tString fieldName = getFieldName(f);\n+\t\t\t\t\tif (fieldName.equals(\"startTime\") || fieldName.equals(\"eventThread\")\n+\t\t\t\t\t\t\t|| fieldName.equals(\"stackTrace\")) {\n+\t\t\t\t\t\t\/\/ built-in fields; skip\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n+\t\t\t\t\tTypedFieldBuilder fieldTypeBuilder = types.fieldBuilder(fieldName, fieldType);\n+\n+\t\t\t\t\tfor (java.lang.annotation.Annotation a : as) {\n+\t\t\t\t\t\tAnnotationValueObject val = processAnnotation(types, a);\n+\t\t\t\t\t\tif (val != null) {\n+\t\t\t\t\t\t\tfieldTypeBuilder = val.annotationValue != null\n+\t\t\t\t\t\t\t\t\t? fieldTypeBuilder.addAnnotation(val.annotationType, val.annotationValue)\n+\t\t\t\t\t\t\t\t\t: fieldTypeBuilder.addAnnotation(val.annotationType);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tb.addField(fieldTypeBuilder.build());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t\/\/ force 'startTime' field\n+\t\t\tb.addField(\"startTime\", Types.Builtin.LONG,\n+\t\t\t\t\tfield -> field.addAnnotation(Types.JDK.ANNOTATION_TIMESTAMP, \"NANOSECONDS_SINCE_EPOCH\"));\n+\t\t\t\/\/ force 'eventThread' field\n+\t\t\tb.addField(\"eventThread\", Types.JDK.THREAD);\n+\n+\t\t\t\/\/ force 'stackTrace' field if the event is collecting stacktraces\n+\t\t\tif (hasStackTrace(eventType)) {\n+\t\t\t\tb.addField(\"stackTrace\", Types.JDK.STACK_TRACE);\n+\t\t\t}\n+\t\t\tfor (java.lang.annotation.Annotation a : eventType.getAnnotations()) {\n+\t\t\t\tAnnotationValueObject val = processAnnotation(types, a);\n+\t\t\t\tif (val != null) {\n+\t\t\t\t\tb = val.annotationValue != null ? b.addAnnotation(val.annotationType, val.annotationValue)\n+\t\t\t\t\t\t\t: b.addAnnotation(val.annotationType);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\t@Override\n+\tpublic RecordingImpl writeEvent(Event event) {\n+\t\tregisterEventType(event.getClass());\n+\t\twriteEvent(createEventValue(event));\n+\t\treturn this;\n+\t}\n+\n+\tprivate String getEventName(Class<? extends Event> eventType) {\n+\t\tName nameAnnotation = eventType.getAnnotation(Name.class);\n+\t\tif (nameAnnotation != null) {\n+\t\t\treturn nameAnnotation.value();\n+\t\t}\n+\t\treturn eventType.getSimpleName();\n+\t}\n+\n+\tprivate String getFieldName(Field fld) {\n+\t\tName nameAnnotation = fld.getAnnotation(Name.class);\n+\t\tif (nameAnnotation != null) {\n+\t\t\treturn nameAnnotation.value();\n+\t\t}\n+\t\treturn fld.getName();\n+\t}\n+\n+\tprivate boolean hasStackTrace(Class<? extends Event> eventType) {\n+\t\tStackTrace stAnnotation = eventType.getAnnotation(StackTrace.class);\n+\t\tif (stAnnotation != null) {\n+\t\t\treturn stAnnotation.value();\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprivate TypedValue createEventValue(Event event) {\n+\t\tType eventType = getType(getEventName(event.getClass()));\n+\t\tField[] fields = event.getClass().getDeclaredFields();\n+\n+\t\tTypedValue typedValue = eventType.asValue(access -> {\n+\t\t\tboolean startTimeWritten = false;\n+\t\t\tboolean eventThreadWritten = false;\n+\t\t\tboolean stackTraceWritten = false;\n+\t\t\tfor (Field f : fields) {\n+\t\t\t\tf.setAccessible(true);\n+\n+\t\t\t\t\/*\n+\t\t\t\t * From jdk.jfr.Event.java: Supported field types are the Java primitives: {@code\n+\t\t\t\t * boolean}, {@code char}, {@code byte}, {@code short}, {@code int}, {@code long},\n+\t\t\t\t * {@code float}, and {@code double}. Supported reference types are: {@code String},\n+\t\t\t\t * {@code Thread} and {@code Class}. Arrays, enums, and other reference types are\n+\t\t\t\t * silently ignored and not included. Fields that are of the supported types can be\n+\t\t\t\t * excluded by using the transient modifier. Static fields, even of the supported\n+\t\t\t\t * types, are not included.\n+\t\t\t\t *\/\n+\t\t\t\t\/\/ Transient and static fields are excluded\n+\t\t\t\tif (Modifier.isTransient(f.getModifiers()) || Modifier.isStatic(f.getModifiers())) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tString fldName = getFieldName(f);\n+\t\t\t\tif (fldName.equals(\"startTime\")) {\n+\t\t\t\t\tstartTimeWritten = true;\n+\t\t\t\t} else if (fldName.equals(\"eventThread\")) {\n+\t\t\t\t\teventThreadWritten = true;\n+\t\t\t\t} else if (fldName.equals(\"stackTrace\")) {\n+\t\t\t\t\tstackTraceWritten = true;\n+\t\t\t\t}\n+\t\t\t\ttry {\n+\t\t\t\t\tswitch (f.getType().getName()) {\n+\t\t\t\t\tcase \"byte\": {\n+\t\t\t\t\t\tbyte byteValue = f.getByte(event);\n+\t\t\t\t\t\taccess.putField(fldName, byteValue);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase \"char\": {\n+\t\t\t\t\t\tchar charValue = f.getChar(event);\n+\t\t\t\t\t\taccess.putField(fldName, charValue);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase \"short\": {\n+\t\t\t\t\t\tshort shortValue = f.getShort(event);\n+\t\t\t\t\t\taccess.putField(fldName, shortValue);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase \"int\": {\n+\t\t\t\t\t\tint intValue = f.getInt(event);\n+\t\t\t\t\t\taccess.putField(fldName, intValue);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase \"long\": {\n+\t\t\t\t\t\tlong longValue = f.getLong(event);\n+\t\t\t\t\t\taccess.putField(fldName, longValue);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase \"float\": {\n+\t\t\t\t\t\tfloat floatValue = f.getFloat(event);\n+\t\t\t\t\t\taccess.putField(fldName, floatValue);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase \"double\": {\n+\t\t\t\t\t\tdouble doubleValue = f.getDouble(event);\n+\t\t\t\t\t\taccess.putField(fldName, doubleValue);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase \"boolean\": {\n+\t\t\t\t\t\tboolean booleanValue = f.getBoolean(event);\n+\t\t\t\t\t\taccess.putField(fldName, booleanValue);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase \"java.lang.String\": {\n+\t\t\t\t\t\tString stringValue = (String) f.get(event);\n+\t\t\t\t\t\taccess.putField(fldName, stringValue);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase \"java.lang.Class\": {\n+\t\t\t\t\t\tClass<?> clz = (Class<?>) f.get(event);\n+\t\t\t\t\t\taccess.putField(fldName, fldAccess -> {\n+\t\t\t\t\t\t\tfldAccess.putField(\"name\", nameAccess -> {\n+\t\t\t\t\t\t\t\tnameAccess.putField(\"string\", clz.getSimpleName());\n+\t\t\t\t\t\t\t}).putField(\"package\", clz.getPackage().getName()).putField(\"modifiers\",\n+\t\t\t\t\t\t\t\t\tclz.getModifiers());\n+\t\t\t\t\t\t});\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase \"java.lang.Thread\": {\n+\t\t\t\t\t\tThread thrd = (Thread) f.get(event);\n+\t\t\t\t\t\tputThreadField(access, fldName, thrd);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase \"java.lang.StackTraceElement[]\": {\n+\t\t\t\t\t\tStackTraceElement[] stackTrace = (StackTraceElement[]) f.get(event);\n+\t\t\t\t\t\tputStackTraceField(access, fldName, stackTrace);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tdefault: {\n+\t\t\t\t\t\t\/\/System.err.println(\"Cannot write type:\" + f.getType().getName());\n+\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t} catch (IllegalAccessException e) {\n+\t\t\t\t\tthrow new RuntimeException();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (!startTimeWritten) {\n+\t\t\t\t\/\/ default to 0\n+\t\t\t\taccess.putField(\"startTime\", 0L);\n+\t\t\t}\n+\t\t\tif (!eventThreadWritten) {\n+\t\t\t\t\/\/ default to current thread\n+\t\t\t\tputThreadField(access, \"eventThread\", Thread.currentThread());\n+\t\t\t}\n+\t\t\tif (!stackTraceWritten && hasStackTrace(event.getClass())) {\n+\t\t\t\tputStackTraceField(access, \"stackTrace\", Thread.currentThread().getStackTrace());\n+\t\t\t}\n+\t\t});\n+\n+\t\treturn typedValue;\n+\t}\n+\n+\tprivate void putThreadField(TypedValueBuilder access, String fldName, Thread thread) {\n+\t\taccess.putField(fldName, fldAccess -> {\n+\t\t\tfldAccess.putField(\"javaThreadId\", thread.getId()).putField(\"osThreadId\", thread.getId())\n+\t\t\t\t\t.putField(\"javaName\", thread.getName());\n+\t\t});\n+\t}\n+\n+\tprivate void putStackTraceField(TypedValueBuilder access, String fldName, StackTraceElement[] stackTrace) {\n+\t\tTypes types = access.getType().getTypes();\n+\t\tTypedValue[] frames = new TypedValue[stackTrace.length];\n+\t\tboolean[] truncated = new boolean[] {false};\n+\t\tfor (int i = 0; i < stackTrace.length; i++) {\n+\t\t\tframes[i] = asStackFrame(types, stackTrace[i]);\n+\t\t\tif (i >= 8192) {\n+\t\t\t\ttruncated[0] = true;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\taccess.putField(fldName, p -> {\n+\t\t\tp.putField(\"frames\", frames).putField(\"truncated\", truncated[0]);\n+\t\t});\n+\t}\n+\n+\tprivate TypedValue asStackFrame(Types types, StackTraceElement element) {\n+\t\treturn frameCache.computeIfAbsent(element, k -> types.getType(Types.JDK.STACK_FRAME).asValue(p -> {\n+\t\t\tp.putField(\"method\", methodValue(types, k)).putField(\"lineNumber\", k.getLineNumber())\n+\t\t\t\t\t.putField(\"bytecodeIndex\", -1).putField(\"type\", k.isNativeMethod() ? \"native\" : \"java\");\n+\t\t}));\n+\t}\n+\n+\tprivate TypedValue methodValue(Types types, StackTraceElement element) {\n+\t\treturn types.getType(Types.JDK.METHOD).asValue(p -> {\n+\t\t\tp.putField(\"type\", classValue(types, element)).putField(\"name\", element.getMethodName());\n+\t\t});\n+\t}\n+\n+\tprivate TypedValue classValue(Types types, StackTraceElement element) {\n+\t\treturn types.getType(Types.JDK.CLASS).asValue(p -> {\n+\t\t\tp.putField(\"classLoader\", classLoaderValue(types, element.getClassLoaderName()))\n+\t\t\t\t\t.putField(\"name\", getSimpleName(element.getClassName())).putField(\"package\",\n+\t\t\t\t\t\t\tpackageValue(types, getPackageName(element.getClassName()), element.getModuleName()));\n+\t\t});\n+\t}\n+\n+\tprivate TypedValue classLoaderValue(Types types, String classLoaderName) {\n+\t\treturn classLoaderCache.computeIfAbsent(classLoaderName,\n+\t\t\t\tk -> types.getType(Types.JDK.CLASS_LOADER).asValue(p -> {\n+\t\t\t\t\tp.putField(\"name\", k);\n+\t\t\t\t}));\n+\t}\n+\n+\tprivate TypedValue packageValue(Types types, String packageName, String module) {\n+\t\treturn types.getType(Types.JDK.PACKAGE).asValue(p -> {\n+\t\t\tp.putField(\"name\", packageName).putField(\"module\", moduleValue(types, module));\n+\t\t});\n+\t}\n+\n+\tprivate TypedValue moduleValue(Types types, String module) {\n+\t\treturn moduleCache.computeIfAbsent(module, k -> types.getType(Types.JDK.MODULE).asValue(p -> {\n+\t\t\tp.putField(\"name\", k);\n+\t\t}));\n+\t}\n+\n+\tprivate String getSimpleName(String className) {\n+\t\treturn className.substring(className.lastIndexOf('.') + 1);\n+\t}\n+\n+\tprivate String getPackageName(String className) {\n+\t\tint idx = className.lastIndexOf('.');\n+\t\tif (idx > -1) {\n+\t\t\treturn className.substring(0, idx);\n+\t\t}\n+\t\treturn \"\";\n+\t}\n+\n+\tprivate AnnotationValueObject processAnnotation(Types types, java.lang.annotation.Annotation annotation) {\n+\t\t\/\/ skip non-JFR related annotations\n+\t\tif (!isJfrAnnotation(annotation)) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tif (annotation instanceof Name) {\n+\t\t\t\/\/ skip @Name annotation\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tString value = null;\n+\t\ttry {\n+\t\t\tMethod m = annotation.getClass().getMethod(\"value\");\n+\t\t\tif (!String.class.isAssignableFrom(m.getReturnType())) {\n+\t\t\t\t\/\/ wrong value type\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tvalue = (String) m.invoke(annotation);\n+\t\t} catch (NoSuchMethodException ignored) {\n+\t\t\t\/\/ no-value annotations are also permitted\n+\t\t} catch (SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {\n+\t\t\t\/\/ error retrieving value attribute\n+\t\t\treturn null;\n+\t\t}\n+\t\tString annotationValue = value;\n+\t\tString annotationTypeName = annotation.annotationType().getTypeName();\n+\t\tType annotationType = types.getOrAdd(annotationTypeName, Annotation.ANNOTATION_SUPER_TYPE_NAME, builder -> {\n+\t\t\tif (annotationValue != null) {\n+\t\t\t\tbuilder.addField(\"value\", Types.Builtin.STRING);\n+\t\t\t}\n+\t\t});\n+\t\treturn new AnnotationValueObject(annotationType, annotationValue);\n+\t}\n+\n+\tprivate boolean isJfrAnnotation(java.lang.annotation.Annotation target) {\n+\t\tString typeName = target.annotationType().getName();\n+\t\tif (typeName.startsWith(\"jdk.jfr.\")) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tfor (java.lang.annotation.Annotation annotation : target.annotationType().getAnnotations()) {\n+\t\t\tif (isJfrAnnotation(annotation)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/RecordingImpl.java","additions":352,"deletions":2,"binary":false,"changes":354,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Datadog, Inc. All rights reserved.\n@@ -42,0 +42,2 @@\n+import jdk.jfr.Event;\n+\n@@ -56,0 +58,2 @@\n+\tpublic abstract RecordingImpl writeEvent(Event event);\n+\n@@ -66,0 +70,2 @@\n+\tpublic abstract Type registerEventType(Class<? extends Event> eventType);\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/Recording.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Datadog, Inc. All rights reserved.\n@@ -108,1 +108,1 @@\n-\t\tassertThrows(IllegalArgumentException.class, () -> recording.registerEventType(null));\n+\t\tassertThrows(IllegalArgumentException.class, () -> recording.registerEventType((String) null));\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/RecordingImplTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}