{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,0 +101,1 @@\n+import org.openjdk.jmc.common.collection.IteratorToolkit;\n@@ -645,7 +646,10 @@\n-\t\t\/\/ FIXME: JMC-4520 - Handle multiple item iterables\n-\t\tIterator<IItemIterable> ii = items.iterator();\n-\t\tif (ii.hasNext()) {\n-\t\t\tIItemIterable itemStream = ii.next();\n-\t\t\tIType<IItem> type = itemStream.getType();\n-\t\t\t\/\/ FIXME: A better way to ensure sorting by endTime\n-\t\t\treturn yAttributes.peek(a -> addEndTimeLine(renderer, itemStream.iterator(), type, a, fill))\n+\t\tif (items.hasItems()) {\n+\t\t\tList<Iterator<IItem>> iterators = new ArrayList<>();\n+\t\t\tfor (IItemIterable ii : items) {\n+\t\t\t\titerators.add(ii.iterator());\n+\t\t\t}\n+\t\t\tIType<IItem> type = items.iterator().next().getType();\n+\t\t\tIMemberAccessor<IQuantity, IItem> accessor = JfrAttributes.END_TIME.getAccessor(type);\n+\t\t\tComparator<IItem> comparator = Comparator.comparing(item -> accessor.getMember(item));\n+\t\t\treturn yAttributes.peek(\n+\t\t\t\t\ta -> addEndTimeLine(renderer, IteratorToolkit.mergedSorting(iterators, comparator), type, a, fill))\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/common\/DataPageToolkit.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.util.Iterator;\n@@ -76,1 +75,1 @@\n-\t\tpopulateAttributeMaps(isSuitableForLineCharts(items, allTypes));\n+\t\tpopulateAttributeMaps(isSuitableForLineCharts(allTypes));\n@@ -120,10 +119,2 @@\n-\tprivate static boolean isSuitableForLineCharts(IItemCollection items, Map<String, IType<?>> types) {\n-\t\t\/\/ NOTE: JMC-4520 - Only allowing line charts for one event type, which only has one event array. \n-\t\tif (types.values().size() == 1) {\n-\t\t\tIterator<IItemIterable> iterator = items.iterator();\n-\t\t\tif (iterator.hasNext()) {\n-\t\t\t\titerator.next();\n-\t\t\t\treturn !iterator.hasNext();\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n+\tprivate static boolean isSuitableForLineCharts(Map<String, IType<?>> types) {\n+\t\treturn types.values().size() == 1;\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/pages\/itemhandler\/AttributeComponentConfiguration.java","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.util.Comparator;\n@@ -62,0 +63,1 @@\n+import org.openjdk.jmc.common.collection.IteratorToolkit;\n@@ -65,0 +67,1 @@\n+import org.openjdk.jmc.common.item.IItem;\n@@ -67,0 +70,1 @@\n+import org.openjdk.jmc.common.item.IMemberAccessor;\n@@ -543,9 +547,15 @@\n-\t\t\t\t\t\tIterator<IItemIterable> chartItemsWithAttributeSomeType = itemsToChart\n-\t\t\t\t\t\t\t\t.apply(ItemFilters.hasAttribute(attribute)).iterator();\n-\t\t\t\t\t\tif (chartItemsWithAttributeSomeType.hasNext()\n-\t\t\t\t\t\t\t\t&& attribute.getContentType() instanceof LinearKindOfQuantity) {\n-\t\t\t\t\t\t\tIItemIterable is = chartItemsWithAttributeSomeType.next();\n-\t\t\t\t\t\t\tif (chartItemsWithAttributeSomeType.hasNext()) {\n-\t\t\t\t\t\t\t\t\/\/ FIXME: JMC-4520 - Add support for multiple item iterables\n-\t\t\t\t\t\t\t\tFlightRecorderUI.getDefault().getLogger().log(Level.INFO,\n-\t\t\t\t\t\t\t\t\t\t\"Only charting a subset of the events!\"); \/\/$NON-NLS-1$\n+\t\t\t\t\t\tif (attribute.getContentType() instanceof LinearKindOfQuantity) {\n+\t\t\t\t\t\t\tIItemCollection itemsWithAttributeSomeType = itemsToChart\n+\t\t\t\t\t\t\t\t\t.apply(ItemFilters.hasAttribute(attribute));\n+\t\t\t\t\t\t\tif (itemsWithAttributeSomeType.hasItems()) {\n+\t\t\t\t\t\t\t\tList<Iterator<IItem>> iterators = new ArrayList<>();\n+\t\t\t\t\t\t\t\tfor (IItemIterable ii : itemsWithAttributeSomeType) {\n+\t\t\t\t\t\t\t\t\titerators.add(ii.iterator());\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tIType<IItem> type = itemsWithAttributeSomeType.iterator().next().getType();\n+\t\t\t\t\t\t\t\tIMemberAccessor<IQuantity, IItem> accessor = JfrAttributes.END_TIME.getAccessor(type);\n+\t\t\t\t\t\t\t\tComparator<IItem> comparator = Comparator.comparing(item -> accessor.getMember(item));\n+\t\t\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n+\t\t\t\t\t\t\t\tIAttribute<IQuantity> qAttribute = (IAttribute<IQuantity>) attribute;\n+\t\t\t\t\t\t\t\tDataPageToolkit.addEndTimeLine(xyRenderer,\n+\t\t\t\t\t\t\t\t\t\tIteratorToolkit.mergedSorting(iterators, comparator), type, qAttribute, fill);\n@@ -553,3 +563,0 @@\n-\t\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n-\t\t\t\t\t\t\tIAttribute<IQuantity> qAttribute = (IAttribute<IQuantity>) attribute;\n-\t\t\t\t\t\t\tDataPageToolkit.addEndTimeLine(xyRenderer, is.iterator(), is.getType(), qAttribute, fill);\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/pages\/itemhandler\/ItemChart.java","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+import java.util.Collection;\n+import java.util.Comparator;\n@@ -39,0 +41,2 @@\n+import java.util.PriorityQueue;\n+import java.util.Queue;\n@@ -109,0 +113,35 @@\n+\t\/**\n+\t * Wrap an iterator in a new iterator that merges values from sorted iterators.\n+\t *\n+\t * @param <T>\n+\t *            input iterator type\n+\t * @param iterators\n+\t *            input iterators\n+\t * @param comparator\n+\t *            ordering rule function\n+\t * @return a new iterator that contains sorted elements\n+\t *\/\n+\tpublic static <T> Iterator<T> mergedSorting(\n+\t\tfinal Collection<? extends Iterator<T>> iterators, final Comparator<T> comparator) {\n+\t\tfinal Queue<PeekingIterator<T>> priorityQueue = new PriorityQueue<>(\n+\t\t\t\tComparator.comparing(PeekingIterator::peek, comparator));\n+\t\tfor (Iterator<T> iterator : iterators) {\n+\t\t\tif (iterator.hasNext()) {\n+\t\t\t\tpriorityQueue.add(new PeekingIterator<>(iterator));\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn new AbstractIterator<T>() {\n+\t\t\t@Override\n+\t\t\tprotected T findNext() {\n+\t\t\t\tif (priorityQueue.isEmpty())\n+\t\t\t\t\treturn NO_MORE_ELEMENTS;\n+\t\t\t\tPeekingIterator<T> minPeekingIterator = priorityQueue.poll();\n+\t\t\t\tT result = minPeekingIterator.next();\n+\t\t\t\tif (minPeekingIterator.hasNext())\n+\t\t\t\t\tpriorityQueue.add(minPeekingIterator);\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t};\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.common\/src\/main\/java\/org\/openjdk\/jmc\/common\/collection\/IteratorToolkit.java","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2018, 2026 Oracle and\/or its affiliates. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.common.collection;\n+\n+import java.util.Iterator;\n+\n+\/**\n+ * Iterator wrapper that allows peeking at the next element.\n+ *\n+ * @param <T>\n+ *            the type of elements returned by the iterator\n+ *\/\n+public class PeekingIterator<T> implements Iterator<T> {\n+\tprivate final Iterator<T> sourceIterator;\n+\tprivate T peekedElement;\n+\tprivate boolean hasPeeked;\n+\n+\tpublic PeekingIterator(Iterator<T> sourceIterator) {\n+\t\tthis.sourceIterator = sourceIterator;\n+\t}\n+\n+\tpublic T peek() {\n+\t\tif (!this.hasPeeked) {\n+\t\t\tthis.hasPeeked = true;\n+\t\t\tthis.peekedElement = this.sourceIterator.next();\n+\t\t}\n+\t\treturn this.peekedElement;\n+\t}\n+\n+\t@Override\n+\tpublic T next() {\n+\t\tif (!this.hasPeeked) {\n+\t\t\treturn this.sourceIterator.next();\n+\t\t}\n+\t\tthis.hasPeeked = false;\n+\t\tT result = this.peekedElement;\n+\t\tthis.peekedElement = null;\n+\t\treturn result;\n+\t}\n+\n+\t@Override\n+\tpublic boolean hasNext() {\n+\t\treturn this.hasPeeked || this.sourceIterator.hasNext();\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.common\/src\/main\/java\/org\/openjdk\/jmc\/common\/collection\/PeekingIterator.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"}]}