{"files":[{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.management.ManagementFactory;\n@@ -41,1 +40,0 @@\n-import java.util.Arrays;\n@@ -45,7 +43,0 @@\n-import javax.management.Attribute;\n-import javax.management.AttributeList;\n-import javax.management.InstanceNotFoundException;\n-import javax.management.MalformedObjectNameException;\n-import javax.management.ObjectName;\n-import javax.management.openmbean.CompositeDataSupport;\n-import javax.management.openmbean.TabularDataSupport;\n@@ -54,3 +45,0 @@\n-import org.jolokia.client.jmxadapter.RemoteJmxAdapter;\n-import org.openjdk.jmc.common.jvm.Connectable;\n-import org.openjdk.jmc.common.jvm.JVMArch;\n@@ -58,1 +46,0 @@\n-import org.openjdk.jmc.common.jvm.JVMType;\n@@ -65,2 +52,0 @@\n-\tpublic static final JVMDescriptor NULL_DESCRIPTOR = new JVMDescriptor(null, null, null, null, null, null, null,\n-\t\t\tnull, false, Connectable.UNKNOWN);\n@@ -69,1 +54,0 @@\n-\tprivate final JVMDescriptor jvmDescriptor;\n@@ -71,2 +55,1 @@\n-\tpublic JolokiaAgentDescriptor(Map<String, ?> agentData, JVMDescriptor jvmDescriptor)\n-\t\t\tthrows URISyntaxException, MalformedURLException {\n+\tpublic JolokiaAgentDescriptor(Map<String, ?> agentData) throws URISyntaxException, MalformedURLException {\n@@ -78,1 +61,0 @@\n-\t\tthis.jvmDescriptor = jvmDescriptor;\n@@ -97,80 +79,4 @@\n-\t\treturn this.jvmDescriptor;\n-\t}\n-\n-\t\/**\n-\t * Best effort to extract JVM information from a connection if everything works. Can be adjusted\n-\t * to support different flavors of JVM.\n-\t *\/\n-\tpublic static JVMDescriptor attemptToGetJvmInfo(RemoteJmxAdapter adapter) {\n-\t\ttry {\n-\t\t\tAttributeList attributes = adapter.getAttributes(new ObjectName(ManagementFactory.RUNTIME_MXBEAN_NAME),\n-\t\t\t\t\tnew String[] {\"Pid\", \"Name\", \"InputArguments\", \"SystemProperties\"}); \/\/$NON-NLS-1$ \/\/$NON-NLS-2$ \/\/$NON-NLS-3$ \/\/$NON-NLS-4$\n-\t\t\tInteger pid = null;\n-\t\t\tString arguments = null, javaCommand = null, javaVersion = null, vmName = null, vmVendor = null;\n-\t\t\tboolean isDebug = false;\n-\t\t\tJVMType type = JVMType.UNKNOWN;\n-\t\t\tJVMArch arch = JVMArch.UNKNOWN;\n-\t\t\tfor (Attribute attribute : attributes.asList()) {\n-\t\t\t\t\/\/ newer JVM have pid as separate attribute, older have to parse from name\n-\t\t\t\tif (attribute.getName().equalsIgnoreCase(\"Pid\")) { \/\/$NON-NLS-1$\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tpid = Integer.valueOf(String.valueOf(attribute.getValue()));\n-\t\t\t\t\t} catch (NumberFormatException ignore) {\n-\t\t\t\t\t}\n-\t\t\t\t} else if (attribute.getName().equalsIgnoreCase(\"Name\") && pid == null) { \/\/$NON-NLS-1$\n-\t\t\t\t\tString pidAndHost = String.valueOf(attribute.getValue());\n-\t\t\t\t\tint separator = pidAndHost.indexOf('@');\n-\t\t\t\t\tif (separator > 0) {\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tpid = Integer.valueOf(pidAndHost.substring(0, separator));\n-\t\t\t\t\t\t} catch (NumberFormatException e) {\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t} else if (attribute.getName().equalsIgnoreCase(\"InputArguments\")) { \/\/$NON-NLS-1$\n-\n-\t\t\t\t\tif (attribute.getValue() instanceof String[]) {\n-\t\t\t\t\t\targuments = Arrays.toString((String[]) attribute.getValue());\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\targuments = String.valueOf(attribute.getValue());\n-\t\t\t\t\t}\n-\t\t\t\t\tif (arguments.contains(\"-agentlib:jdwp\")) { \/\/$NON-NLS-1$\n-\t\t\t\t\t\tisDebug = true;\n-\t\t\t\t\t}\n-\t\t\t\t} else if (attribute.getName().equalsIgnoreCase(\"SystemProperties\") \/\/$NON-NLS-1$\n-\t\t\t\t\t\t&& attribute.getValue() instanceof TabularDataSupport) {\n-\t\t\t\t\tTabularDataSupport systemProperties = (TabularDataSupport) attribute.getValue();\n-\n-\t\t\t\t\t\/\/ quite clumsy: iterate over properties as we need to use the exact key, which is non trivial\n-\t\t\t\t\t\/\/ to reproduce\n-\t\t\t\t\tfor (Object entry : systemProperties.values()) {\n-\t\t\t\t\t\tString key = ((CompositeDataSupport) entry).get(\"key\").toString(); \/\/$NON-NLS-1$\n-\t\t\t\t\t\tString value = ((CompositeDataSupport) entry).get(\"value\").toString(); \/\/$NON-NLS-1$\n-\t\t\t\t\t\tif (key.equalsIgnoreCase(\"sun.management.compiler\")) { \/\/$NON-NLS-1$\n-\t\t\t\t\t\t\tif (value.toLowerCase().contains(\"hotspot\")) { \/\/$NON-NLS-1$\n-\t\t\t\t\t\t\t\ttype = JVMType.HOTSPOT;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} else if (key.equalsIgnoreCase(\"sun.arch.data.model\")) { \/\/$NON-NLS-1$\n-\t\t\t\t\t\t\tString archIndicator = value;\n-\t\t\t\t\t\t\tif (archIndicator.contains(\"64\")) { \/\/$NON-NLS-1$\n-\t\t\t\t\t\t\t\tarch = JVMArch.BIT64;\n-\t\t\t\t\t\t\t} else if (archIndicator.contains(\"32\")) { \/\/$NON-NLS-1$\n-\t\t\t\t\t\t\t\tarch = JVMArch.BIT32;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} else if (key.equalsIgnoreCase(\"sun.java.command\")) { \/\/$NON-NLS-1$\n-\t\t\t\t\t\t\tjavaCommand = value;\n-\t\t\t\t\t\t} else if (key.equalsIgnoreCase(\"java.version\")) { \/\/$NON-NLS-1$\n-\t\t\t\t\t\t\tjavaVersion = value;\n-\t\t\t\t\t\t} else if (key.equalsIgnoreCase(\"java.vm.name\")) { \/\/$NON-NLS-1$\n-\t\t\t\t\t\t\tvmName = value;\n-\t\t\t\t\t\t} else if (key.equalsIgnoreCase(\"java.vm.vendor\")) { \/\/$NON-NLS-1$\n-\t\t\t\t\t\t\tvmVendor = value;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn new JVMDescriptor(javaVersion, type, arch, javaCommand, arguments, vmName, vmVendor, pid, isDebug,\n-\t\t\t\t\tConnectable.UNKNOWN);\n-\n-\t\t} catch (RuntimeException | IOException | InstanceNotFoundException | MalformedObjectNameException ignore) {\n-\t\t\treturn NULL_DESCRIPTOR;\n-\t\t}\n+\t\t\/\/Note: From discovery we may know a bit about the target JVM, however the presence of JVM info\n+\t\t\/\/is interpreted as a local JVM by AgentJmxHelper.isLocalJvm() hence the JMC Agent will be available \n+\t\t\/\/which does not make sense over this protocol\n+\t\treturn null;\n","filename":"application\/org.openjdk.jmc.jolokia\/src\/main\/java\/org\/openjdk\/jmc\/jolokia\/JolokiaAgentDescriptor.java","additions":5,"deletions":99,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import org.jolokia.client.jmxadapter.RemoteJmxAdapter;\n@@ -43,1 +42,0 @@\n-import org.openjdk.jmc.common.jvm.JVMDescriptor;\n@@ -52,1 +50,2 @@\n-\tJolokiaDiscoverySettings settings;\n+\tprivate JolokiaDiscoverySettings settings;\n+\tprivate final JolokiaDiscovery jolokiaDiscovery;\n@@ -56,0 +55,2 @@\n+\t\tjolokiaDiscovery = new JolokiaDiscovery();\n+\t\tjolokiaDiscovery.init(this.settings.getJolokiaContext());\n@@ -69,2 +70,0 @@\n-\t\t\tJolokiaDiscovery jolokiaDiscovery = new JolokiaDiscovery();\n-\t\t\tjolokiaDiscovery.init(this.settings.getJolokiaContext());\n@@ -77,8 +76,1 @@\n-\t\t\t\t\tJVMDescriptor jvmInfo;\n-\t\t\t\t\ttry {\/\/ if it is connectable, see if we can get info from connection\n-\t\t\t\t\t\tjvmInfo = JolokiaAgentDescriptor\n-\t\t\t\t\t\t\t\t.attemptToGetJvmInfo(new RemoteJmxAdapter(String.valueOf(response.get(\"url\")))); \/\/$NON-NLS-1$\n-\t\t\t\t\t} catch (Exception ignore) {\n-\t\t\t\t\t\tjvmInfo = JolokiaAgentDescriptor.NULL_DESCRIPTOR;\n-\t\t\t\t\t}\n-\t\t\t\t\tJolokiaAgentDescriptor agentDescriptor = new JolokiaAgentDescriptor(response, jvmInfo);\n+\t\t\t\t\tJolokiaAgentDescriptor agentDescriptor = new JolokiaAgentDescriptor(response);\n","filename":"application\/org.openjdk.jmc.jolokia\/src\/main\/java\/org\/openjdk\/jmc\/jolokia\/JolokiaDiscoveryListener.java","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"}]}