{"files":[{"patch":"@@ -0,0 +1,336 @@\n+@file:DependsOn(\"org.eclipse.jgit:org.eclipse.jgit:6.0.0.202111291000-r\")\n+\n+import org.eclipse.jgit.api.Git\n+import org.eclipse.jgit.diff.DiffEntry.ChangeType.*\n+import org.eclipse.jgit.lib.AbbreviatedObjectId\n+import org.eclipse.jgit.lib.Constants\n+import org.eclipse.jgit.lib.ObjectReader\n+import org.eclipse.jgit.lib.Repository\n+import org.eclipse.jgit.revwalk.RevCommit\n+import org.eclipse.jgit.revwalk.RevTree\n+import org.eclipse.jgit.revwalk.RevWalk\n+import org.eclipse.jgit.revwalk.filter.RevFilter\n+import org.eclipse.jgit.treewalk.CanonicalTreeParser\n+import org.eclipse.jgit.treewalk.TreeWalk\n+import org.eclipse.jgit.treewalk.filter.PathSuffixFilter\n+import java.io.File\n+import java.time.Instant\n+import java.time.ZoneId\n+import kotlin.system.exitProcess\n+\n+fun run() {\n+    \/\/ the script needs to run in the directory where jmc is checked out:\n+    \/\/ kotlinc -script scripts\/copyrightchecker.main.kts\n+    val git = GitClient(\".\")\n+    CopyrightChecker.validateChanges(git.getCommitYear(), git.getChanges())\n+}\n+\n+treeWalk()\n+\n+class GitClient(jmcRepoPath: String) {\n+    private val git: Git\n+    private val repo: Repository\n+    private val head: RevCommit\n+    private val base: RevCommit\n+    init {\n+        val gitDir = File(jmcRepoPath)\n+        git = Git.open(gitDir)\n+        \/\/ TODO: fail if not in JMC repo\n+        repo = git.repository!!\n+        head = getHeadCommit()\n+        base = getBaseCommit()\n+        println(\"Checked out at: ${head.name} (base: ${base.name})\")\n+        \/\/ TODO: maybe fail if there are unstashed changes?\n+        \/\/ TODO: exit with success if head commit is on master\n+    }\n+\n+    private fun getHeadCommit(): RevCommit =\n+        RevWalk(repo).parseCommit(repo.resolve(Constants.HEAD))\n+\n+    private fun getBaseCommit(): RevCommit {\n+        val walk = RevWalk(repo)\n+        val master = walk.parseCommit(repo.resolve(\"master\"))\n+        walk.apply {\n+            revFilter = RevFilter.MERGE_BASE\n+            markStart(head)\n+            markStart(master)\n+        }\n+        return walk.next()\n+    }\n+\n+    private fun getBytes(reader: ObjectReader, shortId: AbbreviatedObjectId): ByteArray {\n+        val objId = reader.resolve(shortId).single()\n+        return reader.open(objId).bytes\n+    }\n+\n+    fun getChanges(): List<Change> {\n+        val headTree = repo.resolve(\"HEAD^{tree}\")\n+        val baseTree = repo.resolve(\"${base.name}^{tree}\")\n+        val reader: ObjectReader = repo.newObjectReader()\n+        val baseIter = CanonicalTreeParser().apply { reset(reader, baseTree) }\n+        val headIter = CanonicalTreeParser().apply { reset(reader, headTree) }\n+        return git.diff()\n+            .setNewTree(headIter)\n+            .setOldTree(baseIter)\n+            .call()\n+            .filterNot { it.changeType == DELETE }\n+            .map { diff ->\n+                when (diff.changeType) {\n+                    MODIFY, RENAME, COPY -> {\n+                        Change(\n+                            headPath = diff.newPath,\n+                            headBytes = getBytes(reader, diff.newId),\n+                            baseBytes = getBytes(reader, diff.oldId),\n+                        )\n+                    }\n+                    ADD -> Change(headPath = diff.newPath, headBytes = getBytes(reader, diff.newId))\n+                    else -> throw IllegalArgumentException(\"Unsupported: ${diff.changeType}\")\n+                }\n+            }\n+    }\n+\n+    fun getCommitYear(): Int =\n+        Instant.ofEpochSecond(head.commitTime.toLong()).atZone(ZoneId.of(\"Etc\/UTC\")).year\n+}\n+\n+class Change(\n+    val headPath: String,\n+    val headBytes: ByteArray,\n+    val baseBytes: ByteArray? = null,\n+    val basePath: String? = null\n+)\n+\n+data class Range(val start: Int, val end: Int? = null) {\n+    companion object {\n+        fun update(range: Range, year: Int): Range =\n+            if (range.start >= year) {\n+                range\n+            } else {\n+                Range(range.start, year)\n+            }\n+    }\n+    override fun toString(): String =\n+        if (end != null) {\n+            \"$start, $end\"\n+        } else {\n+            \"$start\"\n+        }\n+\n+    fun endsWith(year: Int): Boolean =\n+        if (end == null) {\n+            start == year\n+        } else {\n+            end == year\n+        }\n+}\n+\n+data class CopyrightString(val range: Range, val holder: CopyrightHolders) {\n+    companion object {\n+        fun parse(line: String): CopyrightString? {\n+            if (!line.contains(\"Copyright\")) return null\n+            return try {\n+                val regex = \"\"\".*Copyright \\(c\\) (\\d{4}),(?: (\\d{4}),)? ([^.]+).*\"\"\".toRegex()\n+                val match = regex.matchEntire(line) ?: throw IllegalArgumentException(\"failed to match regex\")\n+                CopyrightString(\n+                    range = Range(match.groups[1]!!.value.toInt(), match.groups[2]?.value?.toInt()),\n+                    holder = CopyrightHolders.fromString(match.groups[3]!!.value)\n+                )\n+            } catch (e: Exception) {\n+                throw IllegalArgumentException(\"ðŸŸ¡ Failed to parse '$line': $e\", e)\n+            }\n+        }\n+\n+        fun update(original: CopyrightString, endYear: Int): CopyrightString {\n+            return original.copy(range = Range.update(original.range, endYear))\n+        }\n+    }\n+    override fun toString() = \"Copyright (c) $range, ${holder.displayName}. All rights reserved.\"\n+}\n+\n+data class CopyrightHeader(val holders: List<CopyrightString>) {\n+    companion object {\n+        fun parse(fileContents: String): CopyrightHeader {\n+            val holders = fileContents.split(\"\\n\").mapNotNull { CopyrightString.parse(it) }\n+            return CopyrightHeader(holders)\n+        }\n+\n+        fun update(original: CopyrightHeader, endYear: Int): CopyrightHeader =\n+            CopyrightHeader(original.holders.map { CopyrightString.update(it, endYear) })\n+    }\n+    fun format(fileType: FileTypes): String {\n+        val prefix: String\n+        val before: List<String>\n+        val after: List<String>\n+        when (fileType) {\n+            FileTypes.JAVA -> {\n+                prefix = \" * \"\n+                before = listOf(\"\/*\")\n+                after = listOf(\" *\", \" * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\")\n+            }\n+            FileTypes.JAVASCRIPT -> {\n+                prefix = \" \"\n+                before = listOf(\"\/*\")\n+                after = listOf(\"\", \" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\")\n+            }\n+            FileTypes.XML -> {\n+                prefix = \"\\t\"\n+                before = listOf(\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\"\"\", \"<!--\")\n+                after = listOf(\"\", \"\\tDO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\")\n+            }\n+            FileTypes.UNSUPPORTED -> throw IllegalArgumentException(fileType.toString())\n+        }\n+        val headerLines = before + holders.map { \"$prefix$it\" } + after\n+        return headerLines.joinToString(\"\\n\")\n+    }\n+}\n+\n+class CopyrightChecker {\n+    companion object {\n+        fun validateChanges(commitYear: Int, changes: List<Change>) {\n+            if (changes.map { validateChange(it, commitYear) }.filterNot { it }.isNotEmpty()) {\n+                println()\n+                println(\"âŒ Validation failed\")\n+                exitProcess(1)\n+            } else {\n+                println(\"âœ… Validation succeeded\")\n+                exitProcess(0)\n+            }\n+        }\n+\n+        private fun validateChange(change: Change, year: Int): Boolean {\n+            val fileType = FileTypes.fromPath(change.headPath)\n+            if (fileType == FileTypes.UNSUPPORTED) {\n+                println(\"âšªï¸ ${change.headPath}\")\n+                return true\n+            }\n+            return if (change.baseBytes != null) {\n+                checkModifiedFile(change, year, fileType)\n+            } else {\n+                checkNewFile(change, year, fileType)\n+            }\n+        }\n+\n+        private fun checkModifiedFile(change: Change, year: Int, fileType: FileTypes): Boolean {\n+            val baseContent = String(change.baseBytes!!, Charsets.UTF_8)\n+            val baseHeader = try {\n+                CopyrightHeader.parse(baseContent)\n+            } catch (e: Exception) {\n+                println(\"ðŸŸ¡ ${change.headPath}\")\n+                println(\"Failed to parse header in base commit $change\")\n+                println(e.message)\n+                return false\n+            }\n+            val header = CopyrightHeader.update(baseHeader, year)\n+            val headContent = String(change.headBytes, Charsets.UTF_8)\n+            return checkContents(change.headPath, headContent, fileType, header)\n+        }\n+\n+        private fun checkNewFile(change: Change, year: Int, fileType: FileTypes): Boolean {\n+            val headContent = String(change.headBytes, Charsets.UTF_8)\n+            return try {\n+                val header = CopyrightHeader.parse(headContent)\n+                val invalid = header.holders.filter { it.range != Range(year) }\n+                if (invalid.isNotEmpty()) throw IllegalArgumentException(\"Invalid ranges $invalid\")\n+                if (header.holders.none { it.holder == CopyrightHolders.ORACLE }) {\n+                    throw IllegalArgumentException(\"Oracle copyright missing\")\n+                }\n+                checkContents(change.headPath, headContent, fileType, header)\n+            } catch (e: Exception) {\n+                println(\"ðŸ”´ ${change.headPath}\")\n+                println(e.message)\n+                false\n+            }\n+        }\n+\n+        private fun checkContents(filePath: String, fileContent: String, fileType: FileTypes, expectedHeader: CopyrightHeader): Boolean {\n+            val expected = expectedHeader.format(fileType)\n+            return if (fileContent.startsWith(expected)) {\n+                println(\"ðŸŸ¢ $filePath\")\n+                true\n+            } else {\n+                println(\"ðŸ”´ $filePath\")\n+                println(\"Expected:\")\n+                println(expected)\n+                println(\"Actual:\")\n+                println(fileContent.substring(0, expected.length + 1))\n+                println(\"(check whitespace if strings seem to match)\")\n+                false\n+            }\n+        }\n+    }\n+}\n+\n+enum class FileTypes {\n+    JAVA, JAVASCRIPT, XML, UNSUPPORTED;\n+    companion object {\n+        fun fromPath(path: String): FileTypes =\n+            if (isExcluded(path)) {\n+                UNSUPPORTED\n+            } else if (path.endsWith(\".java\")) {\n+                JAVA\n+            } else if (path.endsWith(\".js\")) {\n+                JAVASCRIPT\n+            } else if (path.endsWith(\".xml\")) {\n+                XML\n+            } else {\n+                UNSUPPORTED\n+            }\n+\n+        private fun isExcluded(path: String): Boolean =\n+            path.endsWith(\"plugin.xml\")\n+    }\n+}\n+\n+enum class CopyrightHolders(val displayName: String) {\n+    ORACLE(\"Oracle and\/or its affiliates\"),\n+    DATADOG(\"Datadog, Inc\"),\n+    RED_HAT(\"Red Hat Inc\");\n+    companion object {\n+        fun fromString(str: String) =\n+            values().find { it.displayName == str } ?: throw IllegalArgumentException(str)\n+    }\n+}\n+\n+\/\/ We could use something similar to validate all copyright notices in the repo:\n+\/\/\n+fun treeWalk() {\n+    val git = Git.open(File(\".\"))\n+    val repo = git.repository!!\n+    val revWalk = RevWalk(repo)\n+    val lastCommitId = repo.resolve(Constants.HEAD)!!\n+    val commit: RevCommit = revWalk.parseCommit(lastCommitId)\n+\n+    val tree: RevTree = commit.tree\n+    val treeWalk = TreeWalk(repo)\n+    treeWalk.addTree(tree)\n+    treeWalk.isRecursive = true\n+    treeWalk.filter = PathSuffixFilter.create(\".java\")\n+    var successes = 0\n+    var failures = 0\n+    while (treeWalk.next()) {\n+        git.log()\n+            .addPath(treeWalk.pathString)\n+            .setMaxCount(1)\n+            .call().forEach { lastCommit ->\n+                val year = Instant.ofEpochSecond(lastCommit.commitTime.toLong())\n+                    .atZone(ZoneId.of(\"Etc\/UTC\"))\n+                    .year\n+                try {\n+                    val header = CopyrightHeader.parse(File(treeWalk.pathString).readText(Charsets.UTF_8))\n+                    if (header.holders.none { it.holder == CopyrightHolders.ORACLE }) {\n+                        throw IllegalArgumentException(\"no Oracle copyright\")\n+                    }\n+                    if (header.holders.any { !it.range.endsWith(year) }) {\n+                        throw IllegalArgumentException(\"invalid range, expected to end with $year but was $header\")\n+                    }\n+                    println(\"ðŸŸ¢ ${treeWalk.pathString}\")\n+                    successes++\n+                } catch (e: Exception) {\n+                    println(\"ðŸ”´ ${treeWalk.pathString}\")\n+                    println(e.message)\n+                    failures++\n+                }\n+            }\n+    }\n+    println(\"$successes succeeded; $failures failed\")\n+}\n","filename":"scripts\/copyrightchecker.main.kts","additions":336,"deletions":0,"binary":false,"changes":336,"status":"added"}]}