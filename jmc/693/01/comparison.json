{"files":[{"filename":"application\/org.openjdk.jmc.flightrecorder.flamegraph\/icons\/butterfly.png","binary":true,"status":"added"},{"filename":"application\/org.openjdk.jmc.flightrecorder.flamegraph\/icons\/butterfly@2x.png","binary":true,"status":"added"},{"patch":"@@ -35,0 +35,1 @@\n+BUTTERFLY_VIEW_NAME=Butterfly\n","filename":"application\/org.openjdk.jmc.flightrecorder.flamegraph\/plugin.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,0 +45,7 @@\n+\t\t<view\n+\t\t\tallowMultiple=\"false\"\n+\t\t\tcategory=\"org.openjdk.jmc.ui.main\"\n+\t\t\tclass=\"org.openjdk.jmc.flightrecorder.flamegraph.views.ButterflyView\"\n+\t\t\ticon=\"icons\/butterfly.png\"\n+\t\t\tid=\"org.openjdk.jmc.flightrecorder.flamegraph.butterfly\"\n+\t\t\tname=\"%BUTTERFLY_VIEW_NAME\"\/>\n@@ -54,0 +61,6 @@\n+\t\t\t<view\n+\t\t\t\tid=\"org.openjdk.jmc.flightrecorder.flamegraph.butterfly\"\n+\t\t\t\trelationship=\"stack\"\n+\t\t\t\trelative=\"org.openjdk.jmc.flightrecorder.flamegraph\"\n+\t\t\t\tshowTitle=\"true\"\n+\t\t\t\tvisible=\"false\"\/>\n","filename":"application\/org.openjdk.jmc.flightrecorder.flamegraph\/plugin.xml","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -53,0 +53,5 @@\n+\tpublic static final String BUTTERFLYVIEW_CALLERS = \"BUTTERFLYVIEW_CALLERS\"; \/\/$NON-NLS-1$\n+\tpublic static final String BUTTERFLYVIEW_CALLEES = \"BUTTERFLYVIEW_CALLEES\"; \/\/$NON-NLS-1$\n+\tpublic static final String BUTTERFLYVIEW_SEARCH = \"BUTTERFLYVIEW_SEARCH\"; \/\/$NON-NLS-1$\n+\tpublic static final String BUTTERFLYVIEW_SELECT_METHOD = \"BUTTERFLYVIEW_SELECT_METHOD\"; \/\/$NON-NLS-1$\n+\tpublic static final String BUTTERFLYVIEW_NO_METHOD_SELECTED = \"BUTTERFLYVIEW_NO_METHOD_SELECTED\"; \/\/$NON-NLS-1$\n","filename":"application\/org.openjdk.jmc.flightrecorder.flamegraph\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/flamegraph\/Messages.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,556 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.flamegraph.views;\n+\n+import static org.openjdk.jmc.flightrecorder.flamegraph.MessagesUtils.getFlamegraphMessage;\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.Insets;\n+import java.awt.Rectangle;\n+import java.awt.RenderingHints;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Stream;\n+\n+import javax.swing.BorderFactory;\n+import javax.swing.JComponent;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingConstants;\n+import javax.swing.SwingUtilities;\n+\n+import org.eclipse.jface.viewers.ISelection;\n+import org.eclipse.jface.viewers.IStructuredSelection;\n+import org.eclipse.jface.window.DefaultToolTip;\n+import org.eclipse.jface.window.ToolTip;\n+import org.eclipse.swt.SWT;\n+import org.eclipse.swt.custom.SashForm;\n+import org.eclipse.swt.graphics.Point;\n+import org.eclipse.swt.widgets.Composite;\n+import org.eclipse.swt.widgets.Display;\n+import org.eclipse.ui.IMemento;\n+import org.eclipse.ui.ISelectionListener;\n+import org.eclipse.ui.IViewSite;\n+import org.eclipse.ui.IWorkbenchPart;\n+import org.eclipse.ui.PartInitException;\n+import org.eclipse.ui.part.ViewPart;\n+import org.openjdk.jmc.common.IMCMethod;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.item.ItemCollectionToolkit;\n+import org.openjdk.jmc.common.util.FormatToolkit;\n+import org.openjdk.jmc.flightrecorder.flamegraph.Messages;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkFilters;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;\n+import org.openjdk.jmc.common.item.ItemFilters;\n+import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator;\n+import org.openjdk.jmc.flightrecorder.stacktrace.tree.AggregatableFrame;\n+import org.openjdk.jmc.flightrecorder.stacktrace.tree.Node;\n+import org.openjdk.jmc.flightrecorder.stacktrace.tree.StacktraceTreeModel;\n+import org.openjdk.jmc.flightrecorder.ui.FlightRecorderUI;\n+import org.openjdk.jmc.flightrecorder.ui.selection.StacktraceFrameSelection;\n+import org.openjdk.jmc.ui.common.util.AdapterUtil;\n+import org.openjdk.jmc.ui.common.util.ThemeUtils;\n+import org.openjdk.jmc.ui.misc.PatternFly.Palette;\n+\n+import io.github.bric3.fireplace.core.ui.Colors;\n+import io.github.bric3.fireplace.flamegraph.ColorMapper;\n+import io.github.bric3.fireplace.flamegraph.DimmingFrameColorProvider;\n+import io.github.bric3.fireplace.flamegraph.FlamegraphView;\n+import io.github.bric3.fireplace.flamegraph.FlamegraphView.HoverListener;\n+import io.github.bric3.fireplace.flamegraph.FrameBox;\n+import io.github.bric3.fireplace.flamegraph.FrameFontProvider;\n+import io.github.bric3.fireplace.flamegraph.FrameModel;\n+import io.github.bric3.fireplace.flamegraph.FrameTextsProvider;\n+import io.github.bric3.fireplace.flamegraph.animation.ZoomAnimation;\n+import io.github.bric3.fireplace.swt_awt.EmbeddingComposite;\n+import io.github.bric3.fireplace.swt_awt.SWT_AWTBridge;\n+\n+public class ButterflyView extends ViewPart implements ISelectionListener {\n+\tprivate static final int MODEL_EXECUTOR_THREADS_NUMBER = 3;\n+\tprivate static final ExecutorService MODEL_EXECUTOR = Executors.newFixedThreadPool(MODEL_EXECUTOR_THREADS_NUMBER,\n+\t\t\tnew ThreadFactory() {\n+\t\t\t\tprivate final ThreadGroup group = new ThreadGroup(\"ButterflyModelCalculationGroup\");\n+\t\t\t\tprivate final AtomicInteger counter = new AtomicInteger();\n+\n+\t\t\t\t@Override\n+\t\t\t\tpublic Thread newThread(Runnable r) {\n+\t\t\t\t\tvar t = new Thread(group, r, \"ButterflyModelCalculation-\" + counter.getAndIncrement());\n+\t\t\t\t\tt.setDaemon(true);\n+\t\t\t\t\treturn t;\n+\t\t\t\t}\n+\t\t\t});\n+\n+\tprivate FrameSeparator frameSeparator;\n+\tprivate EmbeddingComposite embeddingComposite;\n+\tprivate FlamegraphView<Node> callersView;\n+\tprivate FlamegraphView<Node> calleesView;\n+\tprivate JLabel selectedMethodLabel;\n+\tprivate JPanel rootPanel;\n+\tprivate IItemCollection currentItems;\n+\tprivate volatile ModelState modelState = ModelState.NONE;\n+\tprivate ModelRebuildRunnable modelRebuildRunnable;\n+\tprivate IMCMethod selectedIMCMethod;\n+\n+\tprivate enum ModelState {\n+\t\tNOT_STARTED, STARTED, FINISHED, NONE\n+\t}\n+\n+\tprivate static class VerticalLabel extends JPanel {\n+\t\tprivate final String text;\n+\t\tprivate final Font font;\n+\t\tprivate final Color textColor;\n+\n+\t\tVerticalLabel(String text, Color bgColor, Color textColor) {\n+\t\t\tthis.text = text;\n+\t\t\tthis.textColor = textColor;\n+\t\t\tthis.font = new Font(Font.SANS_SERIF, Font.BOLD, 12);\n+\t\t\tsetBackground(bgColor);\n+\t\t\tsetPreferredSize(new Dimension(27, 100));\n+\t\t\tsetBorder(BorderFactory.createEmptyBorder(0, 1, 0, 2));\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected void paintComponent(Graphics g) {\n+\t\t\tsuper.paintComponent(g);\n+\t\t\tGraphics2D g2d = (Graphics2D) g.create();\n+\t\t\tg2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n+\t\t\tg2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n+\t\t\tg2d.setFont(font);\n+\t\t\tg2d.setColor(textColor);\n+\n+\t\t\tFontMetrics fm = g2d.getFontMetrics();\n+\t\t\tint textWidth = fm.stringWidth(text);\n+\t\t\tint textHeight = fm.getAscent();\n+\n+\t\t\tint x = (getWidth() - textHeight) \/ 2 + textHeight - 2;\n+\t\t\tint y = (getHeight() + textWidth) \/ 2;\n+\n+\t\t\tAffineTransform originalTransform = g2d.getTransform();\n+\t\t\tg2d.rotate(-Math.PI \/ 2, x, y);\n+\t\t\tg2d.drawString(text, x, y);\n+\t\t\tg2d.setTransform(originalTransform);\n+\t\t\tg2d.dispose();\n+\t\t}\n+\t}\n+\n+\tprivate static class ModelRebuildRunnable implements Runnable {\n+\n+\t\tprivate final ButterflyView view;\n+\t\tprivate final IItemCollection items;\n+\t\tprivate final IMCMethod pivotMethod;\n+\t\tprivate volatile boolean isInvalid;\n+\n+\t\tprivate ModelRebuildRunnable(ButterflyView view, IItemCollection items, IMCMethod pivotMethod) {\n+\t\t\tthis.view = view;\n+\t\t\tthis.items = items;\n+\t\t\tthis.pivotMethod = pivotMethod;\n+\t\t}\n+\n+\t\tprivate void setInvalid() {\n+\t\t\tthis.isInvalid = true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void run() {\n+\t\t\tfinal var start = System.currentTimeMillis();\n+\t\t\ttry {\n+\t\t\t\tview.modelState = ModelState.STARTED;\n+\t\t\t\tif (isInvalid) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tList<FrameBox<Node>> callerFrames = Collections.emptyList();\n+\t\t\t\tList<FrameBox<Node>> calleeFrames = Collections.emptyList();\n+\t\t\t\tAggregatableFrame foundPivotFrame = null;\n+\n+\t\t\t\tif (pivotMethod != null) {\n+\t\t\t\t\tString typeName = pivotMethod.getType().getFullName();\n+\t\t\t\t\tString methodName = pivotMethod.getMethodName();\n+\n+\t\t\t\t\tvar methodFilter = new JdkFilters.MethodFilter(typeName, methodName);\n+\t\t\t\t\tvar executionSampleFilter = ItemFilters.type(JdkTypeIDs.EXECUTION_SAMPLE);\n+\t\t\t\t\tvar filteredItems = items.apply(ItemFilters.and(executionSampleFilter, methodFilter));\n+\n+\t\t\t\t\tif (isInvalid) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tvar treeModel = new StacktraceTreeModel(filteredItems, view.frameSeparator, false, null,\n+\t\t\t\t\t\t\t() -> isInvalid);\n+\t\t\t\t\tif (isInvalid) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tvar callerSubtree = treeModel.extractPredecessorsFor(typeName, methodName);\n+\t\t\t\t\tif (callerSubtree != null) {\n+\t\t\t\t\t\tcallerFrames = convertToFrameBoxes(callerSubtree);\n+\t\t\t\t\t\tfoundPivotFrame = callerSubtree.getFrame();\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tvar calleeSubtree = treeModel.extractSuccessorsFor(typeName, methodName);\n+\t\t\t\t\tif (calleeSubtree != null) {\n+\t\t\t\t\t\tcalleeFrames = convertToFrameBoxes(calleeSubtree);\n+\t\t\t\t\t\tif (foundPivotFrame == null) {\n+\t\t\t\t\t\t\tfoundPivotFrame = calleeSubtree.getFrame();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (!isInvalid) {\n+\t\t\t\t\tview.modelState = ModelState.FINISHED;\n+\t\t\t\t\tview.setModel(items, callerFrames, calleeFrames, foundPivotFrame);\n+\t\t\t\t}\n+\t\t\t} finally {\n+\t\t\t\tfinal var duration = Duration.ofMillis(System.currentTimeMillis() - start);\n+\t\t\t\tFlightRecorderUI.getDefault().getLogger()\n+\t\t\t\t\t\t.info(\"butterfly model rebuild with isInvalid:\" + isInvalid + \" in \" + duration);\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate static List<FrameBox<Node>> convertToFrameBoxes(Node root) {\n+\t\t\tvar nodes = new ArrayList<FrameBox<Node>>();\n+\t\t\tFrameBox.flattenAndCalculateCoordinate(nodes, root, Node::getChildren, Node::getCumulativeWeight,\n+\t\t\t\t\tnode -> node.getChildren().stream().mapToDouble(Node::getCumulativeWeight).sum(), 0.0d, 1.0d, 0);\n+\t\t\treturn nodes;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void init(IViewSite site, IMemento memento) throws PartInitException {\n+\t\tsuper.init(site, memento);\n+\t\tframeSeparator = new FrameSeparator(FrameSeparator.FrameCategorization.METHOD, false);\n+\t\tgetSite().getPage().addSelectionListener(this);\n+\t}\n+\n+\t@Override\n+\tpublic void dispose() {\n+\t\tgetSite().getPage().removeSelectionListener(this);\n+\t\tsuper.dispose();\n+\t}\n+\n+\t@Override\n+\tpublic void createPartControl(Composite parent) {\n+\t\tvar container = new SashForm(parent, SWT.HORIZONTAL);\n+\t\tembeddingComposite = new EmbeddingComposite(container);\n+\t\tcontainer.setMaximizedControl(embeddingComposite);\n+\n+\t\tvar bgColorAwtColor = SWT_AWTBridge.toAWTColor(container.getBackground());\n+\t\tvar fgColorAwtColor = ThemeUtils.isDarkTheme() ? Palette.PF_BLACK_100.getAWTColor()\n+\t\t\t\t: Palette.PF_BLACK.getAWTColor();\n+\n+\t\tvar callersTooltip = new StyledToolTip(embeddingComposite, ToolTip.NO_RECREATE, true);\n+\t\tcallersTooltip.setPopupDelay(500);\n+\t\tcallersTooltip.setShift(new Point(10, 5));\n+\n+\t\tvar calleesTooltip = new StyledToolTip(embeddingComposite, ToolTip.NO_RECREATE, true);\n+\t\tcalleesTooltip.setPopupDelay(500);\n+\t\tcalleesTooltip.setShift(new Point(10, 5));\n+\n+\t\tembeddingComposite.init(() -> {\n+\t\t\trootPanel = new JPanel(new GridBagLayout());\n+\t\t\trootPanel.setBackground(bgColorAwtColor);\n+\t\t\tGridBagConstraints gbc = new GridBagConstraints();\n+\t\t\tgbc.fill = GridBagConstraints.BOTH;\n+\t\t\tgbc.insets = new Insets(0, 0, 0, 0);\n+\n+\t\t\tgbc.gridx = 0;\n+\t\t\tgbc.gridy = 0;\n+\t\t\tgbc.weightx = 0.0;\n+\t\t\tgbc.weighty = 0.45;\n+\t\t\tgbc.fill = GridBagConstraints.VERTICAL;\n+\t\t\tvar callersLabel = new VerticalLabel(getFlamegraphMessage(Messages.BUTTERFLYVIEW_CALLERS), bgColorAwtColor,\n+\t\t\t\t\tfgColorAwtColor);\n+\t\t\trootPanel.add(callersLabel, gbc);\n+\n+\t\t\tgbc.gridx = 1;\n+\t\t\tgbc.gridy = 0;\n+\t\t\tgbc.weightx = 1.0;\n+\t\t\tgbc.weighty = 0.45;\n+\t\t\tgbc.fill = GridBagConstraints.BOTH;\n+\t\t\tcallersView = createFlamegraph(embeddingComposite, callersTooltip, bgColorAwtColor);\n+\t\t\tcallersView.setMode(FlamegraphView.Mode.FLAMEGRAPH);\n+\t\t\tnew ZoomAnimation().install(callersView);\n+\t\t\tJComponent callersComponent = callersView.component;\n+\t\t\tcallersComponent.setBackground(bgColorAwtColor);\n+\t\t\trootPanel.add(callersComponent, gbc);\n+\n+\t\t\tgbc.gridx = 0;\n+\t\t\tgbc.gridy = 1;\n+\t\t\tgbc.gridwidth = 2;\n+\t\t\tgbc.weightx = 1.0;\n+\t\t\tgbc.weighty = 0.0;\n+\t\t\tgbc.fill = GridBagConstraints.HORIZONTAL;\n+\t\t\tselectedMethodLabel = new JLabel(getFlamegraphMessage(Messages.BUTTERFLYVIEW_SELECT_METHOD));\n+\t\t\tselectedMethodLabel.setHorizontalAlignment(SwingConstants.CENTER);\n+\t\t\tselectedMethodLabel.setFont(selectedMethodLabel.getFont().deriveFont(Font.BOLD, 14f));\n+\t\t\tselectedMethodLabel.setForeground(fgColorAwtColor);\n+\t\t\tselectedMethodLabel.setBorder(\n+\t\t\t\t\tBorderFactory.createCompoundBorder(BorderFactory.createMatteBorder(1, 0, 1, 0, fgColorAwtColor),\n+\t\t\t\t\t\t\tBorderFactory.createEmptyBorder(8, 8, 8, 8)));\n+\t\t\tselectedMethodLabel.setOpaque(true);\n+\t\t\tselectedMethodLabel.setBackground(bgColorAwtColor);\n+\t\t\trootPanel.add(selectedMethodLabel, gbc);\n+\n+\t\t\tgbc.gridwidth = 1;\n+\n+\t\t\tgbc.gridx = 0;\n+\t\t\tgbc.gridy = 2;\n+\t\t\tgbc.weightx = 0.0;\n+\t\t\tgbc.weighty = 0.45;\n+\t\t\tgbc.fill = GridBagConstraints.VERTICAL;\n+\t\t\tvar calleesLabel = new VerticalLabel(getFlamegraphMessage(Messages.BUTTERFLYVIEW_CALLEES), bgColorAwtColor,\n+\t\t\t\t\tfgColorAwtColor);\n+\t\t\trootPanel.add(calleesLabel, gbc);\n+\n+\t\t\tgbc.gridx = 1;\n+\t\t\tgbc.gridy = 2;\n+\t\t\tgbc.weightx = 1.0;\n+\t\t\tgbc.weighty = 0.45;\n+\t\t\tgbc.fill = GridBagConstraints.BOTH;\n+\t\t\tcalleesView = createFlamegraph(embeddingComposite, calleesTooltip, bgColorAwtColor);\n+\t\t\tcalleesView.setMode(FlamegraphView.Mode.ICICLEGRAPH);\n+\t\t\tnew ZoomAnimation().install(calleesView);\n+\t\t\tJComponent calleesComponent = calleesView.component;\n+\t\t\tcalleesComponent.setBackground(bgColorAwtColor);\n+\t\t\trootPanel.add(calleesComponent, gbc);\n+\n+\t\t\treturn rootPanel;\n+\t\t});\n+\t}\n+\n+\tprivate FlamegraphView<Node> createFlamegraph(Composite owner, DefaultToolTip tooltip, Color bgColor) {\n+\t\tvar fg = new FlamegraphView<Node>();\n+\t\tfg.putClientProperty(FlamegraphView.SHOW_STATS, false);\n+\t\tfg.setShowMinimap(false);\n+\n+\t\tfg.setRenderConfiguration(\n+\t\t\t\tFrameTextsProvider.of(\n+\t\t\t\t\t\tframe -> frame.isRoot() ? \"\" : frame.actualNode.getFrame().getHumanReadableShortString(),\n+\t\t\t\t\t\tframe -> frame.isRoot() ? \"\"\n+\t\t\t\t\t\t\t\t: FormatToolkit.getHumanReadable(frame.actualNode.getFrame().getMethod(), false, false,\n+\t\t\t\t\t\t\t\t\t\tfalse, false, true, false),\n+\t\t\t\t\t\tframe -> frame.isRoot() ? \"\" : frame.actualNode.getFrame().getMethod().getMethodName()),\n+\t\t\t\tnew DimmingFrameColorProvider<>(frame -> ColorMapper.ofObjectHashUsing(Colors.Palette.DATADOG.colors())\n+\t\t\t\t\t\t.apply(frame.actualNode.getFrame().getMethod().getType().getPackage())),\n+\t\t\t\tFrameFontProvider.defaultFontProvider());\n+\n+\t\tfg.setHoverListener(new HoverListener<Node>() {\n+\t\t\t@Override\n+\t\t\tpublic void onStopHover(FrameBox<Node> frameBox, Rectangle frameRect, MouseEvent mouseEvent) {\n+\t\t\t\tDisplay.getDefault().asyncExec(tooltip::hide);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void onFrameHover(FrameBox<Node> frameBox, Rectangle frameRect, MouseEvent mouseEvent) {\n+\t\t\t\tif (frameBox.isRoot()) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tvar method = frameBox.actualNode.getFrame().getMethod();\n+\t\t\t\tvar escapedMethod = frameBox.actualNode.getFrame().getHumanReadableShortString().replace(\"<\", \"&lt;\")\n+\t\t\t\t\t\t.replace(\">\", \"&gt;\");\n+\t\t\t\tvar sb = new StringBuilder().append(\"<form><p>\").append(\"<b>\").append(escapedMethod)\n+\t\t\t\t\t\t.append(\"<\/b><br\/>\");\n+\n+\t\t\t\tvar packageName = method.getType().getPackage();\n+\t\t\t\tif (packageName != null) {\n+\t\t\t\t\tsb.append(packageName).append(\"<br\/>\");\n+\t\t\t\t}\n+\t\t\t\tsb.append(\"<hr\/>Weight: \").append(frameBox.actualNode.getCumulativeWeight()).append(\"<br\/>\");\n+\t\t\t\tsb.append(\"<\/p><\/form>\");\n+\n+\t\t\t\tDisplay.getDefault().asyncExec(() -> {\n+\t\t\t\t\tvar control = Display.getDefault().getCursorControl();\n+\t\t\t\t\tif (Objects.equals(owner, control)) {\n+\t\t\t\t\t\ttooltip.setText(sb.toString());\n+\t\t\t\t\t\ttooltip.hide();\n+\t\t\t\t\t\tvar componentPoint = SwingUtilities.convertPoint(mouseEvent.getComponent(),\n+\t\t\t\t\t\t\t\tmouseEvent.getPoint(), rootPanel);\n+\t\t\t\t\t\ttooltip.show(SWT_AWTBridge.toSWTPoint(componentPoint));\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\t\t}\n+\t\t});\n+\n+\t\treturn fg;\n+\t}\n+\n+\t@Override\n+\tpublic void selectionChanged(IWorkbenchPart part, ISelection selection) {\n+\t\tif (selection instanceof IStructuredSelection) {\n+\t\t\tvar first = ((IStructuredSelection) selection).getFirstElement();\n+\n+\t\t\tif (first instanceof StacktraceFrameSelection) {\n+\t\t\t\tvar frameSelection = (StacktraceFrameSelection) first;\n+\t\t\t\tvar method = frameSelection.getMethod();\n+\t\t\t\tvar items = frameSelection.getFullItems();\n+\t\t\t\tif (items == null) {\n+\t\t\t\t\titems = frameSelection.getSelectedItems();\n+\t\t\t\t}\n+\n+\t\t\t\tif (items != null && method != null && !isSameMethod(method, selectedIMCMethod)) {\n+\t\t\t\t\tselectedIMCMethod = method;\n+\t\t\t\t\tcurrentItems = items;\n+\t\t\t\t\tupdateMethodLabel(method);\n+\t\t\t\t\ttriggerRebuildTask(items, method);\n+\t\t\t\t} else if (items != null && !items.equals(currentItems)) {\n+\t\t\t\t\tcurrentItems = items;\n+\t\t\t\t\tif (selectedIMCMethod != null) {\n+\t\t\t\t\t\ttriggerRebuildTask(items, selectedIMCMethod);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tvar items = AdapterUtil.getAdapter(first, IItemCollection.class);\n+\t\t\tif (items == null) {\n+\t\t\t\tcurrentItems = ItemCollectionToolkit.build(Stream.empty());\n+\t\t\t} else if (!items.equals(currentItems)) {\n+\t\t\t\tcurrentItems = items;\n+\t\t\t\tif (selectedIMCMethod != null) {\n+\t\t\t\t\ttriggerRebuildTask(items, selectedIMCMethod);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void updateMethodLabel(IMCMethod method) {\n+\t\tString methodDescription = FormatToolkit.getHumanReadable(method, false, false, true, true, true, false);\n+\t\tSwingUtilities.invokeLater(() -> {\n+\t\t\tif (selectedMethodLabel != null) {\n+\t\t\t\tselectedMethodLabel.setText(methodDescription);\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\tprivate boolean isSameMethod(IMCMethod m1, IMCMethod m2) {\n+\t\tif (m1 == m2) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (m1 == null || m2 == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn Objects.equals(m1.getMethodName(), m2.getMethodName())\n+\t\t\t\t&& Objects.equals(m1.getType().getFullName(), m2.getType().getFullName());\n+\t}\n+\n+\t@Override\n+\tpublic void setFocus() {\n+\t\tembeddingComposite.setFocus();\n+\t}\n+\n+\tprivate void triggerRebuildTask(IItemCollection items, IMCMethod pivotMethod) {\n+\t\tif (modelRebuildRunnable != null) {\n+\t\t\tmodelRebuildRunnable.setInvalid();\n+\t\t}\n+\n+\t\tcurrentItems = items;\n+\t\tmodelState = ModelState.NOT_STARTED;\n+\t\tmodelRebuildRunnable = new ModelRebuildRunnable(this, items, pivotMethod);\n+\t\tif (!modelRebuildRunnable.isInvalid) {\n+\t\t\tMODEL_EXECUTOR.execute(modelRebuildRunnable);\n+\t\t}\n+\t}\n+\n+\tprivate void setModel(\n+\t\tIItemCollection items, List<FrameBox<Node>> callerFrames, List<FrameBox<Node>> calleeFrames,\n+\t\tAggregatableFrame pivotFrame) {\n+\t\tif (ModelState.FINISHED.equals(modelState) && items.equals(currentItems)) {\n+\t\t\tSwingUtilities.invokeLater(() -> {\n+\t\t\t\tString pivotDescription = pivotFrame != null ? pivotFrame.getHumanReadableShortString()\n+\t\t\t\t\t\t: getFlamegraphMessage(Messages.BUTTERFLYVIEW_NO_METHOD_SELECTED);\n+\n+\t\t\t\tselectedMethodLabel.setText(pivotDescription);\n+\n+\t\t\t\tcallersView.setModel(new FrameModel<>(getFlamegraphMessage(Messages.BUTTERFLYVIEW_CALLERS),\n+\t\t\t\t\t\t(frameA, frameB) -> Objects.equals(frameA.actualNode.getFrame(), frameB.actualNode.getFrame()),\n+\t\t\t\t\t\tcallerFrames));\n+\n+\t\t\t\tcalleesView.setModel(new FrameModel<>(getFlamegraphMessage(Messages.BUTTERFLYVIEW_CALLEES),\n+\t\t\t\t\t\t(frameA, frameB) -> Objects.equals(frameA.actualNode.getFrame(), frameB.actualNode.getFrame()),\n+\t\t\t\t\t\tcalleeFrames));\n+\n+\t\t\t\tscrollCallersViewToBottom();\n+\t\t\t});\n+\t\t}\n+\t}\n+\n+\tprivate void scrollCallersViewToBottom() {\n+\t\tJScrollPane scrollPane = findScrollPane(callersView.component);\n+\t\tif (scrollPane != null) {\n+\t\t\tvar verticalBar = scrollPane.getVerticalScrollBar();\n+\t\t\tvar listener = new java.awt.event.AdjustmentListener() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void adjustmentValueChanged(java.awt.event.AdjustmentEvent e) {\n+\t\t\t\t\tverticalBar.removeAdjustmentListener(this);\n+\t\t\t\t\tSwingUtilities.invokeLater(() -> {\n+\t\t\t\t\t\tverticalBar.setValue(verticalBar.getMaximum());\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\t\t\t};\n+\t\t\tverticalBar.addAdjustmentListener(listener);\n+\t\t}\n+\t}\n+\n+\tprivate JScrollPane findScrollPane(java.awt.Container container) {\n+\t\tfor (java.awt.Component child : container.getComponents()) {\n+\t\t\tif (child instanceof JScrollPane) {\n+\t\t\t\treturn (JScrollPane) child;\n+\t\t\t}\n+\t\t\tif (child instanceof java.awt.Container) {\n+\t\t\t\tJScrollPane found = findScrollPane((java.awt.Container) child);\n+\t\t\t\tif (found != null) {\n+\t\t\t\t\treturn found;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+}\n","filename":"application\/org.openjdk.jmc.flightrecorder.flamegraph\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/flamegraph\/views\/ButterflyView.java","additions":556,"deletions":0,"binary":false,"changes":556,"status":"added"},{"patch":"@@ -60,0 +60,5 @@\n+BUTTERFLYVIEW_CALLERS=Callers\n+BUTTERFLYVIEW_CALLEES=Callees\n+BUTTERFLYVIEW_SEARCH=Search:\n+BUTTERFLYVIEW_SELECT_METHOD=Select a method (e.g. in the Method Profiling page)\n+BUTTERFLYVIEW_NO_METHOD_SELECTED=No method selected\n","filename":"application\/org.openjdk.jmc.flightrecorder.flamegraph\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/flamegraph\/messages.properties","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,0 +60,5 @@\n+BUTTERFLYVIEW_CALLERS=Callers\n+BUTTERFLYVIEW_CALLEES=Callees\n+BUTTERFLYVIEW_SEARCH=Search:\n+BUTTERFLYVIEW_SELECT_METHOD=Select a method (e.g. in the Method Profiling page)\n+BUTTERFLYVIEW_NO_METHOD_SELECTED=No method selected\n","filename":"application\/org.openjdk.jmc.flightrecorder.flamegraph\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/flamegraph\/messages_ja.properties","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,0 +60,5 @@\n+BUTTERFLYVIEW_CALLERS=Callers\n+BUTTERFLYVIEW_CALLEES=Callees\n+BUTTERFLYVIEW_SEARCH=Search:\n+BUTTERFLYVIEW_SELECT_METHOD=Select a method (e.g. in the Method Profiling page)\n+BUTTERFLYVIEW_NO_METHOD_SELECTED=No method selected\n","filename":"application\/org.openjdk.jmc.flightrecorder.flamegraph\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/flamegraph\/messages_zh.properties","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -363,1 +363,14 @@\n-         <pages weight=\"100\" file=\"defaultPages.xml\" \/> \n+         <pages weight=\"100\" file=\"defaultPages.xml\" \/>\n+   <\/extension>\n+\n+   <extension point=\"org.eclipse.core.runtime.adapters\">\n+      <factory\n+            adaptableType=\"org.openjdk.jmc.flightrecorder.ui.selection.StacktraceFrameSelection\"\n+            class=\"org.openjdk.jmc.flightrecorder.ui.selection.FlavoredSelectionAdapterFactory\">\n+         <adapter type=\"org.openjdk.jmc.common.item.IItemCollection\"\/>\n+      <\/factory>\n+      <factory\n+            adaptableType=\"org.openjdk.jmc.flightrecorder.ui.selection.ItemBackedSelection\"\n+            class=\"org.openjdk.jmc.flightrecorder.ui.selection.FlavoredSelectionAdapterFactory\">\n+         <adapter type=\"org.openjdk.jmc.common.item.IItemCollection\"\/>\n+      <\/factory>\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/plugin.xml","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-\t\tgetSite().getSelectionProvider().setSelection(selection);\n+\t\tgetSite().getSelectionProvider().setSelection(new StructuredSelection(selection));\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/JfrEditor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+import org.openjdk.jmc.common.util.MCFrame;\n@@ -118,0 +119,1 @@\n+import org.openjdk.jmc.flightrecorder.ui.selection.StacktraceFrameSelection;\n@@ -261,2 +263,13 @@\n-\t\t\ttable.getManager().getViewer()\n-\t\t\t\t\t.addSelectionChangedListener(e -> pageContainer.showSelection(table.getSelection().getItems()));\n+\t\t\ttable.getManager().getViewer().addSelectionChangedListener(e -> {\n+\t\t\t\tvar selection = table.getSelection();\n+\t\t\t\tvar items = selection.getItems();\n+\t\t\t\tvar methodOpt = selection.getSelectedRows((key, rowItems) -> (MethodWithFrameType) key).findFirst();\n+\t\t\t\tif (methodOpt.isPresent()) {\n+\t\t\t\t\tvar methodWithType = methodOpt.get();\n+\t\t\t\t\tvar frame = new MCFrame(methodWithType.getMethod(), null, null, methodWithType.getFrameType());\n+\t\t\t\t\tpageContainer.showSelection(new StacktraceFrameSelection(frame, items, getDataSource().getItems(),\n+\t\t\t\t\t\t\tMessages.MethodProfilingPage_PAGE_NAME));\n+\t\t\t\t} else {\n+\t\t\t\t\tpageContainer.showSelection(items);\n+\t\t\t\t}\n+\t\t\t});\n@@ -393,2 +406,2 @@\n-\t\tprivate void mergeNode(SuccessorTreeModel model, SuccessorNode destNode, Node srcNode) {\n-\t\t\tdestNode.count += (int) srcNode.getCumulativeWeight();\n+\t\tprivate SuccessorNode convertToSuccessorNode(SuccessorTreeModel model, SuccessorNode parent, Node srcNode) {\n+\t\t\tSuccessorNode node = new SuccessorNode(model, parent, srcNode);\n@@ -396,18 +409,2 @@\n-\t\t\t\tString key = SuccessorTreeModel.makeKey(child.getFrame());\n-\t\t\t\tSuccessorNode existing = destNode.children.putIfAbsent(key, new SuccessorNode(model, destNode, child));\n-\t\t\t\tif (existing != null) {\n-\t\t\t\t\tmergeNode(model, existing, child);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tprivate void traverse(Node current, String typeName, String methodName, SuccessorTreeModel model) {\n-\t\t\tif (methodName.equals(current.getFrame().getMethod().getMethodName())\n-\t\t\t\t\t&& typeName.equals(current.getFrame().getMethod().getType().getFullName())) {\n-\t\t\t\tif (model.root == null) {\n-\t\t\t\t\tmodel.root = new SuccessorNode(model, null, current);\n-\t\t\t\t}\n-\t\t\t\tmergeNode(model, model.root, current);\n-\t\t\t}\n-\t\t\tfor (Node child : current.getChildren()) {\n-\t\t\t\ttraverse(child, typeName, methodName, model);\n+\t\t\t\tString key = child.getFrame().getMethodKey();\n+\t\t\t\tnode.children.put(key, convertToSuccessorNode(model, node, child));\n@@ -415,0 +412,1 @@\n+\t\t\treturn node;\n@@ -468,1 +466,0 @@\n-\t\t\t\t\/\/ Filters event containing the current method\n@@ -472,0 +469,4 @@\n+\t\t\t\tNode successorRoot = stacktraceTreeModel.extractSuccessorsFor(typeName, methodName);\n+\t\t\t\tif (successorRoot == null) {\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n@@ -473,1 +474,1 @@\n-\t\t\t\ttraverse(stacktraceTreeModel.getRoot(), typeName, methodName, model);\n+\t\t\t\tmodel.root = convertToSuccessorNode(model, null, successorRoot);\n@@ -796,4 +797,0 @@\n-\n-\t\tpublic static String makeKey(IMCFrame frame) {\n-\t\t\treturn frame.getMethod().getType().getFullName() + \"::\" + frame.getMethod().getMethodName();\n-\t\t}\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/pages\/MethodProfilingPage.java","additions":25,"deletions":28,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.ui.selection;\n+\n+import org.eclipse.core.runtime.IAdapterFactory;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+\n+\/**\n+ * Adapter factory that enables IFlavoredSelection implementations to be adapted to IItemCollection.\n+ * This allows views that expect IItemCollection selections to work with flavored selections.\n+ *\/\n+public class FlavoredSelectionAdapterFactory implements IAdapterFactory {\n+\n+\tprivate static final Class<?>[] ADAPTER_LIST = new Class<?>[] {IItemCollection.class};\n+\n+\t@Override\n+\tpublic <T> T getAdapter(Object adaptableObject, Class<T> adapterType) {\n+\t\tif (adapterType == IItemCollection.class) {\n+\t\t\tif (adaptableObject instanceof StacktraceFrameSelection) {\n+\t\t\t\treturn adapterType.cast(((StacktraceFrameSelection) adaptableObject).getSelectedItems());\n+\t\t\t}\n+\t\t\tif (adaptableObject instanceof ItemBackedSelection) {\n+\t\t\t\treturn adapterType.cast(((ItemBackedSelection) adaptableObject).getItems());\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic Class<?>[] getAdapterList() {\n+\t\treturn ADAPTER_LIST;\n+\t}\n+}\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/selection\/FlavoredSelectionAdapterFactory.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -55,0 +55,1 @@\n+\tprivate IItemCollection fullItems;\n@@ -57,0 +58,5 @@\n+\t\tthis(frame, selectedItems, null, name);\n+\t}\n+\n+\tpublic StacktraceFrameSelection(IMCFrame frame, IItemCollection selectedItems, IItemCollection fullItems,\n+\t\t\tString name) {\n@@ -60,0 +66,24 @@\n+\t\tthis.fullItems = fullItems;\n+\t}\n+\n+\tpublic IMCFrame getFrame() {\n+\t\treturn frame;\n+\t}\n+\n+\tpublic IMCMethod getMethod() {\n+\t\treturn frame != null ? frame.getMethod() : null;\n+\t}\n+\n+\tpublic IItemCollection getSelectedItems() {\n+\t\treturn selectedItems;\n+\t}\n+\n+\t\/**\n+\t * Returns the full\/unfiltered item collection from the recording. This can be used by views\n+\t * that need to apply their own filters (e.g., to find all events containing a method anywhere\n+\t * in the stack trace, not just at the top).\n+\t *\n+\t * @return the full item collection, or null if not available\n+\t *\/\n+\tpublic IItemCollection getFullItems() {\n+\t\treturn fullItems;\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/selection\/StacktraceFrameSelection.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-\t\tpublic static final Type UNKNOWN = new Type(\"UNKNONW\"); \/\/$NON-NLS-1$\n+\t\tpublic static final Type UNKNOWN = new Type(\"UNKNOWN\"); \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.common\/src\/main\/java\/org\/openjdk\/jmc\/common\/IMCFrame.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import org.openjdk.jmc.flightrecorder.stacktrace.Messages;\n@@ -138,0 +139,15 @@\n+\n+\t\/**\n+\t * Returns a unique key for this frame based on the fully qualified class name and method name.\n+\t * This key can be used for merging frames from different stack traces.\n+\t *\n+\t * @return a key in the format \"fully.qualified.ClassName::methodName\", or a sentinel value for\n+\t *         special frames (root or unclassifiable frames from truncated stacks)\n+\t *\/\n+\tpublic String getMethodKey() {\n+\t\tIMCMethod method = frame.getMethod();\n+\t\tif (method == null || method.getType() == null) {\n+\t\t\treturn Messages.getString(Messages.STACKTRACE_UNCLASSIFIABLE_FRAME);\n+\t\t}\n+\t\treturn method.getType().getFullName() + \"::\" + method.getMethodName();\n+\t}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/stacktrace\/tree\/AggregatableFrame.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -126,0 +126,20 @@\n+\tpublic void setWeight(double weight) {\n+\t\tthis.weight = weight;\n+\t}\n+\n+\tpublic void setCumulativeWeight(double cumulativeWeight) {\n+\t\tthis.cumulativeWeight = cumulativeWeight;\n+\t}\n+\n+\tpublic void addWeight(double delta) {\n+\t\tthis.weight += delta;\n+\t}\n+\n+\tpublic void addCumulativeWeight(double delta) {\n+\t\tthis.cumulativeWeight += delta;\n+\t}\n+\n+\tpublic void addChild(Node child) {\n+\t\tthis.children.add(child);\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/stacktrace\/tree\/Node.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import org.openjdk.jmc.common.IMCMethod;\n@@ -275,0 +276,122 @@\n+\n+\t\/**\n+\t * Extracts a merged tree of successors (callees) for a given method. This finds all occurrences\n+\t * of the specified method in the tree and merges their subtrees into a single tree rooted at\n+\t * the method.\n+\t *\n+\t * @param typeName\n+\t *            the fully qualified class name of the method\n+\t * @param methodName\n+\t *            the method name\n+\t * @return a new Node representing the merged successor tree, or null if the method is not found\n+\t *\/\n+\tpublic Node extractSuccessorsFor(String typeName, String methodName) {\n+\t\tAggregatableFrame pivotFrame = findFirstMatchingFrame(root, typeName, methodName);\n+\t\tif (pivotFrame == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tNode result = Node.newRootNode(pivotFrame);\n+\t\ttraverseForSuccessors(root, typeName, methodName, result);\n+\t\treturn result.getCumulativeWeight() > 0 ? result : null;\n+\t}\n+\n+\tprivate boolean matchesMethod(Node node, String typeName, String methodName) {\n+\t\tIMCMethod method = node.getFrame().getMethod();\n+\t\treturn method != null && methodName.equals(method.getMethodName())\n+\t\t\t\t&& typeName.equals(method.getType().getFullName());\n+\t}\n+\n+\tprivate AggregatableFrame findFirstMatchingFrame(Node current, String typeName, String methodName) {\n+\t\tif (matchesMethod(current, typeName, methodName)) {\n+\t\t\treturn current.getFrame();\n+\t\t}\n+\t\tfor (Node child : current.getChildren()) {\n+\t\t\tAggregatableFrame found = findFirstMatchingFrame(child, typeName, methodName);\n+\t\t\tif (found != null) {\n+\t\t\t\treturn found;\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprivate void traverseForSuccessors(Node current, String typeName, String methodName, Node result) {\n+\t\tif (matchesMethod(current, typeName, methodName)) {\n+\t\t\tmergeSuccessorNode(result, current);\n+\t\t}\n+\t\tfor (Node child : current.getChildren()) {\n+\t\t\ttraverseForSuccessors(child, typeName, methodName, result);\n+\t\t}\n+\t}\n+\n+\tprivate void mergeSuccessorNode(Node destNode, Node srcNode) {\n+\t\tdestNode.addCumulativeWeight(srcNode.getCumulativeWeight());\n+\t\tfor (Node child : srcNode.getChildren()) {\n+\t\t\tString key = child.getFrame().getMethodKey();\n+\t\t\tNode existing = findChildByKey(destNode, key);\n+\t\t\tif (existing == null) {\n+\t\t\t\tNode newChild = new Node(destNode, child.getFrame());\n+\t\t\t\tdestNode.addChild(newChild);\n+\t\t\t\tmergeSuccessorNode(newChild, child);\n+\t\t\t} else {\n+\t\t\t\tmergeSuccessorNode(existing, child);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Node findChildByKey(Node parent, String key) {\n+\t\tfor (Node child : parent.getChildren()) {\n+\t\t\tif (child.getFrame().getMethodKey().equals(key)) {\n+\t\t\t\treturn child;\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t\/**\n+\t * Extracts a merged tree of predecessors (callers) for a given method. This finds all\n+\t * occurrences of the specified method in the tree and merges their ancestor chains into a\n+\t * single inverted tree rooted at the method.\n+\t *\n+\t * @param typeName\n+\t *            the fully qualified class name of the method\n+\t * @param methodName\n+\t *            the method name\n+\t * @return a new Node representing the merged predecessor tree, or null if the method is not\n+\t *         found\n+\t *\/\n+\tpublic Node extractPredecessorsFor(String typeName, String methodName) {\n+\t\tAggregatableFrame pivotFrame = findFirstMatchingFrame(root, typeName, methodName);\n+\t\tif (pivotFrame == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tNode result = Node.newRootNode(pivotFrame);\n+\t\ttraverseForPredecessors(root, typeName, methodName, result);\n+\t\treturn result.getCumulativeWeight() > 0 ? result : null;\n+\t}\n+\n+\tprivate void traverseForPredecessors(Node current, String typeName, String methodName, Node result) {\n+\t\tif (matchesMethod(current, typeName, methodName)) {\n+\t\t\tresult.addCumulativeWeight(current.getCumulativeWeight());\n+\t\t\tmergePredecessorChain(result, current.getParent(), current.getCumulativeWeight());\n+\t\t}\n+\t\tfor (Node child : current.getChildren()) {\n+\t\t\ttraverseForPredecessors(child, typeName, methodName, result);\n+\t\t}\n+\t}\n+\n+\tprivate void mergePredecessorChain(Node destNode, Node srcAncestor, double weight) {\n+\t\tif (srcAncestor == null || srcAncestor.isRoot()) {\n+\t\t\treturn;\n+\t\t}\n+\t\tString key = srcAncestor.getFrame().getMethodKey();\n+\t\tNode existing = findChildByKey(destNode, key);\n+\t\tif (existing == null) {\n+\t\t\tNode newChild = new Node(destNode, srcAncestor.getFrame());\n+\t\t\tnewChild.addCumulativeWeight(weight);\n+\t\t\tdestNode.addChild(newChild);\n+\t\t\tmergePredecessorChain(newChild, srcAncestor.getParent(), weight);\n+\t\t} else {\n+\t\t\texisting.addCumulativeWeight(weight);\n+\t\t\tmergePredecessorChain(existing, srcAncestor.getParent(), weight);\n+\t\t}\n+\t}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/stacktrace\/tree\/StacktraceTreeModel.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"modified"}]}