{"files":[{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import org.openjdk.jmc.flightrecorder.writer.api.Annotation;\n+import org.openjdk.jmc.flightrecorder.writer.api.AnnotationElementBuilder;\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedValue;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedValueBuilder;\n+\n+import java.util.function.Consumer;\n+\n+final class AnnotationElementBuilderImpl implements AnnotationElementBuilder {\n+\tprivate final Type type;\n+\n+\tAnnotationElementBuilderImpl(Type type) {\n+\t\tthis.type = type;\n+\t}\n+\n+\t@Override\n+\tpublic AnnotationElementBuilder addArgument(String name, TypedValue value) {\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic AnnotationElementBuilder addArgument(String name, Consumer<TypedValueBuilder> builderCallback) {\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic Annotation build() {\n+\t\treturn new Annotation(type, (String) null);\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/AnnotationElementBuilderImpl.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -48,0 +48,2 @@\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedFieldValue;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedValue;\n@@ -307,2 +309,15 @@\n-\t\t\tif (annotation.getValue() != null) {\n-\t\t\t\tstoreString(annotation.getValue());\n+\t\t\tfor (Map.Entry<String, ? extends TypedFieldValue> entry : annotation.getAttributes().entrySet()) {\n+\t\t\t\tTypedFieldValue typedValue = entry.getValue();\n+\t\t\t\t\/\/ value arrays are encoded as 'attributeName-N' where N starts at 0\n+\t\t\t\tif (typedValue.getField().isArray()) {\n+\t\t\t\t\tTypedValue[] vals = typedValue.getValues();\n+\t\t\t\t\tfor (int i = 0; i < vals.length; i++) {\n+\t\t\t\t\t\tTypedValue val = vals[i];\n+\t\t\t\t\t\tstoreString(entry.getKey() + \"-\" + i);\n+\t\t\t\t\t\tstoreString(Objects.toString(val.getValue()));\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tObject val = typedValue.getValue() != null ? typedValue.getValue().getValue() : null;\n+\t\t\t\t\tstoreString(entry.getKey());\n+\t\t\t\t\tstoreString(Objects.toString(val));\n+\t\t\t\t}\n@@ -436,4 +451,22 @@\n-\t\twriter.writeInt(annotation.getValue() != null ? 2 : 1) \/\/ number of attributes\n-\t\t\t\t.writeInt(stringIndex(CLASS_KEY)).writeInt(stringIndex(String.valueOf(annotation.getType().getId())));\n-\t\tif (annotation.getValue() != null) {\n-\t\t\twriter.writeInt(stringIndex(VALUE_KEY)).writeInt(stringIndex(annotation.getValue()));\n+\t\tint len = 1 + annotation.getAttributes().size();\n+\t\tfor (TypedFieldValue value : annotation.getAttributes().values()) {\n+\t\t\tif (value.getField().isArray()) {\n+\t\t\t\tlen += (value.getValues().length - 1); \/\/ add the number of synthetic attributes and remove the base one\n+\t\t\t}\n+\t\t}\n+\t\twriter.writeInt(len).writeInt(stringIndex(CLASS_KEY))\n+\t\t\t\t.writeInt(stringIndex(String.valueOf(annotation.getType().getId())));\n+\t\tfor (Map.Entry<String, ? extends TypedFieldValue> entry : annotation.getAttributes().entrySet()) {\n+\t\t\tTypedFieldValue typedValue = entry.getValue();\n+\t\t\tif (typedValue.getField().isArray()) {\n+\t\t\t\t\/\/ value arrays are encoded as 'attributeName-N' where N starts at 0\n+\t\t\t\tTypedValue[] vals = typedValue.getValues();\n+\t\t\t\tfor (int i = 0; i < vals.length; i++) {\n+\t\t\t\t\tTypedValue val = vals[i];\n+\t\t\t\t\twriter.writeInt(stringIndex(entry.getKey() + \"-\" + i))\n+\t\t\t\t\t\t\t.writeInt(stringIndex(Objects.toString(val.getValue())));\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tObject val = typedValue.getValue() != null ? typedValue.getValue().getValue() : null;\n+\t\t\t\twriter.writeInt(stringIndex(entry.getKey())).writeInt(stringIndex(Objects.toString(val)));\n+\t\t\t}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/MetadataImpl.java","additions":39,"deletions":6,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedValueBuilder;\n@@ -101,1 +102,1 @@\n-\t\treturn addAnnotation(type, null);\n+\t\treturn addAnnotation(type, (String) null);\n@@ -110,0 +111,25 @@\n+\t@Override\n+\tpublic TypeStructureBuilderImpl addAnnotation(Types.Predefined type) {\n+\t\treturn addAnnotation(types.getType(type));\n+\t}\n+\n+\t@Override\n+\tpublic TypeStructureBuilderImpl addAnnotation(Types.Predefined type, String value) {\n+\t\treturn addAnnotation(types.getType(type), value);\n+\t}\n+\n+\t@Override\n+\tpublic TypeStructureBuilderImpl addAnnotation(Type type, Consumer<TypedValueBuilder> builderCallback) {\n+\t\tTypedValueBuilderImpl impl = new TypedValueBuilderImpl((TypeImpl) type);\n+\t\tif (builderCallback != null) {\n+\t\t\tbuilderCallback.accept(impl);\n+\t\t}\n+\t\tannotations.add(new Annotation(type, impl.build()));\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic TypeStructureBuilderImpl addAnnotation(Types.Predefined type, Consumer<TypedValueBuilder> builderCallback) {\n+\t\treturn addAnnotation(types.getType(type), builderCallback);\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypeStructureBuilderImpl.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedValueBuilder;\n+import org.openjdk.jmc.flightrecorder.writer.api.Types;\n@@ -42,0 +44,1 @@\n+import java.util.function.Consumer;\n@@ -58,1 +61,1 @@\n-\t\treturn addAnnotation(type, null);\n+\t\treturn addAnnotation(type, (String) null);\n@@ -73,1 +76,1 @@\n-\tpublic TypedFieldBuilderImpl addAnnotation(TypesImpl.Predefined type, String value) {\n+\tpublic TypedFieldBuilderImpl addAnnotation(Types.Predefined type, String value) {\n@@ -77,0 +80,15 @@\n+\t@Override\n+\tpublic TypedFieldBuilder addAnnotation(Type type, Consumer<TypedValueBuilder> builderCallback) {\n+\t\tTypedValueBuilderImpl impl = new TypedValueBuilderImpl((TypeImpl) type);\n+\t\tif (builderCallback != null) {\n+\t\t\tbuilderCallback.accept(impl);\n+\t\t}\n+\t\tannotations.add(new Annotation(type, impl.build()));\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic TypedFieldBuilder addAnnotation(Types.Predefined type, Consumer<TypedValueBuilder> builderCallback) {\n+\t\treturn addAnnotation(types.getType(type), builderCallback);\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypedFieldBuilderImpl.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-\tTypedFieldImpl(TypeImpl type, String name) {\n+\tpublic TypedFieldImpl(TypeImpl type, String name) {\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypedFieldImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-final class TypedValueImpl implements TypedValue {\n+public final class TypedValueImpl implements TypedValue {\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypedValueImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-\t\t\t\t\t.addAnnotation(annotationContentTypeType, null).addAnnotation(annotationLabelType, \"Timestamp\")\n+\t\t\t\t\t.addAnnotation(annotationContentTypeType).addAnnotation(annotationLabelType, \"Timestamp\")\n@@ -93,1 +93,1 @@\n-\t\t\t\t\t.addAnnotation(annotationContentTypeType, null).addAnnotation(annotationLabelType, \"Timespan\")\n+\t\t\t\t\t.addAnnotation(annotationContentTypeType).addAnnotation(annotationLabelType, \"Timespan\")\n@@ -98,1 +98,1 @@\n-\t\t\t\t\t.addAnnotation(annotationContentTypeType, null).addAnnotation(annotationLabelType, \"Unsigned value\")\n+\t\t\t\t\t.addAnnotation(annotationContentTypeType).addAnnotation(annotationLabelType, \"Unsigned value\")\n@@ -101,0 +101,4 @@\n+\t\tgetOrAdd(JDK.ANNOTATION_CATEGORY, ANNOTATION_SUPER_TYPE_NAME, builder -> {\n+\t\t\tbuilder.addField(\"value\", STRING, TypedFieldBuilder::asArray).addAnnotation(annotationNameType,\n+\t\t\t\t\t\"jdk.jfr.Category\");\n+\t\t});\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypesImpl.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer.api;\n+\n+import java.util.function.Consumer;\n+\n+public interface AnnotatedElementBuilder<T extends AnnotatedElementBuilder<?>> {\n+\t\/**\n+\t * Add an annotation of the given type\n+\t *\n+\t * @param type\n+\t *            the annotation type\n+\t * @return a {@linkplain AnnotatedElementBuilder} instance for invocation chaining\n+\t *\/\n+\tT addAnnotation(Type type);\n+\n+\t\/**\n+\t * Add an annotation of the given type and with the given value\n+\t *\n+\t * @param type\n+\t *            the annotation type\n+\t * @param value\n+\t *            the annotation value\n+\t * @return a {@linkplain AnnotatedElementBuilder} instance for invocation chaining\n+\t *\/\n+\tT addAnnotation(Type type, String value);\n+\n+\t\/**\n+\t * Add a predefined annotation\n+\t *\n+\t * @param type\n+\t *            predefined annotation type\n+\t * @return a {@linkplain AnnotatedElementBuilder} instance for invocation chaining\n+\t *\/\n+\tT addAnnotation(Types.Predefined type);\n+\n+\t\/**\n+\t * Add a predefined annotation with a value\n+\t *\n+\t * @param type\n+\t *            predefined annotation type\n+\t * @param value\n+\t *            annotation value\n+\t * @return a {@linkplain AnnotatedElementBuilder} instance for invocation chaining\n+\t *\/\n+\tT addAnnotation(Types.Predefined type, String value);\n+\n+\t\/**\n+\t * Add an annotation of the given type and with the given values array\n+\t *\n+\t * @param type\n+\t *            the annotation type\n+\t * @param builderCallback\n+\t *            the annotation attributes builder callback\n+\t * @return a {@linkplain AnnotatedElementBuilder} instance for invocation chaining\n+\t *\/\n+\tT addAnnotation(Type type, Consumer<TypedValueBuilder> builderCallback);\n+\n+\t\/**\n+\t * Add an annotation of the given type and with the given values array\n+\t *\n+\t * @param type\n+\t *            the annotation type\n+\t * @param builderCallback\n+\t *            the annotation attributes builder callback\n+\t * @return a {@linkplain AnnotatedElementBuilder} instance for invocation chaining\n+\t *\/\n+\tT addAnnotation(Types.Predefined type, Consumer<TypedValueBuilder> builderCallback);\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/AnnotatedElementBuilder.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -36,0 +36,5 @@\n+import org.openjdk.jmc.flightrecorder.writer.TypeImpl;\n+import org.openjdk.jmc.flightrecorder.writer.TypedFieldImpl;\n+import org.openjdk.jmc.flightrecorder.writer.TypedFieldValueImpl;\n+import org.openjdk.jmc.flightrecorder.writer.TypedValueBuilderImpl;\n+import org.openjdk.jmc.flightrecorder.writer.TypedValueImpl;\n@@ -38,0 +43,6 @@\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n@@ -39,0 +50,1 @@\n+import java.util.function.Consumer;\n@@ -42,0 +54,2 @@\n+\tprivate static final String VALUE_KEY = \"value\";\n+\n@@ -43,0 +57,1 @@\n+\n@@ -46,1 +61,16 @@\n-\tprivate final String value;\n+\tprivate final Map<String, ? extends TypedFieldValue> attributes;\n+\tprivate final List<Annotation> annotations = new ArrayList<>();\n+\n+\t\/**\n+\t * Create a new {@linkplain Annotation} instance\n+\t *\n+\t * @param type\n+\t *            the annotation type (must have the value of\n+\t *            {@linkplain Annotation#ANNOTATION_SUPER_TYPE_NAME} as its super type)\n+\t * @throws IllegalArgumentException\n+\t *             if the annotation type is not having the value of\n+\t *             {@linkplain Annotation#ANNOTATION_SUPER_TYPE_NAME} as its super type\n+\t *\/\n+\tpublic Annotation(Type type) {\n+\t\tthis(type, (String) null);\n+\t}\n@@ -65,1 +95,72 @@\n-\t\tthis.value = value;\n+\t\tthis.attributes = value != null ? singleValue(value) : Collections.emptyMap();\n+\t}\n+\n+\t\/**\n+\t * Create a new {@linkplain Annotation} instance\n+\t *\n+\t * @param type\n+\t *            the annotation type (must have the value of\n+\t *            {@linkplain Annotation#ANNOTATION_SUPER_TYPE_NAME} as its super type)\n+\t * @param value\n+\t *            the annotation value or {@literal null}\n+\t * @param annotations\n+\t *            the annotations list attached to this annotation\n+\t * @throws IllegalArgumentException\n+\t *             if the annotation type is not having the value of\n+\t *             {@linkplain Annotation#ANNOTATION_SUPER_TYPE_NAME} as its super type\n+\t *\/\n+\tpublic Annotation(Type type, String value, Annotation ... annotations) {\n+\t\tif (!isAnnotationType(type)) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\tthis.type = type;\n+\t\tthis.attributes = value != null ? singleValue(value) : Collections.emptyMap();\n+\t\tthis.annotations.addAll(Arrays.asList(annotations));\n+\t}\n+\n+\t\/**\n+\t * Create a new {@linkplain Annotation} instance\n+\t *\n+\t * @param type\n+\t *            the annotation type (must have the value of\n+\t *            {@linkplain Annotation#ANNOTATION_SUPER_TYPE_NAME} as its super type)\n+\t * @param attributes\n+\t *            the annotation attributes or {@literal null}\n+\t * @param annotations\n+\t *            the annotations list attached to this annotation\n+\t * @throws IllegalArgumentException\n+\t *             if the annotation type is not having the value of\n+\t *             {@linkplain Annotation#ANNOTATION_SUPER_TYPE_NAME} as its super type\n+\t *\/\n+\tpublic Annotation(Type type, Map<String, ? extends TypedFieldValue> attributes, Annotation ... annotations) {\n+\t\tif (!isAnnotationType(type)) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\tthis.type = type;\n+\t\tthis.attributes = attributes;\n+\t}\n+\n+\t\/**\n+\t * Create a new {@linkplain Annotation} instance\n+\t *\n+\t * @param type\n+\t *            the annotation type (must have the value of\n+\t *            {@linkplain Annotation#ANNOTATION_SUPER_TYPE_NAME} as its super type)\n+\t * @param builderCallback\n+\t *            the annotation attributes builder callback or {@literal null}\n+\t * @param annotations\n+\t *            the annotations list attached to this annotation\n+\t * @throws IllegalArgumentException\n+\t *             if the annotation type is not having the value of\n+\t *             {@linkplain Annotation#ANNOTATION_SUPER_TYPE_NAME} as its super type\n+\t *\/\n+\tpublic Annotation(Type type, Consumer<TypedValueBuilder> builderCallback, Annotation ... annotations) {\n+\t\tif (!isAnnotationType(type)) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\tthis.type = type;\n+\t\tTypedValueBuilderImpl builder = new TypedValueBuilderImpl((TypeImpl) type);\n+\t\tif (builderCallback != null) {\n+\t\t\tbuilderCallback.accept(builder);\n+\t\t}\n+\t\tthis.attributes = builder.build();\n@@ -68,0 +169,8 @@\n+\t\/**\n+\t * Check whether a particular {@linkplain Type} is an annotation type\n+\t * \n+\t * @param type\n+\t *            {@linkplain Type} to check\n+\t * @return {@linkplain true} if the type extends {@linkplain java.lang.annotation.Annotation}\n+\t *         type\n+\t *\/\n@@ -72,0 +181,69 @@\n+\t\/**\n+\t * Get the list of the associated {@link Annotation annotations}\n+\t * \n+\t * @return the associated {@link Annotation annotations}\n+\t *\/\n+\tpublic List<Annotation> getAnnotations() {\n+\t\treturn annotations;\n+\t}\n+\n+\t\/**\n+\t * @return the annotation type\n+\t *\/\n+\tpublic Type getType() {\n+\t\treturn type;\n+\t}\n+\n+\t\/**\n+\t * @return the annotation's attribute value or {@literal null} if the attribute is an array\n+\t *\/\n+\tpublic String getValue() {\n+\t\treturn getValue(String.class, VALUE_KEY);\n+\t}\n+\n+\t\/**\n+\t * Get the attribute value by its name and type\n+\t * \n+\t * @param valueType\n+\t *            the expected value type\n+\t * @param name\n+\t *            the attribute name\n+\t * @param <T>\n+\t *            the expected value type\n+\t * @return the attribute value or {@literal null}\n+\t * @throws IllegalArgumentException\n+\t *             when the attribute's type is not assignable to the requested value type\n+\t *\/\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic <T> T getValue(Class<T> valueType, String name) {\n+\t\tTypedFieldValue fieldValue = attributes.get(name);\n+\t\tif (fieldValue == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tObject val = null;\n+\t\tif (fieldValue.getField().isArray()) {\n+\t\t\tTypedValue[] values = fieldValue.getValues();\n+\t\t\tObject valArray = Array.newInstance(valueType.getComponentType(), values.length);\n+\t\t\tfor (int i = 0; i < values.length; i++) {\n+\t\t\t\tArray.set(valArray, i, values[i].getValue());\n+\t\t\t}\n+\t\t\tval = valArray;\n+\t\t} else {\n+\t\t\tTypedValue typedValue = fieldValue.getValue();\n+\t\t\tval = typedValue != null ? typedValue.getValue() : null;\n+\t\t}\n+\n+\t\tif (val != null && !valueType.isAssignableFrom(val.getClass())) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\treturn (T) val;\n+\t}\n+\n+\t\/**\n+\t * @return the annotation's attribute array value or {@literal null} if the attribute is not an\n+\t *         array\n+\t *\/\n+\tpublic Map<String, ? extends TypedFieldValue> getAttributes() {\n+\t\treturn attributes;\n+\t}\n+\n@@ -81,1 +259,1 @@\n-\t\treturn type.equals(that.type) && Objects.equals(value, that.value);\n+\t\treturn type.equals(that.type) && Objects.equals(attributes, that.attributes);\n@@ -87,1 +265,1 @@\n-\t\t\thashCode = NonZeroHashCode.hash(type, value);\n+\t\t\thashCode = NonZeroHashCode.hash(type, attributes);\n@@ -92,8 +270,0 @@\n-\tpublic Type getType() {\n-\t\treturn type;\n-\t}\n-\n-\tpublic String getValue() {\n-\t\treturn value;\n-\t}\n-\n@@ -102,1 +272,8 @@\n-\t\treturn \"Annotation [type=\" + type + \", value=\" + value + \"]\";\n+\t\treturn \"Annotation [type=\" + type + \", attributes=\" + attributes + \"]\";\n+\t}\n+\n+\tprivate Map<String, ? extends TypedFieldValue> singleValue(String value) {\n+\t\tTypeImpl targetType = (TypeImpl) type.getTypes().getType(Types.Builtin.STRING);\n+\t\tTypedValueImpl typedValue = targetType.asValue(value);\n+\t\tTypedFieldImpl typedField = new TypedFieldImpl(targetType, VALUE_KEY);\n+\t\treturn Collections.singletonMap(VALUE_KEY, new TypedFieldValueImpl(typedField, typedValue));\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/Annotation.java","additions":190,"deletions":13,"binary":false,"changes":203,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer.api;\n+\n+import java.util.function.Consumer;\n+\n+\/**\n+ * Builder for {@linkplain Annotation} instances\n+ *\/\n+public interface AnnotationElementBuilder {\n+\t\/**\n+\t * Add annotation argument\n+\t * \n+\t * @param name\n+\t *            the argument name\n+\t * @param value\n+\t *            the argument value\n+\t * @return this instance for chaining\n+\t *\/\n+\tAnnotationElementBuilder addArgument(String name, TypedValue value);\n+\n+\t\/**\n+\t * Add annotation argument\n+\t * \n+\t * @param name\n+\t *            the argument name\n+\t * @param builderCallback\n+\t *            the argument value customization callback\n+\t * @return this instance for chaining\n+\t *\/\n+\tAnnotationElementBuilder addArgument(String name, Consumer<TypedValueBuilder> builderCallback);\n+\n+\t\/**\n+\t * Build a new {@linkplain Annotation} instance\n+\t * \n+\t * @return {@linkplain Annotation} instance\n+\t *\/\n+\tAnnotation build();\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/AnnotationElementBuilder.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -73,1 +73,1 @@\n-\t * @return the {@link TypedFieldImpl field} instance\n+\t * @return the {@link TypedField field} instance\n@@ -75,1 +75,1 @@\n-\tTypedFieldImpl getField(String name);\n+\tTypedField getField(String name);\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/Type.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-public interface TypeStructureBuilder {\n+public interface TypeStructureBuilder extends AnnotatedElementBuilder<TypeStructureBuilder> {\n@@ -112,20 +112,0 @@\n-\t\/**\n-\t * Add an annotation of the given type\n-\t *\n-\t * @param type\n-\t *            the annotation type\n-\t * @return a {@linkplain TypeStructureBuilder} instance for invocation chaining\n-\t *\/\n-\tTypeStructureBuilder addAnnotation(Type type);\n-\n-\t\/**\n-\t * Add an annotation of the given type and with the given value\n-\t *\n-\t * @param type\n-\t *            the annotation type\n-\t * @param value\n-\t *            the annotation value\n-\t * @return a {@linkplain TypeStructureBuilder} instance for invocation chaining\n-\t *\/\n-\tTypeStructureBuilder addAnnotation(Type type, String value);\n-\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/TypeStructureBuilder.java","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-import org.openjdk.jmc.flightrecorder.writer.TypedFieldImpl;\n-\n@@ -39,41 +37,1 @@\n-public interface TypedFieldBuilder {\n-\t\/**\n-\t * Add an annotation\n-\t *\n-\t * @param type\n-\t *            annotation type\n-\t * @return a {@linkplain TypedFieldBuilder} instance for invocation chaining\n-\t *\/\n-\tTypedFieldBuilder addAnnotation(Type type);\n-\n-\t\/**\n-\t * Add an annotation with a value\n-\t *\n-\t * @param type\n-\t *            annotation type\n-\t * @param value\n-\t *            annotation value\n-\t * @return a {@linkplain TypedFieldBuilder} instance for invocation chaining\n-\t *\/\n-\tTypedFieldBuilder addAnnotation(Type type, String value);\n-\n-\t\/**\n-\t * Add a predefined annotation\n-\t *\n-\t * @param type\n-\t *            predefined annotation type\n-\t * @return a {@linkplain TypedFieldBuilder} instance for invocation chaining\n-\t *\/\n-\tTypedFieldBuilder addAnnotation(Types.Predefined type);\n-\n-\t\/**\n-\t * Add a predefined annotation with a value\n-\t *\n-\t * @param type\n-\t *            predefined annotation type\n-\t * @param value\n-\t *            annotation value\n-\t * @return a {@linkplain TypedFieldBuilder} instance for invocation chaining\n-\t *\/\n-\tTypedFieldBuilder addAnnotation(Types.Predefined type, String value);\n-\n+public interface TypedFieldBuilder extends AnnotatedElementBuilder<TypedFieldBuilder> {\n@@ -87,1 +45,6 @@\n-\tTypedFieldImpl build();\n+\t\/**\n+\t * Build new {@linkplain TypedField} instance\n+\t * \n+\t * @return {@linkplain TypedField} instance\n+\t *\/\n+\tTypedField build();\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/TypedFieldBuilder.java","additions":7,"deletions":44,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-import org.openjdk.jmc.flightrecorder.writer.TypedFieldImpl;\n-\n@@ -39,1 +37,1 @@\n- * The composite of {@linkplain TypedFieldImpl} and corresponding {@link TypedValue TypedValue(s)}\n+ * The composite of {@linkplain TypedField} and corresponding {@link TypedValue TypedValue(s)}\n@@ -42,2 +40,2 @@\n-\t\/** @return the corresponding {@linkplain TypedFieldImpl} *\/\n-\tTypedFieldImpl getField();\n+\t\/** @return the corresponding {@linkplain TypedField} *\/\n+\tTypedField getField();\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/TypedFieldValue.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -291,1 +291,3 @@\n-\t\tANNOTATION_UNSIGNED(\"jdk.jfr.Unsigned\");\n+\t\tANNOTATION_UNSIGNED(\"jdk.jfr.Unsigned\"),\n+\t\tANNOTATION_CATEGORY(\"jdk.jfr.Category\");\n+\t\t;\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/Types.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n@@ -37,1 +38,0 @@\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n@@ -44,0 +44,1 @@\n+import org.openjdk.jmc.flightrecorder.writer.api.Types;\n@@ -58,2 +59,1 @@\n-\t\tAnnotation annotation = new Annotation(type, null);\n-\t\tassertNotNull(annotation);\n+\t\tAnnotation annotation = new Annotation(type);\n@@ -69,1 +69,1 @@\n-\t\tassertNotNull(annotation);\n+\t\tassertEquals(type, annotation.getType());\n@@ -71,0 +71,9 @@\n+\t}\n+\n+\t@Test\n+\tvoid validAnnotationWithArrayValue() {\n+\t\tString[] values = new String[] {\"value1\", \"value2\"};\n+\t\tTypeImpl type = types.getType(Types.JDK.ANNOTATION_CATEGORY);\n+\t\tAnnotation annotation = new Annotation(type, access -> {\n+\t\t\taccess.putField(\"value\", values);\n+\t\t});\n@@ -72,0 +81,1 @@\n+\t\tassertArrayEquals(values, annotation.getValue(String[].class, \"value\"));\n@@ -77,1 +87,1 @@\n-\t\tassertThrows(IllegalArgumentException.class, () -> new Annotation(type, null));\n+\t\tassertThrows(IllegalArgumentException.class, () -> new Annotation(type));\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/AnnotationTest.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -97,1 +97,4 @@\n-\t\t\teventTypeBuilder.addFields(nameField, messageField);\n+\t\t\teventTypeBuilder.addFields(nameField, messageField).addAnnotation(Types.JDK.ANNOTATION_CATEGORY,\n+\t\t\t\t\tbuilder -> {\n+\t\t\t\t\t\tbuilder.putField(\"value\", new String[] {\"cat1\", \"cat2\", \"cat3\"});\n+\t\t\t\t\t});\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/ChunkComplexTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-\t\tConstantPools constantPools = Mockito.mock(ConstantPools.class);\n+\t\tConstantPools constantPools = new ConstantPools();\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypeStructureBuilderImplTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import org.openjdk.jmc.flightrecorder.writer.api.Types;\n@@ -63,1 +64,1 @@\n-\t\tConstantPools constantPools = Mockito.mock(ConstantPools.class);\n+\t\tConstantPools constantPools = new ConstantPools();\n@@ -131,1 +132,1 @@\n-\t\tTypedFieldImpl field = instance.addAnnotation(TypesImpl.JDK.ANNOTATION_LABEL, ANNOTATION_LABEL).build();\n+\t\tTypedFieldImpl field = instance.addAnnotation(Types.JDK.ANNOTATION_LABEL, ANNOTATION_LABEL).build();\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypedFieldBuilderImplTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}