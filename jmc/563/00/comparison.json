{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-import java.net.URISyntaxException;\n+import java.lang.reflect.Method;\n@@ -51,1 +51,0 @@\n-import java.util.concurrent.atomic.AtomicBoolean;\n@@ -57,0 +56,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -66,0 +66,2 @@\n+import org.openjdk.jmc.browser.attach.internal.MonitoredHostWrapper;\n+import org.openjdk.jmc.browser.attach.internal.MonitoredVmWrapper;\n@@ -81,9 +83,0 @@\n-import sun.jvmstat.monitor.HostIdentifier;\n-import sun.jvmstat.monitor.MonitorException;\n-import sun.jvmstat.monitor.MonitoredHost;\n-import sun.jvmstat.monitor.MonitoredVm;\n-import sun.jvmstat.monitor.MonitoredVmUtil;\n-import sun.jvmstat.monitor.StringMonitor;\n-import sun.jvmstat.monitor.VmIdentifier;\n-import sun.tools.attach.HotSpotVirtualMachine;\n-\n@@ -112,0 +105,1 @@\n+\tprivate static Class<?> CLASS_HOTSPOT_VIRTUAL_MACHINE;\n@@ -129,0 +123,8 @@\n+\tstatic {\n+\t\ttry {\n+\t\t\tCLASS_HOTSPOT_VIRTUAL_MACHINE = Class.forName(\"sun.tools.attach.HotSpotVirtualMachine\");\n+\t\t} catch (ClassNotFoundException e) {\n+\t\t\tCLASS_HOTSPOT_VIRTUAL_MACHINE = null;\n+\t\t}\n+\t}\n+\n@@ -165,6 +167,3 @@\n-\t\tMonitoredHost host = getMonitoredHost();\n-\t\tSet<?> vms;\n-\t\ttry {\n-\t\t\tvms = host.activeVms();\n-\t\t} catch (MonitorException mx) {\n-\t\t\tthrow new InternalError(mx.getMessage());\n+\t\tMonitoredHostWrapper monitoredHost = MonitoredHostWrapper.getMonitoredHost();\n+\t\tif (monitoredHost == null) {\n+\t\t\treturn;\n@@ -172,0 +171,1 @@\n+\t\tSet<?> vms = monitoredHost.activeVms();\n@@ -181,1 +181,1 @@\n-\t\t\t\t\tconnDesc = createMonitoredJvmDescriptor(host, (Integer) vmid);\n+\t\t\t\t\tconnDesc = createMonitoredJvmDescriptor(monitoredHost, (Integer) vmid);\n@@ -192,1 +192,1 @@\n-\tprivate static DiscoveryEntry createMonitoredJvmDescriptor(MonitoredHost host, Integer vmid) {\n+\tprivate static DiscoveryEntry createMonitoredJvmDescriptor(MonitoredHostWrapper host, Integer vmid) {\n@@ -214,1 +214,1 @@\n-\t\t\t\t\t\tMonitoredVm mvm = host.getMonitoredVm(new VmIdentifier(name));\n+\t\t\t\t\t\tMonitoredVmWrapper mvm = host.getMonitoredVm(name);\n@@ -217,12 +217,5 @@\n-\t\t\t\t\t\t\tname = MonitoredVmUtil.commandLine(mvm);\n-\t\t\t\t\t\t\tjvmArgs = MonitoredVmUtil.jvmArgs(mvm);\n-\t\t\t\t\t\t\tStringMonitor sm = (StringMonitor) mvm.findByName(\"java.property.java.vm.name\"); \/\/$NON-NLS-1$\n-\t\t\t\t\t\t\tif (sm != null) {\n-\t\t\t\t\t\t\t\tjvmName = sm.stringValue();\n-\t\t\t\t\t\t\t\ttype = JVMType.getJVMType(sm.stringValue());\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tsm = (StringMonitor) mvm.findByName(\"java.property.java.version\"); \/\/$NON-NLS-1$\n-\t\t\t\t\t\t\tif (sm != null) {\n-\t\t\t\t\t\t\t\tversion = sm.stringValue();\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tname = mvm.commandLine();\n+\t\t\t\t\t\t\tjvmArgs = mvm.jvmArgs();\n+\t\t\t\t\t\t\tjvmName = mvm.jvmName();\n+\t\t\t\t\t\t\ttype = JVMType.getJVMType(jvmName);\n+\t\t\t\t\t\t\tversion = mvm.javaVersion();\n@@ -232,8 +225,5 @@\n-\t\t\t\t\t\t\t\tsm = (StringMonitor) mvm.findByName(\"java.property.java.vm.version\"); \/\/$NON-NLS-1$\n-\t\t\t\t\t\t\t\tif (sm != null) {\n-\t\t\t\t\t\t\t\t\tString vmVersion = sm.stringValue();\n-\t\t\t\t\t\t\t\t\tif (type == JVMType.JROCKIT) {\n-\t\t\t\t\t\t\t\t\t\tversion = JavaVMVersionToolkit.decodeJavaVersion(vmVersion);\n-\t\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\t\tversion = JavaVMVersionToolkit.parseJavaVersion(vmVersion);\n-\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tString vmVersion = mvm.jvmVersion();\n+\t\t\t\t\t\t\t\tif (type == JVMType.JROCKIT) {\n+\t\t\t\t\t\t\t\t\tversion = JavaVMVersionToolkit.decodeJavaVersion(vmVersion);\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tversion = JavaVMVersionToolkit.parseJavaVersion(vmVersion);\n@@ -245,10 +235,2 @@\n-\n-\t\t\t\t\t\t\tif (sm != null) {\n-\t\t\t\t\t\t\t\tisDebug = isDebug(sm.stringValue());\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tsm = (StringMonitor) mvm.findByName(\"java.property.java.vm.vendor\"); \/\/$NON-NLS-1$\n-\t\t\t\t\t\t\tif (sm != null) {\n-\t\t\t\t\t\t\t\tjvmVendor = sm.stringValue();\n-\t\t\t\t\t\t\t}\n-\n+\t\t\t\t\t\t\tisDebug = isDebug(version);\n+\t\t\t\t\t\t\tjvmVendor = mvm.jvmVendor();\n@@ -425,1 +407,3 @@\n-\t\t\t\t\t\t\t\t\t((HotSpotVirtualMachine) vm).startLocalManagementAgent();\n+\t\t\t\t\t\t\t\t\tMethod methodStartLocalManagementAgent = CLASS_HOTSPOT_VIRTUAL_MACHINE\n+\t\t\t\t\t\t\t\t\t\t\t.getMethod(\"startLocalManagementAgent\");\n+\t\t\t\t\t\t\t\t\tmethodStartLocalManagementAgent.invoke(vm);\n@@ -481,10 +465,0 @@\n-\tprivate static MonitoredHost getMonitoredHost() {\n-\t\ttry {\n-\t\t\treturn MonitoredHost.getMonitoredHost(new HostIdentifier((String) null));\n-\t\t} catch (MonitorException e) {\n-\t\t\tthrow new InternalError(e.getMessage());\n-\t\t} catch (URISyntaxException e) {\n-\t\t\tthrow new InternalError(e.getMessage());\n-\t\t}\n-\t}\n-\n@@ -607,2 +581,1 @@\n-\t\tHotSpotVirtualMachine hvm = (HotSpotVirtualMachine) vm;\n-\t\tInputStream in = ExecuteTunnler.execute(hvm, \"jcmd\", new Object[] {command}, throwCausingException); \/\/$NON-NLS-1$\n+\t\tInputStream in = ExecuteTunnler.execute(vm, \"jcmd\", new Object[] {command}, throwCausingException); \/\/$NON-NLS-1$\n","filename":"application\/org.openjdk.jmc.browser.attach\/src\/main\/java\/org\/openjdk\/jmc\/browser\/attach\/LocalJVMToolkit.java","additions":37,"deletions":64,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-import sun.tools.attach.HotSpotVirtualMachine;\n+import com.sun.tools.attach.VirtualMachine;\n@@ -47,1 +47,1 @@\n- * Ugly ass class needed for us to work better with Sun.\n+ * This is class is required to for example execute diagnostic commands.\n@@ -67,2 +67,1 @@\n-\tpublic static InputStream execute(\n-\t\tHotSpotVirtualMachine hsvm, String command, Object[] args, boolean throwCausingException)\n+\tpublic static InputStream execute(VirtualMachine hsvm, String command, Object[] args, boolean throwCausingException)\n@@ -73,2 +72,2 @@\n-\tprivate static InputStream invoke(\n-\t\tHotSpotVirtualMachine hsvm, String command, Object[] args, boolean throwCausingException) throws IOException {\n+\tprivate static InputStream invoke(VirtualMachine hsvm, String command, Object[] args, boolean throwCausingException)\n+\t\t\tthrows IOException {\n","filename":"application\/org.openjdk.jmc.browser.attach\/src\/main\/java\/org\/openjdk\/jmc\/browser\/attach\/internal\/ExecuteTunnler.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+package org.openjdk.jmc.browser.attach.internal;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.logging.Level;\n+\n+import org.openjdk.jmc.browser.attach.BrowserAttachPlugin;\n+\n+public class MonitoredHostWrapper {\n+\tstatic final String ERROR_MESSAGE_ATTACH = \"Could not find attach related classes. This can affect discovery of locally running JVMs.\";\n+\n+\tprivate static Class<?> CLASS_HOST_IDENTIFIER;\n+\tprivate static Class<?> CLASS_VM_IDENTIFIER;\n+\tstatic Class<?> CLASS_MONITORED_HOST;\n+\n+\tprivate Object host;\n+\n+\tstatic {\n+\t\ttry {\n+\t\t\tCLASS_MONITORED_HOST = Class.forName(\"sun.jvmstat.monitor.MonitoredHost\");\n+\t\t\tCLASS_HOST_IDENTIFIER = Class.forName(\"sun.jvmstat.monitor.HostIdentifier\");\n+\t\t\tCLASS_VM_IDENTIFIER = Class.forName(\"sun.jvmstat.monitor.VmIdentifier\");\n+\t\t} catch (ClassNotFoundException e) {\n+\t\t\tCLASS_MONITORED_HOST = null;\n+\t\t\tCLASS_HOST_IDENTIFIER = null;\n+\t\t\tCLASS_VM_IDENTIFIER = null;\n+\t\t\tBrowserAttachPlugin.getPluginLogger().log(Level.WARNING, ERROR_MESSAGE_ATTACH, e);\n+\t\t}\n+\t}\n+\n+\tpublic static MonitoredHostWrapper getMonitoredHost() {\n+\t\treturn new MonitoredHostWrapper();\n+\t}\n+\n+\tpublic MonitoredHostWrapper() {\n+\t\tif (CLASS_MONITORED_HOST != null) {\n+\t\t\ttry {\n+\t\t\t\tObject hostIdentifier = createHostIdentifier(null);\n+\t\t\t\tMethod method;\n+\t\t\t\tmethod = CLASS_MONITORED_HOST.getMethod(\"getMonitoredHost\", CLASS_HOST_IDENTIFIER);\n+\t\t\t\thost = method.invoke(null, hostIdentifier);\n+\t\t\t} catch (NoSuchMethodException\n+\t\t\t\t\t| SecurityException\n+\t\t\t\t\t| IllegalAccessException\n+\t\t\t\t\t| IllegalArgumentException\n+\t\t\t\t\t| InvocationTargetException\n+\t\t\t\t\t| InstantiationException e) {\n+\t\t\t\tBrowserAttachPlugin.getPluginLogger().log(Level.FINEST,\n+\t\t\t\t\t\t\"Could not create monitored host. This could make local attach problematic.\", e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Object createHostIdentifier(String id) throws NoSuchMethodException, SecurityException,\n+\t\t\tInstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n+\t\tConstructor<?> constructor = CLASS_HOST_IDENTIFIER.getConstructor(String.class);\n+\t\treturn constructor.newInstance(id);\n+\t}\n+\n+\tpublic Set<?> activeVms() {\n+\t\tif (host != null) {\n+\t\t\tMethod method;\n+\t\t\ttry {\n+\t\t\t\tmethod = CLASS_MONITORED_HOST.getMethod(\"activeVms\");\n+\t\t\t\treturn (Set<?>) method.invoke(host);\n+\t\t\t} catch (NoSuchMethodException\n+\t\t\t\t\t| SecurityException\n+\t\t\t\t\t| IllegalAccessException\n+\t\t\t\t\t| IllegalArgumentException\n+\t\t\t\t\t| InvocationTargetException e) {\n+\t\t\t\tBrowserAttachPlugin.getPluginLogger().log(Level.WARNING,\n+\t\t\t\t\t\t\"Problem getting active VMs. This could make local attach problematic.\", e);\n+\t\t\t}\n+\t\t}\n+\t\treturn Collections.emptySet();\n+\t}\n+\n+\tpublic MonitoredVmWrapper getMonitoredVm(String name) {\n+\t\tif (host != null) {\n+\t\t\tif (CLASS_VM_IDENTIFIER != null) {\n+\t\t\t\tConstructor<?> constructor;\n+\t\t\t\ttry {\n+\t\t\t\t\tconstructor = CLASS_VM_IDENTIFIER.getConstructor(String.class);\n+\t\t\t\t\tObject vmIdentifier = constructor.newInstance(name);\n+\t\t\t\t\tMethod getMonitoredVm = CLASS_MONITORED_HOST.getMethod(\"getMonitoredVm\", CLASS_VM_IDENTIFIER);\n+\t\t\t\t\tObject mvm = getMonitoredVm.invoke(host, vmIdentifier);\n+\t\t\t\t\tif (mvm != null) {\n+\t\t\t\t\t\treturn new MonitoredVmWrapper(mvm);\n+\t\t\t\t\t}\n+\t\t\t\t} catch (InstantiationException\n+\t\t\t\t\t\t| IllegalAccessException\n+\t\t\t\t\t\t| IllegalArgumentException\n+\t\t\t\t\t\t| InvocationTargetException\n+\t\t\t\t\t\t| NoSuchMethodException\n+\t\t\t\t\t\t| SecurityException e) {\n+\t\t\t\t\tBrowserAttachPlugin.getPluginLogger().log(Level.WARNING, MonitoredHostWrapper.ERROR_MESSAGE_ATTACH,\n+\t\t\t\t\t\t\te);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+}\n","filename":"application\/org.openjdk.jmc.browser.attach\/src\/main\/java\/org\/openjdk\/jmc\/browser\/attach\/internal\/MonitoredHostWrapper.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.browser.attach.internal;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.logging.Level;\n+\n+import org.openjdk.jmc.browser.attach.BrowserAttachPlugin;\n+\n+public class MonitoredVmWrapper {\n+\tprivate static Class<?> CLASS_MONITORED_VM;\n+\tprivate static Class<?> CLASS_MONITORED_VM_UTIL;\n+\tprivate static Class<?> CLASS_STRING_MONITOR;\n+\n+\tprivate Object monitoredVm;\n+\n+\tstatic {\n+\t\ttry {\n+\t\t\tCLASS_MONITORED_VM = Class.forName(\"sun.jvmstat.monitor.MonitoredVm\"); \/\/$NON-NLS-1$\n+\t\t\tCLASS_MONITORED_VM_UTIL = Class.forName(\"sun.jvmstat.monitor.MonitoredVmUtil\"); \/\/$NON-NLS-1$\n+\t\t\tCLASS_STRING_MONITOR = Class.forName(\"sun.jvmstat.monitor.StringMonitor\"); \/\/$NON-NLS-1$\n+\t\t} catch (ClassNotFoundException e) {\n+\t\t\tCLASS_MONITORED_VM = null;\n+\t\t\tCLASS_MONITORED_VM_UTIL = null;\n+\t\t\tCLASS_STRING_MONITOR = null;\n+\t\t\tBrowserAttachPlugin.getPluginLogger().log(Level.WARNING, MonitoredHostWrapper.ERROR_MESSAGE_ATTACH, e);\n+\t\t}\n+\t}\n+\n+\tpublic MonitoredVmWrapper(Object monitoredVm) {\n+\t\tthis.monitoredVm = monitoredVm;\n+\t}\n+\n+\tpublic String commandLine() {\n+\t\tif (CLASS_MONITORED_VM_UTIL != null) {\n+\t\t\tMethod methodCommandLine;\n+\t\t\ttry {\n+\t\t\t\tmethodCommandLine = CLASS_MONITORED_VM_UTIL.getMethod(\"commandLine\", CLASS_MONITORED_VM); \/\/$NON-NLS-1$\n+\t\t\t\tObject commandLine = methodCommandLine.invoke(null, monitoredVm);\n+\t\t\t\treturn String.valueOf(commandLine);\n+\t\t\t} catch (NoSuchMethodException\n+\t\t\t\t\t| SecurityException\n+\t\t\t\t\t| IllegalAccessException\n+\t\t\t\t\t| IllegalArgumentException\n+\t\t\t\t\t| InvocationTargetException e) {\n+\t\t\t\tBrowserAttachPlugin.getPluginLogger().log(Level.FINEST, \"Could not read command line!\", e); \/\/$NON-NLS-1$\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tpublic String jvmArgs() {\n+\t\tif (CLASS_MONITORED_VM_UTIL != null) {\n+\t\t\tMethod methodCommandLine;\n+\t\t\ttry {\n+\t\t\t\tmethodCommandLine = CLASS_MONITORED_VM_UTIL.getMethod(\"jvmArgs\", CLASS_MONITORED_VM); \/\/$NON-NLS-1$\n+\t\t\t\tObject commandLine = methodCommandLine.invoke(null, monitoredVm);\n+\t\t\t\treturn String.valueOf(commandLine);\n+\t\t\t} catch (NoSuchMethodException\n+\t\t\t\t\t| SecurityException\n+\t\t\t\t\t| IllegalAccessException\n+\t\t\t\t\t| IllegalArgumentException\n+\t\t\t\t\t| InvocationTargetException e) {\n+\t\t\t\tBrowserAttachPlugin.getPluginLogger().log(Level.FINEST, \"Could not read command line!\", e); \/\/$NON-NLS-1$\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tpublic String jvmName() {\n+\t\treturn getPropertyStringValue(\"java.property.java.vm.name\"); \/\/$NON-NLS-1$\n+\t}\n+\n+\tpublic String javaVersion() {\n+\t\treturn getPropertyStringValue(\"java.property.java.version\"); \/\/$NON-NLS-1$\n+\t}\n+\n+\tpublic String jvmVersion() {\n+\t\treturn getPropertyStringValue(\"java.property.java.vm.version\"); \/\/$NON-NLS-1$\n+\t}\n+\n+\tpublic String jvmVendor() {\n+\t\treturn getPropertyStringValue(\"java.property.java.vm.vendor\");\n+\t}\n+\n+\tpublic void detach() {\n+\t\ttry {\n+\t\t\tMethod methodDetach = CLASS_MONITORED_VM.getMethod(\"detach\");\n+\t\t\tmethodDetach.invoke(monitoredVm);\n+\t\t} catch (NoSuchMethodException\n+\t\t\t\t| SecurityException\n+\t\t\t\t| IllegalAccessException\n+\t\t\t\t| IllegalArgumentException\n+\t\t\t\t| InvocationTargetException e) {\n+\t\t\tBrowserAttachPlugin.getPluginLogger().log(Level.FINEST, \"Could not detach from monitored VM\", e); \/\/$NON-NLS-1$\n+\t\t}\n+\t}\n+\n+\tprivate String getPropertyStringValue(String propertyName) {\n+\t\tMethod methodFindByName;\n+\t\ttry {\n+\t\t\tmethodFindByName = CLASS_MONITORED_VM.getMethod(\"findByName\", String.class); \/\/$NON-NLS-1$\n+\t\t\tObject stringMonitor = methodFindByName.invoke(monitoredVm, propertyName);\n+\t\t\tMethod methodStringValue = CLASS_STRING_MONITOR.getMethod(\"stringValue\"); \/\/$NON-NLS-1$\n+\t\t\treturn String.valueOf(methodStringValue.invoke(stringMonitor));\n+\t\t} catch (NoSuchMethodException\n+\t\t\t\t| SecurityException\n+\t\t\t\t| IllegalAccessException\n+\t\t\t\t| IllegalArgumentException\n+\t\t\t\t| InvocationTargetException e) {\n+\t\t\tBrowserAttachPlugin.getPluginLogger().log(Level.FINEST, \"Could not read StringMonitor \" + propertyName, e); \/\/$NON-NLS-1$\n+\t\t}\n+\t\treturn null;\n+\t}\n+}\n","filename":"application\/org.openjdk.jmc.browser.attach\/src\/main\/java\/org\/openjdk\/jmc\/browser\/attach\/internal\/MonitoredVmWrapper.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"}]}