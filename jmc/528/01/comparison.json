{"files":[{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.rules.jdk.memory;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RunnableFuture;\n+\n+import org.openjdk.jmc.common.item.Aggregators;\n+import org.openjdk.jmc.common.item.IItem;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.item.IItemIterable;\n+import org.openjdk.jmc.common.unit.IQuantity;\n+import org.openjdk.jmc.common.unit.UnitLookup;\n+import org.openjdk.jmc.common.util.IPreferenceValueProvider;\n+import org.openjdk.jmc.common.util.TypedPreference;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkAggregators;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkAttributes;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkFilters;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;\n+import org.openjdk.jmc.flightrecorder.rules.IResult;\n+import org.openjdk.jmc.flightrecorder.rules.IResultValueProvider;\n+import org.openjdk.jmc.flightrecorder.rules.IRule;\n+import org.openjdk.jmc.flightrecorder.rules.ResultBuilder;\n+import org.openjdk.jmc.flightrecorder.rules.Severity;\n+import org.openjdk.jmc.flightrecorder.rules.TypedResult;\n+import org.openjdk.jmc.flightrecorder.rules.jdk.messages.internal.Messages;\n+import org.openjdk.jmc.flightrecorder.rules.util.JfrRuleTopics;\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit;\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit.EventAvailability;\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit.RequiredEventsBuilder;\n+\n+\/**\n+ * Rule that checks for \"Inverted Parallelism\", as described by the Garbagecat GC log analysis tool.\n+ * Checks if the parallel collection performance is less than serial (single-threaded). See:\n+ * https:\/\/github.com\/mgm3746\/garbagecat\/blob\/main\/src\/main\/java\/org\/eclipselabs\/garbagecat\/util\/jdk\/JdkMath.java#L365\n+ *\/\n+public class GcInvertedParallelismRule implements IRule {\n+\tprivate static final String INVERTED_PARALLELISM_RESULT_ID = \"GcInvertedParallelism\"; \/\/$NON-NLS-1$\n+\t\/\/ Requires the jdk.GCCPUTime event introduced in JDK 20\n+\t\/\/ See: JDK-8291753\n+\tprivate static final Map<String, EventAvailability> REQUIRED_EVENTS = RequiredEventsBuilder.create()\n+\t\t\t.addEventType(JdkTypeIDs.GC_CONF, EventAvailability.AVAILABLE)\n+\t\t\t.addEventType(JdkTypeIDs.GC_CPU_TIME, EventAvailability.AVAILABLE).build();\n+\n+\tpublic static final TypedResult<IQuantity> GC_CPU_TIME_EVENT_COUNT = new TypedResult<>(\"gcCpuTimeEventCount\", \/\/$NON-NLS-1$\n+\t\t\t\"GCCPUTime Event Count\", \"The number of recorded jdk.GCCPUTime events.\", UnitLookup.NUMBER,\n+\t\t\tIQuantity.class);\n+\n+\tpublic static final TypedResult<Long> INVERTED_PARALLELISM_COUNT = new TypedResult<>(\"invertedParallelismCount\", \/\/$NON-NLS-1$\n+\t\t\t\"Inverted Parallelism Count\", \"The number of detected instances of Inverted Parallelism.\",\n+\t\t\tUnitLookup.RAW_LONG, Long.class);\n+\n+\tprivate static final Collection<TypedResult<?>> RESULT_ATTRIBUTES = Arrays\n+\t\t\t.<TypedResult<?>> asList(GC_CPU_TIME_EVENT_COUNT, INVERTED_PARALLELISM_COUNT);\n+\n+\t@Override\n+\tpublic RunnableFuture<IResult> createEvaluation(\n+\t\tfinal IItemCollection items, final IPreferenceValueProvider valueProvider,\n+\t\tfinal IResultValueProvider resultProvider) {\n+\t\treturn new FutureTask<>(new Callable<IResult>() {\n+\t\t\t@Override\n+\t\t\tpublic IResult call() throws Exception {\n+\t\t\t\tif (items.getAggregate(JdkAggregators.OLD_COLLECTOR)\n+\t\t\t\t\t\t.equals(CollectorType.SERIAL_OLD.getCollectorName())) {\n+\t\t\t\t\treturn ResultBuilder.createFor(GcInvertedParallelismRule.this, valueProvider)\n+\t\t\t\t\t\t\t.setSeverity(Severity.IGNORE).build();\n+\t\t\t\t}\n+\t\t\t\tIItemCollection gcCpuTimeItems = items.apply(JdkFilters.GC_CPU_TIME);\n+\t\t\t\tlong invertedParallelismCount = 0;\n+\t\t\t\tfor (IItemIterable item : gcCpuTimeItems) {\n+\t\t\t\t\tfor (IItem event : item) {\n+\t\t\t\t\t\tlong timeUser = RulesToolkit.getValue(event, JdkAttributes.GC_TIME_USER)\n+\t\t\t\t\t\t\t\t.longValueIn(UnitLookup.NANOSECOND);\n+\t\t\t\t\t\tlong timeSystem = RulesToolkit.getValue(event, JdkAttributes.GC_TIME_SYSTEM)\n+\t\t\t\t\t\t\t\t.longValueIn(UnitLookup.NANOSECOND);\n+\t\t\t\t\t\tlong timeReal = RulesToolkit.getValue(event, JdkAttributes.GC_TIME_REAL)\n+\t\t\t\t\t\t\t\t.longValueIn(UnitLookup.NANOSECOND);\n+\t\t\t\t\t\tif (isInvertedParallelism(calcParallelism(timeUser, timeSystem, timeReal))) {\n+\t\t\t\t\t\t\tinvertedParallelismCount++;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (invertedParallelismCount == 0) {\n+\t\t\t\t\treturn ResultBuilder.createFor(GcInvertedParallelismRule.this, valueProvider)\n+\t\t\t\t\t\t\t.setSeverity(Severity.OK).setSummary(\"OK\").build();\n+\t\t\t\t} else {\n+\t\t\t\t\treturn ResultBuilder.createFor(GcInvertedParallelismRule.this, valueProvider)\n+\t\t\t\t\t\t\t.addResult(INVERTED_PARALLELISM_COUNT, invertedParallelismCount)\n+\t\t\t\t\t\t\t.addResult(GC_CPU_TIME_EVENT_COUNT, gcCpuTimeItems.getAggregate(Aggregators.count()))\n+\t\t\t\t\t\t\t.setSeverity(Severity.WARNING)\n+\t\t\t\t\t\t\t.setSummary(Messages.getString(Messages.GcInvertedParallelism_TEXT_WARN_SHORT))\n+\t\t\t\t\t\t\t.setExplanation(Messages.getString(Messages.GcInvertedParallelism_TEXT_WARN_LONG)).build();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\t\/**\n+\t * Calculate parallelism, the ratio of user + sys to wall (real) time.\n+\t * \n+\t * @param timeUser\n+\t *            The user (non-kernel) time.\n+\t * @param timeSys\n+\t *            The sys (kernel) time.\n+\t * @param timeReal\n+\t *            The wall (clock) time.\n+\t * @return Percent user:real time rounded up the the nearest whole number.\n+\t *\/\n+\tpublic static int calcParallelism(final long timeUser, final long timeSys, final long timeReal) {\n+\t\tif (timeReal == 0) {\n+\t\t\tif (timeUser == 0 && timeUser == 0) {\n+\t\t\t\treturn 100;\n+\t\t\t}\n+\t\t\treturn Integer.MAX_VALUE;\n+\t\t} else {\n+\t\t\tBigDecimal parallelism = new BigDecimal(timeUser);\n+\t\t\tparallelism = parallelism.add(new BigDecimal(timeSys));\n+\t\t\tBigDecimal hundred = new BigDecimal(\"100\");\n+\t\t\tparallelism = parallelism.multiply(hundred);\n+\t\t\tparallelism = parallelism.divide(new BigDecimal(timeReal), 0, RoundingMode.CEILING);\n+\t\t\treturn parallelism.intValue();\n+\t\t}\n+\t}\n+\n+\t\/**\n+\t * @param parallelism\n+\t *            The parallelism percent (ratio or user to wall (real time).\n+\t * @return True if the parallelism is \"inverted\", false otherwise. Inverted parallelism is less\n+\t *         than 100. In other words, the parallel collection performance is less than serial\n+\t *         (single-threaded).\n+\t *\/\n+\tpublic static boolean isInvertedParallelism(int parallelism) {\n+\t\treturn (parallelism < 100);\n+\t}\n+\n+\t@Override\n+\tpublic Collection<TypedPreference<?>> getConfigurationAttributes() {\n+\t\treturn Collections.emptyList();\n+\t}\n+\n+\t@Override\n+\tpublic String getId() {\n+\t\treturn INVERTED_PARALLELISM_RESULT_ID;\n+\t}\n+\n+\t@Override\n+\tpublic String getName() {\n+\t\treturn Messages.getString(Messages.GcInvertedParallelism_RULE_NAME);\n+\t}\n+\n+\t@Override\n+\tpublic String getTopic() {\n+\t\treturn JfrRuleTopics.GARBAGE_COLLECTION;\n+\t}\n+\n+\t@Override\n+\tpublic Map<String, EventAvailability> getRequiredEvents() {\n+\t\treturn REQUIRED_EVENTS;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<TypedResult<?>> getResults() {\n+\t\treturn RESULT_ATTRIBUTES;\n+\t}\n+\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/memory\/GcInvertedParallelismRule.java","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"@@ -309,0 +309,3 @@\n+\tpublic static final String GcInvertedParallelism_RULE_NAME = \"GcInvertedParallelism_RULE_NAME\"; \/\/$NON-NLS-1$\n+\tpublic static final String GcInvertedParallelism_TEXT_WARN_SHORT = \"GcInvertedParallelism_TEXT_WARN_SHORT\"; \/\/$NON-NLS-1$\n+\tpublic static final String GcInvertedParallelism_TEXT_WARN_LONG = \"GcInvertedParallelism_TEXT_WARN_LONG\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/Messages.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+org.openjdk.jmc.flightrecorder.rules.jdk.memory.GcInvertedParallelismRule\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/resources\/META-INF\/services\/org.openjdk.jmc.flightrecorder.rules.IRule","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -333,0 +333,3 @@\n+GcInvertedParallelism_RULE_NAME=Inverted Parallelism\n+GcInvertedParallelism_TEXT_WARN_SHORT=Inverted Parallelism detected {invertedParallelismCount} times out of {gcCpuTimeEventCount} recorded events.\n+GcInvertedParallelism_TEXT_WARN_LONG=There is evidence of inverted parallelism. With parallel (multi-threaded) collector events, the \"user\" + \"sys\" time should be approximately equal to the \"real\" (wall) time multiplied by the # of GC threads. For example, if there are 3 GC threads we would expect a parallel collection that takes 1 second of \"real\" time to take approximately 3 seconds of \"user\" + \"sys\" time. The parallelism is 3x. If the parallelism is 1x (\"user\" + \"sys\" = \"real\"), the parallel collection is not offering any efficiency over a serial (single-threaded) collection. When \"user\" + \"sys\" < \"real\", the parallelism is inverted. Inverted parallelism can be a sign of high i\/o (e.g. disk or network access) or not enough CPU (e.g. GC threads competing with each other or other processes). Check for swapping and if the number of GC threads (-XX:ParallelGCThreads=<n>) is appropriate for the number of cpu\/cores and any processes sharing cpu.\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/messages.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -720,0 +720,6 @@\n+\tpublic static final IAttribute<IQuantity> GC_TIME_REAL = attr(\"realTime\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_GC_TIME_REAL), TIMESPAN);\n+\tpublic static final IAttribute<IQuantity> GC_TIME_SYSTEM = attr(\"systemTime\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_GC_TIME_SYSTEM), TIMESPAN);\n+\tpublic static final IAttribute<IQuantity> GC_TIME_USER = attr(\"userTime\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_GC_TIME_USER), TIMESPAN);\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkAttributes.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+\tpublic static final IItemFilter GC_CPU_TIME = ItemFilters.type(JdkTypeIDs.GC_CPU_TIME);\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkFilters.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -164,0 +164,1 @@\n+\tpublic static final String GC_CPU_TIME = PREFIX + \"GCCPUTime\";\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkTypeIDs.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -343,0 +343,3 @@\n+\tpublic static final String ATTR_GC_TIME_REAL = \"ATTR_GC_TIME_REAL\"; \/\/$NON-NLS-1$\n+\tpublic static final String ATTR_GC_TIME_SYSTEM = \"ATTR_GC_TIME_SYSTEM\"; \/\/$NON-NLS-1$\n+\tpublic static final String ATTR_GC_TIME_USER = \"ATTR_GC_TIME_USER\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/messages\/internal\/Messages.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -282,0 +282,3 @@\n+ATTR_GC_TIME_REAL=Real Time\n+ATTR_GC_TIME_SYSTEM=System Time\n+ATTR_GC_TIME_USER=User Time\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/jdk\/messages\/internal\/messages.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.test.rules.jdk;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.openjdk.jmc.flightrecorder.rules.jdk.memory.GcInvertedParallelismRule;\n+\n+public class GcParallelismTest {\n+\n+\t@Test\n+\tpublic void testCalcParallelism() {\n+\t\tint timeUser = 90;\n+\t\tint timeSys = 10;\n+\t\tint timeReal = 10;\n+\t\tAssert.assertEquals(1000, GcInvertedParallelismRule.calcParallelism(timeUser, timeSys, timeReal));\n+\t}\n+\n+\t@Test\n+\tpublic void testCalcParallelismRounded() {\n+\t\tint timeUser = 90;\n+\t\tint timeSys = 10;\n+\t\tint timeReal = 1000;\n+\t\tAssert.assertEquals(10, GcInvertedParallelismRule.calcParallelism(timeUser, timeSys, timeReal));\n+\t}\n+\n+\t@Test\n+\tpublic void testCalcParallelismRoundedUp() {\n+\t\tint timeUser = 90;\n+\t\tint timeSys = 10;\n+\t\tint timeReal = 199;\n+\t\tAssert.assertEquals(51, GcInvertedParallelismRule.calcParallelism(timeUser, timeSys, timeReal));\n+\t}\n+\n+\t@Test\n+\tpublic void testCalcParallelismUserZero() {\n+\t\tint timeUser = 0;\n+\t\tint timeSys = 0;\n+\t\tint timeReal = 100;\n+\t\tAssert.assertEquals(0, GcInvertedParallelismRule.calcParallelism(timeUser, timeSys, timeReal));\n+\t}\n+\n+\t@Test\n+\tpublic void testCalcParallelismRealZero() {\n+\t\tint timeUser = 100;\n+\t\tint timeSys = 0;\n+\t\tint timeReal = 0;\n+\t\tAssert.assertEquals(Integer.MAX_VALUE, GcInvertedParallelismRule.calcParallelism(timeUser, timeSys, timeReal));\n+\t}\n+\n+\t@Test\n+\tpublic void testCalcParallelismUserZeroRealZero() {\n+\t\tint timeUser = 0;\n+\t\tint timeSys = 0;\n+\t\tint timeReal = 0;\n+\t\tAssert.assertEquals(100, GcInvertedParallelismRule.calcParallelism(timeUser, timeSys, timeReal));\n+\t}\n+\n+\t@Test\n+\tpublic void testParallelism() {\n+\t\tAssert.assertTrue(GcInvertedParallelismRule.isInvertedParallelism(0));\n+\t\tAssert.assertTrue(GcInvertedParallelismRule.isInvertedParallelism(99));\n+\t\tAssert.assertFalse(GcInvertedParallelismRule.isInvertedParallelism(100));\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/rules\/jdk\/GcParallelismTest.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -143,0 +143,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -447,0 +451,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -718,0 +726,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -992,0 +1004,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -1251,0 +1267,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -1516,0 +1536,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -1781,0 +1805,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -2073,0 +2101,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -2371,0 +2403,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -2656,0 +2692,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -2975,0 +3015,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -3292,0 +3336,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -3498,0 +3546,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -3747,0 +3799,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -4017,0 +4073,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -4306,0 +4366,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -4469,0 +4533,550 @@\n+    <report>\n+        <file>jdk21-inverted-parallelism.jfr<\/file>\n+        <rule>\n+            <id>Allocations.class<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Allocations.thread<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ApplicationHalts<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>BufferLost<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No Flight Recorder buffers were lost during the recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>BytecodeVerification<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLeak<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLoading<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CodeCache<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CompareCpu<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CompressedOops<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ContextSwitch<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DMSIncident<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DebugNonSafepoints<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DiscouragedVmOptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DumpReason<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DuplicateFlags<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Exceptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Fatal Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FewSampledThreads<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FileRead<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FileWrite<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FinalizersRun<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FlightRecordingSupport<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FullGc<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No Stop-the-World, Full GC events detected.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>GarbageCollectionInfoRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcFreedRatio<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Warning<\/severity>\n+            <summary>Inverted Parallelism detected 1 times out of 11 recorded events.<\/summary>\n+            <explanation>There is evidence of inverted parallelism. With parallel (multi-threaded) collector events, the \"user\" + \"sys\" time should be approximately equal to the \"real\" (wall) time multiplied by the # of GC threads. For example, if there are 3 GC threads we would expect a parallel collection that takes 1 second of \"real\" time to take approximately 3 seconds of \"user\" + \"sys\" time. The parallelism is 3x. If the parallelism is 1x (\"user\" + \"sys\" = \"real\"), the parallel collection is not offering any efficiency over a serial (single-threaded) collection. When \"user\" + \"sys\" &lt; \"real\", the parallelism is inverted. Inverted parallelism can be a sign of high i\/o (e.g. disk or network access) or not enough CPU (e.g. GC threads competing with each other or other processes). Check for swapping and if the number of GC threads (-XX:ParallelGCThreads=&lt;n&gt;) is appropriate for the number of cpu\/cores and any processes sharing cpu.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>GcOptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseRatio<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HeapContent<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HeapDump<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HighGc<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HighJvmCpu<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingLiveSet<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingMetaSpaceLiveSet<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>JavaBlocking<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>LongGcPause<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>LowOnPhysicalMemory<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ManagementAgent<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ManyRunningProcesses<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MetaspaceOom<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MethodProfiling<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Options<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>OverAggressiveRecordingSetting<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInArguments<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInEnvironment<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInSystemProperties<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PrimitiveToObjectConversion<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ProcessStarted<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SocketRead<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SocketWrite<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>StackdepthSetting<\/id>\n+            <severity>Not Applicable<\/severity>\n+            <summary>No events with stack traces were recorded.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>StringDeduplication<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>TlabAllocationRatio<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>VMOperations<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocation<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocationPause<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+    <\/report>\n+    <report>\n+        <file>jdk21.jfr<\/file>\n+        <rule>\n+            <id>Allocations.class<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Allocations.thread<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ApplicationHalts<\/id>\n+            <severity>OK<\/severity>\n+            <summary>Application efficiency was not highly affected by halts.<\/summary>\n+            <explanation>The highest ratio of application halts to execution time was 0.172 % during 11\/20\/2023 4:22:52.000 PM – 4:23:52 PM. 0.118 % of the halts were for reasons other than GC. The halts ratio for the entire recording was 0.275 %. 0.114 % of the total halts were for reasons other than GC.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>BufferLost<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No Flight Recorder buffers were lost during the recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>BytecodeVerification<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLeak<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No classes with identical names have been loaded more times than the limit.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLoading<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No significant time was spent loading new classes during this recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>CodeCache<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CompareCpu<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CompressedOops<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ContextSwitch<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DMSIncident<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DebugNonSafepoints<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DiscouragedVmOptions<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No problems were found with the VM options.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>DumpReason<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DuplicateFlags<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Exceptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Fatal Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FewSampledThreads<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FileRead<\/id>\n+            <severity>OK<\/severity>\n+            <summary>There are no file read events in this recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>FileWrite<\/id>\n+            <severity>OK<\/severity>\n+            <summary>There are no file write events in this recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>FinalizersRun<\/id>\n+            <severity>Information<\/severity>\n+            <summary>80 finalizers were run.<\/summary>\n+            <explanation>Finalization can lead to performance issues, deadlocks, or hangs, and has been marked for removal in a future Java version. The following finalizable classes have been detected: &lt;ul&gt;&lt;li&gt;org.openjdk.jmc.rjmx.internal.DefaultConnectionHandle&lt;\/li&gt;&lt;li&gt;org.openjdk.jmc.rjmx.internal.ServerHandle&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n+            <solution>Remove finalize method implementations from your application, and consider making use of the [Cleaner API](https:\/\/docs.oracle.com\/en\/java\/javase\/17\/docs\/api\/java.base\/java\/lang\/ref\/Cleaner.html) instead.<\/solution>\n+        <\/rule>\n+        <rule>\n+            <id>FlightRecordingSupport<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FullGc<\/id>\n+            <severity>Warning<\/severity>\n+            <summary>Full GC detected.<\/summary>\n+            <explanation>At least one Full, Stop-The-World Garbage Collection occurred during this recording. For the CMS and G1 collectors, Full GC events are a strong negative performance indicator. Tunable GC parameters can be used to allow the collector to operate in concurrent mode, avoiding Stop-The-World pauses and increasing GC and application performance.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>GarbageCollectionInfoRule<\/id>\n+            <severity>OK<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcFreedRatio<\/id>\n+            <severity>OK<\/severity>\n+            <summary>Only 4 heap summary events were found, this rule requires at least 10 events to be able to calculate a relevant result. This likely means that only a few garbage collections occurred during the recording. Having few garbage collections is generally a good sign.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>OK<\/severity>\n+            <summary>OK<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>GcLocker<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No GCs were affected by the GC Locker.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>GcOptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseRatio<\/id>\n+            <severity>OK<\/severity>\n+            <summary>Application efficiency was not highly affected by GC pauses.<\/summary>\n+            <explanation>The highest ratio between garbage collection pauses and execution time was 0.172 % during 11\/20\/2023 4:22:52.000 PM – 4:23:52 PM. The garbage collection pause ratio of the entire recording was 0.275 %.<\/explanation>\n+            <solution>Pause times may be reduced by increasing the heap size or by trying to reduce allocation.<\/solution>\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcStall<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No indications that the garbage collector could not keep up with the workload were detected.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>HeapContent<\/id>\n+            <severity>Warning<\/severity>\n+            <summary>Most of the heap was used by only a few classes.<\/summary>\n+            <explanation>If the heap usage needs to be reduced, then this would be a good place to start.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>HeapDump<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No heap dump performed.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>HeapInspectionGc<\/id>\n+            <severity>Information<\/severity>\n+            <summary>The JVM performed 2 heap inspection garbage collections.<\/summary>\n+            <explanation>Performing heap inspection garbage collections may be a problem since they usually take a lot of time.\n+Some of these inspections were caused by the 'Object Count' JFR event. It triggers a full garbage collection at the beginning and end of every recording where that event is enabled. If recordings are only made on demand or not too often, then these garbage collections are usually not a problem since the resulting pauses are not part of the normal application behavior. If recordings are collected often, for example by automatic scripts, or if the application is sensitive to pauses, then it might become an issue. In that case you can consider disabling the 'Object Count' event.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>HighGc<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The JVM was paused for 100 % during 11\/20\/2023 4:23:22.169.000 PM – .272<\/summary>\n+            <explanation>The time spent performing garbage collection may be reduced by increasing the heap size or by trying to reduce allocation.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>HighJvmCpu<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingLiveSet<\/id>\n+            <severity>Not Applicable<\/severity>\n+            <summary>Too few events to calculate the result.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingMetaSpaceLiveSet<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The class data does not seem to increase during the recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>JavaBlocking<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No excessive problems with lock contention found.<\/summary>\n+            <explanation>The following regular expression was used to exclude threads from this rule: ''(.*weblogic\\.socket\\.Muxer.*)''<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>LongGcPause<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The longest GC pause was 103.247 ms.<\/summary>\n+            <explanation\/>\n+        <\/rule>\n+        <rule>\n+            <id>LowOnPhysicalMemory<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ManagementAgent<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ManyRunningProcesses<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MetaspaceOom<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The metaspace was not exhausted during this recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>MethodProfiling<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No methods where optimization would be particularly efficient could be detected.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>Options<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>OverAggressiveRecordingSetting<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInArguments<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInEnvironment<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInSystemProperties<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PrimitiveToObjectConversion<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No allocation was caused by conversion from primitive types to the corresponding object types.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>ProcessStarted<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SocketRead<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SocketWrite<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>StackdepthSetting<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No stack traces were truncated in this recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>StringDeduplication<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SystemGc<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No garbage collections were caused by System.gc().<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>TlabAllocationRatio<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The program allocated 4.04 % of the memory outside of TLABs.<\/summary>\n+            <solution>Allocating objects outside of Thread Local Allocation Buffers (TLABs) is more expensive than allocating inside TLABs. This may be acceptable if the individual allocations are intended to be larger than a reasonable TLAB. It may be possible to avoid this by decreasing the size of the individual allocations. There are some TLAB related JVM flags that you can experiment with, but it is usually better to let the JVM manage TLAB sizes automatically.<\/solution>\n+        <\/rule>\n+        <rule>\n+            <id>VMOperations<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No excessively long VM operations were found in this recording (the longest was 103.369 ms).<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocation<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocationPause<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No revocation of biased locks found.<\/summary>\n+        <\/rule>\n+    <\/report>\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/baseline\/JfrRuleBaseline.xml","additions":614,"deletions":0,"binary":false,"changes":614,"status":"modified"},{"patch":"@@ -9,0 +9,2 @@\n+jdk21.jfr\n+jdk21-inverted-parallelism.jfr\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/jfr\/index.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/jfr\/jdk21-inverted-parallelism.jfr","binary":true,"status":"added"},{"filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/jfr\/jdk21.jfr","binary":true,"status":"added"}]}