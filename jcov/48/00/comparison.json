{"files":[{"patch":"@@ -1,1 +1,1 @@\n-# Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-build.number = 13\n+build.number = 14\n","filename":"build\/release.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+### IntelliJ IDEA ###\n+out\/\n+!**\/src\/main\/**\/out\/\n+!**\/src\/test\/**\/out\/\n+\n+### Eclipse ###\n+.apt_generated\n+.classpath\n+.factorypath\n+.project\n+.settings\n+.springBeans\n+.sts4-cache\n+bin\/\n+!**\/src\/main\/**\/bin\/\n+!**\/src\/test\/**\/bin\/\n+\n+### NetBeans ###\n+\/nbproject\/private\/\n+\/nbbuild\/\n+\/dist\/\n+\/nbdist\/\n+\/.nb-gradle\/\n+\n+### VS Code ###\n+.vscode\/\n+\n+### Mac OS ###\n+.DS_Store\n\\ No newline at end of file\n","filename":"src\/classes\/.gitignore","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,8 +27,0 @@\n-import com.sun.tdk.jcov.instrument.DataMethod;\n-import com.sun.tdk.jcov.instrument.DataClass;\n-import com.sun.tdk.jcov.instrument.DataField;\n-import com.sun.tdk.jcov.processing.DataProcessorSPI;\n-import com.sun.tdk.jcov.report.AncFilter;\n-import com.sun.tdk.jcov.report.ParameterizedAncFilter;\n-import com.sun.tdk.jcov.report.AncFilterFactory;\n-import com.sun.tdk.jcov.util.Utils;\n@@ -37,6 +29,0 @@\n-import com.sun.tdk.jcov.instrument.DataRoot;\n-import com.sun.tdk.jcov.processing.ProcessingException;\n-\n-import com.sun.tdk.jcov.tools.EnvHandler;\n-import com.sun.tdk.jcov.tools.OptionDescr;\n-import com.sun.tdk.jcov.io.Reader;\n@@ -44,1 +30,0 @@\n-import com.sun.tdk.jcov.filter.MemberFilter;\n@@ -46,1 +31,2 @@\n-import com.sun.tdk.jcov.instrument.InstrumentationOptions;\n+import com.sun.tdk.jcov.filter.MemberFilter;\n+import com.sun.tdk.jcov.instrument.*;\n@@ -48,0 +34,2 @@\n+import com.sun.tdk.jcov.io.Reader;\n+import com.sun.tdk.jcov.processing.DataProcessorSPI;\n@@ -49,0 +37,1 @@\n+import com.sun.tdk.jcov.processing.ProcessingException;\n@@ -50,5 +39,1 @@\n-import com.sun.tdk.jcov.report.DefaultReportGeneratorSPI;\n-import com.sun.tdk.jcov.report.ProductCoverage;\n-import com.sun.tdk.jcov.report.ReportGenerator;\n-import com.sun.tdk.jcov.report.ReportGeneratorSPI;\n-import com.sun.tdk.jcov.report.SmartTestService;\n+import com.sun.tdk.jcov.report.*;\n@@ -57,0 +42,1 @@\n+import com.sun.tdk.jcov.tools.EnvHandler;\n@@ -58,0 +44,1 @@\n+import com.sun.tdk.jcov.tools.OptionDescr;\n@@ -59,0 +46,3 @@\n+import com.sun.tdk.jcov.util.Utils;\n+\n+import java.io.File;\n@@ -61,0 +51,2 @@\n+import java.util.Arrays;\n+import java.util.List;\n@@ -65,4 +57,1 @@\n-import static com.sun.tdk.jcov.tools.OptionDescr.*;\n-import java.io.File;\n-import java.util.Arrays;\n-import java.util.List;\n+import static com.sun.tdk.jcov.tools.OptionDescr.VAL_SINGLE;\n@@ -88,0 +77,1 @@\n+\n@@ -202,1 +192,1 @@\n-     * @param classes parsed javap classes\n+     * @param classes     parsed javap classes\n@@ -236,1 +226,1 @@\n-        if (ancfilters != null){\n+        if (ancfilters != null) {\n@@ -315,1 +305,1 @@\n-                        + \"Datafile {0} contains {1} item(s).\\nThe test list contains {2} item(s).\",\n+                                + \"Datafile {0} contains {1} item(s).\\nThe test list contains {2} item(s).\",\n@@ -347,1 +337,0 @@\n-        ReportGenerator rg = null;\n@@ -350,1 +339,1 @@\n-                rg = reportGeneratorSPI.getReportGenerator(name);\n+                ReportGenerator rg = reportGeneratorSPI.getReportGenerator(name);\n@@ -511,1 +500,1 @@\n-    public void setDataProcessorsSPIs(DataProcessorSPI[] dataProcessorSPIs){\n+    public void setDataProcessorsSPIs(DataProcessorSPI[] dataProcessorSPIs) {\n@@ -537,6 +526,6 @@\n-     * @param include patterns for including data. Set null for default value -\n-     * {\".*\"} (include all)\n-     * @param exclude patterns for excluding data. Set null for default value -\n-     * {\"\"} (exclude nothing)\n-     * @param classModifiers modifiers that should have a class to be included\n-     * @param filter custom filter classname\n+     * @param include             patterns for including data. Set null for default value -\n+     *                            {\".*\"} (include all)\n+     * @param exclude             patterns for excluding data. Set null for default value -\n+     *                            {\"\"} (exclude nothing)\n+     * @param classModifiers      modifiers that should have a class to be included\n+     * @param filter              custom filter classname\n@@ -544,6 +533,6 @@\n-     * @param publicAPI should generate only public API (public and protected)\n-     * @param hideAbstract should hide abstract data\n-     * @param hideMethods should hide methods\n-     * @param hideBlocks should hide blocks\n-     * @param hideBranches should hide branches\n-     * @param hideLines should hide lines\n+     * @param publicAPI           should generate only public API (public and protected)\n+     * @param hideAbstract        should hide abstract data\n+     * @param hideMethods         should hide methods\n+     * @param hideBlocks          should hide blocks\n+     * @param hideBranches        should hide branches\n+     * @param hideLines           should hide lines\n@@ -552,3 +541,3 @@\n-            String filter, boolean generateShortFormat, boolean publicAPI, boolean hideAbstract,\n-            boolean hideMethods, boolean hideBlocks, boolean hideBranches, boolean hideLines,\n-            boolean hideFields) {\n+                          String filter, boolean generateShortFormat, boolean publicAPI, boolean hideAbstract,\n+                          boolean hideMethods, boolean hideBlocks, boolean hideBranches, boolean hideLines,\n+                          boolean hideFields) {\n@@ -564,4 +553,4 @@\n-     * @param include patterns for including data. Set null for default value -\n-     * {\".*\"} (include all)\n-     * @param exclude patterns for excluding data. Set null for default value -\n-     * {\"\"} (exclude nothing)\n+     * @param include        patterns for including data. Set null for default value -\n+     *                       {\".*\"} (include all)\n+     * @param exclude        patterns for excluding data. Set null for default value -\n+     *                       {\"\"} (exclude nothing)\n@@ -690,28 +679,28 @@\n-                    DSC_FMT,\n-                    DSC_OUTPUT,\n-                    \/\/            DSC_STDOUT,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MINCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MEXCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MINCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MEXCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_FM,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_FM_LIST,\n-                    DSC_NO_ABSTRACT,\n-                    DSC_SYNTHETIC_ON,\n-                    DSC_PUBLIC_API,\n-                    DSC_SRC_ROOT,\n-                    DSC_VERBOSE,\n-                    DSC_FILTER_PLUGIN,\n-                    DSC_ANC_FILTER_PLUGINS,\n-                    DSC_ANC_DEFAULT_FILTERS,\n-                    DSC_TEST_LIST,\n-                    DSC_ANONYM,\n-                    DSC_JAVAP,\n-                    DSC_TESTS_INFO,\n-                    DSC_REPORT_TITLE_MAIN,\n-                    DSC_REPORT_TITLE_OVERVIEW,\n-                    DSC_REPORT_TITLE_ENTITIES,}, this);\n+                DSC_FMT,\n+                DSC_OUTPUT,\n+                \/\/            DSC_STDOUT,\n+                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE,\n+                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE,\n+                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE_LIST,\n+                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE_LIST,\n+                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MINCLUDE_LIST,\n+                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MEXCLUDE_LIST,\n+                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MINCLUDE,\n+                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MEXCLUDE,\n+                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_FM,\n+                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_FM_LIST,\n+                DSC_NO_ABSTRACT,\n+                DSC_SYNTHETIC_ON,\n+                DSC_PUBLIC_API,\n+                DSC_SRC_ROOT,\n+                DSC_VERBOSE,\n+                DSC_FILTER_PLUGIN,\n+                DSC_ANC_FILTER_PLUGINS,\n+                DSC_ANC_DEFAULT_FILTERS,\n+                DSC_TEST_LIST,\n+                DSC_ANONYM,\n+                DSC_JAVAP,\n+                DSC_TESTS_INFO,\n+                DSC_REPORT_TITLE_MAIN,\n+                DSC_REPORT_TITLE_OVERVIEW,\n+                DSC_REPORT_TITLE_ENTITIES,}, this);\n@@ -767,1 +756,1 @@\n-        if (opts.isSet(DSC_REPORT_TITLE_MAIN)){\n+        if (opts.isSet(DSC_REPORT_TITLE_MAIN)) {\n@@ -770,1 +759,1 @@\n-        if (opts.isSet(DSC_REPORT_TITLE_OVERVIEW)){\n+        if (opts.isSet(DSC_REPORT_TITLE_OVERVIEW)) {\n@@ -773,1 +762,1 @@\n-        if (opts.isSet(DSC_REPORT_TITLE_ENTITIES)){\n+        if (opts.isSet(DSC_REPORT_TITLE_ENTITIES)) {\n@@ -836,0 +825,1 @@\n+\n@@ -838,6 +828,6 @@\n-            \"Report generation output.\", VAL_SINGLE,\n-            \"Specifies the format of the report.\\n\"\n-            + \"Use \\\"text\\\" for generate text report and \\\"html\\\" for generate HTML report\\n\"\n-            + \"Text report in one file which contains method\/block\/branch coverage information.\\n\"\n-            + \"HTML report contains coverage information with marked-up sources.\\n\\n\"\n-            + \"Custom reports can be specified with ReportGeneratorSPI interface.\", \"html\");\n+                    \"Report generation output.\", VAL_SINGLE,\n+                    \"Specifies the format of the report.\\n\"\n+                            + \"Use \\\"text\\\" for generate text report and \\\"html\\\" for generate HTML report\\n\"\n+                            + \"Text report in one file which contains method\/block\/branch coverage information.\\n\"\n+                            + \"HTML report contains coverage information with marked-up sources.\\n\\n\"\n+                            + \"Custom reports can be specified with ReportGeneratorSPI interface.\", \"html\");\n@@ -849,1 +839,1 @@\n-            \"Output directory for generating text and HTML reports.\", \"report\");\n+                    \"Output directory for generating text and HTML reports.\", \"report\");\n@@ -855,2 +845,2 @@\n-            \"Specify the path to the file containing test list. File should contain a list of tests\\n\"\n-            + \"with one name per line.\");\n+                    \"Specify the path to the file containing test list. File should contain a list of tests\\n\"\n+                            + \"with one name per line.\");\n@@ -859,1 +849,1 @@\n-            \"Custom filtering plugin class\");\n+                    \"Custom filtering plugin class\");\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/RepGen.java","additions":82,"deletions":92,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import com.sun.tdk.jcov.data.Scale;\n@@ -29,1 +30,0 @@\n-import com.sun.tdk.jcov.data.Scale;\n@@ -31,0 +31,1 @@\n+\n@@ -95,6 +96,6 @@\n-            final int access,\n-            final String name,\n-            final String desc,\n-            final String signature,\n-            final String[] exceptions,\n-            final boolean differentiateMethods) {\n+               final int access,\n+               final String name,\n+               final String desc,\n+               final String signature,\n+               final String[] exceptions,\n+               final boolean differentiateMethods) {\n@@ -117,1 +118,0 @@\n-     *\n@@ -131,0 +131,11 @@\n+    \/**\n+     * This method clears the LineTable associated with the method.\n+     * It can be used when switching from Java source line coverage to javap output line coverage.\n+     *\n+     * @return  the instance\n+     *\/\n+    public DataMethod clearLineTable() {\n+        lineTable.clear();\n+        return this;\n+    }\n+\n@@ -183,2 +194,3 @@\n-     * Get methods access code\n-     * @return methods access code\n+     * Get method's access code\n+     *\n+     * @return method's access code\n@@ -190,1 +202,3 @@\n-    public Modifiers getModifiers() { return access; }\n+    public Modifiers getModifiers() {\n+        return access;\n+    }\n@@ -204,1 +218,0 @@\n-     * @see #getAccess()\n@@ -206,0 +219,1 @@\n+     * @see #getAccess()\n@@ -215,1 +229,0 @@\n-     * @see #getAccess()\n@@ -217,0 +230,1 @@\n+     * @see #getAccess()\n@@ -225,1 +239,0 @@\n-     * @see #getAccess()\n@@ -227,0 +240,1 @@\n+     * @see #getAccess()\n@@ -307,1 +321,1 @@\n-     *\n+     * <p>\n@@ -318,1 +332,1 @@\n-     *\n+     * <p>\n@@ -329,1 +343,1 @@\n-     *\n+     * <p>\n@@ -340,1 +354,1 @@\n-     *\n+     * <p>\n@@ -378,1 +392,1 @@\n-        return super.toString() + \"-\" + name;\n+        return \"0x%04x %s\".formatted(access.access(), getFullName());\n@@ -468,1 +482,1 @@\n-            lineTable = new ArrayList<LineEntry>();\n+            lineTable = new ArrayList<>();\n@@ -617,1 +631,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DataMethod.java","additions":36,"deletions":22,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import com.sun.tdk.jcov.report.javap.JavapCodeLine;\n+import com.sun.tdk.jcov.report.javap.JavapLine;\n@@ -35,0 +37,1 @@\n+\n@@ -49,0 +52,2 @@\n+ * @author Dmitry Fazunenko\n+ * @author Alexey Fedorchenko\n@@ -52,3 +57,0 @@\n- *\n- * @author Dmitry Fazunenko\n- * @author Alexey Fedorchenko\n@@ -59,1 +61,1 @@\n-    private boolean javapSource = false;\n+    private boolean javapCoverage = false;\n@@ -65,1 +67,1 @@\n-        DataType.BLOCK, DataType.BRANCH, DataType.LINE};\n+            DataType.BLOCK, DataType.BRANCH, DataType.LINE};\n@@ -78,1 +80,1 @@\n-     * @param clz DataClass to read data from\n+     * @param clz          DataClass to read data from\n@@ -80,1 +82,1 @@\n-     * @param filter Allows to filter read data\n+     * @param filter       Allows to filter read data\n@@ -98,3 +100,3 @@\n-        if (ancFilters != null){\n-            for (AncFilter ancFilter : ancFilters){\n-                if (ancFilter.accept(clz)){\n+        if (ancFilters != null) {\n+            for (AncFilter ancFilter : ancFilters) {\n+                if (ancFilter.accept(clz)) {\n@@ -108,0 +110,13 @@\n+        \/\/ Checks the mode of the line coverage: either Java or Javap\n+        if (javapClasses == null) {\n+            this.source = findBestSource(clz, srcRootPaths);\n+        } else {\n+            javapCoverage = true;\n+            for (JavapClass jpClass : javapClasses) {\n+                if (jpClass != null && jpClass.getClassName().equals(name)) {\n+                    javapClass = jpClass;\n+                    break;\n+                }\n+            }\n+        }\n+\n@@ -114,4 +129,4 @@\n-            if (ancFilters != null){\n-                for (AncFilter ancFilter : ancFilters){\n-                    if (isInAnc || ancFilter.accept(clz, method)){\n-                        methodCoverage = new MethodCoverage(method, ancFilters, ancFilter.getAncReason());\n+            if (ancFilters != null) {\n+                for (AncFilter ancFilter : ancFilters) {\n+                    if (isInAnc || ancFilter.accept(clz, method)) {\n+                        methodCoverage = new MethodCoverage(method, javapCoverage, ancFilters, ancFilter.getAncReason());\n@@ -124,1 +139,1 @@\n-                methodCoverage = new MethodCoverage(method, ancFilters, null);\n+                methodCoverage = new MethodCoverage(method, javapCoverage, ancFilters, null);\n@@ -130,1 +145,1 @@\n-            if (method.getModifiers().isSynthetic() && method.getName().startsWith(\"lambda$\")){\n+            if (method.getModifiers().isSynthetic() && method.getName().startsWith(\"lambda$\")) {\n@@ -135,1 +150,4 @@\n-            lineCoverage.processLineCoverage(methodCoverage.getLineCoverage());\n+            if (!javapCoverage) {\n+                \/\/Since Javap mode is selected, it doesn't make sense to calculate line coverage for Java sources.\n+                lineCoverage.processLineCoverage(methodCoverage.getLineCoverage());\n+            }\n@@ -146,4 +164,4 @@\n-        if (javapClasses == null) {\n-            this.source = findBestSource(clz, srcRootPaths);\n-        } else {\n-            javapSource = true;\n+        if (javapCoverage) {\n+            \/\/ Set line coverage according to the chosen Javap mode\n+            setJavapLineCoverage(javapClass);\n+        }\n@@ -151,4 +169,3 @@\n-            for (JavapClass jpClass : javapClasses) {\n-                if (jpClass != null\n-                        && jpClass.getClassName() != null\n-                        && (jpClass.getClassName()).equals(name)) {\n+        Collections.sort(methods);\n+        Collections.sort(fields);\n+    }\n@@ -156,2 +173,18 @@\n-                    javapClass = jpClass;\n-                    break;\n+    \/**\n+     * Set the line coverage based on the Javap structure.\n+     *\n+     * @param javapClass represents the javap output for the current class.\n+     * @see com.sun.tdk.jcov.report.javap.JavapClass\n+     *\/\n+    private void setJavapLineCoverage(JavapClass javapClass) {\n+        \/\/ update Class LineCoverage\n+        this.lineCoverage.clear();\n+        for (MethodCoverage methodCoverage : methods) {\n+            List<JavapLine> javapLines = javapClass.getMethod(methodCoverage.getName(), methodCoverage.getSignature());\n+            if (javapLines != null) {\n+                methodCoverage.clearLineCoverage();\n+                DataMethod dataMethod = methodCoverage.getDataMethod().clearLineTable();\n+                for (JavapCodeLine javapCodeLine : javapLines.stream().\n+                        filter(l -> l instanceof JavapCodeLine).\n+                        map(l -> (JavapCodeLine) l).toList()) {\n+                    dataMethod.addLineEntry(javapCodeLine.getCodeNumber(), javapCodeLine.getLineNumber());\n@@ -159,0 +192,1 @@\n+                methodCoverage.setLineCoverage();\n@@ -160,0 +194,1 @@\n+            this.lineCoverage.processLineCoverage(methodCoverage.getLineCoverage());\n@@ -161,3 +196,0 @@\n-\n-        Collections.sort(methods);\n-        Collections.sort(fields);\n@@ -167,1 +199,1 @@\n-     * @return true if the class doesn't contain neither methods or fields\n+     * @return true if the class doesn't contain neither methods nor fields\n@@ -182,1 +214,3 @@\n-    public boolean isPublicAPI() { return modifiers.isPublic() || modifiers.isProtected(); }\n+    public boolean isPublicAPI() {\n+        return modifiers.isPublic() || modifiers.isProtected();\n+    }\n@@ -336,2 +370,7 @@\n-    public boolean isJavapSource() {\n-        return javapSource;\n+    \/**\n+     * Return whether the coverage of the Javap sources is selected.\n+     *\n+     * @return true if the coverage of javap sources is selected.\n+     *\/\n+    public boolean isJavapCoverage() {\n+        return javapCoverage;\n@@ -367,1 +406,1 @@\n-    public boolean isLineInAnc(int lineNum){\n+    public boolean isLineInAnc(int lineNum) {\n@@ -371,1 +410,1 @@\n-    public void setAncInfo(String ancInfo){\n+    public void setAncInfo(String ancInfo) {\n@@ -376,1 +415,1 @@\n-    public String getAncInfo(){\n+    public String getAncInfo() {\n@@ -414,1 +453,1 @@\n-                    if (method.count <= 0 && !method.isMethodInAnc()){\n+                    if (method.count <= 0 && !method.isMethodInAnc()) {\n@@ -431,1 +470,1 @@\n-                        covered.add(new CoverageData(0, mcov.getAnc() ,mcov.getTotal()));\n+                        covered.add(new CoverageData(0, mcov.getAnc(), mcov.getTotal()));\n@@ -504,2 +543,1 @@\n-            }\n-            else{\n+            } else {\n@@ -523,0 +561,1 @@\n+\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/report\/ClassCoverage.java","additions":81,"deletions":42,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,2 @@\n-    final HashMap<Long, Boolean> lines_hits = new HashMap<Long, Boolean>();\n-    final HashMap<Long, Boolean> lines_ancs = new HashMap<Long, Boolean>();\n+    final HashMap<Long, Boolean>  lines_hits = new HashMap<>();\n+    final HashMap<Long, Boolean> lines_ancs = new HashMap<>();\n@@ -45,0 +45,13 @@\n+    \/**\n+     * This method removes all from this line coverage.\n+     * It can be used when switching from Java source line coverage to javap output line coverage.\n+     *\n+     * @return  the instance\n+     *\/\n+    public LineCoverage clear() {\n+        covered = anc = total = 0;\n+        lines_hits.clear();\n+        lines_ancs.clear();\n+        return this;\n+    }\n+\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/report\/LineCoverage.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.tdk.jcov.instrument.*;\n@@ -29,7 +30,0 @@\n-import java.util.Map;\n-import java.util.HashMap;\n-import com.sun.tdk.jcov.instrument.DataBlockTarget;\n-import com.sun.tdk.jcov.instrument.DataBlockTargetCond;\n-import com.sun.tdk.jcov.instrument.XmlNames;\n-import com.sun.tdk.jcov.instrument.DataBlock;\n-import com.sun.tdk.jcov.instrument.DataMethod;\n@@ -37,4 +31,3 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Iterator;\n-import java.util.List;\n+\n+import java.util.*;\n+\n@@ -56,0 +49,1 @@\n+    private DataMethod dataMethod;\n@@ -65,9 +59,0 @@\n-    \/**\n-     * <p> Creates new MethodCoverage instance without counting blocks <\/p>\n-     *\n-     * @param method DataMethod to read data from\n-     *\/\n-    public MethodCoverage(DataMethod method, AncFilter[] ancFilters, String ancReason) {\n-        this(method, false, ancFilters, ancReason);\n-    }\n-\n@@ -82,1 +67,0 @@\n-     * @param countBlocks not used\n@@ -84,1 +68,2 @@\n-    public MethodCoverage(DataMethod method, boolean countBlocks,  AncFilter[] ancFilters, String ancReason) {\n+    public MethodCoverage(DataMethod method, boolean javapCoverage, AncFilter[] ancFilters, String ancReason) {\n+        this.dataMethod = method;\n@@ -90,1 +75,1 @@\n-                        method.getLineTable().get(0).line : 0;\n+                method.getLineTable().get(0).line : 0;\n@@ -98,0 +83,4 @@\n+        if( !javapCoverage ) {\n+            setLineCoverage();\n+        } \/\/ else Javap line coverage is calculated in ClassCoverage.setJavapLineCoverage(JavapClass javapClass)\n+    }\n@@ -99,1 +88,5 @@\n-        List<LineEntry> lineTable = method.getLineTable();\n+    \/**\n+     * Sets the line coverage for the method.\n+     *\/\n+    public void setLineCoverage() {\n+        List<LineEntry> lineTable = dataMethod.getLineTable();\n@@ -107,2 +100,1 @@\n-                        }\n-                        else {\n+                        } else {\n@@ -118,1 +110,1 @@\n-                if (item.getSourceLine() < 0 && lineTable.size() > 0){\n+                if (item.getSourceLine() < 0 && lineTable.size() > 0) {\n@@ -125,2 +117,2 @@\n-    private static String isBlockInAnc(DataMethod m, DataBlock b , AncFilter[] filters, List<String> ancBlockReasons){\n-        if (filters == null){\n+    private static String isBlockInAnc(DataMethod m, DataBlock b, AncFilter[] filters, List<String> ancBlockReasons) {\n+        if (filters == null) {\n@@ -129,2 +121,2 @@\n-        for (AncFilter filter : filters){\n-            if (filter.accept(m , b)){\n+        for (AncFilter filter : filters) {\n+            if (filter.accept(m, b)) {\n@@ -167,1 +159,1 @@\n-     void detectItems(DataMethod m, List<ItemCoverage> list, boolean isInAnc, AncFilter[] ancFilters) {\n+    void detectItems(DataMethod m, List<ItemCoverage> list, boolean isInAnc, AncFilter[] ancFilters) {\n@@ -184,1 +176,1 @@\n-            if (isInAnc || ancReason != null){\n+            if (isInAnc || ancReason != null) {\n@@ -222,1 +214,1 @@\n-            if (isInAnc || ancReason != null){\n+            if (isInAnc || ancReason != null) {\n@@ -254,1 +246,1 @@\n-                if (isInAnc || ancReason != null){\n+                if (isInAnc || ancReason != null) {\n@@ -263,2 +255,2 @@\n-                        if (added.get(d).scale != null && db.getScale() != null){\n-                            Scale s =  Scale.createZeroScale(added.get(d).scale.size());\n+                        if (added.get(d).scale != null && db.getScale() != null) {\n+                            Scale s = Scale.createZeroScale(added.get(d).scale.size());\n@@ -293,1 +285,1 @@\n-    public void setAncInfo(String ancInfo){\n+    public void setAncInfo(String ancInfo) {\n@@ -298,1 +290,1 @@\n-    public boolean isMethodInAnc(){\n+    public boolean isMethodInAnc() {\n@@ -302,1 +294,1 @@\n-    public String getAncInfo(){\n+    public String getAncInfo() {\n@@ -338,0 +330,9 @@\n+    \/**\n+     * Returns associated method's data\n+     *\n+     * @return data of the method\n+     *\/\n+    public DataMethod getDataMethod() {\n+        return dataMethod;\n+    }\n+\n@@ -358,0 +359,7 @@\n+    \/**\n+     * Clears line coverage of the methods\n+     *\/\n+    public void clearLineCoverage() {\n+        lineCoverage.clear();\n+    }\n+\n@@ -396,1 +404,1 @@\n-                if (name.startsWith(\"lambda$\")){\n+                if (name.startsWith(\"lambda$\")) {\n@@ -423,1 +431,1 @@\n-                        if (isInAnc){\n+                        if (isInAnc) {\n@@ -425,2 +433,1 @@\n-                        }\n-                        else {\n+                        } else {\n@@ -459,0 +466,1 @@\n+\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/report\/MethodCoverage.java","additions":53,"deletions":45,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -1108,1 +1108,1 @@\n-        if (src == null || theClass.isJavapSource()) {\n+        if (src == null || theClass.isJavapCoverage()) {\n@@ -1141,1 +1141,1 @@\n-        generateMemberTable(pw, theClass, \"method\", methodList, isGenerate, theClass.isJavapSource());\n+        generateMemberTable(pw, theClass, \"method\", methodList, isGenerate, theClass.isJavapCoverage());\n@@ -1152,1 +1152,1 @@\n-            generateMemberTable(pw, theClass, \"field\", fieldList, isGenerate, theClass.isJavapSource());\n+            generateMemberTable(pw, theClass, \"field\", fieldList, isGenerate, theClass.isJavapCoverage());\n@@ -1169,1 +1169,1 @@\n-        if (theClass.isJavapSource()) {\n+        if (theClass.isJavapCoverage()) {\n@@ -1179,1 +1179,1 @@\n-                    List<JavapLine> lines = javapClass.getMethod(mcov.getName() + mcov.getSignature());\n+                    List<JavapLine> lines = javapClass.getMethod(mcov.getName(), mcov.getSignature());\n@@ -1850,1 +1850,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/report\/html\/CoverageReport.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014,2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014,2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,6 +27,1 @@\n-import java.io.BufferedReader;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.InputStreamReader;\n-import java.io.OutputStreamWriter;\n-import java.io.PrintWriter;\n+import java.io.*;\n@@ -49,1 +44,0 @@\n-    \/\/ class as list of JavapLines\n@@ -55,1 +49,1 @@\n-     * return method in the class like list of JavapLines\n+     * Get a list of JavapLines associated with the method\n@@ -57,3 +51,3 @@\n-     * @param nameAndVMSig name and VMsig string is needed to find method in the\n-     * class\n-     * @return method in the class like list of JavapLines\n+     * @param methodName      the name of the method to find\n+     * @param methodSignature the signature of the method to find\n+     * @return a list of JavapLines associated with the method\n@@ -61,5 +55,3 @@\n-    public List<JavapLine> getMethod(String nameAndVMSig) {\n-\n-        List<Integer> numbers = methods.get(nameAndVMSig);\n-\n-        if (numbers == null || numbers.isEmpty()) {\n+    public List<JavapLine> getMethod(String methodName, String methodSignature) {\n+        List<Integer> list = methods.get(methodName + methodSignature);\n+        if (list == null || list.isEmpty()) {\n@@ -68,2 +60,1 @@\n-\n-        return lines.subList(numbers.get(0), numbers.get(numbers.size() - 1) + 1);\n+        return lines.subList(list.get(0), list.get(list.size() - 1) + 1);\n@@ -73,5 +64,1 @@\n-        return className;\n-    }\n-\n-    public String getPackageName() {\n-        return packageName;\n+        return className == null ? \"\" : className;\n@@ -81,1 +68,1 @@\n-     * return javap result for class like list of JavapLines\n+     * return a list of JavapLines associated with the class\n@@ -121,1 +108,0 @@\n-                    \/\/ check if it is constructor or not\n@@ -135,3 +121,1 @@\n-                if (textLine.contains(\":\") && !textLine.contains(\"Code\")\n-                        && !textLine.contains(\"case\") && !textLine.contains(\"default\")\n-                        && !textLine.contains(\"Exception table\")) {\n+                if (isCodeLine(textLine)) {\n@@ -142,1 +126,0 @@\n-\n@@ -147,1 +130,0 @@\n-\n@@ -152,0 +134,4 @@\n+    }\n+\n+    final private static Pattern codeLinePattern = Pattern.compile(\"^\\\\s*\\\\d+:.*\");\n+    final private static Pattern switchPattern = Pattern.compile(\"^\\\\s*\\\\d+:\\\\s+\\\\d+$\");\n@@ -153,0 +139,13 @@\n+    \/**\n+     * Check whether the line is a code line\n+     *\n+     * @param textLine javap source line\n+     * @return true if the line is the code line\n+     *\/\n+    private boolean isCodeLine(String textLine) {\n+        if (codeLinePattern.matcher(textLine).find()) {\n+            int ind = textLine.indexOf(\"\/\/\");\n+            String line = ((ind != -1) ? textLine.substring(ind) : textLine).trim();\n+            return !switchPattern.matcher(line).find();\n+        }\n+        return false;\n@@ -155,1 +154,1 @@\n-    final private static String[] JavaClassTokens = new String[] {\"implements\", \"extends\", \"{\"};\n+    final private static String[] JavaClassTokens = new String[]{\"implements\", \"extends\", \"{\"};\n@@ -159,3 +158,3 @@\n-         for( String s :  JavaClassTokens) {\n-             if (textLine.contains(s)) {\n-                 textLine = textLine.substring(0, textLine.indexOf(s));\n+        for (String s : JavaClassTokens) {\n+            if (textLine.contains(s)) {\n+                textLine = textLine.substring(0, textLine.indexOf(s));\n@@ -165,1 +164,1 @@\n-         textLine = textLine.substring(textLine.indexOf(\"class\")+5).trim();\n+        textLine = textLine.substring(textLine.indexOf(\"class\") + 5).trim();\n@@ -167,4 +166,4 @@\n-         int ind = textLine.indexOf('<');\n-         if(ind != -1){\n-             textLine = textLine.substring(0, ind);\n-    }\n+        int ind = textLine.indexOf('<');\n+        if (ind != -1) {\n+            textLine = textLine.substring(0, ind);\n+        }\n@@ -172,7 +171,7 @@\n-         ind = textLine.lastIndexOf('.');\n-         if( ind > 0 ) {\n-             packageName = textLine.substring(0,ind);\n-             className = textLine.substring(ind+1);\n-         } else {\n-             className = textLine;\n-             packageName = \"\";\n+        ind = textLine.lastIndexOf('.');\n+        if (ind > 0) {\n+            packageName = textLine.substring(0, ind);\n+            className = textLine.substring(ind + 1);\n+        } else {\n+            className = textLine;\n+            packageName = \"\";\n@@ -192,0 +191,8 @@\n+    \/**\n+     * Parses the method's name and signature from the Javap source.\n+     * Since the constructor in the Javap output shares the same name as the class,\n+     * the method substitutes it with &pt;init&gt; to ensure compatibility with the coverage report.\"\n+     *\n+     * @param textLine a line containing the method's name and signature\n+     * @Returns the method name concatenated with the method's signature\n+     *\/\n@@ -195,4 +202,9 @@\n-        String returnType = substringBetween(textLine, \"\\\\ \", \" \" + methodName, true);\n-\n-        String vmSig = encodeVmSignature(substringBetween(textLine, \"\\\\(\", \"\\\\)\", false), returnType);\n-\n+        String vmSig;\n+        \/\/ Checks whether it is a constructor, according to javap notation\n+        if (methodName.equals(className)) {\n+            methodName = \"<init>\";\n+            vmSig = encodeVmSignature(substringBetween(textLine, \"\\\\(\", \"\\\\)\", false), null);\n+        } else {\n+            String returnType = substringBetween(textLine, \"\\\\ \", \" \" + methodName, true);\n+            vmSig = encodeVmSignature(substringBetween(textLine, \"\\\\(\", \"\\\\)\", false), returnType);\n+        }\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/report\/javap\/JavapClass.java","additions":63,"deletions":51,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n-import com.sun.tools.javap.Main;\n-import java.io.File;\n@@ -30,3 +28,2 @@\n-import java.lang.reflect.Method;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n+import java.util.NoSuchElementException;\n+import java.util.spi.ToolProvider;\n@@ -34,11 +31,1 @@\n-\/**\n- * This class is used to run javap on class files\n- *\n- * @author Alexey Fedorchenko\n- *\/\n-public class JavapClassReader {\n-\n-    private static URLClassLoader classLoader = null;\n-    private static Method method;\n-    private static Object instance;\n-    private static File toolsJar;\n+import static java.util.spi.ToolProvider.findFirst;\n@@ -46,0 +33,1 @@\n+public class JavapClassReader {\n@@ -47,3 +35,1 @@\n-\n-        \/\/ Note: if the RepGen is being started by JDK 9 and above then\n-        \/\/ the option \"--add-exports jdk.jdeps\/com.sun.tools.javap=ALL-UNNAMED\" should be added to the JVM command-line.\n+        int rc = 0;\n@@ -51,0 +37,1 @@\n+            ToolProvider javap = findFirst(\"javap\").orElseThrow();\n@@ -52,49 +39,1 @@\n-                Main.run(new String[]{\"-c\", \"-p\", filePath}, pw);\n-            } else {\n-                Main.run(new String[]{\"-c\", \"-p\", \"-classpath\", jarPath, filePath}, pw);\n-            }\n-        } catch (NoClassDefFoundError error) {\n-\n-            if (classLoader == null) {\n-\n-                File javaHome = new File(System.getProperty(\"java.home\"));\n-\n-                if (javaHome.getName().equals(\"jre\")) {\n-                    javaHome = javaHome.getParentFile();\n-                    toolsJar = new File(new File(javaHome, \"lib\"), \"tools.jar\");\n-\n-                    if (toolsJar.exists()) {\n-\n-                        try {\n-                            classLoader = new URLClassLoader(new URL[]{toolsJar.toURI().toURL()}, ClassLoader.getSystemClassLoader());\n-                            Class classToLoad = Class.forName(\"com.sun.tools.javap.Main\", true, classLoader);\n-                            method = classToLoad.getDeclaredMethod(\"run\", String[].class, PrintWriter.class);\n-                            instance = classToLoad.getDeclaredConstructor().newInstance();\n-\n-                            String[] params;\n-\n-                            if (jarPath == null) {\n-                                params = new String[]{\"-c\", \"-p\", filePath};\n-                            } else {\n-                                params = new String[]{\"-c\", \"-p\", \"-classpath\", jarPath, filePath};\n-                            }\n-                            try {\n-                                Object result = method.invoke(instance, params, pw);\n-                            } catch (Exception ex) {\n-                                printToolsJarError();\n-                            }\n-\n-                        } catch (Exception e) {\n-                            printToolsJarError();\n-                        }\n-\n-\n-                    } else {\n-                        printToolsJarError();\n-                    }\n-\n-                } else {\n-                    System.err.println(\"cannot execute javap, perhaps jdk8\/lib\/tools.jar is missing from the classpath\");\n-                    System.err.println(\"example: java -cp jcov.jar:tools.jar com.sun.tdk.jcov.RepGen -javap path_to_classes -o path_to_javap_output path_to_result.xml\");\n-                    return;\n-                }\n+                rc = javap.run(pw, new PrintWriter(System.err), \"-c\", \"-p\", filePath);\n@@ -102,13 +41,1 @@\n-\n-                String[] params;\n-\n-                if (jarPath == null) {\n-                    params = new String[]{\"-c\", \"-p\", filePath};\n-                } else {\n-                    params = new String[]{\"-c\", \"-p\", \"-classpath\", jarPath, filePath};\n-                }\n-                try {\n-                    method.invoke(instance, params, pw);\n-                } catch (Exception ex) {\n-                    printToolsJarError();\n-                }\n+                rc = javap.run(pw, new PrintWriter(System.err), \"-c\", \"-p\", \"-classpath\", jarPath, filePath);\n@@ -116,0 +43,6 @@\n+        } catch (NoSuchElementException ex) {\n+            System.err.println(\"Cannot find the javap tool\");\n+        }\n+        if (rc != 0) {\n+            System.err.println(\"Usage: java -cp jcov.jar com.sun.tdk.jcov.RepGen -javap path_to_classes \" +\n+                    \"-o path_to_javap_output path_to_result.xml\");\n@@ -117,6 +50,0 @@\n-    }\n-\n-    private static void printToolsJarError() {\n-        System.err.println(\"cannot execute javap, perhaps jdk8\/lib\/tools.jar is missing from the classpath and from java.home\");\n-        System.err.println(\"example: java -cp jcov.jar:tools.jar com.sun.tdk.jcov.RepGen -javap path_to_classes -o path_to_javap_output path_to_result.xml\");\n-        return;\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/report\/javap\/JavapClassReader.java","additions":15,"deletions":88,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,1 +187,1 @@\n-                    methodLines = javapClass.getMethod(dataMethod.getName() + dataMethod.getVmSignature());\n+                    methodLines = javapClass.getMethod(dataMethod.getName(), dataMethod.getVmSignature());\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/report\/javap\/JavapRepGen.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}