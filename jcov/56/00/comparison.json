{"files":[{"patch":"@@ -45,0 +45,5 @@\n+    <copy todir=\"${classes}\">\n+      <fileset dir=\"${src}\">\n+        <exclude name=\"**\/*.java\"\/>\n+      <\/fileset>\n+    <\/copy>\n","filename":"plugins\/coverage_reports\/build.xml","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import static java.lang.String.format;\n+\n@@ -39,0 +41,1 @@\n+    private final FileItems.Quality quality;\n@@ -41,0 +44,4 @@\n+        this(covered, total, covered > 0 ? FileItems.Quality.GOOD : FileItems.Quality.BAD);\n+    }\n+\n+    public Coverage(int covered, int total, FileItems.Quality quality) {\n@@ -43,0 +50,5 @@\n+        this.quality = quality;\n+    }\n+\n+    public FileItems.Quality quality() {\n+        return quality;\n@@ -77,1 +89,1 @@\n-        return covered + \"\/\" + total;\n+        return format(\"%2.2f%%(%d\/%d)\", Math.ceil((double) covered\/(double)total * 100), covered,  total);\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/Coverage.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.codetools.jcov.report;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/**\n+ * A file may have a set of &ldquo;items&rdquo, which are associated with the coverage collection. Examples:\n+ * methods, fields, try blocks, field usaget, etc, etc, etc. An &ldquo;items&rdquo may be related to one or more\n+ * portions of the source code, such as method is related to ranges of lines within the code, field - to\n+ * field declaration, etc.\n+ *\/\n+public interface FileItems {\n+    List<FileItem> items(String file);\n+\n+    \/**\n+     * Display name for the kind of the item. Probably plural: &ldquo;Methods&rdquo if the items represent methods\n+     *\/\n+    String kind();\n+\n+    \/**\n+     * Meanings for the colors. This is used in the reporting.\n+     *\/\n+    Map<Quality, String> legend();\n+\n+    interface FileItem {\n+        \/**\n+         * Display name for the item.\n+         *\/\n+        String item();\n+\n+        \/**\n+         * Ranges of the source code which this item is related to. Could be null.\n+         *\/\n+        List<LineRange> ranges();\n+\n+        \/**\n+         * How bad is the item?\n+         *\/\n+        Quality quality();\n+    }\n+\n+    class FileItemImpl implements FileItem{\n+\n+        private final String item;\n+        private final List<LineRange> ranges;\n+        private final Quality quality;\n+\n+        public FileItemImpl(String item, List<LineRange> ranges, Quality quality) {\n+            this.item = item;\n+            this.ranges = ranges;\n+            this.quality = quality;\n+        }\n+\n+        @Override\n+        public String item() {\n+            return item;\n+        }\n+\n+        @Override\n+        public List<LineRange> ranges() {\n+            return ranges;\n+        }\n+\n+        @Override\n+        public Quality quality() {\n+            return quality;\n+        }\n+    }\n+    \/**\n+     * Items are grouped by the level of attention they require. Something bad deserves more attention and\n+     * likely to be red in the report.\n+     *\/\n+    enum Quality {\n+        VERY_GOOD, GOOD, SO_SO, BAD, IGNORE, NONE,\n+        LEFT, RIGHT, BOTH\n+    }\n+\n+    class ItemsCache {\n+        private final FileItems items;\n+        private final FileSet files;\n+        private final Map<String, Map<Quality, Integer>> cache = new HashMap<>();\n+\n+        public ItemsCache(FileItems items, FileSet files) {\n+            this.items = items;\n+            this.files = files;\n+        }\n+\n+        \/\/TODO will this work if the first call is with a file?\n+        public Map<Quality, Integer> count(String folder) {\n+            if (items == null) return Map.of();\n+            if (cache.containsKey(folder)) return cache.get(folder);\n+            var res = new HashMap<Quality, Integer>();\n+            items.legend().entrySet().stream().forEach(e -> res.put(e.getKey(), 0));\n+            files.files(folder).stream()\n+                    .forEach(f -> {\n+                        Map<Quality, Integer> colors;\n+                        if (cache.containsKey(f)) colors = cache.get(f);\n+                        else {\n+                            colors = new HashMap<>();\n+                            res.keySet().forEach(c ->\n+                            {\n+                                List<FileItem> items = this.items.items(f);\n+                                if (items != null)\n+                                    colors.put(c, (int) (items.stream()\n+                                        .filter(i -> i.quality() == c).count()));\n+                            });\n+                        }\n+                        colors.forEach((color, count) -> res.put(color, res.get(color) + count));\n+                        cache.put(f, colors);\n+                    });\n+            files.folders(folder).forEach(fld -> {\n+                count(fld).forEach((color, count) -> res.put(color, res.get(color) + count));\n+            });\n+            cache.put(folder, res);\n+            return res;\n+        }\n+    }\n+}\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/FileItems.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -59,1 +59,1 @@\n-                parent.isEmpty() && f.indexOf('\/') < 0 ||\n+                parent.isEmpty  () && f.indexOf('\/') < 0 ||\n@@ -61,1 +61,2 @@\n-                f.substring(parent.length() + 1).indexOf('\/') < 0).collect(toSet());\n+                f.substring(parent.length() + 1).indexOf('\/') < 0)\n+                .collect(toSet());\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/FileSet.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2024 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.codetools.jcov.report.commandline;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static java.util.stream.Collectors.joining;\n+\n+public class CommandLine {\n+    private final List<Option> options;\n+    private final List<Parameter> parameters;\n+    private final boolean checkValidity;\n+\n+    public CommandLine(List<Option> options, List<Parameter> parameters, boolean validity) {\n+        this.options = options;\n+        this.parameters = parameters;\n+        checkValidity = validity;\n+    }\n+\n+    public CommandLine(List<Option> options, List<Parameter> parameters) {\n+        this(options, parameters, true);\n+    }\n+\n+    public Parsed parse(String[] argv) {\n+        int i = 0;\n+        var opts = new HashMap<Option, String>();\n+        while (i < argv.length) {\n+            var next = argv[i];\n+            var option = options.stream().filter(o -> o.option().equals(next)).findAny();\n+            if (option.isPresent()) {\n+                opts.put(option.get(), argv[i + 1]);\n+                i+=2;\n+            } else {\n+                \/\/not an option - parameters start\n+                break;\n+            }\n+        }\n+        if (checkValidity) {\n+            for( Option o : options)\n+                if (!o.optional() && !opts.containsKey(o))\n+                    throw new IllegalArgumentException(\n+                            String.format(\"Option %s is missing in %s\",\n+                                    o.option(), Arrays.stream(argv).collect(joining(\" \"))));\n+        }\n+        var params = Arrays.asList(Arrays.copyOfRange(argv, i, argv.length));\n+        if (checkValidity && params.size() != parameters.size())\n+            throw new IllegalArgumentException(\n+                    String.format(\"Insufficient number of parameters. Expected %d, found %d:\\n %s\",\n+                            parameters.size(), params.size(), params.stream().collect(joining(\" \"))));\n+        return new Parsed() {\n+            @Override\n+            public String get(Option option) {\n+                return opts.get(option);\n+            }\n+\n+            @Override\n+            public List<String> parameters() {\n+                return params;\n+            }\n+        };\n+    }\n+\n+    public String usageLine() {\n+        return options.stream().map(o -> {\n+            String res = o.option() + \" \" + o.name();\n+            if (!o.optional())\n+                return res;\n+            else\n+                return \"[\" + res + \"]\";\n+        }).collect(joining(\" \")) + \" \" +\n+                parameters.stream().map(Parameter::name).collect(joining(\" \"));\n+\n+    }\n+\n+    public String usageList(String indent) {\n+        return options.stream().map(o -> indent + o.name() + \": \" + o.description()).collect(joining(\"\\n\")) +\n+                \"\\n\" +\n+                parameters.stream().map(p -> indent + p.name() + \": \" + p.description()).collect(joining(\"\\n\"));\n+    }\n+\n+    public interface Parsed {\n+        String get(Option option);\n+        List<String> parameters();\n+        default String getOrElse(Option title, String def) {\n+            String res = get(title);\n+            if (res != null)\n+                return res;\n+            else\n+                return def;\n+        }\n+    }\n+\n+    public static class Builder {\n+\n+        private List<Option> options = new ArrayList<>();\n+        private List<Parameter> parameters = new ArrayList<>();\n+        private boolean validity = true;\n+\n+        public Builder option(Option option) {\n+            options.add(option);\n+            return this;\n+        }\n+\n+        public Builder parameter(Parameter parameter) {\n+            parameters.add(parameter);\n+            return this;\n+        }\n+\n+        public Builder checkValidity(boolean validity) {\n+            this.validity = validity;\n+            return this;\n+        }\n+\n+        public CommandLine create() {\n+            return new CommandLine(options, parameters, validity);\n+        }\n+    }\n+}\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/commandline\/CommandLine.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2024 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.codetools.jcov.report.commandline;\n+\n+import java.util.Objects;\n+\n+public class Option {\n+    private final String option;\n+    private final String name;\n+    private final String description;\n+    private final boolean optional;\n+\n+    public Option(String option, String name, String description, boolean optional) {\n+        this.option = option;\n+        this.name = name;\n+        this.description = description;\n+        this.optional = optional;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        Option option1 = (Option) o;\n+        return Objects.equals(option, option1.option);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hashCode(option);\n+    }\n+\n+    public String option() {\n+        return option;\n+    }\n+\n+    public String name() {\n+        return name;\n+    }\n+\n+    public String description() {\n+        return description;\n+    }\n+\n+    public boolean optional() {\n+        return optional;\n+    }\n+\n+    public static class Builder {\n+        private String option;\n+        private String name;\n+        private String description;\n+        private boolean optional = false;\n+\n+        public Builder option(String option) {\n+            this.option = option;\n+            return this;\n+        }\n+\n+        public Builder name(String name) {\n+            this.name = name;\n+            return this;\n+        }\n+\n+        public Builder description(String description) {\n+            this.description = description;\n+            return this;\n+        }\n+\n+        public Builder optional(boolean optional) {\n+            this.optional = optional;\n+            return this;\n+        }\n+\n+        public Option create() {\n+            return new Option(option, name, description, optional);\n+        }\n+    }\n+}\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/commandline\/Option.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2024 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.codetools.jcov.report.commandline;\n+\n+public class Parameter {\n+    private final String name;\n+    private final String description;\n+\n+    public Parameter(String name, String description) {\n+        this.name = name;\n+        this.description = description;\n+    }\n+\n+    public String name() {\n+        return name;\n+    }\n+\n+    public String description() {\n+        return description;\n+    }\n+}\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/commandline\/Parameter.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2023, 2024 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/filter\/SourceFileFilter.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.codetools.jcov.report.filter;\n+\n+import openjdk.codetools.jcov.report.LineRange;\n+import openjdk.codetools.jcov.report.source.SourceHierarchy;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+\/**\n+ * Only include code which has not changed from last time.\n+ *\/\n+public class UnchangedCodeFilter implements SourceFilter {\n+    private final SourceHierarchy oldSource, newSource;\n+    private final Function<String, List<NamedLineRange>> oldFilter, newFilter;\n+\n+    public UnchangedCodeFilter(SourceHierarchy oldSource, Function<String, List<NamedLineRange>> oldFilter,\n+                               SourceHierarchy newSource, Function<String, List<NamedLineRange>> newFilter) {\n+        this.oldSource = oldSource;\n+        this.newSource = newSource;\n+        this.oldFilter = oldFilter;\n+        this.newFilter = newFilter;\n+    }\n+\n+    @Override\n+    public List<LineRange> ranges(String file) {\n+        try {\n+            var res = new ArrayList<LineRange>();\n+            var oldFileSource = oldSource.readFile(file);\n+            var newFileSource = newSource.readFile(file);\n+            var oldRanges = oldFilter.apply(file);\n+            for(var range : newFilter.apply(file)) {\n+                var oldRange = oldRanges.stream()\n+                        .filter(r -> r.name.equals(range.name))\n+                        .findAny();\n+                if (oldRange.isPresent()) {\n+                    int lastMatchingLine = -1;\n+                    for (int line = range.first(); line <= range.last(); line++) {\n+                        if (!oldFileSource.get(oldRange.get().first() + (line - range.first()) - 1)\n+                                .equals(newFileSource.get(line - 1))) break;\n+                        lastMatchingLine = line;\n+                    }\n+                    if(lastMatchingLine >= 0) res.add(new LineRange(range.first(), lastMatchingLine));\n+                }\n+            }\n+            return res;\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static class NamedLineRange extends LineRange {\n+        private final String name;\n+        public NamedLineRange(String name, int first, int last) {\n+            super(first, last);\n+            this.name = name;\n+        }\n+\n+        public String name() {\n+            return name;\n+        }\n+    }\n+}\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/filter\/UnchangedCodeFilter.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.codetools.jcov.report.jcov;\n+\n+import com.sun.tdk.jcov.data.FileFormatException;\n+import com.sun.tdk.jcov.instrument.DataMethod;\n+import com.sun.tdk.jcov.instrument.DataRoot;\n+import com.sun.tdk.jcov.report.LineCoverage;\n+import com.sun.tdk.jcov.report.MethodCoverage;\n+import openjdk.codetools.jcov.report.Coverage;\n+import openjdk.codetools.jcov.report.CoveredLineRange;\n+import openjdk.codetools.jcov.report.FileCoverage;\n+import openjdk.codetools.jcov.report.FileItems;\n+import openjdk.codetools.jcov.report.source.SourceHierarchy;\n+import openjdk.codetools.jcov.report.view.jdk.JDKDiffCoverageReport;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static openjdk.codetools.jcov.report.jcov.JCovMethodCoverageComparison.DEFAULT_COLORING;\n+\n+public class JCovCoverageComparison implements FileCoverage {\n+    private final Map<String, List<CoveredLineRange>> cache = new HashMap<>();\n+    private final SourceHierarchy newSource;\n+\n+    public JCovCoverageComparison(DataRoot oldCoverage, SourceHierarchy oldSource,\n+                                  DataRoot newCoverage, SourceHierarchy newSource) throws IOException {\n+        this(oldCoverage, oldSource, newCoverage, newSource, DEFAULT_COLORING);\n+    }\n+    public JCovCoverageComparison(DataRoot oldCoverage, SourceHierarchy oldSource,\n+                                  DataRoot newCoverage, SourceHierarchy newSource,\n+                                  BiFunction<Boolean, Boolean, FileItems.Quality> coloring) throws IOException {\n+        this.newSource = newSource;\n+        Set<String> oldClasses =  oldCoverage.getClasses().stream().map(dc -> dc.getFullname())\n+                .collect(Collectors.toSet());\n+        Map<String, DataMethod> oldMethodsCache = oldCoverage.getClasses().stream().flatMap(c -> c.getMethods().stream())\n+                .collect(toMap(m -> methodID(m), m -> m));\n+        for (var newClass : newCoverage.getClasses()) {\n+            boolean isOld = oldClasses.contains(newClass.getFullname());\n+            var newClassName = newClass.getFullname();\n+            newClassName = newClassName.contains(\"$\") ? newClassName.substring(0, newClassName.indexOf(\"$\")) : newClassName;\n+            var newFile =newSource.toFile( newClassName + \".java\");\n+            if(newFile != null) { \/\/null would happen if no source for a class found. Nothing to do.\n+                var newFileSource = newSource.readFile(newFile);\n+                List<String> oldFileSource;\n+                if(isOld) {\n+                    oldFileSource = oldSource != null ? oldSource.readFile(newFile) : newFileSource;\n+                    if (oldFileSource == null) {\n+                        System.err.println(\"Warning: no reference source for \" + newClass.getFullname());\n+                    }\n+                } else oldFileSource = null;\n+                for (var newMethod : newClass.getMethods()) {\n+                    \/\/no code for synthetic methods - no way to compare the code\n+                    \/\/TODO are there non-synthetic generated methods with no code? enum methods?\n+                    if (!newMethod.getModifiers().isSynthetic()) {\n+                        String className = newClass.getFullname();\n+                        String methodName = newMethod.getName() + newMethod.getVmSignature();\n+                        if (className.contains(\"$\")) {\n+                            methodName = className.substring(className.indexOf('$') + 1) + \"$\" + methodName;\n+                            className = className.substring(0, className.indexOf('$'));\n+                        }\n+                        var ranges = cache.get(className);\n+                        if (ranges == null) {\n+                            ranges = new ArrayList<>();\n+                            cache.put(className, ranges);\n+                        }\n+                        String id = className + \"#\" + methodName;\n+                        var isOldMethod = oldSource == null || oldMethodsCache.containsKey(id);\n+                        DataMethod oldMethod = isOldMethod ? oldMethodsCache.get(id) : null;\n+                        var newLineCoverage = new MethodCoverage(newMethod, true).getLineCoverage();\n+                        var oldLineCoverage = isOld && isOldMethod ?\n+                                new MethodCoverage(oldMethod, true).getLineCoverage() : null;\n+                        if(newFileSource.size() < newLineCoverage.lastLine() - 1) {\n+                            System.err.println(\"Wrong source for method \" + className + \".\" + methodName);\n+                            System.err.println(\"    \" + newLineCoverage.lastLine() + \" lines expected but only \" +\n+                                    newFileSource.size() + \" in file: \" + newFile);\n+                        } else {\n+                            var newMethodSource = methodSource(newFileSource, newLineCoverage);\n+                            int[] repeatedLines;\n+                            if (oldSource == null) {\n+                                repeatedLines = IntStream.range(0, newMethodSource.size()).toArray();\n+                            } else if (oldFileSource != null) {\n+                                var oldMethodSource = isOld && isOldMethod ? methodSource(oldFileSource,\n+                                        new MethodCoverage(oldMethod, true).getLineCoverage()) : null;\n+                                repeatedLines = repeatedLines(oldMethodSource, newMethodSource, newLineCoverage);\n+                            } else repeatedLines = new int[0];\n+                            for (int ln : repeatedLines)\n+                                if (newLineCoverage.isCode(ln + newLineCoverage.firstLine())) {\n+                                    FileItems.Quality rangeCoverage;\n+                                    if (isOld && isOldMethod) {\n+                                        var oldLC = oldLineCoverage.isLineCovered(oldLineCoverage.firstLine() + ln);\n+                                        var newLC = newLineCoverage.isLineCovered(newLineCoverage.firstLine() + ln);\n+                                        rangeCoverage = coloring.apply(oldLC, newLC);\n+                                    } else rangeCoverage = FileItems.Quality.NONE;\n+                                    ranges.add(new CoveredLineRange(\n+                                            (int) (ln + newLineCoverage.firstLine()),\n+                                            (int) (ln + newLineCoverage.firstLine()),\n+                                            new Coverage(newLineCoverage.getCovered() > 0 ? 1 : 0, 1, rangeCoverage)));\n+                                }\n+                        }\n+                    }\n+                }\n+            }\n+\n+        }\n+    }\n+\n+    \/\/TODO a better diff algorithm could be used, right now only returning a top portion\n+    \/\/of the code which is unchanged\n+    \/\/if so also need to return a map between new and old lines\n+    private int[] repeatedLines(List<String> oldSource, List<String> newSource, LineCoverage lineCoverage) {\n+        if(oldSource == null) return new int[0];\n+        int length = 0;\n+        int[] res = new int[newSource.size()];\n+        for (int i = 0; i < newSource.size(); i++) {\n+            if(lineCoverage.isCode(lineCoverage.firstLine() + i))\n+                if (oldSource.size() > i && newSource.get(i).equals(oldSource.get(i))) {\n+                    res[length] = i;\n+                    length++;\n+                } else break;\n+        }\n+        return Arrays.copyOf(res, length);\n+    }\n+\n+    private List<String> methodSource(List<String> classSource, LineCoverage lineCoverage) {\n+        return classSource.subList((int)lineCoverage.firstLine() - 1, (int)lineCoverage.lastLine());\n+    }\n+\n+    private static String methodID(DataMethod m) {\n+        String className = m.getParent().getFullname();\n+        String methodName = m.getName() + m.getVmSignature();\n+        if (className.contains(\"$\")) {\n+            methodName = className.substring(className.indexOf('$') + 1) + \"$\" + methodName;\n+            className = className.substring(0, className.indexOf('$'));\n+        }\n+        return className + \"#\" + methodName;\n+    }\n+\n+    @Override\n+    public List<CoveredLineRange> ranges(String file) {\n+        return cache.get(newSource.toClassFile(file));\n+    }\n+\n+    public static void main(String[] args) throws FileFormatException, IOException {\n+        new JCovCoverageComparison(\n+                DataRoot.read(args[0]), JDKDiffCoverageReport.jdkSource(List.of(Path.of(args[1]))),\n+                DataRoot.read(args[2]), JDKDiffCoverageReport.jdkSource(List.of(Path.of(args[3]))));\n+    }\n+}\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/jcov\/JCovCoverageComparison.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -31,1 +31,0 @@\n-import com.sun.tdk.jcov.instrument.LocationRef;\n@@ -36,0 +35,1 @@\n+import openjdk.codetools.jcov.report.source.SourceHierarchy;\n@@ -52,1 +52,1 @@\n-    private final Map<String, List<CoveredLineRange>> cache = new HashMap<>();\n+    private final SourceHierarchy source;\n@@ -54,1 +54,1 @@\n-    public JCovLineCoverage(DataRoot root) {\n+    public JCovLineCoverage(DataRoot root, SourceHierarchy source) {\n@@ -56,0 +56,1 @@\n+        this.source = source;\n@@ -61,1 +62,1 @@\n-        String className = file.substring(0, file.length() - \".java\".length());\n+        String className = source.toClassFile(file);\/\/file.substring(0, file.length() - \".java\".length());\n@@ -68,1 +69,2 @@\n-    private List<CoveredLineRange> ranges(DataClass cls) {\n+\n+    private static List<CoveredLineRange> ranges(DataClass cls) {\n@@ -71,0 +73,1 @@\n+            \/\/TODO there is a copy-paste in other classes\n@@ -72,1 +75,0 @@\n-\/\/            boolean methodCovered = false;\n@@ -77,1 +79,0 @@\n-\/\/                    methodCovered |= lc.isLineCovered(i);\n@@ -145,0 +146,1 @@\n+\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/jcov\/JCovLineCoverage.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.codetools.jcov.report.jcov;\n+\n+import com.sun.tdk.jcov.instrument.DataMethod;\n+import com.sun.tdk.jcov.instrument.DataRoot;\n+import com.sun.tdk.jcov.report.MethodCoverage;\n+import openjdk.codetools.jcov.report.FileItems;\n+import openjdk.codetools.jcov.report.LineRange;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static java.util.stream.Collectors.toMap;\n+\n+public class JCovMethodCoverageComparison implements FileItems {\n+    private final Map<String, List<FileItem>> items = new HashMap<>();\n+    static final BiFunction<Boolean, Boolean, Quality> DEFAULT_COLORING = (left, right) -> {\n+        if (right) return Quality.GOOD;\n+        else if (left) return Quality.BAD;\n+        else return Quality.SO_SO;\n+    };\n+    static final Map<Quality, String> DEFAULT_LEFEND = Map.of(\n+            Quality.GOOD, \"Covered\",\n+            Quality.BAD, \"Lost\",\n+            Quality.SO_SO, \"Uncovered\",\n+            Quality.IGNORE, \"New\"\n+    );\n+\n+    private final Map<Quality, String> legend;\n+\n+    public JCovMethodCoverageComparison(DataRoot oldCoverage, DataRoot newCoverage,\n+                                        Function<String, String> fileResolver) {\n+        this(oldCoverage, newCoverage, fileResolver, DEFAULT_LEFEND, DEFAULT_COLORING);\n+    }\n+    public JCovMethodCoverageComparison(DataRoot oldCoverage, DataRoot newCoverage,\n+                                        Function<String, String> fileResolver,\n+                                        Map<Quality, String> legend,\n+                                        BiFunction<Boolean, Boolean, Quality> coloring) {\n+        this.legend = legend;\n+        var oldCache = oldCoverage.getClasses().stream().flatMap(c -> c.getMethods().stream())\n+                .collect(toMap(m -> methodID(m), m -> m));\n+        for (var newClass : newCoverage.getClasses()) {\n+            for (var newMethod : newClass.getMethods()) {\n+                String className = newClass.getFullname();\n+                String methodName = newMethod.getName() + newMethod.getVmSignature();\n+                if (newClass.getFullname().contains(\"$\")) {\n+                    methodName = className.substring(className.indexOf('$') + 1) + \"$\" + methodName;\n+                    className = className.substring(0, className.indexOf('$'));\n+                }\n+                String id = className + \"#\" + methodName;\n+                FileItem toAdd;\n+                if (oldCache.containsKey(id)) {\n+                    var oldMethod = oldCache.get(id);\n+                    Quality quality = coloring.apply(oldMethod.wasHit(), newMethod.wasHit());\n+                    toAdd = new MethodItem(newMethod, methodName, quality);\n+                } else {\n+                    toAdd = new MethodItem(newMethod, methodName, Quality.IGNORE);\n+                }\n+                List<FileItem> classItems;\n+                String fileName = fileResolver.apply(className + \".java\");\n+                if (items.containsKey(fileName)) classItems = items.get(fileName);\n+                else {\n+                    classItems = new ArrayList<>();\n+                    items.put(fileName, classItems);\n+                }\n+                classItems.add(toAdd);\n+            }\n+        }\n+    }\n+\n+    private static String methodID(DataMethod m) {\n+        String className = m.getParent().getFullname();\n+        String methodName = m.getName() + m.getVmSignature();\n+        if (className.contains(\"$\")) {\n+            methodName = className.substring(className.indexOf('$') + 1) + \"$\" + methodName;\n+            className = className.substring(0, className.indexOf('$'));\n+        }\n+        return className + \"#\" + methodName;\n+    }\n+\n+    private static List<LineRange> methodRanges(DataMethod m) {\n+        Map<Integer, Boolean> result = new HashMap<>();\n+        var lc = new MethodCoverage(m, true).getLineCoverage();\n+        for (int i = (int) lc.firstLine(); i <= lc.lastLine(); i++) {\n+            if (lc.isCode(i)) {\n+                if (result.get(i) == null || !result.get(i).booleanValue())\n+                    result.put(i, lc.isLineCovered(i));\n+            }\n+        }\n+        return result.entrySet().stream()\n+                .sorted(Comparator.comparingInt(Map.Entry::getKey))\n+                .map(le -> new LineRange(le.getKey(), le.getKey()))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private static class MethodItem implements FileItem {\n+        private final String id;\n+        private final Quality quality;\n+        private final List<LineRange> ranges;\n+\n+        private MethodItem(DataMethod method, String displayName, Quality quality) {\n+            this.id = displayName;\n+            this.quality = quality;\n+            var lt = method.getLineTable();\n+            var mc = new MethodCoverage(method, true);\n+            ranges = methodRanges(method);\n+        }\n+\n+        @Override\n+        public String item() {\n+            return id;\n+        }\n+\n+        @Override\n+        public List<LineRange> ranges() {\n+            return ranges;\n+        }\n+\n+        @Override\n+        public Quality quality() {\n+            return quality;\n+        }\n+    }\n+\n+    @Override\n+    public List<FileItem> items(String file) {\n+        return items.get(file);\n+    }\n+\n+    @Override\n+    public String kind() {\n+        return \"Methods\";\n+    }\n+\n+    @Override\n+    public Map<Quality, String> legend() {\n+        return legend;\n+    }\n+}\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/jcov\/JCovMethodCoverageComparison.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n@@ -4,0 +28,1 @@\n+import java.nio.file.Path;\n@@ -6,3 +31,0 @@\n-\/**\n- * An abstraction for source hierarchy.\n- *\/\n@@ -10,0 +32,1 @@\n+\n@@ -21,1 +44,20 @@\n-    String toClass(String file);\n+    String toClassFile(String file);\n+\n+    \/**\n+     * Finds a file by a class file name. There could be multiple source with the same class file names,\n+     * the implemenation is responsible to decide which one is to be selected.\n+     * Example: <code>my\/company\/product\/Main.hava<\/code> to <code>src\/main\/java\/my\/company\/product\/Main.hava<\/code>.\n+     * @param classFileName - a class file name relative to the root of a class hierarchy.\n+     *\/\n+    String toFile(String classFileName);\n+\n+    String JAVA_EXTENSION = \".java\";\n+\n+    static String toClassName(String classFileName) {\n+        return classFileName.substring(0, classFileName.lastIndexOf(JAVA_EXTENSION));\n+    }\n+\n+    static String toClassFileName(String className) {\n+        return className + JAVA_EXTENSION;\n+    }\n+\n@@ -23,0 +65,2 @@\n+\n+\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/source\/SourceHierarchy.java","additions":48,"deletions":4,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.codetools.jcov.report.source;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class SourceHierarchyUnion implements SourceHierarchy {\n+    private final List<SourceHierarchy> subHierarchies;\n+    private final Map<SourceHierarchy, Path> locations;\n+\n+    public SourceHierarchyUnion(List<SourceHierarchy> paths, Map<SourceHierarchy, Path> locations) {\n+        subHierarchies = paths;\n+        this.locations = locations;\n+    }\n+\n+    @Override\n+    public List<String> readFile(String file) throws IOException {\n+        for (var sp : subHierarchies) {\n+            var path = Path.of(file);\n+            if (locations != null && locations.containsKey(sp))\n+                path = locations.get(sp).relativize(path);\n+            List<String> result = sp.readFile(path.toString());\n+            if (result != null) return result;\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public String toClassFile(String file) {\n+        for (var sp : subHierarchies) {\n+            var path = Path.of(file);\n+            if (locations != null && locations.containsKey(sp))\n+                path = locations.get(sp).relativize(path);\n+            var res = sp.toClassFile(path.toString());\n+            if (res != null) return res;\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public String toFile(String classFileName) {\n+        for (var sp : subHierarchies) {\n+            var res = sp.toFile(classFileName);\n+            if (res != null) {\n+                if (locations != null && locations.containsKey(sp))\n+                    res = locations.get(sp).resolve(res).toString();\n+                return res;\n+            }\n+        }\n+        return null;\n+    }\n+}\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/source\/SourceHierarchyUnion.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+    private final List<Path> repositories;\n@@ -42,2 +43,2 @@\n-    public SourcePath(Path srcRoot, Path classRoot) {\n-        this(srcRoot, List.of(classRoot));\n+    public SourcePath(Path repositorY, Path root) {\n+        this(repositorY, List.of(root));\n@@ -49,2 +50,2 @@\n-    public SourcePath(Path srcRoot, List<Path> classRoots) {\n-        this(Map.of(srcRoot, classRoots));\n+    public SourcePath(Path repository, List<Path> roots) {\n+        this(List.of(repository), Map.of(repository, roots));\n@@ -55,0 +56,1 @@\n+     * @param repositories List of source\n@@ -56,1 +58,1 @@\n-    public SourcePath(Map<Path, List<Path>> roots) {\n+    public SourcePath(List<Path> repositories, Map<Path, List<Path>> roots) {\n@@ -58,0 +60,16 @@\n+        this.repositories = repositories;\n+    }\n+\n+    \/**\n+     * Maps class-root-relative path to repository-root-relative.\n+     * @param classFileName\n+     * @return\n+     *\/\n+    @Override\n+    public String toFile(String classFileName) {\n+        for (var source : repositories)\n+            for (var root : roots.get(source)) {\n+                var file = root.resolve(classFileName);\n+                if (Files.exists(file)) return source.relativize(file).toString();\n+            }\n+        return null;\n@@ -67,2 +85,2 @@\n-        for (var root : roots.keySet()) {\n-            res = resolveFile(root, file);\n+        for (var source : repositories) {\n+            res = source.resolve(file);\n@@ -76,3 +94,3 @@\n-        for (var sourceRoot : roots.keySet()) {\n-            for (var classRoot : roots.get(sourceRoot)) {\n-                res = resolveFile(classRoot, file);\n+        for (var repository : repositories) {\n+            for (var root : roots.get(repository)) {\n+                res = resolveFile(root, file);\n@@ -86,7 +104,12 @@\n-    public String toClass(String file) {\n-        for (var sourceRoot : roots.keySet()) {\n-            var path = sourceRoot.resolve(file);\n-            if (Files.exists(path))  {\n-                for (var classRoot : roots.get(sourceRoot))\n-                    if (path.startsWith(classRoot))\n-                        return classRoot.relativize(path).toString();\n+    public String toClassFile(String file) {\n+        for (var sourceHierarchy : repositories) {\n+            var path = sourceHierarchy.resolve(file);\n+            if (Files.exists(path)) {\n+                if (file.endsWith(\".java\")) {\n+                    for(var sourceRoot : roots.get(sourceHierarchy)) {\n+                        if (path.startsWith(sourceRoot)) {\n+                            var relPath = sourceRoot.relativize(path).toString();\n+                            return relPath.substring(0, relPath.length() - \".java\".length());\n+                        }\n+                    }\n+                } else return file;\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/source\/SourcePath.java","additions":40,"deletions":17,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+    private final Collection<String> files;\n@@ -47,1 +48,2 @@\n-    public CoverageHierarchy(Collection<String> files, SourceHierarchy source, FileCoverage coverage, SourceFilter filter) {\n+    public CoverageHierarchy(Collection<String> files, SourceHierarchy source, FileCoverage coverage,\n+                             SourceFilter filter) {\n@@ -62,0 +64,1 @@\n+        this.files = files;\n@@ -65,0 +68,1 @@\n+        if(!files.contains(file)) return Map.of();\n@@ -67,1 +71,1 @@\n-        String className = source.toClass(file);\n+        String className = source.toClassFile(file);\n@@ -69,10 +73,21 @@\n-        var coverage = this.coverage.ranges(className);\n-        var coverageIt = coverage.iterator();\n-        CoveredLineRange lastCoverageRange = null;\n-        var fileCoverage = new HashMap<Integer, CoveredLineRange>();\n-        var used = new HashSet<CoveredLineRange>();\n-        for (var range : filter.ranges(file)) {\n-            for (int line = range.first(); line <= range.last() ; line++) {\n-                if (lastCoverageRange == null || lastCoverageRange.last() < line) {\n-                    while (coverageIt.hasNext() && (lastCoverageRange == null || lastCoverageRange.last() < line))\n-                        lastCoverageRange = coverageIt.next();\n+        var coverage = this.coverage.ranges(file);\n+        if(coverage == null) {\n+            System.err.println(\"No coverage for \" + className);\n+            return Map.of();\n+        } else {\n+            var coverageIt = coverage.iterator();\n+            CoveredLineRange lastCoverageRange = null;\n+            var fileCoverage = new HashMap<Integer, CoveredLineRange>();\n+            var used = new HashSet<CoveredLineRange>();\n+            if (filter != null)\n+                for (var range : filter.ranges(file)) {\n+                    for (int line = range.first(); line <= range.last(); line++) {\n+                        if (lastCoverageRange == null || lastCoverageRange.last() < line) {\n+                            while (coverageIt.hasNext() && (lastCoverageRange == null || lastCoverageRange.last() < line))\n+                                lastCoverageRange = coverageIt.next();\n+                        }\n+                        if (lastCoverageRange != null && lastCoverageRange.last() >= line && lastCoverageRange.first() <= line) {\n+                            fileCoverage.put(line, lastCoverageRange);\n+                            used.add(lastCoverageRange);\n+                        }\n+                    }\n@@ -80,3 +95,6 @@\n-                if (lastCoverageRange != null && lastCoverageRange.last() >= line && lastCoverageRange.first() <= line) {\n-                    fileCoverage.put(line, lastCoverageRange);\n-                    used.add(lastCoverageRange);\n+            else\n+                while (coverageIt.hasNext()) {\n+                    var nextCov = coverageIt.next();\n+                    for (int line = nextCov.first(); line <= nextCov.last(); line++)\n+                        fileCoverage.put(line, nextCov);\n+                    used.add(nextCov);\n@@ -84,1 +102,3 @@\n-            }\n+            data.put(file, Coverage.sum(used.stream().map(CoveredLineRange::coverage).collect(Collectors.toList())));\n+            lineCoverage.put(file, fileCoverage);\n+            return fileCoverage;\n@@ -86,3 +106,0 @@\n-        data.put(file, Coverage.sum(used.stream().map(CoveredLineRange::coverage).collect(Collectors.toList())));\n-        lineCoverage.put(file, fileCoverage);\n-        return fileCoverage;\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/view\/CoverageHierarchy.java","additions":36,"deletions":19,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.codetools.jcov.report.view;\n+\n+import openjdk.codetools.jcov.report.Coverage;\n+import openjdk.codetools.jcov.report.FileItems;\n+import openjdk.codetools.jcov.report.FileSet;\n+import openjdk.codetools.jcov.report.LineRange;\n+import openjdk.codetools.jcov.report.filter.SourceFilter;\n+import openjdk.codetools.jcov.report.source.SourceHierarchy;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static java.util.stream.Collectors.toMap;\n+\n+\/**\n+ * This support class allows to create reports which only <b>include<\/b> code which is selected by a filter.\n+ * The implementation uses visitor pattern twice: once for creating a table of content and then\n+ * for the body of the report.\n+ * @see #report(FilteredReport.FileOut, String)\n+ * @see FileOut\n+ *\/\n+public class FilteredReport {\n+    protected final FileSet files;\n+    protected final FileItems items;\n+    protected final CoverageHierarchy coverage;\n+    protected final SourceHierarchy source;\n+    protected final SourceFilter include;\n+    private final FileItems.ItemsCache cache;\n+\n+    public FilteredReport(SourceHierarchy source, FileSet files, FileItems items,\n+                          CoverageHierarchy coverage, SourceFilter include) {\n+        this.files = files;\n+        this.items = items;\n+        this.coverage = coverage;\n+        this.source = source;\n+        this.include = include;\n+        cache = new FileItems.ItemsCache(items, files);\n+    }\n+\n+    protected FileItems items() {\n+        return items;\n+    }\n+\n+    protected FileItems.ItemsCache itemsCache() {\n+        return cache;\n+    }\n+\n+    public FileSet files() {\n+        return files;\n+    }\n+\n+    public void report(FileOut out) throws Exception {\n+        report(out, \"\");\n+    }\n+\n+    \/\/TODO this code should be aware on what root the file is\n+    protected void report(FileOut out, String s) throws Exception {\n+        Coverage cov = coverage.get(s);\n+        if (cov != null) {\n+            List<String> subFolders = files.folders(s).stream().sorted().collect(Collectors.toList());\n+            List<String> files = this.files.files(s).stream().sorted().collect(Collectors.toList());\n+            out.startFolder(s);\n+            for (var f : subFolders) {\n+                report(out, f);\n+            }\n+            for (var file : files) {\n+                var fileCov = coverage.getLineRanges(file);\n+                if (fileCov != null) {\n+                    out.startFile(file);\n+                    if (this.items != null) {\n+                        List<FileItems.FileItem> itemss = this.items.items(file);\n+                        if(itemss != null) {\n+                            itemss = itemss.stream()\n+                                    .sorted((o, a) -> o.item().compareTo(a.item())).collect(Collectors.toList());\n+                            if (itemss != null && !itemss.isEmpty()) {\n+                                out.startItems();\n+                                for (var fi : itemss) out.printItem(fi);\n+                                out.endItems();\n+                            }\n+                        }\n+                    }\n+                    var source = this.source.readFile(file);\n+                    List<LineRange> ranges = include != null ?\n+                            include.ranges(file) : List.of(new LineRange(1, source.size() + 1));\n+                    for (var range : ranges) {\n+                        out.startLineRange(range);\n+                        for (int line = range.first() - 1; line < range.last() && line < source.size(); line++) {\n+                            \/\/TODO a separate visitor with no highlight?\n+                            out.printSourceLine(line, source.get(line),\n+                                    fileCov.containsKey(line + 1) ? fileCov.get(line + 1).coverage() : null,\n+                                    findItem(file, line + 1));\n+                        }\n+                        out.endLineRange(range);\n+                    }\n+                    out.endFile(s);\n+                }\n+            }\n+            out.endFolder(s);\n+        }\n+    }\n+\n+    protected List<FileItems.FileItem> findItem(String file, int line) {\n+        if (items == null) return null;\n+        var fileItems = items.items(file);\n+        if (fileItems == null) return null;\n+        return fileItems.stream().filter(i -> {\n+            List<LineRange> ranges = i.ranges();\n+            return ranges != null && ranges.stream().anyMatch(r -> r.compare(line) == 0);\n+        }).collect(Collectors.toList());\n+    }\n+\n+    protected CoverageHierarchy coverage() {\n+        return coverage;\n+    }\n+\n+    protected interface FileOut {\n+\n+        void startFolder(String s) throws Exception;\n+\n+        void startFile(String s) throws Exception;\n+\n+        void startItems() throws Exception;\n+\n+        void printItem(FileItems.FileItem fi) throws Exception;\n+\n+        void endItems() throws Exception;\n+\n+        void startLineRange(LineRange range) throws Exception;\n+\n+        void printSourceLine(int line, String s, Coverage coverage,\n+                             List<FileItems.FileItem> items)\n+                throws Exception;\n+\n+        void endLineRange(LineRange range) throws Exception;\n+\n+        void endFile(String s) throws Exception;\n+\n+        void endFolder(String s);\n+\n+    }\n+\n+    \/**\n+     * This class allows to <b>highlight<\/b> some portion of the included source code, leaving the\n+     * non-highlighted code in the report for context.\n+     *\/\n+    public interface Highlighter {\n+        boolean isHighlighted(String file, int line);\n+    }\n+\n+    public static class Builder {\n+        private SourceHierarchy source;\n+        private FileSet files;\n+        private FileItems items;\n+        private CoverageHierarchy coverage;\n+        private SourceFilter include;\n+\n+        public Builder setItems(FileItems items) {\n+            this.items = items;\n+            return this;\n+        }\n+\n+        public Builder setSource(SourceHierarchy source) {\n+            this.source = source;\n+            return this;\n+        }\n+\n+        public Builder setFiles(FileSet files) {\n+            this.files = files;\n+            return this;\n+        }\n+\n+        public Builder setCoverage(CoverageHierarchy coverage) {\n+            this.coverage = coverage;\n+            return this;\n+        }\n+\n+        public Builder setInclude(SourceFilter include) {\n+            this.include = include;\n+            return this;\n+        }\n+\n+        public FilteredReport report() {\n+            return new FilteredReport(source, files, items, coverage, include);\n+        }\n+    }\n+\n+    public static class FilterHighlighter implements Highlighter {\n+        private final SourceFilter highlight;\n+        private Iterator<LineRange> lastFileRanges;\n+        private LineRange lastRange = null;\n+        private String lastFile;\n+        private final SourceHierarchy source;\n+\n+        public FilterHighlighter(SourceHierarchy source, SourceFilter highlight) {\n+            this.source = source;\n+            this.highlight = highlight;\n+        }\n+\n+        public boolean isHighlighted(String file, int line) {\n+            if (lastFile == null || !lastFile.equals(file)) {\n+                lastFile = file;\n+                lastFileRanges = highlight.ranges(file).iterator();\n+            }\n+            if (lastRange == null)\n+                if (lastFileRanges.hasNext()) lastRange = lastFileRanges.next();\n+                else return false;\n+            while (lastRange.compare(line) > 0 && lastFileRanges.hasNext()) lastRange = lastFileRanges.next();\n+            return lastRange.compare(line) == 0;\n+        }\n+    }\n+}\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/view\/FilteredReport.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package openjdk.codetools.jcov.report.view;\n-\n-import com.sun.tdk.jcov.instrument.DataRoot;\n-import openjdk.codetools.jcov.report.FileSet;\n-import openjdk.codetools.jcov.report.filter.GitDiffFilter;\n-import openjdk.codetools.jcov.report.jcov.JCovLineCoverage;\n-import openjdk.codetools.jcov.report.source.ContextFilter;\n-import openjdk.codetools.jcov.report.source.SourcePath;\n-\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-\/**\n- * This is a utility class to generate report for openjdk.\n- *\/\n-public class JDKReport {\n-    public static void main(String[] args) throws Exception {\n-        try {\n-            var coverage = new JCovLineCoverage(DataRoot.read(args[0]));\n-            var source = jdkSource(List.of(Path.of(args[1])));\n-            var diff = GitDiffFilter.parseDiff(Path.of(args[2])\/*, source.roots(List.of(Path.of(args[1])))*\/);\n-            String reportFile = args[3];\n-            boolean isHTML = reportFile.endsWith(\"html\");\n-            String title = args.length >= 5 ? args[4] : \"\";\n-            String header = args.length >= 6 ? args[5] : \"\";\n-            if (isHTML)\n-                new SingleHTMLReport(source, new FileSet(diff.files()), coverage,\n-                        title, header,\n-                        diff, new ContextFilter(diff, 10))\n-                        .report(Path.of(reportFile));\n-            else\n-                new TextReport(source, new FileSet(diff.files()), coverage, header, diff)\n-                        .report(Path.of(reportFile));\n-        } catch (Throwable e) {\n-            System.out.println(\"Usage: java ... openjdk.codetools.jcov.report.view.JDKReport \\\\\");\n-            System.out.println(\"    <JCov coderage file produced for the tip of the repository> \\\\\");\n-            System.out.println(\"    <JDK source hierarchy> \\\\\");\n-            System.out.println(\"    <git diff file from the tip to a revision in the past produced with -U0 option> \\\\\");\n-            System.out.println(\"    <output file> \\\\\");\n-            System.out.println(\"    <report title> <report header>\");\n-            throw e;\n-        }\n-    }\n-\n-    private static SourcePath jdkSource(List<Path> repos) {\n-        \/\/TODO add platform specific - one platform or many?\n-        \/\/TODO - what about closed?\n-        return new SourcePath(repos.stream().collect(Collectors.toMap(\n-                repo -> repo,\n-                repo -> {\n-                    try {\n-                        return Files.list(repo.resolve(\"src\")).map(module -> module.resolve(\"share\/classes\")).\n-                                filter(Files::exists).collect(Collectors.toList());\n-                    } catch (IOException e) {\n-                        throw new UncheckedIOException(e);\n-                    }\n-                })));\n-    }\n-}\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/view\/JDKReport.java","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -0,0 +1,70 @@\n+<!--\n+ Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+ This code is free software; you can redistribute it and\/or modify it\n+ under the terms of the GNU General Public License version 2 only, as\n+ published by the Free Software Foundation.  Oracle designates this\n+ particular file as subject to the \"Classpath\" exception as provided\n+ by Oracle in the LICENSE file that accompanied this code.\n+\n+ This code is distributed in the hope that it will be useful, but WITHOUT\n+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ version 2 for more details (a copy is included in the LICENSE file that\n+ accompanied this code).\n+\n+ You should have received a copy of the GNU General Public License version\n+ 2 along with this work; if not, write to the Free Software Foundation,\n+ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ or visit www.oracle.com if you need additional information or have any\n+ questions.\n+-->\n+<html>\n+<head>\n+    <link rel=\"stylesheet\" type=\"text\/css\" href=\"coverage.css\" title=\"Style\">\n+<\/head>\n+<body>\n+<h1>Method coverage comparison report<\/h1>\n+<p>This report compares method coverage between two code coverage collections. A <i>target<\/i>\n+    coverage is compared to a <i>reference<\/i> coverage. Coverage of every method\n+    from the <i>target<\/i> collection is then compared to coverage of the same method in the <i>reference<\/i> collection.<\/p>\n+<p>A typical use for the report would be to investigate changes in method coverage\n+    over time, in which case the <i>reference<\/i> collection would be performed in the past and\n+    the <i>target<\/i> collection is recent.<\/p>\n+<p>Every method in the report marked in one of four ways:<\/p>\n+<ul>\n+    <li><a class=\"item_good\">Covered<\/a> - methods that are covered in the <i>target<\/i> coverage collection<\/li>\n+    <li><a class=\"item_so_so\">Uncovered<\/a> - methods that are not covered in either <i>target<\/i> or <i>reference<\/i> collections<\/li>\n+    <li><a class=\"item_not_so_good\">Lost<\/a> - methods that are covered in the <i>reference<\/i> collection but are not covered in the <i>target<\/i> collection<\/li>\n+    <li><a class=\"item_ignore\">New<\/a> - methods that are present in the <i>target<\/i> collection and missing in the <i>reference<\/i> collection<\/li>\n+<\/ul>\n+<p>In addition to the method coverage, the report provides line coverage from the <i>target<\/i> collection.<\/p>\n+<h2>Folder view<\/h2>\n+<p>A folder view lists total number of method for all four groups of methods for the files nested\n+    hierarchically within this folders.<\/p>\n+<p>Next the view shows direct <b>sub-folders<\/b> of this folder along with the totals for the groups of methods and\n+    total line coverage. The table is sortable by any column. Clicking on a sub-folder name takes to a folder view\n+    for that sub-folder. The table may be omitted altogether should tere be no direct sub-folders.<\/p>\n+<p>Next the view shows direct <b>files<\/b> which are located directly in this folder along with the totals for the\n+    groups of methods and total line coverage for the file. The table is sortable by any column. Clicking on a\n+    file name takes to a file view for that file.<\/p>\n+<h2>File view<\/h2>\n+<p>A file view lists methods of the file, colored in accordance to the groups to which the methods belong.\n+    Clicking on a method signature takes to the first line of the method, according to the line table\n+    from the bytecode.<\/p>\n+<p>Next there is the file source code. The source code is colored according to line coverage from the <i>target<\/i>\n+    collection:<\/p>\n+<ul>\n+    <li><a class=\"covered\">covered<\/a><\/li>\n+    <li><a class=\"uncovered\">uncovered<\/a><\/li>\n+    <li>no information on the text<\/li>\n+<\/ul>\n+    <p>Every line of the source code, which, according to the line table, is nested within one or more method,\n+        is prepended by one or more links, which lead to a corresponding method at the top of the file view.\n+        Every such link is colored the same way as the method it links to. Hovering mouse over such link\n+        displays method signature to which the link corresponds.<\/p>\n+<\/body>\n+<\/html>\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/view\/MethodCoverageComparisonReport.html","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,425 @@\n+\/*\n+ * Copyright (c) 2023, 2024 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.codetools.jcov.report.view;\n+\n+import openjdk.codetools.jcov.report.Coverage;\n+import openjdk.codetools.jcov.report.FileCoverage;\n+import openjdk.codetools.jcov.report.FileItems;\n+import openjdk.codetools.jcov.report.FileSet;\n+import openjdk.codetools.jcov.report.LineRange;\n+import openjdk.codetools.jcov.report.filter.SourceFilter;\n+import openjdk.codetools.jcov.report.source.SourceHierarchy;\n+\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import static java.lang.String.format;\n+\n+public class MultiHTMLReport {\n+    private final String title;\n+    private final Function<String, String> folderHeader;\n+    private final Function<String, String> fileHeader;\n+    private final FilteredReport theReport;\n+    private final SourceFilter highlight;\n+    private final SourceHierarchy source;\n+\n+    protected MultiHTMLReport(SourceHierarchy source, FileSet files, FileCoverage coverage,\n+                              FileItems items, String title,\n+                              Function<String, String> folderHeader, Function<String, String> fileHeader,\n+                              SourceFilter highlight, SourceFilter include) {\n+        theReport = new FilteredReport.Builder()\n+                .setSource(source)\n+                .setFiles(files)\n+                .setItems(items)\n+                .setCoverage(new CoverageHierarchy(files.files(), source, coverage, highlight))\n+                .setInclude(include)\n+                .report();\n+        this.source = source;\n+        this.title = title;\n+        this.folderHeader = folderHeader;\n+        this.fileHeader = fileHeader;\n+        this.highlight = highlight;\n+    }\n+\n+    public void report(Path dest) throws Exception {\n+        if (Files.isDirectory(dest)) {\n+            if (Files.list(dest).findAny().isPresent()) {\n+                throw new IllegalStateException(\"Not empty: \" + dest);\n+            }\n+        } else if (Files.isRegularFile(dest)) {\n+            throw new IllegalStateException(\"Is a file: \" + dest);\n+        } else {\n+            Files.createDirectories(dest);\n+        }\n+        toReport(\"coverage.css\", dest);\n+        toReport(\"sorttable.js\", dest);\n+        try (HtmlOut out = new HtmlOut(dest)) {\n+            theReport.report(out);\n+        }\n+    }\n+\n+    static void toReport(String resourceName, Path dest) throws IOException {\n+        toReport(resourceName, resourceName, dest);\n+    }\n+    static void toReport(String resourceName, String fileName, Path dest) throws IOException {\n+        var className = MultiHTMLReport.class.getName();\n+        className = className.substring(0, className.lastIndexOf('.')).replace('.', '\/');\n+        className = \"\/\" + className;\n+        className += \"\/\" + resourceName;\n+        copyToReport(MultiHTMLReport.class, className, fileName, dest);\n+    }\n+    public static void copyToReport(Class loaderClass, String resourceName, String fileName, Path dest) throws IOException {\n+        try (var in = loaderClass.getResourceAsStream(resourceName)) {\n+            Files.write(dest.resolve(fileName), in.readAllBytes());\n+        } catch (Exception e) {\n+            System.err.printf(\"Failed to extract %s to %s\/%s\\n\", resourceName, dest.toString(), fileName);\n+            throw e;\n+        }\n+    }\n+\n+    final static Map<FileItems.Quality, String> HTML_COLOR_CLASSES = Map.of(\n+            FileItems.Quality.BAD, \"item_not_so_good\",\n+            FileItems.Quality.SO_SO, \"item_so_so\",\n+            FileItems.Quality.GOOD, \"item_good\",\n+            FileItems.Quality.VERY_GOOD, \"item_very_good\",\n+            FileItems.Quality.IGNORE, \"item_ignore\",\n+            FileItems.Quality.NONE, \"item_none\",\n+            FileItems.Quality.LEFT, \"item_left\",\n+            FileItems.Quality.RIGHT, \"item_right\",\n+            FileItems.Quality.BOTH, \"item_both\"\n+    );\n+\n+    private class HtmlOut implements FilteredReport.FileOut, AutoCloseable {\n+        private final Path dest;\n+        private BufferedWriter folderOut = null;\n+        private BufferedWriter fileOut = null;\n+        private String file;\n+        private final FilteredReport.FilterHighlighter highlighter;\n+\n+        private HtmlOut(Path dest) throws IOException {\n+            this.highlighter = new FilteredReport.FilterHighlighter(source, highlight);\n+            this.dest = dest;\n+        }\n+\n+        private void init(String title, String header, BufferedWriter out\/*, boolean folder*\/) throws IOException {\n+            out.write(\"<html><head>\"); out.newLine();\n+            out.write(\"<title>\" + title + \"<\/title>\"); out.newLine();\n+            out.write(\"<link rel=\\\"stylesheet\\\" type=\\\"text\/css\\\" href=\\\"coverage.css\\\" title=\\\"Style\\\">\");\n+            out.newLine();\n+            out.write(\"<script type=\\\"text\/javascript\\\" src=\\\"sorttable.js\\\"><\/script>\");\n+            out.newLine();\n+            out.write(\"<\/head><body>\\n\"); out.newLine();\n+            out.write(header + \"\\n\"); out.newLine();\n+        }\n+\n+        private String navbarRef(String s) {\n+            StringBuilder line = new StringBuilder(\"<a href=\\\"\");\n+            line.append(s.isEmpty() ? \"index.html\" : reportFile(s));\n+            line.append(\"\\\">\");\n+            line.append(s.isEmpty() ? \"root\" : s.substring(s.lastIndexOf('\/') + 1));\n+            line.append(\"<\/a>\");\n+            return line.toString();\n+        }\n+\n+        private String navbar(String s) {\n+            if (s.isEmpty()) return \"\";\n+            StringBuilder line = new StringBuilder(\"<p>\");\n+            line.append(navbarRef(\"\"));\n+            int slashInd = 0;\n+            while ((slashInd = s.indexOf('\/', slashInd + 1)) > -1) {\n+                line.append(\" \/ \");\n+                line.append(navbarRef(s.substring(0, slashInd)));\n+            }\n+            line.append(\"<a> \/ \");\n+            line.append(s.substring(s.lastIndexOf('\/') + 1));\n+            line.append(\"<\/a><\/p>\");\n+            return line.toString();\n+        }\n+\n+        private String reportFile(String folderOrFile) {\n+            return folderOrFile.replace('\/', '_') + \".html\";\n+        }\n+        @Override\n+        public void startFolder(String s) throws IOException {\n+            String folderFile;\n+            if (!s.isEmpty()) folderFile = reportFile(s);\n+            else folderFile = \"index.html\";\n+            try(BufferedWriter out = Files.newBufferedWriter(dest.resolve(folderFile))) {\n+                init(title, folderHeader.apply(s), out);\n+                out.write(navbar(s)); out.newLine();\n+                var colors = theReport.itemsCache().count(s);\n+                if (!colors.isEmpty()) {\n+                    out.write(\"<table><tr><th>\" + theReport.items().kind() + \"<\/th><th>Count<\/th><\/tr>\");\n+                    out.newLine();\n+                    for (var c : FileItems.Quality.values()) {\n+                        if (theReport.items().legend().containsKey(c)) {\n+                            out.write(\"<tr><td><a class=\\\"\" + HTML_COLOR_CLASSES.get(c) + \"\\\">\" +\n+                                    theReport.items().legend().get(c) + \"<\/a><\/td>\");\n+                            out.write(\"<td>\" + colors.get(c) + \"<\/td><\/tr>\");\n+                            out.newLine();\n+                        }\n+                    }\n+                    out.write(\"<\/table>\");\n+                    out.newLine();\n+                }\n+                out.write(\"Line coverage: \" + theReport.coverage().get(s).toString());\n+                out.newLine();\n+                Collection<String> folders = theReport.files().folders(s);\n+                if (!folders.isEmpty()) {\n+                    out.write(\"<table id=\\\"folders\\\" class=\\\"sortable\\\"><tr><th>Folder<\/th>\");\n+                    out.newLine();\n+                    if (!colors.isEmpty()) {\n+                        for (var c : FileItems.Quality.values()) {\n+                            if (theReport.items().legend().containsKey(c)) {\n+                                out.write(\"<th>\" + theReport.items().legend().get(c) + \"<\/th>\");\n+                            }\n+                        }\n+                    }\n+                    out.write(\"<th>Line coverage<\/th><\/tr>\");\n+                    out.newLine();\n+                    for (String subFolder : folders) {\n+                        out.write(\"<tr><td><a href=\\\"\" + reportFile(subFolder) + \"\\\"<\/a>\" + subFolder + \"<\/a><\/td>\");\n+                        colors = theReport.itemsCache().count(subFolder);\n+                        if (!colors.isEmpty()) {\n+                            for (var c : FileItems.Quality.values()) {\n+                                if (theReport.items().legend().containsKey(c)) {\n+                                    out.write(\"<td><a class=\\\"\" + HTML_COLOR_CLASSES.get(c) + \"\\\">\" +\n+                                            colors.get(c) + \"<\/a><\/td>\");\n+                                }\n+                            }\n+                        }\n+                        out.write(\"<td>\" + theReport.coverage().get(subFolder) + \"<\/td><\/tr>\");\n+                        out.newLine();\n+                    }\n+                    out.write(\"<\/table>\");\n+                    out.newLine();\n+                }\n+                Collection<String> files = theReport.files().files(s);\n+                if (!files.isEmpty()) {\n+                    out.write(\"<table id=\\\"files\\\" class=\\\"sortable\\\"><tr><th>File<\/th>\");\n+                    if (!colors.isEmpty()) {\n+                        for (var c : FileItems.Quality.values()) {\n+                            if (theReport.items().legend().containsKey(c)) {\n+                                out.write(\"<th>\" + theReport.items().legend().get(c) + \"<\/th>\");\n+                            }\n+                        }\n+                    }\n+                    out.write(\"<th>Line coverage<\/th><\/tr>\");\n+                    out.newLine();\n+                    for (String file : files) {\n+                        out.write(\"<tr><td><a href=\\\"\" + reportFile(file) + \"\\\"<\/a>\" + file + \"<\/a><\/td>\");\n+                        colors = theReport.itemsCache().count(file);\n+                        if (!colors.isEmpty()) {\n+                            for (var c : FileItems.Quality.values()) {\n+                                if (theReport.items().legend().containsKey(c)) {\n+                                    out.write(\"<td><a class=\\\"\" + HTML_COLOR_CLASSES.get(c) + \"\\\">\" +\n+                                            colors.get(c) + \"<\/a><\/td>\");\n+                                }\n+                            }\n+                        }\n+                        out.write(\"<td>\" + theReport.coverage().get(file) + \"<\/td><\/tr>\");\n+                        out.newLine();\n+                    }\n+                    out.write(\"<\/table>\");\n+                    out.newLine();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void startFile(String file) throws IOException {\n+            this.file = file;\n+            fileOut = Files.newBufferedWriter(dest.resolve(reportFile(file)));\n+            init(title, fileHeader.apply(file), fileOut);\n+            fileOut.write(navbar(file)); fileOut.newLine();\n+        }\n+\n+        @Override\n+        public void startItems() throws Exception {\n+            fileOut.write(\"<table>\"); fileOut.newLine();\n+            fileOut.write(\"<tr><th>\"+theReport.items().kind()+\"<\/th><\/tr>\");\n+        }\n+\n+        @Override\n+        public void printItem(FileItems.FileItem fi) throws IOException {\n+            String href;\n+            if (fi.ranges().isEmpty()) href = \"\";\n+            else href = \"href=\\\"#line_\" + fi.ranges().get(0).first() + \"\\\"\";\n+            fileOut.write(format(\"<tr><td><pre><a id=\\\"item_%s\\\" %s class=\\\"%s\\\">%s<\/a><\/pre><\/td>\",\n+                    fi.item(), href,\n+                    HTML_COLOR_CLASSES.get(fi.quality()),\n+                    fi.item().replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")));\n+            fileOut.write(\"<\/tr>\");\n+            fileOut.newLine();\n+        }\n+\n+        @Override\n+        public void endItems() throws Exception {\n+            fileOut.write(\"<\/table>\"); fileOut.newLine();\n+            fileOut.write(\"Line coverage \" + theReport.coverage().get(file)); fileOut.newLine();\n+        }\n+\n+        @Override\n+        public void startLineRange(LineRange range) throws IOException {\n+            if (highlight != null)\n+                fileOut.write(\"<hr\/>\"); fileOut.newLine();\n+            fileOut.write(\"<table>\"); fileOut.newLine();\n+        }\n+\n+        private String coveredClass(Coverage coverage) {\n+            if (coverage != null)\n+                switch (coverage.quality()) {\n+                    case GOOD:\n+                        return \"covered\";\n+                    case BAD:\n+                        return \"uncovered\";\n+                    case SO_SO:\n+                        return \"so_so\";\n+                    case LEFT:\n+                        return \"left\";\n+                    case RIGHT:\n+                        return \"right\";\n+                    case BOTH:\n+                        return \"both\";\n+                    default:\n+                        return \"context\";\n+                }\n+            else return \"context\";\n+        }\n+\n+        @Override\n+        public void printSourceLine(int lineNo, String line, Coverage coverage,\n+                                    List<FileItems.FileItem> items) throws IOException {\n+            fileOut.write(\"<tr>\");\n+            if (items != null) {\n+                fileOut.write(\"<td><pre>\");\n+                for (var item : items) {\n+                    \/\/TODO should there be a separate method on what to print?\n+                    fileOut.write(format(\"<a id=\\\"line_%s\\\" href=\\\"#item_%s\\\" class=\\\"%s\\\" title=\\\"%s\\\">%s<\/a>&nbsp;\",\n+                            (lineNo + 1), item.item(), HTML_COLOR_CLASSES.get(item.quality()), item.item(), \" \"));\n+                }\n+                fileOut.write(\"<\/pre><\/td>\");\n+            }\n+            fileOut.write(\"<td><pre>\" + (lineNo + 1) + \"<\/pre><\/td>\");\n+            fileOut.write(\"<td><pre><a class=\\\"\" +\n+                    (coverage != null ? coveredClass(coverage) :\n+                        (highlight != null && highlighter.isHighlighted(file, lineNo + 1) ?\n+                                \"highlight\" : \"context\")) +\n+                    \"\\\">\");\n+            fileOut.write(line.replaceAll(\"<\/?\\\\s*pre\\\\s*>\", \"\"));\n+            fileOut.write(\"<\/a><\/pre><\/td><\/tr>\");\n+            fileOut.newLine();\n+        }\n+\n+        @Override\n+        public void endLineRange(LineRange range) throws IOException {\n+            fileOut.write(\"<\/table>\"); fileOut.newLine();\n+        }\n+\n+        @Override\n+        public void endFile(String s) throws IOException {\n+            if (highlight != null)\n+                fileOut.write(\"<hr\/>\"); fileOut.newLine();\n+            fileOut.close();\n+        }\n+\n+        public void endFolder(String s) {\n+        }\n+\n+        @Override\n+        public void close() throws Exception {\n+        }\n+    }\n+\n+    public static class Builder {\n+        private FileSet files;\n+        private SourceHierarchy source;\n+        private SourceFilter highlight;\n+        private SourceFilter include;\n+        private String title = \"\";\n+        private Function<String, String> folderHeader = s -> \"\";\n+        private Function<String, String> fileHeader = s -> \"\";\n+        private FileCoverage coverage;\n+        private FileItems items;\n+\n+        public Builder setFiles(FileSet files) {\n+            this.files = files;\n+            return this;\n+        }\n+\n+        public Builder setSource(SourceHierarchy source) {\n+            this.source = source;\n+            return this;\n+        }\n+\n+        public Builder setInclude(SourceFilter include) {\n+            this.include = include;\n+            return this;\n+        }\n+\n+        public Builder setHighlight(SourceFilter highlight) {\n+            this.highlight = highlight;\n+            return this;\n+        }\n+\n+        public Builder setTitle(String title) {\n+            this.title = title;\n+            return this;\n+        }\n+\n+        public Builder setCoverage(FileCoverage coverage) {\n+            this.coverage = coverage;\n+            return this;\n+        }\n+\n+        public MultiHTMLReport report() {\n+            return new MultiHTMLReport(source, files, coverage, items,\n+                    title,\n+                    folderHeader, fileHeader, highlight,include);\n+        }\n+\n+        public Builder setFolderHeader(Function<String, String> prefix) {\n+            this.folderHeader = prefix;\n+            return this;\n+        }\n+\n+        public Builder setFileHeader(Function<String, String> prefix) {\n+            this.fileHeader = prefix;\n+            return this;\n+        }\n+\n+        public Builder setItems(FileItems items) {\n+            this.items = items;\n+            return this;\n+        }\n+    }\n+}\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/view\/MultiHTMLReport.java","additions":425,"deletions":0,"binary":false,"changes":425,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import openjdk.codetools.jcov.report.FileItems;\n@@ -38,0 +39,3 @@\n+import java.util.List;\n+\n+import static java.lang.String.format;\n@@ -42,1 +46,1 @@\n-public class SingleHTMLReport extends HightlightFilteredReport {\n+public class SingleHTMLReport {\n@@ -44,2 +48,41 @@\n-    private String title;\n-    private String header;\n+    static final String CSS = \"\"\"\n+                    .sortable {\n+                    }\n+                    .context {\n+                      font-weight: lighter;\n+                    }\n+                    .highlight {\n+                      font-weight: bold;\n+                    }\n+                    .covered {\n+                      font-weight: bold;\n+                      background-color: palegreen;\n+                    }\n+                    .uncovered {\n+                      font-weight: bold;\n+                      background-color: salmon;\n+                    }\n+                    .filename {\n+                      font-weight: bold;\n+                      font-size: larger;\n+                    }\n+                    .item_good {\n+                      background-color: palegreen;\n+                    }\n+                    .item_so_so {\n+                      background-color: yellow;\n+                    }\n+                    .item_not_so_good {\n+                      background-color: salmon;\n+                    }\n+                    .item_ignore {\n+                      background-color: lightgrey;\n+                    }\n+                    .item_none {\n+                    }\n+                    \"\"\";\n+    private final String title;\n+    private final String header;\n+    private final FilteredReport theReport;\n+    private final SourceFilter highlight;\n+    private final SourceHierarchy source;\n@@ -48,1 +91,1 @@\n-                            String title, String header,\n+                            FileItems items, String title, String header,\n@@ -50,3 +93,7 @@\n-        \/\/TODO a builder\n-        super(source, files, new CoverageHierarchy(files.files(), source, coverage, highlight),\n-                highlight, include);\n+        theReport = new FilteredReport.Builder()\n+                .setSource(source)\n+                .setFiles(files)\n+                .setItems(items)\n+                .setCoverage(new CoverageHierarchy(files.files(), source, coverage, highlight))\n+                .setInclude(include)\n+                .report();\n@@ -55,0 +102,2 @@\n+        this.highlight = highlight;\n+        this.source = source;\n@@ -59,1 +108,0 @@\n-            var rout = new HtmlOut(out);\n@@ -63,18 +111,1 @@\n-                    \".context {\\n\" +\n-                    \"  font-weight: lighter;\\n\" +\n-                    \"}\\n\" +\n-                    \".highlight {\\n\" +\n-                    \"  font-weight: bold;\\n\" +\n-                    \"}\\n\" +\n-                    \".covered {\\n\" +\n-                    \"  font-weight: bold;\\n\" +\n-                    \"  background-color: palegreen;\\n\" +\n-                    \"}\\n\" +\n-                    \".uncovered {\\n\" +\n-                    \"  font-weight: bold;\\n\" +\n-                    \"  background-color: salmon;\\n\" +\n-                    \"}\\n\" +\n-                    \".filename {\\n\" +\n-                    \"  font-weight: bold;\\n\" +\n-                    \"  font-size: larger;\\n\" +\n-                    \"}\\n\" +\n+                    CSS +\n@@ -85,1 +116,2 @@\n-            toc(rout, \"\");\n+\n+            theReport.report(new HtmlTOCOut(out));\n@@ -88,1 +120,1 @@\n-            code(rout, \"\");\n+            theReport.report(new HtmlOut(out));\n@@ -93,1 +125,1 @@\n-    private class HtmlOut implements TOCOut, FileOut {\n+    private class HtmlTOCOut implements FilteredReport.FileOut {\n@@ -96,1 +128,1 @@\n-        private HtmlOut(BufferedWriter out) {\n+        private HtmlTOCOut(BufferedWriter out) {\n@@ -101,2 +133,2 @@\n-        public void printFileLine(String s) throws IOException {\n-            var cov = coverage().get(s);\n+        public void startFile(String s) throws IOException {\n+            var cov = theReport.coverage().get(s);\n@@ -109,1 +141,26 @@\n-        public void printFolderLine(String s, Coverage cov) throws IOException {\n+        public void startItems() throws Exception {}\n+\n+        @Override\n+        public void printItem(FileItems.FileItem fi) throws Exception {}\n+\n+        @Override\n+        public void endItems() throws Exception {}\n+\n+        @Override\n+        public void startLineRange(LineRange range) throws Exception {}\n+\n+        @Override\n+        public void printSourceLine(int line, String s, Coverage coverage, List<FileItems.FileItem> items) throws Exception {}\n+\n+        @Override\n+        public void endLineRange(LineRange range) throws Exception {}\n+\n+        @Override\n+        public void endFile(String s) throws Exception {}\n+\n+        @Override\n+        public void endFolder(String s) {}\n+\n+        @Override\n+        public void startFolder(String s) throws IOException {\n+            Coverage cov = theReport.coverage().get(s);\n@@ -115,0 +172,10 @@\n+    }\n+    private class HtmlOut implements FilteredReport.FileOut {\n+        private final BufferedWriter out;\n+        private final FilteredReport.FilterHighlighter highlighter;\n+        private String lastFile;\n+\n+        private HtmlOut(BufferedWriter out) {\n+            this.highlighter = new FilteredReport.FilterHighlighter(source, highlight);\n+            this.out = out;\n+        }\n@@ -121,1 +188,2 @@\n-                    coverage().get(file) + \"<\/a><\/br>\"); out.newLine();\n+                    theReport.coverage().get(file) + \"<\/a><\/br>\"); out.newLine();\n+            lastFile = file;\n@@ -130,1 +198,2 @@\n-        public void printSourceLine(int lineNo, String line, boolean highlight, Coverage coverage) throws IOException {\n+        public void printSourceLine(int lineNo, String line, Coverage coverage,\n+                                    List<FileItems.FileItem> items) throws IOException {\n@@ -137,1 +206,1 @@\n-            } else if (highlight) {\n+            } else if (highlighter.isHighlighted(lastFile, lineNo + 1)) {\n@@ -159,1 +228,6 @@\n-        public void startDir(String s, Coverage cov) throws IOException {\n+        public void endFolder(String s) {\n+\n+        }\n+\n+        @Override\n+        public void startFolder(String s) throws IOException {\n@@ -163,0 +237,73 @@\n+\n+        @Override\n+        public void startItems() throws Exception {\n+            out.write(\"<table>\"); out.newLine();\n+        }\n+\n+        @Override\n+        public void printItem(FileItems.FileItem fi) throws IOException, Exception {\n+            out.write(format(\"<tr><td><pre><a id=\\\"item_%s\\\" class=\\\"%s\\\">%s<\/a><\/pre><\/td>\",\n+                    fi.item(), MultiHTMLReport.HTML_COLOR_CLASSES.get(fi.quality()), fi.item()));\n+            out.write(\"<\/tr>\");\n+            out.newLine();\n+        }\n+\n+        @Override\n+        public void endItems() throws Exception {\n+            out.write(\"<\/table>\"); out.newLine();\n+        }\n+    }\n+\n+    public static class Builder {\n+        private SourceHierarchy source;\n+        private FileSet files;\n+        private FileCoverage coverage;\n+        private String title;\n+        private String header;\n+        private SourceFilter highlight;\n+        private SourceFilter include;\n+        private FileItems items;\n+\n+        public Builder source(SourceHierarchy source) {\n+            this.source = source;\n+            return this;\n+        }\n+\n+        public Builder files(FileSet files) {\n+            this.files = files;\n+            return this;\n+        }\n+\n+        public Builder coverage(FileCoverage coverage) {\n+            this.coverage = coverage;\n+            return this;\n+        }\n+\n+        public Builder title(String title) {\n+            this.title = title;\n+            return this;\n+        }\n+\n+        public Builder header(String header) {\n+            this.header = header;\n+            return this;\n+        }\n+\n+        public Builder highlight(SourceFilter highlight) {\n+            this.highlight = highlight;\n+            return this;\n+        }\n+\n+        public Builder include(SourceFilter include) {\n+            this.include = include;\n+            return this;\n+        }\n+\n+        public Builder items(FileItems items) {\n+            this.items = items;\n+            return this;\n+        }\n+\n+        public SingleHTMLReport report() {\n+            return new SingleHTMLReport(source, files, coverage, items, title, header, highlight, include);\n+        }\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/view\/SingleHTMLReport.java","additions":185,"deletions":38,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import openjdk.codetools.jcov.report.FileItems;\n@@ -37,0 +38,1 @@\n+import java.util.List;\n@@ -41,1 +43,1 @@\n-public class TextReport extends HightlightFilteredReport {\n+public class TextReport {\n@@ -43,1 +45,2 @@\n-    private String header;\n+    private final String header;\n+    private final FilteredReport theReport;\n@@ -45,2 +48,10 @@\n-    public TextReport(SourceHierarchy source, FileSet files, FileCoverage coverage, String header, SourceFilter filter) {\n-        super(source, files, new CoverageHierarchy(files.files(), source, coverage, filter), filter, filter);\n+    public TextReport(SourceHierarchy source, FileSet files,\n+                      FileCoverage coverage,\n+                      String header, SourceFilter filter) {\n+        theReport = new FilteredReport.Builder()\n+                .setSource(source)\n+                .setFiles(files)\n+                .setItems(null)\n+                .setCoverage(new CoverageHierarchy(files.files(), source, coverage, filter))\n+                .setInclude(filter)\n+                .report();\n@@ -53,1 +64,1 @@\n-            super.toc(new TOCOut() {\n+            theReport.report(new FilteredReport.FileOut() {\n@@ -55,2 +66,2 @@\n-                public void printFileLine(String file) throws Exception {\n-                    out.write(file + \" \" + coverage().get(file));\n+                public void startFile(String file) throws Exception {\n+                    out.write(file + \" \" + theReport.coverage().get(file));\n@@ -61,2 +72,42 @@\n-                public void printFolderLine(String folder, Coverage cov) throws Exception {\n-                    out.write((folder.isEmpty() ? \"total\" : folder) + \" \" + cov);\n+                public void startItems() throws Exception {\n+\n+                }\n+\n+                @Override\n+                public void printItem(FileItems.FileItem fi) throws Exception {\n+\n+                }\n+\n+                @Override\n+                public void endItems() throws Exception {\n+\n+                }\n+\n+                @Override\n+                public void startLineRange(LineRange range) throws Exception {\n+\n+                }\n+\n+                @Override\n+                public void printSourceLine(int line, String s, Coverage coverage, List<FileItems.FileItem> items) throws Exception {\n+\n+                }\n+\n+                @Override\n+                public void endLineRange(LineRange range) throws Exception {\n+\n+                }\n+\n+                @Override\n+                public void endFile(String s) throws Exception {\n+\n+                }\n+\n+                @Override\n+                public void endFolder(String s) {\n+\n+                }\n+\n+                @Override\n+                public void startFolder(String folder) throws Exception {\n+                    out.write((folder.isEmpty() ? \"total\" : folder) + \" \" + theReport.coverage().get(folder));\n@@ -65,2 +116,2 @@\n-            }, \"\");\n-            code(new FileOut() {\n+            });\n+            theReport.report(new FilteredReport.FileOut() {\n@@ -69,1 +120,1 @@\n-                    out.write(\"file:\" + file + \" \" + coverage().get(file));\n+                    out.write(\"file:\" + file + \" \" + theReport.coverage().get(file));\n@@ -80,1 +131,2 @@\n-                public void printSourceLine(int line, String s, boolean highlight, Coverage coverage) throws Exception {\n+                public void printSourceLine(int line, String s, Coverage coverage,\n+                                            List<FileItems.FileItem> items) throws Exception {\n@@ -97,1 +149,6 @@\n-                public void startDir(String s, Coverage cov) throws Exception {\n+                public void endFolder(String s) {\n+\n+                }\n+\n+                @Override\n+                public void startFolder(String s) throws Exception {\n@@ -100,1 +157,53 @@\n-            }, \"\");\n+\n+                @Override\n+                public void startItems() {\n+                    throw new RuntimeException(\"This shoudl not happen\");\n+                }\n+\n+                @Override\n+                public void printItem(FileItems.FileItem fi) {\n+                    throw new RuntimeException(\"This shoudl not happen\");\n+                }\n+\n+                @Override\n+                public void endItems() {\n+                    throw new RuntimeException(\"This shoudl not happen\");\n+                }\n+            });\n+        }\n+    }\n+\n+    public static class Builder {\n+        private SourceHierarchy source;\n+        private FileSet files;\n+        private FileCoverage coverage;\n+        private String header;\n+        private SourceFilter filter;\n+\n+        public Builder source(SourceHierarchy source) {\n+            this.source = source;\n+            return this;\n+        }\n+\n+        public Builder files(FileSet files) {\n+            this.files = files;\n+            return this;\n+        }\n+\n+        public Builder coverage(FileCoverage coverage) {\n+            this.coverage = coverage;\n+            return this;\n+        }\n+\n+        public Builder header(String header) {\n+            this.header = header;\n+            return this;\n+        }\n+\n+        public Builder filter(SourceFilter filter) {\n+            this.filter = filter;\n+            return this;\n+        }\n+\n+        public TextReport report() {\n+            return new TextReport(source, files, coverage, header, filter);\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/view\/TextReport.java","additions":124,"deletions":15,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2023, 2024 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+.sortable {\n+}\n+.context {\n+  font-weight: lighter;\n+}\n+.highlight {\n+  font-weight: bold;\n+}\n+.covered {\n+  font-weight: bold;\n+  background-color: palegreen;\n+}\n+.so_so {\n+  font-weight: bold;\n+  background-color: yellow;\n+}\n+.left {\n+  font-weight: bold;\n+  background-color: lightgreen;\n+}\n+.right {\n+  font-weight: bold;\n+  background-color: lightblue;\n+}\n+.both {\n+  font-weight: bold;\n+  background-color: lightgrey;\n+}\n+.filename {\n+  font-weight: bold;\n+  font-size: larger;\n+}\n+.item_very_good {\n+  background-color: lightgreen;\n+}\n+.item_good {\n+  background-color: palegreen;\n+}\n+.item_so_so {\n+  background-color: yellow;\n+}\n+.item_not_so_good {\n+  background-color: lightsalmon;\n+}\n+.item_ignore {\n+  background-color: lightgrey;\n+}\n+.item_none {\n+}\n+.item_left {\n+  background-color: lightgreen;\n+}\n+.item_right {\n+  background-color: lightblue;\n+}\n+.item_both {\n+  background-color: lightgrey;\n+}\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/view\/coverage.css","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+<!DOCTYPE HTML PUBLIC \"-\/\/W3C\/\/DTD HTML 4.01 Transitional\/\/EN\"\n+        \"http:\/\/www.w3.org\/TR\/html4\/loose.dtd\">\n+<html>\n+<head>\n+    <title>JDK coverage comparison report<\/title>\n+    <link rel=\"stylesheet\" type=\"text\/css\" href=\"coverage.css\" title=\"Style\">\n+<\/head>\n+<body>\n+<h1>JDK coverage comparison report<\/h1>\n+<p>The reports shows difference in coverage between two code coverage collections done on the same build.\n+    For simplicity, let's call the two coverage collections as <b>left<\/b> and <b>right<\/b>. An example of a use case\n+would be comparing coverage of two groups of tests targeting the same code.<\/p>\n+\n+<h2>The report<\/h2>\n+<p>The report simultaneously compares coverage for the methods and the source code. Only methods and the code which\n+    are present in the <b>right<\/b> collection are displayed in the report. Color coding is used to indicate coverage differences.<\/p>\n+\n+Next coloring is used (same coloring used for methods and source lines unless otherwise specified):\n+<ul>\n+    <li><a class=\"item_both\">Both<\/a> - Code covered by both <b>left<\/b> and <b>right<\/b> code coverage collections.<\/li>\n+    <li><a class=\"item_left\">Left<\/a> - Code only covered by <b>left<\/b>.<\/li>\n+    <li><a class=\"item_right\">Right<\/a> - Code only covered by <b>right<\/b>.<\/li>\n+    <li><a class=\"item_none\">None<\/a> - Code not covered by either <b>left<\/b> or <b>right<\/b>.<\/li>\n+<\/ul>\n+\n+<h3>Views<\/h3>\n+There are two views in the report:\n+<h4>Folder view<\/h4>\n+<p>At the top of the view, with the esception of the root view, there is a navgation bar, which takes back up the hierarchy.<\/p>\n+<p>Following that there are stats on method coverage for all four groups: covered, uncovered, lost and new.<\/p>\n+<p>Following that, there is an information on line coverage for the files in that folder (recursively).<\/p>\n+<p>Following that, there is a table of sub-folders for each of which there are stats on method coverage for all four groups\n+and line coverage for every sub-folder. Clicking on a column header allows to sort the list by this column values in a\n+    descending or an ascending order. Clicking on a folder name takes to the next level.\n+<p>Finally there is a table with files located in this folder. It displays the same information for every file: all four\n+kinds of method coverage plus line coverage for every method. Clicking on a file name takes to a file view<\/p>\n+\n+<h4>File view<\/h4>\n+<p>At the top of the view, with the esception of the root view, there is a navgation bar, which takes back up the hierarchy.<\/p>\n+<p>Following that there is a list of methods in alphabetical order colored according to the method\n+coverage status. (Please note that VM method signatures are used). Clicking on a method name takes to the first\n+line of the source code corresponding to this method.<\/p>\n+<p>Following that there is line coverage information for the file.<\/p>\n+<p>Following that there is file source, colored according to the coverage status. Left to every line of code which\n+is a code line and is not new, there is one or more \"_\" clickable links which take to the method in the list at the top\n+    of the view. Mouse hovering over a \"_\" link brings a tooltip with the signature of the method.<\/p>\n+<\/body>\n+<\/html>\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/view\/jdk\/JDKComparisonReport.html","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+package openjdk.codetools.jcov.report.view.jdk;\n+\n+import com.sun.tdk.jcov.instrument.DataRoot;\n+import openjdk.codetools.jcov.report.FileItems;\n+import openjdk.codetools.jcov.report.FileSet;\n+import openjdk.codetools.jcov.report.jcov.JCovCoverageComparison;\n+import openjdk.codetools.jcov.report.jcov.JCovMethodCoverageComparison;\n+import openjdk.codetools.jcov.report.source.SourceHierarchy;\n+import openjdk.codetools.jcov.report.view.MultiHTMLReport;\n+\n+import java.nio.file.Path;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+import static openjdk.codetools.jcov.report.view.jdk.JDKLostKeptReport.DESCRIPTION_HTML;\n+\n+public class JDKComparisonReport {\n+    private final static String USAGE = \"\"\"\n+        java ... %s \\\\\n+            <left coverage> <right coverage> \\\\\n+            <source> \\\\\n+            <report directory>\n+        Where:\n+            (left|right)_coverage - JCov XML coverage files to compare\n+            source - JDK source hierarchies corresponding to the coverage files\n+            <report directory> - must not exist or be empty\n+    \"\"\".formatted(JDKComparisonReport.class.getName());\n+    private final DataRoot oldCov;\n+    private final DataRoot newCov;\n+    private final SourceHierarchy source;\n+    private final Path reportDir;\n+    private final BiFunction<Boolean, Boolean, FileItems.Quality> coloring = (o, n) -> {\n+        if (o)\n+            if (n) return FileItems.Quality.BOTH;\n+            else return FileItems.Quality.LEFT;\n+        else\n+        if (n) return FileItems.Quality.RIGHT;\n+        else return FileItems.Quality.NONE;\n+    };\n+    private final Map <FileItems.Quality, String> legend =  Map.of(\n+            FileItems.Quality.LEFT, \"left\",\n+            FileItems.Quality.RIGHT, \"right\",\n+            FileItems.Quality.BOTH, \"both\",\n+            FileItems.Quality.NONE, \"neither\");\n+\n+    public JDKComparisonReport(DataRoot oldCov, DataRoot newCov, SourceHierarchy source, Path dir) {\n+        this.source = source;\n+        reportDir = dir;\n+        this.oldCov = oldCov;\n+        this.newCov = newCov;\n+    }\n+\n+    public void report() {\n+        try {\n+            var reportLegendLink = \"<a style=\\\"float:right\\\" href=\\\"\" + DESCRIPTION_HTML + \"\\\">What am I looking at?<\/a>\";\n+            var noSourceClasses = new HashSet<String>();\n+            var report = new MultiHTMLReport.Builder()\n+                    .setSource(source)\n+                    .setCoverage(new JCovCoverageComparison(\n+                            oldCov, null,\n+                            newCov, this.source, coloring))\n+                    .setItems(new JCovMethodCoverageComparison(\n+                            oldCov, newCov,\n+                            f -> source.toFile(f),\n+                            legend,\n+                            coloring))\n+                    .setFolderHeader(s -> \"<h1>Lost\/kept coverage<\/h1>\" + reportLegendLink)\n+                    .setFileHeader(s -> \"<h1>Lost\/kept coverage<\/h1>\" + reportLegendLink)\n+                    .setTitle(\"Lost\/kept method coverage\")\n+                    .setFiles(new FileSet(newCov.getClasses().stream()\n+                            .map(dc -> {\n+                                var cn = dc.getFullname();\n+                                cn = cn.contains(\"$\") ? cn.substring(0, cn.indexOf(\"$\")) : cn;\n+                                if (!noSourceClasses.contains(cn)) {\n+                                    var res = source.toFile(cn.replace('.', '\/') + \".java\");\n+                                    if (res == null) noSourceClasses.add(cn);\n+                                    return res;\n+                                }\n+                                return null;\n+                            })\n+                            .filter(c -> c != null)\n+                            .collect(Collectors.toSet())))\n+                    .report();\n+            noSourceClasses.stream().sorted().forEach(cn -> System.err.println(\"No source file for \" + cn));\n+            report.report(reportDir);\n+            MultiHTMLReport.copyToReport(JDKComparisonReport.class, \"JDKComparisonReport.html\",\n+                    DESCRIPTION_HTML, reportDir);\n+        } catch (Throwable e) {\n+            System.err.println(USAGE);\n+            System.exit(1);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new JDKComparisonReport(DataRoot.read(args[0]), DataRoot.read(args[1]),\n+                JDKLostKeptReport.jdkSourceHierarchy(args[2]), Path.of(args[3])).report();\n+    }\n+}\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/view\/jdk\/JDKComparisonReport.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2023, 2024 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.codetools.jcov.report.view.jdk;\n+\n+import com.sun.tdk.jcov.instrument.DataRoot;\n+import openjdk.codetools.jcov.report.FileSet;\n+import openjdk.codetools.jcov.report.commandline.CommandLine;\n+import openjdk.codetools.jcov.report.commandline.Option;\n+import openjdk.codetools.jcov.report.filter.GitDiffFilter;\n+import openjdk.codetools.jcov.report.jcov.JCovLineCoverage;\n+import openjdk.codetools.jcov.report.source.ContextFilter;\n+import openjdk.codetools.jcov.report.source.SourcePath;\n+import openjdk.codetools.jcov.report.view.MultiHTMLReport;\n+import openjdk.codetools.jcov.report.view.SingleHTMLReport;\n+import openjdk.codetools.jcov.report.view.TextReport;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * This is a utility class to generate report for openjdk.\n+ *\/\n+public class JDKDiffCoverageReport {\n+    private static final Option FORMAT = new Option.Builder().option(\"--format\").name(\"format\")\n+            .description(\"single|multi|text for single|multi html report or a text report\").create();\n+    private static final Option SOURCE = new Option.Builder().option(\"--source\").name(\"source\")\n+            .description(\"JDK source root\").create();\n+    public static final Option COVERAGE = new Option.Builder().option(\"--coverage\").name(\"coverage\")\n+            .description(\"JCov coverage file\").create();\n+    public static final Option DIFF = new Option.Builder().option(\"--diff\").name(\"diff\")\n+            .description(\"Git diff file from the tip to a revision in the past produced with -U0 option\").create();\n+    public static final Option REPORT = new Option.Builder().option(\"--report\").name(\"report\")\n+            .description(\"Report output\").create();\n+    public static final Option TITLE = new Option.Builder().option(\"--title\").name(\"title\").optional(true)\n+            .description(\"Report title\").create();\n+    public static final Option HEADER = new Option.Builder().option(\"--header\").name(\"header\").optional(true)\n+            .description(\"Report header\").create();\n+    private static final CommandLine commandLine = new CommandLine.Builder()\n+            .option(FORMAT)\n+            .option(SOURCE)\n+            .option(COVERAGE)\n+            .option(DIFF)\n+            .option(REPORT)\n+            .option(TITLE)\n+            .option(HEADER)\n+            .create();\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            var command = commandLine.parse(args);\n+            var source = jdkSource(List.of(Path.of(command.get(SOURCE))));\n+            var coverage = new JCovLineCoverage(DataRoot.read(command.get(COVERAGE)), source);\n+            var diff = GitDiffFilter.parseDiff(Path.of(command.get(DIFF))\/*, source.roots(List.of(Path.of(args[1])))*\/);\n+            String reportFile = command.get(REPORT);\n+            String title = command.getOrElse(TITLE, \"\");\n+            String header = command.getOrElse(HEADER, \"\");\n+            switch (command.get(FORMAT)) {\n+                case \"single\":\n+                    new SingleHTMLReport.Builder().source(source).files(new FileSet(diff.files()))\n+                            .coverage(coverage).title(title).header(header).highlight(diff)\n+                            .include(new ContextFilter(diff, 10)).report()\n+                            .report(Path.of(reportFile));\n+                    break;\n+                case \"multi\":\n+                    new MultiHTMLReport.Builder().setSource(source).setFiles(new FileSet(diff.files()))\n+                            .setCoverage(coverage).setTitle(title)\n+                            .setFolderHeader(s -> header).setFileHeader(s -> header)\n+                            .setHighlight(diff)\n+                            .setInclude(new ContextFilter(diff, 10)).report()\n+                            .report(Path.of(reportFile));\n+                    break;\n+                case \"text\":\n+                    new TextReport.Builder().source(source).files(new FileSet(diff.files())).coverage(coverage)\n+                            .header(header).filter(diff).report()\n+                            .report(Path.of(reportFile));\n+                    break;\n+            }\n+        } catch (Throwable e) {\n+            System.out.println(\"Usage: java ... openjdk.codetools.jcov.report.view.JDKReport \" +\n+                    commandLine.usageLine() + \"\\n\");\n+            System.out.println(commandLine.usageList(\"    \"));\n+            throw e;\n+        }\n+    }\n+\n+    public static SourcePath jdkSource(String sourcePath) {\n+        var list = new ArrayList<Path>();\n+        for (var s : sourcePath.split(\":\")) list.add(Path.of(s));\n+        return jdkSource(list);\n+    }\n+\n+    public static SourcePath jdkSource(List<Path> repos) {\n+        return new SourcePath(repos, repos.stream().collect(Collectors.toMap(\n+                repo -> repo,\n+                repo -> {\n+                    try {\n+                        return jdkSource(repo);\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                })));\n+    }\n+\n+    public static List<Path> jdkSource(Path path) throws IOException {\n+        var srcRoot = path.resolve(\"src\");\n+        var classesDirs = List.of(\"linux\/classes\", \"unix\/classes\", \"share\/classes\");\n+        var res = new ArrayList<Path>();\n+        for (var cd : classesDirs)\n+            Files.list(srcRoot).map(module -> module.resolve(cd)).\n+                    filter(Files::exists).forEach(res::add);\n+        return res;\n+    }\n+}\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/view\/jdk\/JDKDiffCoverageReport.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+<!DOCTYPE HTML PUBLIC \"-\/\/W3C\/\/DTD HTML 4.01 Transitional\/\/EN\"\n+        \"http:\/\/www.w3.org\/TR\/html4\/loose.dtd\">\n+<html>\n+<head>\n+    <title>JDK coverage comparison report<\/title>\n+    <link rel=\"stylesheet\" type=\"text\/css\" href=\"coverage.css\" title=\"Style\">\n+<\/head>\n+<body>\n+<h1>JDK coverage comparison report<\/h1>\n+<p>The reports shows difference in coverage between two JDK code coverage collections. For simplicity, let's\n+    call the two coverage collections as <b>first<\/b> and <b>second<\/b>.<\/p>\n+<p>Examples of use cases:<\/p>\n+<ul>\n+    <li>Comparing change in coverage over time.<\/li>\n+    <li>Comparing coverage from different test sets.<\/li>\n+<\/ul>\n+<h2>The report<\/h2>\n+<p>The report simultaneously compares coverage for the methods and the source code. Only methods and the code which\n+    are present in the second collection are displayed in the report. Color coding is used to indicate coverage differences.<\/p>\n+\n+Next coloring is used (same coloring used for methods and source lines unless otherwise specified):\n+<ul>\n+    <li><a class=\"item_good\">Green, a.k.a covered<\/a> - exists in both versions and covered in the second version.<\/li>\n+    <li><a class=\"item_so_so\">Yellow a.k.a. uncovered<\/a> - exists in both versions and covered in neither version.<\/li>\n+    <li><a class=\"item_not_so_good\">Red a.k.a. lost<\/a> - exists in both versions, covered in the first but not is the second.<\/li>\n+    <li><a class=\"item_ignore\">Grey a.k.a. new<\/a> - only exists in the second version. This is only used for methods,\n+        code which is only present in the second version has no color highlight.<\/li>\n+<\/ul>\n+\n+The report only includes source code for classes which are present in the <b>second<\/b> coverage data.\n+\n+<h3>Views<\/h3>\n+There are two views in the report:\n+<h4>Folder view<\/h4>\n+<p>At the top of the view, with the esception of the root view, there is a navgation bar, which takes back up the hierarchy.<\/p>\n+<p>Following that there are stats on method coverage for all four groups: covered, uncovered, lost and new.<\/p>\n+<p>Following that, there is an information on line coverage for the files in that folder (recursively).<\/p>\n+<p>Following that, there is a table of sub-folders for each of which there are stats on method coverage for all four groups\n+and line coverage for every sub-folder. Clicking on a column header allows to sort the list by this column values in a\n+    descending or an ascending order. Clicking on a folder name takes to the next level.\n+<p>Finally there is a table with files located in this folder. It displays the same information for every file: all four\n+kinds of method coverage plus line coverage for every method. Clicking on a file name takes to a file view<\/p>\n+\n+<h4>File view<\/h4>\n+<p>At the top of the view, with the esception of the root view, there is a navgation bar, which takes back up the hierarchy.<\/p>\n+<p>Following that there is a list of methods in alphabetical order colored according to the method\n+coverage status. (Please note that VM method signatures are used). Clicking on a method name takes to the first\n+line of the source code corresponding to this method.<\/p>\n+<p>Following that there is line coverage information for the file.<\/p>\n+<p>Following that there is file source, colored according to the coverage status. Left to every line of code which\n+is a code line and is not new, there is one or more \"_\" clickable links which take to the method in the list at the top\n+    of the view. Mouse hovering over a \"_\" link brings a tooltip with the signature of the method.<\/p>\n+<\/body>\n+<\/html>\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/view\/jdk\/JDKLostKeptReport.html","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.codetools.jcov.report.view.jdk;\n+\n+import com.sun.tdk.jcov.instrument.DataRoot;\n+import openjdk.codetools.jcov.report.FileItems;\n+import openjdk.codetools.jcov.report.FileSet;\n+import openjdk.codetools.jcov.report.jcov.JCovCoverageComparison;\n+import openjdk.codetools.jcov.report.jcov.JCovMethodCoverageComparison;\n+import openjdk.codetools.jcov.report.source.SourceHierarchy;\n+import openjdk.codetools.jcov.report.source.SourceHierarchyUnion;\n+import openjdk.codetools.jcov.report.view.MultiHTMLReport;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+public class JDKLostKeptReport {\n+    private final static String USAGE = \"\"\"\n+        java ... %s \\\\\n+            <first coverage> <first source> \\\\\n+            <second coverage> <second source> \\\\\n+            <report directory>\n+        Where:\n+            (first|second)_coverage - JCov XML coverage files to compare\n+            (first|second)_source - JDK source hierarchies corresponding to the coverage files\n+            <report directory> - must not exist or be empty\n+    \"\"\".formatted(JDKLostKeptReport.class.getName());\n+    public static final String DESCRIPTION_HTML = \"report-description.html\";\n+    private final DataRoot oldCov;\n+    private final DataRoot newCov;\n+    private final SourceHierarchy oldSource;\n+    private final SourceHierarchy newSource;\n+    private final Path reportDir;\n+    private final BiFunction<Boolean, Boolean, FileItems.Quality> coloring;\n+    private final JCovMethodCoverageComparison items;\n+    private final JCovCoverageComparison comparison;\n+\n+    public JDKLostKeptReport(DataRoot oldCov, DataRoot newCov,\n+                             SourceHierarchy oldSource, SourceHierarchy newSource,\n+                             Path dir, BiFunction<Boolean, Boolean, FileItems.Quality> coloring,\n+                             JCovMethodCoverageComparison items, JCovCoverageComparison comparison) {\n+        this.oldCov = oldCov;\n+        this.newCov = newCov;\n+        this.oldSource = oldSource;\n+        this.newSource = newSource;\n+        reportDir = dir;\n+        this.coloring = coloring;\n+        this.items = items;\n+        this.comparison = comparison;\n+    }\n+\n+    public void report() throws Exception {\n+        try {\n+            DataRoot[] coverage = new DataRoot[] {oldCov, newCov};\n+            var noSourceClasses = new HashSet<String>();\n+            var classes = coverage[1].getClasses().stream()\n+                    .map(dc -> {\n+                        var cn = dc.getFullname();\n+                        cn = cn.contains(\"$\") ? cn.substring(0, cn.indexOf(\"$\")) : cn;\n+                        if (!noSourceClasses.contains(cn)) {\n+                            var res = newSource.toFile(cn.replace('.', '\/') + \".java\");\n+                            if (res == null) noSourceClasses.add(cn);\n+                            return res;\n+                        } return null;\n+                    })\n+                    .filter(c -> c != null)\n+                    .collect(Collectors.toSet());\n+            noSourceClasses.stream().sorted().forEach(cn -> System.err.println(\"No source file for \" + cn));\n+            var reportLegenLink = \"<a style=\\\"float:right\\\" href=\\\"\"+DESCRIPTION_HTML +\"\\\">What am I looking at?<\/a>\";\n+            var report = new MultiHTMLReport.Builder().setItems(items)\n+                    .setCoverage(comparison)\n+                    .setFolderHeader(s -> \"<h1>Lost\/kept coverage<\/h1>\" + reportLegenLink)\n+                    .setFileHeader(s -> \"<h1>Lost\/kept coverage<\/h1>\" + reportLegenLink)\n+                    .setTitle(\"Lost\/kept method coverage\")\n+                    .setSource(newSource)\n+                    .setFiles(new FileSet(classes))\n+                    .report();\n+            report.report(reportDir);\n+            MultiHTMLReport.copyToReport(JDKLostKeptReport.class, \"JDKLostKeptReport.html\",\n+                    DESCRIPTION_HTML, reportDir);\n+        } catch (Exception e) {\n+            System.err.println(USAGE);\n+            throw e;\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            long start = System.currentTimeMillis();\n+            Builder builder = new Builder()\n+                    .oldSource(jdkSourceHierarchy(args[1]))\n+                    .newSource(jdkSourceHierarchy(args[3]))\n+                    .dir(Path.of(args[4]));\n+            builder.oldCov(DataRoot.read(args[0])).newCov(DataRoot.read(args[2]));\n+            builder.items(new JCovMethodCoverageComparison(\n+                    builder.oldCov, builder.newCov,\n+                    f -> builder.newSource.toFile(f)));\n+            builder.comparison(new JCovCoverageComparison(\n+                    builder.oldCov, builder.oldSource,\n+                    builder.newCov, builder.newSource));\n+            builder.report().report();\n+         } catch (Exception e) {\n+            System.err.println(USAGE);\n+            throw e;\n+        }\n+    }\n+\n+    public static SourceHierarchy jdkSourceHierarchy(String description) {\n+        var roots = new ArrayList<SourceHierarchy>();\n+        var names = new HashMap<SourceHierarchy, Path>();\n+        Arrays.stream(description.split(\":\")).forEach(sp -> {\n+            String path;\n+            String name;\n+            int nameIndex = sp.indexOf(\"=\");\n+            if(nameIndex > -1) {\n+                path = sp.substring(0, nameIndex);\n+                name = sp.substring(nameIndex + 1);\n+            } else {\n+                name = null;\n+                path = sp;\n+            }\n+            SourceHierarchy sh = JDKDiffCoverageReport.jdkSource(path);\n+            roots.add(sh);\n+            if (name != null) names.put(sh, Path.of(name));\n+        });\n+        return new SourceHierarchyUnion(roots, names);\n+    }\n+\n+    public static class Builder {\n+        private DataRoot oldCov;\n+        private DataRoot newCov;\n+        private SourceHierarchy oldSource;\n+        private SourceHierarchy newSource;\n+        private Path dir;\n+        private JCovMethodCoverageComparison items;\n+        JCovCoverageComparison comparison;\n+        private BiFunction<Boolean, Boolean, FileItems.Quality> coloring;\n+\n+        public DataRoot oldCov() {\n+            return oldCov;\n+        }\n+\n+        public DataRoot newCov() {\n+            return newCov;\n+        }\n+\n+        public SourceHierarchy oldSource() {\n+            return oldSource;\n+        }\n+\n+        public SourceHierarchy newSource() {\n+            return newSource;\n+        }\n+\n+        public Builder oldCov(DataRoot cov) {\n+            this.oldCov = cov;\n+            return this;\n+        }\n+\n+        public Builder coloring(BiFunction<Boolean, Boolean, FileItems.Quality> coloring) {\n+            this.coloring = coloring;\n+            return this;\n+        }\n+\n+        public Builder newCov(DataRoot cov) {\n+            this.newCov = cov;\n+            return this;\n+        }\n+\n+        public Builder oldSource(SourceHierarchy source) {\n+            this.oldSource = source;\n+            return this;\n+        }\n+\n+        public Builder newSource(SourceHierarchy source) {\n+            this.newSource = source;\n+            return this;\n+        }\n+\n+        public Builder dir(Path dir) {\n+            this.dir = dir;\n+            return this;\n+        }\n+\n+        public Builder items(JCovMethodCoverageComparison items) {\n+            this.items = items;\n+            return this;\n+        }\n+\n+        public Builder comparison(JCovCoverageComparison comparison) {\n+            this.comparison = comparison;\n+            return this;\n+        }\n+\n+        public JDKLostKeptReport report() {\n+            return new JDKLostKeptReport(oldCov, newCov, oldSource, newSource, dir, coloring, items, comparison);\n+        }\n+    }\n+}\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/view\/jdk\/JDKLostKeptReport.java","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-        if (((' '+thisTbl.className+' ').indexOf(\"report\") != -1) && (thisTbl.id)) {\n+        if (((' '+thisTbl.className+' ').indexOf(\"sortable\") != -1) && (thisTbl.id)) {\n","filename":"plugins\/coverage_reports\/src\/openjdk\/codetools\/jcov\/report\/view\/sorttable.js","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/classes\/com\/sun\/tdk\/jcov\/report\/html\/resources\/sorttable.js","status":"copied"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.codetools.jcov.report.commandline;\n+\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class CommandLineTest {\n+    CommandLine commandLine;\n+    List<Option> options;\n+    List<Parameter> parameters;\n+    @Test\n+    void before() {\n+        options = List.of(\n+                new Option.Builder().option(\"-a\").name(\"A\").description(\"The A\").optional(false).create(),\n+                new Option.Builder().option(\"-b\").name(\"B\").description(\"The B\").optional(true).create()\n+        );\n+        parameters = List.of(\n+                new Parameter(\"first\", \"The first\"),\n+                new Parameter(\"second\", \"The second\")\n+        );\n+        commandLine = new CommandLine(options, parameters);\n+    }\n+\n+    @Test\n+    void usage() {\n+        assertEquals(commandLine.usageLine(), \"-a A [-b B] first second\");\n+        assertEquals(commandLine.usageList(\"  \"), \"  A: The A\\n  B: The B\\n  first: The first\\n  second: The second\");\n+    }\n+\n+    @Test\n+    void parseFull() {\n+        var parsed = commandLine.parse(new String[] {\n+                options.get(0).option(), \"a\",\n+                options.get(1).option(), \"b\",\n+                \"c\", \"d\"});\n+        assertEquals(parsed.get(options.get(0)), \"a\");\n+        assertEquals(parsed.get(options.get(1)), \"b\");\n+        assertEquals(parsed.parameters().size(), parameters.size());\n+        assertEquals(parsed.parameters().get(0), \"c\");\n+        assertEquals(parsed.parameters().get(1), \"d\");\n+    }\n+\n+    @Test\n+    void missingOptOpt() {\n+        var parsed = commandLine.parse(new String[] {\n+                options.get(0).option(), \"a\",\n+                \"c\", \"d\"});\n+        assertEquals(parsed.get(options.get(0)), \"a\");\n+        assertEquals(parsed.get(options.get(1)), null);\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    void missingMandatoryOpt() {\n+        commandLine.parse(new String[] {\n+                options.get(1).option(), \"b\",\n+                \"c\", \"d\"});\n+    }\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    void missingParams() {\n+        commandLine.parse(new String[] {\n+                options.get(0).option(), \"a\",\n+                \"c\"});\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    void noParams() {\n+        commandLine.parse(new String[] {options.get(0).option(), \"a\"});\n+    }\n+\n+}\n","filename":"plugins\/coverage_reports\/test\/openjdk\/codetools\/jcov\/report\/commandline\/CommandLineTest.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -101,17 +101,14 @@\n-        new TextReport(new SourcePath(src, src.resolve(\"src\")),\n-                files,\n-                file -> {\n-                    var res = new ArrayList<CoveredLineRange>();\n-                    var line = 0;\n-                    var chunkSize = 1;\n-                    while (line < 10000) {\n-                        res.add(new CoveredLineRange(line, line + chunkSize - 1, Coverage.UNCOVERED));\n-                        line += chunkSize;\n-                        res.add(new CoveredLineRange(line, line + chunkSize - 1, Coverage.COVERED));\n-                        line += chunkSize;\n-                        line += chunkSize;\n-                    }\n-                    return res;\n-                },\n-                \"ObjectInputStream coverage\",\n-                filter).report(report);\n+        new TextReport.Builder().source(new SourcePath(src, src.resolve(\"src\"))).files(files).coverage(file -> {\n+            var res = new ArrayList<CoveredLineRange>();\n+            var line = 0;\n+            var chunkSize = 1;\n+            while (line < 10000) {\n+                res.add(new CoveredLineRange(line, line + chunkSize - 1, Coverage.UNCOVERED));\n+                line += chunkSize;\n+                res.add(new CoveredLineRange(line, line + chunkSize - 1, Coverage.COVERED));\n+                line += chunkSize;\n+                line += chunkSize;\n+            }\n+            return res;\n+        }).header(\"ObjectInputStream coverage\").filter(filter).report()\n+                .report(report);\n@@ -119,1 +116,1 @@\n-        assertTrue(reportLines.contains(\"src\/ObjectInputStream.java 1\/2\"));\n+        assertTrue(reportLines.contains(\"src\/ObjectInputStream.java 50.00%(1\/2)\"));\n","filename":"plugins\/coverage_reports\/test\/openjdk\/codetools\/jcov\/report\/filter\/GitDifFilterTest.java","additions":15,"deletions":18,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.codetools.jcov.report.filter;\n+\n+import openjdk.codetools.jcov.report.LineRange;\n+import openjdk.codetools.jcov.report.source.SourceHierarchy;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class UnchangedCodeFilterTest {\n+    public static final String FILE_1 = \"file1\";\n+    SourceHierarchy oldSource = new SourceHierarchy() {\n+        @Override\n+        public List<String> readFile(String file) throws IOException {\n+            return file.equals(FILE_1) ? List.of(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\") : List.of();\n+        }\n+\n+        @Override\n+        public String toClassFile(String file) {\n+            return null;\n+        }\n+\n+        @Override\n+        public String toFile(String classFileName) {return classFileName;}\n+    };\n+    Function<String, List<UnchangedCodeFilter.NamedLineRange>> oldParts = (file) -> {\n+        return file.equals(FILE_1) ? List.of(\n+                new UnchangedCodeFilter.NamedLineRange(\"12\", 1, 2),\n+                new UnchangedCodeFilter.NamedLineRange(\"34\", 3, 4),\n+                new UnchangedCodeFilter.NamedLineRange(\"56\", 5, 6)\n+        ) : List.of();\n+    };\n+    SourceHierarchy newSource = new SourceHierarchy() {\n+        @Override\n+        public List<String> readFile(String file) throws IOException {\n+            return file.equals(FILE_1) ? List.of(\"\", \"1\", \"3\", \"4\", \"4\", \"5\", \"6\") : List.of();\n+        }\n+\n+        @Override\n+        public String toClassFile(String file) {\n+            return null;\n+        }\n+\n+        @Override\n+        public String toFile(String classFileName) {return classFileName;}\n+    };\n+    Function<String, List<UnchangedCodeFilter.NamedLineRange>> newParts = (file) -> {\n+        return file.equals(FILE_1) ? List.of(\n+                new UnchangedCodeFilter.NamedLineRange(\"12\", 2, 3),\n+                new UnchangedCodeFilter.NamedLineRange(\"34\", 4, 5),\n+                new UnchangedCodeFilter.NamedLineRange(\"56\", 6, 7)\n+        ) : List.of();\n+    };\n+    @Test\n+    void test() {\n+        var filter = new UnchangedCodeFilter(oldSource, oldParts, newSource, newParts);\n+        var ranges = filter.ranges(FILE_1);\n+        assertEquals(ranges.size(), 2);\n+        assertEquals(ranges.get(0).toString(), \"[2,2]\");\n+        assertEquals(ranges.get(1).toString(), \"[6,7]\");\n+    }\n+}\n","filename":"plugins\/coverage_reports\/test\/openjdk\/codetools\/jcov\/report\/filter\/UnchangedCodeFilterTest.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n-import openjdk.codetools.jcov.report.Coverage;\n@@ -29,1 +28,0 @@\n-import openjdk.codetools.jcov.report.LineRange;\n@@ -33,0 +31,1 @@\n+import openjdk.codetools.jcov.report.source.SourceHierarchy;\n@@ -37,0 +36,1 @@\n+import java.nio.file.Path;\n@@ -38,1 +38,0 @@\n-import java.util.Map;\n@@ -49,1 +48,13 @@\n-        coverage = new JCovLineCoverage(DataRoot.read(GitDifFilterTest.cp(xmlName).toString()));\n+        coverage = new JCovLineCoverage(DataRoot.read(GitDifFilterTest.cp(xmlName).toString()), new SourceHierarchy() {\n+            @Override\n+            public List<String> readFile(String file) throws IOException {\n+                return null;\n+            }\n+\n+            @Override\n+            public String toClassFile(String file) {\n+                return file.substring(0, file.lastIndexOf(\".java\"));\n+            }\n+            @Override\n+            public String toFile(String classFileName) {return classFileName;}\n+        });\n","filename":"plugins\/coverage_reports\/test\/openjdk\/codetools\/jcov\/report\/jcov\/JCovLoadTest.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import openjdk.codetools.jcov.report.source.SourceHierarchy;\n@@ -34,0 +35,1 @@\n+import openjdk.codetools.jcov.report.view.MultiHTMLReport;\n@@ -35,1 +37,0 @@\n-import openjdk.codetools.jcov.report.view.TextReport;\n@@ -38,0 +39,1 @@\n+import openjdk.codetools.jcov.report.view.TextReport;\n@@ -48,0 +50,1 @@\n+import static java.util.regex.Pattern.matches;\n@@ -55,0 +58,1 @@\n+    private SourceHierarchy source;\n@@ -65,1 +69,2 @@\n-        rawCoverage = new JCovLineCoverage(DataRoot.read(GitDifFilterTest.cp(xmlName).toString()));\n+        source = new SourcePath(src, src.resolve(\"src\"));\n+        rawCoverage = new JCovLineCoverage(DataRoot.read(GitDifFilterTest.cp(xmlName).toString()), source);\n@@ -68,1 +73,1 @@\n-    void report() throws Exception {\n+    void txtReport() throws Exception {\n@@ -72,5 +77,6 @@\n-        new TextReport(new SourcePath(src, src.resolve(\"src\")),\n-                files,\n-                rawCoverage,\n-                \"negative array size fix\",\n-                new ContextFilter(filter, 10)).report(textReport);\n+        new TextReport.Builder()\n+                .source(new SourcePath(src, src.resolve(\"src\")))\n+                .files(files)\n+                .coverage(rawCoverage).header(\"negative array size fix\")\n+                .filter(new ContextFilter(filter, 10)).report()\n+                .report(textReport);\n@@ -85,0 +91,5 @@\n+    }\n+    @Test\n+    void singleReport() throws Exception {\n+        String diffPkg = \"\/\" + JCovReportTest.class.getPackageName().replace('.', '\/') + \"\/\";\n+        var filter = GitDiffFilter.parseDiff(GitDifFilterTest.cp(diffPkg + \"negative_array_size.diff\")\/*, Set.of(\"src\")*\/);\n@@ -86,7 +97,3 @@\n-        new SingleHTMLReport(new SourcePath(src, src.resolve(\"src\")),\n-                files,\n-                rawCoverage,\n-                \"negative array size fix\",\n-                \"negative array size fix\",\n-                filter,\n-                new ContextFilter(filter, 10)).report(htmlReport);\n+        new SingleHTMLReport.Builder().source(new SourcePath(src, src.resolve(\"src\"))).files(files)\n+                .coverage(rawCoverage).title(\"negative array size fix\").header(\"negative array size fix\")\n+                .highlight(filter).include(new ContextFilter(filter, 10)).report().report(htmlReport);\n@@ -94,1 +101,1 @@\n-        reportLines = Files.readAllLines(htmlReport);\n+        var reportLines = Files.readAllLines(htmlReport);\n@@ -101,2 +108,20 @@\n-        assertTrue(reportLines.contains(\"<a class=\\\"covered\\\">2142:             throw new StreamCorruptedException(\\\"Array length is negative\\\");<\/a>\"));\n-\n+    }\n+    @Test\n+    void multiReport() throws Exception {\n+        String diffPkg = \"\/\" + JCovReportTest.class.getPackageName().replace('.', '\/') + \"\/\";\n+        var filter = GitDiffFilter.parseDiff(GitDifFilterTest.cp(diffPkg + \"negative_array_size.diff\")\/*, Set.of(\"src\")*\/);\n+        Path multiHtmlReport = Files.createTempDirectory(\"report\");\n+        new MultiHTMLReport.Builder().setSource(new SourcePath(src, src.resolve(\"src\"))).setFiles(files)\n+                .setCoverage(rawCoverage).setTitle(\"negative array size fix\")\n+                .setFolderHeader(x -> \"negative array size fix\")\n+                .setFileHeader(x -> \"negative array size fix\")\n+                .setHighlight(filter).setInclude(new ContextFilter(filter, 10)).report().report(multiHtmlReport);\n+        System.out.println(\"Report: \" + multiHtmlReport);\n+        var reportLines = Files.readAllLines(multiHtmlReport.resolve(\"index.html\"));\n+        reportLines = Files.readAllLines(multiHtmlReport.resolve(\"src_java_io_ObjectInputStream.java.html\"));\n+        assertTrue(reportLines.stream().anyMatch(s -> matches(\".*1454.*class=\\\"highlight\\\".*@throws StreamCorruptedException if arrayLength is negative.*\", s)));\n+        assertTrue(reportLines.stream().anyMatch(s -> matches(\".*1457.*class=\\\"highlight\\\".*private void checkArray.*\", s)));\n+        assertTrue(reportLines.stream().anyMatch(s -> matches(\".*1463.*class=\\\"covered\\\".*throw new StreamCorruptedException.*\", s)));\n+        assertTrue(reportLines.stream().anyMatch(s -> matches(\".*2141.*class=\\\"covered\\\".*\", s)));\n+        assertTrue(reportLines.stream().anyMatch(s -> matches(\".*2142.*class=\\\"covered\\\".*throw new StreamCorruptedException.*\", s)));\n+        assertTrue(reportLines.stream().anyMatch(s -> matches(\".*2143.*lass=\\\"highlight\\\".*\", s)));\n@@ -113,5 +138,1 @@\n-        new TextReport(new SourcePath(src, src.resolve(\"src\")),\n-                files,\n-                rawCoverage,\n-                \"negative array size fix\",\n-                filter).report(textReport);\n+        new TextReport.Builder().source(source).files(files).coverage(rawCoverage).header(\"negative array size fix\").filter(filter).report().report(textReport);\n@@ -121,1 +142,0 @@\n-    \/\/2987,3838\n","filename":"plugins\/coverage_reports\/test\/openjdk\/codetools\/jcov\/report\/jcov\/JCovReportTest.java","additions":45,"deletions":25,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,335 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.codetools.jcov.report.jcov;\n+\n+import com.sun.tdk.jcov.Instr;\n+import com.sun.tdk.jcov.data.FileFormatException;\n+import com.sun.tdk.jcov.instrument.DataRoot;\n+import openjdk.codetools.jcov.report.CoveredLineRange;\n+import openjdk.codetools.jcov.report.FileCoverage;\n+import openjdk.codetools.jcov.report.FileItems;\n+import openjdk.codetools.jcov.report.FileSet;\n+import openjdk.codetools.jcov.report.source.SourcePath;\n+import openjdk.codetools.jcov.report.view.MultiHTMLReport;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.StandardJavaFileManager;\n+import javax.tools.ToolProvider;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import static org.testng.Assert.*;\n+\n+public class LostKeptTest {\n+    static final String STILL_EXISTS_JAVA_FILE = \"p\/a\/StillExists.java\";\n+    List<Map<String, Map<String, String>>> classes = List.of(\n+        Map.of(\"src0\",\n+            Map.of(\n+                STILL_EXISTS_JAVA_FILE, \"\"\"\n+        package p.a;\n+        public class StillExists {\n+            public static void still_covered_same_code() {\n+                System.out.println(\"still_covered_same_code\");\n+            }\n+            public static void still_covered_code_added() {\n+                System.out.println(\"still_covered_code_added\");\n+            }\n+            public static void still_covered_code_changed() {\n+                System.out.println(\"still_covered_code_changed\");\n+            }\n+            public static void still_uncovered_same_code() {\n+                System.out.println(\"still_uncovered_same_code\");\n+            }\n+            public static void lost_coverage() {\n+                System.out.println(\"lost_coverage\");\n+            }\n+            public static void got_coverage() {\n+                System.out.println(\"got_coverage\");\n+            }\n+            public static void removed() {\n+                System.out.println(\"removed\");\n+            }\n+            public static void main(String[] argv) {\n+                StillExists.still_covered_same_code();\n+                StillExists.still_covered_code_added();\n+                StillExists.still_covered_code_changed();\n+                StillExists.lost_coverage();\n+                StillExists.removed();\n+                StillExists.Inner.inner_lost_coverage();\n+                p.b.Removed.b();\n+            }\n+            public static interface Inner {\n+                public static void inner_lost_coverage() {\n+                    System.out.println(\"inner_lost_coverage\");\n+                }\n+                public static void inner_got_coverage() {\n+                    System.out.println(\"inner_got_coverage\");\n+                }\n+            }\n+        }\n+        \"\"\",\n+        \"p\/b\/Removed.java\", \"\"\"\n+        package p.b;\n+        public class Removed {\n+            public static void b() {System.out.println(\"b\");}\n+        }\n+        \"\"\"),\n+            \"src1\",\n+            Map.of(\"p\/d\/EmptyOuter.java\", \"\"\"\n+        package p.d;\n+        public interface EmptyOuter {\n+            public static class FullInner {\n+                public void method() {};\n+            }\n+        }\n+        \"\"\")),\n+        Map.of(\"src0\",\n+            Map.of(\n+                STILL_EXISTS_JAVA_FILE, \"\"\"\n+        package p.a;\n+        public class StillExists {\n+            public enum TYPE {ELEM_1, ELEM_2};\n+            public static void still_covered_same_code() {\n+                System.out.println(\"still_covered_same_code\");\n+            }\n+            public static void still_covered_code_added() {\n+                System.out.println(\"still_covered_code_added\");\n+                System.out.println(\"added code\");\n+            }\n+            public static void still_covered_code_changed() {\n+                System.out.println(\"changed code\");\n+            }\n+            public static void still_uncovered_same_code() {\n+                System.out.println(\"still_uncovered_same_code\");\n+            }\n+            public static void lost_coverage() {\n+                System.out.println(\"lost_coverage\");\n+            }\n+            public static void got_coverage() {\n+                System.out.println(\"got_coverage\");\n+            }\n+            public static void added() {\n+                System.out.println(\"added\");\n+            }\n+            public static TYPE type = TYPE.ELEM_1;\n+            public static void main(String[] argv) {\n+                StillExists.still_covered_same_code();\n+                StillExists.still_covered_code_added();\n+                StillExists.still_covered_code_changed();\n+                StillExists.got_coverage();\n+                StillExists.added();\n+                StillExists.Inner.inner_got_coverage();\n+                p.c.Added.c();\n+            }\n+            public static class Inner {\n+                public static void inner_lost_coverage() {\n+                    System.out.println(\"inner_lost_coverage\");\n+                }\n+                public static void inner_got_coverage() {\n+                    System.out.println(\"inner_got_coverage\");\n+                }\n+            }\n+        }\n+        \"\"\",\n+        \"p\/c\/Added.java\", \"\"\"\n+        package p.c;\n+        public class Added {\n+            public static void c() {System.out.println(\"c\");}\n+        }\n+        \"\"\"),\n+        \"src1\",\n+        Map.of(\"p\/d\/EmptyOuter.java\", \"\"\"\n+        package p.d;\n+        public interface EmptyOuter {\n+            public static class FullInner {\n+                public void method() {};\n+            }\n+        }\n+        \"\"\")));\n+    Path[] instrumentedDirs = new Path[2];\n+    Path wd;\n+    List<Path>[] sourceDirs = new List[2];\n+    Path[] repoDirs = new Path[2];\n+    JCovMethodCoverageComparison items;\n+    SourcePath newSource;\n+    DataRoot newCoverage, oldCoverage;\n+    private FileSet files;\n+\n+    @BeforeMethod\n+    public void setup() throws IOException, InterruptedException, FileFormatException {\n+        wd = Files.createTempDirectory(\"lost_found_\");\n+        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null);\n+        for (int i = 0; i < 2; i++) {\n+            var repo = wd.resolve(\"source_\" + i);\n+            repoDirs[i] = repo;\n+            sourceDirs[i] = new ArrayList<>();\n+            for (var src : classes.get(i).keySet()) {\n+                List<File> javaFiles = new ArrayList<>();\n+                var sourceDir = repo.resolve(src);\n+                sourceDirs[i].add(sourceDir);\n+                for (var f : classes.get(i).get(src).keySet()) {\n+                    var dirName = f.substring(0, f.lastIndexOf('\/'));\n+                    var fileName = f.substring(f.lastIndexOf('\/') + 1);\n+                    var packageDir = repo.resolve(src).resolve(dirName);\n+                    Files.createDirectories(packageDir);\n+                    var javaFile = packageDir.resolve(fileName);\n+                    Files.write(javaFile, List.of(classes.get(i).get(src).get(f)));\n+                    javaFiles.add(javaFile.toFile());\n+                }\n+                Iterable<? extends JavaFileObject> cu = fileManager.getJavaFileObjectsFromFiles(javaFiles);\n+                compiler.getTask(null, fileManager, null, null, null, cu).call();\n+            }\n+        }\n+        \/\/instrument\n+        for (int i = 0; i < 2; i++) {\n+            var instrumented = wd.resolve(\"instrumented_\" + i);\n+            instrumentedDirs[i] = instrumented;\n+            var command = new ArrayList<String>();\n+            command.addAll(List.of(Path.of(System.getProperty(\"java.home\")).resolve(\"bin\").resolve(\"java\").toString(),\n+                    \"-cp\", System.getProperty(\"java.class.path\"),\n+                    Instr.class.getName(),\n+                    \"-rt\", findRT(),\n+                    \"-t\", repoDirs[i].resolve(\"template.xml\").toString(),\n+                    \"-o\", instrumented.toString()));\n+            command.addAll(sourceDirs[i].stream().map(Path::toString).collect(Collectors.toList()));\n+            assertEquals(0, new ProcessBuilder(command).inheritIO().start().waitFor());\n+        }\n+        \/\/run\n+        for (int i = 0; i < 2; i++) {\n+            Files.move(repoDirs[i].resolve(\"template.xml\"), instrumentedDirs[i].resolve(\"template.xml\"));\n+\n+            assertEquals(0, new ProcessBuilder(\n+                    Path.of(System.getProperty(\"java.home\")).resolve(\"bin\").resolve(\"java\").toString(),\n+                    \"-cp\", instrumentedDirs[i].toString() + System.getProperty(\"path.separator\") + System.getProperty(\"java.class.path\"),\n+                    \"p.a.StillExists\").inheritIO().directory(instrumentedDirs[i].toFile()).start().waitFor());\n+        }\n+        newCoverage = DataRoot.read(instrumentedDirs[1].resolve(\"result.xml\").toString());\n+        oldCoverage = DataRoot.read(instrumentedDirs[0].resolve(\"result.xml\").toString());\n+        newSource = new SourcePath(repoDirs[1], sourceDirs[1]);\n+        items = new JCovMethodCoverageComparison(\n+                oldCoverage,\n+                newCoverage, f -> newSource.toFile(f));\n+        files = new FileSet(classes.get(1).entrySet().stream()\n+                .flatMap(e -> e.getValue().keySet().stream().map(f -> e.getKey() + \"\/\" + f))\n+                .collect(Collectors.toSet()));\n+    }\n+    private String findRT() {\n+        return Arrays.stream(System.getProperty(\"java.class.path\").split(\":\"))\n+                .filter(p -> p.endsWith(\"jcov_file_saver.jar\")).findAny().get();\n+    }\n+    private FileItems.FileItem find(String clss, String method) {\n+        return items.items(newSource.toFile(clss)).stream().filter(i -> i.item().equals(method + \"()V\")).findAny().get();\n+    }\n+    @Test\n+    void testItems() {\n+        assertEquals(find(STILL_EXISTS_JAVA_FILE, \"still_covered_same_code\").quality(), FileItems.Quality.GOOD);\n+        assertEquals(find(STILL_EXISTS_JAVA_FILE, \"still_covered_code_added\").quality(), FileItems.Quality.GOOD);\n+        assertEquals(find(STILL_EXISTS_JAVA_FILE, \"still_uncovered_same_code\").quality(), FileItems.Quality.SO_SO);\n+        assertEquals(find(STILL_EXISTS_JAVA_FILE, \"lost_coverage\").quality(), FileItems.Quality.BAD);\n+        assertEquals(find(STILL_EXISTS_JAVA_FILE, \"added\").quality(), FileItems.Quality.IGNORE);\n+        assertEquals(find(STILL_EXISTS_JAVA_FILE, \"Inner$inner_got_coverage\").quality(), FileItems.Quality.GOOD);\n+        assertEquals(find(STILL_EXISTS_JAVA_FILE, \"Inner$inner_lost_coverage\").quality(), FileItems.Quality.BAD);\n+        assertEquals(1, items.items(newSource.toFile(STILL_EXISTS_JAVA_FILE)).stream().filter(i -> i.item().\n+                equals(\"added()V\")).count());\n+        assertEquals(0, items.items(newSource.toFile(STILL_EXISTS_JAVA_FILE)).stream().filter(i -> i.item().\n+                equals(\"removed()V\")).count());\n+        assertNotNull(items.items(newSource.toFile(\"p\/c\/Added.java\")));\n+        assertNull(items.items(newSource.toFile(\"p\/b\/Removed.java\")));\n+        assertEquals(find(\"p\/c\/Added.java\", \"c\").quality(), FileItems.Quality.IGNORE);\n+    }\n+    @Test(dependsOnMethods = \"testItems\")\n+    void testReport() throws Exception {\n+        var reportDir = wd.resolve(\"report\");\n+        new MultiHTMLReport.Builder()\n+                .setItems(items)\n+                .setCoverage(new JCovLineCoverage(newCoverage, newSource))\n+                .setFolderHeader(s -> \"<h1>Lost\/kept method coverage<\/h1>\")\n+                .setFileHeader(s -> \"<h1>Lost\/kept method coverage<\/h1>\")\n+                .setTitle(\"Lost\/kept method coverage\")\n+                .setSource(newSource)\n+                .setFiles(files)\n+                .report().report(reportDir);\n+        var content = Files.readAllLines(reportDir.resolve(\"index.html\"));\n+        assertTrue(content.contains(\"Line coverage: 69.00%(24\/35)\"));\n+        assertTrue(content.stream().anyMatch(l ->\n+                Pattern.matches(\".*class=\\\"item_not_so_good\\\".*Lost.*2.*\", l)));\n+        content = Files.readAllLines(reportDir.resolve(\"src0_p_a_StillExists.java.html\"));\n+        assertTrue(content.stream().anyMatch(l ->\n+                Pattern.matches(\".*item_not_so_good.*lost_coverage\\\\(\\\\)V.*\", l)));\n+        assertTrue(content.stream().anyMatch(l ->\n+                Pattern.matches(\n+                        \".*href=\\\"#item_added\\\\(\\\\)V\\\".*class=\\\"item_ignore\\\".*title=\\\"added\\\\(\\\\)\" +\n+                                \"V.*System.out.println\\\\(\\\"added\\\"\\\\);.*\",\n+                        l)));\n+    }\n+    private List<CoveredLineRange> qualityAtLine(FileCoverage coverage, String file, int line) {\n+        var fileCov = coverage.ranges(file);\n+        return fileCov.stream().filter(lr -> lr.first() >= line && lr.last() <= line)\n+                .collect(Collectors.toList());\n+    }\n+    @Test(dependsOnMethods = \"testItems\")\n+    void testComparisonReport() throws Exception {\n+        JCovCoverageComparison comparison = new JCovCoverageComparison(\n+                oldCoverage, new SourcePath(repoDirs[0], sourceDirs[0]),\n+                newCoverage, newSource);\n+        testQuality(comparison, \"src0\/\" + STILL_EXISTS_JAVA_FILE, 5, 1, FileItems.Quality.GOOD);\n+        testQuality(comparison, \"src0\/\" + STILL_EXISTS_JAVA_FILE, 15, 1, FileItems.Quality.SO_SO);\n+        testQuality(comparison, \"src0\/\" + STILL_EXISTS_JAVA_FILE, 18, 1, FileItems.Quality.BAD);\n+        assertNull(comparison.ranges(\"src0\/p\/a\/Removed.java\"));\n+        assertEquals(comparison.ranges(\"src0\/p\/c\/Added.java\").size(), 0);\n+        var reportDir = wd.resolve(\"report\");\n+        var report = new MultiHTMLReport.Builder()\n+                .setItems(items)\n+                .setCoverage(comparison)\n+                .setFolderHeader(s -> \"<h1>Lost\/kept method coverage<\/h1>\")\n+                .setFileHeader(s -> \"<h1>Lost\/kept method coverage<\/h1>\")\n+                .setTitle(\"Lost\/kept method coverage\")\n+                .setSource(newSource)\n+                .setFiles(files)\n+                .report();\n+        report.report(reportDir);\n+        assertTrue(Files.exists(reportDir.resolve(\"src0_p_c_Added.java.html\")));\n+    }\n+\n+    void testQuality(FileCoverage coverage, String file, int line, int expectedSize,\n+                     FileItems.Quality... expected) {\n+        var lineCoverage = qualityAtLine(coverage, file, line);\n+        assertEquals(lineCoverage.size(), expectedSize);\n+        if(expectedSize > 0)\n+            assertTrue(lineCoverage.stream().anyMatch(lr -> lr.coverage().quality() == expected[0]));\n+    }\n+}\n","filename":"plugins\/coverage_reports\/test\/openjdk\/codetools\/jcov\/report\/jcov\/LostKeptTest.java","additions":335,"deletions":0,"binary":false,"changes":335,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-import openjdk.codetools.jcov.report.CoveredLineRange;\n@@ -31,0 +30,1 @@\n+import openjdk.codetools.jcov.report.source.SourceHierarchy;\n@@ -35,0 +35,1 @@\n+import java.nio.file.Path;\n@@ -46,1 +47,13 @@\n-        coverage = new JCovLineCoverage(DataRoot.read(GitDifFilterTest.cp(xmlName).toString()));\n+        coverage = new JCovLineCoverage(DataRoot.read(GitDifFilterTest.cp(xmlName).toString()), new SourceHierarchy() {\n+            @Override\n+            public List<String> readFile(String file) throws IOException {\n+                return null;\n+            }\n+\n+            @Override\n+            public String toClassFile(String file) {\n+                return file.substring(0, file.indexOf(\".java\"));\n+            }\n+            @Override\n+            public String toFile(String classFileName) { return classFileName; }\n+        });\n","filename":"plugins\/coverage_reports\/test\/openjdk\/codetools\/jcov\/report\/jcov\/SameLineMethods.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.codetools.jcov.report.source;\n+\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class SourceHierarchyUnionTest {\n+    private static class SimpleSourceHierarchy implements SourceHierarchy {\n+        private final String file;\n+\n+        private SimpleSourceHierarchy(String file) {\n+            this.file = file;\n+        }\n+\n+        @Override\n+        public List<String> readFile(String file) throws IOException {\n+            return file.equals(this.file) ? List.of(this.file) : null;\n+        }\n+\n+        @Override\n+        public String toClassFile(String file) {\n+            return file.equals(this.file) ? file : null;\n+        }\n+\n+        @Override\n+        public String toFile(String classFileName) {\n+            return classFileName.equals(file) ? file : null;\n+        }\n+    }\n+    SourceHierarchy one = new SimpleSourceHierarchy(\"one\");\n+    SourceHierarchy two = new SimpleSourceHierarchy(\"two\");\n+    SourceHierarchy three = new SimpleSourceHierarchy(\"three\");\n+    SourceHierarchy testedObject = new SourceHierarchyUnion(List.of(one, two, three),\n+            Map.of(two, Path.of(\"a\"),\n+                    three, Path.of(\"b\/c\")));\n+    @Test\n+    void testHierarchy() throws IOException {\n+        assertEquals(testedObject.readFile(\"one\").get(0), \"one\");\n+        assertEquals(testedObject.readFile(\"a\/two\").get(0), \"two\");\n+        assertEquals(testedObject.readFile(\"b\/c\/three\").get(0), \"three\");\n+        assertEquals(testedObject.toClassFile(\"one\"), \"one\");\n+        assertEquals(testedObject.toClassFile(\"a\/two\"), \"two\");\n+        assertEquals(testedObject.toClassFile(\"b\/c\/three\"), \"three\");\n+        assertEquals(testedObject.toFile(\"one\"), \"one\");\n+        assertEquals(testedObject.toFile(\"two\"), \"a\/two\");\n+        assertEquals(testedObject.toFile(\"three\"), \"b\/c\/three\");\n+    }\n+}\n","filename":"plugins\/coverage_reports\/test\/openjdk\/codetools\/jcov\/report\/source\/SourceHierarchyUnionTest.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -67,1 +67,1 @@\n-                    public String toClass(String file) {\n+                    public String toClassFile(String file) {\n@@ -70,0 +70,5 @@\n+\n+                    @Override\n+                    public String toFile(String classFileName) {\n+                        return classFileName;\n+                    }\n@@ -95,1 +100,1 @@\n-                    public String toClass(String file) {\n+                    public String toClassFile(String file) {\n@@ -98,0 +103,2 @@\n+                    @Override\n+                    public String toFile(String classFileName) { return classFileName; }\n","filename":"plugins\/coverage_reports\/test\/openjdk\/codetools\/jcov\/report\/view\/CoverageCacheTest.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.codetools.jcov.report.view;\n+\n+import openjdk.codetools.jcov.report.Coverage;\n+import openjdk.codetools.jcov.report.CoveredLineRange;\n+import openjdk.codetools.jcov.report.FileCoverage;\n+import openjdk.codetools.jcov.report.FileItems;\n+import openjdk.codetools.jcov.report.FileSet;\n+import openjdk.codetools.jcov.report.LineRange;\n+import openjdk.codetools.jcov.report.filter.SourceFilter;\n+import openjdk.codetools.jcov.report.source.SourceHierarchy;\n+import openjdk.codetools.jcov.report.source.SourcePath;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.testng.Assert.assertTrue;\n+\n+public class MultiFilesReportTest {\n+    public static final String FILE_11 = \"dir1\/file1.java\";\n+    public static final String FILE_12 = \"dir1\/file2.java\";\n+    public static final String FILE_21 = \"dir2\/file1.java\";\n+    public static final String FILE_22 = \"dir2\/file2.java\";\n+    static SourceHierarchy source;\n+    static FileCoverage coverage;\n+    static Path reportFile;\n+    private static FileItems items;\n+\n+    public static Path createFiles() throws IOException {\n+        Path root = Files.createTempDirectory(\"source\");\n+        Files.createDirectories(root);\n+        for (var dir : List.of(\"dir1\", \"dir2\")) Files.createDirectories(root.resolve(dir));\n+        for (var file : List.of(FILE_11, FILE_12, FILE_21, FILE_22))\n+            Files.write(root.resolve(file),\n+                    List.of(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"0\").stream().map(s -> \"source line #\" + s)\n+                            .collect(Collectors.toList()));\n+        return root;\n+    }\n+    @BeforeClass\n+    static void init() throws IOException {\n+        Path root = createFiles();\n+        source = new SourcePath(root, root);\n+        coverage = new FileCoverage() {\n+            @Override\n+            public List<CoveredLineRange> ranges(String file) {\n+                return file.equals(FILE_11) ? List.of(\n+                        new CoveredLineRange(1, 1, Coverage.COVERED),\n+                        new CoveredLineRange(3, 4, Coverage.UNCOVERED),\n+                        new CoveredLineRange(6, 8, Coverage.COVERED)\n+                ) : List.of();\n+            }\n+        };\n+\n+        items = new FileItems() {\n+            @Override\n+            public List<FileItem> items(String file) {\n+                var res = new ArrayList<FileItems.FileItem>();\n+                res.add(new FileItems.FileItemImpl(\"item0\", List.of(new LineRange(1, 2)), Quality.GOOD));\n+                if (file.equals(FILE_22)) return  res;\n+                res.add(new FileItems.FileItemImpl(\"item1\", List.of(new LineRange(3, 4)), Quality.BAD));\n+                if (file.equals(FILE_21)) return  res;\n+                res.add(new FileItems.FileItemImpl(\"item2\", List.of(new LineRange(5, 6)), Quality.SO_SO));\n+                if (file.equals(FILE_12)) return  res;\n+                res.add(new FileItems.FileItemImpl(\"item3\", List.of(new LineRange(7, 8)), Quality.IGNORE));\n+                if (file.equals(FILE_11)) return  res;\n+                return null;\n+            }\n+\n+            @Override\n+            public String kind() {\n+                return \"Item\";\n+            }\n+\n+            @Override\n+            public Map<Quality, String> legend() {\n+                return Map.of(Quality.GOOD, \"green\", Quality.BAD, \"red\",\n+                        Quality.SO_SO, \"yellow\", Quality.IGNORE, \"grey\");\n+            }\n+\n+        };\n+        reportFile = Files.createTempDirectory(\"report\");\n+    }\n+    @Test\n+    void test() throws Exception {\n+        var fileSet = new FileSet(Set.of(FILE_11, FILE_12, FILE_21, FILE_22));\n+        SourceFilter filter = file -> List.of(\n+                new LineRange(1, 3),\n+                new LineRange(4, 4),\n+                new LineRange(6, 6),\n+                new LineRange(8, 8)\n+        );\n+        var report = new MultiHTMLReport.Builder().setSource(source).setFiles(fileSet)\n+                .setCoverage(coverage).setItems(items)\n+                .setTitle(\"TITLE\").setFolderHeader(s -> s.isEmpty() ? \"HEADER\" : \"FOLDER \" + s)\n+                .setInclude(filter)\n+                .setFileHeader(f -> \"FILE \" + f).report();\n+        report.report(reportFile);\n+        System.out.println(\"Report: \" + reportFile.toString());\n+        Path root = reportFile.resolve(\"index.html\");\n+        List<String> content = Files.readAllLines(root);\n+        assertTrue(content.contains(\"<title>TITLE<\/title>\"));\n+        assertTrue(content.contains(\"HEADER\"));\n+        assertTrue(content.stream().anyMatch(s -> s.contains(\"Line coverage:\") && s.contains(\"2\/3\")));\n+        content = Files.readAllLines(reportFile.resolve(\"dir1.html\"));\n+        assertTrue(content.contains(\"FOLDER dir1\"));\n+        assertTrue(content.contains(\"<p><a href=\\\"index.html\\\">root<\/a><a> \/ dir1<\/a><\/p>\"));\n+        content = Files.readAllLines(reportFile.resolve(FILE_11.replace('\/', '_') + \".html\"));\n+        assertTrue(content.contains(\"FILE dir1\/file1.java\"));\n+        assertTrue(content.stream().anyMatch(s -> s.contains(\"class=\\\"uncovered\\\"\") && s.contains(\"source line #4\")));\n+        assertTrue(content.stream().anyMatch(s -> s.contains(\"class=\\\"covered\\\"\") && s.contains(\"source line #6\")));\n+        assertTrue(content.contains(\"<p><a href=\\\"index.html\\\">root<\/a> \/ <a href=\\\"dir1.html\\\">dir1<\/a><a> \/ file1.java<\/a><\/p>\"));\n+    }\n+}\n","filename":"plugins\/coverage_reports\/test\/openjdk\/codetools\/jcov\/report\/view\/MultiFilesReportTest.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.codetools.jcov.report.view;\n+\n+import openjdk.codetools.jcov.report.Coverage;\n+import openjdk.codetools.jcov.report.CoveredLineRange;\n+import openjdk.codetools.jcov.report.FileCoverage;\n+import openjdk.codetools.jcov.report.FileItems;\n+import openjdk.codetools.jcov.report.FileSet;\n+import openjdk.codetools.jcov.report.LineRange;\n+import openjdk.codetools.jcov.report.filter.SourceFilter;\n+import openjdk.codetools.jcov.report.source.SourceHierarchy;\n+import openjdk.codetools.jcov.report.source.SourcePath;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class SingleFileReportTest {\n+    public static final String FILE_11 = \"dir1\/file1.java\";\n+    public static final String FILE_12 = \"dir1\/file2.java\";\n+    public static final String FILE_21 = \"dir2\/file1.java\";\n+    public static final String FILE_22 = \"dir2\/file2.java\";\n+    static SourceHierarchy source;\n+    static FileCoverage coverage;\n+    static Path reportFile;\n+    private static FileItems items;\n+\n+    public static Path createFiles() throws IOException {\n+        Path root = Files.createTempDirectory(\"source\");\n+        Files.createDirectories(root);\n+        for (var dir : List.of(\"dir1\", \"dir2\")) Files.createDirectories(root.resolve(dir));\n+        for (var file : List.of(FILE_11, FILE_12, FILE_21, FILE_22))\n+            Files.write(root.resolve(file),\n+                    List.of(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"0\").stream().map(s -> \"source line #\" + s)\n+                            .collect(Collectors.toList()));\n+        return root;\n+    }\n+    @BeforeClass\n+    static void init() throws IOException {\n+        Path root = createFiles();\n+        source = new SourcePath(root, root);\n+        coverage = file -> file.equals(FILE_11) ? List.of(\n+                new CoveredLineRange(1, 1, Coverage.COVERED),\n+                new CoveredLineRange(3, 4, Coverage.UNCOVERED),\n+                new CoveredLineRange(6, 8, Coverage.COVERED)\n+        ) : List.of();\n+        items = new FileItems() {\n+            @Override\n+            public List<FileItem> items(String file) {\n+                var res = new ArrayList<FileItems.FileItem>();\n+                res.add(new FileItems.FileItemImpl(\"item0\", List.of(new LineRange(0, 1)), Quality.GOOD));\n+                if (file.equals(SingleFileReportTest.FILE_11)) return res;\n+                res.add(new FileItems.FileItemImpl(\"item1\", List.of(new LineRange(2, 3)), Quality.BAD));\n+                if (file.equals(SingleFileReportTest.FILE_12)) return res;\n+                res.add(new FileItems.FileItemImpl(\"item2\", List.of(new LineRange(4, 5)), Quality.SO_SO));\n+                if (file.equals(SingleFileReportTest.FILE_21)) return res;\n+                res.add(new FileItems.FileItemImpl(\"item3\", List.of(new LineRange(6, 7)), Quality.IGNORE));\n+                if (file.equals(SingleFileReportTest.FILE_22)) return res;\n+                return null;\n+            }\n+\n+            @Override\n+            public String kind() {\n+                return \"Item\";\n+            }\n+\n+            @Override\n+            public Map<Quality, String> legend() {\n+                return null;\n+            }\n+        };\n+        reportFile = Files.createTempFile(\"report\", \".html\");\n+    }\n+    @Test\n+    void test() throws Exception {\n+        var fileSet = new FileSet(Set.of(FILE_11, FILE_12, FILE_21, FILE_22));\n+        SourceFilter filter = file -> List.of(\n+                new LineRange(2, 2),\n+                new LineRange(4, 4),\n+                new LineRange(6, 6),\n+                new LineRange(8, 8)\n+        );\n+        var report = new SingleHTMLReport.Builder().source(source).files(fileSet)\n+                .coverage(coverage).items(items)\n+                .title(\"TITLE\").header(\"<h1>HEADER<\/h1>\").highlight(filter)\n+                .include(filter).report();\n+        report.report(reportFile);\n+        System.out.println(\"Report: \" + reportFile.toString());\n+        List<String> content = Files.readAllLines(reportFile);\n+        assertTrue(content.contains(\"<title>TITLE<\/title>\"));\n+        assertTrue(content.contains(\"<h1>HEADER<\/h1>\"));\n+        assertTrue(content.stream().anyMatch(\"<tr><td><a href=\\\"#total\\\">total<\/a><\/td><td>50.00%(1\/2)<\/td><\/tr>\"::equals));\n+        assertTrue(content.stream().anyMatch(\"<a class=\\\"uncovered\\\">4: source line #4<\/a>\"::equals));\n+        assertTrue(content.stream().anyMatch(\"<a class=\\\"covered\\\">6: source line #6<\/a>\"::equals));\n+        assertTrue(content.contains(\"<tr><td><pre><a id=\\\"item_item3\\\" class=\\\"item_ignore\\\">item3<\/a><\/pre><\/td><\/tr>\"));\n+    }\n+}\n","filename":"plugins\/coverage_reports\/test\/openjdk\/codetools\/jcov\/report\/view\/SingleFileReportTest.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package openjdk.codetools.jcov.report.view;\n-\n-import openjdk.codetools.jcov.report.Coverage;\n-import openjdk.codetools.jcov.report.CoveredLineRange;\n-import openjdk.codetools.jcov.report.FileCoverage;\n-import openjdk.codetools.jcov.report.FileSet;\n-import openjdk.codetools.jcov.report.LineRange;\n-import openjdk.codetools.jcov.report.filter.SourceFilter;\n-import openjdk.codetools.jcov.report.source.SourceHierarchy;\n-import openjdk.codetools.jcov.report.source.SourcePath;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.Test;\n-\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.List;\n-import java.util.Set;\n-\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-\n-public class SingleFiletReportTest {\n-    public static final String FILE_11 = \"dir1\/file1.java\";\n-    public static final String FILE_12 = \"dir1\/file2.java\";\n-    public static final String FILE_21 = \"dir2\/file1.java\";\n-    public static final String FILE_22 = \"dir2\/file2.java\";\n-    static SourceHierarchy source;\n-    static FileCoverage coverage;\n-    static Path reportFile;\n-    public static Path createFiles() throws IOException {\n-        Path root = Files.createTempDirectory(\"source\");\n-        Files.createDirectories(root);\n-        for (var dir : List.of(\"dir1\", \"dir2\")) Files.createDirectories(root.resolve(dir));\n-        for (var file : List.of(FILE_11, FILE_12, FILE_21, FILE_22))\n-            Files.write(root.resolve(file), List.of(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"0\"));\n-        return root;\n-    }\n-    @BeforeClass\n-    static void init() throws IOException {\n-        Path root = createFiles();\n-        source = new SourcePath(root, root);\n-        coverage = new FileCoverage() {\n-            @Override\n-            public List<CoveredLineRange> ranges(String file) {\n-                return file.equals(FILE_11) ? List.of(\n-                        new CoveredLineRange(1, 1, Coverage.COVERED),\n-                        new CoveredLineRange(3, 4, Coverage.UNCOVERED),\n-                        new CoveredLineRange(6, 8, Coverage.COVERED)\n-                ) : List.of();\n-            }\n-        };\n-        reportFile = Files.createTempFile(\"report\", \".html\");\n-    }\n-    @Test\n-    void everyOdd() throws Exception {\n-        var fileSet = new FileSet(Set.of(FILE_11, FILE_12, FILE_21, FILE_22));\n-        SourceFilter filter = file -> List.of(\n-\/\/                new LineRange(0, 0),\n-                new LineRange(2, 2),\n-                new LineRange(4, 4),\n-                new LineRange(6, 6),\n-                new LineRange(8, 8)\n-        );\n-        var report = new SingleHTMLReport(source, fileSet,\n-                coverage, \"TITLE\", \"<h1>HEADER<\/h1>\", filter, filter);\n-        report.report(reportFile);\n-        System.out.println(\"Report: \" + reportFile.toString());\n-        List<String> content = Files.readAllLines(reportFile);\n-        assertTrue(content.contains(\"<title>TITLE<\/title>\"));\n-        assertTrue(content.contains(\"<h1>HEADER<\/h1>\"));\n-        assertTrue(content.stream().anyMatch(\"<tr><td><a href=\\\"#total\\\">total<\/a><\/td><td>1\/2<\/td><\/tr>\"::equals));\n-        assertTrue(content.stream().anyMatch(\"<a class=\\\"uncovered\\\">4: 4<\/a>\"::equals));\n-        assertTrue(content.stream().anyMatch(\"<a class=\\\"covered\\\">6: 6<\/a>\"::equals));\n-    }\n-}\n","filename":"plugins\/coverage_reports\/test\/openjdk\/codetools\/jcov\/report\/view\/SingleFiletReportTest.java","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -52,1 +52,1 @@\n-        Path root = SingleFiletReportTest.createFiles();\n+        Path root = SingleFileReportTest.createFiles();\n@@ -54,10 +54,5 @@\n-        coverage = new FileCoverage() {\n-            @Override\n-            public List<CoveredLineRange> ranges(String file) {\n-                return file.equals(SingleFiletReportTest.FILE_11) ? List.of(\n-                        new CoveredLineRange(1, 1, Coverage.COVERED),\n-                        new CoveredLineRange(3, 4, Coverage.UNCOVERED),\n-                        new CoveredLineRange(6, 8, Coverage.COVERED)\n-                ) : List.of();\n-            }\n-        };\n+        coverage = file -> file.equals(SingleFileReportTest.FILE_11) ? List.of(\n+                new CoveredLineRange(1, 1, Coverage.COVERED),\n+                new CoveredLineRange(3, 4, Coverage.UNCOVERED),\n+                new CoveredLineRange(6, 8, Coverage.COVERED)\n+        ) : List.of();\n@@ -74,3 +69,4 @@\n-        var files = new FileSet(Set.of(SingleFiletReportTest.FILE_11, SingleFiletReportTest.FILE_12,\n-                SingleFiletReportTest.FILE_21, SingleFiletReportTest.FILE_22));\n-        var report = new TextReport(source, files, coverage, \"HEADER\", filter);\n+        var files = new FileSet(Set.of(SingleFileReportTest.FILE_11, SingleFileReportTest.FILE_12,\n+                SingleFileReportTest.FILE_21, SingleFileReportTest.FILE_22));\n+        var report = new TextReport.Builder().source(source).files(files).coverage(coverage)\n+                .header(\"HEADER\").filter(filter).report();\n@@ -80,3 +76,3 @@\n-        assertTrue(content.stream().anyMatch(\"total 1\/2\"::equals));\n-        assertTrue(content.stream().anyMatch(\"4:-4\"::equals));\n-        assertTrue(content.stream().anyMatch(\"6:+6\"::equals));\n+        assertTrue(content.stream().anyMatch(\"total 50.00%(1\/2)\"::equals));\n+        assertTrue(content.stream().anyMatch(\"4:-source line #4\"::equals));\n+        assertTrue(content.stream().anyMatch(\"6:+source line #6\"::equals));\n","filename":"plugins\/coverage_reports\/test\/openjdk\/codetools\/jcov\/report\/view\/TextReportTest.java","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"}]}