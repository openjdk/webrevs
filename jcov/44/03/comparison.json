{"files":[{"patch":"@@ -37,1 +37,2 @@\n-  <property name=\"jcov.jar\" location=\"..\/..\/JCOV_BUILD\/jcov_3.0\/jcov.jar\"\/>\n+  <property name=\"jcov.jar.dir\" location=\"..\/..\/JCOV_BUILD\/jcov_3.0\"\/>\n+  <property name=\"jcov.classpath\" location=\"${jcov.jar.dir}\/jcov.jar\"\/>\n@@ -40,1 +41,1 @@\n-    <available file=\"${jcov.jar}\" property=\"jcov-jar-exists\"\/>\n+    <available file=\"${jcov.classpath}\" property=\"jcov-jar-exists\"\/>\n@@ -43,1 +44,5 @@\n-    <javac srcdir=\"${src}\" classpath=\"${jcov.jar}\" destdir=\"${classes}\"\/>\n+    <javac srcdir=\"${src}\" classpath=\"${jcov.classpath}\" destdir=\"${classes}\">\n+      <compilerarg value='--enable-preview'\/>\n+      <compilerarg value='--source'\/>\n+      <compilerarg value='22'\/>\n+    <\/javac>\n@@ -47,1 +52,5 @@\n-    <jar jarfile=\"${jar}\" basedir=\"${classes}\"\/>\n+     <jar jarfile=\"${jar}\" basedir=\"${classes}\"\/>\n+  <\/target>\n+\n+  <target name=\"dist\" depends=\"jar\">\n+    <copy file=\"${jar}\" todir=\"${jcov.jar.dir}\"\/>\n@@ -57,1 +66,5 @@\n-    <javac srcdir=\"${test}\" classpath=\"${classes}:${jcov.jar}:${testng.classpath}\" destdir=\"${test.classes}\"\/>\n+    <javac srcdir=\"${test}\" classpath=\"${classes}:${jcov.classpath}:${testng.classpath}\" destdir=\"${test.classes}\">\n+      <compilerarg value='--enable-preview'\/>\n+      <compilerarg value='--source'\/>\n+      <compilerarg value='22'\/>\n+    <\/javac>\n@@ -68,1 +81,2 @@\n-    <testng classpath=\"${classes}:${jcov.jar}:${test.classes}:${testng.classpath}\" outputDir=\"${test.results}\">\n+    <testng classpath=\"${classes}:${jcov.classpath}:${test.classes}:${testng.classpath}\" outputDir=\"${test.results}\">\n+      <jvmarg value='--enable-preview'\/>\n","filename":"plugins\/simple_methods_anc\/build.xml","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,6 +27,5 @@\n-import org.objectweb.asm.tree.AbstractInsnNode;\n-import org.objectweb.asm.tree.ClassNode;\n-import org.objectweb.asm.tree.InvokeDynamicInsnNode;\n-import org.objectweb.asm.tree.MethodInsnNode;\n-import org.objectweb.asm.tree.MethodNode;\n-\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.instruction.InvokeDynamicInstruction;\n+import java.lang.classfile.instruction.InvokeInstruction;\n@@ -35,1 +34,0 @@\n-import static java.util.Arrays.binarySearch;\n@@ -40,1 +38,1 @@\n-public class Delegators implements BiPredicate<ClassNode, MethodNode> {\n+public class Delegators implements BiPredicate<ClassModel, MethodModel> {\n@@ -55,1 +53,1 @@\n-     * @see Utils#isSimpleInstruction(int)\n+     * @see Utils#isSimpleInstruction(java.lang.classfile.Opcode)\n@@ -58,28 +56,5 @@\n-    public boolean test(ClassNode clazz, MethodNode m) {\n-        int index = 0;\n-        int opCode = -1;\n-        \/\/skip all instructions allowed to get values\n-        for(; index < m.instructions.size(); index++) {\n-            opCode = m.instructions.get(index).getOpcode();\n-            if(opCode >=0) {\n-                if (!isSimpleInstruction(opCode)) {\n-                    break;\n-                }\n-            }\n-        }\n-        \/\/that should be an invocation instruction\n-        if(!isInvokeInstruction(opCode)) {\n-            return false;\n-        }\n-        if(sameNameDelegationOnly) {\n-            \/\/check name\n-            AbstractInsnNode node = m.instructions.get(index);\n-            String name;\n-            if (node instanceof MethodInsnNode) {\n-                name = ((MethodInsnNode) node).name;\n-            } else if (node instanceof InvokeDynamicInsnNode) {\n-                name = ((InvokeDynamicInsnNode) node).name;\n-            } else {\n-                throw new IllegalStateException(\"Unknown node type: \" + node.getClass().getName());\n-            }\n-            if(!m.name.equals(name)) {\n+    public boolean test(ClassModel clazz, MethodModel m) {\n+        if (m.code().isPresent()) {\n+            var iter = new InstructionIterator(m.code().get());\n+            Instruction next = iter.next(i -> !isSimpleInstruction(i.opcode()));\n+            if (next == null || !isInvokeInstruction(next.opcode()))\n@@ -87,0 +62,8 @@\n+            if(sameNameDelegationOnly) {\n+                String name = switch (next) {\n+                    case InvokeInstruction ii -> ii.name().toString();\n+                    case InvokeDynamicInstruction idi -> idi.name().toString();\n+                    default -> throw new IllegalStateException(STR.\"Unknown node type: \\{next.getClass().getName()}\");\n+                };\n+                if (!m.methodName().toString().equals(name))\n+                    return false;\n@@ -88,0 +71,3 @@\n+            return isReturnInstruction(iter.next(i -> true).opcode());\n+        } else {\n+            return false;\n@@ -89,9 +75,0 @@\n-        \/\/scroll to next instruction\n-        for(index++; index < m.instructions.size(); index++) {\n-            opCode = m.instructions.get(index).getOpcode();\n-            if(opCode >=0) {\n-                break;\n-            }\n-        }\n-        \/\/that should be a return instruction\n-        return isReturnInstruction(opCode);\n","filename":"plugins\/simple_methods_anc\/src\/openjdk\/jcov\/filter\/simplemethods\/Delegators.java","additions":24,"deletions":47,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,4 @@\n-import org.objectweb.asm.tree.ClassNode;\n-import org.objectweb.asm.tree.MethodNode;\n-\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.Opcode;\n@@ -32,1 +33,1 @@\n-import static org.objectweb.asm.Opcodes.RETURN;\n+import static openjdk.jcov.filter.simplemethods.Utils.isSimpleInstruction;\n@@ -34,1 +35,1 @@\n-public class EmptyMethods implements BiPredicate<ClassNode, MethodNode> {\n+public class EmptyMethods implements BiPredicate<ClassModel, MethodModel> {\n@@ -36,11 +37,6 @@\n-    public boolean test(ClassNode node, MethodNode m) {\n-        int index = 0;\n-        int opCode = -1;\n-        \/\/skip all instructions allowed to get values\n-        for(; index < m.instructions.size(); index++) {\n-            opCode = m.instructions.get(index).getOpcode();\n-            if(opCode >=0) {\n-                if (!Utils.isSimpleInstruction(opCode)) {\n-                    break;\n-                }\n-            }\n+    public boolean test(ClassModel node, MethodModel m) {\n+        if (m.code().isPresent()) {\n+            Instruction next = new InstructionIterator(m.code().get()).next(i -> !isSimpleInstruction(i.opcode()));\n+            return next.opcode() == Opcode.RETURN;\n+        } else {\n+            return false;\n@@ -48,2 +44,0 @@\n-        \/\/that should be a return\n-        return opCode == RETURN;\n","filename":"plugins\/simple_methods_anc\/src\/openjdk\/jcov\/filter\/simplemethods\/EmptyMethods.java","additions":13,"deletions":19,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,4 @@\n-import org.objectweb.asm.tree.ClassNode;\n-import org.objectweb.asm.tree.MethodNode;\n-\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.Opcode;\n@@ -32,1 +33,1 @@\n-import static org.objectweb.asm.Opcodes.RETURN;\n+import static openjdk.jcov.filter.simplemethods.Utils.isSimpleInstruction;\n@@ -34,1 +35,1 @@\n-public class Getters implements BiPredicate<ClassNode, MethodNode> {\n+public class Getters implements BiPredicate<ClassModel, MethodModel> {\n@@ -37,1 +38,1 @@\n-     * @see Utils#isSimpleInstruction(int)\n+     * @see Utils#isSimpleInstruction(java.lang.classfile.Opcode)\n@@ -40,11 +41,6 @@\n-    public boolean test(ClassNode clazz, MethodNode m) {\n-        int index = 0;\n-        int opCode = -1;\n-        \/\/skip all instructions allowed to get values\n-        for(; index < m.instructions.size(); index++) {\n-            opCode = m.instructions.get(index).getOpcode();\n-            if(opCode >=0) {\n-                if (!Utils.isSimpleInstruction(opCode)) {\n-                    break;\n-                }\n-            }\n+    public boolean test(ClassModel clazz, MethodModel m) {\n+        if (m.code().isPresent()) {\n+            Instruction next = new InstructionIterator(m.code().get()).next(i -> !isSimpleInstruction(i.opcode()));\n+            return next != null && Utils.isReturnInstruction(next.opcode()) && next.opcode() != Opcode.RETURN;\n+        } else {\n+            return false;\n@@ -52,2 +48,0 @@\n-        \/\/that should be a return instruction, but returning a value\n-        return Utils.isReturnInstruction(opCode) && opCode != RETURN;\n","filename":"plugins\/simple_methods_anc\/src\/openjdk\/jcov\/filter\/simplemethods\/Getters.java","additions":14,"deletions":20,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.filter.simplemethods;\n+\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeModel;\n+import java.lang.classfile.Instruction;\n+import java.util.Iterator;\n+import java.util.function.Predicate;\n+\n+public class InstructionIterator {\n+    private final Iterator<CodeElement> elements;\n+\n+    public InstructionIterator(CodeModel model) {\n+        elements = model.elements().iterator();\n+    }\n+\n+    public Instruction next(Predicate<Instruction> criteria) {\n+        while (elements.hasNext()) {\n+            CodeElement next = elements.next();\n+            if (next instanceof Instruction i) {\n+                if(criteria.test(i))\n+                    return i;\n+            }\n+        }\n+        return null;\n+    }\n+}\n","filename":"plugins\/simple_methods_anc\/src\/openjdk\/jcov\/filter\/simplemethods\/InstructionIterator.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.tree.ClassNode;\n-import org.objectweb.asm.tree.MethodNode;\n@@ -34,1 +31,3 @@\n-import java.io.InputStream;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n@@ -56,27 +55,21 @@\n-            \"java -classpath jcov.jar:SimpleMethods.jar \" + Scanner.class.getName() + \" --usage\\n\" +\n-                    \"\\n\" +\n-                    \"java -classpath jcov.jar:SimpleMethods.jar \" + Scanner.class.getName() +\n-                    \" [--include|-i <include patern>] [--exclude|-e <exclude pattern>] \\\\\\n\" +\n-                    \"[--getters <output file name>] \" +\n-                    \"[--setters <output file name>] \" +\n-                    \"[--delegators <output file name>] \" +\n-                    \"[--throwers <output file name>] \" +\n-                    \"[--empty <output file name>] \\\\\\n\" +\n-                    \"jrt:\/ | jar:file:\/<jar file> | file:\/<class hierarchy>\\n\" +\n-                    \"\\n\" +\n-                    \"    Options\\n\" +\n-                    \"        --include - what classes to scan for simple methods.\\n\" +\n-                    \"        --exclude - what classes to exclude from scanning.\\n\" +\n-                    \"    Next options specify file names where to collect this or that type of methods. \" +\n-                    \"Only those which specified are detected. At least one kind of methods should be requested. \" +\n-                    \"Please consult the source code for exact details.\\n\" +\n-                    \"        --getters - methods which are just returning a value.\\n\" +\n-                    \"        --setters - methods which are just setting a field.\\n\" +\n-                    \"        --delegators - methods which are just calling another method.\\n\" +\n-                    \"        --throwers - methods which are just throwing an exception.\\n\" +\n-                    \"        --empty - methods with an empty body.\\n\" +\n-                    \"\\n\" +\n-                    \"    Parameters define where to look for classes which are to be scanned.\\n\" +\n-                    \"        jrt:\/ - scan JDK classes\\n\" +\n-                    \"        jar:file:\/ - scan a jar file\\n\" +\n-                    \"        file:\/ - scan a directory containing compiled classes.\";\n+            STR.\"\"\"\n+java -classpath jcov.jar:SimpleMethods.jar \\{Scanner.class.getName()} --usage\n+\n+java -classpath jcov.jar:SimpleMethods.jar \\{Scanner.class.getName()} [--include|-i <include patern>] [--exclude|-e <exclude pattern>] \\\\\n+[--getters <output file name>] [--setters <output file name>] [--delegators <output file name>] [--throwers <output file name>] [--empty <output file name>] \\\\\n+jrt:\/ | jar:file:\/<jar file> | file:\/<class hierarchy>\n+\n+    Options\n+        --include - what classes to scan for simple methods.\n+        --exclude - what classes to exclude from scanning.\n+    Next options specify file names where to collect this or that type of methods. Only those which specified are detected. At least one kind of methods should be requested. Please consult the source code for exact details.\n+        --getters - methods which are just returning a value.\n+        --setters - methods which are just setting a field.\n+        --delegators - methods which are just calling another method.\n+        --throwers - methods which are just throwing an exception.\n+        --empty - methods with an empty body.\n+\n+    Parameters define where to look for classes which are to be scanned.\n+        jrt:\/ - scan JDK classes\n+        jar:file:\/ - scan a jar file\n+        file:\/ - scan a directory containing compiled classes.\"\"\";\n@@ -191,13 +184,6 @@\n-        try (InputStream in = Files.newInputStream(file)) {\n-            ClassReader reader;\n-            reader = new ClassReader(in);\n-            if (included(reader.getClassName())) {\n-                ClassNode clazz = new ClassNode();\n-                reader.accept(clazz, 0);\n-                for (Object methodObject : clazz.methods) {\n-                    MethodNode method = (MethodNode) methodObject;\n-                    for (Filter f : filters) {\n-                        if (f.filter.test(clazz, method)) {\n-                            f.add(clazz.name + \"#\" + method.name + method.desc);\n-                        }\n-                    }\n+        var cm = ClassFile.of().parse(file);\n+        if (included(cm.thisClass().name().toString()))\n+            for (var mm : cm.methods()) {\n+                for (var f : filters) {\n+                    if (f.filter.test(cm, mm))\n+                        f.add(STR.\"\\{cm.thisClass().name()}#\\{mm.methodName()}\\{mm.methodType()}\");\n@@ -206,5 +192,0 @@\n-        } catch (IOException e) {\n-            throw e;\n-        } catch (Exception e) {\n-            throw new RuntimeException(\"Exception while parsing file \" + file + \" from \" + root, e);\n-        }\n@@ -225,1 +206,1 @@\n-        private BiPredicate<ClassNode, MethodNode> filter;\n+        private BiPredicate<ClassModel, MethodModel> filter;\n@@ -229,1 +210,1 @@\n-        Filter(String description, BiPredicate<ClassNode, MethodNode> filter) {\n+        Filter(String description, BiPredicate<ClassModel, MethodModel> filter) {\n","filename":"plugins\/simple_methods_anc\/src\/openjdk\/jcov\/filter\/simplemethods\/Scanner.java","additions":33,"deletions":52,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,4 @@\n-import org.objectweb.asm.tree.ClassNode;\n-import org.objectweb.asm.tree.MethodNode;\n-\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.Opcode;\n@@ -32,3 +33,1 @@\n-import static org.objectweb.asm.Opcodes.PUTFIELD;\n-import static org.objectweb.asm.Opcodes.PUTSTATIC;\n-import static org.objectweb.asm.Opcodes.RETURN;\n+import static openjdk.jcov.filter.simplemethods.Utils.isSimpleInstruction;\n@@ -39,1 +38,1 @@\n- * @see Utils#isSimpleInstruction(int)\n+ * @see Utils#isSimpleInstruction(java.lang.classfile.Opcode)\n@@ -41,1 +40,1 @@\n-public class Setters implements BiPredicate<ClassNode, MethodNode> {\n+public class Setters implements BiPredicate<ClassModel, MethodModel> {\n@@ -43,27 +42,9 @@\n-    public boolean test(ClassNode clazz, MethodNode m) {\n-        int index = 0;\n-        int opCode = -1;\n-        \/\/skip all instructions allowed to get values\n-        for(; index < m.instructions.size(); index++) {\n-            opCode = m.instructions.get(index).getOpcode();\n-            if(opCode >=0) {\n-                if (!Utils.isSimpleInstruction(opCode)) {\n-                    break;\n-                }\n-            }\n-        }\n-        \/\/that should be an instruction setting a field\n-        if(opCode != PUTFIELD && opCode != PUTSTATIC) {\n-            return false;\n-        }\n-        \/\/find next\n-        for(index++; index < m.instructions.size(); index++) {\n-            opCode = m.instructions.get(index).getOpcode();\n-            if(opCode >=0) {\n-                if (!Utils.isSimpleInstruction(opCode)) {\n-                    break;\n-                }\n-            }\n-        }\n-        \/\/and that should be a return\n-        return opCode == RETURN;\n+    public boolean test(ClassModel clazz, MethodModel m) {\n+        if (m.code().isPresent()) {\n+            var iter = new InstructionIterator(m.code().get());\n+            Instruction next = iter.next(i -> !isSimpleInstruction(i.opcode()));\n+            if (next.opcode() != Opcode.PUTFIELD && next.opcode() != Opcode.PUTSTATIC)\n+                return false;\n+            next = iter.next(i -> !isSimpleInstruction(i.opcode()));\n+            return next.opcode() == Opcode.RETURN;\n+        } else return false;\n","filename":"plugins\/simple_methods_anc\/src\/openjdk\/jcov\/filter\/simplemethods\/Setters.java","additions":17,"deletions":36,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,6 +27,5 @@\n-import org.objectweb.asm.Opcodes;\n-import org.objectweb.asm.tree.AbstractInsnNode;\n-import org.objectweb.asm.tree.ClassNode;\n-import org.objectweb.asm.tree.MethodInsnNode;\n-import org.objectweb.asm.tree.MethodNode;\n-\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.instruction.InvokeInstruction;\n@@ -35,1 +34,3 @@\n-public class Throwers implements BiPredicate<ClassNode, MethodNode> {\n+import static openjdk.jcov.filter.simplemethods.Utils.isSimpleInstruction;\n+\n+public class Throwers implements BiPredicate<ClassModel, MethodModel> {\n@@ -37,27 +38,17 @@\n-    public boolean test(ClassNode cnode, MethodNode m) {\n-        int index = 0;\n-        int opCode = -1;\n-        \/\/find first instruction\n-        for(; index < m.instructions.size(); index++) {\n-            opCode = m.instructions.get(index).getOpcode();\n-            if(opCode >=0) {\n-                    break;\n-            }\n-        }\n-        \/\/should be NEW\n-        if(opCode != Opcodes.NEW) {\n-            return false;\n-        }\n-        \/\/next is DUP\n-        index++;\n-        opCode = m.instructions.get(index).getOpcode();\n-        if(opCode != Opcodes.DUP) {\n-            return false;\n-        }\n-        \/\/some more simple code\n-        for(index++; index < m.instructions.size(); index++) {\n-            opCode = m.instructions.get(index).getOpcode();\n-            if(opCode >=0) {\n-                if (!Utils.isSimpleInstruction(opCode)) {\n-                    break;\n-                }\n+    public boolean test(ClassModel cnode, MethodModel m) {\n+        if (m.code().isPresent()) {\n+            var iter = new InstructionIterator(m.code().get());\n+            \/\/first should be NEW\n+            if(iter.next(i -> true).opcode() != Opcode.NEW)\n+                return false;\n+            \/\/next is DUP\n+            if(iter.next(i -> true).opcode() != Opcode.DUP)\n+                return false;\n+            \/\/next is a constructor call\n+            Instruction next = iter.next(i -> !isSimpleInstruction(i.opcode()));\n+            if (next.opcode() != Opcode.INVOKESPECIAL)\n+                return false;\n+            if (next instanceof InvokeInstruction call) {\n+                if (!call.name().toString().equals(\"<init>\")) return false;\n+            } else {\n+                return false;\n@@ -65,15 +56,3 @@\n-        }\n-        \/\/should be a constructor\n-        if(opCode != Opcodes.INVOKESPECIAL) {\n-            return false;\n-        }\n-        AbstractInsnNode node = m.instructions.get(index);\n-        if(!(node instanceof MethodInsnNode)) {\n-            return false;\n-        }\n-        if(!((MethodInsnNode)node).name.equals(\"<init>\")) {\n-            return false;\n-        }\n-        index++;\n-        opCode = m.instructions.get(index).getOpcode();\n-        return opCode == Opcodes.ATHROW;\n+            \/\/finally a throw\n+            return iter.next(i -> true).opcode() == Opcode.ATHROW;\n+        } else return false;\n","filename":"plugins\/simple_methods_anc\/src\/openjdk\/jcov\/filter\/simplemethods\/Throwers.java","additions":29,"deletions":50,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.lang.classfile.Opcode;\n@@ -29,1 +30,1 @@\n-import static org.objectweb.asm.Opcodes.*;\n+import static java.lang.classfile.Opcode.*;\n@@ -32,1 +33,3 @@\n-    private final static int[] SIMPLE_INSTRUCTIONS = new int[]{DUP, LDC,\n+    private final static Opcode[] SIMPLE_INSTRUCTIONS = new Opcode[]{\n+            DUP,\n+            LDC, LDC_W, LDC2_W,\n@@ -39,1 +42,5 @@\n-            ALOAD, ILOAD, FLOAD, LLOAD, DLOAD,\n+            ALOAD, ALOAD_0, ALOAD_1, ALOAD_2, ALOAD_3, ALOAD_W,\n+            ILOAD, ILOAD_0, ILOAD_1, ILOAD_2, ILOAD_3, ILOAD_W,\n+            FLOAD, FLOAD_0, FLOAD_1, FLOAD_2, FLOAD_3, FLOAD_W,\n+            LLOAD, LLOAD_0, LLOAD_1, LLOAD_2, LLOAD_3, LLOAD_W,\n+            DLOAD, DLOAD_0, DLOAD_1, DLOAD_2, DLOAD_3, DLOAD_W,\n@@ -42,1 +49,1 @@\n-    private final static int[] INVOKE_INSTRUCTIONS = new int[]{INVOKEVIRTUAL, INVOKEINTERFACE, INVOKESTATIC,\n+    private final static Opcode[] INVOKE_INSTRUCTIONS = new Opcode[]{INVOKEVIRTUAL, INVOKEINTERFACE, INVOKESTATIC,\n@@ -44,1 +51,1 @@\n-    private final static int[] RETURN_INSTRUCTIONS = new int[]{RETURN, ARETURN, IRETURN, FRETURN, LRETURN, DRETURN};\n+    private final static Opcode[] RETURN_INSTRUCTIONS = new Opcode[]{RETURN, ARETURN, IRETURN, FRETURN, LRETURN, DRETURN};\n@@ -57,1 +64,1 @@\n-    public static boolean isSimpleInstruction(int opCode) {\n+    public static boolean isSimpleInstruction(Opcode opCode) {\n@@ -60,1 +67,1 @@\n-    public static boolean isReturnInstruction(int opCode) {\n+    public static boolean isReturnInstruction(Opcode opCode) {\n@@ -63,1 +70,1 @@\n-    public static boolean isInvokeInstruction(int opCode) {\n+    public static boolean isInvokeInstruction(Opcode opCode) {\n@@ -66,0 +73,1 @@\n+\n","filename":"plugins\/simple_methods_anc\/src\/openjdk\/jcov\/filter\/simplemethods\/Utils.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import org.objectweb.asm.tree.ClassNode;\n@@ -33,0 +32,1 @@\n+import java.lang.classfile.ClassModel;\n@@ -40,1 +40,1 @@\n-    ClassNode cls;\n+    ClassModel cls;\n","filename":"plugins\/simple_methods_anc\/test\/openjdk\/jcov\/filter\/simplemethods\/DelegatorsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import org.objectweb.asm.tree.ClassNode;\n@@ -33,0 +32,1 @@\n+import java.lang.classfile.ClassModel;\n@@ -39,1 +39,1 @@\n-    ClassNode cls;\n+    ClassModel cls;\n","filename":"plugins\/simple_methods_anc\/test\/openjdk\/jcov\/filter\/simplemethods\/EmptyMethodsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import org.objectweb.asm.tree.ClassNode;\n@@ -33,0 +32,1 @@\n+import java.lang.classfile.ClassModel;\n@@ -40,1 +40,1 @@\n-    ClassNode cls;\n+    ClassModel cls;\n","filename":"plugins\/simple_methods_anc\/test\/openjdk\/jcov\/filter\/simplemethods\/GettersTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import org.objectweb.asm.tree.ClassNode;\n@@ -33,0 +32,1 @@\n+import java.lang.classfile.ClassModel;\n@@ -39,1 +39,1 @@\n-    ClassNode cls;\n+    ClassModel cls;\n","filename":"plugins\/simple_methods_anc\/test\/openjdk\/jcov\/filter\/simplemethods\/SettersTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018,2024  Oracle and\/or its affiliates. All rights reserved.\n@@ -27,4 +27,0 @@\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.tree.ClassNode;\n-import org.objectweb.asm.tree.MethodNode;\n-\n@@ -32,0 +28,3 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n@@ -34,6 +33,3 @@\n-    static ClassNode findTestClass(Class cls) throws IOException {\n-        ClassNode result = new ClassNode();\n-        ClassReader reader = new ClassReader(cls.getClassLoader().\n-                getResourceAsStream(cls.getName().replace('.','\/') + \".class\"));\n-        reader.accept(result, 0);\n-        return result;\n+    static ClassModel findTestClass(Class cls) throws IOException {\n+        return ClassFile.of().parse(cls.getClassLoader().\n+                getResourceAsStream(cls.getName().replace('.','\/') + \".class\").readAllBytes());\n@@ -42,8 +38,4 @@\n-    static MethodNode findTestMethod(ClassNode cls, String methodSig)  {\n-        for(Object mo: cls.methods) {\n-            MethodNode m = (MethodNode) mo;\n-            if((m.name + m.desc).equals(methodSig)) {\n-                return m;\n-            }\n-        }\n-        throw new IllegalStateException(\"Method does not exist: \" + methodSig + \" in class \" + cls.name);\n+    static MethodModel findTestMethod(ClassModel cls, String methodSig)  {\n+        return cls.methods().stream()\n+                .filter(m -> (m.methodName().toString() + m.methodType().toString()).equals(methodSig))\n+                .findAny().get();\n","filename":"plugins\/simple_methods_anc\/test\/openjdk\/jcov\/filter\/simplemethods\/TestUtils.java","additions":11,"deletions":19,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import org.objectweb.asm.tree.ClassNode;\n@@ -33,0 +32,1 @@\n+import java.lang.classfile.ClassModel;\n@@ -40,1 +40,1 @@\n-    ClassNode cls;\n+    ClassModel cls;\n","filename":"plugins\/simple_methods_anc\/test\/openjdk\/jcov\/filter\/simplemethods\/ThrowersTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}