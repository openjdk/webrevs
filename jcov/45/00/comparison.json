{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import java.util.zip.ZipInputStream;\n@@ -71,0 +72,17 @@\n+    private static final String ZIP_EXTENSION = \".xml.zip\";\n+    private static final String XML_EXTENSION = \".xml\";\n+\n+    private static InputStream openZipOrXML(File zipOrXML) throws IOException {\n+        if (zipOrXML.toString().endsWith(ZIP_EXTENSION)) {\n+            \/\/the assumption is that\n+            \/\/1. the zip will be having a special extension: \".xml.zip\"\n+            \/\/2. the zip has one entry and that entry is the xml file\n+            if (!zipOrXML.getName().endsWith(ZIP_EXTENSION))\n+                throw new IllegalArgumentException(\"Unknown file format. Can be \\\".xml.zip\\\" or XML \" + zipOrXML);\n+            ZipInputStream res = new ZipInputStream(new FileInputStream(zipOrXML));\n+            if (!res.getNextEntry().getName().endsWith(XML_EXTENSION))\n+                throw new IllegalArgumentException(\"No XML file in \" + zipOrXML);\n+            return res;\n+        } else return new FileInputStream(zipOrXML);\n+    }\n+\n@@ -73,8 +91,5 @@\n-        FileInputStream in = null;\n-        try {\n-            File f = new File(fileName);\n-            if (!f.exists()) {\n-                throw new FileFormatException(\"File \" + fileName + \" doesn''t exist\");\n-            }\n-\n-            in = new FileInputStream(f);\n+        File f = new File(fileName);\n+        if (!f.exists()) {\n+            throw new FileFormatException(\"File \" + fileName + \" doesn''t exist\");\n+        }\n+        try  (InputStream in = openZipOrXML(f)) {\n@@ -83,3 +98,0 @@\n-            in.close();\n-            in = null;\n-\n@@ -93,8 +105,0 @@\n-        } finally {\n-            if (in != null) {\n-                try {\n-                    in.close();\n-                } catch (IOException ex) {\/*do nothing*\/\n-\n-                }\n-            }\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/io\/Reader.java","additions":24,"deletions":20,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument;\n+\n+import com.sun.tdk.jcov.Instr;\n+import com.sun.tdk.jcov.Merger;\n+import com.sun.tdk.jcov.data.FileFormatException;\n+import com.sun.tdk.jcov.instrument.DataRoot;\n+import com.sun.tdk.jcov.instrument.Util;\n+import com.sun.tdk.jcov.instrument.instr.UserCode;\n+import com.sun.tdk.jcov.io.Reader;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class ReadZipTest {\n+    Path test_dir;\n+    Path template;\n+    Path template_zip;\n+    int method_slot = -1;\n+    @BeforeClass\n+    public void clean() throws IOException {\n+        System.setProperty(\"jcov.selftest\", \"true\");\n+        Path data_dir = Paths.get(System.getProperty(\"user.dir\"));\n+        test_dir = data_dir.resolve(\"instr_test\");\n+        System.out.println(\"test dir = \" + test_dir);\n+        Util.rmRF(test_dir);\n+        template = test_dir.resolve(\"template.xml\");\n+        template_zip = test_dir.resolve(\"template.xml.zip\");\n+    }\n+    @Test\n+    public void instrument() throws IOException, InterruptedException, FileFormatException {\n+        List<String> params = new ArrayList<>();\n+        params.add(\"-t\");\n+        params.add(template.toString());\n+        params.add(new Util(test_dir).copyBytecode(UserCode.class.getName()).get(0).toString());\n+        System.out.println(\"Running Instr with\");\n+        params.forEach(System.out::println);\n+        new Instr().run(params.toArray(new String[0]));\n+        try (var out = new ZipOutputStream(Files.newOutputStream(template_zip))) {\n+            out.putNextEntry(new ZipEntry(\"template.xml\"));\n+            out.write(Files.readAllBytes(template));\n+        }\n+        compare(Reader.readXML(template_zip.toString()), Reader.readXML(template.toString()));\n+    }\n+\n+    @Test(dependsOnMethods = \"instrument\")\n+    void merge() throws FileFormatException {\n+        var template_merge = test_dir.resolve(\"template_merge.xml\");\n+        List<String> params = new ArrayList<>();\n+        params.add(\"-o\");\n+        params.add(template_merge.toString());\n+        params.add(template_zip.toString());\n+        params.add(template.toString());\n+        System.out.println(\"Running Merger with\");\n+        params.forEach(System.out::println);\n+        new Merger().run(params.toArray(new String[0]));\n+        compare(Reader.readXML(template_merge.toString()), Reader.readXML(template.toString()));\n+    }\n+\n+    private void compare(DataRoot one, DataRoot another) {\n+        var methods = one.getClasses().stream()\n+                .flatMap(c -> c.getMethods().stream().map(m -> c.getName() + \".\" + m.getName() + m.getVmSignature()))\n+                .sorted().collect(Collectors.toList());\n+        var otherMethods = another.getClasses().stream()\n+                .flatMap(c -> c.getMethods().stream().map(m -> c.getName() + \".\" + m.getName() + m.getVmSignature()))\n+                .sorted().collect(Collectors.toList());\n+        assertEquals(methods.size(), otherMethods.size());\n+        for (int i = 0; i < methods.size(); i++) {\n+            assertEquals(methods.get(i), otherMethods.get(i));\n+        }\n+    }\n+\n+    @AfterClass\n+    public void tearDown() throws IOException {\n+        Util.rmRF(test_dir);\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/ReadZipTest.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"}]}