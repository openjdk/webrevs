{"files":[{"patch":"@@ -54,0 +54,4 @@\n+      dry-run:\n+        required: false\n+        type: boolean\n+        default: false\n@@ -107,0 +111,1 @@\n+        if: ${{ inputs.dry-run == false }}\n@@ -113,0 +118,1 @@\n+        if: ${{ inputs.dry-run == false }}\n","filename":".github\/workflows\/build-alpine-linux.yml","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,0 +43,4 @@\n+      dry-run:\n+        required: false\n+        type: boolean\n+        default: false\n@@ -192,1 +196,1 @@\n-        if: steps.create-sysroot.outcome == 'success' || steps.get-cached-sysroot.outputs.cache-hit == 'true'\n+        if: ((steps.create-sysroot.outcome == 'success' || steps.get-cached-sysroot.outputs.cache-hit == 'true') && inputs.dry-run == false)\n","filename":".github\/workflows\/build-cross-compile.yml","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,0 +64,4 @@\n+      dry-run:\n+        required: false\n+        type: boolean\n+        default: false\n@@ -67,0 +71,3 @@\n+      static-suffix:\n+        required: false\n+        type: string\n@@ -139,0 +146,1 @@\n+        if: ${{ inputs.dry-run == false }}\n@@ -146,0 +154,2 @@\n+          static-suffix: ${{ inputs.static-suffix }}\n+        if: ${{ inputs.dry-run == false }}\n","filename":".github\/workflows\/build-linux.yml","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,0 +57,4 @@\n+      dry-run:\n+        required: false\n+        type: boolean\n+        default: false\n@@ -121,0 +125,1 @@\n+        if: ${{ inputs.dry-run == false }}\n@@ -127,0 +132,1 @@\n+        if: ${{ inputs.dry-run == false }}\n","filename":".github\/workflows\/build-macos.yml","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,0 +57,4 @@\n+      dry-run:\n+        required: false\n+        type: boolean\n+        default: false\n@@ -66,1 +70,1 @@\n-    runs-on: windows-2019\n+    runs-on: windows-2025\n@@ -105,1 +109,1 @@\n-          '\/c\/Program Files (x86)\/Microsoft Visual Studio\/2019\/Enterprise\/vc\/auxiliary\/build\/vcvars64.bat' -vcvars_ver=${{ inputs.msvc-toolset-version }}\n+          '\/c\/Program Files\/Microsoft Visual Studio\/2022\/Enterprise\/vc\/auxiliary\/build\/vcvars64.bat' -vcvars_ver=${{ inputs.msvc-toolset-version }}\n@@ -118,1 +122,1 @@\n-            modify --quiet --installPath 'C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise' \\\n+            modify --quiet --installPath 'C:\\Program Files\\Microsoft Visual Studio\\2022\\Enterprise' \\\n@@ -142,0 +146,1 @@\n+        if: ${{ inputs.dry-run == false }}\n@@ -150,0 +155,1 @@\n+        if: ${{ inputs.dry-run == false }}\n@@ -156,0 +162,1 @@\n+        if: ${{ inputs.dry-run == false }}\n","filename":".github\/workflows\/build-windows.yml","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-      - master\n-      - jdk*\n@@ -46,0 +44,3 @@\n+      dry-run:\n+        description: 'Dry run: skip actual builds and tests'\n+        required: false\n@@ -73,0 +74,1 @@\n+      dry-run: ${{ steps.include.outputs.dry-run }}\n@@ -146,0 +148,29 @@\n+          function check_dry_run() {\n+            if [[ $GITHUB_EVENT_NAME == workflow_dispatch ]]; then\n+              # Take the user-specified one.\n+              echo '${{ github.event.inputs.dry-run }}'\n+              return\n+            elif [[ $GITHUB_EVENT_NAME == push ]]; then\n+              # Cut out the real branch name\n+              BRANCH=${GITHUB_REF##*\/}\n+\n+              # Dry run rebuilds the caches in current branch, so they can be reused\n+              # for any child PR branches. Because of this, we want to trigger this\n+              # workflow in master branch, so that actual PR branches can use the cache.\n+              # This workflow would trigger every time contributors sync their master\n+              # branches in their personal forks.\n+              if [[ $BRANCH == \"master\" ]]; then\n+                echo 'true'\n+                return\n+              fi\n+\n+              # ...same for stabilization branches\n+              if [[ $BRANCH =~ \"jdk(.*)\" ]]; then\n+                echo 'true'\n+                return\n+              fi\n+            fi\n+\n+            echo 'false'\n+          }\n+\n@@ -155,0 +186,1 @@\n+          echo \"dry-run=$(check_dry_run)\" >> $GITHUB_OUTPUT\n@@ -169,0 +201,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -183,0 +216,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -197,0 +231,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -211,0 +246,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -226,0 +262,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -234,1 +271,1 @@\n-      make-target: 'static-jdk-image'\n+      make-target: 'static-jdk-bundles'\n@@ -241,3 +278,2 @@\n-      # It currently doesn't produce any bundles, but probably will do in\n-      # the future.\n-      bundle-suffix: \"-static\"\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n+      static-suffix: \"-static\"\n@@ -259,0 +295,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -273,0 +310,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -283,0 +321,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -295,0 +334,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -307,0 +347,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -315,1 +356,1 @@\n-      msvc-toolset-version: '14.29'\n+      msvc-toolset-version: '14.44'\n@@ -319,0 +360,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -327,1 +369,1 @@\n-      msvc-toolset-version: '14.29'\n+      msvc-toolset-version: '14.44'\n@@ -333,0 +375,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -349,0 +392,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -358,0 +402,14 @@\n+      - prepare\n+      - build-linux-x64\n+    uses: .\/.github\/workflows\/test.yml\n+    with:\n+      platform: linux-x64\n+      bootjdk-platform: linux-x64\n+      runs-on: ubuntu-22.04\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n+      debug-suffix: -debug\n+\n+  test-linux-x64-static:\n+    name: linux-x64-static\n+    needs:\n+      - prepare\n@@ -359,0 +417,1 @@\n+      - build-linux-x64-static\n@@ -364,0 +423,2 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n+      static-suffix: \"-static\"\n@@ -368,0 +429,1 @@\n+      - prepare\n@@ -374,0 +436,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -375,0 +438,1 @@\n+      debug-suffix: -debug\n@@ -379,0 +443,1 @@\n+      - prepare\n@@ -384,1 +449,3 @@\n-      runs-on: windows-2019\n+      runs-on: windows-2025\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n+      debug-suffix: -debug\n","filename":".github\/workflows\/main.yml","additions":76,"deletions":9,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -43,0 +43,10 @@\n+      dry-run:\n+        required: false\n+        type: boolean\n+        default: false\n+      debug-suffix:\n+        required: false\n+        type: string\n+      static-suffix:\n+        required: false\n+        type: string\n@@ -89,1 +99,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -93,1 +103,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -97,1 +107,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -101,1 +111,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -105,1 +115,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -109,1 +119,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -113,1 +123,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -117,1 +127,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -143,0 +153,2 @@\n+          static-suffix: ${{ inputs.static-suffix }}\n+        if: ${{ inputs.dry-run == false }}\n@@ -163,0 +175,15 @@\n+          if [[ '${{ inputs.static-suffix }}' == '-static' ]]; then\n+            echo \"static-hotspot-problemlist-path=`pwd`\/test\/hotspot\/jtreg\/ProblemList-StaticJdk.txt\" >> $GITHUB_OUTPUT\n+            echo \"static-jdk-problemlist-path=`pwd`\/test\/jdk\/ProblemList-StaticJdk.txt\" >> $GITHUB_OUTPUT\n+            echo \"static-langtools-problemlist-path=`pwd`\/test\/langtools\/ProblemList-StaticJdk.txt\" >> $GITHUB_OUTPUT\n+            echo \"static-lib-test-problemlist-path=`pwd`\/test\/lib-test\/ProblemList-StaticJdk.txt\" >> $GITHUB_OUTPUT\n+          fi\n+\n+      - name: 'Set Extra Options'\n+        id: extra-options\n+        run: |\n+          if [[ '${{ inputs.static-suffix }}' == '-static' ]]; then\n+            echo \"test-jdk=JDK_UNDER_TEST=${{ steps.bundles.outputs.static-jdk-path }}\" >> $GITHUB_OUTPUT\n+            echo \"compile-jdk=JDK_FOR_COMPILE=${{ steps.bundles.outputs.jdk-path }}\" >> $GITHUB_OUTPUT\n+            echo \"extra-problem-lists=EXTRA_PROBLEM_LISTS=${{ steps.path.outputs.static-hotspot-problemlist-path }}%20${{ steps.path.outputs.static-jdk-problemlist-path }}%20${{ steps.path.outputs.static-langtools-problemlist-path }}%20${{ steps.path.outputs.static-lib-test-problemlist-path }}\" >> $GITHUB_OUTPUT\n+          fi\n@@ -174,1 +201,3 @@\n-          JTREG='JAVA_OPTIONS=-XX:-CreateCoredumpOnCrash;VERBOSE=fail,error,time;KEYWORDS=!headful'\n+          ${{ steps.extra-options.outputs.test-jdk }}\n+          ${{ steps.extra-options.outputs.compile-jdk }}\n+          JTREG='JAVA_OPTIONS=-XX:-CreateCoredumpOnCrash;VERBOSE=fail,error,time;KEYWORDS=!headful;${{ steps.extra-options.outputs.extra-problem-lists }}'\n@@ -178,0 +207,1 @@\n+        if: ${{ inputs.dry-run == false }}\n@@ -207,1 +237,1 @@\n-          artifact_name=\"results-${{ inputs.platform }}-$(echo ${{ matrix.test-name }} | tr '\/ ' '__')\"\n+          artifact_name=\"results-${{ inputs.platform }}-$(echo ${{ matrix.test-name }}${{ inputs.static-suffix }} | tr '\/ ' '__')\"\n","filename":".github\/workflows\/test.yml","additions":40,"deletions":10,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -45,0 +45,6 @@\n+\n+ifeq ($(UPDATE_MODULE_DEPS), true)\n+  # Update module-deps.gmk if requested. This is read in Modules.gmk.\n+  GENERATE_MODULE_DEPS_FILE := true\n+endif\n+\n@@ -414,0 +420,2 @@\n+BOOTCYCLE_SPEC := $(dir $(SPEC))bootcycle-spec.gmk\n+\n@@ -419,1 +427,1 @@\n-\t      LOG_PREFIX=\"[bootcycle] \" JOBS= SPEC=$(dir $(SPEC))bootcycle-spec.gmk main\n+\t      LOG_PREFIX=\"[bootcycle] \" JOBS= SPEC=$(BOOTCYCLE_SPEC) main\n@@ -1009,1 +1017,1 @@\n-    jdk.compiler-gendata: jdk.compiler-launchers\n+    jdk.compiler-gendata: jdk.compiler-launchers java.base-launchers\n","filename":"make\/Main.gmk","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+import java.util.Locale;\n@@ -96,1 +97,3 @@\n-        LINT_CATEGORY(\"lint.category\");\n+        LINT_CATEGORY(\"lint.category\"),\n+        DIAGNOSTIC_FLAGS_EMPTY(\"diagnostic.flags.empty\"),\n+        DIAGNOSTIC_FLAGS_NON_EMPTY(\"diagnostic.flags.non-empty\");\n@@ -262,0 +265,7 @@\n+        String diagnosticFlags = lines.stream()\n+                .filter(MessageLine::isDiagnosticFlags)\n+                .map(MessageLine::diagnosticFlags)\n+                .flatMap(Stream::of)\n+                .map(s -> s.replace('-', '_'))\n+                .map(s -> s.toUpperCase(Locale.ROOT))\n+                .collect(Collectors.joining(\", \"));\n@@ -268,0 +278,3 @@\n+                        diagnosticFlags.isEmpty() ?\n+                          StubKind.DIAGNOSTIC_FLAGS_EMPTY.format() :\n+                          StubKind.DIAGNOSTIC_FLAGS_NON_EMPTY.format(diagnosticFlags),\n@@ -273,0 +286,3 @@\n+                        diagnosticFlags.isEmpty() ?\n+                          StubKind.DIAGNOSTIC_FLAGS_EMPTY.format() :\n+                          StubKind.DIAGNOSTIC_FLAGS_NON_EMPTY.format(diagnosticFlags),\n@@ -290,0 +306,3 @@\n+                            diagnosticFlags.isEmpty() ?\n+                              StubKind.DIAGNOSTIC_FLAGS_EMPTY.format() :\n+                              StubKind.DIAGNOSTIC_FLAGS_NON_EMPTY.format(diagnosticFlags),\n@@ -295,0 +314,3 @@\n+                            diagnosticFlags.isEmpty() ?\n+                              StubKind.DIAGNOSTIC_FLAGS_EMPTY.format() :\n+                              StubKind.DIAGNOSTIC_FLAGS_NON_EMPTY.format(diagnosticFlags),\n","filename":"make\/langtools\/tools\/propertiesparser\/gen\/ClassGenerator.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n- * such as {0}, {1}, etc within the property value.\n+ * such as {0}, {1}, etc within the property value, a lint category,\n+ * and\/or a list of diagnostic flags.\n@@ -52,1 +53,1 @@\n-            if (l != null && l.isLint()) {\n+            while (l != null && (l.isLint() || l.isDiagnosticFlags())) {\n@@ -77,1 +78,1 @@\n-            if (l.prev != null && (l.prev.isInfo() || l.prev.isLint()))\n+            while (l.prev != null && (l.prev.isInfo() || l.prev.isLint() || l.prev.isDiagnosticFlags()))\n","filename":"make\/langtools\/tools\/propertiesparser\/parser\/Message.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.List;\n@@ -42,0 +43,1 @@\n+    static final Pattern diagnosticFlagsPattern = Pattern.compile(\"# flags: ([a-z\\\\-]+(, ([a-z\\\\-]+))*)\");\n@@ -72,0 +74,13 @@\n+    public boolean isDiagnosticFlags() {\n+        return diagnosticFlagsPattern.matcher(text).matches();\n+    }\n+\n+    public String[] diagnosticFlags() {\n+        Matcher matcher = diagnosticFlagsPattern.matcher(text);\n+        if (matcher.matches()) {\n+            return matcher.group(1).split(\", \", -1);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n","filename":"make\/langtools\/tools\/propertiesparser\/parser\/MessageLine.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+    import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;\\n\\\n@@ -37,0 +38,4 @@\n+    import java.util.EnumSet;\\n\\\n+    \\n\\\n+    import static com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag.*;\\n\\\n+    \\n\\\n@@ -61,1 +66,1 @@\n-    return new {0}({1}, {2}, {3});\n+    return new {0}({1}, {2}, {3}, {4});\n@@ -64,1 +69,1 @@\n-    return new {0}({1}, {2}, {3}, {4});\n+    return new {0}({1}, {2}, {3}, {4}, {5});\n@@ -70,1 +75,1 @@\n-    public static final {0} {1} = new {0}({2}, {3});\n+    public static final {0} {1} = new {0}({2}, {3}, {4});\n@@ -76,1 +81,1 @@\n-    public static final {0} {1} = new {0}({2}, {3}, {4});\n+    public static final {0} {1} = new {0}({2}, {3}, {4}, {5});\n@@ -87,0 +92,6 @@\n+diagnostic.flags.empty=\\\n+  EnumSet.noneOf(DiagnosticFlag.class)\n+\n+diagnostic.flags.non-empty=\\\n+  EnumSet.of({0})\n+\n","filename":"make\/langtools\/tools\/propertiesparser\/resources\/templates.properties","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-export SOURCE := 7\n+export SOURCE := 8\n@@ -37,1 +37,1 @@\n-export TARGET := 7\n+export TARGET := 8\n","filename":"src\/demo\/share\/java2d\/J2DBench\/Makefile","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  <condition property=\"source\" value=\"7\">\n+  <condition property=\"source\" value=\"8\">\n@@ -47,1 +47,1 @@\n-  <condition property=\"target\" value=\"7\">\n+  <condition property=\"target\" value=\"8\">\n@@ -57,5 +57,0 @@\n-  <condition property=\"javac\" value=\"javac\">\n-     <not>\n-        <isset property=\"javac\"\/>\n-     <\/not>\n-  <\/condition>\n@@ -73,1 +68,1 @@\n-    <javac debug=\"off\" source=\"${source}\" target=\"${target}\" srcdir=\"${src}\" destdir=\"${build}\" fork=\"true\" executable=\"${javac}\"\/>\n+    <javac debug=\"off\" source=\"${source}\" target=\"${target}\" srcdir=\"${src}\" destdir=\"${build}\"\/>\n","filename":"src\/demo\/share\/java2d\/J2DBench\/build.xml","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-                System.out.println(\"    Overall average:  \"+overallscore);\n+                System.out.printf( \"    Overall average:  %-10.4f%n\", overallscore);\n","filename":"src\/demo\/share\/java2d\/J2DBench\/src\/j2dbench\/report\/J2DAnalyzer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1768,4 +1768,0 @@\n-  \/\/ insert a nop at the start of the prolog so we can patch in a\n-  \/\/ branch if we need to invalidate the method later\n-  __ nop();\n-\n@@ -1891,1 +1887,1 @@\n-    __ safepoint_poll(*code_stub, true \/* at_return *\/, false \/* acquire *\/, true \/* in_nmethod *\/);\n+    __ safepoint_poll(*code_stub, true \/* at_return *\/, true \/* in_nmethod *\/);\n@@ -3924,0 +3920,4 @@\n+\/\/ Whether this node is expanded during code emission into a sequence of\n+\/\/ instructions and the first instruction can perform an implicit null check.\n+ins_attrib ins_is_late_expanded_null_check_candidate(false);\n+\n@@ -7768,2 +7768,1 @@\n-  format %{ \"movw   $src, $src\\n\\t\"\n-            \"mov    $tmp, $src\\t# vector (1D)\\n\\t\"\n+  format %{ \"fmovs  $tmp, $src\\t# vector (1S)\\n\\t\"\n@@ -7774,2 +7773,1 @@\n-    __ movw($src$$Register, $src$$Register); \/\/ ensure top 32 bits 0\n-    __ mov($tmp$$FloatRegister, __ D, 0, $src$$Register);\n+    __ fmovs($tmp$$FloatRegister, $src$$Register);\n@@ -8243,0 +8241,10 @@\n+instruct castHH(vRegF dst)\n+%{\n+  match(Set dst (CastHH dst));\n+  size(0);\n+  format %{ \"# castHH of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::counter_overflow_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_counter_overflow_id)));\n@@ -68,1 +68,1 @@\n-    address a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+    address a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -81,1 +81,1 @@\n-  C1StubId stub_id;\n+  StubId stub_id;\n@@ -83,1 +83,1 @@\n-    stub_id = C1StubId::throw_index_exception_id;\n+    stub_id = StubId::c1_throw_index_exception_id;\n@@ -87,1 +87,1 @@\n-    stub_id = C1StubId::throw_range_check_failed_id;\n+    stub_id = StubId::c1_throw_range_check_failed_id;\n@@ -102,1 +102,1 @@\n-  address a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+  address a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -114,1 +114,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::throw_div0_exception_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_throw_div0_exception_id)));\n@@ -126,1 +126,1 @@\n-NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, C1StubId stub_id) {\n+NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, StubId stub_id) {\n@@ -131,3 +131,3 @@\n-  assert(stub_id == C1StubId::new_instance_id                 ||\n-         stub_id == C1StubId::fast_new_instance_id            ||\n-         stub_id == C1StubId::fast_new_instance_init_check_id,\n+  assert(stub_id == StubId::c1_new_instance_id                 ||\n+         stub_id == StubId::c1_fast_new_instance_id            ||\n+         stub_id == StubId::c1_fast_new_instance_init_check_id,\n@@ -169,1 +169,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::new_type_array_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_new_type_array_id)));\n@@ -192,1 +192,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::new_object_array_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_new_object_array_id)));\n@@ -204,1 +204,1 @@\n-  C1StubId enter_id;\n+  StubId enter_id;\n@@ -206,1 +206,1 @@\n-    enter_id = C1StubId::monitorenter_id;\n+    enter_id = StubId::c1_monitorenter_id;\n@@ -208,1 +208,1 @@\n-    enter_id = C1StubId::monitorenter_nofpu_id;\n+    enter_id = StubId::c1_monitorenter_nofpu_id;\n@@ -225,1 +225,1 @@\n-  C1StubId exit_id;\n+  StubId exit_id;\n@@ -227,1 +227,1 @@\n-    exit_id = C1StubId::monitorexit_id;\n+    exit_id = StubId::c1_monitorexit_id;\n@@ -229,1 +229,1 @@\n-    exit_id = C1StubId::monitorexit_nofpu_id;\n+    exit_id = StubId::c1_monitorexit_nofpu_id;\n@@ -257,1 +257,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::deoptimize_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_deoptimize_id)));\n@@ -267,1 +267,1 @@\n-    a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+    a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -269,1 +269,1 @@\n-    a = Runtime1::entry_for(C1StubId::throw_null_pointer_exception_id);\n+    a = Runtime1::entry_for(StubId::c1_throw_null_pointer_exception_id);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -323,1 +323,1 @@\n-    target = Runtime1::entry_for(C1StubId::access_field_patching_id);\n+    target = Runtime1::entry_for(StubId::c1_access_field_patching_id);\n@@ -327,1 +327,1 @@\n-    target = Runtime1::entry_for(C1StubId::load_klass_patching_id);\n+    target = Runtime1::entry_for(StubId::c1_load_klass_patching_id);\n@@ -331,1 +331,1 @@\n-    target = Runtime1::entry_for(C1StubId::load_mirror_patching_id);\n+    target = Runtime1::entry_for(StubId::c1_load_mirror_patching_id);\n@@ -335,1 +335,1 @@\n-    target = Runtime1::entry_for(C1StubId::load_appendix_patching_id);\n+    target = Runtime1::entry_for(StubId::c1_load_appendix_patching_id);\n@@ -377,1 +377,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::handle_exception_from_callee_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_handle_exception_from_callee_id)));\n@@ -434,1 +434,1 @@\n-  __ far_jump(RuntimeAddress(Runtime1::entry_for(C1StubId::unwind_exception_id)));\n+  __ far_jump(RuntimeAddress(Runtime1::entry_for(StubId::c1_unwind_exception_id)));\n@@ -486,1 +486,1 @@\n-  __ safepoint_poll(*code_stub->entry(), true \/* at_return *\/, false \/* acquire *\/, true \/* in_nmethod *\/);\n+  __ safepoint_poll(*code_stub->entry(), true \/* at_return *\/, true \/* in_nmethod *\/);\n@@ -877,1 +877,1 @@\n-    target = Runtime1::entry_for(C1StubId::access_field_patching_id);\n+    target = Runtime1::entry_for(StubId::c1_access_field_patching_id);\n@@ -881,1 +881,1 @@\n-    target = Runtime1::entry_for(C1StubId::load_klass_patching_id);\n+    target = Runtime1::entry_for(StubId::c1_load_klass_patching_id);\n@@ -885,1 +885,1 @@\n-    target = Runtime1::entry_for(C1StubId::load_mirror_patching_id);\n+    target = Runtime1::entry_for(StubId::c1_load_mirror_patching_id);\n@@ -889,1 +889,1 @@\n-    target = Runtime1::entry_for(C1StubId::load_appendix_patching_id);\n+    target = Runtime1::entry_for(StubId::c1_load_appendix_patching_id);\n@@ -1361,1 +1361,1 @@\n-        __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+        __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n@@ -1372,1 +1372,1 @@\n-      __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+      __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n@@ -1450,1 +1450,1 @@\n-    __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+    __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n@@ -2036,1 +2036,1 @@\n-  C1StubId unwind_id;\n+  StubId unwind_id;\n@@ -2055,1 +2055,1 @@\n-    unwind_id = C1StubId::handle_exception_id;\n+    unwind_id = StubId::c1_handle_exception_id;\n@@ -2057,1 +2057,1 @@\n-    unwind_id = C1StubId::handle_exception_nofpu_id;\n+    unwind_id = StubId::c1_handle_exception_nofpu_id;\n@@ -2328,1 +2328,1 @@\n-      __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+      __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1248,1 +1248,1 @@\n-  __ call_runtime(Runtime1::entry_for(C1StubId::new_multi_array_id),\n+  __ call_runtime(Runtime1::entry_for(StubId::c1_new_multi_array_id),\n@@ -1279,1 +1279,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);\n+    stub = new SimpleExceptionStub(StubId::c1_throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);\n@@ -1286,1 +1286,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_class_cast_exception_id, obj.result(), info_for_exception);\n+    stub = new SimpleExceptionStub(StubId::c1_throw_class_cast_exception_id, obj.result(), info_for_exception);\n@@ -1321,1 +1321,1 @@\n-  return Runtime1::entry_for(C1StubId::is_instance_of_id);\n+  return Runtime1::entry_for(StubId::c1_is_instance_of_id);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -274,1 +274,1 @@\n-    far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::dtrace_object_alloc_id)));\n+    far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_dtrace_object_alloc_id)));\n@@ -315,1 +315,1 @@\n-    far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::dtrace_object_alloc_id)));\n+    far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_dtrace_object_alloc_id)));\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-    } else if (_stub_id == (int)C1StubId::forward_exception_id) {\n+    } else if (_stub_id == (int)StubId::c1_forward_exception_id) {\n@@ -105,1 +105,1 @@\n-      far_jump(RuntimeAddress(Runtime1::entry_for(C1StubId::forward_exception_id)));\n+      far_jump(RuntimeAddress(Runtime1::entry_for(StubId::c1_forward_exception_id)));\n@@ -353,2 +353,2 @@\n-  assert(cb == Runtime1::blob_for(C1StubId::monitorenter_id) ||\n-         cb == Runtime1::blob_for(C1StubId::monitorenter_nofpu_id), \"must be\");\n+  assert(cb == Runtime1::blob_for(StubId::c1_monitorenter_id) ||\n+         cb == Runtime1::blob_for(StubId::c1_monitorenter_nofpu_id), \"must be\");\n@@ -380,1 +380,1 @@\n-OopMapSet* Runtime1::generate_handle_exception(C1StubId id, StubAssembler *sasm) {\n+OopMapSet* Runtime1::generate_handle_exception(StubId id, StubAssembler *sasm) {\n@@ -392,1 +392,1 @@\n-  case C1StubId::forward_exception_id:\n+  case StubId::c1_forward_exception_id:\n@@ -412,2 +412,2 @@\n-  case C1StubId::handle_exception_nofpu_id:\n-  case C1StubId::handle_exception_id:\n+  case StubId::c1_handle_exception_nofpu_id:\n+  case StubId::c1_handle_exception_id:\n@@ -415,1 +415,1 @@\n-    oop_map = save_live_registers(sasm, id != C1StubId::handle_exception_nofpu_id);\n+    oop_map = save_live_registers(sasm, id != StubId::c1_handle_exception_nofpu_id);\n@@ -417,1 +417,1 @@\n-  case C1StubId::handle_exception_from_callee_id: {\n+  case StubId::c1_handle_exception_from_callee_id: {\n@@ -475,3 +475,3 @@\n-  case C1StubId::forward_exception_id:\n-  case C1StubId::handle_exception_nofpu_id:\n-  case C1StubId::handle_exception_id:\n+  case StubId::c1_forward_exception_id:\n+  case StubId::c1_handle_exception_nofpu_id:\n+  case StubId::c1_handle_exception_id:\n@@ -479,1 +479,1 @@\n-    restore_live_registers(sasm, id != C1StubId::handle_exception_nofpu_id);\n+    restore_live_registers(sasm, id != StubId::c1_handle_exception_nofpu_id);\n@@ -481,1 +481,1 @@\n-  case C1StubId::handle_exception_from_callee_id:\n+  case StubId::c1_handle_exception_from_callee_id:\n@@ -633,1 +633,1 @@\n-OopMapSet* Runtime1::generate_code_for(C1StubId id, StubAssembler* sasm) {\n+OopMapSet* Runtime1::generate_code_for(StubId id, StubAssembler* sasm) {\n@@ -650,1 +650,1 @@\n-    case C1StubId::forward_exception_id:\n+    case StubId::c1_forward_exception_id:\n@@ -658,1 +658,1 @@\n-    case C1StubId::throw_div0_exception_id:\n+    case StubId::c1_throw_div0_exception_id:\n@@ -664,1 +664,1 @@\n-    case C1StubId::throw_null_pointer_exception_id:\n+    case StubId::c1_throw_null_pointer_exception_id:\n@@ -670,3 +670,3 @@\n-    case C1StubId::new_instance_id:\n-    case C1StubId::fast_new_instance_id:\n-    case C1StubId::fast_new_instance_init_check_id:\n+    case StubId::c1_new_instance_id:\n+    case StubId::c1_fast_new_instance_id:\n+    case StubId::c1_fast_new_instance_init_check_id:\n@@ -677,1 +677,1 @@\n-        if (id == C1StubId::new_instance_id) {\n+        if (id == StubId::c1_new_instance_id) {\n@@ -679,1 +679,1 @@\n-        } else if (id == C1StubId::fast_new_instance_id) {\n+        } else if (id == StubId::c1_fast_new_instance_id) {\n@@ -682,1 +682,1 @@\n-          assert(id == C1StubId::fast_new_instance_init_check_id, \"bad C1StubId\");\n+          assert(id == StubId::c1_fast_new_instance_init_check_id, \"bad StubId\");\n@@ -701,1 +701,1 @@\n-    case C1StubId::counter_overflow_id:\n+    case StubId::c1_counter_overflow_id:\n@@ -719,2 +719,2 @@\n-    case C1StubId::new_type_array_id:\n-    case C1StubId::new_object_array_id:\n+    case StubId::c1_new_type_array_id:\n+    case StubId::c1_new_object_array_id:\n@@ -726,1 +726,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -739,1 +739,1 @@\n-          int tag = ((id == C1StubId::new_type_array_id)\n+          int tag = ((id == StubId::c1_new_type_array_id)\n@@ -754,1 +754,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -772,1 +772,1 @@\n-    case C1StubId::new_multi_array_id:\n+    case StubId::c1_new_multi_array_id:\n@@ -792,1 +792,1 @@\n-    case C1StubId::register_finalizer_id:\n+    case StubId::c1_register_finalizer_id:\n@@ -824,1 +824,1 @@\n-    case C1StubId::throw_class_cast_exception_id:\n+    case StubId::c1_throw_class_cast_exception_id:\n@@ -830,1 +830,1 @@\n-    case C1StubId::throw_incompatible_class_change_error_id:\n+    case StubId::c1_throw_incompatible_class_change_error_id:\n@@ -836,1 +836,1 @@\n-    case C1StubId::slow_subtype_check_id:\n+    case StubId::c1_slow_subtype_check_id:\n@@ -885,1 +885,1 @@\n-    case C1StubId::monitorenter_nofpu_id:\n+    case StubId::c1_monitorenter_nofpu_id:\n@@ -888,1 +888,1 @@\n-    case C1StubId::monitorenter_id:\n+    case StubId::c1_monitorenter_id:\n@@ -906,1 +906,1 @@\n-    case C1StubId::is_instance_of_id:\n+    case StubId::c1_is_instance_of_id:\n@@ -955,1 +955,1 @@\n-    case C1StubId::monitorexit_nofpu_id:\n+    case StubId::c1_monitorexit_nofpu_id:\n@@ -958,1 +958,1 @@\n-    case C1StubId::monitorexit_id:\n+    case StubId::c1_monitorexit_id:\n@@ -978,1 +978,1 @@\n-    case C1StubId::deoptimize_id:\n+    case StubId::c1_deoptimize_id:\n@@ -995,1 +995,1 @@\n-    case C1StubId::throw_range_check_failed_id:\n+    case StubId::c1_throw_range_check_failed_id:\n@@ -1001,1 +1001,1 @@\n-    case C1StubId::unwind_exception_id:\n+    case StubId::c1_unwind_exception_id:\n@@ -1009,1 +1009,1 @@\n-    case C1StubId::access_field_patching_id:\n+    case StubId::c1_access_field_patching_id:\n@@ -1016,1 +1016,1 @@\n-    case C1StubId::load_klass_patching_id:\n+    case StubId::c1_load_klass_patching_id:\n@@ -1023,1 +1023,1 @@\n-    case C1StubId::load_mirror_patching_id:\n+    case StubId::c1_load_mirror_patching_id:\n@@ -1030,1 +1030,1 @@\n-    case C1StubId::load_appendix_patching_id:\n+    case StubId::c1_load_appendix_patching_id:\n@@ -1037,2 +1037,2 @@\n-    case C1StubId::handle_exception_nofpu_id:\n-    case C1StubId::handle_exception_id:\n+    case StubId::c1_handle_exception_nofpu_id:\n+    case StubId::c1_handle_exception_id:\n@@ -1044,1 +1044,1 @@\n-    case C1StubId::handle_exception_from_callee_id:\n+    case StubId::c1_handle_exception_from_callee_id:\n@@ -1050,1 +1050,1 @@\n-    case C1StubId::throw_index_exception_id:\n+    case StubId::c1_throw_index_exception_id:\n@@ -1056,1 +1056,1 @@\n-    case C1StubId::throw_array_store_exception_id:\n+    case StubId::c1_throw_array_store_exception_id:\n@@ -1064,1 +1064,1 @@\n-    case C1StubId::predicate_failed_trap_id:\n+    case StubId::c1_predicate_failed_trap_id:\n@@ -1082,1 +1082,1 @@\n-    case C1StubId::dtrace_object_alloc_id:\n+    case StubId::c1_dtrace_object_alloc_id:\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":55,"deletions":55,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -444,2 +444,2 @@\n-  if (cb == Runtime1::blob_for(C1StubId::monitorenter_id) ||\n-      cb == Runtime1::blob_for(C1StubId::monitorenter_nofpu_id)) {\n+  if (cb == Runtime1::blob_for(StubId::c1_monitorenter_id) ||\n+      cb == Runtime1::blob_for(StubId::c1_monitorenter_nofpu_id)) {\n@@ -831,1 +831,0 @@\n-  vmassert(last_Java_pc() == nullptr, \"already walkable\");\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -556,7 +556,2 @@\n-void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod, Register tmp) {\n-  if (acquire) {\n-    lea(tmp, Address(rthread, JavaThread::polling_word_offset()));\n-    ldar(tmp, tmp);\n-  } else {\n-    ldr(tmp, Address(rthread, JavaThread::polling_word_offset()));\n-  }\n+void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool in_nmethod, Register tmp) {\n+  ldr(tmp, Address(rthread, JavaThread::polling_word_offset()));\n@@ -992,2 +987,6 @@\n-  movptr(rscratch1, 0);\n-  br(rscratch1);\n+  if (codestub_branch_needs_far_jump()) {\n+    movptr(rscratch1, 0);\n+    br(rscratch1);\n+  } else {\n+    b(pc());\n+  }\n@@ -997,0 +996,4 @@\n+  if (!codestub_branch_needs_far_jump()) {\n+    \/\/ isb; movk; movz; movz; b\n+    return 5 * NativeInstruction::instruction_size;\n+  }\n@@ -5343,0 +5346,29 @@\n+static Register pick_different_tmp(Register dst, Register src) {\n+  auto tmps = RegSet::of(r0, r1, r2) - RegSet::of(src, dst);\n+  return *tmps.begin();\n+}\n+\n+void MacroAssembler::encode_klass_not_null_for_aot(Register dst, Register src) {\n+  \/\/ we have to load the klass base from the AOT constants area but\n+  \/\/ not the shift because it is not allowed to change\n+  int shift = CompressedKlassPointers::shift();\n+  assert(shift >= 0 && shift <= CompressedKlassPointers::max_shift(), \"unexpected compressed klass shift!\");\n+  if (dst != src) {\n+    \/\/ we can load the base into dst, subtract it formthe src and shift down\n+    lea(dst, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    ldr(dst, dst);\n+    sub(dst, src, dst);\n+    lsr(dst, dst, shift);\n+  } else {\n+    \/\/ we need an extra register in order to load the coop base\n+    Register tmp = pick_different_tmp(dst, src);\n+    RegSet regs = RegSet::of(tmp);\n+    push(regs, sp);\n+    lea(tmp, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    ldr(tmp, tmp);\n+    sub(dst, src, tmp);\n+    lsr(dst, dst, shift);\n+    pop(regs, sp);\n+  }\n+}\n+\n@@ -5344,0 +5376,5 @@\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    encode_klass_not_null_for_aot(dst, src);\n+    return;\n+  }\n+\n@@ -5380,0 +5417,22 @@\n+void MacroAssembler::decode_klass_not_null_for_aot(Register dst, Register src) {\n+  \/\/ we have to load the klass base from the AOT constants area but\n+  \/\/ not the shift because it is not allowed to change\n+  int shift = CompressedKlassPointers::shift();\n+  assert(shift >= 0 && shift <= CompressedKlassPointers::max_shift(), \"unexpected compressed klass shift!\");\n+  if (dst != src) {\n+    \/\/ we can load the base into dst then add the offset with a suitable shift\n+    lea(dst, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    ldr(dst, dst);\n+    add(dst, dst, src, LSL,  shift);\n+  } else {\n+    \/\/ we need an extra register in order to load the coop base\n+    Register tmp = pick_different_tmp(dst, src);\n+    RegSet regs = RegSet::of(tmp);\n+    push(regs, sp);\n+    lea(tmp, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    ldr(tmp, tmp);\n+    add(dst, tmp,  src, LSL,  shift);\n+    pop(regs, sp);\n+  }\n+}\n+\n@@ -5383,0 +5442,5 @@\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    decode_klass_not_null_for_aot(dst, src);\n+    return;\n+  }\n+\n@@ -6653,1 +6717,1 @@\n-  mov(lr, CAST_FROM_FN_PTR(address, JavaThread::aarch64_get_thread_helper));\n+  mov(lr, ExternalAddress(CAST_FROM_FN_PTR(address, JavaThread::aarch64_get_thread_helper)));\n@@ -6749,0 +6813,3 @@\n+      case SpinWait::SB:\n+        sb();\n+        break;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":77,"deletions":10,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -63,0 +64,6 @@\n+  const char* name = OptoRuntime::stub_name(StubId::c2_uncommon_trap_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, BlobId::c2_uncommon_trap_id);\n+  if (blob != nullptr) {\n+    return blob->as_uncommon_trap_blob();\n+  }\n+\n@@ -66,1 +73,0 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n@@ -249,2 +255,4 @@\n-  return UncommonTrapBlob::create(&buffer, oop_maps,\n-                                                 SimpleRuntimeFrame::framesize >> 1);\n+  UncommonTrapBlob *ut_blob = UncommonTrapBlob::create(&buffer, oop_maps,\n+                                                       SimpleRuntimeFrame::framesize >> 1);\n+  AOTCodeCache::store_code_blob(*ut_blob, AOTCodeEntry::C2Blob, BlobId::c2_uncommon_trap_id);\n+  return ut_blob;\n@@ -286,0 +294,6 @@\n+  const char* name = OptoRuntime::stub_name(StubId::c2_exception_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, (uint)BlobId::c2_exception_id, name);\n+  if (blob != nullptr) {\n+    return blob->as_exception_blob();\n+  }\n+\n@@ -289,1 +303,0 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n@@ -387,1 +400,3 @@\n-  return ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n+  ExceptionBlob* ex_blob = ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n+  AOTCodeCache::store_code_blob(*ex_blob, AOTCodeEntry::C2Blob, BlobId::c2_exception_id);\n+  return ex_blob;\n","filename":"src\/hotspot\/cpu\/aarch64\/runtime_aarch64.cpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -1879,1 +1880,1 @@\n-    __ safepoint_poll(safepoint_in_progress, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+    __ safepoint_poll(safepoint_in_progress, true \/* at_return *\/, false \/* in_nmethod *\/);\n@@ -1987,0 +1988,17 @@\n+  #if INCLUDE_JFR\n+  \/\/ We need to do a poll test after unwind in case the sampler\n+  \/\/ managed to sample the native frame after returning to Java.\n+  Label L_return;\n+  __ ldr(rscratch1, Address(rthread, JavaThread::polling_word_offset()));\n+  address poll_test_pc = __ pc();\n+  __ relocate(relocInfo::poll_return_type);\n+  __ tbz(rscratch1, log2i_exact(SafepointMechanism::poll_bit()), L_return);\n+  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n+    \"polling page return stub not created yet\");\n+  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+  __ adr(rscratch1, InternalAddress(poll_test_pc));\n+  __ str(rscratch1, Address(rthread, JavaThread::saved_exception_pc_offset()));\n+  __ far_jump(RuntimeAddress(stub));\n+  __ bind(L_return);\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -2186,1 +2204,7 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::deopt_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_deopt_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, BlobId::shared_deopt_id);\n+  if (blob != nullptr) {\n+    _deopt_blob = blob->as_deoptimization_blob();\n+    return;\n+  }\n+\n@@ -2550,0 +2574,2 @@\n+\n+  AOTCodeCache::store_code_blob(*_deopt_blob, AOTCodeEntry::SharedBlob, BlobId::shared_deopt_id);\n@@ -2575,1 +2601,1 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(StubId id, address call_ptr) {\n@@ -2578,0 +2604,7 @@\n+  \/\/ Allocate space for the code.  Setup code generation tools.\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n+  if (blob != nullptr) {\n+    return blob->as_safepoint_blob();\n+  }\n+\n@@ -2581,3 +2614,0 @@\n-\n-  \/\/ Allocate space for the code.  Setup code generation tools.\n-  const char* name = SharedRuntime::stub_name(id);\n@@ -2590,2 +2620,2 @@\n-  bool cause_return = (id == SharedStubId::polling_page_return_handler_id);\n-  RegisterSaver reg_save(id == SharedStubId::polling_page_vectors_safepoint_handler_id \/* save_vectors *\/);\n+  bool cause_return = (id == StubId::shared_polling_page_return_handler_id);\n+  RegisterSaver reg_save(id == StubId::shared_polling_page_vectors_safepoint_handler_id \/* save_vectors *\/);\n@@ -2692,1 +2722,4 @@\n-  return SafepointBlob::create(&buffer, oop_maps, frame_size_in_words);\n+  SafepointBlob* sp_blob = SafepointBlob::create(&buffer, oop_maps, frame_size_in_words);\n+\n+  AOTCodeCache::store_code_blob(*sp_blob, AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n+  return sp_blob;\n@@ -2703,1 +2736,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(StubId id, address destination) {\n@@ -2707,0 +2740,6 @@\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n+  if (blob != nullptr) {\n+    return blob->as_runtime_stub();\n+  }\n+\n@@ -2709,2 +2748,0 @@\n-\n-  const char* name = SharedRuntime::stub_name(id);\n@@ -2783,1 +2820,4 @@\n-  return RuntimeStub::new_runtime_stub(name, &buffer, frame_complete, frame_size_in_words, oop_maps, true);\n+  RuntimeStub* rs_blob = RuntimeStub::new_runtime_stub(name, &buffer, frame_complete, frame_size_in_words, oop_maps, true);\n+\n+  AOTCodeCache::store_code_blob(*rs_blob, AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n+  return rs_blob;\n@@ -2802,1 +2842,1 @@\n-RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+RuntimeStub* SharedRuntime::generate_throw_exception(StubId id, address runtime_entry) {\n@@ -2823,1 +2863,0 @@\n-  ResourceMark rm;\n@@ -2827,0 +2866,6 @@\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n+  if (blob != nullptr) {\n+    return blob->as_runtime_stub();\n+  }\n+\n+  ResourceMark rm;\n@@ -2853,1 +2898,1 @@\n-  __ mov(rscratch1, runtime_entry);\n+  __ lea(rscratch1, RuntimeAddress(runtime_entry));\n@@ -2886,0 +2931,2 @@\n+  AOTCodeCache::store_code_blob(*stub, AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n+\n@@ -2915,1 +2962,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_write_checkpoint_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_jfr_write_checkpoint_id);\n@@ -2954,1 +3001,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_return_lease_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_jfr_return_lease_id);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":65,"deletions":18,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-    StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+    StubId stub_id = StubId::stubgen_call_stub_id;\n@@ -425,1 +425,1 @@\n-    StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+    StubId stub_id = StubId::stubgen_catch_exception_id;\n@@ -481,1 +481,1 @@\n-    StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+    StubId stub_id = StubId::stubgen_forward_exception_id;\n@@ -571,1 +571,1 @@\n-    StubGenStubId stub_id = StubGenStubId::verify_oop_id;\n+    StubId stub_id = StubId::stubgen_verify_oop_id;\n@@ -620,1 +620,1 @@\n-  address generate_iota_indices(StubGenStubId stub_id) {\n+  address generate_iota_indices(StubId stub_id) {\n@@ -665,1 +665,1 @@\n-    StubGenStubId stub_id = StubGenStubId::zero_blocks_id;\n+    StubId stub_id = StubId::stubgen_zero_blocks_id;\n@@ -805,1 +805,1 @@\n-  void generate_copy_longs(StubGenStubId stub_id, DecoratorSet decorators, Label &start, Register s, Register d, Register count) {\n+  void generate_copy_longs(StubId stub_id, DecoratorSet decorators, Label &start, Register s, Register d, Register count) {\n@@ -810,1 +810,1 @@\n-    case copy_byte_f_id:\n+    case StubId::stubgen_copy_byte_f_id:\n@@ -814,1 +814,1 @@\n-    case copy_byte_b_id:\n+    case StubId::stubgen_copy_byte_b_id:\n@@ -818,1 +818,1 @@\n-    case copy_oop_f_id:\n+    case StubId::stubgen_copy_oop_f_id:\n@@ -822,1 +822,1 @@\n-    case copy_oop_b_id:\n+    case StubId::stubgen_copy_oop_b_id:\n@@ -826,1 +826,1 @@\n-    case copy_oop_uninit_f_id:\n+    case StubId::stubgen_copy_oop_uninit_f_id:\n@@ -830,1 +830,1 @@\n-    case copy_oop_uninit_b_id:\n+    case StubId::stubgen_copy_oop_uninit_b_id:\n@@ -1529,1 +1529,1 @@\n-  address generate_disjoint_copy(StubGenStubId stub_id, address *entry) {\n+  address generate_disjoint_copy(StubId stub_id, address *entry) {\n@@ -1537,1 +1537,1 @@\n-    case jbyte_disjoint_arraycopy_id:\n+    case StubId::stubgen_jbyte_disjoint_arraycopy_id:\n@@ -1543,1 +1543,1 @@\n-    case arrayof_jbyte_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id:\n@@ -1549,1 +1549,1 @@\n-    case jshort_disjoint_arraycopy_id:\n+    case StubId::stubgen_jshort_disjoint_arraycopy_id:\n@@ -1555,1 +1555,1 @@\n-    case arrayof_jshort_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id:\n@@ -1561,1 +1561,1 @@\n-    case jint_disjoint_arraycopy_id:\n+    case StubId::stubgen_jint_disjoint_arraycopy_id:\n@@ -1567,1 +1567,1 @@\n-    case arrayof_jint_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jint_disjoint_arraycopy_id:\n@@ -1573,1 +1573,1 @@\n-    case jlong_disjoint_arraycopy_id:\n+    case StubId::stubgen_jlong_disjoint_arraycopy_id:\n@@ -1575,1 +1575,1 @@\n-      \/\/ stub as for case arrayof_jlong_disjoint_arraycopy\n+      \/\/ stub as for case StubId::stubgen_arrayof_jlong_disjoint_arraycopy\n@@ -1578,1 +1578,1 @@\n-    case arrayof_jlong_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id:\n@@ -1584,1 +1584,1 @@\n-    case oop_disjoint_arraycopy_id:\n+    case StubId::stubgen_oop_disjoint_arraycopy_id:\n@@ -1590,1 +1590,1 @@\n-    case arrayof_oop_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_oop_disjoint_arraycopy_id:\n@@ -1596,1 +1596,1 @@\n-    case oop_disjoint_arraycopy_uninit_id:\n+    case StubId::stubgen_oop_disjoint_arraycopy_uninit_id:\n@@ -1602,1 +1602,1 @@\n-    case arrayof_oop_disjoint_arraycopy_uninit_id:\n+    case StubId::stubgen_arrayof_oop_disjoint_arraycopy_uninit_id:\n@@ -1685,1 +1685,1 @@\n-  address generate_conjoint_copy(StubGenStubId stub_id, address nooverlap_target, address *entry) {\n+  address generate_conjoint_copy(StubId stub_id, address nooverlap_target, address *entry) {\n@@ -1693,1 +1693,1 @@\n-    case jbyte_arraycopy_id:\n+    case StubId::stubgen_jbyte_arraycopy_id:\n@@ -1699,1 +1699,1 @@\n-    case arrayof_jbyte_arraycopy_id:\n+    case StubId::stubgen_arrayof_jbyte_arraycopy_id:\n@@ -1705,1 +1705,1 @@\n-    case jshort_arraycopy_id:\n+    case StubId::stubgen_jshort_arraycopy_id:\n@@ -1711,1 +1711,1 @@\n-    case arrayof_jshort_arraycopy_id:\n+    case StubId::stubgen_arrayof_jshort_arraycopy_id:\n@@ -1717,1 +1717,1 @@\n-    case jint_arraycopy_id:\n+    case StubId::stubgen_jint_arraycopy_id:\n@@ -1723,1 +1723,1 @@\n-    case arrayof_jint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jint_arraycopy_id:\n@@ -1729,1 +1729,1 @@\n-    case jlong_arraycopy_id:\n+    case StubId::stubgen_jlong_arraycopy_id:\n@@ -1731,1 +1731,1 @@\n-      \/\/ stub as for case arrayof_jlong_disjoint_arraycopy\n+      \/\/ stub as for case StubId::stubgen_arrayof_jlong_disjoint_arraycopy\n@@ -1734,1 +1734,1 @@\n-    case arrayof_jlong_arraycopy_id:\n+    case StubId::stubgen_arrayof_jlong_arraycopy_id:\n@@ -1740,1 +1740,1 @@\n-    case oop_arraycopy_id:\n+    case StubId::stubgen_oop_arraycopy_id:\n@@ -1746,1 +1746,1 @@\n-    case arrayof_oop_arraycopy_id:\n+    case StubId::stubgen_arrayof_oop_arraycopy_id:\n@@ -1752,1 +1752,1 @@\n-    case oop_arraycopy_uninit_id:\n+    case StubId::stubgen_oop_arraycopy_uninit_id:\n@@ -1758,1 +1758,1 @@\n-    case arrayof_oop_arraycopy_uninit_id:\n+    case StubId::stubgen_arrayof_oop_arraycopy_uninit_id:\n@@ -1853,1 +1853,1 @@\n-  address generate_checkcast_copy(StubGenStubId stub_id, address *entry) {\n+  address generate_checkcast_copy(StubId stub_id, address *entry) {\n@@ -1856,1 +1856,1 @@\n-    case checkcast_arraycopy_id:\n+    case StubId::stubgen_checkcast_arraycopy_id:\n@@ -1859,1 +1859,1 @@\n-    case checkcast_arraycopy_uninit_id:\n+    case StubId::stubgen_checkcast_arraycopy_uninit_id:\n@@ -2074,1 +2074,1 @@\n-    StubGenStubId stub_id = StubGenStubId::unsafe_arraycopy_id;\n+    StubId stub_id = StubId::stubgen_unsafe_arraycopy_id;\n@@ -2127,1 +2127,1 @@\n-    StubGenStubId stub_id = StubGenStubId::generic_arraycopy_id;\n+    StubId stub_id = StubId::stubgen_generic_arraycopy_id;\n@@ -2398,1 +2398,1 @@\n-  address generate_fill(StubGenStubId stub_id) {\n+  address generate_fill(StubId stub_id) {\n@@ -2403,1 +2403,1 @@\n-    case jbyte_fill_id:\n+    case StubId::stubgen_jbyte_fill_id:\n@@ -2407,1 +2407,1 @@\n-    case jshort_fill_id:\n+    case StubId::stubgen_jshort_fill_id:\n@@ -2411,1 +2411,1 @@\n-    case jint_fill_id:\n+    case StubId::stubgen_jint_fill_id:\n@@ -2415,1 +2415,1 @@\n-    case arrayof_jbyte_fill_id:\n+    case StubId::stubgen_arrayof_jbyte_fill_id:\n@@ -2419,1 +2419,1 @@\n-    case arrayof_jshort_fill_id:\n+    case StubId::stubgen_arrayof_jshort_fill_id:\n@@ -2423,1 +2423,1 @@\n-    case arrayof_jint_fill_id:\n+    case StubId::stubgen_arrayof_jint_fill_id:\n@@ -2569,0 +2569,117 @@\n+  address generate_unsafecopy_common_error_exit() {\n+    address start_pc = __ pc();\n+      __ leave();\n+      __ mov(r0, 0);\n+      __ ret(lr);\n+    return start_pc;\n+  }\n+\n+  \/\/\n+  \/\/  Generate 'unsafe' set memory stub\n+  \/\/  Though just as safe as the other stubs, it takes an unscaled\n+  \/\/  size_t (# bytes) argument instead of an element count.\n+  \/\/\n+  \/\/  This fill operation is atomicity preserving: as long as the\n+  \/\/  address supplied is sufficiently aligned, all writes of up to 64\n+  \/\/  bits in size are single-copy atomic.\n+  \/\/\n+  \/\/  Input:\n+  \/\/    c_rarg0   - destination array address\n+  \/\/    c_rarg1   - byte count (size_t)\n+  \/\/    c_rarg2   - byte value\n+  \/\/\n+  address generate_unsafe_setmemory() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, StubId::stubgen_unsafe_setmemory_id);\n+    address start = __ pc();\n+\n+    Register dest = c_rarg0, count = c_rarg1, value = c_rarg2;\n+    Label tail;\n+\n+    UnsafeMemoryAccessMark umam(this, true, false);\n+\n+    __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+    __ dup(v0, __ T16B, value);\n+\n+    if (AvoidUnalignedAccesses) {\n+      __ cmp(count, (u1)16);\n+      __ br(__ LO, tail);\n+\n+      __ mov(rscratch1, 16);\n+      __ andr(rscratch2, dest, 15);\n+      __ sub(rscratch1, rscratch1, rscratch2);  \/\/ Bytes needed to 16-align dest\n+      __ strq(v0, Address(dest));\n+      __ sub(count, count, rscratch1);\n+      __ add(dest, dest, rscratch1);\n+    }\n+\n+    __ subs(count, count, (u1)64);\n+    __ br(__ LO, tail);\n+    {\n+      Label again;\n+      __ bind(again);\n+      __ stpq(v0, v0, Address(dest));\n+      __ stpq(v0, v0, Address(dest, 32));\n+\n+      __ subs(count, count, 64);\n+      __ add(dest, dest, 64);\n+      __ br(__ HS, again);\n+    }\n+\n+    __ bind(tail);\n+    \/\/ The count of bytes is off by 64, but we don't need to correct\n+    \/\/ it because we're only going to use the least-significant few\n+    \/\/ count bits from here on.\n+    \/\/ __ add(count, count, 64);\n+\n+    {\n+      Label dont;\n+      __ tbz(count, exact_log2(32), dont);\n+      __ stpq(v0, v0, __ post(dest, 32));\n+      __ bind(dont);\n+    }\n+    {\n+      Label dont;\n+      __ tbz(count, exact_log2(16), dont);\n+      __ strq(v0, __ post(dest, 16));\n+      __ bind(dont);\n+    }\n+    {\n+      Label dont;\n+      __ tbz(count, exact_log2(8), dont);\n+      __ strd(v0, __ post(dest, 8));\n+      __ bind(dont);\n+    }\n+\n+    Label finished;\n+    __ tst(count, 7);\n+    __ br(__ EQ, finished);\n+\n+    {\n+      Label dont;\n+      __ tbz(count, exact_log2(4), dont);\n+      __ strs(v0, __ post(dest, 4));\n+      __ bind(dont);\n+    }\n+    {\n+      Label dont;\n+      __ tbz(count, exact_log2(2), dont);\n+      __ bfi(value, value, 8, 8);\n+      __ strh(value, __ post(dest, 2));\n+      __ bind(dont);\n+    }\n+    {\n+      Label dont;\n+      __ tbz(count, exact_log2(1), dont);\n+      __ strb(value, Address(dest));\n+      __ bind(dont);\n+    }\n+\n+    __ bind(finished);\n+    __ leave();\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -2574,1 +2691,1 @@\n-    StubGenStubId stub_id = StubGenStubId::data_cache_writeback_id;\n+    StubId stub_id = StubId::stubgen_data_cache_writeback_id;\n@@ -2591,1 +2708,1 @@\n-    StubGenStubId stub_id = StubGenStubId::data_cache_writeback_sync_id;\n+    StubId stub_id = StubId::stubgen_data_cache_writeback_sync_id;\n@@ -2618,2 +2735,2 @@\n-    generate_copy_longs(StubGenStubId::copy_byte_f_id, IN_HEAP | IS_ARRAY, copy_f, r0, r1, r15);\n-    generate_copy_longs(StubGenStubId::copy_byte_b_id, IN_HEAP | IS_ARRAY, copy_b, r0, r1, r15);\n+    address ucm_common_error_exit       =  generate_unsafecopy_common_error_exit();\n+    UnsafeMemoryAccess::set_common_exit_stub_pc(ucm_common_error_exit);\n@@ -2621,2 +2738,2 @@\n-    generate_copy_longs(StubGenStubId::copy_oop_f_id, IN_HEAP | IS_ARRAY, copy_obj_f, r0, r1, r15);\n-    generate_copy_longs(StubGenStubId::copy_oop_b_id, IN_HEAP | IS_ARRAY, copy_obj_b, r0, r1, r15);\n+    generate_copy_longs(StubId::stubgen_copy_byte_f_id, IN_HEAP | IS_ARRAY, copy_f, r0, r1, r15);\n+    generate_copy_longs(StubId::stubgen_copy_byte_b_id, IN_HEAP | IS_ARRAY, copy_b, r0, r1, r15);\n@@ -2624,2 +2741,5 @@\n-    generate_copy_longs(StubGenStubId::copy_oop_uninit_f_id, IN_HEAP | IS_ARRAY | IS_DEST_UNINITIALIZED, copy_obj_uninit_f, r0, r1, r15);\n-    generate_copy_longs(StubGenStubId::copy_oop_uninit_b_id, IN_HEAP | IS_ARRAY | IS_DEST_UNINITIALIZED, copy_obj_uninit_b, r0, r1, r15);\n+    generate_copy_longs(StubId::stubgen_copy_oop_f_id, IN_HEAP | IS_ARRAY, copy_obj_f, r0, r1, r15);\n+    generate_copy_longs(StubId::stubgen_copy_oop_b_id, IN_HEAP | IS_ARRAY, copy_obj_b, r0, r1, r15);\n+\n+    generate_copy_longs(StubId::stubgen_copy_oop_uninit_f_id, IN_HEAP | IS_ARRAY | IS_DEST_UNINITIALIZED, copy_obj_uninit_f, r0, r1, r15);\n+    generate_copy_longs(StubId::stubgen_copy_oop_uninit_b_id, IN_HEAP | IS_ARRAY | IS_DEST_UNINITIALIZED, copy_obj_uninit_b, r0, r1, r15);\n@@ -2631,4 +2751,4 @@\n-    StubRoutines::_jbyte_disjoint_arraycopy         = generate_disjoint_copy(StubGenStubId::jbyte_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_jbyte_arraycopy                  = generate_conjoint_copy(StubGenStubId::jbyte_arraycopy_id, entry, &entry_jbyte_arraycopy);\n-    StubRoutines::_arrayof_jbyte_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jbyte_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jbyte_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jbyte_arraycopy_id, entry, nullptr);\n+    StubRoutines::_jbyte_disjoint_arraycopy         = generate_disjoint_copy(StubId::stubgen_jbyte_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jbyte_arraycopy                  = generate_conjoint_copy(StubId::stubgen_jbyte_arraycopy_id, entry, &entry_jbyte_arraycopy);\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jbyte_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jbyte_arraycopy_id, entry, nullptr);\n@@ -2638,4 +2758,4 @@\n-    StubRoutines::_jshort_disjoint_arraycopy         = generate_disjoint_copy(StubGenStubId::jshort_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_jshort_arraycopy                  = generate_conjoint_copy(StubGenStubId::jshort_arraycopy_id, entry, &entry_jshort_arraycopy);\n-    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jshort_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jshort_arraycopy_id, entry, nullptr);\n+    StubRoutines::_jshort_disjoint_arraycopy         = generate_disjoint_copy(StubId::stubgen_jshort_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jshort_arraycopy                  = generate_conjoint_copy(StubId::stubgen_jshort_arraycopy_id, entry, &entry_jshort_arraycopy);\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jshort_arraycopy_id, entry, nullptr);\n@@ -2645,2 +2765,2 @@\n-    StubRoutines::_arrayof_jint_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jint_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jint_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jint_arraycopy_id, entry, &entry_jint_arraycopy);\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jint_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jint_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jint_arraycopy_id, entry, &entry_jint_arraycopy);\n@@ -2649,2 +2769,2 @@\n-    StubRoutines::_jint_disjoint_arraycopy         = generate_disjoint_copy(StubGenStubId::jint_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_jint_arraycopy                  = generate_conjoint_copy(StubGenStubId::jint_arraycopy_id, entry, &entry_jint_arraycopy);\n+    StubRoutines::_jint_disjoint_arraycopy         = generate_disjoint_copy(StubId::stubgen_jint_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jint_arraycopy                  = generate_conjoint_copy(StubId::stubgen_jint_arraycopy_id, entry, &entry_jint_arraycopy);\n@@ -2654,2 +2774,2 @@\n-    StubRoutines::_arrayof_jlong_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jlong_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jlong_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jlong_arraycopy_id, entry, &entry_jlong_arraycopy);\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jlong_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jlong_arraycopy_id, entry, &entry_jlong_arraycopy);\n@@ -2666,1 +2786,1 @@\n-        = generate_disjoint_copy(StubGenStubId::arrayof_oop_disjoint_arraycopy_id, &entry);\n+        = generate_disjoint_copy(StubId::stubgen_arrayof_oop_disjoint_arraycopy_id, &entry);\n@@ -2668,1 +2788,1 @@\n-        = generate_conjoint_copy(StubGenStubId::arrayof_oop_arraycopy_id, entry, &entry_oop_arraycopy);\n+        = generate_conjoint_copy(StubId::stubgen_arrayof_oop_arraycopy_id, entry, &entry_oop_arraycopy);\n@@ -2671,1 +2791,1 @@\n-        = generate_disjoint_copy(StubGenStubId::arrayof_oop_disjoint_arraycopy_uninit_id, &entry);\n+        = generate_disjoint_copy(StubId::stubgen_arrayof_oop_disjoint_arraycopy_uninit_id, &entry);\n@@ -2673,1 +2793,1 @@\n-        = generate_conjoint_copy(StubGenStubId::arrayof_oop_arraycopy_uninit_id, entry, nullptr);\n+        = generate_conjoint_copy(StubId::stubgen_arrayof_oop_arraycopy_uninit_id, entry, nullptr);\n@@ -2681,2 +2801,2 @@\n-    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_id, &entry_checkcast_arraycopy);\n-    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_uninit_id, nullptr);\n+    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubId::stubgen_checkcast_arraycopy_id, &entry_checkcast_arraycopy);\n+    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubId::stubgen_checkcast_arraycopy_uninit_id, nullptr);\n@@ -2696,6 +2816,6 @@\n-    StubRoutines::_jbyte_fill = generate_fill(StubGenStubId::jbyte_fill_id);\n-    StubRoutines::_jshort_fill = generate_fill(StubGenStubId::jshort_fill_id);\n-    StubRoutines::_jint_fill = generate_fill(StubGenStubId::jint_fill_id);\n-    StubRoutines::_arrayof_jbyte_fill = generate_fill(StubGenStubId::arrayof_jbyte_fill_id);\n-    StubRoutines::_arrayof_jshort_fill = generate_fill(StubGenStubId::arrayof_jshort_fill_id);\n-    StubRoutines::_arrayof_jint_fill = generate_fill(StubGenStubId::arrayof_jint_fill_id);\n+    StubRoutines::_jbyte_fill = generate_fill(StubId::stubgen_jbyte_fill_id);\n+    StubRoutines::_jshort_fill = generate_fill(StubId::stubgen_jshort_fill_id);\n+    StubRoutines::_jint_fill = generate_fill(StubId::stubgen_jint_fill_id);\n+    StubRoutines::_arrayof_jbyte_fill = generate_fill(StubId::stubgen_arrayof_jbyte_fill_id);\n+    StubRoutines::_arrayof_jshort_fill = generate_fill(StubId::stubgen_arrayof_jshort_fill_id);\n+    StubRoutines::_arrayof_jint_fill = generate_fill(StubId::stubgen_arrayof_jint_fill_id);\n@@ -2715,1 +2835,1 @@\n-    StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+    StubId stub_id = StubId::stubgen_aescrypt_encryptBlock_id;\n@@ -2749,1 +2869,1 @@\n-    StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+    StubId stub_id = StubId::stubgen_aescrypt_decryptBlock_id;\n@@ -2788,1 +2908,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_encryptAESCrypt_id;\n+    StubId stub_id = StubId::stubgen_cipherBlockChaining_encryptAESCrypt_id;\n@@ -2893,1 +3013,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_decryptAESCrypt_id;\n+    StubId stub_id = StubId::stubgen_cipherBlockChaining_decryptAESCrypt_id;\n@@ -3080,1 +3200,1 @@\n-    StubGenStubId stub_id = StubGenStubId::counterMode_AESCrypt_id;\n+    StubId stub_id = StubId::stubgen_counterMode_AESCrypt_id;\n@@ -3290,1 +3410,1 @@\n-    StubGenStubId stub_id = StubGenStubId::galoisCounterMode_AESCrypt_id;\n+    StubId stub_id = StubId::stubgen_galoisCounterMode_AESCrypt_id;\n@@ -3500,1 +3620,1 @@\n-  address generate_md5_implCompress(StubGenStubId stub_id) {\n+  address generate_md5_implCompress(StubId stub_id) {\n@@ -3503,1 +3623,1 @@\n-    case md5_implCompress_id:\n+    case StubId::stubgen_md5_implCompress_id:\n@@ -3506,1 +3626,1 @@\n-    case md5_implCompressMB_id:\n+    case StubId::stubgen_md5_implCompressMB_id:\n@@ -3653,1 +3773,1 @@\n-  address generate_sha1_implCompress(StubGenStubId stub_id) {\n+  address generate_sha1_implCompress(StubId stub_id) {\n@@ -3656,1 +3776,1 @@\n-    case sha1_implCompress_id:\n+    case StubId::stubgen_sha1_implCompress_id:\n@@ -3659,1 +3779,1 @@\n-    case sha1_implCompressMB_id:\n+    case StubId::stubgen_sha1_implCompressMB_id:\n@@ -3758,1 +3878,1 @@\n-  address generate_sha256_implCompress(StubGenStubId stub_id) {\n+  address generate_sha256_implCompress(StubId stub_id) {\n@@ -3761,1 +3881,1 @@\n-    case sha256_implCompress_id:\n+    case StubId::stubgen_sha256_implCompress_id:\n@@ -3764,1 +3884,1 @@\n-    case sha256_implCompressMB_id:\n+    case StubId::stubgen_sha256_implCompressMB_id:\n@@ -3914,1 +4034,1 @@\n-  address generate_sha512_implCompress(StubGenStubId stub_id) {\n+  address generate_sha512_implCompress(StubId stub_id) {\n@@ -3917,1 +4037,1 @@\n-    case sha512_implCompress_id:\n+    case StubId::stubgen_sha512_implCompress_id:\n@@ -3920,1 +4040,1 @@\n-    case sha512_implCompressMB_id:\n+    case StubId::stubgen_sha512_implCompressMB_id:\n@@ -4164,1 +4284,1 @@\n-  address generate_sha3_implCompress(StubGenStubId stub_id) {\n+  address generate_sha3_implCompress(StubId stub_id) {\n@@ -4167,1 +4287,1 @@\n-    case sha3_implCompress_id:\n+    case StubId::stubgen_sha3_implCompress_id:\n@@ -4170,1 +4290,1 @@\n-    case sha3_implCompressMB_id:\n+    case StubId::stubgen_sha3_implCompressMB_id:\n@@ -4450,1 +4570,1 @@\n-    StubGenStubId stub_id = StubGenStubId::chacha20Block_id;\n+    StubId stub_id = StubId::stubgen_chacha20Block_id;\n@@ -5086,1 +5206,1 @@\n-    StubGenStubId stub_id = StubGenStubId::kyberNtt_id;\n+    StubId stub_id = StubId::stubgen_kyberNtt_id;\n@@ -5324,1 +5444,1 @@\n-    StubGenStubId stub_id = StubGenStubId::kyberInverseNtt_id;\n+    StubId stub_id = StubId::stubgen_kyberInverseNtt_id;\n@@ -5611,1 +5731,1 @@\n-    StubGenStubId stub_id = StubGenStubId::kyberNttMult_id;\n+    StubId stub_id = StubId::stubgen_kyberNttMult_id;\n@@ -5728,1 +5848,1 @@\n-    StubGenStubId stub_id = StubGenStubId::kyberAddPoly_2_id;\n+    StubId stub_id = StubId::stubgen_kyberAddPoly_2_id;\n@@ -5813,1 +5933,1 @@\n-    StubGenStubId stub_id = StubGenStubId::kyberAddPoly_3_id;\n+    StubId stub_id = StubId::stubgen_kyberAddPoly_3_id;\n@@ -5921,1 +6041,1 @@\n-    StubGenStubId stub_id = StubGenStubId::kyber12To16_id;\n+    StubId stub_id = StubId::stubgen_kyber12To16_id;\n@@ -6124,1 +6244,1 @@\n-    StubGenStubId stub_id = StubGenStubId::kyberBarrettReduce_id;\n+    StubId stub_id = StubId::stubgen_kyberBarrettReduce_id;\n@@ -6371,1 +6491,1 @@\n-    StubGenStubId stub_id = StubGenStubId::dilithiumAlmostNtt_id;\n+    StubId stub_id = StubId::stubgen_dilithiumAlmostNtt_id;\n@@ -6578,1 +6698,1 @@\n-    StubGenStubId stub_id = StubGenStubId::dilithiumAlmostInverseNtt_id;\n+    StubId stub_id = StubId::stubgen_dilithiumAlmostInverseNtt_id;\n@@ -6691,1 +6811,1 @@\n-    StubGenStubId stub_id = StubGenStubId::dilithiumNttMult_id;\n+    StubId stub_id = StubId::stubgen_dilithiumNttMult_id;\n@@ -6755,1 +6875,1 @@\n-    StubGenStubId stub_id = StubGenStubId::dilithiumMontMulByConstant_id;\n+    StubId stub_id = StubId::stubgen_dilithiumMontMulByConstant_id;\n@@ -6819,1 +6939,1 @@\n-    StubGenStubId stub_id = StubGenStubId::dilithiumDecomposePoly_id;\n+    StubId stub_id = StubId::stubgen_dilithiumDecomposePoly_id;\n@@ -6964,0 +7084,360 @@\n+  void bcax5(Register a0, Register a1, Register a2, Register a3, Register a4,\n+             Register tmp0, Register tmp1, Register tmp2) {\n+    __ bic(tmp0, a2, a1); \/\/ for a0\n+    __ bic(tmp1, a3, a2); \/\/ for a1\n+    __ bic(tmp2, a4, a3); \/\/ for a2\n+    __ eor(a2, a2, tmp2);\n+    __ bic(tmp2, a0, a4); \/\/ for a3\n+    __ eor(a3, a3, tmp2);\n+    __ bic(tmp2, a1, a0); \/\/ for a4\n+    __ eor(a0, a0, tmp0);\n+    __ eor(a1, a1, tmp1);\n+    __ eor(a4, a4, tmp2);\n+  }\n+\n+  void keccak_round_gpr(bool can_use_fp, bool can_use_r18, Register rc,\n+                        Register a0, Register a1, Register a2, Register a3, Register a4,\n+                        Register a5, Register a6, Register a7, Register a8, Register a9,\n+                        Register a10, Register a11, Register a12, Register a13, Register a14,\n+                        Register a15, Register a16, Register a17, Register a18, Register a19,\n+                        Register a20, Register a21, Register a22, Register a23, Register a24,\n+                        Register tmp0, Register tmp1, Register tmp2) {\n+    __ eor3(tmp1, a4, a9, a14);\n+    __ eor3(tmp0, tmp1, a19, a24); \/\/ tmp0 = a4^a9^a14^a19^a24 = c4\n+    __ eor3(tmp2, a1, a6, a11);\n+    __ eor3(tmp1, tmp2, a16, a21); \/\/ tmp1 = a1^a6^a11^a16^a21 = c1\n+    __ rax1(tmp2, tmp0, tmp1); \/\/ d0\n+    {\n+\n+      Register tmp3, tmp4;\n+      if (can_use_fp && can_use_r18) {\n+        tmp3 = rfp;\n+        tmp4 = r18_tls;\n+      } else {\n+        tmp3 = a4;\n+        tmp4 = a9;\n+        __ stp(tmp3, tmp4, __ pre(sp, -16));\n+      }\n+\n+      __ eor3(tmp3, a0, a5, a10);\n+      __ eor3(tmp4, tmp3, a15, a20); \/\/ tmp4 = a0^a5^a10^a15^a20 = c0\n+      __ eor(a0, a0, tmp2);\n+      __ eor(a5, a5, tmp2);\n+      __ eor(a10, a10, tmp2);\n+      __ eor(a15, a15, tmp2);\n+      __ eor(a20, a20, tmp2); \/\/ d0(tmp2)\n+      __ eor3(tmp3, a2, a7, a12);\n+      __ eor3(tmp2, tmp3, a17, a22); \/\/ tmp2 = a2^a7^a12^a17^a22 = c2\n+      __ rax1(tmp3, tmp4, tmp2); \/\/ d1\n+      __ eor(a1, a1, tmp3);\n+      __ eor(a6, a6, tmp3);\n+      __ eor(a11, a11, tmp3);\n+      __ eor(a16, a16, tmp3);\n+      __ eor(a21, a21, tmp3); \/\/ d1(tmp3)\n+      __ rax1(tmp3, tmp2, tmp0); \/\/ d3\n+      __ eor3(tmp2, a3, a8, a13);\n+      __ eor3(tmp0, tmp2, a18, a23);  \/\/ tmp0 = a3^a8^a13^a18^a23 = c3\n+      __ eor(a3, a3, tmp3);\n+      __ eor(a8, a8, tmp3);\n+      __ eor(a13, a13, tmp3);\n+      __ eor(a18, a18, tmp3);\n+      __ eor(a23, a23, tmp3);\n+      __ rax1(tmp2, tmp1, tmp0); \/\/ d2\n+      __ eor(a2, a2, tmp2);\n+      __ eor(a7, a7, tmp2);\n+      __ eor(a12, a12, tmp2);\n+      __ rax1(tmp0, tmp0, tmp4); \/\/ d4\n+      if (!can_use_fp || !can_use_r18) {\n+        __ ldp(tmp3, tmp4, __ post(sp, 16));\n+      }\n+      __ eor(a17, a17, tmp2);\n+      __ eor(a22, a22, tmp2);\n+      __ eor(a4, a4, tmp0);\n+      __ eor(a9, a9, tmp0);\n+      __ eor(a14, a14, tmp0);\n+      __ eor(a19, a19, tmp0);\n+      __ eor(a24, a24, tmp0);\n+    }\n+\n+    __ rol(tmp0, a10, 3);\n+    __ rol(a10, a1, 1);\n+    __ rol(a1, a6, 44);\n+    __ rol(a6, a9, 20);\n+    __ rol(a9, a22, 61);\n+    __ rol(a22, a14, 39);\n+    __ rol(a14, a20, 18);\n+    __ rol(a20, a2, 62);\n+    __ rol(a2, a12, 43);\n+    __ rol(a12, a13, 25);\n+    __ rol(a13, a19, 8) ;\n+    __ rol(a19, a23, 56);\n+    __ rol(a23, a15, 41);\n+    __ rol(a15, a4, 27);\n+    __ rol(a4, a24, 14);\n+    __ rol(a24, a21, 2);\n+    __ rol(a21, a8, 55);\n+    __ rol(a8, a16, 45);\n+    __ rol(a16, a5, 36);\n+    __ rol(a5, a3, 28);\n+    __ rol(a3, a18, 21);\n+    __ rol(a18, a17, 15);\n+    __ rol(a17, a11, 10);\n+    __ rol(a11, a7, 6);\n+    __ mov(a7, tmp0);\n+\n+    bcax5(a0, a1, a2, a3, a4, tmp0, tmp1, tmp2);\n+    bcax5(a5, a6, a7, a8, a9, tmp0, tmp1, tmp2);\n+    bcax5(a10, a11, a12, a13, a14, tmp0, tmp1, tmp2);\n+    bcax5(a15, a16, a17, a18, a19, tmp0, tmp1, tmp2);\n+    bcax5(a20, a21, a22, a23, a24, tmp0, tmp1, tmp2);\n+\n+    __ ldr(tmp1, __ post(rc, 8));\n+    __ eor(a0, a0, tmp1);\n+\n+  }\n+\n+  \/\/ Arguments:\n+  \/\/\n+  \/\/ Inputs:\n+  \/\/   c_rarg0   - byte[]  source+offset\n+  \/\/   c_rarg1   - byte[]  SHA.state\n+  \/\/   c_rarg2   - int     block_size\n+  \/\/   c_rarg3   - int     offset\n+  \/\/   c_rarg4   - int     limit\n+  \/\/\n+  address generate_sha3_implCompress_gpr(StubId stub_id) {\n+    bool multi_block;\n+    switch (stub_id) {\n+    case StubId::stubgen_sha3_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case StubId::stubgen_sha3_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    static const uint64_t round_consts[24] = {\n+      0x0000000000000001L, 0x0000000000008082L, 0x800000000000808AL,\n+      0x8000000080008000L, 0x000000000000808BL, 0x0000000080000001L,\n+      0x8000000080008081L, 0x8000000000008009L, 0x000000000000008AL,\n+      0x0000000000000088L, 0x0000000080008009L, 0x000000008000000AL,\n+      0x000000008000808BL, 0x800000000000008BL, 0x8000000000008089L,\n+      0x8000000000008003L, 0x8000000000008002L, 0x8000000000000080L,\n+      0x000000000000800AL, 0x800000008000000AL, 0x8000000080008081L,\n+      0x8000000000008080L, 0x0000000080000001L, 0x8000000080008008L\n+    };\n+\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, stub_id);\n+    address start = __ pc();\n+\n+    Register buf           = c_rarg0;\n+    Register state         = c_rarg1;\n+    Register block_size    = c_rarg2;\n+    Register ofs           = c_rarg3;\n+    Register limit         = c_rarg4;\n+\n+    \/\/ use r3.r17,r19..r28 to keep a0..a24.\n+    \/\/ a0..a24 are respective locals from SHA3.java\n+    Register a0 = r25,\n+             a1 = r26,\n+             a2 = r27,\n+             a3 = r3,\n+             a4 = r4,\n+             a5 = r5,\n+             a6 = r6,\n+             a7 = r7,\n+             a8 = rscratch1, \/\/ r8\n+             a9 = rscratch2, \/\/ r9\n+             a10 = r10,\n+             a11 = r11,\n+             a12 = r12,\n+             a13 = r13,\n+             a14 = r14,\n+             a15 = r15,\n+             a16 = r16,\n+             a17 = r17,\n+             a18 = r28,\n+             a19 = r19,\n+             a20 = r20,\n+             a21 = r21,\n+             a22 = r22,\n+             a23 = r23,\n+             a24 = r24;\n+\n+    Register tmp0 = block_size, tmp1 = buf, tmp2 = state, tmp3 = r30;\n+\n+    Label sha3_loop, rounds24_preloop, loop_body;\n+    Label sha3_512_or_sha3_384, shake128;\n+\n+    bool can_use_r18 = false;\n+#ifndef R18_RESERVED\n+    can_use_r18 = true;\n+#endif\n+    bool can_use_fp = !PreserveFramePointer;\n+\n+    __ enter();\n+\n+    \/\/ save almost all yet unsaved gpr registers on stack\n+    __ str(block_size, __ pre(sp, -128));\n+    if (multi_block) {\n+      __ stpw(ofs, limit, Address(sp, 8));\n+    }\n+    \/\/ 8 bytes at sp+16 will be used to keep buf\n+    __ stp(r19, r20, Address(sp, 32));\n+    __ stp(r21, r22, Address(sp, 48));\n+    __ stp(r23, r24, Address(sp, 64));\n+    __ stp(r25, r26, Address(sp, 80));\n+    __ stp(r27, r28, Address(sp, 96));\n+    if (can_use_r18 && can_use_fp) {\n+      __ stp(r18_tls, state, Address(sp, 112));\n+    } else {\n+      __ str(state, Address(sp, 112));\n+    }\n+\n+    \/\/ begin sha3 calculations: loading a0..a24 from state arrary\n+    __ ldp(a0, a1, state);\n+    __ ldp(a2, a3, Address(state, 16));\n+    __ ldp(a4, a5, Address(state, 32));\n+    __ ldp(a6, a7, Address(state, 48));\n+    __ ldp(a8, a9, Address(state, 64));\n+    __ ldp(a10, a11, Address(state, 80));\n+    __ ldp(a12, a13, Address(state, 96));\n+    __ ldp(a14, a15, Address(state, 112));\n+    __ ldp(a16, a17, Address(state, 128));\n+    __ ldp(a18, a19, Address(state, 144));\n+    __ ldp(a20, a21, Address(state, 160));\n+    __ ldp(a22, a23, Address(state, 176));\n+    __ ldr(a24, Address(state, 192));\n+\n+    __ BIND(sha3_loop);\n+\n+    \/\/ load input\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a0, a0, tmp3);\n+    __ eor(a1, a1, tmp2);\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a2, a2, tmp3);\n+    __ eor(a3, a3, tmp2);\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a4, a4, tmp3);\n+    __ eor(a5, a5, tmp2);\n+    __ ldr(tmp3, __ post(buf, 8));\n+    __ eor(a6, a6, tmp3);\n+\n+    \/\/ block_size == 72, SHA3-512; block_size == 104, SHA3-384\n+    __ tbz(block_size, 7, sha3_512_or_sha3_384);\n+\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a7, a7, tmp3);\n+    __ eor(a8, a8, tmp2);\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a9, a9, tmp3);\n+    __ eor(a10, a10, tmp2);\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a11, a11, tmp3);\n+    __ eor(a12, a12, tmp2);\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a13, a13, tmp3);\n+    __ eor(a14, a14, tmp2);\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a15, a15, tmp3);\n+    __ eor(a16, a16, tmp2);\n+\n+    \/\/ block_size == 136, bit4 == 0 and bit5 == 0, SHA3-256 or SHAKE256\n+    __ andw(tmp2, block_size, 48);\n+    __ cbzw(tmp2, rounds24_preloop);\n+    __ tbnz(block_size, 5, shake128);\n+    \/\/ block_size == 144, bit5 == 0, SHA3-244\n+    __ ldr(tmp3, __ post(buf, 8));\n+    __ eor(a17, a17, tmp3);\n+    __ b(rounds24_preloop);\n+\n+    __ BIND(shake128);\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a17, a17, tmp3);\n+    __ eor(a18, a18, tmp2);\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a19, a19, tmp3);\n+    __ eor(a20, a20, tmp2);\n+    __ b(rounds24_preloop); \/\/ block_size == 168, SHAKE128\n+\n+    __ BIND(sha3_512_or_sha3_384);\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a7, a7, tmp3);\n+    __ eor(a8, a8, tmp2);\n+    __ tbz(block_size, 5, rounds24_preloop); \/\/ SHA3-512\n+\n+    \/\/ SHA3-384\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a9, a9, tmp3);\n+    __ eor(a10, a10, tmp2);\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a11, a11, tmp3);\n+    __ eor(a12, a12, tmp2);\n+\n+    __ BIND(rounds24_preloop);\n+    __ fmovs(v0, 24.0); \/\/ float loop counter,\n+    __ fmovs(v1, 1.0);  \/\/ exact representation\n+\n+    __ str(buf, Address(sp, 16));\n+    __ lea(tmp3, ExternalAddress((address) round_consts));\n+\n+    __ BIND(loop_body);\n+    keccak_round_gpr(can_use_fp, can_use_r18, tmp3,\n+                     a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12,\n+                     a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24,\n+                     tmp0, tmp1, tmp2);\n+    __ fsubs(v0, v0, v1);\n+    __ fcmps(v0, 0.0);\n+    __ br(__ NE, loop_body);\n+\n+    if (multi_block) {\n+      __ ldrw(block_size, sp); \/\/ block_size\n+      __ ldpw(tmp2, tmp1, Address(sp, 8)); \/\/ offset, limit\n+      __ addw(tmp2, tmp2, block_size);\n+      __ cmpw(tmp2, tmp1);\n+      __ strw(tmp2, Address(sp, 8)); \/\/ store offset in case we're jumping\n+      __ ldr(buf, Address(sp, 16)); \/\/ restore buf in case we're jumping\n+      __ br(Assembler::LE, sha3_loop);\n+      __ movw(c_rarg0, tmp2); \/\/ return offset\n+    }\n+    if (can_use_fp && can_use_r18) {\n+      __ ldp(r18_tls, state, Address(sp, 112));\n+    } else {\n+      __ ldr(state, Address(sp, 112));\n+    }\n+    \/\/ save calculated sha3 state\n+    __ stp(a0, a1, Address(state));\n+    __ stp(a2, a3, Address(state, 16));\n+    __ stp(a4, a5, Address(state, 32));\n+    __ stp(a6, a7, Address(state, 48));\n+    __ stp(a8, a9, Address(state, 64));\n+    __ stp(a10, a11, Address(state, 80));\n+    __ stp(a12, a13, Address(state, 96));\n+    __ stp(a14, a15, Address(state, 112));\n+    __ stp(a16, a17, Address(state, 128));\n+    __ stp(a18, a19, Address(state, 144));\n+    __ stp(a20, a21, Address(state, 160));\n+    __ stp(a22, a23, Address(state, 176));\n+    __ str(a24, Address(state, 192));\n+\n+    \/\/ restore required registers from stack\n+    __ ldp(r19, r20, Address(sp, 32));\n+    __ ldp(r21, r22, Address(sp, 48));\n+    __ ldp(r23, r24, Address(sp, 64));\n+    __ ldp(r25, r26, Address(sp, 80));\n+    __ ldp(r27, r28, Address(sp, 96));\n+    if (can_use_fp && can_use_r18) {\n+      __ add(rfp, sp, 128); \/\/ leave() will copy rfp to sp below\n+    } \/\/ else no need to recalculate rfp, since it wasn't changed\n+\n+    __ leave();\n+\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -6979,1 +7459,1 @@\n-    StubGenStubId stub_id = StubGenStubId::updateBytesCRC32_id;\n+    StubId stub_id = StubId::stubgen_updateBytesCRC32_id;\n@@ -7021,1 +7501,1 @@\n-    StubGenStubId stub_id = StubGenStubId::updateBytesCRC32C_id;\n+    StubId stub_id = StubId::stubgen_updateBytesCRC32C_id;\n@@ -7060,1 +7540,1 @@\n-    StubGenStubId stub_id = StubGenStubId::updateBytesAdler32_id;\n+    StubId stub_id = StubId::stubgen_updateBytesAdler32_id;\n@@ -7282,1 +7762,1 @@\n-    StubGenStubId stub_id = StubGenStubId::multiplyToLen_id;\n+    StubId stub_id = StubId::stubgen_multiplyToLen_id;\n@@ -7315,1 +7795,1 @@\n-    StubGenStubId stub_id = StubGenStubId::squareToLen_id;\n+    StubId stub_id = StubId::stubgen_squareToLen_id;\n@@ -7349,1 +7829,1 @@\n-    StubGenStubId stub_id = StubGenStubId::mulAdd_id;\n+    StubId stub_id = StubId::stubgen_mulAdd_id;\n@@ -7380,1 +7860,1 @@\n-    StubGenStubId stub_id = StubGenStubId::bigIntegerRightShiftWorker_id;\n+    StubId stub_id = StubId::stubgen_bigIntegerRightShiftWorker_id;\n@@ -7503,1 +7983,1 @@\n-    StubGenStubId stub_id = StubGenStubId::bigIntegerLeftShiftWorker_id;\n+    StubId stub_id = StubId::stubgen_bigIntegerLeftShiftWorker_id;\n@@ -7612,1 +8092,1 @@\n-    StubGenStubId stub_id = StubGenStubId::count_positives_id;\n+    StubId stub_id = StubId::stubgen_count_positives_id;\n@@ -7874,1 +8354,1 @@\n-    StubGenStubId stub_id = StubGenStubId::large_array_equals_id;\n+    StubId stub_id = StubId::stubgen_large_array_equals_id;\n@@ -8000,1 +8480,1 @@\n-    StubGenStubId stub_id;\n+    StubId stub_id;\n@@ -8003,1 +8483,1 @@\n-      stub_id = StubGenStubId::large_arrays_hashcode_boolean_id;\n+      stub_id = StubId::stubgen_large_arrays_hashcode_boolean_id;\n@@ -8006,1 +8486,1 @@\n-      stub_id = StubGenStubId::large_arrays_hashcode_byte_id;\n+      stub_id = StubId::stubgen_large_arrays_hashcode_byte_id;\n@@ -8009,1 +8489,1 @@\n-      stub_id = StubGenStubId::large_arrays_hashcode_char_id;\n+      stub_id = StubId::stubgen_large_arrays_hashcode_char_id;\n@@ -8012,1 +8492,1 @@\n-      stub_id = StubGenStubId::large_arrays_hashcode_short_id;\n+      stub_id = StubId::stubgen_large_arrays_hashcode_short_id;\n@@ -8015,1 +8495,1 @@\n-      stub_id = StubGenStubId::large_arrays_hashcode_int_id;\n+      stub_id = StubId::stubgen_large_arrays_hashcode_int_id;\n@@ -8018,1 +8498,1 @@\n-      stub_id = StubGenStubId::NO_STUBID;\n+      stub_id = StubId::NO_STUBID;\n@@ -8112,1 +8592,2 @@\n-    __ sub(rscratch1, rscratch1, rscratch2, ext::uxtw, 3);\n+    \/\/ For Cortex-A53 offset is 4 because 2 nops are generated.\n+    __ sub(rscratch1, rscratch1, rscratch2, ext::uxtw, VM_Version::supports_a53mac() ? 4 : 3);\n@@ -8120,0 +8601,5 @@\n+      \/\/ maddw generates an extra nop for Cortex-A53 (see maddw definition in macroAssembler).\n+      \/\/ Generate 2nd nop to have 4 instructions per iteration.\n+      if (VM_Version::supports_a53mac()) {\n+        __ nop();\n+      }\n@@ -8255,1 +8741,1 @@\n-    StubGenStubId stub_id = (isCos ? StubGenStubId::dcos_id : StubGenStubId::dsin_id);\n+    StubId stub_id = (isCos ? StubId::stubgen_dcos_id : StubId::stubgen_dsin_id);\n@@ -8307,1 +8793,1 @@\n-    StubGenStubId stub_id = (isLU ? StubGenStubId::compare_long_string_LU_id : StubGenStubId::compare_long_string_UL_id);\n+    StubId stub_id = (isLU ? StubId::stubgen_compare_long_string_LU_id : StubId::stubgen_compare_long_string_UL_id);\n@@ -8417,1 +8903,1 @@\n-    StubGenStubId stub_id = StubGenStubId::hf2f_id;\n+    StubId stub_id = StubId::stubgen_hf2f_id;\n@@ -8431,1 +8917,1 @@\n-    StubGenStubId stub_id = StubGenStubId::f2hf_id;\n+    StubId stub_id = StubId::stubgen_f2hf_id;\n@@ -8442,1 +8928,1 @@\n-    StubGenStubId stub_id = StubGenStubId::method_entry_barrier_id;\n+    StubId stub_id = StubId::stubgen_method_entry_barrier_id;\n@@ -8508,1 +8994,1 @@\n-    StubGenStubId stub_id = (isLL ? StubGenStubId::compare_long_string_LL_id : StubGenStubId::compare_long_string_UU_id);\n+    StubId stub_id = (isLL ? StubId::stubgen_compare_long_string_LL_id : StubId::stubgen_compare_long_string_UU_id);\n@@ -8639,1 +9125,1 @@\n-    StubGenStubId stub_id;\n+    StubId stub_id;\n@@ -8641,4 +9127,4 @@\n-      case LL: stub_id = StubGenStubId::compare_long_string_LL_id;  break;\n-      case LU: stub_id = StubGenStubId::compare_long_string_LU_id; break;\n-      case UL: stub_id = StubGenStubId::compare_long_string_UL_id; break;\n-      case UU: stub_id = StubGenStubId::compare_long_string_UU_id; break;\n+      case LL: stub_id = StubId::stubgen_compare_long_string_LL_id;  break;\n+      case LU: stub_id = StubId::stubgen_compare_long_string_LU_id; break;\n+      case UL: stub_id = StubId::stubgen_compare_long_string_UL_id; break;\n+      case UU: stub_id = StubId::stubgen_compare_long_string_UU_id; break;\n@@ -8775,1 +9261,1 @@\n-    StubGenStubId stub_id;\n+    StubId stub_id;\n@@ -8778,1 +9264,1 @@\n-        stub_id = StubGenStubId::string_indexof_linear_ll_id;\n+        stub_id = StubId::stubgen_string_indexof_linear_ll_id;\n@@ -8780,1 +9266,1 @@\n-        stub_id = StubGenStubId::string_indexof_linear_ul_id;\n+        stub_id = StubId::stubgen_string_indexof_linear_ul_id;\n@@ -8786,1 +9272,1 @@\n-        stub_id = StubGenStubId::string_indexof_linear_uu_id;\n+        stub_id = StubId::stubgen_string_indexof_linear_uu_id;\n@@ -9088,1 +9574,1 @@\n-    StubGenStubId stub_id = StubGenStubId::large_byte_array_inflate_id;\n+    StubId stub_id = StubId::stubgen_large_byte_array_inflate_id;\n@@ -9154,1 +9640,1 @@\n-    StubGenStubId stub_id = StubGenStubId::ghash_processBlocks_id;\n+    StubId stub_id = StubId::stubgen_ghash_processBlocks_id;\n@@ -9221,1 +9707,1 @@\n-    StubGenStubId stub_id = StubGenStubId::ghash_processBlocks_wide_id;\n+    StubId stub_id = StubId::stubgen_ghash_processBlocks_wide_id;\n@@ -9333,1 +9819,1 @@\n-    StubGenStubId stub_id = StubGenStubId::base64_encodeBlock_id;\n+    StubId stub_id = StubId::stubgen_base64_encodeBlock_id;\n@@ -9602,1 +10088,1 @@\n-    StubGenStubId stub_id = StubGenStubId::base64_decodeBlock_id;\n+    StubId stub_id = StubId::stubgen_base64_decodeBlock_id;\n@@ -9719,1 +10205,1 @@\n-    StubGenStubId stub_id = StubGenStubId::spin_wait_id;\n+    StubId stub_id = StubId::stubgen_spin_wait_id;\n@@ -9730,1 +10216,1 @@\n-    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n+    StubId stub_id = StubId::stubgen_lookup_secondary_supers_table_id;\n@@ -9759,1 +10245,1 @@\n-    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_slow_path_id;\n+    StubId stub_id = StubId::stubgen_lookup_secondary_supers_table_slow_path_id;\n@@ -9914,1 +10400,1 @@\n-    StubGenStubId stub_id = StubGenStubId::atomic_entry_points_id;\n+    StubId stub_id = StubId::stubgen_atomic_entry_points_id;\n@@ -10074,1 +10560,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cont_thaw_id;\n+    StubId stub_id = StubId::stubgen_cont_thaw_id;\n@@ -10085,1 +10571,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cont_returnBarrier_id;\n+    StubId stub_id = StubId::stubgen_cont_returnBarrier_id;\n@@ -10097,1 +10583,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cont_returnBarrierExc_id;\n+    StubId stub_id = StubId::stubgen_cont_returnBarrierExc_id;\n@@ -10108,1 +10594,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cont_preempt_id;\n+    StubId stub_id = StubId::stubgen_cont_preempt_id;\n@@ -10191,1 +10677,1 @@\n-    StubGenStubId stub_id = StubGenStubId::poly1305_processBlocks_id;\n+    StubId stub_id = StubId::stubgen_poly1305_processBlocks_id;\n@@ -10306,1 +10792,1 @@\n-    StubGenStubId stub_id = StubGenStubId::upcall_stub_exception_handler_id;\n+    StubId stub_id = StubId::stubgen_upcall_stub_exception_handler_id;\n@@ -10324,1 +10810,1 @@\n-    StubGenStubId stub_id = StubGenStubId::upcall_stub_load_target_id;\n+    StubId stub_id = StubId::stubgen_upcall_stub_load_target_id;\n@@ -11170,0 +11656,4 @@\n+  void generate_preuniverse_stubs() {\n+    \/\/ preuniverse stubs are not needed for aarch64\n+  }\n+\n@@ -11256,0 +11746,2 @@\n+    StubRoutines::_unsafe_setmemory = generate_unsafe_setmemory();\n+\n@@ -11263,1 +11755,1 @@\n-      StubRoutines::aarch64::_vector_iota_indices = generate_iota_indices(StubGenStubId::vector_iota_indices_id);\n+      StubRoutines::aarch64::_vector_iota_indices = generate_iota_indices(StubId::stubgen_vector_iota_indices_id);\n@@ -11307,1 +11799,1 @@\n-      StubGenStubId stub_id = StubGenStubId::montgomeryMultiply_id;\n+      StubId stub_id = StubId::stubgen_montgomeryMultiply_id;\n@@ -11314,1 +11806,1 @@\n-      StubGenStubId stub_id = StubGenStubId::montgomerySquare_id;\n+      StubId stub_id = StubId::stubgen_montgomerySquare_id;\n@@ -11371,2 +11863,2 @@\n-      StubRoutines::_md5_implCompress      = generate_md5_implCompress(StubGenStubId::md5_implCompress_id);\n-      StubRoutines::_md5_implCompressMB    = generate_md5_implCompress(StubGenStubId::md5_implCompressMB_id);\n+      StubRoutines::_md5_implCompress      = generate_md5_implCompress(StubId::stubgen_md5_implCompress_id);\n+      StubRoutines::_md5_implCompressMB    = generate_md5_implCompress(StubId::stubgen_md5_implCompressMB_id);\n@@ -11375,2 +11867,2 @@\n-      StubRoutines::_sha1_implCompress     = generate_sha1_implCompress(StubGenStubId::sha1_implCompress_id);\n-      StubRoutines::_sha1_implCompressMB   = generate_sha1_implCompress(StubGenStubId::sha1_implCompressMB_id);\n+      StubRoutines::_sha1_implCompress     = generate_sha1_implCompress(StubId::stubgen_sha1_implCompress_id);\n+      StubRoutines::_sha1_implCompressMB   = generate_sha1_implCompress(StubId::stubgen_sha1_implCompressMB_id);\n@@ -11379,2 +11871,2 @@\n-      StubRoutines::_sha256_implCompress   = generate_sha256_implCompress(StubGenStubId::sha256_implCompress_id);\n-      StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(StubGenStubId::sha256_implCompressMB_id);\n+      StubRoutines::_sha256_implCompress   = generate_sha256_implCompress(StubId::stubgen_sha256_implCompress_id);\n+      StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(StubId::stubgen_sha256_implCompressMB_id);\n@@ -11383,2 +11875,2 @@\n-      StubRoutines::_sha512_implCompress   = generate_sha512_implCompress(StubGenStubId::sha512_implCompress_id);\n-      StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(StubGenStubId::sha512_implCompressMB_id);\n+      StubRoutines::_sha512_implCompress   = generate_sha512_implCompress(StubId::stubgen_sha512_implCompress_id);\n+      StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(StubId::stubgen_sha512_implCompressMB_id);\n@@ -11387,1 +11879,1 @@\n-      StubRoutines::_sha3_implCompress     = generate_sha3_implCompress(StubGenStubId::sha3_implCompress_id);\n+\n@@ -11389,1 +11881,7 @@\n-      StubRoutines::_sha3_implCompressMB   = generate_sha3_implCompress(StubGenStubId::sha3_implCompressMB_id);\n+      if (UseSIMDForSHA3Intrinsic) {\n+         StubRoutines::_sha3_implCompress     = generate_sha3_implCompress(StubId::stubgen_sha3_implCompress_id);\n+         StubRoutines::_sha3_implCompressMB   = generate_sha3_implCompress(StubId::stubgen_sha3_implCompressMB_id);\n+      } else {\n+         StubRoutines::_sha3_implCompress     = generate_sha3_implCompress_gpr(StubId::stubgen_sha3_implCompress_id);\n+         StubRoutines::_sha3_implCompressMB   = generate_sha3_implCompress_gpr(StubId::stubgen_sha3_implCompressMB_id);\n+      }\n@@ -11405,1 +11903,1 @@\n-  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+  StubGenerator(CodeBuffer* code, BlobId blob_id) : StubCodeGenerator(code, blob_id) {\n@@ -11407,1 +11905,4 @@\n-    case initial_id:\n+    case BlobId::stubgen_preuniverse_id:\n+      generate_preuniverse_stubs();\n+      break;\n+    case BlobId::stubgen_initial_id:\n@@ -11410,1 +11911,1 @@\n-     case continuation_id:\n+     case BlobId::stubgen_continuation_id:\n@@ -11413,1 +11914,1 @@\n-    case compiler_id:\n+    case BlobId::stubgen_compiler_id:\n@@ -11416,1 +11917,1 @@\n-    case final_id:\n+    case BlobId::stubgen_final_id:\n@@ -11420,1 +11921,1 @@\n-      fatal(\"unexpected blob id: %d\", blob_id);\n+      fatal(\"unexpected blob id: %s\", StubInfo::name(blob_id));\n@@ -11426,1 +11927,1 @@\n-void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+void StubGenerator_generate(CodeBuffer* code, BlobId blob_id) {\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":691,"deletions":190,"binary":false,"changes":881,"status":"modified"},{"patch":"@@ -1147,0 +1147,1 @@\n+  \/\/ Clobbers: r10, r11, r3\n@@ -1155,0 +1156,1 @@\n+  \/\/ Clobbers: r10, r11, r3\n@@ -1760,1 +1762,1 @@\n-  __ profile_taken_branch(r0, r1);\n+  __ profile_taken_branch(r0);\n@@ -1810,1 +1812,0 @@\n-    \/\/ w1: MDO bumped taken-count\n@@ -1821,1 +1822,0 @@\n-    __ push(r1);\n@@ -1826,1 +1826,0 @@\n-    __ pop(r1);\n@@ -1893,0 +1892,2 @@\n+    JFR_ONLY(__ enter_jfr_critical_section();)\n+\n@@ -1904,0 +1905,3 @@\n+\n+    JFR_ONLY(__ leave_jfr_critical_section();)\n+\n@@ -2880,0 +2884,1 @@\n+    \/\/ Clobbers: r10, r11, r3\n@@ -3075,2 +3080,2 @@\n-  \/\/ R1: field offset, R2: field holder, R3: flags\n-  load_resolved_field_entry(r2, r2, noreg, r1, r3);\n+  \/\/ R1: field offset, R2: field holder, R5: flags\n+  load_resolved_field_entry(r2, r2, noreg, r1, r5);\n@@ -3080,1 +3085,1 @@\n-    __ tbz(r3, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n+    __ tbz(r5, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n@@ -3096,0 +3101,1 @@\n+    \/\/ Clobbers: r10, r11, r3\n@@ -3128,1 +3134,1 @@\n-    __ tbz(r3, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n+    __ tbz(r5, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  __ call(Runtime1::entry_for(C1StubId::counter_overflow_id), relocInfo::runtime_call_type);\n+  __ call(Runtime1::entry_for(StubId::c1_counter_overflow_id), relocInfo::runtime_call_type);\n@@ -59,1 +59,1 @@\n-    __ call(Runtime1::entry_for(C1StubId::predicate_failed_trap_id), relocInfo::runtime_call_type);\n+    __ call(Runtime1::entry_for(StubId::c1_predicate_failed_trap_id), relocInfo::runtime_call_type);\n@@ -75,1 +75,1 @@\n-    __ call(Runtime1::entry_for(C1StubId::throw_index_exception_id), relocInfo::runtime_call_type);\n+    __ call(Runtime1::entry_for(StubId::c1_throw_index_exception_id), relocInfo::runtime_call_type);\n@@ -78,1 +78,1 @@\n-    __ call(Runtime1::entry_for(C1StubId::throw_range_check_failed_id), relocInfo::runtime_call_type);\n+    __ call(Runtime1::entry_for(StubId::c1_throw_range_check_failed_id), relocInfo::runtime_call_type);\n@@ -91,1 +91,1 @@\n-  __ call(Runtime1::entry_for(C1StubId::predicate_failed_trap_id), relocInfo::runtime_call_type);\n+  __ call(Runtime1::entry_for(StubId::c1_predicate_failed_trap_id), relocInfo::runtime_call_type);\n@@ -102,1 +102,1 @@\n-  __ call(Runtime1::entry_for(C1StubId::throw_div0_exception_id),\n+  __ call(Runtime1::entry_for(StubId::c1_throw_div0_exception_id),\n@@ -111,1 +111,1 @@\n-NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, C1StubId stub_id) {\n+NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, StubId stub_id) {\n@@ -116,3 +116,3 @@\n-  assert(stub_id == C1StubId::new_instance_id                 ||\n-         stub_id == C1StubId::fast_new_instance_id            ||\n-         stub_id == C1StubId::fast_new_instance_init_check_id,\n+  assert(stub_id == StubId::c1_new_instance_id                 ||\n+         stub_id == StubId::c1_fast_new_instance_id            ||\n+         stub_id == StubId::c1_fast_new_instance_init_check_id,\n@@ -150,1 +150,1 @@\n-  __ call(Runtime1::entry_for(C1StubId::new_type_array_id), relocInfo::runtime_call_type);\n+  __ call(Runtime1::entry_for(StubId::c1_new_type_array_id), relocInfo::runtime_call_type);\n@@ -172,1 +172,1 @@\n-  __ call(Runtime1::entry_for(C1StubId::new_object_array_id), relocInfo::runtime_call_type);\n+  __ call(Runtime1::entry_for(StubId::c1_new_object_array_id), relocInfo::runtime_call_type);\n@@ -191,3 +191,3 @@\n-  C1StubId enter_id = ce->compilation()->has_fpu_code() ?\n-                              C1StubId::monitorenter_id :\n-                              C1StubId::monitorenter_nofpu_id;\n+  StubId enter_id = ce->compilation()->has_fpu_code() ?\n+                              StubId::c1_monitorenter_id :\n+                              StubId::c1_monitorenter_nofpu_id;\n@@ -212,3 +212,3 @@\n-  C1StubId exit_id = ce->compilation()->has_fpu_code() ?\n-                             C1StubId::monitorexit_id :\n-                             C1StubId::monitorexit_nofpu_id;\n+  StubId exit_id = ce->compilation()->has_fpu_code() ?\n+                             StubId::c1_monitorexit_id :\n+                             StubId::c1_monitorexit_nofpu_id;\n@@ -324,4 +324,4 @@\n-    case access_field_id:  target = Runtime1::entry_for(C1StubId::access_field_patching_id); break;\n-    case load_klass_id:    target = Runtime1::entry_for(C1StubId::load_klass_patching_id); reloc_type = relocInfo::metadata_type; break;\n-    case load_mirror_id:   target = Runtime1::entry_for(C1StubId::load_mirror_patching_id); reloc_type = relocInfo::oop_type; break;\n-    case load_appendix_id: target = Runtime1::entry_for(C1StubId::load_appendix_patching_id); reloc_type = relocInfo::oop_type; break;\n+    case access_field_id:  target = Runtime1::entry_for(StubId::c1_access_field_patching_id); break;\n+    case load_klass_id:    target = Runtime1::entry_for(StubId::c1_load_klass_patching_id); reloc_type = relocInfo::metadata_type; break;\n+    case load_mirror_id:   target = Runtime1::entry_for(StubId::c1_load_mirror_patching_id); reloc_type = relocInfo::oop_type; break;\n+    case load_appendix_id: target = Runtime1::entry_for(StubId::c1_load_appendix_patching_id); reloc_type = relocInfo::oop_type; break;\n@@ -353,1 +353,1 @@\n-  __ call(Runtime1::entry_for(C1StubId::deoptimize_id), relocInfo::runtime_call_type);\n+  __ call(Runtime1::entry_for(StubId::c1_deoptimize_id), relocInfo::runtime_call_type);\n@@ -364,1 +364,1 @@\n-    a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+    a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -366,1 +366,1 @@\n-    a = Runtime1::entry_for(C1StubId::throw_null_pointer_exception_id);\n+    a = Runtime1::entry_for(StubId::c1_throw_null_pointer_exception_id);\n","filename":"src\/hotspot\/cpu\/arm\/c1_CodeStubs_arm.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-  __ call(Runtime1::entry_for(C1StubId::handle_exception_from_callee_id), relocInfo::runtime_call_type);\n+  __ call(Runtime1::entry_for(StubId::c1_handle_exception_from_callee_id), relocInfo::runtime_call_type);\n@@ -255,1 +255,1 @@\n-  __ jump(Runtime1::entry_for(C1StubId::unwind_exception_id), relocInfo::runtime_call_type, Rtemp);\n+  __ jump(Runtime1::entry_for(StubId::c1_unwind_exception_id), relocInfo::runtime_call_type, Rtemp);\n@@ -1139,1 +1139,1 @@\n-      __ call(Runtime1::entry_for(C1StubId::slow_subtype_check_id), relocInfo::runtime_call_type);\n+      __ call(Runtime1::entry_for(StubId::c1_slow_subtype_check_id), relocInfo::runtime_call_type);\n@@ -1213,1 +1213,1 @@\n-          __ call(Runtime1::entry_for(C1StubId::slow_subtype_check_id), relocInfo::runtime_call_type);\n+          __ call(Runtime1::entry_for(StubId::c1_slow_subtype_check_id), relocInfo::runtime_call_type);\n@@ -1230,1 +1230,1 @@\n-        __ call(Runtime1::entry_for(C1StubId::slow_subtype_check_id), relocInfo::runtime_call_type);\n+        __ call(Runtime1::entry_for(StubId::c1_slow_subtype_check_id), relocInfo::runtime_call_type);\n@@ -1306,1 +1306,1 @@\n-          __ call(Runtime1::entry_for(C1StubId::slow_subtype_check_id), relocInfo::runtime_call_type);\n+          __ call(Runtime1::entry_for(StubId::c1_slow_subtype_check_id), relocInfo::runtime_call_type);\n@@ -1337,1 +1337,1 @@\n-        __ call(Runtime1::entry_for(C1StubId::slow_subtype_check_id), relocInfo::runtime_call_type);\n+        __ call(Runtime1::entry_for(StubId::c1_slow_subtype_check_id), relocInfo::runtime_call_type);\n@@ -1984,3 +1984,3 @@\n-  C1StubId handle_id = compilation()->has_fpu_code() ?\n-                               C1StubId::handle_exception_id :\n-                               C1StubId::handle_exception_nofpu_id;\n+  StubId handle_id = compilation()->has_fpu_code() ?\n+                               StubId::c1_handle_exception_id :\n+                               StubId::c1_handle_exception_nofpu_id;\n@@ -2263,1 +2263,1 @@\n-      __ call(Runtime1::entry_for(C1StubId::slow_subtype_check_id), relocInfo::runtime_call_type); \/\/ does not blow any registers except R0, LR and Rtemp\n+      __ call(Runtime1::entry_for(StubId::c1_slow_subtype_check_id), relocInfo::runtime_call_type); \/\/ does not blow any registers except R0, LR and Rtemp\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1060,1 +1060,1 @@\n-  __ call_runtime(Runtime1::entry_for(C1StubId::new_multi_array_id),\n+  __ call_runtime(Runtime1::entry_for(StubId::c1_new_multi_array_id),\n@@ -1089,1 +1089,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_incompatible_class_change_error_id,\n+    stub = new SimpleExceptionStub(StubId::c1_throw_incompatible_class_change_error_id,\n@@ -1097,1 +1097,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_class_cast_exception_id,\n+    stub = new SimpleExceptionStub(StubId::c1_throw_class_cast_exception_id,\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRGenerator_arm.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-  if (_stub_id != (int)C1StubId::forward_exception_id) {\n+  if (_stub_id != (int)StubId::c1_forward_exception_id) {\n@@ -83,1 +83,1 @@\n-  if (_stub_id != (int)C1StubId::forward_exception_id) {\n+  if (_stub_id != (int)StubId::c1_forward_exception_id) {\n@@ -86,1 +86,1 @@\n-    jump(Runtime1::entry_for(C1StubId::forward_exception_id), relocInfo::runtime_call_type, Rtemp, ne);\n+    jump(Runtime1::entry_for(StubId::c1_forward_exception_id), relocInfo::runtime_call_type, Rtemp, ne);\n@@ -286,1 +286,1 @@\n-OopMapSet* Runtime1::generate_handle_exception(C1StubId id, StubAssembler* sasm) {\n+OopMapSet* Runtime1::generate_handle_exception(StubId id, StubAssembler* sasm) {\n@@ -296,1 +296,1 @@\n-  case C1StubId::forward_exception_id: {\n+  case StubId::c1_forward_exception_id: {\n@@ -305,1 +305,1 @@\n-  case C1StubId::handle_exception_id:\n+  case StubId::c1_handle_exception_id:\n@@ -308,1 +308,1 @@\n-  case C1StubId::handle_exception_nofpu_id:\n+  case StubId::c1_handle_exception_nofpu_id:\n@@ -312,1 +312,1 @@\n-  case C1StubId::handle_exception_from_callee_id:\n+  case StubId::c1_handle_exception_from_callee_id:\n@@ -334,3 +334,3 @@\n-  case C1StubId::forward_exception_id:\n-  case C1StubId::handle_exception_nofpu_id:\n-  case C1StubId::handle_exception_id:\n+  case StubId::c1_forward_exception_id:\n+  case StubId::c1_handle_exception_nofpu_id:\n+  case StubId::c1_handle_exception_id:\n@@ -340,1 +340,1 @@\n-  case C1StubId::handle_exception_from_callee_id:\n+  case StubId::c1_handle_exception_from_callee_id:\n@@ -409,1 +409,1 @@\n-OopMapSet* Runtime1::generate_code_for(C1StubId id, StubAssembler* sasm) {\n+OopMapSet* Runtime1::generate_code_for(StubId id, StubAssembler* sasm) {\n@@ -417,1 +417,1 @@\n-    case C1StubId::forward_exception_id:\n+    case StubId::c1_forward_exception_id:\n@@ -424,3 +424,3 @@\n-    case C1StubId::new_instance_id:\n-    case C1StubId::fast_new_instance_id:\n-    case C1StubId::fast_new_instance_init_check_id:\n+    case StubId::c1_new_instance_id:\n+    case StubId::c1_fast_new_instance_id:\n+    case StubId::c1_fast_new_instance_init_check_id:\n@@ -442,1 +442,1 @@\n-    case C1StubId::counter_overflow_id:\n+    case StubId::c1_counter_overflow_id:\n@@ -454,2 +454,2 @@\n-    case C1StubId::new_type_array_id:\n-    case C1StubId::new_object_array_id:\n+    case StubId::c1_new_type_array_id:\n+    case StubId::c1_new_object_array_id:\n@@ -457,1 +457,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -469,1 +469,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -483,1 +483,1 @@\n-    case C1StubId::new_multi_array_id:\n+    case StubId::c1_new_multi_array_id:\n@@ -506,1 +506,1 @@\n-    case C1StubId::register_finalizer_id:\n+    case StubId::c1_register_finalizer_id:\n@@ -527,1 +527,1 @@\n-    case C1StubId::throw_range_check_failed_id:\n+    case StubId::c1_throw_range_check_failed_id:\n@@ -534,1 +534,1 @@\n-    case C1StubId::throw_index_exception_id:\n+    case StubId::c1_throw_index_exception_id:\n@@ -541,1 +541,1 @@\n-    case C1StubId::throw_div0_exception_id:\n+    case StubId::c1_throw_div0_exception_id:\n@@ -548,1 +548,1 @@\n-    case C1StubId::throw_null_pointer_exception_id:\n+    case StubId::c1_throw_null_pointer_exception_id:\n@@ -555,2 +555,2 @@\n-    case C1StubId::handle_exception_nofpu_id:\n-    case C1StubId::handle_exception_id:\n+    case StubId::c1_handle_exception_nofpu_id:\n+    case StubId::c1_handle_exception_id:\n@@ -563,1 +563,1 @@\n-    case C1StubId::handle_exception_from_callee_id:\n+    case StubId::c1_handle_exception_from_callee_id:\n@@ -570,1 +570,1 @@\n-    case C1StubId::unwind_exception_id:\n+    case StubId::c1_unwind_exception_id:\n@@ -577,1 +577,1 @@\n-    case C1StubId::throw_array_store_exception_id:\n+    case StubId::c1_throw_array_store_exception_id:\n@@ -584,1 +584,1 @@\n-    case C1StubId::throw_class_cast_exception_id:\n+    case StubId::c1_throw_class_cast_exception_id:\n@@ -591,1 +591,1 @@\n-    case C1StubId::throw_incompatible_class_change_error_id:\n+    case StubId::c1_throw_incompatible_class_change_error_id:\n@@ -598,1 +598,1 @@\n-    case C1StubId::slow_subtype_check_id:\n+    case StubId::c1_slow_subtype_check_id:\n@@ -631,1 +631,1 @@\n-    case C1StubId::monitorenter_nofpu_id:\n+    case StubId::c1_monitorenter_nofpu_id:\n@@ -634,1 +634,1 @@\n-    case C1StubId::monitorenter_id:\n+    case StubId::c1_monitorenter_id:\n@@ -649,1 +649,1 @@\n-    case C1StubId::monitorexit_nofpu_id:\n+    case StubId::c1_monitorexit_nofpu_id:\n@@ -652,1 +652,1 @@\n-    case C1StubId::monitorexit_id:\n+    case StubId::c1_monitorexit_id:\n@@ -665,1 +665,1 @@\n-    case C1StubId::deoptimize_id:\n+    case StubId::c1_deoptimize_id:\n@@ -681,1 +681,1 @@\n-    case C1StubId::access_field_patching_id:\n+    case StubId::c1_access_field_patching_id:\n@@ -688,1 +688,1 @@\n-    case C1StubId::load_klass_patching_id:\n+    case StubId::c1_load_klass_patching_id:\n@@ -695,1 +695,1 @@\n-    case C1StubId::load_appendix_patching_id:\n+    case StubId::c1_load_appendix_patching_id:\n@@ -702,1 +702,1 @@\n-    case C1StubId::load_mirror_patching_id:\n+    case StubId::c1_load_mirror_patching_id:\n@@ -709,1 +709,1 @@\n-    case C1StubId::predicate_failed_trap_id:\n+    case StubId::c1_predicate_failed_trap_id:\n","filename":"src\/hotspot\/cpu\/arm\/c1_Runtime1_arm.cpp","additions":46,"deletions":46,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n+  const char* name = OptoRuntime::stub_name(StubId::c2_uncommon_trap_id);\n@@ -213,1 +213,1 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n+  const char* name = OptoRuntime::stub_name(StubId::c2_exception_id);\n","filename":"src\/hotspot\/cpu\/arm\/runtime_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1369,1 +1369,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::deopt_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_deopt_id);\n@@ -1611,1 +1611,1 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(StubId id, address call_ptr) {\n@@ -1621,1 +1621,1 @@\n-  bool cause_return = (id == SharedStubId::polling_page_return_handler_id);\n+  bool cause_return = (id == StubId::shared_polling_page_return_handler_id);\n@@ -1683,1 +1683,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(StubId id, address destination) {\n@@ -1747,1 +1747,1 @@\n-RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+RuntimeStub* SharedRuntime::generate_throw_exception(StubId id, address runtime_entry) {\n@@ -1811,1 +1811,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_write_checkpoint_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_jfr_write_checkpoint_id);\n@@ -1855,1 +1855,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_return_lease_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_jfr_return_lease_id);\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,0 +29,7 @@\n+#define STUBGEN_PREUNIVERSE_BLOBS_ARCH_DO(do_stub,                      \\\n+                                          do_arch_blob,                 \\\n+                                          do_arch_entry,                \\\n+                                          do_arch_entry_init)           \\\n+  do_arch_blob(preuniverse, 0)                                          \\\n+\n+\n@@ -41,1 +48,1 @@\n-  do_arch_entry(Arm, initial, atomic_load_long,                         \\\n+  do_arch_entry(Arm, initial, atomic_store_long,                        \\\n","filename":"src\/hotspot\/cpu\/arm\/stubDeclarations_arm.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-    StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+    StubId stub_id = StubId::stubgen_call_stub_id;\n@@ -255,1 +255,1 @@\n-    StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+    StubId stub_id = StubId::stubgen_catch_exception_id;\n@@ -268,1 +268,1 @@\n-    StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+    StubId stub_id = StubId::stubgen_forward_exception_id;\n@@ -318,1 +318,1 @@\n-    StubGenStubId stub_id = StubGenStubId::idiv_irem_id;\n+    StubId stub_id = StubId::stubgen_idiv_irem_id;\n@@ -461,1 +461,1 @@\n-    StubGenStubId stub_id = StubGenStubId::atomic_add_id;\n+    StubId stub_id = StubId::stubgen_atomic_add_id;\n@@ -513,1 +513,1 @@\n-    StubGenStubId stub_id = StubGenStubId::atomic_xchg_id;\n+    StubId stub_id = StubId::stubgen_atomic_xchg_id;\n@@ -564,1 +564,1 @@\n-    StubGenStubId stub_id = StubGenStubId::atomic_cmpxchg_id;\n+    StubId stub_id = StubId::stubgen_atomic_cmpxchg_id;\n@@ -603,1 +603,1 @@\n-    StubGenStubId stub_id = StubGenStubId::atomic_cmpxchg_long_id;\n+    StubId stub_id = StubId::stubgen_atomic_cmpxchg_long_id;\n@@ -641,1 +641,1 @@\n-    StubGenStubId stub_id = StubGenStubId::atomic_load_long_id;\n+    StubId stub_id = StubId::stubgen_atomic_load_long_id;\n@@ -666,1 +666,1 @@\n-    StubGenStubId stub_id = StubGenStubId::atomic_store_long_id;\n+    StubId stub_id = StubId::stubgen_atomic_store_long_id;\n@@ -709,1 +709,1 @@\n-    StubGenStubId stub_id = StubGenStubId::partial_subtype_check_id;\n+    StubId stub_id = StubId::stubgen_partial_subtype_check_id;\n@@ -799,1 +799,1 @@\n-    StubGenStubId stub_id = StubGenStubId::verify_oop_id;\n+    StubId stub_id = StubId::stubgen_verify_oop_id;\n@@ -2030,1 +2030,1 @@\n-  address generate_primitive_copy(StubGenStubId stub_id, address nooverlap_target = nullptr) {\n+  address generate_primitive_copy(StubId stub_id, address nooverlap_target = nullptr) {\n@@ -2037,1 +2037,1 @@\n-    case jbyte_disjoint_arraycopy_id:\n+    case StubId::stubgen_jbyte_disjoint_arraycopy_id:\n@@ -2043,1 +2043,1 @@\n-    case jshort_disjoint_arraycopy_id:\n+    case StubId::stubgen_jshort_disjoint_arraycopy_id:\n@@ -2049,1 +2049,1 @@\n-    case jint_disjoint_arraycopy_id:\n+    case StubId::stubgen_jint_disjoint_arraycopy_id:\n@@ -2055,1 +2055,1 @@\n-    case jlong_disjoint_arraycopy_id:\n+    case StubId::stubgen_jlong_disjoint_arraycopy_id:\n@@ -2061,1 +2061,1 @@\n-    case arrayof_jbyte_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id:\n@@ -2067,1 +2067,1 @@\n-    case arrayof_jshort_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id:\n@@ -2073,1 +2073,1 @@\n-    case arrayof_jint_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jint_disjoint_arraycopy_id:\n@@ -2079,1 +2079,1 @@\n-    case arrayof_jlong_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id:\n@@ -2085,1 +2085,1 @@\n-    case jbyte_arraycopy_id:\n+    case StubId::stubgen_jbyte_arraycopy_id:\n@@ -2091,1 +2091,1 @@\n-    case jshort_arraycopy_id:\n+    case StubId::stubgen_jshort_arraycopy_id:\n@@ -2097,1 +2097,1 @@\n-    case jint_arraycopy_id:\n+    case StubId::stubgen_jint_arraycopy_id:\n@@ -2103,1 +2103,1 @@\n-    case jlong_arraycopy_id:\n+    case StubId::stubgen_jlong_arraycopy_id:\n@@ -2109,1 +2109,1 @@\n-    case arrayof_jbyte_arraycopy_id:\n+    case StubId::stubgen_arrayof_jbyte_arraycopy_id:\n@@ -2115,1 +2115,1 @@\n-    case arrayof_jshort_arraycopy_id:\n+    case StubId::stubgen_arrayof_jshort_arraycopy_id:\n@@ -2121,1 +2121,1 @@\n-    case arrayof_jint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jint_arraycopy_id:\n@@ -2304,1 +2304,1 @@\n-  address generate_oop_copy(StubGenStubId stub_id, address nooverlap_target = nullptr) {\n+  address generate_oop_copy(StubId stub_id, address nooverlap_target = nullptr) {\n@@ -2310,1 +2310,1 @@\n-    case oop_disjoint_arraycopy_id:\n+    case StubId::stubgen_oop_disjoint_arraycopy_id:\n@@ -2315,1 +2315,1 @@\n-    case arrayof_oop_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_oop_disjoint_arraycopy_id:\n@@ -2320,1 +2320,1 @@\n-    case oop_arraycopy_id:\n+    case StubId::stubgen_oop_arraycopy_id:\n@@ -2325,1 +2325,1 @@\n-    case arrayof_oop_arraycopy_id:\n+    case StubId::stubgen_arrayof_oop_arraycopy_id:\n@@ -2479,1 +2479,1 @@\n-    StubGenStubId stub_id = StubGenStubId::unsafe_arraycopy_id;\n+    StubId stub_id = StubId::stubgen_unsafe_arraycopy_id;\n@@ -2607,1 +2607,1 @@\n-    StubGenStubId stub_id = StubGenStubId::checkcast_arraycopy_id;\n+    StubId stub_id = StubId::stubgen_checkcast_arraycopy_id;\n@@ -2775,1 +2775,1 @@\n-    StubGenStubId stub_id = StubGenStubId::generic_arraycopy_id;\n+    StubId stub_id = StubId::stubgen_generic_arraycopy_id;\n@@ -3011,11 +3011,11 @@\n-    StubRoutines::_jbyte_disjoint_arraycopy  = generate_primitive_copy(StubGenStubId::jbyte_disjoint_arraycopy_id);\n-    StubRoutines::_jshort_disjoint_arraycopy = generate_primitive_copy(StubGenStubId::jshort_disjoint_arraycopy_id);\n-    StubRoutines::_jint_disjoint_arraycopy   = generate_primitive_copy(StubGenStubId::jint_disjoint_arraycopy_id);\n-    StubRoutines::_jlong_disjoint_arraycopy  = generate_primitive_copy(StubGenStubId::jlong_disjoint_arraycopy_id);\n-    StubRoutines::_oop_disjoint_arraycopy    = generate_oop_copy      (StubGenStubId::oop_disjoint_arraycopy_id);\n-\n-    StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = generate_primitive_copy(StubGenStubId::arrayof_jbyte_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_primitive_copy(StubGenStubId::arrayof_jshort_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_jint_disjoint_arraycopy   = generate_primitive_copy(StubGenStubId::arrayof_jint_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_jlong_disjoint_arraycopy  = generate_primitive_copy(StubGenStubId::arrayof_jlong_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_oop_disjoint_arraycopy    = generate_oop_copy      (StubGenStubId::arrayof_oop_disjoint_arraycopy_id);\n+    StubRoutines::_jbyte_disjoint_arraycopy  = generate_primitive_copy(StubId::stubgen_jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_jshort_disjoint_arraycopy = generate_primitive_copy(StubId::stubgen_jshort_disjoint_arraycopy_id);\n+    StubRoutines::_jint_disjoint_arraycopy   = generate_primitive_copy(StubId::stubgen_jint_disjoint_arraycopy_id);\n+    StubRoutines::_jlong_disjoint_arraycopy  = generate_primitive_copy(StubId::stubgen_jlong_disjoint_arraycopy_id);\n+    StubRoutines::_oop_disjoint_arraycopy    = generate_oop_copy      (StubId::stubgen_oop_disjoint_arraycopy_id);\n+\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = generate_primitive_copy(StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_primitive_copy(StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy   = generate_primitive_copy(StubId::stubgen_arrayof_jint_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy  = generate_primitive_copy(StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy    = generate_oop_copy      (StubId::stubgen_arrayof_oop_disjoint_arraycopy_id);\n@@ -3024,8 +3024,8 @@\n-    StubRoutines::_jbyte_arraycopy  = generate_primitive_copy(StubGenStubId::jbyte_arraycopy_id, StubRoutines::_jbyte_disjoint_arraycopy);\n-    StubRoutines::_jshort_arraycopy = generate_primitive_copy(StubGenStubId::jshort_arraycopy_id, StubRoutines::_jshort_disjoint_arraycopy);\n-    StubRoutines::_jint_arraycopy   = generate_primitive_copy(StubGenStubId::jint_arraycopy_id, StubRoutines::_jint_disjoint_arraycopy);\n-    StubRoutines::_jlong_arraycopy  = generate_primitive_copy(StubGenStubId::jlong_arraycopy_id, StubRoutines::_jlong_disjoint_arraycopy);\n-    StubRoutines::_oop_arraycopy    = generate_oop_copy      (StubGenStubId::oop_arraycopy_id, StubRoutines::_oop_disjoint_arraycopy);\n-\n-    StubRoutines::_arrayof_jbyte_arraycopy    = generate_primitive_copy(StubGenStubId::arrayof_jbyte_arraycopy_id, StubRoutines::_arrayof_jbyte_disjoint_arraycopy);\n-    StubRoutines::_arrayof_jshort_arraycopy   = generate_primitive_copy(StubGenStubId::arrayof_jshort_arraycopy_id, StubRoutines::_arrayof_jshort_disjoint_arraycopy);\n+    StubRoutines::_jbyte_arraycopy  = generate_primitive_copy(StubId::stubgen_jbyte_arraycopy_id, StubRoutines::_jbyte_disjoint_arraycopy);\n+    StubRoutines::_jshort_arraycopy = generate_primitive_copy(StubId::stubgen_jshort_arraycopy_id, StubRoutines::_jshort_disjoint_arraycopy);\n+    StubRoutines::_jint_arraycopy   = generate_primitive_copy(StubId::stubgen_jint_arraycopy_id, StubRoutines::_jint_disjoint_arraycopy);\n+    StubRoutines::_jlong_arraycopy  = generate_primitive_copy(StubId::stubgen_jlong_arraycopy_id, StubRoutines::_jlong_disjoint_arraycopy);\n+    StubRoutines::_oop_arraycopy    = generate_oop_copy      (StubId::stubgen_oop_arraycopy_id, StubRoutines::_oop_disjoint_arraycopy);\n+\n+    StubRoutines::_arrayof_jbyte_arraycopy    = generate_primitive_copy(StubId::stubgen_arrayof_jbyte_arraycopy_id, StubRoutines::_arrayof_jbyte_disjoint_arraycopy);\n+    StubRoutines::_arrayof_jshort_arraycopy   = generate_primitive_copy(StubId::stubgen_arrayof_jshort_arraycopy_id, StubRoutines::_arrayof_jshort_disjoint_arraycopy);\n@@ -3034,1 +3034,1 @@\n-    StubRoutines::_arrayof_jint_arraycopy     = generate_primitive_copy(StubGenStubId::arrayof_jint_arraycopy_id, StubRoutines::_arrayof_jint_disjoint_arraycopy);\n+    StubRoutines::_arrayof_jint_arraycopy     = generate_primitive_copy(StubId::stubgen_arrayof_jint_arraycopy_id, StubRoutines::_arrayof_jint_disjoint_arraycopy);\n@@ -3039,1 +3039,1 @@\n-      StubRoutines::_arrayof_oop_arraycopy    = generate_oop_copy      (StubGenStubId::arrayof_oop_arraycopy_id, StubRoutines::_arrayof_oop_disjoint_arraycopy);\n+      StubRoutines::_arrayof_oop_arraycopy    = generate_oop_copy      (StubId::stubgen_arrayof_oop_arraycopy_id, StubRoutines::_arrayof_oop_disjoint_arraycopy);\n@@ -3054,1 +3054,1 @@\n-    StubGenStubId stub_id = StubGenStubId::method_entry_barrier_id;\n+    StubId stub_id = StubId::stubgen_method_entry_barrier_id;\n@@ -3108,1 +3108,1 @@\n-  address generate_cont_thaw(StubGenStubId stub_id) {\n+  address generate_cont_thaw(StubId stub_id) {\n@@ -3115,1 +3115,1 @@\n-    return generate_cont_thaw(StubGenStubId::cont_thaw_id);\n+    return generate_cont_thaw(StubId::stubgen_cont_thaw_id);\n@@ -3119,1 +3119,1 @@\n-    return generate_cont_thaw(StubGenStubId::cont_returnBarrier_id);\n+    return generate_cont_thaw(StubId::stubgen_cont_returnBarrier_id);\n@@ -3123,1 +3123,1 @@\n-    return generate_cont_thaw(StubGenStubId::cont_returnBarrierExc_id);\n+    return generate_cont_thaw(StubId::stubgen_cont_returnBarrierExc_id);\n@@ -3129,0 +3129,4 @@\n+  void generate_preuniverse_stubs() {\n+    \/\/ preuniverse stubs are not needed for arm\n+  }\n+\n@@ -3202,1 +3206,1 @@\n-  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+  StubGenerator(CodeBuffer* code, BlobId blob_id) : StubCodeGenerator(code, blob_id) {\n@@ -3204,1 +3208,4 @@\n-    case initial_id:\n+    case BlobId::stubgen_preuniverse_id:\n+      generate_preuniverse_stubs();\n+      break;\n+    case BlobId::stubgen_initial_id:\n@@ -3207,1 +3214,1 @@\n-     case continuation_id:\n+     case BlobId::stubgen_continuation_id:\n@@ -3210,1 +3217,1 @@\n-    case compiler_id:\n+    case BlobId::stubgen_compiler_id:\n@@ -3213,1 +3220,1 @@\n-    case final_id:\n+    case BlobId::stubgen_final_id:\n@@ -3217,1 +3224,1 @@\n-      fatal(\"unexpected blob id: %d\", blob_id);\n+      fatal(\"unexpected blob id: %s\", StubInfo::name(blob_id));\n@@ -3223,1 +3230,1 @@\n-void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+void StubGenerator_generate(CodeBuffer* code, BlobId blob_id) {\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":76,"deletions":69,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,1 +122,1 @@\n-  StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+  StubId stub_id = StubId::stubgen_aescrypt_encryptBlock_id;\n@@ -320,1 +320,1 @@\n-  StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+  StubId stub_id = StubId::stubgen_aescrypt_decryptBlock_id;\n@@ -541,1 +541,1 @@\n-  StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_encryptAESCrypt_id;\n+  StubId stub_id = StubId::stubgen_cipherBlockChaining_encryptAESCrypt_id;\n@@ -607,1 +607,1 @@\n-  StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_decryptAESCrypt_id;\n+  StubId stub_id = StubId::stubgen_cipherBlockChaining_decryptAESCrypt_id;\n","filename":"src\/hotspot\/cpu\/arm\/stubRoutinesCrypto_arm.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -594,0 +594,4 @@\n+    XVMINSP_OPCODE = (60u << OPCODE_SHIFT |  200u << 3),\n+    XVMINDP_OPCODE = (60u << OPCODE_SHIFT |  232u << 3),\n+    XVMAXSP_OPCODE = (60u << OPCODE_SHIFT |  192u << 3),\n+    XVMAXDP_OPCODE = (60u << OPCODE_SHIFT |  224u << 3),\n@@ -702,0 +706,1 @@\n+    VMAXSD_OPCODE  = (4u  << OPCODE_SHIFT |  450u     ),\n@@ -705,0 +710,1 @@\n+    VMAXUD_OPCODE  = (4u  << OPCODE_SHIFT |  194u     ),\n@@ -708,0 +714,1 @@\n+    VMINSD_OPCODE  = (4u  << OPCODE_SHIFT |  962u     ),\n@@ -711,0 +718,1 @@\n+    VMINUD_OPCODE  = (4u  << OPCODE_SHIFT |  706u     ),\n@@ -752,0 +760,1 @@\n+    VNEGW_OPCODE   = (4u  << OPCODE_SHIFT |  6u << 16 | 1538u),\n@@ -2011,1 +2020,1 @@\n-  inline void waitrsv(); \/\/ >=Power7\n+  inline void waitrsv();\n@@ -2019,1 +2028,0 @@\n-  inline bool lxarx_hint_exclusive_access();\n@@ -2042,1 +2050,0 @@\n-  \/\/ >= Power7\n@@ -2307,0 +2314,1 @@\n+  inline void vmaxsd(   VectorRegister d, VectorRegister a, VectorRegister b);\n@@ -2310,0 +2318,1 @@\n+  inline void vmaxud(   VectorRegister d, VectorRegister a, VectorRegister b);\n@@ -2313,0 +2322,1 @@\n+  inline void vminsd(   VectorRegister d, VectorRegister a, VectorRegister b);\n@@ -2316,0 +2326,1 @@\n+  inline void vminud(   VectorRegister d, VectorRegister a, VectorRegister b);\n@@ -2365,0 +2376,1 @@\n+  inline void vnegw(    VectorRegister d, VectorRegister b);\n@@ -2440,0 +2452,6 @@\n+  \/\/ The following functions do not match exactly the Java.math semantics.\n+  inline void xvminsp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);\n+  inline void xvmindp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);\n+  inline void xvmaxsp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);\n+  inline void xvmaxdp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -211,2 +211,1 @@\n-inline void Assembler::isel(Register d, Register a, Register b, int c) { guarantee(VM_Version::has_isel(), \"opcode not supported on this hardware\");\n-                                                                         emit_int32(ISEL_OPCODE    | rt(d)  | ra(a) | rb(b) | bc(c)); }\n+inline void Assembler::isel(Register d, Register a, Register b, int c) { emit_int32(ISEL_OPCODE    | rt(d)  | ra(a) | rb(b) | bc(c)); }\n@@ -704,6 +703,5 @@\n-inline bool Assembler::lxarx_hint_exclusive_access()                                          { return VM_Version::has_lxarxeh(); }\n-inline void Assembler::lbarx( Register d, Register a, Register b, bool hint_exclusive_access) { lbarx_unchecked(d, a, b, (hint_exclusive_access && lxarx_hint_exclusive_access() && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n-inline void Assembler::lharx( Register d, Register a, Register b, bool hint_exclusive_access) { lharx_unchecked(d, a, b, (hint_exclusive_access && lxarx_hint_exclusive_access() && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n-inline void Assembler::lwarx( Register d, Register a, Register b, bool hint_exclusive_access) { lwarx_unchecked(d, a, b, (hint_exclusive_access && lxarx_hint_exclusive_access() && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n-inline void Assembler::ldarx( Register d, Register a, Register b, bool hint_exclusive_access) { ldarx_unchecked(d, a, b, (hint_exclusive_access && lxarx_hint_exclusive_access() && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n-inline void Assembler::lqarx( Register d, Register a, Register b, bool hint_exclusive_access) { lqarx_unchecked(d, a, b, (hint_exclusive_access && lxarx_hint_exclusive_access() && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n+inline void Assembler::lbarx( Register d, Register a, Register b, bool hint_exclusive_access) { lbarx_unchecked(d, a, b, (hint_exclusive_access && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n+inline void Assembler::lharx( Register d, Register a, Register b, bool hint_exclusive_access) { lharx_unchecked(d, a, b, (hint_exclusive_access && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n+inline void Assembler::lwarx( Register d, Register a, Register b, bool hint_exclusive_access) { lwarx_unchecked(d, a, b, (hint_exclusive_access && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n+inline void Assembler::ldarx( Register d, Register a, Register b, bool hint_exclusive_access) { ldarx_unchecked(d, a, b, (hint_exclusive_access && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n+inline void Assembler::lqarx( Register d, Register a, Register b, bool hint_exclusive_access) { lqarx_unchecked(d, a, b, (hint_exclusive_access && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n@@ -778,6 +776,3 @@\n-inline void Assembler::cmpb(   Register a, Register s, Register b) { guarantee(VM_Version::has_cmpb(), \"opcode not supported on this hardware\");\n-                                                                     emit_int32( CMPB_OPCODE    | rta(a) | rs(s) | rb(b) | rc(0)); }\n-inline void Assembler::popcntb(Register a, Register s)             { guarantee(VM_Version::has_popcntb(), \"opcode not supported on this hardware\");\n-                                                                     emit_int32( POPCNTB_OPCODE | rta(a) | rs(s)); };\n-inline void Assembler::popcntw(Register a, Register s)             { guarantee(VM_Version::has_popcntw(), \"opcode not supported on this hardware\");\n-                                                                     emit_int32( POPCNTW_OPCODE | rta(a) | rs(s)); };\n+inline void Assembler::cmpb(   Register a, Register s, Register b) { emit_int32( CMPB_OPCODE    | rta(a) | rs(s) | rb(b) | rc(0)); }\n+inline void Assembler::popcntb(Register a, Register s)             { emit_int32( POPCNTB_OPCODE | rta(a) | rs(s)); };\n+inline void Assembler::popcntw(Register a, Register s)             { emit_int32( POPCNTW_OPCODE | rta(a) | rs(s)); };\n@@ -838,2 +833,1 @@\n-inline void Assembler::fcfids(FloatRegister d, FloatRegister b) { guarantee(VM_Version::has_fcfids(), \"opcode not supported on this hardware\");\n-                                                                  emit_int32( FCFIDS_OPCODE | frt(d) | frb(b) | rc(0)); }\n+inline void Assembler::fcfids(FloatRegister d, FloatRegister b) { emit_int32( FCFIDS_OPCODE | frt(d) | frb(b) | rc(0)); }\n@@ -845,4 +839,2 @@\n-inline void Assembler::fsqrt( FloatRegister d, FloatRegister b) { guarantee(VM_Version::has_fsqrt(), \"opcode not supported on this hardware\");\n-                                                                  emit_int32( FSQRT_OPCODE  | frt(d) | frb(b) | rc(0)); }\n-inline void Assembler::fsqrts(FloatRegister d, FloatRegister b) { guarantee(VM_Version::has_fsqrts(), \"opcode not supported on this hardware\");\n-                                                                  emit_int32( FSQRTS_OPCODE | frt(d) | frb(b) | rc(0)); }\n+inline void Assembler::fsqrt( FloatRegister d, FloatRegister b) { emit_int32( FSQRT_OPCODE  | frt(d) | frb(b) | rc(0)); }\n+inline void Assembler::fsqrts(FloatRegister d, FloatRegister b) { emit_int32( FSQRTS_OPCODE | frt(d) | frb(b) | rc(0)); }\n@@ -919,0 +911,5 @@\n+inline void Assembler::xvminsp(VectorSRegister d, VectorSRegister a, VectorSRegister b) { emit_int32( XVMINSP_OPCODE | vsrt(d) | vsra(a) | vsrb(b)); }\n+inline void Assembler::xvmindp(VectorSRegister d, VectorSRegister a, VectorSRegister b) { emit_int32( XVMINDP_OPCODE | vsrt(d) | vsra(a) | vsrb(b)); }\n+inline void Assembler::xvmaxsp(VectorSRegister d, VectorSRegister a, VectorSRegister b) { emit_int32( XVMAXSP_OPCODE | vsrt(d) | vsra(a) | vsrb(b)); }\n+inline void Assembler::xvmaxdp(VectorSRegister d, VectorSRegister a, VectorSRegister b) { emit_int32( XVMAXDP_OPCODE | vsrt(d) | vsra(a) | vsrb(b)); }\n+\n@@ -1033,0 +1030,1 @@\n+inline void Assembler::vmaxsd(  VectorRegister d, VectorRegister a, VectorRegister b) { emit_int32( VMAXSD_OPCODE   | vrt(d) | vra(a) | vrb(b)); }\n@@ -1036,0 +1034,1 @@\n+inline void Assembler::vmaxud(  VectorRegister d, VectorRegister a, VectorRegister b) { emit_int32( VMAXUD_OPCODE   | vrt(d) | vra(a) | vrb(b)); }\n@@ -1039,0 +1038,1 @@\n+inline void Assembler::vminsd(  VectorRegister d, VectorRegister a, VectorRegister b) { emit_int32( VMINSD_OPCODE   | vrt(d) | vra(a) | vrb(b)); }\n@@ -1042,0 +1042,1 @@\n+inline void Assembler::vminud(  VectorRegister d, VectorRegister a, VectorRegister b) { emit_int32( VMINUD_OPCODE   | vrt(d) | vra(a) | vrb(b)); }\n@@ -1060,2 +1061,1 @@\n-inline void Assembler::vand(    VectorRegister d, VectorRegister a, VectorRegister b) { guarantee(VM_Version::has_vand(), \"opcode not supported on this hardware\");\n-                                                                                        emit_int32( VAND_OPCODE     | vrt(d) | vra(a) | vrb(b)); }\n+inline void Assembler::vand(    VectorRegister d, VectorRegister a, VectorRegister b) { emit_int32( VAND_OPCODE     | vrt(d) | vra(a) | vrb(b)); }\n@@ -1095,0 +1095,3 @@\n+\/\/ Vector Negate Word (introduced with Power 9)\n+inline void Assembler::vnegw(   VectorRegister d, VectorRegister b)                   { emit_int32( VNEGW_OPCODE    | vrt(d) | vrb(b)); }\n+\n@@ -1169,5 +1172,5 @@\n-inline void Assembler::lbarx( Register d, Register b, bool hint_exclusive_access){ lbarx_unchecked(d, b, (hint_exclusive_access && lxarx_hint_exclusive_access() && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n-inline void Assembler::lharx( Register d, Register b, bool hint_exclusive_access){ lharx_unchecked(d, b, (hint_exclusive_access && lxarx_hint_exclusive_access() && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n-inline void Assembler::lwarx( Register d, Register b, bool hint_exclusive_access){ lwarx_unchecked(d, b, (hint_exclusive_access && lxarx_hint_exclusive_access() && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n-inline void Assembler::ldarx( Register d, Register b, bool hint_exclusive_access){ ldarx_unchecked(d, b, (hint_exclusive_access && lxarx_hint_exclusive_access() && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n-inline void Assembler::lqarx( Register d, Register b, bool hint_exclusive_access){ lqarx_unchecked(d, b, (hint_exclusive_access && lxarx_hint_exclusive_access() && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n+inline void Assembler::lbarx( Register d, Register b, bool hint_exclusive_access){ lbarx_unchecked(d, b, (hint_exclusive_access && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n+inline void Assembler::lharx( Register d, Register b, bool hint_exclusive_access){ lharx_unchecked(d, b, (hint_exclusive_access && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n+inline void Assembler::lwarx( Register d, Register b, bool hint_exclusive_access){ lwarx_unchecked(d, b, (hint_exclusive_access && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n+inline void Assembler::ldarx( Register d, Register b, bool hint_exclusive_access){ ldarx_unchecked(d, b, (hint_exclusive_access && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n+inline void Assembler::lqarx( Register d, Register b, bool hint_exclusive_access){ lqarx_unchecked(d, b, (hint_exclusive_access && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":30,"deletions":27,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -44,18 +44,1 @@\n-    assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n-           \"polling page return stub not created yet\");\n-    address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n-\n-    \/\/ Using pc relative address computation.\n-    {\n-      Label next_pc;\n-      __ bl(next_pc);\n-      __ bind(next_pc);\n-    }\n-    int current_offset = __ offset();\n-    __ mflr(R12);\n-    __ add_const_optimized(R12, R12, safepoint_offset() - current_offset);\n-    __ std(R12, in_bytes(JavaThread::saved_exception_pc_offset()), R16_thread);\n-\n-    __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(stub));\n-    __ mtctr(R0);\n-    __ bctr();\n+    __ jump_to_polling_page_return_handler_blob(safepoint_offset());\n@@ -70,1 +53,1 @@\n-    address a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+    address a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -81,2 +64,2 @@\n-  address stub = _throw_index_out_of_bounds_exception ? Runtime1::entry_for(C1StubId::throw_index_exception_id)\n-                                                      : Runtime1::entry_for(C1StubId::throw_range_check_failed_id);\n+  address stub = _throw_index_out_of_bounds_exception ? Runtime1::entry_for(StubId::c1_throw_index_exception_id)\n+                                                      : Runtime1::entry_for(StubId::c1_throw_range_check_failed_id);\n@@ -111,1 +94,1 @@\n-  address a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+  address a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -135,1 +118,1 @@\n-  address a = Runtime1::entry_for(C1StubId::counter_overflow_id);\n+  address a = Runtime1::entry_for(StubId::c1_counter_overflow_id);\n@@ -152,1 +135,1 @@\n-  address stub = Runtime1::entry_for(C1StubId::throw_div0_exception_id);\n+  address stub = Runtime1::entry_for(StubId::c1_throw_div0_exception_id);\n@@ -167,1 +150,1 @@\n-    a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+    a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -169,1 +152,1 @@\n-    a = Runtime1::entry_for(C1StubId::throw_null_pointer_exception_id);\n+    a = Runtime1::entry_for(StubId::c1_throw_null_pointer_exception_id);\n@@ -201,1 +184,1 @@\n-NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, C1StubId stub_id) {\n+NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, StubId stub_id) {\n@@ -206,3 +189,3 @@\n-  assert(stub_id == C1StubId::new_instance_id                 ||\n-         stub_id == C1StubId::fast_new_instance_id            ||\n-         stub_id == C1StubId::fast_new_instance_init_check_id,\n+  assert(stub_id == StubId::c1_new_instance_id                 ||\n+         stub_id == StubId::c1_fast_new_instance_id            ||\n+         stub_id == StubId::c1_fast_new_instance_init_check_id,\n@@ -238,1 +221,1 @@\n-  address entry = Runtime1::entry_for(C1StubId::new_type_array_id);\n+  address entry = Runtime1::entry_for(StubId::c1_new_type_array_id);\n@@ -261,1 +244,1 @@\n-  address entry = Runtime1::entry_for(C1StubId::new_object_array_id);\n+  address entry = Runtime1::entry_for(StubId::c1_new_object_array_id);\n@@ -274,1 +257,1 @@\n-  address stub = Runtime1::entry_for(ce->compilation()->has_fpu_code() ? C1StubId::monitorenter_id : C1StubId::monitorenter_nofpu_id);\n+  address stub = Runtime1::entry_for(ce->compilation()->has_fpu_code() ? StubId::c1_monitorenter_id : StubId::c1_monitorenter_nofpu_id);\n@@ -291,1 +274,1 @@\n-  address stub = Runtime1::entry_for(ce->compilation()->has_fpu_code() ? C1StubId::monitorexit_id : C1StubId::monitorexit_nofpu_id);\n+  address stub = Runtime1::entry_for(ce->compilation()->has_fpu_code() ? StubId::c1_monitorexit_id : StubId::c1_monitorexit_nofpu_id);\n@@ -405,2 +388,2 @@\n-    case access_field_id:  target = Runtime1::entry_for(C1StubId::access_field_patching_id); break;\n-    case load_klass_id:    target = Runtime1::entry_for(C1StubId::load_klass_patching_id);\n+    case access_field_id:  target = Runtime1::entry_for(StubId::c1_access_field_patching_id); break;\n+    case load_klass_id:    target = Runtime1::entry_for(StubId::c1_load_klass_patching_id);\n@@ -408,1 +391,1 @@\n-    case load_mirror_id:   target = Runtime1::entry_for(C1StubId::load_mirror_patching_id);\n+    case load_mirror_id:   target = Runtime1::entry_for(StubId::c1_load_mirror_patching_id);\n@@ -410,1 +393,1 @@\n-    case load_appendix_id: target = Runtime1::entry_for(C1StubId::load_appendix_patching_id);\n+    case load_appendix_id: target = Runtime1::entry_for(StubId::c1_load_appendix_patching_id);\n@@ -436,1 +419,1 @@\n-  address stub = Runtime1::entry_for(C1StubId::deoptimize_id);\n+  address stub = Runtime1::entry_for(StubId::c1_deoptimize_id);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_CodeStubs_ppc.cpp","additions":22,"deletions":39,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-  address entry_point = CAST_FROM_FN_PTR(address, Runtime1::entry_for(C1StubId::handle_exception_from_callee_id));\n+  address entry_point = CAST_FROM_FN_PTR(address, Runtime1::entry_for(StubId::c1_handle_exception_from_callee_id));\n@@ -244,1 +244,1 @@\n-  address unwind_stub = Runtime1::entry_for(C1StubId::unwind_exception_id);\n+  address unwind_stub = Runtime1::entry_for(StubId::c1_unwind_exception_id);\n@@ -541,1 +541,7 @@\n-    case Bytecodes::_i2d:\n+    case Bytecodes::_i2d:{\n+      FloatRegister rdst = dst->as_double_reg();\n+      \/\/ move src to dst register\n+      __ mtfprwa(rdst, src->as_register());\n+      __ fcfid(rdst, rdst);\n+      break;\n+    }\n@@ -543,14 +549,10 @@\n-      bool src_in_memory = !VM_Version::has_mtfprd();\n-      FloatRegister rsrc;\n-      if (src_in_memory) {\n-        rsrc = src->as_double_reg(); \/\/ via mem\n-      } else {\n-        \/\/ move src to dst register\n-        if (code == Bytecodes::_i2d) {\n-          __ mtfprwa(rdst, src->as_register());\n-        } else {\n-          __ mtfprd(rdst, src->as_register_lo());\n-        }\n-        rsrc = rdst;\n-      }\n-      __ fcfid(rdst, rsrc);\n+      \/\/ move src to dst register\n+      __ mtfprd(rdst, src->as_register_lo());\n+      __ fcfid(rdst, rdst);\n+      break;\n+    }\n+    case Bytecodes::_i2f:{\n+      FloatRegister rdst = dst->as_float_reg();\n+      \/\/ move src to dst register\n+      __ mtfprwa(rdst, src->as_register());\n+      __ fcfids(rdst, rdst);\n@@ -560,21 +562,3 @@\n-    case Bytecodes::_i2f:\n-      bool src_in_memory = !VM_Version::has_mtfprd();\n-      FloatRegister rsrc;\n-      if (src_in_memory) {\n-        rsrc = src->as_double_reg(); \/\/ via mem\n-      } else {\n-        \/\/ move src to dst register\n-        if (code == Bytecodes::_i2f) {\n-          __ mtfprwa(rdst, src->as_register());\n-        } else {\n-          __ mtfprd(rdst, src->as_register_lo());\n-        }\n-        rsrc = rdst;\n-      }\n-      if (VM_Version::has_fcfids()) {\n-        __ fcfids(rdst, rsrc);\n-      } else {\n-        assert(code == Bytecodes::_i2f, \"fcfid+frsp needs fixup code to avoid rounding incompatibility\");\n-        __ fcfid(rdst, rsrc);\n-        __ frsp(rdst, rdst);\n-      }\n+      \/\/ move src to dst register\n+      __ mtfprd(rdst, src->as_register_lo());\n+      __ fcfids(rdst, rdst);\n@@ -595,2 +579,0 @@\n-      bool dst_in_memory = !VM_Version::has_mtfprd();\n-      Address       addr = dst_in_memory ? frame_map()->address_for_slot(dst->double_stack_ix()) : Address();\n@@ -601,6 +583,1 @@\n-      if (dst_in_memory) {\n-        __ li(R0, 0); \/\/ 0 in case of NAN\n-        __ std(R0, addr);\n-      } else {\n-        __ li(dst->as_register(), 0);\n-      }\n+      __ li(dst->as_register(), 0);\n@@ -609,5 +586,1 @@\n-      if (dst_in_memory) {\n-        __ stfd(rsrc, addr.disp(), addr.base());\n-      } else {\n-        __ mffprd(dst->as_register(), rsrc);\n-      }\n+      __ mffprd(dst->as_register(), rsrc);\n@@ -619,2 +592,0 @@\n-      bool dst_in_memory = !VM_Version::has_mtfprd();\n-      Address       addr = dst_in_memory ? frame_map()->address_for_slot(dst->double_stack_ix()) : Address();\n@@ -625,6 +596,1 @@\n-      if (dst_in_memory) {\n-        __ li(R0, 0); \/\/ 0 in case of NAN\n-        __ std(R0, addr);\n-      } else {\n-        __ li(dst->as_register_lo(), 0);\n-      }\n+      __ li(dst->as_register_lo(), 0);\n@@ -633,5 +599,1 @@\n-      if (dst_in_memory) {\n-        __ stfd(rsrc, addr.disp(), addr.base());\n-      } else {\n-        __ mffprd(dst->as_register_lo(), rsrc);\n-      }\n+      __ mffprd(dst->as_register_lo(), rsrc);\n@@ -1584,2 +1546,1 @@\n-  \/\/ Try to use isel on >=Power7.\n-  if (VM_Version::has_isel() && result->is_cpu_register()) {\n+  if (result->is_cpu_register()) {\n@@ -1830,2 +1791,2 @@\n-  address stub = Runtime1::entry_for(compilation()->has_fpu_code() ? C1StubId::handle_exception_id\n-                                                                   : C1StubId::handle_exception_nofpu_id);\n+  address stub = Runtime1::entry_for(compilation()->has_fpu_code() ? StubId::c1_handle_exception_id\n+                                                                   : StubId::c1_handle_exception_nofpu_id);\n@@ -2022,1 +1983,1 @@\n-      address slow_stc = Runtime1::entry_for(C1StubId::slow_subtype_check_id);\n+      address slow_stc = Runtime1::entry_for(StubId::c1_slow_subtype_check_id);\n@@ -2450,1 +2411,1 @@\n-      address entry = Runtime1::entry_for(C1StubId::slow_subtype_check_id);\n+      address entry = Runtime1::entry_for(StubId::c1_slow_subtype_check_id);\n@@ -2541,1 +2502,1 @@\n-    const address slow_path = Runtime1::entry_for(C1StubId::slow_subtype_check_id);\n+    const address slow_path = Runtime1::entry_for(StubId::c1_slow_subtype_check_id);\n@@ -2843,3 +2804,3 @@\n-  if (dest == Runtime1::entry_for(C1StubId::register_finalizer_id) ||\n-      dest == Runtime1::entry_for(C1StubId::new_multi_array_id   ) ||\n-      dest == Runtime1::entry_for(C1StubId::is_instance_of_id    )) {\n+  if (dest == Runtime1::entry_for(StubId::c1_register_finalizer_id) ||\n+      dest == Runtime1::entry_for(StubId::c1_new_multi_array_id   ) ||\n+      dest == Runtime1::entry_for(StubId::c1_is_instance_of_id    )) {\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":35,"deletions":74,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -717,8 +717,6 @@\n-      if (VM_Version::has_fsqrt()) {\n-        assert(x->number_of_arguments() == 1, \"wrong type\");\n-        LIRItem value(x->argument_at(0), this);\n-        value.load_item();\n-        LIR_Opr dst = rlock_result(x);\n-        __ sqrt(value.result(), dst, LIR_OprFact::illegalOpr);\n-        break;\n-      } \/\/ else fallthru\n+      assert(x->number_of_arguments() == 1, \"wrong type\");\n+      LIRItem value(x->argument_at(0), this);\n+      value.load_item();\n+      LIR_Opr dst = rlock_result(x);\n+      __ sqrt(value.result(), dst, LIR_OprFact::illegalOpr);\n+      break;\n@@ -736,4 +734,0 @@\n-        case vmIntrinsics::_dsqrt:\n-        case vmIntrinsics::_dsqrt_strict:\n-          runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dsqrt);\n-          break;\n@@ -822,72 +816,0 @@\n-  if (!VM_Version::has_mtfprd()) {\n-    switch (x->op()) {\n-\n-      \/\/ int -> float: force spill\n-      case Bytecodes::_l2f: {\n-        if (!VM_Version::has_fcfids()) { \/\/ fcfids is >= Power7 only\n-          \/\/ fcfid+frsp needs fixup code to avoid rounding incompatibility.\n-          address entry = CAST_FROM_FN_PTR(address, SharedRuntime::l2f);\n-          LIR_Opr result = call_runtime(x->value(), entry, x->type(), nullptr);\n-          set_result(x, result);\n-          return;\n-        } \/\/ else fallthru\n-      }\n-      case Bytecodes::_l2d: {\n-        LIRItem value(x->value(), this);\n-        LIR_Opr reg = rlock_result(x);\n-        value.load_item();\n-        LIR_Opr tmp = force_to_spill(value.result(), T_DOUBLE);\n-        __ convert(x->op(), tmp, reg);\n-        return;\n-      }\n-      case Bytecodes::_i2f:\n-      case Bytecodes::_i2d: {\n-        LIRItem value(x->value(), this);\n-        LIR_Opr reg = rlock_result(x);\n-        value.load_item();\n-        \/\/ Convert i2l first.\n-        LIR_Opr tmp1 = new_register(T_LONG);\n-        __ convert(Bytecodes::_i2l, value.result(), tmp1);\n-        LIR_Opr tmp2 = force_to_spill(tmp1, T_DOUBLE);\n-        __ convert(x->op(), tmp2, reg);\n-        return;\n-      }\n-\n-      \/\/ float -> int: result will be stored\n-      case Bytecodes::_f2l:\n-      case Bytecodes::_d2l: {\n-        LIRItem value(x->value(), this);\n-        LIR_Opr reg = rlock_result(x);\n-        value.set_destroys_register(); \/\/ USE_KILL\n-        value.load_item();\n-        set_vreg_flag(reg, must_start_in_memory);\n-        __ convert(x->op(), value.result(), reg);\n-        return;\n-      }\n-      case Bytecodes::_f2i:\n-      case Bytecodes::_d2i: {\n-        LIRItem value(x->value(), this);\n-        LIR_Opr reg = rlock_result(x);\n-        value.set_destroys_register(); \/\/ USE_KILL\n-        value.load_item();\n-        \/\/ Convert l2i afterwards.\n-        LIR_Opr tmp1 = new_register(T_LONG);\n-        set_vreg_flag(tmp1, must_start_in_memory);\n-        __ convert(x->op(), value.result(), tmp1);\n-        __ convert(Bytecodes::_l2i, tmp1, reg);\n-        return;\n-      }\n-\n-      \/\/ Within same category: just register conversions.\n-      case Bytecodes::_i2b:\n-      case Bytecodes::_i2c:\n-      case Bytecodes::_i2s:\n-      case Bytecodes::_i2l:\n-      case Bytecodes::_l2i:\n-      case Bytecodes::_f2d:\n-      case Bytecodes::_d2f:\n-        break;\n-\n-      default: ShouldNotReachHere();\n-    }\n-  }\n@@ -1057,1 +979,1 @@\n-  __ call_runtime(Runtime1::entry_for(C1StubId::new_multi_array_id),\n+  __ call_runtime(Runtime1::entry_for(StubId::c1_new_multi_array_id),\n@@ -1092,1 +1014,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_incompatible_class_change_error_id,\n+    stub = new SimpleExceptionStub(StubId::c1_throw_incompatible_class_change_error_id,\n@@ -1100,1 +1022,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_class_cast_exception_id, obj.result(), info_for_exception);\n+    stub = new SimpleExceptionStub(StubId::c1_throw_class_cast_exception_id, obj.result(), info_for_exception);\n@@ -1134,1 +1056,1 @@\n-  return Runtime1::entry_for(C1StubId::is_instance_of_id);\n+  return Runtime1::entry_for(StubId::c1_is_instance_of_id);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":10,"deletions":88,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-  \/\/ Avoid stack bang as first instruction. It may get overwritten by patch_verified_entry.\n@@ -311,1 +310,1 @@\n-\/\/    call(CAST_FROM_FN_PTR(address, Runtime1::entry_for(C1StubId::dtrace_object_alloc_id)),\n+\/\/    call(CAST_FROM_FN_PTR(address, Runtime1::entry_for(StubId::c1_dtrace_object_alloc_id)),\n@@ -387,1 +386,1 @@\n-    \/\/call(CAST_FROM_FN_PTR(address, Runtime1::entry_for(C1StubId::dtrace_object_alloc_id)),\n+    \/\/call(CAST_FROM_FN_PTR(address, Runtime1::entry_for(StubId::c1_dtrace_object_alloc_id)),\n@@ -416,1 +415,1 @@\n-    \/\/const address exception_entry = Runtime1::entry_for(C1StubId::throw_null_pointer_exception_id);\n+    \/\/const address exception_entry = Runtime1::entry_for(StubId::c1_throw_null_pointer_exception_id);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-    } else if (_stub_id == (int)C1StubId::forward_exception_id) {\n+    } else if (_stub_id == (int)StubId::c1_forward_exception_id) {\n@@ -104,2 +104,2 @@\n-      \/\/load_const_optimized(R0, Runtime1::entry_for(C1StubId::forward_exception_id));\n-      add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(Runtime1::entry_for(C1StubId::forward_exception_id)));\n+      \/\/load_const_optimized(R0, Runtime1::entry_for(StubId::c1_forward_exception_id));\n+      add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(Runtime1::entry_for(StubId::c1_forward_exception_id)));\n@@ -394,1 +394,1 @@\n-OopMapSet* Runtime1::generate_code_for(C1StubId id, StubAssembler* sasm) {\n+OopMapSet* Runtime1::generate_code_for(StubId id, StubAssembler* sasm) {\n@@ -403,1 +403,1 @@\n-    case C1StubId::forward_exception_id:\n+    case StubId::c1_forward_exception_id:\n@@ -409,3 +409,3 @@\n-    case C1StubId::new_instance_id:\n-    case C1StubId::fast_new_instance_id:\n-    case C1StubId::fast_new_instance_init_check_id:\n+    case StubId::c1_new_instance_id:\n+    case StubId::c1_fast_new_instance_id:\n+    case StubId::c1_fast_new_instance_init_check_id:\n@@ -413,1 +413,1 @@\n-        if (id == C1StubId::new_instance_id) {\n+        if (id == StubId::c1_new_instance_id) {\n@@ -415,1 +415,1 @@\n-        } else if (id == C1StubId::fast_new_instance_id) {\n+        } else if (id == StubId::c1_fast_new_instance_id) {\n@@ -418,1 +418,1 @@\n-          assert(id == C1StubId::fast_new_instance_init_check_id, \"bad C1StubId\");\n+          assert(id == StubId::c1_fast_new_instance_init_check_id, \"bad StubId\");\n@@ -428,1 +428,1 @@\n-    case C1StubId::counter_overflow_id:\n+    case StubId::c1_counter_overflow_id:\n@@ -433,2 +433,2 @@\n-    case C1StubId::new_type_array_id:\n-    case C1StubId::new_object_array_id:\n+    case StubId::c1_new_type_array_id:\n+    case StubId::c1_new_object_array_id:\n@@ -436,1 +436,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -445,1 +445,1 @@\n-          int tag = (id == C1StubId::new_type_array_id) ? Klass::_lh_array_tag_type_value : Klass::_lh_array_tag_obj_value;\n+          int tag = (id == StubId::c1_new_type_array_id) ? Klass::_lh_array_tag_type_value : Klass::_lh_array_tag_obj_value;\n@@ -459,1 +459,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -467,1 +467,1 @@\n-    case C1StubId::new_multi_array_id:\n+    case StubId::c1_new_multi_array_id:\n@@ -477,1 +477,1 @@\n-    case C1StubId::register_finalizer_id:\n+    case StubId::c1_register_finalizer_id:\n@@ -507,1 +507,1 @@\n-    case C1StubId::throw_range_check_failed_id:\n+    case StubId::c1_throw_range_check_failed_id:\n@@ -514,1 +514,1 @@\n-    case C1StubId::throw_index_exception_id:\n+    case StubId::c1_throw_index_exception_id:\n@@ -521,1 +521,1 @@\n-    case C1StubId::throw_div0_exception_id:\n+    case StubId::c1_throw_div0_exception_id:\n@@ -528,1 +528,1 @@\n-    case C1StubId::throw_null_pointer_exception_id:\n+    case StubId::c1_throw_null_pointer_exception_id:\n@@ -535,2 +535,2 @@\n-    case C1StubId::handle_exception_nofpu_id:\n-    case C1StubId::handle_exception_id:\n+    case StubId::c1_handle_exception_nofpu_id:\n+    case StubId::c1_handle_exception_id:\n@@ -543,1 +543,1 @@\n-    case C1StubId::handle_exception_from_callee_id:\n+    case StubId::c1_handle_exception_from_callee_id:\n@@ -550,1 +550,1 @@\n-    case C1StubId::unwind_exception_id:\n+    case StubId::c1_unwind_exception_id:\n@@ -578,1 +578,1 @@\n-    case C1StubId::throw_array_store_exception_id:\n+    case StubId::c1_throw_array_store_exception_id:\n@@ -585,1 +585,1 @@\n-    case C1StubId::throw_class_cast_exception_id:\n+    case StubId::c1_throw_class_cast_exception_id:\n@@ -592,1 +592,1 @@\n-    case C1StubId::throw_incompatible_class_change_error_id:\n+    case StubId::c1_throw_incompatible_class_change_error_id:\n@@ -599,1 +599,1 @@\n-    case C1StubId::slow_subtype_check_id:\n+    case StubId::c1_slow_subtype_check_id:\n@@ -610,1 +610,1 @@\n-    case C1StubId::is_instance_of_id:\n+    case StubId::c1_is_instance_of_id:\n@@ -677,2 +677,2 @@\n-    case C1StubId::monitorenter_nofpu_id:\n-    case C1StubId::monitorenter_id:\n+    case StubId::c1_monitorenter_nofpu_id:\n+    case StubId::c1_monitorenter_id:\n@@ -682,1 +682,1 @@\n-        int save_fpu_registers = (id == C1StubId::monitorenter_id);\n+        int save_fpu_registers = (id == StubId::c1_monitorenter_id);\n@@ -696,2 +696,2 @@\n-    case C1StubId::monitorexit_nofpu_id:\n-    case C1StubId::monitorexit_id:\n+    case StubId::c1_monitorexit_nofpu_id:\n+    case StubId::c1_monitorexit_id:\n@@ -704,1 +704,1 @@\n-        int save_fpu_registers = (id == C1StubId::monitorexit_id);\n+        int save_fpu_registers = (id == StubId::c1_monitorexit_id);\n@@ -718,1 +718,1 @@\n-    case C1StubId::deoptimize_id:\n+    case StubId::c1_deoptimize_id:\n@@ -734,1 +734,1 @@\n-    case C1StubId::access_field_patching_id:\n+    case StubId::c1_access_field_patching_id:\n@@ -741,1 +741,1 @@\n-    case C1StubId::load_klass_patching_id:\n+    case StubId::c1_load_klass_patching_id:\n@@ -748,1 +748,1 @@\n-    case C1StubId::load_mirror_patching_id:\n+    case StubId::c1_load_mirror_patching_id:\n@@ -755,1 +755,1 @@\n-    case C1StubId::load_appendix_patching_id:\n+    case StubId::c1_load_appendix_patching_id:\n@@ -762,1 +762,1 @@\n-    case C1StubId::dtrace_object_alloc_id:\n+    case StubId::c1_dtrace_object_alloc_id:\n@@ -782,1 +782,1 @@\n-    case C1StubId::predicate_failed_trap_id:\n+    case StubId::c1_predicate_failed_trap_id:\n@@ -826,1 +826,1 @@\n-OopMapSet* Runtime1::generate_handle_exception(C1StubId id, StubAssembler* sasm) {\n+OopMapSet* Runtime1::generate_handle_exception(StubId id, StubAssembler* sasm) {\n@@ -836,1 +836,1 @@\n-  case C1StubId::forward_exception_id:\n+  case StubId::c1_forward_exception_id:\n@@ -852,2 +852,2 @@\n-  case C1StubId::handle_exception_nofpu_id:\n-  case C1StubId::handle_exception_id:\n+  case StubId::c1_handle_exception_nofpu_id:\n+  case StubId::c1_handle_exception_id:\n@@ -855,1 +855,1 @@\n-    oop_map = save_live_registers(sasm, id != C1StubId::handle_exception_nofpu_id, Rexception_pc);\n+    oop_map = save_live_registers(sasm, id != StubId::c1_handle_exception_nofpu_id, Rexception_pc);\n@@ -857,1 +857,1 @@\n-  case C1StubId::handle_exception_from_callee_id:\n+  case StubId::c1_handle_exception_from_callee_id:\n@@ -896,4 +896,4 @@\n-  case C1StubId::forward_exception_id:\n-  case C1StubId::handle_exception_nofpu_id:\n-  case C1StubId::handle_exception_id:\n-    restore_live_registers(sasm, noreg, noreg, id != C1StubId::handle_exception_nofpu_id);\n+  case StubId::c1_forward_exception_id:\n+  case StubId::c1_handle_exception_nofpu_id:\n+  case StubId::c1_handle_exception_id:\n+    restore_live_registers(sasm, noreg, noreg, id != StubId::c1_handle_exception_nofpu_id);\n@@ -902,1 +902,1 @@\n-  case C1StubId::handle_exception_from_callee_id: {\n+  case StubId::c1_handle_exception_from_callee_id: {\n","filename":"src\/hotspot\/cpu\/ppc\/c1_Runtime1_ppc.cpp","additions":56,"deletions":56,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -258,1 +258,1 @@\n-\/\/ Vector-Scalar Registers\n+\/\/ Vector Registers\n@@ -260,321 +260,160 @@\n-  \/\/ 1st 32 VSRs are aliases for the FPRs which are already defined above.\n-  reg_def VSR0   (SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n-  reg_def VSR0_H (SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n-  reg_def VSR0_J (SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n-  reg_def VSR0_K (SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n-\n-  reg_def VSR1   (SOC, SOC, Op_RegF, 1, VMRegImpl::Bad());\n-  reg_def VSR1_H (SOC, SOC, Op_RegF, 1, VMRegImpl::Bad());\n-  reg_def VSR1_J (SOC, SOC, Op_RegF, 1, VMRegImpl::Bad());\n-  reg_def VSR1_K (SOC, SOC, Op_RegF, 1, VMRegImpl::Bad());\n-\n-  reg_def VSR2   (SOC, SOC, Op_RegF, 2, VMRegImpl::Bad());\n-  reg_def VSR2_H (SOC, SOC, Op_RegF, 2, VMRegImpl::Bad());\n-  reg_def VSR2_J (SOC, SOC, Op_RegF, 2, VMRegImpl::Bad());\n-  reg_def VSR2_K (SOC, SOC, Op_RegF, 2, VMRegImpl::Bad());\n-\n-  reg_def VSR3   (SOC, SOC, Op_RegF, 3, VMRegImpl::Bad());\n-  reg_def VSR3_H (SOC, SOC, Op_RegF, 3, VMRegImpl::Bad());\n-  reg_def VSR3_J (SOC, SOC, Op_RegF, 3, VMRegImpl::Bad());\n-  reg_def VSR3_K (SOC, SOC, Op_RegF, 3, VMRegImpl::Bad());\n-\n-  reg_def VSR4   (SOC, SOC, Op_RegF, 4, VMRegImpl::Bad());\n-  reg_def VSR4_H (SOC, SOC, Op_RegF, 4, VMRegImpl::Bad());\n-  reg_def VSR4_J (SOC, SOC, Op_RegF, 4, VMRegImpl::Bad());\n-  reg_def VSR4_K (SOC, SOC, Op_RegF, 4, VMRegImpl::Bad());\n-\n-  reg_def VSR5   (SOC, SOC, Op_RegF, 5, VMRegImpl::Bad());\n-  reg_def VSR5_H (SOC, SOC, Op_RegF, 5, VMRegImpl::Bad());\n-  reg_def VSR5_J (SOC, SOC, Op_RegF, 5, VMRegImpl::Bad());\n-  reg_def VSR5_K (SOC, SOC, Op_RegF, 5, VMRegImpl::Bad());\n-\n-  reg_def VSR6   (SOC, SOC, Op_RegF, 6, VMRegImpl::Bad());\n-  reg_def VSR6_H (SOC, SOC, Op_RegF, 6, VMRegImpl::Bad());\n-  reg_def VSR6_J (SOC, SOC, Op_RegF, 6, VMRegImpl::Bad());\n-  reg_def VSR6_K (SOC, SOC, Op_RegF, 6, VMRegImpl::Bad());\n-\n-  reg_def VSR7   (SOC, SOC, Op_RegF, 7, VMRegImpl::Bad());\n-  reg_def VSR7_H (SOC, SOC, Op_RegF, 7, VMRegImpl::Bad());\n-  reg_def VSR7_J (SOC, SOC, Op_RegF, 7, VMRegImpl::Bad());\n-  reg_def VSR7_K (SOC, SOC, Op_RegF, 7, VMRegImpl::Bad());\n-\n-  reg_def VSR8   (SOC, SOC, Op_RegF, 8, VMRegImpl::Bad());\n-  reg_def VSR8_H (SOC, SOC, Op_RegF, 8, VMRegImpl::Bad());\n-  reg_def VSR8_J (SOC, SOC, Op_RegF, 8, VMRegImpl::Bad());\n-  reg_def VSR8_K (SOC, SOC, Op_RegF, 8, VMRegImpl::Bad());\n-\n-  reg_def VSR9   (SOC, SOC, Op_RegF, 9, VMRegImpl::Bad());\n-  reg_def VSR9_H (SOC, SOC, Op_RegF, 9, VMRegImpl::Bad());\n-  reg_def VSR9_J (SOC, SOC, Op_RegF, 9, VMRegImpl::Bad());\n-  reg_def VSR9_K (SOC, SOC, Op_RegF, 9, VMRegImpl::Bad());\n-\n-  reg_def VSR10  (SOC, SOC, Op_RegF, 10, VMRegImpl::Bad());\n-  reg_def VSR10_H(SOC, SOC, Op_RegF, 10, VMRegImpl::Bad());\n-  reg_def VSR10_J(SOC, SOC, Op_RegF, 10, VMRegImpl::Bad());\n-  reg_def VSR10_K(SOC, SOC, Op_RegF, 10, VMRegImpl::Bad());\n-\n-  reg_def VSR11  (SOC, SOC, Op_RegF, 11, VMRegImpl::Bad());\n-  reg_def VSR11_H(SOC, SOC, Op_RegF, 11, VMRegImpl::Bad());\n-  reg_def VSR11_J(SOC, SOC, Op_RegF, 11, VMRegImpl::Bad());\n-  reg_def VSR11_K(SOC, SOC, Op_RegF, 11, VMRegImpl::Bad());\n-\n-  reg_def VSR12  (SOC, SOC, Op_RegF, 12, VMRegImpl::Bad());\n-  reg_def VSR12_H(SOC, SOC, Op_RegF, 12, VMRegImpl::Bad());\n-  reg_def VSR12_J(SOC, SOC, Op_RegF, 12, VMRegImpl::Bad());\n-  reg_def VSR12_K(SOC, SOC, Op_RegF, 12, VMRegImpl::Bad());\n-\n-  reg_def VSR13  (SOC, SOC, Op_RegF, 13, VMRegImpl::Bad());\n-  reg_def VSR13_H(SOC, SOC, Op_RegF, 13, VMRegImpl::Bad());\n-  reg_def VSR13_J(SOC, SOC, Op_RegF, 13, VMRegImpl::Bad());\n-  reg_def VSR13_K(SOC, SOC, Op_RegF, 13, VMRegImpl::Bad());\n-\n-  reg_def VSR14  (SOC, SOC, Op_RegF, 14, VMRegImpl::Bad());\n-  reg_def VSR14_H(SOC, SOC, Op_RegF, 14, VMRegImpl::Bad());\n-  reg_def VSR14_J(SOC, SOC, Op_RegF, 14, VMRegImpl::Bad());\n-  reg_def VSR14_K(SOC, SOC, Op_RegF, 14, VMRegImpl::Bad());\n-\n-  reg_def VSR15  (SOC, SOC, Op_RegF, 15, VMRegImpl::Bad());\n-  reg_def VSR15_H(SOC, SOC, Op_RegF, 15, VMRegImpl::Bad());\n-  reg_def VSR15_J(SOC, SOC, Op_RegF, 15, VMRegImpl::Bad());\n-  reg_def VSR15_K(SOC, SOC, Op_RegF, 15, VMRegImpl::Bad());\n-\n-  reg_def VSR16  (SOC, SOC, Op_RegF, 16, VMRegImpl::Bad());\n-  reg_def VSR16_H(SOC, SOC, Op_RegF, 16, VMRegImpl::Bad());\n-  reg_def VSR16_J(SOC, SOC, Op_RegF, 16, VMRegImpl::Bad());\n-  reg_def VSR16_K(SOC, SOC, Op_RegF, 16, VMRegImpl::Bad());\n-\n-  reg_def VSR17  (SOC, SOC, Op_RegF, 17, VMRegImpl::Bad());\n-  reg_def VSR17_H(SOC, SOC, Op_RegF, 17, VMRegImpl::Bad());\n-  reg_def VSR17_J(SOC, SOC, Op_RegF, 17, VMRegImpl::Bad());\n-  reg_def VSR17_K(SOC, SOC, Op_RegF, 17, VMRegImpl::Bad());\n-\n-  reg_def VSR18  (SOC, SOC, Op_RegF, 18, VMRegImpl::Bad());\n-  reg_def VSR18_H(SOC, SOC, Op_RegF, 18, VMRegImpl::Bad());\n-  reg_def VSR18_J(SOC, SOC, Op_RegF, 18, VMRegImpl::Bad());\n-  reg_def VSR18_K(SOC, SOC, Op_RegF, 18, VMRegImpl::Bad());\n-\n-  reg_def VSR19  (SOC, SOC, Op_RegF, 19, VMRegImpl::Bad());\n-  reg_def VSR19_H(SOC, SOC, Op_RegF, 19, VMRegImpl::Bad());\n-  reg_def VSR19_J(SOC, SOC, Op_RegF, 19, VMRegImpl::Bad());\n-  reg_def VSR19_K(SOC, SOC, Op_RegF, 19, VMRegImpl::Bad());\n-\n-  reg_def VSR20  (SOC, SOC, Op_RegF, 20, VMRegImpl::Bad());\n-  reg_def VSR20_H(SOC, SOC, Op_RegF, 20, VMRegImpl::Bad());\n-  reg_def VSR20_J(SOC, SOC, Op_RegF, 20, VMRegImpl::Bad());\n-  reg_def VSR20_K(SOC, SOC, Op_RegF, 20, VMRegImpl::Bad());\n-\n-  reg_def VSR21  (SOC, SOC, Op_RegF, 21, VMRegImpl::Bad());\n-  reg_def VSR21_H(SOC, SOC, Op_RegF, 21, VMRegImpl::Bad());\n-  reg_def VSR21_J(SOC, SOC, Op_RegF, 21, VMRegImpl::Bad());\n-  reg_def VSR21_K(SOC, SOC, Op_RegF, 21, VMRegImpl::Bad());\n-\n-  reg_def VSR22  (SOC, SOC, Op_RegF, 22, VMRegImpl::Bad());\n-  reg_def VSR22_H(SOC, SOC, Op_RegF, 22, VMRegImpl::Bad());\n-  reg_def VSR22_J(SOC, SOC, Op_RegF, 22, VMRegImpl::Bad());\n-  reg_def VSR22_K(SOC, SOC, Op_RegF, 22, VMRegImpl::Bad());\n-\n-  reg_def VSR23  (SOC, SOC, Op_RegF, 23, VMRegImpl::Bad());\n-  reg_def VSR23_H(SOC, SOC, Op_RegF, 23, VMRegImpl::Bad());\n-  reg_def VSR23_J(SOC, SOC, Op_RegF, 23, VMRegImpl::Bad());\n-  reg_def VSR23_K(SOC, SOC, Op_RegF, 23, VMRegImpl::Bad());\n-\n-  reg_def VSR24  (SOC, SOC, Op_RegF, 24, VMRegImpl::Bad());\n-  reg_def VSR24_H(SOC, SOC, Op_RegF, 24, VMRegImpl::Bad());\n-  reg_def VSR24_J(SOC, SOC, Op_RegF, 24, VMRegImpl::Bad());\n-  reg_def VSR24_K(SOC, SOC, Op_RegF, 24, VMRegImpl::Bad());\n-\n-  reg_def VSR25  (SOC, SOC, Op_RegF, 25, VMRegImpl::Bad());\n-  reg_def VSR25_H(SOC, SOC, Op_RegF, 25, VMRegImpl::Bad());\n-  reg_def VSR25_J(SOC, SOC, Op_RegF, 25, VMRegImpl::Bad());\n-  reg_def VSR25_K(SOC, SOC, Op_RegF, 25, VMRegImpl::Bad());\n-\n-  reg_def VSR26  (SOC, SOC, Op_RegF, 26, VMRegImpl::Bad());\n-  reg_def VSR26_H(SOC, SOC, Op_RegF, 26, VMRegImpl::Bad());\n-  reg_def VSR26_J(SOC, SOC, Op_RegF, 26, VMRegImpl::Bad());\n-  reg_def VSR26_K(SOC, SOC, Op_RegF, 26, VMRegImpl::Bad());\n-\n-  reg_def VSR27  (SOC, SOC, Op_RegF, 27, VMRegImpl::Bad());\n-  reg_def VSR27_H(SOC, SOC, Op_RegF, 27, VMRegImpl::Bad());\n-  reg_def VSR27_J(SOC, SOC, Op_RegF, 27, VMRegImpl::Bad());\n-  reg_def VSR27_K(SOC, SOC, Op_RegF, 27, VMRegImpl::Bad());\n-\n-  reg_def VSR28  (SOC, SOC, Op_RegF, 28, VMRegImpl::Bad());\n-  reg_def VSR28_H(SOC, SOC, Op_RegF, 28, VMRegImpl::Bad());\n-  reg_def VSR28_J(SOC, SOC, Op_RegF, 28, VMRegImpl::Bad());\n-  reg_def VSR28_K(SOC, SOC, Op_RegF, 28, VMRegImpl::Bad());\n-\n-  reg_def VSR29  (SOC, SOC, Op_RegF, 29, VMRegImpl::Bad());\n-  reg_def VSR29_H(SOC, SOC, Op_RegF, 29, VMRegImpl::Bad());\n-  reg_def VSR29_J(SOC, SOC, Op_RegF, 29, VMRegImpl::Bad());\n-  reg_def VSR29_K(SOC, SOC, Op_RegF, 29, VMRegImpl::Bad());\n-\n-  reg_def VSR30  (SOC, SOC, Op_RegF, 30, VMRegImpl::Bad());\n-  reg_def VSR30_H(SOC, SOC, Op_RegF, 30, VMRegImpl::Bad());\n-  reg_def VSR30_J(SOC, SOC, Op_RegF, 30, VMRegImpl::Bad());\n-  reg_def VSR30_K(SOC, SOC, Op_RegF, 30, VMRegImpl::Bad());\n-\n-  reg_def VSR31  (SOC, SOC, Op_RegF, 31, VMRegImpl::Bad());\n-  reg_def VSR31_H(SOC, SOC, Op_RegF, 31, VMRegImpl::Bad());\n-  reg_def VSR31_J(SOC, SOC, Op_RegF, 31, VMRegImpl::Bad());\n-  reg_def VSR31_K(SOC, SOC, Op_RegF, 31, VMRegImpl::Bad());\n-\n-  \/\/ 2nd 32 VSRs are aliases for the VRs which are only defined here.\n-  reg_def VSR32  (SOC, SOC, Op_RegF, 32, VSR32->as_VMReg()         );\n-  reg_def VSR32_H(SOC, SOC, Op_RegF, 32, VSR32->as_VMReg()->next() );\n-  reg_def VSR32_J(SOC, SOC, Op_RegF, 32, VSR32->as_VMReg()->next(2));\n-  reg_def VSR32_K(SOC, SOC, Op_RegF, 32, VSR32->as_VMReg()->next(3));\n-\n-  reg_def VSR33  (SOC, SOC, Op_RegF, 33, VSR33->as_VMReg()         );\n-  reg_def VSR33_H(SOC, SOC, Op_RegF, 33, VSR33->as_VMReg()->next() );\n-  reg_def VSR33_J(SOC, SOC, Op_RegF, 33, VSR33->as_VMReg()->next(2));\n-  reg_def VSR33_K(SOC, SOC, Op_RegF, 33, VSR33->as_VMReg()->next(3));\n-\n-  reg_def VSR34  (SOC, SOC, Op_RegF, 34, VSR34->as_VMReg()         );\n-  reg_def VSR34_H(SOC, SOC, Op_RegF, 34, VSR34->as_VMReg()->next() );\n-  reg_def VSR34_J(SOC, SOC, Op_RegF, 34, VSR34->as_VMReg()->next(2));\n-  reg_def VSR34_K(SOC, SOC, Op_RegF, 34, VSR34->as_VMReg()->next(3));\n-\n-  reg_def VSR35  (SOC, SOC, Op_RegF, 35, VSR35->as_VMReg()         );\n-  reg_def VSR35_H(SOC, SOC, Op_RegF, 35, VSR35->as_VMReg()->next() );\n-  reg_def VSR35_J(SOC, SOC, Op_RegF, 35, VSR35->as_VMReg()->next(2));\n-  reg_def VSR35_K(SOC, SOC, Op_RegF, 35, VSR35->as_VMReg()->next(3));\n-\n-  reg_def VSR36  (SOC, SOC, Op_RegF, 36, VSR36->as_VMReg()         );\n-  reg_def VSR36_H(SOC, SOC, Op_RegF, 36, VSR36->as_VMReg()->next() );\n-  reg_def VSR36_J(SOC, SOC, Op_RegF, 36, VSR36->as_VMReg()->next(2));\n-  reg_def VSR36_K(SOC, SOC, Op_RegF, 36, VSR36->as_VMReg()->next(3));\n-\n-  reg_def VSR37  (SOC, SOC, Op_RegF, 37, VSR37->as_VMReg()         );\n-  reg_def VSR37_H(SOC, SOC, Op_RegF, 37, VSR37->as_VMReg()->next() );\n-  reg_def VSR37_J(SOC, SOC, Op_RegF, 37, VSR37->as_VMReg()->next(2));\n-  reg_def VSR37_K(SOC, SOC, Op_RegF, 37, VSR37->as_VMReg()->next(3));\n-\n-  reg_def VSR38  (SOC, SOC, Op_RegF, 38, VSR38->as_VMReg()         );\n-  reg_def VSR38_H(SOC, SOC, Op_RegF, 38, VSR38->as_VMReg()->next() );\n-  reg_def VSR38_J(SOC, SOC, Op_RegF, 38, VSR38->as_VMReg()->next(2));\n-  reg_def VSR38_K(SOC, SOC, Op_RegF, 38, VSR38->as_VMReg()->next(3));\n-\n-  reg_def VSR39  (SOC, SOC, Op_RegF, 39, VSR39->as_VMReg()         );\n-  reg_def VSR39_H(SOC, SOC, Op_RegF, 39, VSR39->as_VMReg()->next() );\n-  reg_def VSR39_J(SOC, SOC, Op_RegF, 39, VSR39->as_VMReg()->next(2));\n-  reg_def VSR39_K(SOC, SOC, Op_RegF, 39, VSR39->as_VMReg()->next(3));\n-\n-  reg_def VSR40  (SOC, SOC, Op_RegF, 40, VSR40->as_VMReg()         );\n-  reg_def VSR40_H(SOC, SOC, Op_RegF, 40, VSR40->as_VMReg()->next() );\n-  reg_def VSR40_J(SOC, SOC, Op_RegF, 40, VSR40->as_VMReg()->next(2));\n-  reg_def VSR40_K(SOC, SOC, Op_RegF, 40, VSR40->as_VMReg()->next(3));\n-\n-  reg_def VSR41  (SOC, SOC, Op_RegF, 41, VSR41->as_VMReg()         );\n-  reg_def VSR41_H(SOC, SOC, Op_RegF, 41, VSR41->as_VMReg()->next() );\n-  reg_def VSR41_J(SOC, SOC, Op_RegF, 41, VSR41->as_VMReg()->next(2));\n-  reg_def VSR41_K(SOC, SOC, Op_RegF, 41, VSR41->as_VMReg()->next(3));\n-\n-  reg_def VSR42  (SOC, SOC, Op_RegF, 42, VSR42->as_VMReg()         );\n-  reg_def VSR42_H(SOC, SOC, Op_RegF, 42, VSR42->as_VMReg()->next() );\n-  reg_def VSR42_J(SOC, SOC, Op_RegF, 42, VSR42->as_VMReg()->next(2));\n-  reg_def VSR42_K(SOC, SOC, Op_RegF, 42, VSR42->as_VMReg()->next(3));\n-\n-  reg_def VSR43  (SOC, SOC, Op_RegF, 43, VSR43->as_VMReg()         );\n-  reg_def VSR43_H(SOC, SOC, Op_RegF, 43, VSR43->as_VMReg()->next() );\n-  reg_def VSR43_J(SOC, SOC, Op_RegF, 43, VSR43->as_VMReg()->next(2));\n-  reg_def VSR43_K(SOC, SOC, Op_RegF, 43, VSR43->as_VMReg()->next(3));\n-\n-  reg_def VSR44  (SOC, SOC, Op_RegF, 44, VSR44->as_VMReg()         );\n-  reg_def VSR44_H(SOC, SOC, Op_RegF, 44, VSR44->as_VMReg()->next() );\n-  reg_def VSR44_J(SOC, SOC, Op_RegF, 44, VSR44->as_VMReg()->next(2));\n-  reg_def VSR44_K(SOC, SOC, Op_RegF, 44, VSR44->as_VMReg()->next(3));\n-\n-  reg_def VSR45  (SOC, SOC, Op_RegF, 45, VSR45->as_VMReg()         );\n-  reg_def VSR45_H(SOC, SOC, Op_RegF, 45, VSR45->as_VMReg()->next() );\n-  reg_def VSR45_J(SOC, SOC, Op_RegF, 45, VSR45->as_VMReg()->next(2));\n-  reg_def VSR45_K(SOC, SOC, Op_RegF, 45, VSR45->as_VMReg()->next(3));\n-\n-  reg_def VSR46  (SOC, SOC, Op_RegF, 46, VSR46->as_VMReg()         );\n-  reg_def VSR46_H(SOC, SOC, Op_RegF, 46, VSR46->as_VMReg()->next() );\n-  reg_def VSR46_J(SOC, SOC, Op_RegF, 46, VSR46->as_VMReg()->next(2));\n-  reg_def VSR46_K(SOC, SOC, Op_RegF, 46, VSR46->as_VMReg()->next(3));\n-\n-  reg_def VSR47  (SOC, SOC, Op_RegF, 47, VSR47->as_VMReg()         );\n-  reg_def VSR47_H(SOC, SOC, Op_RegF, 47, VSR47->as_VMReg()->next() );\n-  reg_def VSR47_J(SOC, SOC, Op_RegF, 47, VSR47->as_VMReg()->next(2));\n-  reg_def VSR47_K(SOC, SOC, Op_RegF, 47, VSR47->as_VMReg()->next(3));\n-\n-  reg_def VSR48  (SOC, SOC, Op_RegF, 48, VSR48->as_VMReg()         );\n-  reg_def VSR48_H(SOC, SOC, Op_RegF, 48, VSR48->as_VMReg()->next() );\n-  reg_def VSR48_J(SOC, SOC, Op_RegF, 48, VSR48->as_VMReg()->next(2));\n-  reg_def VSR48_K(SOC, SOC, Op_RegF, 48, VSR48->as_VMReg()->next(3));\n-\n-  reg_def VSR49  (SOC, SOC, Op_RegF, 49, VSR49->as_VMReg()         );\n-  reg_def VSR49_H(SOC, SOC, Op_RegF, 49, VSR49->as_VMReg()->next() );\n-  reg_def VSR49_J(SOC, SOC, Op_RegF, 49, VSR49->as_VMReg()->next(2));\n-  reg_def VSR49_K(SOC, SOC, Op_RegF, 49, VSR49->as_VMReg()->next(3));\n-\n-  reg_def VSR50  (SOC, SOC, Op_RegF, 50, VSR50->as_VMReg()         );\n-  reg_def VSR50_H(SOC, SOC, Op_RegF, 50, VSR50->as_VMReg()->next() );\n-  reg_def VSR50_J(SOC, SOC, Op_RegF, 50, VSR50->as_VMReg()->next(2));\n-  reg_def VSR50_K(SOC, SOC, Op_RegF, 50, VSR50->as_VMReg()->next(3));\n-\n-  reg_def VSR51  (SOC, SOC, Op_RegF, 51, VSR51->as_VMReg()         );\n-  reg_def VSR51_H(SOC, SOC, Op_RegF, 51, VSR51->as_VMReg()->next() );\n-  reg_def VSR51_J(SOC, SOC, Op_RegF, 51, VSR51->as_VMReg()->next(2));\n-  reg_def VSR51_K(SOC, SOC, Op_RegF, 51, VSR51->as_VMReg()->next(3));\n-\n-  reg_def VSR52  (SOC, SOE, Op_RegF, 52, VSR52->as_VMReg()         );\n-  reg_def VSR52_H(SOC, SOE, Op_RegF, 52, VSR52->as_VMReg()->next() );\n-  reg_def VSR52_J(SOC, SOE, Op_RegF, 52, VSR52->as_VMReg()->next(2));\n-  reg_def VSR52_K(SOC, SOE, Op_RegF, 52, VSR52->as_VMReg()->next(3));\n-\n-  reg_def VSR53  (SOC, SOE, Op_RegF, 53, VSR53->as_VMReg()         );\n-  reg_def VSR53_H(SOC, SOE, Op_RegF, 53, VSR53->as_VMReg()->next() );\n-  reg_def VSR53_J(SOC, SOE, Op_RegF, 53, VSR53->as_VMReg()->next(2));\n-  reg_def VSR53_K(SOC, SOE, Op_RegF, 53, VSR53->as_VMReg()->next(3));\n-\n-  reg_def VSR54  (SOC, SOE, Op_RegF, 54, VSR54->as_VMReg()         );\n-  reg_def VSR54_H(SOC, SOE, Op_RegF, 54, VSR54->as_VMReg()->next() );\n-  reg_def VSR54_J(SOC, SOE, Op_RegF, 54, VSR54->as_VMReg()->next(2));\n-  reg_def VSR54_K(SOC, SOE, Op_RegF, 54, VSR54->as_VMReg()->next(3));\n-\n-  reg_def VSR55  (SOC, SOE, Op_RegF, 55, VSR55->as_VMReg()         );\n-  reg_def VSR55_H(SOC, SOE, Op_RegF, 55, VSR55->as_VMReg()->next() );\n-  reg_def VSR55_J(SOC, SOE, Op_RegF, 55, VSR55->as_VMReg()->next(2));\n-  reg_def VSR55_K(SOC, SOE, Op_RegF, 55, VSR55->as_VMReg()->next(3));\n-\n-  reg_def VSR56  (SOC, SOE, Op_RegF, 56, VSR56->as_VMReg()         );\n-  reg_def VSR56_H(SOC, SOE, Op_RegF, 56, VSR56->as_VMReg()->next() );\n-  reg_def VSR56_J(SOC, SOE, Op_RegF, 56, VSR56->as_VMReg()->next(2));\n-  reg_def VSR56_K(SOC, SOE, Op_RegF, 56, VSR56->as_VMReg()->next(3));\n-\n-  reg_def VSR57  (SOC, SOE, Op_RegF, 57, VSR57->as_VMReg()         );\n-  reg_def VSR57_H(SOC, SOE, Op_RegF, 57, VSR57->as_VMReg()->next() );\n-  reg_def VSR57_J(SOC, SOE, Op_RegF, 57, VSR57->as_VMReg()->next(2));\n-  reg_def VSR57_K(SOC, SOE, Op_RegF, 57, VSR57->as_VMReg()->next(3));\n-\n-  reg_def VSR58  (SOC, SOE, Op_RegF, 58, VSR58->as_VMReg()         );\n-  reg_def VSR58_H(SOC, SOE, Op_RegF, 58, VSR58->as_VMReg()->next() );\n-  reg_def VSR58_J(SOC, SOE, Op_RegF, 58, VSR58->as_VMReg()->next(2));\n-  reg_def VSR58_K(SOC, SOE, Op_RegF, 58, VSR58->as_VMReg()->next(3));\n-\n-  reg_def VSR59  (SOC, SOE, Op_RegF, 59, VSR59->as_VMReg()         );\n-  reg_def VSR59_H(SOC, SOE, Op_RegF, 59, VSR59->as_VMReg()->next() );\n-  reg_def VSR59_J(SOC, SOE, Op_RegF, 59, VSR59->as_VMReg()->next(2));\n-  reg_def VSR59_K(SOC, SOE, Op_RegF, 59, VSR59->as_VMReg()->next(3));\n-\n-  reg_def VSR60  (SOC, SOE, Op_RegF, 60, VSR60->as_VMReg()         );\n-  reg_def VSR60_H(SOC, SOE, Op_RegF, 60, VSR60->as_VMReg()->next() );\n-  reg_def VSR60_J(SOC, SOE, Op_RegF, 60, VSR60->as_VMReg()->next(2));\n-  reg_def VSR60_K(SOC, SOE, Op_RegF, 60, VSR60->as_VMReg()->next(3));\n-\n-  reg_def VSR61  (SOC, SOE, Op_RegF, 61, VSR61->as_VMReg()         );\n-  reg_def VSR61_H(SOC, SOE, Op_RegF, 61, VSR61->as_VMReg()->next() );\n-  reg_def VSR61_J(SOC, SOE, Op_RegF, 61, VSR61->as_VMReg()->next(2));\n-  reg_def VSR61_K(SOC, SOE, Op_RegF, 61, VSR61->as_VMReg()->next(3));\n-\n-  reg_def VSR62  (SOC, SOE, Op_RegF, 62, VSR62->as_VMReg()         );\n-  reg_def VSR62_H(SOC, SOE, Op_RegF, 62, VSR62->as_VMReg()->next() );\n-  reg_def VSR62_J(SOC, SOE, Op_RegF, 62, VSR62->as_VMReg()->next(2));\n-  reg_def VSR62_K(SOC, SOE, Op_RegF, 62, VSR62->as_VMReg()->next(3));\n-\n-  reg_def VSR63  (SOC, SOE, Op_RegF, 63, VSR63->as_VMReg()         );\n-  reg_def VSR63_H(SOC, SOE, Op_RegF, 63, VSR63->as_VMReg()->next() );\n-  reg_def VSR63_J(SOC, SOE, Op_RegF, 63, VSR63->as_VMReg()->next(2));\n-  reg_def VSR63_K(SOC, SOE, Op_RegF, 63, VSR63->as_VMReg()->next(3));\n+\n+  reg_def VR0  (SOC, SOC, Op_RegF, 0, VR0->as_VMReg()         );\n+  reg_def VR0_H(SOC, SOC, Op_RegF, 0, VR0->as_VMReg()->next() );\n+  reg_def VR0_J(SOC, SOC, Op_RegF, 0, VR0->as_VMReg()->next(2));\n+  reg_def VR0_K(SOC, SOC, Op_RegF, 0, VR0->as_VMReg()->next(3));\n+\n+  reg_def VR1  (SOC, SOC, Op_RegF, 1, VR1->as_VMReg()         );\n+  reg_def VR1_H(SOC, SOC, Op_RegF, 1, VR1->as_VMReg()->next() );\n+  reg_def VR1_J(SOC, SOC, Op_RegF, 1, VR1->as_VMReg()->next(2));\n+  reg_def VR1_K(SOC, SOC, Op_RegF, 1, VR1->as_VMReg()->next(3));\n+\n+  reg_def VR2  (SOC, SOC, Op_RegF, 2, VR2->as_VMReg()         );\n+  reg_def VR2_H(SOC, SOC, Op_RegF, 2, VR2->as_VMReg()->next() );\n+  reg_def VR2_J(SOC, SOC, Op_RegF, 2, VR2->as_VMReg()->next(2));\n+  reg_def VR2_K(SOC, SOC, Op_RegF, 2, VR2->as_VMReg()->next(3));\n+\n+  reg_def VR3  (SOC, SOC, Op_RegF, 3, VR3->as_VMReg()         );\n+  reg_def VR3_H(SOC, SOC, Op_RegF, 3, VR3->as_VMReg()->next() );\n+  reg_def VR3_J(SOC, SOC, Op_RegF, 3, VR3->as_VMReg()->next(2));\n+  reg_def VR3_K(SOC, SOC, Op_RegF, 3, VR3->as_VMReg()->next(3));\n+\n+  reg_def VR4  (SOC, SOC, Op_RegF, 4, VR4->as_VMReg()         );\n+  reg_def VR4_H(SOC, SOC, Op_RegF, 4, VR4->as_VMReg()->next() );\n+  reg_def VR4_J(SOC, SOC, Op_RegF, 4, VR4->as_VMReg()->next(2));\n+  reg_def VR4_K(SOC, SOC, Op_RegF, 4, VR4->as_VMReg()->next(3));\n+\n+  reg_def VR5  (SOC, SOC, Op_RegF, 5, VR5->as_VMReg()         );\n+  reg_def VR5_H(SOC, SOC, Op_RegF, 5, VR5->as_VMReg()->next() );\n+  reg_def VR5_J(SOC, SOC, Op_RegF, 5, VR5->as_VMReg()->next(2));\n+  reg_def VR5_K(SOC, SOC, Op_RegF, 5, VR5->as_VMReg()->next(3));\n+\n+  reg_def VR6  (SOC, SOC, Op_RegF, 6, VR6->as_VMReg()         );\n+  reg_def VR6_H(SOC, SOC, Op_RegF, 6, VR6->as_VMReg()->next() );\n+  reg_def VR6_J(SOC, SOC, Op_RegF, 6, VR6->as_VMReg()->next(2));\n+  reg_def VR6_K(SOC, SOC, Op_RegF, 6, VR6->as_VMReg()->next(3));\n+\n+  reg_def VR7  (SOC, SOC, Op_RegF, 7, VR7->as_VMReg()         );\n+  reg_def VR7_H(SOC, SOC, Op_RegF, 7, VR7->as_VMReg()->next() );\n+  reg_def VR7_J(SOC, SOC, Op_RegF, 7, VR7->as_VMReg()->next(2));\n+  reg_def VR7_K(SOC, SOC, Op_RegF, 7, VR7->as_VMReg()->next(3));\n+\n+  reg_def VR8  (SOC, SOC, Op_RegF, 8, VR8->as_VMReg()         );\n+  reg_def VR8_H(SOC, SOC, Op_RegF, 8, VR8->as_VMReg()->next() );\n+  reg_def VR8_J(SOC, SOC, Op_RegF, 8, VR8->as_VMReg()->next(2));\n+  reg_def VR8_K(SOC, SOC, Op_RegF, 8, VR8->as_VMReg()->next(3));\n+\n+  reg_def VR9  (SOC, SOC, Op_RegF, 9, VR9->as_VMReg()         );\n+  reg_def VR9_H(SOC, SOC, Op_RegF, 9, VR9->as_VMReg()->next() );\n+  reg_def VR9_J(SOC, SOC, Op_RegF, 9, VR9->as_VMReg()->next(2));\n+  reg_def VR9_K(SOC, SOC, Op_RegF, 9, VR9->as_VMReg()->next(3));\n+\n+  reg_def VR10  (SOC, SOC, Op_RegF, 10, VR10->as_VMReg()         );\n+  reg_def VR10_H(SOC, SOC, Op_RegF, 10, VR10->as_VMReg()->next() );\n+  reg_def VR10_J(SOC, SOC, Op_RegF, 10, VR10->as_VMReg()->next(2));\n+  reg_def VR10_K(SOC, SOC, Op_RegF, 10, VR10->as_VMReg()->next(3));\n+\n+  reg_def VR11  (SOC, SOC, Op_RegF, 11, VR11->as_VMReg()         );\n+  reg_def VR11_H(SOC, SOC, Op_RegF, 11, VR11->as_VMReg()->next() );\n+  reg_def VR11_J(SOC, SOC, Op_RegF, 11, VR11->as_VMReg()->next(2));\n+  reg_def VR11_K(SOC, SOC, Op_RegF, 11, VR11->as_VMReg()->next(3));\n+\n+  reg_def VR12  (SOC, SOC, Op_RegF, 12, VR12->as_VMReg()         );\n+  reg_def VR12_H(SOC, SOC, Op_RegF, 12, VR12->as_VMReg()->next() );\n+  reg_def VR12_J(SOC, SOC, Op_RegF, 12, VR12->as_VMReg()->next(2));\n+  reg_def VR12_K(SOC, SOC, Op_RegF, 12, VR12->as_VMReg()->next(3));\n+\n+  reg_def VR13  (SOC, SOC, Op_RegF, 13, VR13->as_VMReg()         );\n+  reg_def VR13_H(SOC, SOC, Op_RegF, 13, VR13->as_VMReg()->next() );\n+  reg_def VR13_J(SOC, SOC, Op_RegF, 13, VR13->as_VMReg()->next(2));\n+  reg_def VR13_K(SOC, SOC, Op_RegF, 13, VR13->as_VMReg()->next(3));\n+\n+  reg_def VR14  (SOC, SOC, Op_RegF, 14, VR14->as_VMReg()         );\n+  reg_def VR14_H(SOC, SOC, Op_RegF, 14, VR14->as_VMReg()->next() );\n+  reg_def VR14_J(SOC, SOC, Op_RegF, 14, VR14->as_VMReg()->next(2));\n+  reg_def VR14_K(SOC, SOC, Op_RegF, 14, VR14->as_VMReg()->next(3));\n+\n+  reg_def VR15  (SOC, SOC, Op_RegF, 15, VR15->as_VMReg()         );\n+  reg_def VR15_H(SOC, SOC, Op_RegF, 15, VR15->as_VMReg()->next() );\n+  reg_def VR15_J(SOC, SOC, Op_RegF, 15, VR15->as_VMReg()->next(2));\n+  reg_def VR15_K(SOC, SOC, Op_RegF, 15, VR15->as_VMReg()->next(3));\n+\n+  reg_def VR16  (SOC, SOC, Op_RegF, 16, VR16->as_VMReg()         );\n+  reg_def VR16_H(SOC, SOC, Op_RegF, 16, VR16->as_VMReg()->next() );\n+  reg_def VR16_J(SOC, SOC, Op_RegF, 16, VR16->as_VMReg()->next(2));\n+  reg_def VR16_K(SOC, SOC, Op_RegF, 16, VR16->as_VMReg()->next(3));\n+\n+  reg_def VR17  (SOC, SOC, Op_RegF, 17, VR17->as_VMReg()         );\n+  reg_def VR17_H(SOC, SOC, Op_RegF, 17, VR17->as_VMReg()->next() );\n+  reg_def VR17_J(SOC, SOC, Op_RegF, 17, VR17->as_VMReg()->next(2));\n+  reg_def VR17_K(SOC, SOC, Op_RegF, 17, VR17->as_VMReg()->next(3));\n+\n+  reg_def VR18  (SOC, SOC, Op_RegF, 18, VR18->as_VMReg()         );\n+  reg_def VR18_H(SOC, SOC, Op_RegF, 18, VR18->as_VMReg()->next() );\n+  reg_def VR18_J(SOC, SOC, Op_RegF, 18, VR18->as_VMReg()->next(2));\n+  reg_def VR18_K(SOC, SOC, Op_RegF, 18, VR18->as_VMReg()->next(3));\n+\n+  reg_def VR19  (SOC, SOC, Op_RegF, 19, VR19->as_VMReg()         );\n+  reg_def VR19_H(SOC, SOC, Op_RegF, 19, VR19->as_VMReg()->next() );\n+  reg_def VR19_J(SOC, SOC, Op_RegF, 19, VR19->as_VMReg()->next(2));\n+  reg_def VR19_K(SOC, SOC, Op_RegF, 19, VR19->as_VMReg()->next(3));\n+\n+  reg_def VR20  (SOC, SOE, Op_RegF, 20, VR20->as_VMReg()         );\n+  reg_def VR20_H(SOC, SOE, Op_RegF, 20, VR20->as_VMReg()->next() );\n+  reg_def VR20_J(SOC, SOE, Op_RegF, 20, VR20->as_VMReg()->next(2));\n+  reg_def VR20_K(SOC, SOE, Op_RegF, 20, VR20->as_VMReg()->next(3));\n+\n+  reg_def VR21  (SOC, SOE, Op_RegF, 21, VR21->as_VMReg()         );\n+  reg_def VR21_H(SOC, SOE, Op_RegF, 21, VR21->as_VMReg()->next() );\n+  reg_def VR21_J(SOC, SOE, Op_RegF, 21, VR21->as_VMReg()->next(2));\n+  reg_def VR21_K(SOC, SOE, Op_RegF, 21, VR21->as_VMReg()->next(3));\n+\n+  reg_def VR22  (SOC, SOE, Op_RegF, 22, VR22->as_VMReg()         );\n+  reg_def VR22_H(SOC, SOE, Op_RegF, 22, VR22->as_VMReg()->next() );\n+  reg_def VR22_J(SOC, SOE, Op_RegF, 22, VR22->as_VMReg()->next(2));\n+  reg_def VR22_K(SOC, SOE, Op_RegF, 22, VR22->as_VMReg()->next(3));\n+\n+  reg_def VR23  (SOC, SOE, Op_RegF, 23, VR23->as_VMReg()         );\n+  reg_def VR23_H(SOC, SOE, Op_RegF, 23, VR23->as_VMReg()->next() );\n+  reg_def VR23_J(SOC, SOE, Op_RegF, 23, VR23->as_VMReg()->next(2));\n+  reg_def VR23_K(SOC, SOE, Op_RegF, 23, VR23->as_VMReg()->next(3));\n+\n+  reg_def VR24  (SOC, SOE, Op_RegF, 24, VR24->as_VMReg()         );\n+  reg_def VR24_H(SOC, SOE, Op_RegF, 24, VR24->as_VMReg()->next() );\n+  reg_def VR24_J(SOC, SOE, Op_RegF, 24, VR24->as_VMReg()->next(2));\n+  reg_def VR24_K(SOC, SOE, Op_RegF, 24, VR24->as_VMReg()->next(3));\n+\n+  reg_def VR25  (SOC, SOE, Op_RegF, 25, VR25->as_VMReg()         );\n+  reg_def VR25_H(SOC, SOE, Op_RegF, 25, VR25->as_VMReg()->next() );\n+  reg_def VR25_J(SOC, SOE, Op_RegF, 25, VR25->as_VMReg()->next(2));\n+  reg_def VR25_K(SOC, SOE, Op_RegF, 25, VR25->as_VMReg()->next(3));\n+\n+  reg_def VR26  (SOC, SOE, Op_RegF, 26, VR26->as_VMReg()         );\n+  reg_def VR26_H(SOC, SOE, Op_RegF, 26, VR26->as_VMReg()->next() );\n+  reg_def VR26_J(SOC, SOE, Op_RegF, 26, VR26->as_VMReg()->next(2));\n+  reg_def VR26_K(SOC, SOE, Op_RegF, 26, VR26->as_VMReg()->next(3));\n+\n+  reg_def VR27  (SOC, SOE, Op_RegF, 27, VR27->as_VMReg()         );\n+  reg_def VR27_H(SOC, SOE, Op_RegF, 27, VR27->as_VMReg()->next() );\n+  reg_def VR27_J(SOC, SOE, Op_RegF, 27, VR27->as_VMReg()->next(2));\n+  reg_def VR27_K(SOC, SOE, Op_RegF, 27, VR27->as_VMReg()->next(3));\n+\n+  reg_def VR28  (SOC, SOE, Op_RegF, 28, VR28->as_VMReg()         );\n+  reg_def VR28_H(SOC, SOE, Op_RegF, 28, VR28->as_VMReg()->next() );\n+  reg_def VR28_J(SOC, SOE, Op_RegF, 28, VR28->as_VMReg()->next(2));\n+  reg_def VR28_K(SOC, SOE, Op_RegF, 28, VR28->as_VMReg()->next(3));\n+\n+  reg_def VR29  (SOC, SOE, Op_RegF, 29, VR29->as_VMReg()         );\n+  reg_def VR29_H(SOC, SOE, Op_RegF, 29, VR29->as_VMReg()->next() );\n+  reg_def VR29_J(SOC, SOE, Op_RegF, 29, VR29->as_VMReg()->next(2));\n+  reg_def VR29_K(SOC, SOE, Op_RegF, 29, VR29->as_VMReg()->next(3));\n+\n+  reg_def VR30  (SOC, SOE, Op_RegF, 30, VR30->as_VMReg()         );\n+  reg_def VR30_H(SOC, SOE, Op_RegF, 30, VR30->as_VMReg()->next() );\n+  reg_def VR30_J(SOC, SOE, Op_RegF, 30, VR30->as_VMReg()->next(2));\n+  reg_def VR30_K(SOC, SOE, Op_RegF, 30, VR30->as_VMReg()->next(3));\n+\n+  reg_def VR31  (SOC, SOE, Op_RegF, 31, VR31->as_VMReg()         );\n+  reg_def VR31_H(SOC, SOE, Op_RegF, 31, VR31->as_VMReg()->next() );\n+  reg_def VR31_J(SOC, SOE, Op_RegF, 31, VR31->as_VMReg()->next(2));\n+  reg_def VR31_K(SOC, SOE, Op_RegF, 31, VR31->as_VMReg()->next(3));\n@@ -699,64 +538,32 @@\n-  VSR0 , VSR0_H , VSR0_J , VSR0_K ,\n-  VSR1 , VSR1_H , VSR1_J , VSR1_K ,\n-  VSR2 , VSR2_H , VSR2_J , VSR2_K ,\n-  VSR3 , VSR3_H , VSR3_J , VSR3_K ,\n-  VSR4 , VSR4_H , VSR4_J , VSR4_K ,\n-  VSR5 , VSR5_H , VSR5_J , VSR5_K ,\n-  VSR6 , VSR6_H , VSR6_J , VSR6_K ,\n-  VSR7 , VSR7_H , VSR7_J , VSR7_K ,\n-  VSR8 , VSR8_H , VSR8_J , VSR8_K ,\n-  VSR9 , VSR9_H , VSR9_J , VSR9_K ,\n-  VSR10, VSR10_H, VSR10_J, VSR10_K,\n-  VSR11, VSR11_H, VSR11_J, VSR11_K,\n-  VSR12, VSR12_H, VSR12_J, VSR12_K,\n-  VSR13, VSR13_H, VSR13_J, VSR13_K,\n-  VSR14, VSR14_H, VSR14_J, VSR14_K,\n-  VSR15, VSR15_H, VSR15_J, VSR15_K,\n-  VSR16, VSR16_H, VSR16_J, VSR16_K,\n-  VSR17, VSR17_H, VSR17_J, VSR17_K,\n-  VSR18, VSR18_H, VSR18_J, VSR18_K,\n-  VSR19, VSR19_H, VSR19_J, VSR19_K,\n-  VSR20, VSR20_H, VSR20_J, VSR20_K,\n-  VSR21, VSR21_H, VSR21_J, VSR21_K,\n-  VSR22, VSR22_H, VSR22_J, VSR22_K,\n-  VSR23, VSR23_H, VSR23_J, VSR23_K,\n-  VSR24, VSR24_H, VSR24_J, VSR24_K,\n-  VSR25, VSR25_H, VSR25_J, VSR25_K,\n-  VSR26, VSR26_H, VSR26_J, VSR26_K,\n-  VSR27, VSR27_H, VSR27_J, VSR27_K,\n-  VSR28, VSR28_H, VSR28_J, VSR28_K,\n-  VSR29, VSR29_H, VSR29_J, VSR29_K,\n-  VSR30, VSR30_H, VSR30_J, VSR30_K,\n-  VSR31, VSR31_H, VSR31_J, VSR31_K,\n-  VSR32, VSR32_H, VSR32_J, VSR32_K,\n-  VSR33, VSR33_H, VSR33_J, VSR33_K,\n-  VSR34, VSR34_H, VSR34_J, VSR34_K,\n-  VSR35, VSR35_H, VSR35_J, VSR35_K,\n-  VSR36, VSR36_H, VSR36_J, VSR36_K,\n-  VSR37, VSR37_H, VSR37_J, VSR37_K,\n-  VSR38, VSR38_H, VSR38_J, VSR38_K,\n-  VSR39, VSR39_H, VSR39_J, VSR39_K,\n-  VSR40, VSR40_H, VSR40_J, VSR40_K,\n-  VSR41, VSR41_H, VSR41_J, VSR41_K,\n-  VSR42, VSR42_H, VSR42_J, VSR42_K,\n-  VSR43, VSR43_H, VSR43_J, VSR43_K,\n-  VSR44, VSR44_H, VSR44_J, VSR44_K,\n-  VSR45, VSR45_H, VSR45_J, VSR45_K,\n-  VSR46, VSR46_H, VSR46_J, VSR46_K,\n-  VSR47, VSR47_H, VSR47_J, VSR47_K,\n-  VSR48, VSR48_H, VSR48_J, VSR48_K,\n-  VSR49, VSR49_H, VSR49_J, VSR49_K,\n-  VSR50, VSR50_H, VSR50_J, VSR50_K,\n-  VSR51, VSR51_H, VSR51_J, VSR51_K,\n-  VSR52, VSR52_H, VSR52_J, VSR52_K,\n-  VSR53, VSR53_H, VSR53_J, VSR53_K,\n-  VSR54, VSR54_H, VSR54_J, VSR54_K,\n-  VSR55, VSR55_H, VSR55_J, VSR55_K,\n-  VSR56, VSR56_H, VSR56_J, VSR56_K,\n-  VSR57, VSR57_H, VSR57_J, VSR57_K,\n-  VSR58, VSR58_H, VSR58_J, VSR58_K,\n-  VSR59, VSR59_H, VSR59_J, VSR59_K,\n-  VSR60, VSR60_H, VSR60_J, VSR60_K,\n-  VSR61, VSR61_H, VSR61_J, VSR61_K,\n-  VSR62, VSR62_H, VSR62_J, VSR62_K,\n-  VSR63, VSR63_H, VSR63_J, VSR63_K\n+  VR0 , VR0_H , VR0_J , VR0_K ,\n+  VR1 , VR1_H , VR1_J , VR1_K ,\n+  VR2 , VR2_H , VR2_J , VR2_K ,\n+  VR3 , VR3_H , VR3_J , VR3_K ,\n+  VR4 , VR4_H , VR4_J , VR4_K ,\n+  VR5 , VR5_H , VR5_J , VR5_K ,\n+  VR6 , VR6_H , VR6_J , VR6_K ,\n+  VR7 , VR7_H , VR7_J , VR7_K ,\n+  VR8 , VR8_H , VR8_J , VR8_K ,\n+  VR9 , VR9_H , VR9_J , VR9_K ,\n+  VR10, VR10_H, VR10_J, VR10_K,\n+  VR11, VR11_H, VR11_J, VR11_K,\n+  VR12, VR12_H, VR12_J, VR12_K,\n+  VR13, VR13_H, VR13_J, VR13_K,\n+  VR14, VR14_H, VR14_J, VR14_K,\n+  VR15, VR15_H, VR15_J, VR15_K,\n+  VR16, VR16_H, VR16_J, VR16_K,\n+  VR17, VR17_H, VR17_J, VR17_K,\n+  VR18, VR18_H, VR18_J, VR18_K,\n+  VR19, VR19_H, VR19_J, VR19_K,\n+  VR20, VR20_H, VR20_J, VR20_K,\n+  VR21, VR21_H, VR21_J, VR21_K,\n+  VR22, VR22_H, VR22_J, VR22_K,\n+  VR23, VR23_H, VR23_J, VR23_K,\n+  VR24, VR24_H, VR24_J, VR24_K,\n+  VR25, VR25_H, VR25_J, VR25_K,\n+  VR26, VR26_H, VR26_J, VR26_K,\n+  VR27, VR27_H, VR27_J, VR27_K,\n+  VR28, VR28_H, VR28_J, VR28_K,\n+  VR29, VR29_H, VR29_J, VR29_K,\n+  VR30, VR30_H, VR30_J, VR30_K,\n+  VR31, VR31_H, VR31_J, VR31_K\n@@ -1166,33 +973,33 @@\n-reg_class vs_reg(\n-  VSR32, VSR32_H, VSR32_J, VSR32_K,\n-  VSR33, VSR33_H, VSR33_J, VSR33_K,\n-  VSR34, VSR34_H, VSR34_J, VSR34_K,\n-  VSR35, VSR35_H, VSR35_J, VSR35_K,\n-  VSR36, VSR36_H, VSR36_J, VSR36_K,\n-  VSR37, VSR37_H, VSR37_J, VSR37_K,\n-  VSR38, VSR38_H, VSR38_J, VSR38_K,\n-  VSR39, VSR39_H, VSR39_J, VSR39_K,\n-  VSR40, VSR40_H, VSR40_J, VSR40_K,\n-  VSR41, VSR41_H, VSR41_J, VSR41_K,\n-  VSR42, VSR42_H, VSR42_J, VSR42_K,\n-  VSR43, VSR43_H, VSR43_J, VSR43_K,\n-  VSR44, VSR44_H, VSR44_J, VSR44_K,\n-  VSR45, VSR45_H, VSR45_J, VSR45_K,\n-  VSR46, VSR46_H, VSR46_J, VSR46_K,\n-  VSR47, VSR47_H, VSR47_J, VSR47_K,\n-  VSR48, VSR48_H, VSR48_J, VSR48_K,\n-  VSR49, VSR49_H, VSR49_J, VSR49_K,\n-  VSR50, VSR50_H, VSR50_J, VSR50_K,\n-  VSR51, VSR51_H, VSR51_J, VSR51_K,\n-  VSR52, VSR52_H, VSR52_J, VSR52_K, \/\/ non-volatile\n-  VSR53, VSR53_H, VSR53_J, VSR53_K, \/\/ non-volatile\n-  VSR54, VSR54_H, VSR54_J, VSR54_K, \/\/ non-volatile\n-  VSR55, VSR55_H, VSR55_J, VSR55_K, \/\/ non-volatile\n-  VSR56, VSR56_H, VSR56_J, VSR56_K, \/\/ non-volatile\n-  VSR57, VSR57_H, VSR57_J, VSR57_K, \/\/ non-volatile\n-  VSR58, VSR58_H, VSR58_J, VSR58_K, \/\/ non-volatile\n-  VSR59, VSR59_H, VSR59_J, VSR59_K, \/\/ non-volatile\n-  VSR60, VSR60_H, VSR60_J, VSR60_K, \/\/ non-volatile\n-  VSR61, VSR61_H, VSR61_J, VSR61_K, \/\/ non-volatile\n-  VSR62, VSR62_H, VSR62_J, VSR62_K, \/\/ non-volatile\n-  VSR63, VSR63_H, VSR63_J, VSR63_K  \/\/ non-volatile\n+reg_class v_reg(\n+  VR0 , VR0_H , VR0_J , VR0_K ,\n+  VR1 , VR1_H , VR1_J , VR1_K ,\n+  VR2 , VR2_H , VR2_J , VR2_K ,\n+  VR3 , VR3_H , VR3_J , VR3_K ,\n+  VR4 , VR4_H , VR4_J , VR4_K ,\n+  VR5 , VR5_H , VR5_J , VR5_K ,\n+  VR6 , VR6_H , VR6_J , VR6_K ,\n+  VR7 , VR7_H , VR7_J , VR7_K ,\n+  VR8 , VR8_H , VR8_J , VR8_K ,\n+  VR9 , VR9_H , VR9_J , VR9_K ,\n+  VR10, VR10_H, VR10_J, VR10_K,\n+  VR11, VR11_H, VR11_J, VR11_K,\n+  VR12, VR12_H, VR12_J, VR12_K,\n+  VR13, VR13_H, VR13_J, VR13_K,\n+  VR14, VR14_H, VR14_J, VR14_K,\n+  VR15, VR15_H, VR15_J, VR15_K,\n+  VR16, VR16_H, VR16_J, VR16_K,\n+  VR17, VR17_H, VR17_J, VR17_K,\n+  VR18, VR18_H, VR18_J, VR18_K,\n+  VR19, VR19_H, VR19_J, VR19_K,\n+  VR20, VR20_H, VR20_J, VR20_K,\n+  VR21, VR21_H, VR21_J, VR21_K,\n+  VR22, VR22_H, VR22_J, VR22_K,\n+  VR23, VR23_H, VR23_J, VR23_K,\n+  VR24, VR24_H, VR24_J, VR24_K,\n+  VR25, VR25_H, VR25_J, VR25_K,\n+  VR26, VR26_H, VR26_J, VR26_K,\n+  VR27, VR27_H, VR27_J, VR27_K,\n+  VR28, VR28_H, VR28_J, VR28_K,\n+  VR29, VR29_H, VR29_J, VR29_K,\n+  VR30, VR30_H, VR30_J, VR30_K,\n+  VR31, VR31_H, VR31_J, VR31_K\n@@ -1689,6 +1496,1 @@\n-  if (method_is_frameless) {\n-    \/\/ Add nop at beginning of all frameless methods to prevent any\n-    \/\/ oop instructions from getting overwritten by make_not_entrant\n-    \/\/ (patching attempt would fail).\n-    __ nop();\n-  } else {\n+  if (!method_is_frameless) {\n@@ -1911,1 +1713,1 @@\n-\/\/ Figure out which register class each belongs in: rc_int, rc_float, rc_vs or\n+\/\/ Figure out which register class each belongs in: rc_int, rc_float, rc_vec or\n@@ -1913,1 +1715,1 @@\n-enum RC { rc_bad, rc_int, rc_float, rc_vs, rc_stack };\n+enum RC { rc_bad, rc_int, rc_float, rc_vec, rc_stack };\n@@ -1927,1 +1729,1 @@\n-  STATIC_ASSERT((int)ConcreteRegisterImpl::max_fpr == (int)MachRegisterNumbers::VSR0_num);\n+  STATIC_ASSERT((int)ConcreteRegisterImpl::max_fpr == (int)MachRegisterNumbers::VR0_num);\n@@ -1931,2 +1733,2 @@\n-  STATIC_ASSERT((int)ConcreteRegisterImpl::max_vsr == (int)MachRegisterNumbers::CR0_num);\n-  if (reg < ConcreteRegisterImpl::max_vsr) return rc_vs;\n+  STATIC_ASSERT((int)ConcreteRegisterImpl::max_vr == (int)MachRegisterNumbers::CR0_num);\n+  if (reg < ConcreteRegisterImpl::max_vr) return rc_vec;\n@@ -2008,3 +1810,3 @@\n-    \/\/ VectorSRegister->Memory Spill.\n-    else if (src_lo_rc == rc_vs && dst_lo_rc == rc_stack) {\n-      VectorSRegister Rsrc = as_VectorSRegister(Matcher::_regEncode[src_lo]);\n+    \/\/ VectorRegister->Memory Spill.\n+    else if (src_lo_rc == rc_vec && dst_lo_rc == rc_stack) {\n+      VectorSRegister Rsrc = as_VectorRegister(Matcher::_regEncode[src_lo]).to_vsr();\n@@ -2035,3 +1837,3 @@\n-    \/\/ Memory->VectorSRegister Spill.\n-    else if (src_lo_rc == rc_stack && dst_lo_rc == rc_vs) {\n-      VectorSRegister Rdst = as_VectorSRegister(Matcher::_regEncode[dst_lo]);\n+    \/\/ Memory->VectorRegister Spill.\n+    else if (src_lo_rc == rc_stack && dst_lo_rc == rc_vec) {\n+      VectorSRegister Rdst = as_VectorRegister(Matcher::_regEncode[dst_lo]).to_vsr();\n@@ -2060,4 +1862,4 @@\n-    \/\/ VectorSRegister->VectorSRegister.\n-    else if (src_lo_rc == rc_vs && dst_lo_rc == rc_vs) {\n-      VectorSRegister Rsrc = as_VectorSRegister(Matcher::_regEncode[src_lo]);\n-      VectorSRegister Rdst = as_VectorSRegister(Matcher::_regEncode[dst_lo]);\n+    \/\/ VectorRegister->VectorRegister.\n+    else if (src_lo_rc == rc_vec && dst_lo_rc == rc_vec) {\n+      VectorSRegister Rsrc = as_VectorRegister(Matcher::_regEncode[src_lo]).to_vsr();\n+      VectorSRegister Rdst = as_VectorRegister(Matcher::_regEncode[dst_lo]).to_vsr();\n@@ -2070,1 +1872,1 @@\n-      ShouldNotReachHere(); \/\/ No VSR spill.\n+      ShouldNotReachHere(); \/\/ No VR spill.\n@@ -2365,4 +2167,0 @@\n-    case Op_SqrtD:\n-      return VM_Version::has_fsqrt();\n-    case Op_RoundDoubleMode:\n-      return VM_Version::has_vsx();\n@@ -2377,1 +2175,1 @@\n-      return (UsePopCountInstruction && VM_Version::has_popcntw());\n+      return UsePopCountInstruction;\n@@ -2381,1 +2179,0 @@\n-\n@@ -2399,0 +2196,1 @@\n+    case Op_NegVI:\n@@ -2407,0 +2205,14 @@\n+    case Op_MinV:\n+    case Op_MaxV:\n+    case Op_UMinV:\n+    case Op_UMaxV:\n+    case Op_AndV:\n+    case Op_OrV:\n+    case Op_XorV:\n+    case Op_AddReductionVI:\n+    case Op_MulReductionVI:\n+    case Op_AndReductionV:\n+    case Op_OrReductionV:\n+    case Op_XorReductionV:\n+    case Op_MinReductionV:\n+    case Op_MaxReductionV:\n@@ -2448,0 +2260,20 @@\n+  \/\/ Special cases\n+  switch (opcode) {\n+    \/\/ Reductions only support INT at the moment.\n+    case Op_AddReductionVI:\n+    case Op_MulReductionVI:\n+    case Op_AndReductionV:\n+    case Op_OrReductionV:\n+    case Op_XorReductionV:\n+    case Op_MinReductionV:\n+    case Op_MaxReductionV:\n+      return bt == T_INT;\n+    \/\/ MaxV, MinV need types == INT || LONG.\n+    case Op_MaxV:\n+    case Op_MinV:\n+    case Op_UMinV:\n+    case Op_UMaxV:\n+      return bt == T_INT || bt == T_LONG;\n+    case Op_NegVI:\n+      return PowerArchitecturePPC64 >= 9 && bt == T_INT;\n+  }\n@@ -3188,0 +3020,10 @@\n+    \/\/ use isel instruction with Power 7\n+    cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();\n+    encodeP_subNode    *n_sub_base = new encodeP_subNode();\n+    encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();\n+    cond_set_0_oopNode *n_cond_set = new cond_set_0_oopNode();\n+\n+    n_compare->add_req(n_region, n_src);\n+    n_compare->_opnds[0] = op_crx;\n+    n_compare->_opnds[1] = op_src;\n+    n_compare->_opnds[2] = new immL16Oper(0);\n@@ -3189,37 +3031,4 @@\n-    if (VM_Version::has_isel()) {\n-      \/\/ use isel instruction with Power 7\n-      cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();\n-      encodeP_subNode    *n_sub_base = new encodeP_subNode();\n-      encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();\n-      cond_set_0_oopNode *n_cond_set = new cond_set_0_oopNode();\n-\n-      n_compare->add_req(n_region, n_src);\n-      n_compare->_opnds[0] = op_crx;\n-      n_compare->_opnds[1] = op_src;\n-      n_compare->_opnds[2] = new immL16Oper(0);\n-\n-      n_sub_base->add_req(n_region, n_src);\n-      n_sub_base->_opnds[0] = op_dst;\n-      n_sub_base->_opnds[1] = op_src;\n-      n_sub_base->_bottom_type = _bottom_type;\n-\n-      n_shift->add_req(n_region, n_sub_base);\n-      n_shift->_opnds[0] = op_dst;\n-      n_shift->_opnds[1] = op_dst;\n-      n_shift->_bottom_type = _bottom_type;\n-\n-      n_cond_set->add_req(n_region, n_compare, n_shift);\n-      n_cond_set->_opnds[0] = op_dst;\n-      n_cond_set->_opnds[1] = op_crx;\n-      n_cond_set->_opnds[2] = op_dst;\n-      n_cond_set->_bottom_type = _bottom_type;\n-\n-      ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n-      ra_->set_pair(n_sub_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_cond_set->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-\n-      nodes->push(n_compare);\n-      nodes->push(n_sub_base);\n-      nodes->push(n_shift);\n-      nodes->push(n_cond_set);\n+    n_sub_base->add_req(n_region, n_src);\n+    n_sub_base->_opnds[0] = op_dst;\n+    n_sub_base->_opnds[1] = op_src;\n+    n_sub_base->_bottom_type = _bottom_type;\n@@ -3227,40 +3036,20 @@\n-    } else {\n-      \/\/ before Power 7\n-      moveRegNode        *n_move     = new moveRegNode();\n-      cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();\n-      encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();\n-      cond_sub_baseNode  *n_sub_base = new cond_sub_baseNode();\n-\n-      n_move->add_req(n_region, n_src);\n-      n_move->_opnds[0] = op_dst;\n-      n_move->_opnds[1] = op_src;\n-      ra_->set_oop(n_move, true); \/\/ Until here, 'n_move' still produces an oop.\n-\n-      n_compare->add_req(n_region, n_src);\n-      n_compare->add_prec(n_move);\n-\n-      n_compare->_opnds[0] = op_crx;\n-      n_compare->_opnds[1] = op_src;\n-      n_compare->_opnds[2] = new immL16Oper(0);\n-\n-      n_sub_base->add_req(n_region, n_compare, n_src);\n-      n_sub_base->_opnds[0] = op_dst;\n-      n_sub_base->_opnds[1] = op_crx;\n-      n_sub_base->_opnds[2] = op_src;\n-      n_sub_base->_bottom_type = _bottom_type;\n-\n-      n_shift->add_req(n_region, n_sub_base);\n-      n_shift->_opnds[0] = op_dst;\n-      n_shift->_opnds[1] = op_dst;\n-      n_shift->_bottom_type = _bottom_type;\n-\n-      ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n-      ra_->set_pair(n_sub_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_move->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-\n-      nodes->push(n_move);\n-      nodes->push(n_compare);\n-      nodes->push(n_sub_base);\n-      nodes->push(n_shift);\n-    }\n+    n_shift->add_req(n_region, n_sub_base);\n+    n_shift->_opnds[0] = op_dst;\n+    n_shift->_opnds[1] = op_dst;\n+    n_shift->_bottom_type = _bottom_type;\n+\n+    n_cond_set->add_req(n_region, n_compare, n_shift);\n+    n_cond_set->_opnds[0] = op_dst;\n+    n_cond_set->_opnds[1] = op_crx;\n+    n_cond_set->_opnds[2] = op_dst;\n+    n_cond_set->_bottom_type = _bottom_type;\n+\n+    ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n+    ra_->set_pair(n_sub_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+    ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+    ra_->set_pair(n_cond_set->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+\n+    nodes->push(n_compare);\n+    nodes->push(n_sub_base);\n+    nodes->push(n_shift);\n+    nodes->push(n_cond_set);\n@@ -3306,15 +3095,6 @@\n-    if (VM_Version::has_isel()) {\n-      \/\/ use isel instruction with Power 7\n-\n-      decodeN_addNode *n_add_base = new decodeN_addNode();\n-      n_add_base->add_req(n_region, n_shift);\n-      n_add_base->_opnds[0] = op_dst;\n-      n_add_base->_opnds[1] = op_dst;\n-      n_add_base->_bottom_type = _bottom_type;\n-\n-      cond_set_0_ptrNode *n_cond_set = new cond_set_0_ptrNode();\n-      n_cond_set->add_req(n_region, n_compare, n_add_base);\n-      n_cond_set->_opnds[0] = op_dst;\n-      n_cond_set->_opnds[1] = op_crx;\n-      n_cond_set->_opnds[2] = op_dst;\n-      n_cond_set->_bottom_type = _bottom_type;\n+    \/\/ use isel instruction with Power 7\n+    decodeN_addNode *n_add_base = new decodeN_addNode();\n+    n_add_base->add_req(n_region, n_shift);\n+    n_add_base->_opnds[0] = op_dst;\n+    n_add_base->_opnds[1] = op_dst;\n+    n_add_base->_bottom_type = _bottom_type;\n@@ -3322,16 +3102,6 @@\n-      assert(ra_->is_oop(this) == true, \"A decodeN node must produce an oop!\");\n-      ra_->set_oop(n_cond_set, true);\n-\n-      ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n-      ra_->set_pair(n_add_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_cond_set->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-\n-      nodes->push(n_compare);\n-      nodes->push(n_shift);\n-      nodes->push(n_add_base);\n-      nodes->push(n_cond_set);\n-\n-    } else {\n-      \/\/ before Power 7\n-      cond_add_baseNode *n_add_base = new cond_add_baseNode();\n+    cond_set_0_ptrNode *n_cond_set = new cond_set_0_ptrNode();\n+    n_cond_set->add_req(n_region, n_compare, n_add_base);\n+    n_cond_set->_opnds[0] = op_dst;\n+    n_cond_set->_opnds[1] = op_crx;\n+    n_cond_set->_opnds[2] = op_dst;\n+    n_cond_set->_bottom_type = _bottom_type;\n@@ -3339,5 +3109,2 @@\n-      n_add_base->add_req(n_region, n_compare, n_shift);\n-      n_add_base->_opnds[0] = op_dst;\n-      n_add_base->_opnds[1] = op_crx;\n-      n_add_base->_opnds[2] = op_dst;\n-      n_add_base->_bottom_type = _bottom_type;\n+    assert(ra_->is_oop(this) == true, \"A decodeN node must produce an oop!\");\n+    ra_->set_oop(n_cond_set, true);\n@@ -3345,2 +3112,4 @@\n-      assert(ra_->is_oop(this) == true, \"A decodeN node must produce an oop!\");\n-      ra_->set_oop(n_add_base, true);\n+    ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+    ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n+    ra_->set_pair(n_add_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+    ra_->set_pair(n_cond_set->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n@@ -3348,3 +3117,4 @@\n-      ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n-      ra_->set_pair(n_add_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+    nodes->push(n_compare);\n+    nodes->push(n_shift);\n+    nodes->push(n_add_base);\n+    nodes->push(n_cond_set);\n@@ -3352,4 +3122,0 @@\n-      nodes->push(n_compare);\n-      nodes->push(n_shift);\n-      nodes->push(n_add_base);\n-    }\n@@ -3380,19 +3146,0 @@\n-  enc_class enc_cmove_reg(iRegIdst dst, flagsRegSrc crx, iRegIsrc src, cmpOp cmp) %{\n-    int cc        = $cmp$$cmpcode;\n-    int flags_reg = $crx$$reg;\n-    Label done;\n-    assert((Assembler::bcondCRbiIs1 & ~Assembler::bcondCRbiIs0) == 8, \"check encoding\");\n-    \/\/ Branch if not (cmp crx).\n-    __ bc(cc_to_inverse_boint(cc), cc_to_biint(cc, flags_reg), done);\n-    __ mr($dst$$Register, $src$$Register);\n-    __ bind(done);\n-  %}\n-\n-  enc_class enc_cmove_imm(iRegIdst dst, flagsRegSrc crx, immI16 src, cmpOp cmp) %{\n-    Label done;\n-    assert((Assembler::bcondCRbiIs1 & ~Assembler::bcondCRbiIs0) == 8, \"check encoding\");\n-    \/\/ Branch if not (cmp crx).\n-    __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);\n-    __ li($dst$$Register, $src$$constant);\n-    __ bind(done);\n-  %}\n@@ -4101,0 +3848,4 @@\n+\/\/ Whether this node is expanded during code emission into a sequence of\n+\/\/ instructions and the first instruction can perform an implicit null check.\n+ins_attrib ins_is_late_expanded_null_check_candidate(false);\n+\n@@ -4109,1 +3860,1 @@\n-  constraint(ALLOC_IN_RC(vs_reg));\n+  constraint(ALLOC_IN_RC(v_reg));\n@@ -5685,1 +5436,1 @@\n-    __ lxvd2x($dst$$VectorSRegister, $mem$$Register);\n+    __ lxvd2x($dst$$VectorRegister.to_vsr(), $mem$$Register);\n@@ -5698,1 +5449,1 @@\n-    __ lxv($dst$$VectorSRegister, $mem$$disp, $mem$$Register);\n+    __ lxv($dst$$VectorRegister.to_vsr(), $mem$$disp, $mem$$Register);\n@@ -6725,1 +6476,1 @@\n-    __ stxvd2x($src$$VectorSRegister, $mem$$Register);\n+    __ stxvd2x($src$$VectorRegister.to_vsr(), $mem$$Register);\n@@ -6738,1 +6489,1 @@\n-    __ stxv($src$$VectorSRegister, $mem$$disp, $mem$$Register);\n+    __ stxv($src$$VectorRegister.to_vsr(), $mem$$disp, $mem$$Register);\n@@ -6748,0 +6499,1 @@\n+  size(0);\n@@ -6756,0 +6508,1 @@\n+  size(0);\n@@ -6875,1 +6628,0 @@\n-    \/\/ This is a Power7 instruction for which no machine description exists.\n@@ -7007,1 +6759,0 @@\n-    \/\/ This is a Power7 instruction for which no machine description exists.\n@@ -7099,1 +6850,1 @@\n-            CompressedOops::base_disjoint() && VM_Version::has_isel());\n+            CompressedOops::base_disjoint());\n@@ -7479,1 +7230,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -7485,2 +7235,0 @@\n-    \/\/ This is a Power7 instruction for which no machine description\n-    \/\/ exists. Anyways, the scheduler should be off on Power7.\n@@ -7494,27 +7242,0 @@\n-instruct cmovI_reg(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, iRegIsrc src) %{\n-  match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));\n-  predicate(!VM_Version::has_isel());\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler\n-  size(8);\n-  ins_encode( enc_cmove_reg(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct cmovI_imm(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, immI16 src) %{\n-  match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler\n-  size(8);\n-  ins_encode( enc_cmove_imm(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n-\n@@ -7524,1 +7245,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -7530,2 +7250,0 @@\n-    \/\/ This is a Power7 instruction for which no machine description\n-    \/\/ exists. Anyways, the scheduler should be off on Power7.\n@@ -7539,27 +7257,0 @@\n-instruct cmovL_reg(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, iRegLsrc src) %{\n-  match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));\n-  predicate(!VM_Version::has_isel());\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n-  size(8);\n-  ins_encode( enc_cmove_reg(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct cmovL_imm(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, immL16 src) %{\n-  match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n-  size(8);\n-  ins_encode( enc_cmove_imm(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n-\n@@ -7569,1 +7260,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -7575,2 +7265,0 @@\n-    \/\/ This is a Power7 instruction for which no machine description\n-    \/\/ exists. Anyways, the scheduler should be off on Power7.\n@@ -7584,28 +7272,0 @@\n-\/\/ Conditional move for RegN. Only cmov(reg, reg).\n-instruct cmovN_reg(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, iRegNsrc src) %{\n-  match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));\n-  predicate(!VM_Version::has_isel());\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n-  size(8);\n-  ins_encode( enc_cmove_reg(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct cmovN_imm(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, immN_0 src) %{\n-  match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n-  size(8);\n-  ins_encode( enc_cmove_imm(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n-\n@@ -7615,1 +7275,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -7621,2 +7280,0 @@\n-    \/\/ This is a Power7 instruction for which no machine description\n-    \/\/ exists. Anyways, the scheduler should be off on Power7.\n@@ -7630,27 +7287,0 @@\n-instruct cmovP_reg(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, iRegP_N2P src) %{\n-  match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));\n-  predicate(!VM_Version::has_isel());\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n-  size(8);\n-  ins_encode( enc_cmove_reg(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct cmovP_imm(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, immP_0 src) %{\n-  match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n-  size(8);\n-  ins_encode( enc_cmove_imm(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n-\n@@ -7707,1 +7337,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -7712,20 +7341,1 @@\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                $res$$Register, nullptr, true);\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct compareAndSwapB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndSwapB mem_ptr (Binary src1 src2)));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n+    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7745,1 +7355,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -7750,20 +7359,1 @@\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                $res$$Register, nullptr, true);\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct compareAndSwapS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndSwapS mem_ptr (Binary src1 src2)));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n+    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7859,1 +7449,1 @@\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && VM_Version::has_lqarx());\n+  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n@@ -7864,15 +7454,1 @@\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n-                MacroAssembler::MemBarNone,\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct weakCompareAndSwapB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"weak CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n+    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7887,1 +7463,1 @@\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && VM_Version::has_lqarx());\n+  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) );\n@@ -7892,15 +7468,1 @@\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n-                support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct weakCompareAndSwapB4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"weak CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n+    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7915,1 +7477,1 @@\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && VM_Version::has_lqarx());\n+  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n@@ -7920,15 +7482,1 @@\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n-                MacroAssembler::MemBarNone,\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct weakCompareAndSwapS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"weak CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n+    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7943,1 +7491,1 @@\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && VM_Version::has_lqarx());\n+  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst));\n@@ -7948,15 +7496,1 @@\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n-                support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct weakCompareAndSwapS4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"weak CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n+    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -8094,1 +7628,1 @@\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && VM_Version::has_lqarx());\n+  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n@@ -8099,15 +7633,1 @@\n-    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                noreg, nullptr, true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct compareAndExchangeB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);\n-  format %{ \"CMPXCHGB $res, $mem_ptr, $src1, $src2; as int\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,\n+    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -8122,1 +7642,1 @@\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && VM_Version::has_lqarx());\n+  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst));\n@@ -8127,1 +7647,1 @@\n-    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -8140,19 +7660,0 @@\n-instruct compareAndExchangeB4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);\n-  format %{ \"CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as int\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                noreg, nullptr, true);\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      \/\/ isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -8162,1 +7663,1 @@\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && VM_Version::has_lqarx());\n+  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n@@ -8167,1 +7668,1 @@\n-    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -8174,1 +7675,1 @@\n-instruct compareAndExchangeS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{\n+instruct compareAndExchangeS_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{\n@@ -8176,3 +7677,3 @@\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);\n-  format %{ \"CMPXCHGH $res, $mem_ptr, $src1, $src2; as int\" %}\n+  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst));\n+  effect(TEMP_DEF res, TEMP cr0);\n+  format %{ \"CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as int\" %}\n@@ -8181,35 +7682,1 @@\n-    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                noreg, nullptr, true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct compareAndExchangeS_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, TEMP cr0);\n-  format %{ \"CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as int\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                noreg, nullptr, true);\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      \/\/ isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct compareAndExchangeS4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);\n-  format %{ \"CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as int\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,\n+    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -8370,1 +7837,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -8385,17 +7851,0 @@\n-instruct getAndAddB4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (GetAndAddB mem_ptr src));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);\n-  format %{ \"GetAndAddB $res, $mem_ptr, $src\" %}\n-  ins_encode %{\n-    __ getandaddb($res$$Register, $src$$Register, $mem_ptr$$Register,\n-                  R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n@@ -8404,1 +7853,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -8419,16 +7867,0 @@\n-instruct getAndAddS4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (GetAndAddS mem_ptr src));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);\n-  format %{ \"GetAndAddS $res, $mem_ptr, $src\" %}\n-  ins_encode %{\n-    __ getandaddh($res$$Register, $src$$Register, $mem_ptr$$Register,\n-                  R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -8470,1 +7902,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -8485,17 +7916,0 @@\n-instruct getAndSetB4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (GetAndSetB mem_ptr src));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);\n-  format %{ \"GetAndSetB $res, $mem_ptr, $src\" %}\n-  ins_encode %{\n-    __ getandsetb($res$$Register, $src$$Register, $mem_ptr$$Register,\n-                  R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n@@ -8504,1 +7918,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -8519,16 +7932,0 @@\n-instruct getAndSetS4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (GetAndSetS mem_ptr src));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);\n-  format %{ \"GetAndSetS $res, $mem_ptr, $src\" %}\n-  ins_encode %{\n-    __ getandseth($res$$Register, $src$$Register, $mem_ptr$$Register,\n-                  R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -9035,0 +8432,12 @@\n+instruct uMulHighL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{\n+  match(Set dst (UMulHiL src1 src2));\n+  ins_cost(DEFAULT_COST);\n+\n+  format %{ \"MULHDU   $dst $src1, $src2 \\t\/\/ unsigned long\" %}\n+  size(4);\n+  ins_encode %{\n+    __ mulhdu($dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n@@ -9823,1 +9232,0 @@\n-\/\/ VM_Version::has_fsqrt() decides if this node will be used.\n@@ -9838,1 +9246,0 @@\n-  predicate(VM_Version::has_fsqrts());\n@@ -10330,7 +9737,0 @@\n-\/\/\n-\/\/ Notes on the implementation on ppc64:\n-\/\/ For Power7 and earlier, the rules are limited to those which move between a\n-\/\/ register and a stack-location, because we always have to go through memory\n-\/\/ when moving between a float register and an integer register.\n-\/\/ This restriction is removed in Power8 with the introduction of the mtfprd\n-\/\/ and mffprd instructions.\n@@ -10340,1 +9740,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -10460,12 +9859,0 @@\n-\/\/----------Moves between long and float\n-\n-instruct moveF2L_reg_stack(stackSlotL dst, regF src) %{\n-  \/\/ no match-rule, false predicate\n-  effect(DEF dst, USE src);\n-  predicate(false);\n-\n-  format %{ \"storeD  $src, $dst \\t\/\/ STACK\" %}\n-  size(4);\n-  ins_encode( enc_stfd(src, dst) );\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -10497,21 +9884,0 @@\n-\/\/ Move long value from long stack-location to double register.\n-instruct moveL2D_stack_reg(regD dst, stackSlotL src) %{\n-  match(Set dst (MoveL2D src));\n-  ins_cost(MEMORY_REF_COST);\n-\n-  format %{ \"LFD     $dst, $src \\t\/\/ MoveL2D\" %}\n-  size(4);\n-  ins_encode( enc_lfd(dst, src) );\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-\/\/ Move long value from long register to double stack-location.\n-instruct moveL2D_reg_stack(stackSlotD dst, iRegLsrc src) %{\n-  match(Set dst (MoveL2D src));\n-  ins_cost(MEMORY_REF_COST);\n-\n-  format %{ \"STD     $src, $dst \\t\/\/ MoveL2D\" %}\n-  size(4);\n-  ins_encode( enc_std(src, dst) );\n-  ins_pipe(pipe_class_memory);\n-%}\n@@ -10917,53 +10283,0 @@\n-instruct cmovI_bso_stackSlotL_conLvalue0_Ex(iRegIdst dst, flagsRegSrc crx, stackSlotL mem) %{\n-  \/\/ no match-rule, false predicate\n-  effect(DEF dst, USE crx, USE mem);\n-  predicate(false);\n-\n-  format %{ \"CmovI   $dst, $crx, $mem \\t\/\/ postalloc expanded\" %}\n-  postalloc_expand %{\n-    \/\/\n-    \/\/ replaces\n-    \/\/\n-    \/\/   region  dst  crx  mem\n-    \/\/    \\       |    |   \/\n-    \/\/     dst=cmovI_bso_stackSlotL_conLvalue0\n-    \/\/\n-    \/\/ with\n-    \/\/\n-    \/\/   region  dst\n-    \/\/    \\       \/\n-    \/\/     dst=loadConI16(0)\n-    \/\/      |\n-    \/\/      ^  region  dst  crx  mem\n-    \/\/      |   \\       |    |    \/\n-    \/\/      dst=cmovI_bso_stackSlotL\n-    \/\/\n-\n-    \/\/ Create new nodes.\n-    MachNode *m1 = new loadConI16Node();\n-    MachNode *m2 = new cmovI_bso_stackSlotLNode();\n-\n-    \/\/ inputs for new nodes\n-    m1->add_req(n_region);\n-    m2->add_req(n_region, n_crx, n_mem);\n-\n-    \/\/ precedences for new nodes\n-    m2->add_prec(m1);\n-\n-    \/\/ operands for new nodes\n-    m1->_opnds[0] = op_dst;\n-    m1->_opnds[1] = new immI16Oper(0);\n-\n-    m2->_opnds[0] = op_dst;\n-    m2->_opnds[1] = op_crx;\n-    m2->_opnds[2] = op_mem;\n-\n-    \/\/ registers for new nodes\n-    ra_->set_pair(m1->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this)); \/\/ dst\n-    ra_->set_pair(m2->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this)); \/\/ dst\n-\n-    \/\/ Insert new nodes.\n-    nodes->push(m1);\n-    nodes->push(m2);\n-  %}\n-%}\n@@ -11025,16 +10338,0 @@\n-\/\/ Double to Int conversion, NaN is mapped to 0.\n-instruct convD2I_reg_ExEx(iRegIdst dst, regD src) %{\n-  match(Set dst (ConvD2I src));\n-  predicate(!VM_Version::has_mtfprd());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    regD tmpD;\n-    stackSlotL tmpS;\n-    flagsReg crx;\n-    cmpDUnordered_reg_reg(crx, src, src);               \/\/ Check whether src is NaN.\n-    convD2IRaw_regD(tmpD, src);                         \/\/ Convert float to int (speculated).\n-    moveD2L_reg_stack(tmpS, tmpD);                      \/\/ Store float to stack (speculated).\n-    cmovI_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); \/\/ Cmove based on NaN check.\n-  %}\n-%}\n@@ -11045,1 +10342,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -11070,16 +10366,0 @@\n-\/\/ Float to Int conversion, NaN is mapped to 0.\n-instruct convF2I_regF_ExEx(iRegIdst dst, regF src) %{\n-  match(Set dst (ConvF2I src));\n-  predicate(!VM_Version::has_mtfprd());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    regF tmpF;\n-    stackSlotL tmpS;\n-    flagsReg crx;\n-    cmpFUnordered_reg_reg(crx, src, src);               \/\/ Check whether src is NaN.\n-    convF2IRaw_regF(tmpF, src);                         \/\/ Convert float to int (speculated).\n-    moveF2L_reg_stack(tmpS, tmpF);                      \/\/ Store float to stack (speculated).\n-    cmovI_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); \/\/ Cmove based on NaN check.\n-  %}\n-%}\n@@ -11090,1 +10370,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -11181,50 +10460,0 @@\n-instruct cmovL_bso_stackSlotL_conLvalue0_Ex(iRegLdst dst, flagsRegSrc crx, stackSlotL mem) %{\n-  \/\/ no match-rule, false predicate\n-  effect(DEF dst, USE crx, USE mem);\n-  predicate(false);\n-\n-  format %{ \"CmovL   $dst, $crx, $mem \\t\/\/ postalloc expanded\" %}\n-  postalloc_expand %{\n-    \/\/\n-    \/\/ replaces\n-    \/\/\n-    \/\/   region  dst  crx  mem\n-    \/\/    \\       |    |   \/\n-    \/\/     dst=cmovL_bso_stackSlotL_conLvalue0\n-    \/\/\n-    \/\/ with\n-    \/\/\n-    \/\/   region  dst\n-    \/\/    \\       \/\n-    \/\/     dst=loadConL16(0)\n-    \/\/      |\n-    \/\/      ^  region  dst  crx  mem\n-    \/\/      |   \\       |    |    \/\n-    \/\/      dst=cmovL_bso_stackSlotL\n-    \/\/\n-\n-    \/\/ Create new nodes.\n-    MachNode *m1 = new loadConL16Node();\n-    MachNode *m2 = new cmovL_bso_stackSlotLNode();\n-\n-    \/\/ inputs for new nodes\n-    m1->add_req(n_region);\n-    m2->add_req(n_region, n_crx, n_mem);\n-    m2->add_prec(m1);\n-\n-    \/\/ operands for new nodes\n-    m1->_opnds[0] = op_dst;\n-    m1->_opnds[1] = new immL16Oper(0);\n-    m2->_opnds[0] = op_dst;\n-    m2->_opnds[1] = op_crx;\n-    m2->_opnds[2] = op_mem;\n-\n-    \/\/ registers for new nodes\n-    ra_->set_pair(m1->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this)); \/\/ dst\n-    ra_->set_pair(m2->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this)); \/\/ dst\n-\n-    \/\/ Insert new nodes.\n-    nodes->push(m1);\n-    nodes->push(m2);\n-  %}\n-%}\n@@ -11283,16 +10512,0 @@\n-\/\/ Float to Long conversion, NaN is mapped to 0.\n-instruct convF2L_reg_ExEx(iRegLdst dst, regF src) %{\n-  match(Set dst (ConvF2L src));\n-  predicate(!VM_Version::has_mtfprd());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    regF tmpF;\n-    stackSlotL tmpS;\n-    flagsReg crx;\n-    cmpFUnordered_reg_reg(crx, src, src);               \/\/ Check whether src is NaN.\n-    convF2LRaw_regF(tmpF, src);                         \/\/ Convert float to long (speculated).\n-    moveF2L_reg_stack(tmpS, tmpF);                      \/\/ Store float to stack (speculated).\n-    cmovL_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); \/\/ Cmove based on NaN check.\n-  %}\n-%}\n@@ -11303,1 +10516,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -11328,16 +10540,0 @@\n-\/\/ Double to Long conversion, NaN is mapped to 0.\n-instruct convD2L_reg_ExEx(iRegLdst dst, regD src) %{\n-  match(Set dst (ConvD2L src));\n-  predicate(!VM_Version::has_mtfprd());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    regD tmpD;\n-    stackSlotL tmpS;\n-    flagsReg crx;\n-    cmpDUnordered_reg_reg(crx, src, src);               \/\/ Check whether src is NaN.\n-    convD2LRaw_regD(tmpD, src);                         \/\/ Convert float to long (speculated).\n-    moveD2L_reg_stack(tmpS, tmpD);                      \/\/ Store float to stack (speculated).\n-    cmovL_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); \/\/ Cmove based on NaN check.\n-  %}\n-%}\n@@ -11348,1 +10544,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -11387,19 +10582,0 @@\n-\/\/ Integer to Float conversion.\n-instruct convI2F_ireg_Ex(regF dst, iRegIsrc src) %{\n-  match(Set dst (ConvI2F src));\n-  predicate(!VM_Version::has_fcfids());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    iRegLdst tmpL;\n-    stackSlotL tmpS;\n-    regD tmpD;\n-    regD tmpD2;\n-    convI2L_reg(tmpL, src);              \/\/ Sign-extension int to long.\n-    regL_to_stkL(tmpS, tmpL);            \/\/ Store long to stack.\n-    moveL2D_stack_reg(tmpD, tmpS);       \/\/ Load long into double register.\n-    convL2DRaw_regD(tmpD2, tmpD);        \/\/ Convert to double.\n-    convD2F_reg(dst, tmpD2);             \/\/ Convert double to float.\n-  %}\n-%}\n-\n@@ -11419,16 +10595,0 @@\n-\/\/ Integer to Float conversion. Special version for Power7.\n-instruct convI2F_ireg_fcfids_Ex(regF dst, iRegIsrc src) %{\n-  match(Set dst (ConvI2F src));\n-  predicate(VM_Version::has_fcfids() && !VM_Version::has_mtfprd());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    iRegLdst tmpL;\n-    stackSlotL tmpS;\n-    regD tmpD;\n-    convI2L_reg(tmpL, src);              \/\/ Sign-extension int to long.\n-    regL_to_stkL(tmpS, tmpL);            \/\/ Store long to stack.\n-    moveL2D_stack_reg(tmpD, tmpS);       \/\/ Load long into double register.\n-    convL2FRaw_regF(dst, tmpD);          \/\/ Convert to float.\n-  %}\n-%}\n@@ -11439,1 +10599,0 @@\n-  predicate(VM_Version::has_fcfids() && VM_Version::has_mtfprd());\n@@ -11449,14 +10608,0 @@\n-\/\/ L2F to avoid runtime call.\n-instruct convL2F_ireg_fcfids_Ex(regF dst, iRegLsrc src) %{\n-  match(Set dst (ConvL2F src));\n-  predicate(VM_Version::has_fcfids() && !VM_Version::has_mtfprd());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    stackSlotL tmpS;\n-    regD tmpD;\n-    regL_to_stkL(tmpS, src);             \/\/ Store long to stack.\n-    moveL2D_stack_reg(tmpD, tmpS);       \/\/ Load long into double register.\n-    convL2FRaw_regF(dst, tmpD);          \/\/ Convert to float.\n-  %}\n-%}\n@@ -11467,1 +10612,0 @@\n-  predicate(VM_Version::has_fcfids() && VM_Version::has_mtfprd());\n@@ -11482,16 +10626,0 @@\n-\/\/ Integer to Double conversion.\n-instruct convI2D_reg_Ex(regD dst, iRegIsrc src) %{\n-  match(Set dst (ConvI2D src));\n-  predicate(!VM_Version::has_mtfprd());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    iRegLdst tmpL;\n-    stackSlotL tmpS;\n-    regD tmpD;\n-    convI2L_reg(tmpL, src);              \/\/ Sign-extension int to long.\n-    regL_to_stkL(tmpS, tmpL);            \/\/ Store long to stack.\n-    moveL2D_stack_reg(tmpD, tmpS);       \/\/ Load long into double register.\n-    convL2DRaw_regD(dst, tmpD);          \/\/ Convert to double.\n-  %}\n-%}\n@@ -11502,1 +10630,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -11512,11 +10639,0 @@\n-\/\/ Long to Double conversion\n-instruct convL2D_reg_Ex(regD dst, stackSlotL src) %{\n-  match(Set dst (ConvL2D src));\n-  ins_cost(DEFAULT_COST + MEMORY_REF_COST);\n-\n-  expand %{\n-    regD tmpD;\n-    moveL2D_stack_reg(tmpD, src);\n-    convL2DRaw_regD(dst, tmpD);\n-  %}\n-%}\n@@ -11527,1 +10643,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -11690,0 +10805,30 @@\n+instruct cmpU3_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{\n+  match(Set dst (CmpU3 src1 src2));\n+  effect(KILL cr0);\n+  ins_cost(DEFAULT_COST * 5);\n+  size((VM_Version::has_brw() ? 16 : 20));\n+\n+  format %{ \"cmpU3_reg_reg $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ cmplw(CR0, $src1$$Register, $src2$$Register);\n+    __ set_cmp3($dst$$Register);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct cmpUL3_reg_reg(iRegIdst dst, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{\n+  match(Set dst (CmpUL3 src1 src2));\n+  effect(KILL cr0);\n+  ins_cost(DEFAULT_COST * 5);\n+  size((VM_Version::has_brw() ? 16 : 20));\n+\n+  format %{ \"cmpUL3_reg_reg $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ cmpld(CR0, $src1$$Register, $src2$$Register);\n+    __ set_cmp3($dst$$Register);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n@@ -13122,19 +12267,0 @@\n-instruct minI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{\n-  match(Set dst (MinI src1 src2));\n-  ins_cost(DEFAULT_COST*6);\n-\n-  expand %{\n-    iRegLdst src1s;\n-    iRegLdst src2s;\n-    iRegLdst diff;\n-    iRegLdst sm;\n-    iRegLdst doz; \/\/ difference or zero\n-    convI2L_reg(src1s, src1); \/\/ Ensure proper sign extension.\n-    convI2L_reg(src2s, src2); \/\/ Ensure proper sign extension.\n-    subL_reg_reg(diff, src2s, src1s);\n-    \/\/ Need to consider >=33 bit result, therefore we need signmaskL.\n-    signmask64L_regL(sm, diff);\n-    andL_reg_reg(doz, diff, sm); \/\/ <=0\n-    addI_regL_regL(dst, doz, src1s);\n-  %}\n-%}\n@@ -13145,1 +12271,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -13148,0 +12273,1 @@\n+  size(8);\n@@ -13155,19 +12281,0 @@\n-instruct maxI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{\n-  match(Set dst (MaxI src1 src2));\n-  ins_cost(DEFAULT_COST*6);\n-\n-  expand %{\n-    iRegLdst src1s;\n-    iRegLdst src2s;\n-    iRegLdst diff;\n-    iRegLdst sm;\n-    iRegLdst doz; \/\/ difference or zero\n-    convI2L_reg(src1s, src1); \/\/ Ensure proper sign extension.\n-    convI2L_reg(src2s, src2); \/\/ Ensure proper sign extension.\n-    subL_reg_reg(diff, src2s, src1s);\n-    \/\/ Need to consider >=33 bit result, therefore we need signmaskL.\n-    signmask64L_regL(sm, diff);\n-    andcL_reg_reg(doz, diff, sm); \/\/ >=0\n-    addI_regL_regL(dst, doz, src1s);\n-  %}\n-%}\n@@ -13178,1 +12285,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -13181,0 +12287,1 @@\n+  size(8);\n@@ -13190,1 +12297,0 @@\n-\/\/ Popcnt for Power7.\n@@ -13193,1 +12299,1 @@\n-  predicate(UsePopCountInstruction && VM_Version::has_popcntw());\n+  predicate(UsePopCountInstruction);\n@@ -13204,2 +12310,1 @@\n-\/\/ Popcnt for Power7.\n-  predicate(UsePopCountInstruction && VM_Version::has_popcntw());\n+  predicate(UsePopCountInstruction);\n@@ -13383,3 +12488,3 @@\n-    __ mtvsrwz($tmpV$$VectorSRegister, $src$$Register);\n-    __ xxbrw($tmpV$$VectorSRegister, $tmpV$$VectorSRegister);\n-    __ mfvsrwz($dst$$Register, $tmpV$$VectorSRegister);\n+    __ mtvsrwz($tmpV$$VectorRegister.to_vsr(), $src$$Register);\n+    __ xxbrw($tmpV$$VectorRegister.to_vsr(), $tmpV$$VectorRegister->to_vsr());\n+    __ mfvsrwz($dst$$Register, $tmpV$$VectorRegister->to_vsr());\n@@ -13455,3 +12560,3 @@\n-    __ mtvsrd($tmpV$$VectorSRegister, $src$$Register);\n-    __ xxbrd($tmpV$$VectorSRegister, $tmpV$$VectorSRegister);\n-    __ mfvsrd($dst$$Register, $tmpV$$VectorSRegister);\n+    __ mtvsrd($tmpV$$VectorRegister->to_vsr(), $src$$Register);\n+    __ xxbrd($tmpV$$VectorRegister->to_vsr(), $tmpV$$VectorRegister->to_vsr());\n+    __ mfvsrd($dst$$Register, $tmpV$$VectorRegister->to_vsr());\n@@ -13565,1 +12670,1 @@\n-  predicate(VM_Version::has_ldbrx() && (n->in(1)->as_Load()->is_unordered() || followed_by_acquire(n->in(1))));\n+  predicate((n->in(1)->as_Load()->is_unordered() || followed_by_acquire(n->in(1))));\n@@ -13577,1 +12682,0 @@\n-  predicate(VM_Version::has_ldbrx());\n@@ -13658,1 +12762,0 @@\n-  predicate(VM_Version::has_stdbrx());\n@@ -13698,1 +12801,1 @@\n-    __ mtvsrwz($temp1$$VectorSRegister, $src$$Register);\n+    __ mtvsrwz($temp1$$VectorRegister->to_vsr(), $src$$Register);\n@@ -13709,1 +12812,1 @@\n-    __ xxspltw($dst$$VectorSRegister, $src$$VectorSRegister, $imm1$$constant);\n+    __ xxspltw($dst$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr(), $imm1$$constant);\n@@ -13720,1 +12823,1 @@\n-    __ xscvdpspn($dst$$VectorSRegister, $src$$FloatRegister->to_vsr());\n+    __ xscvdpspn($dst$$VectorRegister->to_vsr(), $src$$FloatRegister->to_vsr());\n@@ -13827,1 +12930,1 @@\n-    __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);\n+    __ xxlxor($dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr());\n@@ -13840,1 +12943,1 @@\n-    __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);\n+    __ xxleqv($dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr());\n@@ -13905,1 +13008,1 @@\n-    __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);\n+    __ xxlxor($dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr());\n@@ -13918,1 +13021,1 @@\n-    __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);\n+    __ xxleqv($dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr());\n@@ -13983,1 +13086,1 @@\n-    __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);\n+    __ xxlxor($dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr());\n@@ -13996,1 +13099,1 @@\n-    __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);\n+    __ xxleqv($dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr());\n@@ -14035,0 +13138,1 @@\n+  size(4);\n@@ -14052,1 +13156,1 @@\n-    __ vaddubm($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vaddubm($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -14063,1 +13167,1 @@\n-    __ vadduhm($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vadduhm($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -14074,1 +13178,1 @@\n-    __ vadduwm($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vadduwm($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -14085,1 +13189,1 @@\n-    __ vaddfp($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vaddfp($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -14096,1 +13200,1 @@\n-    __ vaddudm($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vaddudm($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -14107,1 +13211,1 @@\n-    __ xvadddp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvadddp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n@@ -14120,1 +13224,1 @@\n-    __ vsububm($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vsububm($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -14131,1 +13235,1 @@\n-    __ vsubuhm($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vsubuhm($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -14142,1 +13246,1 @@\n-    __ vsubuwm($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vsubuwm($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -14153,1 +13257,1 @@\n-    __ vsubfp($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vsubfp($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -14164,1 +13268,1 @@\n-    __ vsubudm($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vsubudm($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -14175,1 +13279,1 @@\n-    __ xvsubdp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvsubdp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n@@ -14190,2 +13294,2 @@\n-    __ vspltish($tmp$$VectorSRegister->to_vr(), 0);\n-    __ vmladduhm($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr(), $tmp$$VectorSRegister->to_vr());\n+    __ vspltish($tmp$$VectorRegister, 0);\n+    __ vmladduhm($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister, $tmp$$VectorRegister);\n@@ -14202,1 +13306,1 @@\n-    __ vmuluwm($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vmuluwm($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -14213,1 +13317,1 @@\n-    __ xvmulsp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvmulsp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n@@ -14224,1 +13328,1 @@\n-    __ xvmuldp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvmuldp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n@@ -14237,1 +13341,1 @@\n-    __ xvdivsp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvdivsp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n@@ -14248,1 +13352,148 @@\n-    __ xvdivdp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvdivdp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+\/\/ Vector Min \/ Max Instructions\n+\n+instruct vmin_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (MinV src1 src2));\n+  format %{ \"VMIN  $dst,$src1,$src2\\t\/\/ vector min\" %}\n+  size(4);\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    switch (bt) {\n+      case T_INT:\n+        __ vminsw($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+        break;\n+      case T_LONG:\n+        __ vminsd($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct vmax_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (MaxV src1 src2));\n+  format %{ \"VMAX  $dst,$src1,$src2\\t\/\/ vector max\" %}\n+  size(4);\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    switch (bt) {\n+      case T_INT:\n+        __ vmaxsw($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+        break;\n+      case T_LONG:\n+        __ vmaxsd($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct vminu_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (UMinV src1 src2));\n+  format %{ \"VMINU  $dst,$src1,$src2\\t\/\/ vector unsigned min\" %}\n+  size(4);\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    switch (bt) {\n+      case T_INT:\n+        __ vminuw($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+        break;\n+      case T_LONG:\n+        __ vminud($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct vmaxu_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (UMaxV src1 src2));\n+  format %{ \"VMAXU  $dst,$src1,$src2\\t\/\/ vector unsigned max\" %}\n+  size(4);\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    switch (bt) {\n+      case T_INT:\n+        __ vmaxuw($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+        break;\n+      case T_LONG:\n+        __ vmaxud($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct vand(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (AndV src1 src2));\n+  size(4);\n+  format %{ \"VAND   $dst,$src1,$src2\\t\/\/ and vectors\" %}\n+  ins_encode %{\n+    __ vand($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct vor(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (OrV src1 src2));\n+  size(4);\n+  format %{ \"VOR   $dst,$src1,$src2\\t\/\/ or vectors\" %}\n+  ins_encode %{\n+    __ vor($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct vxor(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (XorV src1 src2));\n+  size(4);\n+  format %{ \"VXOR   $dst,$src1,$src2\\t\/\/ xor vectors\" %}\n+  ins_encode %{\n+    __ vxor($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct reductionI_arith_logic(iRegIdst dst, iRegIsrc srcInt, vecX srcVec, vecX tmp1, vecX tmp2) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_INT);\n+  match(Set dst (AddReductionVI srcInt srcVec));\n+  match(Set dst (MulReductionVI srcInt srcVec));\n+  match(Set dst (AndReductionV  srcInt srcVec));\n+  match(Set dst ( OrReductionV  srcInt srcVec));\n+  match(Set dst (XorReductionV  srcInt srcVec));\n+  effect(TEMP tmp1, TEMP tmp2);\n+  ins_cost(DEFAULT_COST * 6);\n+  format %{ \"REDUCEI_ARITH_LOGIC \/\/ $dst,$srcInt,$srcVec,$tmp1,$tmp2\\t\/\/ reduce vector int add\/mul\/and\/or\/xor\" %}\n+  size(24);\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    __ reduceI(opcode, $dst$$Register, $srcInt$$Register, $srcVec$$VectorRegister,\n+        $tmp1$$VectorRegister, $tmp2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct reductionI_min_max(iRegIdst dst, iRegIsrc srcInt, vecX srcVec, vecX tmp1, vecX tmp2, flagsRegCR0 cr0) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_INT);\n+  match(Set dst (MinReductionV srcInt srcVec));\n+  match(Set dst (MaxReductionV srcInt srcVec));\n+  effect(TEMP tmp1, TEMP tmp2, KILL cr0);\n+  ins_cost(DEFAULT_COST * 7);\n+  format %{ \"REDUCEI_MINMAX \/\/ $dst,$srcInt,$srcVec,$tmp1,$tmp2,cr0\\t\/\/ reduce vector int min\/max\" %}\n+  size(28);\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    __ reduceI(opcode, $dst$$Register, $srcInt$$Register, $srcVec$$VectorRegister,\n+        $tmp1$$VectorRegister, $tmp2$$VectorRegister);\n@@ -14261,1 +13512,1 @@\n-    __ xvabssp($dst$$VectorSRegister, $src$$VectorSRegister);\n+    __ xvabssp($dst$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr());\n@@ -14272,1 +13523,1 @@\n-    __ xvabsdp($dst$$VectorSRegister, $src$$VectorSRegister);\n+    __ xvabsdp($dst$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr());\n@@ -14309,1 +13560,1 @@\n-        __ xvrdpic($dst$$VectorSRegister, $src$$VectorSRegister);\n+        __ xvrdpic($dst$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr());\n@@ -14312,1 +13563,1 @@\n-        __ xvrdpim($dst$$VectorSRegister, $src$$VectorSRegister);\n+        __ xvrdpim($dst$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr());\n@@ -14315,1 +13566,1 @@\n-        __ xvrdpip($dst$$VectorSRegister, $src$$VectorSRegister);\n+        __ xvrdpip($dst$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr());\n@@ -14332,1 +13583,1 @@\n-    __ xvnegsp($dst$$VectorSRegister, $src$$VectorSRegister);\n+    __ xvnegsp($dst$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr());\n@@ -14343,1 +13594,12 @@\n-    __ xvnegdp($dst$$VectorSRegister, $src$$VectorSRegister);\n+    __ xvnegdp($dst$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr());\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct vneg4I_reg(vecX dst, vecX src) %{\n+  match(Set dst (NegVI src));\n+  predicate(PowerArchitecturePPC64 >= 9 && Matcher::vector_element_basic_type(n) == T_INT);\n+  format %{ \"VNEGW $dst,$src\\t\/\/ negate int vector\" %}\n+  size(4);\n+  ins_encode %{\n+    __ vnegw($dst$$VectorRegister, $src$$VectorRegister);\n@@ -14356,1 +13618,1 @@\n-    __ xvsqrtsp($dst$$VectorSRegister, $src$$VectorSRegister);\n+    __ xvsqrtsp($dst$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr());\n@@ -14367,1 +13629,1 @@\n-    __ xvsqrtdp($dst$$VectorSRegister, $src$$VectorSRegister);\n+    __ xvsqrtdp($dst$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr());\n@@ -14383,1 +13645,1 @@\n-        __ vpopcntb($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vpopcntb($dst$$VectorRegister, $src$$VectorRegister);\n@@ -14386,1 +13648,1 @@\n-        __ vpopcnth($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vpopcnth($dst$$VectorRegister, $src$$VectorRegister);\n@@ -14389,1 +13651,1 @@\n-        __ vpopcntw($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vpopcntw($dst$$VectorRegister, $src$$VectorRegister);\n@@ -14392,1 +13654,1 @@\n-        __ vpopcntd($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vpopcntd($dst$$VectorRegister, $src$$VectorRegister);\n@@ -14409,1 +13671,1 @@\n-        __ vclzb($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vclzb($dst$$VectorRegister, $src$$VectorRegister);\n@@ -14412,1 +13674,1 @@\n-        __ vclzh($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vclzh($dst$$VectorRegister, $src$$VectorRegister);\n@@ -14415,1 +13677,1 @@\n-        __ vclzw($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vclzw($dst$$VectorRegister, $src$$VectorRegister);\n@@ -14418,1 +13680,1 @@\n-        __ vclzd($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vclzd($dst$$VectorRegister, $src$$VectorRegister);\n@@ -14435,1 +13697,1 @@\n-        __ vctzb($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vctzb($dst$$VectorRegister, $src$$VectorRegister);\n@@ -14438,1 +13700,1 @@\n-        __ vctzh($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vctzh($dst$$VectorRegister, $src$$VectorRegister);\n@@ -14441,1 +13703,1 @@\n-        __ vctzw($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vctzw($dst$$VectorRegister, $src$$VectorRegister);\n@@ -14444,1 +13706,1 @@\n-        __ vctzd($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vctzd($dst$$VectorRegister, $src$$VectorRegister);\n@@ -14464,1 +13726,1 @@\n-    __ xvmaddasp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvmaddasp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n@@ -14480,1 +13742,1 @@\n-    __ xvnmsubasp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvnmsubasp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n@@ -14495,1 +13757,1 @@\n-    __ xvmsubasp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvmsubasp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n@@ -14510,1 +13772,1 @@\n-    __ xvmaddadp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvmaddadp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n@@ -14526,1 +13788,1 @@\n-    __ xvnmsubadp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvnmsubadp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n@@ -14541,1 +13803,1 @@\n-    __ xvmsubadp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvmsubadp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n@@ -14556,0 +13818,1 @@\n+  size(12);\n@@ -14568,0 +13831,1 @@\n+  size(12);\n@@ -14580,0 +13844,1 @@\n+  size(12);\n@@ -14592,0 +13857,1 @@\n+  size(12);\n@@ -14630,0 +13896,1 @@\n+  size(4);\n@@ -14631,1 +13898,1 @@\n-    __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);\n+    __ xxlxor($dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr());\n@@ -14644,1 +13911,1 @@\n-    __ xxpermdi($dst$$VectorSRegister, $src$$FloatRegister->to_vsr(), $src$$FloatRegister->to_vsr(), 0);\n+    __ xxpermdi($dst$$VectorRegister->to_vsr(), $src$$FloatRegister->to_vsr(), $src$$FloatRegister->to_vsr(), 0);\n@@ -14657,1 +13924,1 @@\n-    __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);\n+    __ xxlxor($dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr());\n@@ -14669,1 +13936,1 @@\n-    __ mtvsrd($dst$$VectorSRegister, $src$$Register);\n+    __ mtvsrd($dst$$VectorRegister->to_vsr(), $src$$Register);\n@@ -14680,1 +13947,1 @@\n-    __ xxpermdi($dst$$VectorSRegister, $src$$VectorSRegister, $src$$VectorSRegister, $zero$$constant);\n+    __ xxpermdi($dst$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr(), $zero$$constant);\n@@ -14691,1 +13958,1 @@\n-    __ xxpermdi($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister, $zero$$constant);\n+    __ xxpermdi($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr(), $zero$$constant);\n@@ -14716,1 +13983,1 @@\n-    __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);\n+    __ xxlxor($dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr());\n@@ -14729,1 +13996,1 @@\n-    __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);\n+    __ xxleqv($dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr());\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":648,"deletions":1381,"binary":false,"changes":2029,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n+  const char* name = OptoRuntime::stub_name(StubId::c2_exception_id);\n","filename":"src\/hotspot\/cpu\/ppc\/runtime_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-    vs_reg\n+    vec_reg\n@@ -120,1 +120,1 @@\n-    vs_reg_size       = 16\n+    vec_reg_size      = 16\n@@ -140,2 +140,2 @@\n-#define RegisterSaver_LiveVSReg(regname) \\\n-  { RegisterSaver::vs_reg,      regname->encoding(), regname->as_VMReg() }\n+#define RegisterSaver_LiveVecReg(regname) \\\n+  { RegisterSaver::vec_reg,      regname->encoding(), regname->as_VMReg() }\n@@ -223,1 +223,1 @@\n-static const RegisterSaver::LiveRegType RegisterSaver_LiveVSRegs[] = {\n+static const RegisterSaver::LiveRegType RegisterSaver_LiveVecRegs[] = {\n@@ -225,1 +225,1 @@\n-  \/\/ live vector scalar registers (optional, only these ones are used by C2):\n+  \/\/ live vector registers (optional, only these ones are used by C2):\n@@ -227,32 +227,32 @@\n-  RegisterSaver_LiveVSReg( VSR32 ),\n-  RegisterSaver_LiveVSReg( VSR33 ),\n-  RegisterSaver_LiveVSReg( VSR34 ),\n-  RegisterSaver_LiveVSReg( VSR35 ),\n-  RegisterSaver_LiveVSReg( VSR36 ),\n-  RegisterSaver_LiveVSReg( VSR37 ),\n-  RegisterSaver_LiveVSReg( VSR38 ),\n-  RegisterSaver_LiveVSReg( VSR39 ),\n-  RegisterSaver_LiveVSReg( VSR40 ),\n-  RegisterSaver_LiveVSReg( VSR41 ),\n-  RegisterSaver_LiveVSReg( VSR42 ),\n-  RegisterSaver_LiveVSReg( VSR43 ),\n-  RegisterSaver_LiveVSReg( VSR44 ),\n-  RegisterSaver_LiveVSReg( VSR45 ),\n-  RegisterSaver_LiveVSReg( VSR46 ),\n-  RegisterSaver_LiveVSReg( VSR47 ),\n-  RegisterSaver_LiveVSReg( VSR48 ),\n-  RegisterSaver_LiveVSReg( VSR49 ),\n-  RegisterSaver_LiveVSReg( VSR50 ),\n-  RegisterSaver_LiveVSReg( VSR51 ),\n-  RegisterSaver_LiveVSReg( VSR52 ),\n-  RegisterSaver_LiveVSReg( VSR53 ),\n-  RegisterSaver_LiveVSReg( VSR54 ),\n-  RegisterSaver_LiveVSReg( VSR55 ),\n-  RegisterSaver_LiveVSReg( VSR56 ),\n-  RegisterSaver_LiveVSReg( VSR57 ),\n-  RegisterSaver_LiveVSReg( VSR58 ),\n-  RegisterSaver_LiveVSReg( VSR59 ),\n-  RegisterSaver_LiveVSReg( VSR60 ),\n-  RegisterSaver_LiveVSReg( VSR61 ),\n-  RegisterSaver_LiveVSReg( VSR62 ),\n-  RegisterSaver_LiveVSReg( VSR63 )\n+  RegisterSaver_LiveVecReg( VR0 ),\n+  RegisterSaver_LiveVecReg( VR1 ),\n+  RegisterSaver_LiveVecReg( VR2 ),\n+  RegisterSaver_LiveVecReg( VR3 ),\n+  RegisterSaver_LiveVecReg( VR4 ),\n+  RegisterSaver_LiveVecReg( VR5 ),\n+  RegisterSaver_LiveVecReg( VR6 ),\n+  RegisterSaver_LiveVecReg( VR7 ),\n+  RegisterSaver_LiveVecReg( VR8 ),\n+  RegisterSaver_LiveVecReg( VR9 ),\n+  RegisterSaver_LiveVecReg( VR10 ),\n+  RegisterSaver_LiveVecReg( VR11 ),\n+  RegisterSaver_LiveVecReg( VR12 ),\n+  RegisterSaver_LiveVecReg( VR13 ),\n+  RegisterSaver_LiveVecReg( VR14 ),\n+  RegisterSaver_LiveVecReg( VR15 ),\n+  RegisterSaver_LiveVecReg( VR16 ),\n+  RegisterSaver_LiveVecReg( VR17 ),\n+  RegisterSaver_LiveVecReg( VR18 ),\n+  RegisterSaver_LiveVecReg( VR19 ),\n+  RegisterSaver_LiveVecReg( VR20 ),\n+  RegisterSaver_LiveVecReg( VR21 ),\n+  RegisterSaver_LiveVecReg( VR22 ),\n+  RegisterSaver_LiveVecReg( VR23 ),\n+  RegisterSaver_LiveVecReg( VR24 ),\n+  RegisterSaver_LiveVecReg( VR25 ),\n+  RegisterSaver_LiveVecReg( VR26 ),\n+  RegisterSaver_LiveVecReg( VR27 ),\n+  RegisterSaver_LiveVecReg( VR28 ),\n+  RegisterSaver_LiveVecReg( VR29 ),\n+  RegisterSaver_LiveVecReg( VR30 ),\n+  RegisterSaver_LiveVecReg( VR31 )\n@@ -280,1 +280,1 @@\n-  const int vsregstosave_num     = save_vectors ? (sizeof(RegisterSaver_LiveVSRegs) \/\n+  const int vecregstosave_num    = save_vectors ? (sizeof(RegisterSaver_LiveVecRegs) \/\n@@ -283,1 +283,1 @@\n-  const int register_save_size   = regstosave_num * reg_size + vsregstosave_num * vs_reg_size;\n+  const int register_save_size   = regstosave_num * reg_size + vecregstosave_num * vec_reg_size;\n@@ -301,2 +301,2 @@\n-  __ std(R31, frame_size_in_bytes -   reg_size - vsregstosave_num * vs_reg_size, R1_SP);\n-  __ std(R30, frame_size_in_bytes - 2*reg_size - vsregstosave_num * vs_reg_size, R1_SP);\n+  __ std(R31, frame_size_in_bytes -   reg_size - vecregstosave_num * vec_reg_size, R1_SP);\n+  __ std(R30, frame_size_in_bytes - 2*reg_size - vecregstosave_num * vec_reg_size, R1_SP);\n@@ -363,4 +363,4 @@\n-    assert(is_even(vsregstosave_num), \"expectation\");\n-    for (int i = 0; i < vsregstosave_num; i += 2) {\n-      int reg_num = RegisterSaver_LiveVSRegs[i].reg_num;\n-      assert(RegisterSaver_LiveVSRegs[i + 1].reg_num == reg_num + 1, \"or use other instructions!\");\n+    assert(is_even(vecregstosave_num), \"expectation\");\n+    for (int i = 0; i < vecregstosave_num; i += 2) {\n+      int reg_num = RegisterSaver_LiveVecRegs[i].reg_num;\n+      assert(RegisterSaver_LiveVecRegs[i + 1].reg_num == reg_num + 1, \"or use other instructions!\");\n@@ -368,1 +368,1 @@\n-      __ stxvp(as_VectorSRegister(reg_num), offset, R1_SP);\n+      __ stxvp(as_VectorRegister(reg_num).to_vsr(), offset, R1_SP);\n@@ -372,3 +372,3 @@\n-                              RegisterSaver_LiveVSRegs[i LITTLE_ENDIAN_ONLY(+1) ].vmreg);\n-        map->set_callee_saved(VMRegImpl::stack2reg((offset + vs_reg_size) >> 2),\n-                              RegisterSaver_LiveVSRegs[i BIG_ENDIAN_ONLY(+1) ].vmreg);\n+                              RegisterSaver_LiveVecRegs[i LITTLE_ENDIAN_ONLY(+1) ].vmreg);\n+        map->set_callee_saved(VMRegImpl::stack2reg((offset + vec_reg_size) >> 2),\n+                              RegisterSaver_LiveVecRegs[i BIG_ENDIAN_ONLY(+1) ].vmreg);\n@@ -376,1 +376,1 @@\n-      offset += (2 * vs_reg_size);\n+      offset += (2 * vec_reg_size);\n@@ -379,2 +379,2 @@\n-    for (int i = 0; i < vsregstosave_num; i++) {\n-      int reg_num = RegisterSaver_LiveVSRegs[i].reg_num;\n+    for (int i = 0; i < vecregstosave_num; i++) {\n+      int reg_num = RegisterSaver_LiveVecRegs[i].reg_num;\n@@ -383,1 +383,1 @@\n-        __ stxv(as_VectorSRegister(reg_num), offset, R1_SP);\n+        __ stxv(as_VectorRegister(reg_num)->to_vsr(), offset, R1_SP);\n@@ -386,1 +386,1 @@\n-        __ stxvd2x(as_VectorSRegister(reg_num), R31, R1_SP);\n+        __ stxvd2x(as_VectorRegister(reg_num)->to_vsr(), R31, R1_SP);\n@@ -390,1 +390,1 @@\n-        VMReg vsr = RegisterSaver_LiveVSRegs[i].vmreg;\n+        VMReg vsr = RegisterSaver_LiveVecRegs[i].vmreg;\n@@ -393,1 +393,1 @@\n-      offset += vs_reg_size;\n+      offset += vec_reg_size;\n@@ -414,1 +414,1 @@\n-  const int vsregstosave_num     = save_vectors ? (sizeof(RegisterSaver_LiveVSRegs) \/\n+  const int vecregstosave_num    = save_vectors ? (sizeof(RegisterSaver_LiveVecRegs) \/\n@@ -417,1 +417,1 @@\n-  const int register_save_size   = regstosave_num * reg_size + vsregstosave_num * vs_reg_size;\n+  const int register_save_size   = regstosave_num * reg_size + vecregstosave_num * vec_reg_size;\n@@ -459,3 +459,3 @@\n-    for (int i = 0; i < vsregstosave_num; i += 2) {\n-      int reg_num  = RegisterSaver_LiveVSRegs[i].reg_num;\n-      assert(RegisterSaver_LiveVSRegs[i + 1].reg_num == reg_num + 1, \"or use other instructions!\");\n+    for (int i = 0; i < vecregstosave_num; i += 2) {\n+      int reg_num  = RegisterSaver_LiveVecRegs[i].reg_num;\n+      assert(RegisterSaver_LiveVecRegs[i + 1].reg_num == reg_num + 1, \"or use other instructions!\");\n@@ -463,1 +463,1 @@\n-      __ lxvp(as_VectorSRegister(reg_num), offset, R1_SP);\n+      __ lxvp(as_VectorRegister(reg_num).to_vsr(), offset, R1_SP);\n@@ -465,1 +465,1 @@\n-      offset += (2 * vs_reg_size);\n+      offset += (2 * vec_reg_size);\n@@ -468,2 +468,2 @@\n-    for (int i = 0; i < vsregstosave_num; i++) {\n-      int reg_num  = RegisterSaver_LiveVSRegs[i].reg_num;\n+    for (int i = 0; i < vecregstosave_num; i++) {\n+      int reg_num  = RegisterSaver_LiveVecRegs[i].reg_num;\n@@ -472,1 +472,1 @@\n-        __ lxv(as_VectorSRegister(reg_num), offset, R1_SP);\n+        __ lxv(as_VectorRegister(reg_num).to_vsr(), offset, R1_SP);\n@@ -475,1 +475,1 @@\n-        __ lxvd2x(as_VectorSRegister(reg_num), R31, R1_SP);\n+        __ lxvd2x(as_VectorRegister(reg_num).to_vsr(), R31, R1_SP);\n@@ -478,1 +478,1 @@\n-      offset += vs_reg_size;\n+      offset += vec_reg_size;\n@@ -489,1 +489,1 @@\n-  __ ld(R31, frame_size_in_bytes - reg_size - vsregstosave_num * vs_reg_size, R1_SP);\n+  __ ld(R31, frame_size_in_bytes - reg_size - vecregstosave_num * vec_reg_size, R1_SP);\n@@ -2743,0 +2743,15 @@\n+  \/\/ Prepare for return\n+  \/\/ --------------------------------------------------------------------------\n+  __ pop_frame();\n+  __ restore_LR(R11);\n+\n+#if INCLUDE_JFR\n+  \/\/ We need to do a poll test after unwind in case the sampler\n+  \/\/ managed to sample the native frame after returning to Java.\n+  Label L_stub;\n+  int safepoint_offset = __ offset();\n+  if (!UseSIGTRAP) {\n+    __ relocate(relocInfo::poll_return_type);\n+  }\n+  __ safepoint_poll(L_stub, r_temp_2, true \/* at_return *\/, true \/* in_nmethod: frame already popped *\/);\n+#endif \/\/ INCLUDE_JFR\n@@ -2750,5 +2765,1 @@\n-  \/\/ Return\n-  \/\/ --------------------------------------------------------------------------\n-\n-  __ pop_frame();\n-  __ restore_LR(R11);\n+  \/\/ Return.\n@@ -2757,0 +2768,7 @@\n+  \/\/ Handler for return safepoint (out-of-line).\n+#if INCLUDE_JFR\n+  if (!UseSIGTRAP) {\n+    __ bind(L_stub);\n+    __ jump_to_polling_page_return_handler_blob(safepoint_offset);\n+  }\n+#endif \/\/ INCLUDE_JFR\n@@ -2764,3 +2782,0 @@\n-\n-  __ pop_frame();\n-  __ restore_LR(R11);\n@@ -2923,1 +2938,1 @@\n-  \/\/ Get the return address pointing into the frame manager.\n+  \/\/ Get the return address pointing into the template interpreter.\n@@ -2935,1 +2950,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::deopt_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_deopt_id);\n@@ -3158,1 +3173,1 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n+  const char* name = OptoRuntime::stub_name(StubId::c2_uncommon_trap_id);\n@@ -3290,1 +3305,1 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(StubId id, address call_ptr) {\n@@ -3308,1 +3323,1 @@\n-  bool cause_return = (id == SharedStubId::polling_page_return_handler_id);\n+  bool cause_return = (id == StubId::shared_polling_page_return_handler_id);\n@@ -3318,1 +3333,1 @@\n-  bool save_vectors = (id == SharedStubId::polling_page_vectors_safepoint_handler_id);\n+  bool save_vectors = (id == StubId::shared_polling_page_vectors_safepoint_handler_id);\n@@ -3405,1 +3420,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(StubId id, address destination) {\n@@ -3509,1 +3524,1 @@\n-RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+RuntimeStub* SharedRuntime::generate_throw_exception(StubId id, address runtime_entry) {\n@@ -3832,1 +3847,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_write_checkpoint_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_jfr_write_checkpoint_id);\n@@ -3869,1 +3884,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_return_lease_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_jfr_return_lease_id);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":103,"deletions":88,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-    \/\/ Setup a new c frame, copy java arguments, call frame manager or\n+    \/\/ Setup a new c frame, copy java arguments, call template interpreter or\n@@ -92,1 +92,1 @@\n-    StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+    StubId stub_id = StubId::stubgen_call_stub_id;\n@@ -218,2 +218,1 @@\n-      BLOCK_COMMENT(\"Call frame manager or native entry.\");\n-      \/\/ Call frame manager or native entry.\n+      BLOCK_COMMENT(\"Call template interpreter or native entry.\");\n@@ -222,1 +221,1 @@\n-      \/\/ Register state on entry to frame manager \/ native entry:\n+      \/\/ Register state on entry to template interpreter \/ native entry:\n@@ -245,1 +244,1 @@\n-      \/\/ Stack on entry to frame manager \/ native entry:\n+      \/\/ Stack on entry to template interpreter \/ native entry:\n@@ -265,1 +264,1 @@\n-      \/\/ of the interpreter entry point (frame manager or native entry)\n+      \/\/ of the interpreter entry point (template interpreter or native entry)\n@@ -273,2 +272,1 @@\n-      BLOCK_COMMENT(\"Returned from frame manager or native entry.\");\n-      \/\/ Returned from frame manager or native entry.\n+      BLOCK_COMMENT(\"Returned from template interpreter or native entry.\");\n@@ -277,1 +275,1 @@\n-      \/\/ Stack on exit from frame manager \/ native entry:\n+      \/\/ Stack on exit from template interpreter \/ native entry:\n@@ -298,1 +296,1 @@\n-      \/\/ to frame manager \/ native entry.\n+      \/\/ to template interpreter \/ native entry.\n@@ -370,1 +368,1 @@\n-    StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+    StubId stub_id = StubId::stubgen_catch_exception_id;\n@@ -426,1 +424,1 @@\n-    StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+    StubId stub_id = StubId::stubgen_forward_exception_id;\n@@ -711,1 +709,1 @@\n-  address generate_fill(StubGenStubId stub_id) {\n+  address generate_fill(StubId stub_id) {\n@@ -716,1 +714,1 @@\n-    case jbyte_fill_id:\n+    case StubId::stubgen_jbyte_fill_id:\n@@ -720,1 +718,1 @@\n-    case jshort_fill_id:\n+    case StubId::stubgen_jshort_fill_id:\n@@ -724,1 +722,1 @@\n-    case jint_fill_id:\n+    case StubId::stubgen_jint_fill_id:\n@@ -728,1 +726,1 @@\n-    case arrayof_jbyte_fill_id:\n+    case StubId::stubgen_arrayof_jbyte_fill_id:\n@@ -732,1 +730,1 @@\n-    case arrayof_jshort_fill_id:\n+    case StubId::stubgen_arrayof_jshort_fill_id:\n@@ -736,1 +734,1 @@\n-    case arrayof_jint_fill_id:\n+    case StubId::stubgen_arrayof_jint_fill_id:\n@@ -989,1 +987,1 @@\n-  address generate_disjoint_byte_copy(StubGenStubId stub_id) {\n+  address generate_disjoint_byte_copy(StubId stub_id) {\n@@ -992,1 +990,1 @@\n-    case jbyte_disjoint_arraycopy_id:\n+    case StubId::stubgen_jbyte_disjoint_arraycopy_id:\n@@ -995,1 +993,1 @@\n-    case arrayof_jbyte_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id:\n@@ -1072,19 +1070,0 @@\n-       if (!VM_Version::has_vsx()) {\n-\n-        __ bind(l_8);\n-        \/\/ Use unrolled version for mass copying (copy 32 elements a time)\n-        \/\/ Load feeding store gets zero latency on Power6, however not on Power5.\n-        \/\/ Therefore, the following sequence is made for the good of both.\n-        __ ld(tmp1, 0, R3_ARG1);\n-        __ ld(tmp2, 8, R3_ARG1);\n-        __ ld(tmp3, 16, R3_ARG1);\n-        __ ld(tmp4, 24, R3_ARG1);\n-        __ std(tmp1, 0, R4_ARG2);\n-        __ std(tmp2, 8, R4_ARG2);\n-        __ std(tmp3, 16, R4_ARG2);\n-        __ std(tmp4, 24, R4_ARG2);\n-        __ addi(R3_ARG1, R3_ARG1, 32);\n-        __ addi(R4_ARG2, R4_ARG2, 32);\n-        __ bdnz(l_8);\n-\n-      } else { \/\/ Processor supports VSX, so use it to mass copy.\n@@ -1100,1 +1079,0 @@\n-\n@@ -1125,1 +1103,0 @@\n-      } \/\/ VSX\n@@ -1180,1 +1157,1 @@\n-  address generate_conjoint_byte_copy(StubGenStubId stub_id) {\n+  address generate_conjoint_byte_copy(StubId stub_id) {\n@@ -1183,1 +1160,1 @@\n-    case jbyte_arraycopy_id:\n+    case StubId::stubgen_jbyte_arraycopy_id:\n@@ -1186,1 +1163,1 @@\n-    case arrayof_jbyte_arraycopy_id:\n+    case StubId::stubgen_arrayof_jbyte_arraycopy_id:\n@@ -1281,1 +1258,1 @@\n-  address generate_disjoint_short_copy(StubGenStubId stub_id) {\n+  address generate_disjoint_short_copy(StubId stub_id) {\n@@ -1284,1 +1261,1 @@\n-    case jshort_disjoint_arraycopy_id:\n+    case StubId::stubgen_jshort_disjoint_arraycopy_id:\n@@ -1287,1 +1264,1 @@\n-    case arrayof_jshort_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id:\n@@ -1368,19 +1345,2 @@\n-        if (!VM_Version::has_vsx()) {\n-\n-          __ bind(l_8);\n-          \/\/ Use unrolled version for mass copying (copy 16 elements a time).\n-          \/\/ Load feeding store gets zero latency on Power6, however not on Power5.\n-          \/\/ Therefore, the following sequence is made for the good of both.\n-          __ ld(tmp1, 0, R3_ARG1);\n-          __ ld(tmp2, 8, R3_ARG1);\n-          __ ld(tmp3, 16, R3_ARG1);\n-          __ ld(tmp4, 24, R3_ARG1);\n-          __ std(tmp1, 0, R4_ARG2);\n-          __ std(tmp2, 8, R4_ARG2);\n-          __ std(tmp3, 16, R4_ARG2);\n-          __ std(tmp4, 24, R4_ARG2);\n-          __ addi(R3_ARG1, R3_ARG1, 32);\n-          __ addi(R4_ARG2, R4_ARG2, 32);\n-          __ bdnz(l_8);\n-\n-        } else { \/\/ Processor supports VSX, so use it to mass copy.\n+\n+        \/\/ Processor supports VSX, so use it to mass copy.\n@@ -1420,1 +1380,0 @@\n-        }\n@@ -1476,1 +1435,1 @@\n-  address generate_conjoint_short_copy(StubGenStubId stub_id) {\n+  address generate_conjoint_short_copy(StubId stub_id) {\n@@ -1479,1 +1438,1 @@\n-    case jshort_arraycopy_id:\n+    case StubId::stubgen_jshort_arraycopy_id:\n@@ -1482,1 +1441,1 @@\n-    case arrayof_jshort_arraycopy_id:\n+    case StubId::stubgen_arrayof_jshort_arraycopy_id:\n@@ -1575,1 +1534,1 @@\n-     if (!VM_Version::has_vsx()) {\n+    \/\/ Processor supports VSX, so use it to mass copy.\n@@ -1577,20 +1536,2 @@\n-      __ bind(l_6);\n-      \/\/ Use unrolled version for mass copying (copy 8 elements a time).\n-      \/\/ Load feeding store gets zero latency on power6, however not on power 5.\n-      \/\/ Therefore, the following sequence is made for the good of both.\n-      __ ld(tmp1, 0, R3_ARG1);\n-      __ ld(tmp2, 8, R3_ARG1);\n-      __ ld(tmp3, 16, R3_ARG1);\n-      __ ld(tmp4, 24, R3_ARG1);\n-      __ std(tmp1, 0, R4_ARG2);\n-      __ std(tmp2, 8, R4_ARG2);\n-      __ std(tmp3, 16, R4_ARG2);\n-      __ std(tmp4, 24, R4_ARG2);\n-      __ addi(R3_ARG1, R3_ARG1, 32);\n-      __ addi(R4_ARG2, R4_ARG2, 32);\n-      __ bdnz(l_6);\n-\n-    } else { \/\/ Processor supports VSX, so use it to mass copy.\n-\n-      \/\/ Prefetch the data into the L2 cache.\n-      __ dcbt(R3_ARG1, 0);\n+    \/\/ Prefetch the data into the L2 cache.\n+    __ dcbt(R3_ARG1, 0);\n@@ -1598,12 +1539,6 @@\n-      \/\/ If supported set DSCR pre-fetch to deepest.\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n-        __ mtdscr(tmp2);\n-      }\n-\n-      __ li(tmp1, 16);\n-\n-      \/\/ Backbranch target aligned to 32-byte. Not 16-byte align as\n-      \/\/ loop contains < 8 instructions that fit inside a single\n-      \/\/ i-cache sector.\n-      __ align(32);\n+    \/\/ Set DSCR pre-fetch to deepest.\n+    if (VM_Version::has_mfdscr()) {\n+      __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n+      __ mtdscr(tmp2);\n+    }\n+    __ li(tmp1, 16);\n@@ -1611,10 +1546,4 @@\n-      __ bind(l_7);\n-      \/\/ Use loop with VSX load\/store instructions to\n-      \/\/ copy 8 elements a time.\n-      __ lxvd2x(tmp_vsr1, R3_ARG1);        \/\/ Load src\n-      __ stxvd2x(tmp_vsr1, R4_ARG2);       \/\/ Store to dst\n-      __ lxvd2x(tmp_vsr2, tmp1, R3_ARG1);  \/\/ Load src + 16\n-      __ stxvd2x(tmp_vsr2, tmp1, R4_ARG2); \/\/ Store to dst + 16\n-      __ addi(R3_ARG1, R3_ARG1, 32);       \/\/ Update src+=32\n-      __ addi(R4_ARG2, R4_ARG2, 32);       \/\/ Update dsc+=32\n-      __ bdnz(l_7);                        \/\/ Dec CTR and loop if not zero.\n+    \/\/ Backbranch target aligned to 32-byte. Not 16-byte align as\n+    \/\/ loop contains < 8 instructions that fit inside a single\n+    \/\/ i-cache sector.\n+    __ align(32);\n@@ -1622,5 +1551,16 @@\n-      \/\/ Restore DSCR pre-fetch value.\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n-        __ mtdscr(tmp2);\n-      }\n+    __ bind(l_7);\n+    \/\/ Use loop with VSX load\/store instructions to\n+    \/\/ copy 8 elements a time.\n+    __ lxvd2x(tmp_vsr1, R3_ARG1);        \/\/ Load src\n+    __ stxvd2x(tmp_vsr1, R4_ARG2);       \/\/ Store to dst\n+    __ lxvd2x(tmp_vsr2, tmp1, R3_ARG1);  \/\/ Load src + 16\n+    __ stxvd2x(tmp_vsr2, tmp1, R4_ARG2); \/\/ Store to dst + 16\n+    __ addi(R3_ARG1, R3_ARG1, 32);       \/\/ Update src+=32\n+    __ addi(R4_ARG2, R4_ARG2, 32);       \/\/ Update dsc+=32\n+    __ bdnz(l_7);                        \/\/ Dec CTR and loop if not zero.\n+\n+    \/\/ Restore DSCR pre-fetch value.\n+    if (VM_Version::has_mfdscr()) {\n+      __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n+      __ mtdscr(tmp2);\n+    }\n@@ -1628,1 +1568,0 @@\n-    } \/\/ VSX\n@@ -1659,1 +1598,1 @@\n-  address generate_disjoint_int_copy(StubGenStubId stub_id) {\n+  address generate_disjoint_int_copy(StubId stub_id) {\n@@ -1662,1 +1601,1 @@\n-    case jint_disjoint_arraycopy_id:\n+    case StubId::stubgen_jint_disjoint_arraycopy_id:\n@@ -1665,1 +1604,1 @@\n-    case arrayof_jint_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jint_disjoint_arraycopy_id:\n@@ -1743,17 +1682,1 @@\n-     if (!VM_Version::has_vsx()) {\n-      __ bind(l_4);\n-      \/\/ Use unrolled version for mass copying (copy 4 elements a time).\n-      \/\/ Load feeding store gets zero latency on Power6, however not on Power5.\n-      \/\/ Therefore, the following sequence is made for the good of both.\n-      __ addi(R3_ARG1, R3_ARG1, -32);\n-      __ addi(R4_ARG2, R4_ARG2, -32);\n-      __ ld(tmp4, 24, R3_ARG1);\n-      __ ld(tmp3, 16, R3_ARG1);\n-      __ ld(tmp2, 8, R3_ARG1);\n-      __ ld(tmp1, 0, R3_ARG1);\n-      __ std(tmp4, 24, R4_ARG2);\n-      __ std(tmp3, 16, R4_ARG2);\n-      __ std(tmp2, 8, R4_ARG2);\n-      __ std(tmp1, 0, R4_ARG2);\n-      __ bdnz(l_4);\n-     } else {  \/\/ Processor supports VSX, so use it to mass copy.\n+      \/\/ Processor supports VSX, so use it to mass copy.\n@@ -1763,1 +1686,1 @@\n-      \/\/ If supported set DSCR pre-fetch to deepest.\n+      \/\/ Set DSCR pre-fetch to deepest.\n@@ -1768,1 +1691,0 @@\n-\n@@ -1792,1 +1714,0 @@\n-     }\n@@ -1818,1 +1739,1 @@\n-  address generate_conjoint_int_copy(StubGenStubId stub_id) {\n+  address generate_conjoint_int_copy(StubId stub_id) {\n@@ -1821,1 +1742,1 @@\n-    case jint_arraycopy_id:\n+    case StubId::stubgen_jint_arraycopy_id:\n@@ -1824,1 +1745,1 @@\n-    case arrayof_jint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jint_arraycopy_id:\n@@ -1879,18 +1800,1 @@\n-    if (!VM_Version::has_vsx()) {\n-      __ bind(l_4);\n-      \/\/ Use unrolled version for mass copying (copy 4 elements a time).\n-      \/\/ Load feeding store gets zero latency on Power6, however not on Power5.\n-      \/\/ Therefore, the following sequence is made for the good of both.\n-      __ ld(tmp1, 0, R3_ARG1);\n-      __ ld(tmp2, 8, R3_ARG1);\n-      __ ld(tmp3, 16, R3_ARG1);\n-      __ ld(tmp4, 24, R3_ARG1);\n-      __ std(tmp1, 0, R4_ARG2);\n-      __ std(tmp2, 8, R4_ARG2);\n-      __ std(tmp3, 16, R4_ARG2);\n-      __ std(tmp4, 24, R4_ARG2);\n-      __ addi(R3_ARG1, R3_ARG1, 32);\n-      __ addi(R4_ARG2, R4_ARG2, 32);\n-      __ bdnz(l_4);\n-\n-    } else { \/\/ Processor supports VSX, so use it to mass copy.\n+      \/\/ Processor supports VSX, so use it to mass copy.\n@@ -1901,1 +1805,1 @@\n-      \/\/ If supported set DSCR pre-fetch to deepest.\n+      \/\/ Set DSCR pre-fetch to deepest.\n@@ -1906,1 +1810,0 @@\n-\n@@ -1931,1 +1834,0 @@\n-    } \/\/ VSX\n@@ -1961,1 +1863,1 @@\n-  address generate_disjoint_long_copy(StubGenStubId stub_id) {\n+  address generate_disjoint_long_copy(StubId stub_id) {\n@@ -1964,1 +1866,1 @@\n-    case jlong_disjoint_arraycopy_id:\n+    case StubId::stubgen_jlong_disjoint_arraycopy_id:\n@@ -1967,1 +1869,1 @@\n-    case arrayof_jlong_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id:\n@@ -2024,17 +1926,1 @@\n-     if (!VM_Version::has_vsx()) {\n-      __ bind(l_4);\n-      \/\/ Use unrolled version for mass copying (copy 4 elements a time).\n-      \/\/ Load feeding store gets zero latency on Power6, however not on Power5.\n-      \/\/ Therefore, the following sequence is made for the good of both.\n-      __ addi(R3_ARG1, R3_ARG1, -32);\n-      __ addi(R4_ARG2, R4_ARG2, -32);\n-      __ ld(tmp4, 24, R3_ARG1);\n-      __ ld(tmp3, 16, R3_ARG1);\n-      __ ld(tmp2, 8, R3_ARG1);\n-      __ ld(tmp1, 0, R3_ARG1);\n-      __ std(tmp4, 24, R4_ARG2);\n-      __ std(tmp3, 16, R4_ARG2);\n-      __ std(tmp2, 8, R4_ARG2);\n-      __ std(tmp1, 0, R4_ARG2);\n-      __ bdnz(l_4);\n-     } else { \/\/ Processor supports VSX, so use it to mass copy.\n+      \/\/ Processor supports VSX, so use it to mass copy.\n@@ -2044,1 +1930,1 @@\n-      \/\/ If supported set DSCR pre-fetch to deepest.\n+      \/\/ Set DSCR pre-fetch to deepest.\n@@ -2049,1 +1935,0 @@\n-\n@@ -2073,1 +1958,0 @@\n-     }\n@@ -2099,1 +1983,1 @@\n-  address generate_conjoint_long_copy(StubGenStubId stub_id) {\n+  address generate_conjoint_long_copy(StubId stub_id) {\n@@ -2102,1 +1986,1 @@\n-    case jlong_arraycopy_id:\n+    case StubId::stubgen_jlong_arraycopy_id:\n@@ -2105,1 +1989,1 @@\n-    case arrayof_jlong_arraycopy_id:\n+    case StubId::stubgen_arrayof_jlong_arraycopy_id:\n@@ -2140,1 +2024,1 @@\n-  address generate_conjoint_oop_copy(StubGenStubId stub_id) {\n+  address generate_conjoint_oop_copy(StubId stub_id) {\n@@ -2144,1 +2028,1 @@\n-    case oop_arraycopy_id:\n+    case StubId::stubgen_oop_arraycopy_id:\n@@ -2148,1 +2032,1 @@\n-    case arrayof_oop_arraycopy_id:\n+    case StubId::stubgen_arrayof_oop_arraycopy_id:\n@@ -2152,1 +2036,1 @@\n-    case oop_arraycopy_uninit_id:\n+    case StubId::stubgen_oop_arraycopy_uninit_id:\n@@ -2156,1 +2040,1 @@\n-    case arrayof_oop_arraycopy_uninit_id:\n+    case StubId::stubgen_arrayof_oop_arraycopy_uninit_id:\n@@ -2211,1 +2095,1 @@\n-  address generate_disjoint_oop_copy(StubGenStubId stub_id) {\n+  address generate_disjoint_oop_copy(StubId stub_id) {\n@@ -2215,1 +2099,1 @@\n-    case oop_disjoint_arraycopy_id:\n+    case StubId::stubgen_oop_disjoint_arraycopy_id:\n@@ -2219,1 +2103,1 @@\n-    case arrayof_oop_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_oop_disjoint_arraycopy_id:\n@@ -2223,1 +2107,1 @@\n-    case oop_disjoint_arraycopy_uninit_id:\n+    case StubId::stubgen_oop_disjoint_arraycopy_uninit_id:\n@@ -2227,1 +2111,1 @@\n-    case arrayof_oop_disjoint_arraycopy_uninit_id:\n+    case StubId::stubgen_arrayof_oop_disjoint_arraycopy_uninit_id:\n@@ -2303,1 +2187,1 @@\n-  address generate_checkcast_copy(StubGenStubId stub_id) {\n+  address generate_checkcast_copy(StubId stub_id) {\n@@ -2319,1 +2203,1 @@\n-    case checkcast_arraycopy_id:\n+    case StubId::stubgen_checkcast_arraycopy_id:\n@@ -2322,1 +2206,1 @@\n-    case checkcast_arraycopy_uninit_id:\n+    case StubId::stubgen_checkcast_arraycopy_uninit_id:\n@@ -2461,1 +2345,1 @@\n-    StubGenStubId stub_id = StubGenStubId::unsafe_arraycopy_id;\n+    StubId stub_id = StubId::stubgen_unsafe_arraycopy_id;\n@@ -2574,1 +2458,1 @@\n-    StubCodeMark mark(this, StubGenStubId::unsafe_setmemory_id);\n+    StubCodeMark mark(this, StubId::stubgen_unsafe_setmemory_id);\n@@ -2667,1 +2551,1 @@\n-    StubGenStubId stub_id = StubGenStubId::generic_arraycopy_id;\n+    StubId stub_id = StubId::stubgen_generic_arraycopy_id;\n@@ -2870,1 +2754,1 @@\n-    StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+    StubId stub_id = StubId::stubgen_aescrypt_encryptBlock_id;\n@@ -3078,1 +2962,1 @@\n-    StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+    StubId stub_id = StubId::stubgen_aescrypt_decryptBlock_id;\n@@ -3316,1 +3200,1 @@\n-  address generate_sha256_implCompress(StubGenStubId stub_id) {\n+  address generate_sha256_implCompress(StubId stub_id) {\n@@ -3320,1 +3204,1 @@\n-    case sha256_implCompress_id:\n+    case StubId::stubgen_sha256_implCompress_id:\n@@ -3323,1 +3207,1 @@\n-    case sha256_implCompressMB_id:\n+    case StubId::stubgen_sha256_implCompressMB_id:\n@@ -3338,1 +3222,1 @@\n-  address generate_sha512_implCompress(StubGenStubId stub_id) {\n+  address generate_sha512_implCompress(StubId stub_id) {\n@@ -3342,1 +3226,1 @@\n-    case sha512_implCompress_id:\n+    case StubId::stubgen_sha512_implCompress_id:\n@@ -3345,1 +3229,1 @@\n-    case sha512_implCompressMB_id:\n+    case StubId::stubgen_sha512_implCompressMB_id:\n@@ -3362,1 +3246,1 @@\n-    StubGenStubId stub_id = StubGenStubId::data_cache_writeback_id;\n+    StubId stub_id = StubId::stubgen_data_cache_writeback_id;\n@@ -3376,1 +3260,1 @@\n-    StubGenStubId stub_id = StubGenStubId::data_cache_writeback_sync_id;\n+    StubId stub_id = StubId::stubgen_data_cache_writeback_sync_id;\n@@ -3397,6 +3281,6 @@\n-    StubRoutines::_jbyte_disjoint_arraycopy       = generate_disjoint_byte_copy(StubGenStubId::jbyte_disjoint_arraycopy_id);\n-    StubRoutines::_jshort_disjoint_arraycopy      = generate_disjoint_short_copy(StubGenStubId::jshort_disjoint_arraycopy_id);\n-    StubRoutines::_jint_disjoint_arraycopy        = generate_disjoint_int_copy(StubGenStubId::jint_disjoint_arraycopy_id);\n-    StubRoutines::_jlong_disjoint_arraycopy       = generate_disjoint_long_copy(StubGenStubId::jlong_disjoint_arraycopy_id);\n-    StubRoutines::_oop_disjoint_arraycopy         = generate_disjoint_oop_copy(StubGenStubId::oop_disjoint_arraycopy_id);\n-    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_oop_copy(StubGenStubId::oop_disjoint_arraycopy_uninit_id);\n+    StubRoutines::_jbyte_disjoint_arraycopy       = generate_disjoint_byte_copy(StubId::stubgen_jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_jshort_disjoint_arraycopy      = generate_disjoint_short_copy(StubId::stubgen_jshort_disjoint_arraycopy_id);\n+    StubRoutines::_jint_disjoint_arraycopy        = generate_disjoint_int_copy(StubId::stubgen_jint_disjoint_arraycopy_id);\n+    StubRoutines::_jlong_disjoint_arraycopy       = generate_disjoint_long_copy(StubId::stubgen_jlong_disjoint_arraycopy_id);\n+    StubRoutines::_oop_disjoint_arraycopy         = generate_disjoint_oop_copy(StubId::stubgen_oop_disjoint_arraycopy_id);\n+    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_oop_copy(StubId::stubgen_oop_disjoint_arraycopy_uninit_id);\n@@ -3405,6 +3289,6 @@\n-    StubRoutines::_arrayof_jbyte_disjoint_arraycopy      = generate_disjoint_byte_copy(StubGenStubId::arrayof_jbyte_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_jshort_disjoint_arraycopy     = generate_disjoint_short_copy(StubGenStubId::arrayof_jshort_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_jint_disjoint_arraycopy       = generate_disjoint_int_copy(StubGenStubId::arrayof_jint_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_jlong_disjoint_arraycopy      = generate_disjoint_long_copy(StubGenStubId::arrayof_jlong_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_oop_disjoint_arraycopy        = generate_disjoint_oop_copy(StubGenStubId::arrayof_oop_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy(StubGenStubId::oop_disjoint_arraycopy_uninit_id);\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy      = generate_disjoint_byte_copy(StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy     = generate_disjoint_short_copy(StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy       = generate_disjoint_int_copy(StubId::stubgen_arrayof_jint_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy      = generate_disjoint_long_copy(StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy        = generate_disjoint_oop_copy(StubId::stubgen_arrayof_oop_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy(StubId::stubgen_oop_disjoint_arraycopy_uninit_id);\n@@ -3413,6 +3297,6 @@\n-    StubRoutines::_jbyte_arraycopy      = generate_conjoint_byte_copy(StubGenStubId::jbyte_arraycopy_id);\n-    StubRoutines::_jshort_arraycopy     = generate_conjoint_short_copy(StubGenStubId::jshort_arraycopy_id);\n-    StubRoutines::_jint_arraycopy       = generate_conjoint_int_copy(StubGenStubId::jint_arraycopy_id);\n-    StubRoutines::_jlong_arraycopy      = generate_conjoint_long_copy(StubGenStubId::jlong_arraycopy_id);\n-    StubRoutines::_oop_arraycopy        = generate_conjoint_oop_copy(StubGenStubId::oop_arraycopy_id);\n-    StubRoutines::_oop_arraycopy_uninit = generate_conjoint_oop_copy(StubGenStubId::oop_arraycopy_uninit_id);\n+    StubRoutines::_jbyte_arraycopy      = generate_conjoint_byte_copy(StubId::stubgen_jbyte_arraycopy_id);\n+    StubRoutines::_jshort_arraycopy     = generate_conjoint_short_copy(StubId::stubgen_jshort_arraycopy_id);\n+    StubRoutines::_jint_arraycopy       = generate_conjoint_int_copy(StubId::stubgen_jint_arraycopy_id);\n+    StubRoutines::_jlong_arraycopy      = generate_conjoint_long_copy(StubId::stubgen_jlong_arraycopy_id);\n+    StubRoutines::_oop_arraycopy        = generate_conjoint_oop_copy(StubId::stubgen_oop_arraycopy_id);\n+    StubRoutines::_oop_arraycopy_uninit = generate_conjoint_oop_copy(StubId::stubgen_oop_arraycopy_uninit_id);\n@@ -3421,6 +3305,6 @@\n-    StubRoutines::_arrayof_jbyte_arraycopy      = generate_conjoint_byte_copy(StubGenStubId::arrayof_jbyte_arraycopy_id);\n-    StubRoutines::_arrayof_jshort_arraycopy     = generate_conjoint_short_copy(StubGenStubId::arrayof_jshort_arraycopy_id);\n-    StubRoutines::_arrayof_jint_arraycopy       = generate_conjoint_int_copy(StubGenStubId::arrayof_jint_arraycopy_id);\n-    StubRoutines::_arrayof_jlong_arraycopy      = generate_conjoint_long_copy(StubGenStubId::arrayof_jlong_arraycopy_id);\n-    StubRoutines::_arrayof_oop_arraycopy        = generate_conjoint_oop_copy(StubGenStubId::arrayof_oop_arraycopy_id);\n-    StubRoutines::_arrayof_oop_arraycopy_uninit = generate_conjoint_oop_copy(StubGenStubId::arrayof_oop_arraycopy_id);\n+    StubRoutines::_arrayof_jbyte_arraycopy      = generate_conjoint_byte_copy(StubId::stubgen_arrayof_jbyte_arraycopy_id);\n+    StubRoutines::_arrayof_jshort_arraycopy     = generate_conjoint_short_copy(StubId::stubgen_arrayof_jshort_arraycopy_id);\n+    StubRoutines::_arrayof_jint_arraycopy       = generate_conjoint_int_copy(StubId::stubgen_arrayof_jint_arraycopy_id);\n+    StubRoutines::_arrayof_jlong_arraycopy      = generate_conjoint_long_copy(StubId::stubgen_arrayof_jlong_arraycopy_id);\n+    StubRoutines::_arrayof_oop_arraycopy        = generate_conjoint_oop_copy(StubId::stubgen_arrayof_oop_arraycopy_id);\n+    StubRoutines::_arrayof_oop_arraycopy_uninit = generate_conjoint_oop_copy(StubId::stubgen_arrayof_oop_arraycopy_id);\n@@ -3429,2 +3313,2 @@\n-    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_id);\n-    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_uninit_id);\n+    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubId::stubgen_checkcast_arraycopy_id);\n+    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubId::stubgen_checkcast_arraycopy_uninit_id);\n@@ -3447,6 +3331,6 @@\n-      StubRoutines::_jbyte_fill          = generate_fill(StubGenStubId::jbyte_fill_id);\n-      StubRoutines::_jshort_fill         = generate_fill(StubGenStubId::jshort_fill_id);\n-      StubRoutines::_jint_fill           = generate_fill(StubGenStubId::jint_fill_id);\n-      StubRoutines::_arrayof_jbyte_fill  = generate_fill(StubGenStubId::arrayof_jbyte_fill_id);\n-      StubRoutines::_arrayof_jshort_fill = generate_fill(StubGenStubId::arrayof_jshort_fill_id);\n-      StubRoutines::_arrayof_jint_fill   = generate_fill(StubGenStubId::arrayof_jint_fill_id);\n+      StubRoutines::_jbyte_fill          = generate_fill(StubId::stubgen_jbyte_fill_id);\n+      StubRoutines::_jshort_fill         = generate_fill(StubId::stubgen_jshort_fill_id);\n+      StubRoutines::_jint_fill           = generate_fill(StubId::stubgen_jint_fill_id);\n+      StubRoutines::_arrayof_jbyte_fill  = generate_fill(StubId::stubgen_arrayof_jbyte_fill_id);\n+      StubRoutines::_arrayof_jshort_fill = generate_fill(StubId::stubgen_arrayof_jshort_fill_id);\n+      StubRoutines::_arrayof_jint_fill   = generate_fill(StubId::stubgen_arrayof_jint_fill_id);\n@@ -3471,1 +3355,1 @@\n-    StubGenStubId stub_id = StubGenStubId::multiplyToLen_id;\n+    StubId stub_id = StubId::stubgen_multiplyToLen_id;\n@@ -3548,1 +3432,1 @@\n-    StubGenStubId stub_id = StubGenStubId::mulAdd_id;\n+    StubId stub_id = StubId::stubgen_mulAdd_id;\n@@ -3579,1 +3463,1 @@\n-    StubGenStubId stub_id = StubGenStubId::squareToLen_id;\n+    StubId stub_id = StubId::stubgen_squareToLen_id;\n@@ -3813,1 +3697,1 @@\n-  address generate_CRC32_updateBytes(StubGenStubId stub_id) {\n+  address generate_CRC32_updateBytes(StubId stub_id) {\n@@ -3816,1 +3700,1 @@\n-    case updateBytesCRC32_id:\n+    case StubId::stubgen_updateBytesCRC32_id:\n@@ -3819,1 +3703,1 @@\n-    case updateBytesCRC32C_id:\n+    case StubId::stubgen_updateBytesCRC32C_id:\n@@ -3853,1 +3737,1 @@\n-    StubGenStubId stub_id = StubGenStubId::method_entry_barrier_id;\n+    StubId stub_id = StubId::stubgen_method_entry_barrier_id;\n@@ -3951,1 +3835,1 @@\n-    StubGenStubId stub_id = StubGenStubId::base64_decodeBlock_id;\n+    StubId stub_id = StubId::stubgen_base64_decodeBlock_id;\n@@ -4540,1 +4424,1 @@\n-    StubGenStubId stub_id = StubGenStubId::base64_encodeBlock_id;\n+    StubId stub_id = StubId::stubgen_base64_encodeBlock_id;\n@@ -4831,1 +4715,1 @@\n-    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n+    StubId stub_id = StubId::stubgen_lookup_secondary_supers_table_id;\n@@ -4854,1 +4738,1 @@\n-    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_slow_path_id;\n+    StubId stub_id = StubId::stubgen_lookup_secondary_supers_table_slow_path_id;\n@@ -4872,1 +4756,1 @@\n-  address generate_cont_thaw(StubGenStubId stub_id) {\n+  address generate_cont_thaw(StubId stub_id) {\n@@ -4880,1 +4764,1 @@\n-    case cont_thaw_id:\n+    case StubId::stubgen_cont_thaw_id:\n@@ -4885,1 +4769,1 @@\n-    case cont_returnBarrier_id:\n+    case StubId::stubgen_cont_returnBarrier_id:\n@@ -4890,1 +4774,1 @@\n-    case cont_returnBarrierExc_id:\n+    case StubId::stubgen_cont_returnBarrierExc_id:\n@@ -4987,1 +4871,1 @@\n-    return generate_cont_thaw(StubGenStubId::cont_thaw_id);\n+    return generate_cont_thaw(StubId::stubgen_cont_thaw_id);\n@@ -4993,1 +4877,1 @@\n-    return generate_cont_thaw(StubGenStubId::cont_returnBarrier_id);\n+    return generate_cont_thaw(StubId::stubgen_cont_returnBarrier_id);\n@@ -4997,1 +4881,1 @@\n-    return generate_cont_thaw(StubGenStubId::cont_returnBarrierExc_id);\n+    return generate_cont_thaw(StubId::stubgen_cont_returnBarrierExc_id);\n@@ -5002,1 +4886,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cont_preempt_id;\n+    StubId stub_id = StubId::stubgen_cont_preempt_id;\n@@ -5038,1 +4922,1 @@\n-    StubGenStubId stub_id = StubGenStubId::upcall_stub_exception_handler_id;\n+    StubId stub_id = StubId::stubgen_upcall_stub_exception_handler_id;\n@@ -5057,1 +4941,1 @@\n-    StubGenStubId stub_id = StubGenStubId::upcall_stub_load_target_id;\n+    StubId stub_id = StubId::stubgen_upcall_stub_load_target_id;\n@@ -5078,0 +4962,4 @@\n+  void generate_preuniverse_stubs() {\n+    \/\/ preuniverse stubs are not needed for ppc\n+  }\n+\n@@ -5098,1 +4986,1 @@\n-      StubRoutines::_updateBytesCRC32 = generate_CRC32_updateBytes(StubGenStubId::updateBytesCRC32_id);\n+      StubRoutines::_updateBytesCRC32 = generate_CRC32_updateBytes(StubId::stubgen_updateBytesCRC32_id);\n@@ -5104,1 +4992,1 @@\n-      StubRoutines::_updateBytesCRC32C = generate_CRC32_updateBytes(StubGenStubId::updateBytesCRC32C_id);\n+      StubRoutines::_updateBytesCRC32C = generate_CRC32_updateBytes(StubId::stubgen_updateBytesCRC32C_id);\n@@ -5186,2 +5074,2 @@\n-      StubRoutines::_sha256_implCompress   = generate_sha256_implCompress(StubGenStubId::sha256_implCompress_id);\n-      StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(StubGenStubId::sha256_implCompressMB_id);\n+      StubRoutines::_sha256_implCompress   = generate_sha256_implCompress(StubId::stubgen_sha256_implCompress_id);\n+      StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(StubId::stubgen_sha256_implCompressMB_id);\n@@ -5190,2 +5078,2 @@\n-      StubRoutines::_sha512_implCompress   = generate_sha512_implCompress(StubGenStubId::sha512_implCompress_id);\n-      StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(StubGenStubId::sha512_implCompressMB_id);\n+      StubRoutines::_sha512_implCompress   = generate_sha512_implCompress(StubId::stubgen_sha512_implCompress_id);\n+      StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(StubId::stubgen_sha512_implCompressMB_id);\n@@ -5205,1 +5093,1 @@\n-  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+  StubGenerator(CodeBuffer* code, BlobId blob_id) : StubCodeGenerator(code, blob_id) {\n@@ -5207,1 +5095,4 @@\n-    case initial_id:\n+    case BlobId::stubgen_preuniverse_id:\n+      generate_preuniverse_stubs();\n+      break;\n+    case BlobId::stubgen_initial_id:\n@@ -5210,1 +5101,1 @@\n-     case continuation_id:\n+    case BlobId::stubgen_continuation_id:\n@@ -5213,1 +5104,1 @@\n-    case compiler_id:\n+    case BlobId::stubgen_compiler_id:\n@@ -5216,1 +5107,1 @@\n-    case final_id:\n+    case BlobId::stubgen_final_id:\n@@ -5220,1 +5111,1 @@\n-      fatal(\"unexpected blob id: %d\", blob_id);\n+      fatal(\"unexpected blob id: %s\", StubInfo::name(blob_id));\n@@ -5226,1 +5117,1 @@\n-void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+void StubGenerator_generate(CodeBuffer* code, BlobId blob_id) {\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":178,"deletions":287,"binary":false,"changes":465,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::counter_overflow_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_counter_overflow_id)));\n@@ -69,1 +69,1 @@\n-    address a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+    address a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -82,1 +82,1 @@\n-  C1StubId stub_id;\n+  StubId stub_id;\n@@ -84,1 +84,1 @@\n-    stub_id = C1StubId::throw_index_exception_id;\n+    stub_id = StubId::c1_throw_index_exception_id;\n@@ -88,1 +88,1 @@\n-    stub_id = C1StubId::throw_range_check_failed_id;\n+    stub_id = StubId::c1_throw_range_check_failed_id;\n@@ -104,1 +104,1 @@\n-  address a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+  address a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -116,1 +116,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::throw_div0_exception_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_throw_div0_exception_id)));\n@@ -125,1 +125,1 @@\n-NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, C1StubId stub_id) {\n+NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, StubId stub_id) {\n@@ -130,3 +130,3 @@\n-  assert(stub_id == C1StubId::new_instance_id                 ||\n-         stub_id == C1StubId::fast_new_instance_id            ||\n-         stub_id == C1StubId::fast_new_instance_init_check_id,\n+  assert(stub_id == StubId::c1_new_instance_id                 ||\n+         stub_id == StubId::c1_fast_new_instance_id            ||\n+         stub_id == StubId::c1_fast_new_instance_init_check_id,\n@@ -161,1 +161,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::new_type_array_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_new_type_array_id)));\n@@ -181,1 +181,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::new_object_array_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_new_object_array_id)));\n@@ -193,1 +193,1 @@\n-  C1StubId enter_id;\n+  StubId enter_id;\n@@ -195,1 +195,1 @@\n-    enter_id = C1StubId::monitorenter_id;\n+    enter_id = StubId::c1_monitorenter_id;\n@@ -197,1 +197,1 @@\n-    enter_id = C1StubId::monitorenter_nofpu_id;\n+    enter_id = StubId::c1_monitorenter_nofpu_id;\n@@ -213,1 +213,1 @@\n-  C1StubId exit_id;\n+  StubId exit_id;\n@@ -215,1 +215,1 @@\n-    exit_id = C1StubId::monitorexit_id;\n+    exit_id = StubId::c1_monitorexit_id;\n@@ -217,1 +217,1 @@\n-    exit_id = C1StubId::monitorexit_nofpu_id;\n+    exit_id = StubId::c1_monitorexit_nofpu_id;\n@@ -242,1 +242,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::deoptimize_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_deoptimize_id)));\n@@ -251,1 +251,1 @@\n-    a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+    a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -253,1 +253,1 @@\n-    a = Runtime1::entry_for(C1StubId::throw_null_pointer_exception_id);\n+    a = Runtime1::entry_for(StubId::c1_throw_null_pointer_exception_id);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_CodeStubs_riscv.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -228,1 +228,1 @@\n-    __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+    __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_arraycopy_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -307,1 +307,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::handle_exception_from_callee_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_handle_exception_from_callee_id)));\n@@ -363,1 +363,1 @@\n-  __ far_jump(RuntimeAddress(Runtime1::entry_for(C1StubId::unwind_exception_id)));\n+  __ far_jump(RuntimeAddress(Runtime1::entry_for(StubId::c1_unwind_exception_id)));\n@@ -404,1 +404,1 @@\n-  __ safepoint_poll(*code_stub->entry(), true \/* at_return *\/, false \/* acquire *\/, true \/* in_nmethod *\/);\n+  __ safepoint_poll(*code_stub->entry(), true \/* at_return *\/, true \/* in_nmethod *\/);\n@@ -1099,1 +1099,1 @@\n-      __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+      __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n@@ -1114,1 +1114,1 @@\n-    __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+    __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n@@ -1402,1 +1402,1 @@\n-  C1StubId unwind_id;\n+  StubId unwind_id;\n@@ -1421,1 +1421,1 @@\n-    unwind_id = C1StubId::handle_exception_id;\n+    unwind_id = StubId::c1_handle_exception_id;\n@@ -1423,1 +1423,1 @@\n-    unwind_id = C1StubId::handle_exception_nofpu_id;\n+    unwind_id = StubId::c1_handle_exception_nofpu_id;\n@@ -2056,1 +2056,1 @@\n-      target = Runtime1::entry_for(C1StubId::access_field_patching_id);\n+      target = Runtime1::entry_for(StubId::c1_access_field_patching_id);\n@@ -2059,1 +2059,1 @@\n-      target = Runtime1::entry_for(C1StubId::load_klass_patching_id);\n+      target = Runtime1::entry_for(StubId::c1_load_klass_patching_id);\n@@ -2062,1 +2062,1 @@\n-      target = Runtime1::entry_for(C1StubId::load_mirror_patching_id);\n+      target = Runtime1::entry_for(StubId::c1_load_mirror_patching_id);\n@@ -2065,1 +2065,1 @@\n-      target = Runtime1::entry_for(C1StubId::load_appendix_patching_id);\n+      target = Runtime1::entry_for(StubId::c1_load_appendix_patching_id);\n@@ -2154,1 +2154,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1032,1 +1032,1 @@\n-  __ call_runtime(Runtime1::entry_for(C1StubId::new_multi_array_id),\n+  __ call_runtime(Runtime1::entry_for(StubId::c1_new_multi_array_id),\n@@ -1064,1 +1064,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr,\n+    stub = new SimpleExceptionStub(StubId::c1_throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr,\n@@ -1072,1 +1072,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_class_cast_exception_id, obj.result(), info_for_exception);\n+    stub = new SimpleExceptionStub(StubId::c1_throw_class_cast_exception_id, obj.result(), info_for_exception);\n@@ -1107,1 +1107,1 @@\n-  return Runtime1::entry_for(C1StubId::is_instance_of_id);\n+  return Runtime1::entry_for(StubId::c1_is_instance_of_id);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRGenerator_riscv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-    far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::dtrace_object_alloc_id)));\n+    far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_dtrace_object_alloc_id)));\n@@ -324,1 +324,1 @@\n-    far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::dtrace_object_alloc_id)));\n+    far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_dtrace_object_alloc_id)));\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-    } else if (_stub_id == (int)C1StubId::forward_exception_id) {\n+    } else if (_stub_id == (int)StubId::c1_forward_exception_id) {\n@@ -103,1 +103,1 @@\n-      far_jump(RuntimeAddress(Runtime1::entry_for(C1StubId::forward_exception_id)));\n+      far_jump(RuntimeAddress(Runtime1::entry_for(StubId::c1_forward_exception_id)));\n@@ -373,2 +373,2 @@\n-  assert(cb == Runtime1::blob_for(C1StubId::monitorenter_id) ||\n-         cb == Runtime1::blob_for(C1StubId::monitorenter_nofpu_id), \"must be\");\n+  assert(cb == Runtime1::blob_for(StubId::c1_monitorenter_id) ||\n+         cb == Runtime1::blob_for(StubId::c1_monitorenter_nofpu_id), \"must be\");\n@@ -402,1 +402,1 @@\n-OopMapSet* Runtime1::generate_handle_exception(C1StubId id, StubAssembler *sasm) {\n+OopMapSet* Runtime1::generate_handle_exception(StubId id, StubAssembler *sasm) {\n@@ -414,1 +414,1 @@\n-    case C1StubId::forward_exception_id:\n+    case StubId::c1_forward_exception_id:\n@@ -433,2 +433,2 @@\n-    case C1StubId::handle_exception_nofpu_id:\n-    case C1StubId::handle_exception_id:\n+    case StubId::c1_handle_exception_nofpu_id:\n+    case StubId::c1_handle_exception_id:\n@@ -436,1 +436,1 @@\n-      oop_map = save_live_registers(sasm, id != C1StubId::handle_exception_nofpu_id);\n+      oop_map = save_live_registers(sasm, id != StubId::c1_handle_exception_nofpu_id);\n@@ -438,1 +438,1 @@\n-    case C1StubId::handle_exception_from_callee_id: {\n+    case StubId::c1_handle_exception_from_callee_id: {\n@@ -495,3 +495,3 @@\n-    case C1StubId::forward_exception_id:\n-    case C1StubId::handle_exception_nofpu_id:\n-    case C1StubId::handle_exception_id:\n+    case StubId::c1_forward_exception_id:\n+    case StubId::c1_handle_exception_nofpu_id:\n+    case StubId::c1_handle_exception_id:\n@@ -499,1 +499,1 @@\n-      restore_live_registers(sasm, id != C1StubId::handle_exception_nofpu_id);\n+      restore_live_registers(sasm, id != StubId::c1_handle_exception_nofpu_id);\n@@ -501,1 +501,1 @@\n-    case C1StubId::handle_exception_from_callee_id:\n+    case StubId::c1_handle_exception_from_callee_id:\n@@ -647,1 +647,1 @@\n-OopMapSet* Runtime1::generate_code_for(C1StubId id, StubAssembler* sasm) {\n+OopMapSet* Runtime1::generate_code_for(StubId id, StubAssembler* sasm) {\n@@ -658,1 +658,1 @@\n-    case C1StubId::forward_exception_id:\n+    case StubId::c1_forward_exception_id:\n@@ -666,1 +666,1 @@\n-    case C1StubId::throw_div0_exception_id:\n+    case StubId::c1_throw_div0_exception_id:\n@@ -673,1 +673,1 @@\n-    case C1StubId::throw_null_pointer_exception_id:\n+    case StubId::c1_throw_null_pointer_exception_id:\n@@ -679,3 +679,3 @@\n-    case C1StubId::new_instance_id:\n-    case C1StubId::fast_new_instance_id:\n-    case C1StubId::fast_new_instance_init_check_id:\n+    case StubId::c1_new_instance_id:\n+    case StubId::c1_fast_new_instance_id:\n+    case StubId::c1_fast_new_instance_init_check_id:\n@@ -686,1 +686,1 @@\n-        if (id == C1StubId::new_instance_id) {\n+        if (id == StubId::c1_new_instance_id) {\n@@ -688,1 +688,1 @@\n-        } else if (id == C1StubId::fast_new_instance_id) {\n+        } else if (id == StubId::c1_fast_new_instance_id) {\n@@ -691,1 +691,1 @@\n-          assert(id == C1StubId::fast_new_instance_init_check_id, \"bad C1StubId\");\n+          assert(id == StubId::c1_fast_new_instance_init_check_id, \"bad StubId\");\n@@ -712,1 +712,1 @@\n-    case C1StubId::counter_overflow_id:\n+    case StubId::c1_counter_overflow_id:\n@@ -736,2 +736,2 @@\n-    case C1StubId::new_type_array_id:\n-    case C1StubId::new_object_array_id:\n+    case StubId::c1_new_type_array_id:\n+    case StubId::c1_new_object_array_id:\n@@ -743,1 +743,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -756,1 +756,1 @@\n-          int tag = ((id == C1StubId::new_type_array_id) ? Klass::_lh_array_tag_type_value : Klass::_lh_array_tag_obj_value);\n+          int tag = ((id == StubId::c1_new_type_array_id) ? Klass::_lh_array_tag_type_value : Klass::_lh_array_tag_obj_value);\n@@ -769,1 +769,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -788,1 +788,1 @@\n-    case C1StubId::new_multi_array_id:\n+    case StubId::c1_new_multi_array_id:\n@@ -811,1 +811,1 @@\n-    case C1StubId::register_finalizer_id:\n+    case StubId::c1_register_finalizer_id:\n@@ -845,1 +845,1 @@\n-    case C1StubId::throw_class_cast_exception_id:\n+    case StubId::c1_throw_class_cast_exception_id:\n@@ -852,1 +852,1 @@\n-    case C1StubId::throw_incompatible_class_change_error_id:\n+    case StubId::c1_throw_incompatible_class_change_error_id:\n@@ -860,1 +860,1 @@\n-    case C1StubId::slow_subtype_check_id:\n+    case StubId::c1_slow_subtype_check_id:\n@@ -906,1 +906,1 @@\n-    case C1StubId::monitorenter_nofpu_id:\n+    case StubId::c1_monitorenter_nofpu_id:\n@@ -909,1 +909,1 @@\n-    case C1StubId::monitorenter_id:\n+    case StubId::c1_monitorenter_id:\n@@ -928,1 +928,1 @@\n-    case C1StubId::is_instance_of_id:\n+    case StubId::c1_is_instance_of_id:\n@@ -974,1 +974,1 @@\n-    case C1StubId::monitorexit_nofpu_id:\n+    case StubId::c1_monitorexit_nofpu_id:\n@@ -977,1 +977,1 @@\n-    case C1StubId::monitorexit_id:\n+    case StubId::c1_monitorexit_id:\n@@ -998,1 +998,1 @@\n-    case C1StubId::deoptimize_id:\n+    case StubId::c1_deoptimize_id:\n@@ -1017,1 +1017,1 @@\n-    case C1StubId::throw_range_check_failed_id:\n+    case StubId::c1_throw_range_check_failed_id:\n@@ -1024,1 +1024,1 @@\n-    case C1StubId::unwind_exception_id:\n+    case StubId::c1_unwind_exception_id:\n@@ -1033,1 +1033,1 @@\n-    case C1StubId::access_field_patching_id:\n+    case StubId::c1_access_field_patching_id:\n@@ -1041,1 +1041,1 @@\n-    case C1StubId::load_klass_patching_id:\n+    case StubId::c1_load_klass_patching_id:\n@@ -1049,1 +1049,1 @@\n-    case C1StubId::load_mirror_patching_id:\n+    case StubId::c1_load_mirror_patching_id:\n@@ -1057,1 +1057,1 @@\n-    case C1StubId::load_appendix_patching_id:\n+    case StubId::c1_load_appendix_patching_id:\n@@ -1065,2 +1065,2 @@\n-    case C1StubId::handle_exception_nofpu_id:\n-    case C1StubId::handle_exception_id:\n+    case StubId::c1_handle_exception_nofpu_id:\n+    case StubId::c1_handle_exception_id:\n@@ -1073,1 +1073,1 @@\n-    case C1StubId::handle_exception_from_callee_id:\n+    case StubId::c1_handle_exception_from_callee_id:\n@@ -1080,1 +1080,1 @@\n-    case C1StubId::throw_index_exception_id:\n+    case StubId::c1_throw_index_exception_id:\n@@ -1087,1 +1087,1 @@\n-    case C1StubId::throw_array_store_exception_id:\n+    case StubId::c1_throw_array_store_exception_id:\n@@ -1096,1 +1096,1 @@\n-    case C1StubId::predicate_failed_trap_id:\n+    case StubId::c1_predicate_failed_trap_id:\n@@ -1116,1 +1116,1 @@\n-    case C1StubId::dtrace_object_alloc_id:\n+    case StubId::c1_dtrace_object_alloc_id:\n","filename":"src\/hotspot\/cpu\/riscv\/c1_Runtime1_riscv.cpp","additions":55,"deletions":55,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -417,2 +417,2 @@\n-  if (cb == Runtime1::blob_for(C1StubId::monitorenter_id) ||\n-      cb == Runtime1::blob_for(C1StubId::monitorenter_nofpu_id)) {\n+  if (cb == Runtime1::blob_for(StubId::c1_monitorenter_id) ||\n+      cb == Runtime1::blob_for(StubId::c1_monitorenter_nofpu_id)) {\n@@ -673,1 +673,0 @@\n-  vmassert(last_Java_pc() == nullptr, \"already walkable\");\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1371,8 +1371,0 @@\n-  \/\/ insert a nop at the start of the prolog so we can patch in a\n-  \/\/ branch if we need to invalidate the method later\n-  {\n-    Assembler::IncompressibleScope scope(masm); \/\/ keep the nop as 4 bytes for patching.\n-    MacroAssembler::assert_alignment(__ pc());\n-    __ nop();  \/\/ 4 bytes\n-  }\n-\n@@ -1496,1 +1488,1 @@\n-    __ safepoint_poll(*code_stub, true \/* at_return *\/, false \/* acquire *\/, true \/* in_nmethod *\/);\n+    __ safepoint_poll(*code_stub, true \/* at_return *\/, true \/* in_nmethod *\/);\n@@ -1807,1 +1799,0 @@\n-  \/\/ Verified entry point must be properly 4 bytes aligned for patching by NativeJump::patch_verified_entry().\n@@ -1885,12 +1876,0 @@\n-    \/\/ Current test shows that, it brings performance gain when MaxVectorSize >= 32, but brings\n-    \/\/ regression when MaxVectorSize == 16. So only enable the intrinsic when MaxVectorSize >= 32.\n-    case Op_RoundVF:\n-      return UseRVV && MaxVectorSize >= 32;\n-\n-    \/\/ For double, current test shows that even with MaxVectorSize == 32, there is still some regression.\n-    \/\/ Although there is no hardware to verify it for now, from the trend of performance data on hardwares\n-    \/\/ (with vlenb == 16 and 32 respectively), it's promising to bring better performance rather than\n-    \/\/ regression for double when MaxVectorSize == 64+. So only enable the intrinsic when MaxVectorSize >= 64.\n-    case Op_RoundVD:\n-      return UseRVV && MaxVectorSize >= 64;\n-\n@@ -1920,3 +1899,0 @@\n-    case Op_FmaVF:\n-    case Op_FmaVD:\n-      return UseRVV && UseFMA;\n@@ -1936,1 +1912,1 @@\n-    case Op_SubHF:\n+    case Op_SubHF:\n@@ -2322,36 +2298,0 @@\n-  enc_class riscv_enc_cmpxchgw(iRegINoSp res, memory mem, iRegI oldval, iRegI newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int32,\n-               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n-  enc_class riscv_enc_cmpxchgn(iRegINoSp res, memory mem, iRegI oldval, iRegI newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::uint32,\n-               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n-  enc_class riscv_enc_cmpxchg(iRegINoSp res, memory mem, iRegL oldval, iRegL newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n-               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n-  enc_class riscv_enc_cmpxchgw_acq(iRegINoSp res, memory mem, iRegI oldval, iRegI newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int32,\n-               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n-  enc_class riscv_enc_cmpxchgn_acq(iRegINoSp res, memory mem, iRegI oldval, iRegI newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::uint32,\n-               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n-  enc_class riscv_enc_cmpxchg_acq(iRegINoSp res, memory mem, iRegL oldval, iRegL newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n-               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n@@ -2673,0 +2613,4 @@\n+\/\/ Whether this node is expanded during code emission into a sequence of\n+\/\/ instructions and the first instruction can perform an implicit null check.\n+ins_attrib ins_is_late_expanded_null_check_candidate(false);\n+\n@@ -5269,2 +5213,2 @@\n-instruct compareAndSwapB(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                         iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndSwapB_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n@@ -5272,0 +5216,2 @@\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5274,1 +5220,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 10 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5280,1 +5226,1 @@\n-    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapB\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapB_narrow\"\n@@ -5292,2 +5238,24 @@\n-instruct compareAndSwapS(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                         iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndSwapB(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n+%{\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (CompareAndSwapB mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"cmpxchg $mem, $oldval, $newval\\t# (byte) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapB\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+               Assembler::relaxed \/* acquire *\/, Assembler::rl \/* release *\/, $res$$Register,\n+               true \/* result as bool *\/);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndSwapS_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n@@ -5295,0 +5263,2 @@\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5297,1 +5267,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 11 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5303,1 +5273,1 @@\n-    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapS\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapS_narrow\"\n@@ -5315,0 +5285,22 @@\n+instruct compareAndSwapS(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n+%{\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (CompareAndSwapS mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"cmpxchg $mem, $oldval, $newval\\t# (short) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapS\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+               Assembler::relaxed \/* acquire *\/, Assembler::rl \/* release *\/, $res$$Register,\n+               true \/* result as bool *\/);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5319,1 +5311,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 6 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5326,1 +5318,5 @@\n-  ins_encode(riscv_enc_cmpxchgw(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int32,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5335,1 +5331,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 6 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5342,1 +5338,5 @@\n-  ins_encode(riscv_enc_cmpxchg(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5353,1 +5353,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 6 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5360,1 +5360,5 @@\n-  ins_encode(riscv_enc_cmpxchg(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5368,0 +5372,1 @@\n+\n@@ -5370,1 +5375,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 8 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5377,1 +5382,5 @@\n-  ins_encode(riscv_enc_cmpxchgn(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::uint32,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5383,2 +5392,2 @@\n-instruct compareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                            iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndSwapBAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                   iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n@@ -5386,1 +5395,1 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5390,1 +5399,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 10 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5396,1 +5405,1 @@\n-    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapBAcq\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapBAcq_narrow\"\n@@ -5408,2 +5417,1 @@\n-instruct compareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                            iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n@@ -5411,1 +5419,24 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (CompareAndSwapB mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"cmpxchg $mem, $oldval, $newval\\t# (byte) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapBAcq\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+               Assembler::aq \/* acquire *\/, Assembler::rl \/* release *\/, $res$$Register,\n+               true \/* result as bool *\/);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndSwapSAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                   iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5415,1 +5446,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 11 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5421,1 +5452,1 @@\n-    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapSAcq\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapSAcq_narrow\"\n@@ -5433,0 +5464,22 @@\n+instruct compareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n+%{\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (CompareAndSwapS mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"cmpxchg $mem, $oldval, $newval\\t# (short) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapSAcq\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+               Assembler::aq \/* acquire *\/, Assembler::rl \/* release *\/, $res$$Register,\n+               true \/* result as bool *\/);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5439,1 +5492,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 6 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5446,1 +5499,5 @@\n-  ins_encode(riscv_enc_cmpxchgw_acq(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int32,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5457,1 +5514,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 6 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5464,1 +5521,5 @@\n-  ins_encode(riscv_enc_cmpxchg_acq(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5475,1 +5536,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 6 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5482,1 +5543,5 @@\n-  ins_encode(riscv_enc_cmpxchg_acq(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5493,1 +5558,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 8 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5500,1 +5565,5 @@\n-  ins_encode(riscv_enc_cmpxchgn_acq(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::uint32,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5511,2 +5580,2 @@\n-instruct compareAndExchangeB(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                             iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndExchangeB_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                    iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n@@ -5514,0 +5583,2 @@\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5516,1 +5587,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST * 5);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5521,1 +5592,1 @@\n-    \"cmpxchg $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeB\"\n+    \"cmpxchg $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeB_narrow\"\n@@ -5533,2 +5604,22 @@\n-instruct compareAndExchangeS(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                             iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndExchangeB(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n+%{\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (CompareAndExchangeB mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"cmpxchg $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeB\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndExchangeS_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                    iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n@@ -5536,0 +5627,2 @@\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5538,1 +5631,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST * 6);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5543,1 +5636,1 @@\n-    \"cmpxchg $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeS\"\n+    \"cmpxchg $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeS_narrow\"\n@@ -5555,0 +5648,20 @@\n+instruct compareAndExchangeS(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n+%{\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (CompareAndExchangeS mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"cmpxchg $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeS\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5559,3 +5672,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST);\n-\n-  effect(TEMP_DEF res);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5579,3 +5690,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST);\n-\n-  effect(TEMP_DEF res);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5598,2 +5707,1 @@\n-  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST * 3);\n+  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));\n@@ -5602,1 +5710,1 @@\n-  effect(TEMP_DEF res);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5619,2 +5727,1 @@\n-  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST);\n+  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));\n@@ -5623,1 +5730,1 @@\n-  effect(TEMP_DEF res);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5637,2 +5744,2 @@\n-instruct compareAndExchangeBAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                                iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndExchangeBAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                       iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n@@ -5640,1 +5747,1 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5644,1 +5751,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST * 5);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5649,1 +5756,1 @@\n-    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeBAcq\"\n+    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeBAcq_narrow\"\n@@ -5661,2 +5768,1 @@\n-instruct compareAndExchangeSAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                                iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndExchangeBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n@@ -5664,1 +5770,22 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (CompareAndExchangeB mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeBAcq\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndExchangeSAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                       iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5668,1 +5795,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST * 6);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5673,1 +5800,1 @@\n-    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeSAcq\"\n+    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeSAcq_narrow\"\n@@ -5685,0 +5812,20 @@\n+instruct compareAndExchangeSAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n+%{\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (CompareAndExchangeS mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeSAcq\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5691,3 +5838,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST);\n-\n-  effect(TEMP_DEF res);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5713,3 +5858,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST);\n-\n-  effect(TEMP_DEF res);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5735,3 +5878,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST);\n-\n-  effect(TEMP_DEF res);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5757,3 +5898,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST);\n-\n-  effect(TEMP_DEF res);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5773,2 +5912,2 @@\n-instruct weakCompareAndSwapB(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                             iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct weakCompareAndSwapB_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                    iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n@@ -5776,0 +5915,2 @@\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5778,1 +5919,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 6);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5784,1 +5925,1 @@\n-    \"# $res == 1 when success, #@weakCompareAndSwapB\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapB_narrow\"\n@@ -5796,2 +5937,1 @@\n-instruct weakCompareAndSwapS(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                             iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct weakCompareAndSwapB(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n@@ -5799,0 +5939,24 @@\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (WeakCompareAndSwapB mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"weak_cmpxchg $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapB\"\n+  %}\n+\n+  ins_encode %{\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+                    \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct weakCompareAndSwapS_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                    iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5801,1 +5965,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 7);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5807,1 +5971,1 @@\n-    \"# $res == 1 when success, #@weakCompareAndSwapS\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapS_narrow\"\n@@ -5819,0 +5983,21 @@\n+instruct weakCompareAndSwapS(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n+%{\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (WeakCompareAndSwapS mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"weak_cmpxchg $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapS\"\n+  %}\n+\n+  ins_encode %{\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+                    \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5823,1 +6008,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 2);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5842,1 +6027,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 2);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5860,0 +6045,1 @@\n+\n@@ -5862,1 +6048,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5880,0 +6066,1 @@\n+\n@@ -5882,1 +6069,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 2);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5897,2 +6084,2 @@\n-instruct weakCompareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                                iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct weakCompareAndSwapBAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                       iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n@@ -5900,1 +6087,1 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5904,1 +6091,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 6);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5910,1 +6097,1 @@\n-    \"# $res == 1 when success, #@weakCompareAndSwapBAcq\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapBAcq_narrow\"\n@@ -5922,2 +6109,1 @@\n-instruct weakCompareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                                iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct weakCompareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n@@ -5925,1 +6111,23 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (WeakCompareAndSwapB mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"weak_cmpxchg_acq $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapBAcq\"\n+  %}\n+\n+  ins_encode %{\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+                    \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct weakCompareAndSwapSAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                       iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5929,1 +6137,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 7);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5935,1 +6143,1 @@\n-    \"# $res == 1 when success, #@weakCompareAndSwapSAcq\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapSAcq_narrow\"\n@@ -5947,0 +6155,21 @@\n+instruct weakCompareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n+%{\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (WeakCompareAndSwapS mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"weak_cmpxchg_acq $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapSAcq\"\n+  %}\n+\n+  ins_encode %{\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+                    \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5953,1 +6182,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 2);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5974,1 +6203,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 2);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5995,1 +6224,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -6016,1 +6245,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 2);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -7965,1 +8194,1 @@\n-  \n+ \n@@ -8201,0 +8430,11 @@\n+instruct castVVMask(vRegMask dst)\n+%{\n+  match(Set dst (CastVV dst));\n+\n+  size(0);\n+  format %{ \"# castVV of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":405,"deletions":165,"binary":false,"changes":570,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n+  const char* name = OptoRuntime::stub_name(StubId::c2_uncommon_trap_id);\n@@ -286,1 +286,1 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n+  const char* name = OptoRuntime::stub_name(StubId::c2_exception_id);\n","filename":"src\/hotspot\/cpu\/riscv\/runtime_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1780,9 +1780,1 @@\n-    \/\/ We need an acquire here to ensure that any subsequent load of the\n-    \/\/ global SafepointSynchronize::_state flag is ordered after this load\n-    \/\/ of the thread-local polling word. We don't want this poll to\n-    \/\/ return false (i.e. not safepointing) and a later poll of the global\n-    \/\/ SafepointSynchronize::_state spuriously to return true.\n-    \/\/ This is to avoid a race when we're in a native->Java transition\n-    \/\/ racing the code which wakes up from a safepoint.\n-\n-    __ safepoint_poll(safepoint_in_progress, true \/* at_return *\/, true \/* acquire *\/, false \/* in_nmethod *\/);\n+    __ safepoint_poll(safepoint_in_progress, true \/* at_return *\/, false \/* in_nmethod *\/);\n@@ -1897,0 +1889,18 @@\n+  #if INCLUDE_JFR\n+  \/\/ We need to do a poll test after unwind in case the sampler\n+  \/\/ managed to sample the native frame after returning to Java.\n+  Label L_return;\n+  __ ld(t0, Address(xthread, JavaThread::polling_word_offset()));\n+  address poll_test_pc = __ pc();\n+  __ relocate(relocInfo::poll_return_type);\n+  __ test_bit(t0, t0, log2i_exact(SafepointMechanism::poll_bit()));\n+  __ beqz(t0, L_return);\n+  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n+         \"polling page return stub not created yet\");\n+  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+  __ la(t0, InternalAddress(poll_test_pc));\n+  __ sd(t0, Address(xthread, JavaThread::saved_exception_pc_offset()));\n+  __ far_jump(RuntimeAddress(stub));\n+  __ bind(L_return);\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -2093,1 +2103,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::deopt_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_deopt_id);\n@@ -2476,1 +2486,1 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(StubId id, address call_ptr) {\n@@ -2493,2 +2503,2 @@\n-  bool cause_return = (id == SharedStubId::polling_page_return_handler_id);\n-  RegisterSaver reg_saver(id == SharedStubId::polling_page_vectors_safepoint_handler_id \/* save_vectors *\/);\n+  bool cause_return = (id == StubId::shared_polling_page_return_handler_id);\n+  RegisterSaver reg_saver(id == StubId::shared_polling_page_vectors_safepoint_handler_id \/* save_vectors *\/);\n@@ -2601,1 +2611,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(StubId id, address destination) {\n@@ -2698,1 +2708,1 @@\n-RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+RuntimeStub* SharedRuntime::generate_throw_exception(StubId id, address runtime_entry) {\n@@ -2809,1 +2819,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_write_checkpoint_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_jfr_write_checkpoint_id);\n@@ -2848,1 +2858,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_return_lease_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_jfr_return_lease_id);\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2025, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -210,1 +210,1 @@\n-    StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+    StubId stub_id = StubId::stubgen_call_stub_id;\n@@ -479,1 +479,1 @@\n-    StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+    StubId stub_id = StubId::stubgen_catch_exception_id;\n@@ -532,1 +532,1 @@\n-    StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+    StubId stub_id = StubId::stubgen_forward_exception_id;\n@@ -619,1 +619,1 @@\n-    StubGenStubId stub_id = StubGenStubId::verify_oop_id;\n+    StubId stub_id = StubId::stubgen_verify_oop_id;\n@@ -681,1 +681,1 @@\n-    StubGenStubId stub_id = StubGenStubId::zero_blocks_id;\n+    StubId stub_id = StubId::stubgen_zero_blocks_id;\n@@ -734,1 +734,1 @@\n-  void generate_copy_longs(StubGenStubId stub_id, Label &start,\n+  void generate_copy_longs(StubId stub_id, Label &start,\n@@ -739,1 +739,1 @@\n-    case copy_byte_f_id:\n+    case StubId::stubgen_copy_byte_f_id:\n@@ -743,1 +743,1 @@\n-    case copy_byte_b_id:\n+    case StubId::stubgen_copy_byte_b_id:\n@@ -1117,1 +1117,1 @@\n-  address generate_disjoint_copy(StubGenStubId stub_id, address* entry) {\n+  address generate_disjoint_copy(StubId stub_id, address* entry) {\n@@ -1123,1 +1123,1 @@\n-    case jbyte_disjoint_arraycopy_id:\n+    case StubId::stubgen_jbyte_disjoint_arraycopy_id:\n@@ -1129,1 +1129,1 @@\n-    case arrayof_jbyte_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id:\n@@ -1135,1 +1135,1 @@\n-    case jshort_disjoint_arraycopy_id:\n+    case StubId::stubgen_jshort_disjoint_arraycopy_id:\n@@ -1141,1 +1141,1 @@\n-    case arrayof_jshort_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id:\n@@ -1147,1 +1147,1 @@\n-    case jint_disjoint_arraycopy_id:\n+    case StubId::stubgen_jint_disjoint_arraycopy_id:\n@@ -1153,1 +1153,1 @@\n-    case arrayof_jint_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jint_disjoint_arraycopy_id:\n@@ -1159,1 +1159,1 @@\n-    case jlong_disjoint_arraycopy_id:\n+    case StubId::stubgen_jlong_disjoint_arraycopy_id:\n@@ -1164,1 +1164,1 @@\n-    case arrayof_jlong_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id:\n@@ -1170,1 +1170,1 @@\n-    case oop_disjoint_arraycopy_id:\n+    case StubId::stubgen_oop_disjoint_arraycopy_id:\n@@ -1176,1 +1176,1 @@\n-    case arrayof_oop_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_oop_disjoint_arraycopy_id:\n@@ -1182,1 +1182,1 @@\n-    case oop_disjoint_arraycopy_uninit_id:\n+    case StubId::stubgen_oop_disjoint_arraycopy_uninit_id:\n@@ -1188,1 +1188,1 @@\n-    case arrayof_oop_disjoint_arraycopy_uninit_id:\n+    case StubId::stubgen_arrayof_oop_disjoint_arraycopy_uninit_id:\n@@ -1274,1 +1274,1 @@\n-  address generate_conjoint_copy(StubGenStubId stub_id, address nooverlap_target, address *entry) {\n+  address generate_conjoint_copy(StubId stub_id, address nooverlap_target, address *entry) {\n@@ -1282,1 +1282,1 @@\n-    case jbyte_arraycopy_id:\n+    case StubId::stubgen_jbyte_arraycopy_id:\n@@ -1288,1 +1288,1 @@\n-    case arrayof_jbyte_arraycopy_id:\n+    case StubId::stubgen_arrayof_jbyte_arraycopy_id:\n@@ -1294,1 +1294,1 @@\n-    case jshort_arraycopy_id:\n+    case StubId::stubgen_jshort_arraycopy_id:\n@@ -1300,1 +1300,1 @@\n-    case arrayof_jshort_arraycopy_id:\n+    case StubId::stubgen_arrayof_jshort_arraycopy_id:\n@@ -1306,1 +1306,1 @@\n-    case jint_arraycopy_id:\n+    case StubId::stubgen_jint_arraycopy_id:\n@@ -1312,1 +1312,1 @@\n-    case arrayof_jint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jint_arraycopy_id:\n@@ -1318,1 +1318,1 @@\n-    case jlong_arraycopy_id:\n+    case StubId::stubgen_jlong_arraycopy_id:\n@@ -1323,1 +1323,1 @@\n-    case arrayof_jlong_arraycopy_id:\n+    case StubId::stubgen_arrayof_jlong_arraycopy_id:\n@@ -1329,1 +1329,1 @@\n-    case oop_arraycopy_id:\n+    case StubId::stubgen_oop_arraycopy_id:\n@@ -1335,1 +1335,1 @@\n-    case arrayof_oop_arraycopy_id:\n+    case StubId::stubgen_arrayof_oop_arraycopy_id:\n@@ -1341,1 +1341,1 @@\n-    case oop_arraycopy_uninit_id:\n+    case StubId::stubgen_oop_arraycopy_uninit_id:\n@@ -1347,1 +1347,1 @@\n-    case arrayof_oop_arraycopy_uninit_id:\n+    case StubId::stubgen_arrayof_oop_arraycopy_uninit_id:\n@@ -1447,1 +1447,1 @@\n-  address generate_checkcast_copy(StubGenStubId stub_id, address* entry) {\n+  address generate_checkcast_copy(StubId stub_id, address* entry) {\n@@ -1450,1 +1450,1 @@\n-    case checkcast_arraycopy_id:\n+    case StubId::stubgen_checkcast_arraycopy_id:\n@@ -1453,1 +1453,1 @@\n-    case checkcast_arraycopy_uninit_id:\n+    case StubId::stubgen_checkcast_arraycopy_uninit_id:\n@@ -1636,0 +1636,120 @@\n+  address generate_unsafecopy_common_error_exit() {\n+    address start = __ pc();\n+    __ mv(x10, 0);\n+    __ leave();\n+    __ ret();\n+    return start;\n+  }\n+\n+  \/\/\n+  \/\/  Generate 'unsafe' set memory stub\n+  \/\/  Though just as safe as the other stubs, it takes an unscaled\n+  \/\/  size_t (# bytes) argument instead of an element count.\n+  \/\/\n+  \/\/  Input:\n+  \/\/    c_rarg0   - destination array address\n+  \/\/    c_rarg1   - byte count (size_t)\n+  \/\/    c_rarg2   - byte value\n+  \/\/\n+  address generate_unsafe_setmemory() {\n+    __ align(CodeEntryAlignment);\n+    StubId stub_id = StubId::stubgen_unsafe_setmemory_id;\n+    StubCodeMark mark(this, stub_id);\n+    address start = __ pc();\n+\n+    \/\/ bump this on entry, not on exit:\n+    \/\/ inc_counter_np(SharedRuntime::_unsafe_set_memory_ctr);\n+\n+    Label L_fill_elements;\n+\n+    const Register dest = c_rarg0;\n+    const Register count = c_rarg1;\n+    const Register value = c_rarg2;\n+    const Register cnt_words = x28; \/\/ temp register\n+    const Register tmp_reg   = x29; \/\/ temp register\n+\n+    \/\/ Mark remaining code as such which performs Unsafe accesses.\n+    UnsafeMemoryAccessMark umam(this, true, false);\n+\n+    __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+    \/\/ if count < 8, jump to L_fill_elements\n+    __ mv(tmp_reg, 8); \/\/ 8 bytes fill by element\n+    __ bltu(count, tmp_reg, L_fill_elements);\n+\n+    \/\/ Propagate byte to 64-bit width\n+    \/\/ 8 bit -> 16 bit\n+    __ zext(value, value, 8);\n+    __ slli(tmp_reg, value, 8);\n+    __ orr(value, value, tmp_reg);\n+    \/\/ 16 bit -> 32 bit\n+    __ slli(tmp_reg, value, 16);\n+    __ orr(value, value, tmp_reg);\n+    \/\/ 32 bit -> 64 bit\n+    __ slli(tmp_reg, value, 32);\n+    __ orr(value, value, tmp_reg);\n+\n+    \/\/ Align source address at 8 bytes address boundary.\n+    Label L_skip_align1, L_skip_align2, L_skip_align4;\n+    \/\/ One byte misalignment happens.\n+    __ test_bit(tmp_reg, dest, 0);\n+    __ beqz(tmp_reg, L_skip_align1);\n+    __ sb(value, Address(dest, 0));\n+    __ addi(dest, dest, 1);\n+    __ subi(count, count, 1);\n+\n+    __ bind(L_skip_align1);\n+    \/\/ Two bytes misalignment happens.\n+    __ test_bit(tmp_reg, dest, 1);\n+    __ beqz(tmp_reg, L_skip_align2);\n+    __ sh(value, Address(dest, 0));\n+    __ addi(dest, dest, 2);\n+    __ subi(count, count, 2);\n+\n+    __ bind(L_skip_align2);\n+    \/\/ Four bytes misalignment happens.\n+    __ test_bit(tmp_reg, dest, 2);\n+    __ beqz(tmp_reg, L_skip_align4);\n+    __ sw(value, Address(dest, 0));\n+    __ addi(dest, dest, 4);\n+    __ subi(count, count, 4);\n+    __ bind(L_skip_align4);\n+\n+    \/\/  Fill large chunks\n+    __ srli(cnt_words, count, 3); \/\/ number of words\n+    __ slli(tmp_reg, cnt_words, 3);\n+    __ sub(count, count, tmp_reg);\n+    {\n+      __ fill_words(dest, cnt_words, value);\n+    }\n+\n+    \/\/ Handle copies less than 8 bytes\n+    __ bind(L_fill_elements);\n+    Label L_fill_2, L_fill_1, L_exit;\n+    __ test_bit(tmp_reg, count, 2);\n+    __ beqz(tmp_reg, L_fill_2);\n+    __ sb(value, Address(dest, 0));\n+    __ sb(value, Address(dest, 1));\n+    __ sb(value, Address(dest, 2));\n+    __ sb(value, Address(dest, 3));\n+    __ addi(dest, dest, 4);\n+\n+    __ bind(L_fill_2);\n+    __ test_bit(tmp_reg, count, 1);\n+    __ beqz(tmp_reg, L_fill_1);\n+    __ sb(value, Address(dest, 0));\n+    __ sb(value, Address(dest, 1));\n+    __ addi(dest, dest, 2);\n+\n+    __ bind(L_fill_1);\n+    __ test_bit(tmp_reg, count, 0);\n+    __ beqz(tmp_reg, L_exit);\n+    __ sb(value, Address(dest, 0));\n+\n+    __ bind(L_exit);\n+    __ leave();\n+    __ ret();\n+\n+    return start;\n+  }\n+\n@@ -1659,1 +1779,1 @@\n-    StubGenStubId stub_id = StubGenStubId::unsafe_arraycopy_id;\n+    StubId stub_id = StubId::stubgen_unsafe_arraycopy_id;\n@@ -1726,1 +1846,1 @@\n-    StubGenStubId stub_id = StubGenStubId::generic_arraycopy_id;\n+    StubId stub_id = StubId::stubgen_generic_arraycopy_id;\n@@ -1983,1 +2103,1 @@\n-  address generate_fill(StubGenStubId stub_id) {\n+  address generate_fill(StubId stub_id) {\n@@ -1988,1 +2108,1 @@\n-    case jbyte_fill_id:\n+    case StubId::stubgen_jbyte_fill_id:\n@@ -1992,1 +2112,1 @@\n-    case jshort_fill_id:\n+    case StubId::stubgen_jshort_fill_id:\n@@ -1996,1 +2116,1 @@\n-    case jint_fill_id:\n+    case StubId::stubgen_jint_fill_id:\n@@ -2000,1 +2120,1 @@\n-    case arrayof_jbyte_fill_id:\n+    case StubId::stubgen_arrayof_jbyte_fill_id:\n@@ -2004,1 +2124,1 @@\n-    case arrayof_jshort_fill_id:\n+    case StubId::stubgen_arrayof_jshort_fill_id:\n@@ -2008,1 +2128,1 @@\n-    case arrayof_jint_fill_id:\n+    case StubId::stubgen_arrayof_jint_fill_id:\n@@ -2079,2 +2199,2 @@\n-          __ test_bit(t0, to, 0);\n-          __ beqz(t0, L_skip_align1);\n+          __ test_bit(tmp_reg, to, 0);\n+          __ beqz(tmp_reg, L_skip_align1);\n@@ -2088,2 +2208,2 @@\n-          __ test_bit(t0, to, 1);\n-          __ beqz(t0, L_skip_align2);\n+          __ test_bit(tmp_reg, to, 1);\n+          __ beqz(tmp_reg, L_skip_align2);\n@@ -2097,2 +2217,2 @@\n-          __ test_bit(t0, to, 2);\n-          __ beqz(t0, L_skip_align4);\n+          __ test_bit(tmp_reg, to, 2);\n+          __ beqz(tmp_reg, L_skip_align4);\n@@ -2124,2 +2244,4 @@\n-    \/\/ Remaining count is less than 8 bytes and address is heapword aligned.\n-    Label L_fill_1, L_fill_2, L_exit1;\n+    \/\/ Handle copies less than 8 bytes.\n+    \/\/ Address may not be heapword aligned.\n+    Label L_fill_1, L_fill_2, L_exit;\n+    __ bind(L_fill_elements);\n@@ -2128,3 +2250,6 @@\n-        __ test_bit(t0, count, 2);\n-        __ beqz(t0, L_fill_2);\n-        __ sw(value, Address(to, 0));\n+        __ test_bit(tmp_reg, count, 2);\n+        __ beqz(tmp_reg, L_fill_2);\n+        __ sb(value, Address(to, 0));\n+        __ sb(value, Address(to, 1));\n+        __ sb(value, Address(to, 2));\n+        __ sb(value, Address(to, 3));\n@@ -2132,0 +2257,1 @@\n+\n@@ -2133,3 +2259,4 @@\n-        __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_1);\n-        __ sh(value, Address(to, 0));\n+        __ test_bit(tmp_reg, count, 1);\n+        __ beqz(tmp_reg, L_fill_1);\n+        __ sb(value, Address(to, 0));\n+        __ sb(value, Address(to, 1));\n@@ -2137,0 +2264,1 @@\n+\n@@ -2138,2 +2266,2 @@\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_exit1);\n+        __ test_bit(tmp_reg, count, 0);\n+        __ beqz(tmp_reg, L_exit);\n@@ -2143,7 +2271,2 @@\n-        __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_2);\n-        __ sw(value, Address(to, 0));\n-        __ addi(to, to, 4);\n-        __ bind(L_fill_2);\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_exit1);\n+        __ test_bit(tmp_reg, count, 1);\n+        __ beqz(tmp_reg, L_fill_2);\n@@ -2151,10 +2274,2 @@\n-        break;\n-      case T_INT:\n-        __ beqz(count, L_exit1);\n-        __ sw(value, Address(to, 0));\n-        break;\n-      default: ShouldNotReachHere();\n-    }\n-    __ bind(L_exit1);\n-    __ leave();\n-    __ ret();\n+        __ sh(value, Address(to, 2));\n+        __ addi(to, to, 4);\n@@ -2162,14 +2277,3 @@\n-    \/\/ Handle copies less than 8 bytes.\n-    Label L_loop1, L_loop2, L_exit2;\n-    __ bind(L_fill_elements);\n-    __ beqz(count, L_exit2);\n-    switch (t) {\n-      case T_BYTE:\n-        __ bind(L_loop1);\n-        __ sb(value, Address(to, 0));\n-        __ addi(to, to, 1);\n-        __ subiw(count, count, 1);\n-        __ bnez(count, L_loop1);\n-        break;\n-      case T_SHORT:\n-        __ bind(L_loop2);\n+        __ bind(L_fill_2);\n+        __ test_bit(tmp_reg, count, 0);\n+        __ beqz(tmp_reg, L_exit);\n@@ -2177,3 +2281,0 @@\n-        __ addi(to, to, 2);\n-        __ subiw(count, count, 2 >> shift);\n-        __ bnez(count, L_loop2);\n@@ -2182,0 +2283,1 @@\n+        __ beqz(count, L_exit);\n@@ -2186,1 +2288,1 @@\n-    __ bind(L_exit2);\n+    __ bind(L_exit);\n@@ -2202,2 +2304,5 @@\n-    generate_copy_longs(StubGenStubId::copy_byte_f_id, copy_f, c_rarg0, c_rarg1, t1);\n-    generate_copy_longs(StubGenStubId::copy_byte_b_id, copy_b, c_rarg0, c_rarg1, t1);\n+    generate_copy_longs(StubId::stubgen_copy_byte_f_id, copy_f, c_rarg0, c_rarg1, t1);\n+    generate_copy_longs(StubId::stubgen_copy_byte_b_id, copy_b, c_rarg0, c_rarg1, t1);\n+\n+    address ucm_common_error_exit     = generate_unsafecopy_common_error_exit();\n+    UnsafeMemoryAccess::set_common_exit_stub_pc(ucm_common_error_exit);\n@@ -2209,4 +2314,4 @@\n-    StubRoutines::_jbyte_disjoint_arraycopy          = generate_disjoint_copy(StubGenStubId::jbyte_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_jbyte_arraycopy                   = generate_conjoint_copy(StubGenStubId::jbyte_arraycopy_id, entry, &entry_jbyte_arraycopy);\n-    StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = generate_disjoint_copy(StubGenStubId::arrayof_jbyte_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jbyte_arraycopy           = generate_conjoint_copy(StubGenStubId::arrayof_jbyte_arraycopy_id, entry, nullptr);\n+    StubRoutines::_jbyte_disjoint_arraycopy          = generate_disjoint_copy(StubId::stubgen_jbyte_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jbyte_arraycopy                   = generate_conjoint_copy(StubId::stubgen_jbyte_arraycopy_id, entry, &entry_jbyte_arraycopy);\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = generate_disjoint_copy(StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jbyte_arraycopy           = generate_conjoint_copy(StubId::stubgen_arrayof_jbyte_arraycopy_id, entry, nullptr);\n@@ -2216,4 +2321,4 @@\n-    StubRoutines::_jshort_disjoint_arraycopy         = generate_disjoint_copy(StubGenStubId::jshort_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_jshort_arraycopy                  = generate_conjoint_copy(StubGenStubId::jshort_arraycopy_id, entry, &entry_jshort_arraycopy);\n-    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jshort_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jshort_arraycopy_id, entry, nullptr);\n+    StubRoutines::_jshort_disjoint_arraycopy         = generate_disjoint_copy(StubId::stubgen_jshort_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jshort_arraycopy                  = generate_conjoint_copy(StubId::stubgen_jshort_arraycopy_id, entry, &entry_jshort_arraycopy);\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jshort_arraycopy_id, entry, nullptr);\n@@ -2223,2 +2328,2 @@\n-    StubRoutines::_arrayof_jint_disjoint_arraycopy   = generate_disjoint_copy(StubGenStubId::arrayof_jint_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jint_arraycopy            = generate_conjoint_copy(StubGenStubId::arrayof_jint_arraycopy_id, entry, &entry_jint_arraycopy);\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy   = generate_disjoint_copy(StubId::stubgen_arrayof_jint_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jint_arraycopy            = generate_conjoint_copy(StubId::stubgen_arrayof_jint_arraycopy_id, entry, &entry_jint_arraycopy);\n@@ -2227,2 +2332,2 @@\n-    StubRoutines::_jint_disjoint_arraycopy           = generate_disjoint_copy(StubGenStubId::jint_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_jint_arraycopy                  = generate_conjoint_copy(StubGenStubId::jint_arraycopy_id, entry, &entry_jint_arraycopy);\n+    StubRoutines::_jint_disjoint_arraycopy           = generate_disjoint_copy(StubId::stubgen_jint_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jint_arraycopy                  = generate_conjoint_copy(StubId::stubgen_jint_arraycopy_id, entry, &entry_jint_arraycopy);\n@@ -2232,2 +2337,2 @@\n-    StubRoutines::_arrayof_jlong_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jlong_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jlong_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jlong_arraycopy_id, entry, &entry_jlong_arraycopy);\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jlong_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jlong_arraycopy_id, entry, &entry_jlong_arraycopy);\n@@ -2239,1 +2344,1 @@\n-      = generate_disjoint_copy(StubGenStubId::arrayof_oop_disjoint_arraycopy_id, &entry);\n+      = generate_disjoint_copy(StubId::stubgen_arrayof_oop_disjoint_arraycopy_id, &entry);\n@@ -2241,1 +2346,1 @@\n-      = generate_conjoint_copy(StubGenStubId::arrayof_oop_arraycopy_id, entry, &entry_oop_arraycopy);\n+      = generate_conjoint_copy(StubId::stubgen_arrayof_oop_arraycopy_id, entry, &entry_oop_arraycopy);\n@@ -2244,1 +2349,1 @@\n-      = generate_disjoint_copy(StubGenStubId::arrayof_oop_disjoint_arraycopy_uninit_id, &entry);\n+      = generate_disjoint_copy(StubId::stubgen_arrayof_oop_disjoint_arraycopy_uninit_id, &entry);\n@@ -2246,1 +2351,1 @@\n-      = generate_conjoint_copy(StubGenStubId::arrayof_oop_arraycopy_uninit_id, entry, nullptr);\n+      = generate_conjoint_copy(StubId::stubgen_arrayof_oop_arraycopy_uninit_id, entry, nullptr);\n@@ -2253,2 +2358,2 @@\n-    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_id, &entry_checkcast_arraycopy);\n-    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_uninit_id, nullptr);\n+    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubId::stubgen_checkcast_arraycopy_id, &entry_checkcast_arraycopy);\n+    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubId::stubgen_checkcast_arraycopy_uninit_id, nullptr);\n@@ -2269,6 +2374,8 @@\n-    StubRoutines::_jbyte_fill = generate_fill(StubGenStubId::jbyte_fill_id);\n-    StubRoutines::_jshort_fill = generate_fill(StubGenStubId::jshort_fill_id);\n-    StubRoutines::_jint_fill = generate_fill(StubGenStubId::jint_fill_id);\n-    StubRoutines::_arrayof_jbyte_fill = generate_fill(StubGenStubId::arrayof_jbyte_fill_id);\n-    StubRoutines::_arrayof_jshort_fill = generate_fill(StubGenStubId::arrayof_jshort_fill_id);\n-    StubRoutines::_arrayof_jint_fill = generate_fill(StubGenStubId::arrayof_jint_fill_id);\n+    StubRoutines::_jbyte_fill = generate_fill(StubId::stubgen_jbyte_fill_id);\n+    StubRoutines::_jshort_fill = generate_fill(StubId::stubgen_jshort_fill_id);\n+    StubRoutines::_jint_fill = generate_fill(StubId::stubgen_jint_fill_id);\n+    StubRoutines::_arrayof_jbyte_fill = generate_fill(StubId::stubgen_arrayof_jbyte_fill_id);\n+    StubRoutines::_arrayof_jshort_fill = generate_fill(StubId::stubgen_arrayof_jshort_fill_id);\n+    StubRoutines::_arrayof_jint_fill = generate_fill(StubId::stubgen_arrayof_jint_fill_id);\n+\n+    StubRoutines::_unsafe_setmemory    = generate_unsafe_setmemory();\n@@ -2310,1 +2417,1 @@\n-    StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+    StubId stub_id = StubId::stubgen_aescrypt_encryptBlock_id;\n@@ -2389,1 +2496,1 @@\n-    StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+    StubId stub_id = StubId::stubgen_aescrypt_decryptBlock_id;\n@@ -2491,1 +2598,1 @@\n-  address generate_compare_long_string_different_encoding(StubGenStubId stub_id) {\n+  address generate_compare_long_string_different_encoding(StubId stub_id) {\n@@ -2494,1 +2601,1 @@\n-    case compare_long_string_LU_id:\n+    case StubId::stubgen_compare_long_string_LU_id:\n@@ -2497,1 +2604,1 @@\n-    case compare_long_string_UL_id:\n+    case StubId::stubgen_compare_long_string_UL_id:\n@@ -2593,1 +2700,1 @@\n-    StubGenStubId stub_id = StubGenStubId::method_entry_barrier_id;\n+    StubId stub_id = StubId::stubgen_method_entry_barrier_id;\n@@ -2664,1 +2771,1 @@\n-  address generate_compare_long_string_same_encoding(StubGenStubId stub_id) {\n+  address generate_compare_long_string_same_encoding(StubId stub_id) {\n@@ -2667,1 +2774,1 @@\n-    case compare_long_string_LL_id:\n+    case StubId::stubgen_compare_long_string_LL_id:\n@@ -2670,1 +2777,1 @@\n-    case compare_long_string_UU_id:\n+    case StubId::stubgen_compare_long_string_UU_id:\n@@ -2776,4 +2883,4 @@\n-    StubRoutines::riscv::_compare_long_string_LL = generate_compare_long_string_same_encoding(StubGenStubId::compare_long_string_LL_id);\n-    StubRoutines::riscv::_compare_long_string_UU = generate_compare_long_string_same_encoding(StubGenStubId::compare_long_string_UU_id);\n-    StubRoutines::riscv::_compare_long_string_LU = generate_compare_long_string_different_encoding(StubGenStubId::compare_long_string_LU_id);\n-    StubRoutines::riscv::_compare_long_string_UL = generate_compare_long_string_different_encoding(StubGenStubId::compare_long_string_UL_id);\n+    StubRoutines::riscv::_compare_long_string_LL = generate_compare_long_string_same_encoding(StubId::stubgen_compare_long_string_LL_id);\n+    StubRoutines::riscv::_compare_long_string_UU = generate_compare_long_string_same_encoding(StubId::stubgen_compare_long_string_UU_id);\n+    StubRoutines::riscv::_compare_long_string_LU = generate_compare_long_string_different_encoding(StubId::stubgen_compare_long_string_LU_id);\n+    StubRoutines::riscv::_compare_long_string_UL = generate_compare_long_string_different_encoding(StubId::stubgen_compare_long_string_UL_id);\n@@ -2787,1 +2894,1 @@\n-  address generate_string_indexof_linear(StubGenStubId stub_id)\n+  address generate_string_indexof_linear(StubId stub_id)\n@@ -2792,1 +2899,1 @@\n-    case string_indexof_linear_ll_id:\n+    case StubId::stubgen_string_indexof_linear_ll_id:\n@@ -2796,1 +2903,1 @@\n-    case string_indexof_linear_ul_id:\n+    case StubId::stubgen_string_indexof_linear_ul_id:\n@@ -2800,1 +2907,1 @@\n-    case string_indexof_linear_uu_id:\n+    case StubId::stubgen_string_indexof_linear_uu_id:\n@@ -3036,3 +3143,3 @@\n-    StubRoutines::riscv::_string_indexof_linear_ll = generate_string_indexof_linear(StubGenStubId::string_indexof_linear_ll_id);\n-    StubRoutines::riscv::_string_indexof_linear_uu = generate_string_indexof_linear(StubGenStubId::string_indexof_linear_uu_id);\n-    StubRoutines::riscv::_string_indexof_linear_ul = generate_string_indexof_linear(StubGenStubId::string_indexof_linear_ul_id);\n+    StubRoutines::riscv::_string_indexof_linear_ll = generate_string_indexof_linear(StubId::stubgen_string_indexof_linear_ll_id);\n+    StubRoutines::riscv::_string_indexof_linear_uu = generate_string_indexof_linear(StubId::stubgen_string_indexof_linear_uu_id);\n+    StubRoutines::riscv::_string_indexof_linear_ul = generate_string_indexof_linear(StubId::stubgen_string_indexof_linear_ul_id);\n@@ -3043,1 +3150,1 @@\n-    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n+    StubId stub_id = StubId::stubgen_lookup_secondary_supers_table_id;\n@@ -3069,1 +3176,1 @@\n-    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_slow_path_id;\n+    StubId stub_id = StubId::stubgen_lookup_secondary_supers_table_slow_path_id;\n@@ -3091,1 +3198,1 @@\n-    StubGenStubId stub_id = StubGenStubId::mulAdd_id;\n+    StubId stub_id = StubId::stubgen_mulAdd_id;\n@@ -3125,1 +3232,1 @@\n-    StubGenStubId stub_id = StubGenStubId::multiplyToLen_id;\n+    StubId stub_id = StubId::stubgen_multiplyToLen_id;\n@@ -3156,1 +3263,1 @@\n-    StubGenStubId stub_id = StubGenStubId::squareToLen_id;\n+    StubId stub_id = StubId::stubgen_squareToLen_id;\n@@ -3197,1 +3304,1 @@\n-    StubGenStubId stub_id = StubGenStubId::bigIntegerLeftShiftWorker_id;\n+    StubId stub_id = StubId::stubgen_bigIntegerLeftShiftWorker_id;\n@@ -3249,1 +3356,1 @@\n-    StubGenStubId stub_id = StubGenStubId::bigIntegerRightShiftWorker_id;\n+    StubId stub_id = StubId::stubgen_bigIntegerRightShiftWorker_id;\n@@ -4076,1 +4183,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cont_thaw_id;\n+    StubId stub_id = StubId::stubgen_cont_thaw_id;\n@@ -4087,1 +4194,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cont_returnBarrier_id;\n+    StubId stub_id = StubId::stubgen_cont_returnBarrier_id;\n@@ -4099,1 +4206,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cont_returnBarrierExc_id;\n+    StubId stub_id = StubId::stubgen_cont_returnBarrierExc_id;\n@@ -4110,1 +4217,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cont_preempt_id;\n+    StubId stub_id = StubId::stubgen_cont_preempt_id;\n@@ -4148,1 +4255,1 @@\n-      address generate_sha256_implCompress(StubGenStubId stub_id) {\n+      address generate_sha256_implCompress(StubId stub_id) {\n@@ -4151,1 +4258,1 @@\n-      address generate_sha512_implCompress(StubGenStubId stub_id) {\n+      address generate_sha512_implCompress(StubId stub_id) {\n@@ -4285,1 +4392,1 @@\n-    address generate_sha2_implCompress(Assembler::SEW vset_sew, StubGenStubId stub_id) {\n+    address generate_sha2_implCompress(Assembler::SEW vset_sew, StubId stub_id) {\n@@ -4337,1 +4444,1 @@\n-      case sha256_implCompress_id:\n+      case StubId::stubgen_sha256_implCompress_id:\n@@ -4341,1 +4448,1 @@\n-      case sha256_implCompressMB_id:\n+      case StubId::stubgen_sha256_implCompressMB_id:\n@@ -4345,1 +4452,1 @@\n-      case sha512_implCompress_id:\n+      case StubId::stubgen_sha512_implCompress_id:\n@@ -4349,1 +4456,1 @@\n-      case sha512_implCompressMB_id:\n+      case StubId::stubgen_sha512_implCompressMB_id:\n@@ -4704,1 +4811,1 @@\n-  address generate_md5_implCompress(StubGenStubId stub_id) {\n+  address generate_md5_implCompress(StubId stub_id) {\n@@ -4708,1 +4815,1 @@\n-    case md5_implCompress_id:\n+    case StubId::stubgen_md5_implCompress_id:\n@@ -4711,1 +4818,1 @@\n-    case md5_implCompressMB_id:\n+    case StubId::stubgen_md5_implCompressMB_id:\n@@ -4971,1 +5078,1 @@\n-    StubGenStubId stub_id = StubGenStubId::chacha20Block_id;\n+    StubId stub_id = StubId::stubgen_chacha20Block_id;\n@@ -5271,1 +5378,1 @@\n-  address generate_sha1_implCompress(StubGenStubId stub_id) {\n+  address generate_sha1_implCompress(StubId stub_id) {\n@@ -5274,1 +5381,1 @@\n-      case sha1_implCompress_id:\n+      case StubId::stubgen_sha1_implCompress_id:\n@@ -5277,1 +5384,1 @@\n-      case sha1_implCompressMB_id:\n+      case StubId::stubgen_sha1_implCompressMB_id:\n@@ -5494,1 +5601,1 @@\n-    StubGenStubId stub_id = StubGenStubId::base64_encodeBlock_id;\n+    StubId stub_id = StubId::stubgen_base64_encodeBlock_id;\n@@ -5751,1 +5858,1 @@\n-    StubGenStubId stub_id = StubGenStubId::base64_decodeBlock_id;\n+    StubId stub_id = StubId::stubgen_base64_decodeBlock_id;\n@@ -5996,1 +6103,1 @@\n-    StubGenStubId stub_id = StubGenStubId::updateBytesAdler32_id;\n+    StubId stub_id = StubId::stubgen_updateBytesAdler32_id;\n@@ -6174,1 +6281,1 @@\n-    StubGenStubId stub_id = StubGenStubId::hf2f_id;\n+    StubId stub_id = StubId::stubgen_hf2f_id;\n@@ -6225,1 +6332,1 @@\n-    StubGenStubId stub_id = StubGenStubId::f2hf_id;\n+    StubId stub_id = StubId::stubgen_f2hf_id;\n@@ -6353,1 +6460,1 @@\n-    StubGenStubId stub_id = StubGenStubId::poly1305_processBlocks_id;\n+    StubId stub_id = StubId::stubgen_poly1305_processBlocks_id;\n@@ -6491,1 +6598,1 @@\n-    StubGenStubId stub_id = StubGenStubId::updateBytesCRC32_id;\n+    StubId stub_id = StubId::stubgen_updateBytesCRC32_id;\n@@ -6516,1 +6623,1 @@\n-    StubGenStubId stub_id = StubGenStubId::upcall_stub_exception_handler_id;\n+    StubId stub_id = StubId::stubgen_upcall_stub_exception_handler_id;\n@@ -6534,1 +6641,1 @@\n-    StubGenStubId stub_id = StubGenStubId::upcall_stub_load_target_id;\n+    StubId stub_id = StubId::stubgen_upcall_stub_load_target_id;\n@@ -6556,0 +6663,4 @@\n+  void generate_preuniverse_stubs() {\n+    \/\/ preuniverse stubs are not needed for riscv\n+  }\n+\n@@ -6639,1 +6750,1 @@\n-      StubGenStubId stub_id = StubGenStubId::montgomeryMultiply_id;\n+      StubId stub_id = StubId::stubgen_montgomeryMultiply_id;\n@@ -6646,1 +6757,1 @@\n-      StubGenStubId stub_id = StubGenStubId::montgomerySquare_id;\n+      StubId stub_id = StubId::stubgen_montgomerySquare_id;\n@@ -6668,2 +6779,2 @@\n-      StubRoutines::_sha256_implCompress   = sha2.generate_sha256_implCompress(StubGenStubId::sha256_implCompress_id);\n-      StubRoutines::_sha256_implCompressMB = sha2.generate_sha256_implCompress(StubGenStubId::sha256_implCompressMB_id);\n+      StubRoutines::_sha256_implCompress   = sha2.generate_sha256_implCompress(StubId::stubgen_sha256_implCompress_id);\n+      StubRoutines::_sha256_implCompressMB = sha2.generate_sha256_implCompress(StubId::stubgen_sha256_implCompressMB_id);\n@@ -6674,2 +6785,2 @@\n-      StubRoutines::_sha512_implCompress   = sha2.generate_sha512_implCompress(StubGenStubId::sha512_implCompress_id);\n-      StubRoutines::_sha512_implCompressMB = sha2.generate_sha512_implCompress(StubGenStubId::sha512_implCompressMB_id);\n+      StubRoutines::_sha512_implCompress   = sha2.generate_sha512_implCompress(StubId::stubgen_sha512_implCompress_id);\n+      StubRoutines::_sha512_implCompressMB = sha2.generate_sha512_implCompress(StubId::stubgen_sha512_implCompressMB_id);\n@@ -6679,2 +6790,2 @@\n-      StubRoutines::_md5_implCompress   = generate_md5_implCompress(StubGenStubId::md5_implCompress_id);\n-      StubRoutines::_md5_implCompressMB = generate_md5_implCompress(StubGenStubId::md5_implCompressMB_id);\n+      StubRoutines::_md5_implCompress   = generate_md5_implCompress(StubId::stubgen_md5_implCompress_id);\n+      StubRoutines::_md5_implCompressMB = generate_md5_implCompress(StubId::stubgen_md5_implCompressMB_id);\n@@ -6688,2 +6799,2 @@\n-      StubRoutines::_sha1_implCompress     = generate_sha1_implCompress(StubGenStubId::sha1_implCompress_id);\n-      StubRoutines::_sha1_implCompressMB   = generate_sha1_implCompress(StubGenStubId::sha1_implCompressMB_id);\n+      StubRoutines::_sha1_implCompress     = generate_sha1_implCompress(StubId::stubgen_sha1_implCompress_id);\n+      StubRoutines::_sha1_implCompressMB   = generate_sha1_implCompress(StubId::stubgen_sha1_implCompressMB_id);\n@@ -6709,1 +6820,1 @@\n-  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+  StubGenerator(CodeBuffer* code, BlobId blob_id) : StubCodeGenerator(code, blob_id) {\n@@ -6711,1 +6822,4 @@\n-    case initial_id:\n+    case BlobId::stubgen_preuniverse_id:\n+      generate_preuniverse_stubs();\n+      break;\n+    case BlobId::stubgen_initial_id:\n@@ -6714,1 +6828,1 @@\n-     case continuation_id:\n+    case BlobId::stubgen_continuation_id:\n@@ -6717,1 +6831,1 @@\n-    case compiler_id:\n+    case BlobId::stubgen_compiler_id:\n@@ -6720,1 +6834,1 @@\n-    case final_id:\n+    case BlobId::stubgen_final_id:\n@@ -6724,1 +6838,1 @@\n-      fatal(\"unexpected blob id: %d\", blob_id);\n+      fatal(\"unexpected blob id: %s\", StubInfo::name(blob_id));\n@@ -6730,1 +6844,1 @@\n-void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+void StubGenerator_generate(CodeBuffer* code, BlobId blob_id) {\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":311,"deletions":197,"binary":false,"changes":508,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-    address a = Runtime1::entry_for (C1StubId::predicate_failed_trap_id);\n+    address a = Runtime1::entry_for (StubId::c1_predicate_failed_trap_id);\n@@ -66,1 +66,1 @@\n-  C1StubId stub_id;\n+  StubId stub_id;\n@@ -68,1 +68,1 @@\n-    stub_id = C1StubId::throw_index_exception_id;\n+    stub_id = StubId::c1_throw_index_exception_id;\n@@ -70,1 +70,1 @@\n-    stub_id = C1StubId::throw_range_check_failed_id;\n+    stub_id = StubId::c1_throw_range_check_failed_id;\n@@ -86,1 +86,1 @@\n-  address a = Runtime1::entry_for (C1StubId::predicate_failed_trap_id);\n+  address a = Runtime1::entry_for (StubId::c1_predicate_failed_trap_id);\n@@ -104,1 +104,1 @@\n-  ce->emit_call_c(Runtime1::entry_for (C1StubId::counter_overflow_id));\n+  ce->emit_call_c(Runtime1::entry_for (StubId::c1_counter_overflow_id));\n@@ -116,1 +116,1 @@\n-  ce->emit_call_c(Runtime1::entry_for (C1StubId::throw_div0_exception_id));\n+  ce->emit_call_c(Runtime1::entry_for (StubId::c1_throw_div0_exception_id));\n@@ -126,1 +126,1 @@\n-    a = Runtime1::entry_for (C1StubId::predicate_failed_trap_id);\n+    a = Runtime1::entry_for (StubId::c1_predicate_failed_trap_id);\n@@ -128,1 +128,1 @@\n-    a = Runtime1::entry_for (C1StubId::throw_null_pointer_exception_id);\n+    a = Runtime1::entry_for (StubId::c1_throw_null_pointer_exception_id);\n@@ -153,1 +153,1 @@\n-NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, C1StubId stub_id) {\n+NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, StubId stub_id) {\n@@ -158,3 +158,3 @@\n-  assert(stub_id == C1StubId::new_instance_id                 ||\n-         stub_id == C1StubId::fast_new_instance_id            ||\n-         stub_id == C1StubId::fast_new_instance_init_check_id,\n+  assert(stub_id == StubId::c1_new_instance_id                 ||\n+         stub_id == StubId::c1_fast_new_instance_id            ||\n+         stub_id == StubId::c1_fast_new_instance_init_check_id,\n@@ -188,1 +188,1 @@\n-  address a = Runtime1::entry_for (C1StubId::new_type_array_id);\n+  address a = Runtime1::entry_for (StubId::c1_new_type_array_id);\n@@ -208,1 +208,1 @@\n-  address a = Runtime1::entry_for (C1StubId::new_object_array_id);\n+  address a = Runtime1::entry_for (StubId::c1_new_object_array_id);\n@@ -219,1 +219,1 @@\n-  C1StubId enter_id;\n+  StubId enter_id;\n@@ -221,1 +221,1 @@\n-    enter_id = C1StubId::monitorenter_id;\n+    enter_id = StubId::c1_monitorenter_id;\n@@ -223,1 +223,1 @@\n-    enter_id = C1StubId::monitorenter_nofpu_id;\n+    enter_id = StubId::c1_monitorenter_nofpu_id;\n@@ -244,1 +244,1 @@\n-  C1StubId exit_id;\n+  StubId exit_id;\n@@ -246,1 +246,1 @@\n-    exit_id = C1StubId::monitorexit_id;\n+    exit_id = StubId::c1_monitorexit_id;\n@@ -248,1 +248,1 @@\n-    exit_id = C1StubId::monitorexit_nofpu_id;\n+    exit_id = StubId::c1_monitorexit_nofpu_id;\n@@ -380,4 +380,4 @@\n-    case access_field_id:  target = Runtime1::entry_for (C1StubId::access_field_patching_id); break;\n-    case load_klass_id:    target = Runtime1::entry_for (C1StubId::load_klass_patching_id); reloc_type = relocInfo::metadata_type; break;\n-    case load_mirror_id:   target = Runtime1::entry_for (C1StubId::load_mirror_patching_id); reloc_type = relocInfo::oop_type; break;\n-    case load_appendix_id: target = Runtime1::entry_for (C1StubId::load_appendix_patching_id); reloc_type = relocInfo::oop_type; break;\n+    case access_field_id:  target = Runtime1::entry_for (StubId::c1_access_field_patching_id); break;\n+    case load_klass_id:    target = Runtime1::entry_for (StubId::c1_load_klass_patching_id); reloc_type = relocInfo::metadata_type; break;\n+    case load_mirror_id:   target = Runtime1::entry_for (StubId::c1_load_mirror_patching_id); reloc_type = relocInfo::oop_type; break;\n+    case load_appendix_id: target = Runtime1::entry_for (StubId::c1_load_appendix_patching_id); reloc_type = relocInfo::oop_type; break;\n@@ -408,1 +408,1 @@\n-  ce->emit_call_c(Runtime1::entry_for (C1StubId::deoptimize_id));\n+  ce->emit_call_c(Runtime1::entry_for (StubId::c1_deoptimize_id));\n","filename":"src\/hotspot\/cpu\/s390\/c1_CodeStubs_s390.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-  address a = Runtime1::entry_for (C1StubId::handle_exception_from_callee_id);\n+  address a = Runtime1::entry_for (StubId::c1_handle_exception_from_callee_id);\n@@ -228,1 +228,1 @@\n-    \/\/ C1StubId::monitorexit_id expects lock address in Z_R1_scratch.\n+    \/\/ StubId::c1_monitorexit_id expects lock address in Z_R1_scratch.\n@@ -261,1 +261,1 @@\n-  __ load_const_optimized(Z_R5, Runtime1::entry_for (C1StubId::unwind_exception_id));\n+  __ load_const_optimized(Z_R5, Runtime1::entry_for (StubId::c1_unwind_exception_id));\n@@ -1934,2 +1934,2 @@\n-  address stub = Runtime1::entry_for (compilation()->has_fpu_code() ? C1StubId::handle_exception_id\n-                                                                    : C1StubId::handle_exception_nofpu_id);\n+  address stub = Runtime1::entry_for (compilation()->has_fpu_code() ? StubId::c1_handle_exception_id\n+                                                                    : StubId::c1_handle_exception_nofpu_id);\n@@ -2132,1 +2132,1 @@\n-      emit_call_c(Runtime1::entry_for (C1StubId::slow_subtype_check_id));\n+      emit_call_c(Runtime1::entry_for (StubId::c1_slow_subtype_check_id));\n@@ -2552,1 +2552,1 @@\n-      address a = Runtime1::entry_for (C1StubId::slow_subtype_check_id);\n+      address a = Runtime1::entry_for (StubId::c1_slow_subtype_check_id);\n@@ -2627,1 +2627,1 @@\n-    address a = Runtime1::entry_for (C1StubId::slow_subtype_check_id);\n+    address a = Runtime1::entry_for (StubId::c1_slow_subtype_check_id);\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -893,1 +893,1 @@\n-  __ call_runtime(Runtime1::entry_for (C1StubId::new_multi_array_id),\n+  __ call_runtime(Runtime1::entry_for (StubId::c1_new_multi_array_id),\n@@ -924,1 +924,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);\n+    stub = new SimpleExceptionStub(StubId::c1_throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);\n@@ -931,1 +931,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_class_cast_exception_id, obj.result(), info_for_exception);\n+    stub = new SimpleExceptionStub(StubId::c1_throw_class_cast_exception_id, obj.result(), info_for_exception);\n@@ -964,1 +964,1 @@\n-  return Runtime1::entry_for(C1StubId::is_instance_of_id);\n+  return Runtime1::entry_for(StubId::c1_is_instance_of_id);\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRGenerator_s390.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-  \/\/    call(RuntimeAddress(Runtime1::entry_for (C1StubId::dtrace_object_alloc_id)));\n+  \/\/    call(RuntimeAddress(Runtime1::entry_for (StubId::c1_dtrace_object_alloc_id)));\n@@ -326,1 +326,1 @@\n-  \/\/   call(RuntimeAddress(Runtime1::entry_for (C1StubId::dtrace_object_alloc_id)));\n+  \/\/   call(RuntimeAddress(Runtime1::entry_for (StubId::c1_dtrace_object_alloc_id)));\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-    } else if (_stub_id == (int)C1StubId::forward_exception_id) {\n+    } else if (_stub_id == (int)StubId::c1_forward_exception_id) {\n@@ -103,1 +103,1 @@\n-      load_const_optimized(Z_R1, Runtime1::entry_for (C1StubId::forward_exception_id));\n+      load_const_optimized(Z_R1, Runtime1::entry_for (StubId::c1_forward_exception_id));\n@@ -312,1 +312,1 @@\n-OopMapSet* Runtime1::generate_code_for(C1StubId id, StubAssembler* sasm) {\n+OopMapSet* Runtime1::generate_code_for(StubId id, StubAssembler* sasm) {\n@@ -325,1 +325,1 @@\n-    case C1StubId::forward_exception_id:\n+    case StubId::c1_forward_exception_id:\n@@ -332,3 +332,3 @@\n-    case C1StubId::new_instance_id:\n-    case C1StubId::fast_new_instance_id:\n-    case C1StubId::fast_new_instance_init_check_id:\n+    case StubId::c1_new_instance_id:\n+    case StubId::c1_fast_new_instance_id:\n+    case StubId::c1_fast_new_instance_init_check_id:\n@@ -339,1 +339,1 @@\n-        if (id == C1StubId::new_instance_id) {\n+        if (id == StubId::c1_new_instance_id) {\n@@ -341,1 +341,1 @@\n-        } else if (id == C1StubId::fast_new_instance_id) {\n+        } else if (id == StubId::c1_fast_new_instance_id) {\n@@ -344,1 +344,1 @@\n-          assert(id == C1StubId::fast_new_instance_init_check_id, \"bad C1StubId\");\n+          assert(id == StubId::c1_fast_new_instance_init_check_id, \"bad StubId\");\n@@ -359,1 +359,1 @@\n-    case C1StubId::counter_overflow_id:\n+    case StubId::c1_counter_overflow_id:\n@@ -378,2 +378,2 @@\n-    case C1StubId::new_type_array_id:\n-    case C1StubId::new_object_array_id:\n+    case StubId::c1_new_type_array_id:\n+    case StubId::c1_new_object_array_id:\n@@ -385,1 +385,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -398,1 +398,1 @@\n-          int tag = ((id == C1StubId::new_type_array_id)\n+          int tag = ((id == StubId::c1_new_type_array_id)\n@@ -410,1 +410,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -425,1 +425,1 @@\n-    case C1StubId::new_multi_array_id:\n+    case StubId::c1_new_multi_array_id:\n@@ -443,1 +443,1 @@\n-    case C1StubId::register_finalizer_id:\n+    case StubId::c1_register_finalizer_id:\n@@ -466,1 +466,1 @@\n-    case C1StubId::throw_range_check_failed_id:\n+    case StubId::c1_throw_range_check_failed_id:\n@@ -472,1 +472,1 @@\n-    case C1StubId::throw_index_exception_id:\n+    case StubId::c1_throw_index_exception_id:\n@@ -477,1 +477,1 @@\n-    case C1StubId::throw_div0_exception_id:\n+    case StubId::c1_throw_div0_exception_id:\n@@ -482,1 +482,1 @@\n-    case C1StubId::throw_null_pointer_exception_id:\n+    case StubId::c1_throw_null_pointer_exception_id:\n@@ -487,2 +487,2 @@\n-    case C1StubId::handle_exception_nofpu_id:\n-    case C1StubId::handle_exception_id:\n+    case StubId::c1_handle_exception_nofpu_id:\n+    case StubId::c1_handle_exception_id:\n@@ -493,1 +493,1 @@\n-    case C1StubId::handle_exception_from_callee_id:\n+    case StubId::c1_handle_exception_from_callee_id:\n@@ -498,1 +498,1 @@\n-    case C1StubId::unwind_exception_id:\n+    case StubId::c1_unwind_exception_id:\n@@ -505,1 +505,1 @@\n-    case C1StubId::throw_array_store_exception_id:\n+    case StubId::c1_throw_array_store_exception_id:\n@@ -510,1 +510,1 @@\n-    case C1StubId::throw_class_cast_exception_id:\n+    case StubId::c1_throw_class_cast_exception_id:\n@@ -516,1 +516,1 @@\n-    case C1StubId::throw_incompatible_class_change_error_id:\n+    case StubId::c1_throw_incompatible_class_change_error_id:\n@@ -521,1 +521,1 @@\n-    case C1StubId::slow_subtype_check_id:\n+    case StubId::c1_slow_subtype_check_id:\n@@ -592,1 +592,1 @@\n-    case C1StubId::is_instance_of_id:\n+    case StubId::c1_is_instance_of_id:\n@@ -653,2 +653,2 @@\n-    case C1StubId::monitorenter_nofpu_id:\n-    case C1StubId::monitorenter_id:\n+    case StubId::c1_monitorenter_nofpu_id:\n+    case StubId::c1_monitorenter_id:\n@@ -659,1 +659,1 @@\n-        int save_fpu_registers = (id == C1StubId::monitorenter_id);\n+        int save_fpu_registers = (id == StubId::c1_monitorenter_id);\n@@ -673,2 +673,2 @@\n-    case C1StubId::monitorexit_nofpu_id:\n-    case C1StubId::monitorexit_id:\n+    case StubId::c1_monitorexit_nofpu_id:\n+    case StubId::c1_monitorexit_id:\n@@ -681,1 +681,1 @@\n-        int save_fpu_registers = (id == C1StubId::monitorexit_id);\n+        int save_fpu_registers = (id == StubId::c1_monitorexit_id);\n@@ -695,1 +695,1 @@\n-    case C1StubId::deoptimize_id:\n+    case StubId::c1_deoptimize_id:\n@@ -712,1 +712,1 @@\n-    case C1StubId::access_field_patching_id:\n+    case StubId::c1_access_field_patching_id:\n@@ -718,1 +718,1 @@\n-    case C1StubId::load_klass_patching_id:\n+    case StubId::c1_load_klass_patching_id:\n@@ -725,1 +725,1 @@\n-    case C1StubId::load_mirror_patching_id:\n+    case StubId::c1_load_mirror_patching_id:\n@@ -731,1 +731,1 @@\n-    case C1StubId::load_appendix_patching_id:\n+    case StubId::c1_load_appendix_patching_id:\n@@ -737,1 +737,1 @@\n-    case C1StubId::dtrace_object_alloc_id:\n+    case StubId::c1_dtrace_object_alloc_id:\n@@ -752,1 +752,1 @@\n-    case C1StubId::fpu2long_stub_id:\n+    case StubId::c1_fpu2long_stub_id:\n@@ -827,1 +827,1 @@\n-    case C1StubId::predicate_failed_trap_id:\n+    case StubId::c1_predicate_failed_trap_id:\n@@ -855,1 +855,1 @@\n-OopMapSet* Runtime1::generate_handle_exception(C1StubId id, StubAssembler *sasm) {\n+OopMapSet* Runtime1::generate_handle_exception(StubId id, StubAssembler *sasm) {\n@@ -866,1 +866,1 @@\n-    case C1StubId::forward_exception_id: {\n+    case StubId::c1_forward_exception_id: {\n@@ -893,2 +893,2 @@\n-    case C1StubId::handle_exception_nofpu_id:\n-    case C1StubId::handle_exception_id:\n+    case StubId::c1_handle_exception_nofpu_id:\n+    case StubId::c1_handle_exception_id:\n@@ -897,1 +897,1 @@\n-      oop_map = save_live_registers(sasm, id != C1StubId::handle_exception_nofpu_id, Z_EXC_PC);\n+      oop_map = save_live_registers(sasm, id != StubId::c1_handle_exception_nofpu_id, Z_EXC_PC);\n@@ -899,1 +899,1 @@\n-    case C1StubId::handle_exception_from_callee_id: {\n+    case StubId::c1_handle_exception_from_callee_id: {\n@@ -948,3 +948,3 @@\n-    case C1StubId::forward_exception_id:\n-    case C1StubId::handle_exception_nofpu_id:\n-    case C1StubId::handle_exception_id:\n+    case StubId::c1_forward_exception_id:\n+    case StubId::c1_handle_exception_nofpu_id:\n+    case StubId::c1_handle_exception_id:\n@@ -953,1 +953,1 @@\n-      restore_live_registers(sasm, id != C1StubId::handle_exception_nofpu_id);  \/\/ Pops as well the frame.\n+      restore_live_registers(sasm, id != StubId::c1_handle_exception_nofpu_id);  \/\/ Pops as well the frame.\n@@ -956,1 +956,1 @@\n-    case C1StubId::handle_exception_from_callee_id: {\n+    case StubId::c1_handle_exception_from_callee_id: {\n","filename":"src\/hotspot\/cpu\/s390\/c1_Runtime1_s390.cpp","additions":56,"deletions":56,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n+  const char* name = OptoRuntime::stub_name(StubId::c2_exception_id);\n@@ -121,1 +121,1 @@\n-  \/\/ C2I adapter extensions are now removed by a resize in the frame manager\n+  \/\/ C2I adapter extensions are now removed by a resize in the template interpreter\n","filename":"src\/hotspot\/cpu\/s390\/runtime_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2142,1 +2142,1 @@\n-  \/\/ In addition, frame manager expects initial_caller_sp in Z_R10.\n+  \/\/ In addition, template interpreter expects initial_caller_sp in Z_R10.\n@@ -2547,1 +2547,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::deopt_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_deopt_id);\n@@ -2770,1 +2770,1 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n+  const char* name = OptoRuntime::stub_name(StubId::c2_uncommon_trap_id);\n@@ -2898,1 +2898,1 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(StubId id, address call_ptr) {\n@@ -2916,1 +2916,1 @@\n-  bool cause_return = (id == SharedStubId::polling_page_return_handler_id);\n+  bool cause_return = (id == StubId::shared_polling_page_return_handler_id);\n@@ -2922,1 +2922,1 @@\n-  bool save_vectors = (id == SharedStubId::polling_page_vectors_safepoint_handler_id);\n+  bool save_vectors = (id == StubId::shared_polling_page_vectors_safepoint_handler_id);\n@@ -3002,1 +3002,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(StubId id, address destination) {\n@@ -3101,1 +3101,1 @@\n-RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+RuntimeStub* SharedRuntime::generate_throw_exception(StubId id, address runtime_entry) {\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-    \/\/ Set up a new C frame, copy Java arguments, call frame manager\n+    \/\/ Set up a new C frame, copy Java arguments, call template interpreter\n@@ -121,1 +121,1 @@\n-    StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+    StubId stub_id = StubId::stubgen_call_stub_id;\n@@ -275,1 +275,1 @@\n-      \/\/ Call frame manager or native entry.\n+      \/\/ Call template interpreter or native entry.\n@@ -278,1 +278,1 @@\n-      \/\/ Register state on entry to frame manager \/ native entry:\n+      \/\/ Register state on entry to template interpreter \/ native entry:\n@@ -293,1 +293,1 @@\n-      \/\/ Stack on entry to frame manager \/ native entry:\n+      \/\/ Stack on entry to template interpreter \/ native entry:\n@@ -303,1 +303,1 @@\n-      \/\/ of the interpreter entry point (frame manager or native entry)\n+      \/\/ of the interpreter entry point (template interpreter or native entry)\n@@ -312,1 +312,1 @@\n-      \/\/ Returned from frame manager or native entry.\n+      \/\/ Returned from template interpreter or native entry.\n@@ -316,1 +316,1 @@\n-      \/\/ Stack on exit from frame manager \/ native entry:\n+      \/\/ Stack on exit from template interpreter \/ native entry:\n@@ -333,1 +333,1 @@\n-      \/\/ to frame manager \/ native entry.\n+      \/\/ to template interpreter \/ native entry.\n@@ -462,1 +462,1 @@\n-    StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+    StubId stub_id = StubId::stubgen_catch_exception_id;\n@@ -514,1 +514,1 @@\n-    StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+    StubId stub_id = StubId::stubgen_forward_exception_id;\n@@ -595,1 +595,1 @@\n-    StubGenStubId stub_id = StubGenStubId::partial_subtype_check_id;\n+    StubId stub_id = StubId::stubgen_partial_subtype_check_id;\n@@ -629,1 +629,1 @@\n-    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n+    StubId stub_id = StubId::stubgen_lookup_secondary_supers_table_id;\n@@ -652,1 +652,1 @@\n-    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_slow_path_id;\n+    StubId stub_id = StubId::stubgen_lookup_secondary_supers_table_slow_path_id;\n@@ -1268,1 +1268,1 @@\n-  address generate_disjoint_nonoop_copy(StubGenStubId stub_id) {\n+  address generate_disjoint_nonoop_copy(StubId stub_id) {\n@@ -1272,1 +1272,1 @@\n-    case jbyte_disjoint_arraycopy_id:\n+    case StubId::stubgen_jbyte_disjoint_arraycopy_id:\n@@ -1276,1 +1276,1 @@\n-    case arrayof_jbyte_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id:\n@@ -1280,1 +1280,1 @@\n-    case jshort_disjoint_arraycopy_id:\n+    case StubId::stubgen_jshort_disjoint_arraycopy_id:\n@@ -1284,1 +1284,1 @@\n-    case arrayof_jshort_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id:\n@@ -1288,1 +1288,1 @@\n-    case jint_disjoint_arraycopy_id:\n+    case StubId::stubgen_jint_disjoint_arraycopy_id:\n@@ -1292,1 +1292,1 @@\n-    case arrayof_jint_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jint_disjoint_arraycopy_id:\n@@ -1296,1 +1296,1 @@\n-    case jlong_disjoint_arraycopy_id:\n+    case StubId::stubgen_jlong_disjoint_arraycopy_id:\n@@ -1300,1 +1300,1 @@\n-    case arrayof_jlong_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id:\n@@ -1313,1 +1313,1 @@\n-  address generate_disjoint_oop_copy(StubGenStubId stub_id) {\n+  address generate_disjoint_oop_copy(StubId stub_id) {\n@@ -1317,1 +1317,1 @@\n-    case oop_disjoint_arraycopy_id:\n+    case StubId::stubgen_oop_disjoint_arraycopy_id:\n@@ -1321,1 +1321,1 @@\n-    case arrayof_oop_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_oop_disjoint_arraycopy_id:\n@@ -1325,1 +1325,1 @@\n-    case oop_disjoint_arraycopy_uninit_id:\n+    case StubId::stubgen_oop_disjoint_arraycopy_uninit_id:\n@@ -1329,1 +1329,1 @@\n-    case arrayof_oop_disjoint_arraycopy_uninit_id:\n+    case StubId::stubgen_arrayof_oop_disjoint_arraycopy_uninit_id:\n@@ -1360,1 +1360,1 @@\n-  address generate_conjoint_nonoop_copy(StubGenStubId stub_id) {\n+  address generate_conjoint_nonoop_copy(StubId stub_id) {\n@@ -1365,1 +1365,1 @@\n-    case jbyte_arraycopy_id:\n+    case StubId::stubgen_jbyte_arraycopy_id:\n@@ -1370,1 +1370,1 @@\n-    case arrayof_jbyte_arraycopy_id:\n+    case StubId::stubgen_arrayof_jbyte_arraycopy_id:\n@@ -1375,1 +1375,1 @@\n-    case jshort_arraycopy_id:\n+    case StubId::stubgen_jshort_arraycopy_id:\n@@ -1380,1 +1380,1 @@\n-    case arrayof_jshort_arraycopy_id:\n+    case StubId::stubgen_arrayof_jshort_arraycopy_id:\n@@ -1385,1 +1385,1 @@\n-    case jint_arraycopy_id:\n+    case StubId::stubgen_jint_arraycopy_id:\n@@ -1390,1 +1390,1 @@\n-    case arrayof_jint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jint_arraycopy_id:\n@@ -1395,1 +1395,1 @@\n-    case jlong_arraycopy_id:\n+    case StubId::stubgen_jlong_arraycopy_id:\n@@ -1400,1 +1400,1 @@\n-    case arrayof_jlong_arraycopy_id:\n+    case StubId::stubgen_arrayof_jlong_arraycopy_id:\n@@ -1415,1 +1415,1 @@\n-  address generate_conjoint_oop_copy(StubGenStubId stub_id) {\n+  address generate_conjoint_oop_copy(StubId stub_id) {\n@@ -1420,1 +1420,1 @@\n-    case oop_arraycopy_id:\n+    case StubId::stubgen_oop_arraycopy_id:\n@@ -1425,1 +1425,1 @@\n-    case arrayof_oop_arraycopy_id:\n+    case StubId::stubgen_arrayof_oop_arraycopy_id:\n@@ -1430,1 +1430,1 @@\n-    case oop_arraycopy_uninit_id:\n+    case StubId::stubgen_oop_arraycopy_uninit_id:\n@@ -1435,1 +1435,1 @@\n-    case arrayof_oop_arraycopy_uninit_id:\n+    case StubId::stubgen_arrayof_oop_arraycopy_uninit_id:\n@@ -1471,0 +1471,105 @@\n+  \/\/\n+  \/\/  Generate 'unsafe' set memory stub\n+  \/\/  Though just as safe as the other stubs, it takes an unscaled\n+  \/\/  size_t (# bytes) argument instead of an element count.\n+  \/\/\n+  \/\/  Input:\n+  \/\/    Z_ARG1   - destination array address\n+  \/\/    Z_ARG2   - byte count (size_t)\n+  \/\/    Z_ARG3   - byte value\n+  \/\/\n+  address generate_unsafe_setmemory(address unsafe_byte_fill) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, StubId::stubgen_unsafe_setmemory_id);\n+    unsigned int start_off = __ offset();\n+\n+    \/\/ bump this on entry, not on exit:\n+    \/\/ inc_counter_np(SharedRuntime::_unsafe_set_memory_ctr);\n+\n+    const Register dest = Z_ARG1;\n+    const Register size = Z_ARG2;\n+    const Register byteVal = Z_ARG3;\n+    NearLabel tail, finished;\n+    \/\/ fill_to_memory_atomic(unsigned char*, unsigned long, unsigned char)\n+\n+    \/\/ Mark remaining code as such which performs Unsafe accesses.\n+    UnsafeMemoryAccessMark umam(this, true, false);\n+\n+    __ z_vlvgb(Z_V0, byteVal, 0);\n+    __ z_vrepb(Z_V0, Z_V0, 0);\n+\n+    __ z_aghi(size, -32);\n+    __ z_brl(tail);\n+\n+    {\n+      NearLabel again;\n+      __ bind(again);\n+      __ z_vst(Z_V0, Address(dest, 0));\n+      __ z_vst(Z_V0, Address(dest, 16));\n+      __ z_aghi(dest, 32);\n+      __ z_aghi(size, -32);\n+      __ z_brnl(again);\n+    }\n+\n+    __ bind(tail);\n+\n+    {\n+      NearLabel dont;\n+      __ testbit(size, 4);\n+      __ z_brz(dont);\n+      __ z_vst(Z_V0, Address(dest, 0));\n+      __ z_aghi(dest, 16);\n+      __ bind(dont);\n+    }\n+\n+    {\n+      NearLabel dont;\n+      __ testbit(size, 3);\n+      __ z_brz(dont);\n+      __ z_vsteg(Z_V0, 0, Z_R0, dest, 0);\n+      __ z_aghi(dest, 8);\n+      __ bind(dont);\n+    }\n+\n+    __ z_tmll(size, 7);\n+    __ z_brc(Assembler::bcondAllZero, finished);\n+\n+    {\n+      NearLabel dont;\n+      __ testbit(size, 2);\n+      __ z_brz(dont);\n+      __ z_vstef(Z_V0, 0, Z_R0, dest, 0);\n+      __ z_aghi(dest, 4);\n+      __ bind(dont);\n+    }\n+\n+    {\n+      NearLabel dont;\n+      __ testbit(size, 1);\n+      __ z_brz(dont);\n+      __ z_vsteh(Z_V0, 0, Z_R0, dest, 0);\n+      __ z_aghi(dest, 2);\n+      __ bind(dont);\n+    }\n+\n+    {\n+      NearLabel dont;\n+      __ testbit(size, 0);\n+      __ z_brz(dont);\n+      __ z_vsteb(Z_V0, 0, Z_R0, dest, 0);\n+      __ bind(dont);\n+    }\n+\n+    __ bind(finished);\n+    __ z_br(Z_R14);\n+\n+    return __ addr_at(start_off);\n+  }\n+\n+  \/\/ This is common errorexit stub for UnsafeMemoryAccess.\n+  address generate_unsafecopy_common_error_exit() {\n+    unsigned int start_off = __ offset();\n+    __ z_lghi(Z_RET, 0); \/\/ return 0\n+    __ z_br(Z_R14);\n+    return __ addr_at(start_off);\n+  }\n@@ -1476,27 +1581,37 @@\n-    StubRoutines::_jbyte_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubGenStubId::jbyte_disjoint_arraycopy_id);\n-    StubRoutines::_jshort_disjoint_arraycopy     = generate_disjoint_nonoop_copy(StubGenStubId::jshort_disjoint_arraycopy_id);\n-    StubRoutines::_jint_disjoint_arraycopy       = generate_disjoint_nonoop_copy  (StubGenStubId::jint_disjoint_arraycopy_id);\n-    StubRoutines::_jlong_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubGenStubId::jlong_disjoint_arraycopy_id);\n-    StubRoutines::_oop_disjoint_arraycopy        = generate_disjoint_oop_copy  (StubGenStubId::oop_disjoint_arraycopy_id);\n-    StubRoutines::_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy  (StubGenStubId::oop_disjoint_arraycopy_uninit_id);\n-\n-    StubRoutines::_arrayof_jbyte_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubGenStubId::arrayof_jbyte_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_jshort_disjoint_arraycopy     = generate_disjoint_nonoop_copy(StubGenStubId::arrayof_jshort_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_jint_disjoint_arraycopy       = generate_disjoint_nonoop_copy  (StubGenStubId::arrayof_jint_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_jlong_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubGenStubId::arrayof_jlong_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_oop_disjoint_arraycopy        = generate_disjoint_oop_copy  (StubGenStubId::arrayof_oop_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy  (StubGenStubId::arrayof_oop_disjoint_arraycopy_uninit_id);\n-\n-    StubRoutines::_jbyte_arraycopy           = generate_conjoint_nonoop_copy(StubGenStubId::jbyte_arraycopy_id);\n-    StubRoutines::_jshort_arraycopy          = generate_conjoint_nonoop_copy(StubGenStubId::jshort_arraycopy_id);\n-    StubRoutines::_jint_arraycopy            = generate_conjoint_nonoop_copy(StubGenStubId::jint_arraycopy_id);\n-    StubRoutines::_jlong_arraycopy           = generate_conjoint_nonoop_copy(StubGenStubId::jlong_arraycopy_id);\n-    StubRoutines::_oop_arraycopy             = generate_conjoint_oop_copy(StubGenStubId::oop_arraycopy_id);\n-    StubRoutines::_oop_arraycopy_uninit      = generate_conjoint_oop_copy(StubGenStubId::oop_arraycopy_uninit_id);\n-\n-    StubRoutines::_arrayof_jbyte_arraycopy      = generate_conjoint_nonoop_copy(StubGenStubId::arrayof_jbyte_arraycopy_id);\n-    StubRoutines::_arrayof_jshort_arraycopy     = generate_conjoint_nonoop_copy(StubGenStubId::arrayof_jshort_arraycopy_id);\n-    StubRoutines::_arrayof_jint_arraycopy       = generate_conjoint_nonoop_copy (StubGenStubId::arrayof_jint_arraycopy_id);\n-    StubRoutines::_arrayof_jlong_arraycopy      = generate_conjoint_nonoop_copy(StubGenStubId::arrayof_jlong_arraycopy_id);\n-    StubRoutines::_arrayof_oop_arraycopy        = generate_conjoint_oop_copy(StubGenStubId::arrayof_oop_arraycopy_id);\n-    StubRoutines::_arrayof_oop_arraycopy_uninit = generate_conjoint_oop_copy(StubGenStubId::arrayof_oop_arraycopy_uninit_id);\n+\n+    address ucm_common_error_exit       =  generate_unsafecopy_common_error_exit();\n+    UnsafeMemoryAccess::set_common_exit_stub_pc(ucm_common_error_exit);\n+\n+    StubRoutines::_jbyte_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubId::stubgen_jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_jshort_disjoint_arraycopy     = generate_disjoint_nonoop_copy(StubId::stubgen_jshort_disjoint_arraycopy_id);\n+    StubRoutines::_jint_disjoint_arraycopy       = generate_disjoint_nonoop_copy  (StubId::stubgen_jint_disjoint_arraycopy_id);\n+    StubRoutines::_jlong_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubId::stubgen_jlong_disjoint_arraycopy_id);\n+    StubRoutines::_oop_disjoint_arraycopy        = generate_disjoint_oop_copy  (StubId::stubgen_oop_disjoint_arraycopy_id);\n+    StubRoutines::_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy  (StubId::stubgen_oop_disjoint_arraycopy_uninit_id);\n+\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy     = generate_disjoint_nonoop_copy(StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy       = generate_disjoint_nonoop_copy  (StubId::stubgen_arrayof_jint_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy        = generate_disjoint_oop_copy  (StubId::stubgen_arrayof_oop_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy  (StubId::stubgen_arrayof_oop_disjoint_arraycopy_uninit_id);\n+\n+    StubRoutines::_jbyte_arraycopy           = generate_conjoint_nonoop_copy(StubId::stubgen_jbyte_arraycopy_id);\n+    StubRoutines::_jshort_arraycopy          = generate_conjoint_nonoop_copy(StubId::stubgen_jshort_arraycopy_id);\n+    StubRoutines::_jint_arraycopy            = generate_conjoint_nonoop_copy(StubId::stubgen_jint_arraycopy_id);\n+    StubRoutines::_jlong_arraycopy           = generate_conjoint_nonoop_copy(StubId::stubgen_jlong_arraycopy_id);\n+    StubRoutines::_oop_arraycopy             = generate_conjoint_oop_copy(StubId::stubgen_oop_arraycopy_id);\n+    StubRoutines::_oop_arraycopy_uninit      = generate_conjoint_oop_copy(StubId::stubgen_oop_arraycopy_uninit_id);\n+\n+    StubRoutines::_arrayof_jbyte_arraycopy      = generate_conjoint_nonoop_copy(StubId::stubgen_arrayof_jbyte_arraycopy_id);\n+    StubRoutines::_arrayof_jshort_arraycopy     = generate_conjoint_nonoop_copy(StubId::stubgen_arrayof_jshort_arraycopy_id);\n+    StubRoutines::_arrayof_jint_arraycopy       = generate_conjoint_nonoop_copy (StubId::stubgen_arrayof_jint_arraycopy_id);\n+    StubRoutines::_arrayof_jlong_arraycopy      = generate_conjoint_nonoop_copy(StubId::stubgen_arrayof_jlong_arraycopy_id);\n+    StubRoutines::_arrayof_oop_arraycopy        = generate_conjoint_oop_copy(StubId::stubgen_arrayof_oop_arraycopy_id);\n+    StubRoutines::_arrayof_oop_arraycopy_uninit = generate_conjoint_oop_copy(StubId::stubgen_arrayof_oop_arraycopy_uninit_id);\n+\n+#ifdef COMPILER2\n+    StubRoutines::_unsafe_setmemory =\n+             VM_Version::has_VectorFacility() ? generate_unsafe_setmemory(StubRoutines::_jbyte_fill) : nullptr;\n+\n+#endif \/\/ COMPILER2\n@@ -1786,1 +1901,1 @@\n-    StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+    StubId stub_id = StubId::stubgen_aescrypt_encryptBlock_id;\n@@ -1798,1 +1913,1 @@\n-    StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+    StubId stub_id = StubId::stubgen_aescrypt_decryptBlock_id;\n@@ -1859,1 +1974,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_encryptAESCrypt_id;\n+    StubId stub_id = StubId::stubgen_cipherBlockChaining_encryptAESCrypt_id;\n@@ -1871,1 +1986,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_decryptAESCrypt_id;\n+    StubId stub_id = StubId::stubgen_cipherBlockChaining_decryptAESCrypt_id;\n@@ -2578,1 +2693,1 @@\n-    StubGenStubId stub_id = StubGenStubId::counterMode_AESCrypt_id;\n+    StubId stub_id = StubId::stubgen_counterMode_AESCrypt_id;\n@@ -2592,1 +2707,1 @@\n-    StubGenStubId stub_id = StubGenStubId::ghash_processBlocks_id;\n+    StubId stub_id = StubId::stubgen_ghash_processBlocks_id;\n@@ -2670,1 +2785,1 @@\n-  address generate_SHA1_stub(StubGenStubId stub_id) {\n+  address generate_SHA1_stub(StubId stub_id) {\n@@ -2673,1 +2788,1 @@\n-    case sha1_implCompress_id:\n+    case StubId::stubgen_sha1_implCompress_id:\n@@ -2676,1 +2791,1 @@\n-    case sha1_implCompressMB_id:\n+    case StubId::stubgen_sha1_implCompressMB_id:\n@@ -2763,1 +2878,1 @@\n-  address generate_SHA256_stub(StubGenStubId stub_id) {\n+  address generate_SHA256_stub(StubId stub_id) {\n@@ -2766,1 +2881,1 @@\n-    case sha256_implCompress_id:\n+    case StubId::stubgen_sha256_implCompress_id:\n@@ -2769,1 +2884,1 @@\n-    case sha256_implCompressMB_id:\n+    case StubId::stubgen_sha256_implCompressMB_id:\n@@ -2854,1 +2969,1 @@\n-  address generate_SHA512_stub(StubGenStubId stub_id) {\n+  address generate_SHA512_stub(StubId stub_id) {\n@@ -2857,1 +2972,1 @@\n-    case sha512_implCompress_id:\n+    case StubId::stubgen_sha512_implCompress_id:\n@@ -2860,1 +2975,1 @@\n-    case sha512_implCompressMB_id:\n+    case StubId::stubgen_sha512_implCompressMB_id:\n@@ -2990,1 +3105,1 @@\n-    StubGenStubId stub_id =  StubGenStubId::updateBytesCRC32_id;\n+    StubId stub_id =  StubId::stubgen_updateBytesCRC32_id;\n@@ -3010,1 +3125,1 @@\n-    StubGenStubId stub_id =  StubGenStubId::updateBytesCRC32C_id;\n+    StubId stub_id =  StubId::stubgen_updateBytesCRC32C_id;\n@@ -3035,1 +3150,1 @@\n-    StubGenStubId stub_id =  StubGenStubId::multiplyToLen_id;\n+    StubId stub_id =  StubId::stubgen_multiplyToLen_id;\n@@ -3067,1 +3182,1 @@\n-    StubGenStubId stub_id =  StubGenStubId::method_entry_barrier_id;\n+    StubId stub_id =  StubId::stubgen_method_entry_barrier_id;\n@@ -3085,1 +3200,1 @@\n-    __ z_ltr(Z_R0_scratch, Z_RET);\n+    __ z_ltr(Z_RET, Z_RET);\n@@ -3133,1 +3248,1 @@\n-    StubGenStubId stub_id =  StubGenStubId::upcall_stub_exception_handler_id;\n+    StubId stub_id =  StubId::stubgen_upcall_stub_exception_handler_id;\n@@ -3151,1 +3266,1 @@\n-    StubGenStubId stub_id =  StubGenStubId::upcall_stub_load_target_id;\n+    StubId stub_id =  StubId::stubgen_upcall_stub_load_target_id;\n@@ -3171,0 +3286,4 @@\n+  void generate_preuniverse_stubs() {\n+    \/\/ preuniverse stubs are not needed for s390\n+  }\n+\n@@ -3187,0 +3306,4 @@\n+    if (UnsafeMemoryAccess::_table == nullptr) {\n+      UnsafeMemoryAccess::create_table(4); \/\/ 4 for setMemory\n+    }\n+\n@@ -3271,2 +3394,2 @@\n-      StubRoutines::_sha1_implCompress     = generate_SHA1_stub(StubGenStubId::sha1_implCompress_id);\n-      StubRoutines::_sha1_implCompressMB   = generate_SHA1_stub(StubGenStubId::sha1_implCompressMB_id);\n+      StubRoutines::_sha1_implCompress     = generate_SHA1_stub(StubId::stubgen_sha1_implCompress_id);\n+      StubRoutines::_sha1_implCompressMB   = generate_SHA1_stub(StubId::stubgen_sha1_implCompressMB_id);\n@@ -3275,2 +3398,2 @@\n-      StubRoutines::_sha256_implCompress   = generate_SHA256_stub(StubGenStubId::sha256_implCompress_id);\n-      StubRoutines::_sha256_implCompressMB = generate_SHA256_stub(StubGenStubId::sha256_implCompressMB_id);\n+      StubRoutines::_sha256_implCompress   = generate_SHA256_stub(StubId::stubgen_sha256_implCompress_id);\n+      StubRoutines::_sha256_implCompressMB = generate_SHA256_stub(StubId::stubgen_sha256_implCompressMB_id);\n@@ -3279,2 +3402,2 @@\n-      StubRoutines::_sha512_implCompress   = generate_SHA512_stub(StubGenStubId::sha512_implCompress_id);\n-      StubRoutines::_sha512_implCompressMB = generate_SHA512_stub(StubGenStubId::sha512_implCompressMB_id);\n+      StubRoutines::_sha512_implCompress   = generate_SHA512_stub(StubId::stubgen_sha512_implCompress_id);\n+      StubRoutines::_sha512_implCompressMB = generate_SHA512_stub(StubId::stubgen_sha512_implCompressMB_id);\n@@ -3300,1 +3423,1 @@\n-  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+  StubGenerator(CodeBuffer* code, BlobId blob_id) : StubCodeGenerator(code, blob_id) {\n@@ -3302,1 +3425,4 @@\n-    case initial_id:\n+    case BlobId::stubgen_preuniverse_id:\n+      generate_preuniverse_stubs();\n+      break;\n+    case BlobId::stubgen_initial_id:\n@@ -3305,1 +3431,1 @@\n-     case continuation_id:\n+    case BlobId::stubgen_continuation_id:\n@@ -3308,1 +3434,1 @@\n-    case compiler_id:\n+    case BlobId::stubgen_compiler_id:\n@@ -3311,1 +3437,1 @@\n-    case final_id:\n+    case BlobId::stubgen_final_id:\n@@ -3315,1 +3441,1 @@\n-      fatal(\"unexpected blob id: %d\", blob_id);\n+      fatal(\"unexpected blob id: %s\", StubInfo::name(blob_id));\n@@ -3354,1 +3480,1 @@\n-void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+void StubGenerator_generate(CodeBuffer* code, BlobId blob_id) {\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":230,"deletions":104,"binary":false,"changes":334,"status":"modified"},{"patch":"@@ -283,2 +283,1 @@\n-\n-void Assembler::emit_arith(int op1, int op2, Register dst, int32_t imm32) {\n+void Assembler::emit_arith(int op1, int op2, Register dst, int32_t imm32, bool optimize_rax_dst) {\n@@ -291,1 +290,1 @@\n-  } else if (dst == rax) {\n+  } else if (optimize_rax_dst && dst == rax) {\n@@ -310,15 +309,0 @@\n-void Assembler::emit_arith_ndd(int op1, int op2, Register dst, int32_t imm32) {\n-  assert(isByte(op1) && isByte(op2), \"wrong opcode\");\n-  assert(op1 == 0x81, \"Unexpected opcode\");\n-  \/\/ This code cache friendly optimization saves 3 bytes per encoding, which offsets the EVEX encoding penalty.\n-  if (is8bit(imm32)) {\n-    emit_int24(op1 | 0x02,        \/\/ set sign bit\n-               op2 | encode(dst),\n-               imm32 & 0xFF);\n-  }\n-  else {\n-    emit_int16(op1, (op2 | encode(dst)));\n-    emit_int32(imm32);\n-  }\n-}\n-\n@@ -1367,1 +1351,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -1419,1 +1403,1 @@\n-  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -1430,3 +1414,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_arith_ndd(0x81, 0xC0, src, imm32);\n+  emit_eevex_prefix_or_demote_arith_ndd(dst, src, imm32, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0x81, 0xC0, no_flags);\n@@ -1444,5 +1426,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n-  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_int8(0x03);\n-  emit_operand(src1, src2, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0x03, no_flags);\n@@ -1460,1 +1438,1 @@\n-  (void)evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  (void)emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -1650,1 +1628,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -1660,3 +1638,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_arith_ndd(0x81, 0xE0, src, imm32);\n+  emit_eevex_prefix_or_demote_arith_ndd(dst, src, imm32, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0x81, 0xE0, no_flags);\n@@ -1681,5 +1657,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n-  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_int8(0x23);\n-  emit_operand(src1, src2, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0x23, no_flags);\n@@ -1697,1 +1669,1 @@\n-  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  (void) emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -1844,3 +1816,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n-  emit_int16((0x40 | cc), (0xC0 | encode));\n+  emit_eevex_or_demote(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0x40 | cc, false \/* no_flags *\/, true \/* is_map1 *\/,  true \/* swap *\/);\n@@ -1858,5 +1828,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n-  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n-  emit_int8((0x40 | cc));\n-  emit_operand(src1, src2, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, (0x40 | cc) , false \/* no_flags *\/, true \/* is_map1 *\/);\n@@ -2032,1 +1998,1 @@\n-    int encode = vex_prefix_and_encode(crc->encoding(), 0, v->encoding(), sizeInBytes == 2 ? VEX_SIMD_66 : VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, true);\n+    int encode = vex_prefix_and_encode(crc->encoding(), 0, v->encoding(), sizeInBytes == 2 ? VEX_SIMD_66 : VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, true);\n@@ -2079,1 +2045,1 @@\n-    vex_prefix(adr, 0, crc->encoding(), sizeInBytes == 2 ? VEX_SIMD_66 : VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+    vex_prefix(adr, 0, crc->encoding(), sizeInBytes == 2 ? VEX_SIMD_66 : VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes);\n@@ -2476,1 +2442,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -2524,1 +2490,1 @@\n-  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = eevex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -2535,1 +2501,1 @@\n-  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = eevex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -2546,1 +2512,1 @@\n-  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = eevex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -2556,3 +2522,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_int16((unsigned char)0xAF, (0xC0 | encode));\n+  emit_eevex_or_demote(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0xAF, no_flags, true \/* is_map1 *\/,  true \/* swap *\/);\n@@ -2579,1 +2543,1 @@\n-  evex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -2603,1 +2567,1 @@\n-  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = eevex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -2621,5 +2585,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n-  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_int8((unsigned char)0xAF);\n-  emit_operand(src1, src2, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, (unsigned char)0xAF, no_flags, true \/* is_map1 *\/);\n@@ -2641,1 +2601,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -2833,1 +2793,1 @@\n-  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = eevex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -2851,1 +2811,1 @@\n-  evex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -2870,0 +2830,11 @@\n+void Assembler::movapd(XMMRegister dst, Address src) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ VM_Version::supports_evex(), \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_rex_vex_w_reverted();\n+  simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0x28);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -4058,1 +4029,1 @@\n-  evex_prefix_nf(src, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_nf(src, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -4070,1 +4041,1 @@\n-  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = eevex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -4113,1 +4084,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -4128,1 +4099,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -4446,1 +4417,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes);\n@@ -4454,1 +4425,1 @@\n-  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_66, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  (void) emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -4468,1 +4439,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -4478,3 +4449,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_arith_ndd(0x81, 0xC8, src, imm32);\n+  emit_eevex_prefix_or_demote_arith_ndd(dst, src, imm32, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0x81, 0xC8, no_flags);\n@@ -4492,5 +4461,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n-  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_int8(0x0B);\n-  emit_operand(src1, src2, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0x0B, no_flags);\n@@ -4508,1 +4473,1 @@\n-  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  (void) emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -4523,1 +4488,1 @@\n-  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -4540,1 +4505,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -4557,1 +4522,1 @@\n-  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -4592,1 +4557,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -4656,0 +4621,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -4686,0 +4652,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -5395,1 +5362,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_HVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_QVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -5683,1 +5650,1 @@\n-  evex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -5698,1 +5665,1 @@\n-  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = eevex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -6249,1 +6216,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes);\n@@ -6332,1 +6299,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -6347,1 +6314,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -6364,1 +6331,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -6379,1 +6346,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -6390,1 +6357,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n@@ -6407,1 +6374,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n@@ -6422,1 +6389,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n@@ -6439,1 +6406,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n@@ -6467,1 +6434,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -6490,1 +6457,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -6508,1 +6475,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -6523,1 +6490,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -6547,1 +6514,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -6570,1 +6537,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -6588,1 +6555,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -6603,1 +6570,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -6744,1 +6711,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -6759,1 +6726,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -6777,1 +6744,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -6793,1 +6760,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -6808,1 +6775,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -6833,1 +6800,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -6851,5 +6818,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  \/\/ NDD shares its encoding bits with NDS bits for regular EVEX instruction.\n-  \/\/ Therefore, DST is passed as the second argument to minimize changes in the leaf level routine.\n-  int encode = evex_prefix_and_encode_ndd(src2->encoding(), dst->encoding(), src1->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_int16(0xA5, (0xC0 | encode));\n+  emit_eevex_or_demote(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0xA5, no_flags, true \/* is_map1 *\/);\n@@ -6864,5 +6827,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  \/\/ NDD shares its encoding bits with NDS bits for regular EVEX instruction.\n-  \/\/ Therefore, DST is passed as the second argument to minimize changes in the leaf level routine.\n-  int encode = evex_prefix_and_encode_ndd(src2->encoding(), dst->encoding(), src1->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_int24(0x24, (0xC0 | encode), imm8);\n+  emit_eevex_or_demote(dst->encoding(), src1->encoding(), src2->encoding(), imm8, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0x24, no_flags, true \/* is_map1 *\/);\n@@ -6877,5 +6836,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  \/\/ NDD shares its encoding bits with NDS bits for regular EVEX instruction.\n-  \/\/ Therefore, DST is passed as the second argument to minimize changes in the leaf level routine.\n-  int encode = evex_prefix_and_encode_ndd(src2->encoding(), dst->encoding(), src1->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_int16(0xAD, (0xC0 | encode));\n+  emit_eevex_or_demote(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0xAD, no_flags, true \/* is_map1 *\/);\n@@ -6890,5 +6845,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  \/\/ NDD shares its encoding bits with NDS bits for regular EVEX instruction.\n-  \/\/ Therefore, DST is passed as the second argument to minimize changes in the leaf level routine.\n-  int encode = evex_prefix_and_encode_ndd(src2->encoding(), dst->encoding(), src1->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_int24(0x2C, (0xC0 | encode), imm8);\n+  emit_eevex_or_demote(dst->encoding(), src1->encoding(), src2->encoding(), imm8, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0x2C, no_flags, true \/* is_map1 *\/);\n@@ -6903,5 +6854,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  \/\/ NDD shares its encoding bits with NDS bits for regular EVEX instruction.\n-  \/\/ Therefore, DST is passed as the second argument to minimize changes in the leaf level routine.\n-  int encode = evex_prefix_and_encode_ndd(src2->encoding(), dst->encoding(), src1->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_int24(0x24, (0xC0 | encode), imm8);\n+  emit_eevex_or_demote(dst->encoding(), src1->encoding(), src2->encoding(), imm8, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0x24, no_flags, true \/* is_map1 *\/);\n@@ -6916,5 +6863,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  \/\/ NDD shares its encoding bits with NDS bits for regular EVEX instruction.\n-  \/\/ Therefore, DST is passed as the second argument to minimize changes in the leaf level routine.\n-  int encode = evex_prefix_and_encode_ndd(src2->encoding(), dst->encoding(), src1->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_int24(0x2C, (0xC0 | encode), imm8);\n+  emit_eevex_or_demote(dst->encoding(), src1->encoding(), src2->encoding(), imm8, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0x2C, no_flags, true \/* is_map1 *\/);\n@@ -7010,1 +6953,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -7025,1 +6968,1 @@\n-  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -7036,3 +6979,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_arith_ndd(0x81, 0xE8, src, imm32);\n+  emit_eevex_prefix_or_demote_arith_ndd(dst, src, imm32, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0x81, 0xE8, no_flags);\n@@ -7049,1 +6990,1 @@\n-  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  (void) emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -7062,5 +7003,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n-  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_int8(0x2B);\n-  emit_operand(src1, src2, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0x2B, no_flags);\n@@ -7078,1 +7015,1 @@\n-  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  (void) emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -7183,1 +7120,1 @@\n-  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = eevex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -7201,1 +7138,1 @@\n-  evex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -7216,1 +7153,1 @@\n-  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = eevex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -7234,1 +7171,1 @@\n-  evex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -7358,1 +7295,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -7368,3 +7305,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_arith_ndd(0x81, 0xF0, src, imm32);\n+  emit_eevex_prefix_or_demote_arith_ndd(dst, src, imm32, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0x81, 0xF0, no_flags);\n@@ -7382,5 +7317,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n-  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_int8(0x33);\n-  emit_operand(src1, src2, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0x33, no_flags);\n@@ -7398,1 +7329,1 @@\n-  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  (void) emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -7413,1 +7344,1 @@\n-  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -7427,5 +7358,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_8bit);\n-  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_int8(0x32);\n-  emit_operand(src1, src2, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_8bit, 0x32, no_flags);\n@@ -7445,1 +7372,1 @@\n-  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -7460,7 +7387,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_16bit);\n-  \/\/ NDD shares its encoding bits with NDS bits for regular EVEX instruction.\n-  \/\/ Therefore, DST is passed as the second argument to minimize changes in the leaf level routine.\n-  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_66, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_int8(0x33);\n-  emit_operand(src1, src2, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_66, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_16bit, 0x33, no_flags);\n@@ -8073,0 +7994,8 @@\n+void Assembler::orpd(XMMRegister dst, XMMRegister src) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ !_legacy_mode_dq, \/* legacy_mode *\/ _legacy_mode_dq, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_rex_vex_w_reverted();\n+  int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x56, (0xC0 | encode));\n+}\n+\n@@ -8194,0 +8123,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8330,0 +8260,8 @@\n+void Assembler::eminmaxsh(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x53, (0xC0 | encode), imm8);\n+}\n+\n@@ -8367,1 +8305,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8386,1 +8324,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8405,1 +8343,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8425,1 +8363,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8445,1 +8383,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8464,1 +8402,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8483,1 +8421,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8502,1 +8440,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8844,0 +8782,28 @@\n+void Assembler::evminmaxps(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int imm8, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x52, (0xC0 | encode), imm8);\n+}\n+\n+void Assembler::evminmaxps(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int imm8, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int8(0x52);\n+  emit_operand(dst, src, 0);\n+  emit_int8(imm8);\n+}\n+\n@@ -8850,0 +8816,28 @@\n+void Assembler::evminmaxpd(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int imm8, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x52, (0xC0 | encode), imm8);\n+}\n+\n+void Assembler::evminmaxpd(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int imm8, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int8(0x52);\n+  emit_operand(dst, src, 0);\n+  emit_int8(imm8);\n+}\n+\n@@ -8870,1 +8864,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8893,1 +8887,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8916,1 +8910,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8939,1 +8933,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -9039,1 +9033,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -9062,1 +9056,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -9087,1 +9081,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -9110,1 +9104,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -9213,1 +9207,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ VM_Version::supports_evex(), \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_rex_vex_w_reverted();\n@@ -10555,1 +10550,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -10582,1 +10577,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -10725,1 +10720,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -10752,1 +10747,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -10895,1 +10890,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -10922,1 +10917,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -10949,1 +10944,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -10976,1 +10971,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11003,1 +10998,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11030,1 +11025,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11057,1 +11052,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11085,1 +11080,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11112,1 +11107,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11378,1 +11373,0 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11393,1 +11387,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11407,1 +11401,0 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11422,1 +11415,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11542,1 +11535,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11571,0 +11564,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11597,0 +11591,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11623,0 +11618,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11649,0 +11645,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12017,0 +12014,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12042,0 +12040,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12071,0 +12070,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12099,0 +12099,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12126,0 +12127,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12152,0 +12154,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12180,0 +12183,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12207,0 +12211,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12577,1 +12582,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12595,1 +12600,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12642,1 +12647,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12670,1 +12675,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12948,1 +12953,1 @@\n-void Assembler::evex_prefix_ndd(Address adr, int ndd_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes, bool no_flags) {\n+void Assembler::eevex_prefix_ndd(Address adr, int ndd_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes, bool no_flags) {\n@@ -12953,1 +12958,24 @@\n-void Assembler::evex_prefix_nf(Address adr, int ndd_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes, bool no_flags) {\n+void Assembler::emit_eevex_or_demote(Register dst, Register src1, Address src2, VexSimdPrefix pre, VexOpcode opc,\n+                                     int size, int opcode_byte, bool no_flags, bool is_map1) {\n+  if (is_demotable(no_flags, dst->encoding(), src1->encoding())) {\n+    if (size == EVEX_64bit) {\n+      emit_prefix_and_int8(get_prefixq(src2, dst, is_map1), opcode_byte);\n+    } else {\n+      \/\/ For 32-bit, 16-bit and 8-bit\n+      if (size == EVEX_16bit) {\n+        emit_int8(0x66);\n+      }\n+      prefix(src2, dst, false, is_map1);\n+      emit_int8(opcode_byte);\n+    }\n+  } else {\n+    bool vex_w = (size == EVEX_64bit) ? true : false;\n+    InstructionAttr attributes(AVX_128bit, vex_w, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, size);\n+    eevex_prefix_ndd(src2, dst->encoding(), src1->encoding(), pre, opc, &attributes, no_flags);\n+    emit_int8(opcode_byte);\n+  }\n+  emit_operand(src1, src2, 0);\n+}\n+\n+void Assembler::eevex_prefix_nf(Address adr, int ndd_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes, bool no_flags) {\n@@ -13015,2 +13043,49 @@\n-int Assembler::evex_prefix_and_encode_ndd(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc,\n-                           InstructionAttr *attributes, bool no_flags) {\n+void Assembler::emit_eevex_or_demote(int dst_enc, int nds_enc, int src_enc, int8_t imm8, VexSimdPrefix pre, VexOpcode opc,\n+                                     int size, int opcode_byte, bool no_flags, bool is_map1) {\n+  bool is_prefixq = (size == EVEX_64bit) ? true : false;\n+  if (is_demotable(no_flags, dst_enc, nds_enc)) {\n+    int encode = is_prefixq ? prefixq_and_encode(src_enc, dst_enc, is_map1) : prefix_and_encode(src_enc, dst_enc, is_map1);\n+    emit_opcode_prefix_and_encoding((unsigned char)(opcode_byte | 0x80), 0xC0, encode, imm8);\n+  } else {\n+    InstructionAttr attributes(AVX_128bit, is_prefixq, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, size);\n+    int encode = emit_eevex_prefix_or_demote_ndd(src_enc, dst_enc, nds_enc, pre, opc, &attributes, no_flags);\n+    emit_int24(opcode_byte, (0xC0 | encode), imm8);\n+  }\n+}\n+\n+void Assembler::emit_eevex_or_demote(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc,\n+                                     int size, int opcode_byte, bool no_flags, bool is_map1, bool swap) {\n+  int encode;\n+  bool is_prefixq = (size == EVEX_64bit) ? true : false;\n+  if (is_demotable(no_flags, dst_enc, nds_enc)) {\n+    if (size == EVEX_16bit) {\n+      emit_int8(0x66);\n+    }\n+\n+    if (swap) {\n+      encode = is_prefixq ? prefixq_and_encode(dst_enc, src_enc, is_map1) : prefix_and_encode(dst_enc, src_enc, is_map1);\n+    } else {\n+      encode = is_prefixq ? prefixq_and_encode(src_enc, dst_enc, is_map1) : prefix_and_encode(src_enc, dst_enc, is_map1);\n+    }\n+    emit_opcode_prefix_and_encoding((unsigned char)opcode_byte, 0xC0, encode);\n+  } else {\n+    InstructionAttr attributes(AVX_128bit, is_prefixq, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    attributes.set_is_evex_instruction();\n+    if (swap) {\n+      encode = vex_prefix_and_encode(nds_enc, dst_enc, src_enc, pre, opc, &attributes, \/* src_is_gpr *\/ true, \/* nds_is_ndd *\/ true, no_flags);\n+    } else {\n+      encode = vex_prefix_and_encode(src_enc, dst_enc, nds_enc, pre, opc, &attributes, \/* src_is_gpr *\/ true, \/* nds_is_ndd *\/ true, no_flags);\n+    }\n+    emit_int16(opcode_byte, (0xC0 | encode));\n+  }\n+}\n+\n+int Assembler::emit_eevex_prefix_or_demote_ndd(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc,\n+                                               InstructionAttr *attributes, bool no_flags, bool use_prefixq) {\n+  if (is_demotable(no_flags, dst_enc, nds_enc)) {\n+    if (pre == VEX_SIMD_66) {\n+      emit_int8(0x66);\n+    }\n+    return use_prefixq ? prefixq_and_encode(dst_enc, src_enc) : prefix_and_encode(dst_enc, src_enc);\n+  }\n@@ -13021,2 +13096,17 @@\n-int Assembler::evex_prefix_and_encode_nf(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc,\n-                           InstructionAttr *attributes, bool no_flags) {\n+int Assembler::emit_eevex_prefix_or_demote_ndd(int dst_enc, int nds_enc, VexSimdPrefix pre, VexOpcode opc,\n+                                               InstructionAttr *attributes, bool no_flags, bool use_prefixq) {\n+  \/\/Demote RegReg and RegRegImm instructions\n+  if (is_demotable(no_flags, dst_enc, nds_enc)) {\n+    return use_prefixq ? prefixq_and_encode(dst_enc) : prefix_and_encode(dst_enc);\n+  }\n+  attributes->set_is_evex_instruction();\n+  return vex_prefix_and_encode(0, dst_enc, nds_enc, pre, opc, attributes, \/* src_is_gpr *\/ true, \/* nds_is_ndd *\/ true, no_flags);\n+}\n+\n+int Assembler::emit_eevex_prefix_ndd(int dst_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes, bool no_flags) {\n+  attributes->set_is_evex_instruction();\n+  return vex_prefix_and_encode(0, 0, dst_enc, pre, opc, attributes, \/* src_is_gpr *\/ true, \/* nds_is_ndd *\/ true, no_flags);\n+}\n+\n+int Assembler::eevex_prefix_and_encode_nf(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc,\n+                                          InstructionAttr *attributes, bool no_flags) {\n@@ -13027,0 +13117,18 @@\n+void Assembler::emit_eevex_prefix_or_demote_arith_ndd(Register dst, Register nds, int32_t imm32, VexSimdPrefix pre, VexOpcode opc,\n+                                                      int size, int op1, int op2, bool no_flags) {\n+  int dst_enc = dst->encoding();\n+  int nds_enc = nds->encoding();\n+  bool demote = is_demotable(no_flags, dst_enc, nds_enc);\n+  if (demote) {\n+    (size == EVEX_64bit) ? (void) prefixq_and_encode(dst_enc) : (void) prefix_and_encode(dst_enc);\n+  } else {\n+    bool vex_w = (size == EVEX_64bit) ? true : false;\n+    InstructionAttr attributes(AVX_128bit, vex_w, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    \/\/attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, size);\n+    attributes.set_is_evex_instruction();\n+    vex_prefix_and_encode(0, dst_enc, nds_enc, pre, opc, &attributes, \/* src_is_gpr *\/ true, \/* nds_is_ndd *\/ true, no_flags);\n+\n+  }\n+  emit_arith(op1, op2, nds, imm32, demote);\n+}\n+\n@@ -13052,0 +13160,4 @@\n+bool Assembler::is_demotable(bool no_flags, int dst_enc, int nds_enc) {\n+  return (!no_flags && dst_enc == nds_enc);\n+}\n+\n@@ -13074,0 +13186,8 @@\n+void Assembler::eminmaxss(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x53, (0xC0 | encode), imm8);\n+}\n+\n@@ -13082,0 +13202,8 @@\n+void Assembler::eminmaxsd(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x53, (0xC0 | encode), imm8);\n+}\n+\n@@ -14486,1 +14614,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -14500,1 +14628,1 @@\n-  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -14511,3 +14639,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_arith_ndd(0x81, 0xC0, src, imm32);\n+  emit_eevex_prefix_or_demote_arith_ndd(dst, src, imm32, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0x81, 0xC0, no_flags);\n@@ -14524,5 +14650,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n-  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_int8(0x03);\n-  emit_operand(src1, src2, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0x03, no_flags);\n@@ -14540,1 +14662,1 @@\n-  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  (void) emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n@@ -14548,1 +14670,1 @@\n-    int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3C, &attributes, true);\n+    int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, true);\n@@ -14561,3 +14683,6 @@\n-    InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-    int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3C, &attributes);\n-    emit_int16((unsigned char)0x66, (0xC0 | encode));\n+  if (is_demotable(false, dst->encoding(), src1->encoding())) {\n+    return adcxq(dst, src2);\n+  }\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, false \/* no_flags *\/, true \/* use_prefixq *\/);\n+  emit_int16((unsigned char)0x66, (0xC0 | encode));\n@@ -14570,1 +14695,1 @@\n-    int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_3C, &attributes, true);\n+    int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, true);\n@@ -14583,3 +14708,6 @@\n-    InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-    int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_3C, &attributes);\n-    emit_int16((unsigned char)0x66, (0xC0 | encode));\n+  if (is_demotable(false, dst->encoding(), src1->encoding())) {\n+    return adoxq(dst, src2);\n+  }\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, false \/* no_flags *\/, true \/* use_prefixq *\/);\n+  emit_int16((unsigned char)0x66, (0xC0 | encode));\n@@ -14598,1 +14726,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -14608,3 +14736,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_arith_ndd(0x81, 0xE0, src, imm32);\n+  emit_eevex_prefix_or_demote_arith_ndd(dst, src, imm32, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0x81, 0xE0, no_flags);\n@@ -14621,5 +14747,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n-  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_int8(0x23);\n-  emit_operand(src1, src2, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0x23, no_flags);\n@@ -14637,1 +14759,1 @@\n-  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  (void) emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n@@ -14651,1 +14773,1 @@\n-  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -14790,3 +14912,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n-  emit_int16((0x40 | cc), (0xC0 | encode));\n+  emit_eevex_or_demote(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0x40 | cc, false \/* no_flags *\/, true \/* is_map1 *\/, true \/* swap *\/);\n@@ -14804,5 +14924,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n-  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n-  emit_int8((0x40 | cc));\n-  emit_operand(src1, src2, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, (0x40 | cc) , false \/* no_flags *\/, true \/* is_map1 *\/);\n@@ -14855,1 +14971,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -14864,1 +14980,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -14907,1 +15023,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -14920,1 +15036,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n@@ -14935,1 +15051,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -14975,1 +15091,1 @@\n-  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = eevex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -14986,1 +15102,1 @@\n-  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = eevex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -14996,0 +15112,3 @@\n+  if (is_demotable(no_flags, dst->encoding(), src->encoding())) {\n+    return imulq(dst);\n+  }\n@@ -14997,1 +15116,1 @@\n-  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = eevex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -15002,3 +15121,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_int16((unsigned char)0xAF, (0xC0 | encode));\n+  emit_eevex_or_demote(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0xAF, no_flags, true \/* is_map1 *\/,  true \/* swap *\/);\n@@ -15014,1 +15131,1 @@\n-  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = eevex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -15036,1 +15153,1 @@\n-  evex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -15060,1 +15177,1 @@\n-  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = eevex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -15080,1 +15197,1 @@\n-  evex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -15088,5 +15205,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n-  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_int8((unsigned char)0xAF);\n-  emit_operand(src1, src2, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, (unsigned char)0xAF, no_flags, true \/* is_map1 *\/);\n@@ -15106,2 +15219,1 @@\n-  \/\/ int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -15122,1 +15234,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n@@ -15138,1 +15250,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -15214,1 +15326,1 @@\n-  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = eevex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -15232,1 +15344,1 @@\n-  evex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -15359,1 +15471,1 @@\n-  evex_prefix_nf(src, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_nf(src, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -15371,1 +15483,1 @@\n-  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = eevex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -15389,1 +15501,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n@@ -15403,1 +15515,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -15415,1 +15527,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, false \/* no_flags *\/, true \/* use_prefixq *\/);\n@@ -15459,1 +15571,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -15473,1 +15585,1 @@\n-  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -15484,3 +15596,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_arith_ndd(0x81, 0xC8, src, imm32);\n+  emit_eevex_prefix_or_demote_arith_ndd(dst, src, imm32, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0x81, 0xC8, no_flags);\n@@ -15496,1 +15606,1 @@\n-  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  (void) emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n@@ -15508,5 +15618,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n-  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_int8(0x0B);\n-  emit_operand(src1, src2, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0x0B, no_flags);\n@@ -15524,1 +15630,1 @@\n-  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  (void) emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n@@ -15541,1 +15647,1 @@\n-  evex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -15556,1 +15662,1 @@\n-  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = eevex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -15658,0 +15764,2 @@\n+    \/\/ Restore the original contents of RAX register.\n+    movq(rax, Address(rax));\n@@ -15781,1 +15889,1 @@\n-  int encode =  evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  int encode =  emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, false \/* no_flags *\/, true \/* use_prefixq *\/);\n@@ -15802,1 +15910,1 @@\n-  int encode =  evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  int encode =  emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, false \/* no_flags *\/, true \/* use_prefixq *\/);\n@@ -15865,1 +15973,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -15887,1 +15995,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -15905,1 +16013,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n@@ -15920,1 +16028,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n@@ -15943,1 +16051,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -15965,1 +16073,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -15982,1 +16090,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n@@ -15997,1 +16105,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n@@ -16036,1 +16144,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n@@ -16051,1 +16159,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n@@ -16069,1 +16177,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n@@ -16085,1 +16193,1 @@\n-  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n@@ -16099,1 +16207,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -16123,1 +16231,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -16145,1 +16253,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -16159,1 +16267,1 @@\n-  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -16170,3 +16278,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_arith_ndd(0x81, 0xE8, src, imm32);\n+  emit_eevex_prefix_or_demote_arith_ndd(dst, src, imm32, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0x81, 0xE8, no_flags);\n@@ -16183,1 +16289,1 @@\n-  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  (void) emit_eevex_prefix_or_demote_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n@@ -16195,5 +16301,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n-  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_int8(0x2B);\n-  emit_operand(src1, src2, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0x2B, no_flags);\n@@ -16211,1 +16313,1 @@\n-  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  (void) emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n@@ -16276,1 +16378,1 @@\n-  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  (void) emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n@@ -16288,5 +16390,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n-  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_int8(0x33);\n-  emit_operand(src1, src2, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0x33, no_flags);\n@@ -16301,3 +16399,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n-  emit_arith_ndd(0x81, 0xF0, src, imm32);\n+  emit_eevex_prefix_or_demote_arith_ndd(dst, src, imm32, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0x81, 0xF0, no_flags);\n@@ -16316,1 +16412,1 @@\n-  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -16331,1 +16427,1 @@\n-  int encode =  evex_prefix_and_encode_ndd(0, 0, dst->encoding(), VEX_SIMD_F2, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes);\n+  int encode =  emit_eevex_prefix_ndd(dst->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes); \/\/ demotion disabled\n@@ -16339,1 +16435,1 @@\n-  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  eevex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n@@ -16446,1 +16542,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -16467,1 +16563,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -16488,1 +16584,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -16509,1 +16605,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -16515,0 +16611,28 @@\n+void Assembler::evminmaxph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int imm8, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x52, (0xC0 | encode), imm8);\n+}\n+\n+void Assembler::evminmaxph(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int imm8, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int8(0x52);\n+  emit_operand(dst, src, 0);\n+  emit_int8(imm8);\n+}\n+\n@@ -16530,1 +16654,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -16551,1 +16675,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":480,"deletions":356,"binary":false,"changes":836,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::counter_overflow_id)));\n+  __ call(RuntimeAddress(Runtime1::entry_for(StubId::c1_counter_overflow_id)));\n@@ -67,1 +67,1 @@\n-    address a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+    address a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -81,1 +81,1 @@\n-  C1StubId stub_id;\n+  StubId stub_id;\n@@ -83,1 +83,1 @@\n-    stub_id = C1StubId::throw_index_exception_id;\n+    stub_id = StubId::c1_throw_index_exception_id;\n@@ -85,1 +85,1 @@\n-    stub_id = C1StubId::throw_range_check_failed_id;\n+    stub_id = StubId::c1_throw_range_check_failed_id;\n@@ -100,1 +100,1 @@\n-  address a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+  address a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -112,1 +112,1 @@\n-  __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::throw_div0_exception_id)));\n+  __ call(RuntimeAddress(Runtime1::entry_for(StubId::c1_throw_div0_exception_id)));\n@@ -120,1 +120,1 @@\n-NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, C1StubId stub_id) {\n+NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, StubId stub_id) {\n@@ -125,3 +125,3 @@\n-  assert(stub_id == C1StubId::new_instance_id                 ||\n-         stub_id == C1StubId::fast_new_instance_id            ||\n-         stub_id == C1StubId::fast_new_instance_init_check_id,\n+  assert(stub_id == StubId::c1_new_instance_id                 ||\n+         stub_id == StubId::c1_fast_new_instance_id            ||\n+         stub_id == StubId::c1_fast_new_instance_init_check_id,\n@@ -160,1 +160,1 @@\n-  __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::new_type_array_id)));\n+  __ call(RuntimeAddress(Runtime1::entry_for(StubId::c1_new_type_array_id)));\n@@ -183,1 +183,1 @@\n-  __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::new_object_array_id)));\n+  __ call(RuntimeAddress(Runtime1::entry_for(StubId::c1_new_object_array_id)));\n@@ -195,1 +195,1 @@\n-  C1StubId enter_id;\n+  StubId enter_id;\n@@ -197,1 +197,1 @@\n-    enter_id = C1StubId::monitorenter_id;\n+    enter_id = StubId::c1_monitorenter_id;\n@@ -199,1 +199,1 @@\n-    enter_id = C1StubId::monitorenter_nofpu_id;\n+    enter_id = StubId::c1_monitorenter_nofpu_id;\n@@ -216,1 +216,1 @@\n-  C1StubId exit_id;\n+  StubId exit_id;\n@@ -218,1 +218,1 @@\n-    exit_id = C1StubId::monitorexit_id;\n+    exit_id = StubId::c1_monitorexit_id;\n@@ -220,1 +220,1 @@\n-    exit_id = C1StubId::monitorexit_nofpu_id;\n+    exit_id = StubId::c1_monitorexit_nofpu_id;\n@@ -349,4 +349,4 @@\n-    case access_field_id:  target = Runtime1::entry_for(C1StubId::access_field_patching_id); break;\n-    case load_klass_id:    target = Runtime1::entry_for(C1StubId::load_klass_patching_id); reloc_type = relocInfo::metadata_type; break;\n-    case load_mirror_id:   target = Runtime1::entry_for(C1StubId::load_mirror_patching_id); reloc_type = relocInfo::oop_type; break;\n-    case load_appendix_id:      target = Runtime1::entry_for(C1StubId::load_appendix_patching_id); reloc_type = relocInfo::oop_type; break;\n+    case access_field_id:  target = Runtime1::entry_for(StubId::c1_access_field_patching_id); break;\n+    case load_klass_id:    target = Runtime1::entry_for(StubId::c1_load_klass_patching_id); reloc_type = relocInfo::metadata_type; break;\n+    case load_mirror_id:   target = Runtime1::entry_for(StubId::c1_load_mirror_patching_id); reloc_type = relocInfo::oop_type; break;\n+    case load_appendix_id:      target = Runtime1::entry_for(StubId::c1_load_appendix_patching_id); reloc_type = relocInfo::oop_type; break;\n@@ -382,1 +382,1 @@\n-  __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::deoptimize_id)));\n+  __ call(RuntimeAddress(Runtime1::entry_for(StubId::c1_deoptimize_id)));\n@@ -392,1 +392,1 @@\n-    a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+    a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -394,1 +394,1 @@\n-    a = Runtime1::entry_for(C1StubId::throw_null_pointer_exception_id);\n+    a = Runtime1::entry_for(StubId::c1_throw_null_pointer_exception_id);\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -380,1 +380,1 @@\n-  __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::handle_exception_from_callee_id)));\n+  __ call(RuntimeAddress(Runtime1::entry_for(StubId::c1_handle_exception_from_callee_id)));\n@@ -436,1 +436,1 @@\n-  __ jump(RuntimeAddress(Runtime1::entry_for(C1StubId::unwind_exception_id)));\n+  __ jump(RuntimeAddress(Runtime1::entry_for(StubId::c1_unwind_exception_id)));\n@@ -1390,1 +1390,1 @@\n-        __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+        __ call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n@@ -1404,1 +1404,1 @@\n-      __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+      __ call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n@@ -1483,1 +1483,1 @@\n-    __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+    __ call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n@@ -2220,1 +2220,1 @@\n-  C1StubId unwind_id;\n+  StubId unwind_id;\n@@ -2232,1 +2232,1 @@\n-    unwind_id = C1StubId::handle_exception_id;\n+    unwind_id = StubId::c1_handle_exception_id;\n@@ -2234,1 +2234,1 @@\n-    unwind_id = C1StubId::handle_exception_nofpu_id;\n+    unwind_id = StubId::c1_handle_exception_nofpu_id;\n@@ -2549,1 +2549,1 @@\n-      __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+      __ call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -723,1 +723,2 @@\n-      x->id() == vmIntrinsics::_dlog10 || x->id() == vmIntrinsics::_dtanh\n+      x->id() == vmIntrinsics::_dlog10 || x->id() == vmIntrinsics::_dtanh ||\n+      x->id() == vmIntrinsics::_dcbrt\n@@ -810,1 +811,1 @@\n-       if (StubRoutines::dpow() != nullptr) {\n+      if (StubRoutines::dpow() != nullptr) {\n@@ -831,1 +832,1 @@\n-       if (StubRoutines::dtan() != nullptr) {\n+      if (StubRoutines::dtan() != nullptr) {\n@@ -838,2 +839,2 @@\n-       assert(StubRoutines::dtanh() != nullptr, \"tanh intrinsic not found\");\n-       if (StubRoutines::dtanh() != nullptr) {\n+      assert(StubRoutines::dtanh() != nullptr, \"tanh intrinsic not found\");\n+      if (StubRoutines::dtanh() != nullptr) {\n@@ -843,0 +844,6 @@\n+    case vmIntrinsics::_dcbrt:\n+      assert(StubRoutines::dcbrt() != nullptr, \"cbrt intrinsic not found\");\n+      if (StubRoutines::dcbrt() != nullptr) {\n+        __ call_runtime_leaf(StubRoutines::dcbrt(), getThreadTemp(), result_reg, cc->args());\n+      }\n+      break;\n@@ -1239,1 +1246,1 @@\n-  __ call_runtime(Runtime1::entry_for(C1StubId::new_multi_array_id),\n+  __ call_runtime(Runtime1::entry_for(StubId::c1_new_multi_array_id),\n@@ -1272,1 +1279,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);\n+    stub = new SimpleExceptionStub(StubId::c1_throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);\n@@ -1277,1 +1284,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_class_cast_exception_id, obj.result(), info_for_exception);\n+    stub = new SimpleExceptionStub(StubId::c1_throw_class_cast_exception_id, obj.result(), info_for_exception);\n@@ -1313,1 +1320,1 @@\n-  return Runtime1::entry_for(C1StubId::is_instance_of_id);\n+  return Runtime1::entry_for(StubId::c1_is_instance_of_id);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-    call(RuntimeAddress(Runtime1::entry_for(C1StubId::dtrace_object_alloc_id)));\n+    call(RuntimeAddress(Runtime1::entry_for(StubId::c1_dtrace_object_alloc_id)));\n@@ -294,1 +294,1 @@\n-    call(RuntimeAddress(Runtime1::entry_for(C1StubId::dtrace_object_alloc_id)));\n+    call(RuntimeAddress(Runtime1::entry_for(StubId::c1_dtrace_object_alloc_id)));\n@@ -328,10 +328,0 @@\n-  if (breakAtEntry) {\n-    \/\/ Verified Entry first instruction should be 5 bytes long for correct\n-    \/\/ patching by patch_verified_entry().\n-    \/\/\n-    \/\/ Breakpoint has one byte first instruction.\n-    \/\/ Also first instruction will be one byte \"push(rbp)\" if stack banging\n-    \/\/ code is not generated (see build_frame() above).\n-    \/\/ For all these cases generate long instruction first.\n-    fat_nop();\n-  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  align_stack = (stub_id() == (int)C1StubId::handle_exception_from_callee_id);\n+  align_stack = (stub_id() == (int)StubId::c1_handle_exception_from_callee_id);\n@@ -114,1 +114,1 @@\n-    } else if (_stub_id == (int)C1StubId::forward_exception_id) {\n+    } else if (_stub_id == (int)StubId::c1_forward_exception_id) {\n@@ -117,1 +117,1 @@\n-      jump(RuntimeAddress(Runtime1::entry_for(C1StubId::forward_exception_id)));\n+      jump(RuntimeAddress(Runtime1::entry_for(StubId::c1_forward_exception_id)));\n@@ -506,1 +506,1 @@\n-OopMapSet* Runtime1::generate_handle_exception(C1StubId id, StubAssembler *sasm) {\n+OopMapSet* Runtime1::generate_handle_exception(StubId id, StubAssembler *sasm) {\n@@ -519,1 +519,1 @@\n-  case C1StubId::forward_exception_id:\n+  case StubId::c1_forward_exception_id:\n@@ -538,2 +538,2 @@\n-  case C1StubId::handle_exception_nofpu_id:\n-  case C1StubId::handle_exception_id:\n+  case StubId::c1_handle_exception_nofpu_id:\n+  case StubId::c1_handle_exception_id:\n@@ -541,1 +541,1 @@\n-    oop_map = save_live_registers(sasm, 1 \/*thread*\/, id != C1StubId::handle_exception_nofpu_id);\n+    oop_map = save_live_registers(sasm, 1 \/*thread*\/, id != StubId::c1_handle_exception_nofpu_id);\n@@ -543,1 +543,1 @@\n-  case C1StubId::handle_exception_from_callee_id: {\n+  case StubId::c1_handle_exception_from_callee_id: {\n@@ -600,3 +600,3 @@\n-  case C1StubId::forward_exception_id:\n-  case C1StubId::handle_exception_nofpu_id:\n-  case C1StubId::handle_exception_id:\n+  case StubId::c1_forward_exception_id:\n+  case StubId::c1_handle_exception_nofpu_id:\n+  case StubId::c1_handle_exception_id:\n@@ -604,1 +604,1 @@\n-    restore_live_registers(sasm, id != C1StubId::handle_exception_nofpu_id);\n+    restore_live_registers(sasm, id != StubId::c1_handle_exception_nofpu_id);\n@@ -606,1 +606,1 @@\n-  case C1StubId::handle_exception_from_callee_id:\n+  case StubId::c1_handle_exception_from_callee_id:\n@@ -742,1 +742,1 @@\n-               RuntimeAddress(Runtime1::entry_for(C1StubId::forward_exception_id)));\n+               RuntimeAddress(Runtime1::entry_for(StubId::c1_forward_exception_id)));\n@@ -814,1 +814,1 @@\n-OopMapSet* Runtime1::generate_code_for(C1StubId id, StubAssembler* sasm) {\n+OopMapSet* Runtime1::generate_code_for(StubId id, StubAssembler* sasm) {\n@@ -826,1 +826,1 @@\n-    case C1StubId::forward_exception_id:\n+    case StubId::c1_forward_exception_id:\n@@ -834,3 +834,3 @@\n-    case C1StubId::new_instance_id:\n-    case C1StubId::fast_new_instance_id:\n-    case C1StubId::fast_new_instance_init_check_id:\n+    case StubId::c1_new_instance_id:\n+    case StubId::c1_fast_new_instance_id:\n+    case StubId::c1_fast_new_instance_init_check_id:\n@@ -841,1 +841,1 @@\n-        if (id == C1StubId::new_instance_id) {\n+        if (id == StubId::c1_new_instance_id) {\n@@ -843,1 +843,1 @@\n-        } else if (id == C1StubId::fast_new_instance_id) {\n+        } else if (id == StubId::c1_fast_new_instance_id) {\n@@ -846,1 +846,1 @@\n-          assert(id == C1StubId::fast_new_instance_init_check_id, \"bad C1StubId\");\n+          assert(id == StubId::c1_fast_new_instance_init_check_id, \"bad StubId\");\n@@ -865,1 +865,1 @@\n-    case C1StubId::counter_overflow_id:\n+    case StubId::c1_counter_overflow_id:\n@@ -883,2 +883,2 @@\n-    case C1StubId::new_type_array_id:\n-    case C1StubId::new_object_array_id:\n+    case StubId::c1_new_type_array_id:\n+    case StubId::c1_new_object_array_id:\n@@ -890,1 +890,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -903,1 +903,1 @@\n-          int tag = ((id == C1StubId::new_type_array_id)\n+          int tag = ((id == StubId::c1_new_type_array_id)\n@@ -917,1 +917,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -935,1 +935,1 @@\n-    case C1StubId::new_multi_array_id:\n+    case StubId::c1_new_multi_array_id:\n@@ -952,1 +952,1 @@\n-    case C1StubId::register_finalizer_id:\n+    case StubId::c1_register_finalizer_id:\n@@ -985,1 +985,1 @@\n-    case C1StubId::throw_range_check_failed_id:\n+    case StubId::c1_throw_range_check_failed_id:\n@@ -991,1 +991,1 @@\n-    case C1StubId::throw_index_exception_id:\n+    case StubId::c1_throw_index_exception_id:\n@@ -997,1 +997,1 @@\n-    case C1StubId::throw_div0_exception_id:\n+    case StubId::c1_throw_div0_exception_id:\n@@ -1003,1 +1003,1 @@\n-    case C1StubId::throw_null_pointer_exception_id:\n+    case StubId::c1_throw_null_pointer_exception_id:\n@@ -1009,2 +1009,2 @@\n-    case C1StubId::handle_exception_nofpu_id:\n-    case C1StubId::handle_exception_id:\n+    case StubId::c1_handle_exception_nofpu_id:\n+    case StubId::c1_handle_exception_id:\n@@ -1016,1 +1016,1 @@\n-    case C1StubId::handle_exception_from_callee_id:\n+    case StubId::c1_handle_exception_from_callee_id:\n@@ -1022,1 +1022,1 @@\n-    case C1StubId::unwind_exception_id:\n+    case StubId::c1_unwind_exception_id:\n@@ -1030,1 +1030,1 @@\n-    case C1StubId::throw_array_store_exception_id:\n+    case StubId::c1_throw_array_store_exception_id:\n@@ -1038,1 +1038,1 @@\n-    case C1StubId::throw_class_cast_exception_id:\n+    case StubId::c1_throw_class_cast_exception_id:\n@@ -1044,1 +1044,1 @@\n-    case C1StubId::throw_incompatible_class_change_error_id:\n+    case StubId::c1_throw_incompatible_class_change_error_id:\n@@ -1050,1 +1050,1 @@\n-    case C1StubId::slow_subtype_check_id:\n+    case StubId::c1_slow_subtype_check_id:\n@@ -1103,1 +1103,1 @@\n-    case C1StubId::is_instance_of_id:\n+    case StubId::c1_is_instance_of_id:\n@@ -1157,1 +1157,1 @@\n-    case C1StubId::monitorenter_nofpu_id:\n+    case StubId::c1_monitorenter_nofpu_id:\n@@ -1160,1 +1160,1 @@\n-    case C1StubId::monitorenter_id:\n+    case StubId::c1_monitorenter_id:\n@@ -1178,1 +1178,1 @@\n-    case C1StubId::monitorexit_nofpu_id:\n+    case StubId::c1_monitorexit_nofpu_id:\n@@ -1181,1 +1181,1 @@\n-    case C1StubId::monitorexit_id:\n+    case StubId::c1_monitorexit_id:\n@@ -1201,1 +1201,1 @@\n-    case C1StubId::deoptimize_id:\n+    case StubId::c1_deoptimize_id:\n@@ -1218,1 +1218,1 @@\n-    case C1StubId::access_field_patching_id:\n+    case StubId::c1_access_field_patching_id:\n@@ -1225,1 +1225,1 @@\n-    case C1StubId::load_klass_patching_id:\n+    case StubId::c1_load_klass_patching_id:\n@@ -1232,1 +1232,1 @@\n-    case C1StubId::load_mirror_patching_id:\n+    case StubId::c1_load_mirror_patching_id:\n@@ -1239,1 +1239,1 @@\n-    case C1StubId::load_appendix_patching_id:\n+    case StubId::c1_load_appendix_patching_id:\n@@ -1246,1 +1246,1 @@\n-    case C1StubId::dtrace_object_alloc_id:\n+    case StubId::c1_dtrace_object_alloc_id:\n@@ -1260,1 +1260,1 @@\n-    case C1StubId::fpu2long_stub_id:\n+    case StubId::c1_fpu2long_stub_id:\n@@ -1276,1 +1276,1 @@\n-    case C1StubId::predicate_failed_trap_id:\n+    case StubId::c1_predicate_failed_trap_id:\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":56,"deletions":56,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n-\n-  \/\/ WARNING: Initial instruction MUST be 5 bytes or longer so that\n-  \/\/ NativeJump::patch_verified_entry will be able to patch out the entry\n-  \/\/ code safely. The push to verify stack depth is ok at 5 bytes,\n-  \/\/ the frame allocation can be either 3 or 6 bytes. So if we don't do\n-  \/\/ stack bang then we must use the 6 byte frame allocation even if\n-  \/\/ we have no frame. :-(\n@@ -90,2 +83,1 @@\n-    \/\/ Create frame (force generation of a 4 byte immediate value)\n-    subptr_imm32(rsp, framesize);\n+    subptr(rsp, framesize);\n@@ -1241,0 +1233,15 @@\n+void C2_MacroAssembler::vminmax_fp(int opc, BasicType elem_bt, XMMRegister dst, KRegister mask,\n+                                   XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  assert(opc == Op_MinV || opc == Op_MinReductionV ||\n+         opc == Op_MaxV || opc == Op_MaxReductionV, \"sanity\");\n+\n+  int imm8 = (opc == Op_MinV || opc == Op_MinReductionV) ? AVX10_MINMAX_MIN_COMPARE_SIGN\n+                                                         : AVX10_MINMAX_MAX_COMPARE_SIGN;\n+  if (elem_bt == T_FLOAT) {\n+    evminmaxps(dst, mask, src1, src2, true, imm8, vlen_enc);\n+  } else {\n+    assert(elem_bt == T_DOUBLE, \"\");\n+    evminmaxpd(dst, mask, src1, src2, true, imm8, vlen_enc);\n+  }\n+}\n+\n@@ -1594,6 +1601,4 @@\n-void C2_MacroAssembler::vgather8b_masked_offset(BasicType elem_bt,\n-                                                XMMRegister dst, Register base,\n-                                                Register idx_base,\n-                                                Register offset, Register mask,\n-                                                Register mask_idx, Register rtmp,\n-                                                int vlen_enc) {\n+void C2_MacroAssembler::vgather8b_masked(BasicType elem_bt, XMMRegister dst,\n+                                         Register base, Register idx_base,\n+                                         Register mask, Register mask_idx,\n+                                         Register rtmp, int vlen_enc) {\n@@ -1603,1 +1608,1 @@\n-      \/\/ dst[i] = mask[i] ? src[offset + idx_base[i]] : 0\n+      \/\/ dst[i] = mask[i] ? src[idx_base[i]] : 0\n@@ -1608,3 +1613,0 @@\n-      if (offset != noreg) {\n-        addl(rtmp, offset);\n-      }\n@@ -1618,1 +1620,1 @@\n-      \/\/ dst[i] = mask[i] ? src[offset + idx_base[i]] : 0\n+      \/\/ dst[i] = mask[i] ? src[idx_base[i]] : 0\n@@ -1623,3 +1625,0 @@\n-      if (offset != noreg) {\n-        addl(rtmp, offset);\n-      }\n@@ -1633,4 +1632,3 @@\n-void C2_MacroAssembler::vgather8b_offset(BasicType elem_bt, XMMRegister dst,\n-                                         Register base, Register idx_base,\n-                                         Register offset, Register rtmp,\n-                                         int vlen_enc) {\n+void C2_MacroAssembler::vgather8b(BasicType elem_bt, XMMRegister dst,\n+                                  Register base, Register idx_base,\n+                                  Register rtmp, int vlen_enc) {\n@@ -1640,1 +1638,1 @@\n-      \/\/ dst[i] = src[offset + idx_base[i]]\n+      \/\/ dst[i] = src[idx_base[i]]\n@@ -1642,3 +1640,0 @@\n-      if (offset != noreg) {\n-        addl(rtmp, offset);\n-      }\n@@ -1650,1 +1645,1 @@\n-      \/\/ dst[i] = src[offset + idx_base[i]]\n+      \/\/ dst[i] = src[idx_base[i]]\n@@ -1652,3 +1647,0 @@\n-      if (offset != noreg) {\n-        addl(rtmp, offset);\n-      }\n@@ -1683,5 +1675,4 @@\n-                                        Register offset, Register mask,\n-                                        XMMRegister xtmp1, XMMRegister xtmp2,\n-                                        XMMRegister temp_dst, Register rtmp,\n-                                        Register mask_idx, Register length,\n-                                        int vector_len, int vlen_enc) {\n+                                        Register mask, XMMRegister xtmp1,\n+                                        XMMRegister xtmp2, XMMRegister temp_dst,\n+                                        Register rtmp, Register mask_idx,\n+                                        Register length, int vector_len, int vlen_enc) {\n@@ -1701,1 +1692,1 @@\n-      vgather8b_offset(elem_ty, temp_dst, base, idx_base, offset, rtmp, vlen_enc);\n+      vgather8b(elem_ty, temp_dst, base, idx_base, rtmp, vlen_enc);\n@@ -1703,1 +1694,1 @@\n-      vgather8b_masked_offset(elem_ty, temp_dst, base, idx_base, offset, mask, mask_idx, rtmp, vlen_enc);\n+      vgather8b_masked(elem_ty, temp_dst, base, idx_base, mask, mask_idx, rtmp, vlen_enc);\n@@ -2548,1 +2539,6 @@\n-    vminmax_fp(opcode, T_FLOAT, wdst, wtmp, wsrc, tmp, atmp, btmp, vlen_enc);\n+\n+    if (VM_Version::supports_avx10_2()) {\n+      vminmax_fp(opcode, T_FLOAT, wdst, k0, wtmp, wsrc, vlen_enc);\n+    } else {\n+      vminmax_fp(opcode, T_FLOAT, wdst, wtmp, wsrc, tmp, atmp, btmp, vlen_enc);\n+    }\n@@ -2553,1 +2549,5 @@\n-    vminmax_fp(opcode, T_FLOAT, dst, wdst, dst, tmp, atmp, btmp, Assembler::AVX_128bit);\n+    if (VM_Version::supports_avx10_2()) {\n+      vminmax_fp(opcode, T_FLOAT, dst, k0, wdst, dst, Assembler::AVX_128bit);\n+    } else {\n+      vminmax_fp(opcode, T_FLOAT, dst, wdst, dst, tmp, atmp, btmp, Assembler::AVX_128bit);\n+    }\n@@ -2579,1 +2579,7 @@\n-    vminmax_fp(opcode, T_DOUBLE, wdst, wtmp, wsrc, tmp, atmp, btmp, vlen_enc);\n+\n+    if (VM_Version::supports_avx10_2()) {\n+      vminmax_fp(opcode, T_DOUBLE, wdst, k0, wtmp, wsrc, vlen_enc);\n+    } else {\n+      vminmax_fp(opcode, T_DOUBLE, wdst, wtmp, wsrc, tmp, atmp, btmp, vlen_enc);\n+    }\n+\n@@ -2583,0 +2589,1 @@\n+\n@@ -2584,1 +2591,5 @@\n-    vminmax_fp(opcode, T_DOUBLE, dst, wdst, dst, tmp, atmp, btmp, Assembler::AVX_128bit);\n+    if (VM_Version::supports_avx10_2()) {\n+      vminmax_fp(opcode, T_DOUBLE, dst, k0, wdst, dst, Assembler::AVX_128bit);\n+    } else {\n+      vminmax_fp(opcode, T_DOUBLE, dst, wdst, dst, tmp, atmp, btmp, Assembler::AVX_128bit);\n+    }\n@@ -4658,0 +4669,1 @@\n+  \/\/ APX REX2 encoding for pop(dst) increases the stub size by 1 byte.\n@@ -4690,1 +4702,3 @@\n-  auto stub = C2CodeStub::make<Register, XMMRegister, address>(dst, src, slowpath_target, 23, convertF2I_slowpath);\n+  \/\/ Using the APX extended general purpose registers increases the instruction encoding size by 1 byte.\n+  int max_size = 23 + (UseAPX ? 1 : 0);\n+  auto stub = C2CodeStub::make<Register, XMMRegister, address>(dst, src, slowpath_target, max_size, convertF2I_slowpath);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":61,"deletions":47,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -75,0 +75,3 @@\n+  void vminmax_fp(int opc, BasicType elem_bt, XMMRegister dst, KRegister mask,\n+                  XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n@@ -495,2 +498,2 @@\n-  void vgather_subword(BasicType elem_ty, XMMRegister dst,  Register base, Register idx_base, Register offset,\n-                       Register mask, XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp,\n+  void vgather_subword(BasicType elem_ty, XMMRegister dst,  Register base, Register idx_base, Register mask,\n+                       XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp,\n@@ -499,5 +502,4 @@\n-  void vgather8b_masked_offset(BasicType elem_bt, XMMRegister dst, Register base, Register idx_base,\n-                               Register offset, Register mask, Register midx, Register rtmp, int vlen_enc);\n-\n-  void vgather8b_offset(BasicType elem_bt, XMMRegister dst, Register base, Register idx_base,\n-                              Register offset, Register rtmp, int vlen_enc);\n+  void vgather8b_masked(BasicType elem_bt, XMMRegister dst, Register base, Register idx_base,\n+                        Register mask, Register midx, Register rtmp, int vlen_enc);\n+  void vgather8b(BasicType elem_bt, XMMRegister dst, Register base, Register idx_base,\n+                 Register rtmp, int vlen_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2024, 2025, Intel Corporation. All rights reserved.\n@@ -208,1 +208,1 @@\n-  StubGenStubId stub_id = (isLL ?  StubGenStubId::string_indexof_linear_ll_id : (isUL ? StubGenStubId::string_indexof_linear_ul_id : StubGenStubId::string_indexof_linear_uu_id));\n+  StubId stub_id = (isLL ?  StubId::stubgen_string_indexof_linear_ll_id : (isUL ? StubId::stubgen_string_indexof_linear_ul_id : StubId::stubgen_string_indexof_linear_uu_id));\n","filename":"src\/hotspot\/cpu\/x86\/c2_stubGenerator_x86_64_string.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-\/*\n- * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ \/*\n+ * Copyright (c) 2023, 2025, Red Hat, Inc. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"memory\/metaspace.hpp\"\n@@ -35,7 +36,18 @@\n-  \/\/ Optimize for unscaled encoding; failing that, for zero-based encoding:\n-  if (optimize_for_zero_base) {\n-    result = reserve_address_space_for_unscaled_encoding(size, aslr);\n-    if (result == nullptr) {\n-      result = reserve_address_space_for_zerobased_encoding(size, aslr);\n-    }\n-  } \/\/ end: low-address reservation\n+  assert(CompressedKlassPointers::narrow_klass_pointer_bits() == 32 ||\n+         CompressedKlassPointers::narrow_klass_pointer_bits() == 19, \"Rethink if we ever use different nKlass bit sizes\");\n+\n+  \/\/ Unconditionally attempting to reserve in lower 4G first makes always sense:\n+  \/\/ -CDS -COH: Try to get unscaled mode (zero base, zero shift)\n+  \/\/ +CDS -COH: No zero base possible (CDS prevents it); but we still benefit from small base pointers (imm32 movabs)\n+  \/\/ -CDS +COH: No zero base possible (22bit nKlass + zero base zero shift = 4MB encoding range, way too small);\n+  \/\/            but we still benefit from small base pointers (imm32 movabs)\n+  \/\/ +CDS +COH: No zero base possible for multiple reasons (CDS prevents it and encoding range too small);\n+  \/\/            but we still benefit from small base pointers (imm32 movabs)\n+\n+  result = reserve_address_space_below_4G(size, aslr);\n+\n+  if (result == nullptr && optimize_for_zero_base) {\n+    \/\/ Failing that, if we are running without CDS, attempt to allocate below 32G.\n+    \/\/ This allows us to use zero-based encoding with a non-zero shift.\n+    result = reserve_address_space_for_zerobased_encoding(size, aslr);\n+  }\n@@ -43,1 +55,0 @@\n-  \/\/ Nothing more to optimize for on x64. If base != 0, we will always emit the full 64-bit immediate.\n","filename":"src\/hotspot\/cpu\/x86\/compressedKlass_x86.cpp","additions":21,"deletions":10,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -433,2 +433,2 @@\n-  if (cb == Runtime1::blob_for(C1StubId::monitorenter_id) ||\n-      cb == Runtime1::blob_for(C1StubId::monitorenter_nofpu_id)) {\n+  if (cb == Runtime1::blob_for(StubId::c1_monitorenter_id) ||\n+      cb == Runtime1::blob_for(StubId::c1_monitorenter_nofpu_id)) {\n@@ -704,1 +704,0 @@\n-  vmassert(last_Java_pc() == nullptr, \"already walkable\");\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -356,1 +356,1 @@\n-  uint num_saved_regs = 4 + (dst != rax ? 1 : 0) + 4;\n+  uint num_saved_regs = 4 + (dst != rax ? 1 : 0) + 4 + (UseAPX ? 16 : 0);\n@@ -370,0 +370,19 @@\n+  \/\/ Save APX extended registers r16r31 if enabled\n+  if (UseAPX) {\n+    __ movptr(Address(rsp, (--slot) * wordSize), r16);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r17);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r18);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r19);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r20);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r21);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r22);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r23);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r24);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r25);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r26);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r27);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r28);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r29);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r30);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r31);\n+  }\n@@ -401,0 +420,19 @@\n+  \/\/ Restore APX extended registers r31r16 if previously saved\n+  if (UseAPX) {\n+    __ movptr(r31, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r30, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r29, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r28, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r27, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r26, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r25, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r24, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r23, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r22, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r21, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r20, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r19, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r18, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r17, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r16, Address(rsp, (slot++) * wordSize));\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":39,"deletions":1,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1624,13 +1624,0 @@\n-\/\/ A 5 byte nop that is safe for patching (see patch_verified_entry)\n-void MacroAssembler::fat_nop() {\n-  if (UseAddressNop) {\n-    addr_nop_5();\n-  } else {\n-    emit_int8((uint8_t)0x26); \/\/ es:\n-    emit_int8((uint8_t)0x2e); \/\/ cs:\n-    emit_int8((uint8_t)0x64); \/\/ fs:\n-    emit_int8((uint8_t)0x65); \/\/ gs:\n-    emit_int8((uint8_t)0x90);\n-  }\n-}\n-\n@@ -2253,0 +2240,10 @@\n+void MacroAssembler::movapd(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    Assembler::movapd(dst, as_Address(src));\n+  } else {\n+    lea(rscratch, src);\n+    Assembler::movapd(dst, Address(rscratch, 0));\n+  }\n+}\n@@ -5405,0 +5402,1 @@\n+  BLOCK_COMMENT(\"encode_klass_not_null {\");\n@@ -5407,1 +5405,5 @@\n-    mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+    if (AOTCodeCache::is_on_for_dump()) {\n+      movptr(tmp, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    } else {\n+      movptr(tmp, (intptr_t)CompressedKlassPointers::base());\n+    }\n@@ -5413,0 +5415,1 @@\n+  BLOCK_COMMENT(\"} encode_klass_not_null\");\n@@ -5416,0 +5419,1 @@\n+  BLOCK_COMMENT(\"encode_and_move_klass_not_null {\");\n@@ -5418,1 +5422,1 @@\n-    mov64(dst, -(int64_t)CompressedKlassPointers::base());\n+    movptr(dst, -(intptr_t)CompressedKlassPointers::base());\n@@ -5426,0 +5430,1 @@\n+  BLOCK_COMMENT(\"} encode_and_move_klass_not_null\");\n@@ -5429,0 +5434,1 @@\n+  BLOCK_COMMENT(\"decode_klass_not_null {\");\n@@ -5439,1 +5445,5 @@\n-    mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+    if (AOTCodeCache::is_on_for_dump()) {\n+      movptr(tmp, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    } else {\n+      movptr(tmp, (intptr_t)CompressedKlassPointers::base());\n+    }\n@@ -5442,0 +5452,1 @@\n+  BLOCK_COMMENT(\"} decode_klass_not_null\");\n@@ -5445,0 +5456,1 @@\n+  BLOCK_COMMENT(\"decode_and_move_klass_not_null {\");\n@@ -5460,1 +5472,1 @@\n-        mov64(dst, (int64_t)CompressedKlassPointers::base());\n+        movptr(dst, (intptr_t)CompressedKlassPointers::base());\n@@ -5472,3 +5484,3 @@\n-        const uint64_t base_right_shifted =\n-            (uint64_t)CompressedKlassPointers::base() >> CompressedKlassPointers::shift();\n-        mov64(dst, base_right_shifted);\n+        const intptr_t base_right_shifted =\n+            (intptr_t)CompressedKlassPointers::base() >> CompressedKlassPointers::shift();\n+        movptr(dst, base_right_shifted);\n@@ -5482,0 +5494,1 @@\n+  BLOCK_COMMENT(\"} decode_and_move_klass_not_null\");\n@@ -8831,0 +8844,4 @@\n+    case T_FLOAT:\n+      evminmaxps(dst, mask, nds, src, merge, AVX10_MINMAX_MIN_COMPARE_SIGN, vector_len); break;\n+    case T_DOUBLE:\n+      evminmaxpd(dst, mask, nds, src, merge, AVX10_MINMAX_MIN_COMPARE_SIGN, vector_len); break;\n@@ -8846,0 +8863,4 @@\n+    case T_FLOAT:\n+      evminmaxps(dst, mask, nds, src, merge, AVX10_MINMAX_MAX_COMPARE_SIGN, vector_len); break;\n+    case T_DOUBLE:\n+      evminmaxpd(dst, mask, nds, src, merge, AVX10_MINMAX_MAX_COMPARE_SIGN, vector_len); break;\n@@ -8861,0 +8882,4 @@\n+    case T_FLOAT:\n+      evminmaxps(dst, mask, nds, src, merge, AVX10_MINMAX_MIN_COMPARE_SIGN, vector_len); break;\n+    case T_DOUBLE:\n+      evminmaxpd(dst, mask, nds, src, merge, AVX10_MINMAX_MIN_COMPARE_SIGN, vector_len); break;\n@@ -8876,0 +8901,4 @@\n+    case T_FLOAT:\n+      evminmaxps(dst, mask, nds, src, merge, AVX10_MINMAX_MAX_COMPARE_SIGN, vector_len); break;\n+    case T_DOUBLE:\n+      evminmaxps(dst, mask, nds, src, merge, AVX10_MINMAX_MAX_COMPARE_SIGN, vector_len); break;\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":49,"deletions":20,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"opto\/addnode.hpp\"\n@@ -238,0 +239,137 @@\n+\/\/ This function removes redundant lea instructions that result from chained dereferences that\n+\/\/ match to leaPCompressedOopOffset, leaP8Narrow, or leaP32Narrow. This happens for ideal graphs\n+\/\/ of the form LoadN -> DecodeN -> AddP. Matching with any leaP* rule consumes both the AddP and\n+\/\/ the DecodeN. However, after matching the DecodeN is added back as the base for the leaP*,\n+\/\/ which is necessary if the oop derived by the leaP* gets added to an OopMap, because OopMaps\n+\/\/ cannot contain derived oops with narrow oops as a base.\n+\/\/ This results in the following graph after matching:\n+\/\/  LoadN\n+\/\/  |   \\\n+\/\/  | decodeHeapOop_not_null\n+\/\/  |   \/       \\\n+\/\/  leaP*    MachProj (leaf)\n+\/\/ The decode_heap_oop_not_null will emit a lea with an unused result if the derived oop does\n+\/\/ not end up in an OopMap.\n+\/\/ This peephole recognizes graphs of the shape as shown above, ensures that the result of the\n+\/\/ decode is only used by the derived oop and removes that decode if this is the case. Further,\n+\/\/ multiple leaP*s can have the same decode as their base. This peephole will remove the decode\n+\/\/ if all leaP*s and the decode share the same parent.\n+\/\/ Additionally, if the register allocator spills the result of the LoadN we can get such a graph:\n+\/\/               LoadN\n+\/\/                 |\n+\/\/        DefinitionSpillCopy\n+\/\/           \/           \\\n+\/\/ MemToRegSpillCopy   MemToRegSpillCopy\n+\/\/           |           \/\n+\/\/           | decodeHeapOop_not_null\n+\/\/           |   \/              \\\n+\/\/           leaP*          MachProj (leaf)\n+\/\/ In this case where the common parent of the leaP* and the decode is one MemToRegSpillCopy\n+\/\/ away, this peephole can also recognize the decode as redundant and also remove the spill copy\n+\/\/ if that is only used by the decode.\n+bool Peephole::lea_remove_redundant(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_,\n+                                    MachNode* (*new_root)(), uint inst0_rule) {\n+  MachNode* lea_derived_oop = block->get_node(block_index)->as_Mach();\n+  assert(lea_derived_oop->rule() == inst0_rule, \"sanity\");\n+  assert(lea_derived_oop->ideal_Opcode() == Op_AddP, \"sanity\");\n+\n+  MachNode* decode = lea_derived_oop->in(AddPNode::Base)->isa_Mach();\n+  if (decode == nullptr || decode->ideal_Opcode() != Op_DecodeN) {\n+    return false;\n+  }\n+\n+  \/\/ Check that the lea and the decode live in the same block.\n+  if (!block->contains(decode)) {\n+    return false;\n+  }\n+\n+  Node* lea_address = lea_derived_oop->in(AddPNode::Address);\n+  Node* decode_address = decode->in(1);\n+\n+  bool is_spill = lea_address != decode_address &&\n+                  lea_address->is_SpillCopy() &&\n+                  decode_address->is_SpillCopy();\n+\n+  \/\/ If this is a spill, move lea_address and decode_address one node further up to the\n+  \/\/ grandparents of lea_derived_oop and decode respectively. This lets us look through\n+  \/\/ the indirection of the spill.\n+  if (is_spill) {\n+    decode_address = decode_address->in(1);\n+    lea_address = lea_address->in(1);\n+  }\n+\n+  \/\/ The leaP* and the decode must have the same parent. If we have a spill, they must have\n+  \/\/ the same grandparent.\n+  if (lea_address != decode_address) {\n+    return false;\n+  }\n+\n+  \/\/ Ensure the decode only has the leaP*s (with the same (grand)parent) and a MachProj leaf as children.\n+  MachProjNode* proj = nullptr;\n+  for (DUIterator_Fast imax, i = decode->fast_outs(imax); i < imax; i++) {\n+    Node* out = decode->fast_out(i);\n+    if (out == lea_derived_oop) {\n+      continue;\n+    }\n+    if (out->is_MachProj() && out->outcnt() == 0) {\n+      proj = out->as_MachProj();\n+      continue;\n+    }\n+    if (out->is_Mach()) {\n+      MachNode* other_lea = out->as_Mach();\n+      if ((other_lea->rule() == leaP32Narrow_rule ||\n+           other_lea->rule() == leaP8Narrow_rule ||\n+           other_lea->rule() == leaPCompressedOopOffset_rule) &&\n+           other_lea->in(AddPNode::Base) == decode &&\n+          (is_spill ? other_lea->in(AddPNode::Address)->in(1)\n+                    : other_lea->in(AddPNode::Address)) == decode_address) {\n+        continue;\n+      }\n+    }\n+    \/\/ There is other stuff we do not expect...\n+    return false;\n+  }\n+\n+  \/\/ Ensure the MachProj is in the same block as the decode and the lea.\n+  if (proj == nullptr || !block->contains(proj)) {\n+    \/\/ This should only fail if we are stressing scheduling.\n+    assert(StressGCM, \"should be scheduled contiguously otherwise\");\n+    return false;\n+  }\n+\n+  \/\/ We now have verified that the decode is redundant and can be removed with a peephole.\n+  \/\/ Remove the projection\n+  block->find_remove(proj);\n+  cfg_->map_node_to_block(proj, nullptr);\n+\n+  \/\/ Rewire the base of all leas currently depending on the decode we are removing.\n+  for (DUIterator_Fast imax, i = decode->fast_outs(imax); i < imax; i++) {\n+    Node* dependant_lea = decode->fast_out(i);\n+    if (dependant_lea->is_Mach() && dependant_lea->as_Mach()->ideal_Opcode() == Op_AddP) {\n+      dependant_lea->set_req(AddPNode::Base, lea_derived_oop->in(AddPNode::Address));\n+      \/\/ This deleted something in the out array, hence adjust i, imax.\n+      --i;\n+      --imax;\n+    }\n+  }\n+\n+  \/\/ Remove spill for the decode if the spill node does not have any other uses.\n+  if (is_spill) {\n+    MachNode* decode_spill = decode->in(1)->as_Mach();\n+    if (decode_spill->outcnt() == 1 && block->contains(decode_spill)) {\n+      decode_spill->set_removed();\n+      block->find_remove(decode_spill);\n+      cfg_->map_node_to_block(decode_spill, nullptr);\n+      decode_spill->del_req(1);\n+    }\n+  }\n+\n+  \/\/ Remove the decode\n+  decode->set_removed();\n+  block->find_remove(decode);\n+  cfg_->map_node_to_block(decode, nullptr);\n+  decode->del_req(1);\n+\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/peephole_x86_64.cpp","additions":138,"deletions":0,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -59,0 +60,6 @@\n+  const char* name = OptoRuntime::stub_name(StubId::c2_uncommon_trap_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, BlobId::c2_uncommon_trap_id);\n+  if (blob != nullptr) {\n+    return blob->as_uncommon_trap_blob();\n+  }\n+\n@@ -62,1 +69,0 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n@@ -231,2 +237,4 @@\n-  return UncommonTrapBlob::create(&buffer, oop_maps,\n-                                                 SimpleRuntimeFrame::framesize >> 1);\n+  UncommonTrapBlob *ut_blob = UncommonTrapBlob::create(&buffer, oop_maps,\n+                                                       SimpleRuntimeFrame::framesize >> 1);\n+  AOTCodeCache::store_code_blob(*ut_blob, AOTCodeEntry::C2Blob, BlobId::c2_uncommon_trap_id);\n+  return ut_blob;\n@@ -268,0 +276,6 @@\n+  const char* name = OptoRuntime::stub_name(StubId::c2_exception_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, BlobId::c2_exception_id);\n+  if (blob != nullptr) {\n+    return blob->as_exception_blob();\n+  }\n+\n@@ -271,1 +285,0 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n@@ -366,1 +379,3 @@\n-  return ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n+  ExceptionBlob* ex_blob = ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n+  AOTCodeCache::store_code_blob(*ex_blob, AOTCodeEntry::C2Blob, BlobId::c2_exception_id);\n+  return ex_blob;\n","filename":"src\/hotspot\/cpu\/x86\/runtime_x86_64.cpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -2427,0 +2428,17 @@\n+#if INCLUDE_JFR\n+  \/\/ We need to do a poll test after unwind in case the sampler\n+  \/\/ managed to sample the native frame after returning to Java.\n+  Label L_return;\n+  address poll_test_pc = __ pc();\n+  __ relocate(relocInfo::poll_return_type);\n+  __ testb(Address(r15_thread, JavaThread::polling_word_offset()), SafepointMechanism::poll_bit());\n+  __ jccb(Assembler::zero, L_return);\n+  __ lea(rscratch1, InternalAddress(poll_test_pc));\n+  __ movptr(Address(r15_thread, JavaThread::saved_exception_pc_offset()), rscratch1);\n+  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n+    \"polling page return stub not created yet\");\n+  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+  __ jump(RuntimeAddress(stub));\n+  __ bind(L_return);\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -2602,1 +2620,7 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::deopt_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_deopt_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, BlobId::shared_deopt_id);\n+  if (blob != nullptr) {\n+    _deopt_blob = blob->as_deoptimization_blob();\n+    return;\n+  }\n+\n@@ -2954,0 +2978,2 @@\n+\n+  AOTCodeCache::store_code_blob(*_deopt_blob, AOTCodeEntry::SharedBlob, BlobId::shared_deopt_id);\n@@ -2961,1 +2987,1 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(StubId id, address call_ptr) {\n@@ -2966,0 +2992,7 @@\n+  \/\/ Allocate space for the code.  Setup code generation tools.\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n+  if (blob != nullptr) {\n+    return blob->as_safepoint_blob();\n+  }\n+\n@@ -2969,3 +3002,0 @@\n-\n-  \/\/ Allocate space for the code.  Setup code generation tools.\n-  const char* name = SharedRuntime::stub_name(id);\n@@ -2978,2 +3008,2 @@\n-  bool cause_return = (id == SharedStubId::polling_page_return_handler_id);\n-  bool save_wide_vectors = (id == SharedStubId::polling_page_vectors_safepoint_handler_id);\n+  bool cause_return = (id == StubId::shared_polling_page_return_handler_id);\n+  bool save_wide_vectors = (id == StubId::shared_polling_page_vectors_safepoint_handler_id);\n@@ -3131,1 +3161,4 @@\n-  return SafepointBlob::create(&buffer, oop_maps, frame_size_in_words);\n+  SafepointBlob* sp_blob = SafepointBlob::create(&buffer, oop_maps, frame_size_in_words);\n+\n+  AOTCodeCache::store_code_blob(*sp_blob, AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n+  return sp_blob;\n@@ -3142,1 +3175,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(StubId id, address destination) {\n@@ -3146,0 +3179,6 @@\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n+  if (blob != nullptr) {\n+    return blob->as_runtime_stub();\n+  }\n+\n@@ -3148,2 +3187,0 @@\n-\n-  const char* name = SharedRuntime::stub_name(id);\n@@ -3218,1 +3255,4 @@\n-  return RuntimeStub::new_runtime_stub(name, &buffer, frame_complete, frame_size_in_words, oop_maps, true);\n+  RuntimeStub* rs_blob = RuntimeStub::new_runtime_stub(name, &buffer, frame_complete, frame_size_in_words, oop_maps, true);\n+\n+  AOTCodeCache::store_code_blob(*rs_blob, AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n+  return rs_blob;\n@@ -3236,1 +3276,1 @@\n-RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+RuntimeStub* SharedRuntime::generate_throw_exception(StubId id, address runtime_entry) {\n@@ -3256,1 +3296,0 @@\n-  ResourceMark rm;\n@@ -3260,0 +3299,6 @@\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n+  if (blob != nullptr) {\n+    return blob->as_runtime_stub();\n+  }\n+\n+  ResourceMark rm;\n@@ -3317,0 +3362,2 @@\n+  AOTCodeCache::store_code_blob(*stub, AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n+\n@@ -3599,1 +3646,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_write_checkpoint_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_jfr_write_checkpoint_id);\n@@ -3644,1 +3691,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_return_lease_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_jfr_return_lease_id);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":63,"deletions":16,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -29,0 +29,7 @@\n+#define STUBGEN_PREUNIVERSE_BLOBS_ARCH_DO(do_stub,                      \\\n+                                          do_arch_blob,                 \\\n+                                          do_arch_entry,                \\\n+                                          do_arch_entry_init)           \\\n+  do_arch_blob(preuniverse, 500)                                        \\\n+\n+\n@@ -111,1 +118,1 @@\n-  do_arch_entry(x86, compiler, vector_int_shuffle_mask,                 \\\n+  do_arch_entry(x86, compiler, vector_byte_shuffle_mask,                 \\\n@@ -114,1 +121,1 @@\n-  do_arch_entry(x86, compiler, vector_int_shuffle_mask,                 \\\n+  do_arch_entry(x86, compiler, vector_short_shuffle_mask,               \\\n@@ -242,1 +249,1 @@\n-  do_arch_blob(final, 31000                                             \\\n+  do_arch_blob(final, 33000                                             \\\n","filename":"src\/hotspot\/cpu\/x86\/stubDeclarations_x86.hpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-  StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+  StubId stub_id = StubId::stubgen_call_stub_id;\n@@ -413,1 +413,1 @@\n-  StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+  StubId stub_id = StubId::stubgen_catch_exception_id;\n@@ -469,1 +469,1 @@\n-  StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+  StubId stub_id = StubId::stubgen_forward_exception_id;\n@@ -533,1 +533,1 @@\n-  StubGenStubId stub_id = StubGenStubId::fence_id;\n+  StubId stub_id = StubId::stubgen_fence_id;\n@@ -549,1 +549,1 @@\n-  StubGenStubId stub_id = StubGenStubId::get_previous_sp_id;\n+  StubId stub_id = StubId::stubgen_get_previous_sp_id;\n@@ -568,1 +568,1 @@\n-  StubGenStubId stub_id = StubGenStubId::verify_mxcsr_id;\n+  StubId stub_id = StubId::stubgen_verify_mxcsr_id;\n@@ -597,1 +597,1 @@\n-  StubGenStubId stub_id = StubGenStubId::f2i_fixup_id;\n+  StubId stub_id = StubId::stubgen_f2i_fixup_id;\n@@ -636,1 +636,1 @@\n-  StubGenStubId stub_id = StubGenStubId::f2l_fixup_id;\n+  StubId stub_id = StubId::stubgen_f2l_fixup_id;\n@@ -674,1 +674,1 @@\n-  StubGenStubId stub_id = StubGenStubId::d2i_fixup_id;\n+  StubId stub_id = StubId::stubgen_d2i_fixup_id;\n@@ -722,1 +722,1 @@\n-  StubGenStubId stub_id = StubGenStubId::d2l_fixup_id;\n+  StubId stub_id = StubId::stubgen_d2l_fixup_id;\n@@ -771,1 +771,1 @@\n-  StubGenStubId stub_id = StubGenStubId::vector_count_leading_zeros_lut_id;\n+  StubId stub_id = StubId::stubgen_vector_count_leading_zeros_lut_id;\n@@ -789,1 +789,1 @@\n-  StubGenStubId stub_id = StubGenStubId::vector_popcount_lut_id;\n+  StubId stub_id = StubId::stubgen_vector_popcount_lut_id;\n@@ -807,1 +807,1 @@\n-  StubGenStubId stub_id = StubGenStubId::vector_iota_indices_id;\n+  StubId stub_id = StubId::stubgen_vector_iota_indices_id;\n@@ -869,1 +869,1 @@\n-  StubGenStubId stub_id = StubGenStubId::vector_reverse_bit_lut_id;\n+  StubId stub_id = StubId::stubgen_vector_reverse_bit_lut_id;\n@@ -887,1 +887,1 @@\n-  StubGenStubId stub_id = StubGenStubId::vector_reverse_byte_perm_mask_long_id;\n+  StubId stub_id = StubId::stubgen_vector_reverse_byte_perm_mask_long_id;\n@@ -905,1 +905,1 @@\n-  StubGenStubId stub_id = StubGenStubId::vector_reverse_byte_perm_mask_int_id;\n+  StubId stub_id = StubId::stubgen_vector_reverse_byte_perm_mask_int_id;\n@@ -923,1 +923,1 @@\n-  StubGenStubId stub_id = StubGenStubId::vector_reverse_byte_perm_mask_short_id;\n+  StubId stub_id = StubId::stubgen_vector_reverse_byte_perm_mask_short_id;\n@@ -941,1 +941,1 @@\n-  StubGenStubId stub_id = StubGenStubId::vector_byte_shuffle_mask_id;\n+  StubId stub_id = StubId::stubgen_vector_byte_shuffle_mask_id;\n@@ -953,1 +953,1 @@\n-address StubGenerator::generate_fp_mask(StubGenStubId stub_id, int64_t mask) {\n+address StubGenerator::generate_fp_mask(StubId stub_id, int64_t mask) {\n@@ -964,1 +964,1 @@\n-address StubGenerator::generate_compress_perm_table(StubGenStubId stub_id) {\n+address StubGenerator::generate_compress_perm_table(StubId stub_id) {\n@@ -967,1 +967,1 @@\n-  case compress_perm_table32_id:\n+  case StubId::stubgen_compress_perm_table32_id:\n@@ -970,1 +970,1 @@\n-  case compress_perm_table64_id:\n+  case StubId::stubgen_compress_perm_table64_id:\n@@ -1019,1 +1019,1 @@\n-address StubGenerator::generate_expand_perm_table(StubGenStubId stub_id) {\n+address StubGenerator::generate_expand_perm_table(StubId stub_id) {\n@@ -1022,1 +1022,1 @@\n-  case expand_perm_table32_id:\n+  case StubId::stubgen_expand_perm_table32_id:\n@@ -1025,1 +1025,1 @@\n-  case expand_perm_table64_id:\n+  case StubId::stubgen_expand_perm_table64_id:\n@@ -1072,1 +1072,1 @@\n-address StubGenerator::generate_vector_mask(StubGenStubId stub_id, int64_t mask) {\n+address StubGenerator::generate_vector_mask(StubId stub_id, int64_t mask) {\n@@ -1091,1 +1091,1 @@\n-  StubGenStubId stub_id = StubGenStubId::vector_byte_perm_mask_id;\n+  StubId stub_id = StubId::stubgen_vector_byte_perm_mask_id;\n@@ -1107,1 +1107,1 @@\n-address StubGenerator::generate_vector_fp_mask(StubGenStubId stub_id, int64_t mask) {\n+address StubGenerator::generate_vector_fp_mask(StubId stub_id, int64_t mask) {\n@@ -1124,1 +1124,1 @@\n-address StubGenerator::generate_vector_custom_i32(StubGenStubId stub_id, Assembler::AvxVectorLen len,\n+address StubGenerator::generate_vector_custom_i32(StubId stub_id, Assembler::AvxVectorLen len,\n@@ -1174,1 +1174,1 @@\n-  StubGenStubId stub_id = StubGenStubId::verify_oop_id;\n+  StubId stub_id = StubId::stubgen_verify_oop_id;\n@@ -1372,1 +1372,1 @@\n-  StubGenStubId stub_id = StubGenStubId::data_cache_writeback_id;\n+  StubId stub_id = StubId::stubgen_data_cache_writeback_id;\n@@ -1390,1 +1390,1 @@\n-  StubGenStubId stub_id = StubGenStubId::data_cache_writeback_sync_id;\n+  StubId stub_id = StubId::stubgen_data_cache_writeback_sync_id;\n@@ -1412,1 +1412,1 @@\n-address StubGenerator::generate_md5_implCompress(StubGenStubId stub_id) {\n+address StubGenerator::generate_md5_implCompress(StubId stub_id) {\n@@ -1415,1 +1415,1 @@\n-  case md5_implCompress_id:\n+  case StubId::stubgen_md5_implCompress_id:\n@@ -1418,1 +1418,1 @@\n-  case md5_implCompressMB_id:\n+  case StubId::stubgen_md5_implCompressMB_id:\n@@ -1461,1 +1461,1 @@\n-  StubGenStubId stub_id = StubGenStubId::upper_word_mask_id;\n+  StubId stub_id = StubId::stubgen_upper_word_mask_id;\n@@ -1473,1 +1473,1 @@\n-  StubGenStubId stub_id = StubGenStubId::shuffle_byte_flip_mask_id;\n+  StubId stub_id = StubId::stubgen_shuffle_byte_flip_mask_id;\n@@ -1485,1 +1485,1 @@\n-address StubGenerator::generate_sha1_implCompress(StubGenStubId stub_id) {\n+address StubGenerator::generate_sha1_implCompress(StubId stub_id) {\n@@ -1488,1 +1488,1 @@\n-  case sha1_implCompress_id:\n+  case StubId::stubgen_sha1_implCompress_id:\n@@ -1491,1 +1491,1 @@\n-  case sha1_implCompressMB_id:\n+  case StubId::stubgen_sha1_implCompressMB_id:\n@@ -1533,1 +1533,1 @@\n-  StubGenStubId stub_id = StubGenStubId::pshuffle_byte_flip_mask_id;\n+  StubId stub_id = StubId::stubgen_pshuffle_byte_flip_mask_id;\n@@ -1561,1 +1561,1 @@\n-  StubGenStubId stub_id = StubGenStubId::pshuffle_byte_flip_mask_sha512_id;\n+  StubId stub_id = StubId::stubgen_pshuffle_byte_flip_mask_sha512_id;\n@@ -1581,1 +1581,1 @@\n-address StubGenerator::generate_sha256_implCompress(StubGenStubId stub_id) {\n+address StubGenerator::generate_sha256_implCompress(StubId stub_id) {\n@@ -1584,1 +1584,1 @@\n-  case sha256_implCompress_id:\n+  case StubId::stubgen_sha256_implCompress_id:\n@@ -1587,1 +1587,1 @@\n-  case sha256_implCompressMB_id:\n+  case StubId::stubgen_sha256_implCompressMB_id:\n@@ -1634,1 +1634,1 @@\n-address StubGenerator::generate_sha512_implCompress(StubGenStubId stub_id) {\n+address StubGenerator::generate_sha512_implCompress(StubId stub_id) {\n@@ -1637,1 +1637,1 @@\n-  case sha512_implCompress_id:\n+  case StubId::stubgen_sha512_implCompress_id:\n@@ -1640,1 +1640,1 @@\n-  case sha512_implCompressMB_id:\n+  case StubId::stubgen_sha512_implCompressMB_id:\n@@ -1684,1 +1684,1 @@\n-  StubGenStubId stub_id = StubGenStubId::shuffle_base64_id;\n+  StubId stub_id = StubId::stubgen_shuffle_base64_id;\n@@ -1704,1 +1704,1 @@\n-  StubGenStubId stub_id = StubGenStubId::avx2_shuffle_base64_id;\n+  StubId stub_id = StubId::stubgen_avx2_shuffle_base64_id;\n@@ -1718,1 +1718,1 @@\n-  StubGenStubId stub_id = StubGenStubId::avx2_input_mask_base64_id;\n+  StubId stub_id = StubId::stubgen_avx2_input_mask_base64_id;\n@@ -1732,1 +1732,1 @@\n-  StubGenStubId stub_id = StubGenStubId::avx2_lut_base64_id;\n+  StubId stub_id = StubId::stubgen_avx2_lut_base64_id;\n@@ -1752,1 +1752,1 @@\n-  StubGenStubId stub_id = StubGenStubId::encoding_table_base64_id;\n+  StubId stub_id = StubId::stubgen_encoding_table_base64_id;\n@@ -1786,1 +1786,1 @@\n-  StubGenStubId stub_id = StubGenStubId::base64_encodeBlock_id;\n+  StubId stub_id = StubId::stubgen_base64_encodeBlock_id;\n@@ -2169,1 +2169,1 @@\n-  StubGenStubId stub_id = StubGenStubId::lookup_lo_base64_id;\n+  StubId stub_id = StubId::stubgen_lookup_lo_base64_id;\n@@ -2189,1 +2189,1 @@\n-  StubGenStubId stub_id = StubGenStubId::lookup_hi_base64_id;\n+  StubId stub_id = StubId::stubgen_lookup_hi_base64_id;\n@@ -2208,1 +2208,1 @@\n-  StubGenStubId stub_id = StubGenStubId::lookup_lo_base64url_id;\n+  StubId stub_id = StubId::stubgen_lookup_lo_base64url_id;\n@@ -2228,1 +2228,1 @@\n-  StubGenStubId stub_id = StubGenStubId::lookup_hi_base64url_id;\n+  StubId stub_id = StubId::stubgen_lookup_hi_base64url_id;\n@@ -2248,1 +2248,1 @@\n-  StubGenStubId stub_id = StubGenStubId::pack_vec_base64_id;\n+  StubId stub_id = StubId::stubgen_pack_vec_base64_id;\n@@ -2268,1 +2268,1 @@\n-  StubGenStubId stub_id = StubGenStubId::join_0_1_base64_id;\n+  StubId stub_id = StubId::stubgen_join_0_1_base64_id;\n@@ -2288,1 +2288,1 @@\n-  StubGenStubId stub_id = StubGenStubId::join_1_2_base64_id;\n+  StubId stub_id = StubId::stubgen_join_1_2_base64_id;\n@@ -2308,1 +2308,1 @@\n-  StubGenStubId stub_id = StubGenStubId::join_2_3_base64_id;\n+  StubId stub_id = StubId::stubgen_join_2_3_base64_id;\n@@ -2328,1 +2328,1 @@\n-  StubGenStubId stub_id = StubGenStubId::avx2_decode_tables_base64_id;\n+  StubId stub_id = StubId::stubgen_avx2_decode_tables_base64_id;\n@@ -2363,1 +2363,1 @@\n-  StubGenStubId stub_id = StubGenStubId::avx2_decode_lut_tables_base64_id;\n+  StubId stub_id = StubId::stubgen_avx2_decode_lut_tables_base64_id;\n@@ -2403,1 +2403,1 @@\n-  StubGenStubId stub_id = StubGenStubId::decoding_table_base64_id;\n+  StubId stub_id = StubId::stubgen_decoding_table_base64_id;\n@@ -2486,1 +2486,1 @@\n-  StubGenStubId stub_id = StubGenStubId::base64_decodeBlock_id;\n+  StubId stub_id = StubId::stubgen_base64_decodeBlock_id;\n@@ -3020,1 +3020,1 @@\n-  StubGenStubId stub_id = StubGenStubId::updateBytesCRC32_id;\n+  StubId stub_id = StubId::stubgen_updateBytesCRC32_id;\n@@ -3077,1 +3077,1 @@\n-  StubGenStubId stub_id = StubGenStubId::updateBytesCRC32C_id;\n+  StubId stub_id = StubId::stubgen_updateBytesCRC32C_id;\n@@ -3158,1 +3158,1 @@\n-  StubGenStubId stub_id = StubGenStubId::multiplyToLen_id;\n+  StubId stub_id = StubId::stubgen_multiplyToLen_id;\n@@ -3215,1 +3215,1 @@\n-  StubGenStubId stub_id = StubGenStubId::vectorizedMismatch_id;\n+  StubId stub_id = StubId::stubgen_vectorizedMismatch_id;\n@@ -3267,1 +3267,1 @@\n-  StubGenStubId stub_id = StubGenStubId::squareToLen_id;\n+  StubId stub_id = StubId::stubgen_squareToLen_id;\n@@ -3303,1 +3303,1 @@\n-  StubGenStubId stub_id = StubGenStubId::method_entry_barrier_id;\n+  StubId stub_id = StubId::stubgen_method_entry_barrier_id;\n@@ -3393,1 +3393,1 @@\n-  StubGenStubId stub_id = StubGenStubId::mulAdd_id;\n+  StubId stub_id = StubId::stubgen_mulAdd_id;\n@@ -3435,1 +3435,1 @@\n-  StubGenStubId stub_id = StubGenStubId::bigIntegerRightShiftWorker_id;\n+  StubId stub_id = StubId::stubgen_bigIntegerRightShiftWorker_id;\n@@ -3571,1 +3571,1 @@\n-  StubGenStubId stub_id = StubGenStubId::bigIntegerLeftShiftWorker_id;\n+  StubId stub_id = StubId::stubgen_bigIntegerLeftShiftWorker_id;\n@@ -3695,0 +3695,3 @@\n+    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dcbrt)) {\n+      StubRoutines::_dcbrt = generate_libmCbrt(); \/\/ from stubGenerator_x86_64_cbrt.cpp\n+    }\n@@ -3720,1 +3723,1 @@\n-  StubGenStubId stub_id = StubGenStubId::hf2f_id;\n+  StubId stub_id = StubId::stubgen_hf2f_id;\n@@ -3746,1 +3749,1 @@\n-  StubGenStubId stub_id = StubGenStubId::f2hf_id;\n+  StubId stub_id = StubId::stubgen_f2hf_id;\n@@ -3762,1 +3765,1 @@\n-address StubGenerator::generate_cont_thaw(StubGenStubId stub_id) {\n+address StubGenerator::generate_cont_thaw(StubId stub_id) {\n@@ -3770,1 +3773,1 @@\n-  case cont_thaw_id:\n+  case StubId::stubgen_cont_thaw_id:\n@@ -3775,1 +3778,1 @@\n-  case cont_returnBarrier_id:\n+  case StubId::stubgen_cont_returnBarrier_id:\n@@ -3780,1 +3783,1 @@\n-  case cont_returnBarrierExc_id:\n+  case StubId::stubgen_cont_returnBarrierExc_id:\n@@ -3906,1 +3909,1 @@\n-  return generate_cont_thaw(StubGenStubId::cont_thaw_id);\n+  return generate_cont_thaw(StubId::stubgen_cont_thaw_id);\n@@ -3912,1 +3915,1 @@\n-  return generate_cont_thaw(StubGenStubId::cont_returnBarrier_id);\n+  return generate_cont_thaw(StubId::stubgen_cont_returnBarrier_id);\n@@ -3916,1 +3919,1 @@\n-  return generate_cont_thaw(StubGenStubId::cont_returnBarrierExc_id);\n+  return generate_cont_thaw(StubId::stubgen_cont_returnBarrierExc_id);\n@@ -3921,1 +3924,1 @@\n-  StubGenStubId stub_id = StubGenStubId::cont_preempt_id;\n+  StubId stub_id = StubId::stubgen_cont_preempt_id;\n@@ -3952,1 +3955,1 @@\n-  StubGenStubId stub_id = StubGenStubId::upcall_stub_exception_handler_id;\n+  StubId stub_id = StubId::stubgen_upcall_stub_exception_handler_id;\n@@ -3973,1 +3976,1 @@\n-  StubGenStubId stub_id = StubGenStubId::upcall_stub_load_target_id;\n+  StubId stub_id = StubId::stubgen_upcall_stub_load_target_id;\n@@ -3993,1 +3996,1 @@\n-  StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n+  StubId stub_id = StubId::stubgen_lookup_secondary_supers_table_id;\n@@ -4013,1 +4016,1 @@\n-  StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_slow_path_id;\n+  StubId stub_id = StubId::stubgen_lookup_secondary_supers_table_slow_path_id;\n@@ -4049,0 +4052,5 @@\n+void StubGenerator::generate_preuniverse_stubs() {\n+  \/\/ atomic calls\n+  StubRoutines::_fence_entry                = generate_orderaccess_fence();\n+}\n+\n@@ -4074,3 +4082,0 @@\n-  \/\/ atomic calls\n-  StubRoutines::_fence_entry                = generate_orderaccess_fence();\n-\n@@ -4087,4 +4092,4 @@\n-  StubRoutines::x86::_float_sign_mask       = generate_fp_mask(StubGenStubId::float_sign_mask_id,  0x7FFFFFFF7FFFFFFF);\n-  StubRoutines::x86::_float_sign_flip       = generate_fp_mask(StubGenStubId::float_sign_flip_id,  0x8000000080000000);\n-  StubRoutines::x86::_double_sign_mask      = generate_fp_mask(StubGenStubId::double_sign_mask_id, 0x7FFFFFFFFFFFFFFF);\n-  StubRoutines::x86::_double_sign_flip      = generate_fp_mask(StubGenStubId::double_sign_flip_id, 0x8000000000000000);\n+  StubRoutines::x86::_float_sign_mask       = generate_fp_mask(StubId::stubgen_float_sign_mask_id,  0x7FFFFFFF7FFFFFFF);\n+  StubRoutines::x86::_float_sign_flip       = generate_fp_mask(StubId::stubgen_float_sign_flip_id,  0x8000000080000000);\n+  StubRoutines::x86::_double_sign_mask      = generate_fp_mask(StubId::stubgen_double_sign_mask_id, 0x7FFFFFFFFFFFFFFF);\n+  StubRoutines::x86::_double_sign_flip      = generate_fp_mask(StubId::stubgen_double_sign_flip_id, 0x8000000000000000);\n@@ -4163,7 +4168,7 @@\n-  StubRoutines::x86::_vector_float_sign_mask = generate_vector_mask(StubGenStubId::vector_float_sign_mask_id, 0x7FFFFFFF7FFFFFFF);\n-  StubRoutines::x86::_vector_float_sign_flip = generate_vector_mask(StubGenStubId::vector_float_sign_flip_id, 0x8000000080000000);\n-  StubRoutines::x86::_vector_double_sign_mask = generate_vector_mask(StubGenStubId::vector_double_sign_mask_id, 0x7FFFFFFFFFFFFFFF);\n-  StubRoutines::x86::_vector_double_sign_flip = generate_vector_mask(StubGenStubId::vector_double_sign_flip_id, 0x8000000000000000);\n-  StubRoutines::x86::_vector_all_bits_set = generate_vector_mask(StubGenStubId::vector_all_bits_set_id, 0xFFFFFFFFFFFFFFFF);\n-  StubRoutines::x86::_vector_int_mask_cmp_bits = generate_vector_mask(StubGenStubId::vector_int_mask_cmp_bits_id, 0x0000000100000001);\n-  StubRoutines::x86::_vector_short_to_byte_mask = generate_vector_mask(StubGenStubId::vector_short_to_byte_mask_id, 0x00ff00ff00ff00ff);\n+  StubRoutines::x86::_vector_float_sign_mask = generate_vector_mask(StubId::stubgen_vector_float_sign_mask_id, 0x7FFFFFFF7FFFFFFF);\n+  StubRoutines::x86::_vector_float_sign_flip = generate_vector_mask(StubId::stubgen_vector_float_sign_flip_id, 0x8000000080000000);\n+  StubRoutines::x86::_vector_double_sign_mask = generate_vector_mask(StubId::stubgen_vector_double_sign_mask_id, 0x7FFFFFFFFFFFFFFF);\n+  StubRoutines::x86::_vector_double_sign_flip = generate_vector_mask(StubId::stubgen_vector_double_sign_flip_id, 0x8000000000000000);\n+  StubRoutines::x86::_vector_all_bits_set = generate_vector_mask(StubId::stubgen_vector_all_bits_set_id, 0xFFFFFFFFFFFFFFFF);\n+  StubRoutines::x86::_vector_int_mask_cmp_bits = generate_vector_mask(StubId::stubgen_vector_int_mask_cmp_bits_id, 0x0000000100000001);\n+  StubRoutines::x86::_vector_short_to_byte_mask = generate_vector_mask(StubId::stubgen_vector_short_to_byte_mask_id, 0x00ff00ff00ff00ff);\n@@ -4171,3 +4176,3 @@\n-  StubRoutines::x86::_vector_int_to_byte_mask = generate_vector_mask(StubGenStubId::vector_int_to_byte_mask_id, 0x000000ff000000ff);\n-  StubRoutines::x86::_vector_int_to_short_mask = generate_vector_mask(StubGenStubId::vector_int_to_short_mask_id, 0x0000ffff0000ffff);\n-  StubRoutines::x86::_vector_32_bit_mask = generate_vector_custom_i32(StubGenStubId::vector_32_bit_mask_id, Assembler::AVX_512bit,\n+  StubRoutines::x86::_vector_int_to_byte_mask = generate_vector_mask(StubId::stubgen_vector_int_to_byte_mask_id, 0x000000ff000000ff);\n+  StubRoutines::x86::_vector_int_to_short_mask = generate_vector_mask(StubId::stubgen_vector_int_to_short_mask_id, 0x0000ffff0000ffff);\n+  StubRoutines::x86::_vector_32_bit_mask = generate_vector_custom_i32(StubId::stubgen_vector_32_bit_mask_id, Assembler::AVX_512bit,\n@@ -4175,1 +4180,1 @@\n-  StubRoutines::x86::_vector_64_bit_mask = generate_vector_custom_i32(StubGenStubId::vector_64_bit_mask_id, Assembler::AVX_512bit,\n+  StubRoutines::x86::_vector_64_bit_mask = generate_vector_custom_i32(StubId::stubgen_vector_64_bit_mask_id, Assembler::AVX_512bit,\n@@ -4177,1 +4182,1 @@\n-  StubRoutines::x86::_vector_int_shuffle_mask = generate_vector_mask(StubGenStubId::vector_int_shuffle_mask_id, 0x0302010003020100);\n+  StubRoutines::x86::_vector_int_shuffle_mask = generate_vector_mask(StubId::stubgen_vector_int_shuffle_mask_id, 0x0302010003020100);\n@@ -4179,3 +4184,3 @@\n-  StubRoutines::x86::_vector_short_shuffle_mask = generate_vector_mask(StubGenStubId::vector_short_shuffle_mask_id, 0x0100010001000100);\n-  StubRoutines::x86::_vector_long_shuffle_mask = generate_vector_mask(StubGenStubId::vector_long_shuffle_mask_id, 0x0000000100000000);\n-  StubRoutines::x86::_vector_long_sign_mask = generate_vector_mask(StubGenStubId::vector_long_sign_mask_id, 0x8000000000000000);\n+  StubRoutines::x86::_vector_short_shuffle_mask = generate_vector_mask(StubId::stubgen_vector_short_shuffle_mask_id, 0x0100010001000100);\n+  StubRoutines::x86::_vector_long_shuffle_mask = generate_vector_mask(StubId::stubgen_vector_long_shuffle_mask_id, 0x0000000100000000);\n+  StubRoutines::x86::_vector_long_sign_mask = generate_vector_mask(StubId::stubgen_vector_long_sign_mask_id, 0x8000000000000000);\n@@ -4190,4 +4195,4 @@\n-    StubRoutines::x86::_compress_perm_table32 = generate_compress_perm_table(StubGenStubId::compress_perm_table32_id);\n-    StubRoutines::x86::_compress_perm_table64 = generate_compress_perm_table(StubGenStubId::compress_perm_table64_id);\n-    StubRoutines::x86::_expand_perm_table32 = generate_expand_perm_table(StubGenStubId::expand_perm_table32_id);\n-    StubRoutines::x86::_expand_perm_table64 = generate_expand_perm_table(StubGenStubId::expand_perm_table64_id);\n+    StubRoutines::x86::_compress_perm_table32 = generate_compress_perm_table(StubId::stubgen_compress_perm_table32_id);\n+    StubRoutines::x86::_compress_perm_table64 = generate_compress_perm_table(StubId::stubgen_compress_perm_table64_id);\n+    StubRoutines::x86::_expand_perm_table32 = generate_expand_perm_table(StubId::stubgen_expand_perm_table32_id);\n+    StubRoutines::x86::_expand_perm_table64 = generate_expand_perm_table(StubId::stubgen_expand_perm_table64_id);\n@@ -4207,0 +4212,2 @@\n+  generate_kyber_stubs();\n+\n@@ -4235,2 +4242,2 @@\n-    StubRoutines::_md5_implCompress = generate_md5_implCompress(StubGenStubId::md5_implCompress_id);\n-    StubRoutines::_md5_implCompressMB = generate_md5_implCompress(StubGenStubId::md5_implCompressMB_id);\n+    StubRoutines::_md5_implCompress = generate_md5_implCompress(StubId::stubgen_md5_implCompress_id);\n+    StubRoutines::_md5_implCompressMB = generate_md5_implCompress(StubId::stubgen_md5_implCompressMB_id);\n@@ -4242,2 +4249,2 @@\n-    StubRoutines::_sha1_implCompress = generate_sha1_implCompress(StubGenStubId::sha1_implCompress_id);\n-    StubRoutines::_sha1_implCompressMB = generate_sha1_implCompress(StubGenStubId::sha1_implCompressMB_id);\n+    StubRoutines::_sha1_implCompress = generate_sha1_implCompress(StubId::stubgen_sha1_implCompress_id);\n+    StubRoutines::_sha1_implCompressMB = generate_sha1_implCompress(StubId::stubgen_sha1_implCompressMB_id);\n@@ -4256,2 +4263,2 @@\n-    StubRoutines::_sha256_implCompress = generate_sha256_implCompress(StubGenStubId::sha256_implCompress_id);\n-    StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(StubGenStubId::sha256_implCompressMB_id);\n+    StubRoutines::_sha256_implCompress = generate_sha256_implCompress(StubId::stubgen_sha256_implCompress_id);\n+    StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(StubId::stubgen_sha256_implCompressMB_id);\n@@ -4263,2 +4270,2 @@\n-    StubRoutines::_sha512_implCompress = generate_sha512_implCompress(StubGenStubId::sha512_implCompress_id);\n-    StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(StubGenStubId::sha512_implCompressMB_id);\n+    StubRoutines::_sha512_implCompress = generate_sha512_implCompress(StubId::stubgen_sha512_implCompress_id);\n+    StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(StubId::stubgen_sha512_implCompressMB_id);\n@@ -4340,1 +4347,1 @@\n-StubGenerator::StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+StubGenerator::StubGenerator(CodeBuffer* code, BlobId blob_id) : StubCodeGenerator(code, blob_id) {\n@@ -4342,1 +4349,4 @@\n-  case initial_id:\n+  case BlobId::stubgen_preuniverse_id:\n+    generate_preuniverse_stubs();\n+    break;\n+  case BlobId::stubgen_initial_id:\n@@ -4345,1 +4355,1 @@\n-  case continuation_id:\n+  case BlobId::stubgen_continuation_id:\n@@ -4348,1 +4358,1 @@\n-  case compiler_id:\n+  case BlobId::stubgen_compiler_id:\n@@ -4351,1 +4361,1 @@\n-  case final_id:\n+  case BlobId::stubgen_final_id:\n@@ -4355,1 +4365,1 @@\n-    fatal(\"unexpected blob id: %d\", blob_id);\n+    fatal(\"unexpected blob id: %s\", StubInfo::name(blob_id));\n@@ -4360,1 +4370,1 @@\n-void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+void StubGenerator_generate(CodeBuffer* code, BlobId blob_id) {\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":140,"deletions":130,"binary":false,"changes":270,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-  address generate_fp_mask(StubGenStubId stub_id, int64_t mask);\n+  address generate_fp_mask(StubId stub_id, int64_t mask);\n@@ -103,1 +103,1 @@\n-  address generate_compress_perm_table(StubGenStubId stub_id);\n+  address generate_compress_perm_table(StubId stub_id);\n@@ -105,1 +105,1 @@\n-  address generate_expand_perm_table(StubGenStubId stub_id);\n+  address generate_expand_perm_table(StubId stub_id);\n@@ -107,1 +107,1 @@\n-  address generate_vector_mask(StubGenStubId stub_id, int64_t mask);\n+  address generate_vector_mask(StubId stub_id, int64_t mask);\n@@ -111,1 +111,1 @@\n-  address generate_vector_fp_mask(StubGenStubId stub_id, int64_t mask);\n+  address generate_vector_fp_mask(StubId stub_id, int64_t mask);\n@@ -113,1 +113,1 @@\n-  address generate_vector_custom_i32(StubGenStubId stub_id, Assembler::AvxVectorLen len,\n+  address generate_vector_custom_i32(StubId stub_id, Assembler::AvxVectorLen len,\n@@ -183,1 +183,1 @@\n-  address generate_disjoint_copy_avx3_masked(StubGenStubId stub_id, address* entry);\n+  address generate_disjoint_copy_avx3_masked(StubId stub_id, address* entry);\n@@ -185,1 +185,1 @@\n-  address generate_conjoint_copy_avx3_masked(StubGenStubId stub_id, address* entry,\n+  address generate_conjoint_copy_avx3_masked(StubId stub_id, address* entry,\n@@ -233,1 +233,1 @@\n-  address generate_fill(StubGenStubId stub_id);\n+  address generate_fill(StubId stub_id);\n@@ -236,2 +236,2 @@\n-  address generate_disjoint_int_oop_copy(StubGenStubId stub_id, address* entry);\n-  address generate_conjoint_int_oop_copy(StubGenStubId stub_id, address nooverlap_target,\n+  address generate_disjoint_int_oop_copy(StubId stub_id, address* entry);\n+  address generate_conjoint_int_oop_copy(StubId stub_id, address nooverlap_target,\n@@ -239,2 +239,2 @@\n-  address generate_disjoint_long_oop_copy(StubGenStubId stub_id, address* entry);\n-  address generate_conjoint_long_oop_copy(StubGenStubId stub_id, address nooverlap_target,\n+  address generate_disjoint_long_oop_copy(StubId stub_id, address* entry);\n+  address generate_conjoint_long_oop_copy(StubId stub_id, address nooverlap_target,\n@@ -251,1 +251,1 @@\n-  address generate_checkcast_copy(StubGenStubId stub_id, address *entry);\n+  address generate_checkcast_copy(StubId stub_id, address *entry);\n@@ -297,1 +297,1 @@\n-  address generate_md5_implCompress(StubGenStubId stub_id);\n+  address generate_md5_implCompress(StubId stub_id);\n@@ -304,1 +304,1 @@\n-  address generate_sha1_implCompress(StubGenStubId stub_id);\n+  address generate_sha1_implCompress(StubId stub_id);\n@@ -308,2 +308,2 @@\n-  address generate_sha256_implCompress(StubGenStubId stub_id);\n-  address generate_sha512_implCompress(StubGenStubId stub_id);\n+  address generate_sha256_implCompress(StubId stub_id);\n+  address generate_sha512_implCompress(StubId stub_id);\n@@ -493,1 +493,4 @@\n-  \/\/ Dilithium stubs and helper functions\n+  \/\/ Kyber stubs\n+  void generate_kyber_stubs();\n+\n+  \/\/ Dilithium stubs\n@@ -495,1 +498,1 @@\n-  \/\/ BASE64 stubs\n+  \/\/ BASE64 stubs\n@@ -556,0 +559,1 @@\n+  address generate_libmCbrt();\n@@ -589,1 +593,1 @@\n-  address generate_cont_thaw(StubGenStubId stub_id);\n+  address generate_cont_thaw(StubId stub_id);\n@@ -633,0 +637,1 @@\n+  void generate_preuniverse_stubs();\n@@ -639,1 +644,1 @@\n-  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id);\n+  StubGenerator(CodeBuffer* code, BlobId blob_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":27,"deletions":22,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2021, 2024, Intel Corporation. All rights reserved.\n+* Copyright (c) 2021, 2025, Intel Corporation. All rights reserved.\n@@ -69,1 +69,1 @@\n-  StubGenStubId stub_id = StubGenStubId::updateBytesAdler32_id;\n+  StubId stub_id = StubId::stubgen_updateBytesAdler32_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_adler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2019, 2024, Intel Corporation. All rights reserved.\n+* Copyright (c) 2019, 2025, Intel Corporation. All rights reserved.\n@@ -252,1 +252,1 @@\n-  StubGenStubId stub_id = StubGenStubId::galoisCounterMode_AESCrypt_id;\n+  StubId stub_id = StubId::stubgen_galoisCounterMode_AESCrypt_id;\n@@ -339,1 +339,1 @@\n-  StubGenStubId stub_id = StubGenStubId::galoisCounterMode_AESCrypt_id;\n+  StubId stub_id = StubId::stubgen_galoisCounterMode_AESCrypt_id;\n@@ -411,1 +411,1 @@\n-  StubGenStubId stub_id = StubGenStubId::counterMode_AESCrypt_id;\n+  StubId stub_id = StubId::stubgen_counterMode_AESCrypt_id;\n@@ -500,1 +500,1 @@\n-  StubGenStubId stub_id = StubGenStubId::counterMode_AESCrypt_id;\n+  StubId stub_id = StubId::stubgen_counterMode_AESCrypt_id;\n@@ -788,1 +788,1 @@\n-  StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_decryptAESCrypt_id;\n+  StubId stub_id = StubId::stubgen_cipherBlockChaining_decryptAESCrypt_id;\n@@ -1071,1 +1071,1 @@\n-  StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+  StubId stub_id = StubId::stubgen_aescrypt_encryptBlock_id;\n@@ -1166,1 +1166,1 @@\n-  StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+  StubId stub_id = StubId::stubgen_aescrypt_decryptBlock_id;\n@@ -1268,1 +1268,1 @@\n-  StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_encryptAESCrypt_id;\n+  StubId stub_id = StubId::stubgen_cipherBlockChaining_encryptAESCrypt_id;\n@@ -1420,1 +1420,1 @@\n-  StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_decryptAESCrypt_id;\n+  StubId stub_id = StubId::stubgen_cipherBlockChaining_decryptAESCrypt_id;\n@@ -1663,1 +1663,1 @@\n-  StubGenStubId stub_id = StubGenStubId::electronicCodeBook_encryptAESCrypt_id;\n+  StubId stub_id = StubId::stubgen_electronicCodeBook_encryptAESCrypt_id;\n@@ -1684,1 +1684,1 @@\n-  StubGenStubId stub_id = StubGenStubId::electronicCodeBook_decryptAESCrypt_id;\n+  StubId stub_id = StubId::stubgen_electronicCodeBook_decryptAESCrypt_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_aes.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -93,2 +93,2 @@\n-  StubRoutines::_jint_disjoint_arraycopy   = generate_disjoint_int_oop_copy(StubGenStubId::jint_disjoint_arraycopy_id, &entry);\n-  StubRoutines::_jint_arraycopy            = generate_conjoint_int_oop_copy(StubGenStubId::jint_arraycopy_id, entry, &entry_jint_arraycopy);\n+  StubRoutines::_jint_disjoint_arraycopy   = generate_disjoint_int_oop_copy(StubId::stubgen_jint_disjoint_arraycopy_id, &entry);\n+  StubRoutines::_jint_arraycopy            = generate_conjoint_int_oop_copy(StubId::stubgen_jint_arraycopy_id, entry, &entry_jint_arraycopy);\n@@ -96,2 +96,2 @@\n-  StubRoutines::_jlong_disjoint_arraycopy  = generate_disjoint_long_oop_copy(StubGenStubId::jlong_disjoint_arraycopy_id, &entry);\n-  StubRoutines::_jlong_arraycopy           = generate_conjoint_long_oop_copy(StubGenStubId::jlong_arraycopy_id, entry, &entry_jlong_arraycopy);\n+  StubRoutines::_jlong_disjoint_arraycopy  = generate_disjoint_long_oop_copy(StubId::stubgen_jlong_disjoint_arraycopy_id, &entry);\n+  StubRoutines::_jlong_arraycopy           = generate_conjoint_long_oop_copy(StubId::stubgen_jlong_arraycopy_id, entry, &entry_jlong_arraycopy);\n@@ -99,4 +99,4 @@\n-    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_int_oop_copy(StubGenStubId::oop_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_oop_arraycopy           = generate_conjoint_int_oop_copy(StubGenStubId::oop_arraycopy_id, entry, &entry_oop_arraycopy);\n-    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_int_oop_copy(StubGenStubId::oop_disjoint_arraycopy_uninit_id, &entry);\n-    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_int_oop_copy(StubGenStubId::oop_arraycopy_uninit_id, entry, nullptr);\n+    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_int_oop_copy(StubId::stubgen_oop_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_oop_arraycopy           = generate_conjoint_int_oop_copy(StubId::stubgen_oop_arraycopy_id, entry, &entry_oop_arraycopy);\n+    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_int_oop_copy(StubId::stubgen_oop_disjoint_arraycopy_uninit_id, &entry);\n+    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_int_oop_copy(StubId::stubgen_oop_arraycopy_uninit_id, entry, nullptr);\n@@ -104,4 +104,4 @@\n-    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_long_oop_copy(StubGenStubId::oop_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_oop_arraycopy           = generate_conjoint_long_oop_copy(StubGenStubId::oop_arraycopy_id, entry, &entry_oop_arraycopy);\n-    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_long_oop_copy(StubGenStubId::oop_disjoint_arraycopy_uninit_id, &entry);\n-    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_long_oop_copy(StubGenStubId::oop_arraycopy_uninit_id, entry, nullptr);\n+    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_long_oop_copy(StubId::stubgen_oop_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_oop_arraycopy           = generate_conjoint_long_oop_copy(StubId::stubgen_oop_arraycopy_id, entry, &entry_oop_arraycopy);\n+    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_long_oop_copy(StubId::stubgen_oop_disjoint_arraycopy_uninit_id, &entry);\n+    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_long_oop_copy(StubId::stubgen_oop_arraycopy_uninit_id, entry, nullptr);\n@@ -110,2 +110,2 @@\n-  StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_id, &entry_checkcast_arraycopy);\n-  StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_uninit_id, nullptr);\n+  StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubId::stubgen_checkcast_arraycopy_id, &entry_checkcast_arraycopy);\n+  StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubId::stubgen_checkcast_arraycopy_uninit_id, nullptr);\n@@ -124,6 +124,6 @@\n-  StubRoutines::_jbyte_fill = generate_fill(StubGenStubId::jbyte_fill_id);\n-  StubRoutines::_jshort_fill = generate_fill(StubGenStubId::jshort_fill_id);\n-  StubRoutines::_jint_fill = generate_fill(StubGenStubId::jint_fill_id);\n-  StubRoutines::_arrayof_jbyte_fill = generate_fill(StubGenStubId::arrayof_jbyte_fill_id);\n-  StubRoutines::_arrayof_jshort_fill = generate_fill(StubGenStubId::arrayof_jshort_fill_id);\n-  StubRoutines::_arrayof_jint_fill = generate_fill(StubGenStubId::arrayof_jint_fill_id);\n+  StubRoutines::_jbyte_fill = generate_fill(StubId::stubgen_jbyte_fill_id);\n+  StubRoutines::_jshort_fill = generate_fill(StubId::stubgen_jshort_fill_id);\n+  StubRoutines::_jint_fill = generate_fill(StubId::stubgen_jint_fill_id);\n+  StubRoutines::_arrayof_jbyte_fill = generate_fill(StubId::stubgen_arrayof_jbyte_fill_id);\n+  StubRoutines::_arrayof_jshort_fill = generate_fill(StubId::stubgen_arrayof_jshort_fill_id);\n+  StubRoutines::_arrayof_jint_fill = generate_fill(StubId::stubgen_arrayof_jint_fill_id);\n@@ -487,1 +487,1 @@\n-address StubGenerator::generate_disjoint_copy_avx3_masked(StubGenStubId stub_id, address* entry) {\n+address StubGenerator::generate_disjoint_copy_avx3_masked(StubId stub_id, address* entry) {\n@@ -495,1 +495,1 @@\n-  case jbyte_disjoint_arraycopy_id:\n+  case StubId::stubgen_jbyte_disjoint_arraycopy_id:\n@@ -500,1 +500,1 @@\n-  case jshort_disjoint_arraycopy_id:\n+  case StubId::stubgen_jshort_disjoint_arraycopy_id:\n@@ -505,1 +505,1 @@\n-  case jint_disjoint_arraycopy_id:\n+  case StubId::stubgen_jint_disjoint_arraycopy_id:\n@@ -510,1 +510,1 @@\n-  case jlong_disjoint_arraycopy_id:\n+  case StubId::stubgen_jlong_disjoint_arraycopy_id:\n@@ -515,1 +515,1 @@\n-  case oop_disjoint_arraycopy_id:\n+  case StubId::stubgen_oop_disjoint_arraycopy_id:\n@@ -520,1 +520,1 @@\n-  case oop_disjoint_arraycopy_uninit_id:\n+  case StubId::stubgen_oop_disjoint_arraycopy_uninit_id:\n@@ -825,1 +825,1 @@\n-address StubGenerator::generate_conjoint_copy_avx3_masked(StubGenStubId stub_id, address* entry, address nooverlap_target) {\n+address StubGenerator::generate_conjoint_copy_avx3_masked(StubId stub_id, address* entry, address nooverlap_target) {\n@@ -833,1 +833,1 @@\n-  case jbyte_arraycopy_id:\n+  case StubId::stubgen_jbyte_arraycopy_id:\n@@ -838,1 +838,1 @@\n-  case jshort_arraycopy_id:\n+  case StubId::stubgen_jshort_arraycopy_id:\n@@ -843,1 +843,1 @@\n-  case jint_arraycopy_id:\n+  case StubId::stubgen_jint_arraycopy_id:\n@@ -848,1 +848,1 @@\n-  case jlong_arraycopy_id:\n+  case StubId::stubgen_jlong_arraycopy_id:\n@@ -853,1 +853,1 @@\n-  case oop_arraycopy_id:\n+  case StubId::stubgen_oop_arraycopy_id:\n@@ -858,1 +858,1 @@\n-  case oop_arraycopy_uninit_id:\n+  case StubId::stubgen_oop_arraycopy_uninit_id:\n@@ -1337,1 +1337,1 @@\n-  StubGenStubId stub_id = StubGenStubId::jbyte_disjoint_arraycopy_id;\n+  StubId stub_id = StubId::stubgen_jbyte_disjoint_arraycopy_id;\n@@ -1455,1 +1455,1 @@\n-  StubGenStubId stub_id = StubGenStubId::jbyte_arraycopy_id;\n+  StubId stub_id = StubId::stubgen_jbyte_arraycopy_id;\n@@ -1568,1 +1568,1 @@\n-  StubGenStubId stub_id = StubGenStubId::jshort_disjoint_arraycopy_id;\n+  StubId stub_id = StubId::stubgen_jshort_disjoint_arraycopy_id;\n@@ -1665,1 +1665,1 @@\n-address StubGenerator::generate_fill(StubGenStubId stub_id) {\n+address StubGenerator::generate_fill(StubId stub_id) {\n@@ -1670,1 +1670,1 @@\n-  case jbyte_fill_id:\n+  case StubId::stubgen_jbyte_fill_id:\n@@ -1674,1 +1674,1 @@\n-  case jshort_fill_id:\n+  case StubId::stubgen_jshort_fill_id:\n@@ -1678,1 +1678,1 @@\n-  case jint_fill_id:\n+  case StubId::stubgen_jint_fill_id:\n@@ -1682,1 +1682,1 @@\n-  case arrayof_jbyte_fill_id:\n+  case StubId::stubgen_arrayof_jbyte_fill_id:\n@@ -1686,1 +1686,1 @@\n-  case arrayof_jshort_fill_id:\n+  case StubId::stubgen_arrayof_jshort_fill_id:\n@@ -1690,1 +1690,1 @@\n-  case arrayof_jint_fill_id:\n+  case StubId::stubgen_arrayof_jint_fill_id:\n@@ -1740,1 +1740,1 @@\n-  StubGenStubId stub_id = StubGenStubId::jshort_arraycopy_id;\n+  StubId stub_id = StubId::stubgen_jshort_arraycopy_id;\n@@ -1846,1 +1846,1 @@\n-address StubGenerator::generate_disjoint_int_oop_copy(StubGenStubId stub_id, address* entry) {\n+address StubGenerator::generate_disjoint_int_oop_copy(StubId stub_id, address* entry) {\n@@ -1852,1 +1852,1 @@\n-  case StubGenStubId::jint_disjoint_arraycopy_id:\n+  case StubId::stubgen_jint_disjoint_arraycopy_id:\n@@ -1856,1 +1856,1 @@\n-  case StubGenStubId::oop_disjoint_arraycopy_id:\n+  case StubId::stubgen_oop_disjoint_arraycopy_id:\n@@ -1861,1 +1861,1 @@\n-  case StubGenStubId::oop_disjoint_arraycopy_uninit_id:\n+  case StubId::stubgen_oop_disjoint_arraycopy_uninit_id:\n@@ -1977,1 +1977,1 @@\n-address StubGenerator::generate_conjoint_int_oop_copy(StubGenStubId stub_id, address nooverlap_target, address *entry) {\n+address StubGenerator::generate_conjoint_int_oop_copy(StubId stub_id, address nooverlap_target, address *entry) {\n@@ -1983,1 +1983,1 @@\n-  case StubGenStubId::jint_arraycopy_id:\n+  case StubId::stubgen_jint_arraycopy_id:\n@@ -1987,1 +1987,1 @@\n-  case StubGenStubId::oop_arraycopy_id:\n+  case StubId::stubgen_oop_arraycopy_id:\n@@ -1992,1 +1992,1 @@\n-  case StubGenStubId::oop_arraycopy_uninit_id:\n+  case StubId::stubgen_oop_arraycopy_uninit_id:\n@@ -2110,1 +2110,1 @@\n-address StubGenerator::generate_disjoint_long_oop_copy(StubGenStubId stub_id, address *entry) {\n+address StubGenerator::generate_disjoint_long_oop_copy(StubId stub_id, address *entry) {\n@@ -2116,1 +2116,1 @@\n-  case StubGenStubId::jlong_disjoint_arraycopy_id:\n+  case StubId::stubgen_jlong_disjoint_arraycopy_id:\n@@ -2120,1 +2120,1 @@\n-  case StubGenStubId::oop_disjoint_arraycopy_id:\n+  case StubId::stubgen_oop_disjoint_arraycopy_id:\n@@ -2125,1 +2125,1 @@\n-  case StubGenStubId::oop_disjoint_arraycopy_uninit_id:\n+  case StubId::stubgen_oop_disjoint_arraycopy_uninit_id:\n@@ -2243,1 +2243,1 @@\n-address StubGenerator::generate_conjoint_long_oop_copy(StubGenStubId stub_id, address nooverlap_target, address *entry) {\n+address StubGenerator::generate_conjoint_long_oop_copy(StubId stub_id, address nooverlap_target, address *entry) {\n@@ -2249,1 +2249,1 @@\n-  case StubGenStubId::jlong_arraycopy_id:\n+  case StubId::stubgen_jlong_arraycopy_id:\n@@ -2253,1 +2253,1 @@\n-  case StubGenStubId::oop_arraycopy_id:\n+  case StubId::stubgen_oop_arraycopy_id:\n@@ -2258,1 +2258,1 @@\n-  case StubGenStubId::oop_arraycopy_uninit_id:\n+  case StubId::stubgen_oop_arraycopy_uninit_id:\n@@ -2394,1 +2394,1 @@\n-address StubGenerator::generate_checkcast_copy(StubGenStubId stub_id, address *entry) {\n+address StubGenerator::generate_checkcast_copy(StubId stub_id, address *entry) {\n@@ -2398,1 +2398,1 @@\n-  case StubGenStubId::checkcast_arraycopy_id:\n+  case StubId::stubgen_checkcast_arraycopy_id:\n@@ -2401,1 +2401,1 @@\n-  case StubGenStubId::checkcast_arraycopy_uninit_id:\n+  case StubId::stubgen_checkcast_arraycopy_uninit_id:\n@@ -2626,1 +2626,1 @@\n-  StubGenStubId stub_id = StubGenStubId::unsafe_arraycopy_id;\n+  StubId stub_id = StubId::stubgen_unsafe_arraycopy_id;\n@@ -2762,1 +2762,1 @@\n-  StubGenStubId stub_id = StubGenStubId::unsafe_setmemory_id;\n+  StubId stub_id = StubId::stubgen_unsafe_setmemory_id;\n@@ -2932,1 +2932,1 @@\n-  StubGenStubId stub_id = StubGenStubId::generic_arraycopy_id;\n+  StubId stub_id = StubId::stubgen_generic_arraycopy_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":67,"deletions":67,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -0,0 +1,341 @@\n+\/*\n+ * Copyright (c) 2025, Intel Corporation. All rights reserved.\n+ * Intel Math Library (LIBM) Source Code\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"macroAssembler_x86.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+\n+\/******************************************************************************\/\n+\/\/                     ALGORITHM DESCRIPTION\n+\/\/                     ---------------------\n+\/\/\n+\/\/ x=2^{3*k+j} * 1.b1 b2 ... b5 b6 ... b52\n+\/\/ Let r=(x*2^{-3k-j} - 1.b1 b2 ... b5 1)* rcp[b1 b2 ..b5],\n+\/\/ where rcp[b1 b2 .. b5]=1\/(1.b1 b2 b3 b4 b5 1) in double precision\n+\/\/ cbrt(2^j * 1. b1 b2 .. b5 1) is approximated as T[j][b1..b5]+D[j][b1..b5]\n+\/\/ (T stores the high 53 bits, D stores the low order bits)\n+\/\/ Result=2^k*T+(2^k*T*r)*P+2^k*D\n+\/\/ where P=p1+p2*r+..+p8*r^7\n+\/\/\n+\/\/ Special cases:\n+\/\/  cbrt(NaN) = quiet NaN\n+\/\/  cbrt(+\/-INF) = +\/-INF\n+\/\/  cbrt(+\/-0) = +\/-0\n+\/\/\n+\/******************************************************************************\/\n+\n+\/* Represents 0x7FFFFFFFFFFFFFFF double precision in lower 64 bits*\/\n+ATTRIBUTE_ALIGNED(16) static const juint _ABS_MASK[] =\n+{\n+    4294967295, 2147483647, 0, 0\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _SIG_MASK[] =\n+{\n+    0, 1032192\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _EXP_MASK[] =\n+{\n+    0, 3220176896\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _EXP_MSK2[] =\n+{\n+    0, 3220193280\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _EXP_MSK3[] =\n+{\n+    4294967295, 1048575\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _SCALE63[] =\n+{\n+    0, 1138753536\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _ZERON[] =\n+{\n+    0, 2147483648\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _INF[] =\n+{\n+    0, 2146435072\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _NEG_INF[] =\n+{\n+    0, 4293918720\n+};\n+\n+ATTRIBUTE_ALIGNED(16) static const juint _coeff_table[] =\n+{\n+    1553778919, 3213899486, 3534952507, 3215266280, 1646371399,\n+    3214412045, 477218588,  3216798151, 3582521621, 1066628362,\n+    1007461464, 1068473053, 889629714,  1067378449, 1431655765,\n+    1070945621\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _rcp_table[] =\n+{\n+    528611360,  3220144632, 2884679527, 3220082993, 1991868891, 3220024928,\n+    2298714891, 3219970134, 58835168,   3219918343, 3035110223, 3219869313,\n+    1617585086, 3219822831, 2500867033, 3219778702, 4241943008, 3219736752,\n+    258732970,  3219696825, 404232216,  3219658776, 2172167368, 3219622476,\n+    1544257904, 3219587808, 377579543,  3219554664, 1616385542, 3219522945,\n+    813783277,  3219492562, 3940743189, 3219463431, 2689777499, 3219435478,\n+    1700977147, 3219408632, 3169102082, 3219382828, 327235604,  3219358008,\n+    1244336319, 3219334115, 1300311200, 3219311099, 3095471925, 3219288912,\n+    2166487928, 3219267511, 2913108253, 3219246854, 293672978,  3219226904,\n+    288737297,  3219207624, 1810275472, 3219188981, 174592167,  3219170945,\n+    3539053052, 3219153485, 2164392968, 3219136576\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _cbrt_table[] =\n+{\n+    572345495,  1072698681, 1998204467, 1072709382, 3861501553, 1072719872,\n+    2268192434, 1072730162, 2981979308, 1072740260, 270859143,  1072750176,\n+    2958651392, 1072759916, 313113243,  1072769490, 919449400,  1072778903,\n+    2809328903, 1072788162, 2222981587, 1072797274, 2352530781, 1072806244,\n+    594152517,  1072815078, 1555767199, 1072823780, 4282421314, 1072832355,\n+    2355578597, 1072840809, 1162590619, 1072849145, 797864051,  1072857367,\n+    431273680,  1072865479, 2669831148, 1072873484, 733477752,  1072881387,\n+    4280220604, 1072889189, 801961634,  1072896896, 2915370760, 1072904508,\n+    1159613482, 1072912030, 2689944798, 1072919463, 1248687822, 1072926811,\n+    2967951030, 1072934075, 630170432,  1072941259, 3760898254, 1072948363,\n+    0,          1072955392, 2370273294, 1072962345, 1261754802, 1072972640,\n+    546334065,  1072986123, 1054893830, 1072999340, 1571187597, 1073012304,\n+    1107975175, 1073025027, 3606909377, 1073037519, 1113616747, 1073049792,\n+    4154744632, 1073061853, 3358931423, 1073073713, 4060702372, 1073085379,\n+    747576176,  1073096860, 3023138255, 1073108161, 1419988548, 1073119291,\n+    1914185305, 1073130255, 294389948,  1073141060, 3761802570, 1073151710,\n+    978281566,  1073162213, 823148820,  1073172572, 2420954441, 1073182792,\n+    3815449908, 1073192878, 2046058587, 1073202835, 1807524753, 1073212666,\n+    2628681401, 1073222375, 3225667357, 1073231966, 1555307421, 1073241443,\n+    3454043099, 1073250808, 1208137896, 1073260066, 3659916772, 1073269218,\n+    1886261264, 1073278269, 3593647839, 1073287220, 3086012205, 1073296075,\n+    2769796922, 1073304836, 888716057,  1073317807, 2201465623, 1073334794,\n+    164369365,  1073351447, 3462666733, 1073367780, 2773905457, 1073383810,\n+    1342879088, 1073399550, 2543933975, 1073415012, 1684477781, 1073430209,\n+    3532178543, 1073445151, 1147747300, 1073459850, 1928031793, 1073474314,\n+    2079717015, 1073488553, 4016765315, 1073502575, 3670431139, 1073516389,\n+    3549227225, 1073530002, 11637607,   1073543422, 588220169,  1073556654,\n+    2635407503, 1073569705, 2042029317, 1073582582, 1925128962, 1073595290,\n+    4136375664, 1073607834, 759964600,  1073620221, 4257606771, 1073632453,\n+    297278907,  1073644538, 3655053093, 1073656477, 2442253172, 1073668277,\n+    1111876799, 1073679941, 3330973139, 1073691472, 3438879452, 1073702875,\n+    3671565478, 1073714153, 1317849547, 1073725310, 1642364115, 1073736348\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _D_table[] =\n+{\n+    4050900474, 1014427190, 1157977860, 1016444461, 1374568199, 1017271387,\n+    2809163288, 1016882676, 3742377377, 1013168191, 3101606597, 1017541672,\n+    65224358,   1017217597, 2691591250, 1017266643, 4020758549, 1017689313,\n+    1316310992, 1018030788, 1031537856, 1014090882, 3261395239, 1016413641,\n+    886424999,  1016313335, 3114776834, 1014195875, 1681120620, 1017825416,\n+    1329600273, 1016625740, 465474623,  1017097119, 4251633980, 1017169077,\n+    1986990133, 1017710645, 752958613,  1017159641, 2216216792, 1018020163,\n+    4282860129, 1015924861, 1557627859, 1016039538, 3889219754, 1018086237,\n+    3684996408, 1017353275, 723532103,  1017717141, 2951149676, 1012528470,\n+    831890937,  1017830553, 1031212645, 1017387331, 2741737450, 1017604974,\n+    2863311531, 1003776682, 4276736099, 1013153088, 4111778382, 1015673686,\n+    1728065769, 1016413986, 2708718031, 1018078833, 1069335005, 1015291224,\n+    700037144,  1016482032, 2904566452, 1017226861, 4074156649, 1017622651,\n+    25019565,   1015245366, 3601952608, 1015771755, 3267129373, 1017904664,\n+    503203103,  1014921629, 2122011730, 1018027866, 3927295461, 1014189456,\n+    2790625147, 1016024251, 1330460186, 1016940346, 4033568463, 1015538390,\n+    3695818227, 1017509621, 257573361,  1017208868, 3227697852, 1017337964,\n+    234118548,  1017169577, 4009025803, 1017278524, 1948343394, 1017749310,\n+    678398162,  1018144239, 3083864863, 1016669086, 2415453452, 1017890370,\n+    175467344,  1017330033, 3197359580, 1010339928, 2071276951, 1015941358,\n+    268372543,  1016737773, 938132959,  1017389108, 1816750559, 1017337448,\n+    4119203749, 1017152174, 2578653878, 1013108497, 2470331096, 1014678606,\n+    123855735,  1016553320, 1265650889, 1014782687, 3414398172, 1017182638,\n+    1040773369, 1016158401, 3483628886, 1016886550, 4140499405, 1016191425,\n+    3893477850, 1016964495, 3935319771, 1009634717, 2978982660, 1015027112,\n+    2452709923, 1017990229, 3190365712, 1015835149, 4237588139, 1015832925,\n+    2610678389, 1017962711, 2127316774, 1017405770, 824267502,  1017959463,\n+    2165924042, 1017912225, 2774007076, 1013257418, 4123916326, 1017582284,\n+    1976417958, 1016959909, 4092806412, 1017711279, 119251817,  1015363631,\n+    3475418768, 1017675415, 1972580503, 1015470684, 815541017,  1017517969,\n+    2429917451, 1017397776, 4062888482, 1016749897, 68284153,   1017925678,\n+    2207779246, 1016320298, 1183466520, 1017408657, 143326427,  1017060403\n+};\n+\n+#define __ _masm->\n+\n+address StubGenerator::generate_libmCbrt() {\n+  StubId stub_id = StubId::stubgen_dcbrt_id;\n+  StubCodeMark mark(this, stub_id);\n+  address start = __ pc();\n+\n+  Label L_2TAG_PACKET_0_0_1, L_2TAG_PACKET_1_0_1, L_2TAG_PACKET_2_0_1;\n+  Label B1_1, B1_2, B1_4;\n+\n+  address ABS_MASK        = (address)_ABS_MASK;\n+  address SIG_MASK        = (address)_SIG_MASK;\n+  address EXP_MASK        = (address)_EXP_MASK;\n+  address EXP_MSK2        = (address)_EXP_MSK2;\n+  address EXP_MSK3        = (address)_EXP_MSK3;\n+  address SCALE63         = (address)_SCALE63;\n+  address ZERON           = (address)_ZERON;\n+  address INF             = (address)_INF;\n+  address NEG_INF         = (address)_NEG_INF;\n+  address coeff_table     = (address)_coeff_table;\n+  address rcp_table       = (address)_rcp_table;\n+  address cbrt_table      = (address)_cbrt_table;\n+  address D_table         = (address)_D_table;\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  __ bind(B1_1);\n+  __ ucomisd(xmm0, ExternalAddress(ZERON), r11 \/*rscratch*\/);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_1_0_1); \/\/ Branch only if x is +\/- zero or NaN\n+  __ movq(xmm1, xmm0);\n+  __ andpd(xmm1, ExternalAddress(ABS_MASK), r11 \/*rscratch*\/);\n+  __ ucomisd(xmm1, ExternalAddress(INF), r11 \/*rscratch*\/);\n+  __ jcc(Assembler::equal, B1_4); \/\/ Branch only if x is +\/- INF\n+\n+  __ bind(B1_2);\n+  __ movq(xmm7, xmm0);\n+  __ movl(rdx, 524032);\n+  __ movsd(xmm5, ExternalAddress(EXP_MSK3), r11 \/*rscratch*\/);\n+  __ movsd(xmm3, ExternalAddress(EXP_MSK2), r11 \/*rscratch*\/);\n+  __ psrlq(xmm7, 44);\n+  __ pextrw(rcx, xmm7, 0);\n+  __ movdl(rax, xmm7);\n+  __ movsd(xmm1, ExternalAddress(EXP_MASK), r11 \/*rscratch*\/);\n+  __ movsd(xmm2, ExternalAddress(SIG_MASK), r11 \/*rscratch*\/);\n+  __ andl(rcx, 248);\n+  __ lea(r8, ExternalAddress(rcp_table));\n+  __ movsd(xmm4, Address(rcx, r8, Address::times_1));\n+  __ movq(r9, rax);\n+  __ andl(rdx, rax);\n+  __ cmpl(rdx, 0);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_0_0_1); \/\/ Branch only if |x| is denormalized\n+  __ shrl(rdx, 8);\n+  __ shrq(r9, 8);\n+  __ andpd(xmm2, xmm0);\n+  __ andpd(xmm0, xmm5);\n+  __ orpd(xmm3, xmm2);\n+  __ orpd(xmm1, xmm0);\n+  __ movapd(xmm5, ExternalAddress(coeff_table), r11 \/*rscratch*\/);\n+  __ movl(rax, 5462);\n+  __ movapd(xmm6, ExternalAddress(coeff_table + 16), r11 \/*rscratch*\/);\n+  __ mull(rdx);\n+  __ movq(rdx, r9);\n+  __ andq(r9, 2047);\n+  __ shrl(rax, 14);\n+  __ andl(rdx, 2048);\n+  __ subq(r9, rax);\n+  __ subq(r9, rax);\n+  __ subq(r9, rax);\n+  __ shlq(r9, 8);\n+  __ addl(rax, 682);\n+  __ orl(rax, rdx);\n+  __ movdl(xmm7, rax);\n+  __ addq(rcx, r9);\n+  __ psllq(xmm7, 52);\n+\n+  __ bind(L_2TAG_PACKET_2_0_1);\n+  __ movapd(xmm2, ExternalAddress(coeff_table + 32), r11 \/*rscratch*\/);\n+  __ movapd(xmm0, ExternalAddress(coeff_table + 48), r11 \/*rscratch*\/);\n+  __ subsd(xmm1, xmm3);\n+  __ movq(xmm3, xmm7);\n+  __ lea(r8, ExternalAddress(cbrt_table));\n+  __ mulsd(xmm7, Address(rcx, r8, Address::times_1));\n+  __ mulsd(xmm1, xmm4);\n+  __ lea(r8, ExternalAddress(D_table));\n+  __ mulsd(xmm3, Address(rcx, r8, Address::times_1));\n+  __ movapd(xmm4, xmm1);\n+  __ unpcklpd(xmm1, xmm1);\n+  __ mulpd(xmm5, xmm1);\n+  __ mulpd(xmm6, xmm1);\n+  __ mulpd(xmm1, xmm1);\n+  __ addpd(xmm2, xmm5);\n+  __ addpd(xmm0, xmm6);\n+  __ mulpd(xmm2, xmm1);\n+  __ mulpd(xmm1, xmm1);\n+  __ mulsd(xmm4, xmm7);\n+  __ addpd(xmm0, xmm2);\n+  __ mulsd(xmm1, xmm0);\n+  __ unpckhpd(xmm0, xmm0);\n+  __ addsd(xmm0, xmm1);\n+  __ mulsd(xmm0, xmm4);\n+  __ addsd(xmm0, xmm3);\n+  __ addsd(xmm0, xmm7);\n+  __ jmp(B1_4);\n+\n+  __ bind(L_2TAG_PACKET_0_0_1);\n+  __ mulsd(xmm0, ExternalAddress(SCALE63), r11 \/*rscratch*\/);\n+  __ movq(xmm7, xmm0);\n+  __ movl(rdx, 524032);\n+  __ psrlq(xmm7, 44);\n+  __ pextrw(rcx, xmm7, 0);\n+  __ movdl(rax, xmm7);\n+  __ andl(rcx, 248);\n+  __ lea(r8, ExternalAddress(rcp_table));\n+  __ movsd(xmm4, Address(rcx, r8, Address::times_1));\n+  __ movq(r9, rax);\n+  __ andl(rdx, rax);\n+  __ shrl(rdx, 8);\n+  __ shrq(r9, 8);\n+  __ andpd(xmm2, xmm0);\n+  __ andpd(xmm0, xmm5);\n+  __ orpd(xmm3, xmm2);\n+  __ orpd(xmm1, xmm0);\n+  __ movapd(xmm5, ExternalAddress(coeff_table), r11 \/*rscratch*\/);\n+  __ movl(rax, 5462);\n+  __ movapd(xmm6, ExternalAddress(coeff_table + 16), r11 \/*rscratch*\/);\n+  __ mull(rdx);\n+  __ movq(rdx, r9);\n+  __ andq(r9, 2047);\n+  __ shrl(rax, 14);\n+  __ andl(rdx, 2048);\n+  __ subq(r9, rax);\n+  __ subq(r9, rax);\n+  __ subq(r9, rax);\n+  __ shlq(r9, 8);\n+  __ addl(rax, 661);\n+  __ orl(rax, rdx);\n+  __ movdl(xmm7, rax);\n+  __ addq(rcx, r9);\n+  __ psllq(xmm7, 52);\n+  __ jmp(L_2TAG_PACKET_2_0_1);\n+\n+  __ bind(L_2TAG_PACKET_1_0_1);\n+  __ addsd(xmm0, xmm0);\n+\n+  __ bind(B1_4);\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_cbrt.cpp","additions":341,"deletions":0,"binary":false,"changes":341,"status":"added"},{"patch":"@@ -115,1 +115,1 @@\n-  StubGenStubId stub_id = StubGenStubId::chacha20Block_id;\n+  StubId stub_id = StubId::stubgen_chacha20Block_id;\n@@ -304,1 +304,1 @@\n-  StubGenStubId stub_id = StubGenStubId::chacha20Block_id;\n+  StubId stub_id = StubId::stubgen_chacha20Block_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_chacha.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2016, 2024, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2016, 2025, Intel Corporation. All rights reserved.\n@@ -176,1 +176,1 @@\n-  StubGenStubId stub_id = StubGenStubId::dcos_id;\n+  StubId stub_id = StubId::stubgen_dcos_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_cos.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -277,1 +277,1 @@\n-  StubGenStubId stub_id = dilithiumAlmostNtt_id;\n+  StubId stub_id = StubId::stubgen_dilithiumAlmostNtt_id;\n@@ -467,1 +467,1 @@\n-  StubGenStubId stub_id = dilithiumAlmostInverseNtt_id;\n+  StubId stub_id = StubId::stubgen_dilithiumAlmostInverseNtt_id;\n@@ -648,1 +648,1 @@\n-  StubGenStubId stub_id = dilithiumNttMult_id;\n+  StubId stub_id = StubId::stubgen_dilithiumNttMult_id;\n@@ -712,1 +712,1 @@\n-  StubGenStubId stub_id = dilithiumMontMulByConstant_id;\n+  StubId stub_id = StubId::stubgen_dilithiumMontMulByConstant_id;\n@@ -776,1 +776,1 @@\n-  StubGenStubId stub_id = dilithiumDecomposePoly_id;\n+  StubId stub_id = StubId::stubgen_dilithiumDecomposePoly_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_dilithium.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2024, Intel Corporation. All rights reserved.\n+* Copyright (c) 2016, 2025, Intel Corporation. All rights reserved.\n@@ -168,1 +168,1 @@\n-  StubGenStubId stub_id = StubGenStubId::dexp_id;\n+  StubId stub_id = StubId::stubgen_dexp_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_exp.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2023, 2025, Intel Corporation. All rights reserved.\n@@ -76,1 +76,1 @@\n-  StubGenStubId stub_id = StubGenStubId::fmod_id;\n+  StubId stub_id = StubId::stubgen_fmod_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_fmod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2019, 2024, Intel Corporation. All rights reserved.\n+* Copyright (c) 2019, 2025, Intel Corporation. All rights reserved.\n@@ -85,1 +85,1 @@\n-  StubGenStubId stub_id = StubGenStubId::ghash_processBlocks_id;\n+  StubId stub_id = StubId::stubgen_ghash_processBlocks_id;\n@@ -222,1 +222,1 @@\n-  StubGenStubId stub_id = StubGenStubId::ghash_processBlocks_id;\n+  StubId stub_id = StubId::stubgen_ghash_processBlocks_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_ghash.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,952 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"asm\/assembler.hpp\"\n+#include \"asm\/assembler.inline.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+\n+#define __ _masm->\n+\n+#define xmm(i) as_XMMRegister(i)\n+\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif \/\/ PRODUCT\n+\n+#define BIND(label) bind(label); BLOCK_COMMENT(#label \":\")\n+\n+\/\/ Constants\n+\/\/\n+ATTRIBUTE_ALIGNED(64) static const uint16_t kyberAvx512Consts[] = {\n+    0xF301, 0xF301, 0xF301, 0xF301, \/\/ q^-1 mod montR\n+    0x0D01, 0x0D01, 0x0D01, 0x0D01, \/\/ q\n+    0x4EBF, 0x4EBF, 0x4EBF, 0x4EBF, \/\/ Barrett multiplier\n+    0x0200, 0x0200, 0x0200, 0x0200, \/\/(dim\/2)^-1 mod q\n+    0x0549, 0x0549, 0x0549, 0x0549, \/\/ montR^2 mod q\n+    0x0F00, 0x0F00, 0x0F00, 0x0F00  \/\/ mask for kyber12to16\n+  };\n+\n+static int qInvModROffset = 0;\n+static int qOffset = 8;\n+static int barretMultiplierOffset = 16;\n+static int dimHalfInverseOffset = 24;\n+static int montRSquareModqOffset = 32;\n+static int f00Offset = 40;\n+\n+static address kyberAvx512ConstsAddr(int offset) {\n+  return ((address) kyberAvx512Consts) + offset;\n+}\n+\n+const Register scratch = r10;\n+\n+ATTRIBUTE_ALIGNED(64) static const uint16_t kyberAvx512NttPerms[] = {\n+\/\/ 0\n+    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,\n+    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n+    0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,\n+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n+    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n+    0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,\n+\/\/ 128\n+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n+    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n+    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n+    0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,\n+    0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,\n+    0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,\n+\/\/ 256\n+    0x00, 0x01, 0x02, 0x03, 0x20, 0x21, 0x22, 0x23,\n+    0x08, 0x09, 0x0A, 0x0B, 0x28, 0x29, 0x2A, 0x2B,\n+    0x10, 0x11, 0x12, 0x13, 0x30, 0x31, 0x32, 0x33,\n+    0x18, 0x19, 0x1A, 0x1B, 0x38, 0x39, 0x3A, 0x3B,\n+    0x04, 0x05, 0x06, 0x07, 0x24, 0x25, 0x26, 0x27,\n+    0x0C, 0x0D, 0x0E, 0x0F, 0x2C, 0x2D, 0x2E, 0x2F,\n+    0x14, 0x15, 0x16, 0x17, 0x34, 0x35, 0x36, 0x37,\n+    0x1C, 0x1D, 0x1E, 0x1F, 0x3C, 0x3D, 0x3E, 0x3F,\n+\/\/ 384\n+    0x00, 0x01, 0x20, 0x21, 0x04, 0x05, 0x24, 0x25,\n+    0x08, 0x09, 0x28, 0x29, 0x0C, 0x0D, 0x2C, 0x2D,\n+    0x10, 0x11, 0x30, 0x31, 0x14, 0x15, 0x34, 0x35,\n+    0x18, 0x19, 0x38, 0x39, 0x1C, 0x1D, 0x3C, 0x3D,\n+    0x02, 0x03, 0x22, 0x23, 0x06, 0x07, 0x26, 0x27,\n+    0x0A, 0x0B, 0x2A, 0x2B, 0x0E, 0x0F, 0x2E, 0x2F,\n+    0x12, 0x13, 0x32, 0x33, 0x16, 0x17, 0x36, 0x37,\n+    0x1A, 0x1B, 0x3A, 0x3B, 0x1E, 0x1F, 0x3E, 0x3F,\n+\/\/ 512\n+    0x10, 0x11, 0x30, 0x31, 0x12, 0x13, 0x32, 0x33,\n+    0x14, 0x15, 0x34, 0x35, 0x16, 0x17, 0x36, 0x37,\n+    0x18, 0x19, 0x38, 0x39, 0x1A, 0x1B, 0x3A, 0x3B,\n+    0x1C, 0x1D, 0x3C, 0x3D, 0x1E, 0x1F, 0x3E, 0x3F,\n+    0x00, 0x01, 0x20, 0x21, 0x02, 0x03, 0x22, 0x23,\n+    0x04, 0x05, 0x24, 0x25, 0x06, 0x07, 0x26, 0x27,\n+    0x08, 0x09, 0x28, 0x29, 0x0A, 0x0B, 0x2A, 0x2B,\n+    0x0C, 0x0D, 0x2C, 0x2D, 0x0E, 0x0F, 0x2E, 0x2F\n+  };\n+\n+static address kyberAvx512NttPermsAddr() {\n+  return (address) kyberAvx512NttPerms;\n+}\n+\n+ATTRIBUTE_ALIGNED(64) static const uint16_t kyberAvx512InverseNttPerms[] = {\n+\/\/ 0\n+    0x02, 0x03, 0x06, 0x07, 0x0A, 0x0B, 0x0E, 0x0F,\n+    0x12, 0x13, 0x16, 0x17, 0x1A, 0x1B, 0x1E, 0x1F,\n+    0x22, 0x23, 0x26, 0x27, 0x2A, 0x2B, 0x2E, 0x2F,\n+    0x32, 0x33, 0x36, 0x37, 0x3A, 0x3B, 0x3E, 0x3F,\n+    0x00, 0x01, 0x04, 0x05, 0x08, 0x09, 0x0C, 0x0D,\n+    0x10, 0x11, 0x14, 0x15, 0x18, 0x19, 0x1C, 0x1D,\n+    0x20, 0x21, 0x24, 0x25, 0x28, 0x29, 0x2C, 0x2D,\n+    0x30, 0x31, 0x34, 0x35, 0x38, 0x39, 0x3C, 0x3D,\n+\/\/ 128\n+    0x00, 0x01, 0x20, 0x21, 0x04, 0x05, 0x24, 0x25,\n+    0x08, 0x09, 0x28, 0x29, 0x0C, 0x0D, 0x2C, 0x2D,\n+    0x10, 0x11, 0x30, 0x31, 0x14, 0x15, 0x34, 0x35,\n+    0x18, 0x19, 0x38, 0x39, 0x1C, 0x1D, 0x3C, 0x3D,\n+    0x02, 0x03, 0x22, 0x23, 0x06, 0x07, 0x26, 0x27,\n+    0x0A, 0x0B, 0x2A, 0x2B, 0x0E, 0x0F, 0x2E, 0x2F,\n+    0x12, 0x13, 0x32, 0x33, 0x16, 0x17, 0x36, 0x37,\n+    0x1A, 0x1B, 0x3A, 0x3B, 0x1E, 0x1F, 0x3E, 0x3F,\n+\/\/ 256\n+    0x00, 0x01, 0x02, 0x03, 0x20, 0x21, 0x22, 0x23,\n+    0x08, 0x09, 0x0A, 0x0B, 0x28, 0x29, 0x2A, 0x2B,\n+    0x10, 0x11, 0x12, 0x13, 0x30, 0x31, 0x32, 0x33,\n+    0x18, 0x19, 0x1A, 0x1B, 0x38, 0x39, 0x3A, 0x3B,\n+    0x04, 0x05, 0x06, 0x07, 0x24, 0x25, 0x26, 0x27,\n+    0x0C, 0x0D, 0x0E, 0x0F, 0x2C, 0x2D, 0x2E, 0x2F,\n+    0x14, 0x15, 0x16, 0x17, 0x34, 0x35, 0x36, 0x37,\n+    0x1C, 0x1D, 0x1E, 0x1F, 0x3C, 0x3D, 0x3E, 0x3F,\n+\/\/ 384\n+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n+    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n+    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n+    0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,\n+    0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,\n+    0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,\n+\/\/ 512\n+    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,\n+    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n+    0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,\n+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n+    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n+    0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F\n+  };\n+\n+static address kyberAvx512InverseNttPermsAddr() {\n+  return (address) kyberAvx512InverseNttPerms;\n+}\n+\n+ATTRIBUTE_ALIGNED(64) static const uint16_t kyberAvx512_nttMultPerms[] = {\n+    0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0E,\n+    0x10, 0x12, 0x14, 0x16, 0x18, 0x1A, 0x1C, 0x1E,\n+    0x20, 0x22, 0x24, 0x26, 0x28, 0x2A, 0x2C, 0x2E,\n+    0x30, 0x32, 0x34, 0x36, 0x38, 0x3A, 0x3C, 0x3E,\n+\n+    0x01, 0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F,\n+    0x11, 0x13, 0x15, 0x17, 0x19, 0x1B, 0x1D, 0x1F,\n+    0x21, 0x23, 0x25, 0x27, 0x29, 0x2B, 0x2D, 0x2F,\n+    0x31, 0x33, 0x35, 0x37, 0x39, 0x3B, 0x3D, 0x3F,\n+\n+    0x00, 0x20, 0x01, 0x21, 0x02, 0x22, 0x03, 0x23,\n+    0x04, 0x24, 0x05, 0x25, 0x06, 0x26, 0x07, 0x27,\n+    0x08, 0x28, 0x09, 0x29, 0x0A, 0x2A, 0x0B, 0x2B,\n+    0x0C, 0x2C, 0x0D, 0x2D, 0x0E, 0x2E, 0x0F, 0x2F,\n+\n+    0x10, 0x30, 0x11, 0x31, 0x12, 0x32, 0x13, 0x33,\n+    0x14, 0x34, 0x15, 0x35, 0x16, 0x36, 0x17, 0x37,\n+    0x18, 0x38, 0x19, 0x39, 0x1A, 0x3A, 0x1B, 0x3B,\n+    0x1C, 0x3C, 0x1D, 0x3D, 0x1E, 0x3E, 0x1F, 0x3F\n+  };\n+\n+static address kyberAvx512_nttMultPermsAddr() {\n+  return (address) kyberAvx512_nttMultPerms;\n+}\n+\n+  ATTRIBUTE_ALIGNED(64) static const uint16_t kyberAvx512_12To16Perms[] = {\n+\/\/ 0\n+    0x00, 0x03, 0x06, 0x09, 0x0C, 0x0F, 0x12, 0x15,\n+    0x18, 0x1B, 0x1E, 0x21, 0x24, 0x27, 0x2A, 0x2D,\n+    0x30, 0x33, 0x36, 0x39, 0x3C, 0x3F, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x01, 0x04, 0x07, 0x0A, 0x0D, 0x10, 0x13, 0x16,\n+    0x19, 0x1C, 0x1F, 0x22, 0x25, 0x28, 0x2B, 0x2E,\n+    0x31, 0x34, 0x37, 0x3A, 0x3D, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\/\/ 128\n+    0x02, 0x05, 0x08, 0x0B, 0x0E, 0x11, 0x14, 0x17,\n+    0x1A, 0x1D, 0x20, 0x23, 0x26, 0x29, 0x2C, 0x2F,\n+    0x32, 0x35, 0x38, 0x3B, 0x3E, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n+    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x22, 0x25,\n+    0x28, 0x2B, 0x2E, 0x31, 0x34, 0x37, 0x3A, 0x3D,\n+\/\/ 256\n+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n+    0x10, 0x11, 0x12, 0x13, 0x14, 0x20, 0x23, 0x26,\n+    0x29, 0x2C, 0x2F, 0x32, 0x35, 0x38, 0x3B, 0x3E,\n+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n+    0x10, 0x11, 0x12, 0x13, 0x14, 0x21, 0x24, 0x27,\n+    0x2A, 0x2D, 0x30, 0x33, 0x36, 0x39, 0x3C, 0x3F,\n+\/\/ 384\n+    0x00, 0x20, 0x01, 0x21, 0x02, 0x22, 0x03, 0x23,\n+    0x04, 0x24, 0x05, 0x25, 0x06, 0x26, 0x07, 0x27,\n+    0x08, 0x28, 0x09, 0x29, 0x0A, 0x2A, 0x0B, 0x2B,\n+    0x0C, 0x2C, 0x0D, 0x2D, 0x0E, 0x2E, 0x0F, 0x2F,\n+    0x10, 0x30, 0x11, 0x31, 0x12, 0x32, 0x13, 0x33,\n+    0x14, 0x34, 0x15, 0x35, 0x16, 0x36, 0x17, 0x37,\n+    0x18, 0x38, 0x19, 0x39, 0x1A, 0x3A, 0x1B, 0x3B,\n+    0x1C, 0x3C, 0x1D, 0x3D, 0x1E, 0x3E, 0x1F, 0x3F\n+  };\n+\n+static address kyberAvx512_12To16PermsAddr() {\n+  return (address) kyberAvx512_12To16Perms;\n+}\n+\n+static void load4regs(int destRegs[], Register address, int offset,\n+                      MacroAssembler *_masm) {\n+  for (int i = 0; i < 4; i++) {\n+    __ evmovdquw(xmm(destRegs[i]), Address(address, offset + i * 64),\n+                 Assembler::AVX_512bit);\n+  }\n+}\n+\n+\/\/ For z = montmul(a,b), z will be  between -q and q and congruent\n+\/\/ to a * b * R^-1 mod q, where R > 2 * q, R is a power of 2,\n+\/\/ -R\/2 * q <= a * b < R\/2 * q.\n+\/\/ (See e.g. Algorithm 3 in https:\/\/eprint.iacr.org\/2018\/039.pdf)\n+\/\/ For the Java code, we use R = 2^20 and for the intrinsic, R = 2^16.\n+\/\/ In our computations, b is always c * R mod q, so the montmul() really\n+\/\/ computes a * c mod q. In the Java code, we use 32-bit numbers for the\n+\/\/ computations, and we use R = 2^20 because that way the a * b numbers\n+\/\/ that occur during all computations stay in the required range.\n+\/\/ For the intrinsics, we use R = 2^16, because this way we can do twice\n+\/\/ as much work in parallel, the only drawback is that we should do some Barrett\n+\/\/ reductions in kyberInverseNtt so that the numbers stay in the required range.\n+static void montmul(int outputRegs[], int inputRegs1[], int inputRegs2[],\n+             int scratchRegs1[], int scratchRegs2[], MacroAssembler *_masm) {\n+   for (int i = 0; i < 4; i++) {\n+     __ evpmullw(xmm(scratchRegs1[i]), k0, xmm(inputRegs1[i]),\n+                 xmm(inputRegs2[i]), false, Assembler::AVX_512bit);\n+   }\n+   for (int i = 0; i < 4; i++) {\n+     __ evpmulhw(xmm(scratchRegs2[i]), k0, xmm(inputRegs1[i]),\n+                 xmm(inputRegs2[i]), false, Assembler::AVX_512bit);\n+   }\n+   for (int i = 0; i < 4; i++) {\n+     __ evpmullw(xmm(scratchRegs1[i]), k0, xmm(scratchRegs1[i]),\n+                 xmm31, false, Assembler::AVX_512bit);\n+   }\n+   for (int i = 0; i < 4; i++) {\n+     __ evpmulhw(xmm(scratchRegs1[i]), k0, xmm(scratchRegs1[i]),\n+                 xmm30, false, Assembler::AVX_512bit);\n+   }\n+   for (int i = 0; i < 4; i++) {\n+     __ evpsubw(xmm(outputRegs[i]), k0, xmm(scratchRegs2[i]),\n+                xmm(scratchRegs1[i]), false, Assembler::AVX_512bit);\n+   }\n+}\n+\n+static void sub_add(int subResult[], int addResult[], int input1[], int input2[],\n+                    MacroAssembler *_masm) {\n+  for (int i = 0; i < 4; i++) {\n+    __ evpsubw(xmm(subResult[i]), k0, xmm(input1[i]), xmm(input2[i]),\n+               false, Assembler::AVX_512bit);\n+    __ evpaddw(xmm(addResult[i]), k0, xmm(input1[i]), xmm(input2[i]),\n+               false, Assembler::AVX_512bit);\n+  }\n+}\n+\n+\/\/ result2 also acts as input1\n+\/\/ result1 also acts as perm1\n+static void permute(int result1[], int result2[], int input2[], int perm2,\n+                    MacroAssembler *_masm) {\n+\n+  for (int i = 1; i < 4; i++) {\n+    __ evmovdquw(xmm(result1[i]), xmm(result1[0]), Assembler::AVX_512bit);\n+  }\n+\n+  for (int i = 0; i < 4; i++) {\n+    __ evpermi2w(xmm(result1[i]), xmm(result2[i]), xmm(input2[i]),\n+                 Assembler::AVX_512bit);\n+    __ evpermt2w(xmm(result2[i]), xmm(perm2), xmm(input2[i]),\n+                 Assembler::AVX_512bit);\n+  }\n+}\n+\n+static void store4regs(Register address, int offset, int sourceRegs[],\n+                       MacroAssembler *_masm) {\n+  for (int i = 0; i < 4; i++) {\n+    __ evmovdquw(Address(address, offset + i * 64), xmm(sourceRegs[i]),\n+                 Assembler::AVX_512bit);\n+  }\n+}\n+\n+\/\/ In all 3 invocations of this function we use the same registers:\n+\/\/ xmm0-xmm7 for the input and the result,\n+\/\/ xmm8-xmm15 as scratch registers and\n+\/\/ xmm16-xmm17 for the constants,\n+\/\/ so we don't pass register arguments.\n+static void barrettReduce(MacroAssembler *_masm) {\n+  for (int i = 0; i < 8; i++) {\n+    __ evpmulhw(xmm(i + 8), k0, xmm(i), xmm16, false, Assembler::AVX_512bit);\n+  }\n+\n+  for (int i = 0; i < 8; i++) {\n+    __ evpsraw(xmm(i + 8), k0, xmm(i + 8), 10, false, Assembler::AVX_512bit);\n+  }\n+\n+  for (int i = 0; i < 8; i++) {\n+    __ evpmullw(xmm(i + 8), k0, xmm(i + 8), xmm17, false, Assembler::AVX_512bit);\n+  }\n+\n+  for (int i = 0; i < 8; i++) {\n+    __ evpsubw(xmm(i), k0, xmm(i), xmm(i + 8), false, Assembler::AVX_512bit);\n+  }\n+}\n+\n+static int xmm0_3[] = {0, 1, 2, 3};\n+static int xmm0145[] = {0, 1, 4, 5};\n+static int xmm0246[] = {0, 2, 4, 6};\n+static int xmm0829[] = {0, 8, 2, 9};\n+static int xmm1001[] = {1, 0, 0, 1};\n+static int xmm1357[] = {1, 3, 5, 7};\n+static int xmm2367[] = {2, 3, 6, 7};\n+static int xmm2_0_10_8[] = {2, 0, 10, 8};\n+static int xmm3223[] = {3, 2, 2, 3};\n+static int xmm4_7[] = {4, 5, 6, 7};\n+static int xmm5454[] = {5, 4, 5, 4};\n+static int xmm7676[] = {7, 6, 7, 6};\n+static int xmm8_11[] = {8, 9, 10, 11};\n+static int xmm12_15[] = {12, 13, 14, 15};\n+static int xmm16_19[] = {16, 17, 18, 19};\n+static int xmm20_23[] = {20, 21, 22, 23};\n+static int xmm23_23[] = {23, 23, 23, 23};\n+static int xmm24_27[] = {24, 25, 26, 27};\n+static int xmm26_29[] = {26, 27, 28, 29};\n+static int xmm28_31[] = {28, 29, 30, 31};\n+static int xmm29_29[] = {29, 29, 29, 29};\n+\n+\/\/ Kyber NTT function.\n+\/\/\n+\/\/ coeffs (short[256]) = c_rarg0\n+\/\/ ntt_zetas (short[256]) = c_rarg1\n+address generate_kyberNtt_avx512(StubGenerator *stubgen,\n+                                 MacroAssembler *_masm) {\n+  __ align(CodeEntryAlignment);\n+  StubId stub_id = StubId::stubgen_kyberNtt_id;\n+  StubCodeMark mark(stubgen, stub_id);\n+  address start = __ pc();\n+  __ enter();\n+\n+  const Register coeffs = c_rarg0;\n+  const Register zetas = c_rarg1;\n+\n+  const Register perms = r11;\n+\n+  __ lea(perms, ExternalAddress(kyberAvx512NttPermsAddr()));\n+\n+  load4regs(xmm4_7, coeffs, 256, _masm);\n+  load4regs(xmm20_23, zetas, 0, _masm);\n+\n+  __ vpbroadcastq(xmm30,\n+                  ExternalAddress(kyberAvx512ConstsAddr(qOffset)),\n+                  Assembler::AVX_512bit, scratch); \/\/ q\n+  __ vpbroadcastq(xmm31,\n+                  ExternalAddress(kyberAvx512ConstsAddr(qInvModROffset)),\n+                  Assembler::AVX_512bit, scratch); \/\/ q^-1 mod montR\n+\n+  load4regs(xmm0_3, coeffs, 0, _masm);\n+\n+  \/\/ Each level represents one iteration of the outer for loop of the Java version.\n+  \/\/ level 0\n+  montmul(xmm8_11, xmm4_7, xmm20_23, xmm8_11, xmm4_7, _masm);\n+  load4regs(xmm20_23, zetas, 256, _masm);\n+  sub_add(xmm4_7, xmm0_3, xmm0_3, xmm8_11, _masm);\n+\n+  \/\/level 1\n+  montmul(xmm12_15, xmm2367, xmm20_23, xmm12_15, xmm8_11, _masm);\n+  load4regs(xmm20_23, zetas, 512, _masm);\n+  sub_add(xmm2367, xmm0145, xmm0145, xmm12_15, _masm);\n+\n+  \/\/ level 2\n+  montmul(xmm8_11, xmm1357, xmm20_23, xmm12_15, xmm8_11, _masm);\n+  __ evmovdquw(xmm12, Address(perms, 0), Assembler::AVX_512bit);\n+  __ evmovdquw(xmm16, Address(perms, 64), Assembler::AVX_512bit);\n+  load4regs(xmm20_23, zetas, 768, _masm);\n+  sub_add(xmm1357, xmm0246, xmm0246, xmm8_11, _masm);\n+\n+  \/\/level 3\n+  permute(xmm12_15, xmm0246, xmm1357, 16, _masm);\n+  montmul(xmm8_11, xmm12_15, xmm20_23, xmm16_19, xmm8_11, _masm);\n+  __ evmovdquw(xmm16, Address(perms, 128), Assembler::AVX_512bit);\n+  __ evmovdquw(xmm24, Address(perms, 192), Assembler::AVX_512bit);\n+  load4regs(xmm20_23, zetas, 1024, _masm);\n+  sub_add(xmm1357, xmm0246, xmm0246, xmm8_11, _masm);\n+\n+  \/\/ level 4\n+  permute(xmm16_19, xmm0246, xmm1357, 24, _masm);\n+  montmul(xmm8_11, xmm0246, xmm20_23, xmm24_27, xmm8_11, _masm);\n+  __ evmovdquw(xmm1, Address(perms, 256), Assembler::AVX_512bit);\n+  __ evmovdquw(xmm24, Address(perms, 320), Assembler::AVX_512bit);\n+  load4regs(xmm20_23, zetas, 1280, _masm);\n+  sub_add(xmm12_15, xmm0246, xmm16_19, xmm8_11, _masm);\n+\n+  \/\/ level 5\n+  permute(xmm1357, xmm0246, xmm12_15, 24, _masm);\n+  montmul(xmm16_19, xmm0246, xmm20_23, xmm16_19, xmm8_11, _masm);\n+\n+  __ evmovdquw(xmm12, Address(perms, 384), Assembler::AVX_512bit);\n+  __ evmovdquw(xmm8, Address(perms, 448), Assembler::AVX_512bit);\n+\n+  load4regs(xmm20_23, zetas, 1536, _masm);\n+  sub_add(xmm24_27, xmm0246, xmm1357, xmm16_19, _masm);\n+\n+  \/\/ level 6\n+  permute(xmm12_15, xmm0246, xmm24_27, 8, _masm);\n+\n+  __ evmovdquw(xmm1, Address(perms, 512), Assembler::AVX_512bit);\n+  __ evmovdquw(xmm24, Address(perms, 576), Assembler::AVX_512bit);\n+\n+  montmul(xmm16_19, xmm0246, xmm20_23, xmm16_19, xmm8_11, _masm);\n+  sub_add(xmm20_23, xmm0246, xmm12_15, xmm16_19, _masm);\n+\n+  permute(xmm1357, xmm0246, xmm20_23, 24, _masm);\n+\n+  store4regs(coeffs, 0, xmm0_3, _masm);\n+  store4regs(coeffs, 256, xmm4_7, _masm);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ mov64(rax, 0); \/\/ return 0\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+\/\/ Kyber Inverse NTT function\n+\/\/\n+\/\/ coeffs (short[256]) = c_rarg0\n+\/\/ ntt_zetas (short[256]) = c_rarg1\n+address generate_kyberInverseNtt_avx512(StubGenerator *stubgen,\n+                                        MacroAssembler *_masm) {\n+\n+  __ align(CodeEntryAlignment);\n+  StubId stub_id = StubId::stubgen_kyberInverseNtt_id;\n+  StubCodeMark mark(stubgen, stub_id);\n+  address start = __ pc();\n+  __ enter();\n+\n+  const Register coeffs = c_rarg0;\n+  const Register zetas = c_rarg1;\n+\n+  const Register perms = r11;\n+\n+  __ lea(perms, ExternalAddress(kyberAvx512InverseNttPermsAddr()));\n+  __ evmovdquw(xmm12, Address(perms, 0), Assembler::AVX_512bit);\n+  __ evmovdquw(xmm16, Address(perms, 64), Assembler::AVX_512bit);\n+\n+  __ vpbroadcastq(xmm31,\n+                  ExternalAddress(kyberAvx512ConstsAddr(qInvModROffset)),\n+                  Assembler::AVX_512bit, scratch); \/\/ q^-1 mod montR\n+  __ vpbroadcastq(xmm30,\n+                  ExternalAddress(kyberAvx512ConstsAddr(qOffset)),\n+                  Assembler::AVX_512bit, scratch); \/\/ q\n+  __ vpbroadcastq(xmm29,\n+                  ExternalAddress(kyberAvx512ConstsAddr(dimHalfInverseOffset)),\n+                  Assembler::AVX_512bit, scratch); \/\/ (dim\/2)^-1 mod q\n+\n+  load4regs(xmm0_3, coeffs, 0, _masm);\n+  load4regs(xmm4_7, coeffs, 256, _masm);\n+\n+  \/\/ Each level represents one iteration of the outer for loop of the Java version.\n+  \/\/ level 0\n+  load4regs(xmm8_11, zetas, 0, _masm);\n+  permute(xmm12_15, xmm0246, xmm1357, 16, _masm);\n+\n+  __ evmovdquw(xmm1, Address(perms, 128), Assembler::AVX_512bit);\n+  __ evmovdquw(xmm20, Address(perms, 192), Assembler::AVX_512bit);\n+\n+  sub_add(xmm16_19, xmm0246, xmm0246, xmm12_15, _masm);\n+  montmul(xmm12_15, xmm16_19, xmm8_11, xmm12_15, xmm8_11, _masm);\n+\n+  \/\/ level 1\n+  load4regs(xmm8_11, zetas, 256, _masm);\n+  permute(xmm1357, xmm0246, xmm12_15, 20, _masm);\n+  sub_add(xmm16_19, xmm0246, xmm1357, xmm0246, _masm);\n+\n+  __ evmovdquw(xmm1, Address(perms, 256), Assembler::AVX_512bit);\n+  __ evmovdquw(xmm20, Address(perms, 320), Assembler::AVX_512bit);\n+\n+  montmul(xmm12_15, xmm16_19, xmm8_11, xmm12_15, xmm8_11, _masm);\n+\n+  \/\/ level2\n+  load4regs(xmm8_11, zetas, 512, _masm);\n+  permute(xmm1357, xmm0246, xmm12_15, 20, _masm);\n+  sub_add(xmm16_19, xmm0246, xmm1357,  xmm0246,_masm);\n+\n+  __ evmovdquw(xmm1, Address(perms, 384), Assembler::AVX_512bit);\n+  __ evmovdquw(xmm20, Address(perms, 448), Assembler::AVX_512bit);\n+\n+  montmul(xmm12_15, xmm16_19, xmm8_11, xmm12_15, xmm8_11, _masm);\n+\n+  __ vpbroadcastq(xmm16,\n+                  ExternalAddress(kyberAvx512ConstsAddr(barretMultiplierOffset)),\n+                  Assembler::AVX_512bit, scratch); \/\/ Barrett multiplier\n+  __ vpbroadcastq(xmm17,\n+                  ExternalAddress(kyberAvx512ConstsAddr(qOffset)),\n+                  Assembler::AVX_512bit, scratch); \/\/ q\n+\n+  permute(xmm1357, xmm0246, xmm12_15, 20, _masm);\n+  barrettReduce(_masm);\n+\n+\/\/ level 3\n+  load4regs(xmm8_11, zetas, 768, _masm);\n+  sub_add(xmm16_19, xmm0246, xmm1357, xmm0246, _masm);\n+\n+  __ evmovdquw(xmm1, Address(perms, 512), Assembler::AVX_512bit);\n+  __ evmovdquw(xmm20, Address(perms, 576), Assembler::AVX_512bit);\n+\n+  montmul(xmm12_15, xmm16_19, xmm8_11, xmm12_15, xmm8_11, _masm);\n+  permute(xmm1357, xmm0246, xmm12_15, 20, _masm);\n+\n+  \/\/ level 4\n+  load4regs(xmm8_11, zetas, 1024, _masm);\n+\n+  __ vpbroadcastq(xmm16,\n+                  ExternalAddress(kyberAvx512ConstsAddr(barretMultiplierOffset)),\n+                  Assembler::AVX_512bit, scratch); \/\/ Barrett multiplier\n+  __ vpbroadcastq(xmm17,\n+                  ExternalAddress(kyberAvx512ConstsAddr(qOffset)),\n+                  Assembler::AVX_512bit, scratch); \/\/ q\n+\n+  sub_add(xmm12_15, xmm0246, xmm0246, xmm1357, _masm);\n+  montmul(xmm1357, xmm12_15, xmm8_11, xmm1357, xmm8_11, _masm);\n+  barrettReduce(_masm);\n+\n+  \/\/ level 5\n+  load4regs(xmm8_11, zetas, 1280, _masm);\n+  sub_add(xmm12_15, xmm0145, xmm0145, xmm2367, _masm);\n+  montmul(xmm2367, xmm12_15, xmm8_11, xmm2367, xmm8_11, _masm);\n+\n+  \/\/ level 6\n+  load4regs(xmm8_11, zetas, 1536, _masm);\n+  sub_add(xmm12_15, xmm0_3, xmm0_3, xmm4_7, _masm);\n+  montmul(xmm4_7, xmm12_15, xmm8_11, xmm4_7, xmm8_11, _masm);\n+\n+  montmul(xmm8_11, xmm29_29, xmm0_3, xmm8_11, xmm0_3, _masm);\n+  montmul(xmm12_15, xmm29_29, xmm4_7, xmm12_15, xmm4_7, _masm);\n+\n+  store4regs(coeffs, 0, xmm8_11, _masm);\n+  store4regs(coeffs, 256, xmm12_15, _masm);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ mov64(rax, 0); \/\/ return 0\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+\/\/ Kyber multiply polynomials in the NTT domain.\n+\/\/\n+\/\/ result (short[256]) = c_rarg0\n+\/\/ ntta (short[256]) = c_rarg1\n+\/\/ nttb (short[256]) = c_rarg2\n+\/\/ zetas (short[128]) = c_rarg3\n+address generate_kyberNttMult_avx512(StubGenerator *stubgen,\n+                                     MacroAssembler *_masm) {\n+\n+  __ align(CodeEntryAlignment);\n+  StubId stub_id = StubId::stubgen_kyberNttMult_id;\n+  StubCodeMark mark(stubgen, stub_id);\n+  address start = __ pc();\n+  __ enter();\n+\n+  const Register result = c_rarg0;\n+  const Register ntta = c_rarg1;\n+  const Register nttb = c_rarg2;\n+  const Register zetas = c_rarg3;\n+\n+  const Register perms = r11;\n+  const Register loopCnt = r12;\n+\n+  __ push(r12);\n+  __ movl(loopCnt, 2);\n+\n+  Label Loop;\n+\n+  __ lea(perms, ExternalAddress(kyberAvx512_nttMultPermsAddr()));\n+\n+\n+  load4regs(xmm26_29, perms, 0, _masm);\n+  __ vpbroadcastq(xmm31,\n+                  ExternalAddress(kyberAvx512ConstsAddr(qInvModROffset)),\n+                  Assembler::AVX_512bit, scratch); \/\/ q^-1 mod montR\n+  __ vpbroadcastq(xmm30,\n+                  ExternalAddress(kyberAvx512ConstsAddr(qOffset)),\n+                  Assembler::AVX_512bit, scratch); \/\/ q\n+  __ vpbroadcastq(xmm23,\n+                  ExternalAddress(kyberAvx512ConstsAddr(montRSquareModqOffset)),\n+                  Assembler::AVX_512bit, scratch); \/\/ montR^2 mod q\n+\n+  __ BIND(Loop);\n+\n+    __ evmovdquw(xmm1, Address(ntta, 0), Assembler::AVX_512bit);\n+    __ evmovdquw(xmm8, Address(ntta, 64), Assembler::AVX_512bit);\n+    __ evmovdquw(xmm3, Address(ntta, 128), Assembler::AVX_512bit);\n+    __ evmovdquw(xmm9, Address(ntta, 192), Assembler::AVX_512bit);\n+\n+    __ evmovdquw(xmm5, Address(nttb, 0), Assembler::AVX_512bit);\n+    __ evmovdquw(xmm10, Address(nttb, 64), Assembler::AVX_512bit);\n+    __ evmovdquw(xmm7, Address(nttb, 128), Assembler::AVX_512bit);\n+    __ evmovdquw(xmm11, Address(nttb, 192), Assembler::AVX_512bit);\n+\n+    __ evmovdquw(xmm0, xmm26, Assembler::AVX_512bit);\n+    __ evmovdquw(xmm2, xmm26, Assembler::AVX_512bit);\n+    __ evmovdquw(xmm4, xmm26, Assembler::AVX_512bit);\n+    __ evmovdquw(xmm6, xmm26, Assembler::AVX_512bit);\n+\n+    __ evpermi2w(xmm0, xmm1, xmm8, Assembler::AVX_512bit);\n+    __ evpermt2w(xmm1, xmm27, xmm8, Assembler::AVX_512bit);\n+    __ evpermi2w(xmm2, xmm3, xmm9, Assembler::AVX_512bit);\n+    __ evpermt2w(xmm3, xmm27, xmm9, Assembler::AVX_512bit);\n+\n+    __ evpermi2w(xmm4, xmm5, xmm10, Assembler::AVX_512bit);\n+    __ evpermt2w(xmm5, xmm27, xmm10, Assembler::AVX_512bit);\n+    __ evpermi2w(xmm6, xmm7, xmm11, Assembler::AVX_512bit);\n+    __ evpermt2w(xmm7, xmm27, xmm11, Assembler::AVX_512bit);\n+\n+    __ evmovdquw(xmm24, Address(zetas, 0), Assembler::AVX_512bit);\n+    __ evmovdquw(xmm25, Address(zetas, 64), Assembler::AVX_512bit);\n+\n+    montmul(xmm16_19, xmm1001, xmm5454, xmm16_19, xmm12_15, _masm);\n+\n+    montmul(xmm0145, xmm3223, xmm7676, xmm0145, xmm12_15, _masm);\n+\n+    __ evpmullw(xmm2, k0, xmm16, xmm24, false, Assembler::AVX_512bit);\n+    __ evpmullw(xmm3, k0, xmm0, xmm25, false, Assembler::AVX_512bit);\n+    __ evpmulhw(xmm12, k0, xmm16, xmm24, false, Assembler::AVX_512bit);\n+    __ evpmulhw(xmm13, k0, xmm0, xmm25, false, Assembler::AVX_512bit);\n+\n+    __ evpmullw(xmm2, k0, xmm2, xmm31, false, Assembler::AVX_512bit);\n+    __ evpmullw(xmm3, k0, xmm3, xmm31, false, Assembler::AVX_512bit);\n+    __ evpmulhw(xmm2, k0, xmm30, xmm2, false, Assembler::AVX_512bit);\n+    __ evpmulhw(xmm3, k0, xmm30, xmm3, false, Assembler::AVX_512bit);\n+\n+    __ evpsubw(xmm2, k0, xmm12, xmm2, false, Assembler::AVX_512bit);\n+    __ evpsubw(xmm3, k0, xmm13, xmm3, false, Assembler::AVX_512bit);\n+\n+    __ evpaddw(xmm0, k0, xmm2, xmm17, false, Assembler::AVX_512bit);\n+    __ evpaddw(xmm8, k0, xmm3, xmm1, false, Assembler::AVX_512bit);\n+    __ evpaddw(xmm2, k0, xmm18, xmm19, false, Assembler::AVX_512bit);\n+    __ evpaddw(xmm9, k0, xmm4, xmm5, false, Assembler::AVX_512bit);\n+\n+    montmul(xmm1357, xmm0829, xmm23_23, xmm1357, xmm0829, _masm);\n+\n+    __ evmovdquw(xmm0, xmm28, Assembler::AVX_512bit);\n+    __ evmovdquw(xmm2, xmm28, Assembler::AVX_512bit);\n+    __ evpermi2w(xmm0, xmm1, xmm5, Assembler::AVX_512bit);\n+    __ evpermt2w(xmm1, xmm29, xmm5, Assembler::AVX_512bit);\n+    __ evpermi2w(xmm2, xmm3, xmm7, Assembler::AVX_512bit);\n+    __ evpermt2w(xmm3, xmm29, xmm7, Assembler::AVX_512bit);\n+\n+    store4regs(result, 0, xmm0_3, _masm);\n+\n+    __ addptr(ntta, 256);\n+    __ addptr(nttb, 256);\n+    __ addptr(result, 256);\n+    __ addptr(zetas, 128);\n+    __ subl(loopCnt, 1);\n+    __ jcc(Assembler::greater, Loop);\n+\n+  __ pop(r12);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ mov64(rax, 0); \/\/ return 0\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+\/\/ Kyber add 2 polynomials.\n+\/\/\n+\/\/ result (short[256]) = c_rarg0\n+\/\/ a (short[256]) = c_rarg1\n+\/\/ b (short[256]) = c_rarg2\n+address generate_kyberAddPoly_2_avx512(StubGenerator *stubgen,\n+                                       MacroAssembler *_masm) {\n+\n+  __ align(CodeEntryAlignment);\n+  StubId stub_id = StubId::stubgen_kyberAddPoly_2_id;\n+  StubCodeMark mark(stubgen, stub_id);\n+  address start = __ pc();\n+  __ enter();\n+\n+  const Register result = c_rarg0;\n+  const Register a = c_rarg1;\n+  const Register b = c_rarg2;\n+\n+  __ vpbroadcastq(xmm31,\n+                  ExternalAddress(kyberAvx512ConstsAddr(qOffset)),\n+                  Assembler::AVX_512bit, scratch); \/\/ q\n+\n+  for (int i = 0; i < 8; i++) {\n+    __ evmovdquw(xmm(i), Address(a, 64 * i), Assembler::AVX_512bit);\n+    __ evmovdquw(xmm(i + 8), Address(b, 64 * i), Assembler::AVX_512bit);\n+  }\n+\n+  for (int i = 0; i < 8; i++) {\n+    __ evpaddw(xmm(i), k0, xmm(i), xmm(i + 8), false, Assembler::AVX_512bit);\n+  }\n+\n+  for (int i = 0; i < 8; i++) {\n+    __ evpaddw(xmm(i), k0, xmm(i), xmm31, false, Assembler::AVX_512bit);\n+  }\n+\n+  store4regs(result, 0, xmm0_3, _masm);\n+  store4regs(result, 256, xmm4_7, _masm);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ mov64(rax, 0); \/\/ return 0\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+\/\/ Kyber add 3 polynomials.\n+\/\/\n+\/\/ result (short[256]) = c_rarg0\n+\/\/ a (short[256]) = c_rarg1\n+\/\/ b (short[256]) = c_rarg2\n+\/\/ c (short[256]) = c_rarg3\n+address generate_kyberAddPoly_3_avx512(StubGenerator *stubgen,\n+                                       MacroAssembler *_masm) {\n+\n+  __ align(CodeEntryAlignment);\n+  StubId stub_id = StubId::stubgen_kyberAddPoly_3_id;\n+  StubCodeMark mark(stubgen, stub_id);\n+  address start = __ pc();\n+  __ enter();\n+\n+  const Register result = c_rarg0;\n+  const Register a = c_rarg1;\n+  const Register b = c_rarg2;\n+  const Register c = c_rarg3;\n+\n+  __ vpbroadcastq(xmm31,\n+                  ExternalAddress(kyberAvx512ConstsAddr(qOffset)),\n+                  Assembler::AVX_512bit, scratch); \/\/ q\n+\n+  for (int i = 0; i < 8; i++) {\n+    __ evmovdquw(xmm(i), Address(a, 64 * i), Assembler::AVX_512bit);\n+    __ evmovdquw(xmm(i + 8), Address(b, 64 * i), Assembler::AVX_512bit);\n+    __ evmovdquw(xmm(i + 16), Address(c, 64 * i), Assembler::AVX_512bit);\n+  }\n+\n+  __ evpaddw(xmm31, k0, xmm31, xmm31, false, Assembler::AVX_512bit);\n+\n+  for (int i = 0; i < 8; i++) {\n+    __ evpaddw(xmm(i), k0, xmm(i), xmm(i + 8), false, Assembler::AVX_512bit);\n+  }\n+\n+  for (int i = 0; i < 8; i++) {\n+    __ evpaddw(xmm(i), k0, xmm(i), xmm(i + 16), false, Assembler::AVX_512bit);\n+  }\n+\n+  for (int i = 0; i < 8; i++) {\n+    __ evpaddw(xmm(i), k0, xmm(i), xmm31, false, Assembler::AVX_512bit);\n+  }\n+\n+  store4regs(result, 0, xmm0_3, _masm);\n+  store4regs(result, 256, xmm4_7, _masm);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ mov64(rax, 0); \/\/ return 0\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+\/\/ Kyber parse XOF output to polynomial coefficient candidates.\n+\/\/\n+\/\/ condensed (byte[168]) = c_rarg0\n+\/\/ condensedOffs (int) = c_rarg1\n+\/\/ parsed (short[112]) = c_rarg2\n+\/\/ parsedLength (int) = c_rarg3\n+address generate_kyber12To16_avx512(StubGenerator *stubgen,\n+                                    MacroAssembler *_masm) {\n+\n+  __ align(CodeEntryAlignment);\n+  StubId stub_id = StubId::stubgen_kyber12To16_id;\n+  StubCodeMark mark(stubgen, stub_id);\n+  address start = __ pc();\n+  __ enter();\n+\n+  const Register condensed = c_rarg0;\n+  const Register condensedOffs = c_rarg1;\n+  const Register parsed = c_rarg2;\n+  const Register parsedLength = c_rarg3;\n+\n+  const Register perms = r11;\n+\n+  Label Loop;\n+\n+  __ addptr(condensed, condensedOffs);\n+\n+  __ lea(perms, ExternalAddress(kyberAvx512_12To16PermsAddr()));\n+\n+  load4regs(xmm24_27, perms, 0, _masm);\n+  load4regs(xmm28_31, perms, 256, _masm);\n+  __ vpbroadcastq(xmm23,\n+                  ExternalAddress(kyberAvx512ConstsAddr(f00Offset)),\n+                  Assembler::AVX_512bit, scratch); \/\/ 0xF00\n+\n+  __ BIND(Loop);\n+    __ evmovdqub(xmm0, Address(condensed, 0),Assembler::AVX_256bit);\n+    __ evmovdqub(xmm1, Address(condensed, 32),Assembler::AVX_256bit);\n+    __ evmovdqub(xmm2, Address(condensed, 64),Assembler::AVX_256bit);\n+    __ evmovdqub(xmm8, Address(condensed, 96),Assembler::AVX_256bit);\n+    __ evmovdqub(xmm9, Address(condensed, 128),Assembler::AVX_256bit);\n+    __ evmovdqub(xmm10, Address(condensed, 160),Assembler::AVX_256bit);\n+    __ vpmovzxbw(xmm0, xmm0, Assembler::AVX_512bit);\n+    __ vpmovzxbw(xmm1, xmm1, Assembler::AVX_512bit);\n+    __ vpmovzxbw(xmm2, xmm2, Assembler::AVX_512bit);\n+    __ vpmovzxbw(xmm8, xmm8, Assembler::AVX_512bit);\n+    __ vpmovzxbw(xmm9, xmm9, Assembler::AVX_512bit);\n+    __ vpmovzxbw(xmm10, xmm10, Assembler::AVX_512bit);\n+    __ evmovdquw(xmm3, xmm24, Assembler::AVX_512bit);\n+    __ evmovdquw(xmm4, xmm25, Assembler::AVX_512bit);\n+    __ evmovdquw(xmm5, xmm26, Assembler::AVX_512bit);\n+    __ evmovdquw(xmm11, xmm24, Assembler::AVX_512bit);\n+    __ evmovdquw(xmm12, xmm25, Assembler::AVX_512bit);\n+    __ evmovdquw(xmm13, xmm26, Assembler::AVX_512bit);\n+    __ evpermi2w(xmm3, xmm0, xmm1, Assembler::AVX_512bit);\n+    __ evpermi2w(xmm4, xmm0, xmm1, Assembler::AVX_512bit);\n+    __ evpermi2w(xmm5, xmm0, xmm1, Assembler::AVX_512bit);\n+    __ evpermi2w(xmm11, xmm8, xmm9, Assembler::AVX_512bit);\n+    __ evpermi2w(xmm12, xmm8, xmm9, Assembler::AVX_512bit);\n+    __ evpermi2w(xmm13, xmm8, xmm9, Assembler::AVX_512bit);\n+    __ evpermt2w(xmm3, xmm27, xmm2, Assembler::AVX_512bit);\n+    __ evpermt2w(xmm4, xmm28, xmm2, Assembler::AVX_512bit);\n+    __ evpermt2w(xmm5, xmm29, xmm2, Assembler::AVX_512bit);\n+    __ evpermt2w(xmm11, xmm27, xmm10, Assembler::AVX_512bit);\n+    __ evpermt2w(xmm12, xmm28, xmm10, Assembler::AVX_512bit);\n+    __ evpermt2w(xmm13, xmm29, xmm10, Assembler::AVX_512bit);\n+\n+    __ evpsraw(xmm2, k0, xmm4, 4, false, Assembler::AVX_512bit);\n+    __ evpsllw(xmm0, k0, xmm4, 8, false, Assembler::AVX_512bit);\n+    __ evpsllw(xmm1, k0, xmm5, 4, false, Assembler::AVX_512bit);\n+    __ evpsllw(xmm8, k0, xmm12, 8, false, Assembler::AVX_512bit);\n+    __ evpsraw(xmm10, k0, xmm12, 4, false, Assembler::AVX_512bit);\n+    __ evpsllw(xmm9, k0, xmm13, 4, false, Assembler::AVX_512bit);\n+    __ evpandq(xmm0, k0, xmm0, xmm23, false, Assembler::AVX_512bit);\n+    __ evpandq(xmm8, k0, xmm8, xmm23, false, Assembler::AVX_512bit);\n+    __ evpaddw(xmm1, k0, xmm1, xmm2, false, Assembler::AVX_512bit);\n+    __ evpaddw(xmm0, k0, xmm0, xmm3, false, Assembler::AVX_512bit);\n+    __ evmovdquw(xmm2, xmm30, Assembler::AVX_512bit);\n+    __ evpaddw(xmm9, k0, xmm9, xmm10, false, Assembler::AVX_512bit);\n+    __ evpaddw(xmm8, k0, xmm8, xmm11, false, Assembler::AVX_512bit);\n+    __ evmovdquw(xmm10, xmm30, Assembler::AVX_512bit);\n+    __ evpermi2w(xmm2, xmm0, xmm1, Assembler::AVX_512bit);\n+    __ evpermt2w(xmm0, xmm31, xmm1, Assembler::AVX_512bit);\n+    __ evpermi2w(xmm10, xmm8, xmm9, Assembler::AVX_512bit);\n+    __ evpermt2w(xmm8, xmm31, xmm9, Assembler::AVX_512bit);\n+\n+    store4regs(parsed, 0, xmm2_0_10_8, _masm);\n+\n+    __ addptr(condensed, 192);\n+    __ addptr(parsed, 256);\n+    __ subl(parsedLength, 128);\n+    __ jcc(Assembler::greater, Loop);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ mov64(rax, 0); \/\/ return 0\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+\n+\/\/ Kyber barrett reduce function.\n+\/\/\n+\/\/ coeffs (short[256]) = c_rarg0\n+address generate_kyberBarrettReduce_avx512(StubGenerator *stubgen,\n+                                           MacroAssembler *_masm) {\n+\n+  __ align(CodeEntryAlignment);\n+  StubId stub_id = StubId::stubgen_kyberBarrettReduce_id;\n+  StubCodeMark mark(stubgen, stub_id);\n+  address start = __ pc();\n+  __ enter();\n+\n+  const Register coeffs = c_rarg0;\n+\n+  __ vpbroadcastq(xmm16,\n+                  ExternalAddress(kyberAvx512ConstsAddr(barretMultiplierOffset)),\n+                  Assembler::AVX_512bit, scratch); \/\/ Barrett multiplier\n+  __ vpbroadcastq(xmm17,\n+                  ExternalAddress(kyberAvx512ConstsAddr(qOffset)),\n+                  Assembler::AVX_512bit, scratch); \/\/ q\n+\n+  load4regs(xmm0_3, coeffs, 0, _masm);\n+  load4regs(xmm4_7, coeffs, 256, _masm);\n+\n+  barrettReduce(_masm);\n+\n+  store4regs(coeffs, 0, xmm0_3, _masm);\n+  store4regs(coeffs, 256, xmm4_7, _masm);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ mov64(rax, 0); \/\/ return 0\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+void StubGenerator::generate_kyber_stubs() {\n+  \/\/ Generate Kyber intrinsics code\n+  if (UseKyberIntrinsics) {\n+    if (VM_Version::supports_evex()) {\n+      StubRoutines::_kyberNtt = generate_kyberNtt_avx512(this, _masm);\n+      StubRoutines::_kyberInverseNtt = generate_kyberInverseNtt_avx512(this, _masm);\n+      StubRoutines::_kyberNttMult = generate_kyberNttMult_avx512(this, _masm);\n+      StubRoutines::_kyberAddPoly_2 = generate_kyberAddPoly_2_avx512(this, _masm);\n+      StubRoutines::_kyberAddPoly_3 = generate_kyberAddPoly_3_avx512(this, _masm);\n+      StubRoutines::_kyber12To16 = generate_kyber12To16_avx512(this, _masm);\n+      StubRoutines::_kyberBarrettReduce = generate_kyberBarrettReduce_avx512(this, _masm);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_kyber.cpp","additions":952,"deletions":0,"binary":false,"changes":952,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2024, Intel Corporation. All rights reserved.\n+* Copyright (c) 2016, 2025, Intel Corporation. All rights reserved.\n@@ -179,1 +179,1 @@\n-  StubGenStubId stub_id = StubGenStubId::dlog_id;\n+  StubId stub_id = StubId::stubgen_dlog_id;\n@@ -518,1 +518,1 @@\n-  StubGenStubId stub_id = StubGenStubId::dlog10_id;\n+  StubId stub_id = StubId::stubgen_dlog10_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_log.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2022, 2025, Intel Corporation. All rights reserved.\n@@ -913,1 +913,1 @@\n-  StubGenStubId stub_id = StubGenStubId::poly1305_processBlocks_id;\n+  StubId stub_id = StubId::stubgen_poly1305_processBlocks_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly1305.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -562,1 +562,1 @@\n-  StubGenStubId stub_id = StubGenStubId::intpoly_montgomeryMult_P256_id;\n+  StubId stub_id = StubId::stubgen_intpoly_montgomeryMult_P256_id;\n@@ -684,1 +684,1 @@\n-  StubGenStubId stub_id = StubGenStubId::intpoly_assign_id;\n+  StubId stub_id = StubId::stubgen_intpoly_assign_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly_mont.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2024, Intel Corporation. All rights reserved.\n+* Copyright (c) 2016, 2025, Intel Corporation. All rights reserved.\n@@ -762,1 +762,1 @@\n-  StubGenStubId stub_id = StubGenStubId::dpow_id;\n+  StubId stub_id = StubId::stubgen_dpow_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_pow.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-static address generate_sha3_implCompress(StubGenStubId stub_id,\n+static address generate_sha3_implCompress(StubId stub_id,\n@@ -98,1 +98,1 @@\n-  case sha3_implCompress_id:\n+  case StubId::stubgen_sha3_implCompress_id:\n@@ -101,1 +101,1 @@\n-  case sha3_implCompressMB_id:\n+  case StubId::stubgen_sha3_implCompressMB_id:\n@@ -330,1 +330,1 @@\n-  StubGenStubId stub_id = double_keccak_id;\n+  StubId stub_id = StubId::stubgen_double_keccak_id;\n@@ -504,1 +504,1 @@\n-      generate_sha3_implCompress(StubGenStubId::sha3_implCompress_id, this, _masm);\n+      generate_sha3_implCompress(StubId::stubgen_sha3_implCompress_id, this, _masm);\n@@ -508,1 +508,1 @@\n-      generate_sha3_implCompress(StubGenStubId::sha3_implCompressMB_id, this, _masm);\n+      generate_sha3_implCompress(StubId::stubgen_sha3_implCompressMB_id, this, _masm);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_sha3.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2016, 2025, Intel Corporation. All rights reserved.\n@@ -183,1 +183,1 @@\n-  StubGenStubId stub_id = StubGenStubId::dsin_id;\n+  StubId stub_id = StubId::stubgen_dsin_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_sin.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2024, Intel Corporation. All rights reserved.\n+* Copyright (c) 2016, 2025, Intel Corporation. All rights reserved.\n@@ -458,1 +458,1 @@\n-  StubGenStubId stub_id = StubGenStubId::dtan_id;\n+  StubId stub_id = StubId::stubgen_dtan_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_tan.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-  StubGenStubId stub_id = StubGenStubId::dtanh_id;\n+  StubId stub_id = StubId::stubgen_dtanh_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_tanh.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1690,2 +1690,1 @@\n-  __ profile_taken_branch(rax, rbx); \/\/ rax holds updated MDP, rbx\n-                                     \/\/ holds bumped taken count\n+  __ profile_taken_branch(rax); \/\/ rax holds updated MDP\n@@ -1742,1 +1741,0 @@\n-    \/\/ rbx: MDO bumped taken-count\n@@ -1828,0 +1826,2 @@\n+      JFR_ONLY(__ enter_jfr_critical_section();)\n+\n@@ -1842,0 +1842,1 @@\n+      JFR_ONLY(__ leave_jfr_critical_section();)\n@@ -1843,1 +1844,1 @@\n-      __ mov(rsp, sender_sp);                   \/\/ set sp to sender sp\n+      __ mov(rsp, sender_sp);                    \/\/ set sp to sender sp\n@@ -1847,3 +1848,0 @@\n-      \/\/ unlike x86 we need no specialized return from compiled code\n-      \/\/ to the interpreter or the call stub.\n-\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2027,1 +2027,1 @@\n-      if (is_floating_point_type(bt)) {\n+      if (is_floating_point_type(bt) && !VM_Version::supports_avx10_2()) {\n@@ -4026,1 +4026,1 @@\n-instruct vgather_subwordLE8B(vec dst, memory mem, rRegP idx_base, immI_0 offset, rRegP tmp, rRegI rtmp) %{\n+instruct vgather_subwordLE8B(vec dst, memory mem, rRegP idx_base, rRegP tmp, rRegI rtmp) %{\n@@ -4028,1 +4028,1 @@\n-  match(Set dst (LoadVectorGather mem (Binary idx_base offset)));\n+  match(Set dst (LoadVectorGather mem idx_base));\n@@ -4035,1 +4035,1 @@\n-    __ vgather8b_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, noreg, $rtmp$$Register, vlen_enc);\n+    __ vgather8b(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $rtmp$$Register, vlen_enc);\n@@ -4040,1 +4040,1 @@\n-instruct vgather_subwordGT8B(vec dst, memory mem, rRegP idx_base, immI_0 offset, rRegP tmp, rRegP idx_base_temp,\n+instruct vgather_subwordGT8B(vec dst, memory mem, rRegP idx_base, rRegP tmp, rRegP idx_base_temp,\n@@ -4043,1 +4043,1 @@\n-  match(Set dst (LoadVectorGather mem (Binary idx_base offset)));\n+  match(Set dst (LoadVectorGather mem idx_base));\n@@ -4052,1 +4052,1 @@\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, noreg, noreg, $xtmp1$$XMMRegister,\n+    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, noreg, $xtmp1$$XMMRegister,\n@@ -4058,35 +4058,1 @@\n-instruct vgather_subwordLE8B_off(vec dst, memory mem, rRegP idx_base, rRegI offset, rRegP tmp, rRegI rtmp, rFlagsReg cr) %{\n-  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) <= 8);\n-  match(Set dst (LoadVectorGather mem (Binary idx_base offset)));\n-  effect(TEMP tmp, TEMP rtmp, KILL cr);\n-  format %{ \"vector_gatherLE8_off $dst, $mem, $idx_base, $offset\\t! using $tmp and $rtmp as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ vgather8b_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $offset$$Register, $rtmp$$Register, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\n-instruct vgather_subwordGT8B_off(vec dst, memory mem, rRegP idx_base, rRegI offset, rRegP tmp, rRegP idx_base_temp,\n-                                 vec xtmp1, vec xtmp2, vec xtmp3, rRegI rtmp, rRegI length, rFlagsReg cr) %{\n-  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) > 8);\n-  match(Set dst (LoadVectorGather mem (Binary idx_base offset)));\n-  effect(TEMP_DEF dst, TEMP tmp, TEMP idx_base_temp, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, TEMP length, KILL cr);\n-  format %{ \"vector_gatherGT8_off $dst, $mem, $idx_base, $offset\\t! using $tmp, $idx_base_temp, $xtmp1, $xtmp2, $xtmp3, $rtmp and $length as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    int vector_len = Matcher::vector_length(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ movptr($idx_base_temp$$Register, $idx_base$$Register);\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, $offset$$Register, noreg, $xtmp1$$XMMRegister,\n-                       $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $rtmp$$Register, noreg, $length$$Register, vector_len, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\n-instruct vgather_masked_subwordLE8B_avx3(vec dst, memory mem, rRegP idx_base, immI_0 offset, kReg mask, rRegL mask_idx, rRegP tmp, rRegI rtmp, rRegL rtmp2, rFlagsReg cr) %{\n+instruct vgather_masked_subwordLE8B_avx3(vec dst, memory mem, rRegP idx_base, kReg mask, rRegL mask_idx, rRegP tmp, rRegI rtmp, rRegL rtmp2, rFlagsReg cr) %{\n@@ -4094,1 +4060,1 @@\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base mask)));\n@@ -4103,1 +4069,1 @@\n-    __ vgather8b_masked_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, noreg, $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n+    __ vgather8b_masked(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n@@ -4108,1 +4074,1 @@\n-instruct vgather_masked_subwordGT8B_avx3(vec dst, memory mem, rRegP idx_base, immI_0 offset, kReg mask, rRegP tmp, rRegP idx_base_temp,\n+instruct vgather_masked_subwordGT8B_avx3(vec dst, memory mem, rRegP idx_base, kReg mask, rRegP tmp, rRegP idx_base_temp,\n@@ -4111,1 +4077,1 @@\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base mask)));\n@@ -4122,38 +4088,1 @@\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, noreg, $rtmp2$$Register, $xtmp1$$XMMRegister,\n-                       $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $rtmp$$Register, $mask_idx$$Register, $length$$Register, vector_len, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vgather_masked_subwordLE8B_off_avx3(vec dst, memory mem, rRegP idx_base, rRegI offset, kReg mask, rRegL mask_idx, rRegP tmp, rRegI rtmp, rRegL rtmp2, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_avx512bw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) <= 8);\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n-  effect(TEMP mask_idx, TEMP tmp, TEMP rtmp, TEMP rtmp2, KILL cr);\n-  format %{ \"vector_masked_gatherLE8_off $dst, $mem, $idx_base, $offset, $mask\\t! using $mask_idx, $tmp, $rtmp and $rtmp2 as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ xorq($mask_idx$$Register, $mask_idx$$Register);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ kmovql($rtmp2$$Register, $mask$$KRegister);\n-    __ vgather8b_masked_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $offset$$Register,\n-                                $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vgather_masked_subwordGT8B_off_avx3(vec dst, memory mem, rRegP idx_base, rRegI offset, kReg mask, rRegP tmp, rRegP idx_base_temp,\n-                                             vec xtmp1, vec xtmp2, vec xtmp3, rRegI rtmp, rRegL rtmp2, rRegL mask_idx, rRegI length, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_avx512bw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) > 8);\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n-  effect(TEMP_DEF dst, TEMP tmp, TEMP idx_base_temp, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, TEMP rtmp2, TEMP mask_idx, TEMP length, KILL cr);\n-  format %{ \"vector_gatherGT8_masked_off $dst, $mem, $idx_base, $offset, $mask\\t! using $tmp, $idx_base_temp, $xtmp1, $xtmp2, $xtmp3, $rtmp, $rtmp2, $mask_idx and $length as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    int vector_len = Matcher::vector_length(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ xorq($mask_idx$$Register, $mask_idx$$Register);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ movptr($idx_base_temp$$Register, $idx_base$$Register);\n-    __ kmovql($rtmp2$$Register, $mask$$KRegister);\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, $offset$$Register, $rtmp2$$Register, $xtmp1$$XMMRegister,\n+    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, $rtmp2$$Register, $xtmp1$$XMMRegister,\n@@ -4165,1 +4094,1 @@\n-instruct vgather_masked_subwordLE8B_avx2(vec dst, memory mem, rRegP idx_base, immI_0 offset, vec mask, rRegI mask_idx, rRegP tmp, rRegI rtmp, rRegI rtmp2, rFlagsReg cr) %{\n+instruct vgather_masked_subwordLE8B_avx2(vec dst, memory mem, rRegP idx_base, vec mask, rRegI mask_idx, rRegP tmp, rRegI rtmp, rRegI rtmp2, rFlagsReg cr) %{\n@@ -4167,1 +4096,1 @@\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base mask)));\n@@ -4180,1 +4109,1 @@\n-    __ vgather8b_masked_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, noreg, $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n+    __ vgather8b_masked(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n@@ -4185,1 +4114,1 @@\n-instruct vgather_masked_subwordGT8B_avx2(vec dst, memory mem, rRegP idx_base, immI_0 offset, vec mask, rRegP tmp, rRegP idx_base_temp,\n+instruct vgather_masked_subwordGT8B_avx2(vec dst, memory mem, rRegP idx_base, vec mask, rRegP tmp, rRegP idx_base_temp,\n@@ -4188,1 +4117,1 @@\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base mask)));\n@@ -4203,47 +4132,1 @@\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, noreg, $rtmp2$$Register, $xtmp1$$XMMRegister,\n-                       $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $rtmp$$Register, $mask_idx$$Register, $length$$Register, vector_len, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vgather_masked_subwordLE8B_off_avx2(vec dst, memory mem, rRegP idx_base, rRegI offset, vec mask, rRegI mask_idx, rRegP tmp, rRegI rtmp, rRegI rtmp2, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512vlbw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) <= 8);\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n-  effect(TEMP mask_idx, TEMP tmp, TEMP rtmp, TEMP rtmp2, KILL cr);\n-  format %{ \"vector_masked_gatherLE8_off $dst, $mem, $idx_base, $offset, $mask\\t! using $mask_idx, $tmp, $rtmp and $rtmp2 as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ vpmovmskb($rtmp2$$Register, $mask$$XMMRegister, vlen_enc);\n-    if (elem_bt == T_SHORT) {\n-      __ movl($mask_idx$$Register, 0x55555555);\n-      __ pextl($rtmp2$$Register, $rtmp2$$Register, $mask_idx$$Register);\n-    }\n-    __ xorl($mask_idx$$Register, $mask_idx$$Register);\n-    __ vgather8b_masked_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $offset$$Register,\n-                                $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vgather_masked_subwordGT8B_off_avx2(vec dst, memory mem, rRegP idx_base, rRegI offset, vec mask, rRegP tmp, rRegP idx_base_temp,\n-                                             vec xtmp1, vec xtmp2, vec xtmp3, rRegI rtmp, rRegI rtmp2, rRegI mask_idx, rRegI length, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512vlbw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) > 8);\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n-  effect(TEMP_DEF dst, TEMP tmp, TEMP idx_base_temp, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, TEMP rtmp2, TEMP mask_idx, TEMP length, KILL cr);\n-  format %{ \"vector_gatherGT8_masked_off $dst, $mem, $idx_base, $offset, $mask\\t! using $tmp, $idx_base_temp, $xtmp1, $xtmp2, $xtmp3, $rtmp, $rtmp2, $mask_idx and $length as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    int vector_len = Matcher::vector_length(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ xorl($mask_idx$$Register, $mask_idx$$Register);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ movptr($idx_base_temp$$Register, $idx_base$$Register);\n-    __ vpmovmskb($rtmp2$$Register, $mask$$XMMRegister, vlen_enc);\n-    if (elem_bt == T_SHORT) {\n-      __ movl($mask_idx$$Register, 0x55555555);\n-      __ pextl($rtmp2$$Register, $rtmp2$$Register, $mask_idx$$Register);\n-    }\n-    __ xorl($mask_idx$$Register, $mask_idx$$Register);\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, $offset$$Register, $rtmp2$$Register, $xtmp1$$XMMRegister,\n+    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, $rtmp2$$Register, $xtmp1$$XMMRegister,\n@@ -5296,3 +5179,3 @@\n-instruct minmax_reduction2F(legRegF dst, immF src1, legVec src2, legVec tmp,\n-                            legVec atmp, legVec btmp, legVec xmm_1, rFlagsReg cr) %{\n-  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n+instruct minmax_reduction2F(legRegF dst, immF src1, legVec src2, legVec tmp, legVec atmp,\n+                            legVec btmp, legVec xmm_1, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n@@ -5319,1 +5202,1 @@\n-  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n+  predicate(!VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n@@ -5338,3 +5221,3 @@\n-instruct minmax_reduction2F_av(legRegF dst, legVec src, legVec tmp,\n-                               legVec atmp, legVec btmp, legVec xmm_1, rFlagsReg cr) %{\n-  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n+instruct minmax_reduction2F_av(legRegF dst, legVec src, legVec tmp, legVec atmp,\n+                               legVec btmp, legVec xmm_1, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n@@ -5358,3 +5241,3 @@\n-instruct minmax_reductionF_av(legRegF dst, legVec src, legVec tmp,\n-                              legVec atmp, legVec btmp, legVec xmm_0, legVec xmm_1, rFlagsReg cr) %{\n-  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n+instruct minmax_reductionF_av(legRegF dst, legVec src, legVec tmp, legVec atmp, legVec btmp,\n+                              legVec xmm_0, legVec xmm_1, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n@@ -5377,0 +5260,67 @@\n+instruct minmax_reduction2F_avx10(regF dst, immF src1, vec src2, vec xtmp1) %{\n+  predicate(VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n+            ((n->Opcode() == Op_MinReductionV && n->in(1)->bottom_type() == TypeF::POS_INF) ||\n+             (n->Opcode() == Op_MaxReductionV && n->in(1)->bottom_type() == TypeF::NEG_INF)) &&\n+            Matcher::vector_length(n->in(2)) == 2);\n+  match(Set dst (MinReductionV src1 src2));\n+  match(Set dst (MaxReductionV src1 src2));\n+  effect(TEMP dst, TEMP xtmp1);\n+  format %{ \"vector_minmax_reduction $dst, $src1, $src2 \\t; using $xtmp1 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen = Matcher::vector_length(this, $src2);\n+    __ reduceFloatMinMax(opcode, vlen, false, $dst$$XMMRegister, $src2$$XMMRegister,\n+                         xnoreg, xnoreg, xnoreg, $xtmp1$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct minmax_reductionF_avx10(regF dst, immF src1, vec src2, vec xtmp1, vec xtmp2) %{\n+  predicate(VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n+            ((n->Opcode() == Op_MinReductionV && n->in(1)->bottom_type() == TypeF::POS_INF) ||\n+             (n->Opcode() == Op_MaxReductionV && n->in(1)->bottom_type() == TypeF::NEG_INF)) &&\n+            Matcher::vector_length(n->in(2)) >= 4);\n+  match(Set dst (MinReductionV src1 src2));\n+  match(Set dst (MaxReductionV src1 src2));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vector_minmax_reduction $dst, $src1, $src2 \\t; using $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen = Matcher::vector_length(this, $src2);\n+    __ reduceFloatMinMax(opcode, vlen, false, $dst$$XMMRegister, $src2$$XMMRegister, xnoreg, xnoreg,\n+                         xnoreg, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct minmax_reduction2F_avx10_av(regF dst, vec src, vec xtmp1) %{\n+  predicate(VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n+            Matcher::vector_length(n->in(2)) == 2);\n+  match(Set dst (MinReductionV dst src));\n+  match(Set dst (MaxReductionV dst src));\n+  effect(TEMP dst, TEMP xtmp1);\n+  format %{ \"vector_minmax2F_reduction $dst, $src \\t; using $xtmp1 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen = Matcher::vector_length(this, $src);\n+    __ reduceFloatMinMax(opcode, vlen, true, $dst$$XMMRegister, $src$$XMMRegister, xnoreg, xnoreg, xnoreg,\n+                         $xtmp1$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct minmax_reductionF_avx10_av(regF dst, vec src, vec xtmp1, vec xtmp2) %{\n+  predicate(VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n+            Matcher::vector_length(n->in(2)) >= 4);\n+  match(Set dst (MinReductionV dst src));\n+  match(Set dst (MaxReductionV dst src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vector_minmax2F_reduction $dst, $src \\t; using $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen = Matcher::vector_length(this, $src);\n+    __ reduceFloatMinMax(opcode, vlen, true, $dst$$XMMRegister, $src$$XMMRegister, xnoreg, xnoreg, xnoreg,\n+                         $xtmp1$$XMMRegister, $xtmp2$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n@@ -5379,4 +5329,3 @@\n-instruct minmax_reduction2D(legRegD dst, immD src1, legVec src2,\n-                            legVec tmp1, legVec tmp2, legVec tmp3, legVec tmp4, \/\/ TEMPs\n-                            rFlagsReg cr) %{\n-  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n+instruct minmax_reduction2D(legRegD dst, immD src1, legVec src2, legVec tmp1, legVec tmp2,\n+                            legVec tmp3, legVec tmp4, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n@@ -5401,4 +5350,3 @@\n-instruct minmax_reductionD(legRegD dst, immD src1, legVec src2,\n-                           legVec tmp1, legVec tmp2, legVec tmp3, legVec tmp4, legVec tmp5, \/\/ TEMPs\n-                           rFlagsReg cr) %{\n-  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n+instruct minmax_reductionD(legRegD dst, immD src1, legVec src2, legVec tmp1, legVec tmp2,\n+                           legVec tmp3, legVec tmp4, legVec tmp5, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n@@ -5424,4 +5372,3 @@\n-instruct minmax_reduction2D_av(legRegD dst, legVec src,\n-                               legVec tmp1, legVec tmp2, legVec tmp3, legVec tmp4, \/\/ TEMPs\n-                               rFlagsReg cr) %{\n-  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n+instruct minmax_reduction2D_av(legRegD dst, legVec src, legVec tmp1, legVec tmp2,\n+                               legVec tmp3, legVec tmp4, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n@@ -5444,4 +5391,3 @@\n-instruct minmax_reductionD_av(legRegD dst, legVec src,\n-                              legVec tmp1, legVec tmp2, legVec tmp3, legVec tmp4, legVec tmp5, \/\/ TEMPs\n-                              rFlagsReg cr) %{\n-  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n+instruct minmax_reductionD_av(legRegD dst, legVec src, legVec tmp1, legVec tmp2, legVec tmp3,\n+                              legVec tmp4, legVec tmp5, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n@@ -5464,0 +5410,69 @@\n+instruct minmax_reduction2D_avx10(regD dst, immD src1, vec src2, vec xtmp1) %{\n+  predicate(VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n+            ((n->Opcode() == Op_MinReductionV && n->in(1)->bottom_type() == TypeD::POS_INF) ||\n+             (n->Opcode() == Op_MaxReductionV && n->in(1)->bottom_type() == TypeD::NEG_INF)) &&\n+            Matcher::vector_length(n->in(2)) == 2);\n+  match(Set dst (MinReductionV src1 src2));\n+  match(Set dst (MaxReductionV src1 src2));\n+  effect(TEMP dst, TEMP xtmp1);\n+  format %{ \"vector_minmax2D_reduction $dst, $src1, $src2 ; using $xtmp1 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen = Matcher::vector_length(this, $src2);\n+    __ reduceDoubleMinMax(opcode, vlen, false, $dst$$XMMRegister, $src2$$XMMRegister, xnoreg,\n+                          xnoreg, xnoreg, $xtmp1$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct minmax_reductionD_avx10(regD dst, immD src1, vec src2, vec xtmp1, vec xtmp2) %{\n+  predicate(VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n+            ((n->Opcode() == Op_MinReductionV && n->in(1)->bottom_type() == TypeD::POS_INF) ||\n+             (n->Opcode() == Op_MaxReductionV && n->in(1)->bottom_type() == TypeD::NEG_INF)) &&\n+            Matcher::vector_length(n->in(2)) >= 4);\n+  match(Set dst (MinReductionV src1 src2));\n+  match(Set dst (MaxReductionV src1 src2));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vector_minmaxD_reduction $dst, $src1, $src2 ; using $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen = Matcher::vector_length(this, $src2);\n+    __ reduceDoubleMinMax(opcode, vlen, false, $dst$$XMMRegister, $src2$$XMMRegister, xnoreg, xnoreg,\n+                          xnoreg, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\n+instruct minmax_reduction2D_av_avx10(regD dst, vec src, vec xtmp1) %{\n+  predicate(VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n+            Matcher::vector_length(n->in(2)) == 2);\n+  match(Set dst (MinReductionV dst src));\n+  match(Set dst (MaxReductionV dst src));\n+  effect(TEMP dst, TEMP xtmp1);\n+  format %{ \"vector_minmax2D_reduction $dst, $src ; using $xtmp1 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen = Matcher::vector_length(this, $src);\n+    __ reduceDoubleMinMax(opcode, vlen, true, $dst$$XMMRegister, $src$$XMMRegister,\n+                          xnoreg, xnoreg, xnoreg, $xtmp1$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct minmax_reductionD_av_avx10(regD dst, vec src, vec xtmp1, vec xtmp2) %{\n+  predicate(VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n+            Matcher::vector_length(n->in(2)) >= 4);\n+  match(Set dst (MinReductionV dst src));\n+  match(Set dst (MaxReductionV dst src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vector_minmaxD_reduction $dst, $src ; using $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen = Matcher::vector_length(this, $src);\n+    __ reduceDoubleMinMax(opcode, vlen, true, $dst$$XMMRegister, $src$$XMMRegister,\n+                          xnoreg, xnoreg, xnoreg, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -6350,0 +6365,16 @@\n+\/\/ Float\/Double vector Min\/Max\n+instruct minmaxFP_avx10_reg(vec dst, vec a, vec b) %{\n+  predicate(VM_Version::supports_avx10_2() &&\n+            is_floating_point_type(Matcher::vector_element_basic_type(n))); \/\/ T_FLOAT, T_DOUBLE\n+  match(Set dst (MinV a b));\n+  match(Set dst (MaxV a b));\n+  format %{ \"vector_minmaxFP  $dst, $a, $b\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int opcode = this->ideal_Opcode();\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vminmax_fp(opcode, elem_bt, $dst$$XMMRegister, k0, $a$$XMMRegister, $b$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -6352,1 +6383,1 @@\n-  predicate(Matcher::vector_length_in_bytes(n) <= 32 &&\n+  predicate(!VM_Version::supports_avx10_2() && Matcher::vector_length_in_bytes(n) <= 32 &&\n@@ -6373,2 +6404,2 @@\n-instruct evminmaxFP_reg_eavx(vec dst, vec a, vec b, vec atmp, vec btmp, kReg ktmp) %{\n-  predicate(Matcher::vector_length_in_bytes(n) == 64 &&\n+instruct evminmaxFP_reg_evex(vec dst, vec a, vec b, vec atmp, vec btmp, kReg ktmp) %{\n+  predicate(!VM_Version::supports_avx10_2() && Matcher::vector_length_in_bytes(n) == 64 &&\n@@ -10689,0 +10720,13 @@\n+instruct scalar_minmax_HF_avx10_reg(regF dst, regF src1, regF src2)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (MaxHF src1 src2));\n+  match(Set dst (MinHF src1 src2));\n+  format %{ \"scalar_min_max_fp16 $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int function = this->ideal_Opcode() == Op_MinHF ? AVX10_MINMAX_MIN_COMPARE_SIGN : AVX10_MINMAX_MAX_COMPARE_SIGN;\n+    __ eminmaxsh($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, function);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -10691,0 +10735,1 @@\n+  predicate(!VM_Version::supports_avx10_2());\n@@ -10790,0 +10835,28 @@\n+instruct vector_minmax_HF_avx10_mem(vec dst, vec src1, memory src2)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (MinVHF src1 (VectorReinterpret (LoadVector src2))));\n+  match(Set dst (MaxVHF src1 (VectorReinterpret (LoadVector src2))));\n+  format %{ \"vector_min_max_fp16_mem $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int function =  this->ideal_Opcode() == Op_MinVHF ? AVX10_MINMAX_MIN_COMPARE_SIGN : AVX10_MINMAX_MAX_COMPARE_SIGN;\n+    __ evminmaxph($dst$$XMMRegister, k0, $src1$$XMMRegister, $src2$$Address, true, function, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_minmax_HF_avx10_reg(vec dst, vec src1, vec src2)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (MinVHF src1 src2));\n+  match(Set dst (MaxVHF src1 src2));\n+  format %{ \"vector_min_max_fp16 $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int function =  this->ideal_Opcode() == Op_MinVHF ? AVX10_MINMAX_MIN_COMPARE_SIGN : AVX10_MINMAX_MAX_COMPARE_SIGN;\n+    __ evminmaxph($dst$$XMMRegister, k0, $src1$$XMMRegister, $src2$$XMMRegister, true, function, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -10792,0 +10865,1 @@\n+  predicate(!VM_Version::supports_avx10_2());\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":239,"deletions":165,"binary":false,"changes":404,"status":"modified"},{"patch":"@@ -1862,2 +1862,1 @@\n-    \/\/ No relocation needed\n-    __ mov64(r10, (int64_t) $meth$$method);\n+    __ lea(r10, RuntimeAddress((address)$meth$$method));\n@@ -2059,0 +2058,4 @@\n+\/\/ Whether this node is expanded during code emission into a sequence of\n+\/\/ instructions and the first instruction can perform an implicit null check.\n+ins_attrib ins_is_late_expanded_null_check_candidate(false);\n+\n@@ -4453,0 +4456,11 @@\n+\/\/ max = java.lang.Math.max(float a, float b)\n+instruct maxF_avx10_reg(regF dst, regF a, regF b) %{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (MaxF a b));\n+  format %{ \"maxF $dst, $a, $b\" %}\n+  ins_encode %{\n+    __ eminmaxss($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_MINMAX_MAX_COMPARE_SIGN);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -4455,1 +4469,1 @@\n-  predicate(UseAVX > 0 && !VLoopReductions::is_reduction(n));\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && !VLoopReductions::is_reduction(n));\n@@ -4466,1 +4480,1 @@\n-  predicate(UseAVX > 0 && VLoopReductions::is_reduction(n));\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && VLoopReductions::is_reduction(n));\n@@ -4478,0 +4492,11 @@\n+\/\/ max = java.lang.Math.max(double a, double b)\n+instruct maxD_avx10_reg(regD dst, regD a, regD b) %{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (MaxD a b));\n+  format %{ \"maxD $dst, $a, $b\" %}\n+  ins_encode %{\n+    __ eminmaxsd($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_MINMAX_MAX_COMPARE_SIGN);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -4480,1 +4505,1 @@\n-  predicate(UseAVX > 0 && !VLoopReductions::is_reduction(n));\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && !VLoopReductions::is_reduction(n));\n@@ -4491,1 +4516,1 @@\n-  predicate(UseAVX > 0 && VLoopReductions::is_reduction(n));\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && VLoopReductions::is_reduction(n));\n@@ -4503,0 +4528,11 @@\n+\/\/ max = java.lang.Math.min(float a, float b)\n+instruct minF_avx10_reg(regF dst, regF a, regF b) %{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (MinF a b));\n+  format %{ \"minF $dst, $a, $b\" %}\n+  ins_encode %{\n+    __ eminmaxss($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_MINMAX_MIN_COMPARE_SIGN);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -4505,1 +4541,1 @@\n-  predicate(UseAVX > 0 && !VLoopReductions::is_reduction(n));\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && !VLoopReductions::is_reduction(n));\n@@ -4516,1 +4552,1 @@\n-  predicate(UseAVX > 0 && VLoopReductions::is_reduction(n));\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && VLoopReductions::is_reduction(n));\n@@ -4528,0 +4564,11 @@\n+\/\/ max = java.lang.Math.min(double a, double b)\n+instruct minD_avx10_reg(regD dst, regD a, regD b) %{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (MinD a b));\n+  format %{ \"minD $dst, $a, $b\" %}\n+  ins_encode %{\n+    __ eminmaxsd($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_MINMAX_MIN_COMPARE_SIGN);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -4530,1 +4577,1 @@\n-  predicate(UseAVX > 0 && !VLoopReductions::is_reduction(n));\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && !VLoopReductions::is_reduction(n));\n@@ -4541,1 +4588,1 @@\n-  predicate(UseAVX > 0 && VLoopReductions::is_reduction(n));\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && VLoopReductions::is_reduction(n));\n@@ -6382,1 +6429,1 @@\n-instruct cmovI_rReg_rReg_memUCF_ndd(rRegI dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegI src1, memory src2) \n+instruct cmovI_rReg_rReg_memUCF_ndd(rRegI dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegI src1, memory src2)\n@@ -6765,1 +6812,1 @@\n-instruct cmovL_regUCF_ndd(rRegL dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegL src1, rRegL src2) \n+instruct cmovL_regUCF_ndd(rRegL dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegL src1, rRegL src2)\n@@ -6872,1 +6919,1 @@\n-instruct cmovL_rReg_rReg_memUCF_ndd(rRegL dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegL src1, memory src2) \n+instruct cmovL_rReg_rReg_memUCF_ndd(rRegL dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegL src1, memory src2)\n@@ -7059,15 +7106,0 @@\n-instruct addI_rReg_mem_rReg_ndd(rRegI dst, memory src1, rRegI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (AddI (LoadI src1) src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  ins_cost(150);\n-  format %{ \"eaddl    $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eaddl($dst$$Register, $src1$$Address, $src2$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n@@ -7377,15 +7409,0 @@\n-instruct addL_rReg_mem_rReg_ndd(rRegL dst, memory src1, rRegL src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (AddL (LoadL src1) src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  ins_cost(150);\n-  format %{ \"eaddq    $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eaddq($dst$$Register, $src1$$Address, $src2$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n@@ -8603,1 +8620,0 @@\n-  predicate(!UseAPX);\n@@ -8615,14 +8631,0 @@\n-instruct mulI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (MulI src1 src2));\n-  effect(KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"eimull   $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eimull($dst$$Register, $src1$$Register, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n@@ -8659,1 +8661,0 @@\n-  predicate(!UseAPX);\n@@ -8671,14 +8672,0 @@\n-instruct mulI_rReg_mem_imm(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (MulI (LoadI src1) src2));\n-  effect(KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"eimull   $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eimull($dst$$Register, $src1$$Address, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg_mem_alu0);\n-%}\n-\n@@ -8725,1 +8712,0 @@\n-  predicate(!UseAPX);\n@@ -8737,14 +8723,0 @@\n-instruct mulL_rReg_rReg_imm_ndd(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (MulL src1 src2));\n-  effect(KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"eimulq   $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eimulq($dst$$Register, $src1$$Register, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n@@ -8781,1 +8753,0 @@\n-  predicate(!UseAPX);\n@@ -8793,14 +8764,0 @@\n-instruct mulL_rReg_mem_imm_ndd(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (MulL (LoadL src1) src2));\n-  effect(KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"eimulq   $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eimulq($dst$$Register, $src1$$Address, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg_mem_alu0);\n-%}\n-\n@@ -10624,1 +10581,2 @@\n-  predicate(!UseAPX);\n+  \/\/ Strict predicate check to make selection of xorI_rReg_im1 cost agnostic if immI src is -1.\n+  predicate(!UseAPX && n->in(2)->bottom_type()->is_int()->get_con() != -1);\n@@ -10638,1 +10596,2 @@\n-  predicate(UseAPX);\n+  \/\/ Strict predicate check to make selection of xorI_rReg_im1_ndd cost agnostic if immI src2 is -1.\n+  predicate(UseAPX && n->in(2)->bottom_type()->is_int()->get_con() != -1);\n@@ -10656,0 +10615,1 @@\n+  ins_cost(150);\n@@ -10696,15 +10656,0 @@\n-instruct xorI_rReg_mem_rReg_ndd(rRegI dst, memory src1, rRegI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (XorI (LoadI src1) src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"exorl    $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ exorl($dst$$Register, $src1$$Address, $src2$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n@@ -10890,15 +10835,0 @@\n-instruct andL_rReg_mem_rReg_ndd(rRegL dst, memory src1, rRegL src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (AndL (LoadL src1) src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"eandq    $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eandq($dst$$Register, $src1$$Address, $src2$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n@@ -11328,1 +11258,2 @@\n-  predicate(!UseAPX);\n+  \/\/ Strict predicate check to make selection of xorL_rReg_im1 cost agnostic if immL32 src is -1.\n+  predicate(!UseAPX && n->in(2)->bottom_type()->is_long()->get_con() != -1L);\n@@ -11342,1 +11273,2 @@\n-  predicate(UseAPX);\n+  \/\/ Strict predicate check to make selection of xorL_rReg_im1_ndd cost agnostic if immL32 src2 is -1.\n+  predicate(UseAPX && n->in(2)->bottom_type()->is_long()->get_con() != -1L);\n@@ -11361,0 +11293,1 @@\n+  ins_cost(150);\n@@ -11400,15 +11333,0 @@\n-instruct xorL_rReg_mem_rReg_ndd(rRegL dst, memory src1, rRegL src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (XorL (LoadL src1) src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"exorq    $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ exorq($dst$$Register, $src1$$Address, $src2$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n@@ -14725,0 +14643,18 @@\n+peephole\n+%{\n+  peepmatch (leaPCompressedOopOffset);\n+  peepprocedure (lea_remove_redundant);\n+%}\n+\n+peephole\n+%{\n+  peepmatch (leaP8Narrow);\n+  peepprocedure (lea_remove_redundant);\n+%}\n+\n+peephole\n+%{\n+  peepmatch (leaP32Narrow);\n+  peepprocedure (lea_remove_redundant);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":88,"deletions":152,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(StubId id, address call_ptr) {\n@@ -115,1 +115,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(StubId id, address destination) {\n@@ -119,1 +119,1 @@\n-RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+RuntimeStub* SharedRuntime::generate_throw_exception(StubId id, address runtime_entry) {\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -181,0 +181,4 @@\n+  void generate_preuniverse_stubs() {\n+    StubRoutines::_fence_entry               = ShouldNotCallThisStub();\n+  }\n+\n@@ -197,1 +201,0 @@\n-    StubRoutines::_fence_entry               = ShouldNotCallThisStub();\n@@ -215,1 +218,1 @@\n-  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+  StubGenerator(CodeBuffer* code, BlobId blob_id) : StubCodeGenerator(code, blob_id) {\n@@ -217,1 +220,4 @@\n-    case initial_id:\n+    case BlobId::stubgen_preuniverse_id:\n+      generate_preuniverse_stubs();\n+      break;\n+    case BlobId::stubgen_initial_id:\n@@ -220,1 +226,1 @@\n-     case continuation_id:\n+     case BlobId::stubgen_continuation_id:\n@@ -223,1 +229,1 @@\n-    case compiler_id:\n+    case BlobId::stubgen_compiler_id:\n@@ -226,1 +232,1 @@\n-    case final_id:\n+    case BlobId::stubgen_final_id:\n@@ -230,1 +236,1 @@\n-      fatal(\"unexpected blob id: %d\", blob_id);\n+      fatal(\"unexpected blob id: %s\", StubInfo::name(blob_id));\n@@ -236,1 +242,1 @@\n-void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+void StubGenerator_generate(CodeBuffer* code, BlobId blob_id) {\n","filename":"src\/hotspot\/cpu\/zero\/stubGenerator_zero.cpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-static const char* sem_init_strerror(kern_return_t value) {\n+static const char* sem_strerror(kern_return_t value) {\n@@ -36,3 +36,7 @@\n-    case KERN_INVALID_ARGUMENT:  return \"Invalid argument\";\n-    case KERN_RESOURCE_SHORTAGE: return \"Resource shortage\";\n-    default:                     return \"Unknown\";\n+    case KERN_INVALID_ARGUMENT:    return \"Invalid argument\";\n+    case KERN_RESOURCE_SHORTAGE:   return \"Resource shortage\";\n+    case KERN_TERMINATED:          return \"Resource has been destroyed\";\n+    case KERN_ABORTED:             return \"Operation was aborted\";\n+    case KERN_INVALID_VALUE:       return \"Invalid time specified\";\n+    case KERN_OPERATION_TIMED_OUT: return \"Operation timed-out\";\n+    default:                       return \"Unknown\";\n@@ -45,1 +49,2 @@\n-  guarantee(ret == KERN_SUCCESS, \"Failed to create semaphore: %s\", sem_init_strerror(ret));\n+  guarantee(ret == KERN_SUCCESS, \"Failed to create semaphore: %s (0x%x)\",\n+            sem_strerror(ret), (uint)ret);\n@@ -56,1 +61,2 @@\n-    assert(ret == KERN_SUCCESS, \"Failed to signal semaphore\");\n+    assert(ret == KERN_SUCCESS, \"Failed to signal semaphore: %s (0x%x)\",\n+           sem_strerror(ret), (uint)ret);\n@@ -65,1 +71,2 @@\n-  assert(ret == KERN_SUCCESS, \"Failed to wait on semaphore\");\n+  assert(ret == KERN_SUCCESS, \"Failed to wait on semaphore: %s (0x%x)\",\n+         sem_strerror(ret), (uint)ret);\n@@ -103,0 +110,4 @@\n+  assert(kr == KERN_SUCCESS || kr == KERN_OPERATION_TIMED_OUT,\n+         \"Failed to timed-wait on semaphore: %s (0x%x)\",\n+         sem_strerror(kr), (uint)kr);\n+\n","filename":"src\/hotspot\/os\/bsd\/semaphore_bsd.cpp","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"interpreter\/interpreter.hpp\"\n@@ -61,0 +62,1 @@\n+#include \"porting_aix.hpp\"\n@@ -78,0 +80,1 @@\n+#include <sys\/resource.h>\n@@ -1062,0 +1065,89 @@\n+static char saved_jvm_path[MAXPATHLEN] = {0};\n+\n+\/\/ Find the full path to the current module, libjvm.so\n+void os::jvm_path(char *buf, jint buflen) {\n+  \/\/ Error checking.\n+  if (buflen < MAXPATHLEN) {\n+    assert(false, \"must use a large-enough buffer\");\n+    buf[0] = '\\0';\n+    return;\n+  }\n+  \/\/ Lazy resolve the path to current module.\n+  if (saved_jvm_path[0] != 0) {\n+    strcpy(buf, saved_jvm_path);\n+    return;\n+  }\n+\n+  const char* fname;\n+#ifdef AIX\n+  Dl_info dlinfo;\n+  int ret = dladdr(CAST_FROM_FN_PTR(void *, os::jvm_path), &dlinfo);\n+  assert(ret != 0, \"cannot locate libjvm\");\n+  if (ret == 0) {\n+    return;\n+  }\n+  fname = dlinfo.dli_fname;\n+#else\n+  char dli_fname[MAXPATHLEN];\n+  dli_fname[0] = '\\0';\n+  bool ret = dll_address_to_library_name(\n+                                         CAST_FROM_FN_PTR(address, os::jvm_path),\n+                                         dli_fname, sizeof(dli_fname), nullptr);\n+  assert(ret, \"cannot locate libjvm\");\n+  if (!ret) {\n+    return;\n+  }\n+  fname = dli_fname;\n+#endif \/\/ AIX\n+  char* rp = nullptr;\n+  if (fname[0] != '\\0') {\n+    rp = os::realpath(fname, buf, buflen);\n+  }\n+  if (rp == nullptr) {\n+    return;\n+  }\n+\n+  \/\/ If executing unit tests we require JAVA_HOME to point to the real JDK.\n+  if (Arguments::executing_unit_tests()) {\n+    \/\/ Look for JAVA_HOME in the environment.\n+    char* java_home_var = ::getenv(\"JAVA_HOME\");\n+    if (java_home_var != nullptr && java_home_var[0] != 0) {\n+\n+      \/\/ Check the current module name \"libjvm.so\".\n+      const char* p = strrchr(buf, '\/');\n+      if (p == nullptr) {\n+        return;\n+      }\n+      assert(strstr(p, \"\/libjvm\") == p, \"invalid library name\");\n+\n+      stringStream ss(buf, buflen);\n+      rp = os::realpath(java_home_var, buf, buflen);\n+      if (rp == nullptr) {\n+        return;\n+      }\n+\n+      assert((int)strlen(buf) < buflen, \"Ran out of buffer room\");\n+      ss.print(\"%s\/lib\", buf);\n+\n+      \/\/ If the path exists within JAVA_HOME, add the VM variant directory and JVM\n+      \/\/ library name to complete the path to JVM being overridden.  Otherwise fallback\n+      \/\/ to the path to the current library.\n+      if (0 == access(buf, F_OK)) {\n+        \/\/ Use current module name \"libjvm.so\"\n+        ss.print(\"\/%s\/libjvm%s\", Abstract_VM_Version::vm_variant(), JNI_LIB_SUFFIX);\n+        assert(strcmp(buf + strlen(buf) - strlen(JNI_LIB_SUFFIX), JNI_LIB_SUFFIX) == 0,\n+               \"buf has been truncated\");\n+      } else {\n+        \/\/ Go back to path of .so\n+        rp = os::realpath(fname, buf, buflen);\n+        if (rp == nullptr) {\n+          return;\n+        }\n+      }\n+    }\n+  }\n+\n+  strncpy(saved_jvm_path, buf, MAXPATHLEN);\n+  saved_jvm_path[MAXPATHLEN - 1] = '\\0';\n+}\n+\n@@ -1333,0 +1425,9 @@\n+#ifdef ASSERT\n+bool os::Posix::ucontext_is_interpreter(const ucontext_t* uc) {\n+  assert(uc != nullptr, \"invariant\");\n+  address pc = os::Posix::ucontext_get_pc(uc);\n+  assert(pc != nullptr, \"invariant\");\n+  return Interpreter::contains(pc);\n+}\n+#endif\n+\n@@ -1502,1 +1603,10 @@\n-bool os::supports_vtime() { return true; }\n+double os::elapsed_process_cpu_time() {\n+  struct rusage usage;\n+  int retval = getrusage(RUSAGE_SELF, &usage);\n+  if (retval == 0) {\n+    return usage.ru_utime.tv_sec + usage.ru_stime.tv_sec +\n+         (usage.ru_utime.tv_usec + usage.ru_stime.tv_usec) \/ (1000.0 * 1000.0);\n+  } else {\n+    return -1;\n+  }\n+}\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":111,"deletions":1,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-#include \"runtime\/statSampler.hpp\"\n@@ -760,2 +759,3 @@\n-  int limit = 3;\n-  do {\n+  int trials_remaining = 4;\n+  DWORD next_delay_ms = 1;\n+  while (true) {\n@@ -769,1 +769,17 @@\n-  } while (thread_handle == nullptr && errno == EAGAIN && limit-- > 0);\n+\n+    if (thread_handle != nullptr) {\n+      break;\n+    }\n+\n+    if (errno != EAGAIN) {\n+      break;\n+    }\n+\n+    if (--trials_remaining <= 0) {\n+      break;\n+    }\n+\n+    log_debug(os, thread)(\"Failed to start native thread (%s), retrying after %dms.\", os::errno_name(errno), next_delay_ms);\n+    Sleep(next_delay_ms);\n+    next_delay_ms *= 2;\n+  }\n@@ -1181,5 +1197,3 @@\n-bool os::supports_vtime() { return true; }\n-\n-double os::elapsedVTime() {\n-  FILETIME created;\n-  FILETIME exited;\n+double os::elapsed_process_cpu_time() {\n+  FILETIME create;\n+  FILETIME exit;\n@@ -1188,5 +1202,13 @@\n-  if (GetThreadTimes(GetCurrentThread(), &created, &exited, &kernel, &user) != 0) {\n-    \/\/ the resolution of windows_to_java_time() should be sufficient (ms)\n-    return (double) (windows_to_java_time(kernel) + windows_to_java_time(user)) \/ MILLIUNITS;\n-  } else {\n-    return elapsedTime();\n+\n+  if (GetProcessTimes(GetCurrentProcess(), &create, &exit, &kernel, &user) == 0) {\n+    return -1;\n+  }\n+\n+  SYSTEMTIME user_total;\n+  if (FileTimeToSystemTime(&user, &user_total) == 0) {\n+    return -1;\n+  }\n+\n+  SYSTEMTIME kernel_total;\n+  if (FileTimeToSystemTime(&kernel, &kernel_total) == 0) {\n+    return -1;\n@@ -1194,0 +1216,11 @@\n+\n+  double user_seconds =\n+      double(user_total.wHour) * 3600.0 + double(user_total.wMinute) * 60.0 +\n+      double(user_total.wSecond) + double(user_total.wMilliseconds) \/ 1000.0;\n+\n+  double kernel_seconds = double(kernel_total.wHour) * 3600.0 +\n+                          double(kernel_total.wMinute) * 60.0 +\n+                          double(kernel_total.wSecond) +\n+                          double(kernel_total.wMilliseconds) \/ 1000.0;\n+\n+  return user_seconds + kernel_seconds;\n@@ -2739,13 +2772,0 @@\n-#ifdef _M_ARM64\n-    if (in_java &&\n-        (exception_code == EXCEPTION_ILLEGAL_INSTRUCTION ||\n-          exception_code == EXCEPTION_ILLEGAL_INSTRUCTION_2)) {\n-      if (nativeInstruction_at(pc)->is_sigill_not_entrant()) {\n-        if (TraceTraps) {\n-          tty->print_cr(\"trap: not_entrant\");\n-        }\n-        return Handle_Exception(exceptionInfo, SharedRuntime::get_handle_wrong_method_stub());\n-      }\n-    }\n-#endif\n-\n@@ -4612,0 +4632,57 @@\n+\/\/ This method checks if a wide path is actually a symbolic link\n+static bool is_symbolic_link(const wchar_t* wide_path) {\n+  WIN32_FIND_DATAW fd;\n+  HANDLE f = ::FindFirstFileW(wide_path, &fd);\n+  if (f != INVALID_HANDLE_VALUE) {\n+    const bool result = fd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT && fd.dwReserved0 == IO_REPARSE_TAG_SYMLINK;\n+    if (::FindClose(f) == 0) {\n+      errno = ::GetLastError();\n+      log_debug(os)(\"is_symbolic_link() failed to FindClose: GetLastError->%ld.\", errno);\n+    }\n+    return result;\n+  } else {\n+    errno = ::GetLastError();\n+    log_debug(os)(\"is_symbolic_link() failed to FindFirstFileW: GetLastError->%ld.\", errno);\n+    return false;\n+  }\n+}\n+\n+\/\/ This method dereferences a symbolic link\n+static WCHAR* get_path_to_target(const wchar_t* wide_path) {\n+  HANDLE hFile = CreateFileW(wide_path, GENERIC_READ, FILE_SHARE_READ, nullptr,\n+                             OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);\n+  if (hFile == INVALID_HANDLE_VALUE) {\n+    errno = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to CreateFileW: GetLastError->%ld.\", errno);\n+    return nullptr;\n+  }\n+\n+  \/\/ Returned value includes the terminating null character.\n+  const size_t target_path_size = ::GetFinalPathNameByHandleW(hFile, nullptr, 0,\n+                                                              FILE_NAME_NORMALIZED);\n+  if (target_path_size == 0) {\n+    errno = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to GetFinalPathNameByHandleW: GetLastError->%ld.\", errno);\n+    return nullptr;\n+  }\n+\n+  WCHAR* path_to_target = NEW_C_HEAP_ARRAY(WCHAR, target_path_size, mtInternal);\n+\n+  \/\/ The returned size is the length excluding the terminating null character.\n+  const size_t res = ::GetFinalPathNameByHandleW(hFile, path_to_target, static_cast<DWORD>(target_path_size),\n+                                                 FILE_NAME_NORMALIZED);\n+  if (res != target_path_size - 1) {\n+    errno = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to GetFinalPathNameByHandleW: GetLastError->%ld.\", errno);\n+    return nullptr;\n+  }\n+\n+  if (::CloseHandle(hFile) == 0) {\n+    errno = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to CloseHandle: GetLastError->%ld.\", errno);\n+    return nullptr;\n+  }\n+\n+  return path_to_target;\n+}\n+\n@@ -4680,0 +4757,14 @@\n+  const bool is_symlink = is_symbolic_link(wide_path);\n+  WCHAR* path_to_target = nullptr;\n+\n+  if (is_symlink) {\n+    path_to_target = get_path_to_target(wide_path);\n+    if (path_to_target == nullptr) {\n+      \/\/ it is a symbolic link, but we failed to resolve it,\n+      \/\/ errno has been set in the call to get_path_to_target(),\n+      \/\/ no need to overwrite it\n+      os::free(wide_path);\n+      return -1;\n+    }\n+  }\n+\n@@ -4681,2 +4772,1 @@\n-  BOOL bret = ::GetFileAttributesExW(wide_path, GetFileExInfoStandard, &file_data);\n-  os::free(wide_path);\n+  BOOL bret = ::GetFileAttributesExW(is_symlink ? path_to_target : wide_path, GetFileExInfoStandard, &file_data);\n@@ -4684,0 +4774,1 @@\n+  \/\/ if getting attributes failed, GetLastError should be called immediately after that\n@@ -4686,0 +4777,3 @@\n+    log_debug(os)(\"os::stat() failed to GetFileAttributesExW: GetLastError->%ld.\", errno);\n+    os::free(wide_path);\n+    os::free(path_to_target);\n@@ -4689,0 +4783,3 @@\n+  os::free(wide_path);\n+  os::free(path_to_target);\n+\n@@ -4873,2 +4970,17 @@\n-  int fd = ::_wopen(wide_path, oflag | O_BINARY | O_NOINHERIT, mode);\n-  os::free(wide_path);\n+  const bool is_symlink = is_symbolic_link(wide_path);\n+  WCHAR* path_to_target = nullptr;\n+\n+  if (is_symlink) {\n+    path_to_target = get_path_to_target(wide_path);\n+    if (path_to_target == nullptr) {\n+      \/\/ it is a symbolic link, but we failed to resolve it,\n+      \/\/ errno has been set in the call to get_path_to_target(),\n+      \/\/ no need to overwrite it\n+      os::free(wide_path);\n+      return -1;\n+    }\n+  }\n+\n+  int fd = ::_wopen(is_symlink ? path_to_target : wide_path, oflag | O_BINARY | O_NOINHERIT, mode);\n+\n+  \/\/ if opening files failed, GetLastError should be called immediately after that\n@@ -4878,0 +4990,1 @@\n+    log_debug(os)(\"os::open() failed to _wopen: GetLastError->%ld.\", errno);\n@@ -4879,0 +4992,2 @@\n+  os::free(wide_path);\n+  os::free(path_to_target);\n@@ -5731,18 +5846,4 @@\n-\/\/ returns true if thread could be suspended,\n-\/\/ false otherwise\n-static bool do_suspend(HANDLE* h) {\n-  if (h != nullptr) {\n-    if (SuspendThread(*h) != ~0) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-\/\/ resume the thread\n-\/\/ calling resume on an active thread is a no-op\n-static void do_resume(HANDLE* h) {\n-  if (h != nullptr) {\n-    ResumeThread(*h);\n-  }\n-}\n+\/\/ WINDOWS CONTEXT Flags for THREAD_SAMPLING\n+#if defined(AMD64) || defined(_M_ARM64)\n+  #define sampling_context_flags (CONTEXT_FULL | CONTEXT_FLOATING_POINT)\n+#endif\n@@ -5750,7 +5851,4 @@\n-\/\/ retrieve a suspend\/resume context capable handle\n-\/\/ from the tid. Caller validates handle return value.\n-void get_thread_handle_for_extended_context(HANDLE* h,\n-                                            DWORD tid) {\n-  if (h != nullptr) {\n-    *h = OpenThread(THREAD_SUSPEND_RESUME | THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION, FALSE, tid);\n-  }\n+\/\/ Retrieve a suspend\/resume context capable handle for the tid.\n+\/\/ Caller validates handle return value.\n+static inline HANDLE get_thread_handle_for_extended_context(DWORD tid) {\n+  return OpenThread(THREAD_SUSPEND_RESUME | THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION, FALSE, tid);\n@@ -5762,8 +5860,2 @@\n-  CONTEXT    ctxt;\n-  HANDLE     h = nullptr;\n-\n-  \/\/ get context capable handle for thread\n-  get_thread_handle_for_extended_context(&h, _thread->osthread()->thread_id());\n-\n-  \/\/ sanity\n-  if (h == nullptr || h == INVALID_HANDLE_VALUE) {\n+  const HANDLE h = get_thread_handle_for_extended_context(_thread->osthread()->thread_id());\n+  if (h == nullptr) {\n@@ -5772,11 +5864,9 @@\n-\n-  \/\/ suspend the thread\n-  if (do_suspend(&h)) {\n-    ctxt.ContextFlags = (CONTEXT_FULL | CONTEXT_FLOATING_POINT);\n-    \/\/ get thread context\n-    GetThreadContext(h, &ctxt);\n-    SuspendedThreadTaskContext context(_thread, &ctxt);\n-    \/\/ pass context to Thread Sampling impl\n-    do_task(context);\n-    \/\/ resume thread\n-    do_resume(&h);\n+  CONTEXT ctxt;\n+  ctxt.ContextFlags = sampling_context_flags;\n+  if (SuspendThread(h) != OS_ERR) {\n+    if (GetThreadContext(h, &ctxt)) {\n+      const SuspendedThreadTaskContext context(_thread, &ctxt);\n+      \/\/ Pass context to Thread Sampling implementation.\n+      do_task(context);\n+    }\n+    ResumeThread(h);\n@@ -5784,2 +5874,0 @@\n-\n-  \/\/ close handle\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":165,"deletions":77,"binary":false,"changes":242,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -267,1 +267,1 @@\n-  C1StubId         _stub_id;\n+  StubId           _stub_id;\n@@ -270,1 +270,1 @@\n-  NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, C1StubId stub_id);\n+  NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, StubId stub_id);\n@@ -518,1 +518,1 @@\n-  C1StubId         _stub;\n+  StubId           _stub;\n@@ -522,1 +522,1 @@\n-  SimpleExceptionStub(C1StubId stub, LIR_Opr obj, CodeEmitInfo* info):\n+  SimpleExceptionStub(StubId stub, LIR_Opr obj, CodeEmitInfo* info):\n@@ -549,1 +549,1 @@\n-  ArrayStoreExceptionStub(LIR_Opr obj, CodeEmitInfo* info): SimpleExceptionStub(C1StubId::throw_array_store_exception_id, obj, info) {}\n+  ArrayStoreExceptionStub(LIR_Opr obj, CodeEmitInfo* info): SimpleExceptionStub(StubId::c1_throw_array_store_exception_id, obj, info) {}\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-  return Compilation::desired_max_code_buffer_size() + Compilation::desired_max_constant_size();\n+  return Compilation::desired_max_code_buffer_size + Compilation::desired_max_constant_size;\n@@ -90,2 +90,1 @@\n-  \/\/ setup CodeBuffer.  Preallocate a BufferBlob of size\n-  \/\/ NMethodSizeLimit plus some extra space for constants.\n+  \/\/ Setup CodeBuffer.\n@@ -145,1 +144,1 @@\n-  case vmIntrinsics::_Reference_get:\n+  case vmIntrinsics::_Reference_get0:\n@@ -171,0 +170,1 @@\n+  case vmIntrinsics::_dcbrt:\n@@ -240,1 +240,1 @@\n-#if defined(X86) || defined(AARCH64) || defined(S390) || defined(RISCV) || defined(PPC64)\n+#if defined(X86) || defined(AARCH64) || defined(S390) || defined(RISCV64) || defined(PPC64)\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -353,1 +353,1 @@\n-#if defined(X86) || defined(AARCH64) || defined(S390) || defined(RISCV) || defined(PPC64)\n+#if defined(X86) || defined(AARCH64) || defined(S390) || defined(RISCV64) || defined(PPC64)\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -626,1 +626,0 @@\n-  if (!GenerateSynchronizationCode) return;\n@@ -636,1 +635,0 @@\n-  if (!GenerateSynchronizationCode) return;\n@@ -661,1 +659,1 @@\n-    C1StubId stub_id = klass->is_initialized() ? C1StubId::fast_new_instance_id : C1StubId::fast_new_instance_init_check_id;\n+    StubId stub_id = klass->is_initialized() ? StubId::c1_fast_new_instance_id : StubId::c1_fast_new_instance_init_check_id;\n@@ -672,1 +670,1 @@\n-    CodeStub* slow_path = new NewInstanceStub(klass_reg, dst, klass, info, C1StubId::new_instance_id);\n+    CodeStub* slow_path = new NewInstanceStub(klass_reg, dst, klass, info, StubId::c1_new_instance_id);\n@@ -1188,1 +1186,1 @@\n-void LIRGenerator::do_Reference_get(Intrinsic* x) {\n+void LIRGenerator::do_Reference_get0(Intrinsic* x) {\n@@ -1399,1 +1397,1 @@\n-               CAST_FROM_FN_PTR(address, Runtime1::entry_for(C1StubId::register_finalizer_id)),\n+               CAST_FROM_FN_PTR(address, Runtime1::entry_for(StubId::c1_register_finalizer_id)),\n@@ -2588,1 +2586,1 @@\n-    if (method()->is_synchronized() && GenerateSynchronizationCode) {\n+    if (method()->is_synchronized()) {\n@@ -2873,0 +2871,1 @@\n+  case vmIntrinsics::_dcbrt :         \/\/ fall through\n@@ -2916,2 +2915,2 @@\n-  case vmIntrinsics::_Reference_get:\n-    do_Reference_get(x);\n+  case vmIntrinsics::_Reference_get0:\n+    do_Reference_get0(x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -64,0 +65,1 @@\n+#include \"runtime\/stubInfo.hpp\"\n@@ -105,8 +107,1 @@\n-\n-CodeBlob* Runtime1::_blobs[(int)C1StubId::NUM_STUBIDS];\n-\n-#define C1_BLOB_NAME_DEFINE(name)  \"C1 Runtime \" # name \"_blob\",\n-const char *Runtime1::_blob_names[] = {\n-  C1_STUBS_DO(C1_BLOB_NAME_DEFINE)\n-};\n-#undef C1_STUB_NAME_DEFINE\n+CodeBlob* Runtime1::_blobs[StubInfo::C1_STUB_COUNT];\n@@ -190,1 +185,1 @@\n-class C1StubIdStubAssemblerCodeGenClosure: public StubAssemblerCodeGenClosure {\n+class C1StubAssemblerCodeGenClosure: public StubAssemblerCodeGenClosure {\n@@ -192,1 +187,1 @@\n-  C1StubId _id;\n+  StubId _id;\n@@ -194,1 +189,3 @@\n-  C1StubIdStubAssemblerCodeGenClosure(C1StubId id) : _id(id) {}\n+  C1StubAssemblerCodeGenClosure(StubId id) : _id(id) {\n+    assert(StubInfo::is_c1(_id), \"not a c1 stub id %s\", StubInfo::name(_id));\n+  }\n@@ -200,1 +197,8 @@\n-CodeBlob* Runtime1::generate_blob(BufferBlob* buffer_blob, C1StubId id, const char* name, bool expect_oop_map, StubAssemblerCodeGenClosure* cl) {\n+CodeBlob* Runtime1::generate_blob(BufferBlob* buffer_blob, StubId id, const char* name, bool expect_oop_map, StubAssemblerCodeGenClosure* cl) {\n+  if (id != StubId::NO_STUBID) {\n+    CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C1Blob, StubInfo::blob(id));\n+    if (blob != nullptr) {\n+      return blob;\n+    }\n+  }\n+\n@@ -234,0 +238,3 @@\n+  if (blob != nullptr && (int)id >= 0) {\n+    AOTCodeCache::store_code_blob(*blob, AOTCodeEntry::C1Blob, StubInfo::blob(id));\n+  }\n@@ -237,2 +244,2 @@\n-bool Runtime1::generate_blob_for(BufferBlob* buffer_blob, C1StubId id) {\n-  assert(C1StubId::NO_STUBID < id && id < C1StubId::NUM_STUBIDS, \"illegal stub id\");\n+bool Runtime1::generate_blob_for(BufferBlob* buffer_blob, StubId id) {\n+  assert(StubInfo::is_c1(id), \"not a c1 stub %s\", StubInfo::name(id));\n@@ -244,6 +251,6 @@\n-  case C1StubId::dtrace_object_alloc_id:\n-  case C1StubId::slow_subtype_check_id:\n-  case C1StubId::fpu2long_stub_id:\n-  case C1StubId::unwind_exception_id:\n-  case C1StubId::counter_overflow_id:\n-  case C1StubId::is_instance_of_id:\n+  case StubId::c1_dtrace_object_alloc_id:\n+  case StubId::c1_slow_subtype_check_id:\n+  case StubId::c1_fpu2long_stub_id:\n+  case StubId::c1_unwind_exception_id:\n+  case StubId::c1_counter_overflow_id:\n+  case StubId::c1_is_instance_of_id:\n@@ -256,1 +263,1 @@\n-  C1StubIdStubAssemblerCodeGenClosure cl(id);\n+  C1StubAssemblerCodeGenClosure cl(id);\n@@ -259,1 +266,2 @@\n-  _blobs[(int)id] = blob;\n+  int idx = StubInfo::c1_offset(id);   \/\/ will assert on non-c1 id\n+  _blobs[idx] = blob;\n@@ -266,4 +274,5 @@\n-  \/\/ generate stubs\n-  int limit = (int)C1StubId::NUM_STUBIDS;\n-  for (int id = 0; id < limit; id++) {\n-    if (!generate_blob_for(blob, (C1StubId) id)) {\n+  \/\/ iterate blobs in C1 group and generate a single stub per blob\n+  StubId id = StubInfo::stub_base(StubGroup::C1);\n+  StubId limit = StubInfo::next(StubInfo::stub_max(StubGroup::C1));\n+  for (; id != limit; id = StubInfo::next(id)) {\n+    if (!generate_blob_for(blob, id)) {\n@@ -272,0 +281,4 @@\n+    if (id == StubId::c1_forward_exception_id) {\n+      \/\/ publish early c1 stubs at this point so later stubs can refer to them\n+      AOTCodeCache::init_early_c1_table();\n+    }\n@@ -277,4 +290,6 @@\n-    for (int id = 0; id < limit; id++) {\n-      _blobs[id]->print();\n-      if (_blobs[id]->oop_maps() != nullptr) {\n-        _blobs[id]->oop_maps()->print();\n+    id = StubInfo::stub_base(StubGroup::C1);\n+    for (; id != limit; id = StubInfo::next(id)) {\n+      CodeBlob* blob = blob_for(id);\n+      blob->print();\n+      if (blob->oop_maps() != nullptr) {\n+        blob->oop_maps()->print();\n@@ -289,3 +304,3 @@\n-CodeBlob* Runtime1::blob_for(C1StubId id) {\n-  assert(C1StubId::NO_STUBID < id && id < C1StubId::NUM_STUBIDS, \"illegal stub id\");\n-  return _blobs[(int)id];\n+CodeBlob* Runtime1::blob_for(StubId id) {\n+  int idx = StubInfo::c1_offset(id);   \/\/ will assert on non-c1 id\n+  return _blobs[idx];\n@@ -295,3 +310,2 @@\n-const char* Runtime1::name_for(C1StubId id) {\n-  assert(C1StubId::NO_STUBID < id && id < C1StubId::NUM_STUBIDS, \"illegal stub id\");\n-  return _blob_names[(int)id];\n+const char* Runtime1::name_for(StubId id) {\n+  return StubInfo::name(id);\n@@ -301,4 +315,5 @@\n-  int limit = (int)C1StubId::NUM_STUBIDS;\n-  for (int i = 0; i < limit; i++) {\n-    C1StubId id = (C1StubId)i;\n-    if (entry == entry_for(id)) return name_for(id);\n+  \/\/ iterate stubs starting from C1 group base\n+  StubId id = StubInfo::stub_base(StubGroup::C1);\n+  StubId limit = StubInfo::next(StubInfo::stub_max(StubGroup::C1));\n+  for (; id != limit; id = StubInfo::next(id)) {\n+    if (entry == entry_for(id)) return StubInfo::name(id);\n@@ -351,0 +366,1 @@\n+  FUNCTION_CASE(entry, StubRoutines::dcbrt());\n@@ -435,1 +451,1 @@\n-JRT_ENTRY(void, Runtime1::unimplemented_entry(JavaThread* current, C1StubId id))\n+JRT_ENTRY(void, Runtime1::unimplemented_entry(JavaThread* current, StubId id))\n@@ -494,1 +510,1 @@\n-  JRT_BLOCK\n+  JRT_BLOCK_NO_ASYNC\n@@ -535,2 +551,2 @@\n-  if (current->last_frame().cb() == Runtime1::blob_for(C1StubId::handle_exception_from_callee_id)) {\n-    \/\/ The C1StubId::handle_exception_from_callee_id handler is invoked after the\n+  if (current->last_frame().cb() == Runtime1::blob_for(StubId::c1_handle_exception_from_callee_id)) {\n+    \/\/ The StubId::c1_handle_exception_from_callee_id handler is invoked after the\n@@ -803,1 +819,1 @@\n-    if (nm->make_not_entrant(\"C1 deoptimize\")) {\n+    if (nm->make_not_entrant(nmethod::InvalidationReason::C1_DEOPTIMIZE)) {\n@@ -932,1 +948,1 @@\n-JRT_ENTRY(void, Runtime1::patch_code(JavaThread* current, C1StubId stub_id ))\n+JRT_ENTRY(void, Runtime1::patch_code(JavaThread* current, StubId stub_id ))\n@@ -969,1 +985,1 @@\n-    (stub_id == C1StubId::load_klass_patching_id || stub_id == C1StubId::load_mirror_patching_id);\n+    (stub_id == StubId::c1_load_klass_patching_id || stub_id == StubId::c1_load_mirror_patching_id);\n@@ -971,1 +987,1 @@\n-  if (stub_id == C1StubId::access_field_patching_id) {\n+  if (stub_id == StubId::c1_access_field_patching_id) {\n@@ -1054,1 +1070,1 @@\n-  } else if (stub_id == C1StubId::load_appendix_patching_id) {\n+  } else if (stub_id == StubId::c1_load_appendix_patching_id) {\n@@ -1095,1 +1111,1 @@\n-      nm->make_not_entrant(\"C1 code patch\");\n+      nm->make_not_entrant(nmethod::InvalidationReason::C1_CODEPATCH);\n@@ -1138,1 +1154,1 @@\n-                        p2i(instr_pc), (stub_id == C1StubId::access_field_patching_id) ? \"field\" : \"klass\");\n+                        p2i(instr_pc), (stub_id == StubId::c1_access_field_patching_id) ? \"field\" : \"klass\");\n@@ -1154,1 +1170,1 @@\n-        if (stub_id == C1StubId::access_field_patching_id) {\n+        if (stub_id == StubId::c1_access_field_patching_id) {\n@@ -1180,1 +1196,1 @@\n-            if (stub_id == C1StubId::load_klass_patching_id) {\n+            if (stub_id == StubId::c1_load_klass_patching_id) {\n@@ -1192,1 +1208,1 @@\n-        } else if (stub_id == C1StubId::load_appendix_patching_id) {\n+        } else if (stub_id == StubId::c1_load_appendix_patching_id) {\n@@ -1211,1 +1227,1 @@\n-              stub_id == C1StubId::load_appendix_patching_id) &&\n+              stub_id == StubId::c1_load_appendix_patching_id) &&\n@@ -1219,2 +1235,2 @@\n-                assert(stub_id == C1StubId::load_mirror_patching_id ||\n-                       stub_id == C1StubId::load_appendix_patching_id, \"wrong stub id\");\n+                assert(stub_id == StubId::c1_load_mirror_patching_id ||\n+                       stub_id == StubId::c1_load_appendix_patching_id, \"wrong stub id\");\n@@ -1225,1 +1241,1 @@\n-                assert(stub_id == C1StubId::load_klass_patching_id, \"wrong stub id\");\n+                assert(stub_id == StubId::c1_load_klass_patching_id, \"wrong stub id\");\n@@ -1248,1 +1264,1 @@\n-              stub_id == C1StubId::load_appendix_patching_id) {\n+              stub_id == StubId::c1_load_appendix_patching_id) {\n@@ -1250,1 +1266,1 @@\n-              (stub_id == C1StubId::load_klass_patching_id) ?\n+              (stub_id == StubId::c1_load_klass_patching_id) ?\n@@ -1284,3 +1300,3 @@\n-static bool is_patching_needed(JavaThread* current, C1StubId stub_id) {\n-  if (stub_id == C1StubId::load_klass_patching_id ||\n-      stub_id == C1StubId::load_mirror_patching_id) {\n+static bool is_patching_needed(JavaThread* current, StubId stub_id) {\n+  if (stub_id == StubId::c1_load_klass_patching_id ||\n+      stub_id == StubId::c1_load_mirror_patching_id) {\n@@ -1315,1 +1331,1 @@\n-void Runtime1::patch_code(JavaThread* current, C1StubId stub_id) {\n+void Runtime1::patch_code(JavaThread* current, StubId stub_id) {\n@@ -1343,1 +1359,1 @@\n-      nm->make_not_entrant(\"C1 deoptimize for patching\");\n+      nm->make_not_entrant(nmethod::InvalidationReason::C1_DEOPTIMIZE_FOR_PATCHING);\n@@ -1370,1 +1386,1 @@\n-    patch_code(current, C1StubId::load_klass_patching_id);\n+    patch_code(current, StubId::c1_load_klass_patching_id);\n@@ -1387,1 +1403,1 @@\n-    patch_code(current, C1StubId::load_mirror_patching_id);\n+    patch_code(current, StubId::c1_load_mirror_patching_id);\n@@ -1404,1 +1420,1 @@\n-    patch_code(current, C1StubId::load_appendix_patching_id);\n+    patch_code(current, StubId::c1_load_appendix_patching_id);\n@@ -1431,1 +1447,1 @@\n-    patch_code(current, C1StubId::access_field_patching_id);\n+    patch_code(current, StubId::c1_access_field_patching_id);\n@@ -1471,1 +1487,1 @@\n-  nm->make_not_entrant(\"C1 predicate failed trap\");\n+  nm->make_not_entrant(nmethod::InvalidationReason::C1_PREDICATE_FAILED_TRAP);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":86,"deletions":70,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/stubInfo.hpp\"\n@@ -45,10 +46,0 @@\n-\/\/ define C1StubId enum tags: unwind_exception_id etc\n-\n-#define C1_STUB_ID_ENUM_DECLARE(name) STUB_ID_NAME(name),\n-enum class C1StubId :int {\n-  NO_STUBID = -1,\n-  C1_STUBS_DO(C1_STUB_ID_ENUM_DECLARE)\n-  NUM_STUBIDS\n-};\n-#undef C1_STUB_ID_ENUM_DECLARE\n-\n@@ -57,0 +48,1 @@\n+  friend class AOTCodeAddressTable;\n@@ -82,2 +74,1 @@\n-  static CodeBlob* _blobs[(int)C1StubId::NUM_STUBIDS];\n-  static const char* _blob_names[];\n+  static CodeBlob* _blobs[(int)StubInfo::C1_STUB_COUNT];\n@@ -87,3 +78,3 @@\n-  static CodeBlob*  generate_blob(BufferBlob* buffer_blob, C1StubId id, const char* name, bool expect_oop_map, StubAssemblerCodeGenClosure *cl);\n-  static bool       generate_blob_for(BufferBlob* blob, C1StubId id);\n-  static OopMapSet* generate_code_for(C1StubId id, StubAssembler* sasm);\n+  static CodeBlob*  generate_blob(BufferBlob* buffer_blob, StubId id, const char* name, bool expect_oop_map, StubAssemblerCodeGenClosure *cl);\n+  static bool       generate_blob_for(BufferBlob* blob, StubId id);\n+  static OopMapSet* generate_code_for(StubId id, StubAssembler* sasm);\n@@ -92,1 +83,1 @@\n-  static OopMapSet* generate_handle_exception(C1StubId id, StubAssembler* sasm);\n+  static OopMapSet* generate_handle_exception(StubId id, StubAssembler* sasm);\n@@ -107,1 +98,1 @@\n-  static void unimplemented_entry(JavaThread* current, C1StubId id);\n+  static void unimplemented_entry(JavaThread* current, StubId id);\n@@ -129,1 +120,1 @@\n-  static void patch_code(JavaThread* current, C1StubId stub_id);\n+  static void patch_code(JavaThread* current, StubId stub_id);\n@@ -140,3 +131,3 @@\n-  static CodeBlob* blob_for (C1StubId id);\n-  static address   entry_for(C1StubId id)          { return blob_for(id)->code_begin(); }\n-  static const char* name_for (C1StubId id);\n+  static CodeBlob* blob_for (StubId id);\n+  static address   entry_for(StubId id)          { return blob_for(id)->code_begin(); }\n+  static const char* name_for (StubId id);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":12,"deletions":21,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/aotLogging.hpp\"\n@@ -40,1 +41,0 @@\n-#include \"classfile\/classLoaderExt.hpp\"\n@@ -56,0 +56,2 @@\n+#include \"oops\/methodCounters.hpp\"\n+#include \"oops\/methodData.hpp\"\n@@ -59,0 +61,1 @@\n+#include \"oops\/trainingData.hpp\"\n@@ -133,1 +136,5 @@\n-    address old_p = *ptr_loc;\n+    address old_p_with_tags = *ptr_loc;\n+    assert(old_p_with_tags != nullptr, \"null ptrs shouldn't have been marked\");\n+\n+    address old_p = MetaspaceClosure::strip_tags(old_p_with_tags);\n+    uintx tags = MetaspaceClosure::decode_tags(old_p_with_tags);\n@@ -136,2 +143,11 @@\n-    log_trace(cds)(\"Ref: [\" PTR_FORMAT \"] -> \" PTR_FORMAT \" => \" PTR_FORMAT,\n-                   p2i(ptr_loc), p2i(old_p), p2i(new_p));\n+    bool nulled;\n+    if (new_p == nullptr) {\n+      \/\/ old_p had a FollowMode of set_to_null\n+      nulled = true;\n+    } else {\n+      new_p = MetaspaceClosure::add_tags(new_p, tags);\n+      nulled = false;\n+    }\n+\n+    log_trace(aot)(\"Ref: [\" PTR_FORMAT \"] -> \" PTR_FORMAT \" => \" PTR_FORMAT \" %zu\",\n+                   p2i(ptr_loc), p2i(old_p) + tags, p2i(new_p), tags);\n@@ -140,0 +156,1 @@\n+    ArchiveBuilder::current()->count_relocated_pointer(tags != 0, nulled);\n@@ -180,0 +197,3 @@\n+  _relocated_ptr_info._num_ptrs = 0;\n+  _relocated_ptr_info._num_tagged_ptrs = 0;\n+  _relocated_ptr_info._num_nulled_ptrs = 0;\n@@ -254,1 +274,1 @@\n-  log_info(cds)(\"Gathering classes and symbols ... \");\n+  aot_log_info(aot)(\"Gathering classes and symbols ... \");\n@@ -284,1 +304,1 @@\n-    log_info(cds)(\"Sorting symbols ... \");\n+    aot_log_info(aot)(\"Sorting symbols ... \");\n@@ -306,1 +326,1 @@\n-  log_info(cds)(\"Sorting classes ... \");\n+  aot_log_info(aot)(\"Sorting classes ... \");\n@@ -318,1 +338,1 @@\n-    log_error(cds)(\"Failed to reserve %zu bytes of output buffer.\", buffer_size);\n+    aot_log_error(aot)(\"Failed to reserve %zu bytes of output buffer.\", buffer_size);\n@@ -325,1 +345,1 @@\n-  log_info(cds)(\"Reserved output buffer space at \" PTR_FORMAT \" [%zu bytes]\",\n+  aot_log_info(aot)(\"Reserved output buffer space at \" PTR_FORMAT \" [%zu bytes]\",\n@@ -367,3 +387,3 @@\n-    log_error(cds)(\"my_archive_requested_bottom = \" INTPTR_FORMAT, p2i(my_archive_requested_bottom));\n-    log_error(cds)(\"my_archive_requested_top    = \" INTPTR_FORMAT, p2i(my_archive_requested_top));\n-    log_error(cds)(\"SharedBaseAddress (\" INTPTR_FORMAT \") is too high. \"\n+    aot_log_error(aot)(\"my_archive_requested_bottom = \" INTPTR_FORMAT, p2i(my_archive_requested_bottom));\n+    aot_log_error(aot)(\"my_archive_requested_top    = \" INTPTR_FORMAT, p2i(my_archive_requested_top));\n+    aot_log_error(aot)(\"SharedBaseAddress (\" INTPTR_FORMAT \") is too high. \"\n@@ -427,1 +447,1 @@\n-      log_info(cds, hashtables)(\"Expanded _src_obj_table table to %d\", _src_obj_table.table_size());\n+      log_info(aot, hashtables)(\"Expanded _src_obj_table table to %d\", _src_obj_table.table_size());\n@@ -439,0 +459,5 @@\n+  if (ref->msotype() == MetaspaceObj::MethodDataType) {\n+    MethodData* md = (MethodData*)ref->obj();\n+    md->clean_method_data(false \/* always_clean *\/);\n+  }\n+\n@@ -506,1 +531,1 @@\n-  log_info(cds)(\"Gathering all archivable objects ... \");\n+  aot_log_info(aot)(\"Gathering all archivable objects ... \");\n@@ -536,2 +561,5 @@\n-             ref->msotype() == MetaspaceObj::MethodCountersType) {\n-    return set_to_null;\n+             ref->msotype() == MetaspaceObj::MethodCountersType ||\n+             ref->msotype() == MetaspaceObj::KlassTrainingDataType ||\n+             ref->msotype() == MetaspaceObj::MethodTrainingDataType ||\n+             ref->msotype() == MetaspaceObj::CompileTrainingDataType) {\n+    return (TrainingData::need_data() || TrainingData::assembling_data()) ? make_a_copy : set_to_null;\n@@ -539,1 +567,1 @@\n-    if (AOTCodeCache::is_dumping_adapters()) {\n+    if (CDSConfig::is_dumping_adapters()) {\n@@ -549,0 +577,3 @@\n+      if (RegeneratedClasses::has_been_regenerated(klass)) {\n+        klass = RegeneratedClasses::get_regenerated_object(klass);\n+      }\n@@ -593,1 +624,1 @@\n-  log_info(cds)(\"Allocating RW objects ... \");\n+  aot_log_info(aot)(\"Allocating RW objects ... \");\n@@ -608,1 +639,1 @@\n-  log_info(cds)(\"Allocating RO objects ... \");\n+  aot_log_info(aot)(\"Allocating RO objects ... \");\n@@ -629,1 +660,1 @@\n-  log_info(cds)(\"done (%d objects)\", src_objs->objs()->length());\n+  aot_log_info(aot)(\"done (%d objects)\", src_objs->objs()->length());\n@@ -679,1 +710,1 @@\n-      log_info(cds, hashtables)(\"Expanded _buffered_to_src_table table to %d\", _buffered_to_src_table.table_size());\n+      log_info(aot, hashtables)(\"Expanded _buffered_to_src_table table to %d\", _buffered_to_src_table.table_size());\n@@ -689,1 +720,1 @@\n-  log_trace(cds)(\"Copy: \" PTR_FORMAT \" ==> \" PTR_FORMAT \" %d\", p2i(src), p2i(dest), bytes);\n+  log_trace(aot)(\"Copy: \" PTR_FORMAT \" ==> \" PTR_FORMAT \" %d\", p2i(src), p2i(dest), bytes);\n@@ -755,1 +786,1 @@\n-  log_info(cds)(\"Relocating embedded pointers in core regions ... \");\n+  aot_log_info(aot)(\"Relocating embedded pointers in core regions ... \");\n@@ -758,0 +789,4 @@\n+  log_info(cds)(\"Relocating %zu pointers, %zu tagged, %zu nulled\",\n+                _relocated_ptr_info._num_ptrs,\n+                _relocated_ptr_info._num_tagged_ptrs,\n+                _relocated_ptr_info._num_nulled_ptrs);\n@@ -836,4 +871,0 @@\n-      if (CDSConfig::is_dumping_dynamic_archive()) {\n-        \/\/ For static dump, class loader type are already set.\n-        ik->assign_class_loader_type();\n-      }\n@@ -863,1 +894,1 @@\n-      } else if (ik->is_shared_boot_class()) {\n+      } else if (ik->defined_by_boot_loader()) {\n@@ -866,1 +897,1 @@\n-      } else if (ik->is_shared_platform_class()) {\n+      } else if (ik->defined_by_platform_loader()) {\n@@ -869,1 +900,1 @@\n-      } else if (ik->is_shared_app_class()) {\n+      } else if (ik->defined_by_app_loader()) {\n@@ -873,1 +904,1 @@\n-        assert(ik->is_shared_unregistered_class(), \"must be\");\n+        assert(ik->defined_by_other_loaders(), \"must be\");\n@@ -885,1 +916,1 @@\n-        if (ik->is_shared_boot_class()) {\n+        if (ik->defined_by_boot_loader()) {\n@@ -887,1 +918,1 @@\n-        } else if (ik->is_shared_platform_class()) {\n+        } else if (ik->defined_by_platform_loader()) {\n@@ -889,1 +920,1 @@\n-        } else if (ik->is_shared_app_class()) {\n+        } else if (ik->defined_by_app_loader()) {\n@@ -926,1 +957,1 @@\n-    if (log_is_enabled(Debug, cds, class)) {\n+    if (aot_log_is_enabled(Debug, aot, class)) {\n@@ -928,1 +959,1 @@\n-      log_debug(cds, class)(\"klasses[%5d] = \" PTR_FORMAT \" %-5s %s%s%s%s%s%s%s%s\", i,\n+      aot_log_debug(aot, class)(\"klasses[%5d] = \" PTR_FORMAT \" %-5s %s%s%s%s%s%s%s%s\", i,\n@@ -937,11 +968,11 @@\n-  log_info(cds)(\"Number of classes %d\", num_instance_klasses + num_obj_array_klasses + num_type_array_klasses);\n-  log_info(cds)(\"    instance classes   \" STATS_FORMAT, STATS_PARAMS(instance_klasses));\n-  log_info(cds)(\"      boot             \" STATS_FORMAT, STATS_PARAMS(boot_klasses));\n-  log_info(cds)(\"        vm             \" STATS_FORMAT, STATS_PARAMS(vm_klasses));\n-  log_info(cds)(\"      platform         \" STATS_FORMAT, STATS_PARAMS(platform_klasses));\n-  log_info(cds)(\"      app              \" STATS_FORMAT, STATS_PARAMS(app_klasses));\n-  log_info(cds)(\"      unregistered     \" STATS_FORMAT, STATS_PARAMS(unregistered_klasses));\n-  log_info(cds)(\"      (enum)           \" STATS_FORMAT, STATS_PARAMS(enum_klasses));\n-  log_info(cds)(\"      (hidden)         \" STATS_FORMAT, STATS_PARAMS(hidden_klasses));\n-  log_info(cds)(\"      (old)            \" STATS_FORMAT, STATS_PARAMS(old_klasses));\n-  log_info(cds)(\"      (unlinked)       = %5d, boot = %d, plat = %d, app = %d, unreg = %d\",\n+  aot_log_info(aot)(\"Number of classes %d\", num_instance_klasses + num_obj_array_klasses + num_type_array_klasses);\n+  aot_log_info(aot)(\"    instance classes   \" STATS_FORMAT, STATS_PARAMS(instance_klasses));\n+  aot_log_info(aot)(\"      boot             \" STATS_FORMAT, STATS_PARAMS(boot_klasses));\n+  aot_log_info(aot)(\"        vm             \" STATS_FORMAT, STATS_PARAMS(vm_klasses));\n+  aot_log_info(aot)(\"      platform         \" STATS_FORMAT, STATS_PARAMS(platform_klasses));\n+  aot_log_info(aot)(\"      app              \" STATS_FORMAT, STATS_PARAMS(app_klasses));\n+  aot_log_info(aot)(\"      unregistered     \" STATS_FORMAT, STATS_PARAMS(unregistered_klasses));\n+  aot_log_info(aot)(\"      (enum)           \" STATS_FORMAT, STATS_PARAMS(enum_klasses));\n+  aot_log_info(aot)(\"      (hidden)         \" STATS_FORMAT, STATS_PARAMS(hidden_klasses));\n+  aot_log_info(aot)(\"      (old)            \" STATS_FORMAT, STATS_PARAMS(old_klasses));\n+  aot_log_info(aot)(\"      (unlinked)       = %5d, boot = %d, plat = %d, app = %d, unreg = %d\",\n@@ -949,3 +980,3 @@\n-  log_info(cds)(\"    obj array classes  = %5d\", num_obj_array_klasses);\n-  log_info(cds)(\"    type array classes = %5d\", num_type_array_klasses);\n-  log_info(cds)(\"               symbols = %5d\", _symbols->length());\n+  aot_log_info(aot)(\"    obj array classes  = %5d\", num_obj_array_klasses);\n+  aot_log_info(aot)(\"    type array classes = %5d\", num_type_array_klasses);\n+  aot_log_info(aot)(\"               symbols = %5d\", _symbols->length());\n@@ -959,0 +990,22 @@\n+void ArchiveBuilder::make_training_data_shareable() {\n+  auto clean_td = [&] (address& src_obj,  SourceObjInfo& info) {\n+    if (!is_in_buffer_space(info.buffered_addr())) {\n+      return;\n+    }\n+\n+    if (info.msotype() == MetaspaceObj::KlassTrainingDataType ||\n+        info.msotype() == MetaspaceObj::MethodTrainingDataType ||\n+        info.msotype() == MetaspaceObj::CompileTrainingDataType) {\n+      TrainingData* buffered_td = (TrainingData*)info.buffered_addr();\n+      buffered_td->remove_unshareable_info();\n+    } else if (info.msotype() == MetaspaceObj::MethodDataType) {\n+      MethodData* buffered_mdo = (MethodData*)info.buffered_addr();\n+      buffered_mdo->remove_unshareable_info();\n+    } else if (info.msotype() == MetaspaceObj::MethodCountersType) {\n+      MethodCounters* buffered_mc = (MethodCounters*)info.buffered_addr();\n+      buffered_mc->remove_unshareable_info();\n+    }\n+  };\n+  _src_obj_table.iterate_all(clean_td);\n+}\n+\n@@ -1053,1 +1106,1 @@\n-    log_debug(cds)(\"Relocating archive from [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] to \"\n+    aot_log_debug(aot)(\"Relocating archive from [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] to \"\n@@ -1157,1 +1210,1 @@\n-    log_debug(cds, map)(_LOG_PREFIX \" %s\",\n+    log_debug(aot, map)(_LOG_PREFIX \" %s\",\n@@ -1162,1 +1215,1 @@\n-    log_debug(cds, map)(_LOG_PREFIX \" %s\",\n+    log_debug(aot, map)(_LOG_PREFIX \" %s\",\n@@ -1205,1 +1258,1 @@\n-          log_debug(cds, map)(_LOG_PREFIX \" %s\", p2i(runtime_dest), type_name, bytes,\n+          log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(runtime_dest), type_name, bytes,\n@@ -1210,1 +1263,1 @@\n-        log_debug(cds, map)(_LOG_PREFIX, p2i(runtime_dest), type_name, bytes);\n+        log_debug(aot, map)(_LOG_PREFIX, p2i(runtime_dest), type_name, bytes);\n@@ -1220,1 +1273,1 @@\n-      log_debug(cds, map)(PTR_FORMAT \": @@ Misc data %zu bytes\",\n+      log_debug(aot, map)(PTR_FORMAT \": @@ Misc data %zu bytes\",\n@@ -1244,1 +1297,1 @@\n-    log_info(cds, map)(\"[%-18s \" PTR_FORMAT \" - \" PTR_FORMAT \" %9zu bytes]\",\n+    log_info(aot, map)(\"[%-18s \" PTR_FORMAT \" - \" PTR_FORMAT \" %9zu bytes]\",\n@@ -1255,1 +1308,1 @@\n-    LogStreamHandle(Info, cds, map) st;\n+    LogStreamHandle(Info, aot, map) st;\n@@ -1366,1 +1419,1 @@\n-    LogStreamHandle(Trace, cds, map, oops) st;\n+    LogStreamHandle(Trace, aot, map, oops) st;\n@@ -1434,1 +1487,1 @@\n-    LogStreamHandle(Trace, cds, map, oops) st;\n+    LogStreamHandle(Trace, aot, map, oops) st;\n@@ -1495,1 +1548,1 @@\n-    LogStreamHandle(Trace, cds, map) lsh;\n+    LogStreamHandle(Trace, aot, map) lsh;\n@@ -1508,1 +1561,1 @@\n-    LogStreamHandle(Info, cds, map) lsh;\n+    LogStreamHandle(Info, aot, map) lsh;\n@@ -1518,1 +1571,1 @@\n-    log_info(cds, map)(\"%s CDS archive map for %s\", CDSConfig::is_dumping_static_archive() ? \"Static\" : \"Dynamic\", mapinfo->full_path());\n+    log_info(aot, map)(\"%s CDS archive map for %s\", CDSConfig::is_dumping_static_archive() ? \"Static\" : \"Dynamic\", mapinfo->full_path());\n@@ -1542,1 +1595,1 @@\n-    log_info(cds, map)(\"[End of CDS archive map]\");\n+    log_info(aot, map)(\"[End of CDS archive map]\");\n@@ -1579,2 +1632,2 @@\n-  if (log_is_enabled(Info, cds)) {\n-    log_info(cds)(\"Full module graph = %s\", CDSConfig::is_dumping_full_module_graph() ? \"enabled\" : \"disabled\");\n+  if (log_is_enabled(Info, aot)) {\n+    log_info(aot)(\"Full module graph = %s\", CDSConfig::is_dumping_full_module_graph() ? \"enabled\" : \"disabled\");\n@@ -1584,1 +1637,1 @@\n-  if (log_is_enabled(Info, cds, map)) {\n+  if (log_is_enabled(Info, aot, map)) {\n@@ -1596,0 +1649,6 @@\n+void ArchiveBuilder::count_relocated_pointer(bool tagged, bool nulled) {\n+  _relocated_ptr_info._num_ptrs ++;\n+  _relocated_ptr_info._num_tagged_ptrs += tagged ? 1 : 0;\n+  _relocated_ptr_info._num_nulled_ptrs += nulled ? 1 : 0;\n+}\n+\n@@ -1618,1 +1677,1 @@\n-  log_debug(cds)(\"total   : %9zu [100.0%% of total] out of %9zu bytes [%5.1f%% used]\",\n+  aot_log_debug(aot)(\"total   : %9zu [100.0%% of total] out of %9zu bytes [%5.1f%% used]\",\n@@ -1623,1 +1682,1 @@\n-  log_debug(cds)(\"bm space: %9zu [ %4.1f%% of total] out of %9zu bytes [100.0%% used]\",\n+  aot_log_debug(aot)(\"bm space: %9zu [ %4.1f%% of total] out of %9zu bytes [100.0%% used]\",\n@@ -1631,1 +1690,1 @@\n-  log_debug(cds)(\"hp space: %9zu [ %4.1f%% of total] out of %9zu bytes [100.0%% used] at \" INTPTR_FORMAT,\n+  aot_log_debug(aot)(\"hp space: %9zu [ %4.1f%% of total] out of %9zu bytes [100.0%% used] at \" INTPTR_FORMAT,\n@@ -1642,1 +1701,1 @@\n-  log_error(cds)(\"Unable to allocate from '%s' region: Please reduce the number of shared classes.\", name);\n+  log_error(aot)(\"Unable to allocate from '%s' region: Please reduce the number of shared classes.\", name);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":130,"deletions":71,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"cds\/regeneratedClasses.hpp\"\n@@ -250,1 +251,1 @@\n-    log_info(cds, heap)(\"archived obj root segment [%d] = %zu bytes, obj = \" PTR_FORMAT,\n+    log_info(aot, heap)(\"archived obj root segment [%d] = %zu bytes, obj = \" PTR_FORMAT,\n@@ -296,1 +297,1 @@\n-  log_info(cds)(\"sorting heap objects\");\n+  log_info(aot)(\"sorting heap objects\");\n@@ -306,1 +307,1 @@\n-  log_info(cds)(\"computed ranks\");\n+  log_info(aot)(\"computed ranks\");\n@@ -308,1 +309,1 @@\n-  log_info(cds)(\"sorting heap objects done\");\n+  log_info(aot)(\"sorting heap objects done\");\n@@ -333,1 +334,1 @@\n-  log_info(cds)(\"Size of heap region = %zu bytes, %d objects, %d roots, %d native ptrs\",\n+  log_info(aot)(\"Size of heap region = %zu bytes, %d objects, %d roots, %d native ptrs\",\n@@ -399,1 +400,1 @@\n-    log_info(cds, heap)(\"Inserting filler obj array of %d elements (%zu bytes total) @ buffer offset %zu\",\n+    log_info(aot, heap)(\"Inserting filler obj array of %d elements (%zu bytes total) @ buffer offset %zu\",\n@@ -479,1 +480,1 @@\n-      log_info(cds, heap)(\"Heap end = %p\", heap_end);\n+      log_info(aot, heap)(\"Heap end = %p\", heap_end);\n@@ -548,0 +549,4 @@\n+      Klass* k = java_lang_Class::as_Klass(source_referent);\n+      if (RegeneratedClasses::has_been_regenerated(k)) {\n+        source_referent = RegeneratedClasses::get_regenerated_object(k)->java_mirror();\n+      }\n@@ -647,1 +652,1 @@\n-  log_info(cds)(\"%s = %7zu ... %7zu (%3zu%% ... %3zu%% = %3zu%%)\", which,\n+  log_info(aot)(\"%s = %7zu ... %7zu (%3zu%% ... %3zu%% = %3zu%%)\", which,\n@@ -765,0 +770,5 @@\n+\n+    if (RegeneratedClasses::has_been_regenerated(native_ptr)) {\n+      native_ptr = RegeneratedClasses::get_regenerated_object(native_ptr);\n+    }\n+\n@@ -774,1 +784,1 @@\n-  log_info(cds, heap)(\"calculate_ptrmap: marked %d non-null native pointers for heap region (%zu bits)\",\n+  log_info(aot, heap)(\"calculate_ptrmap: marked %d non-null native pointers for heap region (%zu bits)\",\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"classfile\/classLoaderExt.hpp\"\n@@ -123,1 +122,1 @@\n-    assert(!ik->is_shared_unregistered_class(), \"unexpected archived package entry for an unregistered class\");\n+    assert(!ik->defined_by_other_loaders(), \"unexpected archived package entry for an unregistered class\");\n","filename":"src\/hotspot\/share\/cds\/cdsProtectionDomain.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotLogging.hpp\"\n@@ -32,1 +33,1 @@\n-#include \"classfile\/classLoaderExt.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n@@ -71,1 +72,1 @@\n-  log_info(cds)(\"Parsing %s%s\", file,\n+  aot_log_info(aot)(\"Parsing %s%s\", file,\n@@ -166,1 +167,1 @@\n-    log_warning(cds)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(), ex_msg);\n+    aot_log_warning(aot)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(), ex_msg);\n@@ -170,1 +171,1 @@\n-    log_warning(cds)(\"Preload Warning: Cannot find %s\", _class_name);\n+    aot_log_warning(aot)(\"Preload Warning: Cannot find %s\", _class_name);\n@@ -175,1 +176,1 @@\n-  if (log_is_enabled(Trace, cds)) {\n+  if (aot_log_is_enabled(Trace, aot)) {\n@@ -177,1 +178,1 @@\n-    log_trace(cds)(\"Shared spaces preloaded: %s\", klass->external_name());\n+    log_trace(aot)(\"Shared spaces preloaded: %s\", klass->external_name());\n@@ -398,1 +399,1 @@\n-objArrayOop ClassListParser::get_specified_interfaces(TRAPS) {\n+GrowableArray<InstanceKlass *> ClassListParser::get_specified_interfaces() {\n@@ -400,8 +401,3 @@\n-  if (n == 0) {\n-    return nullptr;\n-  } else {\n-    objArrayOop array = oopFactory::new_objArray(vmClasses::Class_klass(), n, CHECK_NULL);\n-    for (int i = 0; i < n; i++) {\n-      array->obj_at_put(i, lookup_class_by_id(_interfaces->at(i))->java_mirror());\n-    }\n-    return array;\n+  GrowableArray<InstanceKlass *> specified_interfaces(n);\n+  for (int i = 0; i < n; i++) {\n+    specified_interfaces.append(lookup_class_by_id(_interfaces->at(i)));\n@@ -409,0 +405,1 @@\n+  return specified_interfaces;\n@@ -505,1 +502,1 @@\n-  LogTarget(Warning, cds, resolve) lt;\n+  LogTarget(Warning, aot, resolve) lt;\n@@ -512,0 +509,19 @@\n+\/\/ If an unregistered class U is specified to have a registered supertype S1\n+\/\/ named SN but an unregistered class S2 also named SN has already been loaded\n+\/\/ S2 will be incorrectly used as the supertype of U instead of S1 due to\n+\/\/ limitations in the loading mechanism of unregistered classes.\n+void ClassListParser::check_supertype_obstruction(int specified_supertype_id, const InstanceKlass* specified_supertype, TRAPS) {\n+  if (specified_supertype->defined_by_other_loaders()) {\n+    return; \/\/ Only registered supertypes can be obstructed\n+  }\n+  const InstanceKlass* obstructor = SystemDictionaryShared::get_unregistered_class(specified_supertype->name());\n+  if (obstructor == nullptr) {\n+    return; \/\/ No unregistered types with the same name have been loaded, i.e. no obstruction\n+  }\n+  \/\/ 'specified_supertype' is S1, 'obstructor' is S2 from the explanation above\n+  ResourceMark rm;\n+  THROW_MSG(vmSymbols::java_lang_UnsupportedOperationException(),\n+            err_msg(\"%s (id %d) has super-type %s (id %d) obstructed by another class with the same name\",\n+                    _class_name, _id, specified_supertype->external_name(), specified_supertype_id));\n+}\n+\n@@ -530,1 +546,1 @@\n-    log_info(cds)(\"Prohibited package for non-bootstrap classes: %s.class from %s\",\n+    aot_log_info(aot)(\"Prohibited package for non-bootstrap classes: %s.class from %s\",\n@@ -536,6 +552,11 @@\n-  char * source_path = os::strdup_check_oom(ClassLoader::uri_to_path(_source));\n-  Handle super_class(THREAD, specified_super->java_mirror());\n-  objArrayOop r = get_specified_interfaces(CHECK_NULL);\n-  objArrayHandle interfaces(THREAD, r);\n-  InstanceKlass* k = UnregisteredClasses::load_class(class_name, source_path,\n-                                                     super_class, interfaces, CHECK_NULL);\n+  GrowableArray<InstanceKlass*> specified_interfaces = get_specified_interfaces();\n+  \/\/ Obstruction must be checked before the class loading attempt because it may\n+  \/\/ cause class loading errors (JVMS 5.3.5.3-5.3.5.4)\n+  check_supertype_obstruction(_super, specified_super, CHECK_NULL);\n+  for (int i = 0; i < _interfaces->length(); i++) {\n+    check_supertype_obstruction(_interfaces->at(i), specified_interfaces.at(i), CHECK_NULL);\n+  }\n+\n+  const char* source_path = ClassLoader::uri_to_path(_source);\n+  InstanceKlass* k = UnregisteredClasses::load_class(class_name, source_path, CHECK_NULL);\n+\n@@ -554,0 +575,9 @@\n+  for (int i = 0; i < _interfaces->length(); i++) {\n+    InstanceKlass* specified_interface = specified_interfaces.at(i);\n+    if (!k->local_interfaces()->contains(specified_interface)) {\n+      print_specified_interfaces();\n+      print_actual_interfaces(k);\n+      error(\"Specified interface %s (id %d) is not directly implemented\",\n+            specified_interface->external_name(), _interfaces->at(i));\n+      }\n+  }\n@@ -555,1 +585,1 @@\n-  assert(k->is_shared_unregistered_class(), \"must be\");\n+  assert(k->defined_by_other_loaders(), \"must be\");\n@@ -622,1 +652,1 @@\n-    log_warning(cds)(\"resolve_indy for class %s has encountered exception: %s %s\",\n+    aot_log_warning(aot)(\"resolve_indy for class %s has encountered exception: %s %s\",\n@@ -662,1 +692,1 @@\n-        log_debug(cds, lambda)(\"is_supported_invokedynamic check failed for cp_index %d\", pool_index);\n+        log_debug(aot, lambda)(\"is_supported_invokedynamic check failed for cp_index %d\", pool_index);\n@@ -685,1 +715,1 @@\n-      log_warning(cds)(\"No invoke dynamic constant pool entry can be found for class %s. The classlist is probably out-of-date.\",\n+      aot_log_warning(aot)(\"No invoke dynamic constant pool entry can be found for class %s. The classlist is probably out-of-date.\",\n@@ -747,1 +777,1 @@\n-      log_info(cds, hashtables)(\"Expanded id2klass_table() to %d\", id2klass_table()->table_size());\n+      log_info(aot, hashtables)(\"Expanded id2klass_table() to %d\", id2klass_table()->table_size());\n@@ -851,1 +881,1 @@\n-    if (log_is_enabled(Warning, cds, resolve)) {\n+    if (log_is_enabled(Warning, aot, resolve)) {\n@@ -853,1 +883,1 @@\n-      log_warning(cds, resolve)(\"Cannot aot-resolve constants for %s because it is excluded\", ik->external_name());\n+      log_warning(aot, resolve)(\"Cannot aot-resolve constants for %s because it is excluded\", ik->external_name());\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":60,"deletions":30,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotLogging.hpp\"\n@@ -41,1 +42,0 @@\n-#include \"classfile\/classLoaderExt.hpp\"\n@@ -46,0 +46,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n@@ -62,0 +63,1 @@\n+#include \"oops\/trainingData.hpp\"\n@@ -233,0 +235,10 @@\n+  \/\/ Which JIT compier is used\n+  _compiler_type = (u1)CompilerConfig::compiler_type();\n+  _type_profile_level = TypeProfileLevel;\n+  _type_profile_args_limit = TypeProfileArgsLimit;\n+  _type_profile_parms_limit = TypeProfileParmsLimit;\n+  _type_profile_width = TypeProfileWidth;\n+  _bci_profile_width = BciProfileWidth;\n+  _profile_traps = ProfileTraps;\n+  _type_profile_casts = TypeProfileCasts;\n+  _spec_trap_limit_extra_entries = SpecTrapLimitExtraEntries;\n@@ -318,1 +330,1 @@\n-  if (!config->validate(header()->has_aot_linked_classes(), &has_extra_module_paths)) {\n+  if (!config->validate(full_path(), header()->has_aot_linked_classes(), &has_extra_module_paths)) {\n@@ -339,1 +351,1 @@\n-      log_warning(cds)(\n+      aot_log_warning(aot)(\n@@ -345,1 +357,1 @@\n-        log_warning(cds)(\n+        aot_log_warning(aot)(\n@@ -400,1 +412,1 @@\n-      log_info(cds)(\"Specified %s not found (%s)\", CDSConfig::type_of_archive_being_loaded(), _archive_name);\n+      aot_log_info(aot)(\"Specified %s not found (%s)\", CDSConfig::type_of_archive_being_loaded(), _archive_name);\n@@ -417,1 +429,1 @@\n-      log_warning(cds)(\"Unable to read generic CDS file map header from %s\", file_type);\n+      aot_log_warning(aot)(\"Unable to read generic CDS file map header from %s\", file_type);\n@@ -424,1 +436,1 @@\n-      log_warning(cds)(\"The %s has a bad magic number: %#x\", file_type, gen_header._magic);\n+      aot_log_warning(aot)(\"The %s has a bad magic number: %#x\", file_type, gen_header._magic);\n@@ -429,1 +441,1 @@\n-      log_warning(cds)(\"Cannot handle %s version 0x%x. Must be at least 0x%x.\",\n+      aot_log_warning(aot)(\"Cannot handle %s version 0x%x. Must be at least 0x%x.\",\n@@ -435,1 +447,1 @@\n-      log_warning(cds)(\"The %s version 0x%x does not match the required version 0x%x.\",\n+      aot_log_warning(aot)(\"The %s version 0x%x does not match the required version 0x%x.\",\n@@ -441,1 +453,1 @@\n-      log_warning(cds)(\"Archive file header larger than archive file\");\n+      aot_log_warning(aot)(\"Archive file header larger than archive file\");\n@@ -451,1 +463,1 @@\n-      log_warning(cds)(\"Unable to read file map header from %s\", file_type);\n+      aot_log_warning(aot)(\"Unable to read file map header from %s\", file_type);\n@@ -496,3 +508,3 @@\n-        log_info(cds)(\"_crc expected: %d\", header->crc());\n-        log_info(cds)(\"       actual: %d\", actual_crc);\n-        log_warning(cds)(\"Header checksum verification failed.\");\n+        aot_log_info(aot)(\"_crc expected: %d\", header->crc());\n+        aot_log_info(aot)(\"       actual: %d\", actual_crc);\n+        aot_log_warning(aot)(\"Header checksum verification failed.\");\n@@ -511,1 +523,1 @@\n-      log_warning(cds)(\"base_archive_name offset\/size overflow: \" UINT32_FORMAT \"\/\" UINT32_FORMAT,\n+      aot_log_warning(aot)(\"base_archive_name offset\/size overflow: \" UINT32_FORMAT \"\/\" UINT32_FORMAT,\n@@ -518,1 +530,1 @@\n-        log_warning(cds)(\"static shared archive must have zero _base_archive_name_offset\");\n+        aot_log_warning(aot)(\"static shared archive must have zero _base_archive_name_offset\");\n@@ -522,1 +534,1 @@\n-        log_warning(cds)(\"static shared archive must have zero _base_archive_name_size\");\n+        aot_log_warning(aot)(\"static shared archive must have zero _base_archive_name_size\");\n@@ -530,1 +542,1 @@\n-        log_warning(cds)(\"Invalid base_archive_name offset\/size: \" UINT32_FORMAT \"\/\" UINT32_FORMAT,\n+        aot_log_warning(aot)(\"Invalid base_archive_name offset\/size: \" UINT32_FORMAT \"\/\" UINT32_FORMAT,\n@@ -536,1 +548,1 @@\n-          log_warning(cds)(\"Invalid base_archive_name offset\/size (out of range): \"\n+          aot_log_warning(aot)(\"Invalid base_archive_name offset\/size (out of range): \"\n@@ -543,1 +555,1 @@\n-          log_warning(cds)(\"Base archive name is damaged\");\n+          aot_log_warning(aot)(\"Base archive name is damaged\");\n@@ -547,1 +559,1 @@\n-          log_warning(cds)(\"Base archive %s does not exist\", name);\n+          aot_log_warning(aot)(\"Base archive %s does not exist\", name);\n@@ -582,1 +594,1 @@\n-     log_warning(cds)(\"AutoCreateSharedArchive is ignored because %s is a static archive\", archive_name);\n+     aot_log_warning(aot)(\"AutoCreateSharedArchive is ignored because %s is a static archive\", archive_name);\n@@ -610,1 +622,1 @@\n-    log_warning(cds)(\"Unable to read the file header.\");\n+    aot_log_warning(aot)(\"Unable to read the file header.\");\n@@ -622,1 +634,1 @@\n-        log_warning(cds)(\"Not a valid %s (%s)\", file_type, _full_path);\n+        aot_log_warning(aot)(\"Not a valid %s (%s)\", file_type, _full_path);\n@@ -624,1 +636,1 @@\n-        log_warning(cds)(\"Not a base shared archive: %s\", _full_path);\n+        aot_log_warning(aot)(\"Not a base shared archive: %s\", _full_path);\n@@ -630,1 +642,1 @@\n-      log_warning(cds)(\"Not a top shared archive: %s\", _full_path);\n+      aot_log_warning(aot)(\"Not a top shared archive: %s\", _full_path);\n@@ -640,1 +652,1 @@\n-    log_warning(cds)(\"Failed to read file header from the top archive file\\n\");\n+    aot_log_warning(aot)(\"Failed to read file header from the top archive file\\n\");\n@@ -645,3 +657,3 @@\n-    log_info(cds)(\"_version expected: 0x%x\", CURRENT_CDS_ARCHIVE_VERSION);\n-    log_info(cds)(\"           actual: 0x%x\", header()->version());\n-    log_warning(cds)(\"The %s has the wrong version.\", file_type);\n+    aot_log_info(aot)(\"_version expected: 0x%x\", CURRENT_CDS_ARCHIVE_VERSION);\n+    aot_log_info(aot)(\"           actual: 0x%x\", header()->version());\n+    aot_log_warning(aot)(\"The %s has the wrong version.\", file_type);\n@@ -656,4 +668,4 @@\n-      log_info(cds)(\"_header_size: \" UINT32_FORMAT, header_size);\n-      log_info(cds)(\"base_archive_name_size: \" UINT32_FORMAT, header()->base_archive_name_size());\n-      log_info(cds)(\"base_archive_name_offset: \" UINT32_FORMAT, header()->base_archive_name_offset());\n-      log_warning(cds)(\"The %s has an incorrect header size.\", file_type);\n+      aot_log_info(aot)(\"_header_size: \" UINT32_FORMAT, header_size);\n+      aot_log_info(aot)(\"base_archive_name_size: \" UINT32_FORMAT, header()->base_archive_name_size());\n+      aot_log_info(aot)(\"base_archive_name_offset: \" UINT32_FORMAT, header()->base_archive_name_offset());\n+      aot_log_warning(aot)(\"The %s has an incorrect header size.\", file_type);\n@@ -667,1 +679,1 @@\n-    log_warning(cds)(\"JVM version identifier is corrupted.\");\n+    aot_log_warning(aot)(\"JVM version identifier is corrupted.\");\n@@ -674,3 +686,3 @@\n-    log_info(cds)(\"_jvm_ident expected: %s\", expected_ident);\n-    log_info(cds)(\"             actual: %s\", actual_ident);\n-    log_warning(cds)(\"The %s was created by a different\"\n+    aot_log_info(aot)(\"_jvm_ident expected: %s\", expected_ident);\n+    aot_log_info(aot)(\"             actual: %s\", actual_ident);\n+    aot_log_warning(aot)(\"The %s was created by a different\"\n@@ -688,1 +700,1 @@\n-      log_warning(cds)(\"The %s has been truncated.\", file_type);\n+      aot_log_warning(aot)(\"The %s has been truncated.\", file_type);\n@@ -698,1 +710,1 @@\n-    log_error(cds)(\"Unable to seek to position %zu\", pos);\n+    aot_log_error(aot)(\"Unable to seek to position %zu\", pos);\n@@ -711,1 +723,1 @@\n-  log_info(cds)(\"trying to map %s%s\", info, _full_path);\n+  aot_log_info(aot)(\"trying to map %s%s\", info, _full_path);\n@@ -715,1 +727,1 @@\n-      log_info(cds)(\"Specified %s not found (%s)\", file_type, _full_path);\n+      aot_log_info(aot)(\"Specified %s not found (%s)\", file_type, _full_path);\n@@ -717,1 +729,1 @@\n-      log_warning(cds)(\"Failed to open %s (%s)\", file_type,\n+      aot_log_warning(aot)(\"Failed to open %s (%s)\", file_type,\n@@ -722,1 +734,1 @@\n-    log_info(cds)(\"Opened %s %s.\", file_type, _full_path);\n+    aot_log_info(aot)(\"Opened %s %s.\", file_type, _full_path);\n@@ -733,2 +745,1 @@\n-  LogMessage(cds) msg;\n-  if (msg.is_info()) {\n+  if (CDSConfig::new_aot_flags_used()) {\n@@ -736,1 +747,1 @@\n-      msg.info(\"Writing binary AOTConfiguration file: \");\n+      log_info(aot)(\"Writing binary AOTConfiguration file: %s\",  _full_path);\n@@ -738,1 +749,1 @@\n-      msg.info(\"Dumping shared data to file: \");\n+      log_info(aot)(\"Writing AOTCache file: %s\",  _full_path);\n@@ -740,1 +751,2 @@\n-    msg.info(\"   %s\", _full_path);\n+  } else {\n+    aot_log_info(aot)(\"Dumping shared data to file: %s\", _full_path);\n@@ -752,1 +764,1 @@\n-    log_error(cds)(\"Unable to create %s %s: (%s).\", CDSConfig::type_of_archive_being_written(), _full_path,\n+    aot_log_error(aot)(\"Unable to create %s %s: (%s).\", CDSConfig::type_of_archive_being_written(), _full_path,\n@@ -818,1 +830,1 @@\n-    log_warning(cds)(\"Checksum verification failed.\");\n+    aot_log_warning(aot)(\"Checksum verification failed.\");\n@@ -840,1 +852,1 @@\n-  log_debug(cds, reloc)(\"mapped %s relocation %smap @ \" INTPTR_FORMAT \" (%zu bits)\",\n+  aot_log_debug(aot, reloc)(\"mapped %s relocation %smap @ \" INTPTR_FORMAT \" (%zu bits)\",\n@@ -908,1 +920,1 @@\n-    log_info(cds)(\"Shared file region (%s) %d: %8zu\"\n+    aot_log_info(aot)(\"Shared file region (%s) %d: %8zu\"\n@@ -913,1 +925,1 @@\n-     log_info(cds)(\"Shared file region (%s) %d: %8zu\"\n+    aot_log_info(aot)(\"Shared file region (%s) %d: %8zu\"\n@@ -1104,1 +1116,1 @@\n-    log_error(cds)(\"Unable to remap shared readonly space (errno=%d).\", errno);\n+    aot_log_error(aot)(\"Unable to remap shared readonly space (errno=%d).\", errno);\n@@ -1108,1 +1120,1 @@\n-    log_error(cds)(\"Unable to remap shared readonly space (errno=%d).\", errno);\n+    aot_log_error(aot)(\"Unable to remap shared readonly space (errno=%d).\", errno);\n@@ -1139,1 +1151,1 @@\n-    log_info(cds)(\"Mapped %s region #%d at base \" INTPTR_FORMAT \" top \" INTPTR_FORMAT \" (%s)\", is_static() ? \"static \" : \"dynamic\",\n+    aot_log_info(aot)(\"Mapped %s region #%d at base \" INTPTR_FORMAT \" top \" INTPTR_FORMAT \" (%s)\", is_static() ? \"static \" : \"dynamic\",\n@@ -1156,1 +1168,1 @@\n-    log_info(cds)(\"Commit %s region #%d at base \" INTPTR_FORMAT \" top \" INTPTR_FORMAT \" (%s)%s\",\n+    aot_log_info(aot)(\"Commit %s region #%d at base \" INTPTR_FORMAT \" top \" INTPTR_FORMAT \" (%s)%s\",\n@@ -1160,1 +1172,1 @@\n-      log_error(cds)(\"Failed to commit %s region #%d (%s)\", is_static() ? \"static \" : \"dynamic\",\n+      aot_log_error(aot)(\"Failed to commit %s region #%d (%s)\", is_static() ? \"static \" : \"dynamic\",\n@@ -1209,1 +1221,1 @@\n-      log_info(cds)(\"Failed to read %s shared space into reserved space at \" INTPTR_FORMAT,\n+      aot_log_info(aot)(\"Failed to read %s shared space into reserved space at \" INTPTR_FORMAT,\n@@ -1223,1 +1235,1 @@\n-      log_info(cds)(\"Unable to map %s shared space at \" INTPTR_FORMAT,\n+      aot_log_info(aot)(\"Unable to map %s shared space at \" INTPTR_FORMAT,\n@@ -1263,1 +1275,1 @@\n-    log_error(cds)(\"relocation bitmap CRC error\");\n+    aot_log_error(aot)(\"relocation bitmap CRC error\");\n@@ -1272,1 +1284,1 @@\n-  log_info(cds)(\"Mapped %s region #%d at base \" INTPTR_FORMAT \" top \" INTPTR_FORMAT \" (%s)\",\n+  aot_log_info(aot)(\"Mapped %s region #%d at base \" INTPTR_FORMAT \" top \" INTPTR_FORMAT \" (%s)\",\n@@ -1289,1 +1301,1 @@\n-      log_info(cds)(\"Failed to read aot code shared space into reserved space at \" INTPTR_FORMAT,\n+      aot_log_info(aot)(\"Failed to read aot code shared space into reserved space at \" INTPTR_FORMAT,\n@@ -1302,1 +1314,1 @@\n-    log_info(cds)(\"failed to map aot code region\");\n+    aot_log_info(aot)(\"failed to map aot code region\");\n@@ -1308,1 +1320,1 @@\n-    log_info(cds)(\"Mapped static  region #%d at base \" INTPTR_FORMAT \" top \" INTPTR_FORMAT \" (%s)\",\n+    aot_log_info(aot)(\"Mapped static  region #%d at base \" INTPTR_FORMAT \" top \" INTPTR_FORMAT \" (%s)\",\n@@ -1344,1 +1356,1 @@\n-  log_debug(cds, reloc)(\"runtime archive relocation start\");\n+  aot_log_debug(aot, reloc)(\"runtime archive relocation start\");\n@@ -1391,1 +1403,1 @@\n-    log_debug(cds, reloc)(\"runtime archive relocation done\");\n+    aot_log_debug(aot, reloc)(\"runtime archive relocation done\");\n@@ -1440,1 +1452,1 @@\n-  log_info(cds)(\"Requested heap region [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] = %8zu bytes\",\n+  aot_log_info(aot)(\"Requested heap region [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] = %8zu bytes\",\n@@ -1470,1 +1482,1 @@\n-      log_error(cds)(\"%s has aot-linked classes but the archived \"\n+      aot_log_error(aot)(\"%s has aot-linked classes but the archived \"\n@@ -1504,1 +1516,1 @@\n-  log_info(cds)(\"CDS archive was created with max heap size = %zuM, and the following configuration:\",\n+  aot_log_info(aot)(\"CDS archive was created with max heap size = %zuM, and the following configuration:\",\n@@ -1506,1 +1518,1 @@\n-  log_info(cds)(\"    narrow_klass_base at mapping start address, narrow_klass_pointer_bits = %d, narrow_klass_shift = %d\",\n+  aot_log_info(aot)(\"    narrow_klass_base at mapping start address, narrow_klass_pointer_bits = %d, narrow_klass_shift = %d\",\n@@ -1508,1 +1520,1 @@\n-  log_info(cds)(\"    narrow_oop_mode = %d, narrow_oop_base = \" PTR_FORMAT \", narrow_oop_shift = %d\",\n+  aot_log_info(aot)(\"    narrow_oop_mode = %d, narrow_oop_base = \" PTR_FORMAT \", narrow_oop_shift = %d\",\n@@ -1510,1 +1522,1 @@\n-  log_info(cds)(\"The current max heap size = %zuM, G1HeapRegion::GrainBytes = %zu\",\n+  aot_log_info(aot)(\"The current max heap size = %zuM, G1HeapRegion::GrainBytes = %zu\",\n@@ -1512,1 +1524,1 @@\n-  log_info(cds)(\"    narrow_klass_base = \" PTR_FORMAT \", arrow_klass_pointer_bits = %d, narrow_klass_shift = %d\",\n+  aot_log_info(aot)(\"    narrow_klass_base = \" PTR_FORMAT \", arrow_klass_pointer_bits = %d, narrow_klass_shift = %d\",\n@@ -1514,1 +1526,1 @@\n-  log_info(cds)(\"    narrow_oop_mode = %d, narrow_oop_base = \" PTR_FORMAT \", narrow_oop_shift = %d\",\n+  aot_log_info(aot)(\"    narrow_oop_mode = %d, narrow_oop_base = \" PTR_FORMAT \", narrow_oop_shift = %d\",\n@@ -1516,1 +1528,1 @@\n-  log_info(cds)(\"    heap range = [\" PTR_FORMAT \" - \"  PTR_FORMAT \"]\",\n+  aot_log_info(aot)(\"    heap range = [\" PTR_FORMAT \" - \"  PTR_FORMAT \"]\",\n@@ -1543,5 +1555,14 @@\n-    LogTarget(Info, cds) lt;\n-    if (lt.is_enabled()) {\n-      LogStream ls(lt);\n-      ls.print_raw(ss.base());\n-      header()->print(&ls);\n+    if (CDSConfig::new_aot_flags_used()) {\n+      LogTarget(Info, aot) lt;\n+      if (lt.is_enabled()) {\n+        LogStream ls(lt);\n+        ls.print_raw(ss.base());\n+        header()->print(&ls);\n+      }\n+    } else {\n+      LogTarget(Info, cds) lt;\n+      if (lt.is_enabled()) {\n+        LogStream ls(lt);\n+        ls.print_raw(ss.base());\n+        header()->print(&ls);\n+      }\n@@ -1634,1 +1655,1 @@\n-  log_info(cds)(\"Preferred address to map heap data (to avoid relocation) is \" INTPTR_FORMAT, p2i(requested_start));\n+  aot_log_info(aot)(\"Preferred address to map heap data (to avoid relocation) is \" INTPTR_FORMAT, p2i(requested_start));\n@@ -1650,1 +1671,4 @@\n-  if (MetaspaceShared::use_windows_memory_mapping()) {\n+  if (MetaspaceShared::use_windows_memory_mapping() || UseLargePages) {\n+    \/\/ With UseLargePages, memory mapping may fail on some OSes if the size is not\n+    \/\/ large page aligned, so let's use read() instead. In this case, the memory region\n+    \/\/ is already commited by G1 so we don't need to commit it again.\n@@ -1653,1 +1677,1 @@\n-                     \/* do_commit = *\/ true)) {\n+                     \/* do_commit = *\/ !UseLargePages)) {\n@@ -1655,1 +1679,1 @@\n-      log_error(cds)(\"Failed to read archived heap region into \" INTPTR_FORMAT, p2i(addr));\n+      aot_log_error(aot)(\"Failed to read archived heap region into \" INTPTR_FORMAT, p2i(addr));\n@@ -1666,1 +1690,1 @@\n-      log_info(cds)(\"UseSharedSpaces: Unable to map at required address in java heap. \"\n+      aot_log_info(aot)(\"UseSharedSpaces: Unable to map at required address in java heap. \"\n@@ -1704,1 +1728,1 @@\n-  log_info(cds)(\"Heap data mapped at \" INTPTR_FORMAT \", size = %8zu bytes\",\n+  aot_log_info(aot)(\"Heap data mapped at \" INTPTR_FORMAT \", size = %8zu bytes\",\n@@ -1706,1 +1730,1 @@\n-  log_info(cds)(\"CDS heap data relocation delta = %zd bytes\", delta);\n+  aot_log_info(aot)(\"CDS heap data relocation delta = %zd bytes\", delta);\n@@ -1766,1 +1790,1 @@\n-      log_info(cds)(\"Unmapping region #%d at base \" INTPTR_FORMAT \" (%s)\", i, p2i(mapped_base),\n+      aot_log_info(aot)(\"Unmapping region #%d at base \" INTPTR_FORMAT \" (%s)\", i, p2i(mapped_base),\n@@ -1771,1 +1795,1 @@\n-        log_info(cds)(\"Region #%d (%s) is in a reserved space, it will be freed when the space is released\", i, shared_region_name[i]);\n+        aot_log_info(aot)(\"Region #%d (%s) is in a reserved space, it will be freed when the space is released\", i, shared_region_name[i]);\n@@ -1838,1 +1862,1 @@\n-      log_error(cds)(\"%s has aot-linked classes. It cannot be used when JVMTI ClassFileLoadHook is in use.\",\n+      aot_log_error(aot)(\"%s has aot-linked classes. It cannot be used when JVMTI ClassFileLoadHook is in use.\",\n@@ -1843,1 +1867,1 @@\n-      log_error(cds)(\"%s has aot-linked classes. It cannot be used when JVMTI early vm start is in use.\",\n+      aot_log_error(aot)(\"%s has aot-linked classes. It cannot be used when JVMTI early vm start is in use.\",\n@@ -1848,1 +1872,1 @@\n-      log_error(cds)(\"%s has aot-linked classes. It cannot be used when archived full module graph is not used.\",\n+      aot_log_error(aot)(\"%s has aot-linked classes. It cannot be used when archived full module graph is not used.\",\n@@ -1855,1 +1879,1 @@\n-      log_error(cds)(\"%s has aot-linked classes. It cannot be used with -Djava.security.manager=%s.\",\n+      aot_log_error(aot)(\"%s has aot-linked classes. It cannot be used with -Djava.security.manager=%s.\",\n@@ -1862,1 +1886,1 @@\n-      log_error(cds)(\"%s has aot-linked classes. It cannot be used with JDWP agent\", archive_type);\n+      aot_log_error(aot)(\"%s has aot-linked classes. It cannot be used with JDWP agent\", archive_type);\n@@ -1904,1 +1928,1 @@\n-    log_info(cds)(\"The %s's ObjectAlignmentInBytes of %d\"\n+    aot_log_info(aot)(\"The %s's ObjectAlignmentInBytes of %d\"\n@@ -1910,1 +1934,1 @@\n-    log_info(cds)(\"The %s's CompactStrings setting (%s)\"\n+    aot_log_info(aot)(\"The %s's CompactStrings setting (%s)\"\n@@ -1916,0 +1940,75 @@\n+  bool jvmci_compiler_is_enabled = CompilerConfig::is_jvmci_compiler_enabled();\n+  CompilerType compiler_type = CompilerConfig::compiler_type();\n+  CompilerType archive_compiler_type = CompilerType(_compiler_type);\n+  \/\/ JVMCI compiler does different type profiling settigns and generate\n+  \/\/ different code. We can't use archive which was produced\n+  \/\/ without it and reverse.\n+  \/\/ Only allow mix when JIT compilation is disabled.\n+  \/\/ Interpreter is used by default when dumping archive.\n+  bool intepreter_is_used = (archive_compiler_type == CompilerType::compiler_none) ||\n+                            (compiler_type == CompilerType::compiler_none);\n+  if (!intepreter_is_used &&\n+      jvmci_compiler_is_enabled != (archive_compiler_type == CompilerType::compiler_jvmci)) {\n+    MetaspaceShared::report_loading_error(\"The %s's JIT compiler setting (%s)\"\n+                                          \" does not equal the current setting (%s).\", file_type,\n+                                          compilertype2name(archive_compiler_type), compilertype2name(compiler_type));\n+    return false;\n+  }\n+  if (TrainingData::have_data()) {\n+    if (_type_profile_level != TypeProfileLevel) {\n+      MetaspaceShared::report_loading_error(\"The %s's TypeProfileLevel setting (%d)\"\n+                                            \" does not equal the current TypeProfileLevel setting (%d).\", file_type,\n+                                            _type_profile_level, TypeProfileLevel);\n+      return false;\n+    }\n+    if (_type_profile_args_limit != TypeProfileArgsLimit) {\n+      MetaspaceShared::report_loading_error(\"The %s's TypeProfileArgsLimit setting (%d)\"\n+                                            \" does not equal the current TypeProfileArgsLimit setting (%d).\", file_type,\n+                                            _type_profile_args_limit, TypeProfileArgsLimit);\n+      return false;\n+    }\n+    if (_type_profile_parms_limit != TypeProfileParmsLimit) {\n+      MetaspaceShared::report_loading_error(\"The %s's TypeProfileParamsLimit setting (%d)\"\n+                                            \" does not equal the current TypeProfileParamsLimit setting (%d).\", file_type,\n+                                            _type_profile_args_limit, TypeProfileArgsLimit);\n+      return false;\n+\n+    }\n+    if (_type_profile_width != TypeProfileWidth) {\n+      MetaspaceShared::report_loading_error(\"The %s's TypeProfileWidth setting (%d)\"\n+                                            \" does not equal the current TypeProfileWidth setting (%d).\", file_type,\n+                                            (int)_type_profile_width, (int)TypeProfileWidth);\n+      return false;\n+\n+    }\n+    if (_bci_profile_width != BciProfileWidth) {\n+      MetaspaceShared::report_loading_error(\"The %s's BciProfileWidth setting (%d)\"\n+                                            \" does not equal the current BciProfileWidth setting (%d).\", file_type,\n+                                            (int)_bci_profile_width, (int)BciProfileWidth);\n+      return false;\n+    }\n+    if (_type_profile_casts != TypeProfileCasts) {\n+      MetaspaceShared::report_loading_error(\"The %s's TypeProfileCasts setting (%s)\"\n+                                            \" does not equal the current TypeProfileCasts setting (%s).\", file_type,\n+                                            _type_profile_casts ? \"enabled\" : \"disabled\",\n+                                            TypeProfileCasts    ? \"enabled\" : \"disabled\");\n+\n+      return false;\n+\n+    }\n+    if (_profile_traps != ProfileTraps) {\n+      MetaspaceShared::report_loading_error(\"The %s's ProfileTraps setting (%s)\"\n+                                            \" does not equal the current ProfileTraps setting (%s).\", file_type,\n+                                            _profile_traps ? \"enabled\" : \"disabled\",\n+                                            ProfileTraps   ? \"enabled\" : \"disabled\");\n+\n+      return false;\n+    }\n+    if (_spec_trap_limit_extra_entries != SpecTrapLimitExtraEntries) {\n+      MetaspaceShared::report_loading_error(\"The %s's SpecTrapLimitExtraEntries setting (%d)\"\n+                                            \" does not equal the current SpecTrapLimitExtraEntries setting (%d).\", file_type,\n+                                            _spec_trap_limit_extra_entries, SpecTrapLimitExtraEntries);\n+      return false;\n+\n+    }\n+  }\n@@ -1922,1 +2021,1 @@\n-      log_error(cds)(\"%s has aot-linked classes. It cannot be used when the \"\n+      aot_log_error(aot)(\"%s has aot-linked classes. It cannot be used when the \"\n@@ -1926,1 +2025,1 @@\n-    log_warning(cds)(\"Archived non-system classes are disabled because the \"\n+    aot_log_warning(aot)(\"Archived non-system classes are disabled because the \"\n@@ -1935,1 +2034,1 @@\n-    log_info(cds)(\"The %s's BytecodeVerificationLocal setting (%s)\"\n+    aot_log_info(aot)(\"The %s's BytecodeVerificationLocal setting (%s)\"\n@@ -1947,1 +2046,1 @@\n-    log_info(cds)(\"The %s was created with less restrictive \"\n+    aot_log_info(aot)(\"The %s was created with less restrictive \"\n@@ -1959,1 +2058,1 @@\n-    log_warning(cds)(\"The setting of the AllowArchivingWithJavaAgent is different \"\n+    aot_log_warning(aot)(\"The setting of the AllowArchivingWithJavaAgent is different \"\n@@ -1965,1 +2064,1 @@\n-    log_warning(cds)(\"This %s was created with AllowArchivingWithJavaAgent. It should be used \"\n+    aot_log_warning(aot)(\"This %s was created with AllowArchivingWithJavaAgent. It should be used \"\n@@ -1969,1 +2068,1 @@\n-  log_info(cds)(\"The %s was created with UseCompressedOops = %d, UseCompressedClassPointers = %d, UseCompactObjectHeaders = %d\",\n+  aot_log_info(aot)(\"The %s was created with UseCompressedOops = %d, UseCompressedClassPointers = %d, UseCompactObjectHeaders = %d\",\n@@ -1972,1 +2071,1 @@\n-    log_warning(cds)(\"Unable to use %s.\\nThe saved state of UseCompressedOops and UseCompressedClassPointers is \"\n+    aot_log_warning(aot)(\"Unable to use %s.\\nThe saved state of UseCompressedOops and UseCompressedClassPointers is \"\n@@ -1978,1 +2077,1 @@\n-    log_warning(cds)(\"Unable to use %s.\\nThe %s's UseCompactObjectHeaders setting (%s)\"\n+    aot_log_warning(aot)(\"Unable to use %s.\\nThe %s's UseCompactObjectHeaders setting (%s)\"\n@@ -1987,1 +2086,1 @@\n-    log_info(cds)(\"optimized module handling: disabled because archive was created without optimized module handling\");\n+    aot_log_info(aot)(\"optimized module handling: disabled because archive was created without optimized module handling\");\n@@ -2075,1 +2174,1 @@\n-  log_debug(cds, jvmti)(\"classfile data for %s [%d: %s] = %d bytes\", class_name, path_index,\n+  log_debug(aot, jvmti)(\"classfile data for %s [%d: %s] = %d bytes\", class_name, path_index,\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":208,"deletions":109,"binary":false,"changes":317,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/aotLogging.hpp\"\n@@ -38,0 +39,1 @@\n+#include \"cds\/regeneratedClasses.hpp\"\n@@ -39,1 +41,0 @@\n-#include \"classfile\/classLoaderExt.hpp\"\n@@ -177,1 +178,1 @@\n-      if (log_is_enabled(Debug, cds)) {\n+      if (log_is_enabled(Debug, aot)) {\n@@ -179,1 +180,1 @@\n-        log_debug(cds)(\"  calling %s\", method->name_and_sig_as_C_string());\n+        log_debug(aot)(\"  calling %s\", method->name_and_sig_as_C_string());\n@@ -191,1 +192,1 @@\n-  log_debug(cds)(\"Resetting platform loader\");\n+  log_debug(aot)(\"Resetting platform loader\");\n@@ -193,1 +194,1 @@\n-  log_debug(cds)(\"Resetting system loader\");\n+  log_debug(aot)(\"Resetting system loader\");\n@@ -203,1 +204,1 @@\n-  log_debug(cds)(\"Resetting boot loader\");\n+  log_debug(aot)(\"Resetting boot loader\");\n@@ -280,1 +281,1 @@\n-    if (log_is_enabled(Debug, cds, heap)) {\n+    if (log_is_enabled(Debug, aot, heap)) {\n@@ -282,1 +283,1 @@\n-      log_debug(cds, heap)(\"Clearing root %d: was \" PTR_FORMAT, index, p2i(old));\n+      log_debug(aot, heap)(\"Clearing root %d: was \" PTR_FORMAT, index, p2i(old));\n@@ -297,1 +298,1 @@\n-    log_debug(cds, heap)(\"Cannot archive, object (\" PTR_FORMAT \") is too large: %zu\",\n+    log_debug(aot, heap)(\"Cannot archive, object (\" PTR_FORMAT \") is too large: %zu\",\n@@ -339,0 +340,3 @@\n+          if (RegeneratedClasses::has_been_regenerated(m)) {\n+            m = RegeneratedClasses::get_regenerated_object(m);\n+          }\n@@ -345,1 +349,1 @@\n-    if (log_is_enabled(Debug, cds, heap)) {\n+    if (log_is_enabled(Debug, aot, heap)) {\n@@ -347,1 +351,1 @@\n-      LogTarget(Debug, cds, heap) log;\n+      LogTarget(Debug, aot, heap) log;\n@@ -508,3 +512,9 @@\n-  oop orig_mirror = ik->java_mirror();\n-  oop m = scratch_java_mirror(ik);\n-  assert(ik->is_initialized(), \"must be\");\n+  oop orig_mirror;\n+  if (RegeneratedClasses::is_regenerated_object(ik)) {\n+    InstanceKlass* orig_ik = RegeneratedClasses::get_original_object(ik);\n+    precond(orig_ik->is_initialized());\n+    orig_mirror = orig_ik->java_mirror();\n+  } else {\n+    precond(ik->is_initialized());\n+    orig_mirror = ik->java_mirror();\n+  }\n@@ -512,0 +522,1 @@\n+  oop m = scratch_java_mirror(ik);\n@@ -572,1 +583,1 @@\n-  if (log_is_enabled(Debug, cds, init)) {\n+  if (log_is_enabled(Debug, aot, init)) {\n@@ -574,1 +585,1 @@\n-    log_debug(cds, init)(\"copied %3d field(s) in aot-initialized mirror %s%s%s\", nfields, ik->external_name(),\n+    log_debug(aot, init)(\"copied %3d field(s) in aot-initialized mirror %s%s%s\", nfields, ik->external_name(),\n@@ -673,1 +684,1 @@\n-      log_info(cds)(\"Heap range = [\" PTR_FORMAT \" - \"  PTR_FORMAT \"]\",\n+      aot_log_info(aot)(\"Heap range = [\" PTR_FORMAT \" - \"  PTR_FORMAT \"]\",\n@@ -821,1 +832,1 @@\n-      assert(InstanceKlass::cast(abk)->is_shared_boot_class(),\n+      assert(InstanceKlass::cast(abk)->defined_by_boot_loader(),\n@@ -836,1 +847,1 @@\n-  if (log_is_enabled(Debug, cds, heap)) {\n+  if (log_is_enabled(Debug, aot, heap)) {\n@@ -839,1 +850,1 @@\n-      log_debug(cds, heap)(\"Adding klass %s\", orig_k->external_name());\n+      log_debug(aot, heap)(\"Adding klass %s\", orig_k->external_name());\n@@ -882,1 +893,1 @@\n-  log_error(cds, heap)(\"Class %s not allowed in archive heap. Must be in java.base%s%s\",\n+  log_error(aot, heap)(\"Class %s not allowed in archive heap. Must be in java.base%s%s\",\n@@ -894,1 +905,1 @@\n-      log_info(cds, heap)(\"non-early: %s\", k->external_name());\n+      log_info(aot, heap)(\"non-early: %s\", k->external_name());\n@@ -922,1 +933,1 @@\n-    log_info(cds, heap)(\n+    log_info(aot, heap)(\n@@ -961,1 +972,1 @@\n-      if (log_is_enabled(Info, cds, heap)) {\n+      if (log_is_enabled(Info, aot, heap)) {\n@@ -967,1 +978,1 @@\n-        log_info(cds, heap)(\n+        log_info(aot, heap)(\n@@ -1036,1 +1047,1 @@\n-  if (log_is_enabled(Info, cds, heap)) {\n+  if (log_is_enabled(Info, aot, heap)) {\n@@ -1071,1 +1082,1 @@\n-    log_info(cds, heap)(\"Verify heap %s initializing static field(s) in %s\",\n+    log_info(aot, heap)(\"Verify heap %s initializing static field(s) in %s\",\n@@ -1085,1 +1096,1 @@\n-      log_info(cds, heap)(\"Trigger GC %s initializing static field(s) in %s\",\n+      log_info(aot, heap)(\"Trigger GC %s initializing static field(s) in %s\",\n@@ -1115,1 +1126,1 @@\n-    assert(k != nullptr && k->is_shared_boot_class(), \"sanity\");\n+    assert(k != nullptr && k->defined_by_boot_loader(), \"sanity\");\n@@ -1204,1 +1215,1 @@\n-    log_info(cds, heap)(\"Skip initializing ArchivedModuleGraph subgraph: is_using_optimized_module_handling=%s num_module_paths=%d\",\n+    log_info(aot, heap)(\"Skip initializing ArchivedModuleGraph subgraph: is_using_optimized_module_handling=%s num_module_paths=%d\",\n@@ -1247,1 +1258,1 @@\n-    if (log_is_enabled(Info, cds, heap)) {\n+    if (log_is_enabled(Info, aot, heap)) {\n@@ -1249,1 +1260,1 @@\n-      log_info(cds, heap)(\"subgraph %s is not recorded\",\n+      log_info(aot, heap)(\"subgraph %s is not recorded\",\n@@ -1255,1 +1266,1 @@\n-      if (log_is_enabled(Info, cds, heap)) {\n+      if (log_is_enabled(Info, aot, heap)) {\n@@ -1257,1 +1268,1 @@\n-        log_info(cds, heap)(\"subgraph %s cannot be used because full module graph is disabled\",\n+        log_info(aot, heap)(\"subgraph %s cannot be used because full module graph is disabled\",\n@@ -1264,1 +1275,1 @@\n-      if (log_is_enabled(Info, cds, heap)) {\n+      if (log_is_enabled(Info, aot, heap)) {\n@@ -1266,1 +1277,1 @@\n-        log_info(cds, heap)(\"subgraph %s cannot be used because JVMTI ClassFileLoadHook is enabled\",\n+        log_info(aot, heap)(\"subgraph %s cannot be used because JVMTI ClassFileLoadHook is enabled\",\n@@ -1272,1 +1283,1 @@\n-    if (log_is_enabled(Info, cds, heap)) {\n+    if (log_is_enabled(Info, aot, heap)) {\n@@ -1274,1 +1285,1 @@\n-      log_info(cds, heap)(\"%s subgraph %s \", do_init ? \"init\" : \"resolve\", k->external_name());\n+      log_info(aot, heap)(\"%s subgraph %s \", do_init ? \"init\" : \"resolve\", k->external_name());\n@@ -1302,1 +1313,1 @@\n-  assert(k->is_shared_boot_class(), \"sanity\");\n+  assert(k->defined_by_boot_loader(), \"sanity\");\n@@ -1346,1 +1357,1 @@\n-      log_debug(cds, heap)(\"  \" PTR_FORMAT \" init field @ %2d = \" PTR_FORMAT, p2i(k), field_offset, p2i(v));\n+      log_debug(aot, heap)(\"  \" PTR_FORMAT \" init field @ %2d = \" PTR_FORMAT, p2i(k), field_offset, p2i(v));\n@@ -1351,1 +1362,1 @@\n-    if (log_is_enabled(Info, cds, heap)) {\n+    if (log_is_enabled(Info, aot, heap)) {\n@@ -1353,1 +1364,1 @@\n-      log_info(cds, heap)(\"initialize_from_archived_subgraph %s \" PTR_FORMAT \"%s%s\",\n+      log_info(aot, heap)(\"initialize_from_archived_subgraph %s \" PTR_FORMAT \"%s%s\",\n@@ -1425,1 +1436,1 @@\n-      if (!_record_klasses_only && log_is_enabled(Debug, cds, heap)) {\n+      if (!_record_klasses_only && log_is_enabled(Debug, aot, heap)) {\n@@ -1427,1 +1438,1 @@\n-        log_debug(cds, heap)(\"(%d) %s[%d] ==> \" PTR_FORMAT \" size %zu %s\", _level,\n+        log_debug(aot, heap)(\"(%d) %s[%d] ==> \" PTR_FORMAT \" size %zu %s\", _level,\n@@ -1430,2 +1441,2 @@\n-        if (log_is_enabled(Trace, cds, heap)) {\n-          LogTarget(Trace, cds, heap) log;\n+        if (log_is_enabled(Trace, aot, heap)) {\n+          LogTarget(Trace, aot, heap) log;\n@@ -1518,1 +1529,1 @@\n-    log_error(cds, heap)(\"Cannot archive object \" PTR_FORMAT \" of class %s\", p2i(orig_obj), orig_obj->klass()->external_name());\n+    log_error(aot, heap)(\"Cannot archive object \" PTR_FORMAT \" of class %s\", p2i(orig_obj), orig_obj->klass()->external_name());\n@@ -1523,1 +1534,1 @@\n-  if (log_is_enabled(Debug, cds, heap) && java_lang_Class::is_instance(orig_obj)) {\n+  if (log_is_enabled(Debug, aot, heap) && java_lang_Class::is_instance(orig_obj)) {\n@@ -1525,1 +1536,1 @@\n-    LogTarget(Debug, cds, heap) log;\n+    LogTarget(Debug, aot, heap) log;\n@@ -1538,0 +1549,7 @@\n+  if (java_lang_Class::is_instance(orig_obj)) {\n+    Klass* k = java_lang_Class::as_Klass(orig_obj);\n+    if (RegeneratedClasses::has_been_regenerated(k)) {\n+      orig_obj = RegeneratedClasses::get_regenerated_object(k)->java_mirror();\n+    }\n+  }\n+\n@@ -1564,1 +1582,1 @@\n-      log_error(cds, heap)(\"(%d) Unknown java.lang.Class object is in the archived sub-graph\", level);\n+      log_error(aot, heap)(\"(%d) Unknown java.lang.Class object is in the archived sub-graph\", level);\n@@ -1584,1 +1602,1 @@\n-      log_error(cds, heap)(\n+      log_error(aot, heap)(\n@@ -1662,1 +1680,1 @@\n-  assert(k->is_shared_boot_class(), \"must be boot class\");\n+  assert(k->defined_by_boot_loader(), \"must be boot class\");\n@@ -1669,1 +1687,1 @@\n-  log_debug(cds, heap)(\"Start archiving from: %s::%s (\" PTR_FORMAT \")\", klass_name, field_name, p2i(f));\n+  log_debug(aot, heap)(\"Start archiving from: %s::%s (\" PTR_FORMAT \")\", klass_name, field_name, p2i(f));\n@@ -1672,2 +1690,2 @@\n-    if (log_is_enabled(Trace, cds, heap)) {\n-      LogTarget(Trace, cds, heap) log;\n+    if (log_is_enabled(Trace, aot, heap)) {\n+      LogTarget(Trace, aot, heap) log;\n@@ -1680,1 +1698,1 @@\n-      log_error(cds, heap)(\"Archiving failed %s::%s (some reachable objects cannot be archived)\",\n+      log_error(aot, heap)(\"Archiving failed %s::%s (some reachable objects cannot be archived)\",\n@@ -1687,1 +1705,1 @@\n-      log_info(cds, heap)(\"Archived field %s::%s => \" PTR_FORMAT, klass_name, field_name, p2i(f));\n+      log_info(aot, heap)(\"Archived field %s::%s => \" PTR_FORMAT, klass_name, field_name, p2i(f));\n@@ -1713,1 +1731,1 @@\n-  assert(k->is_shared_boot_class(), \"must be boot class\");\n+  assert(k->defined_by_boot_loader(), \"must be boot class\");\n@@ -1806,1 +1824,1 @@\n-  log_info(cds, heap)(\"Start recording subgraph(s) for archived fields in %s\", class_name);\n+  log_info(aot, heap)(\"Start recording subgraph(s) for archived fields in %s\", class_name);\n@@ -1817,1 +1835,1 @@\n-  log_info(cds, heap)(\"Done recording subgraph(s) for archived fields in %s: \"\n+  log_info(aot, heap)(\"Done recording subgraph(s) for archived fields in %s: \"\n@@ -1869,1 +1887,1 @@\n-      log_warning(cds)(\"Loading ArchiveHeapTestClass %s ...\", test_class_name);\n+      log_warning(aot)(\"Loading ArchiveHeapTestClass %s ...\", test_class_name);\n@@ -1887,1 +1905,1 @@\n-    assert(InstanceKlass::cast(ik)->is_shared_boot_class(),\n+    assert(InstanceKlass::cast(ik)->defined_by_boot_loader(),\n@@ -1917,1 +1935,1 @@\n-      log_warning(cds)(\"Initializing ArchiveHeapTestClass %s ...\", test_class_name);\n+      log_warning(aot)(\"Initializing ArchiveHeapTestClass %s ...\", test_class_name);\n@@ -2066,1 +2084,1 @@\n-  log_info(cds, heap)(\"Archived subgraph records = %d\",\n+  log_info(aot, heap)(\"Archived subgraph records = %d\",\n@@ -2068,3 +2086,3 @@\n-  log_info(cds, heap)(\"  Walked %d objects\", _num_total_walked_objs);\n-  log_info(cds, heap)(\"  Archived %d objects\", _num_total_archived_objs);\n-  log_info(cds, heap)(\"  Recorded %d klasses\", _num_total_recorded_klasses);\n+  log_info(aot, heap)(\"  Walked %d objects\", _num_total_walked_objs);\n+  log_info(aot, heap)(\"  Archived %d objects\", _num_total_archived_objs);\n+  log_info(aot, heap)(\"  Recorded %d klasses\", _num_total_recorded_klasses);\n@@ -2077,1 +2095,1 @@\n-  log_info(cds, heap)(\"  Verified %d references\", _num_total_verifications);\n+  log_info(aot, heap)(\"  Verified %d references\", _num_total_verifications);\n@@ -2104,1 +2122,1 @@\n-    LogStream ls(Log(cds, heap)::error());\n+    LogStream ls(Log(aot, heap)::error());\n@@ -2177,1 +2195,1 @@\n-    log_info(cds, heap)(\"%8zu objects are <= %-6zu\"\n+    log_info(aot, heap)(\"%8zu objects are <= %-6zu\"\n@@ -2184,1 +2202,1 @@\n-  log_info(cds, heap)(\"%8zu huge  objects               (total %8zu bytes\"\n+  log_info(aot, heap)(\"%8zu huge  objects               (total %8zu bytes\"\n@@ -2188,1 +2206,1 @@\n-  log_info(cds, heap)(\"%8zu total objects               (total %8zu bytes\"\n+  log_info(aot, heap)(\"%8zu total objects               (total %8zu bytes\"\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":90,"deletions":72,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cds\/aotLogging.hpp\"\n@@ -51,1 +52,0 @@\n-#include \"classfile\/classLoaderExt.hpp\"\n@@ -74,0 +74,1 @@\n+#include \"memory\/oopFactory.hpp\"\n@@ -83,0 +84,1 @@\n+#include \"oops\/trainingData.hpp\"\n@@ -189,1 +191,1 @@\n-      log_info(cds, hashtables)(\"Expanded _dumped_classes table to %d\", _dumped_classes.table_size());\n+      log_info(aot, hashtables)(\"Expanded _dumped_classes table to %d\", _dumped_classes.table_size());\n@@ -260,1 +262,1 @@\n-    log_info(cds)(\"SharedBaseAddress (\" INTPTR_FORMAT \") aligned up to \" INTPTR_FORMAT,\n+    aot_log_info(aot)(\"SharedBaseAddress (\" INTPTR_FORMAT \") aligned up to \" INTPTR_FORMAT,\n@@ -278,1 +280,1 @@\n-  log_warning(cds)(\"SharedBaseAddress (\" INTPTR_FORMAT \") is %s. Reverted to \" INTPTR_FORMAT,\n+  aot_log_warning(aot)(\"SharedBaseAddress (\" INTPTR_FORMAT \") is %s. Reverted to \" INTPTR_FORMAT,\n@@ -293,1 +295,1 @@\n-  log_info(cds)(\"Core region alignment: %zu\", core_region_alignment());\n+  aot_log_info(aot)(\"Core region alignment: %zu\", core_region_alignment());\n@@ -317,1 +319,1 @@\n-    log_error(cds)(\"Unable to reserve memory for symbols: %zu bytes.\", symbol_rs_size);\n+    aot_log_error(aot)(\"Unable to reserve memory for symbols: %zu bytes.\", symbol_rs_size);\n@@ -353,1 +355,1 @@\n-      log_error(cds)(\"string length too large: %d\", utf8_length);\n+      aot_log_error(aot)(\"string length too large: %d\", utf8_length);\n@@ -370,1 +372,1 @@\n-        log_warning(cds, heap)(\"[line %d] extra interned string allocation failed; size too large: %d\",\n+        log_warning(aot, heap)(\"[line %d] extra interned string allocation failed; size too large: %d\",\n@@ -376,1 +378,1 @@\n-          log_warning(cds, heap)(\"[line %d] extra interned string ignored; size too large: %d\",\n+          log_warning(aot, heap)(\"[line %d] extra interned string ignored; size too large: %d\",\n@@ -410,1 +412,1 @@\n-  log_info(cds)(\"Archived %d method handle intrinsics (%d bytes)\", len, word_size * BytesPerWord);\n+  log_info(aot)(\"Archived %d method handle intrinsics (%d bytes)\", len, word_size * BytesPerWord);\n@@ -485,0 +487,1 @@\n+  TrainingData::serialize(soc);\n@@ -542,1 +545,1 @@\n-    log_info(cds)(\"Dumping symbol table ...\");\n+    log_info(aot)(\"Dumping symbol table ...\");\n@@ -571,0 +574,1 @@\n+    TrainingData::iterate_roots(it);\n@@ -610,0 +614,3 @@\n+\n+  TrainingData::dump_training_data();\n+\n@@ -615,1 +622,1 @@\n-  if (AOTCodeCache::is_dumping_adapters()) {\n+  if (CDSConfig::is_dumping_adapters()) {\n@@ -659,1 +666,1 @@\n-  log_info(cds)(\"Make classes shareable\");\n+  log_info(aot)(\"Make classes shareable\");\n@@ -671,1 +678,1 @@\n-    log_info(cds)(\"Adjust lambda proxy class dictionary\");\n+    log_info(aot)(\"Adjust lambda proxy class dictionary\");\n@@ -675,0 +682,3 @@\n+  log_info(cds)(\"Make training data shareable\");\n+  _builder.make_training_data_shareable();\n+\n@@ -735,1 +745,1 @@\n-  if (CDSConfig::is_dumping_dynamic_archive() && ik->is_shared_unregistered_class()) {\n+  if (CDSConfig::is_dumping_dynamic_archive() && ik->defined_by_other_loaders()) {\n@@ -793,0 +803,7 @@\n+ HandleMark hm(THREAD);\n+\n+ if (CDSConfig::is_dumping_final_static_archive() && AOTPrintTrainingInfo) {\n+   tty->print_cr(\"==================== archived_training_data ** before dumping ====================\");\n+   TrainingData::print_archived_training_data_on(tty);\n+ }\n+\n@@ -797,1 +814,1 @@\n-      log_error(cds)(\"Out of memory. Please run with a larger Java heap, current MaxHeapSize = \"\n+      aot_log_error(aot)(\"Out of memory. Please run with a larger Java heap, current MaxHeapSize = \"\n@@ -801,3 +818,5 @@\n-      log_error(cds)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(),\n-                     java_lang_String::as_utf8_string(java_lang_Throwable::message(PENDING_EXCEPTION)));\n-      MetaspaceShared::writing_error(\"Unexpected exception, use -Xlog:cds,exceptions=trace for detail\");\n+      oop message = java_lang_Throwable::message(PENDING_EXCEPTION);\n+      aot_log_error(aot)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(),\n+                         message == nullptr ? \"(null)\" : java_lang_String::as_utf8_string(message));\n+      MetaspaceShared::writing_error(err_msg(\"Unexpected exception, use -Xlog:aot%s,exceptions=trace for detail\",\n+                                             CDSConfig::new_aot_flags_used() ? \"\" : \",cds\"));\n@@ -812,1 +831,0 @@\n-      tty->print_cr(\"AOTConfiguration recorded: %s\", AOTConfiguration);\n@@ -821,1 +839,0 @@\n-        vm_exit(0);\n@@ -824,1 +841,1 @@\n-        vm_exit(0);\n+      vm_direct_exit(0);\n@@ -840,1 +857,1 @@\n-    log_debug(cds)(\"Setting MinHeapSize to 4G for CDS dumping, original size = %zuM\", MinHeapSize\/M);\n+    log_debug(aot)(\"Setting MinHeapSize to 4G for CDS dumping, original size = %zuM\", MinHeapSize\/M);\n@@ -844,1 +861,1 @@\n-    log_debug(cds)(\"Setting InitialHeapSize to 4G for CDS dumping, original size = %zuM\", InitialHeapSize\/M);\n+    log_debug(aot)(\"Setting InitialHeapSize to 4G for CDS dumping, original size = %zuM\", InitialHeapSize\/M);\n@@ -848,1 +865,1 @@\n-    log_debug(cds)(\"Setting MaxHeapSize to 4G for CDS dumping, original size = %zuM\", MaxHeapSize\/M);\n+    log_debug(aot)(\"Setting MaxHeapSize to 4G for CDS dumping, original size = %zuM\", MaxHeapSize\/M);\n@@ -871,1 +888,1 @@\n-  log_info(cds)(\"Loading classes to share ...\");\n+  aot_log_info(aot)(\"Loading classes to share ...\");\n@@ -892,1 +909,1 @@\n-  log_info(cds)(\"Loading classes to share: done.\");\n+  aot_log_info(aot)(\"Loading classes to share: done.\");\n@@ -910,1 +927,1 @@\n-      log_info(cds)(\"Reading extra data from %s ...\", SharedArchiveConfigFile);\n+      log_info(aot)(\"Reading extra data from %s ...\", SharedArchiveConfigFile);\n@@ -912,1 +929,1 @@\n-      log_info(cds)(\"Reading extra data: done.\");\n+      log_info(aot)(\"Reading extra data: done.\");\n@@ -917,1 +934,1 @@\n-    log_info(cds)(\"Reading lambda form invokers from JDK default classlist ...\");\n+    log_info(aot)(\"Reading lambda form invokers from JDK default classlist ...\");\n@@ -941,1 +958,1 @@\n-      log_info(cds)(\"Loading extra classes from %s ...\", ExtraSharedClassListFile);\n+      log_info(aot)(\"Loading extra classes from %s ...\", ExtraSharedClassListFile);\n@@ -948,1 +965,1 @@\n-  log_info(cds)(\"Rewriting and linking classes ...\");\n+  log_info(aot)(\"Rewriting and linking classes ...\");\n@@ -955,1 +972,2 @@\n-  log_info(cds)(\"Rewriting and linking classes: done\");\n+  log_info(aot)(\"Rewriting and linking classes: done\");\n+  TrainingData::init_dumptime_table(CHECK); \/\/ captures TrainingDataSetLocker\n@@ -976,1 +994,1 @@\n-      log_debug(cds)(\"Resetting Class::reflectionFactory\");\n+      log_debug(aot)(\"Resetting Class::reflectionFactory\");\n@@ -991,1 +1009,1 @@\n-    log_info(cds)(\"Not dumping heap, reset CDSConfig::_is_using_optimized_module_handling\");\n+    log_info(aot)(\"Not dumping heap, reset CDSConfig::_is_using_optimized_module_handling\");\n@@ -1010,1 +1028,10 @@\n-  if (!write_static_archive(&builder, op.map_info(), op.heap_info())) {\n+  bool status = write_static_archive(&builder, op.map_info(), op.heap_info());\n+  if (status && CDSConfig::is_dumping_preimage_static_archive()) {\n+    tty->print_cr(\"%s AOTConfiguration recorded: %s\",\n+                  CDSConfig::has_temp_aot_config_file() ? \"Temporary\" : \"\", AOTConfiguration);\n+    if (CDSConfig::is_single_command_training()) {\n+      fork_and_dump_final_static_archive(CHECK);\n+    }\n+  }\n+\n+  if (!status) {\n@@ -1027,1 +1054,1 @@\n-    log_warning(cds)(\"This %s was created with AllowArchivingWithJavaAgent. It should be used \"\n+    aot_log_warning(aot)(\"This %s was created with AllowArchivingWithJavaAgent. It should be used \"\n@@ -1033,0 +1060,126 @@\n+static void print_java_launcher(outputStream* st) {\n+  st->print(\"%s%sbin%sjava\", Arguments::get_java_home(), os::file_separator(), os::file_separator());\n+}\n+\n+static void append_args(GrowableArray<Handle>* args, const char* arg, TRAPS) {\n+  Handle string = java_lang_String::create_from_str(arg, CHECK);\n+  args->append(string);\n+}\n+\n+\/\/ Pass all options in Arguments::jvm_args_array() to a child JVM process\n+\/\/ using the JAVA_TOOL_OPTIONS environment variable.\n+static int exec_jvm_with_java_tool_options(const char* java_launcher_path, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  HandleMark hm(THREAD);\n+  GrowableArray<Handle> args;\n+\n+  const char* cp = Arguments::get_appclasspath();\n+  if (cp != nullptr && strlen(cp) > 0 && strcmp(cp, \".\") != 0) {\n+    \/\/ We cannot use \"-cp\", because \"-cp\" is only interpreted by the java launcher,\n+    \/\/ and is not interpreter by arguments.cpp when it loads args from JAVA_TOOL_OPTIONS\n+    stringStream ss;\n+    ss.print(\"-Djava.class.path=\");\n+    ss.print_raw(cp);\n+    append_args(&args, ss.freeze(), CHECK_0);\n+    \/\/ CDS$ProcessLauncher::execWithJavaToolOptions() must unset CLASSPATH, which has\n+    \/\/ a higher priority than -Djava.class.path=\n+  }\n+\n+  \/\/ Pass all arguments. These include those from JAVA_TOOL_OPTIONS and _JAVA_OPTIONS.\n+  for (int i = 0; i < Arguments::num_jvm_args(); i++) {\n+    const char* arg = Arguments::jvm_args_array()[i];\n+    if (strstr(arg, \"-XX:AOTCacheOutput=\") == arg || \/\/ arg starts with ...\n+        strstr(arg, \"-XX:AOTConfiguration=\") == arg ||\n+        strstr(arg, \"-XX:AOTMode=\") == arg) {\n+      \/\/ Filter these out. They wiill be set below.\n+    } else {\n+      append_args(&args, arg, CHECK_0);\n+    }\n+  }\n+\n+  \/\/ Note: because we are running in AOTMode=record, JDK_AOT_VM_OPTIONS have not been\n+  \/\/ parsed, so they are not in Arguments::jvm_args_array. If JDK_AOT_VM_OPTIONS is in\n+  \/\/ the environment, it will be inherited and parsed by the child JVM process\n+  \/\/ in Arguments::parse_java_tool_options_environment_variable().\n+  precond(strcmp(AOTMode, \"record\") == 0);\n+\n+  \/\/ We don't pass Arguments::jvm_flags_array(), as those will be added by\n+  \/\/ the child process when it loads .hotspotrc\n+\n+  {\n+    \/\/ If AOTCacheOutput contains %p, it should have been already substituted with the\n+    \/\/ pid of the training process.\n+    stringStream ss;\n+    ss.print(\"-XX:AOTCacheOutput=\");\n+    ss.print_raw(AOTCacheOutput);\n+    append_args(&args, ss.freeze(), CHECK_0);\n+  }\n+  {\n+    \/\/ If AOTCacheConfiguration contains %p, it should have been already substituted with the\n+    \/\/ pid of the training process.\n+    \/\/ If AOTCacheConfiguration was not explicitly specified, it should have been assigned a\n+    \/\/ temporary file name.\n+    stringStream ss;\n+    ss.print(\"-XX:AOTConfiguration=\");\n+    ss.print_raw(AOTConfiguration);\n+    append_args(&args, ss.freeze(), CHECK_0);\n+  }\n+\n+  append_args(&args, \"-XX:AOTMode=create\", CHECK_0);\n+\n+  Symbol* klass_name = SymbolTable::new_symbol(\"jdk\/internal\/misc\/CDS$ProcessLauncher\");\n+  Klass* k = SystemDictionary::resolve_or_fail(klass_name, true, CHECK_0);\n+  Symbol* methodName = SymbolTable::new_symbol(\"execWithJavaToolOptions\");\n+  Symbol* methodSignature = SymbolTable::new_symbol(\"(Ljava\/lang\/String;[Ljava\/lang\/String;)I\");\n+\n+  Handle launcher = java_lang_String::create_from_str(java_launcher_path, CHECK_0);\n+  objArrayOop array = oopFactory::new_objArray(vmClasses::String_klass(), args.length(), CHECK_0);\n+  for (int i = 0; i < args.length(); i++) {\n+    array->obj_at_put(i, args.at(i)());\n+  }\n+  objArrayHandle launcher_args(THREAD, array);\n+\n+  \/\/ The following call will pass all options inside the JAVA_TOOL_OPTIONS env variable to\n+  \/\/ the child process. It will also clear the _JAVA_OPTIONS and CLASSPATH env variables for\n+  \/\/ the child process.\n+  \/\/\n+  \/\/ Note: the env variables are set only for the child process. They are not changed\n+  \/\/ for the current process. See java.lang.ProcessBuilder::environment().\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments javacall_args(2);\n+  javacall_args.push_oop(launcher);\n+  javacall_args.push_oop(launcher_args);\n+  JavaCalls::call_static(&result,\n+                          InstanceKlass::cast(k),\n+                          methodName,\n+                          methodSignature,\n+                          &javacall_args,\n+                          CHECK_0);\n+  return result.get_jint();\n+}\n+\n+void MetaspaceShared::fork_and_dump_final_static_archive(TRAPS) {\n+  assert(CDSConfig::is_dumping_preimage_static_archive(), \"sanity\");\n+\n+  ResourceMark rm;\n+  stringStream ss;\n+  print_java_launcher(&ss);\n+  const char* cmd = ss.freeze();\n+  tty->print_cr(\"Launching child process %s to assemble AOT cache %s using configuration %s\", cmd, AOTCacheOutput, AOTConfiguration);\n+  int status = exec_jvm_with_java_tool_options(cmd, CHECK);\n+  if (status != 0) {\n+    log_error(aot)(\"Child process failed; status = %d\", status);\n+    \/\/ We leave the temp config file for debugging\n+  } else if (CDSConfig::has_temp_aot_config_file()) {\n+    const char* tmp_config = AOTConfiguration;\n+    \/\/ On Windows, need WRITE permission to remove the file.\n+    WINDOWS_ONLY(chmod(tmp_config, _S_IREAD | _S_IWRITE));\n+    status = remove(tmp_config);\n+    if (status != 0) {\n+      log_error(aot)(\"Failed to remove temporary AOT configuration file %s\", tmp_config);\n+    } else {\n+      tty->print_cr(\"Removed temporary AOT configuration file %s\", tmp_config);\n+    }\n+  }\n+}\n+\n@@ -1047,1 +1200,1 @@\n-    if (ik->is_shared_unregistered_class() && ik->class_loader() == nullptr) {\n+    if (ik->defined_by_other_loaders() && ik->class_loader() == nullptr) {\n@@ -1060,1 +1213,1 @@\n-      log_warning(cds)(\"Preload Warning: Verification failed for %s\",\n+      aot_log_warning(aot)(\"Preload Warning: Verification failed for %s\",\n@@ -1112,1 +1265,1 @@\n-  report_loading_error(message);\n+  report_loading_error(\"%s\", message);\n@@ -1124,2 +1277,5 @@\n-  \/\/ If the user doesn't specify any CDS options, we will try to load the default CDS archive, which\n-  \/\/ may fail due to incompatible VM options. Print at the info level to avoid excessive verbosity.\n+  \/\/ When using AOT cache, errors messages are always printed on the error channel.\n+  LogStream ls_aot(LogLevel::Error, LogTagSetMapping<LOG_TAGS(aot)>::tagset());\n+\n+  \/\/ If we are loading load the default CDS archive, it may fail due to incompatible VM options.\n+  \/\/ Print at the info level to avoid excessive verbosity.\n@@ -1128,4 +1284,11 @@\n-  Log(cds) log;\n-  LogStream ls_error(log.error());\n-  LogStream ls_info(log.info());\n-  LogStream& ls = (!CDSConfig::is_using_archive()) || CDSConfig::is_using_only_default_archive() ? ls_info : ls_error;\n+  LogLevelType level = (!CDSConfig::is_using_archive() || CDSConfig::is_using_only_default_archive()) ?\n+                        LogLevel::Info : LogLevel::Error;\n+  LogStream ls_cds(level, LogTagSetMapping<LOG_TAGS(cds)>::tagset());\n+\n+  LogStream& ls = CDSConfig::new_aot_flags_used() ? ls_aot : ls_cds;\n+  if (!ls.is_enabled()) {\n+    return;\n+  }\n+\n+  va_list ap;\n+  va_start(ap, format);\n@@ -1135,1 +1298,2 @@\n-    ls.print_cr(\"An error has occurred while processing the %s. Run with -Xlog:cds for details.\", CDSConfig::type_of_archive_being_loaded());\n+    ls.print_cr(\"An error has occurred while processing the %s. Run with -Xlog:%s for details.\",\n+                CDSConfig::type_of_archive_being_loaded(), CDSConfig::new_aot_flags_used() ? \"aot\" : \"aot,cds\");\n@@ -1138,0 +1302,1 @@\n+  ls.vprint_cr(format, ap);\n@@ -1139,6 +1304,1 @@\n-  if (format != nullptr) {\n-    va_list ap;\n-    va_start(ap, format);\n-    ls.vprint_cr(format, ap);\n-    va_end(ap);\n-  }\n+  va_end(ap);\n@@ -1157,1 +1317,1 @@\n-  log_error(cds)(\"An error has occurred while writing the shared archive file.\");\n+  aot_log_error(aot)(\"An error has occurred while writing the shared archive file.\");\n@@ -1159,1 +1319,1 @@\n-    log_error(cds)(\"%s\", message);\n+    aot_log_error(aot)(\"%s\", message);\n@@ -1171,1 +1331,1 @@\n-    log_info(cds)(\"Core region alignment: %zu\", static_mapinfo->core_region_alignment());\n+    aot_log_info(aot)(\"Core region alignment: %zu\", static_mapinfo->core_region_alignment());\n@@ -1174,1 +1334,1 @@\n-    log_info(cds)(\"ArchiveRelocationMode: %d\", ArchiveRelocationMode);\n+    aot_log_info(aot)(\"ArchiveRelocationMode: %d\", ArchiveRelocationMode);\n@@ -1181,1 +1341,1 @@\n-      log_info(cds)(\"Try to map archive(s) at an alternative address\");\n+      aot_log_info(aot)(\"Try to map archive(s) at an alternative address\");\n@@ -1202,1 +1362,1 @@\n-      log_warning(cds)(\"-XX:ArchiveClassesAtExit is unsupported when base CDS archive is not loaded. Run with -Xlog:cds for more info.\");\n+      aot_log_warning(aot)(\"-XX:ArchiveClassesAtExit is unsupported when base CDS archive is not loaded. Run with -Xlog:cds for more info.\");\n@@ -1271,1 +1431,1 @@\n-    log_info(cds)(\"Archive(s) were created with -XX:SharedBaseAddress=0. Always map at os-selected address.\");\n+    aot_log_info(aot)(\"Archive(s) were created with -XX:SharedBaseAddress=0. Always map at os-selected address.\");\n@@ -1279,1 +1439,1 @@\n-      log_info(cds)(\"ArchiveRelocationMode == 1: always map archive(s) at an alternative address\");\n+      aot_log_info(aot)(\"ArchiveRelocationMode == 1: always map archive(s) at an alternative address\");\n@@ -1284,1 +1444,1 @@\n-    log_info(cds)(\"ArchiveRelocationMode == 2: never map archive(s) at an alternative address\");\n+    aot_log_info(aot)(\"ArchiveRelocationMode == 2: never map archive(s) at an alternative address\");\n@@ -1305,1 +1465,1 @@\n-    log_debug(cds)(\"Failed to reserve spaces (use_requested_addr=%u)\", (unsigned)use_requested_addr);\n+    aot_log_debug(aot)(\"Failed to reserve spaces (use_requested_addr=%u)\", (unsigned)use_requested_addr);\n@@ -1335,1 +1495,1 @@\n-    log_info(cds)(\"Reserved archive_space_rs [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] (%zu) bytes%s\",\n+    aot_log_info(aot)(\"Reserved archive_space_rs [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] (%zu) bytes%s\",\n@@ -1338,1 +1498,1 @@\n-    log_info(cds)(\"Reserved class_space_rs   [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] (%zu) bytes\",\n+    aot_log_info(aot)(\"Reserved class_space_rs   [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] (%zu) bytes\",\n@@ -1360,1 +1520,1 @@\n-        log_info(cds)(\"Windows mmap workaround: releasing archive space.\");\n+        aot_log_info(aot)(\"Windows mmap workaround: releasing archive space.\");\n@@ -1377,1 +1537,1 @@\n-            log_debug(cds)(\"Failed to re-reserve protection zone\");\n+            aot_log_debug(aot)(\"Failed to re-reserve protection zone\");\n@@ -1402,1 +1562,1 @@\n-      log_info(cds)(\"ArchiveRelocationMode == 1: always map archive(s) at an alternative address\");\n+      aot_log_info(aot)(\"ArchiveRelocationMode == 1: always map archive(s) at an alternative address\");\n@@ -1471,2 +1631,2 @@\n-    log_info(cds)(\"initial optimized module handling: %s\", CDSConfig::is_using_optimized_module_handling() ? \"enabled\" : \"disabled\");\n-    log_info(cds)(\"initial full module graph: %s\", CDSConfig::is_using_full_module_graph() ? \"enabled\" : \"disabled\");\n+    log_info(aot)(\"initial optimized module handling: %s\", CDSConfig::is_using_optimized_module_handling() ? \"enabled\" : \"disabled\");\n+    log_info(aot)(\"initial full module graph: %s\", CDSConfig::is_using_full_module_graph() ? \"enabled\" : \"disabled\");\n@@ -1618,1 +1778,1 @@\n-    log_info(cds)(\"CDS initialization: Cannot use SharedBaseAddress \" PTR_FORMAT \" with precomputed shift %d.\",\n+    aot_log_info(aot)(\"CDS initialization: Cannot use SharedBaseAddress \" PTR_FORMAT \" with precomputed shift %d.\",\n@@ -1702,1 +1862,1 @@\n-    log_debug(cds)(\"Released shared space (archive + class) \" INTPTR_FORMAT, p2i(total_space_rs.base()));\n+    aot_log_debug(aot)(\"Released shared space (archive + class) \" INTPTR_FORMAT, p2i(total_space_rs.base()));\n@@ -1707,1 +1867,1 @@\n-      log_debug(cds)(\"Released shared space (archive) \" INTPTR_FORMAT, p2i(archive_space_rs.base()));\n+      aot_log_debug(aot)(\"Released shared space (archive) \" INTPTR_FORMAT, p2i(archive_space_rs.base()));\n@@ -1712,1 +1872,1 @@\n-      log_debug(cds)(\"Released shared space (classes) \" INTPTR_FORMAT, p2i(class_space_rs.base()));\n+      aot_log_debug(aot)(\"Released shared space (classes) \" INTPTR_FORMAT, p2i(class_space_rs.base()));\n@@ -1822,1 +1982,1 @@\n-  LogStreamHandle(Info, cds) lsh;\n+  LogStreamHandle(Info, aot) lsh;\n@@ -1857,4 +2017,3 @@\n-    if (AOTCodeCache::is_on_for_use()) {\n-      tty->print_cr(\"\\n\\nAOT Code\");\n-      AOTCodeCache::print_on(tty);\n-    }\n+    TrainingData::print_archived_training_data_on(tty);\n+\n+    AOTCodeCache::print_on(tty);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":238,"deletions":79,"binary":false,"changes":317,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+  friend class CompileTrainingData;\n@@ -233,0 +234,2 @@\n+  bool has_class_initializer();\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -157,0 +157,2 @@\n+#define JAVA_26_VERSION                   70\n+\n@@ -3741,0 +3743,1 @@\n+  this_klass->set_fieldinfo_search_table(_fieldinfo_search_table);\n@@ -3750,0 +3753,2 @@\n+  DEBUG_ONLY(FieldInfoStream::validate_search_table(_cp, _fieldinfo_stream, _fieldinfo_search_table));\n+\n@@ -5022,0 +5027,1 @@\n+  ik->set_class_loader_type();\n@@ -5060,0 +5066,1 @@\n+  assert(nullptr == _fieldinfo_search_table, \"invariant\");\n@@ -5176,1 +5183,1 @@\n-  Handle module_handle(THREAD, module_entry->module());\n+  Handle module_handle(THREAD, module_entry->module_oop());\n@@ -5280,0 +5287,1 @@\n+  _fieldinfo_search_table(nullptr),\n@@ -5356,0 +5364,1 @@\n+  _fieldinfo_search_table = nullptr;\n@@ -5378,0 +5387,1 @@\n+  MetadataFactory::free_array<u1>(_loader_data, _fieldinfo_search_table);\n@@ -5778,0 +5788,1 @@\n+  _fieldinfo_search_table = FieldInfoStream::create_search_table(_cp, _fieldinfo_stream, _loader_data, CHECK);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,0 +127,1 @@\n+  Array<u1>* _fieldinfo_search_table;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/dynamicArchive.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"classfile\/classLoaderExt.hpp\"\n@@ -1198,1 +1198,0 @@\n-      ik->set_shared_class_loader_type(ClassLoader::BOOT_LOADER);\n@@ -1287,1 +1286,1 @@\n-  ClassLoaderExt::record_result_for_builtin_loader(checked_cast<s2>(classpath_index), ik, redefined);\n+  record_result_for_builtin_loader(checked_cast<s2>(classpath_index), ik, redefined);\n@@ -1290,2 +1289,2 @@\n-void ClassLoader::record_hidden_class(InstanceKlass* ik) {\n-  assert(ik->is_hidden(), \"must be\");\n+void ClassLoader::record_result_for_builtin_loader(s2 classpath_index, InstanceKlass* result, bool redefined) {\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -1293,3 +1292,5 @@\n-  s2 classloader_type;\n-  if (HeapShared::is_lambda_form_klass(ik)) {\n-    classloader_type = ClassLoader::BOOT_LOADER;\n+  oop loader = result->class_loader();\n+  if (SystemDictionary::is_system_class_loader(loader)) {\n+    AOTClassLocationConfig::dumptime_set_has_app_classes();\n+  } else if (SystemDictionary::is_platform_class_loader(loader)) {\n+    AOTClassLocationConfig::dumptime_set_has_platform_classes();\n@@ -1297,1 +1298,2 @@\n-    oop loader = ik->class_loader();\n+    precond(loader == nullptr);\n+  }\n@@ -1299,10 +1301,3 @@\n-    if (loader == nullptr) {\n-      classloader_type = ClassLoader::BOOT_LOADER;\n-    } else if (SystemDictionary::is_platform_class_loader(loader)) {\n-      classloader_type = ClassLoader::PLATFORM_LOADER;\n-    } else if (SystemDictionary::is_system_class_loader(loader)) {\n-      classloader_type = ClassLoader::APP_LOADER;\n-    } else {\n-      \/\/ This class won't be archived, so no need to update its\n-      \/\/ classloader_type\/classpath_index.\n-      return;\n+  if (CDSConfig::is_dumping_preimage_static_archive() || CDSConfig::is_dumping_dynamic_archive()) {\n+    if (!AOTClassLocationConfig::dumptime()->is_valid_classpath_index(classpath_index, result)) {\n+      classpath_index = -1;\n@@ -1311,1 +1306,30 @@\n-  ik->set_shared_class_loader_type(classloader_type);\n+\n+  AOTClassLocationConfig::dumptime_update_max_used_index(classpath_index);\n+  result->set_shared_classpath_index(classpath_index);\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (CDSConfig::is_dumping_heap() && AllowArchivingWithJavaAgent && result->defined_by_boot_loader() &&\n+      classpath_index < 0 && redefined) {\n+    \/\/ When dumping the heap (which happens only during static dump), classes for the built-in\n+    \/\/ loaders are always loaded from known locations (jimage, classpath or modulepath),\n+    \/\/ so classpath_index should always be >= 0.\n+    \/\/ The only exception is when a java agent is used during dump time (for testing\n+    \/\/ purposes only). If a class is transformed by the agent, the AOTClassLocation of\n+    \/\/ this class may point to an unknown location. This may break heap object archiving,\n+    \/\/ which requires all the boot classes to be from known locations. This is an\n+    \/\/ uncommon scenario (even in test cases). Let's simply disable heap object archiving.\n+    ResourceMark rm;\n+    log_warning(aot)(\"heap objects cannot be written because class %s maybe modified by ClassFileLoadHook.\",\n+                     result->external_name());\n+    CDSConfig::disable_heap_dumping();\n+  }\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n+}\n+\n+void ClassLoader::record_hidden_class(InstanceKlass* ik) {\n+  assert(ik->is_hidden(), \"must be\");\n+\n+  if (ik->defined_by_other_loaders()) {\n+    \/\/ We don't archive hidden classes for non-builtin loaders.\n+    return;\n+  }\n@@ -1320,1 +1344,1 @@\n-    if (classloader_type == ClassLoader::APP_LOADER) {\n+    if (ik->defined_by_app_loader()) {\n@@ -1327,0 +1351,11 @@\n+\n+void ClassLoader::append_boot_classpath(ClassPathEntry* new_entry) {\n+  if (CDSConfig::is_using_archive()) {\n+    warning(\"Sharing is only supported for boot loader classes because bootstrap classpath has been appended\");\n+    FileMapInfo::current_info()->set_has_platform_or_app_classes(false);\n+    if (DynamicArchive::is_mapped()) {\n+      FileMapInfo::dynamic_info()->set_has_platform_or_app_classes(false);\n+    }\n+  }\n+  add_to_boot_append_entries(new_entry);\n+}\n@@ -1510,2 +1545,1 @@\n-  char* orig_copy = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, strlen(orig)+1);\n-  strcpy(orig_copy, orig);\n+  char* orig_copy = ResourceArea::strdup(thread, orig);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":57,"deletions":23,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -348,0 +348,1 @@\n+  static void record_result_for_builtin_loader(s2 classpath_index, InstanceKlass* result, bool redefined);\n@@ -349,0 +350,1 @@\n+  static void append_boot_classpath(ClassPathEntry* new_entry);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotLogging.hpp\"\n@@ -195,1 +196,1 @@\n-    log_info(cds)(\"use_full_module_graph = true; java.base = \" INTPTR_FORMAT,\n+    aot_log_info(aot)(\"use_full_module_graph = true; java.base = \" INTPTR_FORMAT,\n@@ -210,1 +211,1 @@\n-  return _archived_javabase_moduleEntry->module();\n+  return _archived_javabase_moduleEntry->module_oop();\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,113 +1,0 @@\n-\/*\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"cds\/aotClassLocation.hpp\"\n-#include \"cds\/cds_globals.hpp\"\n-#include \"cds\/cdsConfig.hpp\"\n-#include \"cds\/dynamicArchive.hpp\"\n-#include \"cds\/filemap.hpp\"\n-#include \"cds\/heapShared.hpp\"\n-#include \"classfile\/classFileParser.hpp\"\n-#include \"classfile\/classLoader.inline.hpp\"\n-#include \"classfile\/classLoaderExt.hpp\"\n-#include \"classfile\/classLoaderData.inline.hpp\"\n-#include \"classfile\/classLoadInfo.hpp\"\n-#include \"classfile\/klassFactory.hpp\"\n-#include \"classfile\/modules.hpp\"\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"classfile\/vmSymbols.hpp\"\n-#include \"gc\/shared\/collectedHeap.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/instanceKlass.hpp\"\n-#include \"oops\/klass.inline.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"oops\/symbol.hpp\"\n-#include \"runtime\/arguments.hpp\"\n-#include \"runtime\/handles.inline.hpp\"\n-#include \"runtime\/java.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"utilities\/checkedCast.hpp\"\n-#include \"utilities\/stringUtils.hpp\"\n-\n-void ClassLoaderExt::append_boot_classpath(ClassPathEntry* new_entry) {\n-  if (CDSConfig::is_using_archive()) {\n-    warning(\"Sharing is only supported for boot loader classes because bootstrap classpath has been appended\");\n-    FileMapInfo::current_info()->set_has_platform_or_app_classes(false);\n-    if (DynamicArchive::is_mapped()) {\n-      FileMapInfo::dynamic_info()->set_has_platform_or_app_classes(false);\n-    }\n-  }\n-  ClassLoader::add_to_boot_append_entries(new_entry);\n-}\n-\n-int ClassLoaderExt::compare_module_names(const char** p1, const char** p2) {\n-  return strcmp(*p1, *p2);\n-}\n-\n-void ClassLoaderExt::record_result_for_builtin_loader(s2 classpath_index, InstanceKlass* result, bool redefined) {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-\n-  oop loader = result->class_loader();\n-  s2 classloader_type;\n-  if (SystemDictionary::is_system_class_loader(loader)) {\n-    classloader_type = ClassLoader::APP_LOADER;\n-    AOTClassLocationConfig::dumptime_set_has_app_classes();\n-  } else if (SystemDictionary::is_platform_class_loader(loader)) {\n-    classloader_type = ClassLoader::PLATFORM_LOADER;\n-    AOTClassLocationConfig::dumptime_set_has_platform_classes();\n-  } else {\n-    precond(loader == nullptr);\n-    classloader_type = ClassLoader::BOOT_LOADER;\n-  }\n-\n-  if (CDSConfig::is_dumping_preimage_static_archive() || CDSConfig::is_dumping_dynamic_archive()) {\n-    if (!AOTClassLocationConfig::dumptime()->is_valid_classpath_index(classpath_index, result)) {\n-      classpath_index = -1;\n-    }\n-  }\n-\n-  AOTClassLocationConfig::dumptime_update_max_used_index(classpath_index);\n-  result->set_shared_classpath_index(classpath_index);\n-  result->set_shared_class_loader_type(classloader_type);\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-  if (CDSConfig::is_dumping_heap() && AllowArchivingWithJavaAgent && classloader_type == ClassLoader::BOOT_LOADER &&\n-      classpath_index < 0 && redefined) {\n-    \/\/ When dumping the heap (which happens only during static dump), classes for the built-in\n-    \/\/ loaders are always loaded from known locations (jimage, classpath or modulepath),\n-    \/\/ so classpath_index should always be >= 0.\n-    \/\/ The only exception is when a java agent is used during dump time (for testing\n-    \/\/ purposes only). If a class is transformed by the agent, the AOTClassLocation of\n-    \/\/ this class may point to an unknown location. This may break heap object archiving,\n-    \/\/ which requires all the boot classes to be from known locations. This is an\n-    \/\/ uncommon scenario (even in test cases). Let's simply disable heap object archiving.\n-    ResourceMark rm;\n-    log_warning(cds)(\"CDS heap objects cannot be written because class %s maybe modified by ClassFileLoadHook.\",\n-                     result->external_name());\n-    CDSConfig::disable_heap_dumping();\n-  }\n-#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n-}\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -1,47 +1,0 @@\n-\/*\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_CLASSFILE_CLASSLOADEREXT_HPP\n-#define SHARE_CLASSFILE_CLASSLOADEREXT_HPP\n-\n-#include \"classfile\/classLoader.hpp\"\n-#include \"classfile\/moduleEntry.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-class ClassListParser;\n-\n-class ClassLoaderExt: public ClassLoader { \/\/ AllStatic\n-public:\n-#if INCLUDE_CDS\n-public:\n-  \/\/ Called by JVMTI code to add boot classpath\n-\n-  static void append_boot_classpath(ClassPathEntry* new_entry);\n-\n-  static int compare_module_names(const char** p1, const char** p2);\n-  static void record_result_for_builtin_loader(s2 classpath_index, InstanceKlass* result, bool redefined);\n-#endif \/\/ INCLUDE_CDS\n-};\n-\n-#endif \/\/ SHARE_CLASSFILE_CLASSLOADEREXT_HPP\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.hpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -321,1 +321,1 @@\n-    for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n@@ -481,1 +481,1 @@\n-          for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n+          for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -970,0 +970,7 @@\n+\n+      Array<u1>* old_table = ik->fieldinfo_search_table();\n+      Array<u1>* search_table = FieldInfoStream::create_search_table(ik->constants(), new_fis, k->class_loader_data(), CHECK);\n+      ik->set_fieldinfo_search_table(search_table);\n+      MetadataFactory::free_array<u1>(k->class_loader_data(), old_table);\n+\n+      DEBUG_ONLY(FieldInfoStream::validate_search_table(ik->constants(), new_fis, search_table));\n@@ -1032,1 +1039,1 @@\n-      assert(javabase_entry != nullptr && javabase_entry->module() != nullptr,\n+      assert(javabase_entry != nullptr && javabase_entry->module_oop() != nullptr,\n@@ -1034,1 +1041,1 @@\n-      Handle javabase_handle(current, javabase_entry->module());\n+      Handle javabase_handle(current, javabase_entry->module_oop());\n@@ -1040,1 +1047,1 @@\n-            (module() == ModuleEntryTable::javabase_moduleEntry()->module())),\n+            (module() == ModuleEntryTable::javabase_moduleEntry()->module_oop())),\n@@ -1209,1 +1216,1 @@\n-  log_debug(cds, mirror)(\"Archived mirror is: \" PTR_FORMAT, p2i(m));\n+  log_debug(aot, mirror)(\"Archived mirror is: \" PTR_FORMAT, p2i(m));\n@@ -1234,1 +1241,1 @@\n-  if (log_is_enabled(Trace, cds, heap, mirror)) {\n+  if (log_is_enabled(Trace, aot, heap, mirror)) {\n@@ -1236,1 +1243,1 @@\n-    log_trace(cds, heap, mirror)(\n+    log_trace(aot, heap, mirror)(\n@@ -1875,1 +1882,1 @@\n-  return java_thread->obj_field(_park_blocker_offset);\n+  return java_thread->obj_field_access<MO_RELAXED>(_park_blocker_offset);\n@@ -1895,1 +1902,1 @@\n-  class GetStackTraceClosure : public HandshakeClosure {\n+  class GetStackTraceHandshakeClosure : public HandshakeClosure {\n@@ -1903,2 +1910,2 @@\n-    GetStackTraceClosure(Handle java_thread) :\n-        HandshakeClosure(\"GetStackTraceClosure\"), _java_thread(java_thread), _depth(0), _retry_handshake(false),\n+    GetStackTraceHandshakeClosure(Handle java_thread) :\n+        HandshakeClosure(\"GetStackTraceHandshakeClosure\"), _java_thread(java_thread), _depth(0), _retry_handshake(false),\n@@ -1907,1 +1914,1 @@\n-    ~GetStackTraceClosure() {\n+    ~GetStackTraceHandshakeClosure() {\n@@ -1973,1 +1980,1 @@\n-  GetStackTraceClosure gstc(Handle(THREAD, java_thread));\n+  GetStackTraceHandshakeClosure gsthc(Handle(THREAD, java_thread));\n@@ -1975,2 +1982,2 @@\n-   Handshake::execute(&gstc, &tlh, thread);\n-  } while (gstc.read_reset_retry());\n+   Handshake::execute(&gsthc, &tlh, thread);\n+  } while (gsthc.read_reset_retry());\n@@ -1979,1 +1986,1 @@\n-  if (gstc._depth == 0) {\n+  if (gsthc._depth == 0) {\n@@ -1989,1 +1996,1 @@\n-  objArrayHandle trace = oopFactory::new_objArray_handle(k, gstc._depth, CHECK_NULL);\n+  objArrayHandle trace = oopFactory::new_objArray_handle(k, gsthc._depth, CHECK_NULL);\n@@ -1991,2 +1998,2 @@\n-  for (int i = 0; i < gstc._depth; i++) {\n-    methodHandle method(THREAD, gstc._methods->at(i));\n+  for (int i = 0; i < gsthc._depth; i++) {\n+    methodHandle method(THREAD, gsthc._methods->at(i));\n@@ -1994,1 +2001,1 @@\n-                                                      gstc._bcis->at(i),\n+                                                      gsthc._bcis->at(i),\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":26,"deletions":19,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-oop ModuleEntry::module() const { return _module.resolve(); }\n+oop ModuleEntry::module_oop() const { return _module_handle.resolve(); }\n@@ -287,1 +287,1 @@\n-    _module = loader_data->add_handle(module_handle);\n+    _module_handle = loader_data->add_handle(module_handle);\n@@ -404,1 +404,1 @@\n-    archived_entry->_archived_module_index = HeapShared::append_root(module());\n+    archived_entry->_archived_module_index = HeapShared::append_root(module_oop());\n@@ -425,1 +425,1 @@\n-  archived_entry->_module = null_handle;\n+  archived_entry->_module_handle = null_handle;\n@@ -430,1 +430,1 @@\n-  if (log_is_enabled(Info, cds, module)) {\n+  if (log_is_enabled(Info, aot, module)) {\n@@ -432,1 +432,1 @@\n-    LogStream ls(Log(cds, module)::info());\n+    LogStream ls(Log(aot, module)::info());\n@@ -529,1 +529,1 @@\n-  set_module(loader_data->add_handle(module_handle));\n+  set_module_handle(loader_data->add_handle(module_handle));\n@@ -538,1 +538,1 @@\n-  if (log_is_enabled(Info, cds, module)) {\n+  if (log_is_enabled(Info, aot, module)) {\n@@ -540,1 +540,1 @@\n-    LogStream ls(Log(cds, module)::info());\n+    LogStream ls(Log(aot, module)::info());\n@@ -665,1 +665,1 @@\n-  jb_module->set_module(boot_loader_data->add_handle(module_handle));\n+  jb_module->set_module_handle(boot_loader_data->add_handle(module_handle));\n@@ -703,1 +703,1 @@\n-      Handle unnamed_module_handle(current, unnamed_module->module());\n+      Handle unnamed_module_handle(current, unnamed_module->module_oop());\n@@ -748,1 +748,1 @@\n-               p2i(module()),\n+               p2i(module_oop()),\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-\/\/   - pointer to the java.lang.Module for this module.\n+\/\/   - pointer to the java.lang.Module: the representation of this module as a Java object\n@@ -66,1 +66,1 @@\n-  OopHandle _module;                   \/\/ java.lang.Module\n+  OopHandle _module_handle;            \/\/ java.lang.Module\n@@ -99,3 +99,3 @@\n-  oop              module() const;\n-  OopHandle        module_handle() const               { return _module; }\n-  void             set_module(OopHandle j)             { _module = j; }\n+  oop              module_oop() const;\n+  OopHandle        module_handle() const               { return _module_handle; }\n+  void             set_module_handle(OopHandle j)      { _module_handle = j; }\n@@ -265,1 +265,1 @@\n-                                           (_javabase_module->module() != nullptr)); }\n+                                           (_javabase_module->module_oop() != nullptr)); }\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotLogging.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"classfile\/classLoaderExt.hpp\"\n@@ -492,1 +492,1 @@\n-    log_info(cds, module)(\"Archived java.lang.Module oop \" PTR_FORMAT \" with no ModuleEntry*\", p2i(orig_module_obj));\n+    log_info(aot, module)(\"Archived java.lang.Module oop \" PTR_FORMAT \" with no ModuleEntry*\", p2i(orig_module_obj));\n@@ -496,1 +496,1 @@\n-    if (log_is_enabled(Info, cds, module)) {\n+    if (log_is_enabled(Info, aot, module)) {\n@@ -498,1 +498,1 @@\n-      LogStream ls(Log(cds, module)::info());\n+      LogStream ls(Log(aot, module)::info());\n@@ -587,0 +587,1 @@\n+  {\"jdk.module.addreads\", true},               \/\/ --add-reads\n@@ -601,1 +602,1 @@\n-  log_info(cds)(\"archived module property %s: %s\", _prop,\n+  aot_log_info(aot)(\"archived module property %s: %s\", _prop,\n@@ -626,0 +627,5 @@\n+\n+static int compare_module_names(const char** p1, const char** p2) {\n+  return strcmp(*p1, *p2);\n+}\n+\n@@ -642,2 +648,1 @@\n-    char* p = resource_allocate_bytes(strlen(prop_value) + 1);\n-    strcpy(p, prop_value);\n+    char* p = ResourceArea::strdup(prop_value);\n@@ -667,1 +672,1 @@\n-  list.sort(ClassLoaderExt::compare_module_names);\n+  list.sort(compare_module_names);\n@@ -695,2 +700,2 @@\n-    log_info(cds)(\"optimized module handling: %s\", CDSConfig::is_using_optimized_module_handling() ? \"enabled\" : \"disabled\");\n-    log_info(cds)(\"full module graph: %s\", CDSConfig::is_using_full_module_graph() ? \"enabled\" : \"disabled\");\n+    aot_log_info(aot)(\"optimized module handling: %s\", CDSConfig::is_using_optimized_module_handling() ? \"enabled\" : \"disabled\");\n+    aot_log_info(aot)(\"full module graph: %s\", CDSConfig::is_using_full_module_graph() ? \"enabled\" : \"disabled\");\n@@ -775,1 +780,1 @@\n-  unnamed_module->set_module(boot_loader_data->add_handle(module));\n+  unnamed_module->set_module_handle(boot_loader_data->add_handle(module));\n@@ -956,2 +961,2 @@\n-  if (module_entry != nullptr && module_entry->module() != nullptr && module_entry->is_named()) {\n-    return module_entry->module();\n+  if (module_entry != nullptr && module_entry->module_oop() != nullptr && module_entry->is_named()) {\n+    return module_entry->module_oop();\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"compiler\/compileBroker.hpp\"\n@@ -118,0 +119,1 @@\n+DEBUG_ONLY(static bool _disable_interning_during_cds_dump = false);\n@@ -349,0 +351,4 @@\n+size_t StringTable::items_count_acquire() {\n+  return Atomic::load_acquire(&_items_count);\n+}\n+\n@@ -507,0 +513,3 @@\n+  assert(!Atomic::load_acquire(&_disable_interning_during_cds_dump),\n+         \"All threads that may intern strings should have been stopped before CDS starts copying the interned string table\");\n+\n@@ -796,1 +805,1 @@\n-class VerifyCompStrings : StackObj {\n+class StringTable::VerifyCompStrings : StackObj {\n@@ -808,1 +817,1 @@\n-  VerifyCompStrings() : _table(unsigned(_items_count \/ 8) + 1, 0 \/* do not resize *\/), _errors(0) {}\n+  VerifyCompStrings() : _table(unsigned(items_count_acquire() \/ 8) + 1, 0 \/* do not resize *\/), _errors(0) {}\n@@ -942,3 +951,2 @@\n-\/\/ This is called BEFORE we enter the CDS safepoint. We can allocate heap objects.\n-\/\/ This should be called when we know no more strings will be added (which will be easy\n-\/\/ to guarantee because CDS runs with a single Java thread. See JDK-8253495.)\n+\/\/ This is called BEFORE we enter the CDS safepoint. We can still allocate Java object arrays to\n+\/\/ be used by the shared strings table.\n@@ -949,3 +957,15 @@\n-  assert(CDSConfig::allow_only_single_java_thread(), \"No more interned strings can be added\");\n-  if (_items_count > (size_t)max_jint) {\n-    fatal(\"Too many strings to be archived: %zu\", _items_count);\n+  CompileBroker::wait_for_no_active_tasks();\n+\n+  precond(CDSConfig::allow_only_single_java_thread());\n+\n+  \/\/ At this point, no more strings will be added:\n+  \/\/ - There's only a single Java thread (this thread). It no longer executes Java bytecodes\n+  \/\/   so JIT compilation will eventually stop.\n+  \/\/ - CompileBroker has no more active tasks, so all JIT requests have been processed.\n+\n+  \/\/ This flag will be cleared after intern table dumping has completed, so we can run the\n+  \/\/ compiler again (for future AOT method compilation, etc).\n+  DEBUG_ONLY(Atomic::release_store(&_disable_interning_during_cds_dump, true));\n+\n+  if (items_count_acquire() > (size_t)max_jint) {\n+    fatal(\"Too many strings to be archived: %zu\", items_count_acquire());\n@@ -955,1 +975,1 @@\n-  int total = (int)_items_count;\n+  int total = (int)items_count_acquire();\n@@ -958,1 +978,1 @@\n-  log_info(cds)(\"allocated string table for %d strings\", total);\n+  log_info(aot)(\"allocated string table for %d strings\", total);\n@@ -964,1 +984,1 @@\n-    log_info(cds)(\"string table array (single level) length = %d\", total);\n+    log_info(aot)(\"string table array (single level) length = %d\", total);\n@@ -975,1 +995,1 @@\n-      log_error(cds)(\"Too many strings to be archived: %zu\", _items_count);\n+      log_error(aot)(\"Too many strings to be archived: %zu\", items_count_acquire());\n@@ -983,1 +1003,1 @@\n-    log_info(cds)(\"string table array (primary) length = %d\", primary_array_length);\n+    log_info(aot)(\"string table array (primary) length = %d\", primary_array_length);\n@@ -996,1 +1016,1 @@\n-      log_info(cds)(\"string table array (secondary)[%d] length = %d\", i, len);\n+      log_info(aot)(\"string table array (secondary)[%d] length = %d\", i, len);\n@@ -1067,1 +1087,1 @@\n-  log_info(cds)(\"Archived %d interned strings\", index);\n+  log_info(aot)(\"Archived %d interned strings\", index);\n@@ -1073,1 +1093,1 @@\n-  CompactHashtableWriter writer((int)_items_count, ArchiveBuilder::string_stats());\n+  CompactHashtableWriter writer((int)items_count_acquire(), ArchiveBuilder::string_stats());\n@@ -1087,0 +1107,2 @@\n+\n+  DEBUG_ONLY(Atomic::release_store(&_disable_interning_during_cds_dump, false));\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":38,"deletions":16,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-\n+  class VerifyCompStrings;\n@@ -77,0 +77,1 @@\n+  static size_t items_count_acquire();\n","filename":"src\/hotspot\/share\/classfile\/stringTable.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"classfile\/classLoaderExt.hpp\"\n@@ -926,1 +925,1 @@\n-  if (ik->is_shared_boot_class()) {\n+  if (ik->defined_by_boot_loader()) {\n@@ -930,1 +929,1 @@\n-  } else if (ik->is_shared_platform_class()) {\n+  } else if (ik->defined_by_platform_loader()) {\n@@ -934,1 +933,1 @@\n-  } else if (ik->is_shared_app_class()) {\n+  } else if (ik->defined_by_app_loader()) {\n@@ -964,1 +963,1 @@\n-  assert(!ik->is_shared_unregistered_class(), \"this function should be called for built-in classes only\");\n+  assert(!ik->defined_by_other_loaders(), \"this function should be called for built-in classes only\");\n@@ -1026,1 +1025,1 @@\n-  if (!super_type->is_shared_unregistered_class() && super_type->class_loader_data() != nullptr) {\n+  if (!super_type->defined_by_other_loaders() && super_type->class_loader_data() != nullptr) {\n@@ -1229,1 +1228,1 @@\n-      if (ik != nullptr && ik->is_shared_boot_class() && !ik->shared_loading_failed()) {\n+      if (ik != nullptr && ik->defined_by_boot_loader() && !ik->shared_loading_failed()) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/aotLogging.hpp\"\n@@ -46,1 +47,0 @@\n-#include \"classfile\/classLoaderExt.hpp\"\n@@ -105,2 +105,2 @@\n-    if ((SystemDictionary::is_system_class_loader(class_loader()) && ik->is_shared_app_class())  ||\n-        (SystemDictionary::is_platform_class_loader(class_loader()) && ik->is_shared_platform_class())) {\n+    if ((SystemDictionary::is_system_class_loader(class_loader()) && ik->defined_by_app_loader())  ||\n+        (SystemDictionary::is_platform_class_loader(class_loader()) && ik->defined_by_platform_loader())) {\n@@ -232,1 +232,1 @@\n-  log_warning(cds)(\"Skipping %s: %s\", k->name()->as_C_string(), reason);\n+  aot_log_warning(aot)(\"Skipping %s: %s\", k->name()->as_C_string(), reason);\n@@ -252,1 +252,1 @@\n-  if (CDSConfig::is_dumping_final_static_archive() && k->is_shared_unregistered_class()\n+  if (CDSConfig::is_dumping_final_static_archive() && k->defined_by_other_loaders()\n@@ -276,1 +276,1 @@\n-        log_info(cds)(\"Skipping %s because it is dynamically generated\", k->name()->as_C_string());\n+        aot_log_info(aot)(\"Skipping %s because it is dynamically generated\", k->name()->as_C_string());\n@@ -311,1 +311,1 @@\n-      \/\/ classes from tje preimage. We don't want to get a VerifyError when linking this class.\n+      \/\/ classes from the preimage. We don't want to get a VerifyError when linking this class.\n@@ -326,0 +326,6 @@\n+  if (UnregisteredClasses::check_for_exclusion(k)) {\n+    ResourceMark rm;\n+    aot_log_info(aot)(\"Skipping %s: used only when dumping CDS archive\", k->name()->as_C_string());\n+    return true;\n+  }\n+\n@@ -329,1 +335,1 @@\n-    log_warning(cds)(\"Skipping %s: super class %s is excluded\", k->name()->as_C_string(), super->name()->as_C_string());\n+    aot_log_warning(aot)(\"Skipping %s: super class %s is excluded\", k->name()->as_C_string(), super->name()->as_C_string());\n@@ -339,1 +345,1 @@\n-      log_warning(cds)(\"Skipping %s: interface %s is excluded\", k->name()->as_C_string(), intf->name()->as_C_string());\n+      aot_log_warning(aot)(\"Skipping %s: interface %s is excluded\", k->name()->as_C_string(), intf->name()->as_C_string());\n@@ -344,1 +350,2 @@\n-  if (k == UnregisteredClasses::UnregisteredClassLoader_klass()) {\n+  InstanceKlass* nest_host = k->nest_host_or_null();\n+  if (nest_host != nullptr && nest_host != k && check_for_exclusion(nest_host, nullptr)) {\n@@ -346,1 +353,1 @@\n-    log_info(cds)(\"Skipping %s: used only when dumping CDS archive\", k->name()->as_C_string());\n+    aot_log_warning(aot)(\"Skipping %s: nest_host class %s is excluded\", k->name()->as_C_string(), nest_host->name()->as_C_string());\n@@ -468,0 +475,9 @@\n+InstanceKlass* SystemDictionaryShared::get_unregistered_class(Symbol* name) {\n+  assert(CDSConfig::is_dumping_archive() || ClassListWriter::is_enabled(), \"sanity\");\n+  if (_unregistered_classes_table == nullptr) {\n+    return nullptr;\n+  }\n+  InstanceKlass** k = _unregistered_classes_table->get(name);\n+  return k != nullptr ? *k : nullptr;\n+}\n+\n@@ -585,1 +601,1 @@\n-    guarantee(!k->is_shared_unregistered_class(),\n+    guarantee(!k->defined_by_other_loaders(),\n@@ -589,1 +605,1 @@\n-    guarantee(k->is_shared_unregistered_class(),\n+    guarantee(k->defined_by_other_loaders(),\n@@ -652,0 +668,5 @@\n+    if (CDSConfig::is_dumping_dynamic_archive() && ik->is_shared()) {\n+      \/\/ ik is already part of the static archive, so it will never be considered as excluded.\n+      return false;\n+    }\n+\n@@ -747,1 +768,1 @@\n-      assert(k->is_shared_unregistered_class(), \"must be\");\n+      assert(k->defined_by_other_loaders(), \"must be\");\n@@ -818,1 +839,1 @@\n-      if (log_is_enabled(Trace, cds, verification)) {\n+      if (log_is_enabled(Trace, aot, verification)) {\n@@ -820,1 +841,1 @@\n-        log_trace(cds, verification)(\"check_verification_constraint: %s: %s must be subclass of %s [0x%x]\",\n+        log_trace(aot, verification)(\"check_verification_constraint: %s: %s must be subclass of %s [0x%x]\",\n@@ -933,1 +954,1 @@\n-  if (klass->is_shared_boot_class()) {\n+  if (klass->defined_by_boot_loader()) {\n@@ -937,1 +958,1 @@\n-  if (klass->is_shared_platform_class() || klass->is_shared_app_class()) {\n+  if (klass->defined_by_platform_loader() || klass->defined_by_app_loader()) {\n@@ -980,1 +1001,1 @@\n-  if (klass->is_shared_platform_class() || klass->is_shared_app_class()) {\n+  if (klass->defined_by_platform_loader() || klass->defined_by_app_loader()) {\n@@ -996,1 +1017,1 @@\n-  if (ArchiveBuilder::is_active()) {\n+  if (ArchiveBuilder::is_active() && ArchiveBuilder::current()->is_in_buffer_space(ptr)) {\n@@ -1036,1 +1057,1 @@\n-      if (log_is_enabled(Trace, cds, hashtables)) {\n+      if (log_is_enabled(Trace, aot, hashtables)) {\n@@ -1038,1 +1059,1 @@\n-        log_trace(cds,hashtables)(\"%s dictionary: %s\", (_is_builtin ? \"builtin\" : \"unregistered\"), info._klass->external_name());\n+        log_trace(aot, hashtables)(\"%s dictionary: %s\", (_is_builtin ? \"builtin\" : \"unregistered\"), info._klass->external_name());\n@@ -1148,1 +1169,1 @@\n-  if (ik->is_shared_boot_class()) {\n+  if (ik->defined_by_boot_loader()) {\n@@ -1150,1 +1171,1 @@\n-  } else if (ik->is_shared_platform_class()) {\n+  } else if (ik->defined_by_platform_loader()) {\n@@ -1152,1 +1173,1 @@\n-  } else if (ik->is_shared_app_class()) {\n+  } else if (ik->defined_by_app_loader()) {\n@@ -1154,1 +1175,1 @@\n-  } else if (ik->is_shared_unregistered_class()) {\n+  } else if (ik->defined_by_other_loaders()) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":47,"deletions":26,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-  do_name(round_name, \"round\")  do_name(tanh_name,\"tanh\")                                                               \\\n+  do_name(round_name, \"round\")  do_name(tanh_name,\"tanh\")       do_name(cbrt_name,\"cbrt\")                                                               \\\n@@ -164,1 +164,2 @@\n-  do_intrinsic(_dtanh,                    java_lang_Math,         tanh_name,   double_double_signature,          F_S)   \\\n+  do_intrinsic(_dtanh,                    java_lang_Math,         tanh_name,  double_double_signature,           F_S)   \\\n+  do_intrinsic(_dcbrt,                    java_lang_Math,         cbrt_name,  double_double_signature,           F_S)   \\\n@@ -463,1 +464,1 @@\n-  do_intrinsic(_Reference_get,              java_lang_ref_Reference, get_name,       void_object_signature,    F_R)     \\\n+  do_intrinsic(_Reference_get0,             java_lang_ref_Reference, get0_name,      void_object_signature,    F_RN)    \\\n@@ -1271,0 +1272,1 @@\n+                                     \"I\"                                                                                                       \\\n@@ -1274,0 +1276,3 @@\n+                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                           \\\n+                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                           \\\n+                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                           \\\n@@ -1288,0 +1293,1 @@\n+                                      \"I\"                                                                                                      \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -37,0 +38,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -43,0 +45,1 @@\n+#include \"runtime\/stubInfo.hpp\"\n@@ -45,0 +48,3 @@\n+#ifdef COMPILER1\n+#include \"c1\/c1_Runtime1.hpp\"\n+#endif\n@@ -61,0 +67,6 @@\n+const char* aot_code_entry_kind_name[] = {\n+#define DECL_KIND_STRING(kind) XSTR(kind),\n+  DO_AOTCODEENTRY_KIND(DECL_KIND_STRING)\n+#undef DECL_KIND_STRING\n+};\n+\n@@ -66,1 +78,1 @@\n-  AOTAdapterCaching = false;\n+  AOTCodeCache::disable_caching();\n@@ -75,1 +87,1 @@\n-  AOTAdapterCaching = false;\n+  AOTCodeCache::disable_caching();\n@@ -78,1 +90,22 @@\n-bool AOTCodeCache::is_dumping_adapters() {\n+\/\/ The sequence of AOT code caching flags and parametters settings.\n+\/\/\n+\/\/ 1. The initial AOT code caching flags setting is done\n+\/\/ during call to CDSConfig::check_vm_args_consistency().\n+\/\/\n+\/\/ 2. The earliest AOT code state check done in compilationPolicy_init()\n+\/\/ where we set number of compiler threads for AOT assembly phase.\n+\/\/\n+\/\/ 3. We determine presence of AOT code in AOT Cache in\n+\/\/ MetaspaceShared::open_static_archive() which is calles\n+\/\/ after compilationPolicy_init() but before codeCache_init().\n+\/\/\n+\/\/ 4. AOTCodeCache::initialize() is called during universe_init()\n+\/\/ and does final AOT state and flags settings.\n+\/\/\n+\/\/ 5. Finally AOTCodeCache::init2() is called after universe_init()\n+\/\/ when all GC settings are finalized.\n+\n+\/\/ Next methods determine which action we do with AOT code depending\n+\/\/ on phase of AOT process: assembly or production.\n+\n+bool AOTCodeCache::is_dumping_adapter() {\n@@ -82,1 +115,1 @@\n-bool AOTCodeCache::is_using_adapters()   {\n+bool AOTCodeCache::is_using_adapter()   {\n@@ -86,0 +119,44 @@\n+bool AOTCodeCache::is_dumping_stub() {\n+  return AOTStubCaching && is_on_for_dump();\n+}\n+\n+bool AOTCodeCache::is_using_stub()   {\n+  return AOTStubCaching && is_on_for_use();\n+}\n+\n+\/\/ Next methods could be called regardless AOT code cache status.\n+\/\/ Initially they are called during flags parsing and finilized\n+\/\/ in AOTCodeCache::initialize().\n+void AOTCodeCache::enable_caching() {\n+  FLAG_SET_ERGO_IF_DEFAULT(AOTStubCaching, true);\n+  FLAG_SET_ERGO_IF_DEFAULT(AOTAdapterCaching, true);\n+}\n+\n+void AOTCodeCache::disable_caching() {\n+  FLAG_SET_ERGO(AOTStubCaching, false);\n+  FLAG_SET_ERGO(AOTAdapterCaching, false);\n+}\n+\n+bool AOTCodeCache::is_caching_enabled() {\n+  return AOTStubCaching || AOTAdapterCaching;\n+}\n+\n+static uint32_t encode_id(AOTCodeEntry::Kind kind, int id) {\n+  assert(AOTCodeEntry::is_valid_entry_kind(kind), \"invalid AOTCodeEntry kind %d\", (int)kind);\n+  \/\/ There can be a conflict of id between an Adapter and *Blob, but that should not cause any functional issue\n+  \/\/ becasue both id and kind are used to find an entry, and that combination should be unique\n+  if (kind == AOTCodeEntry::Adapter) {\n+    return id;\n+  } else if (kind == AOTCodeEntry::SharedBlob) {\n+    assert(StubInfo::is_shared(static_cast<BlobId>(id)), \"not a shared blob id %d\", id);\n+    return id;\n+  } else if (kind == AOTCodeEntry::C1Blob) {\n+    assert(StubInfo::is_c1(static_cast<BlobId>(id)), \"not a c1 blob id %d\", id);\n+    return id;\n+  } else {\n+    \/\/ kind must be AOTCodeEntry::C2Blob\n+    assert(StubInfo::is_c2(static_cast<BlobId>(id)), \"not a c2 blob id %d\", id);\n+    return id;\n+  }\n+}\n+\n@@ -91,0 +168,4 @@\n+\/\/ It is called from MetaspaceShared::initialize_shared_spaces()\n+\/\/ which is called from universe_init().\n+\/\/ At this point all AOT class linking seetings are finilized\n+\/\/ and AOT cache is open so we can map AOT code region.\n@@ -94,1 +175,1 @@\n-  AOTAdapterCaching = false;\n+  disable_caching();\n@@ -99,1 +180,1 @@\n-    AOTAdapterCaching = false;\n+    disable_caching();\n@@ -103,0 +184,14 @@\n+  \/\/ Disable stubs caching until JDK-8357398 is fixed.\n+  FLAG_SET_ERGO(AOTStubCaching, false);\n+\n+  if (VerifyOops) {\n+    \/\/ Disable AOT stubs caching when VerifyOops flag is on.\n+    \/\/ Verify oops code generated a lot of C strings which overflow\n+    \/\/ AOT C string table (which has fixed size).\n+    \/\/ AOT C string table will be reworked later to handle such cases.\n+    \/\/\n+    \/\/ Note: AOT adapters are not affected - they don't have oop operations.\n+    log_info(aot, codecache, init)(\"AOT Stubs Caching is not supported with VerifyOops.\");\n+    FLAG_SET_ERGO(AOTStubCaching, false);\n+  }\n+\n@@ -106,1 +201,2 @@\n-    FLAG_SET_ERGO_IF_DEFAULT(AOTAdapterCaching, true);\n+    enable_caching();\n+    is_dumping = is_caching_enabled();\n@@ -109,2 +205,2 @@\n-    FLAG_SET_ERGO_IF_DEFAULT(AOTAdapterCaching, true);\n-    is_using = true;\n+    enable_caching();\n+    is_using = is_caching_enabled();\n@@ -113,0 +209,1 @@\n+    disable_caching();\n@@ -115,1 +212,2 @@\n-  if (!AOTAdapterCaching) {\n+  if (!(is_dumping || is_using)) {\n+    disable_caching();\n@@ -128,0 +226,1 @@\n+    disable_caching();\n@@ -145,0 +244,5 @@\n+static AOTCodeCache*  opened_cache = nullptr; \/\/ Use this until we verify the cache\n+AOTCodeCache* AOTCodeCache::_cache = nullptr;\n+DEBUG_ONLY( bool AOTCodeCache::_passed_init2 = false; )\n+\n+\/\/ It is called after universe_init() when all GC settings are finalized.\n@@ -146,1 +250,2 @@\n-  if (!is_on()) {\n+  DEBUG_ONLY( _passed_init2 = true; )\n+  if (opened_cache == nullptr) {\n@@ -149,2 +254,3 @@\n-  if (!verify_vm_config()) {\n-    close();\n+  if (!opened_cache->verify_config()) {\n+    delete opened_cache;\n+    opened_cache = nullptr;\n@@ -152,0 +258,1 @@\n+    return;\n@@ -153,0 +260,1 @@\n+\n@@ -155,2 +263,3 @@\n-  init_extrs_table();\n-}\n+  AOTCodeAddressTable* table = opened_cache->_table;\n+  assert(table != nullptr, \"should be initialized already\");\n+  table->init_extrs();\n@@ -158,1 +267,3 @@\n-AOTCodeCache* AOTCodeCache::_cache = nullptr;\n+  \/\/ Now cache and address table are ready for AOT code generation\n+  _cache = opened_cache;\n+}\n@@ -161,4 +272,4 @@\n-  AOTCodeCache* cache = new AOTCodeCache(is_dumping, is_using);\n-  if (cache->failed()) {\n-    delete cache;\n-    _cache = nullptr;\n+  opened_cache = new AOTCodeCache(is_dumping, is_using);\n+  if (opened_cache->failed()) {\n+    delete opened_cache;\n+    opened_cache = nullptr;\n@@ -167,1 +278,0 @@\n-  _cache = cache;\n@@ -175,0 +285,1 @@\n+    opened_cache = nullptr;\n@@ -222,1 +333,1 @@\n-    if (!_load_header->verify_config(_load_size)) {\n+    if (!_load_header->verify(_load_size)) {\n@@ -228,1 +339,3 @@\n-    log_debug(aot, codecache, init)(\"  All Blobs: total=%u\", _load_header->blobs_count());\n+    log_debug(aot, codecache, init)(\"  Shared Blobs: total=%u\", _load_header->shared_blobs_count());\n+    log_debug(aot, codecache, init)(\"  C1 Blobs: total=%u\", _load_header->C1_blobs_count());\n+    log_debug(aot, codecache, init)(\"  C2 Blobs: total=%u\", _load_header->C2_blobs_count());\n@@ -244,1 +357,1 @@\n-void AOTCodeCache::init_extrs_table() {\n+void AOTCodeCache::init_early_stubs_table() {\n@@ -247,1 +360,1 @@\n-    table->init_extrs();\n+    table->init_early_stubs();\n@@ -258,0 +371,7 @@\n+void AOTCodeCache::init_early_c1_table() {\n+  AOTCodeAddressTable* table = addr_table();\n+  if (table != nullptr) {\n+    table->init_early_c1();\n+  }\n+}\n+\n@@ -276,0 +396,1 @@\n+    MutexLocker ml(AOTCodeCStrings_lock, Mutex::_no_safepoint_check_flag);\n@@ -308,0 +429,1 @@\n+  _compressedOopBase     = CompressedOops::base();\n@@ -310,1 +432,0 @@\n-  _objectAlignment       = ObjectAlignmentInBytes;\n@@ -315,0 +436,1 @@\n+  \/\/ First checks affect all cached AOT code\n@@ -333,4 +455,0 @@\n-  if (((_flags & compressedOops) != 0) != UseCompressedOops) {\n-    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with UseCompressedOops = %s\", UseCompressedOops ? \"false\" : \"true\");\n-    return false;\n-  }\n@@ -341,7 +459,2 @@\n-\n-  if (((_flags & systemClassAssertions) != 0) != JavaAssertions::systemClassDefault()) {\n-    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with JavaAssertions::systemClassDefault() = %s\", JavaAssertions::systemClassDefault() ? \"disabled\" : \"enabled\");\n-    return false;\n-  }\n-  if (((_flags & userClassAssertions) != 0) != JavaAssertions::userClassDefault()) {\n-    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with JavaAssertions::userClassDefault() = %s\", JavaAssertions::userClassDefault() ? \"disabled\" : \"enabled\");\n+  if (_compressedKlassShift != (uint)CompressedKlassPointers::shift()) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with CompressedKlassPointers::shift() = %d vs current %d\", _compressedKlassShift, CompressedKlassPointers::shift());\n@@ -351,7 +464,5 @@\n-  if (((_flags & enableContendedPadding) != 0) != EnableContended) {\n-    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with EnableContended = %s\", EnableContended ? \"false\" : \"true\");\n-    return false;\n-  }\n-  if (((_flags & restrictContendedPadding) != 0) != RestrictContended) {\n-    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with RestrictContended = %s\", RestrictContended ? \"false\" : \"true\");\n-    return false;\n+  \/\/ The following checks do not affect AOT adapters caching\n+\n+  if (((_flags & compressedOops) != 0) != UseCompressedOops) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with UseCompressedOops = %s\", UseCompressedOops ? \"false\" : \"true\");\n+    AOTStubCaching = false;\n@@ -360,2 +471,2 @@\n-    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with CompressedOops::shift() = %d vs current %d\", _compressedOopShift, CompressedOops::shift());\n-    return false;\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with different CompressedOops::shift(): %d vs current %d\", _compressedOopShift, CompressedOops::shift());\n+    AOTStubCaching = false;\n@@ -363,11 +474,5 @@\n-  if (_compressedKlassShift != (uint)CompressedKlassPointers::shift()) {\n-    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with CompressedKlassPointers::shift() = %d vs current %d\", _compressedKlassShift, CompressedKlassPointers::shift());\n-    return false;\n-  }\n-  if (_contendedPaddingWidth != (uint)ContendedPaddingWidth) {\n-    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with ContendedPaddingWidth = %d vs current %d\", _contendedPaddingWidth, ContendedPaddingWidth);\n-    return false;\n-  }\n-  if (_objectAlignment != (uint)ObjectAlignmentInBytes) {\n-    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with ObjectAlignmentInBytes = %d vs current %d\", _objectAlignment, ObjectAlignmentInBytes);\n-    return false;\n+\n+  \/\/ This should be the last check as it only disables AOTStubCaching\n+  if ((_compressedOopBase == nullptr || CompressedOops::base() == nullptr) && (_compressedOopBase != CompressedOops::base())) {\n+    log_debug(aot, codecache, init)(\"AOTStubCaching is disabled: incompatible CompressedOops::base(): %p vs current %p\", _compressedOopBase, CompressedOops::base());\n+    AOTStubCaching = false;\n@@ -375,0 +480,1 @@\n+\n@@ -378,1 +484,1 @@\n-bool AOTCodeCache::Header::verify_config(uint load_size) const {\n+bool AOTCodeCache::Header::verify(uint load_size) const {\n@@ -407,12 +513,3 @@\n-  assert(size > 0, \"sanity\");\n-  bool by_words = true;\n-  if ((size > 2 * HeapWordSize) && (((intptr_t)from | (intptr_t)to) & (HeapWordSize - 1)) == 0) {\n-    \/\/ Use wordwise copies if possible:\n-    Copy::disjoint_words((HeapWord*)from,\n-                         (HeapWord*)to,\n-                         ((size_t)size + HeapWordSize-1) \/ HeapWordSize);\n-  } else {\n-    by_words = false;\n-    Copy::conjoint_jbytes(from, to, (size_t)size);\n-  }\n-  log_trace(aot, codecache)(\"Copied %d bytes as %s from \" INTPTR_FORMAT \" to \" INTPTR_FORMAT, size, (by_words ? \"HeapWord\" : \"bytes\"), p2i(from), p2i(to));\n+  assert((int)size > 0, \"sanity\");\n+  memcpy(to, from, size);\n+  log_trace(aot, codecache)(\"Copied %d bytes from \" INTPTR_FORMAT \" to \" INTPTR_FORMAT, size, p2i(from), p2i(to));\n@@ -542,0 +639,25 @@\n+      \/\/ Linear search around to handle id collission\n+      for (int i = mid - 1; i >= l; i--) { \/\/ search back\n+        ix = i * 2;\n+        is = _search_entries[ix];\n+        if (is != id) {\n+          break;\n+        }\n+        index = _search_entries[ix + 1];\n+        AOTCodeEntry* entry = &(_load_entries[index]);\n+        if (check_entry(kind, id, entry)) {\n+          return entry; \/\/ Found\n+        }\n+      }\n+      for (int i = mid + 1; i <= h; i++) { \/\/ search forward\n+        ix = i * 2;\n+        is = _search_entries[ix];\n+        if (is != id) {\n+          break;\n+        }\n+        index = _search_entries[ix + 1];\n+        AOTCodeEntry* entry = &(_load_entries[index]);\n+        if (check_entry(kind, id, entry)) {\n+          return entry; \/\/ Found\n+        }\n+      }\n@@ -598,1 +720,3 @@\n-    uint blobs_count = 0;\n+    uint shared_blobs_count = 0;\n+    uint C1_blobs_count = 0;\n+    uint C2_blobs_count = 0;\n@@ -622,2 +746,6 @@\n-      } else if (kind == AOTCodeEntry::Blob) {\n-        blobs_count++;\n+      } else if (kind == AOTCodeEntry::SharedBlob) {\n+        shared_blobs_count++;\n+      } else if (kind == AOTCodeEntry::C1Blob) {\n+        C1_blobs_count++;\n+      } else if (kind == AOTCodeEntry::C2Blob) {\n+        C2_blobs_count++;\n@@ -655,1 +783,3 @@\n-    log_debug(aot, codecache, exit)(\"  All Blobs: total=%u\", blobs_count);\n+    log_debug(aot, codecache, exit)(\"  Shared Blobs:  total=%d\", shared_blobs_count);\n+    log_debug(aot, codecache, exit)(\"  C1 Blobs:      total=%d\", C1_blobs_count);\n+    log_debug(aot, codecache, exit)(\"  C2 Blobs:      total=%d\", C2_blobs_count);\n@@ -662,1 +792,2 @@\n-                 adapters_count, blobs_count);\n+                 adapters_count, shared_blobs_count,\n+                 C1_blobs_count, C2_blobs_count);\n@@ -678,1 +809,1 @@\n-  if ((entry_kind == AOTCodeEntry::Adapter) && !AOTAdapterCaching) {\n+  if (AOTCodeEntry::is_adapter(entry_kind) && !is_dumping_adapter()) {\n@@ -681,1 +812,4 @@\n-  log_debug(aot, codecache, stubs)(\"Writing blob '%s' to AOT Code Cache\", name);\n+  if (AOTCodeEntry::is_blob(entry_kind) && !is_dumping_stub()) {\n+    return false;\n+  }\n+  log_debug(aot, codecache, stubs)(\"Writing blob '%s' (id=%u, kind=%s) to AOT Code Cache\", name, id, aot_code_entry_kind_name[entry_kind]);\n@@ -693,0 +827,3 @@\n+  if (!is_on()) {\n+    return false; \/\/ AOT code cache was already dumped and closed.\n+  }\n@@ -731,0 +868,10 @@\n+#ifndef PRODUCT\n+  \/\/ Write asm remarks\n+  if (!cache->write_asm_remarks(blob)) {\n+    return false;\n+  }\n+  if (!cache->write_dbg_strings(blob)) {\n+    return false;\n+  }\n+#endif \/* PRODUCT *\/\n+\n@@ -732,0 +879,4 @@\n+    if (!cache->failed()) {\n+      \/\/ We may miss an address in AOT table - skip this code blob.\n+      cache->set_write_position(entry_position);\n+    }\n@@ -748,1 +899,1 @@\n-  AOTCodeEntry* entry = new(cache) AOTCodeEntry(entry_kind, id,\n+  AOTCodeEntry* entry = new(cache) AOTCodeEntry(entry_kind, encode_id(entry_kind, id),\n@@ -751,1 +902,1 @@\n-  log_debug(aot, codecache, stubs)(\"Wrote code blob '%s(id=%d)' to AOT Code Cache\", name, id);\n+  log_debug(aot, codecache, stubs)(\"Wrote code blob '%s' (id=%u, kind=%s) to AOT Code Cache\", name, id, aot_code_entry_kind_name[entry_kind]);\n@@ -755,0 +906,6 @@\n+bool AOTCodeCache::store_code_blob(CodeBlob& blob, AOTCodeEntry::Kind entry_kind, BlobId id, int entry_offset_count, int* entry_offsets) {\n+  assert(AOTCodeEntry::is_blob(entry_kind),\n+         \"wrong entry kind for blob id %s\", StubInfo::name(id));\n+  return store_code_blob(blob, entry_kind, (uint)id, StubInfo::name(id), entry_offset_count, entry_offsets);\n+}\n+\n@@ -762,1 +919,1 @@\n-  if ((entry_kind == AOTCodeEntry::Adapter) && !AOTAdapterCaching) {\n+  if (AOTCodeEntry::is_adapter(entry_kind) && !is_using_adapter()) {\n@@ -765,1 +922,4 @@\n-  log_debug(aot, codecache, stubs)(\"Reading blob '%s' from AOT Code Cache\", name);\n+  if (AOTCodeEntry::is_blob(entry_kind) && !is_using_stub()) {\n+    return nullptr;\n+  }\n+  log_debug(aot, codecache, stubs)(\"Reading blob '%s' (id=%u, kind=%s) from AOT Code Cache\", name, id, aot_code_entry_kind_name[entry_kind]);\n@@ -767,1 +927,1 @@\n-  AOTCodeEntry* entry = cache->find_entry(entry_kind, id);\n+  AOTCodeEntry* entry = cache->find_entry(entry_kind, encode_id(entry_kind, id));\n@@ -772,1 +932,11 @@\n-  return reader.compile_code_blob(name, entry_offset_count, entry_offsets);\n+  CodeBlob* blob = reader.compile_code_blob(name, entry_offset_count, entry_offsets);\n+\n+  log_debug(aot, codecache, stubs)(\"%sRead blob '%s' (id=%u, kind=%s) from AOT Code Cache\",\n+                                   (blob == nullptr? \"Failed to \" : \"\"), name, id, aot_code_entry_kind_name[entry_kind]);\n+  return blob;\n+}\n+\n+CodeBlob* AOTCodeCache::load_code_blob(AOTCodeEntry::Kind entry_kind, BlobId id, int entry_offset_count, int* entry_offsets) {\n+  assert(AOTCodeEntry::is_blob(entry_kind),\n+         \"wrong entry kind for blob id %s\", StubInfo::name(id));\n+  return load_code_blob(entry_kind, (uint)id, StubInfo::name(id), entry_offset_count, entry_offsets);\n@@ -786,2 +956,1 @@\n-    ((AOTCodeCache*)_cache)->set_failed();\n-    report_load_failure();\n+    set_lookup_failed(); \/\/ Skip this blob\n@@ -805,1 +974,5 @@\n-  CodeBlob* code_blob = CodeBlob::create(archived_blob, stored_name, reloc_data, oop_maps);\n+  CodeBlob* code_blob = CodeBlob::create(archived_blob,\n+                                         stored_name,\n+                                         reloc_data,\n+                                         oop_maps\n+                                        );\n@@ -810,0 +983,7 @@\n+#ifndef PRODUCT\n+  code_blob->asm_remarks().init();\n+  read_asm_remarks(code_blob->asm_remarks());\n+  code_blob->dbg_strings().init();\n+  read_dbg_strings(code_blob->dbg_strings());\n+#endif \/\/ PRODUCT\n+\n@@ -827,1 +1007,0 @@\n-  log_debug(aot, codecache, stubs)(\"Read blob '%s' from AOT Code Cache\", name);\n@@ -840,0 +1019,4 @@\n+\/\/ Can't use -1. It is valid value for jump to iteself destination\n+\/\/ used by static call stub: see NativeJump::jump_destination().\n+#define BAD_ADDRESS_ID -2\n+\n@@ -856,1 +1039,5 @@\n-        reloc_data.at_put(idx, _table->id_for_address(dest, iter, &code_blob));\n+        int id = _table->id_for_address(dest, iter, &code_blob);\n+        if (id == BAD_ADDRESS_ID) {\n+          return false;\n+        }\n+        reloc_data.at_put(idx, id);\n@@ -860,2 +1047,2 @@\n-        fatal(\"runtime_call_w_cp_type unimplemented\");\n-        break;\n+        log_debug(aot, codecache, reloc)(\"runtime_call_w_cp_type relocation is not implemented\");\n+        return false;\n@@ -865,1 +1052,5 @@\n-        reloc_data.at_put(idx, _table->id_for_address(target, iter, &code_blob));\n+        int id = _table->id_for_address(target, iter, &code_blob);\n+        if (id == BAD_ADDRESS_ID) {\n+          return false;\n+        }\n+        reloc_data.at_put(idx, id);\n@@ -872,0 +1063,2 @@\n+      case relocInfo::post_call_nop_type:\n+        break;\n@@ -873,1 +1066,2 @@\n-        fatal(\"relocation %d unimplemented\", (int)iter.type());\n+        log_debug(aot, codecache, reloc)(\"relocation %d unimplemented\", (int)iter.type());\n+        return false;\n@@ -922,1 +1116,2 @@\n-        fatal(\"runtime_call_w_cp_type unimplemented\");\n+        \/\/ this relocation should not be in cache (see write_relocations)\n+        assert(false, \"runtime_call_w_cp_type relocation is not implemented\");\n@@ -945,0 +1140,2 @@\n+      case relocInfo::post_call_nop_type:\n+        break;\n@@ -946,1 +1143,1 @@\n-        fatal(\"relocation %d unimplemented\", (int)iter.type());\n+        assert(false,\"relocation %d unimplemented\", (int)iter.type());\n@@ -980,0 +1177,82 @@\n+#ifndef PRODUCT\n+bool AOTCodeCache::write_asm_remarks(CodeBlob& cb) {\n+  \/\/ Write asm remarks\n+  uint* count_ptr = (uint *)reserve_bytes(sizeof(uint));\n+  if (count_ptr == nullptr) {\n+    return false;\n+  }\n+  uint count = 0;\n+  bool result = cb.asm_remarks().iterate([&] (uint offset, const char* str) -> bool {\n+    log_trace(aot, codecache, stubs)(\"asm remark offset=%d, str='%s'\", offset, str);\n+    uint n = write_bytes(&offset, sizeof(uint));\n+    if (n != sizeof(uint)) {\n+      return false;\n+    }\n+    const char* cstr = add_C_string(str);\n+    int id = _table->id_for_C_string((address)cstr);\n+    assert(id != -1, \"asm remark string '%s' not found in AOTCodeAddressTable\", str);\n+    n = write_bytes(&id, sizeof(int));\n+    if (n != sizeof(int)) {\n+      return false;\n+    }\n+    count += 1;\n+    return true;\n+  });\n+  *count_ptr = count;\n+  return result;\n+}\n+\n+void AOTCodeReader::read_asm_remarks(AsmRemarks& asm_remarks) {\n+  \/\/ Read asm remarks\n+  uint offset = read_position();\n+  uint count = *(uint *)addr(offset);\n+  offset += sizeof(uint);\n+  for (uint i = 0; i < count; i++) {\n+    uint remark_offset = *(uint *)addr(offset);\n+    offset += sizeof(uint);\n+    int remark_string_id = *(uint *)addr(offset);\n+    offset += sizeof(int);\n+    const char* remark = (const char*)_cache->address_for_C_string(remark_string_id);\n+    asm_remarks.insert(remark_offset, remark);\n+  }\n+  set_read_position(offset);\n+}\n+\n+bool AOTCodeCache::write_dbg_strings(CodeBlob& cb) {\n+  \/\/ Write dbg strings\n+  uint* count_ptr = (uint *)reserve_bytes(sizeof(uint));\n+  if (count_ptr == nullptr) {\n+    return false;\n+  }\n+  uint count = 0;\n+  bool result = cb.dbg_strings().iterate([&] (const char* str) -> bool {\n+    log_trace(aot, codecache, stubs)(\"dbg string=%s\", str);\n+    const char* cstr = add_C_string(str);\n+    int id = _table->id_for_C_string((address)cstr);\n+    assert(id != -1, \"db string '%s' not found in AOTCodeAddressTable\", str);\n+    uint n = write_bytes(&id, sizeof(int));\n+    if (n != sizeof(int)) {\n+      return false;\n+    }\n+    count += 1;\n+    return true;\n+  });\n+  *count_ptr = count;\n+  return result;\n+}\n+\n+void AOTCodeReader::read_dbg_strings(DbgStrings& dbg_strings) {\n+  \/\/ Read dbg strings\n+  uint offset = read_position();\n+  uint count = *(uint *)addr(offset);\n+  offset += sizeof(uint);\n+  for (uint i = 0; i < count; i++) {\n+    int string_id = *(uint *)addr(offset);\n+    offset += sizeof(int);\n+    const char* str = (const char*)_cache->address_for_C_string(string_id);\n+    dbg_strings.insert(str);\n+  }\n+  set_read_position(offset);\n+}\n+#endif \/\/ PRODUCT\n+\n@@ -989,6 +1268,2 @@\n-#define _extrs_max 13\n-#define _blobs_max 10\n-#define _all_max   23\n-#define _extrs_base 0\n-#define _blobs_base (_extrs_base + _extrs_max)\n-#define _blobs_end  (_blobs_base + _blobs_max)\n+#define _extrs_max 100\n+#define _stubs_max 3\n@@ -997,3 +1272,10 @@\n-#if (_blobs_end > _all_max)\n-#error AOTCodeAddress table ranges need adjusting\n-#endif\n+#define _shared_blobs_max 20\n+#define _C1_blobs_max 10\n+#define _blobs_max (_shared_blobs_max+_C1_blobs_max)\n+#define _all_max (_extrs_max+_stubs_max+_blobs_max)\n+\n+#define _extrs_base 0\n+#define _stubs_base (_extrs_base + _extrs_max)\n+#define _shared_blobs_base (_stubs_base + _stubs_max)\n+#define _C1_blobs_base (_shared_blobs_base + _shared_blobs_max)\n+#define _blobs_end  (_shared_blobs_base + _blobs_max)\n@@ -1011,0 +1293,3 @@\n+\n+  assert(_blobs_end <= _all_max, \"AOTCodeAddress table ranges need adjusting\");\n+\n@@ -1016,1 +1301,1 @@\n-  \/\/ Recored addresses of VM runtime methods\n+  \/\/ Record addresses of VM runtime methods\n@@ -1021,0 +1306,88 @@\n+#if defined(AARCH64) && !defined(ZERO)\n+  SET_ADDRESS(_extrs, JavaThread::aarch64_get_thread_helper);\n+#endif\n+  {\n+    \/\/ Required by Shared blobs\n+    SET_ADDRESS(_extrs, Deoptimization::fetch_unroll_info);\n+    SET_ADDRESS(_extrs, Deoptimization::unpack_frames);\n+    SET_ADDRESS(_extrs, SafepointSynchronize::handle_polling_page_exception);\n+    SET_ADDRESS(_extrs, SharedRuntime::resolve_opt_virtual_call_C);\n+    SET_ADDRESS(_extrs, SharedRuntime::resolve_virtual_call_C);\n+    SET_ADDRESS(_extrs, SharedRuntime::resolve_static_call_C);\n+    SET_ADDRESS(_extrs, SharedRuntime::throw_StackOverflowError);\n+    SET_ADDRESS(_extrs, SharedRuntime::throw_delayed_StackOverflowError);\n+    SET_ADDRESS(_extrs, SharedRuntime::throw_AbstractMethodError);\n+    SET_ADDRESS(_extrs, SharedRuntime::throw_IncompatibleClassChangeError);\n+    SET_ADDRESS(_extrs, SharedRuntime::throw_NullPointerException_at_call);\n+  }\n+\n+#ifdef COMPILER1\n+  {\n+    \/\/ Required by C1 blobs\n+    SET_ADDRESS(_extrs, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc));\n+    SET_ADDRESS(_extrs, SharedRuntime::exception_handler_for_return_address);\n+    SET_ADDRESS(_extrs, SharedRuntime::register_finalizer);\n+    SET_ADDRESS(_extrs, Runtime1::is_instance_of);\n+    SET_ADDRESS(_extrs, Runtime1::exception_handler_for_pc);\n+    SET_ADDRESS(_extrs, Runtime1::check_abort_on_vm_exception);\n+    SET_ADDRESS(_extrs, Runtime1::new_instance);\n+    SET_ADDRESS(_extrs, Runtime1::counter_overflow);\n+    SET_ADDRESS(_extrs, Runtime1::new_type_array);\n+    SET_ADDRESS(_extrs, Runtime1::new_object_array);\n+    SET_ADDRESS(_extrs, Runtime1::new_multi_array);\n+    SET_ADDRESS(_extrs, Runtime1::throw_range_check_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_index_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_div0_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_null_pointer_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_array_store_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_class_cast_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_incompatible_class_change_error);\n+    SET_ADDRESS(_extrs, Runtime1::is_instance_of);\n+    SET_ADDRESS(_extrs, Runtime1::monitorenter);\n+    SET_ADDRESS(_extrs, Runtime1::monitorexit);\n+    SET_ADDRESS(_extrs, Runtime1::deoptimize);\n+    SET_ADDRESS(_extrs, Runtime1::access_field_patching);\n+    SET_ADDRESS(_extrs, Runtime1::move_klass_patching);\n+    SET_ADDRESS(_extrs, Runtime1::move_mirror_patching);\n+    SET_ADDRESS(_extrs, Runtime1::move_appendix_patching);\n+    SET_ADDRESS(_extrs, Runtime1::predicate_failed_trap);\n+    SET_ADDRESS(_extrs, Runtime1::unimplemented_entry);\n+    SET_ADDRESS(_extrs, Thread::current);\n+    SET_ADDRESS(_extrs, CompressedKlassPointers::base_addr());\n+#ifndef PRODUCT\n+    SET_ADDRESS(_extrs, os::breakpoint);\n+#endif\n+  }\n+#endif\n+\n+#ifdef COMPILER2\n+  {\n+    \/\/ Required by C2 blobs\n+    SET_ADDRESS(_extrs, Deoptimization::uncommon_trap);\n+    SET_ADDRESS(_extrs, OptoRuntime::handle_exception_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::new_instance_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::new_array_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::new_array_nozero_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::multianewarray2_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::multianewarray3_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::multianewarray4_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::multianewarray5_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::multianewarrayN_C);\n+#if INCLUDE_JVMTI\n+    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_start);\n+    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_end);\n+    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_mount);\n+    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_unmount);\n+#endif\n+    SET_ADDRESS(_extrs, OptoRuntime::complete_monitor_locking_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::monitor_notify_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::monitor_notifyAll_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::rethrow_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::slow_arraycopy_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::register_finalizer_C);\n+#if defined(AARCH64)\n+    SET_ADDRESS(_extrs, JavaThread::verify_cross_modify_fence_failure);\n+#endif \/\/ AARCH64\n+  }\n+#endif \/\/ COMPILER2\n+\n@@ -1036,3 +1409,0 @@\n-#ifdef COMPILER2\n-  SET_ADDRESS(_extrs, OptoRuntime::handle_exception_C);\n-#endif\n@@ -1049,0 +1419,21 @@\n+static bool initializing_early_stubs = false;\n+\n+void AOTCodeAddressTable::init_early_stubs() {\n+  if (_complete || initializing_early_stubs) return; \/\/ Done already\n+  initializing_early_stubs = true;\n+  _stubs_addr = NEW_C_HEAP_ARRAY(address, _stubs_max, mtCode);\n+  _stubs_length = 0;\n+  SET_ADDRESS(_stubs, StubRoutines::forward_exception_entry());\n+\n+  {\n+    \/\/ Required by C1 blobs\n+#if defined(AMD64) && !defined(ZERO)\n+    SET_ADDRESS(_stubs, StubRoutines::x86::double_sign_flip());\n+    SET_ADDRESS(_stubs, StubRoutines::x86::d2l_fixup());\n+#endif \/\/ AMD64\n+  }\n+\n+  _early_stubs_complete = true;\n+  log_info(aot, codecache, init)(\"Early stubs recorded\");\n+}\n+\n@@ -1054,7 +1445,25 @@\n-  _blobs_addr = NEW_C_HEAP_ARRAY(address, _blobs_max, mtCode);\n-\n-  _blobs_length = 0;       \/\/ for shared blobs\n-\n-  \/\/ Recored addresses of generated code blobs\n-  SET_ADDRESS(_blobs, SharedRuntime::get_handle_wrong_method_stub());\n-  SET_ADDRESS(_blobs, SharedRuntime::get_ic_miss_stub());\n+  address* blobs_addr = NEW_C_HEAP_ARRAY(address, _blobs_max, mtCode);\n+\n+  \/\/ Divide _shared_blobs_addr array to chunks because they could be initialized in parrallel\n+  _shared_blobs_addr = blobs_addr;\n+  _C1_blobs_addr = _shared_blobs_addr + _shared_blobs_max;\n+\n+  _shared_blobs_length = 0;\n+  _C1_blobs_length = 0;\n+\n+  \/\/ clear the address table\n+  memset(blobs_addr, 0, sizeof(address)* _blobs_max);\n+\n+  \/\/ Record addresses of generated code blobs\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::get_handle_wrong_method_stub());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::get_ic_miss_stub());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->unpack());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->unpack_with_exception());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->unpack_with_reexecution());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->unpack_with_exception_in_tls());\n+#if INCLUDE_JVMCI\n+  if (EnableJVMCI) {\n+    SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->uncommon_trap());\n+    SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->implicit_exception_uncommon_trap());\n+  }\n+#endif\n@@ -1067,0 +1476,23 @@\n+void AOTCodeAddressTable::init_early_c1() {\n+#ifdef COMPILER1\n+  \/\/ Runtime1 Blobs\n+  StubId id = StubInfo::stub_base(StubGroup::C1);\n+  \/\/ include forward_exception in range we publish\n+  StubId limit = StubInfo::next(StubId::c1_forward_exception_id);\n+  for (; id != limit; id = StubInfo::next(id)) {\n+    if (Runtime1::blob_for(id) == nullptr) {\n+      log_info(aot, codecache, init)(\"C1 blob %s is missing\", Runtime1::name_for(id));\n+      continue;\n+    }\n+    if (Runtime1::entry_for(id) == nullptr) {\n+      log_info(aot, codecache, init)(\"C1 blob %s is missing entry\", Runtime1::name_for(id));\n+      continue;\n+    }\n+    address entry = Runtime1::entry_for(id);\n+    SET_ADDRESS(_C1_blobs, entry);\n+  }\n+#endif \/\/ COMPILER1\n+  assert(_C1_blobs_length <= _C1_blobs_max, \"increase _C1_blobs_max to %d\", _C1_blobs_length);\n+  _early_c1_complete = true;\n+}\n+\n@@ -1073,2 +1505,5 @@\n-  if (_blobs_addr != nullptr) {\n-    FREE_C_HEAP_ARRAY(address, _blobs_addr);\n+  if (_stubs_addr != nullptr) {\n+    FREE_C_HEAP_ARRAY(address, _stubs_addr);\n+  }\n+  if (_shared_blobs_addr != nullptr) {\n+    FREE_C_HEAP_ARRAY(address, _shared_blobs_addr);\n@@ -1084,1 +1519,1 @@\n-#define _c_str_base _all_max\n+static const int _c_str_base = _all_max;\n@@ -1124,0 +1559,1 @@\n+    MutexLocker ml(AOTCodeCStrings_lock, Mutex::_no_safepoint_check_flag);\n@@ -1149,1 +1585,5 @@\n-    return _cache->_table->add_C_string(str);\n+    MutexLocker ml(AOTCodeCStrings_lock, Mutex::_no_safepoint_check_flag);\n+    AOTCodeAddressTable* table = addr_table();\n+    if (table != nullptr) {\n+      return table->add_C_string(str);\n+    }\n@@ -1156,2 +1596,0 @@\n-    LogStreamHandle(Trace, aot, codecache, stringtable) log; \/\/ ctor outside lock\n-    MutexLocker ml(AOTCodeCStrings_lock, Mutex::_no_safepoint_check_flag);\n@@ -1174,3 +1612,1 @@\n-      if (log.is_enabled()) {\n-        log.print_cr(\"add_C_string: [%d] \" INTPTR_FORMAT \" '%s'\", _C_strings_count, p2i(dup), dup);\n-      }\n+      log_trace(aot, codecache, stringtable)(\"add_C_string: [%d] \" INTPTR_FORMAT \" '%s'\", _C_strings_count, p2i(dup), dup);\n@@ -1179,1 +1615,1 @@\n-      fatal(\"Number of C strings >= MAX_STR_COUNT\");\n+      assert(false, \"Number of C strings >= MAX_STR_COUNT\");\n@@ -1218,1 +1654,1 @@\n-  return -1;\n+  return BAD_ADDRESS_ID;\n@@ -1222,3 +1658,1 @@\n-  if (!_extrs_complete) {\n-    fatal(\"AOT Code Cache VM runtime addresses table is not complete\");\n-  }\n+  assert(_extrs_complete, \"AOT Code Cache VM runtime addresses table is not complete\");\n@@ -1235,0 +1669,1 @@\n+    return nullptr;\n@@ -1240,2 +1675,8 @@\n-  if (id >= _blobs_base && id < _blobs_base + _blobs_length) {\n-    return _blobs_addr[id - _blobs_base];\n+  if (id >= _stubs_base && id < _stubs_base + _stubs_length) {\n+    return _stubs_addr[id - _stubs_base];\n+  }\n+  if (id >= _shared_blobs_base && id < _shared_blobs_base + _shared_blobs_length) {\n+    return _shared_blobs_addr[id - _shared_blobs_base];\n+  }\n+  if (id >= _C1_blobs_base && id < _C1_blobs_base + _C1_blobs_length) {\n+    return _C1_blobs_addr[id - _C1_blobs_base];\n@@ -1251,3 +1692,1 @@\n-  if (!_extrs_complete) {\n-    fatal(\"AOT Code Cache VM runtime addresses table is not complete\");\n-  }\n+  assert(_extrs_complete, \"AOT Code Cache VM runtime addresses table is not complete\");\n@@ -1265,3 +1704,10 @@\n-    StubCodeDesc* desc = StubCodeDesc::desc_for(addr);\n-    if (desc == nullptr) {\n-      desc = StubCodeDesc::desc_for(addr + frame::pc_return_offset);\n+    id = search_address(addr, _stubs_addr, _stubs_length);\n+    if (id < 0) {\n+      StubCodeDesc* desc = StubCodeDesc::desc_for(addr);\n+      if (desc == nullptr) {\n+        desc = StubCodeDesc::desc_for(addr + frame::pc_return_offset);\n+      }\n+      const char* sub_name = (desc != nullptr) ? desc->name() : \"<unknown>\";\n+      assert(false, \"Address \" INTPTR_FORMAT \" for Stub:%s is missing in AOT Code Cache addresses table\", p2i(addr), sub_name);\n+    } else {\n+      return id + _stubs_base;\n@@ -1269,2 +1715,0 @@\n-    const char* sub_name = (desc != nullptr) ? desc->name() : \"<unknown>\";\n-    fatal(\"Address \" INTPTR_FORMAT \" for Stub:%s is missing in AOT Code Cache addresses table\", p2i(addr), sub_name);\n@@ -1275,2 +1719,2 @@\n-      int id_base = _blobs_base;\n-      id = search_address(addr, _blobs_addr, _blobs_length);\n+      int id_base = _shared_blobs_base;\n+      id = search_address(addr, _shared_blobs_addr, _blobs_max);\n@@ -1278,1 +1722,1 @@\n-        fatal(\"Address \" INTPTR_FORMAT \" for Blob:%s is missing in AOT Code Cache addresses table\", p2i(addr), cb->name());\n+        assert(false, \"Address \" INTPTR_FORMAT \" for Blob:%s is missing in AOT Code Cache addresses table\", p2i(addr), cb->name());\n@@ -1299,0 +1743,1 @@\n+#ifdef ASSERT\n@@ -1302,1 +1747,2 @@\n-          fatal(\"Address \" INTPTR_FORMAT \" for runtime target '%s+%d' is missing in AOT Code Cache addresses table\", p2i(addr), func_name, offset);\n+          assert(false, \"Address \" INTPTR_FORMAT \" for runtime target '%s+%d' is missing in AOT Code Cache addresses table\", p2i(addr), func_name, offset);\n+#endif\n@@ -1304,0 +1750,1 @@\n+#ifdef ASSERT\n@@ -1308,1 +1755,2 @@\n-          fatal(\"Address \" INTPTR_FORMAT \" for <unknown>\/('%s') is missing in AOT Code Cache addresses table\", p2i(addr), (const char*)addr);\n+          assert(false, \"Address \" INTPTR_FORMAT \" for <unknown>\/('%s') is missing in AOT Code Cache addresses table\", p2i(addr), (const char*)addr);\n+#endif\n@@ -1318,0 +1766,2 @@\n+\/\/ This is called after initialize() but before init2()\n+\/\/ and _cache is not set yet.\n@@ -1319,4 +1769,4 @@\n-  AOTCodeCache* cache = open_for_use();\n-  if (cache != nullptr) {\n-    uint count = cache->_load_header->entries_count();\n-    uint* search_entries = (uint*)cache->addr(cache->_load_header->entries_offset()); \/\/ [id, index]\n+  if (opened_cache != nullptr && opened_cache->for_use()) {\n+    st->print_cr(\"\\nAOT Code Cache\");\n+    uint count = opened_cache->_load_header->entries_count();\n+    uint* search_entries = (uint*)opened_cache->addr(opened_cache->_load_header->entries_offset()); \/\/ [id, index]\n@@ -1332,1 +1782,1 @@\n-      const char* saved_name = cache->addr(name_offset);\n+      const char* saved_name = opened_cache->addr(name_offset);\n@@ -1334,2 +1784,2 @@\n-      st->print_cr(\"%4u: entry_idx:%4u Kind:%u Id:%u size=%u '%s'\",\n-                   i, index, entry->kind(), entry->id(), entry->size(), saved_name);\n+      st->print_cr(\"%4u: %10s idx:%4u Id:%u size=%u '%s'\",\n+                   i, aot_code_entry_kind_name[entry->kind()], index, entry->id(), entry->size(), saved_name);\n@@ -1337,2 +1787,0 @@\n-  } else {\n-    st->print_cr(\"failed to map code cache\");\n@@ -1341,1 +1789,0 @@\n-\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":601,"deletions":154,"binary":false,"changes":755,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+#include \"runtime\/stubInfo.hpp\"\n+\n@@ -41,0 +43,2 @@\n+class AsmRemarks;\n+class DbgStrings;\n@@ -45,0 +49,7 @@\n+#define DO_AOTCODEENTRY_KIND(Fn) \\\n+  Fn(None) \\\n+  Fn(Adapter) \\\n+  Fn(SharedBlob) \\\n+  Fn(C1Blob) \\\n+  Fn(C2Blob) \\\n+\n@@ -48,4 +59,5 @@\n-  enum Kind {\n-    None    = 0,\n-    Adapter = 1,\n-    Blob    = 2\n+  enum Kind : s1 {\n+#define DECL_KIND_ENUM(kind) kind,\n+    DO_AOTCODEENTRY_KIND(DECL_KIND_ENUM)\n+#undef DECL_KIND_ENUM\n+    Kind_count\n@@ -103,1 +115,3 @@\n-  static bool is_valid_entry_kind(Kind kind) { return kind == Adapter || kind == Blob; }\n+  static bool is_valid_entry_kind(Kind kind) { return kind > None && kind < Kind_count; }\n+  static bool is_blob(Kind kind) { return kind == SharedBlob || kind == C1Blob || kind == C2Blob; }\n+  static bool is_adapter(Kind kind) { return kind == Adapter; }\n@@ -110,1 +124,3 @@\n-  address* _blobs_addr;\n+  address* _stubs_addr;\n+  address* _shared_blobs_addr;\n+  address* _C1_blobs_addr;\n@@ -112,1 +128,3 @@\n-  uint     _blobs_length;\n+  uint     _stubs_length;\n+  uint     _shared_blobs_length;\n+  uint     _C1_blobs_length;\n@@ -115,0 +133,1 @@\n+  bool _early_stubs_complete;\n@@ -116,0 +135,1 @@\n+  bool _early_c1_complete;\n@@ -121,1 +141,3 @@\n-    _blobs_addr(nullptr),\n+    _stubs_addr(nullptr),\n+    _shared_blobs_addr(nullptr),\n+    _C1_blobs_addr(nullptr),\n@@ -123,1 +145,3 @@\n-    _blobs_length(0),\n+    _stubs_length(0),\n+    _shared_blobs_length(0),\n+    _C1_blobs_length(0),\n@@ -125,0 +149,1 @@\n+    _early_stubs_complete(false),\n@@ -126,0 +151,1 @@\n+    _early_c1_complete(false),\n@@ -130,0 +156,1 @@\n+  void init_early_stubs();\n@@ -131,0 +158,1 @@\n+  void init_early_c1();\n@@ -143,0 +171,1 @@\n+    address _compressedOopBase;\n@@ -146,1 +175,0 @@\n-    uint _objectAlignment;\n@@ -178,1 +206,3 @@\n-    uint   _blobs_count;\n+    uint   _shared_blobs_count;\n+    uint   _C1_blobs_count;\n+    uint   _C2_blobs_count;\n@@ -181,1 +211,1 @@\n-public:\n+  public:\n@@ -185,1 +215,2 @@\n-              uint adapters_count, uint blobs_count) {\n+              uint adapters_count, uint shared_blobs_count,\n+              uint C1_blobs_count, uint C2_blobs_count) {\n@@ -193,2 +224,3 @@\n-      _blobs_count    = blobs_count;\n-\n+      _shared_blobs_count = shared_blobs_count;\n+      _C1_blobs_count = C1_blobs_count;\n+      _C2_blobs_count = C2_blobs_count;\n@@ -205,1 +237,3 @@\n-    uint blobs_count()    const { return _blobs_count; }\n+    uint shared_blobs_count()    const { return _shared_blobs_count; }\n+    uint C1_blobs_count() const { return _C1_blobs_count; }\n+    uint C2_blobs_count() const { return _C2_blobs_count; }\n@@ -207,2 +241,2 @@\n-    bool verify_config(uint load_size)  const;\n-    bool verify_vm_config() const { \/\/ Called after Universe initialized\n+    bool verify(uint load_size)  const;\n+    bool verify_config() const { \/\/ Called after Universe initialized\n@@ -269,1 +303,1 @@\n-  static void init_extrs_table() NOT_CDS_RETURN;\n+  static void init_early_stubs_table() NOT_CDS_RETURN;\n@@ -271,0 +305,1 @@\n+  static void init_early_c1_table() NOT_CDS_RETURN;\n@@ -272,0 +307,1 @@\n+  address address_for_C_string(int idx) const { return _table->address_for_C_string(idx); }\n@@ -291,0 +327,4 @@\n+#ifndef PRODUCT\n+  bool write_asm_remarks(CodeBlob& cb);\n+  bool write_dbg_strings(CodeBlob& cb);\n+#endif \/\/ PRODUCT\n@@ -292,0 +332,1 @@\n+  \/\/ save and restore API for non-enumerable code blobs\n@@ -295,2 +336,2 @@\n-                              int entry_offset_count,\n-                              int* entry_offsets) NOT_CDS_RETURN_(false);\n+                              int entry_offset_count = 0,\n+                              int* entry_offsets = nullptr) NOT_CDS_RETURN_(false);\n@@ -300,2 +341,14 @@\n-                                  int entry_offset_count,\n-                                  int* entry_offsets) NOT_CDS_RETURN_(nullptr);\n+                                  int entry_offset_count = 0,\n+                                  int* entry_offsets = nullptr) NOT_CDS_RETURN_(nullptr);\n+\n+  \/\/ save and restore API for enumerable code blobs\n+  static bool store_code_blob(CodeBlob& blob,\n+                              AOTCodeEntry::Kind entry_kind,\n+                              BlobId id,\n+                              int entry_offset_count = 0,\n+                              int* entry_offsets = nullptr) NOT_CDS_RETURN_(false);\n+\n+  static CodeBlob* load_code_blob(AOTCodeEntry::Kind kind,\n+                                  BlobId id,\n+                                  int entry_offset_count = 0,\n+                                  int* entry_offsets = nullptr) NOT_CDS_RETURN_(nullptr);\n@@ -313,1 +366,2 @@\n-  static AOTCodeCache*  _cache;\n+  static AOTCodeCache* _cache;\n+  DEBUG_ONLY( static bool _passed_init2; )\n@@ -316,3 +370,3 @@\n-  static bool verify_vm_config() {\n-    if (is_on_for_use()) {\n-      return _cache->_load_header->verify_vm_config();\n+  bool verify_config() {\n+    if (for_use()) {\n+      return _load_header->verify_config();\n@@ -323,1 +377,1 @@\n-  static AOTCodeCache* cache() { return _cache; }\n+  static AOTCodeCache* cache() { assert(_passed_init2, \"Too early to ask\"); return _cache; }\n@@ -327,1 +381,1 @@\n-  static bool is_on() CDS_ONLY({ return _cache != nullptr && !_cache->closing(); }) NOT_CDS_RETURN_(false);\n+  static bool is_on() CDS_ONLY({ return cache() != nullptr && !_cache->closing(); }) NOT_CDS_RETURN_(false);\n@@ -330,3 +384,7 @@\n-\n-  static bool is_dumping_adapters() NOT_CDS_RETURN_(false);\n-  static bool is_using_adapters() NOT_CDS_RETURN_(false);\n+  static bool is_dumping_stub() NOT_CDS_RETURN_(false);\n+  static bool is_dumping_adapter() NOT_CDS_RETURN_(false);\n+  static bool is_using_stub() NOT_CDS_RETURN_(false);\n+  static bool is_using_adapter() NOT_CDS_RETURN_(false);\n+  static void enable_caching() NOT_CDS_RETURN;\n+  static void disable_caching() NOT_CDS_RETURN;\n+  static bool is_caching_enabled() NOT_CDS_RETURN_(false);\n@@ -364,0 +422,4 @@\n+#ifndef PRODUCT\n+  void read_asm_remarks(AsmRemarks& asm_remarks);\n+  void read_dbg_strings(DbgStrings& dbg_strings);\n+#endif \/\/ PRODUCT\n@@ -365,1 +427,2 @@\n-#endif \/\/ SHARE_CODE_AOTCODECACH_HPP\n+\n+#endif \/\/ SHARE_CODE_AOTCODECACHE_HPP\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.hpp","additions":97,"deletions":34,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-    assert(_mutable_data = blob_end(), \"sanity\");\n+    assert(_mutable_data == blob_end(), \"sanity\");\n@@ -180,0 +180,1 @@\n+  _mutable_data_size(0),\n@@ -188,1 +189,1 @@\n-  assert(_mutable_data = blob_end(), \"sanity\");\n+  assert(_mutable_data == blob_end(), \"sanity\");\n@@ -198,0 +199,2 @@\n+  } else {\n+    _mutable_data = blob_end(); \/\/ default value\n@@ -200,0 +203,1 @@\n+    assert(_mutable_data_size > 0, \"relocation is part of mutable data section\");\n@@ -209,0 +213,2 @@\n+    _mutable_data_size = 0;\n+    _relocation_size = 0;\n@@ -267,1 +273,5 @@\n-CodeBlob* CodeBlob::restore(address code_cache_buffer, const char* name, address archived_reloc_data, ImmutableOopMapSet* archived_oop_maps) {\n+CodeBlob* CodeBlob::restore(address code_cache_buffer,\n+                            const char* name,\n+                            address archived_reloc_data,\n+                            ImmutableOopMapSet* archived_oop_maps)\n+{\n@@ -276,1 +286,6 @@\n-CodeBlob* CodeBlob::create(CodeBlob* archived_blob, const char* name, address archived_reloc_data, ImmutableOopMapSet* archived_oop_maps) {\n+CodeBlob* CodeBlob::create(CodeBlob* archived_blob,\n+                           const char* name,\n+                           address archived_reloc_data,\n+                           ImmutableOopMapSet* archived_oop_maps\n+                          )\n+{\n@@ -287,1 +302,4 @@\n-      blob = archived_blob->restore(code_cache_buffer, name, archived_reloc_data, archived_oop_maps);\n+      blob = archived_blob->restore(code_cache_buffer,\n+                                    name,\n+                                    archived_reloc_data,\n+                                    archived_oop_maps);\n@@ -289,0 +307,1 @@\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -102,0 +102,3 @@\n+class DeoptimizationBlob;\n+class SafepointBlob;\n+class UncommonTrapBlob;\n@@ -208,0 +211,3 @@\n+  ExceptionBlob* as_exception_blob() const    { assert(is_exception_stub(), \"must be exception stub\"); return (ExceptionBlob*) this; }\n+  DeoptimizationBlob* as_deoptimization_blob() const { assert(is_deoptimization_stub(), \"must be deopt stub\"); return (DeoptimizationBlob*) this; }\n+  SafepointBlob* as_safepoint_blob() const    { assert(is_safepoint_stub(), \"must be safepoint stub\"); return (SafepointBlob*) this; }\n@@ -210,0 +216,1 @@\n+  UncommonTrapBlob* as_uncommon_trap_blob() const { assert(is_uncommon_trap_stub(), \"must be uncommon trap stub\"); return (UncommonTrapBlob*) this; }\n@@ -243,1 +250,1 @@\n-  int relocation_size() const    { return pointer_delta_as_int((address) relocation_end(), (address) relocation_begin()); }\n+  int relocation_size() const    { return _relocation_size; }\n@@ -311,1 +318,4 @@\n-  static CodeBlob* create(CodeBlob* archived_blob, const char* name, address archived_reloc_data, ImmutableOopMapSet* archived_oop_maps);\n+  static CodeBlob* create(CodeBlob* archived_blob,\n+                          const char* name,\n+                          address archived_reloc_data,\n+                          ImmutableOopMapSet* archived_oop_maps);\n@@ -450,0 +460,1 @@\n+  static const int ENTRY_COUNT = 1;\n@@ -552,0 +563,1 @@\n+  static const int ENTRY_COUNT = 4 JVMTI_ONLY(+ 2);\n@@ -682,0 +694,1 @@\n+  static const int ENTRY_COUNT = 1;\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"code\/relocInfo.hpp\"\n@@ -396,1 +395,3 @@\n-    return (pc-1)->pc_offset() < pc_offset && pc_offset <= pc->pc_offset();\n+    \/\/ Do not look before the sentinel\n+    assert(pc_offset > PcDesc::lower_offset_limit, \"illegal pc_offset\");\n+    return pc_offset <= pc->pc_offset() && (pc-1)->pc_offset() < pc_offset;\n@@ -693,7 +694,0 @@\n-  if (!is_in_use()) {\n-    low_boundary += NativeJump::instruction_size;\n-    \/\/ %%% Note:  On SPARC we patch only a 4-byte trap, not a full NativeJump.\n-    \/\/ This means that the low_boundary is going to be a little too high.\n-    \/\/ This shouldn't matter, since oops of non-entrant methods are never used.\n-    \/\/ In fact, why are we bothering to look at oops in a non-entrant method??\n-  }\n@@ -789,0 +783,2 @@\n+    } else if (md->is_methodCounters()) {\n+      klass = ((MethodCounters*)md)->method()->method_holder();\n@@ -1652,4 +1648,0 @@\n-  \/\/ Enter a critical section to prevent a race with deopts that patch code and updates the relocation info.\n-  \/\/ Unfortunately, we have to lock the NMethodState_lock before the tty lock due to the deadlock rules and\n-  \/\/ cannot lock in a more finely grained manner.\n-  ConditionalMutexLocker ml(NMethodState_lock, !NMethodState_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n@@ -1946,0 +1938,5 @@\n+#if INCLUDE_JVMCI\n+  if (jvmci_skip_profile_deopt()) {\n+    return;\n+  }\n+#endif\n@@ -1974,3 +1971,1 @@\n-void nmethod::log_state_change(const char* reason) const {\n-  assert(reason != nullptr, \"Must provide a reason\");\n-\n+void nmethod::log_state_change(InvalidationReason invalidation_reason) const {\n@@ -1981,1 +1976,1 @@\n-                       os::current_thread_id(), reason);\n+                       os::current_thread_id(), invalidation_reason_to_string(invalidation_reason));\n@@ -1990,1 +1985,1 @@\n-  ss.print(\"made not entrant: %s\", reason);\n+  ss.print(\"made not entrant: %s\", invalidation_reason_to_string(invalidation_reason));\n@@ -2005,3 +2000,1 @@\n-bool nmethod::make_not_entrant(const char* reason) {\n-  assert(reason != nullptr, \"Must provide a reason\");\n-\n+bool nmethod::make_not_entrant(InvalidationReason invalidation_reason) {\n@@ -2043,13 +2036,1 @@\n-      NativeJump::patch_verified_entry(entry_point(), verified_entry_point(),\n-                                       SharedRuntime::get_handle_wrong_method_stub());\n-\n-      \/\/ Update the relocation info for the patched entry.\n-      \/\/ First, get the old relocation info...\n-      RelocIterator iter(this, verified_entry_point(), verified_entry_point() + 8);\n-      if (iter.next() && iter.addr() == verified_entry_point()) {\n-        Relocation* old_reloc = iter.reloc();\n-        \/\/ ...then reset the iterator to update it.\n-        RelocIterator iter(this, verified_entry_point(), verified_entry_point() + 8);\n-        relocInfo::change_reloc_info_for_address(&iter, verified_entry_point(), old_reloc->type(),\n-                                                 relocInfo::relocType::runtime_call_type);\n-      }\n+      BarrierSet::barrier_set()->barrier_set_nmethod()->make_not_entrant(this);\n@@ -2076,1 +2057,1 @@\n-    log_state_change(reason);\n+    log_state_change(invalidation_reason);\n@@ -2087,1 +2068,1 @@\n-    nmethod_data->invalidate_nmethod_mirror(this);\n+    nmethod_data->invalidate_nmethod_mirror(this, invalidation_reason);\n@@ -2125,1 +2106,3 @@\n-    nmethod_data->invalidate_nmethod_mirror(this);\n+    nmethod_data->invalidate_nmethod_mirror(this, is_cold() ?\n+            nmethod::InvalidationReason::UNLOADING_COLD :\n+            nmethod::InvalidationReason::UNLOADING);\n@@ -2144,4 +2127,13 @@\n-  log_debug(codecache)(\"*flushing %s nmethod %3d\/\" INTPTR_FORMAT \". Live blobs:\" UINT32_FORMAT\n-                       \"\/Free CodeCache:%zuKb\",\n-                       is_osr_method() ? \"osr\" : \"\",_compile_id, p2i(this), CodeCache::blob_count(),\n-                       CodeCache::unallocated_capacity(CodeCache::get_code_blob_type(this))\/1024);\n+\n+  LogTarget(Debug, codecache) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    const char* method_name = method()->name()->as_C_string();\n+    const size_t codecache_capacity = CodeCache::capacity()\/1024;\n+    const size_t codecache_free_space = CodeCache::unallocated_capacity(CodeCache::get_code_blob_type(this))\/1024;\n+    ls.print(\"Flushing nmethod %6d\/\" INTPTR_FORMAT \", level=%d, osr=%d, cold=%d, epoch=\" UINT64_FORMAT \", cold_count=\" UINT64_FORMAT \". \"\n+              \"Cache capacity: %zuKb, free space: %zuKb. method %s (%s)\",\n+              _compile_id, p2i(this), _comp_level, is_osr_method(), is_cold(), _gc_epoch, CodeCache::cold_gc_count(),\n+              codecache_capacity, codecache_free_space, method_name, compiler_name());\n+  }\n@@ -2172,0 +2164,1 @@\n+  JVMCI_ONLY( _metadata_size = 0; )\n@@ -2936,3 +2929,0 @@\n-  \/\/ Make sure all the entry points are correctly aligned for patching.\n-  NativeJump::check_verified_entry_alignment(entry_point(), verified_entry_point());\n-\n@@ -3482,0 +3472,3 @@\n+    st->bol();\n+    st->cr();\n+    st->print_cr(\"Loading hsdis library failed, undisassembled code is shown in MachCode section\");\n@@ -3516,0 +3509,3 @@\n+    st->bol();\n+    st->cr();\n+    st->print_cr(\"Loading hsdis library failed, undisassembled code is shown in MachCode section\");\n@@ -4069,0 +4065,4 @@\n+\n+bool nmethod::jvmci_skip_profile_deopt() const {\n+  return jvmci_nmethod_data() != nullptr && !jvmci_nmethod_data()->profile_deopt();\n+}\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":44,"deletions":44,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -474,0 +474,76 @@\n+  \/\/ If you change anything in this enum please patch\n+  \/\/ vmStructs_jvmci.cpp accordingly.\n+  enum class InvalidationReason : s1 {\n+    NOT_INVALIDATED = -1,\n+    C1_CODEPATCH,\n+    C1_DEOPTIMIZE,\n+    C1_DEOPTIMIZE_FOR_PATCHING,\n+    C1_PREDICATE_FAILED_TRAP,\n+    CI_REPLAY,\n+    UNLOADING,\n+    UNLOADING_COLD,\n+    JVMCI_INVALIDATE,\n+    JVMCI_MATERIALIZE_VIRTUAL_OBJECT,\n+    JVMCI_REPLACED_WITH_NEW_CODE,\n+    JVMCI_REPROFILE,\n+    MARKED_FOR_DEOPTIMIZATION,\n+    MISSING_EXCEPTION_HANDLER,\n+    NOT_USED,\n+    OSR_INVALIDATION_BACK_BRANCH,\n+    OSR_INVALIDATION_FOR_COMPILING_WITH_C1,\n+    OSR_INVALIDATION_OF_LOWER_LEVEL,\n+    SET_NATIVE_FUNCTION,\n+    UNCOMMON_TRAP,\n+    WHITEBOX_DEOPTIMIZATION,\n+    ZOMBIE,\n+    INVALIDATION_REASONS_COUNT\n+  };\n+\n+\n+  static const char* invalidation_reason_to_string(InvalidationReason invalidation_reason) {\n+    switch (invalidation_reason) {\n+      case InvalidationReason::C1_CODEPATCH:\n+        return \"C1 code patch\";\n+      case InvalidationReason::C1_DEOPTIMIZE:\n+        return \"C1 deoptimized\";\n+      case InvalidationReason::C1_DEOPTIMIZE_FOR_PATCHING:\n+        return \"C1 deoptimize for patching\";\n+      case InvalidationReason::C1_PREDICATE_FAILED_TRAP:\n+        return \"C1 predicate failed trap\";\n+      case InvalidationReason::CI_REPLAY:\n+        return \"CI replay\";\n+      case InvalidationReason::JVMCI_INVALIDATE:\n+        return \"JVMCI invalidate\";\n+      case InvalidationReason::JVMCI_MATERIALIZE_VIRTUAL_OBJECT:\n+        return \"JVMCI materialize virtual object\";\n+      case InvalidationReason::JVMCI_REPLACED_WITH_NEW_CODE:\n+        return \"JVMCI replaced with new code\";\n+      case InvalidationReason::JVMCI_REPROFILE:\n+        return \"JVMCI reprofile\";\n+      case InvalidationReason::MARKED_FOR_DEOPTIMIZATION:\n+        return \"marked for deoptimization\";\n+      case InvalidationReason::MISSING_EXCEPTION_HANDLER:\n+        return \"missing exception handler\";\n+      case InvalidationReason::NOT_USED:\n+        return \"not used\";\n+      case InvalidationReason::OSR_INVALIDATION_BACK_BRANCH:\n+        return \"OSR invalidation back branch\";\n+      case InvalidationReason::OSR_INVALIDATION_FOR_COMPILING_WITH_C1:\n+        return \"OSR invalidation for compiling with C1\";\n+      case InvalidationReason::OSR_INVALIDATION_OF_LOWER_LEVEL:\n+        return \"OSR invalidation of lower level\";\n+      case InvalidationReason::SET_NATIVE_FUNCTION:\n+        return \"set native function\";\n+      case InvalidationReason::UNCOMMON_TRAP:\n+        return \"uncommon trap\";\n+      case InvalidationReason::WHITEBOX_DEOPTIMIZATION:\n+        return \"whitebox deoptimization\";\n+      case InvalidationReason::ZOMBIE:\n+        return \"zombie\";\n+      default: {\n+        assert(false, \"Unhandled reason\");\n+        return \"Unknown\";\n+      }\n+    }\n+  }\n+\n@@ -636,2 +712,2 @@\n-  bool  make_not_entrant(const char* reason);\n-  bool  make_not_used()    { return make_not_entrant(\"not used\"); }\n+  bool  make_not_entrant(InvalidationReason invalidation_reason);\n+  bool  make_not_used() { return make_not_entrant(InvalidationReason::NOT_USED); }\n@@ -840,0 +916,4 @@\n+\n+  \/\/ Returns true if the runtime should NOT collect deoptimization profile for a JVMCI\n+  \/\/ compiled method\n+  bool jvmci_skip_profile_deopt() const;\n@@ -950,1 +1030,1 @@\n-  void log_state_change(const char* reason) const;\n+  void log_state_change(InvalidationReason invalidation_reason) const;\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":83,"deletions":3,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -233,1 +234,1 @@\n-      MutexLocker notifier(thread, task->lock());\n+      MutexLocker notifier(thread, CompileTaskWait_lock);\n@@ -238,1 +239,1 @@\n-          \/\/ The waiting thread timed out and thus did not free the task.\n+          \/\/ The waiting thread timed out and thus did not delete the task.\n@@ -247,1 +248,1 @@\n-        task->lock()->notify_all();\n+        CompileTaskWait_lock->notify_all();\n@@ -251,2 +252,2 @@\n-      \/\/ The task can only be freed once the task lock is released.\n-      CompileTask::free(task);\n+      \/\/ The task can only be deleted once the task lock is released.\n+      delete task;\n@@ -257,3 +258,3 @@\n-    \/\/ By convention, the compiling thread is responsible for\n-    \/\/ recycling a non-blocking CompileTask.\n-    CompileTask::free(task);\n+    \/\/ By convention, the compiling thread is responsible for deleting\n+    \/\/ a non-blocking CompileTask.\n+    delete task;\n@@ -350,0 +351,7 @@\n+  if (TrainingData::need_data() && !CDSConfig::is_dumping_final_static_archive()) {\n+    CompileTrainingData* ctd = CompileTrainingData::make(task);\n+    if (ctd != nullptr) {\n+      task->set_training_data(ctd);\n+    }\n+  }\n+\n@@ -355,3 +363,3 @@\n- * Empties compilation queue by putting all compilation tasks onto\n- * a freelist. Furthermore, the method wakes up all threads that are\n- * waiting on a compilation task to finish. This can happen if background\n+ * Empties compilation queue by deleting all compilation tasks.\n+ * Furthermore, the method wakes up all threads that are waiting\n+ * on a compilation task to finish. This can happen if background\n@@ -360,1 +368,1 @@\n-void CompileQueue::free_all() {\n+void CompileQueue::delete_all() {\n@@ -370,1 +378,1 @@\n-      MutexLocker ct_lock(current->lock());\n+      MutexLocker ct_lock(CompileTaskWait_lock);\n@@ -375,1 +383,1 @@\n-        current->lock()->notify();\n+        CompileTaskWait_lock->notify_all();\n@@ -380,5 +388,4 @@\n-      \/\/ If no one was waiting for this task, we need to free it ourselves. In this case, the task\n-      \/\/ is also certainly unlocked, because, again, there is no waiter.\n-      \/\/ Otherwise, by convention, it's the waiters responsibility to free the task.\n-      \/\/ Put the task back on the freelist.\n-      CompileTask::free(current);\n+      \/\/ If no one was waiting for this task, we need to delete it ourselves.\n+      \/\/ In this case, the task is also certainly unlocked, because, again, there is no waiter.\n+      \/\/ Otherwise, by convention, it's the waiters responsibility to delete the task.\n+      delete current;\n@@ -444,1 +451,1 @@\n-    task = CompilationPolicy::select_task(this);\n+    task = CompilationPolicy::select_task(this, thread);\n@@ -784,0 +791,4 @@\n+void TrainingReplayThread::training_replay_thread_entry(JavaThread* thread, TRAPS) {\n+  CompilationPolicy::replay_training_at_init_loop(thread);\n+}\n+\n@@ -861,0 +872,3 @@\n+    case training_replay_t:\n+      new_thread = new TrainingReplayThread();\n+      break;\n@@ -1018,0 +1032,10 @@\n+void CompileBroker::init_training_replay() {\n+  \/\/ Ensure any exceptions lead to vm_exit_during_initialization.\n+  EXCEPTION_MARK;\n+  if (TrainingData::have_data()) {\n+    Handle thread_oop = JavaThread::create_system_thread_object(\"Training replay thread\", CHECK);\n+    jobject thread_handle = JNIHandles::make_local(THREAD, thread_oop());\n+    make_thread(training_replay_t, thread_handle, nullptr, nullptr, THREAD);\n+  }\n+}\n+\n@@ -1605,4 +1629,2 @@\n-  CompileTask* new_task = CompileTask::allocate();\n-  new_task->initialize(compile_id, method, osr_bci, comp_level,\n-                       hot_count, compile_reason,\n-                       blocking);\n+  CompileTask* new_task = new CompileTask(compile_id, method, osr_bci, comp_level,\n+                                          hot_count, compile_reason, blocking);\n@@ -1629,1 +1651,1 @@\n- * @return true if this thread needs to free\/recycle the task\n+ * @return true if this thread needs to delete the task\n@@ -1633,1 +1655,1 @@\n-  MonitorLocker ml(thread, task->lock());\n+  MonitorLocker ml(thread, CompileTaskWait_lock);\n@@ -1701,1 +1723,1 @@\n-    MonitorLocker ml(thread, task->lock());\n+    MonitorLocker ml(thread, CompileTaskWait_lock);\n@@ -1712,1 +1734,1 @@\n-      CompileTask::free(task);\n+      delete task;\n@@ -1717,1 +1739,1 @@\n-    \/\/ completion is a stable property (until the task object is recycled).\n+    \/\/ completion is a stable property (until the task object is deleted).\n@@ -1720,1 +1742,1 @@\n-    \/\/ By convention, the waiter is responsible for recycling a\n+    \/\/ By convention, the waiter is responsible for deleting a\n@@ -1723,2 +1745,2 @@\n-    \/\/ be using this CompileTask; we can free it.\n-    CompileTask::free(task);\n+    \/\/ be using this CompileTask; we can delete it.\n+    delete task;\n@@ -1728,0 +1750,4 @@\n+void CompileBroker::wait_for_no_active_tasks() {\n+  CompileTask::wait_for_no_active_tasks();\n+}\n+\n@@ -1801,1 +1827,1 @@\n-      _c1_compile_queue->free_all();\n+      _c1_compile_queue->delete_all();\n@@ -1805,1 +1831,1 @@\n-      _c2_compile_queue->free_all();\n+      _c2_compile_queue->delete_all();\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":60,"deletions":34,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  void free_all();\n+  void delete_all();\n@@ -257,1 +257,2 @@\n-    deoptimizer_t\n+    deoptimizer_t,\n+    training_replay_t\n@@ -262,0 +263,1 @@\n+  static void init_training_replay();\n@@ -384,0 +386,3 @@\n+\n+  static void wait_for_no_active_tasks();\n+\n@@ -450,0 +455,12 @@\n+\/\/ In order to achiveve a maximally fast warmup we attempt to compile important methods as soon as all\n+\/\/ the classes that they depend on are initialized. TrainingReplayThread processes a queue of InstanceKlass*\n+\/\/ that have just finished running their static initializers. We find all the methods that depend on the given class\n+\/\/ and for which the number of remaining dependencies is now zero, and eagerly compile them.\n+class TrainingReplayThread : public JavaThread {\n+  static void training_replay_thread_entry(JavaThread* thread, TRAPS);\n+public:\n+  TrainingReplayThread() : JavaThread(&training_replay_thread_entry) { }\n+\n+  bool is_hidden_from_external_view() const      { return true; }\n+};\n+\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -34,1 +35,1 @@\n-CompileLog* CompileLog::_first = nullptr;\n+CompileLog* volatile CompileLog::_list_head = nullptr;\n@@ -52,3 +53,6 @@\n-  { MutexLocker locker(CompileTaskAlloc_lock);\n-    _next = _first;\n-    _first = this;\n+  while (true) {\n+    CompileLog* head = Atomic::load_acquire(&_list_head);\n+    _next = head;\n+    if (Atomic::cmpxchg(&_list_head, head, this) == head) {\n+      break;\n+    }\n@@ -205,1 +209,1 @@\n-  CompileLog* log = _first;\n+  CompileLog* log = Atomic::load_acquire(&_list_head);\n@@ -293,1 +297,1 @@\n-  _first = nullptr;\n+  Atomic::store(&_list_head, (CompileLog*)nullptr);\n","filename":"src\/hotspot\/share\/compiler\/compileLog.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  static CompileLog* _first;     \/\/ head of static chain\n+  static CompileLog* volatile _list_head; \/\/ head of static chain\n","filename":"src\/hotspot\/share\/compiler\/compileLog.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,55 +39,1 @@\n-CompileTask*  CompileTask::_task_free_list = nullptr;\n-\n-\/**\n- * Allocate a CompileTask, from the free list if possible.\n- *\/\n-CompileTask* CompileTask::allocate() {\n-  MutexLocker locker(CompileTaskAlloc_lock);\n-  CompileTask* task = nullptr;\n-\n-  if (_task_free_list != nullptr) {\n-    task = _task_free_list;\n-    _task_free_list = task->next();\n-    task->set_next(nullptr);\n-  } else {\n-    task = new CompileTask();\n-    task->set_next(nullptr);\n-    task->set_is_free(true);\n-  }\n-  assert(task->is_free(), \"Task must be free.\");\n-  task->set_is_free(false);\n-  return task;\n-}\n-\n-\/**\n-* Add a task to the free list.\n-*\/\n-void CompileTask::free(CompileTask* task) {\n-  MutexLocker locker(CompileTaskAlloc_lock);\n-  if (!task->is_free()) {\n-    assert(!task->lock()->is_locked(), \"Should not be locked when freed\");\n-    if ((task->_method_holder != nullptr && JNIHandles::is_weak_global_handle(task->_method_holder))) {\n-      JNIHandles::destroy_weak_global(task->_method_holder);\n-    } else {\n-      JNIHandles::destroy_global(task->_method_holder);\n-    }\n-    if (task->_failure_reason_on_C_heap && task->_failure_reason != nullptr) {\n-      os::free((void*) task->_failure_reason);\n-    }\n-    task->_failure_reason = nullptr;\n-    task->_failure_reason_on_C_heap = false;\n-\n-    task->set_is_free(true);\n-    task->set_next(_task_free_list);\n-    _task_free_list = task;\n-  }\n-}\n-\n-void CompileTask::initialize(int compile_id,\n-                             const methodHandle& method,\n-                             int osr_bci,\n-                             int comp_level,\n-                             int hot_count,\n-                             CompileTask::CompileReason compile_reason,\n-                             bool is_blocking) {\n-  assert(!_lock->is_locked(), \"bad locking\");\n+int CompileTask::_active_tasks = 0;\n@@ -95,0 +41,7 @@\n+CompileTask::CompileTask(int compile_id,\n+                         const methodHandle& method,\n+                         int osr_bci,\n+                         int comp_level,\n+                         int hot_count,\n+                         CompileReason compile_reason,\n+                         bool is_blocking) {\n@@ -122,0 +75,1 @@\n+  _training_data = nullptr;\n@@ -125,0 +79,27 @@\n+\n+  Atomic::add(&_active_tasks, 1, memory_order_relaxed);\n+}\n+\n+CompileTask::~CompileTask() {\n+  if (_method_holder != nullptr && JNIHandles::is_weak_global_handle(_method_holder)) {\n+    JNIHandles::destroy_weak_global(_method_holder);\n+  } else {\n+    JNIHandles::destroy_global(_method_holder);\n+  }\n+  if (_failure_reason_on_C_heap && _failure_reason != nullptr) {\n+    os::free((void*) _failure_reason);\n+    _failure_reason = nullptr;\n+    _failure_reason_on_C_heap = false;\n+  }\n+\n+  if (Atomic::sub(&_active_tasks, 1, memory_order_relaxed) == 0) {\n+    MonitorLocker wait_ml(CompileTaskWait_lock);\n+    wait_ml.notify_all();\n+  }\n+}\n+\n+void CompileTask::wait_for_no_active_tasks() {\n+  MonitorLocker locker(CompileTaskWait_lock);\n+  while (Atomic::load(&_active_tasks) > 0) {\n+    locker.wait();\n+  }\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":36,"deletions":55,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -34,0 +35,1 @@\n+class CompileTrainingData;\n@@ -83,2 +85,1 @@\n-  static CompileTask*  _task_free_list;\n-  Monitor*             _lock;\n+  static int           _active_tasks;\n@@ -105,1 +106,0 @@\n-  bool                 _is_free;\n@@ -114,0 +114,1 @@\n+  CompileTrainingData* _training_data;\n@@ -117,11 +118,4 @@\n-  CompileTask() : _failure_reason(nullptr), _failure_reason_on_C_heap(false) {\n-    \/\/ May hold MethodCompileQueue_lock\n-    _lock = new Monitor(Mutex::safepoint-1, \"CompileTask_lock\");\n-  }\n-\n-  void initialize(int compile_id, const methodHandle& method, int osr_bci, int comp_level,\n-                  int hot_count,\n-                  CompileTask::CompileReason compile_reason, bool is_blocking);\n-\n-  static CompileTask* allocate();\n-  static void         free(CompileTask* task);\n+  CompileTask(int compile_id, const methodHandle& method, int osr_bci, int comp_level,\n+              int hot_count, CompileReason compile_reason, bool is_blocking);\n+  ~CompileTask();\n+  static void wait_for_no_active_tasks();\n@@ -173,2 +167,0 @@\n-  Monitor*     lock() const                      { return _lock; }\n-\n@@ -177,1 +169,1 @@\n-    assert(_lock->owned_by_self(), \"must have lock to use waiting_for_completion_count()\");\n+    assert(CompileTaskWait_lock->owned_by_self(), \"must have lock to use waiting_for_completion_count()\");\n@@ -182,1 +174,1 @@\n-    assert(_lock->owned_by_self(), \"must have lock to use inc_waiting_for_completion()\");\n+    assert(CompileTaskWait_lock->owned_by_self(), \"must have lock to use inc_waiting_for_completion()\");\n@@ -187,1 +179,1 @@\n-    assert(_lock->owned_by_self(), \"must have lock to use dec_waiting_for_completion()\");\n+    assert(CompileTaskWait_lock->owned_by_self(), \"must have lock to use dec_waiting_for_completion()\");\n@@ -211,2 +203,0 @@\n-  bool         is_free() const                   { return _is_free; }\n-  void         set_is_free(bool val)             { _is_free = val; }\n@@ -215,0 +205,3 @@\n+  CompileTrainingData* training_data() const      { return _training_data; }\n+  void set_training_data(CompileTrainingData* td) { _training_data = td;   }\n+\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":15,"deletions":22,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -52,0 +52,3 @@\n+  void print_tracing_info() const override;\n+  void stop() override {};\n+\n@@ -83,5 +86,0 @@\n-  bool is_maximal_no_gc() const override {\n-    \/\/ No GC is going to happen. Return \"we are at max\", when we are about to fail.\n-    return used() == capacity();\n-  }\n-\n@@ -136,1 +134,0 @@\n-  void print_tracing_info() const override;\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-  _pre_barrier_c1_runtime_code_blob = Runtime1::generate_blob(buffer_blob, C1StubId::NO_STUBID, \"g1_pre_barrier_slow\",\n+  _pre_barrier_c1_runtime_code_blob = Runtime1::generate_blob(buffer_blob, StubId::NO_STUBID, \"g1_pre_barrier_slow\",\n@@ -223,1 +223,1 @@\n-  _post_barrier_c1_runtime_code_blob = Runtime1::generate_blob(buffer_blob, C1StubId::NO_STUBID, \"g1_post_barrier_slow\",\n+  _post_barrier_c1_runtime_code_blob = Runtime1::generate_blob(buffer_blob, StubId::NO_STUBID, \"g1_post_barrier_slow\",\n","filename":"src\/hotspot\/share\/gc\/g1\/c1\/g1BarrierSetC1.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-  uint number_of_recorded_pause_times() const {\n+  static constexpr uint max_num_of_recorded_pause_times() {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -198,2 +198,2 @@\n-    \/\/ We set it here to ~8%.\n-    FLAG_SET_DEFAULT(GCTimeRatio, 12);\n+    \/\/ We set it here to 4%.\n+    FLAG_SET_DEFAULT(GCTimeRatio, 24);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-#include \"gc\/shared\/fullGCForwarding.hpp\"\n+#include \"gc\/shared\/fullGCForwarding.inline.hpp\"\n@@ -350,0 +350,4 @@\n+  if (obj_regions > num_available_regions()) {\n+    \/\/ Can't satisfy this allocation; early-return.\n+    return nullptr;\n+  }\n@@ -362,1 +366,1 @@\n-      policy()->record_new_heap_size(num_regions());\n+      policy()->record_new_heap_size(num_committed_regions());\n@@ -498,1 +502,1 @@\n-                       \" bytes, heap = %zu bytes\", word_size, reserved.word_size());\n+                       \" bytes, heap = %zu bytes\", word_size * HeapWordSize, reserved.byte_size());\n@@ -789,1 +793,1 @@\n-void G1CollectedHeap::prepare_for_mutator_after_full_collection() {\n+void G1CollectedHeap::prepare_for_mutator_after_full_collection(size_t allocation_word_size) {\n@@ -794,2 +798,1 @@\n-  resize_heap_if_necessary();\n-  uncommit_regions_if_necessary();\n+  resize_heap_after_full_collection(allocation_word_size);\n@@ -843,2 +846,3 @@\n-bool G1CollectedHeap::do_full_collection(bool clear_all_soft_refs,\n-                                         bool do_maximal_compaction) {\n+void G1CollectedHeap::do_full_collection(bool clear_all_soft_refs,\n+                                         bool do_maximal_compaction,\n+                                         size_t allocation_word_size) {\n@@ -856,4 +860,1 @@\n-  collector.complete_collection();\n-\n-  \/\/ Full collection was successfully completed.\n-  return true;\n+  collector.complete_collection(allocation_word_size);\n@@ -868,1 +869,2 @@\n-                     false \/* do_maximal_compaction *\/);\n+                     false \/* do_maximal_compaction *\/,\n+                     size_t(0) \/* allocation_word_size *\/);\n@@ -871,1 +873,1 @@\n-bool G1CollectedHeap::upgrade_to_full_collection() {\n+void G1CollectedHeap::upgrade_to_full_collection() {\n@@ -874,6 +876,13 @@\n-  bool success = do_full_collection(true  \/* clear_all_soft_refs *\/,\n-                                    false \/* do_maximal_compaction *\/);\n-  \/\/ do_full_collection only fails if blocked by GC locker and that can't\n-  \/\/ be the case here since we only call this when already completed one gc.\n-  assert(success, \"invariant\");\n-  return success;\n+  do_full_collection(true  \/* clear_all_soft_refs *\/,\n+                     false \/* do_maximal_compaction *\/,\n+                     size_t(0) \/* allocation_word_size *\/);\n+}\n+\n+\n+void G1CollectedHeap::resize_heap(size_t resize_bytes, bool should_expand) {\n+  if (should_expand) {\n+    expand(resize_bytes, _workers);\n+  } else {\n+    shrink(resize_bytes);\n+    uncommit_regions_if_necessary();\n+  }\n@@ -882,1 +891,1 @@\n-void G1CollectedHeap::resize_heap_if_necessary() {\n+void G1CollectedHeap::resize_heap_after_full_collection(size_t allocation_word_size) {\n@@ -886,1 +895,1 @@\n-  size_t resize_amount = _heap_sizing_policy->full_collection_resize_amount(should_expand);\n+  size_t resize_bytes = _heap_sizing_policy->full_collection_resize_amount(should_expand, allocation_word_size);\n@@ -888,6 +897,14 @@\n-  if (resize_amount == 0) {\n-    return;\n-  } else if (should_expand) {\n-    expand(resize_amount, _workers);\n-  } else {\n-    shrink(resize_amount);\n+  if (resize_bytes != 0) {\n+    resize_heap(resize_bytes, should_expand);\n+  }\n+}\n+\n+void G1CollectedHeap::resize_heap_after_young_collection(size_t allocation_word_size) {\n+  Ticks start = Ticks::now();\n+\n+  bool should_expand;\n+\n+  size_t resize_bytes = _heap_sizing_policy->young_collection_resize_amount(should_expand, allocation_word_size);\n+\n+  if (resize_bytes != 0) {\n+    resize_heap(resize_bytes, should_expand);\n@@ -895,0 +912,2 @@\n+\n+  phase_times()->record_resize_heap_time((Ticks::now() - start).seconds() * 1000.0);\n@@ -900,3 +919,1 @@\n-                                                            bool expect_null_mutator_alloc_region,\n-                                                            bool* gc_succeeded) {\n-  *gc_succeeded = true;\n+                                                            bool expect_null_mutator_alloc_region) {\n@@ -930,2 +947,3 @@\n-    *gc_succeeded = do_full_collection(maximal_compaction \/* clear_all_soft_refs *\/ ,\n-                                       maximal_compaction \/* do_maximal_compaction *\/);\n+    do_full_collection(maximal_compaction \/* clear_all_soft_refs *\/,\n+                       maximal_compaction \/* do_maximal_compaction *\/,\n+                       word_size \/* allocation_word_size *\/);\n@@ -937,2 +955,1 @@\n-HeapWord* G1CollectedHeap::satisfy_failed_allocation(size_t word_size,\n-                                                     bool* succeeded) {\n+HeapWord* G1CollectedHeap::satisfy_failed_allocation(size_t word_size) {\n@@ -946,2 +963,1 @@\n-                                     false, \/* expect_null_mutator_alloc_region *\/\n-                                     succeeded);\n+                                     false \/* expect_null_mutator_alloc_region *\/);\n@@ -949,1 +965,1 @@\n-  if (result != nullptr || !*succeeded) {\n+  if (result != nullptr) {\n@@ -957,2 +973,1 @@\n-                                            true, \/* expect_null_mutator_alloc_region *\/\n-                                            succeeded);\n+                                            true \/* expect_null_mutator_alloc_region *\/);\n@@ -960,1 +975,1 @@\n-  if (result != nullptr || !*succeeded) {\n+  if (result != nullptr) {\n@@ -968,2 +983,1 @@\n-                                            true,  \/* expect_null_mutator_alloc_region *\/\n-                                            succeeded);\n+                                            true  \/* expect_null_mutator_alloc_region *\/);\n@@ -1009,1 +1023,3 @@\n-bool G1CollectedHeap::expand(size_t expand_bytes, WorkerThreads* pretouch_workers, double* expand_time_ms) {\n+bool G1CollectedHeap::expand(size_t expand_bytes, WorkerThreads* pretouch_workers) {\n+  assert(expand_bytes > 0, \"precondition\");\n+\n@@ -1013,7 +1029,1 @@\n-  log_debug(gc, ergo, heap)(\"Expand the heap. requested expansion amount: %zuB expansion amount: %zuB\",\n-                            expand_bytes, aligned_expand_bytes);\n-\n-  if (is_maximal_no_gc()) {\n-    log_debug(gc, ergo, heap)(\"Did not expand the heap (heap already fully expanded)\");\n-    return false;\n-  }\n+  uint num_regions_to_expand = (uint)(aligned_expand_bytes \/ G1HeapRegion::GrainBytes);\n@@ -1021,3 +1031,2 @@\n-  double expand_heap_start_time_sec = os::elapsedTime();\n-  uint regions_to_expand = (uint)(aligned_expand_bytes \/ G1HeapRegion::GrainBytes);\n-  assert(regions_to_expand > 0, \"Must expand by at least one region\");\n+  log_debug(gc, ergo, heap)(\"Heap resize. Requested expansion amount: %zuB aligned expansion amount: %zuB (%u regions)\",\n+                            expand_bytes, aligned_expand_bytes, num_regions_to_expand);\n@@ -1025,3 +1034,3 @@\n-  uint expanded_by = _hrm.expand_by(regions_to_expand, pretouch_workers);\n-  if (expand_time_ms != nullptr) {\n-    *expand_time_ms = (os::elapsedTime() - expand_heap_start_time_sec) * MILLIUNITS;\n+  if (num_inactive_regions() == 0) {\n+    log_debug(gc, ergo, heap)(\"Heap resize. Did not expand the heap (heap already fully expanded)\");\n+    return false;\n@@ -1030,1 +1039,1 @@\n-  assert(expanded_by > 0, \"must have failed during commit.\");\n+  uint expanded_by = _hrm.expand_by(num_regions_to_expand, pretouch_workers);\n@@ -1034,1 +1043,1 @@\n-  policy()->record_new_heap_size(num_regions());\n+  policy()->record_new_heap_size(num_committed_regions());\n@@ -1043,1 +1052,1 @@\n-    assert(is_maximal_no_gc(), \"Should be no regions left, available: %u\", _hrm.available());\n+    assert(num_inactive_regions() == 0, \"Should be no regions left, available: %u\", num_inactive_regions());\n@@ -1048,1 +1057,1 @@\n-  policy()->record_new_heap_size(num_regions());\n+  policy()->record_new_heap_size(num_committed_regions());\n@@ -1053,2 +1062,5 @@\n-  size_t aligned_shrink_bytes = os::align_down_vm_page_size(shrink_bytes);\n-  aligned_shrink_bytes = align_down(aligned_shrink_bytes, G1HeapRegion::GrainBytes);\n+  assert(shrink_bytes > 0, \"must be\");\n+  assert(is_aligned(shrink_bytes, G1HeapRegion::GrainBytes),\n+         \"Shrink request for %zuB not aligned to heap region size %zuB\",\n+         shrink_bytes, G1HeapRegion::GrainBytes);\n+\n@@ -1060,2 +1072,2 @@\n-  log_debug(gc, ergo, heap)(\"Shrink the heap. requested shrinking amount: %zuB aligned shrinking amount: %zuB actual amount shrunk: %zuB\",\n-                            shrink_bytes, aligned_shrink_bytes, shrunk_bytes);\n+  log_debug(gc, ergo, heap)(\"Heap resize. Requested shrinking amount: %zuB actual shrinking amount: %zuB (%u regions)\",\n+                            shrink_bytes, shrunk_bytes, num_regions_removed);\n@@ -1063,2 +1075,1 @@\n-    log_debug(gc, heap)(\"Uncommittable regions after shrink: %u\", num_regions_removed);\n-    policy()->record_new_heap_size(num_regions());\n+    policy()->record_new_heap_size(num_committed_regions());\n@@ -1066,1 +1077,1 @@\n-    log_debug(gc, ergo, heap)(\"Did not shrink the heap (heap shrinking operation failed)\");\n+    log_debug(gc, ergo, heap)(\"Heap resize. Did not shrink the heap (heap shrinking operation failed)\");\n@@ -1071,0 +1082,19 @@\n+  if (capacity() == min_capacity()) {\n+    log_debug(gc, ergo, heap)(\"Heap resize. Did not shrink the heap (heap already at minimum)\");\n+    return;\n+  }\n+\n+  size_t aligned_shrink_bytes = os::align_down_vm_page_size(shrink_bytes);\n+  aligned_shrink_bytes = align_down(aligned_shrink_bytes, G1HeapRegion::GrainBytes);\n+\n+  aligned_shrink_bytes = capacity() - MAX2(capacity() - aligned_shrink_bytes, min_capacity());\n+  assert(is_aligned(aligned_shrink_bytes, G1HeapRegion::GrainBytes), \"Bytes to shrink %zuB not aligned\", aligned_shrink_bytes);\n+\n+  log_debug(gc, ergo, heap)(\"Heap resize. Requested shrink amount: %zuB aligned shrink amount: %zuB\",\n+                            shrink_bytes, aligned_shrink_bytes);\n+\n+  if (aligned_shrink_bytes == 0) {\n+    log_debug(gc, ergo, heap)(\"Heap resize. Did not shrink the heap (shrink request too small)\");\n+    return;\n+  }\n+\n@@ -1082,1 +1112,1 @@\n-  shrink_helper(shrink_bytes);\n+  shrink_helper(aligned_shrink_bytes);\n@@ -1282,0 +1312,3 @@\n+  if (!os::is_thread_cpu_time_supported()) {\n+    vm_exit_during_initialization(\"G1 requires cpu time gathering support\");\n+  }\n@@ -1348,1 +1381,1 @@\n-                       MinHeapSize,\n+                       min_capacity(),\n@@ -1376,1 +1409,1 @@\n-  guarantee((max_reserved_regions() - 1) <= max_region_idx, \"too many regions\");\n+  guarantee((max_num_regions() - 1) <= max_region_idx, \"too many regions\");\n@@ -1381,1 +1414,1 @@\n-  G1FromCardCache::initialize(max_reserved_regions());\n+  G1FromCardCache::initialize(max_num_regions());\n@@ -1384,1 +1417,1 @@\n-  _rem_set->initialize(max_reserved_regions());\n+  _rem_set->initialize(max_num_regions());\n@@ -1393,1 +1426,1 @@\n-  G1FreeRegionList::set_unrealistically_long_length(max_regions() + 1);\n+  G1FreeRegionList::set_unrealistically_long_length(max_num_regions() + 1);\n@@ -1461,1 +1494,1 @@\n-  _collection_set.initialize(max_reserved_regions());\n+  _collection_set.initialize(max_num_regions());\n@@ -1560,1 +1593,1 @@\n-  return _hrm.length() * G1HeapRegion::GrainBytes;\n+  return _hrm.num_committed_regions() * G1HeapRegion::GrainBytes;\n@@ -1863,24 +1896,0 @@\n-bool G1CollectedHeap::try_collect_fullgc(GCCause::Cause cause,\n-                                         const G1GCCounters& counters_before) {\n-  assert_heap_not_locked();\n-\n-  while(true) {\n-    VM_G1CollectFull op(counters_before.total_collections(),\n-                        counters_before.total_full_collections(),\n-                        cause);\n-    VMThread::execute(&op);\n-\n-    \/\/ Request is trivially finished.\n-    if (!GCCause::is_explicit_full_gc(cause) || op.gc_succeeded()) {\n-      return op.gc_succeeded();\n-    }\n-\n-    {\n-      MutexLocker ml(Heap_lock);\n-      if (counters_before.total_full_collections() != total_full_collections()) {\n-        return true;\n-      }\n-    }\n-  }\n-}\n-\n@@ -1905,1 +1914,5 @@\n-    return try_collect_fullgc(cause, counters_before);\n+    VM_G1CollectFull op(counters_before.total_collections(),\n+                        counters_before.total_full_collections(),\n+                        cause);\n+    VMThread::execute(&op);\n+    return op.gc_succeeded();\n@@ -2054,1 +2067,1 @@\n-  return (_policy->young_list_target_length() - _survivor.length()) * G1HeapRegion::GrainBytes;\n+  return eden_target_length() * G1HeapRegion::GrainBytes;\n@@ -2072,1 +2085,5 @@\n-  return max_regions() * G1HeapRegion::GrainBytes;\n+  return max_num_regions() * G1HeapRegion::GrainBytes;\n+}\n+\n+size_t G1CollectedHeap::min_capacity() const {\n+  return MinHeapSize;\n@@ -2220,1 +2237,1 @@\n-                       survivor_used_bytes, old_gen_used_bytes, num_regions());\n+                       survivor_used_bytes, old_gen_used_bytes, num_committed_regions());\n@@ -2267,1 +2284,1 @@\n-  update_parallel_gc_threads_cpu_time();\n+  update_perf_counter_cpu_time();\n@@ -2304,2 +2321,2 @@\n-  bool ret_succeeded = op.prologue_succeeded() && op.gc_succeeded();\n-  assert(result == nullptr || ret_succeeded,\n+  *succeeded = op.gc_succeeded();\n+  assert(result == nullptr || *succeeded,\n@@ -2307,1 +2324,0 @@\n-  *succeeded = ret_succeeded;\n@@ -2352,1 +2368,1 @@\n-void G1CollectedHeap::update_parallel_gc_threads_cpu_time() {\n+void G1CollectedHeap::update_perf_counter_cpu_time() {\n@@ -2355,1 +2371,1 @@\n-  if (!UsePerfData || !os::is_thread_cpu_time_supported()) {\n+  if (!UsePerfData) {\n@@ -2421,14 +2437,1 @@\n-void G1CollectedHeap::expand_heap_after_young_collection(){\n-  size_t expand_bytes = _heap_sizing_policy->young_collection_expansion_amount();\n-  if (expand_bytes > 0) {\n-    \/\/ No need for an ergo logging here,\n-    \/\/ expansion_amount() does this when it returns a value > 0.\n-    double expand_ms = 0.0;\n-    if (!expand(expand_bytes, _workers, &expand_ms)) {\n-      \/\/ We failed to expand the heap. Cannot do anything about it.\n-    }\n-    phase_times()->record_expand_heap_time(expand_ms);\n-  }\n-}\n-\n-bool G1CollectedHeap::do_collection_pause_at_safepoint() {\n+void G1CollectedHeap::do_collection_pause_at_safepoint(size_t allocation_word_size) {\n@@ -2438,2 +2441,1 @@\n-  do_collection_pause_at_safepoint_helper();\n-  return true;\n+  do_collection_pause_at_safepoint_helper(allocation_word_size);\n@@ -2447,1 +2449,1 @@\n-  _g1h->print_heap_before_gc();\n+  _g1h->print_before_gc();\n@@ -2461,1 +2463,1 @@\n-  _g1h->print_heap_after_gc();\n+  _g1h->print_after_gc();\n@@ -2503,1 +2505,1 @@\n-void G1CollectedHeap::do_collection_pause_at_safepoint_helper() {\n+void G1CollectedHeap::do_collection_pause_at_safepoint_helper(size_t allocation_word_size) {\n@@ -2521,1 +2523,1 @@\n-  G1YoungCollector collector(gc_cause());\n+  G1YoungCollector collector(gc_cause(), allocation_word_size);\n@@ -2643,0 +2645,7 @@\n+  uint total_allocated = _survivor_evac_stats.regions_filled() + _old_evac_stats.regions_filled();\n+\n+  log_debug(gc)(\"Allocated %u survivor %u old percent total %1.2f%% (%u%%)\",\n+                _survivor_evac_stats.regions_filled(), _old_evac_stats.regions_filled(),\n+                percent_of(total_allocated, num_committed_regions() - total_allocated),\n+                G1ReservePercent);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":139,"deletions":130,"binary":false,"changes":269,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-typedef int RegionIdx_t;   \/\/ needs to hold [ 0..max_reserved_regions() )\n+typedef int RegionIdx_t;   \/\/ needs to hold [ 0..max_num_regions() )\n@@ -265,1 +265,1 @@\n-  void update_parallel_gc_threads_cpu_time();\n+  void update_perf_counter_cpu_time();\n@@ -283,3 +283,0 @@\n-  bool try_collect_fullgc(GCCause::Cause cause,\n-                          const G1GCCounters& counters_before);\n-\n@@ -479,0 +476,2 @@\n+  void resize_heap(size_t resize_bytes, bool should_expand);\n+\n@@ -483,0 +482,2 @@\n+  \/\/ - if allocation_word_size is set, then this allocation size will\n+  \/\/    be accounted for in case shrinking of the heap happens.\n@@ -485,2 +486,3 @@\n-  bool do_full_collection(bool clear_all_soft_refs,\n-                          bool do_maximal_compaction);\n+  void do_full_collection(bool clear_all_soft_refs,\n+                          bool do_maximal_compaction,\n+                          size_t allocation_word_size);\n@@ -492,1 +494,1 @@\n-  bool upgrade_to_full_collection();\n+  void upgrade_to_full_collection();\n@@ -497,2 +499,1 @@\n-  HeapWord* satisfy_failed_allocation(size_t word_size,\n-                                      bool* succeeded);\n+  HeapWord* satisfy_failed_allocation(size_t word_size);\n@@ -504,1 +505,1 @@\n-  void prepare_for_mutator_after_full_collection();\n+  void prepare_for_mutator_after_full_collection(size_t allocation_word_size);\n@@ -513,2 +514,1 @@\n-                                             bool expect_null_mutator_alloc_region,\n-                                             bool* gc_succeeded);\n+                                             bool expect_null_mutator_alloc_region);\n@@ -563,1 +563,2 @@\n-  void resize_heap_if_necessary();\n+  void resize_heap_after_young_collection(size_t allocation_word_size);\n+  void resize_heap_after_full_collection(size_t allocation_word_size);\n@@ -577,1 +578,1 @@\n-  bool expand(size_t expand_bytes, WorkerThreads* pretouch_workers = nullptr, double* expand_time_ms = nullptr);\n+  bool expand(size_t expand_bytes, WorkerThreads* pretouch_workers);\n@@ -745,3 +746,1 @@\n-  \/\/ followed by a by-policy upgrade to a full collection.  Returns\n-  \/\/ false if unable to do the collection due to the GC locker being\n-  \/\/ active, true otherwise.\n+  \/\/ followed by a by-policy upgrade to a full collection.\n@@ -750,1 +749,1 @@\n-  bool do_collection_pause_at_safepoint();\n+  void do_collection_pause_at_safepoint(size_t allocation_word_size = 0);\n@@ -754,1 +753,1 @@\n-  void do_collection_pause_at_safepoint_helper();\n+  void do_collection_pause_at_safepoint_helper(size_t allocation_word_size);\n@@ -771,2 +770,0 @@\n-  void expand_heap_after_young_collection();\n-  \/\/ Update object copying statistics.\n@@ -889,0 +886,4 @@\n+\n+  void print_tracing_info() const override;\n+  void stop() override;\n+\n@@ -898,1 +899,0 @@\n-  void stop() override;\n@@ -973,4 +973,0 @@\n-  bool is_maximal_no_gc() const override {\n-    return _hrm.available() == 0;\n-  }\n-\n@@ -980,1 +976,1 @@\n-    return is_maximal_no_gc() && num_free_regions() == 0;\n+    return num_available_regions() == 0;\n@@ -983,2 +979,2 @@\n-  \/\/ The current number of regions in the heap.\n-  uint num_regions() const { return _hrm.length(); }\n+  \/\/ The number of inactive regions.\n+  uint num_inactive_regions() const { return _hrm.num_inactive_regions(); }\n@@ -986,3 +982,2 @@\n-  \/\/ The max number of regions reserved for the heap. Except for static array\n-  \/\/ sizing purposes you probably want to use max_regions().\n-  uint max_reserved_regions() const { return _hrm.reserved_length(); }\n+  \/\/ The current number of regions in the heap.\n+  uint num_committed_regions() const { return _hrm.num_committed_regions(); }\n@@ -990,2 +985,2 @@\n-  \/\/ Max number of regions that can be committed.\n-  uint max_regions() const { return _hrm.max_length(); }\n+  \/\/ The max number of regions reserved for the heap.\n+  uint max_num_regions() const { return _hrm.max_num_regions(); }\n@@ -996,0 +991,3 @@\n+  \/\/ The number of regions that are not completely free.\n+  uint num_used_regions() const { return _hrm.num_used_regions(); }\n+\n@@ -997,1 +995,1 @@\n-  uint num_free_or_available_regions() const { return num_free_regions() + _hrm.available(); }\n+  uint num_available_regions() const { return num_free_regions() + num_inactive_regions(); }\n@@ -1003,3 +1001,0 @@\n-  \/\/ The number of regions that are not completely free.\n-  uint num_used_regions() const { return num_regions() - num_free_regions(); }\n-\n@@ -1034,0 +1029,2 @@\n+  bool last_gc_was_periodic() { return _gc_lastcause == GCCause::_g1_periodic_collection; }\n+\n@@ -1202,0 +1199,1 @@\n+  size_t min_capacity() const;\n@@ -1216,0 +1214,1 @@\n+  inline uint eden_target_length() const;\n@@ -1321,3 +1320,0 @@\n-  \/\/ Override\n-  void print_tracing_info() const override;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":38,"deletions":42,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -319,0 +319,4 @@\n+inline uint G1CollectedHeap::eden_target_length() const {\n+  return _policy->young_list_target_length() - survivor_regions_count();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -478,1 +479,1 @@\n-  _root_regions(_g1h->max_regions()),\n+  _root_regions(_g1h->max_num_regions()),\n@@ -510,2 +511,0 @@\n-  _accum_task_vtime(nullptr),\n-\n@@ -516,3 +515,3 @@\n-  _region_mark_stats(NEW_C_HEAP_ARRAY(G1RegionMarkStats, _g1h->max_reserved_regions(), mtGC)),\n-  _top_at_mark_starts(NEW_C_HEAP_ARRAY(HeapWord*, _g1h->max_reserved_regions(), mtGC)),\n-  _top_at_rebuild_starts(NEW_C_HEAP_ARRAY(HeapWord*, _g1h->max_reserved_regions(), mtGC)),\n+  _region_mark_stats(NEW_C_HEAP_ARRAY(G1RegionMarkStats, _g1h->max_num_regions(), mtGC)),\n+  _top_at_mark_starts(NEW_C_HEAP_ARRAY(HeapWord*, _g1h->max_num_regions(), mtGC)),\n+  _top_at_rebuild_starts(NEW_C_HEAP_ARRAY(HeapWord*, _g1h->max_num_regions(), mtGC)),\n@@ -545,1 +544,0 @@\n-  _accum_task_vtime = NEW_C_HEAP_ARRAY(double, _max_num_tasks, mtGC);\n@@ -555,2 +553,0 @@\n-\n-    _accum_task_vtime[i] = 0.0;\n@@ -573,2 +569,2 @@\n-  uint max_reserved_regions = _g1h->max_reserved_regions();\n-  for (uint i = 0; i < max_reserved_regions; i++) {\n+  uint max_num_regions = _g1h->max_num_regions();\n+  for (uint i = 0; i < max_num_regions; i++) {\n@@ -616,2 +612,2 @@\n-    uint max_reserved_regions = _g1h->max_reserved_regions();\n-    for (uint i = 0; i < max_reserved_regions; i++) {\n+    uint max_num_regions = _g1h->max_num_regions();\n+    for (uint i = 0; i < max_num_regions; i++) {\n@@ -785,1 +781,1 @@\n-  size_t const num_bytes_to_clear = (G1HeapRegion::GrainBytes * _g1h->num_regions()) \/ G1CMBitMap::heap_map_factor();\n+  size_t const num_bytes_to_clear = (G1HeapRegion::GrainBytes * _g1h->num_committed_regions()) \/ G1CMBitMap::heap_map_factor();\n@@ -983,4 +979,1 @@\n-    double start_vtime = os::elapsedVTime();\n-\n-    {\n-      SuspendibleThreadSetJoiner sts_join;\n+    SuspendibleThreadSetJoiner sts_join;\n@@ -988,1 +981,1 @@\n-      assert(worker_id < _cm->active_tasks(), \"invariant\");\n+    assert(worker_id < _cm->active_tasks(), \"invariant\");\n@@ -990,7 +983,7 @@\n-      G1CMTask* task = _cm->task(worker_id);\n-      task->record_start_time();\n-      if (!_cm->has_aborted()) {\n-        do {\n-          task->do_marking_step(G1ConcMarkStepDurationMillis,\n-                                true  \/* do_termination *\/,\n-                                false \/* is_serial*\/);\n+    G1CMTask* task = _cm->task(worker_id);\n+    task->record_start_time();\n+    if (!_cm->has_aborted()) {\n+      do {\n+        task->do_marking_step(G1ConcMarkStepDurationMillis,\n+                              true  \/* do_termination *\/,\n+                              false \/* is_serial*\/);\n@@ -998,5 +991,2 @@\n-          _cm->do_yield_check();\n-        } while (!_cm->has_aborted() && task->has_aborted());\n-      }\n-      task->record_end_time();\n-      guarantee(!task->has_aborted() || _cm->has_aborted(), \"invariant\");\n+        _cm->do_yield_check();\n+      } while (!_cm->has_aborted() && task->has_aborted());\n@@ -1004,3 +994,2 @@\n-\n-    double end_vtime = os::elapsedVTime();\n-    _cm->update_accum_task_vtime(worker_id, end_vtime - start_vtime);\n+    task->record_end_time();\n+    guarantee(!task->has_aborted() || _cm->has_aborted(), \"invariant\");\n@@ -1437,1 +1426,1 @@\n-      uint const num_workers = MIN2(G1UpdateRegionLivenessAndSelectForRebuildTask::desired_num_workers(_g1h->num_regions()),\n+      uint const num_workers = MIN2(G1UpdateRegionLivenessAndSelectForRebuildTask::desired_num_workers(_g1h->num_committed_regions()),\n@@ -1439,1 +1428,1 @@\n-      log_debug(gc,ergo)(\"Running %s using %u workers for %u regions in heap\", cl.name(), num_workers, _g1h->num_regions());\n+      log_debug(gc,ergo)(\"Running %s using %u workers for %u regions in heap\", cl.name(), num_workers, _g1h->num_committed_regions());\n@@ -1443,1 +1432,1 @@\n-                                        _g1h->num_regions(), cl.total_selected_for_rebuild());\n+                                        _g1h->num_committed_regions(), cl.total_selected_for_rebuild());\n@@ -1450,1 +1439,1 @@\n-        G1CollectionSetChooser::build(_g1h->workers(), _g1h->num_regions(), _g1h->policy()->candidates());\n+        G1CollectionSetChooser::build(_g1h->workers(), _g1h->num_committed_regions(), _g1h->policy()->candidates());\n@@ -1464,2 +1453,7 @@\n-    _g1h->resize_heap_if_necessary();\n-    _g1h->uncommit_regions_if_necessary();\n+    \/\/ For Remark Pauses that may have been triggered by PeriodicGCs, we maintain\n+    \/\/ resizing based on MinHeapFreeRatio or MaxHeapFreeRatio. If a PeriodicGC is\n+    \/\/ triggered, it likely means there are very few regular GCs, making resizing\n+    \/\/ based on gc heuristics less effective.\n+    if (_g1h->last_gc_was_periodic()) {\n+      _g1h->resize_heap_after_full_collection(0 \/* allocation_word_size *\/);\n+    }\n@@ -1499,1 +1493,1 @@\n-  _g1h->update_parallel_gc_threads_cpu_time();\n+  _g1h->update_perf_counter_cpu_time();\n@@ -1707,13 +1701,0 @@\n-    \/\/ We need at least one active thread. If reference processing\n-    \/\/ is not multi-threaded we use the current (VMThread) thread,\n-    \/\/ otherwise we use the workers from the G1CollectedHeap and\n-    \/\/ we utilize all the worker threads we can.\n-    uint active_workers = (ParallelRefProcEnabled ? _g1h->workers()->active_workers() : 1U);\n-    active_workers = clamp(active_workers, 1u, _max_num_tasks);\n-\n-    \/\/ Set the degree of MT processing here.  If the discovery was done MT,\n-    \/\/ the number of threads involved during discovery could differ from\n-    \/\/ the number of active workers.  This is OK as long as the discovered\n-    \/\/ Reference lists are balanced (see balance_all_queues() and balance_queues()).\n-    rp->set_active_mt_degree(active_workers);\n-\n@@ -1725,1 +1706,1 @@\n-    const ReferenceProcessorStats& stats = rp->process_discovered_references(task, pt);\n+    const ReferenceProcessorStats& stats = rp->process_discovered_references(task, _g1h->workers(), pt);\n@@ -1735,2 +1716,0 @@\n-\n-    assert(rp->num_queues() == active_workers, \"why not\");\n@@ -2093,0 +2072,17 @@\n+double G1ConcurrentMark::worker_threads_cpu_time_s() {\n+  class CountCpuTimeThreadClosure : public ThreadClosure {\n+  public:\n+    jlong _total_cpu_time;\n+\n+    CountCpuTimeThreadClosure() : ThreadClosure(), _total_cpu_time(0) { }\n+\n+    void do_thread(Thread* t) {\n+      _total_cpu_time += os::thread_cpu_time(t);\n+    }\n+  } cl;\n+\n+  threads_do(&cl);\n+\n+  return (double)cl._total_cpu_time \/ NANOSECS_PER_SEC;\n+}\n+\n@@ -2122,1 +2118,1 @@\n-            cm_thread()->vtime_accum(), cm_thread()->vtime_mark_accum());\n+            cm_thread()->total_mark_cpu_time_s(), cm_thread()->worker_threads_cpu_time_s());\n@@ -2266,2 +2262,0 @@\n-  double curr_time_ms = os::elapsedVTime() * 1000.0;\n-\n@@ -2277,1 +2271,1 @@\n-  double elapsed_time_ms = curr_time_ms - _start_time_ms;\n+  double elapsed_time_ms = (double)(os::current_thread_cpu_time() - _start_cpu_time_ns) \/ NANOSECS_PER_MILLISEC;\n@@ -2792,3 +2786,3 @@\n-    vtime too regularly, as it is quite expensive. So, once it was in\n-    place, it was natural to piggy-back all the other conditions on it\n-    too and not constantly check them throughout the code.\n+    cpu time gathering too regularly, as it is quite expensive. So,\n+    once it was in place, it was natural to piggy-back all the other\n+    conditions on it too and not constantly check them throughout the code.\n@@ -2817,1 +2811,1 @@\n-  _start_time_ms = os::elapsedVTime() * 1000.0;\n+  _start_cpu_time_ns = os::current_thread_cpu_time();\n@@ -2911,2 +2905,2 @@\n-  double end_time_ms = os::elapsedVTime() * 1000.0;\n-  double elapsed_time_ms = end_time_ms - _start_time_ms;\n+  jlong end_cpu_time_ns = os::current_thread_cpu_time();\n+  double elapsed_time_ms = (double)(end_cpu_time_ns - _start_cpu_time_ns) \/ NANOSECS_PER_MILLISEC;\n@@ -2935,1 +2929,1 @@\n-  _start_time_ms(0.0),\n+  _start_cpu_time_ns(0),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":62,"deletions":68,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  uint max_wasted_regions_allowed = ((heap->num_regions() * G1HeapWastePercent) \/ 100);\n+  uint max_wasted_regions_allowed = ((heap->num_committed_regions() * G1HeapWastePercent) \/ 100);\n@@ -136,3 +136,3 @@\n-  _live_stats = NEW_C_HEAP_ARRAY(G1RegionMarkStats, _heap->max_regions(), mtGC);\n-  _compaction_tops = NEW_C_HEAP_ARRAY(HeapWord*, _heap->max_regions(), mtGC);\n-  for (uint j = 0; j < heap->max_regions(); j++) {\n+  _live_stats = NEW_C_HEAP_ARRAY(G1RegionMarkStats, _heap->max_num_regions(), mtGC);\n+  _compaction_tops = NEW_C_HEAP_ARRAY(HeapWord*, _heap->max_num_regions(), mtGC);\n+  for (uint j = 0; j < heap->max_num_regions(); j++) {\n@@ -235,1 +235,1 @@\n-void G1FullCollector::complete_collection() {\n+void G1FullCollector::complete_collection(size_t allocation_word_size) {\n@@ -249,1 +249,1 @@\n-  _heap->prepare_for_mutator_after_full_collection();\n+  _heap->prepare_for_mutator_after_full_collection(allocation_word_size);\n@@ -306,2 +306,0 @@\n-    uint old_active_mt_degree = reference_processor()->num_queues();\n-    reference_processor()->set_active_mt_degree(workers());\n@@ -312,1 +310,1 @@\n-    const ReferenceProcessorStats& stats = reference_processor()->process_discovered_references(task, pt);\n+    const ReferenceProcessorStats& stats = reference_processor()->process_discovered_references(task, _heap->workers(), pt);\n@@ -316,2 +314,0 @@\n-\n-    reference_processor()->set_active_mt_degree(old_active_mt_degree);\n@@ -422,1 +418,1 @@\n-  assert(start_serial < _heap->max_reserved_regions(), \"Called on empty parallel compaction queues\");\n+  assert(start_serial < _heap->max_num_regions(), \"Called on empty parallel compaction queues\");\n@@ -434,1 +430,1 @@\n-  for (uint i = start_serial + 1; i < _heap->max_reserved_regions(); i++) {\n+  for (uint i = start_serial + 1; i < _heap->max_num_regions(); i++) {\n@@ -452,1 +448,1 @@\n-  uint max_reserved_regions = _heap->max_reserved_regions();\n+  uint max_num_regions = _heap->max_num_regions();\n@@ -456,1 +452,1 @@\n-  while (region_index < max_reserved_regions) {\n+  while (region_index < max_num_regions) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-  _cur_expand_heap_time_ms = 0.0;\n+  _cur_resize_heap_time_ms = 0.0;\n@@ -491,1 +491,1 @@\n-                        _cur_expand_heap_time_ms;\n+                        _cur_resize_heap_time_ms;\n@@ -540,1 +540,1 @@\n-  debug_time(\"Expand Heap After Collection\", _cur_expand_heap_time_ms);\n+  debug_time(\"Resize Heap After Collection\", _cur_resize_heap_time_ms);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-  double _cur_expand_heap_time_ms;\n+  double _cur_resize_heap_time_ms;\n@@ -286,2 +286,2 @@\n-  void record_expand_heap_time(double ms) {\n-    _cur_expand_heap_time_ms = ms;\n+  void record_resize_heap_time(double ms) {\n+    _cur_resize_heap_time_ms = ms;\n@@ -408,2 +408,2 @@\n-  double cur_expand_heap_time_ms() {\n-    return _cur_expand_heap_time_ms;\n+  double cur_resize_heap_time_ms() {\n+    return _cur_resize_heap_time_ms;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n@@ -41,1 +41,6 @@\n-  _num_prev_pauses_for_heuristics(analytics->number_of_recorded_pause_times()) {\n+  \/\/ Bias for expansion at startup; the +1 is to counter the first sample always\n+  \/\/ being 0.0, i.e. lower than any threshold.\n+  _gc_cpu_usage_deviation_counter((G1CPUUsageExpandThreshold \/ 2) + 1),\n+  _recent_cpu_usage_deltas(long_term_count_limit()),\n+  _long_term_count(0) {\n+}\n@@ -43,2 +48,4 @@\n-  assert(MinOverThresholdForGrowth < _num_prev_pauses_for_heuristics, \"Threshold must be less than %u\", _num_prev_pauses_for_heuristics);\n-  clear_ratio_check_data();\n+void G1HeapSizingPolicy::reset_cpu_usage_tracking_data() {\n+  _long_term_count = 0;\n+  _gc_cpu_usage_deviation_counter = 0;\n+  \/\/ Keep the recent GC CPU usage data.\n@@ -47,4 +54,4 @@\n-void G1HeapSizingPolicy::clear_ratio_check_data() {\n-  _ratio_over_threshold_count = 0;\n-  _ratio_over_threshold_sum = 0.0;\n-  _pauses_since_start = 0;\n+void G1HeapSizingPolicy::decay_cpu_usage_tracking_data() {\n+  _long_term_count = 0;\n+  _gc_cpu_usage_deviation_counter \/= 2;\n+  \/\/ Keep the recent GC CPU usage data.\n@@ -53,2 +60,2 @@\n-double G1HeapSizingPolicy::scale_with_heap(double pause_time_threshold) {\n-  double threshold = pause_time_threshold;\n+double G1HeapSizingPolicy::scale_with_heap(double gc_cpu_usage_target) {\n+  double target = gc_cpu_usage_target;\n@@ -59,2 +66,2 @@\n-    threshold *= (double)_g1h->capacity() \/ (double)(_g1h->max_capacity() \/ 2);\n-    threshold = MAX2(threshold, 0.01);\n+    target *= (double)_g1h->capacity() \/ (double)(_g1h->max_capacity() \/ 2);\n+    target = MAX2(target, 0.01);\n@@ -63,1 +70,1 @@\n-  return threshold;\n+  return target;\n@@ -66,17 +73,21 @@\n-static void log_expansion(double short_term_pause_time_ratio,\n-                          double long_term_pause_time_ratio,\n-                          double threshold,\n-                          double pause_time_ratio,\n-                          bool fully_expanded,\n-                          size_t resize_bytes) {\n-\n-  log_debug(gc, ergo, heap)(\"Heap expansion: \"\n-                            \"short term pause time ratio %1.2f%% long term pause time ratio %1.2f%% \"\n-                            \"threshold %1.2f%% pause time ratio %1.2f%% fully expanded %s \"\n-                            \"resize by %zuB\",\n-                            short_term_pause_time_ratio * 100.0,\n-                            long_term_pause_time_ratio * 100.0,\n-                            threshold * 100.0,\n-                            pause_time_ratio * 100.0,\n-                            BOOL_TO_STR(fully_expanded),\n-                            resize_bytes);\n+static void log_resize(double short_term_cpu_usage,\n+                       double long_term_cpu_usage,\n+                       double lower_threshold,\n+                       double upper_threshold,\n+                       double cpu_usage_target,\n+                       bool at_limit,\n+                       size_t resize_bytes,\n+                       bool expand) {\n+\n+  log_debug(gc, ergo, heap)(\"Heap resize: \"\n+                            \"short term GC CPU usage %1.2f%% long term GC CPU usage %1.2f%% \"\n+                            \"lower threshold %1.2f%% upper threshold %1.2f%% GC CPU usage target %1.2f%% \"\n+                            \"at limit %s resize by %zuB expand %s\",\n+                            short_term_cpu_usage * 100.0,\n+                            long_term_cpu_usage * 100.0,\n+                            lower_threshold * 100.0,\n+                            upper_threshold * 100.0,\n+                            cpu_usage_target * 100.0,\n+                            BOOL_TO_STR(at_limit),\n+                            resize_bytes,\n+                            BOOL_TO_STR(expand));\n@@ -85,2 +96,41 @@\n-size_t G1HeapSizingPolicy::young_collection_expansion_amount() {\n-  assert(GCTimeRatio > 0, \"must be\");\n+\/\/ Logistic function, returns values in the range [0,1]\n+static double sigmoid_function(double value) {\n+  \/\/ Sigmoid Parameters:\n+  double inflection_point = 1.0; \/\/ Inflection point (midpoint of the sigmoid).\n+  double steepness = 6.0;\n+  return 1.0 \/ (1.0 + exp(-steepness * (value - inflection_point)));\n+}\n+\n+\/\/ Computes a smooth scaling factor based on the relative deviation of actual gc_cpu_usage\n+\/\/ from the gc_cpu_usage_target, using a sigmoid function to transition between\n+\/\/ the specified minimum and maximum scaling factors.\n+\/\/\n+\/\/ The input cpu_usage_delta represents the relative deviation of the current gc_cpu_usage to the\n+\/\/ gc_cpu_usage_target. This value is passed through a sigmoid function that produces a smooth\n+\/\/ output between 0 and 1, which is then scaled to the range [min_scale_factor, max_scale_factor].\n+\/\/\n+\/\/ The sigmoid's inflection point is set at cpu_usage_delta = 1.0 (a 100% deviation), where the scaling\n+\/\/ response increases most rapidly.\n+\/\/\n+\/\/ The steepness parameter controls how sharply the scale factor changes near the inflection point.\n+\/\/  * Low steepness (1-3): gradual scaling over a wide range of deviations (more conservative).\n+\/\/  * High steepness (7-10): rapid scaling near the inflection point; small deviations result\n+\/\/                           in very low scaling, but larger deviations ramp up scaling quickly.\n+\/\/                           Steepness at 10 is nearly a step function.\n+\/\/\n+\/\/ In this case, we choose a steepness of 6.0:\n+\/\/ - For small deviations, the sigmoid output is close to 0, resulting in scale factors near the\n+\/\/   lower bound, preventing excessive resizing.\n+\/\/ - As cpu_usage_delta grows toward 1.0, the steepness value makes the transition sharper, enabling\n+\/\/   more aggressive scaling for large deviations.\n+\/\/\n+\/\/ This helps avoid overreacting to small gc_cpu_usage deviations but respond appropriately\n+\/\/ when necessary.\n+double G1HeapSizingPolicy::scale_cpu_usage_delta(double cpu_usage_delta,\n+                                                 double min_scale_factor,\n+                                                 double max_scale_factor) const {\n+  double sigmoid = sigmoid_function(cpu_usage_delta);\n+\n+  double scale_factor = min_scale_factor + (max_scale_factor - min_scale_factor) * sigmoid;\n+  return scale_factor;\n+}\n@@ -88,4 +138,4 @@\n-  double long_term_pause_time_ratio = _analytics->long_term_pause_time_ratio();\n-  double short_term_pause_time_ratio = _analytics->short_term_pause_time_ratio();\n-  const double pause_time_threshold = 1.0 \/ (1.0 + GCTimeRatio);\n-  double threshold = scale_with_heap(pause_time_threshold);\n+\/\/ Calculate the relative difference between a and b.\n+static double rel_diff(double a, double b) {\n+  return (a - b) \/ b;\n+}\n@@ -93,1 +143,2 @@\n-  size_t expand_bytes = 0;\n+size_t G1HeapSizingPolicy::young_collection_expand_amount(double cpu_usage_delta) const {\n+  assert(cpu_usage_delta >= 0.0, \"must be\");\n@@ -95,5 +146,45 @@\n-  if (_g1h->capacity() == _g1h->max_capacity()) {\n-    log_expansion(short_term_pause_time_ratio, long_term_pause_time_ratio,\n-                  threshold, pause_time_threshold, true, 0);\n-    clear_ratio_check_data();\n-    return expand_bytes;\n+  size_t reserved_bytes = _g1h->max_capacity();\n+  size_t committed_bytes = _g1h->capacity();\n+  size_t uncommitted_bytes = reserved_bytes - committed_bytes;\n+  size_t expand_bytes_via_pct = uncommitted_bytes * G1ExpandByPercentOfAvailable \/ 100;\n+  size_t min_expand_bytes = MIN2(G1HeapRegion::GrainBytes, uncommitted_bytes);\n+\n+  \/\/ Take the current size or G1ExpandByPercentOfAvailable % of\n+  \/\/ the available expansion space, whichever is smaller, as the base\n+  \/\/ expansion size. Then possibly scale this size according to how much the\n+  \/\/ GC CPU usage (on average) has exceeded the target.\n+  const double min_scale_factor = 0.2;\n+  const double max_scale_factor = 2.0;\n+\n+  double scale_factor = scale_cpu_usage_delta(cpu_usage_delta,\n+                                              min_scale_factor,\n+                                              max_scale_factor);\n+\n+  size_t resize_bytes = MIN2(expand_bytes_via_pct, committed_bytes);\n+\n+  resize_bytes = static_cast<size_t>(resize_bytes * scale_factor);\n+\n+  \/\/ Ensure the expansion size is at least the minimum growth amount\n+  \/\/ and at most the remaining uncommitted byte size.\n+  return clamp(resize_bytes, min_expand_bytes, uncommitted_bytes);\n+}\n+\n+size_t G1HeapSizingPolicy::young_collection_shrink_amount(double cpu_usage_delta, size_t allocation_word_size) const {\n+  assert(cpu_usage_delta >= 0.0, \"must be\");\n+\n+  const double max_scale_factor = G1ShrinkByPercentOfAvailable \/ 100.0;\n+  const double min_scale_factor = max_scale_factor \/ 10.0;\n+\n+  double scale_factor = scale_cpu_usage_delta(cpu_usage_delta,\n+                                              min_scale_factor,\n+                                              max_scale_factor);\n+  assert(scale_factor <= max_scale_factor, \"must be\");\n+\n+  \/\/ We are at the end of GC, so free regions are at maximum. Do not try to shrink\n+  \/\/ to have less than the reserve or the number of regions we are most certainly\n+  \/\/ going to use during this mutator phase.\n+  uint target_regions_to_shrink = _g1h->num_free_regions();\n+\n+  uint needed_for_allocation = _g1h->eden_target_length();\n+  if (_g1h->is_humongous(allocation_word_size)) {\n+    needed_for_allocation += (uint) _g1h->humongous_obj_size_in_regions(allocation_word_size);\n@@ -102,6 +193,4 @@\n-  \/\/ If the last GC time ratio is over the threshold, increment the count of\n-  \/\/ times it has been exceeded, and add this ratio to the sum of exceeded\n-  \/\/ ratios.\n-  if (short_term_pause_time_ratio > threshold) {\n-    _ratio_over_threshold_count++;\n-    _ratio_over_threshold_sum += short_term_pause_time_ratio;\n+  if (target_regions_to_shrink >= needed_for_allocation) {\n+    target_regions_to_shrink -= needed_for_allocation;\n+  } else {\n+    target_regions_to_shrink = 0;\n@@ -110,61 +199,107 @@\n-  log_trace(gc, ergo, heap)(\"Heap expansion triggers: pauses since start: %u \"\n-                            \"num prev pauses for heuristics: %u \"\n-                            \"ratio over threshold count: %u\",\n-                            _pauses_since_start,\n-                            _num_prev_pauses_for_heuristics,\n-                            _ratio_over_threshold_count);\n-\n-  \/\/ Check if we've had enough GC time ratio checks that were over the\n-  \/\/ threshold to trigger an expansion. We'll also expand if we've\n-  \/\/ reached the end of the history buffer and the average of all entries\n-  \/\/ is still over the threshold. This indicates a smaller number of GCs were\n-  \/\/ long enough to make the average exceed the threshold.\n-  bool filled_history_buffer = _pauses_since_start == _num_prev_pauses_for_heuristics;\n-  if ((_ratio_over_threshold_count == MinOverThresholdForGrowth) ||\n-      (filled_history_buffer && (long_term_pause_time_ratio > threshold))) {\n-    size_t min_expand_bytes = G1HeapRegion::GrainBytes;\n-    size_t reserved_bytes = _g1h->max_capacity();\n-    size_t committed_bytes = _g1h->capacity();\n-    size_t uncommitted_bytes = reserved_bytes - committed_bytes;\n-    size_t expand_bytes_via_pct =\n-      uncommitted_bytes * G1ExpandByPercentOfAvailable \/ 100;\n-    double scale_factor = 1.0;\n-\n-    \/\/ If the current size is less than 1\/4 of the Initial heap size, expand\n-    \/\/ by half of the delta between the current and Initial sizes. IE, grow\n-    \/\/ back quickly.\n-    \/\/\n-    \/\/ Otherwise, take the current size, or G1ExpandByPercentOfAvailable % of\n-    \/\/ the available expansion space, whichever is smaller, as the base\n-    \/\/ expansion size. Then possibly scale this size according to how much the\n-    \/\/ threshold has (on average) been exceeded by. If the delta is small\n-    \/\/ (less than the StartScaleDownAt value), scale the size down linearly, but\n-    \/\/ not by less than MinScaleDownFactor. If the delta is large (greater than\n-    \/\/ the StartScaleUpAt value), scale up, but adding no more than MaxScaleUpFactor\n-    \/\/ times the base size. The scaling will be linear in the range from\n-    \/\/ StartScaleUpAt to (StartScaleUpAt + ScaleUpRange). In other words,\n-    \/\/ ScaleUpRange sets the rate of scaling up.\n-    if (committed_bytes < InitialHeapSize \/ 4) {\n-      expand_bytes = (InitialHeapSize - committed_bytes) \/ 2;\n-    } else {\n-      double const MinScaleDownFactor = 0.2;\n-      double const MaxScaleUpFactor = 2;\n-      double const StartScaleDownAt = pause_time_threshold;\n-      double const StartScaleUpAt = pause_time_threshold * 1.5;\n-      double const ScaleUpRange = pause_time_threshold * 2.0;\n-\n-      double ratio_delta;\n-      if (filled_history_buffer) {\n-        ratio_delta = long_term_pause_time_ratio - threshold;\n-      } else {\n-        ratio_delta = (_ratio_over_threshold_sum \/ _ratio_over_threshold_count) - threshold;\n-      }\n-\n-      expand_bytes = MIN2(expand_bytes_via_pct, committed_bytes);\n-      if (ratio_delta < StartScaleDownAt) {\n-        scale_factor = ratio_delta \/ StartScaleDownAt;\n-        scale_factor = MAX2(scale_factor, MinScaleDownFactor);\n-      } else if (ratio_delta > StartScaleUpAt) {\n-        scale_factor = 1 + ((ratio_delta - StartScaleUpAt) \/ ScaleUpRange);\n-        scale_factor = MIN2(scale_factor, MaxScaleUpFactor);\n-      }\n+  size_t resize_bytes = (double)G1HeapRegion::GrainBytes * target_regions_to_shrink * scale_factor;\n+\n+  log_debug(gc, ergo, heap)(\"Shrink log: scale factor %1.2f%% \"\n+                            \"total free regions %u \"\n+                            \"needed for alloc %u \"\n+                            \"base targeted for shrinking %u \"\n+                            \"resize_bytes %zd ( %zu regions)\",\n+                            scale_factor * 100.0,\n+                            _g1h->num_free_regions(),\n+                            needed_for_allocation,\n+                            target_regions_to_shrink,\n+                            resize_bytes,\n+                            (resize_bytes \/ G1HeapRegion::GrainBytes));\n+\n+  return resize_bytes;\n+}\n+\n+size_t G1HeapSizingPolicy::young_collection_resize_amount(bool& expand, size_t allocation_word_size) {\n+  assert(GCTimeRatio > 0, \"must be\");\n+  expand = false;\n+\n+  const double long_term_gc_cpu_usage = _analytics->long_term_pause_time_ratio();\n+  const double short_term_gc_cpu_usage = _analytics->short_term_pause_time_ratio();\n+\n+  double gc_cpu_usage_target = 1.0 \/ (1.0 + GCTimeRatio);\n+  gc_cpu_usage_target = scale_with_heap(gc_cpu_usage_target);\n+\n+  \/\/ Calculate gc_cpu_usage acceptable deviation thresholds:\n+  \/\/ - upper_threshold, do not want to exceed this.\n+  \/\/ - lower_threshold, we do not want to go below.\n+  const double gc_cpu_usage_margin = G1CPUUsageDeviationPercent \/ 100.0;\n+  const double upper_threshold = gc_cpu_usage_target * (1 + gc_cpu_usage_margin);\n+  const double lower_threshold = gc_cpu_usage_target * (1 - gc_cpu_usage_margin);\n+\n+  \/\/ Decide to expand\/shrink based on how far the current GC CPU usage deviates\n+  \/\/ from the target. This allows the policy to respond more quickly to GC pressure\n+  \/\/ when the heap is small relative to the maximum heap.\n+  const double long_term_delta = rel_diff(long_term_gc_cpu_usage, gc_cpu_usage_target);\n+  const double short_term_delta = rel_diff(short_term_gc_cpu_usage, gc_cpu_usage_target);\n+\n+  \/\/ If the short term GC CPU usage exceeds the upper threshold, increment the deviation\n+  \/\/ counter. If it falls below the lower_threshold, decrement the deviation counter.\n+  if (short_term_gc_cpu_usage > upper_threshold) {\n+    _gc_cpu_usage_deviation_counter++;\n+  } else if (short_term_gc_cpu_usage < lower_threshold) {\n+    _gc_cpu_usage_deviation_counter--;\n+  }\n+  \/\/ Ignore very first sample as it is garbage.\n+  if (_long_term_count != 0 || _recent_cpu_usage_deltas.num() != 0) {\n+    _recent_cpu_usage_deltas.add(short_term_delta);\n+  }\n+  _long_term_count++;\n+\n+  log_trace(gc, ergo, heap)(\"Heap resize triggers: long term count: %u \"\n+                            \"long term count limit: %u \"\n+                            \"short term delta: %1.2f \"\n+                            \"recent recorded short term deltas: %u\"\n+                            \"GC CPU usage deviation counter: %d\",\n+                            _long_term_count,\n+                            long_term_count_limit(),\n+                            short_term_delta,\n+                            _recent_cpu_usage_deltas.num(),\n+                            _gc_cpu_usage_deviation_counter);\n+\n+  \/\/ Check if there is a short- or long-term need for resizing, expansion first.\n+  \/\/\n+  \/\/ Short-term resizing need is detected by exceeding the upper or lower thresholds\n+  \/\/ multiple times, tracked in _gc_cpu_usage_deviation_counter. If it contains a large\n+  \/\/ positive or negative (larger than the respective thresholds), we trigger\n+  \/\/ resizing calculation.\n+  \/\/\n+  \/\/ Slowly occurring long-term changes to the actual GC CPU usage are checked\n+  \/\/ only every once in a while.\n+  \/\/\n+  \/\/ The _gc_cpu_usage_deviation_counter value is reset after each resize, or slowly\n+  \/\/ decayed if no resizing happens.\n+\n+  size_t resize_bytes = 0;\n+\n+  const bool use_long_term_delta = (_long_term_count == long_term_count_limit());\n+  const double avg_short_term_delta = _recent_cpu_usage_deltas.avg();\n+\n+  double delta;\n+  if (use_long_term_delta) {\n+    \/\/ For expansion, deltas are positive, and we want to expand aggressively.\n+    \/\/ For shrinking, deltas are negative, so the MAX2 below selects the least\n+    \/\/ aggressive one as we are using the absolute value for scaling.\n+    delta = MAX2(avg_short_term_delta, long_term_delta);\n+  } else {\n+    delta = avg_short_term_delta;\n+  }\n+  \/\/ Delta is negative when shrinking, but the calculation of the resize amount\n+  \/\/ always expects an absolute value. Do that here unconditionally.\n+  delta = fabsd(delta);\n+\n+  int count_threshold_for_shrink = (int)G1CPUUsageShrinkThreshold;\n+\n+  if ((_gc_cpu_usage_deviation_counter >= (int)G1CPUUsageExpandThreshold) ||\n+      (use_long_term_delta && (long_term_gc_cpu_usage > upper_threshold))) {\n+    expand = true;\n+\n+    \/\/ Short-cut calculation if already at maximum capacity.\n+    if (_g1h->capacity() == _g1h->max_capacity()) {\n+      log_resize(short_term_gc_cpu_usage, long_term_gc_cpu_usage,\n+                 lower_threshold, upper_threshold, gc_cpu_usage_target, true, 0, expand);\n+      reset_cpu_usage_tracking_data();\n+      return resize_bytes;\n@@ -173,1 +308,2 @@\n-    expand_bytes = static_cast<size_t>(expand_bytes * scale_factor);\n+    log_trace(gc, ergo, heap)(\"expand deltas long %1.2f short %1.2f use long term %u delta %1.2f\",\n+                              long_term_delta, avg_short_term_delta, use_long_term_delta, delta);\n@@ -175,3 +311,1 @@\n-    \/\/ Ensure the expansion size is at least the minimum growth amount\n-    \/\/ and at most the remaining uncommitted byte size.\n-    expand_bytes = clamp(expand_bytes, min_expand_bytes, uncommitted_bytes);\n+    resize_bytes = young_collection_expand_amount(delta);\n@@ -179,11 +313,10 @@\n-    clear_ratio_check_data();\n-  } else {\n-    \/\/ An expansion was not triggered. If we've started counting, increment\n-    \/\/ the number of checks we've made in the current window.  If we've\n-    \/\/ reached the end of the window without resizing, clear the counters to\n-    \/\/ start again the next time we see a ratio above the threshold.\n-    if (_ratio_over_threshold_count > 0) {\n-      _pauses_since_start++;\n-      if (_pauses_since_start > _num_prev_pauses_for_heuristics) {\n-        clear_ratio_check_data();\n-      }\n+    reset_cpu_usage_tracking_data();\n+  } else if ((_gc_cpu_usage_deviation_counter <= -count_threshold_for_shrink) ||\n+             (use_long_term_delta && (long_term_gc_cpu_usage < lower_threshold))) {\n+    expand = false;\n+    \/\/ Short-cut calculation if already at minimum capacity.\n+    if (_g1h->capacity() == _g1h->min_capacity()) {\n+      log_resize(short_term_gc_cpu_usage, long_term_gc_cpu_usage,\n+                 lower_threshold, upper_threshold, gc_cpu_usage_target, true, 0, expand);\n+      reset_cpu_usage_tracking_data();\n+      return resize_bytes;\n@@ -191,0 +324,11 @@\n+\n+    log_trace(gc, ergo, heap)(\"expand deltas long %1.2f short %1.2f use long term %u delta %1.2f\",\n+                              long_term_delta, avg_short_term_delta, use_long_term_delta, delta);\n+\n+    resize_bytes = young_collection_shrink_amount(delta, allocation_word_size);\n+\n+    reset_cpu_usage_tracking_data();\n+  } else if (use_long_term_delta) {\n+    \/\/ A resize has not been triggered, but the long term counter overflowed.\n+    decay_cpu_usage_tracking_data();\n+    expand = false; \/\/ Does not matter.\n@@ -193,2 +337,3 @@\n-  log_expansion(short_term_pause_time_ratio, long_term_pause_time_ratio,\n-                threshold, pause_time_threshold, false, expand_bytes);\n+  log_resize(short_term_gc_cpu_usage, long_term_gc_cpu_usage,\n+             lower_threshold, upper_threshold, gc_cpu_usage_target,\n+             false, resize_bytes, expand);\n@@ -196,1 +341,1 @@\n-  return expand_bytes;\n+  return resize_bytes;\n@@ -223,1 +368,12 @@\n-size_t G1HeapSizingPolicy::full_collection_resize_amount(bool& expand) {\n+size_t G1HeapSizingPolicy::full_collection_resize_amount(bool& expand, size_t allocation_word_size) {\n+  \/\/ If the full collection was triggered by an allocation failure, we should account\n+  \/\/ for the bytes required for this allocation under used_after_gc. This prevents\n+  \/\/ unnecessary shrinking that would be followed by an expand call to satisfy the\n+  \/\/ allocation.\n+  size_t allocation_bytes = allocation_word_size * HeapWordSize;\n+  if (_g1h->is_humongous(allocation_word_size)) {\n+    \/\/ Humongous objects are allocated in entire regions, we must calculate\n+    \/\/ required space in terms of full regions, not just the object size.\n+    allocation_bytes = G1HeapRegion::align_up_to_region_byte_size(allocation_bytes);\n+  }\n+\n@@ -227,1 +383,1 @@\n-  const size_t used_after_gc = capacity_after_gc -\n+  const size_t used_after_gc = capacity_after_gc + allocation_bytes -\n@@ -249,1 +405,1 @@\n-  minimum_desired_capacity = MIN2(minimum_desired_capacity, MaxHeapSize);\n+  minimum_desired_capacity = MIN2(minimum_desired_capacity, _g1h->max_capacity());\n@@ -253,1 +409,1 @@\n-  maximum_desired_capacity =  MAX2(maximum_desired_capacity, MinHeapSize);\n+  maximum_desired_capacity = MAX2(maximum_desired_capacity, _g1h->min_capacity());\n@@ -259,1 +415,1 @@\n-    log_debug(gc, ergo, heap)(\"Attempt heap expansion (capacity lower than min desired capacity). \"\n+    log_debug(gc, ergo, heap)(\"Heap resize. Attempt heap expansion (capacity lower than min desired capacity). \"\n@@ -271,1 +427,1 @@\n-    log_debug(gc, ergo, heap)(\"Attempt heap shrinking (capacity higher than max desired capacity). \"\n+    log_debug(gc, ergo, heap)(\"Heap resize. Attempt heap shrinking (capacity higher than max desired capacity). \"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":289,"deletions":133,"binary":false,"changes":422,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1Analytics.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"utilities\/numberSeq.hpp\"\n@@ -30,1 +32,0 @@\n-class G1Analytics;\n@@ -33,0 +34,34 @@\n+\/\/\n+\/\/ Contains heuristics to resize the heap, i.e. expand or shrink, during operation.\n+\/\/\n+\/\/ For young collections, this heuristics is based on GC CPU usage, i.e. trying to\n+\/\/ change the heap so that the GC CPU usage stays approximately close to the target\n+\/\/ GC CPU usage set by the user.\n+\/\/\n+\/\/ The heuristics track both short and long term GC behavior to affect heap resizing.\n+\/\/\n+\/\/ Short term tracking is based on the short-term GC CPU usage i.e we count events\n+\/\/ for which short-term GC CPU usage is outside the range:\n+\/\/ gc_cpu_usage_target  [1 - d, 1 + d], where d = G1CPUUsageDeviationPercent \/ 100\n+\/\/ If below that range, we decrement that counter, if above, we increment it.\n+\/\/\n+\/\/ If that counter reaches the G1CPUUsageExpandThreshold we consider expansion,\n+\/\/ if that counter reaches -G1CPUUsageShrinkThreshold we consider shrinking the heap.\n+\/\/\n+\/\/ While doing so, we accumulate the relative difference to the target GC CPU usage\n+\/\/ to guide the expansion\/shrinking amount.\n+\/\/\n+\/\/ Furthermore, if there is no short-term based resizing event for a \"long\" time,\n+\/\/ we decay that counter, i.e. drop it towards zero again to avoid that previous\n+\/\/ intermediate length short term behavior followed by a quiet time and a single\n+\/\/ short term event causes unnecessary resizes.\n+\/\/\n+\/\/ Long term behavior is solely managed by regularly comparing actual long term\n+\/\/ GC CPU usage with the boundaries of acceptable deviation range. If the actual\n+\/\/ long term GC CPU usage is outside this range, expand or shrink accordingly.\n+\/\/\n+\/\/ The mechanism is meant to filter out short term events because heap resizing\n+\/\/ has some overhead.\n+\/\/\n+\/\/ For full collections, we base resize decisions only on Min\/MaxHeapFreeRatio.\n+\/\/\n@@ -34,5 +69,0 @@\n-  \/\/ MinOverThresholdForGrowth must be less than the number of recorded\n-  \/\/ pause times in G1Analytics, representing the minimum number of pause\n-  \/\/ time ratios that exceed GCTimeRatio before a heap expansion will be triggered.\n-  const static uint MinOverThresholdForGrowth = 4;\n-\n@@ -42,5 +72,12 @@\n-  const uint _num_prev_pauses_for_heuristics;\n-  \/\/ Ratio check data for determining if heap growth is necessary.\n-  uint _ratio_over_threshold_count;\n-  double _ratio_over_threshold_sum;\n-  uint _pauses_since_start;\n+  \/\/ Number of times short-term GC CPU usage crossed the lower or upper threshold\n+  \/\/ recently; every time the upper threshold is exceeded, it is incremented, and\n+  \/\/ decremented if the lower threshold is exceeded.\n+  int _gc_cpu_usage_deviation_counter;\n+  \/\/ Recent GC CPU usage deviations relative to the gc_cpu_usage_target\n+  TruncatedSeq _recent_cpu_usage_deltas;\n+  uint _long_term_count;\n+\n+  \/\/ Clear GC CPU usage tracking data used by young_collection_resize_amount().\n+  void reset_cpu_usage_tracking_data();\n+  \/\/ Decay (move towards \"no changes\") GC CPU usage tracking data.\n+  void decay_cpu_usage_tracking_data();\n@@ -48,1 +85,1 @@\n-  \/\/ Scale \"full\" gc pause time threshold with heap size as we want to resize more\n+  \/\/ Scale the gc_cpu_usage_target with heap size as we want to resize more\n@@ -50,1 +87,7 @@\n-  double scale_with_heap(double pause_time_threshold);\n+  double scale_with_heap(double gc_cpu_usage_target);\n+\n+  \/\/ Scale the cpu usage delta depending on the relative difference from the target gc_cpu_usage.\n+  double scale_cpu_usage_delta(double cpu_usage_delta, double min_scale_factor, double max_scale_factor) const;\n+\n+  size_t young_collection_expand_amount(double cpu_usage_delta) const;\n+  size_t young_collection_shrink_amount(double cpu_usage_delta, size_t allocation_word_size) const;\n@@ -55,3 +98,7 @@\n-  \/\/ If an expansion would be appropriate, because recent GC overhead had\n-  \/\/ exceeded the desired limit, return an amount to expand by.\n-  size_t young_collection_expansion_amount();\n+  static constexpr uint long_term_count_limit() {\n+    return G1Analytics::max_num_of_recorded_pause_times();\n+  }\n+  \/\/ Return by how many bytes the heap should be changed based on recent GC CPU\n+  \/\/ usage after young collection. If expand is set, the heap should be expanded,\n+  \/\/ otherwise shrunk.\n+  size_t young_collection_resize_amount(bool& expand, size_t allocation_word_size);\n@@ -61,3 +108,1 @@\n-  size_t full_collection_resize_amount(bool& expand);\n-  \/\/ Clear ratio tracking data used by expansion_amount().\n-  void clear_ratio_check_data();\n+  size_t full_collection_resize_amount(bool& expand, size_t allocation_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.hpp","additions":65,"deletions":20,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-    _partial_array_splitter(g1h->partial_array_state_manager(), num_workers),\n+    _partial_array_splitter(g1h->partial_array_state_manager(), num_workers, ParGCArrayScanChunk),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -499,1 +499,1 @@\n-  _evac_failure_regions.pre_collection(_g1h->max_reserved_regions());\n+  _evac_failure_regions.pre_collection(_g1h->max_num_regions());\n@@ -974,3 +974,0 @@\n-  uint no_of_gc_workers = workers()->active_workers();\n-  rp->set_active_mt_degree(no_of_gc_workers);\n-\n@@ -979,1 +976,1 @@\n-  ReferenceProcessorStats stats = rp->process_discovered_references(task, pt);\n+  ReferenceProcessorStats stats = rp->process_discovered_references(task, _g1h->workers(), pt);\n@@ -1065,1 +1062,1 @@\n-  _g1h->expand_heap_after_young_collection();\n+  _g1h->resize_heap_after_young_collection(_allocation_word_size);\n@@ -1080,1 +1077,2 @@\n-G1YoungCollector::G1YoungCollector(GCCause::Cause gc_cause) :\n+G1YoungCollector::G1YoungCollector(GCCause::Cause gc_cause,\n+                                   size_t allocation_word_size) :\n@@ -1083,0 +1081,1 @@\n+  _allocation_word_size(allocation_word_size),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,0 +82,1 @@\n+  size_t _allocation_word_size;\n@@ -140,1 +141,2 @@\n-  G1YoungCollector(GCCause::Cause gc_cause);\n+  G1YoungCollector(GCCause::Cause gc_cause,\n+                   size_t allocation_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,1 +147,1 @@\n-          constraint(G1SATBBufferSizeConstraintFunc, AtParse)               \\\n+          constraint(G1SATBBufferSizeConstraintFunc, AfterErgo)             \\\n@@ -161,1 +161,2 @@\n-          \"When expanding, % of uncommitted space to claim.\")               \\\n+          \"When expanding, % of uncommitted space to expand the heap by in \"\\\n+          \"a single expand attempt.\")                                       \\\n@@ -164,0 +165,26 @@\n+  product(uint, G1ShrinkByPercentOfAvailable, 50, DIAGNOSTIC,               \\\n+          \"When shrinking, maximum % of free space to free for a single \"   \\\n+          \"shrink attempt.\")                                                \\\n+          range(0, 100)                                                     \\\n+                                                                            \\\n+  product(uint, G1CPUUsageDeviationPercent, 25, DIAGNOSTIC,                 \\\n+          \"The acceptable deviation (in percent) from the target GC CPU \"   \\\n+          \"usage (based on GCTimeRatio). Creates a tolerance range \"        \\\n+          \"around the target to deal with short-term fluctuations without \" \\\n+          \"triggering GC resizing mechanism prematurely.\")                  \\\n+          range(0, 100)                                                     \\\n+                                                                            \\\n+  product(uint, G1CPUUsageExpandThreshold, 4, DIAGNOSTIC,                   \\\n+          \"If the GC CPU usage deviation counter exceeds this threshold, \"  \\\n+          \"a heap expansion may be triggered. The counter is incremented \"  \\\n+          \"when short-term GC CPU usage exceeds the upper bound of the \"    \\\n+          \"acceptable deviation range.\")                                    \\\n+          constraint(G1CPUUsageExpandConstraintFunc, AfterErgo)             \\\n+                                                                            \\\n+  product(uint, G1CPUUsageShrinkThreshold, 8, DIAGNOSTIC,                   \\\n+          \"If the GC CPU usage deviation counter drops below the negative \" \\\n+          \"of this threshold, a heap shrink may be triggered. The counter \" \\\n+          \"is decremented when short-term GC CPU usage is below the lower \" \\\n+          \"bound of acceptable deviation range.\")                           \\\n+          constraint(G1CPUUsageShrinkConstraintFunc, AfterErgo)             \\\n+                                                                            \\\n@@ -166,1 +193,1 @@\n-          constraint(G1UpdateBufferSizeConstraintFunc, AtParse)             \\\n+          constraint(G1UpdateBufferSizeConstraintFunc, AfterErgo)           \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":31,"deletions":4,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/g1\/g1HeapSizingPolicy.hpp\"\n@@ -213,0 +214,29 @@\n+\n+JVMFlag::Error gc_cpu_usage_threshold_helper(JVMFlagsEnum flagid,\n+                                             uint value,\n+                                             bool verbose) {\n+  if (UseG1GC) {\n+    JVMFlag* flag = JVMFlag::flag_from_enum(flagid);\n+    const uint min_count = 1;\n+    const uint max_count = G1HeapSizingPolicy::long_term_count_limit();\n+    if (value < min_count || value > max_count) {\n+      JVMFlag::printError(verbose,\n+                          \"%s (%u) must be in range [%u, %u]\\n\",\n+                          flag->name(), value, min_count, max_count);\n+      return JVMFlag::VIOLATES_CONSTRAINT;\n+    }\n+  }\n+  return JVMFlag::SUCCESS;\n+}\n+\n+JVMFlag::Error G1CPUUsageExpandConstraintFunc(uint value, bool verbose) {\n+  return gc_cpu_usage_threshold_helper(FLAG_MEMBER_ENUM(G1CPUUsageExpandThreshold),\n+                                       value,\n+                                       verbose);\n+}\n+\n+JVMFlag::Error G1CPUUsageShrinkConstraintFunc(uint value, bool verbose) {\n+  return gc_cpu_usage_threshold_helper(FLAG_MEMBER_ENUM(G1CPUUsageShrinkThreshold),\n+                                       value,\n+                                       verbose);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,4 @@\n+                                                      \\\n+  \/* G1 GC deviation counter threshold constraints *\/ \\\n+  f(uint, G1CPUUsageExpandConstraintFunc)             \\\n+  f(uint, G1CPUUsageShrinkConstraintFunc)             \\\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-          \"Inconsistent MinSurvivorRatio vs InitialSurvivorRatio: %d vs %d\\n\", MinSurvivorRatio, InitialSurvivorRatio);\n+          \"Inconsistent MinSurvivorRatio vs InitialSurvivorRatio: %zu vs %zu\\n\", MinSurvivorRatio, InitialSurvivorRatio);\n@@ -98,2 +98,2 @@\n-\/\/ The alignment used for boundary between young gen and old gen\n-static size_t default_gen_alignment() {\n+\/\/ The alignment used for spaces in young gen and old gen\n+static size_t default_space_alignment() {\n@@ -106,1 +106,1 @@\n-  SpaceAlignment = GenAlignment = default_gen_alignment();\n+  SpaceAlignment = default_space_alignment();\n@@ -123,3 +123,2 @@\n-  size_t new_alignment = align_up(page_sz, GenAlignment);\n-  if (new_alignment != GenAlignment) {\n-    GenAlignment = new_alignment;\n+  size_t new_alignment = align_up(page_sz, SpaceAlignment);\n+  if (new_alignment != SpaceAlignment) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelArguments.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -73,2 +73,2 @@\n-  ReservedSpace old_rs   = heap_rs.first_part(MaxOldSize, GenAlignment);\n-  ReservedSpace young_rs = heap_rs.last_part(MaxOldSize, GenAlignment);\n+  ReservedSpace old_rs   = heap_rs.first_part(MaxOldSize, SpaceAlignment);\n+  ReservedSpace young_rs = heap_rs.last_part(MaxOldSize, SpaceAlignment);\n@@ -97,2 +97,1 @@\n-      MaxOldSize,\n-      \"old\", 1);\n+      MaxOldSize);\n@@ -112,1 +111,1 @@\n-                             GenAlignment,\n+                             SpaceAlignment,\n@@ -222,6 +221,0 @@\n-bool ParallelScavengeHeap::is_maximal_no_gc() const {\n-  \/\/ We don't expand young-gen except at a GC.\n-  return old_gen()->is_maximal_no_gc();\n-}\n-\n-\n@@ -342,1 +335,1 @@\n-      if (op.prologue_succeeded()) {\n+      if (op.gc_succeeded()) {\n@@ -533,15 +526,2 @@\n-  while (true) {\n-    VM_ParallelGCCollect op(gc_count, full_gc_count, cause);\n-    VMThread::execute(&op);\n-\n-    if (!GCCause::is_explicit_full_gc(cause)) {\n-      return;\n-    }\n-\n-    {\n-      MutexLocker ml(Heap_lock);\n-      if (full_gc_count != total_full_collections()) {\n-        return;\n-      }\n-    }\n-  }\n+  VM_ParallelGCCollect op(gc_count, full_gc_count, cause);\n+  VMThread::execute(&op);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":7,"deletions":27,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -114,0 +114,3 @@\n+  void print_tracing_info() const override;\n+  void stop() override {};\n+\n@@ -161,5 +164,0 @@\n-  \/\/ Return \"true\" if all generations have reached the\n-  \/\/ maximal committed limit that they can reach, without a garbage\n-  \/\/ collection.\n-  bool is_maximal_no_gc() const override;\n-\n@@ -220,1 +218,0 @@\n-  void print_tracing_info() const override;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-  :_partial_array_splitter(_partial_array_state_manager, parallel_gc_threads),\n+  :_partial_array_splitter(_partial_array_state_manager, parallel_gc_threads, ObjArrayMarkingStride),\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManagerNew.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -667,1 +667,1 @@\n-  heap->print_heap_before_gc();\n+  heap->print_before_gc();\n@@ -1174,1 +1174,1 @@\n-  heap->print_heap_after_gc();\n+  heap->print_after_gc();\n@@ -1317,2 +1317,1 @@\n-    ref_processor()->set_active_mt_degree(active_gc_threads);\n-    stats = ref_processor()->process_discovered_references(task, pt);\n+    stats = ref_processor()->process_discovered_references(task, &ParallelScavengeHeap::heap()->workers(), pt);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-  heap->print_heap_before_gc();\n+  heap->print_before_gc();\n@@ -687,1 +687,1 @@\n-  heap->print_heap_after_gc();\n+  heap->print_after_gc();\n@@ -821,1 +821,0 @@\n-    ref_processor()->set_active_mt_degree(active_gc_threads);\n@@ -823,1 +822,1 @@\n-    stats = ref_processor()->process_discovered_references(task, pt);\n+    stats = ref_processor()->process_discovered_references(task, &ParallelScavengeHeap::heap()->workers(), pt);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompactNew.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-    Threads::possibly_parallel_threads_do(true \/* is_par *\/, &closure);\n+    Threads::possibly_parallel_threads_do(_active_workers > 1 \/* is_par *\/, &closure);\n@@ -356,1 +356,1 @@\n-  heap->print_heap_before_gc();\n+  heap->print_before_gc();\n@@ -414,1 +414,0 @@\n-      reference_processor()->set_active_mt_degree(active_workers);\n@@ -419,1 +418,1 @@\n-      stats = reference_processor()->process_discovered_references(task, pt);\n+      stats = reference_processor()->process_discovered_references(task, &ParallelScavengeHeap::heap()->workers(), pt);\n@@ -591,1 +590,1 @@\n-  heap->print_heap_after_gc();\n+  heap->print_after_gc();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -634,1 +634,1 @@\n-    const ReferenceProcessorStats& stats = rp->process_discovered_references(task, pt);\n+    const ReferenceProcessorStats& stats = rp->process_discovered_references(task, nullptr, pt);\n@@ -815,1 +815,1 @@\n-    _gen_counters->update_all(_virtual_space.committed_size());\n+    _gen_counters->update_capacity(_virtual_space.committed_size());\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"gc\/shared\/fullGCForwarding.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/serialArguments.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -232,1 +232,1 @@\n-  static void forward_obj(oop obj, HeapWord* new_addr) {\n+  static void forward_obj(oop obj, HeapWord* new_addr, bool after_first_dead) {\n@@ -238,2 +238,7 @@\n-      \/\/ This obj will stay in-place. Fix the markword.\n-      obj->init_mark();\n+      if (!after_first_dead) {\n+        \/\/ This obj will stay in-place and we'll not see it during relocation.\n+        \/\/ Fix the markword.\n+        obj->init_mark();\n+      } else {\n+        FullGCForwarding::forward_to(obj, cast_to_oop(new_addr));\n+      }\n@@ -310,1 +315,1 @@\n-          forward_obj(obj, new_addr);\n+          forward_obj(obj, new_addr, record_first_dead_done);\n@@ -510,1 +515,1 @@\n-    const ReferenceProcessorStats& stats = ref_processor()->process_discovered_references(task, pt);\n+    const ReferenceProcessorStats& stats = ref_processor()->process_discovered_references(task, nullptr, pt);\n","filename":"src\/hotspot\/share\/gc\/serial\/serialFullGC.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#include \"gc\/shared\/fullGCForwarding.hpp\"\n+#include \"gc\/shared\/fullGCForwarding.inline.hpp\"\n@@ -191,2 +191,2 @@\n-  ReservedSpace young_rs = heap_rs.first_part(MaxNewSize, GenAlignment);\n-  ReservedSpace old_rs = heap_rs.last_part(MaxNewSize, GenAlignment);\n+  ReservedSpace young_rs = heap_rs.first_part(MaxNewSize, SpaceAlignment);\n+  ReservedSpace old_rs = heap_rs.last_part(MaxNewSize, SpaceAlignment);\n@@ -342,1 +342,1 @@\n-    if (op.prologue_succeeded()) {\n+    if (op.gc_succeeded()) {\n@@ -407,1 +407,1 @@\n-  print_heap_before_gc();\n+  print_before_gc();\n@@ -443,1 +443,1 @@\n-  print_heap_after_gc();\n+  print_after_gc();\n@@ -610,18 +610,5 @@\n-  while (true) {\n-    VM_SerialGCCollect op(!should_run_young_gc,\n-                          gc_count_before,\n-                          full_gc_count_before,\n-                          cause);\n-    VMThread::execute(&op);\n-    if (!GCCause::is_explicit_full_gc(cause)) {\n-      return;\n-    }\n-\n-    {\n-      MutexLocker ml(Heap_lock);\n-      \/\/ Read the GC count while holding the Heap_lock\n-      if (full_gc_count_before != total_full_collections()) {\n-        return;\n-      }\n-    }\n-  }\n+  VM_SerialGCCollect op(!should_run_young_gc,\n+                        gc_count_before,\n+                        full_gc_count_before,\n+                        cause);\n+  VMThread::execute(&op);\n@@ -639,1 +626,1 @@\n-  print_heap_before_gc();\n+  print_before_gc();\n@@ -699,1 +686,1 @@\n-  print_heap_after_gc();\n+  print_after_gc();\n@@ -782,5 +769,0 @@\n-bool SerialHeap::is_maximal_no_gc() const {\n-  \/\/ We don't expand young-gen except at a GC.\n-  return _old_gen->is_maximal_no_gc();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":13,"deletions":31,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -121,0 +121,3 @@\n+  void print_tracing_info() const override;\n+  void stop() override {};\n+\n@@ -212,1 +215,0 @@\n-  void print_tracing_info() const override;\n@@ -219,5 +221,0 @@\n-  \/\/ Return \"true\" if all generations have reached the\n-  \/\/ maximal committed limit that they can reach, without a garbage\n-  \/\/ collection.\n-  virtual bool is_maximal_no_gc() const override;\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -371,1 +371,1 @@\n-    _gen_counters->update_all(_virtual_space.committed_size());\n+    _gen_counters->update_capacity(_virtual_space.committed_size());\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"gc\/shared\/stringdedup\/stringDedupProcessor.hpp\"\n@@ -70,4 +71,1 @@\n-class GCMessage : public FormatBuffer<1024> {\n- public:\n-  bool is_before;\n-};\n+class GCLogMessage : public FormatBuffer<512> {};\n@@ -76,2 +74,1 @@\n-void EventLogBase<GCMessage>::print(outputStream* st, GCMessage& m) {\n-  st->print_cr(\"GC heap %s\", m.is_before ? \"before\" : \"after\");\n+void EventLogBase<GCLogMessage>::print(outputStream* st, GCLogMessage& m) {\n@@ -81,3 +78,3 @@\n-class GCHeapLog : public EventLogBase<GCMessage> {\n- private:\n-  void log_heap(CollectedHeap* heap, bool before);\n+class GCLog : public EventLogBase<GCLogMessage> {\n+ protected:\n+  virtual void log_usage(const CollectedHeap* heap, outputStream* st) const = 0;\n@@ -86,1 +83,1 @@\n-  GCHeapLog() : EventLogBase<GCMessage>(\"GC Heap History\", \"gc\") {}\n+  GCLog(const char* name, const char* handle) : EventLogBase<GCLogMessage>(name, handle) {}\n@@ -88,6 +85,1 @@\n-  void log_heap_before(CollectedHeap* heap) {\n-    log_heap(heap, true);\n-  }\n-  void log_heap_after(CollectedHeap* heap) {\n-    log_heap(heap, false);\n-  }\n+  void log_gc(const CollectedHeap* heap, GCWhen::Type when);\n@@ -96,1 +88,1 @@\n-void GCHeapLog::log_heap(CollectedHeap* heap, bool before) {\n+void GCLog::log_gc(const CollectedHeap* heap, GCWhen::Type when) {\n@@ -104,1 +96,1 @@\n-  _records[index].thread = nullptr; \/\/ Its the GC thread so it's not that interesting.\n+  _records[index].thread = nullptr; \/\/ It's the GC thread so it's not that interesting.\n@@ -106,1 +98,0 @@\n-  _records[index].data.is_before = before;\n@@ -109,5 +100,1 @@\n-  st.print_cr(\"{Heap %s GC invocations=%u (full %u):\",\n-                 before ? \"before\" : \"after\",\n-                 heap->total_collections(),\n-                 heap->total_full_collections());\n-\n+  st.print(\"{\");\n@@ -115,0 +102,1 @@\n+    heap->print_invocation_on(&st, _handle, when);\n@@ -116,2 +104,1 @@\n-    heap->print_heap_on(&st);\n-    MetaspaceUtils::print_on(&st);\n+    log_usage(heap, &st);\n@@ -119,1 +106,0 @@\n-\n@@ -123,0 +109,20 @@\n+class GCHeapLog : public GCLog {\n+ private:\n+  void log_usage(const CollectedHeap* heap, outputStream* st) const override {\n+    heap->print_heap_on(st);\n+  }\n+\n+ public:\n+  GCHeapLog() : GCLog(\"GC Heap Usage History\", \"heap\") {}\n+};\n+\n+class GCMetaspaceLog : public GCLog {\n+ private:\n+  void log_usage(const CollectedHeap* heap, outputStream* st) const override {\n+    MetaspaceUtils::print_on(st);\n+  }\n+\n+ public:\n+  GCMetaspaceLog() : GCLog(\"Metaspace Usage History\", \"metaspace\") {}\n+};\n+\n@@ -166,5 +172,3 @@\n-void CollectedHeap::print_heap_before_gc() {\n-  LogTarget(Debug, gc, heap) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    ls.print_cr(\"Heap before GC invocations=%u (full %u):\", total_collections(), total_full_collections());\n+void CollectedHeap::print_invocation_on(outputStream* st, const char* type, GCWhen::Type when) const {\n+  st->print_cr(\"%s %s invocations=%u (full %u):\", type, GCWhen::to_string(when), total_collections(), total_full_collections());\n+}\n@@ -172,0 +176,6 @@\n+void CollectedHeap::print_relative_to_gc(GCWhen::Type when) const {\n+  \/\/ Print heap information\n+  LogTarget(Debug, gc, heap) lt_heap;\n+  if (lt_heap.is_enabled()) {\n+    LogStream ls(lt_heap);\n+    print_invocation_on(&ls, \"Heap\", when);\n@@ -174,0 +184,12 @@\n+  }\n+\n+  if (_heap_log != nullptr) {\n+    _heap_log->log_gc(this, when);\n+  }\n+\n+  \/\/ Print metaspace information\n+  LogTarget(Debug, gc, metaspace) lt_metaspace;\n+  if (lt_metaspace.is_enabled()) {\n+    LogStream ls(lt_metaspace);\n+    print_invocation_on(&ls, \"Metaspace\", when);\n+    StreamIndentor indentor(&ls, 1);\n@@ -177,2 +199,2 @@\n-  if (_gc_heap_log != nullptr) {\n-    _gc_heap_log->log_heap_before(this);\n+  if (_metaspace_log != nullptr) {\n+    _metaspace_log->log_gc(this, when);\n@@ -182,5 +204,3 @@\n-void CollectedHeap::print_heap_after_gc() {\n-  LogTarget(Debug, gc, heap) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    ls.print_cr(\"Heap after GC invocations=%u (full %u):\", total_collections(), total_full_collections());\n+class CPUTimeThreadClosure : public ThreadClosure {\n+private:\n+  jlong _cpu_time = 0;\n@@ -188,3 +208,6 @@\n-    StreamIndentor si(&ls, 1);\n-    print_heap_on(&ls);\n-    MetaspaceUtils::print_on(&ls);\n+public:\n+  virtual void do_thread(Thread* thread) {\n+    jlong cpu_time = os::thread_cpu_time(thread);\n+    if (cpu_time != -1) {\n+      _cpu_time += cpu_time;\n+    }\n@@ -192,0 +215,2 @@\n+  jlong cpu_time() { return _cpu_time; };\n+};\n@@ -193,2 +218,6 @@\n-  if (_gc_heap_log != nullptr) {\n-    _gc_heap_log->log_heap_after(this);\n+double CollectedHeap::elapsed_gc_cpu_time() const {\n+  double string_dedup_cpu_time = UseStringDeduplication ?\n+    os::thread_cpu_time((Thread*)StringDedup::_processor->_thread) : 0;\n+\n+  if (string_dedup_cpu_time == -1) {\n+    string_dedup_cpu_time = 0;\n@@ -196,0 +225,13 @@\n+\n+  CPUTimeThreadClosure cl;\n+  gc_threads_do(&cl);\n+\n+  return (double)(cl.cpu_time() + _vmthread_cpu_time + string_dedup_cpu_time) \/ NANOSECS_PER_SEC;\n+}\n+\n+void CollectedHeap::print_before_gc() const {\n+  print_relative_to_gc(GCWhen::BeforeGC);\n+}\n+\n+void CollectedHeap::print_after_gc() const {\n+  print_relative_to_gc(GCWhen::AfterGC);\n@@ -271,0 +313,1 @@\n+  _vmthread_cpu_time(0),\n@@ -304,1 +347,2 @@\n-    _gc_heap_log = new GCHeapLog();\n+    _metaspace_log = new GCMetaspaceLog();\n+    _heap_log = new GCHeapLog();\n@@ -306,1 +350,2 @@\n-    _gc_heap_log = nullptr;\n+    _metaspace_log = nullptr;\n+    _heap_log = nullptr;\n@@ -370,1 +415,1 @@\n-    if (op.prologue_succeeded()) {\n+    if (op.gc_succeeded()) {\n@@ -520,2 +565,2 @@\n-      if (retire_tlabs) {\n-        thread->tlab().retire(&stats);\n+      if (retire_tlabs || ZeroTLAB) {\n+        thread->retire_tlab(&stats);\n@@ -591,0 +636,34 @@\n+void CollectedHeap::log_gc_cpu_time() const {\n+  LogTarget(Info, gc, cpu) out;\n+  if (os::is_thread_cpu_time_supported() && out.is_enabled()) {\n+    double process_cpu_time = os::elapsed_process_cpu_time();\n+    double gc_cpu_time = elapsed_gc_cpu_time();\n+\n+    if (process_cpu_time == -1 || gc_cpu_time == -1) {\n+      log_warning(gc, cpu)(\"Could not sample CPU time\");\n+      return;\n+    }\n+\n+    double usage;\n+    if (gc_cpu_time > process_cpu_time ||\n+        process_cpu_time == 0 || gc_cpu_time == 0) {\n+      \/\/ This can happen e.g. for short running processes with\n+      \/\/ low CPU utilization\n+      usage = 0;\n+    } else {\n+      usage = 100 * gc_cpu_time \/ process_cpu_time;\n+    }\n+    out.print(\"GC CPU usage: %.2f%% (Process: %.4fs GC: %.4fs)\", usage, process_cpu_time, gc_cpu_time);\n+  }\n+}\n+\n+void CollectedHeap::before_exit() {\n+  print_tracing_info();\n+\n+  \/\/ Log GC CPU usage.\n+  log_gc_cpu_time();\n+\n+  \/\/ Stop any on-going concurrent work and prepare for exit.\n+  stop();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":128,"deletions":49,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -51,0 +51,2 @@\n+class GCMemoryManager;\n+class GCMetaspaceLog;\n@@ -53,1 +55,0 @@\n-class GCMemoryManager;\n@@ -97,1 +98,2 @@\n-  GCHeapLog* _gc_heap_log;\n+  GCHeapLog*      _heap_log;\n+  GCMetaspaceLog* _metaspace_log;\n@@ -133,0 +135,2 @@\n+  jlong _vmthread_cpu_time;\n+\n@@ -207,0 +211,7 @@\n+  \/\/ Print any relevant tracing info that flags imply.\n+  \/\/ Default implementation does nothing.\n+  virtual void print_tracing_info() const = 0;\n+\n+  \/\/ Stop any onging concurrent work and prepare for exit.\n+  virtual void stop() = 0;\n+\n@@ -240,2 +251,1 @@\n-  \/\/ Stop any onging concurrent work and prepare for exit.\n-  virtual void stop() {}\n+  void before_exit();\n@@ -247,0 +257,2 @@\n+  void add_vmthread_cpu_time(jlong time);\n+\n@@ -260,5 +272,0 @@\n-  \/\/ Return \"true\" if the part of the heap that allocates Java\n-  \/\/ objects has reached the maximal committed limit that it can\n-  \/\/ reach, without a garbage collection.\n-  virtual bool is_maximal_no_gc() const = 0;\n-\n@@ -423,0 +430,4 @@\n+  void print_relative_to_gc(GCWhen::Type when) const;\n+\n+  void log_gc_cpu_time() const;\n+\n@@ -438,0 +449,2 @@\n+  void print_invocation_on(outputStream* st, const char* type, GCWhen::Type when) const;\n+\n@@ -453,3 +466,1 @@\n-  \/\/ Print any relevant tracing info that flags imply.\n-  \/\/ Default implementation does nothing.\n-  virtual void print_tracing_info() const = 0;\n+  double elapsed_gc_cpu_time() const;\n@@ -457,2 +468,2 @@\n-  void print_heap_before_gc();\n-  void print_heap_after_gc();\n+  void print_before_gc() const;\n+  void print_after_gc() const;\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":25,"deletions":14,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -49,0 +49,4 @@\n+inline void CollectedHeap::add_vmthread_cpu_time(jlong time) {\n+  _vmthread_cpu_time += time;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,186 +1,0 @@\n-\/*\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"gc\/shared\/fullGCForwarding.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"nmt\/memTag.hpp\"\n-#include \"utilities\/ostream.hpp\"\n-#include \"utilities\/concurrentHashTable.inline.hpp\"\n-#include \"utilities\/fastHash.hpp\"\n-#include \"utilities\/powerOfTwo.hpp\"\n-\n-static uintx hash(HeapWord* const& addr) {\n-  uint64_t val = reinterpret_cast<uint64_t>(addr);\n-  uint32_t hash = FastHash::get_hash32((uint32_t)val, (uint32_t)(val >> 32));\n-  return hash;\n-}\n-\n-struct ForwardingEntry {\n-  HeapWord* _from;\n-  HeapWord* _to;\n-  ForwardingEntry(HeapWord* from, HeapWord* to) : _from(from), _to(to) {}\n-};\n-\n-struct FallbackTableConfig {\n-  using Value = ForwardingEntry;\n-  static uintx get_hash(Value const& entry, bool* is_dead) {\n-    return hash(entry._from);\n-  }\n-  static void* allocate_node(void* context, size_t size, Value const& value) {\n-    return AllocateHeap(size, mtGC);\n-  }\n-  static void free_node(void* context, void* memory, Value const& value) {\n-    FreeHeap(memory);\n-  }\n-};\n-\n-class FallbackTable : public ConcurrentHashTable<FallbackTableConfig, mtGC> {\n-\n-};\n-\n-class FallbackTableLookup : public StackObj {\n-  ForwardingEntry const _entry;\n-public:\n-  explicit FallbackTableLookup(HeapWord* from) : _entry(from, nullptr) {}\n-  uintx get_hash() const {\n-    return hash(_entry._from);\n-  }\n-  bool equals(ForwardingEntry* value) {\n-    return _entry._from == value->_from;\n-  }\n-  bool is_dead(ForwardingEntry* value) { return false; }\n-};\n-\n-\/\/ We cannot use 0, because that may already be a valid base address in zero-based heaps.\n-\/\/ 0x1 is safe because heap base addresses must be aligned by much larger alignment\n-HeapWord* const FullGCForwarding::UNUSED_BASE = reinterpret_cast<HeapWord*>(0x1);\n-\n-HeapWord* FullGCForwarding::_heap_start = nullptr;\n-size_t FullGCForwarding::_heap_start_region_bias = 0;\n-size_t FullGCForwarding::_num_regions = 0;\n-uintptr_t FullGCForwarding::_region_mask = 0;\n-HeapWord** FullGCForwarding::_biased_bases = nullptr;\n-HeapWord** FullGCForwarding::_bases_table = nullptr;\n-FallbackTable* FullGCForwarding::_fallback_table = nullptr;\n-#ifndef PRODUCT\n-volatile uint64_t FullGCForwarding::_num_forwardings = 0;\n-volatile uint64_t FullGCForwarding::_num_fallback_forwardings = 0;\n-#endif\n-\n-void FullGCForwarding::initialize(MemRegion heap) {\n-#ifdef _LP64\n-  _heap_start = heap.start();\n-\n-  size_t rounded_heap_size = round_up_power_of_2(heap.byte_size());\n-\n-  _num_regions = (rounded_heap_size \/ BytesPerWord) \/ BLOCK_SIZE_WORDS;\n-\n-  _heap_start_region_bias = (uintptr_t)_heap_start >> BLOCK_SIZE_BYTES_SHIFT;\n-  _region_mask = ~((uintptr_t(1) << BLOCK_SIZE_BYTES_SHIFT) - 1);\n-\n-  assert(_bases_table == nullptr, \"should not be initialized yet\");\n-  assert(_fallback_table == nullptr, \"should not be initialized yet\");\n-#endif\n-}\n-\n-void FullGCForwarding::begin() {\n-#ifdef _LP64\n-  assert(_bases_table == nullptr, \"should not be initialized yet\");\n-  assert(_fallback_table == nullptr, \"should not be initialized yet\");\n-\n-  _fallback_table = new FallbackTable();\n-\n-#ifndef PRODUCT\n-  _num_forwardings = 0;\n-  _num_fallback_forwardings = 0;\n-#endif\n-\n-  size_t max = _num_regions;\n-  _bases_table = NEW_C_HEAP_ARRAY(HeapWord*, max, mtGC);\n-  HeapWord** biased_start = _bases_table - _heap_start_region_bias;\n-  _biased_bases = biased_start;\n-  for (size_t i = 0; i < max; i++) {\n-    _bases_table[i] = UNUSED_BASE;\n-  }\n-#endif\n-}\n-\n-void FullGCForwarding::end() {\n-#ifndef PRODUCT\n-  log_info(gc)(\"Total forwardings: \" UINT64_FORMAT \", fallback forwardings: \" UINT64_FORMAT\n-                \", ratio: %f, memory used by fallback table: %zu%s, memory used by bases table: %zu%s\",\n-               _num_forwardings, _num_fallback_forwardings, (float)_num_forwardings\/(float)_num_fallback_forwardings,\n-               byte_size_in_proper_unit(_fallback_table->get_mem_size(Thread::current())),\n-               proper_unit_for_byte_size(_fallback_table->get_mem_size(Thread::current())),\n-               byte_size_in_proper_unit(sizeof(HeapWord*) * _num_regions),\n-               proper_unit_for_byte_size(sizeof(HeapWord*) * _num_regions));\n-#endif\n-#ifdef _LP64\n-  assert(_bases_table != nullptr, \"should be initialized\");\n-  FREE_C_HEAP_ARRAY(HeapWord*, _bases_table);\n-  _bases_table = nullptr;\n-  delete _fallback_table;\n-  _fallback_table = nullptr;\n-#endif\n-}\n-\n-void FullGCForwarding::fallback_forward_to(HeapWord* from, HeapWord* to) {\n-  assert(to != nullptr, \"no null forwarding\");\n-  assert(_fallback_table != nullptr, \"should be initialized\");\n-  FallbackTableLookup lookup_f(from);\n-  ForwardingEntry entry(from, to);\n-  auto found_f = [&](ForwardingEntry* found) {\n-    \/\/ If dupe has been found, override it with new value.\n-    \/\/ This is also called when new entry is succussfully inserted.\n-    if (found->_to != to) {\n-      found->_to = to;\n-    }\n-  };\n-  Thread* current_thread = Thread::current();\n-  bool grow;\n-  bool added = _fallback_table->insert_get(current_thread, lookup_f, entry, found_f, &grow);\n-  NOT_PRODUCT(Atomic::inc(&_num_fallback_forwardings);)\n-#ifdef ASSERT\n-  assert(fallback_forwardee(from) != nullptr, \"must have entered forwarding\");\n-  assert(fallback_forwardee(from) == to, \"forwarding must be correct, added: %s, from: \" PTR_FORMAT \", to: \" PTR_FORMAT \", fwd: \" PTR_FORMAT, BOOL_TO_STR(added), p2i(from), p2i(to), p2i(fallback_forwardee(from)));\n-#endif\n-  if (grow) {\n-    _fallback_table->grow(current_thread);\n-    tty->print_cr(\"grow fallback table to size: %zu bytes\",\n-                  _fallback_table->get_mem_size(current_thread));\n-  }\n-}\n-\n-HeapWord* FullGCForwarding::fallback_forwardee(HeapWord* from) {\n-  assert(_fallback_table != nullptr, \"fallback table must be present\");\n-  HeapWord* result;\n-  FallbackTableLookup lookup_f(from);\n-  auto found_f = [&](ForwardingEntry* found) {\n-    result = found->_to;\n-  };\n-  bool found = _fallback_table->get(Thread::current(), lookup_f, found_f);\n-  assert(found, \"something must have been found\");\n-  assert(result != nullptr, \"must have found forwarding\");\n-  return result;\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/fullGCForwarding.cpp","additions":0,"deletions":186,"binary":false,"changes":186,"status":"deleted"},{"patch":"@@ -34,1 +34,0 @@\n-class Mutex;\n@@ -119,4 +118,5 @@\n-class FullGCForwarding : public AllStatic {\n-private:\n-  static constexpr int AVAILABLE_LOW_BITS       = 11;\n-  static constexpr int AVAILABLE_BITS_MASK      = right_n_bits(AVAILABLE_LOW_BITS);\n+template <int BITS>\n+class FullGCForwardingImpl : public AllStatic {\n+  friend class FullGCForwardingTest;\n+  static constexpr int AVAILABLE_LOW_BITS        = BITS;\n+  static constexpr uintptr_t AVAILABLE_BITS_MASK = right_n_bits(AVAILABLE_LOW_BITS);\n@@ -130,1 +130,1 @@\n-  static constexpr size_t BLOCK_SIZE_WORDS = 1 << NUM_OFFSET_BITS;\n+  static constexpr size_t BLOCK_SIZE_WORDS = 1ll << NUM_OFFSET_BITS;\n@@ -156,0 +156,1 @@\n+  static size_t _fallback_table_log2_start_size;\n@@ -163,1 +164,1 @@\n-  static inline size_t biased_region_index_containing(HeapWord* addr);\n+  static size_t biased_region_index_containing(HeapWord* addr);\n@@ -165,3 +166,3 @@\n-  static inline bool is_fallback(uintptr_t encoded);\n-  static inline uintptr_t encode_forwarding(HeapWord* from, HeapWord* to);\n-  static inline HeapWord* decode_forwarding(HeapWord* from, uintptr_t encoded);\n+  static bool is_fallback(uintptr_t encoded);\n+  static uintptr_t encode_forwarding(HeapWord* from, HeapWord* to);\n+  static HeapWord* decode_forwarding(HeapWord* from, uintptr_t encoded);\n@@ -169,0 +170,1 @@\n+  static void maybe_init_fallback_table();\n@@ -172,2 +174,2 @@\n-  static inline void forward_to_impl(oop from, oop to);\n-  static inline oop forwardee_impl(oop from);\n+  static void forward_to_impl(oop from, oop to);\n+  static oop forwardee_impl(oop from);\n@@ -175,0 +177,6 @@\n+  FullGCForwardingImpl() = delete;\n+\n+  \/\/ Used in unit-test, so that we can test fallback-table-growth.\n+  static void set_fallback_table_log2_start_size(size_t fallback_table_log2_start_size) {\n+    _fallback_table_log2_start_size = fallback_table_log2_start_size;\n+  }\n@@ -180,2 +188,1 @@\n-  static inline bool is_forwarded(oop obj);\n-  static inline bool is_not_forwarded(oop obj);\n+  static bool is_forwarded(oop obj);\n@@ -183,2 +190,2 @@\n-  static inline void forward_to(oop from, oop to);\n-  static inline oop forwardee(oop from);\n+  static void forward_to(oop from, oop to);\n+  static oop forwardee(oop from);\n@@ -188,0 +195,8 @@\n+#ifdef _LP64\n+using FullGCForwarding = FullGCForwardingImpl<markWord::hashctrl_shift>;\n+#else\n+\/\/ On 32 bit, the BITS template argument is not used, but we still need\n+\/\/ to pass a value.\n+using FullGCForwarding = FullGCForwardingImpl<0>;\n+#endif\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/fullGCForwarding.hpp","additions":31,"deletions":16,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"nmt\/memTag.hpp\"\n@@ -31,0 +32,2 @@\n+#include \"utilities\/concurrentHashTable.inline.hpp\"\n+#include \"utilities\/fastHash.hpp\"\n@@ -32,0 +35,1 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -33,1 +37,30 @@\n-inline bool FullGCForwarding::is_forwarded(oop obj) {\n+\/\/ We cannot use 0, because that may already be a valid base address in zero-based heaps.\n+\/\/ 0x1 is safe because heap base addresses must be aligned by much larger alignment\n+template <int BITS>\n+HeapWord* const FullGCForwardingImpl<BITS>::UNUSED_BASE = reinterpret_cast<HeapWord*>(0x1);\n+\n+template <int BITS>\n+HeapWord* FullGCForwardingImpl<BITS>::_heap_start = nullptr;\n+template <int BITS>\n+size_t FullGCForwardingImpl<BITS>::_heap_start_region_bias = 0;\n+template <int BITS>\n+size_t FullGCForwardingImpl<BITS>::_num_regions = 0;\n+template <int BITS>\n+uintptr_t FullGCForwardingImpl<BITS>::_region_mask = 0;\n+template <int BITS>\n+HeapWord** FullGCForwardingImpl<BITS>::_biased_bases = nullptr;\n+template <int BITS>\n+HeapWord** FullGCForwardingImpl<BITS>::_bases_table = nullptr;\n+template <int BITS>\n+size_t FullGCForwardingImpl<BITS>::_fallback_table_log2_start_size = 9; \/\/ 512 entries.\n+template <int BITS>\n+FallbackTable* FullGCForwardingImpl<BITS>::_fallback_table = nullptr;\n+#ifndef PRODUCT\n+template <int BITS>\n+volatile uint64_t FullGCForwardingImpl<BITS>::_num_forwardings = 0;\n+template <int BITS>\n+volatile uint64_t FullGCForwardingImpl<BITS>::_num_fallback_forwardings = 0;\n+#endif\n+\n+template <int BITS>\n+bool FullGCForwardingImpl<BITS>::is_forwarded(oop obj) {\n@@ -37,2 +70,3 @@\n-size_t FullGCForwarding::biased_region_index_containing(HeapWord* addr) {\n-  return (uintptr_t)addr >> BLOCK_SIZE_BYTES_SHIFT;\n+template <int BITS>\n+size_t FullGCForwardingImpl<BITS>::biased_region_index_containing(HeapWord* addr) {\n+  return reinterpret_cast<uintptr_t>(addr) >> BLOCK_SIZE_BYTES_SHIFT;\n@@ -41,1 +75,2 @@\n-bool FullGCForwarding::is_fallback(uintptr_t encoded) {\n+template <int BITS>\n+bool FullGCForwardingImpl<BITS>::is_fallback(uintptr_t encoded) {\n@@ -45,1 +80,2 @@\n-uintptr_t FullGCForwarding::encode_forwarding(HeapWord* from, HeapWord* to) {\n+template <int BITS>\n+uintptr_t FullGCForwardingImpl<BITS>::encode_forwarding(HeapWord* from, HeapWord* to) {\n@@ -50,1 +86,7 @@\n-    _biased_bases[from_block_idx] = to_region_base = to;\n+    HeapWord* prev = Atomic::cmpxchg(&_biased_bases[from_block_idx], UNUSED_BASE, to);\n+    if (prev == UNUSED_BASE) {\n+      to_region_base = to;\n+    } else {\n+      to_region_base = prev;\n+    }\n+    \/\/ _biased_bases[from_block_idx] = to_region_base = to;\n@@ -52,1 +94,0 @@\n-\n@@ -57,1 +98,1 @@\n-  size_t offset = size_t(to - to_region_base);\n+  size_t offset = static_cast<size_t>(to - to_region_base);\n@@ -63,1 +104,1 @@\n-  assert(is_fallback(encoded) || to == decode_forwarding(from, encoded), \"must be reversible\");\n+  assert(is_fallback(encoded) || to == decode_forwarding(from, encoded), \"must be reversible: \" PTR_FORMAT \" -> \" PTR_FORMAT \", reversed: \" PTR_FORMAT \", encoded: \" INTPTR_FORMAT \", to_region_base: \" PTR_FORMAT \", from_block_idx: %lu\", p2i(from), p2i(to), p2i(decode_forwarding(from, encoded)), encoded, p2i(to_region_base), from_block_idx);\n@@ -68,1 +109,2 @@\n-HeapWord* FullGCForwarding::decode_forwarding(HeapWord* from, uintptr_t encoded) {\n+template <int BITS>\n+HeapWord* FullGCForwardingImpl<BITS>::decode_forwarding(HeapWord* from, uintptr_t encoded) {\n@@ -84,1 +126,2 @@\n-inline void FullGCForwarding::forward_to_impl(oop from, oop to) {\n+template <int BITS>\n+void FullGCForwardingImpl<BITS>::forward_to_impl(oop from, oop to) {\n@@ -100,1 +143,2 @@\n-inline void FullGCForwarding::forward_to(oop obj, oop fwd) {\n+template <int BITS>\n+void FullGCForwardingImpl<BITS>::forward_to(oop obj, oop fwd) {\n@@ -105,1 +149,1 @@\n-  assert(forwardee(obj) == fwd, \"must be forwarded to correct forwardee, obj: \" PTR_FORMAT \", forwardee(obj): \" PTR_FORMAT \", fwd: \" PTR_FORMAT \", mark: \" INTPTR_FORMAT, p2i(obj), p2i(forwardee(obj)), p2i(fwd), obj->mark().value());\n+  \/\/ assert(forwardee(obj) == fwd, \"must be forwarded to correct forwardee, obj: \" PTR_FORMAT \", forwardee(obj): \" PTR_FORMAT \", fwd: \" PTR_FORMAT \", mark: \" INTPTR_FORMAT \", num-regions: %lu, base: \" PTR_FORMAT \", OFFSET_MASK: \" INTPTR_FORMAT \", encoded: \" PTR_FORMAT \", biased-base: \" PTR_FORMAT \", heap-start: \" PTR_FORMAT, p2i(obj), p2i(forwardee(obj)), p2i(fwd), obj->mark().value(), _num_regions, p2i(_bases_table[0]), OFFSET_MASK, encode_forwarding(cast_from_oop<HeapWord*>(obj), cast_from_oop<HeapWord*>(fwd)), p2i(_biased_bases[biased_region_index_containing(cast_from_oop<HeapWord*>(obj))]), p2i(_heap_start));\n@@ -111,1 +155,2 @@\n-inline oop FullGCForwarding::forwardee_impl(oop from) {\n+template <int BITS>\n+oop FullGCForwardingImpl<BITS>::forwardee_impl(oop from) {\n@@ -125,1 +170,2 @@\n-inline oop FullGCForwarding::forwardee(oop obj) {\n+template <int BITS>\n+oop FullGCForwardingImpl<BITS>::forwardee(oop obj) {\n@@ -134,0 +180,169 @@\n+static uintx hash(HeapWord* const& addr) {\n+  uint64_t val = reinterpret_cast<uint64_t>(addr);\n+  uint32_t hash = FastHash::get_hash32(static_cast<uint32_t>(val), static_cast<uint32_t>(val >> 32));\n+  return hash;\n+}\n+\n+struct ForwardingEntry {\n+  HeapWord* _from;\n+  HeapWord* _to;\n+  ForwardingEntry(HeapWord* from, HeapWord* to) : _from(from), _to(to) {}\n+};\n+\n+struct FallbackTableConfig {\n+  using Value = ForwardingEntry;\n+  static uintx get_hash(Value const& entry, bool* is_dead) {\n+    return hash(entry._from);\n+  }\n+  static void* allocate_node(void* context, size_t size, Value const& value) {\n+    return AllocateHeap(size, mtGC);\n+  }\n+  static void free_node(void* context, void* memory, Value const& value) {\n+    FreeHeap(memory);\n+  }\n+};\n+\n+class FallbackTable : public ConcurrentHashTable<FallbackTableConfig, mtGC> {\n+public:\n+  explicit FallbackTable(size_t log2size) : ConcurrentHashTable(log2size) {}\n+};\n+\n+class FallbackTableLookup : public StackObj {\n+  ForwardingEntry const _entry;\n+public:\n+  explicit FallbackTableLookup(HeapWord* from) : _entry(from, nullptr) {}\n+  uintx get_hash() const {\n+    return hash(_entry._from);\n+  }\n+  bool equals(const ForwardingEntry* value) const {\n+    return _entry._from == value->_from;\n+  }\n+  static bool is_dead(ForwardingEntry* value) { return false; }\n+};\n+\n+template <int BITS>\n+void FullGCForwardingImpl<BITS>::initialize(MemRegion heap) {\n+#ifdef _LP64\n+  _heap_start = heap.start();\n+\n+  size_t rounded_heap_size = MAX2(round_up_power_of_2(heap.byte_size()) \/ BytesPerWord, BLOCK_SIZE_WORDS);\n+\n+  _num_regions = rounded_heap_size \/ BLOCK_SIZE_WORDS;\n+\n+  _heap_start_region_bias = reinterpret_cast<uintptr_t>(_heap_start) >> BLOCK_SIZE_BYTES_SHIFT;\n+  _region_mask = ~((static_cast<uintptr_t>(1) << BLOCK_SIZE_BYTES_SHIFT) - 1);\n+\n+  assert(_bases_table == nullptr, \"should not be initialized yet\");\n+  assert(_fallback_table == nullptr, \"should not be initialized yet\");\n+#endif\n+}\n+\n+template <int BITS>\n+void FullGCForwardingImpl<BITS>::begin() {\n+#ifdef _LP64\n+  assert(_bases_table == nullptr, \"should not be initialized yet\");\n+  assert(_fallback_table == nullptr, \"should not be initialized yet\");\n+\n+  _fallback_table = nullptr;\n+\n+#ifndef PRODUCT\n+  _num_forwardings = 0;\n+  _num_fallback_forwardings = 0;\n+#endif\n+\n+  size_t max = _num_regions;\n+  _bases_table = NEW_C_HEAP_ARRAY(HeapWord*, max, mtGC);\n+  HeapWord** biased_start = _bases_table - _heap_start_region_bias;\n+  _biased_bases = biased_start;\n+  if (max == 1) {\n+    \/\/ Optimize the case when the block-size >= heap-size.\n+    \/\/ In this case we can use the heap-start as block-start,\n+    \/\/ and don't risk that competing GC threads set a higher\n+    \/\/ address as block-start, which would lead to unnecessary\n+    \/\/ fallback-usage.\n+    _bases_table[0] = _heap_start;\n+  } else {\n+    for (size_t i = 0; i < max; i++) {\n+      _bases_table[i] = UNUSED_BASE;\n+    }\n+  }\n+#endif\n+}\n+\n+template <int BITS>\n+void FullGCForwardingImpl<BITS>::end() {\n+#ifndef PRODUCT\n+  size_t fallback_table_size = _fallback_table != nullptr ? _fallback_table->get_mem_size(Thread::current()) : 0;\n+  log_info(gc)(\"Total forwardings: \" UINT64_FORMAT \", fallback forwardings: \" UINT64_FORMAT\n+                \", ratio: %f, memory used by fallback table: %zu%s, memory used by bases table: %zu%s\",\n+               _num_forwardings, _num_fallback_forwardings, static_cast<float>(_num_forwardings) \/ static_cast<float>(_num_fallback_forwardings),\n+               byte_size_in_proper_unit(fallback_table_size),\n+               proper_unit_for_byte_size(fallback_table_size),\n+               byte_size_in_proper_unit(sizeof(HeapWord*) * _num_regions),\n+               proper_unit_for_byte_size(sizeof(HeapWord*) * _num_regions));\n+#endif\n+#ifdef _LP64\n+  assert(_bases_table != nullptr, \"should be initialized\");\n+  FREE_C_HEAP_ARRAY(HeapWord*, _bases_table);\n+  _bases_table = nullptr;\n+  if (_fallback_table != nullptr) {\n+    delete _fallback_table;\n+    _fallback_table = nullptr;\n+  }\n+#endif\n+}\n+\n+template <int BITS>\n+void FullGCForwardingImpl<BITS>::maybe_init_fallback_table() {\n+  if (_fallback_table == nullptr) {\n+    FallbackTable* fallback_table = new FallbackTable(_fallback_table_log2_start_size);\n+    FallbackTable* prev = Atomic::cmpxchg(&_fallback_table, static_cast<FallbackTable*>(nullptr), fallback_table);\n+    if (prev != nullptr) {\n+      \/\/ Another thread won, discard our table.\n+      delete fallback_table;\n+    }\n+  }\n+}\n+\n+template <int BITS>\n+void FullGCForwardingImpl<BITS>::fallback_forward_to(HeapWord* from, HeapWord* to) {\n+  assert(to != nullptr, \"no null forwarding\");\n+  maybe_init_fallback_table();\n+  assert(_fallback_table != nullptr, \"should be initialized\");\n+  FallbackTableLookup lookup_f(from);\n+  ForwardingEntry entry(from, to);\n+  auto found_f = [&](ForwardingEntry* found) {\n+    \/\/ If dupe has been found, override it with new value.\n+    \/\/ This is also called when new entry is succussfully inserted.\n+    if (found->_to != to) {\n+      found->_to = to;\n+    }\n+  };\n+  Thread* current_thread = Thread::current();\n+  bool grow;\n+  bool added = _fallback_table->insert_get(current_thread, lookup_f, entry, found_f, &grow);\n+  NOT_PRODUCT(Atomic::inc(&_num_fallback_forwardings);)\n+#ifdef ASSERT\n+  assert(fallback_forwardee(from) != nullptr, \"must have entered forwarding\");\n+  assert(fallback_forwardee(from) == to, \"forwarding must be correct, added: %s, from: \" PTR_FORMAT \", to: \" PTR_FORMAT \", fwd: \" PTR_FORMAT, BOOL_TO_STR(added), p2i(from), p2i(to), p2i(fallback_forwardee(from)));\n+#endif\n+  if (grow) {\n+    _fallback_table->grow(current_thread);\n+    log_debug(gc)(\"grow fallback table to size: %zu bytes\", _fallback_table->get_mem_size(current_thread));\n+  }\n+}\n+\n+template <int BITS>\n+HeapWord* FullGCForwardingImpl<BITS>::fallback_forwardee(HeapWord* from) {\n+  assert(_fallback_table != nullptr, \"fallback table must be present\");\n+  HeapWord* result;\n+  FallbackTableLookup lookup_f(from);\n+  auto found_f = [&](const ForwardingEntry* found) {\n+    result = found->_to;\n+  };\n+  bool found = _fallback_table->get(Thread::current(), lookup_f, found_f);\n+  assert(found, \"something must have been found\");\n+  assert(result != nullptr, \"must have found forwarding\");\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/fullGCForwarding.inline.hpp","additions":231,"deletions":16,"binary":false,"changes":247,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-  bool                _tlab_end_reset_for_sample;\n@@ -77,2 +76,1 @@\n-      _allocated_tlab_size(0),\n-      _tlab_end_reset_for_sample(false)\n+      _allocated_tlab_size(0)\n@@ -177,5 +175,2 @@\n-  if (!_allocated_outside_tlab && _allocated_tlab_size == 0 && !_tlab_end_reset_for_sample) {\n-    \/\/ Sample if it's a non-TLAB allocation, or a TLAB allocation that either refills the TLAB\n-    \/\/ or expands it due to taking a sampler induced slow path.\n-    return;\n-  }\n+  ThreadHeapSampler& heap_sampler = _thread->heap_sampler();\n+  ThreadLocalAllocBuffer& tlab = _thread->tlab();\n@@ -183,4 +178,2 @@\n-  \/\/ If we want to be sampling, protect the allocated object with a Handle\n-  \/\/ before doing the callback. The callback is done in the destructor of\n-  \/\/ the JvmtiSampledObjectAllocEventCollector.\n-  size_t bytes_since_last = 0;\n+  \/\/ Log sample decision\n+  heap_sampler.log_sample_decision(tlab.top());\n@@ -188,1 +181,4 @@\n-  {\n+  if (heap_sampler.should_sample(tlab.top())) {\n+    \/\/ If we want to be sampling, protect the allocated object with a Handle\n+    \/\/ before doing the callback. The callback is done in the destructor of\n+    \/\/ the JvmtiSampledObjectAllocEventCollector.\n@@ -191,5 +187,2 @@\n-    size_t size_in_bytes = _allocator._word_size * HeapWordSize;\n-    ThreadLocalAllocBuffer& tlab = _thread->tlab();\n-    if (!_allocated_outside_tlab) {\n-      bytes_since_last = tlab.bytes_since_last_sample_point();\n-    }\n+    \/\/ Perform the sampling\n+    heap_sampler.sample(obj_h(), tlab.top());\n@@ -198,1 +191,3 @@\n-    _thread->heap_sampler().check_for_sampling(obj_h(), size_in_bytes, bytes_since_last);\n+    \/\/ Note that after this point all the TLAB can have been retired, and agent\n+    \/\/ code can run and allocate, don't rely on earlier calculations involving\n+    \/\/ the TLAB.\n@@ -201,3 +196,4 @@\n-  if (_tlab_end_reset_for_sample || _allocated_tlab_size != 0) {\n-    \/\/ Tell tlab to forget bytes_since_last if we passed it to the heap sampler.\n-    _thread->tlab().set_sample_end(bytes_since_last != 0);\n+  \/\/ Set a new sampling point in the TLAB if it fits in the current TLAB\n+  const size_t words_until_sample = heap_sampler.bytes_until_sample(tlab.top()) \/ HeapWordSize;\n+  if (words_until_sample <= tlab.free()) {\n+    tlab.set_sampling_point(tlab.top() + words_until_sample);\n@@ -252,0 +248,1 @@\n+  _thread->heap_sampler().inc_outside_tlab_bytes(size_in_bytes);\n@@ -265,0 +262,6 @@\n+    \/\/ When sampling we artificially set the TLAB end to the sample point.\n+    \/\/ When we hit that point it looks like the TLAB is full, but it's\n+    \/\/ not necessarily the case. Set the real end and retry the allocation.\n+\n+    \/\/ Undo previous adjustment of end.\n+    \/\/ Note that notify_allocation_jvmti_sampler will set a new sample point.\n@@ -266,4 +269,2 @@\n-    mem = tlab.allocate(_word_size);\n-    \/\/ We set back the allocation sample point to try to allocate this, reset it\n-    \/\/ when done.\n-    allocation._tlab_end_reset_for_sample = true;\n+    \/\/ Retry the TLAB allocation with the proper end\n+    mem = tlab.allocate(_word_size);\n@@ -285,0 +286,7 @@\n+\n+  \/\/ Record the amount wasted\n+  tlab.record_refill_waste();\n+\n+  \/\/ Retire the current TLAB\n+  _thread->retire_tlab();\n+\n@@ -288,2 +296,0 @@\n-  tlab.retire_before_allocation();\n-\n@@ -320,1 +326,2 @@\n-  tlab.fill(mem, mem + _word_size, allocation._allocated_tlab_size);\n+  _thread->fill_tlab(mem, _word_size, allocation._allocated_tlab_size);\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":36,"deletions":29,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+class CollectedHeap;\n@@ -118,0 +119,1 @@\n+  friend class CollectedHeap;\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedup.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+class CollectedHeap;\n@@ -45,0 +46,2 @@\n+  friend class CollectedHeap;\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupProcessor.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_VMTHREADCPUTIMESCOPE_HPP\n+#define SHARE_GC_SHARED_VMTHREADCPUTIMESCOPE_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+\n+class VMThread;\n+\n+class VMThreadCPUTimeScope : public StackObj {\n+private:\n+  jlong   _start;\n+  bool    _enabled;\n+  bool    _is_gc_operation;\n+  VMThread* _thread;\n+\n+public:\n+  VMThreadCPUTimeScope(VMThread* thread, bool is_gc_operation);\n+  ~VMThreadCPUTimeScope();\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_VMTHREADCPUTIMESCOPE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/vmThreadCpuTimeScope.hpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"gc\/shared\/vmThreadCpuTimeScope.hpp\"\n+\n+#include \"gc\/shared\/collectedHeap.inline.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"runtime\/cpuTimeCounters.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+\n+inline VMThreadCPUTimeScope::VMThreadCPUTimeScope(VMThread* thread, bool is_gc_operation)\n+  : _start(0),\n+    _enabled(os::is_thread_cpu_time_supported()),\n+    _is_gc_operation(is_gc_operation),\n+    _thread(thread) {\n+  if (_is_gc_operation && _enabled) {\n+    _start = os::thread_cpu_time(_thread);\n+  }\n+}\n+\n+inline VMThreadCPUTimeScope::~VMThreadCPUTimeScope() {\n+  if (!_enabled) {\n+    return;\n+  }\n+\n+  jlong end = (_is_gc_operation || UsePerfData) ? os::thread_cpu_time(_thread) : 0;\n+\n+  if (_is_gc_operation) {\n+    jlong duration = end > _start ? end - _start : 0;\n+    Universe::heap()->add_vmthread_cpu_time(duration);\n+  }\n+\n+  if (UsePerfData) {\n+    CPUTimeCounters::update_counter(CPUTimeGroups::CPUTimeType::vm, end);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/vmThreadCpuTimeScope.inline.hpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -277,1 +277,1 @@\n-  _pre_barrier_c1_runtime_code_blob = Runtime1::generate_blob(buffer_blob, C1StubId::NO_STUBID,\n+  _pre_barrier_c1_runtime_code_blob = Runtime1::generate_blob(buffer_blob, StubId::NO_STUBID,\n@@ -285,1 +285,1 @@\n-    _load_reference_barrier_strong_rt_code_blob = Runtime1::generate_blob(buffer_blob, C1StubId::NO_STUBID,\n+    _load_reference_barrier_strong_rt_code_blob = Runtime1::generate_blob(buffer_blob, StubId::NO_STUBID,\n@@ -293,1 +293,1 @@\n-    _load_reference_barrier_strong_native_rt_code_blob = Runtime1::generate_blob(buffer_blob, C1StubId::NO_STUBID,\n+    _load_reference_barrier_strong_native_rt_code_blob = Runtime1::generate_blob(buffer_blob, StubId::NO_STUBID,\n@@ -301,1 +301,1 @@\n-    _load_reference_barrier_weak_rt_code_blob = Runtime1::generate_blob(buffer_blob, C1StubId::NO_STUBID,\n+    _load_reference_barrier_weak_rt_code_blob = Runtime1::generate_blob(buffer_blob, StubId::NO_STUBID,\n@@ -309,1 +309,1 @@\n-    _load_reference_barrier_phantom_rt_code_blob = Runtime1::generate_blob(buffer_blob, C1StubId::NO_STUBID,\n+    _load_reference_barrier_phantom_rt_code_blob = Runtime1::generate_blob(buffer_blob, StubId::NO_STUBID,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-  size_t capacity    = _space_info->soft_max_capacity();\n+  size_t capacity    = ShenandoahHeap::heap()->soft_max_capacity();\n@@ -236,1 +236,1 @@\n-  size_t capacity = _space_info->soft_max_capacity();\n+  size_t capacity = ShenandoahHeap::heap()->soft_max_capacity();\n@@ -352,4 +352,1 @@\n-  \/\/ Note that soft_max_capacity() \/ 100 * min_free_threshold is smaller than max_capacity() \/ 100 * min_free_threshold.\n-  \/\/ We want to behave conservatively here, so use max_capacity().  By returning a larger value, we cause the GC to\n-  \/\/ trigger when the remaining amount of free shrinks below the larger threshold.\n-  return _space_info->max_capacity() \/ 100 * ShenandoahMinFreeThreshold;\n+  return ShenandoahHeap::heap()->soft_max_capacity() \/ 100 * ShenandoahMinFreeThreshold;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  size_t capacity = _space_info->soft_max_capacity();\n+  size_t capacity = ShenandoahHeap::heap()->soft_max_capacity();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  size_t capacity = heap->young_generation()->max_capacity();\n+  size_t capacity = heap->soft_max_capacity();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGlobalHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  virtual size_t soft_max_capacity() const = 0;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  size_t capacity = _space_info->soft_max_capacity();\n+  size_t capacity = ShenandoahHeap::heap()->soft_max_capacity();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-  size_t capacity = heap->young_generation()->max_capacity();\n+  size_t capacity = heap->soft_max_capacity();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-  if (FLAG_IS_DEFAULT(TLABAllocationWeight)) {\n+  if (strcmp(ShenandoahGCMode, \"generational\") && FLAG_IS_DEFAULT(TLABAllocationWeight)) {\n@@ -189,0 +189,1 @@\n+  \/\/ In generational mode, let TLABAllocationWeight keeps its default value of 35.\n@@ -217,0 +218,4 @@\n+\n+  if (FLAG_IS_DEFAULT(TLABSize)) {\n+    TLABSize = MAX2(ShenandoahHeapRegion::region_size_bytes() \/ 256, (size_t) 32 * 1024);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -67,1 +67,3 @@\n-  msg.append(\"  \" PTR_FORMAT \" - klass \" PTR_FORMAT \" %s\\n\", p2i(obj), p2i(obj->klass()), obj->klass()->external_name());\n+  Klass* obj_klass = ShenandoahForwarding::klass(obj);\n+\n+  msg.append(\"  \" PTR_FORMAT \" - klass \" PTR_FORMAT \" %s\\n\", p2i(obj), p2i(obj_klass), obj_klass->external_name());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-  const size_t v_soft_max_capacity = soft_max_capacity();\n+  const size_t v_soft_max_capacity = ShenandoahHeap::heap()->soft_max_capacity();\n@@ -802,2 +802,1 @@\n-                                           size_t max_capacity,\n-                                           size_t soft_max_capacity) :\n+                                           size_t max_capacity) :\n@@ -809,1 +808,1 @@\n-  _max_capacity(max_capacity), _soft_max_capacity(soft_max_capacity),\n+  _max_capacity(max_capacity),\n@@ -955,1 +954,1 @@\n-  return available(soft_max_capacity());\n+  return available(ShenandoahHeap::heap()->soft_max_capacity());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-  size_t _soft_max_capacity;\n@@ -108,2 +107,1 @@\n-                       size_t max_capacity,\n-                       size_t soft_max_capacity);\n+                       size_t max_capacity);\n@@ -129,1 +127,0 @@\n-  size_t soft_max_capacity() const override { return _soft_max_capacity; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,15 +56,0 @@\n-\n-  void print_heap() override {\n-    ShenandoahInitLogger::print_heap();\n-\n-    ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n-\n-    ShenandoahYoungGeneration* young = heap->young_generation();\n-    log_info(gc, init)(\"Young Generation Soft Size: \" EXACTFMT, EXACTFMTARGS(young->soft_max_capacity()));\n-    log_info(gc, init)(\"Young Generation Max: \" EXACTFMT, EXACTFMTARGS(young->max_capacity()));\n-\n-    ShenandoahOldGeneration* old = heap->old_generation();\n-    log_info(gc, init)(\"Old Generation Soft Size: \" EXACTFMT, EXACTFMTARGS(old->soft_max_capacity()));\n-    log_info(gc, init)(\"Old Generation Max: \" EXACTFMT, EXACTFMTARGS(old->max_capacity()));\n-  }\n-\n@@ -144,2 +129,2 @@\n-  _young_generation = new ShenandoahYoungGeneration(max_workers(), max_capacity_young, initial_capacity_young);\n-  _old_generation = new ShenandoahOldGeneration(max_workers(), max_capacity_old, initial_capacity_old);\n+  _young_generation = new ShenandoahYoungGeneration(max_workers(), max_capacity_young);\n+  _old_generation = new ShenandoahOldGeneration(max_workers(), max_capacity_old);\n@@ -186,0 +171,23 @@\n+bool ShenandoahGenerationalHeap::requires_barriers(stackChunkOop obj) const {\n+  if (is_idle()) {\n+    return false;\n+  }\n+\n+  if (is_concurrent_young_mark_in_progress() && is_in_young(obj) && !marking_context()->allocated_after_mark_start(obj)) {\n+    \/\/ We are marking young, this object is in young, and it is below the TAMS\n+    return true;\n+  }\n+\n+  if (is_in_old(obj)) {\n+    \/\/ Card marking barriers are required for objects in the old generation\n+    return true;\n+  }\n+\n+  if (has_forwarded_objects()) {\n+    \/\/ Object may have pointers that need to be updated\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+  void print_tracing_info() const override;\n+  void stop() override;\n+\n@@ -56,1 +59,0 @@\n-  void print_tracing_info() const override;\n@@ -129,1 +131,1 @@\n-  void stop() override;\n+  bool requires_barriers(stackChunkOop obj) const override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,4 +53,0 @@\n-size_t ShenandoahGlobalGeneration::soft_max_capacity() const {\n-  return ShenandoahHeap::heap()->soft_max_capacity();\n-}\n-\n@@ -68,2 +64,2 @@\n-  assert(max_capacity() >= soft_max_capacity(), \"Max capacity must be greater than soft max capacity.\");\n-  size_t soft_tail = max_capacity() - soft_max_capacity();\n+  assert(max_capacity() >= ShenandoahHeap::heap()->soft_max_capacity(), \"Max capacity must be greater than soft max capacity.\");\n+  size_t soft_tail = max_capacity() - ShenandoahHeap::heap()->soft_max_capacity();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-  ShenandoahGlobalGeneration(bool generational, uint max_queues, size_t max_capacity, size_t soft_max_capacity)\n-  : ShenandoahGeneration(generational ? GLOBAL : NON_GEN, max_queues, max_capacity, soft_max_capacity) { }\n+  ShenandoahGlobalGeneration(bool generational, uint max_queues, size_t max_capacity)\n+  : ShenandoahGeneration(generational ? GLOBAL : NON_GEN, max_queues, max_capacity) { }\n@@ -42,1 +42,0 @@\n-  size_t soft_max_capacity() const override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/shared\/fullGCForwarding.hpp\"\n+#include \"gc\/shared\/fullGCForwarding.inline.hpp\"\n@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -204,2 +205,1 @@\n-  \/\/ Default to max heap size.\n-  _soft_max_size = _num_regions * reg_size_bytes;\n+  _soft_max_size = SoftMaxHeapSize;\n@@ -527,1 +527,1 @@\n-  _global_generation = new ShenandoahGlobalGeneration(mode()->is_generational(), max_workers(), max_capacity(), max_capacity());\n+  _global_generation = new ShenandoahGlobalGeneration(mode()->is_generational(), max_workers(), max_capacity());\n@@ -1248,1 +1248,1 @@\n-class ShenandoahGCStatePropagator : public HandshakeClosure {\n+class ShenandoahGCStatePropagatorHandshakeClosure : public HandshakeClosure {\n@@ -1250,1 +1250,1 @@\n-  explicit ShenandoahGCStatePropagator(char gc_state) :\n+  explicit ShenandoahGCStatePropagatorHandshakeClosure(char gc_state) :\n@@ -1261,1 +1261,1 @@\n-class ShenandoahPrepareForUpdateRefs : public HandshakeClosure {\n+class ShenandoahPrepareForUpdateRefsHandshakeClosure : public HandshakeClosure {\n@@ -1263,1 +1263,1 @@\n-  explicit ShenandoahPrepareForUpdateRefs(char gc_state) :\n+  explicit ShenandoahPrepareForUpdateRefsHandshakeClosure(char gc_state) :\n@@ -1275,1 +1275,1 @@\n-  ShenandoahGCStatePropagator _propagator;\n+  ShenandoahGCStatePropagatorHandshakeClosure _propagator;\n@@ -1298,1 +1298,1 @@\n-  ShenandoahPrepareForUpdateRefs prepare_for_update_refs(_gc_state.raw_value());\n+  ShenandoahPrepareForUpdateRefsHandshakeClosure prepare_for_update_refs(_gc_state.raw_value());\n@@ -1330,1 +1330,1 @@\n-  ShenandoahGCStatePropagator propagator(_gc_state.raw_value());\n+  ShenandoahGCStatePropagatorHandshakeClosure propagator(_gc_state.raw_value());\n@@ -1509,0 +1509,3 @@\n+    if (ZeroTLAB) {\n+      t->retire_tlab();\n+    }\n@@ -1526,2 +1529,1 @@\n-    ThreadLocalAllocBuffer& tlab = t->tlab();\n-    tlab.retire(&stats);\n+    t->retire_tlab(&stats);\n@@ -1529,1 +1531,1 @@\n-      tlab.resize();\n+      t->tlab().resize();\n@@ -2028,1 +2030,1 @@\n-class ShenandoahRendezvousClosure : public HandshakeClosure {\n+class ShenandoahRendezvousHandshakeClosure : public HandshakeClosure {\n@@ -2030,1 +2032,1 @@\n-  inline ShenandoahRendezvousClosure(const char* name) : HandshakeClosure(name) {}\n+  inline ShenandoahRendezvousHandshakeClosure(const char* name) : HandshakeClosure(name) {}\n@@ -2035,1 +2037,1 @@\n-  ShenandoahRendezvousClosure cl(name);\n+  ShenandoahRendezvousHandshakeClosure cl(name);\n@@ -2077,1 +2079,1 @@\n-    ShenandoahGCStatePropagator propagator(_gc_state.raw_value());\n+    ShenandoahGCStatePropagatorHandshakeClosure propagator(_gc_state.raw_value());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -162,0 +162,4 @@\n+protected:\n+  void print_tracing_info() const override;\n+  void stop() override;\n+\n@@ -207,1 +211,0 @@\n-  void print_tracing_info()                    const override;\n@@ -210,2 +213,0 @@\n-  void stop() override;\n-\n@@ -617,2 +618,0 @@\n-  bool is_maximal_no_gc() const override shenandoah_not_implemented_return(false);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+  log_info(gc, init)(\"Soft Max Heap Size: \" EXACTFMT, EXACTFMTARGS(ShenandoahHeap::heap()->soft_max_capacity()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahInitLogger.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-  size_t free_expected = (generation->max_capacity() \/ 100) * ShenandoahCriticalFreeThreshold;\n+  size_t free_expected = (ShenandoahHeap::heap()->soft_max_capacity() \/ 100) * ShenandoahCriticalFreeThreshold;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMetrics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -199,2 +199,2 @@\n-ShenandoahOldGeneration::ShenandoahOldGeneration(uint max_queues, size_t max_capacity, size_t soft_max_capacity)\n-  : ShenandoahGeneration(OLD, max_queues, max_capacity, soft_max_capacity),\n+ShenandoahOldGeneration::ShenandoahOldGeneration(uint max_queues, size_t max_capacity)\n+  : ShenandoahGeneration(OLD, max_queues, max_capacity),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-  ShenandoahOldGeneration(uint max_queues, size_t max_capacity, size_t soft_max_capacity);\n+  ShenandoahOldGeneration(uint max_queues, size_t max_capacity);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -627,1 +627,1 @@\n-  CardValue* end_bp = &(new_ptr)[_card_table->last_valid_index()];\n+  CardValue* end_bp = &(start_bp[_card_table->last_valid_index()]);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-ShenandoahYoungGeneration::ShenandoahYoungGeneration(uint max_queues, size_t max_capacity, size_t soft_max_capacity) :\n-  ShenandoahGeneration(YOUNG, max_queues, max_capacity, soft_max_capacity),\n+ShenandoahYoungGeneration::ShenandoahYoungGeneration(uint max_queues, size_t max_capacity) :\n+  ShenandoahGeneration(YOUNG, max_queues, max_capacity),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  ShenandoahYoungGeneration(uint max_queues, size_t max_capacity, size_t max_soft_capacity);\n+  ShenandoahYoungGeneration(uint max_queues, size_t max_capacity);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -509,1 +509,1 @@\n-  CodeBlob* const code_blob = Runtime1::generate_blob(blob, C1StubId::NO_STUBID \/* stub_id *\/, name, false \/* expect_oop_map*\/, &cl);\n+  CodeBlob* const code_blob = Runtime1::generate_blob(blob, StubId::NO_STUBID \/* stub_id *\/, name, false \/* expect_oop_map*\/, &cl);\n@@ -529,1 +529,1 @@\n-  CodeBlob* const code_blob = Runtime1::generate_blob(blob, C1StubId::NO_STUBID \/* stub_id *\/, name, false \/* expect_oop_map*\/, &cl);\n+  CodeBlob* const code_blob = Runtime1::generate_blob(blob, StubId::NO_STUBID \/* stub_id *\/, name, false \/* expect_oop_map*\/, &cl);\n","filename":"src\/hotspot\/share\/gc\/z\/c1\/zBarrierSetC1.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,0 +58,3 @@\n+  void print_tracing_info() const override;\n+  void stop() override;\n+\n@@ -66,1 +69,0 @@\n-  void stop() override;\n@@ -73,1 +75,0 @@\n-  bool is_maximal_no_gc() const override;\n@@ -120,1 +121,0 @@\n-  void print_tracing_info() const override;\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -494,1 +494,1 @@\n-    return _shared[static_cast<uint>(age) - 1];\n+    return _shared[untype(age - 1)];\n@@ -498,1 +498,1 @@\n-    _shared[static_cast<uint>(age) - 1] = page;\n+    _shared[untype(age - 1)] = page;\n@@ -576,1 +576,1 @@\n-    return _target[static_cast<uint>(age) - 1];\n+    return _target[untype(age - 1)];\n@@ -580,1 +580,1 @@\n-    _target[static_cast<uint>(age) - 1] = page;\n+    _target[untype(age - 1)] = page;\n@@ -1246,1 +1246,1 @@\n-  const uint age = static_cast<uint>(from_age);\n+  const uint age = untype(from_age);\n@@ -1251,1 +1251,1 @@\n-  return static_cast<ZPageAge>(age + 1);\n+  return to_zpageage(age + 1);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"classfile\/classFileStream.hpp\"\n@@ -26,0 +27,1 @@\n+#include \"classfile\/moduleEntry.hpp\"\n@@ -30,0 +32,1 @@\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp\"\n@@ -31,0 +34,1 @@\n+#include \"jfr\/support\/methodtracer\/jfrTracedMethod.hpp\"\n@@ -39,0 +43,1 @@\n+#include \"runtime\/javaCalls.hpp\"\n@@ -40,0 +45,1 @@\n+#include \"runtime\/jniHandles.inline.hpp\"\n@@ -50,0 +56,4 @@\n+static Symbol* on_method_trace_sym = nullptr;\n+static Symbol* on_method_trace_sig_sym = nullptr;\n+static Symbol* publish_method_timers_for_klass_sym = nullptr;\n+static Symbol* publish_method_timers_for_klass_sig_sym = nullptr;\n@@ -62,1 +72,5 @@\n-    initialized = unhide_internal_types_sig_sym != nullptr;\n+    on_method_trace_sym = SymbolTable::new_permanent_symbol(\"onMethodTrace\");\n+    on_method_trace_sig_sym = SymbolTable::new_permanent_symbol(\"(Ljava\/lang\/Module;Ljava\/lang\/ClassLoader;Ljava\/lang\/String;[B[J[Ljava\/lang\/String;[Ljava\/lang\/String;[I)[B\");\n+    publish_method_timers_for_klass_sym = SymbolTable::new_permanent_symbol(\"publishMethodTimersForClass\");\n+    publish_method_timers_for_klass_sig_sym = SymbolTable::new_permanent_symbol(\"(J)V\");\n+    initialized = publish_method_timers_for_klass_sig_sym != nullptr;\n@@ -210,0 +224,100 @@\n+\n+\/\/ Caller needs ResourceMark\n+ClassFileStream* JfrUpcalls::on_method_trace(InstanceKlass* ik, const ClassFileStream* stream, GrowableArray<JfrTracedMethod>* methods, TRAPS) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n+  assert(stream != nullptr, \"invariant\");\n+  assert(methods != nullptr, \"invariant\");\n+  assert(methods->is_nonempty(), \"invariant\");\n+  initialize(THREAD);\n+  Klass* klass = SystemDictionary::resolve_or_fail(jvm_upcalls_class_sym, true, CHECK_NULL);\n+  assert(klass != nullptr, \"invariant\");\n+\n+  HandleMark hm(THREAD);\n+\n+  ModuleEntry* module_entry = ik->module();\n+  oop module = nullptr;\n+  if (module_entry != nullptr) {\n+    module = module_entry->module_oop();\n+  }\n+  instanceHandle module_handle(THREAD, (instanceOop)module);\n+\n+  \/\/ ClassLoader\n+  oop class_loader = ik->class_loader();\n+  instanceHandle class_loader_handle(THREAD, (instanceOop)class_loader);\n+\n+  \/\/ String class name\n+  Handle class_name_h = java_lang_String::create_from_symbol(ik->name(), CHECK_NULL);\n+\n+  \/\/ new byte[]\n+  int size = stream->length();\n+  typeArrayOop bytecode_array = oopFactory::new_byteArray(size, CHECK_NULL);\n+  typeArrayHandle h_bytecode_array(THREAD, bytecode_array);\n+\n+  \/\/ Copy ClassFileStream bytes to byte[]\n+  const jbyte* src = reinterpret_cast<const jbyte*>(stream->buffer());\n+  ArrayAccess<>::arraycopy_from_native(src, bytecode_array, typeArrayOopDesc::element_offset<jbyte>(0), size);\n+\n+  int method_count = methods->length();\n+\n+  \/\/ new long[method_count]\n+  typeArrayOop id_array = oopFactory::new_longArray(method_count, CHECK_NULL);\n+  typeArrayHandle h_id_array(THREAD, id_array);\n+\n+  \/\/ new String[method_count]\n+  objArrayOop name_array = oopFactory::new_objArray(vmClasses::String_klass(), method_count, CHECK_NULL);\n+  objArrayHandle h_name_array(THREAD, name_array);\n+\n+  \/\/ new String[method_count]\n+  objArrayOop signature_array = oopFactory::new_objArray(vmClasses::String_klass(), method_count, CHECK_NULL);\n+  objArrayHandle h_signature_array(THREAD, signature_array);\n+\n+   \/\/ new int[method_count]\n+  typeArrayOop modification_array = oopFactory::new_intArray(method_count, CHECK_NULL);\n+  typeArrayHandle h_modification_array(THREAD, modification_array);\n+\n+  \/\/ Fill in arrays\n+  for (int i = 0; i < method_count; i++) {\n+    JfrTracedMethod method = methods->at(i);\n+    h_id_array->long_at_put(i, method.id());\n+    Handle name = java_lang_String::create_from_symbol(method.name(), CHECK_NULL);\n+    h_name_array->obj_at_put(i, name());\n+    Handle signature = java_lang_String::create_from_symbol(method.signature(), CHECK_NULL);\n+    h_signature_array->obj_at_put(i, signature());\n+    h_modification_array->int_at_put(i, method.modification());\n+  }\n+\n+  \/\/ Call JVMUpcalls::onMethodTrace\n+  JavaCallArguments args;\n+  JavaValue result(T_ARRAY);\n+  args.push_oop(module_handle);\n+  args.push_oop(class_loader_handle);\n+  args.push_oop(class_name_h);\n+  args.push_oop(h_bytecode_array);\n+  args.push_oop(h_id_array);\n+  args.push_oop(h_name_array);\n+  args.push_oop(h_signature_array);\n+  args.push_oop(h_modification_array);\n+  JavaCalls::call_static(&result, klass, on_method_trace_sym, on_method_trace_sig_sym, &args, CHECK_NULL);\n+\n+  oop return_object = result.get_oop();\n+  if (return_object != nullptr) {\n+    assert(return_object->is_typeArray(), \"invariant\");\n+    assert(TypeArrayKlass::cast(return_object->klass())->element_type() == T_BYTE, \"invariant\");\n+    typeArrayOop byte_array = typeArrayOop(return_object);\n+    int length = byte_array->length();\n+    u1* buffer = NEW_RESOURCE_ARRAY_IN_THREAD_RETURN_NULL(THREAD, u1, length);\n+    ArrayAccess<>::arraycopy_to_native<>(byte_array, typeArrayOopDesc::element_offset<jbyte>(0), buffer, length);\n+    return new ClassFileStream(buffer, length, stream->source(), stream->from_boot_loader_modules_image());\n+  }\n+  return nullptr;\n+}\n+\n+void JfrUpcalls::publish_method_timers_for_klass(traceid klass_id, TRAPS) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n+  Klass* const klass = SystemDictionary::resolve_or_fail(jvm_upcalls_class_sym, true, CHECK);\n+  assert(klass != nullptr, \"invariant\");\n+  JavaCallArguments args;\n+  JavaValue result(T_VOID);\n+  args.push_long(static_cast<jlong>(klass_id));\n+  JavaCalls::call_static(&result, klass, publish_method_timers_for_klass_sym, publish_method_timers_for_klass_sig_sym, &args, CHECK);\n+}\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrUpcalls.cpp","additions":115,"deletions":1,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -713,0 +713,5 @@\n+  <Event name=\"SafepointLatency\" category=\"Java Virtual Machine, Runtime, Safepoint\" label=\"Safepoint Latency\"\n+    description=\"The delay for a thread to reach its next safepoint poll instruction after receiving an asynchronous sampling interrupt\" thread=\"true\" stackTrace=\"true\" throttle=\"true\">\n+    <Field type=\"VMThreadState\" name=\"threadState\" label=\"VM Thread State\" \/>\n+  <\/Event>\n+\n@@ -946,1 +951,2 @@\n-  <Event name=\"ExecutionSample\" category=\"Java Virtual Machine, Profiling\" label=\"Method Profiling Sample\" description=\"Snapshot of a threads state\"\n+  <Event name=\"ExecutionSample\" category=\"Java Virtual Machine, Profiling\" label=\"Java Execution Sample\"\n+         description=\"Snapshot of a thread executing Java code. Threads that are not executing Java code, including those waiting or executing native code, are not included.\"\n@@ -953,1 +959,2 @@\n-  <Event name=\"NativeMethodSample\" category=\"Java Virtual Machine, Profiling\" label=\"Method Profiling Sample Native\" description=\"Snapshot of a threads state when in native\"\n+  <Event name=\"NativeMethodSample\" category=\"Java Virtual Machine, Profiling\" label=\"Native Sample\"\n+         description=\"Snapshot of a thread in native code, executing or waiting. Threads that are executing Java code are not included.\"\n@@ -960,0 +967,16 @@\n+  <Event name=\"CPUTimeSample\" category=\"Java Virtual Machine, Profiling\" label=\"CPU Time Sample\"\n+    description=\"Snapshot of a threads state from the CPU time sampler, both threads executing native and Java code are included. The throttle setting can be either an upper bound for the event emission rate, e.g. 100\/s, or the cpu-time period, e.g. 10ms, with s, ms, us and ns supported as time units.\"\n+    throttle=\"true\" thread=\"false\" experimental=\"true\" startTime=\"false\">\n+    <Field type=\"StackTrace\" name=\"stackTrace\" label=\"Stack Trace\" \/>\n+    <Field type=\"Thread\" name=\"eventThread\" label=\"Thread\" \/>\n+    <Field type=\"boolean\" name=\"failed\" label=\"Failed\" description=\"Failed to obtain the stack trace\" \/>\n+    <Field type=\"Tickspan\" name=\"samplingPeriod\" label=\"CPU Time Sampling Period\"\/>\n+    <Field type=\"boolean\" name=\"biased\" label=\"Biased\" description=\"The sample is safepoint-biased\" \/>\n+  <\/Event>\n+\n+  <Event name=\"CPUTimeSamplesLost\" category=\"Java Virtual Machine, Profiling\" label=\"CPU Time Samples Lost\" description=\"Records that the CPU time sampler lost samples\"\n+    thread=\"false\" stackTrace=\"false\" startTime=\"false\" experimental=\"true\">\n+    <Field type=\"int\" name=\"lostSamples\" label=\"Lost Samples\" \/>\n+    <Field type=\"Thread\" name=\"eventThread\" label=\"Thread\" \/>\n+  <\/Event>\n+\n@@ -1290,0 +1313,12 @@\n+  <Event name=\"MethodTrace\" category=\"Java Application\" label=\"Method Trace\" thread=\"true\" stackTrace=\"true\" startTime=\"true\">\n+    <Field type=\"Method\" name=\"method\" label=\"Method\" \/>\n+  <\/Event>\n+\n+  <Event name=\"MethodTiming\" category=\"Java Application\" label=\"Method Timing\" thread=\"false\" stackTrace=\"false\" startTime=\"false\" period=\"everyChunk\">\n+    <Field type=\"Method\" name=\"method\" label=\"Method\" \/>\n+    <Field type=\"long\" name=\"invocations\" label=\"Invocations\" description=\"The number of times the method was invoked\" \/>\n+    <Field type=\"Tickspan\" name=\"minimum\" label=\"Minimum\" description=\"An approximation of the minimum wall-clock time it took for the method to execute\" \/>\n+    <Field type=\"Tickspan\" name=\"average\" label=\"Average\" description=\"An approximation of the average wall-clock time it took for the method to execute\" \/>\n+    <Field type=\"Tickspan\" name=\"maximum\" label=\"Maximum\" description=\"An approximation of the maximum wall-clock time it took for the method to execute\" \/>\n+  <\/Event>\n+\n@@ -1298,0 +1333,4 @@\n+  <Type name=\"VMThreadState\" label=\"JVM Thread State\">\n+    <Field type=\"string\" name=\"state\" label=\"State\" \/>\n+  <\/Type>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":41,"deletions":2,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-  const JvmtiAgentList::Iterator it =JvmtiAgentList::java_agents();\n+  JvmtiAgentList::Iterator it = JvmtiAgentList::java_agents();\n@@ -303,1 +303,1 @@\n-static void send_native_agent_events(const JvmtiAgentList::Iterator& it) {\n+static void send_native_agent_events(JvmtiAgentList::Iterator& it) {\n@@ -314,1 +314,1 @@\n-  const JvmtiAgentList::Iterator native_agents_it = JvmtiAgentList::native_agents();\n+  JvmtiAgentList::Iterator native_agents_it = JvmtiAgentList::native_agents();\n@@ -316,1 +316,1 @@\n-  const JvmtiAgentList::Iterator xrun_agents_it = JvmtiAgentList::xrun_agents();\n+  JvmtiAgentList::Iterator xrun_agents_it = JvmtiAgentList::xrun_agents();\n@@ -324,0 +324,4 @@\n+TRACE_REQUEST_FUNC(MethodTiming) {\n+  \/\/ Emitted in Java, but defined in native to have Method type field.\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), \"JVMCI is not enabled\")\n+    THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), JVMCI_NOT_ENABLED_ERROR_MESSAGE)\n@@ -147,1 +147,1 @@\n-          if (excludeModules->obj_at(i) == moduleEntry->module()) {\n+          if (excludeModules->obj_at(i) == moduleEntry->module_oop()) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"code\/nmethod.hpp\"\n@@ -52,0 +53,1 @@\n+#include \"oops\/trainingData.hpp\"\n@@ -508,2 +510,5 @@\n-      klass = *((Klass**) (intptr_t) (base_address + offset));\n-      if (klass == nullptr || !klass->is_loader_alive()) {\n+      Klass* k = *((Klass**) (intptr_t) (base_address + offset));\n+      if (k == nullptr || k->class_loader_data() == nullptr || !TrainingData::is_klass_loaded(k)) {\n+        return nullptr;\n+      }\n+      if (!k->is_loader_alive()) {\n@@ -513,0 +518,1 @@\n+      klass = k;\n@@ -811,0 +817,8 @@\n+C2V_VMENTRY_0(jint, getNumIndyEntries, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp)))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n+  if (cp->cache()->resolved_indy_entries() == nullptr) {\n+    return 0;\n+  }\n+  return cp->resolved_indy_entries_length();\n+C2V_END\n+\n@@ -1196,1 +1210,1 @@\n-        JVMCIENV->invalidate_nmethod_mirror(nmethod_mirror, true, JVMCI_CHECK_0);\n+        JVMCIENV->invalidate_nmethod_mirror(nmethod_mirror, true, nmethod::InvalidationReason::JVMCI_REPLACED_WITH_NEW_CODE, JVMCI_CHECK_0);\n@@ -1207,0 +1221,8 @@\n+C2V_VMENTRY_0(jobject, getInvalidationReasonDescription, (JNIEnv *env, jobject, jint invalidation_reason))\n+  HandleMark hm(THREAD);\n+  JNIHandleMark jni_hm(thread);\n+  nmethod::InvalidationReason reason = static_cast<nmethod::InvalidationReason>(invalidation_reason);\n+  JVMCIObject desc = JVMCIENV->create_string(nmethod::invalidation_reason_to_string(reason), JVMCI_CHECK_NULL);\n+  return JVMCIENV->get_jobject(desc);\n+C2V_END\n+\n@@ -1372,1 +1394,1 @@\n-    code->make_not_entrant(\"JVMCI reprofile\");\n+    code->make_not_entrant(nmethod::InvalidationReason::JVMCI_REPROFILE);\n@@ -1385,1 +1407,6 @@\n-C2V_VMENTRY(void, invalidateHotSpotNmethod, (JNIEnv* env, jobject, jobject hs_nmethod, jboolean deoptimize))\n+C2V_VMENTRY(void, invalidateHotSpotNmethod, (JNIEnv* env, jobject, jobject hs_nmethod, jboolean deoptimize, jint invalidation_reason))\n+  int first = static_cast<int>(nmethod::InvalidationReason::C1_CODEPATCH);\n+  int last = static_cast<int>(nmethod::InvalidationReason::INVALIDATION_REASONS_COUNT);\n+  if (invalidation_reason < first || invalidation_reason >= last) {\n+    JVMCI_THROW_MSG(IllegalArgumentException, err_msg(\"Invalid invalidation_reason: %d\", invalidation_reason));\n+  }\n@@ -1387,1 +1414,1 @@\n-  JVMCIENV->invalidate_nmethod_mirror(nmethod_mirror, deoptimize, JVMCI_CHECK);\n+  JVMCIENV->invalidate_nmethod_mirror(nmethod_mirror, deoptimize, static_cast<nmethod::InvalidationReason>(invalidation_reason), JVMCI_CHECK);\n@@ -1812,1 +1839,1 @@\n-    fst.current()->cb()->as_nmethod()->make_not_entrant(\"JVMCI materialize virtual objects\");\n+    fst.current()->cb()->as_nmethod()->make_not_entrant(nmethod::InvalidationReason::JVMCI_MATERIALIZE_VIRTUAL_OBJECT);\n@@ -2222,0 +2249,20 @@\n+C2V_VMENTRY_NULL(jobjectArray, getAllMethods, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass)))\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  if (klass == nullptr) {\n+    JVMCI_THROW_NULL(NullPointerException);\n+  }\n+  if (!klass->is_instance_klass()) {\n+    JVMCIObjectArray methods = JVMCIENV->new_ResolvedJavaMethod_array(0, JVMCI_CHECK_NULL);\n+    return JVMCIENV->get_jobjectArray(methods);\n+  }\n+\n+  InstanceKlass* iklass = InstanceKlass::cast(klass);\n+  JVMCIObjectArray methods = JVMCIENV->new_ResolvedJavaMethod_array(iklass->methods()->length(), JVMCI_CHECK_NULL);\n+  for (int i = 0; i < iklass->methods()->length(); i++) {\n+    methodHandle mh(THREAD, iklass->methods()->at(i));\n+    JVMCIObject method = JVMCIENV->get_jvmci_method(mh, JVMCI_CHECK_NULL);\n+    JVMCIENV->put_object_at(methods, i, method);\n+  }\n+  return JVMCIENV->get_jobjectArray(methods);\n+C2V_END\n+\n@@ -2834,1 +2881,1 @@\n-          oop nmethod_mirror = data->get_nmethod_mirror(nm, \/* phantom_ref *\/ true);\n+          oop nmethod_mirror = data->get_nmethod_mirror(nm);\n@@ -2846,0 +2893,1 @@\n+      jboolean profileDeopt = thisEnv->get_HotSpotNmethod_profileDeopt(obj);\n@@ -2850,1 +2898,1 @@\n-      result = PEER_JVMCIENV->new_HotSpotNmethod(mh, cstring, isDefault, compileIdSnapshot, JVMCI_CHECK_0);\n+      result = PEER_JVMCIENV->new_HotSpotNmethod(mh, cstring, isDefault, profileDeopt, compileIdSnapshot, JVMCI_CHECK_0);\n@@ -2866,1 +2914,1 @@\n-          if (data->get_nmethod_mirror(nm, \/* phantom_ref *\/ false) != nullptr) {\n+          if (data->get_nmethod_mirror(nm) != nullptr) {\n@@ -3298,0 +3346,1 @@\n+  {CC \"getNumIndyEntries\",                            CC \"(\" HS_CONSTANT_POOL2 \")I\",                                                        FN_PTR(getNumIndyEntries)},\n@@ -3320,0 +3369,1 @@\n+  {CC \"getInvalidationReasonDescription\",             CC \"(I)\" STRING,                                                                      FN_PTR(getInvalidationReasonDescription)},\n@@ -3328,1 +3378,1 @@\n-  {CC \"invalidateHotSpotNmethod\",                     CC \"(\" HS_NMETHOD \"Z)V\",                                                              FN_PTR(invalidateHotSpotNmethod)},\n+  {CC \"invalidateHotSpotNmethod\",                     CC \"(\" HS_NMETHOD \"ZI)V\",                                                             FN_PTR(invalidateHotSpotNmethod)},\n@@ -3357,0 +3407,1 @@\n+  {CC \"getAllMethods\",                                CC \"(\" HS_KLASS2 \")[\" RESOLVED_METHOD,                                                FN_PTR(getAllMethods)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":62,"deletions":11,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -148,0 +148,1 @@\n+address CompilerToVM::Data::dcbrt;\n@@ -290,0 +291,1 @@\n+  SET_TRIGFUNC_OR_NULL(dcbrt);\n@@ -344,1 +346,1 @@\n-#define PREDEFINED_CONFIG_FLAGS(do_bool_flag, do_int_flag, do_intx_flag, do_uintx_flag) \\\n+#define PREDEFINED_CONFIG_FLAGS(do_bool_flag, do_int_flag, do_size_t_flag, do_intx_flag, do_uintx_flag) \\\n@@ -355,1 +357,1 @@\n-  do_uintx_flag(CodeCacheSegmentSize)                                      \\\n+  do_size_t_flag(CodeCacheSegmentSize)                                     \\\n@@ -542,4 +544,5 @@\n-#define ADD_BOOL_FLAG(name)  ADD_FLAG(bool, name, BOXED_BOOLEAN)\n-#define ADD_INT_FLAG(name)   ADD_FLAG(int, name, BOXED_LONG)\n-#define ADD_INTX_FLAG(name)  ADD_FLAG(intx, name, BOXED_LONG)\n-#define ADD_UINTX_FLAG(name) ADD_FLAG(uintx, name, BOXED_LONG)\n+#define ADD_BOOL_FLAG(name)   ADD_FLAG(bool, name, BOXED_BOOLEAN)\n+#define ADD_INT_FLAG(name)    ADD_FLAG(int, name, BOXED_LONG)\n+#define ADD_SIZE_T_FLAG(name) ADD_FLAG(size_t, name, BOXED_LONG)\n+#define ADD_INTX_FLAG(name)   ADD_FLAG(intx, name, BOXED_LONG)\n+#define ADD_UINTX_FLAG(name)  ADD_FLAG(uintx, name, BOXED_LONG)\n@@ -547,1 +550,1 @@\n-  len = 0 + PREDEFINED_CONFIG_FLAGS(COUNT_FLAG, COUNT_FLAG, COUNT_FLAG, COUNT_FLAG);\n+  len = 0 + PREDEFINED_CONFIG_FLAGS(COUNT_FLAG, COUNT_FLAG, COUNT_FLAG, COUNT_FLAG, COUNT_FLAG);\n@@ -551,1 +554,1 @@\n-  PREDEFINED_CONFIG_FLAGS(ADD_BOOL_FLAG, ADD_INT_FLAG, ADD_INTX_FLAG, ADD_UINTX_FLAG)\n+  PREDEFINED_CONFIG_FLAGS(ADD_BOOL_FLAG, ADD_INT_FLAG, ADD_SIZE_T_FLAG, ADD_INTX_FLAG, ADD_UINTX_FLAG)\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -254,3 +254,0 @@\n-  if (_init_error == JNI_ENOMEM) {\n-    THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), \"JNI_ENOMEM creating or attaching to libjvmci\");\n-  }\n@@ -259,1 +256,1 @@\n-           _init_error, _init_error_msg == nullptr ? \"unknown\" : _init_error_msg);\n+            _init_error, _init_error_msg != nullptr ? _init_error_msg : (_init_error == JNI_ENOMEM ? \"JNI_ENOMEM\" : \"none\"));\n@@ -1216,1 +1213,1 @@\n-JVMCIObject JVMCIEnv::new_HotSpotNmethod(const methodHandle& method, const char* name, jboolean isDefault, jlong compileId, JVMCI_TRAPS) {\n+JVMCIObject JVMCIEnv::new_HotSpotNmethod(const methodHandle& method, const char* name, jboolean isDefault, jboolean profileDeopt, jlong compileId, JVMCI_TRAPS) {\n@@ -1236,0 +1233,1 @@\n+    jargs.push_int(profileDeopt);\n@@ -1240,1 +1238,1 @@\n-                            vmSymbols::method_string_bool_long_signature(),\n+                            vmSymbols::method_string_bool_bool_long_signature(),\n@@ -1469,2 +1467,1 @@\n-    Klass* byteArrayArrayKlass = TypeArrayKlass::cast(Universe::byteArrayKlass())->array_klass(CHECK_(JVMCIObject()));\n-    objArrayOop result = ObjArrayKlass::cast(byteArrayArrayKlass) ->allocate(length, CHECK_(JVMCIObject()));\n+    objArrayOop result = oopFactory::new_objArray(Universe::byteArrayKlass(), length, CHECK_(JVMCIObject()));\n@@ -1756,1 +1753,1 @@\n-void JVMCIEnv::invalidate_nmethod_mirror(JVMCIObject mirror, bool deoptimize, JVMCI_TRAPS) {\n+void JVMCIEnv::invalidate_nmethod_mirror(JVMCIObject mirror, bool deoptimize, nmethod::InvalidationReason invalidation_reason, JVMCI_TRAPS) {\n@@ -1779,1 +1776,1 @@\n-    nm->make_not_entrant(\"JVMCI invalidate nmethod mirror\");\n+    nm->make_not_entrant(invalidation_reason);\n@@ -1788,1 +1785,1 @@\n-    nm->make_not_entrant(\"JVMCI invalidate nmethod mirror\");\n+    nm->make_not_entrant(invalidation_reason);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -429,1 +429,1 @@\n-  JVMCIObject new_HotSpotNmethod(const methodHandle& method, const char* name, jboolean isDefault, jlong compileId, JVMCI_TRAPS);\n+  JVMCIObject new_HotSpotNmethod(const methodHandle& method, const char* name, jboolean isDefault, jboolean profileDeopt, jlong compileId, JVMCI_TRAPS);\n@@ -465,1 +465,1 @@\n-  void invalidate_nmethod_mirror(JVMCIObject mirror, bool deoptimze, JVMCI_TRAPS);\n+  void invalidate_nmethod_mirror(JVMCIObject mirror, bool deoptimze, nmethod::InvalidationReason invalidation_reason, JVMCI_TRAPS);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,0 +103,1 @@\n+    boolean_field(HotSpotNmethod, profileDeopt)                                                               \\\n@@ -105,1 +106,2 @@\n-    jvmci_constructor(HotSpotNmethod, \"(Ljdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl;Ljava\/lang\/String;ZJ)V\") \\\n+    int_field(HotSpotNmethod, invalidationReason)                                                             \\\n+    jvmci_constructor(HotSpotNmethod, \"(Ljdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl;Ljava\/lang\/String;ZZJ)V\") \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -723,1 +723,1 @@\n-    JVMCI_THROW_MSG_NULL(InternalError, \"JVMCI is not enabled\");\n+    JVMCI_THROW_MSG_NULL(InternalError, JVMCI_NOT_ENABLED_ERROR_MESSAGE);\n@@ -735,1 +735,1 @@\n-    JVMCI_THROW_MSG_0(InternalError, \"JVMCI is not enabled\");\n+    JVMCI_THROW_MSG_0(InternalError, JVMCI_NOT_ENABLED_ERROR_MESSAGE);\n@@ -746,8 +746,0 @@\n-void JVMCIRuntime::call_getCompiler(TRAPS) {\n-  JVMCIENV_FROM_THREAD(THREAD);\n-  JVMCIENV->check_init(CHECK);\n-  JVMCIObject jvmciRuntime = JVMCIRuntime::get_HotSpotJVMCIRuntime(JVMCI_CHECK);\n-  initialize(JVMCI_CHECK);\n-  JVMCIENV->call_HotSpotJVMCIRuntime_getCompiler(jvmciRuntime, JVMCI_CHECK);\n-}\n-\n@@ -757,0 +749,2 @@\n+                                  bool is_default,\n+                                  bool profile_deopt,\n@@ -764,1 +758,1 @@\n-    _has_name = true;\n+    _properties.bits._has_name = 1;\n@@ -768,1 +762,1 @@\n-    _has_name = false;\n+    _properties.bits._has_name = 0;\n@@ -770,0 +764,2 @@\n+  _properties.bits._is_default = is_default;\n+  _properties.bits._profile_deopt = profile_deopt;\n@@ -773,1 +769,2 @@\n-  initialize(data->_nmethod_mirror_index, data->_nmethod_entry_patch_offset, data->name(), data->_failed_speculations);\n+  initialize(data->_nmethod_mirror_index, data->_nmethod_entry_patch_offset, data->name(), data->_properties.bits._is_default,\n+             data->_properties.bits._profile_deopt, data->_failed_speculations);\n@@ -787,1 +784,1 @@\n-oop JVMCINMethodData::get_nmethod_mirror(nmethod* nm, bool phantom_ref) {\n+oop JVMCINMethodData::get_nmethod_mirror(nmethod* nm) {\n@@ -791,5 +788,1 @@\n-  if (phantom_ref) {\n-    return nm->oop_at_phantom(_nmethod_mirror_index);\n-  } else {\n-    return nm->oop_at(_nmethod_mirror_index);\n-  }\n+  return nm->oop_at(_nmethod_mirror_index);\n@@ -812,2 +805,2 @@\n-void JVMCINMethodData::invalidate_nmethod_mirror(nmethod* nm) {\n-  oop nmethod_mirror = get_nmethod_mirror(nm, \/* phantom_ref *\/ false);\n+void JVMCINMethodData::invalidate_nmethod_mirror(nmethod* nm, nmethod::InvalidationReason invalidation_reason) {\n+  oop nmethod_mirror = get_nmethod_mirror(nm);\n@@ -831,0 +824,4 @@\n+      if (HotSpotJVMCI::HotSpotNmethod::invalidationReason(jvmciEnv, nmethod_mirror) ==\n+        static_cast<int>(nmethod::InvalidationReason::NOT_INVALIDATED)) {\n+        HotSpotJVMCI::HotSpotNmethod::set_invalidationReason(jvmciEnv, nmethod_mirror, static_cast<int>(invalidation_reason));\n+      }\n@@ -837,0 +834,4 @@\n+      if (HotSpotJVMCI::HotSpotNmethod::invalidationReason(jvmciEnv, nmethod_mirror) ==\n+        static_cast<int>(nmethod::InvalidationReason::NOT_INVALIDATED)) {\n+        HotSpotJVMCI::HotSpotNmethod::set_invalidationReason(jvmciEnv, nmethod_mirror, static_cast<int>(invalidation_reason));\n+      }\n@@ -1518,1 +1519,1 @@\n-    JVMCI_THROW_MSG(InternalError, \"JVMCI is not enabled\");\n+    JVMCI_THROW_MSG(InternalError, JVMCI_NOT_ENABLED_ERROR_MESSAGE);\n@@ -2091,0 +2092,1 @@\n+  bool profile_deopt = JVMCIENV->get_HotSpotNmethod_profileDeopt(nmethod_mirror) != 0;\n@@ -2137,1 +2139,1 @@\n-    if (result != JVMCI::ok) {\n+    if (install_default && result != JVMCI::ok) {\n@@ -2158,0 +2160,2 @@\n+                                                        install_default,\n+                                                        profile_deopt,\n@@ -2189,1 +2193,1 @@\n-          assert(!nmethod_mirror.is_hotspot() || data->get_nmethod_mirror(nm, \/* phantom_ref *\/ false) == nullptr, \"must be\");\n+          assert(!nmethod_mirror.is_hotspot() || data->get_nmethod_mirror(nm) == nullptr, \"must be\");\n@@ -2199,1 +2203,1 @@\n-              old->make_not_entrant(\"JVMCI register method\");\n+              old->make_not_entrant(nmethod::InvalidationReason::JVMCI_REPLACED_WITH_NEW_CODE);\n@@ -2232,1 +2236,1 @@\n-          assert(!nmethod_mirror.is_hotspot() || data->get_nmethod_mirror(nm, \/* phantom_ref *\/ false) == HotSpotJVMCI::resolve(nmethod_mirror), \"must be\");\n+          assert(!nmethod_mirror.is_hotspot() || data->get_nmethod_mirror(nm) == HotSpotJVMCI::resolve(nmethod_mirror), \"must be\");\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":30,"deletions":26,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,2 @@\n+#define JVMCI_NOT_ENABLED_ERROR_MESSAGE \"JVMCI is not enabled. Must specify '-XX:+EnableJVMCI' or '--add-modules=jdk.internal.vm.ci' to the java launcher.\"\n+\n@@ -49,3 +51,15 @@\n-  \/\/ Is HotSpotNmethod.name non-null? If so, the value is\n-  \/\/ embedded in the end of this object.\n-  bool _has_name;\n+  union JVMCINMethodProperties {\n+    uint8_t value;\n+    struct {\n+      \/\/ Is HotSpotNmethod.name non-null? If so, the value is\n+      \/\/ embedded in the end of this object.\n+      uint8_t _has_name      : 1,\n+      \/\/ HotSpotNmethod.isDefault (e.g., compilation scheduled by CompileBroker)\n+              _is_default    : 1,\n+      \/\/ HotSpotNmethod.profileDeopt\n+              _profile_deopt : 1,\n+                             : 5;\n+    } bits;\n+  };\n+\n+  JVMCINMethodProperties _properties;\n@@ -77,0 +91,2 @@\n+                   bool is_default,\n+                   bool profile_deopt,\n@@ -89,0 +105,2 @@\n+                                  bool is_default,\n+                                  bool profile_deopt,\n@@ -94,0 +112,2 @@\n+                       is_default,\n+                       profile_deopt,\n@@ -118,1 +138,1 @@\n-  const char* name() { return _has_name ? (char*)(((address) this) + sizeof(JVMCINMethodData)) : nullptr; }\n+  const char* name() { return has_name() ? (char*)(((address) this) + sizeof(JVMCINMethodData)) : nullptr; }\n@@ -122,1 +142,1 @@\n-  void invalidate_nmethod_mirror(nmethod* nm);\n+  void invalidate_nmethod_mirror(nmethod* nm, nmethod::InvalidationReason invalidation_reason);\n@@ -125,1 +145,1 @@\n-  oop get_nmethod_mirror(nmethod* nm, bool phantom_ref);\n+  oop get_nmethod_mirror(nmethod* nm);\n@@ -133,0 +153,12 @@\n+\n+  bool has_name() {\n+    return _properties.bits._has_name;\n+  }\n+\n+  bool is_default() {\n+    return _properties.bits._is_default;\n+  }\n+\n+  bool profile_deopt() {\n+    return _properties.bits._profile_deopt;\n+  }\n@@ -376,2 +408,0 @@\n-  void call_getCompiler(TRAPS);\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":39,"deletions":9,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-  template(method_string_bool_long_signature,                     \"(Ljdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl;Ljava\/lang\/String;ZJ)V\") \\\n+  template(method_string_bool_bool_long_signature,                \"(Ljdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl;Ljava\/lang\/String;ZZJ)V\") \\\n","filename":"src\/hotspot\/share\/jvmci\/vmSymbols_jvmci.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,0 +131,1 @@\n+  LOG_TAG(methodtrace) \\\n@@ -209,0 +210,1 @@\n+  LOG_TAG(training) \\\n@@ -218,0 +220,1 @@\n+  LOG_TAG(vmatree) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-void* GuardedMemory::wrap_copy(const void* ptr, const size_t len, const void* tag) {\n+void* GuardedMemory::wrap_copy(const void* ptr, const size_t len,\n+                               const void* tag, const void* tag2) {\n@@ -32,1 +33,1 @@\n-    GuardedMemory guarded(outerp, len, tag);\n+    GuardedMemory guarded(outerp, len, tag, tag2);\n@@ -61,2 +62,2 @@\n-      \" tag=\" PTR_FORMAT \" user_size=%zu user_data=\" PTR_FORMAT,\n-      p2i(this), p2i(_base_addr), p2i(get_tag()), get_user_size(), p2i(get_user_ptr()));\n+      \" tag=\" PTR_FORMAT \" tag2=\" PTR_FORMAT \" user_size=%zu user_data=\" PTR_FORMAT,\n+      p2i(this), p2i(_base_addr), p2i(get_tag()), p2i(get_tag2()), get_user_size(), p2i(get_user_ptr()));\n","filename":"src\/hotspot\/share\/memory\/guardedMemory.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -46,0 +47,1 @@\n+ * |+sizeof(uintptr_t) | <tag2>               | Tag word       |\n@@ -52,1 +54,1 @@\n- *  - tag word is general purpose\n+ *  - tag word and tag2 word are general purpose\n@@ -114,0 +116,4 @@\n+      \/\/ We may not be able to dereference directly.\n+      if (!os::is_readable_range((const void*) _guard, (const void*) (_guard + GUARD_SIZE))) {\n+        return false;\n+      }\n@@ -140,0 +146,1 @@\n+    void* _tag2;\n@@ -147,0 +154,2 @@\n+    void set_tag2(const void* tag2) { _tag2 = (void*) tag2; }\n+    void* get_tag2() const { return _tag2; }\n@@ -165,0 +174,1 @@\n+   * @param tag2      optional second general purpose tag.\n@@ -166,2 +176,3 @@\n-  GuardedMemory(void* base_ptr, const size_t user_size, const void* tag = nullptr) {\n-    wrap_with_guards(base_ptr, user_size, tag);\n+  GuardedMemory(void* base_ptr, const size_t user_size,\n+                const void* tag = nullptr, const void* tag2 = nullptr) {\n+    wrap_with_guards(base_ptr, user_size, tag, tag2);\n@@ -192,0 +203,1 @@\n+   * @param tag2      optional second general purpose tag.\n@@ -195,1 +207,2 @@\n-  void* wrap_with_guards(void* base_ptr, size_t user_size, const void* tag = nullptr) {\n+  void* wrap_with_guards(void* base_ptr, size_t user_size,\n+                         const void* tag = nullptr, const void* tag2 = nullptr) {\n@@ -202,0 +215,1 @@\n+    set_tag2(tag2);\n@@ -233,0 +247,14 @@\n+  \/**\n+   * Set the second general purpose tag.\n+   *\n+   * @param tag general purpose tag.\n+   *\/\n+  void set_tag2(const void* tag) { get_head_guard()->set_tag2(tag); }\n+\n+  \/**\n+   * Return the second general purpose tag.\n+   *\n+   * @return the second general purpose tag, defaults to null.\n+   *\/\n+  void* get_tag2() const { return get_head_guard()->get_tag2(); }\n+\n@@ -305,0 +333,1 @@\n+   * @param tag2 optional general purpose tag (see GuardedMemory::get_tag2())\n@@ -308,1 +337,2 @@\n-  static void* wrap_copy(const void* p, const size_t len, const void* tag = nullptr);\n+  static void* wrap_copy(const void* p, const size_t len,\n+                         const void* tag = nullptr, const void* tag2 = nullptr);\n","filename":"src\/hotspot\/share\/memory\/guardedMemory.hpp","additions":36,"deletions":6,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"oops\/jmethodIDTable.hpp\"\n@@ -439,0 +440,3 @@\n+    \/\/ Initialize table for matching jmethodID, before SystemDictionary.\n+    JmethodIDTable::initialize();\n+\n@@ -447,1 +451,0 @@\n-\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -123,2 +123,2 @@\n-  oop module = (module_entry != nullptr) ? module_entry->module() : (oop)nullptr;\n-  java_lang_Class::create_mirror(k, Handle(THREAD, k->class_loader()), Handle(THREAD, module), Handle(), Handle(), CHECK);\n+  oop module_oop = (module_entry != nullptr) ? module_entry->module_oop() : (oop)nullptr;\n+  java_lang_Class::create_mirror(k, Handle(THREAD, k->class_loader()), Handle(THREAD, module_oop), Handle(), Handle(), CHECK);\n@@ -210,1 +210,1 @@\n-  log_trace(cds)(\"Iter(ArrayKlass): %p (%s)\", this, external_name());\n+  log_trace(aot)(\"Iter(ArrayKlass): %p (%s)\", this, external_name());\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -193,0 +193,4 @@\n+char* CompressedKlassPointers::reserve_address_space_below_4G(size_t size, bool aslr) {\n+  return reserve_address_space_X(0, nth_bit(32), size, Metaspace::reserve_alignment(), aslr);\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+  static char* reserve_address_space_below_4G(size_t size, bool aslr);\n@@ -216,0 +217,1 @@\n+  static address  base_addr()        { return (address)&_base; }\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -690,0 +690,5 @@\n+  if (fieldinfo_search_table() != nullptr && !fieldinfo_search_table()->is_shared()) {\n+    MetadataFactory::free_array<u1>(loader_data, fieldinfo_search_table());\n+  }\n+  set_fieldinfo_search_table(nullptr);\n+\n@@ -870,1 +875,1 @@\n-  if (log_is_enabled(Info, cds, init)) {\n+  if (log_is_enabled(Info, aot, init)) {\n@@ -872,1 +877,1 @@\n-    log_info(cds, init)(\"%s (aot-inited)\", external_name());\n+    log_info(aot, init)(\"%s (aot-inited)\", external_name());\n@@ -1331,0 +1336,1 @@\n+    CompilationPolicy::replay_training_at_init(this, THREAD);\n@@ -1789,7 +1795,6 @@\n-  for (JavaFieldStream fs(this); !fs.done(); fs.next()) {\n-    Symbol* f_name = fs.name();\n-    Symbol* f_sig  = fs.signature();\n-    if (f_name == name && f_sig == sig) {\n-      fd->reinitialize(const_cast<InstanceKlass*>(this), fs.to_FieldInfo());\n-      return true;\n-    }\n+  JavaFieldStream fs(this);\n+  if (fs.lookup(name, sig)) {\n+    assert(fs.name() == name, \"name must match\");\n+    assert(fs.signature() == sig, \"signature must match\");\n+    fd->reinitialize(const_cast<InstanceKlass*>(this), fs.to_FieldInfo());\n+    return true;\n@@ -2394,0 +2399,18 @@\n+\/\/ Allocate the jmethodID cache.\n+static jmethodID* create_jmethod_id_cache(size_t size) {\n+  jmethodID* jmeths = NEW_C_HEAP_ARRAY(jmethodID, size + 1, mtClass);\n+  memset(jmeths, 0, (size + 1) * sizeof(jmethodID));\n+  \/\/ cache size is stored in element[0], other elements offset by one\n+  jmeths[0] = (jmethodID)size;\n+  return jmeths;\n+}\n+\n+\/\/ When reading outside a lock, use this.\n+jmethodID* InstanceKlass::methods_jmethod_ids_acquire() const {\n+  return Atomic::load_acquire(&_methods_jmethod_ids);\n+}\n+\n+void InstanceKlass::release_set_methods_jmethod_ids(jmethodID* jmeths) {\n+  Atomic::release_store(&_methods_jmethod_ids, jmeths);\n+}\n+\n@@ -2395,6 +2418,1 @@\n-\/\/ This code is called by the VMThread and JavaThreads so the\n-\/\/ locking has to be done very carefully to avoid deadlocks\n-\/\/ and\/or other cache consistency problems.\n-\/\/\n-jmethodID InstanceKlass::get_jmethod_id(const methodHandle& method_h) {\n-  Method* method = method_h();\n+jmethodID InstanceKlass::get_jmethod_id(Method* method) {\n@@ -2421,1 +2439,1 @@\n-    jmeths = methods_jmethod_ids_acquire();\n+    jmeths = _methods_jmethod_ids;\n@@ -2426,4 +2444,1 @@\n-      jmeths = NEW_C_HEAP_ARRAY(jmethodID, size + 1, mtClass);\n-      memset(jmeths, 0, (size + 1) * sizeof(jmethodID));\n-      \/\/ cache size is stored in element[0], other elements offset by one\n-      jmeths[0] = (jmethodID)size;\n+      jmeths = create_jmethod_id_cache(size);\n@@ -2459,4 +2474,1 @@\n-      jmethodID* new_cache = NEW_C_HEAP_ARRAY(jmethodID, size + 1, mtClass);\n-      memset(new_cache, 0, (size + 1) * sizeof(jmethodID));\n-      \/\/ The cache size is stored in element[0]; the other elements are offset by one.\n-      new_cache[0] = (jmethodID)size;\n+      jmethodID* new_cache = create_jmethod_id_cache(size);\n@@ -2473,3 +2485,2 @@\n-\/\/ Figure out how many jmethodIDs haven't been allocated, and make\n-\/\/ sure space for them is pre-allocated.  This makes getting all\n-\/\/ method ids much, much faster with classes with more than 8\n+\/\/ Make a jmethodID for all methods in this class.  This makes getting all method\n+\/\/ ids much, much faster with classes with more than 8\n@@ -2478,2 +2489,8 @@\n-void InstanceKlass::ensure_space_for_methodids(int start_offset) {\n-  int new_jmeths = 0;\n+void InstanceKlass::make_methods_jmethod_ids() {\n+  MutexLocker ml(JmethodIdCreation_lock, Mutex::_no_safepoint_check_flag);\n+  jmethodID* jmeths = _methods_jmethod_ids;\n+  if (jmeths == nullptr) {\n+    jmeths = create_jmethod_id_cache(idnum_allocated_count());\n+    release_set_methods_jmethod_ids(jmeths);\n+  }\n+\n@@ -2481,1 +2498,1 @@\n-  for (int index = start_offset; index < length; index++) {\n+  for (int index = 0; index < length; index++) {\n@@ -2483,3 +2500,7 @@\n-    jmethodID id = m->find_jmethod_id_or_null();\n-    if (id == nullptr) {\n-      new_jmeths++;\n+    int idnum = m->method_idnum();\n+    assert(!m->is_old(), \"should not have old methods or I'm confused\");\n+    jmethodID id = Atomic::load_acquire(&jmeths[idnum + 1]);\n+    if (!m->is_overpass() &&  \/\/ skip overpasses\n+        id == nullptr) {\n+      id = Method::make_jmethod_id(class_loader_data(), m);\n+      Atomic::release_store(&jmeths[idnum + 1], id);\n@@ -2488,3 +2509,0 @@\n-  if (new_jmeths != 0) {\n-    Method::ensure_jmethod_ids(class_loader_data(), new_jmeths);\n-  }\n@@ -2571,1 +2589,1 @@\n-  if (log_is_enabled(Trace, cds)) {\n+  if (log_is_enabled(Trace, aot)) {\n@@ -2573,1 +2591,1 @@\n-    log_trace(cds)(\"Iter(InstanceKlass): %p (%s)\", this, external_name());\n+    log_trace(aot)(\"Iter(InstanceKlass): %p (%s)\", this, external_name());\n@@ -2613,0 +2631,1 @@\n+  it->push(&_fieldinfo_search_table);\n@@ -2651,0 +2670,2 @@\n+  _misc_flags.set_has_init_deps_processed(false);\n+\n@@ -2711,0 +2732,2 @@\n+\n+  DEBUG_ONLY(FieldInfoStream::validate_search_table(_constants, _fieldinfo_stream, _fieldinfo_search_table));\n@@ -2738,1 +2761,1 @@\n-    if (is_shared_unregistered_class()) {\n+    if (defined_by_other_loaders()) {\n@@ -2817,0 +2840,2 @@\n+\n+  DEBUG_ONLY(FieldInfoStream::validate_search_table(_constants, _fieldinfo_stream, _fieldinfo_search_table));\n@@ -2846,11 +2871,0 @@\n-int InstanceKlass::shared_class_loader_type() const {\n-  if (is_shared_boot_class()) {\n-    return ClassLoader::BOOT_LOADER;\n-  } else if (is_shared_platform_class()) {\n-    return ClassLoader::PLATFORM_LOADER;\n-  } else if (is_shared_app_class()) {\n-    return ClassLoader::APP_LOADER;\n-  } else {\n-    return ClassLoader::OTHER;\n-  }\n-}\n@@ -2926,1 +2940,1 @@\n-  jmethodID* jmeths = methods_jmethod_ids_acquire();\n+  jmethodID* jmeths = _methods_jmethod_ids;\n@@ -2972,2 +2986,2 @@\n-InstanceKlass* InstanceKlass::get_klass_version(int version) {\n-  for (InstanceKlass* ik = this; ik != nullptr; ik = ik->previous_versions()) {\n+const InstanceKlass* InstanceKlass::get_klass_version(int version) const {\n+  for (const InstanceKlass* ik = this; ik != nullptr; ik = ik->previous_versions()) {\n@@ -3504,1 +3518,1 @@\n-      inv->make_not_entrant(\"OSR invalidation of lower levels\");\n+      inv->make_not_entrant(nmethod::InvalidationReason::OSR_INVALIDATION_OF_LOWER_LEVEL);\n@@ -3772,0 +3786,5 @@\n+\n+  if (fieldinfo_search_table() != nullptr) {\n+    st->print_cr(BULLET\"---- field info search table:\");\n+    FieldInfoStream::print_search_table(st, _constants, _fieldinfo_stream, _fieldinfo_search_table);\n+  }\n@@ -4273,8 +4292,4 @@\n-\/\/ This nulls out jmethodIDs for all methods in 'klass'\n-\/\/ It needs to be called explicitly for all previous versions of a class because these may not be cleaned up\n-\/\/ during class unloading.\n-\/\/ We can not use the jmethodID cache associated with klass directly because the 'previous' versions\n-\/\/ do not have the jmethodID cache filled in. Instead, we need to lookup jmethodID for each method and this\n-\/\/ is expensive - O(n) for one jmethodID lookup. For all contained methods it is O(n^2).\n-\/\/ The reason for expensive jmethodID lookup for each method is that there is no direct link between method and jmethodID.\n-void InstanceKlass::clear_jmethod_ids(InstanceKlass* klass) {\n+\/\/ This nulls out the jmethodID for all obsolete methods in the previous version of the 'klass'.\n+\/\/ These obsolete methods only exist in the previous version and we're about to delete the memory for them.\n+\/\/ The jmethodID for these are deallocated when we unload the class, so this doesn't remove them from the table.\n+void InstanceKlass::clear_obsolete_jmethod_ids(InstanceKlass* klass) {\n@@ -4284,0 +4299,1 @@\n+    \/\/ Only need to clear obsolete methods.\n@@ -4333,1 +4349,1 @@\n-      clear_jmethod_ids(pv_node); \/\/ jmethodID maintenance for the unloaded class\n+      clear_obsolete_jmethod_ids(pv_node); \/\/ jmethodID maintenance for the unloaded class\n@@ -4471,1 +4487,1 @@\n-Method* InstanceKlass::method_with_idnum(int idnum) {\n+Method* InstanceKlass::method_with_idnum(int idnum) const {\n@@ -4490,1 +4506,1 @@\n-Method* InstanceKlass::method_with_orig_idnum(int idnum) {\n+Method* InstanceKlass::method_with_orig_idnum(int idnum) const {\n@@ -4510,2 +4526,2 @@\n-Method* InstanceKlass::method_with_orig_idnum(int idnum, int version) {\n-  InstanceKlass* holder = get_klass_version(version);\n+Method* InstanceKlass::method_with_orig_idnum(int idnum, int version) const {\n+  const InstanceKlass* holder = get_klass_version(version);\n@@ -4515,2 +4531,1 @@\n-  Method* method = holder->method_with_orig_idnum(idnum);\n-  return method;\n+  return holder->method_with_orig_idnum(idnum);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":84,"deletions":69,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -281,0 +281,1 @@\n+  Array<u1>*          _fieldinfo_search_table;\n@@ -311,6 +312,6 @@\n-  \/\/ The three BUILTIN class loader types\n-  bool is_shared_boot_class() const { return _misc_flags.is_shared_boot_class(); }\n-  bool is_shared_platform_class() const { return _misc_flags.is_shared_platform_class(); }\n-  bool is_shared_app_class() const {  return _misc_flags.is_shared_app_class(); }\n-  \/\/ The UNREGISTERED class loader type\n-  bool is_shared_unregistered_class() const { return _misc_flags.is_shared_unregistered_class(); }\n+  \/\/ Quick checks for the loader that defined this class (without switching on this->class_loader())\n+  bool defined_by_boot_loader() const      { return _misc_flags.defined_by_boot_loader(); }\n+  bool defined_by_platform_loader() const  { return _misc_flags.defined_by_platform_loader(); }\n+  bool defined_by_app_loader() const       { return _misc_flags.defined_by_app_loader(); }\n+  bool defined_by_other_loaders() const    { return _misc_flags.defined_by_other_loaders(); }\n+  void set_class_loader_type()             { _misc_flags.set_class_loader_type(_class_loader_data); }\n@@ -325,6 +326,0 @@\n-#if INCLUDE_CDS\n-  int  shared_class_loader_type() const;\n-  void set_shared_class_loader_type(s2 loader_type) { _misc_flags.set_shared_class_loader_type(loader_type); }\n-  void assign_class_loader_type() { _misc_flags.assign_class_loader_type(_class_loader_data); }\n-#endif\n-\n@@ -360,3 +355,3 @@\n-  Method* method_with_idnum(int idnum);\n-  Method* method_with_orig_idnum(int idnum);\n-  Method* method_with_orig_idnum(int idnum, int version);\n+  Method* method_with_idnum(int idnum) const;\n+  Method* method_with_orig_idnum(int idnum) const;\n+  Method* method_with_orig_idnum(int idnum, int version) const;\n@@ -409,0 +404,3 @@\n+  Array<u1>* fieldinfo_search_table() const { return _fieldinfo_search_table; }\n+  void set_fieldinfo_search_table(Array<u1>* table) { _fieldinfo_search_table = table; }\n+\n@@ -451,0 +449,3 @@\n+  InstanceKlass* nest_host_or_null() {\n+    return _nest_host;\n+  }\n@@ -699,1 +700,1 @@\n-  InstanceKlass* get_klass_version(int version);\n+  const InstanceKlass* get_klass_version(int version) const;\n@@ -788,2 +789,2 @@\n-  jmethodID get_jmethod_id(const methodHandle& method_h);\n-  void ensure_space_for_methodids(int start_offset = 0);\n+  jmethodID get_jmethod_id(Method* method);\n+  void make_methods_jmethod_ids();\n@@ -1072,4 +1073,4 @@\n-  inline jmethodID* methods_jmethod_ids_acquire() const;\n-  inline void release_set_methods_jmethod_ids(jmethodID* jmeths);\n-  \/\/ This nulls out jmethodIDs for all methods in 'klass'\n-  static void clear_jmethod_ids(InstanceKlass* klass);\n+  jmethodID* methods_jmethod_ids_acquire() const;\n+  void release_set_methods_jmethod_ids(jmethodID* jmeths);\n+  \/\/ This nulls out obsolete jmethodIDs for all methods in 'klass'.\n+  static void clear_obsolete_jmethod_ids(InstanceKlass* klass);\n@@ -1138,0 +1139,6 @@\n+  bool     has_init_deps_processed() const { return _misc_flags.has_init_deps_processed(); }\n+  void set_has_init_deps_processed() {\n+    assert(is_initialized(), \"\");\n+    assert(!has_init_deps_processed(), \"already set\"); \/\/ one-off action\n+    _misc_flags.set_has_init_deps_processed(true);\n+  }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":29,"deletions":22,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+    assert(expand_for_hash(obj, obj->mark()), \"must expand for hash\");\n","filename":"src\/hotspot\/share\/oops\/instanceMirrorKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -765,1 +765,1 @@\n-  if (log_is_enabled(Trace, cds)) {\n+  if (log_is_enabled(Trace, aot)) {\n@@ -767,1 +767,1 @@\n-    log_trace(cds)(\"Iter(Klass): %p (%s)\", this, external_name());\n+    log_trace(aot)(\"Iter(Klass): %p (%s)\", this, external_name());\n@@ -796,1 +796,1 @@\n-  if (log_is_enabled(Trace, cds, unshareable)) {\n+  if (log_is_enabled(Trace, aot, unshareable)) {\n@@ -798,1 +798,1 @@\n-    log_trace(cds, unshareable)(\"remove: %s\", external_name());\n+    log_trace(aot, unshareable)(\"remove: %s\", external_name());\n@@ -814,4 +814,12 @@\n-  \/\/ FIXME: validation in Klass::hash_secondary_supers() may fail for shared klasses.\n-  \/\/ Even though the bitmaps always match, the canonical order of elements in the table\n-  \/\/ is not guaranteed to stay the same (see tie breaker during Robin Hood hashing in Klass::hash_insert).\n-  \/\/assert(compute_secondary_supers_bitmap(secondary_supers()) == _secondary_supers_bitmap, \"broken table\");\n+  if (CDSConfig::is_dumping_classic_static_archive()) {\n+    \/\/ \"Classic\" static archives are required to have deterministic contents.\n+    \/\/ The elements in _secondary_supers are addresses in the ArchiveBuilder\n+    \/\/ output buffer, so they should have deterministic values. If we rehash\n+    \/\/ _secondary_supers, its elements will appear in a deterministic order.\n+    \/\/\n+    \/\/ Note that the bitmap is guaranteed to be deterministic, regardless of the\n+    \/\/ actual addresses of the elements in _secondary_supers. So rehashing shouldn't\n+    \/\/ change it.\n+    uintx bitmap = hash_secondary_supers(secondary_supers(), true);\n+    assert(bitmap == _secondary_supers_bitmap, \"bitmap should not be changed due to rehashing\");\n+  }\n@@ -822,1 +830,1 @@\n-  if (log_is_enabled(Trace, cds, unshareable)) {\n+  if (log_is_enabled(Trace, aot, unshareable)) {\n@@ -824,1 +832,1 @@\n-    log_trace(cds, unshareable)(\"remove java_mirror: %s\", external_name());\n+    log_trace(aot, unshareable)(\"remove java_mirror: %s\", external_name());\n@@ -835,1 +843,1 @@\n-        assert(InstanceKlass::cast(this)->is_shared_unregistered_class(), \"sanity\");\n+        assert(InstanceKlass::cast(this)->defined_by_other_loaders(), \"sanity\");\n@@ -840,1 +848,1 @@\n-        assert(InstanceKlass::cast(k)->is_shared_unregistered_class(), \"sanity\");\n+        assert(InstanceKlass::cast(k)->defined_by_other_loaders(), \"sanity\");\n@@ -860,1 +868,1 @@\n-  if (log_is_enabled(Trace, cds, unshareable)) {\n+  if (log_is_enabled(Trace, aot, unshareable)) {\n@@ -863,1 +871,1 @@\n-    log_trace(cds, unshareable)(\"restore: %s with class loader: %s\", external_name(),\n+    log_trace(aot, unshareable)(\"restore: %s with class loader: %s\", external_name(),\n@@ -892,1 +900,1 @@\n-  Handle module_handle(THREAD, ((module_entry != nullptr) ? module_entry->module() : (oop)nullptr));\n+  Handle module_handle(THREAD, ((module_entry != nullptr) ? module_entry->module_oop() : (oop)nullptr));\n@@ -896,1 +904,1 @@\n-    log_debug(cds, mirror)(\"%s has raw archived mirror\", external_name());\n+    log_debug(aot, mirror)(\"%s has raw archived mirror\", external_name());\n@@ -907,1 +915,1 @@\n-    log_debug(cds, mirror)(\"No archived mirror data for %s\", external_name());\n+    log_debug(aot, mirror)(\"No archived mirror data for %s\", external_name());\n@@ -916,1 +924,1 @@\n-    log_trace(cds, mirror)(\"Recreate mirror for %s\", external_name());\n+    log_trace(aot, mirror)(\"Recreate mirror for %s\", external_name());\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":26,"deletions":18,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -734,0 +734,1 @@\n+  inline bool is_loader_present_and_alive() const;\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,0 +62,5 @@\n+inline bool Klass::is_loader_present_and_alive() const {\n+  ClassLoaderData* cld = class_loader_data();\n+  return (cld != nullptr) ? cld->is_alive() : false;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-ObjArrayKlass* ObjArrayKlass::allocate(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, TRAPS) {\n+ObjArrayKlass* ObjArrayKlass::allocate_klass(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, TRAPS) {\n@@ -103,1 +103,1 @@\n-  ObjArrayKlass* oak = ObjArrayKlass::allocate(loader_data, n, element_klass, name, CHECK_NULL);\n+  ObjArrayKlass* oak = ObjArrayKlass::allocate_klass(loader_data, n, element_klass, name, CHECK_NULL);\n@@ -153,1 +153,1 @@\n-objArrayOop ObjArrayKlass::allocate(int length, TRAPS) {\n+objArrayOop ObjArrayKlass::allocate_instance(int length, TRAPS) {\n@@ -164,1 +164,1 @@\n-  objArrayOop array = allocate(length, CHECK_NULL);\n+  objArrayOop array = allocate_instance(length, CHECK_NULL);\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  friend class VMStructs;\n+  friend class Deoptimization;\n@@ -38,0 +38,2 @@\n+  friend class oopFactory;\n+  friend class VMStructs;\n@@ -50,1 +52,3 @@\n-  static ObjArrayKlass* allocate(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, TRAPS);\n+  static ObjArrayKlass* allocate_klass(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, TRAPS);\n+\n+  objArrayOop allocate_instance(int length, TRAPS);\n@@ -81,1 +85,0 @@\n-  objArrayOop allocate(int length, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -140,3 +140,1 @@\n-#ifndef PRODUCT\n-  log_trace(ihash)(\"Initializing hash for \" PTR_FORMAT \", old: \" PTR_FORMAT \", hash: %d, offset: %d\", p2i(this), p2i(obj), hash, offset);\n-#endif\n+  log_develop_trace(gc)(\"Initializing hash for \" PTR_FORMAT \", old: \" PTR_FORMAT \", hash: %d, offset: %d, is_mirror: %s\", p2i(this), p2i(obj), hash, offset, BOOL_TO_STR(k->is_mirror_instance_klass()));\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  TypeArrayKlass* ak = TypeArrayKlass::allocate(null_loader_data, type, sym, CHECK_NULL);\n+  TypeArrayKlass* ak = TypeArrayKlass::allocate_klass(null_loader_data, type, sym, CHECK_NULL);\n@@ -68,1 +68,1 @@\n-TypeArrayKlass* TypeArrayKlass::allocate(ClassLoaderData* loader_data, BasicType type, Symbol* name, TRAPS) {\n+TypeArrayKlass* TypeArrayKlass::allocate_klass(ClassLoaderData* loader_data, BasicType type, Symbol* name, TRAPS) {\n@@ -104,1 +104,1 @@\n-  return allocate(length, THREAD);\n+  return allocate_instance(length, THREAD);\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+  friend class Deoptimization;\n+  friend class oopFactory;\n@@ -46,1 +48,4 @@\n-  static TypeArrayKlass* allocate(ClassLoaderData* loader_data, BasicType type, Symbol* name, TRAPS);\n+  static TypeArrayKlass* allocate_klass(ClassLoaderData* loader_data, BasicType type, Symbol* name, TRAPS);\n+\n+  typeArrayOop allocate_common(int length, bool do_zero, TRAPS);\n+  typeArrayOop allocate_instance(int length, TRAPS) { return allocate_common(length, true, THREAD); }\n@@ -69,2 +74,0 @@\n-  typeArrayOop allocate_common(int length, bool do_zero, TRAPS);\n-  typeArrayOop allocate(int length, TRAPS) { return allocate_common(length, true, THREAD); }\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n-#include \"compiler\/compileLog.hpp\"\n+#include \"code\/vmreg.hpp\"\n+#include \"compiler\/compileLog.hpp\"\n@@ -46,1 +47,0 @@\n-#include \"code\/vmreg.hpp\"\n@@ -1454,8 +1454,2 @@\n-  if (GenerateSynchronizationCode) {\n-    ins_req(nextmon,   lock->box_node());\n-    ins_req(nextmon+1, lock->obj_node());\n-  } else {\n-    Node* top = Compile::current()->top();\n-    ins_req(nextmon, top);\n-    ins_req(nextmon, top);\n-  }\n+  ins_req(nextmon,   lock->box_node());\n+  ins_req(nextmon+1, lock->obj_node());\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -35,1 +36,2 @@\n-#include \"compiler\/compilerOracle.hpp\"\n+#include \"compiler\/compilerDefinitions.hpp\"\n+#include \"compiler\/compilerOracle.hpp\"\n@@ -578,0 +580,4 @@\n+void Compile::print_phase(const char* phase_name) {\n+  tty->print_cr(\"%u.\\t%s\", ++_phase_counter, phase_name);\n+}\n+\n@@ -633,0 +639,1 @@\n+      _stub_id(StubId::NO_STUBID),\n@@ -732,1 +739,3 @@\n-      StressIncrementalInlining || StressMacroExpansion || StressUnstableIfTraps || StressBailout) {\n+      StressIncrementalInlining || StressMacroExpansion ||\n+      StressMacroElimination || StressUnstableIfTraps ||\n+      StressBailout || StressLoopPeeling) {\n@@ -778,13 +787,3 @@\n-      if (method()->intrinsic_id() == vmIntrinsics::_Reference_get) {\n-        \/\/ With java.lang.ref.reference.get() we must go through the\n-        \/\/ intrinsic - even when get() is the root\n-        \/\/ method of the compile - so that, if necessary, the value in\n-        \/\/ the referent field of the reference object gets recorded by\n-        \/\/ the pre-barrier code.\n-        cg = find_intrinsic(method(), false);\n-      }\n-      if (cg == nullptr) {\n-        float past_uses = method()->interpreter_invocation_count();\n-        float expected_uses = past_uses;\n-        cg = CallGenerator::for_inline(method(), expected_uses);\n-      }\n+      float past_uses = method()->interpreter_invocation_count();\n+      float expected_uses = past_uses;\n+      cg = CallGenerator::for_inline(method(), expected_uses);\n@@ -902,0 +901,1 @@\n+                 StubId stub_id,\n@@ -913,0 +913,1 @@\n+      _stub_id(stub_id),\n@@ -964,0 +965,11 @@\n+  \/\/ try to reuse an existing stub\n+  {\n+    BlobId blob_id = StubInfo::blob(_stub_id);\n+    CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, blob_id);\n+    if (blob != nullptr) {\n+      RuntimeStub* rs = blob->as_runtime_stub();\n+      _stub_entry_point = rs->entry_point();\n+      return;\n+    }\n+  }\n+\n@@ -1057,0 +1069,1 @@\n+  _phase_counter = 0;\n@@ -2413,0 +2426,1 @@\n+        print_method(PHASE_AFTER_MACRO_ELIMINATION, 2);\n@@ -2512,0 +2526,12 @@\n+    \/\/ Do not allow new macro nodes once we start to eliminate and expand\n+    C->reset_allow_macro_nodes();\n+    \/\/ Last attempt to eliminate macro nodes before expand\n+    mex.eliminate_macro_nodes();\n+    if (failing()) {\n+      return;\n+    }\n+    mex.eliminate_opaque_looplimit_macro_nodes();\n+    if (failing()) {\n+      return;\n+    }\n+    print_method(PHASE_AFTER_MACRO_ELIMINATION, 2);\n@@ -4503,1 +4529,3 @@\n-  if (sizetype != nullptr) index_max = sizetype->_hi - 1;\n+  if (sizetype != nullptr && sizetype->_hi > 0) {\n+    index_max = sizetype->_hi - 1;\n+  }\n@@ -4531,1 +4559,1 @@\n-    log()->head(\"late_inline method='%d'  inline_id='\" JLONG_FORMAT \"'\", log()->identify(cg->method()),\n+    log()->head(\"late_inline method='%d' inline_id='\" JLONG_FORMAT \"'\", log()->identify(cg->method()),\n@@ -5137,1 +5165,4 @@\n-  if (should_print_phase(cpt)) {\n+  if (should_print_phase(level)) {\n+    print_phase(name);\n+  }\n+  if (should_print_ideal_phase(cpt)) {\n@@ -5168,6 +5199,7 @@\n-bool Compile::should_print_phase(CompilerPhaseType cpt) {\n-  if (_directive->should_print_phase(cpt)) {\n-    return true;\n-  }\n-#endif\n-  return false;\n+bool Compile::should_print_phase(const int level) const {\n+  return PrintPhaseLevel > 0 && directive()->PhasePrintLevelOption >= level &&\n+         _method != nullptr; \/\/ Do not print phases for stubs.\n+}\n+\n+bool Compile::should_print_ideal_phase(CompilerPhaseType cpt) const {\n+  return _directive->should_print_ideal_phase(cpt);\n@@ -5177,1 +5209,0 @@\n-#ifndef PRODUCT\n@@ -5184,1 +5215,0 @@\n-#endif\n@@ -5187,1 +5217,2 @@\n-#ifndef PRODUCT\n+  PRODUCT_RETURN_(return false;);\n+\n@@ -5197,3 +5228,0 @@\n-#else\n-  return false;\n-#endif\n@@ -5202,1 +5230,0 @@\n-#ifndef PRODUCT\n@@ -5291,1 +5318,1 @@\n-#endif\n+#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":59,"deletions":32,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"compiler\/compiler_globals.hpp\"\n+#include \"compiler\/cHeapStringHolder.hpp\"\n@@ -33,0 +33,1 @@\n+#include \"compiler\/compiler_globals.hpp\"\n@@ -34,1 +35,0 @@\n-#include \"compiler\/cHeapStringHolder.hpp\"\n@@ -40,1 +40,2 @@\n-#include \"opto\/phasetype.hpp\"\n+#include \"opto\/phasetype.hpp\"\n+#include \"opto\/printinlining.hpp\"\n@@ -49,1 +50,0 @@\n-#include \"opto\/printinlining.hpp\"\n@@ -311,0 +311,1 @@\n+  StubId                   _stub_id;               \/\/ unique id for stub or NO_STUBID\n@@ -349,0 +350,1 @@\n+  uint                  _phase_counter;         \/\/ Counter for the number of already printed phases\n@@ -573,0 +575,1 @@\n+  StubId            stub_id() const             { return _stub_id; }\n@@ -643,1 +646,1 @@\n-  bool          method_has_option(CompileCommandEnum option) {\n+  bool          method_has_option(CompileCommandEnum option) const {\n@@ -650,0 +653,1 @@\n+  void          print_phase(const char* phase_name);\n@@ -667,2 +671,0 @@\n-  bool should_print_igv(int level);\n-  bool should_print_phase(CompilerPhaseType cpt);\n@@ -673,0 +675,3 @@\n+  bool should_print_igv(int level);\n+  bool should_print_phase(int level) const;\n+  bool should_print_ideal_phase(CompilerPhaseType cpt) const;\n@@ -926,2 +931,2 @@\n-  inline Node_Notes* locate_node_notes(GrowableArray<Node_Notes*>* arr,\n-                                       int idx, bool can_grow = false);\n+  Node_Notes* locate_node_notes(GrowableArray<Node_Notes*>* arr,\n+                                int idx, bool can_grow = false);\n@@ -1143,1 +1148,1 @@\n-          int is_fancy_jump, bool pass_tls,\n+          StubId stub_id, int is_fancy_jump, bool pass_tls,\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"opto\/c2compiler.hpp\"\n+#include \"opto\/c2compiler.hpp\"\n@@ -35,0 +35,1 @@\n+#include \"opto\/castnode.hpp\"\n@@ -38,2 +39,1 @@\n-#include \"opto\/macro.hpp\"\n-#include \"opto\/phaseX.hpp\"\n+#include \"opto\/macro.hpp\"\n@@ -43,1 +43,1 @@\n-#include \"opto\/castnode.hpp\"\n+#include \"opto\/phaseX.hpp\"\n@@ -2263,8 +2263,4 @@\n-            if (arg_ptn != src_ptn) {\n-              \/\/ Special arraycopy edge:\n-              \/\/ A destination object's field can't have the source object\n-              \/\/ as base since objects escape states are not related.\n-              \/\/ Only escape state of destination object's fields affects\n-              \/\/ escape state of fields in source object.\n-              add_arraycopy(call, es, src_ptn, arg_ptn);\n-            }\n+            \/\/ Special arraycopy edge:\n+            \/\/ Only escape state of destination object's fields affects\n+            \/\/ escape state of fields in source object.\n+            add_arraycopy(call, es, src_ptn, arg_ptn);\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+#include \"asm\/register.hpp\"\n+#include \"ci\/ciObjArray.hpp\"\n@@ -27,2 +29,0 @@\n-#include \"ci\/ciObjArray.hpp\"\n-#include \"asm\/register.hpp\"\n@@ -50,1 +50,1 @@\n-#include \"utilities\/powerOfTwo.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -3450,2 +3450,0 @@\n-  if( !GenerateSynchronizationCode )\n-    return nullptr;                \/\/ Not locking things?\n@@ -3514,2 +3512,0 @@\n-  if( !GenerateSynchronizationCode )\n-    return;\n@@ -3806,0 +3802,2 @@\n+    assert(fast_size_limit == 0 || count_leading_zeros(fast_size_limit) > static_cast<unsigned>(LogBytesPerLong - log2_esize),\n+           \"fast_size_limit (%d) overflow when shifted left by %d\", fast_size_limit, LogBytesPerLong - log2_esize);\n@@ -3856,1 +3854,3 @@\n-      if (size_max > tilen->_hi)  size_max = tilen->_hi;\n+      if (size_max > tilen->_hi && tilen->_hi >= 0) {\n+        size_max = tilen->_hi;\n+      }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"ci\/ciUtilities.inline.hpp\"\n+#include \"ci\/ciUtilities.inline.hpp\"\n@@ -50,1 +50,1 @@\n-#include \"opto\/runtime.hpp\"\n+#include \"opto\/runtime.hpp\"\n@@ -248,0 +248,1 @@\n+  case vmIntrinsics::_dcbrt:\n@@ -566,1 +567,1 @@\n-  case vmIntrinsics::_Reference_get:            return inline_reference_get();\n+  case vmIntrinsics::_Reference_get0:           return inline_reference_get0();\n@@ -1577,3 +1578,8 @@\n-    \/\/ Check if src array address is aligned to HeapWordSize (dst is always aligned)\n-    const TypeInt* toffset = gvn().type(offset)->is_int();\n-    bool aligned = toffset->is_con() && ((toffset->get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);\n+    \/\/ Check if dst array address is aligned to HeapWordSize\n+    bool aligned = (arrayOopDesc::base_offset_in_bytes(T_BYTE) % HeapWordSize == 0);\n+    \/\/ If true, then check if src array address is aligned to HeapWordSize\n+    if (aligned) {\n+      const TypeInt* toffset = gvn().type(offset)->is_int();\n+      aligned = toffset->is_con() && ((arrayOopDesc::base_offset_in_bytes(T_CHAR) +\n+                                       toffset->get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);\n+    }\n@@ -1660,2 +1666,2 @@\n-    bool aligned = tsrc->is_con() && ((tsrc->get_con() * type2aelembytes(T_BYTE)) % HeapWordSize == 0) &&\n-                   tdst->is_con() && ((tdst->get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);\n+    bool aligned = tsrc->is_con() && ((arrayOopDesc::base_offset_in_bytes(T_BYTE) + tsrc->get_con() * type2aelembytes(T_BYTE)) % HeapWordSize == 0) &&\n+                   tdst->is_con() && ((arrayOopDesc::base_offset_in_bytes(T_CHAR) + tdst->get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);\n@@ -1889,0 +1895,3 @@\n+  case vmIntrinsics::_dcbrt:\n+    return StubRoutines::dcbrt() != nullptr ?\n+      runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dcbrt(), \"dcbrt\") : false;\n@@ -4817,51 +4826,51 @@\n-    \/\/ Our constants.\n-    Node* M = _gvn.intcon(0x337954D5);\n-    Node* A = _gvn.intcon(0xAAAAAAAA);\n-    \/\/ Split object address into lo and hi 32 bits.\n-    Node* obj_addr = _gvn.transform(new CastP2XNode(nullptr, obj));\n-    Node* x = _gvn.transform(new ConvL2INode(obj_addr));\n-    Node* upper_addr = _gvn.transform(new URShiftLNode(obj_addr, _gvn.intcon(32)));\n-    Node* y = _gvn.transform(new ConvL2INode(upper_addr));\n-\n-    Node* H0 = _gvn.transform(new XorINode(x, y));\n-    Node* L0 = _gvn.transform(new XorINode(x, A));\n-\n-    \/\/ Full multiplication of two 32 bit values L0 and M into a hi\/lo result in two 32 bit values V0 and U0.\n-    Node* L0_64 = _gvn.transform(new ConvI2LNode(L0));\n-    L0_64 = _gvn.transform(new AndLNode(L0_64, _gvn.longcon(0xFFFFFFFF)));\n-    Node* M_64 = _gvn.transform(new ConvI2LNode(M));\n-    \/\/ M_64 = _gvn.transform(new AndLNode(M_64, _gvn.longcon(0xFFFFFFFF)));\n-    Node* prod64 = _gvn.transform(new MulLNode(L0_64, M_64));\n-    Node* V0 = _gvn.transform(new ConvL2INode(prod64));\n-    Node* prod_upper = _gvn.transform(new URShiftLNode(prod64, _gvn.intcon(32)));\n-    Node* U0 = _gvn.transform(new ConvL2INode(prod_upper));\n-\n-    Node* Q0 = _gvn.transform(new MulINode(H0, M));\n-    Node* L1 = _gvn.transform(new XorINode(Q0, U0));\n-\n-    \/\/ Full multiplication of two 32 bit values L1 and M into a hi\/lo result in two 32 bit values V1 and U1.\n-    Node* L1_64 = _gvn.transform(new ConvI2LNode(L1));\n-    L1_64 = _gvn.transform(new AndLNode(L1_64, _gvn.longcon(0xFFFFFFFF)));\n-    prod64 = _gvn.transform(new MulLNode(L1_64, M_64));\n-    Node* V1 = _gvn.transform(new ConvL2INode(prod64));\n-    prod_upper = _gvn.transform(new URShiftLNode(prod64, _gvn.intcon(32)));\n-    Node* U1 = _gvn.transform(new ConvL2INode(prod_upper));\n-\n-    Node* P1 = _gvn.transform(new XorINode(V0, M));\n-\n-    \/\/ Right rotate P1 by distance L1.\n-    Node* distance = _gvn.transform(new AndINode(L1, _gvn.intcon(32 - 1)));\n-    Node* inverse_distance = _gvn.transform(new SubINode(_gvn.intcon(32), distance));\n-    Node* ror_part1 = _gvn.transform(new URShiftINode(P1, distance));\n-    Node* ror_part2 = _gvn.transform(new LShiftINode(P1, inverse_distance));\n-    Node* Q1 = _gvn.transform(new OrINode(ror_part1, ror_part2));\n-\n-    Node* L2 = _gvn.transform(new XorINode(Q1, U1));\n-    Node* hash = _gvn.transform(new XorINode(V1, L2));\n-    Node* hash_truncated = _gvn.transform(new AndINode(hash, _gvn.intcon(markWord::hash_mask)));\n-\n-    \/\/ TODO: We could generate a fast case here under the following conditions:\n-    \/\/ - The hashctrl is set to hash_is_copied (see markWord::hash_is_copied())\n-    \/\/ - The type of the object is known\n-    \/\/ Then we can load the identity hashcode from the int field at Klass::hash_offset_in_bytes() of the object.\n-    result_val->init_req(_fast_path, hash_truncated);\n+    if (hashCode == 6) {\n+      \/\/ Our constants.\n+      Node* M = _gvn.intcon(0x337954D5);\n+      Node* A = _gvn.intcon(0xAAAAAAAA);\n+      \/\/ Split object address into lo and hi 32 bits.\n+      Node* obj_addr = _gvn.transform(new CastP2XNode(nullptr, obj));\n+      Node* x = _gvn.transform(new ConvL2INode(obj_addr));\n+      Node* upper_addr = _gvn.transform(new URShiftLNode(obj_addr, _gvn.intcon(32)));\n+      Node* y = _gvn.transform(new ConvL2INode(upper_addr));\n+\n+      Node* H0 = _gvn.transform(new XorINode(x, y));\n+      Node* L0 = _gvn.transform(new XorINode(x, A));\n+\n+      \/\/ Full multiplication of two 32 bit values L0 and M into a hi\/lo result in two 32 bit values V0 and U0.\n+      Node* L0_64 = _gvn.transform(new ConvI2LNode(L0));\n+      L0_64 = _gvn.transform(new AndLNode(L0_64, _gvn.longcon(0xFFFFFFFF)));\n+      Node* M_64 = _gvn.transform(new ConvI2LNode(M));\n+      \/\/ M_64 = _gvn.transform(new AndLNode(M_64, _gvn.longcon(0xFFFFFFFF)));\n+      Node* prod64 = _gvn.transform(new MulLNode(L0_64, M_64));\n+      Node* V0 = _gvn.transform(new ConvL2INode(prod64));\n+      Node* prod_upper = _gvn.transform(new URShiftLNode(prod64, _gvn.intcon(32)));\n+      Node* U0 = _gvn.transform(new ConvL2INode(prod_upper));\n+\n+      Node* Q0 = _gvn.transform(new MulINode(H0, M));\n+      Node* L1 = _gvn.transform(new XorINode(Q0, U0));\n+\n+      \/\/ Full multiplication of two 32 bit values L1 and M into a hi\/lo result in two 32 bit values V1 and U1.\n+      Node* L1_64 = _gvn.transform(new ConvI2LNode(L1));\n+      L1_64 = _gvn.transform(new AndLNode(L1_64, _gvn.longcon(0xFFFFFFFF)));\n+      prod64 = _gvn.transform(new MulLNode(L1_64, M_64));\n+      Node* V1 = _gvn.transform(new ConvL2INode(prod64));\n+      prod_upper = _gvn.transform(new URShiftLNode(prod64, _gvn.intcon(32)));\n+      Node* U1 = _gvn.transform(new ConvL2INode(prod_upper));\n+\n+      Node* P1 = _gvn.transform(new XorINode(V0, M));\n+\n+      \/\/ Right rotate P1 by distance L1.\n+      Node* distance = _gvn.transform(new AndINode(L1, _gvn.intcon(32 - 1)));\n+      Node* inverse_distance = _gvn.transform(new SubINode(_gvn.intcon(32), distance));\n+      Node* ror_part1 = _gvn.transform(new URShiftINode(P1, distance));\n+      Node* ror_part2 = _gvn.transform(new LShiftINode(P1, inverse_distance));\n+      Node* Q1 = _gvn.transform(new OrINode(ror_part1, ror_part2));\n+\n+      Node* L2 = _gvn.transform(new XorINode(Q1, U1));\n+      Node* hash = _gvn.transform(new XorINode(V1, L2));\n+      Node* hash_truncated = _gvn.transform(new AndINode(hash, _gvn.intcon(markWord::hash_mask)));\n+\n+      result_val->init_req(_fast_path, hash_truncated);\n+    } else if (hashCode == 2) {\n+      result_val->init_req(_fast_path, _gvn.intcon(1));\n+    }\n@@ -6725,0 +6734,4 @@\n+  record_for_igvn(exit_block);\n+  record_for_igvn(memory_phi);\n+  record_for_igvn(result_phi);\n+\n@@ -7059,1 +7072,1 @@\n-\/\/----------------------------inline_reference_get----------------------------\n+\/\/----------------------------inline_reference_get0----------------------------\n@@ -7061,1 +7074,1 @@\n-bool LibraryCallKit::inline_reference_get() {\n+bool LibraryCallKit::inline_reference_get0() {\n@@ -7890,0 +7903,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":75,"deletions":61,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2368,0 +2368,4 @@\n+\n+  if (StressMacroElimination) {\n+    C->shuffle_macro_nodes();\n+  }\n@@ -2407,0 +2411,3 @@\n+      if (success) {\n+        C->print_method(PHASE_AFTER_MACRO_ELIMINATION_STEP, 5, n);\n+      }\n@@ -2410,1 +2417,0 @@\n-  _has_locks = false;\n@@ -2434,1 +2440,0 @@\n-        _has_locks = true;\n@@ -2457,0 +2462,3 @@\n+      if (success) {\n+        C->print_method(PHASE_AFTER_MACRO_ELIMINATION_STEP, 5, n);\n+      }\n@@ -2467,8 +2475,3 @@\n-\/\/------------------------------expand_macro_nodes----------------------\n-\/\/  Returns true if a failure occurred.\n-bool PhaseMacroExpand::expand_macro_nodes() {\n-  refine_strip_mined_loop_macro_nodes();\n-  \/\/ Do not allow new macro nodes once we started to expand\n-  C->reset_allow_macro_nodes();\n-  if (StressMacroExpansion) {\n-    C->shuffle_macro_nodes();\n+void PhaseMacroExpand::eliminate_opaque_looplimit_macro_nodes() {\n+  if (C->macro_count() == 0) {\n+    return;\n@@ -2476,4 +2479,1 @@\n-  \/\/ Last attempt to eliminate macro nodes.\n-  eliminate_macro_nodes();\n-  if (C->failing())  return true;\n-\n+  refine_strip_mined_loop_macro_nodes();\n@@ -2541,1 +2541,1 @@\n-        C->print_method(PHASE_AFTER_MACRO_EXPANSION_STEP, 5, n);\n+        C->print_method(PHASE_AFTER_MACRO_ELIMINATION_STEP, 5, n);\n@@ -2545,0 +2545,8 @@\n+}\n+\n+\/\/------------------------------expand_macro_nodes----------------------\n+\/\/  Returns true if a failure occurred.\n+bool PhaseMacroExpand::expand_macro_nodes() {\n+  if (StressMacroExpansion) {\n+    C->shuffle_macro_nodes();\n+  }\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":23,"deletions":15,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2520,16 +2520,1 @@\n-    case Op_LoadVectorGather:\n-      if (is_subword_type(n->bottom_type()->is_vect()->element_basic_type())) {\n-        Node* pair = new BinaryNode(n->in(MemNode::ValueIn), n->in(MemNode::ValueIn+1));\n-        n->set_req(MemNode::ValueIn, pair);\n-        n->del_req(MemNode::ValueIn+1);\n-      }\n-      break;\n-    case Op_LoadVectorGatherMasked:\n-      if (is_subword_type(n->bottom_type()->is_vect()->element_basic_type())) {\n-        Node* pair2 = new BinaryNode(n->in(MemNode::ValueIn + 1), n->in(MemNode::ValueIn + 2));\n-        Node* pair1 = new BinaryNode(n->in(MemNode::ValueIn), pair2);\n-        n->set_req(MemNode::ValueIn, pair1);\n-        n->del_req(MemNode::ValueIn+2);\n-        n->del_req(MemNode::ValueIn+1);\n-        break;\n-      } \/\/ fall-through\n+    case Op_LoadVectorGatherMasked: \/\/ fall-through\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"opto\/regalloc.hpp\"\n@@ -49,0 +48,1 @@\n+#include \"opto\/regalloc.hpp\"\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -38,1 +39,1 @@\n-#include \"opto\/c2compiler.hpp\"\n+#include \"opto\/c2compiler.hpp\"\n@@ -1076,2 +1077,1 @@\n-            num_mon > 0 ||\n-            !GenerateSynchronizationCode,\n+            num_mon > 0,\n@@ -2017,2 +2017,4 @@\n-      assert(n->in(1)->as_Mach()->barrier_data() == 0,\n-             \"Implicit null checks on memory accesses with barriers are not yet supported\");\n+      MachNode* access = n->in(1)->as_Mach();\n+      assert(access->barrier_data() == 0 ||\n+             access->is_late_expanded_null_check_candidate(),\n+             \"Implicit null checks on memory accesses with barriers are only supported on nodes explicitly marked as null-check candidates\");\n@@ -3490,0 +3492,2 @@\n+        BlobId blob_id = StubInfo::blob(C->stub_id());\n+        AOTCodeCache::store_code_blob(*rs, AOTCodeEntry::C2Blob, blob_id);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1068,1 +1068,1 @@\n-  bool do_synch = method()->is_synchronized() && GenerateSynchronizationCode;\n+  bool do_synch = method()->is_synchronized();\n@@ -2192,1 +2192,1 @@\n-  if (method()->is_synchronized() && GenerateSynchronizationCode) {\n+  if (method()->is_synchronized()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-#include \"oops\/objArrayKlass.hpp\"\n+#include \"oops\/objArrayKlass.hpp\"\n@@ -75,1 +75,1 @@\n-#include \"runtime\/vframeArray.hpp\"\n+#include \"runtime\/vframeArray.hpp\"\n@@ -91,1 +91,1 @@\n-  type OptoRuntime:: BLOB_FIELD_NAME(name)  = nullptr;\n+  type* OptoRuntime:: BLOB_FIELD_NAME(name)  = nullptr;\n@@ -102,10 +102,0 @@\n-#define C2_BLOB_NAME_DEFINE(name, type)  \"C2 Runtime \" # name \"_blob\",\n-#define C2_STUB_NAME_DEFINE(name, f, t, r)  \"C2 Runtime \" # name,\n-#define C2_JVMTI_STUB_NAME_DEFINE(name)  \"C2 Runtime \" # name,\n-const char* OptoRuntime::_stub_names[] = {\n-  C2_STUBS_DO(C2_BLOB_NAME_DEFINE, C2_STUB_NAME_DEFINE, C2_JVMTI_STUB_NAME_DEFINE)\n-};\n-#undef C2_BLOB_NAME_DEFINE\n-#undef C2_STUB_NAME_DEFINE\n-#undef C2_JVMTI_STUB_NAME_DEFINE\n-\n@@ -142,1 +132,2 @@\n-#define C2_STUB_NAME(name) stub_name(OptoStubId::name ## _id)\n+#define C2_STUB_ID(name) StubId:: JOIN3(c2, name, id)\n+#define C2_STUB_NAME(name) stub_name(C2_STUB_ID(name))\n@@ -155,1 +146,1 @@\n-    generate_stub(env,                                                  \\\n+    generate_stub(env,                                                \\\n@@ -159,3 +150,4 @@\n-                  fancy_jump,                                           \\\n-                  pass_tls,                                             \\\n-                  pass_retpc);                                          \\\n+                  C2_STUB_ID(name),                                   \\\n+                  fancy_jump,                                         \\\n+                  pass_tls,                                           \\\n+                  pass_retpc);                                        \\\n@@ -167,3 +159,3 @@\n-  STUB_FIELD_NAME(name) =                                               \\\n-    generate_stub(env,                                                  \\\n-                  notify_jvmti_vthread_Type,                            \\\n+  STUB_FIELD_NAME(name) =                                             \\\n+    generate_stub(env,                                                \\\n+                  notify_jvmti_vthread_Type,                          \\\n@@ -172,4 +164,5 @@\n-                  0,                                                    \\\n-                  true,                                                 \\\n-                  false);                                               \\\n-  if (STUB_FIELD_NAME(name) == nullptr) { return false; }               \\\n+                  C2_STUB_ID(name),                                   \\\n+                  0,                                                  \\\n+                  true,                                               \\\n+                  false);                                             \\\n+  if (STUB_FIELD_NAME(name) == nullptr) { return false; }             \\\n@@ -279,2 +272,2 @@\n-                                   const char *name, int is_fancy_jump,\n-                                   bool pass_tls,\n+                                   const char *name, StubId stub_id,\n+                                   int is_fancy_jump, bool pass_tls,\n@@ -287,1 +280,1 @@\n-  Compile C(env, gen, C_function, name, is_fancy_jump, pass_tls, return_pc, directive);\n+  Compile C(env, gen, C_function, name, stub_id, is_fancy_jump, pass_tls, return_pc, directive);\n@@ -1474,0 +1467,1 @@\n+\n@@ -1546,0 +1540,1 @@\n+\n@@ -2037,1 +2032,1 @@\n-  if (!StressCompiledExceptionHandlers && doit) {\n+  if (DeoptimizeOnAllocationException && doit) {\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":24,"deletions":29,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/stubInfo.hpp\"\n@@ -100,14 +101,0 @@\n-\/\/ define OptoStubId enum tags: uncommon_trap_id etc\n-\n-#define C2_BLOB_ID_ENUM_DECLARE(name, type) STUB_ID_NAME(name),\n-#define C2_STUB_ID_ENUM_DECLARE(name, f, t, r) STUB_ID_NAME(name),\n-#define C2_JVMTI_STUB_ID_ENUM_DECLARE(name) STUB_ID_NAME(name),\n-enum class OptoStubId :int {\n-  NO_STUBID = -1,\n-  C2_STUBS_DO(C2_BLOB_ID_ENUM_DECLARE, C2_STUB_ID_ENUM_DECLARE, C2_JVMTI_STUB_ID_ENUM_DECLARE)\n-  NUM_STUBIDS\n-};\n-#undef C2_BLOB_ID_ENUM_DECLARE\n-#undef C2_STUB_ID_ENUM_DECLARE\n-#undef C2_JVMTI_STUB_ID_ENUM_DECLARE\n-\n@@ -121,1 +108,1 @@\n-  static type        BLOB_FIELD_NAME(name);\n+  static type*       BLOB_FIELD_NAME(name);\n@@ -216,4 +203,1 @@\n-  \/\/ Stub names indexed by sharedStubId\n-  static const char *_stub_names[];\n-\n-  static address generate_stub(ciEnv* ci_env, TypeFunc_generator gen, address C_function, const char* name, int is_fancy_jump, bool pass_tls, bool return_pc);\n+  static address generate_stub(ciEnv* ci_env, TypeFunc_generator gen, address C_function, const char* name, StubId stub_id, int is_fancy_jump, bool pass_tls, bool return_pc);\n@@ -286,3 +270,3 @@\n-  static const char* stub_name(OptoStubId id) {\n-    assert(id > OptoStubId::NO_STUBID && id < OptoStubId::NUM_STUBIDS, \"stub id out of range\");\n-    return _stub_names[(int)id];\n+  static const char* stub_name(StubId id) {\n+    assert(StubInfo::is_c2(id), \"not a C2 stub %s\", StubInfo::name(id));\n+    return StubInfo::name(id);\n@@ -599,1 +583,1 @@\n-  static const TypeFunc* kyberNtt_Type() {\n+  static inline const TypeFunc* kyberNtt_Type() {\n@@ -604,1 +588,1 @@\n-  static const TypeFunc* kyberInverseNtt_Type() {\n+  static inline const TypeFunc* kyberInverseNtt_Type() {\n@@ -609,1 +593,1 @@\n-  static const TypeFunc* kyberNttMult_Type() {\n+  static inline const TypeFunc* kyberNttMult_Type() {\n@@ -614,1 +598,1 @@\n-  static const TypeFunc* kyberAddPoly_2_Type() {\n+  static inline const TypeFunc* kyberAddPoly_2_Type() {\n@@ -619,1 +603,1 @@\n-  static const TypeFunc* kyberAddPoly_3_Type() {\n+  static inline const TypeFunc* kyberAddPoly_3_Type() {\n@@ -624,1 +608,1 @@\n-  static const TypeFunc* kyber12To16_Type() {\n+  static inline const TypeFunc* kyber12To16_Type() {\n@@ -629,1 +613,1 @@\n-  static const TypeFunc* kyberBarrettReduce_Type() {\n+  static inline const TypeFunc* kyberBarrettReduce_Type() {\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":13,"deletions":29,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -563,2 +563,4 @@\n-  \/\/ no folding if one of operands is infinity or NaN, do not do constant folding\n-  if(g_isfinite(t1->getf()) && g_isfinite(t2->getf())) {\n+  \/\/ Half precision floating point subtraction follows the rules of IEEE 754\n+  \/\/ applicable to other floating point types.\n+  if (t1->isa_half_float_constant() != nullptr &&\n+      t2->isa_half_float_constant() != nullptr)  {\n@@ -566,8 +568,1 @@\n-  }\n-  else if(g_isnan(t1->getf())) {\n-    return t1;\n-  }\n-  else if(g_isnan(t2->getf())) {\n-    return t2;\n-  }\n-  else {\n+  } else {\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-#include \"opto\/callnode.hpp\"\n+#include \"opto\/callnode.hpp\"\n@@ -43,0 +43,1 @@\n+#include \"opto\/rangeinference.hpp\"\n@@ -45,0 +46,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -48,1 +50,0 @@\n-#include \"runtime\/stubRoutines.hpp\"\n@@ -431,1 +432,0 @@\n-#define SMALLINT ((juint)3)  \/\/ a value too insignificant to consider widening\n@@ -490,19 +490,21 @@\n-  TypeInt::MINUS_1 = TypeInt::make(-1);  \/\/ -1\n-  TypeInt::ZERO    = TypeInt::make( 0);  \/\/  0\n-  TypeInt::ONE     = TypeInt::make( 1);  \/\/  1\n-  TypeInt::BOOL    = TypeInt::make(0,1,   WidenMin);  \/\/ 0 or 1, FALSE or TRUE.\n-  TypeInt::CC      = TypeInt::make(-1, 1, WidenMin);  \/\/ -1, 0 or 1, condition codes\n-  TypeInt::CC_LT   = TypeInt::make(-1,-1, WidenMin);  \/\/ == TypeInt::MINUS_1\n-  TypeInt::CC_GT   = TypeInt::make( 1, 1, WidenMin);  \/\/ == TypeInt::ONE\n-  TypeInt::CC_EQ   = TypeInt::make( 0, 0, WidenMin);  \/\/ == TypeInt::ZERO\n-  TypeInt::CC_LE   = TypeInt::make(-1, 0, WidenMin);\n-  TypeInt::CC_GE   = TypeInt::make( 0, 1, WidenMin);  \/\/ == TypeInt::BOOL\n-  TypeInt::BYTE    = TypeInt::make(-128,127,     WidenMin); \/\/ Bytes\n-  TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin); \/\/ Unsigned Bytes\n-  TypeInt::CHAR    = TypeInt::make(0,65535,      WidenMin); \/\/ Java chars\n-  TypeInt::SHORT   = TypeInt::make(-32768,32767, WidenMin); \/\/ Java shorts\n-  TypeInt::POS     = TypeInt::make(0,max_jint,   WidenMin); \/\/ Non-neg values\n-  TypeInt::POS1    = TypeInt::make(1,max_jint,   WidenMin); \/\/ Positive values\n-  TypeInt::INT     = TypeInt::make(min_jint,max_jint, WidenMax); \/\/ 32-bit integers\n-  TypeInt::SYMINT  = TypeInt::make(-max_jint,max_jint,WidenMin); \/\/ symmetric range\n-  TypeInt::TYPE_DOMAIN  = TypeInt::INT;\n+  TypeInt::MINUS_1  = TypeInt::make(-1);  \/\/ -1\n+  TypeInt::ZERO     = TypeInt::make( 0);  \/\/  0\n+  TypeInt::ONE      = TypeInt::make( 1);  \/\/  1\n+  TypeInt::BOOL     = TypeInt::make( 0, 1, WidenMin);  \/\/ 0 or 1, FALSE or TRUE.\n+  TypeInt::CC       = TypeInt::make(-1, 1, WidenMin);  \/\/ -1, 0 or 1, condition codes\n+  TypeInt::CC_LT    = TypeInt::make(-1,-1, WidenMin);  \/\/ == TypeInt::MINUS_1\n+  TypeInt::CC_GT    = TypeInt::make( 1, 1, WidenMin);  \/\/ == TypeInt::ONE\n+  TypeInt::CC_EQ    = TypeInt::make( 0, 0, WidenMin);  \/\/ == TypeInt::ZERO\n+  TypeInt::CC_NE    = TypeInt::make_or_top(TypeIntPrototype<jint, juint>{{-1, 1}, {1, max_juint}, {0, 1}}, WidenMin)->is_int();\n+  TypeInt::CC_LE    = TypeInt::make(-1, 0, WidenMin);\n+  TypeInt::CC_GE    = TypeInt::make( 0, 1, WidenMin);  \/\/ == TypeInt::BOOL\n+  TypeInt::BYTE     = TypeInt::make(-128, 127,     WidenMin); \/\/ Bytes\n+  TypeInt::UBYTE    = TypeInt::make(0, 255,        WidenMin); \/\/ Unsigned Bytes\n+  TypeInt::CHAR     = TypeInt::make(0, 65535,      WidenMin); \/\/ Java chars\n+  TypeInt::SHORT    = TypeInt::make(-32768, 32767, WidenMin); \/\/ Java shorts\n+  TypeInt::NON_ZERO = TypeInt::make_or_top(TypeIntPrototype<jint, juint>{{min_jint, max_jint}, {1, max_juint}, {0, 0}}, WidenMin)->is_int();\n+  TypeInt::POS      = TypeInt::make(0, max_jint,   WidenMin); \/\/ Non-neg values\n+  TypeInt::POS1     = TypeInt::make(1, max_jint,   WidenMin); \/\/ Positive values\n+  TypeInt::INT      = TypeInt::make(min_jint, max_jint, WidenMax); \/\/ 32-bit integers\n+  TypeInt::SYMINT   = TypeInt::make(-max_jint, max_jint, WidenMin); \/\/ symmetric range\n+  TypeInt::TYPE_DOMAIN = TypeInt::INT;\n@@ -510,1 +512,1 @@\n-  \/\/ a trinary (-1,0,+1) integer result AND as an efficient long\n+  \/\/ a trinary (-1, 0, +1) integer result AND as an efficient long\n@@ -512,16 +514,17 @@\n-  assert( TypeInt::CC_LT == TypeInt::MINUS_1, \"types must match for CmpL to work\" );\n-  assert( TypeInt::CC_GT == TypeInt::ONE,     \"types must match for CmpL to work\" );\n-  assert( TypeInt::CC_EQ == TypeInt::ZERO,    \"types must match for CmpL to work\" );\n-  assert( TypeInt::CC_GE == TypeInt::BOOL,    \"types must match for CmpL to work\" );\n-  assert( (juint)(TypeInt::CC->_hi - TypeInt::CC->_lo) <= SMALLINT, \"CC is truly small\");\n-\n-  TypeLong::MAX = TypeLong::make(max_jlong);  \/\/ Long MAX\n-  TypeLong::MIN = TypeLong::make(min_jlong);  \/\/ Long MIN\n-  TypeLong::MINUS_1 = TypeLong::make(-1);        \/\/ -1\n-  TypeLong::ZERO    = TypeLong::make( 0);        \/\/  0\n-  TypeLong::ONE     = TypeLong::make( 1);        \/\/  1\n-  TypeLong::POS     = TypeLong::make(0,max_jlong, WidenMin); \/\/ Non-neg values\n-  TypeLong::LONG    = TypeLong::make(min_jlong,max_jlong,WidenMax); \/\/ 64-bit integers\n-  TypeLong::INT     = TypeLong::make((jlong)min_jint,(jlong)max_jint,WidenMin);\n-  TypeLong::UINT    = TypeLong::make(0,(jlong)max_juint,WidenMin);\n-  TypeLong::TYPE_DOMAIN  = TypeLong::LONG;\n+  assert(TypeInt::CC_LT == TypeInt::MINUS_1, \"types must match for CmpL to work\" );\n+  assert(TypeInt::CC_GT == TypeInt::ONE,     \"types must match for CmpL to work\" );\n+  assert(TypeInt::CC_EQ == TypeInt::ZERO,    \"types must match for CmpL to work\" );\n+  assert(TypeInt::CC_GE == TypeInt::BOOL,    \"types must match for CmpL to work\" );\n+\n+  TypeLong::MAX = TypeLong::make(max_jlong); \/\/ Long MAX\n+  TypeLong::MIN = TypeLong::make(min_jlong); \/\/ Long MIN\n+  TypeLong::MINUS_1  = TypeLong::make(-1);   \/\/ -1\n+  TypeLong::ZERO     = TypeLong::make( 0);   \/\/  0\n+  TypeLong::ONE      = TypeLong::make( 1);   \/\/  1\n+  TypeLong::NON_ZERO = TypeLong::make_or_top(TypeIntPrototype<jlong, julong>{{min_jlong, max_jlong}, {1, max_julong}, {0, 0}}, WidenMin)->is_long();\n+  TypeLong::POS      = TypeLong::make(0, max_jlong, WidenMin); \/\/ Non-neg values\n+  TypeLong::NEG      = TypeLong::make(min_jlong, -1, WidenMin);\n+  TypeLong::LONG     = TypeLong::make(min_jlong, max_jlong, WidenMax); \/\/ 64-bit integers\n+  TypeLong::INT      = TypeLong::make((jlong)min_jint, (jlong)max_jint,WidenMin);\n+  TypeLong::UINT     = TypeLong::make(0, (jlong)max_juint, WidenMin);\n+  TypeLong::TYPE_DOMAIN = TypeLong::LONG;\n@@ -1748,25 +1751,23 @@\n-const TypeInt *TypeInt::MAX;    \/\/ INT_MAX\n-const TypeInt *TypeInt::MIN;    \/\/ INT_MIN\n-const TypeInt *TypeInt::MINUS_1;\/\/ -1\n-const TypeInt *TypeInt::ZERO;   \/\/ 0\n-const TypeInt *TypeInt::ONE;    \/\/ 1\n-const TypeInt *TypeInt::BOOL;   \/\/ 0 or 1, FALSE or TRUE.\n-const TypeInt *TypeInt::CC;     \/\/ -1,0 or 1, condition codes\n-const TypeInt *TypeInt::CC_LT;  \/\/ [-1]  == MINUS_1\n-const TypeInt *TypeInt::CC_GT;  \/\/ [1]   == ONE\n-const TypeInt *TypeInt::CC_EQ;  \/\/ [0]   == ZERO\n-const TypeInt *TypeInt::CC_LE;  \/\/ [-1,0]\n-const TypeInt *TypeInt::CC_GE;  \/\/ [0,1] == BOOL (!)\n-const TypeInt *TypeInt::BYTE;   \/\/ Bytes, -128 to 127\n-const TypeInt *TypeInt::UBYTE;  \/\/ Unsigned Bytes, 0 to 255\n-const TypeInt *TypeInt::CHAR;   \/\/ Java chars, 0-65535\n-const TypeInt *TypeInt::SHORT;  \/\/ Java shorts, -32768-32767\n-const TypeInt *TypeInt::POS;    \/\/ Positive 32-bit integers or zero\n-const TypeInt *TypeInt::POS1;   \/\/ Positive 32-bit integers\n-const TypeInt *TypeInt::INT;    \/\/ 32-bit integers\n-const TypeInt *TypeInt::SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n-const TypeInt *TypeInt::TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n-\n-\/\/------------------------------TypeInt----------------------------------------\n-TypeInt::TypeInt( jint lo, jint hi, int w ) : TypeInteger(Int, w), _lo(lo), _hi(hi) {\n-}\n+const TypeInt* TypeInt::MAX;    \/\/ INT_MAX\n+const TypeInt* TypeInt::MIN;    \/\/ INT_MIN\n+const TypeInt* TypeInt::MINUS_1;\/\/ -1\n+const TypeInt* TypeInt::ZERO;   \/\/ 0\n+const TypeInt* TypeInt::ONE;    \/\/ 1\n+const TypeInt* TypeInt::BOOL;   \/\/ 0 or 1, FALSE or TRUE.\n+const TypeInt* TypeInt::CC;     \/\/ -1,0 or 1, condition codes\n+const TypeInt* TypeInt::CC_LT;  \/\/ [-1]  == MINUS_1\n+const TypeInt* TypeInt::CC_GT;  \/\/ [1]   == ONE\n+const TypeInt* TypeInt::CC_EQ;  \/\/ [0]   == ZERO\n+const TypeInt* TypeInt::CC_NE;\n+const TypeInt* TypeInt::CC_LE;  \/\/ [-1,0]\n+const TypeInt* TypeInt::CC_GE;  \/\/ [0,1] == BOOL (!)\n+const TypeInt* TypeInt::BYTE;   \/\/ Bytes, -128 to 127\n+const TypeInt* TypeInt::UBYTE;  \/\/ Unsigned Bytes, 0 to 255\n+const TypeInt* TypeInt::CHAR;   \/\/ Java chars, 0-65535\n+const TypeInt* TypeInt::SHORT;  \/\/ Java shorts, -32768-32767\n+const TypeInt* TypeInt::NON_ZERO;\n+const TypeInt* TypeInt::POS;    \/\/ Positive 32-bit integers or zero\n+const TypeInt* TypeInt::POS1;   \/\/ Positive 32-bit integers\n+const TypeInt* TypeInt::INT;    \/\/ 32-bit integers\n+const TypeInt* TypeInt::SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n+const TypeInt* TypeInt::TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n@@ -1774,3 +1775,4 @@\n-\/\/------------------------------make-------------------------------------------\n-const TypeInt *TypeInt::make( jint lo ) {\n-  return (TypeInt*)(new TypeInt(lo,lo,WidenMin))->hashcons();\n+TypeInt::TypeInt(const TypeIntPrototype<jint, juint>& t, int widen, bool dual)\n+  : TypeInteger(Int, t.normalize_widen(widen), dual), _lo(t._srange._lo), _hi(t._srange._hi),\n+    _ulo(t._urange._lo), _uhi(t._urange._hi), _bits(t._bits) {\n+  DEBUG_ONLY(t.verify_constraints());\n@@ -1779,9 +1781,4 @@\n-static int normalize_int_widen( jint lo, jint hi, int w ) {\n-  \/\/ Certain normalizations keep us sane when comparing types.\n-  \/\/ The 'SMALLINT' covers constants and also CC and its relatives.\n-  if (lo <= hi) {\n-    if (((juint)hi - lo) <= SMALLINT)  w = Type::WidenMin;\n-    if (((juint)hi - lo) >= max_juint) w = Type::WidenMax; \/\/ TypeInt::INT\n-  } else {\n-    if (((juint)lo - hi) <= SMALLINT)  w = Type::WidenMin;\n-    if (((juint)lo - hi) >= max_juint) w = Type::WidenMin; \/\/ dual TypeInt::INT\n+const Type* TypeInt::make_or_top(const TypeIntPrototype<jint, juint>& t, int widen, bool dual) {\n+  auto canonicalized_t = t.canonicalize_constraints();\n+  if (canonicalized_t.empty()) {\n+    return dual ? Type::BOTTOM : Type::TOP;\n@@ -1789,1 +1786,1 @@\n-  return w;\n+  return (new TypeInt(canonicalized_t._data, widen, dual))->hashcons()->is_int();\n@@ -1792,3 +1789,4 @@\n-const TypeInt *TypeInt::make( jint lo, jint hi, int w ) {\n-  w = normalize_int_widen(lo, hi, w);\n-  return (TypeInt*)(new TypeInt(lo,hi,w))->hashcons();\n+const TypeInt* TypeInt::make(jint con) {\n+  juint ucon = con;\n+  return (new TypeInt(TypeIntPrototype<jint, juint>{{con, con}, {ucon, ucon}, {~ucon, ucon}},\n+                      WidenMin, false))->hashcons()->is_int();\n@@ -1797,44 +1795,3 @@\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type representation object\n-\/\/ with reference count equal to the number of Types pointing at it.\n-\/\/ Caller should wrap a Types around it.\n-const Type *TypeInt::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type?\n-\n-  \/\/ Currently \"this->_base\" is a TypeInt\n-  switch (t->base()) {          \/\/ Switch on original type\n-  case AnyPtr:                  \/\/ Mixing with oops happens when javac\n-  case RawPtr:                  \/\/ reuses local variables\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Long:\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-  case Top:                     \/\/ No change\n-    return this;\n-  case Int:                     \/\/ Int vs Int?\n-    break;\n-  }\n-\n-  \/\/ Expand covered set\n-  const TypeInt *r = t->is_int();\n-  return make( MIN2(_lo,r->_lo), MAX2(_hi,r->_hi), MAX2(_widen,r->_widen) );\n+const TypeInt* TypeInt::make(jint lo, jint hi, int widen) {\n+  assert(lo <= hi, \"must be legal bounds\");\n+  return make_or_top(TypeIntPrototype<jint, juint>{{lo, hi}, {0, max_juint}, {0, 0}}, widen)->is_int();\n@@ -1843,55 +1800,3 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: reverse hi & lo; flip widen\n-const Type *TypeInt::xdual() const {\n-  int w = normalize_int_widen(_hi,_lo, WidenMax-_widen);\n-  return new TypeInt(_hi,_lo,w);\n-}\n-\n-\/\/------------------------------widen------------------------------------------\n-\/\/ Only happens for optimistic top-down optimizations.\n-const Type *TypeInt::widen( const Type *old, const Type* limit ) const {\n-  \/\/ Coming from TOP or such; no widening\n-  if( old->base() != Int ) return this;\n-  const TypeInt *ot = old->is_int();\n-\n-  \/\/ If new guy is equal to old guy, no widening\n-  if( _lo == ot->_lo && _hi == ot->_hi )\n-    return old;\n-\n-  \/\/ If new guy contains old, then we widened\n-  if( _lo <= ot->_lo && _hi >= ot->_hi ) {\n-    \/\/ New contains old\n-    \/\/ If new guy is already wider than old, no widening\n-    if( _widen > ot->_widen ) return this;\n-    \/\/ If old guy was a constant, do not bother\n-    if (ot->_lo == ot->_hi)  return this;\n-    \/\/ Now widen new guy.\n-    \/\/ Check for widening too far\n-    if (_widen == WidenMax) {\n-      int max = max_jint;\n-      int min = min_jint;\n-      if (limit->isa_int()) {\n-        max = limit->is_int()->_hi;\n-        min = limit->is_int()->_lo;\n-      }\n-      if (min < _lo && _hi < max) {\n-        \/\/ If neither endpoint is extremal yet, push out the endpoint\n-        \/\/ which is closer to its respective limit.\n-        if (_lo >= 0 ||                 \/\/ easy common case\n-            ((juint)_lo - min) >= ((juint)max - _hi)) {\n-          \/\/ Try to widen to an unsigned range type of 31 bits:\n-          return make(_lo, max, WidenMax);\n-        } else {\n-          return make(min, _hi, WidenMax);\n-        }\n-      }\n-      return TypeInt::INT;\n-    }\n-    \/\/ Returned widened new guy\n-    return make(_lo,_hi,_widen+1);\n-  }\n-\n-  \/\/ If old guy contains new, then we probably widened too far & dropped to\n-  \/\/ bottom.  Return the wider fellow.\n-  if ( ot->_lo <= _lo && ot->_hi >= _hi )\n-    return old;\n+const Type* TypeInt::make_or_top(const TypeIntPrototype<jint, juint>& t, int widen) {\n+  return make_or_top(t, widen, false);\n+}\n@@ -1899,3 +1804,6 @@\n-  \/\/fatal(\"Integer value range is not subset\");\n-  \/\/return this;\n-  return TypeInt::INT;\n+bool TypeInt::contains(jint i) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  juint u = i;\n+  return i >= _lo && i <= _hi &&\n+         u >= _ulo && u <= _uhi &&\n+         _bits.is_satisfied_by(u);\n@@ -1904,9 +1812,4 @@\n-\/\/------------------------------narrow---------------------------------------\n-\/\/ Only happens for pessimistic optimizations.\n-const Type *TypeInt::narrow( const Type *old ) const {\n-  if (_lo >= _hi)  return this;   \/\/ already narrow enough\n-  if (old == nullptr)  return this;\n-  const TypeInt* ot = old->isa_int();\n-  if (ot == nullptr)  return this;\n-  jint olo = ot->_lo;\n-  jint ohi = ot->_hi;\n+bool TypeInt::contains(const TypeInt* t) const {\n+  assert(!_is_dual && !t->_is_dual, \"dual types should only be used for join calculation\");\n+  return TypeIntHelper::int_type_is_subset(this, t);\n+}\n@@ -1914,2 +1817,3 @@\n-  \/\/ If new guy is equal to old guy, no narrowing\n-  if (_lo == olo && _hi == ohi)  return old;\n+const Type* TypeInt::xmeet(const Type* t) const {\n+  return TypeIntHelper::int_type_xmeet(this, t);\n+}\n@@ -1917,2 +1821,4 @@\n-  \/\/ If old guy was maximum range, allow the narrowing\n-  if (olo == min_jint && ohi == max_jint)  return this;\n+const Type* TypeInt::xdual() const {\n+  return new TypeInt(TypeIntPrototype<jint, juint>{{_lo, _hi}, {_ulo, _uhi}, _bits},\n+                     _widen, !_is_dual);\n+}\n@@ -1920,2 +1826,4 @@\n-  if (_lo < olo || _hi > ohi)\n-    return this;                \/\/ doesn't narrow; pretty weird\n+const Type* TypeInt::widen(const Type* old, const Type* limit) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  return TypeIntHelper::int_type_widen(this, old->isa_int(), limit->isa_int());\n+}\n@@ -1923,8 +1831,4 @@\n-  \/\/ The new type narrows the old type, so look for a \"death march\".\n-  \/\/ See comments on PhaseTransform::saturate.\n-  juint nrange = (juint)_hi - _lo;\n-  juint orange = (juint)ohi - olo;\n-  if (nrange < max_juint - 1 && nrange > (orange >> 1) + (SMALLINT*2)) {\n-    \/\/ Use the new type only if the range shrinks a lot.\n-    \/\/ We do not want the optimizer computing 2^31 point by point.\n-    return old;\n+const Type* TypeInt::narrow(const Type* old) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  if (old == nullptr) {\n+    return this;\n@@ -1933,1 +1837,1 @@\n-  return this;\n+  return TypeIntHelper::int_type_narrow(this, old->isa_int());\n@@ -1937,1 +1841,2 @@\n-const Type *TypeInt::filter_helper(const Type *kills, bool include_speculative) const {\n+const Type* TypeInt::filter_helper(const Type* kills, bool include_speculative) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n@@ -1939,1 +1844,1 @@\n-  if (ft == nullptr || ft->empty())\n+  if (ft == nullptr) {\n@@ -1941,0 +1846,2 @@\n+  }\n+  assert(!ft->_is_dual, \"dual types should only be used for join calculation\");\n@@ -1944,1 +1851,2 @@\n-    ft = TypeInt::make(ft->_lo, ft->_hi, this->_widen);\n+    return (new TypeInt(TypeIntPrototype<jint, juint>{{ft->_lo, ft->_hi}, {ft->_ulo, ft->_uhi}, ft->_bits},\n+                        this->_widen, false))->hashcons();\n@@ -1951,3 +1859,3 @@\n-bool TypeInt::eq( const Type *t ) const {\n-  const TypeInt *r = t->is_int(); \/\/ Handy access\n-  return r->_lo == _lo && r->_hi == _hi && r->_widen == _widen;\n+bool TypeInt::eq(const Type* t) const {\n+  const TypeInt* r = t->is_int();\n+  return TypeIntHelper::int_type_is_equal(this, r) && _widen == r->_widen && _is_dual == r->_is_dual;\n@@ -1959,1 +1867,2 @@\n-  return (uint)_lo + (uint)_hi + (uint)_widen + (uint)Type::Int;\n+  return (uint)_lo + (uint)_hi + (uint)_ulo + (uint)_uhi +\n+         (uint)_bits._zeros + (uint)_bits._ones + (uint)_widen + (uint)_is_dual + (uint)Type::Int;\n@@ -1968,43 +1877,0 @@\n-\/\/------------------------------dump2------------------------------------------\n-\/\/ Dump TypeInt\n-#ifndef PRODUCT\n-static const char* intname(char* buf, size_t buf_size, jint n) {\n-  if (n == min_jint)\n-    return \"min\";\n-  else if (n < min_jint + 10000)\n-    os::snprintf_checked(buf, buf_size, \"min+\" INT32_FORMAT, n - min_jint);\n-  else if (n == max_jint)\n-    return \"max\";\n-  else if (n > max_jint - 10000)\n-    os::snprintf_checked(buf, buf_size, \"max-\" INT32_FORMAT, max_jint - n);\n-  else\n-    os::snprintf_checked(buf, buf_size, INT32_FORMAT, n);\n-  return buf;\n-}\n-\n-void TypeInt::dump2( Dict &d, uint depth, outputStream *st ) const {\n-  char buf[40], buf2[40];\n-  if (_lo == min_jint && _hi == max_jint)\n-    st->print(\"int\");\n-  else if (is_con())\n-    st->print(\"int:%s\", intname(buf, sizeof(buf), get_con()));\n-  else if (_lo == BOOL->_lo && _hi == BOOL->_hi)\n-    st->print(\"bool\");\n-  else if (_lo == BYTE->_lo && _hi == BYTE->_hi)\n-    st->print(\"byte\");\n-  else if (_lo == CHAR->_lo && _hi == CHAR->_hi)\n-    st->print(\"char\");\n-  else if (_lo == SHORT->_lo && _hi == SHORT->_hi)\n-    st->print(\"short\");\n-  else if (_hi == max_jint)\n-    st->print(\"int:>=%s\", intname(buf, sizeof(buf), _lo));\n-  else if (_lo == min_jint)\n-    st->print(\"int:<=%s\", intname(buf, sizeof(buf), _hi));\n-  else\n-    st->print(\"int:%s..%s\", intname(buf, sizeof(buf), _lo), intname(buf2, sizeof(buf2), _hi));\n-\n-  if (_widen != 0 && this != TypeInt::INT)\n-    st->print(\":%.*s\", _widen, \"wwww\");\n-}\n-#endif\n-\n@@ -2015,1 +1881,1 @@\n-  return _lo >= _hi;\n+  return _lo == _hi;\n@@ -2019,1 +1885,1 @@\n-  return _lo > _hi;\n+  return false;\n@@ -2024,10 +1890,12 @@\n-const TypeLong *TypeLong::MAX;\n-const TypeLong *TypeLong::MIN;\n-const TypeLong *TypeLong::MINUS_1;\/\/ -1\n-const TypeLong *TypeLong::ZERO; \/\/ 0\n-const TypeLong *TypeLong::ONE;  \/\/ 1\n-const TypeLong *TypeLong::POS;  \/\/ >=0\n-const TypeLong *TypeLong::LONG; \/\/ 64-bit integers\n-const TypeLong *TypeLong::INT;  \/\/ 32-bit subrange\n-const TypeLong *TypeLong::UINT; \/\/ 32-bit unsigned subrange\n-const TypeLong *TypeLong::TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n+const TypeLong* TypeLong::MAX;\n+const TypeLong* TypeLong::MIN;\n+const TypeLong* TypeLong::MINUS_1;\/\/ -1\n+const TypeLong* TypeLong::ZERO; \/\/ 0\n+const TypeLong* TypeLong::ONE;  \/\/ 1\n+const TypeLong* TypeLong::NON_ZERO;\n+const TypeLong* TypeLong::POS;  \/\/ >=0\n+const TypeLong* TypeLong::NEG;\n+const TypeLong* TypeLong::LONG; \/\/ 64-bit integers\n+const TypeLong* TypeLong::INT;  \/\/ 32-bit subrange\n+const TypeLong* TypeLong::UINT; \/\/ 32-bit unsigned subrange\n+const TypeLong* TypeLong::TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n@@ -2035,2 +1903,4 @@\n-\/\/------------------------------TypeLong---------------------------------------\n-TypeLong::TypeLong(jlong lo, jlong hi, int w) : TypeInteger(Long, w), _lo(lo), _hi(hi) {\n+TypeLong::TypeLong(const TypeIntPrototype<jlong, julong>& t, int widen, bool dual)\n+  : TypeInteger(Long, t.normalize_widen(widen), dual), _lo(t._srange._lo), _hi(t._srange._hi),\n+    _ulo(t._urange._lo), _uhi(t._urange._hi), _bits(t._bits) {\n+  DEBUG_ONLY(t.verify_constraints());\n@@ -2039,14 +1909,4 @@\n-\/\/------------------------------make-------------------------------------------\n-const TypeLong *TypeLong::make( jlong lo ) {\n-  return (TypeLong*)(new TypeLong(lo,lo,WidenMin))->hashcons();\n-}\n-\n-static int normalize_long_widen( jlong lo, jlong hi, int w ) {\n-  \/\/ Certain normalizations keep us sane when comparing types.\n-  \/\/ The 'SMALLINT' covers constants.\n-  if (lo <= hi) {\n-    if (((julong)hi - lo) <= SMALLINT)   w = Type::WidenMin;\n-    if (((julong)hi - lo) >= max_julong) w = Type::WidenMax; \/\/ TypeLong::LONG\n-  } else {\n-    if (((julong)lo - hi) <= SMALLINT)   w = Type::WidenMin;\n-    if (((julong)lo - hi) >= max_julong) w = Type::WidenMin; \/\/ dual TypeLong::LONG\n+const Type* TypeLong::make_or_top(const TypeIntPrototype<jlong, julong>& t, int widen, bool dual) {\n+  auto canonicalized_t = t.canonicalize_constraints();\n+  if (canonicalized_t.empty()) {\n+    return dual ? Type::BOTTOM : Type::TOP;\n@@ -2054,1 +1914,1 @@\n-  return w;\n+  return (new TypeLong(canonicalized_t._data, widen, dual))->hashcons()->is_long();\n@@ -2057,3 +1917,4 @@\n-const TypeLong *TypeLong::make( jlong lo, jlong hi, int w ) {\n-  w = normalize_long_widen(lo, hi, w);\n-  return (TypeLong*)(new TypeLong(lo,hi,w))->hashcons();\n+const TypeLong* TypeLong::make(jlong con) {\n+  julong ucon = con;\n+  return (new TypeLong(TypeIntPrototype<jlong, julong>{{con, con}, {ucon, ucon}, {~ucon, ucon}},\n+                       WidenMin, false))->hashcons()->is_long();\n@@ -2062,45 +1923,3 @@\n-\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type representation object\n-\/\/ with reference count equal to the number of Types pointing at it.\n-\/\/ Caller should wrap a Types around it.\n-const Type *TypeLong::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type?\n-\n-  \/\/ Currently \"this->_base\" is a TypeLong\n-  switch (t->base()) {          \/\/ Switch on original type\n-  case AnyPtr:                  \/\/ Mixing with oops happens when javac\n-  case RawPtr:                  \/\/ reuses local variables\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Int:\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-  case Top:                     \/\/ No change\n-    return this;\n-  case Long:                    \/\/ Long vs Long?\n-    break;\n-  }\n-\n-  \/\/ Expand covered set\n-  const TypeLong *r = t->is_long(); \/\/ Turn into a TypeLong\n-  return make( MIN2(_lo,r->_lo), MAX2(_hi,r->_hi), MAX2(_widen,r->_widen) );\n+const TypeLong* TypeLong::make(jlong lo, jlong hi, int widen) {\n+  assert(lo <= hi, \"must be legal bounds\");\n+  return make_or_top(TypeIntPrototype<jlong, julong>{{lo, hi}, {0, max_julong}, {0, 0}}, widen)->is_long();\n@@ -2109,58 +1928,3 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: reverse hi & lo; flip widen\n-const Type *TypeLong::xdual() const {\n-  int w = normalize_long_widen(_hi,_lo, WidenMax-_widen);\n-  return new TypeLong(_hi,_lo,w);\n-}\n-\n-\/\/------------------------------widen------------------------------------------\n-\/\/ Only happens for optimistic top-down optimizations.\n-const Type *TypeLong::widen( const Type *old, const Type* limit ) const {\n-  \/\/ Coming from TOP or such; no widening\n-  if( old->base() != Long ) return this;\n-  const TypeLong *ot = old->is_long();\n-\n-  \/\/ If new guy is equal to old guy, no widening\n-  if( _lo == ot->_lo && _hi == ot->_hi )\n-    return old;\n-\n-  \/\/ If new guy contains old, then we widened\n-  if( _lo <= ot->_lo && _hi >= ot->_hi ) {\n-    \/\/ New contains old\n-    \/\/ If new guy is already wider than old, no widening\n-    if( _widen > ot->_widen ) return this;\n-    \/\/ If old guy was a constant, do not bother\n-    if (ot->_lo == ot->_hi)  return this;\n-    \/\/ Now widen new guy.\n-    \/\/ Check for widening too far\n-    if (_widen == WidenMax) {\n-      jlong max = max_jlong;\n-      jlong min = min_jlong;\n-      if (limit->isa_long()) {\n-        max = limit->is_long()->_hi;\n-        min = limit->is_long()->_lo;\n-      }\n-      if (min < _lo && _hi < max) {\n-        \/\/ If neither endpoint is extremal yet, push out the endpoint\n-        \/\/ which is closer to its respective limit.\n-        if (_lo >= 0 ||                 \/\/ easy common case\n-            ((julong)_lo - min) >= ((julong)max - _hi)) {\n-          \/\/ Try to widen to an unsigned range type of 32\/63 bits:\n-          if (max >= max_juint && _hi < max_juint)\n-            return make(_lo, max_juint, WidenMax);\n-          else\n-            return make(_lo, max, WidenMax);\n-        } else {\n-          return make(min, _hi, WidenMax);\n-        }\n-      }\n-      return TypeLong::LONG;\n-    }\n-    \/\/ Returned widened new guy\n-    return make(_lo,_hi,_widen+1);\n-  }\n-\n-  \/\/ If old guy contains new, then we probably widened too far & dropped to\n-  \/\/ bottom.  Return the wider fellow.\n-  if ( ot->_lo <= _lo && ot->_hi >= _hi )\n-    return old;\n+const Type* TypeLong::make_or_top(const TypeIntPrototype<jlong, julong>& t, int widen) {\n+  return make_or_top(t, widen, false);\n+}\n@@ -2168,3 +1932,6 @@\n-  \/\/  fatal(\"Long value range is not subset\");\n-  \/\/ return this;\n-  return TypeLong::LONG;\n+bool TypeLong::contains(jlong i) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  julong u = i;\n+  return i >= _lo && i <= _hi &&\n+         u >= _ulo && u <= _uhi &&\n+         _bits.is_satisfied_by(u);\n@@ -2173,9 +1940,4 @@\n-\/\/------------------------------narrow----------------------------------------\n-\/\/ Only happens for pessimistic optimizations.\n-const Type *TypeLong::narrow( const Type *old ) const {\n-  if (_lo >= _hi)  return this;   \/\/ already narrow enough\n-  if (old == nullptr)  return this;\n-  const TypeLong* ot = old->isa_long();\n-  if (ot == nullptr)  return this;\n-  jlong olo = ot->_lo;\n-  jlong ohi = ot->_hi;\n+bool TypeLong::contains(const TypeLong* t) const {\n+  assert(!_is_dual && !t->_is_dual, \"dual types should only be used for join calculation\");\n+  return TypeIntHelper::int_type_is_subset(this, t);\n+}\n@@ -2183,2 +1945,3 @@\n-  \/\/ If new guy is equal to old guy, no narrowing\n-  if (_lo == olo && _hi == ohi)  return old;\n+const Type* TypeLong::xmeet(const Type* t) const {\n+  return TypeIntHelper::int_type_xmeet(this, t);\n+}\n@@ -2186,2 +1949,4 @@\n-  \/\/ If old guy was maximum range, allow the narrowing\n-  if (olo == min_jlong && ohi == max_jlong)  return this;\n+const Type* TypeLong::xdual() const {\n+  return new TypeLong(TypeIntPrototype<jlong, julong>{{_lo, _hi}, {_ulo, _uhi}, _bits},\n+                      _widen, !_is_dual);\n+}\n@@ -2189,2 +1954,4 @@\n-  if (_lo < olo || _hi > ohi)\n-    return this;                \/\/ doesn't narrow; pretty weird\n+const Type* TypeLong::widen(const Type* old, const Type* limit) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  return TypeIntHelper::int_type_widen(this, old->isa_long(), limit->isa_long());\n+}\n@@ -2192,8 +1959,4 @@\n-  \/\/ The new type narrows the old type, so look for a \"death march\".\n-  \/\/ See comments on PhaseTransform::saturate.\n-  julong nrange = (julong)_hi - _lo;\n-  julong orange = (julong)ohi - olo;\n-  if (nrange < max_julong - 1 && nrange > (orange >> 1) + (SMALLINT*2)) {\n-    \/\/ Use the new type only if the range shrinks a lot.\n-    \/\/ We do not want the optimizer computing 2^31 point by point.\n-    return old;\n+const Type* TypeLong::narrow(const Type* old) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  if (old == nullptr) {\n+    return this;\n@@ -2202,1 +1965,1 @@\n-  return this;\n+  return TypeIntHelper::int_type_narrow(this, old->isa_long());\n@@ -2206,1 +1969,2 @@\n-const Type *TypeLong::filter_helper(const Type *kills, bool include_speculative) const {\n+const Type* TypeLong::filter_helper(const Type* kills, bool include_speculative) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n@@ -2208,1 +1972,1 @@\n-  if (ft == nullptr || ft->empty())\n+  if (ft == nullptr) {\n@@ -2210,0 +1974,2 @@\n+  }\n+  assert(!ft->_is_dual, \"dual types should only be used for join calculation\");\n@@ -2213,1 +1979,2 @@\n-    ft = TypeLong::make(ft->_lo, ft->_hi, this->_widen);\n+    return (new TypeLong(TypeIntPrototype<jlong, julong>{{ft->_lo, ft->_hi}, {ft->_ulo, ft->_uhi}, ft->_bits},\n+                         this->_widen, false))->hashcons();\n@@ -2220,3 +1987,3 @@\n-bool TypeLong::eq( const Type *t ) const {\n-  const TypeLong *r = t->is_long(); \/\/ Handy access\n-  return r->_lo == _lo &&  r->_hi == _hi  && r->_widen == _widen;\n+bool TypeLong::eq(const Type* t) const {\n+  const TypeLong* r = t->is_long();\n+  return TypeIntHelper::int_type_is_equal(this, r) && _widen == r->_widen && _is_dual == r->_is_dual;\n@@ -2228,1 +1995,2 @@\n-  return (uint)_lo + (uint)_hi + (uint)_widen + (uint)Type::Long;\n+  return (uint)_lo + (uint)_hi + (uint)_ulo + (uint)_uhi +\n+         (uint)_bits._zeros + (uint)_bits._ones + (uint)_widen + (uint)_is_dual + (uint)Type::Long;\n@@ -2237,55 +2005,0 @@\n-\/\/------------------------------dump2------------------------------------------\n-\/\/ Dump TypeLong\n-#ifndef PRODUCT\n-static const char* longnamenear(jlong x, const char* xname, char* buf, size_t buf_size, jlong n) {\n-  if (n > x) {\n-    if (n >= x + 10000)  return nullptr;\n-    os::snprintf_checked(buf, buf_size, \"%s+\" JLONG_FORMAT, xname, n - x);\n-  } else if (n < x) {\n-    if (n <= x - 10000)  return nullptr;\n-    os::snprintf_checked(buf, buf_size, \"%s-\" JLONG_FORMAT, xname, x - n);\n-  } else {\n-    return xname;\n-  }\n-  return buf;\n-}\n-\n-static const char* longname(char* buf, size_t buf_size, jlong n) {\n-  const char* str;\n-  if (n == min_jlong)\n-    return \"min\";\n-  else if (n < min_jlong + 10000)\n-    os::snprintf_checked(buf, buf_size, \"min+\" JLONG_FORMAT, n - min_jlong);\n-  else if (n == max_jlong)\n-    return \"max\";\n-  else if (n > max_jlong - 10000)\n-    os::snprintf_checked(buf, buf_size, \"max-\" JLONG_FORMAT, max_jlong - n);\n-  else if ((str = longnamenear(max_juint, \"maxuint\", buf, buf_size, n)) != nullptr)\n-    return str;\n-  else if ((str = longnamenear(max_jint, \"maxint\", buf, buf_size, n)) != nullptr)\n-    return str;\n-  else if ((str = longnamenear(min_jint, \"minint\", buf, buf_size, n)) != nullptr)\n-    return str;\n-  else\n-    os::snprintf_checked(buf, buf_size, JLONG_FORMAT, n);\n-  return buf;\n-}\n-\n-void TypeLong::dump2( Dict &d, uint depth, outputStream *st ) const {\n-  char buf[80], buf2[80];\n-  if (_lo == min_jlong && _hi == max_jlong)\n-    st->print(\"long\");\n-  else if (is_con())\n-    st->print(\"long:%s\", longname(buf, sizeof(buf), get_con()));\n-  else if (_hi == max_jlong)\n-    st->print(\"long:>=%s\", longname(buf, sizeof(buf), _lo));\n-  else if (_lo == min_jlong)\n-    st->print(\"long:<=%s\", longname(buf, sizeof(buf), _hi));\n-  else\n-    st->print(\"long:%s..%s\", longname(buf, sizeof(buf), _lo), longname(buf2,sizeof(buf2),  _hi));\n-\n-  if (_widen != 0 && this != TypeLong::LONG)\n-    st->print(\":%.*s\", _widen, \"wwww\");\n-}\n-#endif\n-\n@@ -2296,1 +2009,1 @@\n-  return _lo >= _hi;\n+  return _lo == _hi;\n@@ -2300,1 +2013,11 @@\n-  return _lo > _hi;\n+  return false;\n+}\n+\n+\/\/------------------------------dump2------------------------------------------\n+#ifndef PRODUCT\n+void TypeInt::dump2(Dict& d, uint depth, outputStream* st) const {\n+  TypeIntHelper::int_type_dump(this, st, false);\n+}\n+\n+void TypeInt::dump_verbose() const {\n+  TypeIntHelper::int_type_dump(this, tty, true);\n@@ -2303,0 +2026,9 @@\n+void TypeLong::dump2(Dict& d, uint depth, outputStream* st) const {\n+  TypeIntHelper::int_type_dump(this, st, false);\n+}\n+\n+void TypeLong::dump_verbose() const {\n+  TypeIntHelper::int_type_dump(this, tty, true);\n+}\n+#endif\n+\n@@ -2554,1 +2286,7 @@\n-    const TypeAry *a = t->is_ary();\n+    const TypeAry* a = t->is_ary();\n+    const Type* size = _size->xmeet(a->_size);\n+    const TypeInt* isize = size->isa_int();\n+    if (isize == nullptr) {\n+      assert(size == Type::TOP || size == Type::BOTTOM, \"\");\n+      return size;\n+    }\n@@ -2556,2 +2294,1 @@\n-                         _size->xmeet(a->_size)->is_int(),\n-                         _stable && a->_stable);\n+                         isize, _stable && a->_stable);\n@@ -4987,1 +4724,1 @@\n-  if (lo > hi)\n+  if (lo > hi) {\n@@ -4989,1 +4726,2 @@\n-  if (!chg)\n+  }\n+  if (!chg) {\n@@ -4991,0 +4729,1 @@\n+  }\n@@ -5155,1 +4894,6 @@\n-    const TypeAry *tary = _ary->meet_speculative(tap->_ary)->is_ary();\n+    const Type* tm = _ary->meet_speculative(tap->_ary);\n+    const TypeAry* tary = tm->isa_ary();\n+    if (tary == nullptr) {\n+      assert(tm == Type::TOP || tm == Type::BOTTOM, \"\");\n+      return tm;\n+    }\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":232,"deletions":488,"binary":false,"changes":720,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"opto\/compile.hpp\"\n+#include \"opto\/rangeinference.hpp\"\n@@ -76,0 +78,3 @@\n+template <class T, class U>\n+class TypeIntPrototype;\n+\n@@ -298,0 +303,4 @@\n+  \/\/ This has the same semantics as std::dynamic_cast<TypeClass*>(this)\n+  template <typename TypeClass>\n+  const TypeClass* try_cast() const;\n+\n@@ -307,3 +316,3 @@\n-  const TypeH      *isa_half_float() const;          \/\/ Returns null if not a Float{Top,Con,Bot}\n-  const TypeH      *is_half_float_constant() const;  \/\/ Asserts it is a FloatCon\n-  const TypeH      *isa_half_float_constant() const; \/\/ Returns null if not a FloatCon\n+  const TypeH      *isa_half_float() const;          \/\/ Returns null if not a HalfFloat{Top,Con,Bot}\n+  const TypeH      *is_half_float_constant() const;  \/\/ Asserts it is a HalfFloatCon\n+  const TypeH      *isa_half_float_constant() const; \/\/ Returns null if not a HalfFloatCon\n@@ -608,1 +617,6 @@\n-  TypeInteger(TYPES t, int w) : Type(t), _widen(w) {}\n+  TypeInteger(TYPES t, int w, bool dual) : Type(t), _is_dual(dual), _widen(w) {}\n+\n+  \/\/ Denote that a set is a dual set.\n+  \/\/ Dual sets are only used to compute the join of 2 sets, and not used\n+  \/\/ outside.\n+  const bool _is_dual;\n@@ -628,0 +642,148 @@\n+\/**\n+ * Definition:\n+ *\n+ * A TypeInt represents a set of non-empty jint values. A jint v is an element\n+ * of a TypeInt iff:\n+ *\n+ *   v >= _lo && v <= _hi &&\n+ *   juint(v) >= _ulo && juint(v) <= _uhi &&\n+ *   _bits.is_satisfied_by(v)\n+ *\n+ * Multiple sets of parameters can represent the same set.\n+ * E.g: consider 2 TypeInt t1, t2\n+ *\n+ * t1._lo = 2, t1._hi = 7, t1._ulo = 0, t1._uhi = 5, t1._bits._zeros = 0x00000000, t1._bits._ones = 0x1\n+ * t2._lo = 3, t2._hi = 5, t2._ulo = 3, t2._uhi = 5, t2._bits._zeros = 0xFFFFFFF8, t2._bits._ones = 0x1\n+ *\n+ * Then, t1 and t2 both represent the set {3, 5}. We can also see that the\n+ * constraints of t2 are the tightest possible. I.e there exists no TypeInt t3\n+ * which also represents {3, 5} such that any of these would be true:\n+ *\n+ *  1)  t3._lo  > t2._lo\n+ *  2)  t3._hi  < t2._hi\n+ *  3)  t3._ulo > t2._ulo\n+ *  4)  t3._uhi < t2._uhi\n+ *  5)  (t3._bits._zeros &~ t2._bis._zeros) != 0\n+ *  6)  (t3._bits._ones  &~ t2._bits._ones) != 0\n+ *\n+ * The 5-th condition mean that the subtraction of the bitsets represented by\n+ * t3._bits._zeros and t2._bits._zeros is not empty, which means that the\n+ * bits in t3._bits._zeros is not a subset of those in t2._bits._zeros, the\n+ * same applies to _bits._ones\n+ *\n+ * To simplify reasoning about the types in optimizations, we canonicalize\n+ * every TypeInt to its tightest form, already at construction. E.g a TypeInt\n+ * t with t._lo < 0 will definitely contain negative values. It also makes it\n+ * trivial to determine if a TypeInt instance is a subset of another.\n+ *\n+ * Lemmas:\n+ *\n+ * 1. Since every TypeInt instance is non-empty and canonicalized, all the\n+ *   bounds must also be elements of such TypeInt. Or else, we can tighten the\n+ *   bounds by narrowing it by one, which contradicts the assumption of the\n+ *   TypeInt being canonical.\n+ *\n+ * 2.\n+ *   2.1.  _lo <= jint(_ulo)\n+ *   2.2.  _lo <= _hi\n+ *   2.3.  _lo <= jint(_uhi)\n+ *   2.4.  _ulo <= juint(_lo)\n+ *   2.5.  _ulo <= juint(_hi)\n+ *   2.6.  _ulo <= _uhi\n+ *   2.7.  _hi >= _lo\n+ *   2.8.  _hi >= jint(_ulo)\n+ *   2.9.  _hi >= jint(_uhi)\n+ *   2.10. _uhi >= juint(_lo)\n+ *   2.11. _uhi >= _ulo\n+ *   2.12. _uhi >= juint(_hi)\n+ *\n+ *   Proof of lemma 2:\n+ *\n+ *   2.1. _lo <= jint(_ulo):\n+ *     According the lemma 1, _ulo is an element of the TypeInt, so in the\n+ *     signed domain, it must not be less than the smallest element of that\n+ *     TypeInt, which is _lo. Which means that _lo <= _ulo in the signed\n+ *     domain, or in a more programmatical way, _lo <= jint(_ulo).\n+ *   2.2. _lo <= _hi:\n+ *     According the lemma 1, _hi is an element of the TypeInt, so in the\n+ *     signed domain, it must not be less than the smallest element of that\n+ *     TypeInt, which is _lo. Which means that _lo <= _hi.\n+ *\n+ *   The other inequalities can be proved in a similar manner.\n+ *\n+ * 3. Given 2 jint values x, y where either both >= 0 or both < 0. Then:\n+ *\n+ *   x <= y iff juint(x) <= juint(y)\n+ *   I.e. x <= y in the signed domain iff x <= y in the unsigned domain\n+ *\n+ * 4. Either _lo == jint(_ulo) and _hi == jint(_uhi), or each element of a\n+ *   TypeInt lies in either interval [_lo, jint(_uhi)] or [jint(_ulo), _hi]\n+ *   (note that these intervals are disjoint in this case).\n+ *\n+ *   Proof of lemma 4:\n+ *\n+ *   For a TypeInt t, there are 3 possible cases:\n+ *\n+ *   a. t._lo >= 0, we have:\n+ *\n+ *     0 <= t_lo <= jint(t._ulo)           (lemma 2.1)\n+ *     juint(t._lo) <= juint(jint(t._ulo)) (lemma 3)\n+ *                  == t._ulo              (juint(jint(v)) == v with juint v)\n+ *                  <= juint(t._lo)        (lemma 2.4)\n+ *\n+ *     Which means that t._lo == jint(t._ulo).\n+ *\n+ *     Furthermore,\n+ *\n+ *     0 <= t._lo <= t._hi                 (lemma 2.2)\n+ *     0 <= t._lo <= jint(t._uhi)          (lemma 2.3)\n+ *     t._hi >= jint(t._uhi)               (lemma 2.9)\n+ *\n+ *     juint(t._hi) >= juint(jint(t._uhi)) (lemma 3)\n+ *                  == t._uhi              (juint(jint(v)) == v with juint v)\n+ *                  >= juint(t._hi)        (lemma 2.12)\n+ *\n+ *     Which means that t._hi == jint(t._uhi).\n+ *     In this case, t._lo == jint(t._ulo) and t._hi == jint(t._uhi)\n+ *\n+ *   b. t._hi < 0. Similarly, we can conclude that:\n+ *     t._lo == jint(t._ulo) and t._hi == jint(t._uhi)\n+ *\n+ *   c. t._lo < 0, t._hi >= 0.\n+ *\n+ *     Since t._ulo <= juint(t._hi) (lemma 2.5), we must have jint(t._ulo) >= 0\n+ *     because all negative values is larger than all non-negative values in the\n+ *     unsigned domain.\n+ *\n+ *     Since t._uhi >= juint(t._lo) (lemma 2.10), we must have jint(t._uhi) < 0\n+ *     similar to the reasoning above.\n+ *\n+ *     In this case, each element of t belongs to either [t._lo, jint(t._uhi)] or\n+ *     [jint(t._ulo), t._hi].\n+ *\n+ *     Below is an illustration of the TypeInt in this case, the intervals that\n+ *     the elements can be in are marked using the = symbol. Note how the\n+ *     negative range in the signed domain wrap around in the unsigned domain.\n+ *\n+ *     Signed:\n+ *     -----lo=========uhi---------0--------ulo==========hi-----\n+ *     Unsigned:\n+ *                                 0--------ulo==========hi----------lo=========uhi---------\n+ *\n+ *   This property is useful for our analysis of TypeInt values. Additionally,\n+ *   it can be seen that _lo and jint(_uhi) are both < 0 or both >= 0, and the\n+ *   same applies to jint(_ulo) and _hi.\n+ *\n+ *   We call [_lo, jint(_uhi)] and [jint(_ulo), _hi] \"simple intervals\". Then,\n+ *   a TypeInt consists of 2 simple intervals, each of which has its bounds\n+ *   being both >= 0 or both < 0. If both simple intervals lie in the same half\n+ *   of the integer domain, they must be the same (i.e _lo == jint(_ulo) and\n+ *   _hi == jint(_uhi)). Otherwise, [_lo, jint(_uhi)] must lie in the negative\n+ *   half and [jint(_ulo), _hi] must lie in the non-negative half of the signed\n+ *   domain (equivalently, [_lo, jint(_uhi)] must lie in the upper half and\n+ *   [jint(_ulo), _hi] must lie in the lower half of the unsigned domain).\n+ *\/\n+class TypeInt : public TypeInteger {\n+private:\n+  TypeInt(const TypeIntPrototype<jint, juint>& t, int w, bool dual);\n+  static const Type* make_or_top(const TypeIntPrototype<jint, juint>& t, int widen, bool dual);\n@@ -629,0 +791,1 @@\n+  friend class TypeIntHelper;\n@@ -630,6 +793,1 @@\n-\/\/------------------------------TypeInt----------------------------------------\n-\/\/ Class of integer ranges, the set of integers between a lower bound and an\n-\/\/ upper bound, inclusive.\n-class TypeInt : public TypeInteger {\n-  TypeInt( jint lo, jint hi, int w );\n-  virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;\n+  virtual const Type* filter_helper(const Type* kills, bool include_speculative) const;\n@@ -640,1 +798,1 @@\n-  virtual bool eq( const Type *t ) const;\n+  virtual bool eq(const Type* t) const;\n@@ -644,1 +802,5 @@\n-  const jint _lo, _hi;          \/\/ Lower bound, upper bound\n+  \/\/ A value is in the set represented by this TypeInt if it satisfies all\n+  \/\/ the below constraints, see contains(jint)\n+  const jint _lo, _hi;       \/\/ Lower bound, upper bound in the signed domain\n+  const juint _ulo, _uhi;    \/\/ Lower bound, upper bound in the unsigned domain\n+  const KnownBits<juint> _bits;\n@@ -646,1 +808,1 @@\n-  static const TypeInt *make(jint lo);\n+  static const TypeInt* make(jint con);\n@@ -648,1 +810,2 @@\n-  static const TypeInt *make(jint lo, jint hi, int w);\n+  static const TypeInt* make(jint lo, jint hi, int widen);\n+  static const Type* make_or_top(const TypeIntPrototype<jint, juint>& t, int widen);\n@@ -651,1 +814,1 @@\n-  bool is_con() const { return _lo==_hi; }\n+  bool is_con() const { return _lo == _hi; }\n@@ -653,1 +816,5 @@\n-  jint get_con() const { assert(is_con(), \"\" );  return _lo; }\n+  jint get_con() const { assert(is_con(), \"\");  return _lo; }\n+  \/\/ Check if a jint\/TypeInt is a subset of this TypeInt (i.e. all elements of the\n+  \/\/ argument are also elements of this type)\n+  bool contains(jint i) const;\n+  bool contains(const TypeInt* t) const;\n@@ -655,1 +822,1 @@\n-  virtual bool        is_finite() const;  \/\/ Has a finite value\n+  virtual bool is_finite() const;  \/\/ Has a finite value\n@@ -657,4 +824,4 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n-  virtual const Type *widen( const Type *t, const Type* limit_type ) const;\n-  virtual const Type *narrow( const Type *t ) const;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* widen(const Type* t, const Type* limit_type) const;\n+  virtual const Type* narrow(const Type* t) const;\n@@ -667,23 +834,25 @@\n-  static const TypeInt *MAX;\n-  static const TypeInt *MIN;\n-  static const TypeInt *MINUS_1;\n-  static const TypeInt *ZERO;\n-  static const TypeInt *ONE;\n-  static const TypeInt *BOOL;\n-  static const TypeInt *CC;\n-  static const TypeInt *CC_LT;  \/\/ [-1]  == MINUS_1\n-  static const TypeInt *CC_GT;  \/\/ [1]   == ONE\n-  static const TypeInt *CC_EQ;  \/\/ [0]   == ZERO\n-  static const TypeInt *CC_LE;  \/\/ [-1,0]\n-  static const TypeInt *CC_GE;  \/\/ [0,1] == BOOL (!)\n-  static const TypeInt *BYTE;\n-  static const TypeInt *UBYTE;\n-  static const TypeInt *CHAR;\n-  static const TypeInt *SHORT;\n-  static const TypeInt *POS;\n-  static const TypeInt *POS1;\n-  static const TypeInt *INT;\n-  static const TypeInt *SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n-  static const TypeInt *TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n-\n-  static const TypeInt *as_self(const Type *t) { return t->is_int(); }\n+  static const TypeInt* MAX;\n+  static const TypeInt* MIN;\n+  static const TypeInt* MINUS_1;\n+  static const TypeInt* ZERO;\n+  static const TypeInt* ONE;\n+  static const TypeInt* BOOL;\n+  static const TypeInt* CC;\n+  static const TypeInt* CC_LT;  \/\/ [-1]  == MINUS_1\n+  static const TypeInt* CC_GT;  \/\/ [1]   == ONE\n+  static const TypeInt* CC_EQ;  \/\/ [0]   == ZERO\n+  static const TypeInt* CC_NE;  \/\/ [-1, 1]\n+  static const TypeInt* CC_LE;  \/\/ [-1,0]\n+  static const TypeInt* CC_GE;  \/\/ [0,1] == BOOL (!)\n+  static const TypeInt* BYTE;\n+  static const TypeInt* UBYTE;\n+  static const TypeInt* CHAR;\n+  static const TypeInt* SHORT;\n+  static const TypeInt* NON_ZERO;\n+  static const TypeInt* POS;\n+  static const TypeInt* POS1;\n+  static const TypeInt* INT;\n+  static const TypeInt* SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n+  static const TypeInt* TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n+\n+  static const TypeInt* as_self(const Type* t) { return t->is_int(); }\n@@ -691,1 +860,2 @@\n-  virtual void dump2( Dict &d, uint depth, outputStream *st ) const;\n+  virtual void dump2(Dict& d, uint depth, outputStream* st) const;\n+  void dump_verbose() const;\n@@ -695,4 +865,1 @@\n-\n-\/\/------------------------------TypeLong---------------------------------------\n-\/\/ Class of long integer ranges, the set of integers between a lower bound and\n-\/\/ an upper bound, inclusive.\n+\/\/ Similar to TypeInt\n@@ -700,1 +867,6 @@\n-  TypeLong( jlong lo, jlong hi, int w );\n+private:\n+  TypeLong(const TypeIntPrototype<jlong, julong>& t, int w, bool dual);\n+  static const Type* make_or_top(const TypeIntPrototype<jlong, julong>& t, int widen, bool dual);\n+\n+  friend class TypeIntHelper;\n+\n@@ -703,1 +875,1 @@\n-  virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;\n+  virtual const Type* filter_helper(const Type* kills, bool include_speculative) const;\n@@ -711,1 +883,5 @@\n-  const jlong _lo, _hi;         \/\/ Lower bound, upper bound\n+  \/\/ A value is in the set represented by this TypeLong if it satisfies all\n+  \/\/ the below constraints, see contains(jlong)\n+  const jlong _lo, _hi;       \/\/ Lower bound, upper bound in the signed domain\n+  const julong _ulo, _uhi;    \/\/ Lower bound, upper bound in the unsigned domain\n+  const KnownBits<julong> _bits;\n@@ -713,1 +889,1 @@\n-  static const TypeLong *make(jlong lo);\n+  static const TypeLong* make(jlong con);\n@@ -715,1 +891,2 @@\n-  static const TypeLong *make(jlong lo, jlong hi, int w);\n+  static const TypeLong* make(jlong lo, jlong hi, int widen);\n+  static const Type* make_or_top(const TypeIntPrototype<jlong, julong>& t, int widen);\n@@ -718,1 +895,1 @@\n-  bool is_con() const { return _lo==_hi; }\n+  bool is_con() const { return _lo == _hi; }\n@@ -721,0 +898,4 @@\n+  \/\/ Check if a jlong\/TypeLong is a subset of this TypeLong (i.e. all elements of the\n+  \/\/ argument are also elements of this type)\n+  bool contains(jlong i) const;\n+  bool contains(const TypeLong* t) const;\n@@ -730,4 +911,4 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n-  virtual const Type *widen( const Type *t, const Type* limit_type ) const;\n-  virtual const Type *narrow( const Type *t ) const;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* widen(const Type* t, const Type* limit_type) const;\n+  virtual const Type* narrow(const Type* t) const;\n@@ -735,10 +916,12 @@\n-  static const TypeLong *MAX;\n-  static const TypeLong *MIN;\n-  static const TypeLong *MINUS_1;\n-  static const TypeLong *ZERO;\n-  static const TypeLong *ONE;\n-  static const TypeLong *POS;\n-  static const TypeLong *LONG;\n-  static const TypeLong *INT;    \/\/ 32-bit subrange [min_jint..max_jint]\n-  static const TypeLong *UINT;   \/\/ 32-bit unsigned [0..max_juint]\n-  static const TypeLong *TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n+  static const TypeLong* MAX;\n+  static const TypeLong* MIN;\n+  static const TypeLong* MINUS_1;\n+  static const TypeLong* ZERO;\n+  static const TypeLong* ONE;\n+  static const TypeLong* NON_ZERO;\n+  static const TypeLong* POS;\n+  static const TypeLong* NEG;\n+  static const TypeLong* LONG;\n+  static const TypeLong* INT;    \/\/ 32-bit subrange [min_jint..max_jint]\n+  static const TypeLong* UINT;   \/\/ 32-bit unsigned [0..max_juint]\n+  static const TypeLong* TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n@@ -747,1 +930,1 @@\n-  static const TypeLong *as_self(const Type *t) { return t->is_long(); }\n+  static const TypeLong* as_self(const Type* t) { return t->is_long(); }\n@@ -750,1 +933,2 @@\n-  virtual void dump2( Dict &d, uint, outputStream *st  ) const;\/\/ Specialized per-Type dumping\n+  virtual void dump2(Dict& d, uint, outputStream* st) const;\/\/ Specialized per-Type dumping\n+  void dump_verbose() const;\n@@ -2260,0 +2444,10 @@\n+template <>\n+inline const TypeInt* Type::try_cast<TypeInt>() const {\n+  return isa_int();\n+}\n+\n+template <>\n+inline const TypeLong* Type::try_cast<TypeLong>() const {\n+  return isa_long();\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":265,"deletions":71,"binary":false,"changes":336,"status":"modified"},{"patch":"@@ -321,2 +321,4 @@\n-  if (opr == nullptr || vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr ||\n-      !opr->is_con() || vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n+  if (opr          == nullptr || !opr->is_con() ||\n+      vector_klass == nullptr || vector_klass->const_oop() == nullptr ||\n+      elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||\n+      vlen         == nullptr || !vlen->is_con()) {\n@@ -590,1 +592,5 @@\n-  if (mask_klass == nullptr || elem_klass == nullptr || mask->is_top() || vlen == nullptr) {\n+  if (mask_klass == nullptr || mask_klass->const_oop() == nullptr ||\n+      elem_klass == nullptr || elem_klass->const_oop() == nullptr ||\n+      vlen       == nullptr || !vlen->is_con() ||\n+      oper       == nullptr || !oper->is_con() ||\n+      mask->is_top()) {\n@@ -650,3 +656,5 @@\n-  if (vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr || mode == nullptr ||\n-      bits_type == nullptr || vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr ||\n-      !vlen->is_con() || !mode->is_con()) {\n+  if (vector_klass == nullptr || vector_klass->const_oop() == nullptr ||\n+      elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||\n+      vlen         == nullptr || !vlen->is_con() ||\n+      bits_type    == nullptr ||\n+      mode         == nullptr || !mode->is_con()) {\n@@ -778,2 +786,4 @@\n-  if (vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr || !from_ms->is_con() ||\n-      vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n+  if (vector_klass == nullptr || vector_klass->const_oop() == nullptr ||\n+      elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||\n+      vlen         == nullptr || !vlen->is_con() ||\n+      from_ms      == nullptr || !from_ms->is_con()) {\n@@ -986,3 +996,5 @@\n-  if (vector_klass == nullptr || mask_klass == nullptr || elem_klass == nullptr || vlen == nullptr ||\n-      vector_klass->const_oop() == nullptr || mask_klass->const_oop() == nullptr || from_ms == nullptr ||\n-      elem_klass->const_oop() == nullptr || !vlen->is_con() || !from_ms->is_con()) {\n+  if (vector_klass == nullptr || vector_klass->const_oop() == nullptr ||\n+      mask_klass   == nullptr || mask_klass->const_oop()   == nullptr ||\n+      elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||\n+      vlen         == nullptr || !vlen->is_con() ||\n+      from_ms      == nullptr || !from_ms->is_con()) {\n@@ -1194,12 +1206,13 @@\n-\/\/ <C,\n-\/\/  V extends Vector<?>,\n-\/\/  W extends Vector<Integer>,\n-\/\/  S extends VectorSpecies<E>,\n-\/\/  M extends VectorMask<E>,\n-\/\/  E>\n-\/\/ V loadWithMap(Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType, int length,\n-\/\/               Class<? extends Vector<Integer>> vectorIndexClass,\n-\/\/               Object base, long offset, \/\/ Unsafe addressing\n-\/\/               W index_vector, M m,\n-\/\/               C container, int index, int[] indexMap, int indexM, S s, \/\/ Arguments for default implementation\n-\/\/               LoadVectorOperationWithMap<C, V, E, S, M> defaultImpl)\n+\/\/\n+\/\/  <C,\n+\/\/   V extends Vector<?>,\n+\/\/   W extends Vector<Integer>,\n+\/\/   S extends VectorSpecies<E>,\n+\/\/   M extends VectorMask<E>,\n+\/\/   E>\n+\/\/   V loadWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass, int length,\n+\/\/                 Class<? extends Vector<Integer>> vectorIndexClass, int indexLength,\n+\/\/                 Object base, long offset,\n+\/\/                 W indexVector1, W indexVector2, W indexVector3, W indexVector4,\n+\/\/                 M m, C container, int index, int[] indexMap, int indexM, S s,\n+\/\/                 LoadVectorOperationWithMap<C, V, S, M> defaultImpl)\n@@ -1212,5 +1225,6 @@\n-\/\/  void storeWithMap(Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType,\n-\/\/                    int length, Class<? extends Vector<Integer>> vectorIndexClass, Object base, long offset,    \/\/ Unsafe addressing\n-\/\/                    W index_vector, V v, M m,\n-\/\/                    C container, int index, int[] indexMap, int indexM, \/\/ Arguments for default implementation\n-\/\/                    StoreVectorOperationWithMap<C, V, M, E> defaultImpl)\n+\/\/   void storeWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass, int length,\n+\/\/                     Class<? extends Vector<Integer>> vectorIndexClass, int indexLength,\n+\/\/                     Object base, long offset, \/\/ Unsafe addressing\n+\/\/                     W indexVector, V v, M m,\n+\/\/                     C container, int index, int[] indexMap, int indexM, \/\/ Arguments for default implementation\n+\/\/                     StoreVectorOperationWithMap<C, V, M> defaultImpl)\n@@ -1224,4 +1238,8 @@\n-\n-  if (vector_klass == nullptr || elem_klass == nullptr || vector_idx_klass == nullptr || vlen == nullptr ||\n-      vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || vector_idx_klass->const_oop() == nullptr || !vlen->is_con()) {\n-    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s viclass=%s\",\n+  const TypeInt*     idx_vlen         = gvn().type(argument(5))->isa_int();\n+\n+  if (vector_klass     == nullptr || vector_klass->const_oop()     == nullptr ||\n+      elem_klass       == nullptr || elem_klass->const_oop()       == nullptr ||\n+      vlen             == nullptr || !vlen->is_con() ||\n+      vector_idx_klass == nullptr || vector_idx_klass->const_oop() == nullptr ||\n+      idx_vlen         == nullptr || !idx_vlen->is_con()) {\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s viclass=%s idx_vlen=%s\",\n@@ -1231,1 +1249,2 @@\n-                    NodeClassNames[argument(4)->Opcode()]);\n+                    NodeClassNames[argument(4)->Opcode()],\n+                    NodeClassNames[argument(5)->Opcode()]);\n@@ -1248,0 +1267,1 @@\n+  int idx_num_elem = idx_vlen->get_con();\n@@ -1249,1 +1269,2 @@\n-  const Type* vmask_type = gvn().type(is_scatter ? argument(10) : argument(9));\n+  Node* m = is_scatter ? argument(11) : argument(13);\n+  const Type* vmask_type = gvn().type(m);\n@@ -1287,5 +1308,5 @@\n-  if (!is_subword_type(elem_bt) && !arch_supports_vector(Op_LoadVector, num_elem, T_INT, VecMaskNotUsed)) {\n-      log_if_needed(\"  ** not supported: arity=%d op=%s\/loadindex vlen=%d etype=int is_masked_op=%d\",\n-                      is_scatter, is_scatter ? \"scatter\" : \"gather\",\n-                      num_elem, is_masked_op ? 1 : 0);\n-      return false; \/\/ not supported\n+  if (!is_subword_type(elem_bt) && !arch_supports_vector(Op_LoadVector, idx_num_elem, T_INT, VecMaskNotUsed)) {\n+    log_if_needed(\"  ** not supported: arity=%d op=%s\/loadindex vlen=%d etype=int is_masked_op=%d\",\n+                  is_scatter, is_scatter ? \"scatter\" : \"gather\",\n+                  idx_num_elem, is_masked_op ? 1 : 0);\n+    return false; \/\/ not supported\n@@ -1294,2 +1315,2 @@\n-  Node* base = argument(5);\n-  Node* offset = ConvL2X(argument(6));\n+  Node* base = argument(6);\n+  Node* offset = ConvL2X(argument(7));\n@@ -1301,1 +1322,11 @@\n-  Node* addr = make_unsafe_address(base, offset, elem_bt, true);\n+  Node* addr = nullptr;\n+  if (!is_subword_type(elem_bt)) {\n+    addr = make_unsafe_address(base, offset, elem_bt, true);\n+  } else {\n+    assert(!is_scatter, \"Only supports gather operation for subword types now\");\n+    uint header = arrayOopDesc::base_offset_in_bytes(elem_bt);\n+    assert(offset->is_Con() && offset->bottom_type()->is_long()->get_con() == header,\n+           \"offset must be the array base offset\");\n+    Node* index = argument(15);\n+    addr = array_element_address(base, index, elem_bt);\n+  }\n@@ -1303,1 +1334,1 @@\n-  const TypePtr *addr_type = gvn().type(addr)->isa_ptr();\n+  const TypePtr* addr_type = gvn().type(addr)->isa_ptr();\n@@ -1325,1 +1356,2 @@\n-  Node* index_vect = nullptr;\n+  \/\/ Get the indexes for gather\/scatter.\n+  Node* indexes = nullptr;\n@@ -1327,3 +1359,8 @@\n-  if (!is_subword_type(elem_bt)) {\n-    index_vect = unbox_vector(argument(8), vbox_idx_type, T_INT, num_elem);\n-    if (index_vect == nullptr) {\n+  if (is_subword_type(elem_bt)) {\n+    Node* indexMap = argument(16);\n+    Node* indexM   = argument(17);\n+    indexes = array_element_address(indexMap, indexM, T_INT);\n+  } else {\n+    \/\/ Get the first index vector.\n+    indexes = unbox_vector(argument(9), vbox_idx_type, T_INT, idx_num_elem);\n+    if (indexes == nullptr) {\n@@ -1336,0 +1373,1 @@\n+  \/\/ Get the vector mask value.\n@@ -1340,1 +1378,1 @@\n-    mask = unbox_vector(is_scatter ? argument(10) : argument(9), mbox_type, elem_bt, num_elem);\n+    mask = unbox_vector(m, mbox_type, elem_bt, num_elem);\n@@ -1342,3 +1380,1 @@\n-      log_if_needed(\"  ** unbox failed mask=%s\",\n-                    is_scatter ? NodeClassNames[argument(10)->Opcode()]\n-                               : NodeClassNames[argument(9)->Opcode()]);\n+      log_if_needed(\"  ** unbox failed mask=%s\", NodeClassNames[m->Opcode()]);\n@@ -1353,1 +1389,1 @@\n-    Node* val = unbox_vector(argument(9), vbox_type, elem_bt, num_elem);\n+    Node* val = unbox_vector(argument(10), vbox_type, elem_bt, num_elem);\n@@ -1363,1 +1399,1 @@\n-      vstore = gvn().transform(new StoreVectorScatterMaskedNode(control(), memory(addr), addr, addr_type, val, index_vect, mask));\n+      vstore = gvn().transform(new StoreVectorScatterMaskedNode(control(), memory(addr), addr, addr_type, val, indexes, mask));\n@@ -1365,1 +1401,1 @@\n-      vstore = gvn().transform(new StoreVectorScatterNode(control(), memory(addr), addr, addr_type, val, index_vect));\n+      vstore = gvn().transform(new StoreVectorScatterNode(control(), memory(addr), addr, addr_type, val, indexes));\n@@ -1370,9 +1406,1 @@\n-    Node* index    = argument(11);\n-    Node* indexMap = argument(12);\n-    Node* indexM   = argument(13);\n-      if (is_subword_type(elem_bt)) {\n-        Node* index_arr_base = array_element_address(indexMap, indexM, T_INT);\n-        vload = gvn().transform(new LoadVectorGatherMaskedNode(control(), memory(addr), addr, addr_type, vector_type, index_arr_base, mask, index));\n-      } else {\n-        vload = gvn().transform(new LoadVectorGatherMaskedNode(control(), memory(addr), addr, addr_type, vector_type, index_vect, mask));\n-      }\n+      vload = gvn().transform(new LoadVectorGatherMaskedNode(control(), memory(addr), addr, addr_type, vector_type, indexes, mask));\n@@ -1381,6 +1409,1 @@\n-      if (is_subword_type(elem_bt)) {\n-        Node* index_arr_base = array_element_address(indexMap, indexM, T_INT);\n-        vload = gvn().transform(new LoadVectorGatherNode(control(), memory(addr), addr, addr_type, vector_type, index_arr_base, index));\n-      } else {\n-        vload = gvn().transform(new LoadVectorGatherNode(control(), memory(addr), addr, addr_type, vector_type, index_vect));\n-      }\n+      vload = gvn().transform(new LoadVectorGatherNode(control(), memory(addr), addr, addr_type, vector_type, indexes));\n@@ -1393,1 +1416,0 @@\n-\n@@ -1412,2 +1434,4 @@\n-  if (opr == nullptr || vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr ||\n-      !opr->is_con() || vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n+  if (opr          == nullptr || !opr->is_con() ||\n+      vector_klass == nullptr || vector_klass->const_oop() == nullptr ||\n+      elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||\n+      vlen         == nullptr || !vlen->is_con()) {\n@@ -1550,2 +1574,4 @@\n-  if (cond == nullptr || vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr ||\n-      !cond->is_con() || vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n+  if (cond         == nullptr || !cond->is_con() ||\n+      vector_klass == nullptr || vector_klass->const_oop() == nullptr ||\n+      elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||\n+      vlen         == nullptr || !vlen->is_con()) {\n@@ -2508,4 +2534,4 @@\n-  if (vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr || idx == nullptr) {\n-    return false; \/\/ dead code\n-  }\n-  if (vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n+  if (vector_klass == nullptr || vector_klass->const_oop() == nullptr ||\n+      elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||\n+      vlen         == nullptr || !vlen->is_con() ||\n+      idx          == nullptr || !idx->is_con()) {\n@@ -2814,3 +2840,5 @@\n-  if (vector_klass == nullptr || elem_klass == nullptr || mask_klass == nullptr || vlen == nullptr ||\n-      vector_klass->const_oop() == nullptr || mask_klass->const_oop() == nullptr ||\n-      elem_klass->const_oop() == nullptr || !vlen->is_con() || !opr->is_con()) {\n+  if (opr          == nullptr || !opr->is_con() ||\n+      vector_klass == nullptr || vector_klass->const_oop() == nullptr ||\n+      mask_klass   == nullptr || mask_klass->const_oop()   == nullptr ||\n+      elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||\n+      vlen         == nullptr || !vlen->is_con()) {\n@@ -2895,3 +2923,3 @@\n-  if (vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr ||\n-      vector_klass->const_oop() == nullptr || !vlen->is_con() ||\n-      elem_klass->const_oop() == nullptr) {\n+  if (vector_klass == nullptr || vector_klass->const_oop() == nullptr ||\n+      elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||\n+      vlen         == nullptr || !vlen->is_con() ) {\n@@ -3029,2 +3057,3 @@\n-  if (mask_klass == nullptr || elem_klass == nullptr || vlen == nullptr ||\n-      mask_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n+  if (mask_klass == nullptr || mask_klass->const_oop() == nullptr ||\n+      elem_klass == nullptr || elem_klass->const_oop() == nullptr ||\n+      vlen       == nullptr || !vlen->is_con()) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":115,"deletions":86,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -1120,1 +1120,1 @@\n-  LoadVectorGatherNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* offset = nullptr)\n+  LoadVectorGatherNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices)\n@@ -1126,4 +1126,0 @@\n-    assert(is_subword || !offset, \"\");\n-    if (offset) {\n-      add_req(offset);\n-    }\n@@ -1135,4 +1131,1 @@\n-     return idx == MemNode::Address ||\n-            idx == MemNode::ValueIn ||\n-            ((is_subword_type(vect_type()->element_basic_type())) &&\n-              idx == MemNode::ValueIn + 1);\n+     return idx == MemNode::Address || idx == MemNode::ValueIn;\n@@ -1257,1 +1250,1 @@\n-  LoadVectorGatherMaskedNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* mask, Node* offset = nullptr)\n+  LoadVectorGatherMaskedNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* mask)\n@@ -1263,3 +1256,1 @@\n-    if (is_subword_type(vt->element_basic_type())) {\n-      add_req(offset);\n-    }\n+    assert(is_subword_type(vt->element_basic_type()) || indices->bottom_type()->is_vect(), \"indices must be in vector\");\n@@ -1271,3 +1262,1 @@\n-                                                   idx == MemNode::ValueIn + 1 ||\n-                                                   (is_subword_type(vect_type()->is_vect()->element_basic_type()) &&\n-                                                   idx == MemNode::ValueIn + 2); }\n+                                                   idx == MemNode::ValueIn + 1; }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -353,0 +353,9 @@\n+\/\/ Arbitrary (but well-known) tag for GetStringChars\n+const void* STRING_TAG = (void*)0x47114711;\n+\n+\/\/ Arbitrary (but well-known) tag for GetStringUTFChars\n+const void* STRING_UTF_TAG = (void*) 0x48124812;\n+\n+\/\/ Arbitrary (but well-known) tag for GetPrimitiveArrayCritical\n+const void* CRITICAL_TAG = (void*)0x49134913;\n+\n@@ -358,1 +367,1 @@\n-    void* orig_elements) {\n+                                       void* orig_elements, jboolean is_critical = JNI_FALSE) {\n@@ -364,1 +373,1 @@\n-    result = GuardedMemory::wrap_copy(orig_elements, len, orig_elements);\n+    result = GuardedMemory::wrap_copy(orig_elements, len, orig_elements, is_critical ? CRITICAL_TAG : nullptr);\n@@ -370,1 +379,1 @@\n-    void* obj, void* carray, size_t* rsz) {\n+                                 void* obj, void* carray, size_t* rsz, jboolean is_critical) {\n@@ -389,0 +398,23 @@\n+  if (orig_result == STRING_TAG || orig_result == STRING_UTF_TAG) {\n+    bool was_utf = orig_result == STRING_UTF_TAG;\n+    tty->print_cr(\"%s: called on something allocated by %s\",\n+                  fn_name, was_utf ? \"GetStringUTFChars\" : \"GetStringChars\");\n+    DEBUG_ONLY(guarded.print_on(tty);) \/\/ This may crash.\n+    NativeReportJNIFatalError(thr, err_msg(\"%s called on something allocated by %s\",\n+                                           fn_name, was_utf ? \"GetStringUTFChars\" : \"GetStringChars\"));\n+  }\n+\n+  if (is_critical && (guarded.get_tag2() != CRITICAL_TAG)) {\n+    tty->print_cr(\"%s: called on something not allocated by GetPrimitiveArrayCritical\", fn_name);\n+    DEBUG_ONLY(guarded.print_on(tty);) \/\/ This may crash.\n+    NativeReportJNIFatalError(thr, err_msg(\"%s called on something not allocated by GetPrimitiveArrayCritical\",\n+                                           fn_name));\n+  }\n+\n+  if (!is_critical && (guarded.get_tag2() == CRITICAL_TAG)) {\n+    tty->print_cr(\"%s: called on something allocated by GetPrimitiveArrayCritical\", fn_name);\n+    DEBUG_ONLY(guarded.print_on(tty);) \/\/ This may crash.\n+    NativeReportJNIFatalError(thr, err_msg(\"%s called on something allocated by GetPrimitiveArrayCritical\",\n+                                           fn_name));\n+  }\n+\n@@ -398,1 +430,1 @@\n-  void* orig_result = check_wrapped_array(thr, fn_name, obj, carray, &sz);\n+  void* orig_result = check_wrapped_array(thr, fn_name, obj, carray, &sz, is_critical);\n@@ -442,1 +474,1 @@\n-  else if (!Method::is_method_id(method_id)) {\n+  else if (!Method::validate_jmethod_id(method_id)) {\n@@ -1433,3 +1465,0 @@\n-\/\/ Arbitrary (but well-known) tag\n-const void* STRING_TAG = (void*)0x47114711;\n-\n@@ -1538,3 +1567,0 @@\n-\/\/ Arbitrary (but well-known) tag - different than GetStringChars\n-const void* STRING_UTF_TAG = (void*) 0x48124812;\n-\n@@ -1862,1 +1888,1 @@\n-      result = check_jni_wrap_copy_array(thr, array, result);\n+      result = check_jni_wrap_copy_array(thr, array, result, JNI_TRUE);\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":38,"deletions":12,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -85,5 +86,1 @@\n-  return _next;\n-}\n-\n-void JvmtiAgent::set_next(JvmtiAgent* agent) {\n-  _next = agent;\n+  return Atomic::load_acquire(&_next);\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-  void set_next(JvmtiAgent* agent);\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-JvmtiAgent* JvmtiAgentList::_list = nullptr;\n+JvmtiAgent* JvmtiAgentList::_head = nullptr;\n@@ -64,19 +64,1 @@\n-static inline JvmtiAgent* head(JvmtiAgent** list) {\n-  assert(list != nullptr, \"invariant\");\n-  return Atomic::load_acquire(list);\n-}\n-\n-\/\/ The storage list is a single cas-linked-list, to allow for concurrent iterations.\n-\/\/ Especially during initial loading of agents, there exist an order requirement to iterate oldest -> newest.\n-\/\/ Our concurrent storage linked-list is newest -> oldest.\n-\/\/ The correct order is preserved by the iterator, by storing a filtered set of entries in a stack.\n-JvmtiAgentList::Iterator::Iterator(JvmtiAgent** list, Filter filter) :\n-  _stack(new GrowableArrayCHeap<JvmtiAgent*, mtServiceability>(16)), _filter(filter) {\n-  JvmtiAgent* next = head(list);\n-  while (next != nullptr) {\n-    next = select(next);\n-    if (next != nullptr) {\n-      _stack->push(next);\n-      next = next->next();\n-    }\n-  }\n+JvmtiAgentList::Iterator::Iterator(JvmtiAgent* head, Filter filter) : _filter(filter), _next(select(head)) {\n@@ -86,7 +68,1 @@\n-  assert(_stack != nullptr, \"invariant\");\n-  return _stack->is_nonempty();\n-}\n-\n-const JvmtiAgent* JvmtiAgentList::Iterator::next() const {\n-  assert(has_next(), \"invariant\");\n-  return _stack->pop();\n+  return _next != nullptr;\n@@ -96,1 +72,5 @@\n-  return const_cast<JvmtiAgent*>(const_cast<const Iterator*>(this)->next());\n+  assert(_next != nullptr, \"must be\");\n+  JvmtiAgent* result = _next;\n+  _next = select(_next->next());\n+  return result;\n+\n@@ -100,1 +80,1 @@\n-  return Iterator(&_list, Iterator::NOT_XRUN);\n+  return Iterator(head(), Iterator::NOT_XRUN);\n@@ -104,1 +84,1 @@\n-  return Iterator(&_list, Iterator::JAVA);\n+  return Iterator(head(), Iterator::JAVA);\n@@ -108,1 +88,1 @@\n-  return Iterator(&_list, Iterator::NATIVE);\n+  return Iterator(head(), Iterator::NATIVE);\n@@ -112,1 +92,1 @@\n-  return Iterator(&_list, Iterator::XRUN);\n+  return Iterator(head(), Iterator::XRUN);\n@@ -116,1 +96,1 @@\n-  return Iterator(&_list, Iterator::ALL);\n+  return Iterator(head(), Iterator::ALL);\n@@ -121,5 +101,16 @@\n-  JvmtiAgent* next;\n-  do {\n-    next = head(&_list);\n-    agent->set_next(next);\n-  } while (Atomic::cmpxchg(&_list, next, agent) != next);\n+\n+  \/\/ address of the pointer to add new agent (&_head when the list is empty or &agent->_next of the last agent in the list)\n+  JvmtiAgent** tail_ptr = &_head;\n+  while (true) {\n+    JvmtiAgent* next = Atomic::load(tail_ptr);\n+    if (next == nullptr) {\n+      \/\/ *tail_ptr == nullptr here\n+      if (Atomic::cmpxchg(tail_ptr, (JvmtiAgent*)nullptr, agent) != nullptr) {\n+        \/\/ another thread added an agent, reload next from tail_ptr\n+        continue;\n+      }\n+      \/\/ successfully set, exit\n+      break;\n+    }\n+    tail_ptr = &next->_next;\n+  }\n@@ -146,0 +137,4 @@\n+JvmtiAgent* JvmtiAgentList::head() {\n+  return Atomic::load_acquire(&_head);\n+}\n+\n@@ -286,1 +281,1 @@\n-  _list = nullptr; \/\/ Pretend that no agents have been added.\n+  _head = nullptr; \/\/ Pretend that no agents have been added.\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.cpp","additions":34,"deletions":39,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"nmt\/memTag.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n@@ -34,1 +32,1 @@\n-\/\/ Maintains a single cas linked-list of JvmtiAgents.\n+\/\/ Maintains thread-safe linked list of JvmtiAgents.\n@@ -36,1 +34,0 @@\n-  friend class Iterator;\n@@ -49,3 +46,3 @@\n-    GrowableArrayCHeap<JvmtiAgent*, mtServiceability>* _stack;\n-    Iterator() : _stack(nullptr), _filter(ALL) {}\n-    Iterator(JvmtiAgent** list, Filter filter);\n+    JvmtiAgent* _next;\n+    Iterator(): _filter(ALL), _next(nullptr) {}\n+    Iterator(JvmtiAgent* head, Filter filter);\n@@ -57,2 +54,0 @@\n-    const JvmtiAgent* next() const NOT_JVMTI_RETURN_(nullptr);\n-    ~Iterator() { delete _stack; }\n@@ -62,1 +57,3 @@\n-  static JvmtiAgent* _list;\n+  static JvmtiAgent* _head;\n+\n+  static JvmtiAgent* head();\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.hpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"classfile\/classLoaderExt.hpp\"\n@@ -678,1 +677,1 @@\n-    ClassLoaderExt::append_boot_classpath(zip_entry);\n+    ClassLoader::append_boot_classpath(zip_entry);\n@@ -2771,1 +2770,0 @@\n-  bool jmethodids_found = true;\n@@ -2774,0 +2772,3 @@\n+  \/\/ Make jmethodIDs for all non-overpass methods.\n+  ik->make_methods_jmethod_ids();\n+\n@@ -2786,14 +2787,2 @@\n-    jmethodID id;\n-    if (jmethodids_found) {\n-      id = m->find_jmethod_id_or_null();\n-      if (id == nullptr) {\n-        \/\/ If we find an uninitialized value, make sure there is\n-        \/\/ enough space for all the uninitialized values we might\n-        \/\/ find.\n-        ik->ensure_space_for_methodids(index);\n-        jmethodids_found = false;\n-        id = m->jmethod_id();\n-      }\n-    } else {\n-      id = m->jmethod_id();\n-    }\n+    jmethodID id = m->find_jmethod_id_or_null();\n+    assert(id != nullptr, \"should be created above\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -946,1 +946,1 @@\n-            module_entry->module() != nullptr &&\n+            module_entry->module_oop() != nullptr &&\n@@ -951,1 +951,1 @@\n-            Handle class_module(_thread, module_entry->module()); \/\/ Obtain j.l.r.Module\n+            Handle class_module(_thread, module_entry->module_oop()); \/\/ Obtain j.l.r.Module\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -947,0 +947,1 @@\n+  assert(o != nullptr, \"Heap iteration should never produce null!\");\n@@ -956,2 +957,2 @@\n-  if (o != nullptr && o->klass()->java_mirror() == nullptr) {\n-    log_debug(cds, heap)(\"skipped dormant archived object \" INTPTR_FORMAT \" (%s)\", p2i(o),\n+  if (o->klass()->java_mirror() == nullptr) {\n+    log_debug(aot, heap)(\"skipped dormant archived object \" INTPTR_FORMAT \" (%s)\", p2i(o),\n@@ -1035,0 +1036,1 @@\n+  assert(obj != nullptr, \"Heap iteration should never produce null!\");\n@@ -1042,2 +1044,2 @@\n-  if (obj != nullptr &&   obj->klass()->java_mirror() == nullptr) {\n-    log_debug(cds, heap)(\"skipped dormant archived object \" INTPTR_FORMAT \" (%s)\", p2i(obj),\n+  if (obj->klass()->java_mirror() == nullptr) {\n+    log_debug(aot, heap)(\"skipped dormant archived object \" INTPTR_FORMAT \" (%s)\", p2i(obj),\n@@ -2781,1 +2783,1 @@\n-  CLDToOopClosure cld_closure(&blk, false);\n+  CLDToOopClosure cld_closure(&blk, ClassLoaderData::_claim_none);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotLogging.hpp\"\n@@ -88,0 +89,3 @@\n+#if INCLUDE_JVMCI\n+bool   Arguments::_jvmci_module_added           = false;\n+#endif\n@@ -135,0 +139,5 @@\n+struct VMInitArgsGroup {\n+  const JavaVMInitArgs* _args;\n+  JVMFlagOrigin _origin;\n+};\n+\n@@ -334,2 +343,1 @@\n-    if (matches_property_suffix(property_suffix, ADDREADS, ADDREADS_LEN) ||\n-        matches_property_suffix(property_suffix, PATCH, PATCH_LEN) ||\n+    if (matches_property_suffix(property_suffix, PATCH, PATCH_LEN) ||\n@@ -346,0 +354,1 @@\n+          matches_property_suffix(property_suffix, ADDREADS, ADDREADS_LEN) ||\n@@ -522,4 +531,0 @@\n-#ifdef LINUX\n-  { \"UseLinuxPosixThreadCPUClocks\", JDK_Version::jdk(24), JDK_Version::jdk(25), JDK_Version::jdk(26) },\n-  { \"UseOprofile\",                  JDK_Version::jdk(25), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n-#endif\n@@ -530,0 +535,3 @@\n+  { \"ParallelRefProcEnabled\",       JDK_Version::jdk(26),  JDK_Version::jdk(27), JDK_Version::jdk(28) },\n+  { \"ParallelRefProcBalancingEnabled\", JDK_Version::jdk(26),  JDK_Version::jdk(27), JDK_Version::jdk(28) },\n+  { \"PSChunkLargeArrays\",           JDK_Version::jdk(26),  JDK_Version::jdk(27), JDK_Version::jdk(28) },\n@@ -535,0 +543,3 @@\n+#ifdef LINUX\n+  { \"UseOprofile\",                  JDK_Version::jdk(25), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n+#endif\n@@ -538,0 +549,3 @@\n+#if defined(AARCH64)\n+  { \"NearCpool\",                    JDK_Version::undefined(), JDK_Version::jdk(25), JDK_Version::undefined() },\n+#endif\n@@ -1365,1 +1379,1 @@\n-    log_error(cds)(\"%s is incompatible with other specified options.\",\n+    aot_log_error(aot)(\"%s is incompatible with other specified options.\",\n@@ -1374,1 +1388,1 @@\n-      log_warning(cds)(\"Unable to use AOT cache: %s\", message);\n+      log_warning(aot)(\"Unable to use AOT cache: %s\", message);\n@@ -1376,1 +1390,1 @@\n-      log_info(cds)(\"Unable to use shared archive: %s\", message);\n+      aot_log_info(aot)(\"Unable to use shared archive: %s\", message);\n@@ -1565,1 +1579,1 @@\n-          log_info(cds)(\"UseCompressedOops and UseCompressedClassPointers have been disabled due to\"\n+          aot_log_info(aot)(\"UseCompressedOops and UseCompressedClassPointers have been disabled due to\"\n@@ -1801,3 +1815,3 @@\n-    PropertyList_unique_add(&_system_properties, \"jdk.internal.vm.ci.enabled\", \"true\",\n-        AddProperty, UnwriteableProperty, InternalProperty);\n-    if (ClassLoader::is_module_observable(\"jdk.internal.vm.ci\")) {\n+    \/\/ Add the JVMCI module if not using libjvmci or EnableJVMCI\n+    \/\/ was explicitly set on the command line or in the jimage.\n+    if ((!UseJVMCINativeLibrary || FLAG_IS_CMDLINE(EnableJVMCI) || FLAG_IS_JIMAGE_RESOURCE(EnableJVMCI)) && ClassLoader::is_module_observable(\"jdk.internal.vm.ci\") && !_jvmci_module_added) {\n@@ -1826,9 +1840,0 @@\n-#ifndef _LP64\n-  if (LockingMode == LM_LEGACY) {\n-    FLAG_SET_CMDLINE(LockingMode, LM_LIGHTWEIGHT);\n-    \/\/ Self-forwarding in bit 3 of the mark-word conflicts\n-    \/\/ with 4-byte-aligned stack-locks.\n-    warning(\"Legacy locking not supported on this platform\");\n-  }\n-#endif\n-\n@@ -1948,6 +1953,1 @@\n-\/\/ Parse JavaVMInitArgs structure\n-\n-jint Arguments::parse_vm_init_args(const JavaVMInitArgs *vm_options_args,\n-                                   const JavaVMInitArgs *java_tool_options_args,\n-                                   const JavaVMInitArgs *java_options_args,\n-                                   const JavaVMInitArgs *cmd_line_args) {\n+jint Arguments::parse_vm_init_args(GrowableArrayCHeap<VMInitArgsGroup, mtArguments>* all_args) {\n@@ -1966,24 +1966,6 @@\n-  \/\/ Parse args structure generated from java.base vm options resource\n-  jint result = parse_each_vm_init_arg(vm_options_args, JVMFlagOrigin::JIMAGE_RESOURCE);\n-  if (result != JNI_OK) {\n-    return result;\n-  }\n-\n-  \/\/ Parse args structure generated from JAVA_TOOL_OPTIONS environment\n-  \/\/ variable (if present).\n-  result = parse_each_vm_init_arg(java_tool_options_args, JVMFlagOrigin::ENVIRON_VAR);\n-  if (result != JNI_OK) {\n-    return result;\n-  }\n-\n-  \/\/ Parse args structure generated from the command line flags.\n-  result = parse_each_vm_init_arg(cmd_line_args, JVMFlagOrigin::COMMAND_LINE);\n-  if (result != JNI_OK) {\n-    return result;\n-  }\n-\n-  \/\/ Parse args structure generated from the _JAVA_OPTIONS environment\n-  \/\/ variable (if present) (mimics classic VM)\n-  result = parse_each_vm_init_arg(java_options_args, JVMFlagOrigin::ENVIRON_VAR);\n-  if (result != JNI_OK) {\n-    return result;\n+  jint result;\n+  for (int i = 0; i < all_args->length(); i++) {\n+    result = parse_each_vm_init_arg(all_args->at(i)._args, all_args->at(i)._origin);\n+    if (result != JNI_OK) {\n+      return result;\n+    }\n@@ -2250,0 +2232,13 @@\n+#if INCLUDE_JVMCI\n+      if (!_jvmci_module_added) {\n+        const char *jvmci_module = strstr(tail, \"jdk.internal.vm.ci\");\n+        if (jvmci_module != nullptr) {\n+          char before = *(jvmci_module - 1);\n+          char after  = *(jvmci_module + strlen(\"jdk.internal.vm.ci\"));\n+          if ((before == '=' || before == ',') && (after == '\\0' || after == ',')) {\n+            FLAG_SET_DEFAULT(EnableJVMCI, true);\n+            _jvmci_module_added = true;\n+          }\n+        }\n+      }\n+#endif\n@@ -2450,1 +2445,1 @@\n-      if (FLAG_SET_CMDLINE(ReservedCodeCacheSize, (uintx)long_ReservedCodeCacheSize) != JVMFlag::SUCCESS) {\n+      if (FLAG_SET_CMDLINE(ReservedCodeCacheSize, (size_t)long_ReservedCodeCacheSize) != JVMFlag::SUCCESS) {\n@@ -3078,0 +3073,44 @@\n+static JavaVMOption* get_last_aotmode_arg(const JavaVMInitArgs* args) {\n+  for (int index = args->nOptions - 1; index >= 0; index--) {\n+    JavaVMOption* option = args->options + index;\n+    if (strstr(option->optionString, \"-XX:AOTMode=\") == option->optionString) {\n+      return option;\n+    }\n+  }\n+\n+  return nullptr;\n+}\n+\n+jint Arguments::parse_jdk_aot_vm_options_environment_variable(GrowableArrayCHeap<VMInitArgsGroup, mtArguments>* all_args,\n+                                                            ScopedVMInitArgs* jdk_aot_vm_options_args) {\n+  \/\/ Don't bother scanning all the args if this env variable is not set\n+  if (::getenv(\"JDK_AOT_VM_OPTIONS\") == nullptr) {\n+    return JNI_OK;\n+  }\n+\n+  \/\/ Scan backwards and find the last occurrence of -XX:AOTMode=xxx, which will decide the value\n+  \/\/ of AOTMode.\n+  JavaVMOption* option = nullptr;\n+  for (int i = all_args->length() - 1; i >= 0; i--) {\n+    if ((option = get_last_aotmode_arg(all_args->at(i)._args)) != nullptr) {\n+      break;\n+    }\n+  }\n+\n+  if (option != nullptr) {\n+    \/\/ We have found the last -XX:AOTMode=xxx. At this point <option> has NOT been parsed yet,\n+    \/\/ so its value is not reflected inside the global variable AOTMode.\n+    if (strcmp(option->optionString, \"-XX:AOTMode=create\") != 0) {\n+      return JNI_OK; \/\/ Do not parse JDK_AOT_VM_OPTIONS\n+    }\n+  } else {\n+    \/\/ -XX:AOTMode is not specified in any of 4 options_args, let's check AOTMode,\n+    \/\/ which would have been set inside process_settings_file();\n+    if (AOTMode == nullptr || strcmp(AOTMode, \"create\") != 0) {\n+      return JNI_OK; \/\/ Do not parse JDK_AOT_VM_OPTIONS\n+    }\n+  }\n+\n+  return parse_options_environment_variable(\"JDK_AOT_VM_OPTIONS\", jdk_aot_vm_options_args);\n+}\n+\n@@ -3456,0 +3495,1 @@\n+  ScopedVMInitArgs initial_jdk_aot_vm_options_args(\"env_var='JDK_AOT_VM_OPTIONS'\");\n@@ -3462,0 +3502,1 @@\n+  JavaVMInitArgs* cur_jdk_aot_vm_options_args;\n@@ -3468,0 +3509,1 @@\n+  ScopedVMInitArgs mod_jdk_aot_vm_options_args(\"env_var='_JDK_AOT_VM_OPTIONS'\");\n@@ -3469,0 +3511,1 @@\n+  GrowableArrayCHeap<VMInitArgsGroup, mtArguments> all_args;\n@@ -3476,0 +3519,2 @@\n+  \/\/ Yet another environment variable: _JAVA_OPTIONS. This mimics the classic VM.\n+  \/\/ This is an undocumented feature.\n@@ -3522,7 +3567,1 @@\n-  if (IgnoreUnrecognizedVMOptions) {\n-    cur_cmd_args->ignoreUnrecognized = true;\n-    cur_java_tool_options_args->ignoreUnrecognized = true;\n-    cur_java_options_args->ignoreUnrecognized = true;\n-  }\n-\n-  \/\/ Parse specified settings file\n+  \/\/ Parse specified settings file (s) -- the effects are applied immediately into the JVM global flags.\n@@ -3531,1 +3570,1 @@\n-                               cur_cmd_args->ignoreUnrecognized)) {\n+                               IgnoreUnrecognizedVMOptions)) {\n@@ -3538,1 +3577,1 @@\n-                               cur_cmd_args->ignoreUnrecognized)) {\n+                               IgnoreUnrecognizedVMOptions)) {\n@@ -3549,0 +3588,43 @@\n+  \/\/ The settings in the args are applied in this order to the the JVM global flags.\n+  \/\/ For historical reasons, the order is DIFFERENT than the scanning order of\n+  \/\/ the above expand_vm_options_as_needed() calls.\n+  all_args.append({cur_vm_options_args, JVMFlagOrigin::JIMAGE_RESOURCE});\n+  all_args.append({cur_java_tool_options_args, JVMFlagOrigin::ENVIRON_VAR});\n+  all_args.append({cur_cmd_args, JVMFlagOrigin::COMMAND_LINE});\n+  all_args.append({cur_java_options_args, JVMFlagOrigin::ENVIRON_VAR});\n+\n+  \/\/ JDK_AOT_VM_OPTIONS are parsed only if -XX:AOTMode=create has been detected from all\n+  \/\/ the options that have been gathered above.\n+  code = parse_jdk_aot_vm_options_environment_variable(&all_args, &initial_jdk_aot_vm_options_args);\n+  if (code != JNI_OK) {\n+    return code;\n+  }\n+  code = expand_vm_options_as_needed(initial_jdk_aot_vm_options_args.get(),\n+                                     &mod_jdk_aot_vm_options_args,\n+                                     &cur_jdk_aot_vm_options_args);\n+  if (code != JNI_OK) {\n+    return code;\n+  }\n+\n+  for (int index = 0; index < cur_jdk_aot_vm_options_args->nOptions; index++) {\n+    JavaVMOption* option = cur_jdk_aot_vm_options_args->options + index;\n+    const char* optionString = option->optionString;\n+    if (strstr(optionString, \"-XX:AOTMode=\") == optionString &&\n+        strcmp(optionString, \"-XX:AOTMode=create\") != 0) {\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \"Option %s cannot be specified in JDK_AOT_VM_OPTIONS\\n\", optionString);\n+      return JNI_ERR;\n+    }\n+  }\n+\n+  all_args.append({cur_jdk_aot_vm_options_args, JVMFlagOrigin::ENVIRON_VAR});\n+\n+  if (IgnoreUnrecognizedVMOptions) {\n+    \/\/ Note: unrecognized options in cur_vm_options_arg cannot be ignored. They are part of\n+    \/\/ the JDK so it shouldn't have bad options.\n+    cur_cmd_args->ignoreUnrecognized = true;\n+    cur_java_tool_options_args->ignoreUnrecognized = true;\n+    cur_java_options_args->ignoreUnrecognized = true;\n+    cur_jdk_aot_vm_options_args->ignoreUnrecognized = true;\n+  }\n+\n@@ -3550,0 +3632,1 @@\n+    \/\/ For historical reasons, options specified in cur_vm_options_arg and -XX:Flags are not printed.\n@@ -3553,0 +3636,1 @@\n+    print_options(cur_jdk_aot_vm_options_args);\n@@ -3555,5 +3639,2 @@\n-  \/\/ Parse JavaVMInitArgs structure passed in, as well as JAVA_TOOL_OPTIONS and _JAVA_OPTIONS\n-  jint result = parse_vm_init_args(cur_vm_options_args,\n-                                   cur_java_tool_options_args,\n-                                   cur_java_options_args,\n-                                   cur_cmd_args);\n+  \/\/ Apply the settings in these args to the JVM global flags.\n+  jint result = parse_vm_init_args(&all_args);\n@@ -3618,1 +3699,1 @@\n-      log_is_enabled(Info, cds)) {\n+      log_is_enabled(Info, cds) || log_is_enabled(Info, aot)) {\n@@ -3622,0 +3703,1 @@\n+    LogConfiguration::configure_stdout(LogLevel::Off, true, LOG_TAGS(aot));\n@@ -3683,3 +3765,0 @@\n-  if (UseCompactObjectHeaders && LockingMode != LM_LIGHTWEIGHT) {\n-    FLAG_SET_DEFAULT(LockingMode, LM_LIGHTWEIGHT);\n-  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":150,"deletions":71,"binary":false,"changes":221,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+#include \"jfr\/jfr.inline.hpp\"\n@@ -476,0 +477,1 @@\n+  JFR_ONLY(Jfr::check_and_process_sample_request(current);)\n@@ -1050,1 +1052,1 @@\n-class DeoptimizeMarkedClosure : public HandshakeClosure {\n+class DeoptimizeMarkedHandshakeClosure : public HandshakeClosure {\n@@ -1052,1 +1054,1 @@\n-  DeoptimizeMarkedClosure() : HandshakeClosure(\"Deoptimize\") {}\n+  DeoptimizeMarkedHandshakeClosure() : HandshakeClosure(\"Deoptimize\") {}\n@@ -1065,1 +1067,1 @@\n-  DeoptimizeMarkedClosure deopt;\n+  DeoptimizeMarkedHandshakeClosure deopt;\n@@ -1275,1 +1277,1 @@\n-      obj = ak->allocate(len, THREAD);\n+      obj = ak->allocate_instance(len, THREAD);\n@@ -1279,1 +1281,1 @@\n-      obj = ak->allocate(sv->field_size(), THREAD);\n+      obj = ak->allocate_instance(sv->field_size(), THREAD);\n@@ -1827,1 +1829,1 @@\n-  nm->make_not_entrant(\"missing exception handler\");\n+  nm->make_not_entrant(nmethod::InvalidationReason::MISSING_EXCEPTION_HANDLER);\n@@ -2364,0 +2366,8 @@\n+#if INCLUDE_JVMCI\n+    \/\/ Deoptimization count is used by the CompileBroker to reason about compilations\n+    \/\/ it requests so do not pollute the count for deoptimizations in non-default (i.e.\n+    \/\/ non-CompilerBroker) compilations.\n+    if (nm->jvmci_skip_profile_deopt()) {\n+      update_trap_state = false;\n+    }\n+#endif\n@@ -2456,1 +2466,1 @@\n-      if (!nm->make_not_entrant(\"uncommon trap\")) {\n+      if (!nm->make_not_entrant(nmethod::InvalidationReason::UNCOMMON_TRAP)) {\n@@ -2474,1 +2484,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-  product(bool, UseCompactObjectHeaders, false, EXPERIMENTAL,               \\\n+  product(bool, UseCompactObjectHeaders, false,                             \\\n@@ -296,0 +296,3 @@\n+  develop(bool, VerifyInlineCaches, true,                                   \\\n+          \"Verify Inline Caches\")                                           \\\n+                                                                            \\\n@@ -330,0 +333,1 @@\n+                                                                            \\\n@@ -653,0 +657,4 @@\n+  product(bool, DeoptimizeOnAllocationException, false, DIAGNOSTIC,         \\\n+          \"Deoptimize on exception during allocation instead of using the \" \\\n+          \"compiled exception handlers\")                                    \\\n+                                                                            \\\n@@ -946,4 +954,0 @@\n-  develop(bool, GenerateSynchronizationCode, true,                          \\\n-          \"generate locking\/unlocking code for synchronized methods and \"   \\\n-          \"monitors\")                                                       \\\n-                                                                            \\\n@@ -1092,0 +1096,3 @@\n+  \/* This value is later shifted left by up to LogBytesPerLong bits       *\/\\\n+  \/* (to convert from element count to size in bytes), so we must ensure  *\/\\\n+  \/* it does not overflow during the shift.                               *\/\\\n@@ -1095,0 +1102,1 @@\n+          range(0, (1 << (BitsPerInt - LogBytesPerLong - 1)) - 1)           \\\n@@ -1499,1 +1507,1 @@\n-  product_pd(uintx, CodeCacheSegmentSize, EXPERIMENTAL,                     \\\n+  product_pd(size_t, CodeCacheSegmentSize, EXPERIMENTAL,                    \\\n@@ -1514,1 +1522,1 @@\n-  product_pd(uintx, InitialCodeCacheSize,                                   \\\n+  product_pd(size_t, InitialCodeCacheSize,                                  \\\n@@ -1518,1 +1526,1 @@\n-  develop_pd(uintx, CodeCacheMinimumUseSpace,                               \\\n+  develop_pd(size_t, CodeCacheMinimumUseSpace,                              \\\n@@ -1520,1 +1528,1 @@\n-          range(0, max_uintx)                                               \\\n+          range(0, SIZE_MAX)                                                \\\n@@ -1525,1 +1533,1 @@\n-  product_pd(uintx, ReservedCodeCacheSize,                                  \\\n+  product_pd(size_t, ReservedCodeCacheSize,                                 \\\n@@ -1529,1 +1537,1 @@\n-  product_pd(uintx, NonProfiledCodeHeapSize,                                \\\n+  product_pd(size_t, NonProfiledCodeHeapSize,                               \\\n@@ -1531,1 +1539,1 @@\n-          range(0, max_uintx)                                               \\\n+          range(0, SIZE_MAX)                                                \\\n@@ -1533,1 +1541,1 @@\n-  product_pd(uintx, ProfiledCodeHeapSize,                                   \\\n+  product_pd(size_t, ProfiledCodeHeapSize,                                  \\\n@@ -1535,1 +1543,1 @@\n-          range(0, max_uintx)                                               \\\n+          range(0, SIZE_MAX)                                                \\\n@@ -1537,1 +1545,1 @@\n-  product_pd(uintx, NonNMethodCodeHeapSize,                                 \\\n+  product_pd(size_t, NonNMethodCodeHeapSize,                                \\\n@@ -1541,1 +1549,1 @@\n-  product_pd(uintx, CodeCacheExpansionSize,                                 \\\n+  product_pd(size_t, CodeCacheExpansionSize,                                \\\n@@ -1543,1 +1551,1 @@\n-          range(32*K, max_uintx)                                            \\\n+          range(32*K, SIZE_MAX)                                             \\\n@@ -1545,1 +1553,1 @@\n-  product_pd(uintx, CodeCacheMinBlockLength, DIAGNOSTIC,                    \\\n+  product_pd(size_t, CodeCacheMinBlockLength, DIAGNOSTIC,                   \\\n@@ -1561,3 +1569,1 @@\n-          \"Start aggressive sweeping if X[%] of the code cache is free.\"    \\\n-          \"Segmented code cache: X[%] of the non-profiled heap.\"            \\\n-          \"Non-segmented code cache: X[%] of the total code cache\")         \\\n+          \"Start aggressive sweeping if less than X[%] of the total code cache is free.\")\\\n@@ -1726,5 +1732,0 @@\n-  product(int, PerfDataSamplingInterval, 50,                                \\\n-          \"Data sampling interval (in milliseconds)\")                       \\\n-          range(PeriodicTask::min_interval, max_jint)                       \\\n-          constraint(PerfDataSamplingIntervalFunc, AfterErgo)               \\\n-                                                                            \\\n@@ -1956,7 +1957,0 @@\n-  product(int, LockingMode, LM_LIGHTWEIGHT,                                 \\\n-          \"(Deprecated) Select locking mode: \"                              \\\n-          \"0: (Deprecated) monitors only (LM_MONITOR), \"                    \\\n-          \"1: (Deprecated) monitors & legacy stack-locking (LM_LEGACY), \"   \\\n-          \"2: monitors & new lightweight locking (LM_LIGHTWEIGHT, default)\") \\\n-          range(0, 2)                                                       \\\n-                                                                            \\\n@@ -2008,0 +2002,4 @@\n+                                                                            \\\n+  develop(uint, BinarySearchThreshold, 16,                                  \\\n+          \"Minimal number of elements in a sorted collection to prefer\"     \\\n+          \"binary search over simple linear search.\" )                      \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":31,"deletions":33,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"oops\/trainingData.hpp\"\n@@ -70,0 +71,2 @@\n+void initialize_stub_info();    \/\/ must precede all blob\/stub generation\n+void preuniverse_stubs_init();\n@@ -72,1 +75,1 @@\n-jint universe_init();           \/\/ depends on codeCache_init and initial_stubs_init\n+jint universe_init();           \/\/ depends on codeCache_init and preuniverse_stubs_init\n@@ -131,7 +134,6 @@\n-  \/\/ stub routines in initial blob are referenced by later generated code\n-  initial_stubs_init();\n-  \/\/ stack overflow exception blob is referenced by the interpreter\n-  SharedRuntime::generate_initial_stubs();\n-  jint status = universe_init();  \/\/ dependent on codeCache_init and\n-                                  \/\/ initial_stubs_init and metaspace_init.\n-  if (status != JNI_OK)\n+  \/\/ ensure we know about all blobs, stubs and entries\n+  initialize_stub_info();\n+  \/\/ initialize stubs needed before we can init the universe\n+  preuniverse_stubs_init();\n+  jint status = universe_init();  \/\/ dependent on codeCache_init and preuniverse_stubs_init\n+  if (status != JNI_OK) {\n@@ -139,1 +141,1 @@\n-\n+  }\n@@ -147,1 +149,1 @@\n-  AOTCodeCache::init2();     \/\/ depends on universe_init\n+  AOTCodeCache::init2();     \/\/ depends on universe_init, must be before initial_stubs_init\n@@ -149,0 +151,5 @@\n+\n+  initial_stubs_init();      \/\/ stubgen initial stub routines\n+  \/\/ stack overflow exception blob is referenced by the interpreter\n+  AOTCodeCache::init_early_stubs_table();  \/\/ need this after stubgen initial stubs and before shared runtime initial stubs\n+  SharedRuntime::generate_initial_stubs();\n@@ -191,0 +198,5 @@\n+  \/\/ Initialize TrainingData only we're recording\/replaying\n+  if (TrainingData::have_data() || TrainingData::need_data()) {\n+   TrainingData::initialize();\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":22,"deletions":10,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-#include \"runtime\/statSampler.hpp\"\n@@ -473,4 +472,0 @@\n-  \/\/ shut down the StatSampler task\n-  StatSampler::disengage();\n-  StatSampler::destroy();\n-\n@@ -479,2 +474,2 @@\n-  \/\/ Stop concurrent GC threads\n-  Universe::heap()->stop();\n+  \/\/ Run before exit and then stop concurrent GC threads\n+  Universe::heap()->before_exit();\n@@ -483,1 +478,1 @@\n-  Log(gc, heap, exit) log;\n+  Log(gc, exit) log;\n@@ -521,1 +516,0 @@\n-  Universe::heap()->print_tracing_info();\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+Mutex*   NMethodEntryBarrier_lock     = nullptr;\n@@ -82,0 +83,1 @@\n+Monitor* CompileTaskWait_lock         = nullptr;\n@@ -85,1 +87,0 @@\n-Mutex*   CompileTaskAlloc_lock        = nullptr;\n@@ -93,0 +94,2 @@\n+Mutex*   TrainingData_lock            = nullptr;\n+Monitor* TrainingReplayQueue_lock     = nullptr;\n@@ -120,1 +123,0 @@\n-Monitor* JfrThreadSampler_lock        = nullptr;\n@@ -206,0 +208,2 @@\n+  MUTEX_DEFN(NMethodEntryBarrier_lock        , PaddedMutex  , service-1);\n+\n@@ -234,1 +238,1 @@\n-  MUTEX_DEFN(JmethodIdCreation_lock          , PaddedMutex  , nosafepoint-2); \/\/ used for creating jmethodIDs.\n+  MUTEX_DEFN(JmethodIdCreation_lock          , PaddedMutex  , nosafepoint-1);    \/\/ used for creating jmethodIDs can also lock HandshakeState_lock\n@@ -260,0 +264,2 @@\n+  MUTEX_DEFL(TrainingData_lock               , PaddedMutex  , MethodCompileQueue_lock);\n+  MUTEX_DEFN(TrainingReplayQueue_lock        , PaddedMonitor, safepoint);\n@@ -285,1 +291,0 @@\n-  MUTEX_DEFN(JfrThreadSampler_lock           , PaddedMonitor, nosafepoint);\n@@ -343,1 +348,2 @@\n-  MUTEX_DEFL(CompileTaskAlloc_lock          , PaddedMutex  ,  MethodCompileQueue_lock);\n+  MUTEX_DEFL(CompileTaskWait_lock           , PaddedMonitor, MethodCompileQueue_lock);\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+extern Mutex*   NMethodEntryBarrier_lock;        \/\/ protects nmethod entry barrier\n@@ -86,1 +87,3 @@\n-extern Mutex*   CompileTaskAlloc_lock;           \/\/ a lock held when CompileTasks are allocated\n+extern Mutex*   TrainingData_lock;               \/\/ a lock used when accessing training records\n+extern Monitor* TrainingReplayQueue_lock;        \/\/ a lock held when class are added\/removed to the training replay queue\n+extern Monitor* CompileTaskWait_lock;            \/\/ a lock held when CompileTasks are waited\/notified\n@@ -139,1 +142,0 @@\n-extern Monitor* JfrThreadSampler_lock;           \/\/ used to suspend\/resume JFR thread sampler\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1045,1 +1045,1 @@\n-    logical_p += unitsize;\n+    logical_p = (const_address) ((uintptr_t)logical_p + unitsize);\n@@ -1128,1 +1128,1 @@\n-  const JvmtiAgentList::Iterator it = JvmtiAgentList::all();\n+  JvmtiAgentList::Iterator it = JvmtiAgentList::all();\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -296,6 +296,1 @@\n-  \/\/ The \"virtual time\" of a thread is the amount of time a thread has\n-  \/\/ actually run.  The first function indicates whether the OS supports\n-  \/\/ this functionality for the current thread, and if so the second\n-  \/\/ returns the elapsed virtual time for the current thread.\n-  static bool supports_vtime();\n-  static double elapsedVTime();\n+  static double elapsed_process_cpu_time();\n@@ -626,0 +621,1 @@\n+  static intptr_t*  fetch_bcp_from_context(const void* ucVoid);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -323,0 +323,8 @@\n+\n+\/\/ Conversion\n+static BasicType basic_type_mirror_to_basic_type(oop basic_type_mirror) {\n+  assert(java_lang_Class::is_primitive(basic_type_mirror),\n+    \"just checking\");\n+  return java_lang_Class::primitive_type(basic_type_mirror);\n+}\n+\n@@ -324,2 +332,1 @@\n-  assert(java_lang_Class::is_primitive(basic_type_mirror), \"just checking\");\n-  BasicType type = java_lang_Class::primitive_type(basic_type_mirror);\n+  BasicType type = basic_type_mirror_to_basic_type(basic_type_mirror);\n@@ -342,2 +349,5 @@\n-    Klass* tak = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);\n-    return TypeArrayKlass::cast(tak)->allocate(length, THREAD);\n+    BasicType type = basic_type_mirror_to_basic_type(element_mirror);\n+    if (type == T_VOID) {\n+      THROW_NULL(vmSymbols::java_lang_IllegalArgumentException());\n+    }\n+    return oopFactory::new_typeArray(type, length, CHECK_NULL);\n@@ -544,3 +554,3 @@\n-        oop jlm = module_to->module();\n-        assert(jlm != nullptr, \"Null jlm in module_to ModuleEntry\");\n-        intptr_t identity_hash = jlm->identity_hash();\n+        oop module_oop = module_to->module_oop();\n+        assert(module_oop != nullptr, \"should have been initialized\");\n+        intptr_t identity_hash = module_oop->identity_hash();\n@@ -571,3 +581,3 @@\n-        oop jlm = module_from->module();\n-        assert(jlm != nullptr, \"Null jlm in module_from ModuleEntry\");\n-        intptr_t identity_hash = jlm->identity_hash();\n+        oop module_oop = module_from->module_oop();\n+        assert(module_oop != nullptr, \"should have been initialized\");\n+        intptr_t identity_hash = module_oop->identity_hash();\n@@ -910,7 +920,0 @@\n-\/\/ Conversion\n-static BasicType basic_type_mirror_to_basic_type(oop basic_type_mirror) {\n-  assert(java_lang_Class::is_primitive(basic_type_mirror),\n-    \"just checking\");\n-  return java_lang_Class::primitive_type(basic_type_mirror);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":20,"deletions":17,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-#include \"jfr\/jfr.hpp\"\n+#include \"jfr\/jfr.inline.hpp\"\n@@ -98,1 +98,1 @@\n-  type        SharedRuntime::BLOB_FIELD_NAME(name);\n+  type*       SharedRuntime::BLOB_FIELD_NAME(name);\n@@ -104,0 +104,2 @@\n+#if 0\n+\/\/ TODO tweak global stub name generation to match this\n@@ -108,0 +110,1 @@\n+#endif\n@@ -113,1 +116,1 @@\n-    generate_throw_exception(SharedStubId::throw_StackOverflowError_id,\n+    generate_throw_exception(StubId::shared_throw_StackOverflowError_id,\n@@ -119,1 +122,1 @@\n-    generate_resolve_blob(SharedStubId::wrong_method_id,\n+    generate_resolve_blob(StubId::shared_wrong_method_id,\n@@ -122,1 +125,1 @@\n-    generate_resolve_blob(SharedStubId::wrong_method_abstract_id,\n+    generate_resolve_blob(StubId::shared_wrong_method_abstract_id,\n@@ -125,1 +128,1 @@\n-    generate_resolve_blob(SharedStubId::ic_miss_id,\n+    generate_resolve_blob(StubId::shared_ic_miss_id,\n@@ -128,1 +131,1 @@\n-    generate_resolve_blob(SharedStubId::resolve_opt_virtual_call_id,\n+    generate_resolve_blob(StubId::shared_resolve_opt_virtual_call_id,\n@@ -131,1 +134,1 @@\n-    generate_resolve_blob(SharedStubId::resolve_virtual_call_id,\n+    generate_resolve_blob(StubId::shared_resolve_virtual_call_id,\n@@ -134,1 +137,1 @@\n-    generate_resolve_blob(SharedStubId::resolve_static_call_id,\n+    generate_resolve_blob(StubId::shared_resolve_static_call_id,\n@@ -138,1 +141,1 @@\n-    generate_throw_exception(SharedStubId::throw_delayed_StackOverflowError_id,\n+    generate_throw_exception(StubId::shared_throw_delayed_StackOverflowError_id,\n@@ -142,1 +145,1 @@\n-    generate_throw_exception(SharedStubId::throw_AbstractMethodError_id,\n+    generate_throw_exception(StubId::shared_throw_AbstractMethodError_id,\n@@ -146,1 +149,1 @@\n-    generate_throw_exception(SharedStubId::throw_IncompatibleClassChangeError_id,\n+    generate_throw_exception(StubId::shared_throw_IncompatibleClassChangeError_id,\n@@ -150,1 +153,1 @@\n-    generate_throw_exception(SharedStubId::throw_NullPointerException_at_call_id,\n+    generate_throw_exception(StubId::shared_throw_NullPointerException_at_call_id,\n@@ -158,1 +161,1 @@\n-      generate_handler_blob(SharedStubId::polling_page_vectors_safepoint_handler_id,\n+      generate_handler_blob(StubId::shared_polling_page_vectors_safepoint_handler_id,\n@@ -163,1 +166,1 @@\n-    generate_handler_blob(SharedStubId::polling_page_safepoint_handler_id,\n+    generate_handler_blob(StubId::shared_polling_page_safepoint_handler_id,\n@@ -166,1 +169,1 @@\n-    generate_handler_blob(SharedStubId::polling_page_return_handler_id,\n+    generate_handler_blob(StubId::shared_polling_page_return_handler_id,\n@@ -444,1 +447,1 @@\n-#if defined(__SOFTFP__) || defined(PPC)\n+#if defined(__SOFTFP__)\n@@ -573,0 +576,1 @@\n+    assert (StubRoutines::catch_exception_entry() != nullptr, \"must be generated before\");\n@@ -2180,1 +2184,0 @@\n-static int _compact; \/\/ number of equals calls with compact signature\n@@ -2191,1 +2194,0 @@\n-    _compact_int_count = 3\n@@ -2197,1 +2199,5 @@\n-  int _value[_compact_int_count];\n+\n+  static int data_offset() { return sizeof(AdapterFingerPrint); }\n+  int* data_pointer() {\n+    return (int*)((address)this + data_offset());\n+  }\n@@ -2200,1 +2206,2 @@\n-  AdapterFingerPrint(int total_args_passed, BasicType* sig_bt) {\n+  AdapterFingerPrint(int total_args_passed, BasicType* sig_bt, int len) {\n+    int* data = data_pointer();\n@@ -2202,1 +2209,2 @@\n-    _length = (total_args_passed + (_basic_types_per_int-1)) \/ _basic_types_per_int;\n+    assert(len == length(total_args_passed), \"sanity\");\n+    _length = len;\n@@ -2211,1 +2219,1 @@\n-      _value[index] = value;\n+      data[index] = value;\n@@ -2217,1 +2225,9 @@\n-    FreeHeap(this);\n+    ShouldNotCallThis();\n+  }\n+\n+  static int length(int total_args) {\n+    return (total_args + (_basic_types_per_int-1)) \/ _basic_types_per_int;\n+  }\n+\n+  static int compute_size_in_words(int len) {\n+    return (int)heap_word_size(sizeof(AdapterFingerPrint) + (len * sizeof(int)));\n@@ -2279,7 +2295,5 @@\n-  static int allocation_size(int total_args_passed, BasicType* sig_bt) {\n-    int len = (total_args_passed + (_basic_types_per_int-1)) \/ _basic_types_per_int;\n-    return sizeof(AdapterFingerPrint) + (len > _compact_int_count ? (len - _compact_int_count) * sizeof(int) : 0);\n-  }\n-\n-    int size_in_bytes = allocation_size(total_args_passed, sig_bt);\n-    return new (size_in_bytes) AdapterFingerPrint(total_args_passed, sig_bt);\n+    int len = length(total_args_passed);\n+    int size_in_bytes = BytesPerWord * compute_size_in_words(len);\n+    AdapterFingerPrint* afp = new (size_in_bytes) AdapterFingerPrint(total_args_passed, sig_bt, len);\n+    assert((afp->size() * BytesPerWord) == size_in_bytes, \"should match\");\n+    return afp;\n@@ -2290,1 +2304,1 @@\n-    fp->~AdapterFingerPrint();\n+    FreeHeap(fp);\n@@ -2294,1 +2308,2 @@\n-    return _value[index];\n+    int* data = data_pointer();\n+    return data[index];\n@@ -2298,1 +2313,0 @@\n-    if (_length < 0) return -_length;\n@@ -2302,4 +2316,0 @@\n-  bool is_compact() {\n-    return _length <= _compact_int_count;\n-  }\n-\n@@ -2408,1 +2418,1 @@\n-        if (_value[i] != other->_value[i]) {\n+        if (value(i) != other->value(i)) {\n@@ -2418,1 +2428,1 @@\n-  int size() const { return (int)heap_word_size(sizeof(AdapterFingerPrint) + (_length > _compact_int_count ? (_length - _compact_int_count) * sizeof(int) : 0)); }\n+  int size() const { return compute_size_in_words(_length); }\n@@ -2459,1 +2469,1 @@\n-  if (!AOTCodeCache::is_dumping_adapters()) {\n+  if (AOTCodeCache::is_using_adapter()) {\n@@ -2462,4 +2472,1 @@\n-    if (entry != nullptr) {\n-      if (fp->is_compact()) {\n-        _compact++;\n-      }\n+    if (entry != nullptr) {\n@@ -2468,1 +2475,1 @@\n-#endif\n+#endif\n@@ -2481,1 +2488,0 @@\n-      if (fp->is_compact()) _compact++;\n@@ -2500,2 +2506,2 @@\n-  tty->print_cr(\"AdapterHandlerTable: lookups %d equals %d hits %d (archived=%d+runtime=%d) compact %d\",\n-                _lookups, _equals, total_hits, _archived_hits, _runtime_hits, _compact);\n+  tty->print_cr(\"AdapterHandlerTable: lookups %d equals %d hits %d (archived=%d+runtime=%d)\",\n+                _lookups, _equals, total_hits, _archived_hits, _runtime_hits);\n@@ -2569,1 +2575,1 @@\n-  if (!_aot_adapter_handler_table.empty()) {\n+  if (AOTCodeCache::is_using_adapter() && !_aot_adapter_handler_table.empty()) {\n@@ -2841,1 +2847,1 @@\n-  if (!is_transient && AOTCodeCache::is_dumping_adapters()) {\n+  if (!is_transient && AOTCodeCache::is_dumping_adapter()) {\n@@ -2853,1 +2859,1 @@\n-    assert(success || !AOTCodeCache::is_dumping_adapters(), \"caching of adapter must be disabled\");\n+    assert(success || !AOTCodeCache::is_dumping_adapter(), \"caching of adapter must be disabled\");\n@@ -2901,1 +2907,1 @@\n-    LogStreamHandle(Trace, cds) lsh;\n+    LogStreamHandle(Trace, aot) lsh;\n@@ -2915,1 +2921,1 @@\n-        log_trace(cds)(\"Added fp=%p (%s), entry=%p to the archived adater table\", buffered_fp, buffered_fp->as_basic_args_string(), buffered_entry);\n+        log_trace(aot)(\"Added fp=%p (%s), entry=%p to the archived adater table\", buffered_fp, buffered_fp->as_basic_args_string(), buffered_entry);\n@@ -2919,1 +2925,1 @@\n-        log_trace(cds)(\"Skipping adapter handler %p (fp=%s) as it is not archived\", entry, fp->as_basic_args_string());\n+        log_trace(aot)(\"Skipping adapter handler %p (fp=%s) as it is not archived\", entry, fp->as_basic_args_string());\n@@ -2964,1 +2970,1 @@\n-  if (AOTCodeCache::is_using_adapters()) {\n+  if (AOTCodeCache::is_using_adapter()) {\n@@ -2967,1 +2973,1 @@\n-      log_warning(cds)(\"Failed to link AdapterHandlerEntry (fp=%s) to its code in the AOT code cache\", _fingerprint->as_basic_args_string());\n+      log_warning(aot)(\"Failed to link AdapterHandlerEntry (fp=%s) to its code in the AOT code cache\", _fingerprint->as_basic_args_string());\n@@ -2991,0 +2997,1 @@\n+  assert(AOTCodeCache::is_using_adapter(), \"AOT adapters code should be available\");\n@@ -3055,1 +3062,1 @@\n-  LogStreamHandle(Trace, cds) lsh;\n+  LogStreamHandle(Trace, aot) lsh;\n@@ -3282,1 +3289,1 @@\n-\n+  JFR_ONLY(Jfr::check_and_process_sample_request(current);)\n@@ -3377,4 +3384,6 @@\n-  auto findblob_archived_table = [&] (AdapterHandlerEntry* handler) {\n-    return (found = (b == CodeCache::find_blob(handler->get_i2c_entry())));\n-  };\n-  _aot_adapter_handler_table.iterate(findblob_archived_table);\n+  if (AOTCodeCache::is_using_adapter()) {\n+    auto findblob_archived_table = [&] (AdapterHandlerEntry* handler) {\n+      return (found = (b == CodeCache::find_blob(handler->get_i2c_entry())));\n+    };\n+    _aot_adapter_handler_table.iterate(findblob_archived_table);\n+  }\n@@ -3404,12 +3413,13 @@\n-  auto findblob_archived_table = [&] (AdapterHandlerEntry* handler) {\n-    if (b == CodeCache::find_blob(handler->get_i2c_entry())) {\n-      found = true;\n-      st->print(\"Adapter for signature: \");\n-      handler->print_adapter_on(st);\n-      return true;\n-    } else {\n-      return false; \/\/ keep looking\n-\n-    }\n-  };\n-  _aot_adapter_handler_table.iterate(findblob_archived_table);\n+  if (AOTCodeCache::is_using_adapter()) {\n+    auto findblob_archived_table = [&] (AdapterHandlerEntry* handler) {\n+      if (b == CodeCache::find_blob(handler->get_i2c_entry())) {\n+        found = true;\n+        st->print(\"Adapter for signature: \");\n+        handler->print_adapter_on(st);\n+        return true;\n+      } else {\n+        return false; \/\/ keep looking\n+      }\n+    };\n+    _aot_adapter_handler_table.iterate(findblob_archived_table);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":85,"deletions":75,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"runtime\/stubDeclarations.hpp\"\n+#include \"runtime\/stubInfo.hpp\"\n@@ -48,10 +48,0 @@\n-\/\/ define SharedStubId enum tags: wrong_method_id, etc\n-\n-#define SHARED_STUB_ID_ENUM_DECLARE(name, type) STUB_ID_NAME(name),\n-enum class SharedStubId :int {\n-  NO_STUBID = -1,\n-  SHARED_STUBS_DO(SHARED_STUB_ID_ENUM_DECLARE)\n-  NUM_STUBIDS\n-};\n-#undef SHARED_STUB_ID_ENUM_DECLARE\n-\n@@ -62,1 +52,1 @@\n-  static type        BLOB_FIELD_NAME(name);\n+  static type*       BLOB_FIELD_NAME(name);\n@@ -67,7 +57,7 @@\n-  static bool is_resolve_id(SharedStubId id) {\n-    return (id == SharedStubId::wrong_method_id ||\n-            id == SharedStubId::wrong_method_abstract_id ||\n-            id == SharedStubId::ic_miss_id ||\n-            id == SharedStubId::resolve_opt_virtual_call_id ||\n-            id == SharedStubId::resolve_virtual_call_id ||\n-            id == SharedStubId::resolve_static_call_id);\n+  static bool is_resolve_id(StubId id) {\n+    return (id == StubId::shared_wrong_method_id ||\n+            id == StubId::shared_wrong_method_abstract_id ||\n+            id == StubId::shared_ic_miss_id ||\n+            id == StubId::shared_resolve_opt_virtual_call_id ||\n+            id == StubId::shared_resolve_virtual_call_id ||\n+            id == StubId::shared_resolve_static_call_id);\n@@ -75,4 +65,4 @@\n-  static bool is_polling_page_id(SharedStubId id) {\n-    return (id == SharedStubId::polling_page_vectors_safepoint_handler_id ||\n-            id == SharedStubId::polling_page_safepoint_handler_id ||\n-            id == SharedStubId::polling_page_return_handler_id);\n+  static bool is_polling_page_id(StubId id) {\n+    return (id == StubId::shared_polling_page_vectors_safepoint_handler_id ||\n+            id == StubId::shared_polling_page_safepoint_handler_id ||\n+            id == StubId::shared_polling_page_return_handler_id);\n@@ -80,6 +70,6 @@\n-  static bool is_throw_id(SharedStubId id) {\n-    return (id == SharedStubId::throw_AbstractMethodError_id ||\n-            id == SharedStubId::throw_IncompatibleClassChangeError_id ||\n-            id == SharedStubId::throw_NullPointerException_at_call_id ||\n-            id == SharedStubId::throw_StackOverflowError_id ||\n-            id == SharedStubId::throw_delayed_StackOverflowError_id);\n+  static bool is_throw_id(StubId id) {\n+    return (id == StubId::shared_throw_AbstractMethodError_id ||\n+            id == StubId::shared_throw_IncompatibleClassChangeError_id ||\n+            id == StubId::shared_throw_NullPointerException_at_call_id ||\n+            id == StubId::shared_throw_StackOverflowError_id ||\n+            id == StubId::shared_throw_delayed_StackOverflowError_id);\n@@ -95,3 +85,0 @@\n-  \/\/ Stub names indexed by SharedStubId\n-  static const char *_stub_names[];\n-\n@@ -104,3 +91,3 @@\n-  static SafepointBlob* generate_handler_blob(SharedStubId id, address call_ptr);\n-  static RuntimeStub*   generate_resolve_blob(SharedStubId id, address destination);\n-  static RuntimeStub*   generate_throw_exception(SharedStubId id, address runtime_entry);\n+  static SafepointBlob* generate_handler_blob(StubId id, address call_ptr);\n+  static RuntimeStub*   generate_resolve_blob(StubId id, address destination);\n+  static RuntimeStub*   generate_throw_exception(StubId id, address runtime_entry);\n@@ -121,3 +108,3 @@\n-  static const char *stub_name(SharedStubId id) {\n-    assert(id > SharedStubId::NO_STUBID && id < SharedStubId::NUM_STUBIDS, \"stub id out of range\");\n-    return _stub_names[(int)id];\n+  static const char *stub_name(StubId id) {\n+    assert(StubInfo::is_shared(id), \"not a shared stub %s\", StubInfo::name(id));\n+    return StubInfo::name(id);\n@@ -188,1 +175,1 @@\n-#if defined(__SOFTFP__) || defined(PPC)\n+#if defined(__SOFTFP__)\n@@ -291,5 +278,20 @@\n-  static address throw_AbstractMethodError_entry()          { return _throw_AbstractMethodError_blob->entry_point(); }\n-  static address throw_IncompatibleClassChangeError_entry() { return _throw_IncompatibleClassChangeError_blob->entry_point(); }\n-  static address throw_NullPointerException_at_call_entry() { return _throw_NullPointerException_at_call_blob->entry_point(); }\n-  static address throw_StackOverflowError_entry()           { return _throw_StackOverflowError_blob->entry_point(); }\n-  static address throw_delayed_StackOverflowError_entry()   { return _throw_delayed_StackOverflowError_blob->entry_point(); }\n+  static address throw_AbstractMethodError_entry()          {\n+    assert(_throw_AbstractMethodError_blob != nullptr, \"\");\n+    return _throw_AbstractMethodError_blob->entry_point();\n+  }\n+  static address throw_IncompatibleClassChangeError_entry() {\n+    assert(_throw_IncompatibleClassChangeError_blob != nullptr, \"\");\n+    return  _throw_IncompatibleClassChangeError_blob->entry_point();\n+  }\n+  static address throw_NullPointerException_at_call_entry() {\n+    assert(_throw_NullPointerException_at_call_blob != nullptr, \"\");\n+    return  _throw_NullPointerException_at_call_blob->entry_point();\n+  }\n+  static address throw_StackOverflowError_entry()           {\n+    assert(_throw_StackOverflowError_blob != nullptr, \"\");\n+    return _throw_StackOverflowError_blob->entry_point();\n+  }\n+  static address throw_delayed_StackOverflowError_entry()   {\n+    assert(_throw_delayed_StackOverflowError_blob != nullptr, \"\");\n+    return _throw_delayed_StackOverflowError_blob->entry_point();\n+  }\n@@ -298,2 +300,8 @@\n-  static address jfr_write_checkpoint() { return _jfr_write_checkpoint_blob->entry_point(); }\n-  static address jfr_return_lease()     { return _jfr_return_lease_blob->entry_point(); }\n+  static address jfr_write_checkpoint() {\n+    assert(_jfr_write_checkpoint_blob != nullptr, \"\");\n+    return _jfr_write_checkpoint_blob->entry_point();\n+  }\n+  static address jfr_return_lease()     {\n+    assert(_jfr_return_lease_blob != nullptr, \"\");\n+    return _jfr_return_lease_blob->entry_point();\n+  }\n@@ -714,0 +722,1 @@\n+    assert(size == BytesPerWord * heap_word_size(sizeof(AdapterHandlerEntry)), \"should match\");\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":55,"deletions":46,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-  _blob_id = StubGenBlobId::NO_BLOBID;\n+  _blob_id = BlobId::NO_BLOBID;\n@@ -76,1 +76,3 @@\n-StubCodeGenerator::StubCodeGenerator(CodeBuffer* code, StubGenBlobId blob_id, bool print_code) {\n+StubCodeGenerator::StubCodeGenerator(CodeBuffer* code, BlobId blob_id, bool print_code) {\n+  assert(StubInfo::is_stubgen(blob_id),\n+         \"not a stubgen blob %s\", StubInfo::name(blob_id));\n@@ -122,1 +124,1 @@\n-void StubCodeGenerator::verify_stub(StubGenStubId stub_id) {\n+void StubCodeGenerator::verify_stub(StubId stub_id) {\n@@ -137,1 +139,1 @@\n-StubCodeMark::StubCodeMark(StubCodeGenerator* cgen, StubGenStubId stub_id) : StubCodeMark(cgen, \"StubRoutines\", StubRoutines::get_stub_name(stub_id)) {\n+StubCodeMark::StubCodeMark(StubCodeGenerator* cgen, StubId stub_id) : StubCodeMark(cgen, \"StubRoutines\", StubRoutines::get_stub_name(stub_id)) {\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"runtime\/stubInfo.hpp\"\n@@ -101,3 +102,0 @@\n-enum StubGenBlobId : int;\n-enum StubGenStubId : int;\n-\n@@ -110,1 +108,1 @@\n-  StubGenBlobId _blob_id;\n+  BlobId _blob_id;\n@@ -116,1 +114,1 @@\n-  StubCodeGenerator(CodeBuffer* code, StubGenBlobId blob_id, bool print_code = false);\n+  StubCodeGenerator(CodeBuffer* code, BlobId blob_id, bool print_code = false);\n@@ -120,1 +118,1 @@\n-  StubGenBlobId blob_id()                        { return _blob_id; }\n+  BlobId blob_id()                               { return _blob_id; }\n@@ -126,1 +124,1 @@\n-  void verify_stub(StubGenStubId stub_id);\n+  void verify_stub(StubId stub_id);\n@@ -142,1 +140,1 @@\n-  StubCodeMark(StubCodeGenerator* cgen, StubGenStubId stub_id);\n+  StubCodeMark(StubCodeGenerator* cgen, StubId stub_id);\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.hpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"code\/codeBlob.hpp\"\n+#include \"oops\/klass.hpp\"\n@@ -31,2 +33,17 @@\n-\/\/ macros for generating definitions and declarations for shared, c1\n-\/\/ and opto blob fields and associated stub ids\n+\/\/ Macros for generating definitions and declarations for shared, c1,\n+\/\/ opto and stubgen blobs and associated stub and entry ids.\n+\/\/\n+\/\/ The template macros that follow define blobs, stubs and entries in\n+\/\/ each stub group. Invocations of the macros with different macro\n+\/\/ arguments can be used to generate definitions and declarations of\n+\/\/ types, data and methods\/functions which support blob, stub and\n+\/\/ entry management.\n+\/\/\n+\/\/ In particular, they are used to generate 3 global enums that list\n+\/\/ all blobs, stubs and entries across stub groups. They are also used\n+\/\/ to generate local (per-stub group) enums listing every stub in the\n+\/\/ group. The former are provided ot allow systematic management of\n+\/\/ blobs, stubs and entries by generic code. The latter are used by\n+\/\/ code which generates and consumes stubs in a specific group. An API\n+\/\/ is provided to convert between global and local ids where needed\n+\/\/ (see class StubInfo).\n@@ -34,2 +51,25 @@\n-\/\/ Different shared stubs can have different blob types and may\n-\/\/ include some JFR stubs\n+\/\/ Shared stub declarations\n+\/\/\n+\/\/ Every shared stub has a unique associated blob whose type must be\n+\/\/ defined as part of the stub declaration. The blob type determines\n+\/\/ how many entries are associated with the stub, normally 1. A build\n+\/\/ may optionally include some JFR stubs.\n+\/\/\n+\/\/ n.b resolve, handler and throw stubs must remain grouped\n+\/\/ contiguously and in the same order so that id values can be range\n+\/\/ checked\n+\/\/\n+\/\/ Alongside the global and local enums, shared declations are used to\n+\/\/ generate the following code elements in class SharedRuntime:\n+\/\/\n+\/\/ Shared Stub blob fields\n+\/\/\n+\/\/ Static field declarations\/definitons for fields of class\n+\/\/ SharedRuntime are generated to store shared blobs\n+\/\/\n+\/\/ static <blobtype>* _<stubname>;\n+\/\/\n+\/\/ Shared stub field names\n+\/\/\n+\/\/ Stubs are provided with names in the format \"Shared Runtime\n+\/\/ <stubname> _blob\".\n@@ -37,2 +77,0 @@\n-\/\/ n.b resolve, handler and throw stubs must remain grouped in the\n-\/\/ same order to allow id values to be range checked\n@@ -43,2 +81,2 @@\n-  do_blob(jfr_write_checkpoint, RuntimeStub*)                          \\\n-  do_blob(jfr_return_lease, RuntimeStub*)                              \\\n+  do_blob(jfr_write_checkpoint, RuntimeStub)                           \\\n+  do_blob(jfr_return_lease, RuntimeStub)                               \\\n@@ -54,1 +92,1 @@\n-  do_blob(deopt, DeoptimizationBlob*)                                  \\\n+  do_blob(deopt, DeoptimizationBlob)                                   \\\n@@ -56,6 +94,6 @@\n-  do_blob(wrong_method, RuntimeStub*)                                  \\\n-  do_blob(wrong_method_abstract, RuntimeStub*)                         \\\n-  do_blob(ic_miss, RuntimeStub*)                                       \\\n-  do_blob(resolve_opt_virtual_call, RuntimeStub*)                      \\\n-  do_blob(resolve_virtual_call, RuntimeStub*)                          \\\n-  do_blob(resolve_static_call, RuntimeStub*)                           \\\n+  do_blob(wrong_method, RuntimeStub)                                   \\\n+  do_blob(wrong_method_abstract, RuntimeStub)                          \\\n+  do_blob(ic_miss, RuntimeStub)                                        \\\n+  do_blob(resolve_opt_virtual_call, RuntimeStub)                       \\\n+  do_blob(resolve_virtual_call, RuntimeStub)                           \\\n+  do_blob(resolve_static_call, RuntimeStub)                            \\\n@@ -63,3 +101,3 @@\n-  do_blob(polling_page_vectors_safepoint_handler, SafepointBlob*)      \\\n-  do_blob(polling_page_safepoint_handler, SafepointBlob*)              \\\n-  do_blob(polling_page_return_handler, SafepointBlob*)                 \\\n+  do_blob(polling_page_vectors_safepoint_handler, SafepointBlob)       \\\n+  do_blob(polling_page_safepoint_handler, SafepointBlob)               \\\n+  do_blob(polling_page_return_handler, SafepointBlob)                  \\\n@@ -67,5 +105,5 @@\n-  do_blob(throw_AbstractMethodError, RuntimeStub*)                     \\\n-  do_blob(throw_IncompatibleClassChangeError, RuntimeStub*)            \\\n-  do_blob(throw_NullPointerException_at_call, RuntimeStub*)            \\\n-  do_blob(throw_StackOverflowError, RuntimeStub*)                      \\\n-  do_blob(throw_delayed_StackOverflowError, RuntimeStub*)              \\\n+  do_blob(throw_AbstractMethodError, RuntimeStub)                      \\\n+  do_blob(throw_IncompatibleClassChangeError, RuntimeStub)             \\\n+  do_blob(throw_NullPointerException_at_call, RuntimeStub)             \\\n+  do_blob(throw_StackOverflowError, RuntimeStub)                       \\\n+  do_blob(throw_delayed_StackOverflowError, RuntimeStub)               \\\n@@ -75,1 +113,6 @@\n-\/\/ C1 stubs are always generated in a generic CodeBlob\n+\/\/ C1 stub declarations\n+\/\/\n+\/\/ C1 stubs are always generated in a unique associated generic\n+\/\/ CodeBlob with a single entry. C1 stubs are stored in an array\n+\/\/ indexed by local enum. So, no other code elements need to be\n+\/\/ generated via this macro.\n@@ -121,2 +164,9 @@\n-\/\/ Opto stubs can be stored as entries with just an address or as\n-\/\/ blobs of different types. The former may include some JVMTI stubs.\n+\/\/ C2 stub declarations\n+\/\/\n+\/\/ C2 stubs are always generated in a unique associated generic\n+\/\/ CodeBlob and have a single entry. In some cases, including JVMTI\n+\/\/ stubs, a standard code blob is employed and only the stub entry\n+\/\/ address is retained. In others a specialized code blob with\n+\/\/ stub-specific properties (e.g. frame size) is required so the blob\n+\/\/ address needs to be stored. In these latter cases the declaration\n+\/\/ includes the relevant storage type.\n@@ -124,1 +174,1 @@\n-\/\/ n.b. blobs and stub defines are generated in the order defined by\n+\/\/ n.b. blob and stub enum tags are generated in the order defined by\n@@ -129,0 +179,21 @@\n+\/\/\n+\/\/ Alongside the local and global enums, C2 declarations are used to\n+\/\/ generate several elements of class OptoRuntime.\n+\/\/\n+\/\/ C2 Stub blob\/address fields\n+\/\/\n+\/\/ Static field declarations\/definitions for fields of class\n+\/\/ OptoRuntime are generated to store either C2 blob or C2 blob entry\n+\/\/ addresses:\n+\/\/\n+\/\/ static <blobtype>* _<stubname>_Java;\n+\/\/ static address _<stubname>;\n+\/\/\n+\/\/ C2 stub blob\/field names\n+\/\/\n+\/\/ C2 stubs are provided with names in the format \"C2 Runtime\n+\/\/ <stubname> _blob\".\n+\/\/\n+\/\/ A stub creation method OptoRuntime::generate(ciEnv* env) is\n+\/\/ generated which invokes the C2 compiler to generate each stub in\n+\/\/ declaration order.\n@@ -149,3 +220,11 @@\n-\/\/ n.b. non-jvmti stubs may employ a special type of jump (0, 1 or 2)\n-\/\/ and require access to TLS and the return pc. jvmti stubs always\n-\/\/ employ jump 0, and require no special access\n+\/\/ do_blob is used for stubs that are generated via direct invocation\n+\/\/ of the assembler to write into a blob of the appropriate type\n+\/\/\n+\/\/ do_stub is used for stubs that are generated as C2 compiler IR\n+\/\/ intrinsics, using the supplied arguments to determine wheher nodes\n+\/\/ in the IR graph employ a special type of jump (0, 1 or 2) or\n+\/\/ provide access to TLS and the return pc.\n+\/\/\n+\/\/ do_jvmti_stub generates a JVMTI stub as an IR intrinsic which\n+\/\/ employs jump 0, and requires no special access\n+\n@@ -153,2 +232,2 @@\n-  do_blob(uncommon_trap, UncommonTrapBlob*)                            \\\n-  do_blob(exception, ExceptionBlob*)                                   \\\n+  do_blob(uncommon_trap, UncommonTrapBlob)                             \\\n+  do_blob(exception, ExceptionBlob)                                    \\\n@@ -175,1 +254,3 @@\n-\/\/ Stub Generator Blobs and Stubs Overview\n+\/\/ Stubgen stub declarations\n+\/\/\n+\/\/ Stub Generator Blobs, Stubs and Entries Overview\n@@ -178,1 +259,7 @@\n-\/\/ are generated in batches into one of four distinct BufferBlobs:\n+\/\/ are generated in batches into one of five distinct BufferBlobs:\n+\/\/\n+\/\/ 1) PreUniverse stubs\n+\/\/ 2) Initial stubs\n+\/\/ 3) Continuation stubs\n+\/\/ 4) Compiler stubs\n+\/\/ 5) Final stubs\n@@ -180,4 +267,2 @@\n-\/\/ 1) Initial stubs\n-\/\/ 2) Continuation stubs\n-\/\/ 3) Compiler stubs\n-\/\/ 4) Final stubs\n+\/\/ Most StubGen stubs have a single entry point. However, in some\n+\/\/ cases there are additional entry points.\n@@ -185,1 +270,1 @@\n-\/\/ Creation of each successive BufferBlobs is staged to ensure that\n+\/\/ Creation of each successive BufferBlob is staged to ensure that\n@@ -187,1 +272,1 @@\n-\/\/ initialized before generated code attempt to reference data or\n+\/\/ initialized before generated code attempts to reference data or\n@@ -192,42 +277,21 @@\n-\/\/ StubGenerator stubs are declared using template macros, one set of\n-\/\/ declarations per blob (see below), with arch-specific stubs for any\n-\/\/ gven blob declared after generic stubs for that blob. Blobs are\n-\/\/ created in a fixed order during startup, which is reflected in the\n-\/\/ order of the declaration set. Stubs within a blob are currently\n-\/\/ created in an order determined by the arch-specific generator code\n-\/\/ which may not reflect the order of stub declarations. It is not\n-\/\/ straightforward to enforce a strict ordering. not least because\n-\/\/ arch-specific stub creation may need to be interleaved with generic\n-\/\/ stub creation.\n-\/\/\n-\/\/ Blob and stub declaration templates are used to generate a variety\n-\/\/ of C++ code elements needed to manage stubs.\n-\/\/\n-\/\/ Blob identifiers:\n-\/\/\n-\/\/ public enum StubGenBlobId is generated to identify each of the\n-\/\/ StubGenerator blobs in blob declaration order. This enum is\n-\/\/ provided for use by client code to identify a specific blob. For a\n-\/\/ blob declared with name <blob_name> the associated enum value is\n-\/\/ StubGenBlobId::<blob_name>_id.\n-\/\/\n-\/\/ Global stub identifiers:\n-\/\/\n-\/\/ public enum StubGenStubId is generated to identify all declared\n-\/\/ stubs across all blobs, sorted first by blob declaration order and\n-\/\/ then within a blob by stub declaration order, generic stubs before\n-\/\/ arch-specific stubs. This enum is provided for use by client code\n-\/\/ to identify a specific stub, independent of the blob it belongs to.\n-\/\/ For a stub declared with name <stub_name> the associated enum value\n-\/\/ is StubGenStubId::<stub_name>_id.\n-\/\/\n-\/\/ Blob-local stub identifiers:\n-\/\/\n-\/\/ For each blob <blob_name>, public enum StubGenStubId_<blob_name> is\n-\/\/ generated to enumerate all stubs within the blob in stub\n-\/\/ declaration order, generic stubs before arch-specific stubs. This\n-\/\/ enum is provided only in a non-product build and is intended for\n-\/\/ internal use by class StubRoutines to validate stub declarations.\n-\/\/ For a stub declared with name <stub_name> belonging to blob\n-\/\/ <blob_name> the associated enum value is\n-\/\/ StubGenStubId::<blob_name>_<stub_name>_id.\n+\/\/ StubGen blobs, stubs and entries are declared using template\n+\/\/ macros, grouped hierarchically by blob and stub, with arch-specific\n+\/\/ stubs for any given blob declared after generic stubs for that\n+\/\/ blob. Stub declarations must follow the blob start (do_blob)\n+\/\/ declaration for their containing blob. Entry declarations must\n+\/\/ follow the the stub start (do_stub) declaration for their\n+\/\/ containing stub.\n+\/\/\n+\/\/ Blob and stub declarations are used to generate a variety of C++\n+\/\/ code elements needed to manage stubs, including the global and\n+\/\/ local blob, stub and entry enum types mentioned above. The blob\n+\/\/ declaration order must reflect the order in which blob create\n+\/\/ operations are invoked during startup. Stubs within a blob are\n+\/\/ currently generated in an order determined by the arch-specific\n+\/\/ generator code which may not always reflect the order of stub\n+\/\/ declarations (it is not straightforward to enforce a strict\n+\/\/ ordering, not least because arch-specific stub creation may need to\n+\/\/ be interleaved with generic stub creation).\n+\/\/\n+\/\/ Alongside the global enums, the stubgen declarations are used to\n+\/\/ define the following elements of class StubRoutines:\n@@ -237,2 +301,2 @@\n-\/\/ Two private static fields are generated to hold the names of the\n-\/\/ four generated blobs and all the generated stubs.\n+\/\/ Name strings are generated for each blob where a blob declared with\n+\/\/ name argument <blob_name> will be named using string \"<blob_name>\".\n@@ -240,8 +304,3 @@\n-\/\/  const char* StubRoutines::_blob_names[];\n-\/\/  const char* StubRoutines::_stub_names[];\n-\/\/\n-\/\/ The entry in _blob_names for a blob declared with name <blob_name>\n-\/\/ will be \"<blob_name>\".\n-\/\/\n-\/\/ The entry in _stub_names for a stub declared with name <stub_name>\n-\/\/ will be \"<stub_name>\".\n+\/\/ Name strings are also generated for each stub where a stub declared\n+\/\/ with name argument <stub_name> will be named using string\n+\/\/ \"<stub_name>\".\n@@ -252,2 +311,2 @@\n-\/\/  const char* StubRoutines::get_blob_name(StubGenBlobId id)\n-\/\/  const char* StubRoutines::get_stub_name(StubGenStubId id)\n+\/\/  const char* StubRoutines::get_blob_name(BlobId id)\n+\/\/  const char* StubRoutines::get_stub_name(StubId id)\n@@ -271,0 +330,1 @@\n+\/\/   _preuniverse_stubs_code_size  =   500,\n@@ -350,1 +410,0 @@\n-\n@@ -416,1 +475,2 @@\n-\/\/ The do_stub template receives a blob name and stub name as argument.\n+\/\/ The do_stub template receives a blob name and stub name as\n+\/\/ argument.\n@@ -420,5 +480,6 @@\n-\/\/ do_stub is primarily used to define a global enum tag for a stub\n-\/\/ and a constant string name, both for use by client code. It is also\n-\/\/ used to declare a tag within the blob-local enum type used to\n-\/\/ validate correct use of stubs within their declared blob. Finally,\n-\/\/ it is also used to declare a name for each stub.\n+\/\/ do_stub is primarily used to define values associated with the stub\n+\/\/ wiht name stub_name, a global enum tag for it and a constant string\n+\/\/ name, both for use by client code. It is also used to declare a tag\n+\/\/ within the blob-local enum type used to validate correct use of\n+\/\/ stubs within their declared blob. Finally, it is also used to\n+\/\/ declare a name string for the stub.\n@@ -454,0 +515,8 @@\n+\/\/ All the above entry macros are used to declare enum tages that\n+\/\/ identify the entry. Three different enums are generated via these\n+\/\/ macros: a per-stub enum that indexes and provides a count for the\n+\/\/ entries associated with the owning stub; a per-blob enume that\n+\/\/ indexes and provides a count for the entries associated with the\n+\/\/ owning blob; and a global enum that indexes and provides a count\n+\/\/ for all entries associated with generated stubs.\n+\/\/\n@@ -504,0 +573,4 @@\n+#ifndef STUBGEN_PREUNIVERSE_BLOBS_ARCH_DO\n+#error \"Arch-specific directory failed to declare required initial stubs and entries\"\n+#endif\n+\n@@ -536,1 +609,15 @@\n-#define STUBGEN_INITIAL_BLOBS_DO(do_blob, end_blob,                     \\\n+#define STUBGEN_PREUNIVERSE_BLOBS_DO(do_blob, end_blob,                 \\\n+                                     do_stub,                           \\\n+                                     do_entry, do_entry_init,           \\\n+                                     do_entry_array,                    \\\n+                                     do_arch_blob,                      \\\n+                                     do_arch_entry, do_arch_entry_init) \\\n+  do_blob(preuniverse)                                                  \\\n+  do_stub(preuniverse, fence)                                           \\\n+  do_entry(preuniverse, fence, fence_entry, fence_entry)                \\\n+  \/* merge in stubs and entries declared in arch header *\/              \\\n+  STUBGEN_PREUNIVERSE_BLOBS_ARCH_DO(do_stub, do_arch_blob,              \\\n+                                    do_arch_entry, do_arch_entry_init)  \\\n+  end_blob(preuniverse)                                                 \\\n+\n+#define STUBGEN_INITIAL_BLOBS_DO(do_blob, end_blob,                      \\\n@@ -553,2 +640,0 @@\n-  do_stub(initial, fence)                                               \\\n-  do_entry(initial, fence, fence_entry, fence_entry)                    \\\n@@ -594,0 +679,2 @@\n+  do_stub(initial, dcbrt)                                               \\\n+  do_entry(initial, dcbrt, dcbrt, dcbrt)                                \\\n@@ -617,1 +704,2 @@\n-                                      do_arch_entry, do_arch_entry_init) \\\n+                                      do_arch_entry,                    \\\n+                                      do_arch_entry_init)               \\\n@@ -622,1 +710,1 @@\n-  do_entry(continuation, cont_prempt, cont_preempt_stub,                \\\n+  do_entry(continuation, cont_preempt, cont_preempt_stub,               \\\n@@ -631,1 +719,1 @@\n-  STUBGEN_CONTINUATION_BLOBS_ARCH_DO(do_stub,  do_arch_blob,            \\\n+  STUBGEN_CONTINUATION_BLOBS_ARCH_DO(do_stub, do_arch_blob,             \\\n@@ -785,1 +873,1 @@\n-  STUBGEN_COMPILER_BLOBS_ARCH_DO(do_stub,  do_arch_blob,                \\\n+  STUBGEN_COMPILER_BLOBS_ARCH_DO(do_stub, do_arch_blob,                 \\\n@@ -954,0 +1042,41 @@\n+\/\/ The whole shebang!\n+\/\/\n+\/\/ client macro for emitting StubGenerator blobs, stubs and entries\n+\n+#define STUBGEN_ALL_DO(do_blob, end_blob,                               \\\n+                       do_stub,                                         \\\n+                       do_entry, do_entry_init,                         \\\n+                       do_entry_array,                                  \\\n+                       do_arch_blob,                                    \\\n+                       do_arch_entry, do_arch_entry_init)               \\\n+  STUBGEN_PREUNIVERSE_BLOBS_DO(do_blob, end_blob,                       \\\n+                               do_stub,                                 \\\n+                               do_entry, do_entry_init,                 \\\n+                               do_entry_array,                          \\\n+                               do_arch_blob,                            \\\n+                               do_arch_entry, do_arch_entry_init)       \\\n+  STUBGEN_INITIAL_BLOBS_DO(do_blob, end_blob,                           \\\n+                           do_stub,                                     \\\n+                           do_entry, do_entry_init,                     \\\n+                           do_entry_array,                              \\\n+                           do_arch_blob,                                \\\n+                           do_arch_entry, do_arch_entry_init)           \\\n+  STUBGEN_CONTINUATION_BLOBS_DO(do_blob, end_blob,                      \\\n+                                do_stub,                                \\\n+                                do_entry, do_entry_init,                \\\n+                                do_entry_array,                         \\\n+                                do_arch_blob,                           \\\n+                                do_arch_entry, do_arch_entry_init)      \\\n+  STUBGEN_COMPILER_BLOBS_DO(do_blob, end_blob,                          \\\n+                            do_stub,                                    \\\n+                            do_entry, do_entry_init,                    \\\n+                            do_entry_array,                             \\\n+                            do_arch_blob,                               \\\n+                            do_arch_entry, do_arch_entry_init)          \\\n+  STUBGEN_FINAL_BLOBS_DO(do_blob, end_blob,                             \\\n+                         do_stub,                                       \\\n+                         do_entry, do_entry_init,                       \\\n+                         do_entry_array,                                \\\n+                         do_arch_blob,                                  \\\n+                         do_arch_entry, do_arch_entry_init)             \\\n+\n@@ -956,1 +1085,10 @@\n-#define STUB_ID_NAME(base) base##_id\n+#define JOIN2(name, suffix)                     \\\n+  name ## _ ## suffix\n+\n+#define JOIN3(prefix, name, suffix)             \\\n+  prefix ## _ ## name ## _ ## suffix\n+\n+#define JOIN4(prefix, prefix2, name, suffix)            \\\n+  prefix ## _ ## prefix2 ## _ ## name ## _ ## suffix\n+\n+#define STUB_ID_NAME(base) JOIN2(base, id)\n@@ -964,1 +1102,1 @@\n-#define BLOB_FIELD_NAME(base) _##base##_blob\n+#define BLOB_FIELD_NAME(base) _## base ## _blob\n@@ -970,0 +1108,23 @@\n+\/\/ first some macros that add an increment\n+\n+#define COUNT1(_1)                              \\\n+  + 1\n+\n+#define COUNT2(_1, _2)                          \\\n+  + 1\n+\n+#define COUNT4(_1, _2, _3, _4)                  \\\n+  + 1\n+\n+#define COUNT5(_1, _2, _3, _4, _5)              \\\n+  + 1\n+\n+#define COUNT6(_1, _2, _3, _4, _5, _6)          \\\n+  + 1\n+\n+#define SHARED_COUNT2(_1, type)                 \\\n+  + type :: ENTRY_COUNT\n+\n+#define STUBGEN_COUNT5(_1, _2, _3, _4, count)   \\\n+  + count\n+\n@@ -1003,35 +1164,0 @@\n-\/\/ The whole shebang!\n-\/\/\n-\/\/ client macro for emitting StubGenerator blobs, stubs and entries\n-\n-#define STUBGEN_ALL_DO(do_blob, end_blob,                               \\\n-                       do_stub,                                         \\\n-                       do_entry, do_entry_init,                         \\\n-                       do_entry_array,                                  \\\n-                       do_arch_blob,                                    \\\n-                       do_arch_entry, do_arch_entry_init)               \\\n-  STUBGEN_INITIAL_BLOBS_DO(do_blob, end_blob,                           \\\n-                           do_stub,                                     \\\n-                           do_entry, do_entry_init,                     \\\n-                           do_entry_array,                              \\\n-                           do_arch_blob,                                \\\n-                           do_arch_entry, do_arch_entry_init)           \\\n-  STUBGEN_CONTINUATION_BLOBS_DO(do_blob, end_blob,                      \\\n-                                do_stub,                                \\\n-                                do_entry, do_entry_init,                \\\n-                                do_entry_array,                         \\\n-                                do_arch_blob,                           \\\n-                                do_arch_entry, do_arch_entry_init)      \\\n-  STUBGEN_COMPILER_BLOBS_DO(do_blob, end_blob,                          \\\n-                            do_stub,                                    \\\n-                            do_entry, do_entry_init,                    \\\n-                            do_entry_array,                             \\\n-                            do_arch_blob,                               \\\n-                            do_arch_entry, do_arch_entry_init)          \\\n-  STUBGEN_FINAL_BLOBS_DO(do_blob, end_blob,                             \\\n-                         do_stub,                                       \\\n-                         do_entry, do_entry_init,                       \\\n-                         do_entry_array,                                \\\n-                         do_arch_blob,                                  \\\n-                         do_arch_entry, do_arch_entry_init)             \\\n-\n@@ -1058,1 +1184,1 @@\n-\/\/ client macro to operate only on StubGenerator blobs and stubs\n+\/\/ client macros to operate only on StubGenerator blobs and stubs\n@@ -1068,0 +1194,11 @@\n+\/\/ client macro to operate only on StubGenerator generci and arch entries\n+\n+#define STUBGEN_ALL_ENTRIES_DO(do_entry, do_entry_init, do_entry_array, \\\n+                               do_arch_entry, do_arch_entry_init)       \\\n+  STUBGEN_ALL_DO(DO_BLOB_EMPTY1, DO_BLOB_EMPTY1,                        \\\n+                 DO_STUB_EMPTY2,                                        \\\n+                 do_entry, do_entry_init,                               \\\n+                 do_entry_array,                                        \\\n+                 DO_ARCH_BLOB_EMPTY2,                                   \\\n+                 do_arch_entry, do_arch_entry_init)                     \\\n+\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":283,"deletions":146,"binary":false,"changes":429,"status":"modified"},{"patch":"@@ -0,0 +1,1080 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"code\/codeBlob.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/stubDeclarations.hpp\"\n+#include \"runtime\/stubInfo.hpp\"\n+\n+\/\/ define static data fields of class Stubdata\n+\n+struct StubInfo::GroupDetails StubInfo::_group_table[StubInfo::GROUP_TABLE_SIZE];\n+struct StubInfo::BlobDetails StubInfo::_blob_table[StubInfo::BLOB_TABLE_SIZE];\n+struct StubInfo::StubDetails StubInfo::_stub_table[StubInfo::STUB_TABLE_SIZE];\n+struct StubInfo::EntryDetails StubInfo::_entry_table[StubInfo::ENTRY_TABLE_SIZE];\n+\n+\/\/ helpers to access table elements using enums as indices\n+\n+struct StubInfo::GroupDetails& StubInfo::group_details(StubGroup g) {\n+  int idx = static_cast<int>(g);\n+  assert(idx >= 0 && idx < GROUP_TABLE_SIZE, \"invalid stub group index %d\", idx);\n+  return _group_table[idx];\n+}\n+\n+struct StubInfo::BlobDetails& StubInfo::blob_details(BlobId b) {\n+  int idx = static_cast<int>(b);\n+  assert(idx >= 0 && idx < BLOB_TABLE_SIZE, \"invalid blob index %d\", idx);\n+  return _blob_table[idx];\n+}\n+\n+struct StubInfo::StubDetails& StubInfo::stub_details(StubId s) {\n+  int idx = static_cast<int>(s);\n+  assert(idx >= 0 && idx < STUB_TABLE_SIZE, \"invalid stub index %d\", idx);\n+  return _stub_table[idx];\n+}\n+\n+struct StubInfo::EntryDetails& StubInfo::entry_details(EntryId e) {\n+  int idx = static_cast<int>(e);\n+  assert(idx >= 0 && idx < ENTRY_TABLE_SIZE, \"invalid entry index %d\", idx);\n+  return _entry_table[idx];\n+}\n+\n+\/\/ helpers to step through blob, stub or entry enum sequences\n+\n+BlobId StubInfo::next(BlobId id) {\n+  int idx = static_cast<int>(id);\n+  \/\/ allow for id to be NO_BLOBID but not NUM_BLOBIDS\n+  assert(idx >= -1 && idx < BLOB_TABLE_SIZE, \"invalid blob index %d\", idx);\n+  return static_cast<BlobId>(idx + 1);\n+}\n+\n+StubId StubInfo::next(StubId id) {\n+  int idx = static_cast<int>(id);\n+  \/\/ allow for id to be NO_STUBID but not NUM_STUBIDS\n+  assert(idx >= -1 && idx < STUB_TABLE_SIZE, \"invalid stub index %d\", idx);\n+  return static_cast<StubId>(idx + 1);\n+}\n+\n+EntryId StubInfo::next(EntryId id) {\n+  int idx = static_cast<int>(id);\n+  \/\/ allow for id to be NO_ENTRYID but not NUM_ENTRYIDS\n+  assert(idx >= -1 && idx < ENTRY_TABLE_SIZE, \"invalid entry index %d\", idx);\n+  return static_cast<EntryId>(idx + 1);\n+}\n+\n+BlobId StubInfo::next_in_group(StubGroup stub_group, BlobId blob_id) {\n+  int idx = static_cast<int>(blob_id);\n+  \/\/ id must be strictly between NO_BLOBID and NUM_BLOBIDS\n+  assert(idx > -1 && idx < STUB_TABLE_SIZE, \"invalid stub index %d\", idx);\n+  assert(blob_details(blob_id)._group == stub_group, \"blob does not belong to stub group!\");\n+  struct GroupDetails& group = group_details(stub_group);\n+  if (blob_id == group._max) {\n+    return BlobId::NO_BLOBID;\n+  } else {\n+    return static_cast<BlobId>(idx + 1);\n+  }\n+}\n+\n+StubId StubInfo::next_in_blob(BlobId blob_id, StubId stub_id) {\n+  int idx = static_cast<int>(stub_id);\n+  \/\/ id must be strictly between NO_STUBID and NUM_STUBIDS\n+  assert(idx > -1 && idx < STUB_TABLE_SIZE, \"invalid stub index %d\", idx);\n+  assert(stub_details(stub_id)._blob == blob_id, \"stub does not belong to blob!\");\n+  struct BlobDetails& blob = blob_details(blob_id);\n+  if (stub_id == blob._max) {\n+    return StubId::NO_STUBID;\n+  } else {\n+    return static_cast<StubId>(idx + 1);\n+  }\n+}\n+\n+EntryId StubInfo::next_in_stub(StubId stub_id, EntryId entry_id) {\n+  int idx = static_cast<int>(entry_id);\n+  \/\/ id must be strictly between NO_ENTRYID and NUM_ENTRYIDS\n+  assert(idx > -1 && idx < ENTRY_TABLE_SIZE, \"invalid entry index %d\", idx);\n+  assert(entry_details(entry_id)._stub == stub_id, \"entry does not belong to stub!\");\n+  struct StubDetails& stub = stub_details(stub_id);\n+  if (entry_id == stub._max) {\n+    return EntryId::NO_ENTRYID;\n+  } else {\n+    return static_cast<EntryId>(idx + 1);\n+  }\n+}\n+\n+\/\/ name retrieval\n+\n+const char* StubInfo::name(StubGroup stub_group) {\n+  return group_details(stub_group)._name;\n+}\n+\n+const char* StubInfo::name(BlobId id) {\n+  return blob_details(id)._name;\n+}\n+\n+const char* StubInfo::name(StubId id) {\n+  return stub_details(id)._name;\n+}\n+\n+const char* StubInfo::name(EntryId id) {\n+  return entry_details(id)._name;\n+}\n+\n+int StubInfo::span(EntryId second, EntryId first) {\n+  \/\/ normally when the two ids are equal the entry span is 1 but we\n+  \/\/ have a special case when the base and max are both NO_ENTRYID in\n+  \/\/ which case the entry count is 0\n+  int idx1 = static_cast<int>(first);\n+  int idx2 = static_cast<int>(second);\n+  assert ((idx1 < 0 && idx2  < 0) || (idx1 >= 0 && idx2 >= idx1), \"bad entry ids first %d and second %d\", idx1, idx2);\n+  if (idx1 < 0) {\n+    return 0;\n+  }\n+  \/\/ span is inclusive of first and second\n+  return idx2 + 1 - idx1;\n+}\n+\n+int StubInfo::span(StubId second, StubId first) {\n+  int idx1 = static_cast<int>(first);\n+  int idx2 = static_cast<int>(second);\n+  assert(idx2 >= 0 && idx2 >= idx1, \"bad stub ids first %d and second %d\", idx1, idx2);\n+  \/\/ span is inclusive of first and second\n+  return idx2 + 1 - idx1;\n+}\n+\n+int StubInfo::span(BlobId second, BlobId first) {\n+  int idx1 = static_cast<int>(first);\n+  int idx2 = static_cast<int>(second);\n+  assert(idx2 >= 0 && idx2 >= idx1, \"bad blob ids first %d and second %d\", idx1, idx2);\n+  \/\/ span is inclusive of first and second\n+  return idx2 + 1 - idx1;\n+}\n+\n+#ifdef ASSERT\n+\/\/ helpers to check sequencing of blobs stubs and entries\n+bool StubInfo::is_next(BlobId second, BlobId first) {\n+  return next(first) == second;\n+}\n+\n+bool StubInfo::is_next(StubId second, StubId first) {\n+  return next(first) == second;\n+}\n+\n+bool StubInfo::is_next(EntryId second, EntryId first) {\n+  return next(first) == second;\n+}\n+#endif \/\/ ASSERT\n+\n+\/\/ implementation of the counting methods used to populate the\n+\/\/ stubgroup, blob, stub and entry tables\n+\n+void StubInfo::process_shared_blob(StubGroup& group_cursor,\n+                                   BlobId&  blob_cursor,\n+                                   StubId& stub_cursor,\n+                                   EntryId& entry_cursor,\n+                                   const char* name,\n+                                   BlobId declaredBlob,\n+                                   StubId declaredStub,\n+                                   EntryId declaredEntry,\n+                                   EntryId declaredMax) {\n+  \/\/ for shared declarations we update the blob, stub and entry tables\n+  \/\/ all in one go based on each unique blob declaration. We may need\n+  \/\/ to write more than one entry table element if the stub has\n+  \/\/ multiple entries\n+  assert(group_cursor == StubGroup::SHARED, \"must be\");\n+  assert(is_next (declaredBlob, blob_cursor), \"Out of order declaration for shared blob %s\", name);\n+  assert(is_next(declaredStub, stub_cursor), \"Out of order declaration for shared stub %s\", name);\n+  assert(is_next(declaredEntry, entry_cursor), \"Out of order declaration for shared entry %s\", name);\n+  assert(span(declaredMax, declaredEntry) > 0, \"Invalid entry count %d for entry %s\", span(declaredMax, declaredEntry), name);\n+  \/\/ if this is the first shared blob then record it as teh base id\n+  \/\/ and also update entry base\n+  if (group_details(group_cursor)._base == BlobId::NO_BLOBID) {\n+    group_details(group_cursor)._base = declaredBlob;\n+    group_details(group_cursor)._entry_base = declaredEntry;\n+  }\n+  \/\/ update the high water mark for blobs and entries in the stub\n+  \/\/ group unconditionally\n+  group_details(group_cursor)._max = declaredBlob;\n+  group_details(group_cursor)._entry_max = declaredMax;\n+  \/\/ move forward to this blob\n+  blob_cursor = declaredBlob;\n+  \/\/ link the blob to its group and its unique stub\n+  blob_details(blob_cursor)._group = group_cursor;\n+  blob_details(blob_cursor)._base = declaredStub;\n+  blob_details(blob_cursor)._max = declaredStub;\n+  blob_details(blob_cursor)._name = name;\n+  \/\/ move forward to this stub\n+  stub_cursor = declaredStub;\n+  \/\/ link the stub to its blob and its entries\n+  stub_details(stub_cursor)._blob = declaredBlob;\n+  stub_details(stub_cursor)._base = declaredEntry;\n+  stub_details(stub_cursor)._max = declaredMax;\n+  stub_details(stub_cursor)._is_entry_array = false;\n+  stub_details(stub_cursor)._name = name;\n+  \/\/ move forward to last entry\n+  entry_cursor = declaredMax;\n+  \/\/ fill out the entry table for the the declared entry up to last entry\n+  EntryId id = declaredEntry;\n+  entry_details(id)._stub = declaredStub;\n+  entry_details(id)._array_base = EntryId::NO_ENTRYID;\n+  entry_details(id)._name = name;\n+  \/\/ fill any subsequent entries\n+  while (id != declaredMax) {\n+    id = next(id);\n+    entry_details(id)._stub = declaredStub;\n+    entry_details(id)._array_base = EntryId::NO_ENTRYID;\n+    entry_details(id)._name = name;\n+  }\n+}\n+\n+void StubInfo::process_c1_blob(StubGroup& group_cursor,\n+                               BlobId&  blob_cursor,\n+                               StubId& stub_cursor,\n+                               EntryId& entry_cursor,\n+                               const char* name,\n+                               BlobId declaredBlob,\n+                               StubId declaredStub,\n+                               EntryId declaredEntry) {\n+  \/\/ for c1 declarations we update the blob, stub and entry tables all\n+  \/\/ in one go based on each unique blob declaration\n+  assert(group_cursor == StubGroup::C1, \"must be\");\n+  assert(is_next(declaredBlob, blob_cursor), \"Out of order declaration for c1 blob %s\", name);\n+  assert(is_next(declaredStub, stub_cursor), \"Out of order declaration for c1 stub %s\", name);\n+  assert(is_next(declaredEntry, entry_cursor), \"Out of order declaration for c1 entry %s\", name);\n+  \/\/ if this is the first c1 blob then record it and the entry\n+  if (group_details(group_cursor)._base == BlobId::NO_BLOBID) {\n+    group_details(group_cursor)._base = declaredBlob;\n+    group_details(group_cursor)._entry_base = declaredEntry;\n+  }\n+  \/\/ update the high water mark for blobs and entries in the stub\n+  \/\/ group unconditionally\n+  group_details(group_cursor)._max = declaredBlob;\n+  group_details(group_cursor)._entry_max = declaredEntry;\n+  \/\/ move forward to this blob\n+  blob_cursor = declaredBlob;\n+  \/\/ link the blob to its group and its unique stub\n+  blob_details(blob_cursor)._group = group_cursor;\n+  blob_details(blob_cursor)._base = declaredStub;\n+  blob_details(blob_cursor)._max = declaredStub;\n+  blob_details(blob_cursor)._name = name;\n+  \/\/ move forward to this stub\n+  stub_cursor = declaredStub;\n+  \/\/ link the stub to its blob and its entries\n+  stub_details(stub_cursor)._blob = declaredBlob;\n+  stub_details(stub_cursor)._base = declaredEntry;\n+  stub_details(stub_cursor)._max = declaredEntry;\n+  stub_details(stub_cursor)._is_entry_array = false;\n+  stub_details(stub_cursor)._name = name;\n+  \/\/ move forward to entry\n+  entry_cursor = declaredEntry;\n+  \/\/ fill out the entry table element\n+  entry_details(entry_cursor)._stub = declaredStub;\n+  entry_details(entry_cursor)._array_base = EntryId::NO_ENTRYID;\n+  entry_details(entry_cursor)._name = name;\n+}\n+\n+void StubInfo::process_c2_blob(StubGroup& group_cursor,\n+                               BlobId&  blob_cursor,\n+                               StubId& stub_cursor,\n+                               EntryId& entry_cursor,\n+                               const char* name,\n+                               BlobId declaredBlob,\n+                               StubId declaredStub,\n+                               EntryId declaredEntry) {\n+  \/\/ for c2 declarations we update the blob, stub and entry tables all\n+  \/\/ in one go based on the same details garnered from each unique\n+  \/\/ blob, stub r jvmti stub declaration\n+  assert(group_cursor == StubGroup::C2, \"must be\");\n+  assert(is_next(declaredBlob, blob_cursor), \"Out of order declaration for c2 blob %s\", name);\n+  assert(is_next(declaredStub, stub_cursor), \"Out of order declaration for c2 stub %s\", name);\n+  assert(is_next(declaredEntry, entry_cursor), \"Out of order declaration for c2 entry %s\", name);\n+  \/\/ if this is the first c2 blob then record it and the entry\n+  if (group_details(group_cursor)._base == BlobId::NO_BLOBID) {\n+    group_details(group_cursor)._base = declaredBlob;\n+    group_details(group_cursor)._entry_base = declaredEntry;\n+  }\n+  \/\/ update the high water mark for blobs and entries in the stub\n+  \/\/ group unconditionally\n+  group_details(group_cursor)._max = declaredBlob;\n+  group_details(group_cursor)._entry_max = declaredEntry;\n+  \/\/ move forward to this blob\n+  blob_cursor = declaredBlob;\n+  \/\/ link the blob to its group and its unique stub\n+  blob_details(blob_cursor)._group = group_cursor;\n+  blob_details(blob_cursor)._base = declaredStub;\n+  blob_details(blob_cursor)._max = declaredStub;\n+  blob_details(blob_cursor)._name = name;\n+  \/\/ move forward to this stub\n+  stub_cursor = declaredStub;\n+  \/\/ link the stub to its blob and its entries\n+  stub_details(stub_cursor)._blob = declaredBlob;\n+  stub_details(stub_cursor)._base = declaredEntry;\n+  stub_details(stub_cursor)._max = declaredEntry;\n+  stub_details(stub_cursor)._is_entry_array = false;\n+  stub_details(stub_cursor)._name = name;\n+  \/\/ move forward to entry\n+  entry_cursor = declaredEntry;\n+  \/\/ fill out the entry table element\n+  entry_details(entry_cursor)._stub = declaredStub;\n+  entry_details(entry_cursor)._array_base = EntryId::NO_ENTRYID;\n+  entry_details(entry_cursor)._name = name;\n+}\n+\n+void StubInfo::process_stubgen_blob(StubGroup& group_cursor,\n+                                    BlobId&  blob_cursor,\n+                                    StubId& stub_cursor,\n+                                    EntryId& entry_cursor,\n+                                    const char* name,\n+                                    BlobId declaredBlob) {\n+  \/\/ for stubgen blob declarations we update the blob table, allowing\n+  \/\/ us to link subsequent stubs to that blob\n+  assert(group_cursor == StubGroup::STUBGEN, \"must be\");\n+  assert(is_next(declaredBlob, blob_cursor), \"Out of order declaration for stubgen blob %s\", name);\n+  \/\/ if this is the first stubgen blob then record it\n+  if (group_details(group_cursor)._base == BlobId::NO_BLOBID) {\n+    group_details(group_cursor)._base = declaredBlob;\n+  }\n+  \/\/ update the high water mark for blobs in the stub group unconditionally\n+  group_details(group_cursor)._max = declaredBlob;\n+  \/\/ move forward to this blob\n+  blob_cursor = declaredBlob;\n+  \/\/ link the blob to its group\n+  blob_details(blob_cursor)._group = group_cursor;\n+  \/\/ clear the blob table base and max - they are set when we first\n+  \/\/ encounter a stub. likewise the blob table entry base and entry\n+  \/\/ max -- they are set when we first encounter an entry\n+  blob_details(blob_cursor)._base = StubId::NO_STUBID;\n+  blob_details(blob_cursor)._max = StubId::NO_STUBID;\n+  blob_details(blob_cursor)._entry_base = EntryId::NO_ENTRYID;\n+  blob_details(blob_cursor)._entry_max = EntryId::NO_ENTRYID;\n+  blob_details(blob_cursor)._name = name;\n+}\n+\n+void StubInfo::process_stubgen_stub(StubGroup& group_cursor,\n+                                    BlobId&  blob_cursor,\n+                                    StubId& stub_cursor,\n+                                    EntryId& entry_cursor,\n+                                    const char* name,\n+                                    BlobId declaredBlob,\n+                                    StubId declaredStub) {\n+  \/\/ for stubgen stub declarations we update the stub table, allowing\n+  \/\/ us to link subsequent entries to that stub\n+  assert(group_cursor == StubGroup::STUBGEN, \"must be\");\n+  \/\/ FIXME use stub name here\n+  assert(declaredBlob == blob_cursor, \"Stubgen stub %s in scope of incorrect blob %s\", name, blob_details(blob_cursor)._name);\n+  assert(is_next(declaredStub, stub_cursor), \"Out of order declaration for stubgen stub %s\", name);\n+  \/\/ if this is the first stubgen stub then record it\n+  if (blob_details(blob_cursor)._base == StubId::NO_STUBID) {\n+    blob_details(blob_cursor)._base = declaredStub;\n+  }\n+  \/\/ update the high water mark for stubs in the blob unconditionally\n+  blob_details(blob_cursor)._max = declaredStub;\n+  \/\/ move forward to this stub\n+  stub_cursor = declaredStub;\n+  \/\/ link the stub to its blob\n+  stub_details(stub_cursor)._blob = blob_cursor;\n+  \/\/ clear the stub table base and max - they are set when we\n+  \/\/ encounter an entry\n+  stub_details(stub_cursor)._base = EntryId::NO_ENTRYID;\n+  stub_details(stub_cursor)._max = EntryId::NO_ENTRYID;\n+  stub_details(stub_cursor)._name = name;;\n+}\n+\n+void StubInfo::process_stubgen_entry(StubGroup& group_cursor,\n+                                     BlobId&  blob_cursor,\n+                                     StubId& stub_cursor,\n+                                     EntryId& entry_cursor,\n+                                     const char* name,\n+                                     BlobId declaredBlob,\n+                                     StubId declaredStub,\n+                                     EntryId declaredEntry,\n+                                     int arrayCount) {\n+  \/\/ for stubgen entry declarations we update the entry table\n+  assert(group_cursor == StubGroup::STUBGEN, \"must be\");\n+  assert(declaredBlob == blob_cursor, \"Stubgen entry %s in scope of wrong blob %s\", name, blob_details(blob_cursor)._name);\n+  assert(declaredStub == stub_cursor, \"Stubgen entry %s declares stub in scope of wrong stub %s\", name, stub_details(stub_cursor)._name);\n+  assert(is_next(declaredEntry, entry_cursor), \"Out of order declaration for stubgen entry %s\", name);\n+  assert(arrayCount >= 0, \"Invalid array count %d\", arrayCount);\n+  \/\/ if this is the first stubgen entry in the group then record it\n+  if (group_details(group_cursor)._entry_base == EntryId::NO_ENTRYID) {\n+    group_details(group_cursor)._entry_base = declaredEntry;\n+  }\n+  \/\/ update the high water mark for entries in the group unconditionally\n+  group_details(group_cursor)._entry_max = declaredEntry;\n+  \/\/ if this is the first stubgen entry in the blob then record it\n+  if (blob_details(blob_cursor)._entry_base == EntryId::NO_ENTRYID) {\n+    blob_details(blob_cursor)._entry_base = declaredEntry;\n+  }\n+  \/\/ update the high water mark for entries in the group unconditionally\n+  blob_details(blob_cursor)._entry_max = declaredEntry;\n+  \/\/ if this is the first stubgen entry in the stub then record it\n+  if (stub_details(stub_cursor)._base == EntryId::NO_ENTRYID) {\n+    stub_details(stub_cursor)._base = declaredEntry;\n+  }\n+  \/\/ move forward to this entry\n+  if (arrayCount == 0) {\n+    \/\/ simply link the entry to its blob\n+    entry_cursor = declaredEntry;\n+    entry_details(entry_cursor)._stub = stub_cursor;\n+    entry_details(entry_cursor)._array_base = EntryId::NO_ENTRYID;\n+    entry_details(entry_cursor)._name = name;\n+  } else {\n+    \/\/ populate multiple entries and link them all to the first entry\n+    for (int i = 0; i < arrayCount; i++) {\n+      entry_cursor = next(entry_cursor);\n+      entry_details(entry_cursor)._stub = stub_cursor;\n+      entry_details(entry_cursor)._array_base = declaredEntry;\n+      \/\/ TODO: consider allocating names labelled with index\n+      entry_details(entry_cursor)._name = name;\n+    }\n+  }\n+  \/\/ update the high water mark for entries in the stub unconditionally\n+  stub_details(stub_cursor)._max = entry_cursor;\n+}\n+\n+\/\/ The stubgroup, blob, stub and entry tables defined above are\n+\/\/ populated by iterating over all blob, stub and entry declarations\n+\/\/ and incrementally updating the associated table entries. The\n+\/\/ following macros invoke static methods of StubInfo that receive\n+\/\/ and, where appropriate, update cursors identifying current\n+\/\/ positions in each table.\n+\n+#define PROCESS_SHARED_BLOB(name, type)                                 \\\n+  process_shared_blob(_group_cursor, _blob_cursor,                      \\\n+                      _stub_cursor, _entry_cursor,                      \\\n+                      \"Shared Runtime \" # name \"_blob\",                 \\\n+                      BlobId:: JOIN3(shared, name, id),                 \\\n+                      StubId:: JOIN3(shared, name, id),                 \\\n+                      EntryId:: JOIN3(shared, name, id),                \\\n+                      EntryId:: JOIN3(shared, name, max));              \\\n+\n+#define PROCESS_C1_BLOB(name)                                     \\\n+  process_c1_blob(_group_cursor, _blob_cursor,                    \\\n+                  _stub_cursor, _entry_cursor,                    \\\n+                  \"C1 Runtime \" # name \"_blob\",                   \\\n+                  BlobId:: JOIN3(c1, name, id),                   \\\n+                  StubId:: JOIN3(c1, name, id),                   \\\n+                  EntryId:: JOIN3(c1, name, id));                 \\\n+\n+#define PROCESS_C2_BLOB(name, type)                         \\\n+  process_c2_blob(_group_cursor, _blob_cursor,              \\\n+                  _stub_cursor, _entry_cursor,              \\\n+                  \"C2 Runtime \" # name \"_blob\",             \\\n+                  BlobId:: JOIN3(c2, name, id),             \\\n+                  StubId:: JOIN3(c2, name, id),             \\\n+                  EntryId:: JOIN3(c2, name, id));           \\\n+\n+#define PROCESS_C2_STUB(name, fancy_jump, pass_tls, return_pc)    \\\n+  process_c2_blob(_group_cursor, _blob_cursor,                    \\\n+                  _stub_cursor, _entry_cursor,                    \\\n+                  \"C2 Runtime \" # name \"_blob\",                   \\\n+                  BlobId:: JOIN3(c2, name, id),                   \\\n+                  StubId:: JOIN3(c2, name, id),                   \\\n+                  EntryId:: JOIN3(c2, name, id));                 \\\n+\n+#define PROCESS_C2_JVMTI_STUB(name)                               \\\n+  process_c2_blob(_group_cursor, _blob_cursor,                    \\\n+                  _stub_cursor, _entry_cursor,                    \\\n+                  \"C2 Runtime \" # name \"_blob\",                   \\\n+                  BlobId:: JOIN3(c2, name, id),                   \\\n+                  StubId:: JOIN3(c2, name, id),                   \\\n+                  EntryId:: JOIN3(c2, name, id));                 \\\n+\n+#define PROCESS_STUBGEN_BLOB(blob)                                \\\n+  process_stubgen_blob(_group_cursor, _blob_cursor,               \\\n+                       _stub_cursor, _entry_cursor,               \\\n+                       \"Stub Generator \" # blob \"_blob\",          \\\n+                       BlobId:: JOIN3(stubgen, blob, id));        \\\n+\n+#define PROCESS_STUBGEN_STUB(blob, stub)                          \\\n+  process_stubgen_stub(_group_cursor, _blob_cursor,               \\\n+                       _stub_cursor, _entry_cursor,               \\\n+                       \"Stub Generator \" # stub \"_stub\",          \\\n+                       BlobId:: JOIN3(stubgen, blob, id),         \\\n+                       StubId:: JOIN3(stubgen, stub, id));        \\\n+\n+#define PROCESS_STUBGEN_ENTRY(blob, stub, field_name, getter_name)      \\\n+  process_stubgen_entry(_group_cursor, _blob_cursor,                    \\\n+                        _stub_cursor, _entry_cursor,                    \\\n+                        \"Stub Generator \" # field_name \"_entry\",        \\\n+                        BlobId:: JOIN3(stubgen, blob, id),              \\\n+                        StubId:: JOIN3(stubgen, stub, id),              \\\n+                        EntryId:: JOIN3(stubgen, field_name, id),       \\\n+                        0);                                             \\\n+\n+#define PROCESS_STUBGEN_ENTRY_INIT(blob, stub, field_name, getter_name, \\\n+                                   init_funcion)                        \\\n+  process_stubgen_entry(_group_cursor, _blob_cursor,                    \\\n+                        _stub_cursor, _entry_cursor,                    \\\n+                        \"Stub Generator \" # field_name \"_entry\",        \\\n+                        BlobId:: JOIN3(stubgen, blob, id),              \\\n+                        StubId:: JOIN3(stubgen, stub, id),              \\\n+                        EntryId:: JOIN3(stubgen, field_name, id),       \\\n+                        0);                                             \\\n+\n+#define PROCESS_STUBGEN_ENTRY_ARRAY(blob, stub, field_name, getter_name, \\\n+                                    count)                              \\\n+  process_stubgen_entry(_group_cursor, _blob_cursor,                    \\\n+                        _stub_cursor, _entry_cursor,                    \\\n+                        \"Stub Generator \" # field_name \"_entry\",        \\\n+                        BlobId:: JOIN3(stubgen, blob, id),              \\\n+                        StubId:: JOIN3(stubgen, stub, id),              \\\n+                        EntryId:: JOIN3(stubgen, field_name, id),       \\\n+                        count);                                         \\\n+\n+#define PROCESS_STUBGEN_ENTRY_ARCH(arch_name, blob, stub, field_name,   \\\n+                                   getter_name)                         \\\n+  process_stubgen_entry(_group_cursor, _blob_cursor,                    \\\n+                        _stub_cursor, _entry_cursor,                    \\\n+                        #arch_name \"_\" # field_name,                    \\\n+                        BlobId:: JOIN3(stubgen, blob, id),              \\\n+                        StubId:: JOIN3(stubgen, stub, id),              \\\n+                        EntryId:: JOIN4(stubgen, arch_name,             \\\n+                                        field_name, id),                \\\n+                        0);                                             \\\n+\n+#define PROCESS_STUBGEN_ENTRY_ARCH_INIT(arch_name, blob, stub,          \\\n+                                        field_name, getter_name,        \\\n+                                        init_function)                  \\\n+  process_stubgen_entry(_group_cursor, _blob_cursor,                    \\\n+                        _stub_cursor, _entry_cursor,                    \\\n+                        \"Stub Generator \" # arch_name \"_\" # field_name \"_entry\", \\\n+                        BlobId:: JOIN3(stubgen, blob, id),              \\\n+                        StubId:: JOIN3(stubgen, stub, id),              \\\n+                        EntryId:: JOIN4(stubgen, arch_name,             \\\n+                                        field_name, id),                \\\n+                        0);                                             \\\n+\n+void StubInfo::populate_stub_tables() {\n+  StubGroup _group_cursor;\n+  BlobId _blob_cursor = BlobId::NO_BLOBID;\n+  StubId _stub_cursor = StubId::NO_STUBID;\n+  EntryId _entry_cursor = EntryId::NO_ENTRYID;\n+\n+  _group_cursor = StubGroup::SHARED;\n+  group_details(_group_cursor)._name = \"Shared Stubs\";\n+  group_details(_group_cursor)._base = BlobId::NO_BLOBID;\n+  group_details(_group_cursor)._max = BlobId::NO_BLOBID;\n+  group_details(_group_cursor)._entry_base = EntryId::NO_ENTRYID;\n+  group_details(_group_cursor)._entry_max = EntryId::NO_ENTRYID;\n+  SHARED_STUBS_DO(PROCESS_SHARED_BLOB);\n+\n+  _group_cursor = StubGroup::C1;\n+  group_details(_group_cursor)._name = \"C1 Stubs\";\n+  group_details(_group_cursor)._base = BlobId::NO_BLOBID;\n+  group_details(_group_cursor)._max = BlobId::NO_BLOBID;\n+  group_details(_group_cursor)._entry_base = EntryId::NO_ENTRYID;\n+  group_details(_group_cursor)._entry_max = EntryId::NO_ENTRYID;\n+  C1_STUBS_DO(PROCESS_C1_BLOB);\n+\n+  _group_cursor = StubGroup::C2;\n+  group_details(_group_cursor)._name = \"C2 Stubs\";\n+  group_details(_group_cursor)._base = BlobId::NO_BLOBID;\n+  group_details(_group_cursor)._max = BlobId::NO_BLOBID;\n+  group_details(_group_cursor)._entry_base = EntryId::NO_ENTRYID;\n+  group_details(_group_cursor)._entry_max = EntryId::NO_ENTRYID;\n+  C2_STUBS_DO(PROCESS_C2_BLOB, PROCESS_C2_STUB, PROCESS_C2_JVMTI_STUB);\n+\n+  _group_cursor = StubGroup::STUBGEN;\n+  group_details(_group_cursor)._name = \"StubGen Stubs\";\n+  group_details(_group_cursor)._base = BlobId::NO_BLOBID;\n+  group_details(_group_cursor)._max = BlobId::NO_BLOBID;\n+  group_details(_group_cursor)._entry_base = EntryId::NO_ENTRYID;\n+  group_details(_group_cursor)._entry_max = EntryId::NO_ENTRYID;\n+  STUBGEN_ALL_DO(PROCESS_STUBGEN_BLOB, DO_BLOB_EMPTY1,\n+                 PROCESS_STUBGEN_STUB,\n+                 PROCESS_STUBGEN_ENTRY, PROCESS_STUBGEN_ENTRY_INIT,\n+                 PROCESS_STUBGEN_ENTRY_ARRAY,\n+                 DO_ARCH_BLOB_EMPTY2,\n+                 PROCESS_STUBGEN_ENTRY_ARCH, PROCESS_STUBGEN_ENTRY_ARCH_INIT);\n+  assert(next(_blob_cursor) == BlobId::NUM_BLOBIDS, \"should have exhausted all blob ids!\");\n+  assert(next(_stub_cursor) == StubId::NUM_STUBIDS, \"should have exhausted all stub ids!\");\n+  assert(next(_entry_cursor) == EntryId::NUM_ENTRYIDS, \"should have exhausted all entry ids!\");\n+#ifdef ASSERT\n+  \/\/ run further sanity checks\n+  verify_stub_tables();\n+#endif \/\/ ASSERT\n+}\n+\n+#undef PROCESS_SHARED_BLOB\n+#undef PROCESS_C1_BLOB\n+#undef PROCESS_C2_BLOB\n+#undef PROCESS_C2_STUB\n+#undef PROCESS_C2_JVMTI_STUB\n+#undef PROCESS_STUBGEN_BLOB\n+#undef PROCESS_STUBGEN_STUB\n+#undef PROCESS_STUBGEN_ENTRY\n+#undef PROCESS_STUBGEN_ENTRY_INIT\n+#undef PROCESS_STUBGEN_ENTRY_ARRAY\n+#undef PROCESS_STUBGEN_ENTRY_ARCH\n+#undef PROCESS_STUBGEN_ENTRY_ARCH_INIT\n+\n+#ifdef ASSERT\n+\n+void StubInfo::verify_stub_tables() {\n+  \/\/ exercise the traversal and interconversion APIs\n+  const int NUM_STUBGROUPS = static_cast<int>(StubGroup::NUM_STUBGROUPS);\n+  StubGroup groups[NUM_STUBGROUPS] = {\n+    StubGroup::SHARED,\n+    StubGroup::C1,\n+    StubGroup::C2,\n+    StubGroup::STUBGEN };\n+\n+  \/\/ check that the statically defined blob, stub and entry counts\n+  \/\/ match the computed totals\n+  assert(blob_count(StubGroup::SHARED) == StubInfo::SHARED_STUB_COUNT,\n+         \"miscounted number of shared blobs %d vs %d\",\n+         blob_count(StubGroup::SHARED), StubInfo::SHARED_STUB_COUNT);\n+\n+  assert(stub_count(StubGroup::SHARED) == StubInfo::SHARED_STUB_COUNT,\n+         \"miscounted number of shared stubs %d vs %d\",\n+         stub_count(StubGroup::SHARED), StubInfo::SHARED_STUB_COUNT);\n+\n+  assert(entry_count(StubGroup::SHARED) == StubInfo::SHARED_ENTRY_COUNT,\n+         \"miscounted number of shared entries %d vs %d\",\n+         entry_count(StubGroup::SHARED), StubInfo::SHARED_ENTRY_COUNT);\n+\n+  assert(blob_count(StubGroup::C1) == StubInfo::C1_STUB_COUNT,\n+         \"miscounted number of c1 blobs %d vs %d\",\n+         blob_count(StubGroup::C1), StubInfo::C1_STUB_COUNT);\n+\n+  assert(stub_count(StubGroup::C1) == StubInfo::C1_STUB_COUNT,\n+         \"miscounted number of c1 stubs %d vs %d\",\n+         stub_count(StubGroup::C1), StubInfo::C1_STUB_COUNT);\n+\n+  assert(entry_count(StubGroup::C1) == StubInfo::C1_STUB_COUNT,\n+         \"miscounted number of c1 entries %d vs %d\",\n+         entry_count(StubGroup::C1), StubInfo::C1_STUB_COUNT);\n+\n+  assert(blob_count(StubGroup::C2) == StubInfo::C2_STUB_COUNT,\n+         \"miscounted number of c2 blobs %d vs %d\",\n+         blob_count(StubGroup::C2), StubInfo::C2_STUB_COUNT);\n+\n+  assert(stub_count(StubGroup::C2) == StubInfo::C2_STUB_COUNT,\n+         \"miscounted number of c2 stubs %d vs %d\",\n+         stub_count(StubGroup::C2), StubInfo::C2_STUB_COUNT);\n+\n+  assert(entry_count(StubGroup::C2) == StubInfo::C2_STUB_COUNT,\n+         \"miscounted number of c2 entries %d vs %d\",\n+         entry_count(StubGroup::C2), StubInfo::C2_STUB_COUNT);\n+\n+  assert(blob_count(StubGroup::STUBGEN) == StubInfo::STUBGEN_BLOB_COUNT,\n+         \"miscounted number of stubgen blobs %d vs %d\",\n+         blob_count(StubGroup::STUBGEN), StubInfo::STUBGEN_STUB_COUNT);\n+\n+  assert(stub_count(StubGroup::STUBGEN) == StubInfo::STUBGEN_STUB_COUNT,\n+         \"miscounted number of stubgen stubs %d vs %d\",\n+         stub_count(StubGroup::STUBGEN), StubInfo::STUBGEN_STUB_COUNT);\n+\n+  assert(entry_count(StubGroup::STUBGEN) == StubInfo::STUBGEN_ENTRY_COUNT,\n+         \"miscounted number of stubgen entries %d vs %d\",\n+         entry_count(StubGroup::STUBGEN), StubInfo::STUBGEN_ENTRY_COUNT);\n+\n+  \/\/ 1) check that the per-group blob counts add up\n+  for (int gidx = 0; gidx < NUM_STUBGROUPS ; gidx++) {\n+    StubGroup group = groups[gidx];\n+    BlobId blob = blob_base(group);\n+    int group_blob_total = blob_count(group);\n+    while (blob != BlobId::NO_BLOBID) {\n+      \/\/ predecrement total\n+      group_blob_total--;\n+      assert(group_blob_total > 0 || blob == blob_max(group), \"must be!\");\n+      assert(stubgroup(blob) == group, \"iterated out of group %s to blob %s\", name(group), name(blob));\n+      blob = next_in_group(group, blob);\n+    }\n+    assert(group_blob_total == 0, \"must be!\");\n+  }\n+\n+  \/\/ 2) check that the per-group and per-blob stub counts add up\n+  for (int gidx = 0; gidx < NUM_STUBGROUPS; gidx++) {\n+    StubGroup group = groups[gidx];\n+    BlobId blob = blob_base(group);\n+    StubId group_stub = stub_base(group);\n+    int group_stub_total = stub_count(group);\n+    while (blob != BlobId::NO_BLOBID) {\n+      StubId stub = stub_base(blob);\n+      int stub_total = stub_count(blob);\n+      while (stub != StubId::NO_STUBID) {\n+        \/\/ iterations via group and blob should proceed in parallel\n+        assert(stub == group_stub, \"must be!\");\n+        \/\/ predecrement totals\n+        group_stub_total--;\n+        stub_total--;\n+        assert(stub_total > 0 || stub == stub_max(blob), \"must be!\");\n+        assert(group_stub_total > 0 || stub == stub_max(group), \"must be!\");\n+        assert(stubgroup(stub) == group, \"iterated out of group %s to stub %s\", name(group), name(stub));\n+        stub = next_in_blob(blob, stub);\n+        group_stub = next(group_stub);\n+      }\n+      assert(stub_total == 0, \"must be!\");\n+      blob = next_in_group(group, blob);\n+    }\n+    assert(group_stub_total == 0, \"must be!\");\n+  }\n+\n+  \/\/ 3) check that the per-group, per-blob and per-stub entry counts add up\n+  for (int gidx = 0; gidx < NUM_STUBGROUPS; gidx++) {\n+    StubGroup group = groups[gidx];\n+    BlobId blob = blob_base(group);\n+    StubId group_stub = stub_base(group);\n+    EntryId group_entry = entry_base(group);\n+    int group_entry_total = entry_count(group);\n+    while (blob != BlobId::NO_BLOBID) {\n+      StubId stub = stub_base(blob);\n+      while (stub != StubId::NO_STUBID) {\n+        EntryId entry = entry_base(stub);\n+        int entry_total = entry_count(stub);\n+        while (entry != EntryId::NO_ENTRYID) {\n+          \/\/ iterations via group and blob should proceed in parallel\n+          assert(entry == group_entry, \"must be!\");\n+          \/\/ predecrement totals\n+          group_entry_total--;\n+          entry_total--;\n+          assert(entry_total > 0 || entry == entry_max(stub), \"must be!\");\n+          assert(group_entry_total > 0 || entry == entry_max(group), \"must be!\");\n+          assert(stubgroup(entry) == group, \"iterated out of group %s to entry %s\", name(group), name(entry));\n+          entry = next_in_stub(stub, entry);\n+          group_entry = next(group_entry);\n+        }\n+        assert(entry_total == 0, \"must be!\");\n+        stub = next_in_blob(blob, stub);\n+        group_stub = next(group_stub);\n+      }\n+      blob = next_in_group(group, blob);\n+    }\n+    assert(group_entry_total == 0, \"must be!\");\n+  }\n+}\n+\n+#endif \/\/ ASSERT\n+\n+\/\/ info support\n+\n+void StubInfo::dump_group_table(LogStream& ls) {\n+  ls.print_cr(\"STUB GROUP TABLE\");\n+  for (int i = 0; i < GROUP_TABLE_SIZE; i++) {\n+    GroupDetails& g = _group_table[i];\n+    ls.print_cr(\"%1d: %-8s\", i, g._name);\n+    if (g._base == g._max) {\n+      ls.print_cr(\"  blobs: %s(%d)\",\n+                  blob_details(g._base)._name,\n+                  static_cast<int>(g._base));\n+    } else {\n+      ls.print_cr(\" blobs: %s(%d) ... %s(%d)\",\n+                  blob_details(g._base)._name,\n+                  static_cast<int>(g._base),\n+                  blob_details(g._max)._name,\n+                  static_cast<int>(g._max));\n+    }\n+  }\n+}\n+\n+void StubInfo::dump_blob_table(LogStream& ls) {\n+  ls.print_cr(\"BLOB TABLE\");\n+  for (int i = 0; i < BLOB_TABLE_SIZE; i++) {\n+    BlobDetails& b = _blob_table[i];\n+    ls.print_cr(\"%-3d: %s\", i, b._name);\n+    if (b._base == b._max) {\n+      ls.print_cr(\"  stubs: %s(%d)\",\n+                  stub_details(b._base)._name,\n+                  static_cast<int>(b._base));\n+    } else {\n+      ls.print_cr(\"  stubs: %s(%d) ... %s(%d)\",\n+                  stub_details(b._base)._name,\n+                  static_cast<int>(b._base),\n+                  stub_details(b._max)._name,\n+                  static_cast<int>(b._max));\n+    }\n+  }\n+}\n+\n+void StubInfo::dump_stub_table(LogStream& ls) {\n+  ls.print_cr(\"STUB TABLE\");\n+  for (int i = 0; i < STUB_TABLE_SIZE; i++) {\n+    StubDetails& s = _stub_table[i];\n+    ls.print_cr(\"%-3d: %s %s\", i, s._name,\n+                (s._is_entry_array ? \"array\" : \"\"));\n+    ls.print_cr(\"  blob: %d\", static_cast<int>(s._blob));\n+    if (s._base == s._max) {\n+      \/\/ some stubs don't have an entry\n+      if (s._base == EntryId::NO_ENTRYID) {\n+        ls.print_cr(\"  entries: %s(%d)\",\n+                    \"no_entry\",\n+                    static_cast<int>(s._base));\n+      } else {\n+        ls.print_cr(\"  entries: %s(%d)\",\n+                    entry_details(s._base)._name,\n+                    static_cast<int>(s._base));\n+      }\n+    } else {\n+      ls.print_cr(\"  entries: %s(%d) ... %s(%d)\",\n+                  entry_details(s._base)._name,\n+                  static_cast<int>(s._base),\n+                  entry_details(s._max)._name,\n+                  static_cast<int>(s._max));\n+    }\n+  }\n+}\n+\n+void StubInfo::dump_entry_table(LogStream& ls) {\n+  ls.print_cr(\"ENTRY TABLE\");\n+  for (int i = 0; i < ENTRY_TABLE_SIZE; i++) {\n+    EntryDetails& e = _entry_table[i];\n+    ls.print_cr(\"%-3d: %s\", i, e._name);\n+    if (e._array_base != EntryId::NO_ENTRYID) {\n+      ls.print_cr(\"  array base: %d\", static_cast<int>(e._array_base));\n+    }\n+    ls.print_cr(\"  stub: %d\", static_cast<int>(e._stub));\n+  }\n+}\n+\n+void StubInfo::dump_tables(LogStream& ls) {\n+  dump_group_table(ls);\n+  ls.print_cr(\"\");\n+  dump_blob_table(ls);\n+  ls.print_cr(\"\");\n+  dump_stub_table(ls);\n+  ls.print_cr(\"\");\n+  dump_entry_table(ls);\n+}\n+\n+\/\/ Global Group\/Blob\/Stub\/Entry Id Hierarchy Traversal:\n+\n+\/\/ traverse up\n+\n+StubGroup StubInfo::stubgroup(EntryId id) {\n+  \/\/ delegate\n+  return stubgroup(stub(id));\n+}\n+\n+StubGroup StubInfo::stubgroup(BlobId id) {\n+  return blob_details(id)._group;\n+}\n+\n+StubGroup StubInfo::stubgroup(StubId id) {\n+  \/\/ delegate\n+  return stubgroup(blob(id));\n+}\n+\n+StubId StubInfo::stub(EntryId id) {\n+  return entry_details(id)._stub;\n+}\n+\n+BlobId StubInfo::blob(EntryId id) {\n+  \/\/ delegate\n+  return blob(stub(id));\n+}\n+\n+BlobId StubInfo::blob(StubId id) {\n+  return stub_details(id)._blob;\n+}\n+\n+\/\/ traverse down\n+\n+BlobId StubInfo::blob_base(StubGroup stub_group) {\n+  return group_details(stub_group)._base;\n+}\n+\n+BlobId StubInfo::blob_max(StubGroup stub_group) {\n+  return group_details(stub_group)._max;\n+}\n+\n+int StubInfo::blob_count(StubGroup stub_group) {\n+  return span(blob_max(stub_group), blob_base(stub_group));\n+}\n+\n+StubId StubInfo::stub_base(StubGroup stub_group) {\n+  \/\/ delegate\n+  return stub_base(blob_base(stub_group));\n+}\n+\n+StubId StubInfo::stub_max(StubGroup stub_group) {\n+  \/\/ delegate\n+  return stub_max(blob_max(stub_group));\n+}\n+\n+int StubInfo::stub_count(StubGroup stub_group) {\n+  return span(stub_max(stub_group), stub_base(stub_group));\n+}\n+\n+EntryId StubInfo::entry_base(StubGroup stub_group) {\n+  return group_details(stub_group)._entry_base;\n+}\n+\n+EntryId StubInfo::entry_max(StubGroup stub_group) {\n+  return group_details(stub_group)._entry_max;\n+}\n+\n+int StubInfo::entry_count(StubGroup stub_group) {\n+  return span(entry_max(stub_group), entry_base(stub_group));\n+}\n+\n+StubId StubInfo::stub_base(BlobId id) {\n+  return blob_details(id)._base;\n+}\n+\n+StubId StubInfo::stub_max(BlobId id) {\n+  return blob_details(id)._max;\n+}\n+\n+int StubInfo::stub_count(BlobId id) {\n+  return span(stub_max(id), stub_base(id));\n+}\n+\n+EntryId StubInfo::entry_base(StubId id) {\n+  return stub_details(id)._base;\n+}\n+\n+EntryId StubInfo::entry_max(StubId id) {\n+  return stub_details(id)._max;\n+}\n+\n+int StubInfo::entry_count(StubId id) {\n+  return span(entry_max(id), entry_base(id));\n+}\n+\n+EntryId StubInfo::entry_base(BlobId id) {\n+  return blob_details(id)._entry_base;\n+}\n+\n+EntryId StubInfo::entry_max(BlobId id) {\n+  return blob_details(id)._entry_max;\n+}\n+\n+int StubInfo::entry_count(BlobId id) {\n+  return span(entry_base(id), entry_max(id));\n+}\n+\n+\/\/ Global <-> Local Id Management:\n+\n+\/\/ private helpers\n+\n+bool StubInfo::has_group(BlobId id, StubGroup group) {\n+  return stubgroup(id) == group;\n+}\n+\n+bool StubInfo::has_group(StubId id, StubGroup group) {\n+  return stubgroup(id) == group;\n+}\n+\n+bool StubInfo::has_group(EntryId id, StubGroup group) {\n+  return stubgroup(id) == group;\n+}\n+\n+\/\/ Convert a blob, entry or stub id to a unique, zero-based offset in\n+\/\/ the range of blob\/stub\/entry ids for a given stub group.\n+\n+int StubInfo::local_offset(StubGroup group, BlobId id) {\n+  assert(has_group(id, group), \"id %s is not a %s blob!\", name(id), name(group));\n+  BlobId base = blob_base(group);\n+  int s = span(id, base);\n+  assert(s >= 1, \"must be\");\n+  return s - 1;\n+}\n+\n+int StubInfo::local_offset(StubGroup group, StubId id) {\n+  assert(has_group(id, group), \"id %s is not a %s stub!\", name(id), name(group));\n+  StubId base = stub_base(group);\n+  int s = span(id, base);\n+  assert(s >= 1, \"must be\");\n+  return s - 1;\n+}\n+\n+int StubInfo::local_offset(StubGroup group, EntryId id) {\n+  assert(has_group(id, group), \"id %s is not a %s entry!\", name(id), name(group));\n+  EntryId base = entry_base(group);\n+  int s = span(id, base);\n+  assert(s >= 1, \"must be\");\n+  return s - 1;\n+}\n+\n+\/\/ public API\n+\n+\/\/ check that a stub belongs to an expected stub group\n+\n+bool StubInfo::is_shared(StubId id) {\n+  return has_group(id, StubGroup::SHARED);\n+}\n+\n+bool StubInfo::is_c1(StubId id) {\n+  return has_group(id, StubGroup::C1);\n+}\n+\n+bool StubInfo::is_c2(StubId id) {\n+  return has_group(id, StubGroup::C2);\n+}\n+\n+bool StubInfo::is_stubgen(StubId id) {\n+  return has_group(id, StubGroup::STUBGEN);\n+}\n+\n+\/\/ check that a stub belongs to an expected stub group\n+\n+bool StubInfo::is_shared(BlobId id) {\n+  return has_group(id, StubGroup::SHARED);\n+}\n+\n+bool StubInfo::is_c1(BlobId id) {\n+  return has_group(id, StubGroup::C1);\n+}\n+\n+bool StubInfo::is_c2(BlobId id) {\n+  return has_group(id, StubGroup::C2);\n+}\n+\n+bool StubInfo::is_stubgen(BlobId id) {\n+  return has_group(id, StubGroup::STUBGEN);\n+}\n+\n+\/\/ Convert a stub id to a unique, zero-based offset in the range of\n+\/\/ stub ids for a given stub group.\n+\n+int StubInfo::shared_offset(StubId id) {\n+  return local_offset(StubGroup::SHARED, id);\n+}\n+\n+int StubInfo::c1_offset(StubId id) {\n+  return local_offset(StubGroup::C1, id);\n+}\n+\n+int StubInfo::c2_offset(StubId id) {\n+  return local_offset(StubGroup::C2, id);\n+}\n+\n+int StubInfo::stubgen_offset(StubId id) {\n+  return local_offset(StubGroup::STUBGEN, id);\n+}\n+\n+\/\/ initialization function called to populate blob. stub and entry\n+\/\/ tables. this must be called before any stubs are generated\n+void initialize_stub_info() {\n+  ResourceMark rm;\n+  StubInfo::populate_stub_tables();\n+\n+  LogTarget(Debug, stubs) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    StubInfo::dump_tables(ls);\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/stubInfo.cpp","additions":1080,"deletions":0,"binary":false,"changes":1080,"status":"added"},{"patch":"@@ -0,0 +1,684 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_STUBINFO_HPP\n+#define SHARE_RUNTIME_STUBINFO_HPP\n+\n+#include \"logging\/logStream.hpp\"\n+#include \"runtime\/stubDeclarations.hpp\"\n+\n+\/\/ class StubInfo records details of the global stubgroup, blob, stub\n+\/\/ and entry hierarchy and provides APIs that\n+\/\/\n+\/\/ 1) allow relationships between blobs, stubs and their entries to be\n+\/\/ identified.\n+\/\/\n+\/\/ 2) Support conversion from a global blob\/stub\/entry id to a\n+\/\/ corresponding, unique, group-local blob\/stub\/entry offset from the\n+\/\/ first blob\/stub\/entry in the same stubgroup\n+\n+\/\/ We have four distinct stub groups, each of which includes multiple\n+\/\/ blobs, stubs and entries.\n+\n+enum class StubGroup : int {\n+  SHARED,\n+  C1,\n+  C2,\n+  STUBGEN,\n+  NUM_STUBGROUPS\n+};\n+\n+\/\/ Generated code elements are used to implement the following enums:\n+\/\/\n+\/\/ Global and Stub Group Local Blob\/Stub\/Entry Enumerations:\n+\/\/\n+\/\/ The following enums uniquely list every generated blob, stub and\n+\/\/ entry across all four stub groups.\n+\/\/\n+\/\/ enum StubId;   \/\/ unique id for every stub in the above groups\n+\/\/ enum BlobId;   \/\/ unique id for every blob in the above groups\n+\/\/ enum EntryId;  \/\/ unique id for every entry in the above groups\n+\/\/\n+\/\/\n+\/\/ Management APIs for these enums are defined in class StubInfo. The\n+\/\/ API methods rely on a small amount of code and data genertaed from\n+\/\/ the blob, stub and entry declarations.\n+\/\/\n+\/\/ Global Group\/Blob\/Stub\/Entry Id Hierarchy Traversal:\n+\/\/\n+\/\/ traverse up\n+\/\/\n+\/\/ StubGroup StubInfo::stubgroup(EntryId);\n+\/\/ StubGroup StubInfo::stubgroup(BlobId);\n+\/\/ StubGroup StubInfo::stubgroup(StubId);\n+\/\/\n+\/\/ StubId  StubInfo::stub(EntryId);\n+\/\/ BlobId  StubInfo::blob(EntryId);\n+\/\/ BlobId  StubInfo::blob(StubId);\n+\/\/\n+\/\/ traverse down\n+\/\/\n+\/\/ BlobId  StubInfo::blob_base(StubGroup)\n+\/\/ BlobId  StubInfo::blob_max(StubGroup)\n+\/\/ int           StubInfo::blob_count(StubGroup)\n+\/\/\n+\/\/ StubId  StubInfo::stub_base(StubGroup)\n+\/\/ StubId  StubInfo::stub_max(StubGroup)\n+\/\/ int     StubInfo::stub_count(StubGroup)\n+\/\/\n+\/\/ EntryId StubInfo::entry_base(StubGroup)\n+\/\/ EntryId StubInfo::entry_max(StubGroup)\n+\/\/ int     StubInfo::entry_count(StubGroup)\n+\/\/\n+\/\/ StubId  StubInfo::stub_base(BlobId);\n+\/\/ StubId  StubInfo::stub_max(BlobId);\n+\/\/ int     StubInfo::stub_count(BlobId);\n+\/\/\n+\/\/ EntryId StubInfo::entry_base(StubId);\n+\/\/ EntryId StubInfo::entry_max(StubId);\n+\/\/ int     StubInfo::entry_count(StubId);\n+\/\/\n+\/\/ EntryId StubInfo::entry_base(BlobId);\n+\/\/ EntryId StubInfo::entry_max(BlobId);\n+\/\/ int     StubInfo::entry_count(BlobId);\n+\/\/\n+\/\/\n+\/\/ Global <-> Local Id Management:\n+\/\/\n+\/\/ check that a stub belongs to an expected stub group\n+\/\/\n+\/\/ bool StubInfo::is_shared(StubId id);\n+\/\/ bool StubInfo::is_c1(StubId id);\n+\/\/ bool StubInfo::is_c2(StubId id);\n+\/\/ bool StubInfo::is_stubgen(StubId id);\n+\/\/\n+\/\/ Convert a stub id to a unique, zero-based offset in the range of\n+\/\/ stub ids for a given stub group.\n+\/\/\n+\/\/ int  StubInfo::shared_offset(StubId id);\n+\/\/ int  StubInfo::c1_offset(StubId id);\n+\/\/ int  StubInfo::c2_offset(StubId id);\n+\/\/ int  StubInfo::stubgen_offset(StubId id);\n+\/\/\n+\/\/ Convert a blob id to a unique, zero-based offset in the range of\n+\/\/ blob ids for a given stub group. we only need this for stubgen\n+\/\/ blobs as for all other stub groups the stub indices and blob\n+\/\/ indices are identical.\n+\/\/\n+\/\/ int  StubInfo::stubgen_offset(BlobId id);\n+\/\/\n+\/\/ Convert an entry id to a unique, zero-based offset in the range\n+\/\/ of entry ids for a given stub group. we only need this for shared\n+\/\/ and stubgen blobs as for all other stub groups the stub indices\n+\/\/ and entry indices are identical.\n+\/\/\n+\/\/ int  StubInfo::shared_offset(EntryId id);\n+\/\/ int  StubInfo::stubgen_offset(EntryId id);\n+\/\/\n+\/\/ n.b. invalid interconversions from a global id to the wrong type of\n+\/\/ group id are caught by asserts\n+\n+\n+\/\/ Generate global blob, stub and entry enums from blob, stubs and\n+\/\/ entry declarations\n+\n+\/\/ Global enumeration for all blobs\n+\/\/\n+\/\/ n.b. the stubgroup is included in tag because the same name may be\n+\/\/ reused across groups (e.g. c1 and c2 both use new_instance)\n+\/\/\n+\/\/    enum BlobId {\n+\/\/      shared_deopt_id,\n+\/\/      . . .\n+\/\/      c1_unwind_exception_id,\n+\/\/      . . .\n+\/\/      c2_uncommon_trap_id,\n+\/\/      . . .\n+\/\/      stubgen_initial_id,\n+\/\/      . . .\n+\/\/      NUM_BLOBIDS,\n+\/\/    };\n+\n+\n+#define SHARED_DECLARE_TAG(name, type) JOIN3(shared, name, id) ,\n+#define C1_DECLARE_TAG(name) JOIN3(c1, name, id) ,\n+#define C2_DECLARE_TAG1(name) JOIN3(c2, name, id) ,\n+#define C2_DECLARE_TAG2(name, _1) JOIN3(c2, name, id) ,\n+#define C2_DECLARE_TAG4(name, _1, _2, _3) JOIN3(c2, name, id) ,\n+#define STUBGEN_DECLARE_TAG(name) JOIN3(stubgen, name, id) ,\n+\n+enum class BlobId : int {\n+  NO_BLOBID = -1,\n+  \/\/ declare an enum tag for each shared runtime blob\n+  SHARED_STUBS_DO(SHARED_DECLARE_TAG)\n+  \/\/ declare an enum tag for each c1 runtime blob\n+  C1_STUBS_DO(C1_DECLARE_TAG)\n+  \/\/ declare an enum tag for each opto runtime blob or stub\n+  C2_STUBS_DO(C2_DECLARE_TAG2,\n+              C2_DECLARE_TAG4,\n+              C2_DECLARE_TAG1)\n+  \/\/ declare an enum tag for each stubgen blob\n+  STUBGEN_BLOBS_DO(STUBGEN_DECLARE_TAG)\n+  NUM_BLOBIDS\n+};\n+\n+#undef SHARED_DECLARE_TAG\n+#undef C1_DECLARE_TAG\n+#undef C2_DECLARE_TAG1\n+#undef C2_DECLARE_TAG2\n+#undef C2_DECLARE_TAG4\n+#undef STUBGEN_DECLARE_TAG\n+\n+\/\/ Global enumeration for all stubs\n+\/\/\n+\/\/ n.b. the stubgroup is included in tag because the same name may be\n+\/\/ reused across groups (e.g. c1 and c2 both use new_instance). For\n+\/\/ stubgen stubs the blob name is omitted from the tag because all\n+\/\/ stub names may not be reused scross different stubgen blobs.\n+\/\/\n+\/\/    enum StubId {\n+\/\/      shared_deopt_id,\n+\/\/      . . .\n+\/\/      c1_unwind_exception_id,\n+\/\/      . . .\n+\/\/      c2_uncommon_trap_id,\n+\/\/      . . .\n+\/\/      stubgen_call_stub_id,\n+\/\/      stubgen_forward_exception_id,\n+\/\/      . . .\n+\/\/      NUM_BLOBIDS,\n+\/\/    };\n+\/\/\n+\n+#define SHARED_DECLARE_TAG(name, type) JOIN3(shared, name, id) ,\n+#define C1_DECLARE_TAG(name) JOIN3(c1, name, id) ,\n+#define C2_DECLARE_TAG1(name) JOIN3(c2, name, id) ,\n+#define C2_DECLARE_TAG2(name, _1) JOIN3(c2, name, id) ,\n+#define C2_DECLARE_TAG4(name, _1, _2, _3) JOIN3(c2, name, id) ,\n+#define STUBGEN_DECLARE_TAG(blob, name) JOIN3(stubgen, name, id) ,\n+\n+enum class StubId : int {\n+  NO_STUBID = -1,\n+  \/\/ declare an enum tag for each shared runtime blob\n+  SHARED_STUBS_DO(SHARED_DECLARE_TAG)\n+  \/\/ declare an enum tag for each c1 runtime blob\n+  C1_STUBS_DO(C1_DECLARE_TAG)\n+  \/\/ declare an enum tag for each opto runtime blob or stub\n+  C2_STUBS_DO(C2_DECLARE_TAG2,\n+              C2_DECLARE_TAG4,\n+              C2_DECLARE_TAG1)\n+  \/\/ declare an enum tag for each stubgen runtime stub\n+  STUBGEN_STUBS_DO(STUBGEN_DECLARE_TAG)\n+  NUM_STUBIDS\n+};\n+\n+#undef SHARED_DECLARE_TAG\n+#undef C1_DECLARE_TAG\n+#undef C2_DECLARE_TAG1\n+#undef C2_DECLARE_TAG2\n+#undef C2_DECLARE_TAG4\n+#undef STUBGEN_DECLARE_TAG\n+\n+\n+\/\/\n+\/\/ Global enumeration for all entries\n+\/\/\n+\/\/ n.b. the stubgroup is included in tag because the same name may be\n+\/\/ reused across groups (e.g. c1 and c2 both use new_instance)\n+\/\/\n+\/\/    enum EntryId : int {\n+\/\/      NO_ENTRYID = -1,\n+\/\/      shared_deopt_id,\n+\/\/      shared_deopt_max =\n+\/\/        shared_deopt_id + DeoptimzationBlob::NUM_ENTRIES -1,\n+\/\/      . . .\n+\/\/      c1_unwind_exception_id,\n+\/\/      . . .\n+\/\/      c2_uncommon_trap_id,\n+\/\/      . . .\n+\/\/      stubgen_call_stub_id,\n+\/\/      stubgen_call_stub_return_address_id,\n+\/\/      stubgen_forward_exception_id,\n+\/\/      . . .\n+\/\/      stubgen_aarch64_large_array_equals_id,\n+\/\/      . . .\n+\/\/      stubgen_lookup_secondary_supers_table_stubs_id,\n+\/\/      stubgen_lookup_secondary_supers_table_stubs_max =\n+\/\/        stubgen_lookup_secondary_supers_table_stubs_id +\n+\/\/        Klass::SECONDARY_SUPERS_TABLE_SIZE,\n+\/\/      . . .\n+\/\/      NUM_ENTRYIDS,\n+\/\/    };\n+\/\/\n+\/\/ - global id tags include a stub group prefix because some of the\n+\/\/ stub names are used in more than one group (e.g. new_instance,\n+\/\/ forward_exception). arch specific stubgen stubs also include the\n+\/\/ arch name in the tag.\n+\/\/\n+\/\/ - for shared stub entries we only need to allocate a single enum\n+\/\/ tag for most blobs since they have only one entry. However, we need\n+\/\/ to bump up the index by an extra 3 (or 5 with JVMCI included) when\n+\/\/ we are generating the deoptimization blob because it has 4\n+\/\/ (respectively, 6) entries. So, in that case we allocate a single\n+\/\/ enum tag identifying the index of the first entry and a max tag\n+\/\/ identifying the index of the last entry\n+\/\/\n+\/\/ - for stubgen stubs which employ an array of entries we allocate a\n+\/\/ single enum tag identifying the index of the first entry and a max\n+\/\/ tag identifying the index of the last entry e.g. for\n+\/\/ lookup_secondary_supers_table we generate\n+\/\/\n+\/\/      . . .\n+\/\/      stubgen_lookup_secondary_supers_table_stubs_id,\n+\/\/      stubgen_lookup_secondary_supers_table_stubs_max = stubgen_lookup_secondary_supers_table_stubs_id + Klass::SECONDARY_SUPERS_TABLE_SIZE,\n+\/\/      . . .\n+\/\/\n+\n+\/\/ macro to declare tags for shared entries with a base id for the\n+\/\/ first (and usually only) entry and a max id that identifies the\n+\/\/ last (usually same as first) entry in the blob, ensuring the entry\n+\/\/ for the next stub has the correct index.\n+\n+#define SHARED_DECLARE_TAG(name, type)                                  \\\n+  JOIN3(shared, name, id),                                              \\\n+  JOIN3(shared, name, max) = JOIN3(shared, name, id) +                  \\\n+    type ::ENTRY_COUNT - 1,                                             \\\n+\n+\/\/ macros to declare a tag for a C1 generated blob or a C2 generated\n+\/\/ blob, stub or JVMTI stub all of which have a single unique entry\n+\n+#define C1_DECLARE_TAG(name)           \\\n+  JOIN3(c1, name, id),                 \\\n+\n+#define C2_DECLARE_BLOB_TAG(name, type)                               \\\n+  JOIN3(c2, name, id),                                                \\\n+\n+#define C2_DECLARE_STUB_TAG(name, fancy_jump, pass_tls, return_pc)    \\\n+  JOIN3(c2, name, id),                                                \\\n+\n+#define C2_DECLARE_JVMTI_STUB_TAG(name)                               \\\n+  JOIN3(c2, name, id),                                                \\\n+\n+\/\/ macros to declare a tag for a StubGen normal entry or initialized\n+\/\/ entry\n+\n+#define STUBGEN_DECLARE_TAG(blob_name, stub_name,                       \\\n+                            field_name, getter_name)                    \\\n+  JOIN3(stubgen, field_name, id),                                       \\\n+\n+#define STUBGEN_DECLARE_INIT_TAG(blob_name, stub_name,                  \\\n+                                 field_name, getter_name,               \\\n+                                 init_function)                         \\\n+  JOIN3(stubgen, field_name, id),                                       \\\n+\n+\/\/ macro to declare a tag for a StubGen entry array. this macro\n+\/\/ declares a base id for the first entry then a max id that\n+\/\/ identifies the last entry in the array, ensuring the entry for the\n+\/\/ next stub has the correct index.\n+\n+#define STUBGEN_DECLARE_ARRAY_TAG(blob_name, stub_name,                 \\\n+                                  field_name, getter_name,              \\\n+                                  count)                                \\\n+  JOIN3(stubgen, field_name, id),                                       \\\n+  JOIN3(stubgen, field_name, max) = JOIN3(stubgen, field_name, id) +    \\\n+    count - 1,                                                          \\\n+\n+\/\/ macros to declare a tag for StubGen arch entries\n+\n+#define STUBGEN_DECLARE_ARCH_TAG(arch_name, blob_name, stub_name,       \\\n+                                 field_name, getter_name)               \\\n+  JOIN4(stubgen, arch_name, field_name, id),                            \\\n+\n+#define STUBGEN_DECLARE_ARCH_INIT_TAG(arch_name, blob_name, stub_name,  \\\n+                                      field_name, getter_name,          \\\n+                                      init_function)                    \\\n+  JOIN4(stubgen, arch_name, field_name, id),                            \\\n+\n+\/\/ the above macros are enough to declare the enum\n+\n+enum class EntryId : int {\n+  NO_ENTRYID = -1,\n+  \/\/ declare an enum tag for each shared runtime blob\n+  SHARED_STUBS_DO(SHARED_DECLARE_TAG)\n+  \/\/ declare an enum tag for each c1 runtime blob\n+  C1_STUBS_DO(C1_DECLARE_TAG)\n+  \/\/ declare an enum tag for each opto runtime blob or stub\n+  C2_STUBS_DO(C2_DECLARE_BLOB_TAG,\n+              C2_DECLARE_STUB_TAG,\n+              C2_DECLARE_JVMTI_STUB_TAG)\n+  \/\/ declare an enum tag for each stubgen entry or, in the case of an\n+  \/\/ array of entries for the first and last entries.\n+  STUBGEN_ALL_ENTRIES_DO(STUBGEN_DECLARE_TAG,\n+                         STUBGEN_DECLARE_INIT_TAG,\n+                         STUBGEN_DECLARE_ARRAY_TAG,\n+                         STUBGEN_DECLARE_ARCH_TAG,\n+                         STUBGEN_DECLARE_ARCH_INIT_TAG)\n+  NUM_ENTRYIDS\n+};\n+\n+#undef SHARED_DECLARE_TAG\n+#undef C1_DECLARE_TAG\n+#undef C2_DECLARE_BLOB_TAG\n+#undef C2_DECLARE_STUB_TAG\n+#undef C2_DECLARE_JVMTI_STUB_TAG\n+#undef STUBGEN_DECLARE_TAG\n+#undef STUBGEN_DECLARE_INIT_TAG\n+#undef STUBGEN_DECLARE_ARRAY_TAG\n+#undef STUBGEN_DECLARE_ARCH_TAG\n+#undef STUBGEN_DECLARE_ARCH_INIT_TAG\n+\n+\/\/ we need static init expressions for blob, stub and entry counts in\n+\/\/ each stubgroup\n+\n+#define SHARED_STUB_COUNT_INITIALIZER           \\\n+  0 SHARED_STUBS_DO(COUNT2)\n+\n+#define SHARED_ENTRY_COUNT_INITIALIZER          \\\n+  0 SHARED_STUBS_DO(SHARED_COUNT2)\n+\n+#define C1_STUB_COUNT_INITIALIZER               \\\n+  0 C1_STUBS_DO(COUNT1)\n+\n+#define C2_STUB_COUNT_INITIALIZER               \\\n+  0 C2_STUBS_DO(COUNT2, COUNT4, COUNT1)\n+\n+#define STUBGEN_BLOB_COUNT_INITIALIZER          \\\n+  0 STUBGEN_BLOBS_DO(COUNT1)\n+\n+#define STUBGEN_STUB_COUNT_INITIALIZER          \\\n+  0 STUBGEN_STUBS_DO(COUNT2)\n+\n+#define STUBGEN_ENTRY_COUNT_INITIALIZER          \\\n+  0 STUBGEN_ALL_ENTRIES_DO(COUNT4, COUNT5,       \\\n+                           STUBGEN_COUNT5,       \\\n+                           COUNT5, COUNT6)\n+\n+\/\/ Declare management class StubInfo\n+\n+class StubInfo: AllStatic {\n+private:\n+  \/\/ element types for tables recording stubgroup, blob, stub and\n+  \/\/ entry properties and relationships\n+\n+  \/\/ map each stubgroup to its initial and final blobs\n+  struct GroupDetails {\n+    BlobId _base;       \/\/ first blob id belonging to stub group\n+    BlobId _max;        \/\/ last blob id belonging to stub group\n+    \/\/ some stubs have no entries so we have to explicitly track the\n+    \/\/ first and last entry associated with the group rather than\n+    \/\/ deriving it from the first and last blob\/stub pair\n+    EntryId _entry_base;  \/\/ first entry id belonging to stub\n+    EntryId _entry_max;   \/\/ last entry id belonging to stub\n+    const char* _name;          \/\/ name of stubgroup\n+  };\n+\n+  \/\/ a blob table element enables the stub group of a guven blob to be\n+  \/\/ identified and all stubs within the blob to be identified\n+  \/\/\n+  \/\/ invariant: the number of stubs in a blob must be 1 unless the\n+  \/\/ blob belongs to the StubGen stub group\n+\n+  struct BlobDetails {\n+    StubGroup _group;           \/\/ stub group to which blob belongs\n+    StubId _base;         \/\/ first stub id belonging to blob\n+    StubId _max;          \/\/ last stub id belonging to blob\n+    \/\/ some stubs have no entries so we have to explicitly track the\n+    \/\/ first and last entry associated with the blob rather than\n+    \/\/ deriving it from the first and last stub\n+    EntryId _entry_base;  \/\/ first entry id belonging to stub\n+    EntryId _entry_max;   \/\/ last entry id belonging to stub\n+    const char* _name;          \/\/ name of blob\n+  };\n+\n+  \/\/ a stub table element enables the blob of a given stub to be\n+  \/\/ identified and all entries within the stub to be identified\n+  \/\/\n+  \/\/ invariant: the number of entries in a blob must be 1 unless the\n+  \/\/ blob belongs to the StubGen group or the Shared stub group\n+\n+  struct StubDetails {\n+    BlobId _blob;         \/\/ blob to which stub belongs\n+    EntryId _base;        \/\/ first entry id belonging to stub\n+    EntryId _max;         \/\/ last entry id belonging to stub\n+    bool _is_entry_array;       \/\/ true iff stub has array of entries\n+    const char* _name;          \/\/ name of stub\n+  };\n+\n+  \/\/ a stub table element enables the blob of a given stub to be\n+  \/\/ identified and all entries within the stub to be identified\n+  \/\/\n+  \/\/ invariant: the number of entries in a blob must be 1 unless the\n+  \/\/ blob belongs to the StubGen group or the Shared stub group\n+\n+  struct EntryDetails {\n+    StubId _stub;          \/\/ stub to which the entry belongs\n+    EntryId _array_base;   \/\/ base entry id for entry array stubs\n+    const char* _name;           \/\/ name of stub\n+  };\n+\n+  \/\/ tables are sized and indexed using the global ids\n+  static const int GROUP_TABLE_SIZE = static_cast<int>(StubGroup::NUM_STUBGROUPS);\n+  static const int BLOB_TABLE_SIZE = static_cast<int>(BlobId::NUM_BLOBIDS);\n+  static const int STUB_TABLE_SIZE = static_cast<int>(StubId::NUM_STUBIDS);\n+  static const int ENTRY_TABLE_SIZE = static_cast<int>(EntryId::NUM_ENTRYIDS);\n+\n+  static struct GroupDetails _group_table[GROUP_TABLE_SIZE];\n+  static struct BlobDetails _blob_table[BLOB_TABLE_SIZE];\n+  static struct StubDetails _stub_table[STUB_TABLE_SIZE];\n+  static struct EntryDetails _entry_table[ENTRY_TABLE_SIZE];\n+\n+  \/\/ helpers to access table elements using enums as indices\n+  static struct GroupDetails& group_details(StubGroup g);\n+  static struct BlobDetails& blob_details(BlobId b);\n+  static struct StubDetails& stub_details(StubId s);\n+  static struct EntryDetails& entry_details(EntryId e);\n+\n+  \/\/ helpers for counting entries\/stubs in a given stub\/blob\n+\n+  static int span(EntryId second, EntryId first);\n+  static int span(StubId second, StubId first);\n+  static int span(BlobId second, BlobId first);\n+\n+  \/\/ helper for testing whether a blob, stub or entry lies in a\n+  \/\/ specific stubgroup\n+  static bool has_group(BlobId id, StubGroup group);\n+  static bool has_group(StubId id, StubGroup group);\n+  static bool has_group(EntryId id, StubGroup group);\n+\n+  \/\/ helpers for computing blob, stub or entry offsets within\n+  \/\/ a specific stub group\n+\n+  static int local_offset(StubGroup group, BlobId id);\n+  static int local_offset(StubGroup group, StubId id);\n+  static int local_offset(StubGroup group, EntryId id);\n+\n+  \/\/ implementation of methods used to populate the stubgroup, blob,\n+  \/\/ stub and entry tables\n+  static void process_shared_blob(StubGroup& group_cursor,\n+                                  BlobId&  blob_cursor,\n+                                  StubId& stub_cursor,\n+                                  EntryId& entry_cursor,\n+                                  const char* name,\n+                                  BlobId declaredBlob,\n+                                  StubId declaredStub,\n+                                  EntryId declaredEntry,\n+                                  EntryId declaredMax);\n+  static void process_c1_blob(StubGroup& group_cursor,\n+                              BlobId&  blob_cursor,\n+                              StubId& stub_cursor,\n+                              EntryId& entry_cursor,\n+                              const char* name,\n+                              BlobId declaredBlob,\n+                              StubId declaredStub,\n+                              EntryId declaredEntry);\n+  static void process_c2_blob(StubGroup& group_cursor,\n+                              BlobId&  blob_cursor,\n+                              StubId& stub_cursor,\n+                              EntryId& entry_cursor,\n+                              const char* name,\n+                              BlobId declaredBlob,\n+                              StubId declaredStub,\n+                              EntryId declaredEntry);\n+  static void process_stubgen_blob(StubGroup& group_cursor,\n+                                   BlobId&  blob_cursor,\n+                                   StubId& stub_cursor,\n+                                   EntryId& entry_cursor,\n+                                   const char* name,\n+                                   BlobId declaredBlob);\n+  static void process_stubgen_stub(StubGroup& group_cursor,\n+                                   BlobId&  blob_cursor,\n+                                   StubId& stub_cursor,\n+                                   EntryId& entry_cursor,\n+                                   const char* name,\n+                                   BlobId declaredBlob,\n+                                   StubId declaredStub);\n+  static void process_stubgen_entry(StubGroup& group_cursor,\n+                                    BlobId&  blob_cursor,\n+                                    StubId& stub_cursor,\n+                                    EntryId& entry_cursor,\n+                                    const char* name,\n+                                    BlobId declaredBlob,\n+                                    StubId declaredStub,\n+                                    EntryId declaredEntry,\n+                                    int arrayCount);\n+\n+  static void dump_group_table(LogStream& ls);\n+  static void dump_blob_table(LogStream& ls);\n+  static void dump_stub_table(LogStream& ls);\n+  static void dump_entry_table(LogStream& ls);\n+\n+  static void verify_stub_tables();\n+public:\n+\n+  \/\/ Define statically sized counts for blobs, stubs and entries in\n+  \/\/ each stub group. n.b. we omit cases where the blob or entry count\n+  \/\/ equals the stub count.\n+  static const int SHARED_STUB_COUNT = SHARED_STUB_COUNT_INITIALIZER;\n+  static const int SHARED_ENTRY_COUNT = SHARED_ENTRY_COUNT_INITIALIZER;\n+\n+  static const int C1_STUB_COUNT = C1_STUB_COUNT_INITIALIZER;\n+\n+  static const int C2_STUB_COUNT = C2_STUB_COUNT_INITIALIZER;\n+\n+  static const int STUBGEN_STUB_COUNT = STUBGEN_STUB_COUNT_INITIALIZER;\n+  static const int STUBGEN_BLOB_COUNT = STUBGEN_BLOB_COUNT_INITIALIZER;\n+  static const int STUBGEN_ENTRY_COUNT = STUBGEN_ENTRY_COUNT_INITIALIZER;\n+\n+  \/\/ init method called from a static initializer\n+  static void populate_stub_tables();\n+  \/\/ for logging\n+  static void dump_tables(LogStream& ls);\n+\n+  \/\/ helpers to step through blob, stub or entry enum sequences.\n+  \/\/ input id may be NO_BLOB\/STUB\/ENTRYID. returned id may be\n+  \/\/ NUM_BLOB\/STUB\/ENTRYIDs\n+  static BlobId next(BlobId id);\n+  static StubId next(StubId id);\n+  static EntryId next(EntryId id);\n+\n+  \/\/ helpers to step through blob\/stub\/entry enum sequence within\n+  \/\/ (respectively) the enclosing group\/blob\/stub. returned id will be\n+  \/\/ a valid blob\/stub\/entry id or NO_BLOB\/STUB\/ENTRYID if the\n+  \/\/ group\/blob\/stub contains no more stubs\/entries.\n+  static BlobId next_in_group(StubGroup stub_group, BlobId blob_id);\n+  static StubId next_in_blob(BlobId blob_id, StubId stub_id);\n+  static EntryId next_in_stub(StubId stub_id, EntryId entry_id);\n+\n+#ifdef ASSERT\n+  \/\/ helpers to check sequencing of blobs stubs and entries\n+  static bool is_next(BlobId second, BlobId first);\n+  static bool is_next(StubId second, StubId first);\n+  static bool is_next(EntryId second, EntryId first);\n+#endif \/\/ ASSERT\n+\n+  \/\/ name retrieval\n+  static const char* name(StubGroup stub_group);\n+  static const char* name(BlobId id);\n+  static const char* name(StubId id);\n+  static const char* name(EntryId id);\n+\n+  \/\/ Global Group\/Blob\/Stub\/Entry Id Hierarchy Traversal:\n+\n+  \/\/ traverse up\n+\n+  static StubGroup stubgroup(EntryId id);\n+  static StubGroup stubgroup(BlobId id);\n+  static StubGroup stubgroup(StubId id);\n+\n+  static StubId  stub(EntryId id);\n+  static BlobId  blob(EntryId id);\n+  static BlobId  blob(StubId id);\n+\n+  \/\/ traverse down\n+\n+  static BlobId  blob_base(StubGroup stub_group);\n+  static BlobId  blob_max(StubGroup stub_group);\n+  static int     blob_count(StubGroup stub_group);\n+\n+  static StubId  stub_base(StubGroup stub_group);\n+  static StubId  stub_max(StubGroup stub_group);\n+  static int     stub_count(StubGroup stub_group);\n+\n+  static EntryId entry_base(StubGroup stub_group);\n+  static EntryId entry_max(StubGroup stub_group);\n+  static int     entry_count(StubGroup stub_group);\n+\n+  static StubId  stub_base(BlobId id);\n+  static StubId  stub_max(BlobId id);\n+  static int     stub_count(BlobId id);\n+\n+  static EntryId entry_base(BlobId id);\n+  static EntryId entry_max(BlobId id);\n+  static int     entry_count(BlobId id);\n+\n+  static EntryId entry_base(StubId id);\n+  static EntryId entry_max(StubId id);\n+  static int     entry_count(StubId id);\n+\n+  \/\/ Global <-> Local Id Management:\n+\n+  \/\/ check that a blob\/stub belongs to an expected stub group\n+\n+  static bool is_shared(StubId id);\n+  static bool is_c1(StubId id);\n+  static bool is_c2(StubId id);\n+  static bool is_stubgen(StubId id);\n+\n+  static bool is_shared(BlobId id);\n+  static bool is_c1(BlobId id);\n+  static bool is_c2(BlobId id);\n+  static bool is_stubgen(BlobId id);\n+\n+  \/\/ Convert a stub id to a unique, zero-based offset in the range of\n+  \/\/ stub ids for a given stub group.\n+\n+  static int  shared_offset(StubId id);\n+  static int  c1_offset(StubId id);\n+  static int  c2_offset(StubId id);\n+  static int  stubgen_offset(StubId id);\n+};\n+\n+\n+#endif \/\/ SHARE_RUNTIME_STUBINFO_HPP\n","filename":"src\/hotspot\/share\/runtime\/stubInfo.hpp","additions":684,"deletions":0,"binary":false,"changes":684,"status":"added"},{"patch":"@@ -51,23 +51,0 @@\n-\/\/ define arrays to hold stub and blob names\n-\n-\/\/ use a template to generate the initializer for the blob names array\n-\n-#define DEFINE_BLOB_NAME(blob_name)             \\\n-  # blob_name,\n-\n-const char* StubRoutines::_blob_names[StubGenBlobId::NUM_BLOBIDS] = {\n-  STUBGEN_BLOBS_DO(DEFINE_BLOB_NAME)\n-};\n-\n-#undef DEFINE_BLOB_NAME\n-\n-#define DEFINE_STUB_NAME(blob_name, stub_name)          \\\n-  # stub_name ,                                         \\\n-\n-\/\/ use a template to generate the initializer for the stub names array\n-const char* StubRoutines::_stub_names[StubGenStubId::NUM_STUBIDS] = {\n-  STUBGEN_STUBS_DO(DEFINE_STUB_NAME)\n-};\n-\n-#undef DEFINE_STUB_NAME\n-\n@@ -76,1 +53,1 @@\n-#define DEFINE_BLOB_FIELD(blob_name) \\\n+#define DEFINE_STUBGEN_BLOB_FIELD(blob_name)                            \\\n@@ -79,1 +56,1 @@\n-STUBGEN_BLOBS_DO(DEFINE_BLOB_FIELD)\n+STUBGEN_BLOBS_DO(DEFINE_STUBGEN_BLOB_FIELD)\n@@ -81,1 +58,1 @@\n-#undef DEFINE_BLOB_FIELD\n+#undef DEFINE_STUBGEN_BLOB_FIELD\n@@ -83,1 +60,1 @@\n-\/\/ Define fields used to store stub entries\n+\/\/ Define fields used to store stubgen stub entries\n@@ -85,1 +62,1 @@\n-#define DEFINE_ENTRY_FIELD(blob_name, stub_name, field_name, getter_name) \\\n+#define DEFINE_STUBGEN_ENTRY_FIELD(blob_name, stub_name, field_name, getter_name) \\\n@@ -88,1 +65,1 @@\n-#define DEFINE_ENTRY_FIELD_INIT(blob_name, stub_name, field_name, getter_name, init_function) \\\n+#define DEFINE_STUBGEN_ENTRY_FIELD_INIT(blob_name, stub_name, field_name, getter_name, init_function) \\\n@@ -91,1 +68,1 @@\n-#define DEFINE_ENTRY_FIELD_ARRAY(blob_name, stub_name, field_name, getter_name, count) \\\n+#define DEFINE_STUBGEN_ENTRY_FIELD_ARRAY(blob_name, stub_name, field_name, getter_name, count) \\\n@@ -94,1 +71,1 @@\n-STUBGEN_ENTRIES_DO(DEFINE_ENTRY_FIELD, DEFINE_ENTRY_FIELD_INIT, DEFINE_ENTRY_FIELD_ARRAY)\n+STUBGEN_ENTRIES_DO(DEFINE_STUBGEN_ENTRY_FIELD, DEFINE_STUBGEN_ENTRY_FIELD_INIT, DEFINE_STUBGEN_ENTRY_FIELD_ARRAY)\n@@ -96,3 +73,3 @@\n-#undef DEFINE_ENTRY_FIELD_ARRAY\n-#undef DEFINE_ENTRY_FIELD_INIT\n-#undef DEFINE_ENTRY_FIELD\n+#undef DEFINE_STUBGEN_ENTRY_FIELD_ARRAY\n+#undef DEFINE_STUBGEN_ENTRY_FIELD_INIT\n+#undef DEFINE_STUBGEN_ENTRY_FIELD\n@@ -105,3 +82,3 @@\n-const char* StubRoutines::get_blob_name(StubGenBlobId id) {\n-  assert(0 <= id && id < StubGenBlobId::NUM_BLOBIDS, \"invalid blob id\");\n-  return _blob_names[id];\n+const char* StubRoutines::get_blob_name(BlobId id) {\n+  assert(StubInfo::is_stubgen(id), \"not a stubgen blob %s\", StubInfo::name(id));\n+  return StubInfo::name(id);\n@@ -110,3 +87,3 @@\n-const char* StubRoutines::get_stub_name(StubGenStubId id) {\n-  assert(0 <= id && id < StubGenStubId::NUM_STUBIDS, \"invalid stub id\");\n-  return _stub_names[id];\n+const char* StubRoutines::get_stub_name(StubId id) {\n+  assert(StubInfo::is_stubgen(id), \"not a stubgen stub %s\", StubInfo::name(id));\n+  return StubInfo::name(id);\n@@ -116,0 +93,2 @@\n+\/\/ translate a stub id to an associated blob id while checking that it\n+\/\/ is a stubgen stub\n@@ -117,62 +96,3 @@\n-\/\/ array holding start and end indices for stub ids associated with a\n-\/\/ given blob. Given a blob with id (StubGenBlobId) blob_id for any\n-\/\/ stub with id (StubGenStubId) stub_id declared within the blob:\n-\/\/ _blob_offsets[blob_id] <= stub_id < _blob_offsets[blob_id+1]\n-\n-static int _blob_limits[StubGenBlobId::NUM_BLOBIDS + 1];\n-\n-\/\/ macro used to compute blob limits\n-#define BLOB_COUNT(blob_name)                                           \\\n-  counter += StubGenStubId_ ## blob_name :: NUM_STUBIDS_ ## blob_name;  \\\n-  _blob_limits[++index] = counter;                                      \\\n-\n-\/\/ macro that checks stubs are associated with the correct blobs\n-#define STUB_VERIFY(blob_name, stub_name)                               \\\n-  localStubId = (int) (StubGenStubId_ ## blob_name :: blob_name ## _ ## stub_name ## _id); \\\n-  globalStubId = (int) (StubGenStubId:: stub_name ## _id);              \\\n-  blobId = (int) (StubGenBlobId:: blob_name ## _id);                    \\\n-  assert((globalStubId >= _blob_limits[blobId] &&                       \\\n-          globalStubId < _blob_limits[blobId+1]),                       \\\n-         \"stub \" # stub_name \" uses incorrect blob name \" # blob_name); \\\n-  assert(globalStubId == _blob_limits[blobId] + localStubId,            \\\n-         \"stub \" # stub_name \" id found at wrong offset!\");             \\\n-\n-bool verifyStubIds() {\n-  \/\/ first compute the blob limits\n-  int counter = 0;\n-  int index = 0;\n-  \/\/ populate offsets table with cumulative total of local enum counts\n-  STUBGEN_BLOBS_DO(BLOB_COUNT);\n-\n-  \/\/ ensure 1) global stub ids lie in the range of the associated blob\n-  \/\/ and 2) each blob's base + local stub id == global stub id\n-  int globalStubId, blobId, localStubId;\n-  STUBGEN_STUBS_DO(STUB_VERIFY);\n-  return true;\n-}\n-\n-#undef BLOB_COUNT\n-#undef STUB_VERIFY\n-\n-\/\/ ensure we verify the blob ids when this compile unit is first entered\n-bool _verified_stub_ids = verifyStubIds();\n-\n-\n-\/\/ macro used by stub to blob translation\n-\n-#define BLOB_CHECK_OFFSET(blob_name)                                \\\n-  if (id < _blob_limits[((int)blobId) + 1]) { return blobId; }      \\\n-  blobId = StubGenBlobId:: blob_name ## _id;                        \\\n-\n-\/\/ translate a global stub id to an associated blob id based on the\n-\/\/ computed blob limits\n-\n-StubGenBlobId StubRoutines::stub_to_blob(StubGenStubId stubId) {\n-  int id = (int)stubId;\n-  assert(id > ((int)StubGenStubId::NO_STUBID) && id < ((int)StubGenStubId::NUM_STUBIDS), \"stub id out of range!\");\n-  \/\/ start with no blob to catch stub id == -1\n-  StubGenBlobId blobId = StubGenBlobId::NO_BLOBID;\n-  STUBGEN_BLOBS_DO(BLOB_CHECK_OFFSET);\n-  \/\/ if we reach here we should have the last blob id\n-  assert(blobId == StubGenBlobId::NUM_BLOBIDS - 1, \"unexpected blob id\");\n-  return blobId;\n+BlobId StubRoutines::stub_to_blob(StubId id) {\n+  assert(StubInfo::is_stubgen(id), \"not a stubgen stub %s\", StubInfo::name(id));\n+  return StubInfo::blob(id);\n@@ -184,5 +104,1 @@\n-\/\/\n-\/\/ Note: to break cycle with universe initialization, stubs are generated in two phases.\n-\/\/ The first one generates stubs needed during universe init (e.g., _handle_must_compile_first_entry).\n-\/\/ The second phase includes all other stubs (which may depend on universe being initialized.)\n-extern void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id); \/\/ only interface to generators\n+extern void StubGenerator_generate(CodeBuffer* code, BlobId blob_id); \/\/ only interface to generators\n@@ -197,0 +113,1 @@\n+  assert(UnsafeMemoryAccess::_table != nullptr, \"\");\n@@ -207,0 +124,1 @@\n+  assert(UnsafeMemoryAccess::_table != nullptr, \"\");\n@@ -217,1 +135,1 @@\n-static BufferBlob* initialize_stubs(StubGenBlobId blob_id,\n+static BufferBlob* initialize_stubs(BlobId blob_id,\n@@ -222,0 +140,1 @@\n+  assert(StubInfo::is_stubgen(blob_id), \"not a stubgen blob %s\", StubInfo::name(blob_id));\n@@ -223,0 +142,8 @@\n+  if (code_size == 0) {\n+    LogTarget(Info, stubs) lt;\n+    if (lt.is_enabled()) {\n+      LogStream ls(lt);\n+      ls.print_cr(\"%s\\t not generated\", buffer_name);\n+      return nullptr;\n+    }\n+  }\n@@ -249,1 +176,1 @@\n-      StubGenBlobId blob_id = StubGenBlobId:: STUB_ID_NAME(blob_name);  \\\n+      BlobId blob_id = BlobId:: JOIN3(stubgen, blob_name, id);          \\\n@@ -253,1 +180,1 @@\n-      const char* name = \"StubRoutines (\" # blob_name \"stubs)\";         \\\n+      const char* name = \"StubRoutines (\" # blob_name \" stubs)\";        \\\n@@ -268,3 +195,3 @@\n-void blob_name ## _stubs_init()  {                      \\\n-  StubRoutines::initialize_ ## blob_name ## _stubs();   \\\n-}\n+  void blob_name ## _stubs_init()  {                    \\\n+    StubRoutines::initialize_ ## blob_name ## _stubs(); \\\n+  }\n@@ -280,1 +207,1 @@\n- * point and have adeterminate ordered init.\n+ * point and have a determinate ordered init.\n@@ -298,1 +225,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":41,"deletions":115,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/stubDeclarations.hpp\"\n+#include \"runtime\/stubInfo.hpp\"\n@@ -154,45 +154,0 @@\n-\/\/ declare stubgen blob id enum\n-\n-#define BLOB_ENUM_DECLARE(blob_name) \\\n-  STUB_ID_NAME(blob_name),\n-\n-enum StubGenBlobId : int {\n-  NO_BLOBID = -1,\n-  STUBGEN_BLOBS_DO(BLOB_ENUM_DECLARE)\n-  NUM_BLOBIDS\n-};\n-\n-#undef BLOB_ENUM_DECLARE\n-\n-\/\/ declare blob local stub id enums\n-\n-#define BLOB_LOCAL_ENUM_START(blob_name)        \\\n-  enum StubGenStubId_ ## blob_name {            \\\n-    NO_STUBID_ ## blob_name = -1,\n-\n-#define BLOB_LOCAL_ENUM_END(blob_name)   \\\n-    NUM_STUBIDS_ ## blob_name            \\\n-  };\n-\n-#define BLOB_LOCAL_STUB_ENUM_DECLARE(blob_name, stub_name) \\\n-  blob_name ## _ ## stub_name ## _id,\n-\n-STUBGEN_BLOBS_STUBS_DO(BLOB_LOCAL_ENUM_START, BLOB_LOCAL_ENUM_END, BLOB_LOCAL_STUB_ENUM_DECLARE)\n-\n-#undef BLOB_LOCAL_ENUM_START\n-#undef BLOB_LOCAL_ENUM_END\n-#undef BLOB_LOCAL_STUB_ENUM_DECLARE\n-\n-\/\/ declare global stub id enum\n-\n-#define STUB_ENUM_DECLARE(blob_name, stub_name) \\\n-  STUB_ID_NAME(stub_name) ,\n-\n-enum StubGenStubId : int {\n-  NO_STUBID = -1,\n-  STUBGEN_STUBS_DO(STUB_ENUM_DECLARE)\n-  NUM_STUBIDS\n-};\n-\n-#undef STUB_ENUM_DECLARE\n-\n@@ -211,11 +166,2 @@\n-\/\/ declare blob and stub name storage and associated lookup methods\n-\n-private:\n-  static bool _inited_names;\n-  static const char* _blob_names[StubGenBlobId::NUM_BLOBIDS];\n-  static const char* _stub_names[StubGenStubId::NUM_STUBIDS];\n-\n-public:\n-  static bool init_names();\n-  static const char* get_blob_name(StubGenBlobId id);\n-  static const char* get_stub_name(StubGenStubId id);\n+  static const char* get_blob_name(BlobId id);\n+  static const char* get_stub_name(StubId id);\n@@ -332,2 +278,1 @@\n-  \/\/ provide a translation from stub id to its associated blob id\n-  static StubGenBlobId stub_to_blob(StubGenStubId stubId);\n+  static BlobId stub_to_blob(StubId id);\n@@ -342,1 +287,1 @@\n-  static CallStub call_stub()                              { return CAST_TO_FN_PTR(CallStub, _call_stub_entry); }\n+  static CallStub call_stub()                              { assert(_call_stub_entry != nullptr, \"\"); return CAST_TO_FN_PTR(CallStub, _call_stub_entry); }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":5,"deletions":60,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1698,1 +1698,1 @@\n-class HandshakeForDeflation : public HandshakeClosure {\n+class DeflationHandshakeClosure : public HandshakeClosure {\n@@ -1700,1 +1700,1 @@\n-  HandshakeForDeflation() : HandshakeClosure(\"HandshakeForDeflation\") {}\n+  DeflationHandshakeClosure() : HandshakeClosure(\"DeflationHandshakeClosure\") {}\n@@ -1703,1 +1703,1 @@\n-    log_trace(monitorinflation)(\"HandshakeForDeflation::do_thread: thread=\"\n+    log_trace(monitorinflation)(\"DeflationHandshakeClosure::do_thread: thread=\"\n@@ -1868,2 +1868,2 @@\n-    HandshakeForDeflation hfd_hc;\n-    Handshake::execute(&hfd_hc);\n+    DeflationHandshakeClosure dhc;\n+    Handshake::execute(&dhc);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"jfr\/recorder\/service\/jfrRecorderThread.hpp\"\n@@ -1028,0 +1029,1 @@\n+        declare_type(TrainingReplayThread, JavaThread)                    \\\n@@ -1030,0 +1032,1 @@\n+        declare_type(JfrRecorderThread, JavaThread)                       \\\n@@ -1486,3 +1489,3 @@\n-  \/***********************************************\/                       \\\n-  \/* ConstantPool* layout enum for InvokeDynamic *\/                       \\\n-  \/***********************************************\/                       \\\n+  \/******************************************************\/                \\\n+  \/* BSMAttributeEntry* - layout enum for InvokeDynamic *\/                \\\n+  \/******************************************************\/                \\\n@@ -1490,3 +1493,3 @@\n-  declare_constant(ConstantPool::_indy_bsm_offset)                        \\\n-  declare_constant(ConstantPool::_indy_argc_offset)                       \\\n-  declare_constant(ConstantPool::_indy_argv_offset)                       \\\n+  declare_constant(BSMAttributeEntry::_bsmi_offset)                       \\\n+  declare_constant(BSMAttributeEntry::_argc_offset)                       \\\n+  declare_constant(BSMAttributeEntry::_argv_offset)                       \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/vmThreadCpuTimeScope.inline.hpp\"\n@@ -278,1 +279,1 @@\n-                     (char *) op->name(), strlen(op->name()),\n+                     (char*) op->name(), strlen(op->name()),\n@@ -282,0 +283,1 @@\n+    VMThreadCPUTimeScope CPUTimeScope(this, op->is_gc_operation());\n@@ -288,1 +290,1 @@\n-                     (char *) op->name(), strlen(op->name()),\n+                     (char*) op->name(), strlen(op->name()),\n@@ -291,7 +293,0 @@\n-\n-  if (UsePerfData && os::is_thread_cpu_time_supported()) {\n-    assert(Thread::current() == this, \"Must be called from VM thread\");\n-    \/\/ Update vm_thread_cpu_time after each VM operation.\n-    ThreadTotalCPUTimeClosure tttc(CPUTimeGroups::CPUTimeType::vm);\n-    tttc.do_thread(this);\n-  }\n@@ -300,1 +295,1 @@\n-class HandshakeALotClosure : public HandshakeClosure {\n+class ALotOfHandshakeClosure : public HandshakeClosure {\n@@ -302,1 +297,1 @@\n-  HandshakeALotClosure() : HandshakeClosure(\"HandshakeALot\") {}\n+  ALotOfHandshakeClosure() : HandshakeClosure(\"ALotOfHandshakeClosure\") {}\n@@ -456,2 +451,2 @@\n-        HandshakeALotClosure hal_cl;\n-        Handshake::execute(&hal_cl);\n+        ALotOfHandshakeClosure aohc;\n+        Handshake::execute(&aohc);\n","filename":"src\/hotspot\/share\/runtime\/vmThread.cpp","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n@@ -31,0 +34,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -201,0 +205,14 @@\n+            @Override\n+            public String readAllAsString() throws IOException {\n+                ensureOpen();\n+                int len = cs.length();\n+                String result = cs.subSequence(next, len).toString();\n+                next += result.length();\n+                return result;\n+            }\n+\n+            @Override\n+            public List<String> readAllLines() throws IOException {\n+                return readAllAsString().lines().toList();\n+            }\n+\n@@ -385,0 +403,151 @@\n+    \/**\n+     * Reads all remaining characters as lines of text. This method blocks until\n+     * all remaining characters have been read and end of stream is detected,\n+     * or an exception is thrown. This method does not close the reader.\n+     *\n+     * <p> When this reader reaches the end of the stream, further\n+     * invocations of this method will return an empty list.\n+     *\n+     * <p> A <i>line<\/i> is either a sequence of zero or more characters\n+     * followed by a line terminator, or it is a sequence of one or\n+     * more characters followed by the end of the stream.\n+     * A line does not include the line terminator.\n+     *\n+     * <p> A <i>line terminator<\/i> is one of the following:\n+     * a line feed character {@code \"\\n\"} (U+000A),\n+     * a carriage return character {@code \"\\r\"} (U+000D),\n+     * or a carriage return followed immediately by a line feed\n+     * {@code \"\\r\\n\"} (U+000D U+000A).\n+     *\n+     * <p> The behavior for the case where the reader is\n+     * <i>asynchronously closed<\/i>, or the thread interrupted during the\n+     * read, is highly reader specific, and therefore not specified.\n+     *\n+     * <p> If an I\/O error occurs reading from the stream then it\n+     * may do so after some, but not all, characters have been read.\n+     * Consequently the stream may not be at end of stream and may\n+     * be in an inconsistent state. It is strongly recommended that the reader\n+     * be promptly closed if an I\/O error occurs.\n+     *\n+     * @apiNote\n+     * This method is intended for simple cases where it is appropriate and\n+     * convenient to read the entire input into a list of lines. It is not\n+     * suitable for reading input from an unknown origin, as this may result\n+     * in the allocation of an arbitrary amount of memory.\n+     *\n+     * @return     the remaining characters as lines of text stored in an\n+     *             unmodifiable {@code List} of {@code String}s in the order\n+     *             they are read\n+     *\n+     * @throws     IOException  If an I\/O error occurs\n+     * @throws     OutOfMemoryError  If the number of remaining characters\n+     *             exceeds the implementation limit for {@code String}.\n+     *\n+     * @see String#lines\n+     * @see #readAllAsString\n+     * @see java.nio.file.Files#readAllLines\n+     *\n+     * @since 25\n+     *\/\n+    public List<String> readAllLines() throws IOException {\n+        List<String> lines = new ArrayList<>();\n+        char[] cb = new char[1024];\n+\n+        int start = 0;\n+        int pos = 0;\n+        int limit = 0;\n+        boolean skipLF = false;\n+        int n;\n+        while ((n = read(cb, pos, cb.length - pos)) != -1) {\n+            limit = pos + n;\n+            while (pos < limit) {\n+                if (skipLF) {\n+                    if (cb[pos] == '\\n') {\n+                        pos++;\n+                        start++;\n+                    }\n+                    skipLF = false;\n+                }\n+                while (pos < limit) {\n+                    char c = cb[pos++];\n+                    if (c == '\\n' || c == '\\r') {\n+                        lines.add(new String(cb, start, pos - 1 - start));\n+                        skipLF = (c == '\\r');\n+                        start = pos;\n+                        break;\n+                    }\n+                }\n+                if (pos == limit) {\n+                    int len = limit - start;\n+                    if (len >= cb.length\/2) {\n+                        \/\/ allocate larger buffer and copy chars to beginning\n+                        int newLength = ArraysSupport.newLength(cb.length,\n+                                            TRANSFER_BUFFER_SIZE, cb.length);\n+                        char[] tmp = new char[newLength];\n+                        System.arraycopy(cb, start, tmp, 0, len);\n+                        cb = tmp;\n+                    } else if (start != 0 && len != 0) {\n+                        \/\/ move fragment to beginning of buffer\n+                        System.arraycopy(cb, start, cb, 0, len);\n+                    }\n+                    pos = limit = len;\n+                    start = 0;\n+                    break;\n+                }\n+            }\n+        }\n+        \/\/ add a string if EOS terminates the last line\n+        if (limit > start)\n+            lines.add(new String(cb, start, limit - start));\n+\n+        return Collections.unmodifiableList(lines);\n+    }\n+\n+    \/**\n+     * Reads all remaining characters into a string. This method blocks until\n+     * all remaining characters including all line separators have been read\n+     * and end of stream is detected, or an exception is thrown. The resulting\n+     * string will contain line separators as they appear in the stream. This\n+     * method does not close the reader.\n+     *\n+     * <p> When this reader reaches the end of the stream, further\n+     * invocations of this method will return an empty string.\n+     *\n+     * <p> The behavior for the case where the reader\n+     * is <i>asynchronously closed<\/i>, or the thread interrupted during the\n+     * read, is highly reader specific, and therefore not specified.\n+     *\n+     * <p> If an I\/O error occurs reading from the stream then it\n+     * may do so after some, but not all, characters have been read.\n+     * Consequently the stream may not be at end of stream and may\n+     * be in an inconsistent state. It is strongly recommended that the reader\n+     * be promptly closed if an I\/O error occurs.\n+     *\n+     * @apiNote\n+     * This method is intended for simple cases where it is appropriate and\n+     * convenient to read the entire input into a {@code String}. It is not\n+     * suitable for reading input from an unknown origin, as this may result\n+     * in the allocation of an arbitrary amount of memory.\n+     *\n+     * @return     a {@code String} containing all remaining characters\n+     *\n+     * @throws     IOException       If an I\/O error occurs\n+     * @throws     OutOfMemoryError  If the number of remaining characters\n+     *                               exceeds the implementation limit for\n+     *                               {@code String}.\n+     *\n+     * @see #readAllLines\n+     * @see java.nio.file.Files#readString\n+     *\n+     * @since 25\n+     *\/\n+    public String readAllAsString() throws IOException {\n+        StringBuilder result = new StringBuilder();\n+        char[] cbuf = new char[TRANSFER_BUFFER_SIZE];\n+        int nread;\n+        while ((nread = read(cbuf, 0, cbuf.length)) != -1) {\n+            result.append(cbuf, 0, nread);\n+        }\n+        return result.toString();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/Reader.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -120,5 +120,3 @@\n- * U+0000 to U+10FFFF, known as <em>Unicode scalar value<\/em>.\n- * (Refer to the <a\n- * href=\"http:\/\/www.unicode.org\/reports\/tr27\/#notation\"><i>\n- * definition<\/i><\/a> of the U+<i>n<\/i> notation in the Unicode\n- * Standard.)\n+ * U+0000 to U+10FFFF, known as\n+ * <em><a href=\"https:\/\/www.unicode.org\/glossary\/#unicode_scalar_value\">\n+ * Unicode scalar value<\/a><\/em>.\n@@ -176,1 +174,1 @@\n- * @spec https:\/\/www.unicode.org\/reports\/tr27 Unicode 3.1.0\n+ * @spec https:\/\/www.unicode.org\/reports\/tr44 Unicode Character Database\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Character.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * ProcessBuilder.start and Runtime.exec.\n+ * {@code ProcessBuilder.start} and {@code Runtime.exec}.\n@@ -81,4 +81,0 @@\n- * <p>The process is not killed when there are no more references to\n- * the {@code Process} object, but rather the process\n- * continues executing asynchronously.\n- *\n@@ -101,0 +97,43 @@\n+ * <h2>Resource Usage<\/h2>\n+ * {@linkplain ProcessBuilder#start() Starting a process} uses resources in both the invoking process and the invoked\n+ * process and for the communication streams between them.\n+ * The resources to control the process and for communication between the processes are retained\n+ * until there are no longer any references to the Process or the input, error, and output streams\n+ * or readers, or they have been closed.\n+ *\n+ * <p>The process is not killed when there are no more references to the {@code Process} object,\n+ * but rather the process continues executing asynchronously.\n+ * The process implementation closes file descriptors and handles for streams\n+ * that are no longer referenced to prevent leaking operating system resources.\n+ * Processes that have terminated or been terminated are monitored and their resources released.\n+ *\n+ * <p>Streams should be {@code closed} when they are no longer needed, to avoid delaying\n+ * releasing the operating system resources.\n+ * {@code Try-with-resources} can be used to open and close the streams.\n+ * <p>For example, to capture the output of a program known to produce some output and then exit:\n+ * {@snippet lang = \"java\" :\n+ * List<String> capture(List<String> args) throws Exception {\n+ *     ProcessBuilder pb = new ProcessBuilder(args);\n+ *     Process process = pb.start();\n+ *     try (BufferedReader in = process.inputReader()) {\n+ *         List<String> captured = in.readAllLines();\n+ *         int status = process.waitFor();\n+ *         if (status != 0) {\n+ *             throw new RuntimeException(\"Process %d: %s failed with %d\"\n+ *                         .formatted(process.pid(), args, status));\n+ *         }\n+ *         return captured;\n+ *     }\n+ * }\n+ * }\n+ * <p>Stream resources (file descriptor or handle) are always paired; one in the invoking process\n+ * and the other end of that connection in the invoked process.\n+ * Closing a stream at either end terminates communication but does not have any direct effect\n+ * on the other Process. The closing of the stream typically results in the other process exiting.\n+ *\n+ * <p> {@linkplain #destroy Destroying a process} signals the operating system to terminate the process.\n+ * It is up to the operating system to clean up and release the resources of that process.\n+ * Typically, file descriptors and handles are closed. When they are closed, any connections to\n+ * other processes are terminated and file descriptors and handles in the invoking process signal\n+ * end-of-file or closed. Usually, that is seen as an end-of-file or an exception.\n+ *\n@@ -130,0 +169,3 @@\n+     * <p>The output stream should be {@linkplain OutputStream#close closed}\n+     * when it is no longer needed.\n+     *\n@@ -162,0 +204,3 @@\n+     * <p>The input stream should be {@linkplain InputStream#close closed}\n+     * when it is no longer needed.\n+     *\n@@ -163,2 +208,5 @@\n-     * Use {@link #getInputStream()} and {@link #inputReader()} with extreme care.\n-     * The {@code BufferedReader} may have buffered input from the input stream.\n+     * Use either this method or an {@linkplain #inputReader() input reader}\n+     * but not both on the same {@code Process}.\n+     * The input reader consumes and buffers bytes from the input stream.\n+     * Bytes read from the input stream would not be seen by the reader and\n+     * buffer contents are unpredictable.\n@@ -188,0 +236,3 @@\n+     * <p>The error stream should be {@linkplain InputStream#close closed}\n+     * when it is no longer needed.\n+     *\n@@ -189,2 +240,5 @@\n-     * Use {@link #getErrorStream()} and {@link #errorReader()} with extreme care.\n-     * The {@code BufferedReader} may have buffered input from the error stream.\n+     * Use either this method or an {@linkplain #errorReader() error reader}\n+     * but not both on the same {@code Process}.\n+     * The error reader consumes and buffers bytes from the error stream.\n+     * Bytes read from the error stream would not be seen by the reader and the\n+     * buffer contents are unpredictable.\n@@ -211,0 +265,10 @@\n+     * <p>The reader should be {@linkplain BufferedReader#close closed}\n+     * when it is no longer needed.\n+     *\n+     * @apiNote\n+     * Use either this method or the {@linkplain #getInputStream input stream}\n+     * but not both on the same {@code Process}.\n+     * The input reader consumes and buffers bytes from the input stream.\n+     * Bytes read from the input stream would not be seen by the reader and the\n+     * buffer contents are unpredictable.\n+     *\n@@ -241,0 +305,3 @@\n+     * <p>The reader should be {@linkplain BufferedReader#close closed}\n+     * when it is no longer needed.\n+     *\n@@ -248,3 +315,5 @@\n-     * Using both {@link #getInputStream} and {@link #inputReader(Charset)} has\n-     * unpredictable behavior since the buffered reader reads ahead from the\n-     * input stream.\n+     * Use either this method or the {@linkplain #getInputStream input stream}\n+     * but not both on the same {@code Process}.\n+     * The input reader consumes and buffers bytes from the input stream.\n+     * Bytes read from the input stream would not be seen by the reader and the\n+     * buffer contents are unpredictable.\n@@ -286,0 +355,10 @@\n+     * <p>The error reader should be {@linkplain BufferedReader#close closed}\n+     * when it is no longer needed.\n+     *\n+     * @apiNote\n+     * Use either this method or the {@linkplain #getErrorStream error stream}\n+     * but not both on the same {@code Process}.\n+     * The error reader consumes and buffers bytes from the error stream.\n+     * Bytes read from the error stream would not be seen by the reader and the\n+     * buffer contents are unpredictable.\n+     *\n@@ -317,0 +396,3 @@\n+     * <p>The error reader should be {@linkplain BufferedReader#close closed}\n+     * when it is no longer needed.\n+     *\n@@ -318,3 +400,5 @@\n-     * Using both {@link #getErrorStream} and {@link #errorReader(Charset)} has\n-     * unpredictable behavior since the buffered reader reads ahead from the\n-     * error stream.\n+     * Use either this method or the {@linkplain #getErrorStream error stream}\n+     * but not both on the same {@code Process}.\n+     * The error reader consumes and buffers bytes from the error stream.\n+     * Bytes read from the error stream would not be seen by the reader and the\n+     * buffer contents are unpredictable.\n@@ -349,1 +433,1 @@\n-     * Writes text to a character-output stream, buffering characters so as to provide\n+     * Writes text to a character-output stream, buffering characters to provide\n@@ -357,0 +441,3 @@\n+     * <p>The output writer should be {@linkplain BufferedWriter#close closed}\n+     * when it is no longer needed.\n+     *\n@@ -368,1 +455,1 @@\n-     * Writes text to a character-output stream, buffering characters so as to provide\n+     * Writes text to a character-output stream, buffering characters to provide\n@@ -386,0 +473,3 @@\n+     * <p>The output writer should be {@linkplain BufferedWriter#close closed}\n+     * when it is no longer needed.\n+     *\n@@ -677,5 +767,6 @@\n-     * <pre> {@code   Process p = new ProcessBuilder(\"cmp\", \"f1\", \"f2\").start();\n-     *    Future<Boolean> identical = p.onExit().thenApply(p1 -> p1.exitValue() == 0);\n-     *    ...\n-     *    if (identical.get()) { ... }\n-     * }<\/pre>\n+     * {@snippet lang = \"java\" :\n+     *     Process p = new ProcessBuilder(\"cmp\", \"f1\", \"f2\").start();\n+     *     Future<Boolean> identical = p.onExit().thenApply(p1 -> p1.exitValue() == 0);\n+     *     ...\n+     *     if (identical.get()) { ... }\n+     * }\n@@ -698,1 +789,1 @@\n-     * <pre>{@code\n+     * {@snippet lang = \"java\" :\n@@ -702,1 +793,1 @@\n-     * }<\/pre>\n+     * }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Process.java","additions":116,"deletions":25,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,1 +153,2 @@\n- * <pre> {@code\n+ * {@snippet lang = \"java\" :\n+\n@@ -155,1 +156,2 @@\n- * }<\/pre>\n+ * }\n+\n@@ -161,16 +163,17 @@\n- * <pre> {@code\n- * ProcessBuilder pb =\n- *   new ProcessBuilder(\"myCommand\", \"myArg1\", \"myArg2\");\n- * Map<String, String> env = pb.environment();\n- * env.put(\"VAR1\", \"myValue\");\n- * env.remove(\"OTHERVAR\");\n- * env.put(\"VAR2\", env.get(\"VAR1\") + \"suffix\");\n- * pb.directory(new File(\"myDir\"));\n- * File log = new File(\"log\");\n- * pb.redirectErrorStream(true);\n- * pb.redirectOutput(Redirect.appendTo(log));\n- * Process p = pb.start();\n- * assert pb.redirectInput() == Redirect.PIPE;\n- * assert pb.redirectOutput().file() == log;\n- * assert p.getInputStream().read() == -1;\n- * }<\/pre>\n+ * {@snippet lang = \"java\":\n+ *     ProcessBuilder pb = new ProcessBuilder(\"myCommand\", \"myArg1\", \"myArg2\");\n+ *     Map<String, String> env = pb.environment();\n+ *     env.put(\"VAR1\", \"myValue\");\n+ *     env.remove(\"OTHERVAR\");\n+ *     env.put(\"VAR2\", env.get(\"VAR1\") + \"suffix\");\n+ *\n+ *     pb.directory(new File(\"myDir\"));\n+ *     File log = new File(\"log\");\n+ *     pb.redirectErrorStream(true);\n+ *     pb.redirectOutput(Redirect.appendTo(log));\n+ *\n+ *     Process p = pb.start();\n+ *     assert pb.redirectInput() == Redirect.PIPE;\n+ *     assert pb.redirectOutput().file() == log;\n+ *     assert p.getInputStream().read() == -1;\n+ * }\n@@ -509,4 +512,4 @@\n-         *  <pre> {@code\n-         * Redirect.PIPE.file() == null &&\n-         * Redirect.PIPE.type() == Redirect.Type.PIPE\n-         * }<\/pre>\n+         * {@snippet lang = \"java\" :\n+         *     Redirect.PIPE.file() == null &&\n+         *     Redirect.PIPE.type() == Redirect.Type.PIPE\n+         * }\n@@ -524,4 +527,4 @@\n-         *  <pre> {@code\n-         * Redirect.INHERIT.file() == null &&\n-         * Redirect.INHERIT.type() == Redirect.Type.INHERIT\n-         * }<\/pre>\n+         * {@snippet lang = \"java\" :\n+         *     Redirect.INHERIT.file() == null &&\n+         *     Redirect.INHERIT.type() == Redirect.Type.INHERIT\n+         * }\n@@ -540,5 +543,4 @@\n-         * <pre> {@code\n-         * Redirect.DISCARD.file() is the filename appropriate for the operating system\n-         * and may be null &&\n-         * Redirect.DISCARD.type() == Redirect.Type.WRITE\n-         * }<\/pre>\n+         * {@snippet lang = \"java\" :\n+         *     Redirect.DISCARD.file() != null && \/\/ is the filename appropriate for the operating system\n+         *     Redirect.DISCARD.type() == Redirect.Type.WRITE;\n+         * }\n@@ -575,4 +577,4 @@\n-         *  <pre> {@code\n-         * Redirect.from(file).file() == file &&\n-         * Redirect.from(file).type() == Redirect.Type.READ\n-         * }<\/pre>\n+         * {@snippet lang = \"java\" :\n+         *     Redirect.from(file).file() == file &&\n+         *     Redirect.from(file).type() == Redirect.Type.READ\n+         * }\n@@ -601,4 +603,4 @@\n-         *  <pre> {@code\n-         * Redirect.to(file).file() == file &&\n-         * Redirect.to(file).type() == Redirect.Type.WRITE\n-         * }<\/pre>\n+         * {@snippet lang = \"java\" :\n+         *     Redirect.to(file).file() == file &&\n+         *     Redirect.to(file).type() == Redirect.Type.WRITE\n+         * }\n@@ -631,4 +633,4 @@\n-         *  <pre> {@code\n-         * Redirect.appendTo(file).file() == file &&\n-         * Redirect.appendTo(file).type() == Redirect.Type.APPEND\n-         * }<\/pre>\n+         * {@snippet lang = \"java\" :\n+         *     Redirect.appendTo(file).file() == file &&\n+         *     Redirect.appendTo(file).type() == Redirect.Type.APPEND\n+         * }\n@@ -917,3 +919,3 @@\n-     *  <pre> {@code\n-     * pb.inheritIO()\n-     * }<\/pre>\n+     * {@snippet lang = \"java\" :\n+     *      pb.inheritIO()\n+     * }\n@@ -921,5 +923,5 @@\n-     *  <pre> {@code\n-     * pb.redirectInput(Redirect.INHERIT)\n-     *   .redirectOutput(Redirect.INHERIT)\n-     *   .redirectError(Redirect.INHERIT)\n-     * }<\/pre>\n+     * {@snippet lang = \"java\" :\n+     *      pb.redirectInput(Redirect.INHERIT)\n+     *          .redirectOutput(Redirect.INHERIT)\n+     *          .redirectError(Redirect.INHERIT)\n+     * }\n@@ -1179,3 +1181,3 @@\n-     * <pre>{@code\n-     * String directory = \"\/home\/duke\/src\";\n-     * ProcessBuilder[] builders = {\n+     * {@snippet lang = \"java\" :\n+     *     String directory = \"\/home\/duke\/src\";\n+     *     ProcessBuilder[] builders = {\n@@ -1186,4 +1188,3 @@\n-     * List<Process> processes = ProcessBuilder.startPipeline(\n-     *         Arrays.asList(builders));\n-     * Process last = processes.get(processes.size()-1);\n-     * try (InputStream is = last.getInputStream();\n+     *     List<Process> processes = ProcessBuilder.startPipeline( Arrays.asList(builders));\n+     *     Process last = processes.get(processes.size() - 1);\n+     *     try (InputStream is = last.getInputStream();\n@@ -1192,1 +1193,2 @@\n-     *     long count = r.lines().count();\n+     *         long count = r.lines().count();\n+     *     }\n@@ -1194,1 +1196,0 @@\n-     * }<\/pre>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ProcessBuilder.java","additions":62,"deletions":61,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2022, Red Hat Inc.\n+ * Copyright (c) 2020, 2025, Red Hat Inc.\n@@ -29,0 +29,1 @@\n+import java.lang.ref.Reference;\n@@ -31,2 +32,2 @@\n-import java.lang.ref.Reference;\n-import java.util.concurrent.StructuredTaskScope;\n+import java.util.concurrent.StructuredTaskScope;\n+import java.util.function.IntSupplier;\n@@ -37,1 +38,1 @@\n-import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.vm.ScopedValueContainer;\n@@ -40,1 +41,1 @@\n-import jdk.internal.vm.ScopedValueContainer;\n+import jdk.internal.vm.annotation.Stable;\n@@ -240,1 +241,1 @@\n- * @since 21\n+ * @since 25\n@@ -242,1 +243,0 @@\n-@PreviewFeature(feature = PreviewFeature.Feature.SCOPED_VALUES)\n@@ -249,0 +249,3 @@\n+    @Stable\n+    static IntSupplier hashGenerator;\n+\n@@ -313,1 +316,1 @@\n-     * @since 21\n+     * @since 25\n@@ -315,1 +318,0 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.SCOPED_VALUES)\n@@ -416,1 +418,0 @@\n-         * @since 23\n@@ -500,1 +501,1 @@\n-     * @since 23\n+     * @since 25\n@@ -502,1 +503,0 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.SCOPED_VALUES)\n@@ -534,1 +534,2 @@\n-        this.hash = generateKey();\n+        IntSupplier nextHash = hashGenerator;\n+        this.hash = nextHash != null ? nextHash.getAsInt() : generateKey();\n@@ -560,1 +561,1 @@\n-            int n = (hash & Cache.SLOT_MASK) * 2;\n+            int n = (hash & Cache.Constants.SLOT_MASK) * 2;\n@@ -564,1 +565,1 @@\n-            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n+            n = ((hash >>> Cache.INDEX_BITS) & Cache.Constants.SLOT_MASK) * 2;\n@@ -588,1 +589,1 @@\n-            int n = (hash & Cache.SLOT_MASK) * 2;\n+            int n = (hash & Cache.Constants.SLOT_MASK) * 2;\n@@ -592,1 +593,1 @@\n-            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n+            n = ((hash >>> Cache.INDEX_BITS) & Cache.Constants.SLOT_MASK) * 2;\n@@ -615,1 +616,1 @@\n-     * @param other the value to return if not bound, can be {@code null}\n+     * @param other the value to return if not bound\n@@ -619,0 +620,1 @@\n+        Objects.requireNonNull(other);\n@@ -695,4 +697,4 @@\n-    \/\/ A Marsaglia xor-shift generator used to generate hashes. This one has full period, so\n-    \/\/ it generates 2**32 - 1 hashes before it repeats. We're going to use the lowest n bits\n-    \/\/ and the next n bits as cache indexes, so we make sure that those indexes map\n-    \/\/ to different slots in the cache.\n+    \/\/ A Marsaglia xor-shift generator used to generate hashes. This one has\n+    \/\/ full period, so it generates 2**32 - 1 hashes before it repeats. We're\n+    \/\/ going to use the lowest n bits and the next n bits as cache indexes, so\n+    \/\/ we make sure that those indexes map to different slots in the cache.\n@@ -705,1 +707,1 @@\n-        } while (Cache.primarySlot(x) == Cache.secondarySlot(x));\n+        } while (((Cache.primaryIndex(x) ^ Cache.secondaryIndex(x)) & 1) == 0);\n@@ -716,1 +718,1 @@\n-        return (1 << Cache.primaryIndex(this)) | (1 << (Cache.secondaryIndex(this) + Cache.TABLE_SIZE));\n+        return (1 << Cache.primaryIndex(hash)) | (1 << (Cache.secondaryIndex(hash) + Cache.TABLE_SIZE));\n@@ -734,18 +736,63 @@\n-        \/\/ The number of elements in the cache array, and a bit mask used to\n-        \/\/ select elements from it.\n-        private static final int CACHE_TABLE_SIZE, SLOT_MASK;\n-        \/\/ The largest cache we allow. Must be a power of 2 and greater than\n-        \/\/ or equal to 2.\n-        private static final int MAX_CACHE_SIZE = 16;\n-\n-        static {\n-            final String propertyName = \"java.lang.ScopedValue.cacheSize\";\n-            var sizeString = System.getProperty(propertyName, \"16\");\n-            var cacheSize = Integer.valueOf(sizeString);\n-            if (cacheSize < 2 || cacheSize > MAX_CACHE_SIZE) {\n-                cacheSize = MAX_CACHE_SIZE;\n-                System.err.println(propertyName + \" is out of range: is \" + sizeString);\n-            }\n-            if ((cacheSize & (cacheSize - 1)) != 0) {  \/\/ a power of 2\n-                cacheSize = MAX_CACHE_SIZE;\n-                System.err.println(propertyName + \" must be an integer power of 2: is \" + sizeString);\n+\n+        \/\/ This class serves to defer initialization of some values until they\n+        \/\/ are needed. In particular, we must not invoke System.getProperty\n+        \/\/ early in the JDK boot process, because that leads to a circular class\n+        \/\/ initialization dependency.\n+        \/\/\n+        \/\/ In more detail:\n+        \/\/\n+        \/\/  The size of the cache depends on System.getProperty. Generating the\n+        \/\/  hash of an instance of ScopedValue depends on ThreadLocalRandom.\n+        \/\/\n+        \/\/  Invoking either of these early in the JDK boot process will cause\n+        \/\/  startup to fail with an unrecoverable circular dependency.\n+        \/\/\n+        \/\/ To break these cycles we allow scoped values to be created (but not\n+        \/\/ used) without invoking either System.getProperty or\n+        \/\/ ThreadLocalRandom. To do this we defer querying System.getProperty\n+        \/\/ until the first reference to CACHE_TABLE_SIZE, and we define a local\n+        \/\/ hash generator which is used until CACHE_TABLE_SIZE is initialized.\n+\n+        private static class Constants {\n+            \/\/ The number of elements in the cache array, and a bit mask used to\n+            \/\/ select elements from it.\n+            private static final int CACHE_TABLE_SIZE, SLOT_MASK;\n+            \/\/ The largest cache we allow. Must be a power of 2 and greater than\n+            \/\/ or equal to 2.\n+            private static final int MAX_CACHE_SIZE = 16;\n+\n+            private static final JavaUtilConcurrentTLRAccess THREAD_LOCAL_RANDOM_ACCESS\n+                = SharedSecrets.getJavaUtilConcurrentTLRAccess();\n+\n+            static {\n+                final String propertyName = \"java.lang.ScopedValue.cacheSize\";\n+                var sizeString = System.getProperty(propertyName, \"16\");\n+                var cacheSize = Integer.valueOf(sizeString);\n+                if (cacheSize < 2 || cacheSize > MAX_CACHE_SIZE) {\n+                    cacheSize = MAX_CACHE_SIZE;\n+                    System.err.println(propertyName + \" is out of range: is \" + sizeString);\n+                }\n+                if ((cacheSize & (cacheSize - 1)) != 0) {  \/\/ a power of 2\n+                    cacheSize = MAX_CACHE_SIZE;\n+                    System.err.println(propertyName + \" must be an integer power of 2: is \" + sizeString);\n+                }\n+                CACHE_TABLE_SIZE = cacheSize;\n+                SLOT_MASK = cacheSize - 1;\n+\n+                \/\/ hashGenerator is set here (in class Constants rather than\n+                \/\/ in global scope) in order not to initialize\n+                \/\/ j.u.c.ThreadLocalRandom early in the JDK boot process.\n+                \/\/ After this static initialization, new instances of\n+                \/\/ ScopedValue will be initialized by a thread-local random\n+                \/\/ generator.\n+                hashGenerator = new IntSupplier() {\n+                    @Override\n+                    public int getAsInt() {\n+                        int x;\n+                        do {\n+                            x = THREAD_LOCAL_RANDOM_ACCESS\n+                                .nextSecondaryThreadLocalRandomSeed();\n+                        } while (Cache.primarySlot(x) == Cache.secondarySlot(x));\n+                        return x;\n+                    }\n+                };\n@@ -753,2 +800,0 @@\n-            CACHE_TABLE_SIZE = cacheSize;\n-            SLOT_MASK = cacheSize - 1;\n@@ -757,2 +802,2 @@\n-        static int primaryIndex(ScopedValue<?> key) {\n-            return key.hash & TABLE_MASK;\n+        static int primaryIndex(int hash) {\n+            return hash & Cache.TABLE_MASK;\n@@ -761,2 +806,2 @@\n-        static int secondaryIndex(ScopedValue<?> key) {\n-            return (key.hash >> INDEX_BITS) & TABLE_MASK;\n+        static int secondaryIndex(int hash) {\n+            return (hash >> INDEX_BITS) & Cache.TABLE_MASK;\n@@ -766,1 +811,1 @@\n-            return key.hashCode() & SLOT_MASK;\n+            return key.hashCode() & Constants.SLOT_MASK;\n@@ -770,1 +815,1 @@\n-            return (key.hash >> INDEX_BITS) & SLOT_MASK;\n+            return (key.hash >> INDEX_BITS) & Constants.SLOT_MASK;\n@@ -774,1 +819,1 @@\n-            return hash & SLOT_MASK;\n+            return hash & Constants.SLOT_MASK;\n@@ -778,1 +823,1 @@\n-            return (hash >> INDEX_BITS) & SLOT_MASK;\n+            return (hash >> INDEX_BITS) & Constants.SLOT_MASK;\n@@ -784,1 +829,1 @@\n-                theCache = new Object[CACHE_TABLE_SIZE * 2];\n+                theCache = new Object[Constants.CACHE_TABLE_SIZE * 2];\n@@ -820,3 +865,0 @@\n-        private static final JavaUtilConcurrentTLRAccess THREAD_LOCAL_RANDOM_ACCESS\n-                = SharedSecrets.getJavaUtilConcurrentTLRAccess();\n-\n@@ -828,1 +870,1 @@\n-            int r = THREAD_LOCAL_RANDOM_ACCESS.nextSecondaryThreadLocalRandomSeed();\n+            int r = Constants.THREAD_LOCAL_RANDOM_ACCESS.nextSecondaryThreadLocalRandomSeed();\n@@ -834,1 +876,1 @@\n-            toClearBits = (toClearBits >>> TABLE_SIZE) | (toClearBits & PRIMARY_MASK);\n+            toClearBits = ((toClearBits >>> Cache.TABLE_SIZE) | toClearBits) & PRIMARY_MASK;\n@@ -839,1 +881,1 @@\n-                    setKeyAndObjectAt(objects, index & SLOT_MASK, null, null);\n+                    setKeyAndObjectAt(objects, index & Constants.SLOT_MASK, null, null);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ScopedValue.java","additions":101,"deletions":59,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -135,0 +135,1 @@\n+     * @throws IndexOutOfBoundsException if the parameter index is out of bounds\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -33,1 +32,0 @@\n-import jdk.internal.ref.Cleaner;\n@@ -47,1 +45,1 @@\n-public abstract sealed class Reference<T>\n+public abstract sealed class Reference<@jdk.internal.RequiresIdentity T>\n@@ -202,5 +200,0 @@\n-            \/\/ pre-load and initialize Cleaner class so that we don't\n-            \/\/ get into trouble later in the run loop if there's\n-            \/\/ memory shortage while loading\/initializing it lazily.\n-            Unsafe.getUnsafe().ensureClassInitialized(Cleaner.class);\n-\n@@ -256,12 +249,1 @@\n-\n-            if (ref instanceof Cleaner) {\n-                ((Cleaner)ref).clean();\n-                \/\/ Notify any waiters that progress has been made.\n-                \/\/ This improves latency for nio.Bits waiters, which\n-                \/\/ are the only important ones.\n-                synchronized (processPendingLock) {\n-                    processPendingLock.notifyAll();\n-                }\n-            } else {\n-                ref.enqueueFromPending();\n-            }\n+            ref.enqueueFromPending();\n@@ -360,2 +342,1 @@\n-    @IntrinsicCandidate\n-        return this.referent;\n+        return get0();\n@@ -365,0 +346,8 @@\n+    \/* Implementation of get().  This method exists to avoid making get() all\n+     * of virtual, native, and intrinsic candidate. That could have the\n+     * undesirable effect of having the native method used instead of the\n+     * intrinsic when devirtualization fails.\n+     *\/\n+    @IntrinsicCandidate\n+    private native T get0();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":11,"deletions":22,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,0 +104,1 @@\n+    private static final long INITIAL_SLEEP = 1;\n@@ -106,0 +107,6 @@\n+    private static final Object RESERVE_SLOWPATH_LOCK = new Object();\n+\n+    \/\/ Token for detecting whether some other thread has done a GC since the\n+    \/\/ last time the checking thread went around the retry-with-GC loop.\n+    private static int RESERVE_GC_EPOCH = 0; \/\/ Never negative.\n+\n@@ -121,1 +128,2 @@\n-        final JavaLangRefAccess jlra = SharedSecrets.getJavaLangRefAccess();\n+        \/\/ Don't completely discard interruptions.  Instead, record them and\n+        \/\/ reapply when we're done here (whether successfully or OOME).\n@@ -124,6 +132,26 @@\n-\n-            \/\/ Retry allocation until success or there are no more\n-            \/\/ references (including Cleaners that might free direct\n-            \/\/ buffer memory) to process and allocation still fails.\n-            boolean refprocActive;\n-            do {\n+            \/\/ Keep trying to reserve until either succeed or there is no\n+            \/\/ further cleaning available from prior GCs. If the latter then\n+            \/\/ GC to hopefully find more cleaning to do. Once a thread GCs it\n+            \/\/ drops to the later retry with backoff loop.\n+            for (int cleanedEpoch = -1; true; ) {\n+                synchronized (RESERVE_SLOWPATH_LOCK) {\n+                    \/\/ Test if cleaning for prior GCs (from here) is complete.\n+                    \/\/ If so, GC to produce more cleaning work, and change\n+                    \/\/ the token to inform other threads that there may be\n+                    \/\/ more cleaning work to do.  This is done under the lock\n+                    \/\/ to close a race.  We could have multiple threads pass\n+                    \/\/ the test \"simultaneously\", resulting in back-to-back\n+                    \/\/ GCs.  For a STW GC the window is small, but for a\n+                    \/\/ concurrent GC it's quite large. If a thread were to\n+                    \/\/ somehow be stuck trying to take the lock while enough\n+                    \/\/ other threads succeeded for the epoch to wrap, it just\n+                    \/\/ does an excess GC.\n+                    if (RESERVE_GC_EPOCH == cleanedEpoch) {\n+                        \/\/ Increment with overflow to 0, so the value can\n+                        \/\/ never equal the initial\/reset cleanedEpoch value.\n+                        RESERVE_GC_EPOCH = Integer.max(0, RESERVE_GC_EPOCH + 1);\n+                        System.gc();\n+                        break;\n+                    }\n+                    cleanedEpoch = RESERVE_GC_EPOCH;\n+                }\n@@ -131,1 +159,3 @@\n-                    refprocActive = jlra.waitForReferenceProcessing();\n+                    if (tryReserveOrClean(size, cap)) {\n+                        return;\n+                    }\n@@ -133,2 +163,1 @@\n-                    \/\/ Defer interrupts and keep trying.\n-                    refprocActive = true;\n+                    cleanedEpoch = -1; \/\/ Reset when incomplete.\n@@ -137,7 +166,1 @@\n-                if (tryReserveMemory(size, cap)) {\n-                    return;\n-                }\n-            } while (refprocActive);\n-\n-            \/\/ trigger VM's Reference processing\n-            System.gc();\n+            }\n@@ -154,9 +177,1 @@\n-            long sleepTime = 1;\n-            int sleeps = 0;\n-            while (true) {\n-                if (tryReserveMemory(size, cap)) {\n-                    return;\n-                }\n-                if (sleeps >= MAX_SLEEPS) {\n-                    break;\n-                }\n+            for (int sleeps = 0; true; ) {\n@@ -164,4 +179,10 @@\n-                    if (!jlra.waitForReferenceProcessing()) {\n-                        Thread.sleep(sleepTime);\n-                        sleepTime <<= 1;\n-                        sleeps++;\n+                    if (tryReserveOrClean(size, cap)) {\n+                        return;\n+                    } else if (sleeps < MAX_SLEEPS) {\n+                        Thread.sleep(INITIAL_SLEEP << sleeps);\n+                        ++sleeps; \/\/ Only increment if sleep completed.\n+                    } else {\n+                        throw new OutOfMemoryError\n+                            (\"Cannot reserve \"\n+                             + size + \" bytes of direct buffer memory (allocated: \"\n+                             + RESERVED_MEMORY.get() + \", limit: \" + MAX_MEMORY +\")\");\n@@ -174,6 +195,1 @@\n-            \/\/ no luck\n-            throw new OutOfMemoryError\n-                (\"Cannot reserve \"\n-                 + size + \" bytes of direct buffer memory (allocated: \"\n-                 + RESERVED_MEMORY.get() + \", limit: \" + MAX_MEMORY +\")\");\n-\n+            \/\/ Reapply any deferred interruption.\n@@ -182,1 +198,0 @@\n-                \/\/ don't swallow interrupts\n@@ -188,0 +203,21 @@\n+    \/\/ Try to reserve memory, or failing that, try to make progress on\n+    \/\/ cleaning.  Returns true if successfully reserved memory, false if\n+    \/\/ failed and ran out of cleaning work.\n+    private static boolean tryReserveOrClean(long size, long cap)\n+        throws InterruptedException\n+    {\n+        JavaLangRefAccess jlra = SharedSecrets.getJavaLangRefAccess();\n+        boolean progressing = true;\n+        while (true) {\n+            if (tryReserveMemory(size, cap)) {\n+                return true;\n+            } else if (BufferCleaner.tryCleaning()) {\n+                progressing = true;\n+            } else if (!progressing) {\n+                return false;\n+            } else {\n+                progressing = jlra.waitForReferenceProcessing();\n+            }\n+        }\n+    }\n+\n@@ -237,0 +273,24 @@\n+\n+    \/\/ Maximum number of bytes to set in one call to {@code Unsafe.setMemory}.\n+    \/\/ This threshold allows safepoint polling during large memory operations.\n+    static final long UNSAFE_SET_THRESHOLD = 1024 * 1024;\n+\n+    \/**\n+     * Sets a block of memory starting from a given address to a specified byte value.\n+     *\n+     * @param srcAddr\n+     *        the starting memory address\n+     * @param count\n+     *        the number of bytes to set\n+     * @param value\n+     *        the byte value to set\n+     *\/\n+    static void setMemory(long srcAddr, long count, byte value) {\n+        long offset = 0;\n+        while (offset < count) {\n+            long len = Math.min(UNSAFE_SET_THRESHOLD, count - offset);\n+            UNSAFE.setMemory(srcAddr + offset, len, value);\n+            offset += len;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Bits.java","additions":98,"deletions":38,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -0,0 +1,269 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.nio;\n+\n+import java.lang.ref.PhantomReference;\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.util.Objects;\n+import sun.nio.Cleaner;\n+\n+\/**\n+ * BufferCleaner supports PhantomReference-based management of native memory\n+ * referred to by Direct-XXX-Buffers. Unreferenced DBBs may be garbage\n+ * collected, deactivating the associated PRefs and making them available for\n+ * cleanup here.\n+ *\n+ * There is a configured limit to the amount of memory that may be allocated\n+ * by DBBs. When that limit is reached, the allocator may invoke the garbage\n+ * collector directly to attempt to trigger cleaning here, hopefully\n+ * permitting the allocation to complete. Only if that doesn't free sufficient\n+ * memory does the allocation fail.  See java.nio.Bits::reserveMemory() for\n+ * details.\n+ *\n+ * One of the requirements for that approach is having a way to determine that\n+ * deactivated cleaners have been cleaned. java.lang.ref.Cleaner doesn't\n+ * provide such a mechanism, and adding such a mechanism to that class to\n+ * satisfy this unique requirement was deemed undesirable. Instead, this class\n+ * uses the underlying primitives (PhantomReferences, ReferenceQueues) to\n+ * provide the functionality needed for DBB management.\n+ *\/\n+class BufferCleaner {\n+    private static final class PhantomCleaner\n+        extends PhantomReference<Object>\n+        implements Cleaner\n+    {\n+        private final Runnable action;\n+        \/\/ Position in the CleanerList.\n+        CleanerList.Node node;\n+        int index;\n+\n+        public PhantomCleaner(Object obj, Runnable action) {\n+            super(obj, queue);\n+            this.action = action;\n+        }\n+\n+        @Override\n+        public void clean() {\n+            if (cleanerList.remove(this)) {\n+                \/\/ If being cleaned explicitly by application, rather than via\n+                \/\/ reference processing by BufferCleaner, clear the referent so\n+                \/\/ reference processing is disabled for this object.\n+                clear();\n+                try {\n+                    action.run();\n+                } catch (Throwable x) {\n+                    \/\/ Long-standing behavior: when cleaning fails, VM exits.\n+                    if (System.err != null) {\n+                        new Error(\"nio Cleaner terminated abnormally\", x).printStackTrace();\n+                    }\n+                    System.exit(1);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Cribbed from jdk.internal.ref.CleanerImpl.\n+    static final class CleanerList {\n+        \/**\n+         * Capacity for a single node in the list.\n+         * This balances memory overheads vs locality vs GC walking costs.\n+         *\/\n+        static final int NODE_CAPACITY = 4096;\n+\n+        \/**\n+         * Head node. This is the only node where PhantomCleanabls are\n+         * added to or removed from. This is the only node with variable size,\n+         * all other nodes linked from the head are always at full capacity.\n+         *\/\n+        private Node head;\n+\n+        \/**\n+         * Cached node instance to provide better behavior near NODE_CAPACITY\n+         * threshold: if list size flips around NODE_CAPACITY, it would reuse\n+         * the cached node instead of wasting and re-allocating a new node all\n+         * the time.\n+         *\/\n+        private Node cache;\n+\n+        public CleanerList() {\n+            this.head = new Node();\n+        }\n+\n+        \/**\n+         * Insert this PhantomCleaner in the list.\n+         *\/\n+        public synchronized void insert(PhantomCleaner phc) {\n+            if (head.size == NODE_CAPACITY) {\n+                \/\/ Head node is full, insert new one.\n+                \/\/ If possible, pick a pre-allocated node from cache.\n+                Node newHead;\n+                if (cache != null) {\n+                    newHead = cache;\n+                    cache = null;\n+                } else {\n+                    newHead = new Node();\n+                }\n+                newHead.next = head;\n+                head = newHead;\n+            }\n+            assert head.size < NODE_CAPACITY;\n+\n+            \/\/ Put the incoming object in head node and record indexes.\n+            final int lastIndex = head.size;\n+            phc.node = head;\n+            phc.index = lastIndex;\n+            head.arr[lastIndex] = phc;\n+            head.size++;\n+        }\n+\n+        \/**\n+         * Remove this PhantomCleaner from the list.\n+         *\n+         * @return true if Cleaner was removed or false if not because\n+         * it had already been removed before\n+         *\/\n+        public synchronized boolean remove(PhantomCleaner phc) {\n+            if (phc.node == null) {\n+                \/\/ Not in the list.\n+                return false;\n+            }\n+            assert phc.node.arr[phc.index] == phc;\n+\n+            \/\/ Replace with another element from the head node, as long\n+            \/\/ as it is not the same element. This keeps all non-head\n+            \/\/ nodes at full capacity.\n+            final int lastIndex = head.size - 1;\n+            assert lastIndex >= 0;\n+            if (head != phc.node || (phc.index != lastIndex)) {\n+                PhantomCleaner mover = head.arr[lastIndex];\n+                mover.node = phc.node;\n+                mover.index = phc.index;\n+                phc.node.arr[phc.index] = mover;\n+            }\n+\n+            \/\/ Now we can unlink the removed element.\n+            phc.node = null;\n+\n+            \/\/ Remove the last element from the head node.\n+            head.arr[lastIndex] = null;\n+            head.size--;\n+\n+            \/\/ If head node becomes empty after this, and there are\n+            \/\/ nodes that follow it, replace the head node with another\n+            \/\/ full one. If needed, stash the now free node in cache.\n+            if (head.size == 0 && head.next != null) {\n+                Node newHead = head.next;\n+                if (cache == null) {\n+                    cache = head;\n+                    cache.next = null;\n+                }\n+                head = newHead;\n+            }\n+\n+            return true;\n+        }\n+\n+        \/**\n+         * Segment node.\n+         *\/\n+        static class Node {\n+            \/\/ Array of tracked cleaners, and the amount of elements in it.\n+            final PhantomCleaner[] arr = new PhantomCleaner[NODE_CAPACITY];\n+            int size;\n+\n+            \/\/ Linked list structure.\n+            Node next;\n+        }\n+    }\n+\n+    private static final class CleaningThread extends Thread {\n+        public CleaningThread() {}\n+\n+        @Override\n+        public void run() {\n+            while (true) {\n+                try {\n+                    Cleaner c = (Cleaner) queue.remove();\n+                    c.clean();\n+                } catch (InterruptedException e) {\n+                    \/\/ Ignore InterruptedException in cleaner thread.\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Try to do some cleaning. Takes a cleaner from the queue and executes it.\n+     *\n+     * @return true if a cleaner was found and executed, false if there\n+     * weren't any cleaners in the queue.\n+     *\/\n+    public static boolean tryCleaning() {\n+        Cleaner c = (Cleaner) queue.poll();\n+        if (c == null) {\n+            return false;\n+        } else {\n+            c.clean();\n+            return true;\n+        }\n+    }\n+\n+    private static final CleanerList cleanerList = new CleanerList();\n+    private static final ReferenceQueue<Object> queue = new ReferenceQueue<Object>();\n+    private static CleaningThread cleaningThread = null;\n+\n+    private static void startCleaningThreadIfNeeded() {\n+        synchronized (cleanerList) {\n+            if (cleaningThread != null) {\n+                return;\n+            }\n+            cleaningThread = new CleaningThread();\n+        }\n+        cleaningThread.setDaemon(true);\n+        cleaningThread.start();\n+    }\n+\n+    private BufferCleaner() {}\n+\n+    \/**\n+     * Construct a new Cleaner for obj, with the associated action.\n+     *\n+     * @param obj object to track.\n+     * @param action cleanup action for obj.\n+     * @return associated cleaner.\n+     *\n+     *\/\n+    public static Cleaner register(Object obj, Runnable action) {\n+        Objects.requireNonNull(obj, \"obj\");\n+        Objects.requireNonNull(action, \"action\");\n+        startCleaningThreadIfNeeded();\n+        PhantomCleaner cleaner = new PhantomCleaner(obj, action);\n+        cleanerList.insert(cleaner);\n+        Reference.reachabilityFence(obj);\n+        return cleaner;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/BufferCleaner.java","additions":269,"deletions":0,"binary":false,"changes":269,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.nio.BufferCleaner;\n@@ -40,1 +41,1 @@\n-import jdk.internal.ref.Cleaner;\n+import sun.nio.Cleaner;\n@@ -117,1 +118,1 @@\n-        UNSAFE.setMemory(base, size, (byte) 0);\n+        Bits.setMemory(base, size, (byte) 0);\n@@ -125,1 +126,1 @@\n-            cleaner = Cleaner.create(this, new Deallocator(base, size, cap));\n+            cleaner = BufferCleaner.register(this, new Deallocator(base, size, cap));\n@@ -200,1 +201,1 @@\n-        cleaner = Cleaner.create(this, unmapper);\n+        cleaner = (unmapper == null) ? null : BufferCleaner.register(this, unmapper);\n@@ -433,0 +434,6 @@\n+#end[rw]\n+\n+    public $Type$Buffer append(CharSequence csq, int start, int end) {\n+#if[rw]\n+        if (csq == null)\n+            return super.append(csq, start, end);\n@@ -434,1 +441,0 @@\n-    private $Type$Buffer appendChars(CharSequence csq, int start, int end) {\n@@ -451,7 +457,1 @@\n-            if (csq instanceof String str) {\n-                str.getChars(start, start + count, buf, 0);\n-            } else if (csq instanceof StringBuilder sb) {\n-                sb.getChars(start, start + count, buf, 0);\n-            } else if (csq instanceof StringBuffer sb) {\n-                sb.getChars(start, start + count, buf, 0);\n-            }\n+            csq.getChars(start, start + count, buf, 0);\n@@ -468,8 +468,0 @@\n-    }\n-#end[rw] \n-    public $Type$Buffer append(CharSequence csq) {\n-#if[rw] \n-        if (csq instanceof StringBuilder) \n-            return appendChars(csq, 0, csq.length());\n- \n-        return super.append(csq);\n@@ -481,2 +473,2 @@\n- \n-    public $Type$Buffer append(CharSequence csq, int start, int end) { \n+\n+    public $Type$Buffer append(CharSequence csq) {\n@@ -484,3 +476,3 @@\n-        if (csq instanceof String || csq instanceof StringBuffer ||\n-            csq instanceof StringBuilder)\n-            return appendChars(csq, start, end);\n+        \/\/ See comment regarding StringBuilder on HeapBuffer.append.\n+        if (csq instanceof StringBuilder)\n+            return append(csq, 0, csq.length());\n@@ -488,1 +480,1 @@\n-        return super.append(csq, start, end);\n+        return super.append(csq);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":19,"deletions":27,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1900,1 +1900,1 @@\n-     * Absolute bulk <i>get<\/i> method.\n+     * Relative bulk <i>get<\/i> method.\n@@ -1903,3 +1903,10 @@\n-     * buffer into the given array, starting at index {@code srcBegin} in this\n-     * buffer and at offset {@code dstBegin} in the array. The position of this\n-     * buffer is unchanged.\n+     * buffer into the given array, starting at index\n+     * {@code position() + srcBegin} in this buffer and at offset\n+     * {@code dstBegin} in the array. The position of this buffer is unchanged.\n+     *\n+     * <p> An invocation of this method behaves exactly the same was as the\n+     * invocation\n+     *\n+     * {@snippet lang=java :\n+     *     get(position() + srcBegin, dst, dstBegin, srcEnd - srcBegin)\n+     * }\n@@ -1908,2 +1915,4 @@\n-     *         The index in this buffer from which the first character will be\n-     *         read; must be non-negative and less than {@code limit()}\n+     *         The index in this buffer, relative to the current position,\n+     *         of the first character to\n+     *         read; must be non-negative and less than\n+     *         {@code limit() - position()}\n@@ -1912,3 +1921,4 @@\n-     *         The index in this buffer directly before the last character to\n-     *         read; must be non-negative and less or equal than {@code limit()}\n-     *         and must be greater or equal than {@code srcBegin}\n+     *         The index in this buffer, relative to the current position,\n+     *         after the last character to read;\n+     *         must be greater than or equal to {@code srcBegin} and less than\n+     *         or equal to {@code limit() - position()}\n@@ -1927,3 +1937,0 @@\n-     * @implSpec This method is equivalent to\n-     *           {@code get(srcBegin, dst, dstBegin, srcEnd - srcBegin)}.\n-     *\n@@ -1934,1 +1941,6 @@\n-        get(srcBegin, dst, dstBegin, srcEnd - srcBegin);\n+        \/\/ Check [srcBegin,srcEnd) is a subset of [0,limit()-position)\n+        int pos = position();\n+        int lim = limit();\n+        Objects.checkFromToIndex(srcBegin, srcEnd, lim - pos);\n+\n+        get(pos + srcBegin, dst, dstBegin, srcEnd - srcBegin);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":25,"deletions":13,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.util.ByteArray;\n@@ -840,0 +841,10 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public long nextLong() {\n+        byte[] b = new byte[8];\n+        nextBytes(b); \/\/ Calls engineNextBytes internally\n+        return ByteArray.getLong(b, 0);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/security\/SecureRandom.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n@@ -388,1 +388,1 @@\n- *     NumberFormat.getCurrencyInstance(Locale.JAPAN).format(number); \/\/ returns \"\\u00A51,000\"\"\n+ *     NumberFormat.getCurrencyInstance(Locale.JAPAN).format(number); \/\/ returns \"1,000\"\"\n@@ -391,1 +391,1 @@\n- *     DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG).localizedBy(Locale.JAPAN).format(date); \/\/ returns \"2024\\u5e741\\u67081\\u65e5\"\n+ *     DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG).localizedBy(Locale.JAPAN).format(date); \/\/ returns \"202411\"\n@@ -564,2 +564,2 @@\n- * @spec https:\/\/unicode.org\/reports\/tr35\/\n- *      Unicode Locale Data Markup Language\n+ * @spec https:\/\/www.unicode.org\/reports\/tr35\n+ *      Unicode Locale Data Markup Language (LDML)\n@@ -736,1 +736,1 @@\n-    public static enum IsoCountryCode {\n+    public enum IsoCountryCode {\n@@ -741,6 +741,1 @@\n-        PART1_ALPHA2 {\n-            @Override\n-            Set<String> createCountryCodeSet() {\n-                return Set.of(Locale.getISOCountries());\n-            }\n-        },\n+        PART1_ALPHA2,\n@@ -753,6 +748,1 @@\n-        PART1_ALPHA3 {\n-            @Override\n-            Set<String> createCountryCodeSet() {\n-                return LocaleISOData.computeISO3166_1Alpha3Countries();\n-            }\n-        },\n+        PART1_ALPHA3,\n@@ -763,25 +753,1 @@\n-        PART3 {\n-            @Override\n-            Set<String> createCountryCodeSet() {\n-                return Set.of(LocaleISOData.ISO3166_3);\n-            }\n-        };\n-\n-        \/**\n-         * Concrete implementation of this method attempts to compute value\n-         * for iso3166CodesMap for each IsoCountryCode type key.\n-         *\/\n-        abstract Set<String> createCountryCodeSet();\n-\n-        \/**\n-         * Map to hold country codes for each ISO3166 part.\n-         *\/\n-        private static final Map<IsoCountryCode, Set<String>> iso3166CodesMap = new ConcurrentHashMap<>();\n-\n-        \/**\n-         * This method is called from Locale class to retrieve country code set\n-         * for getISOCountries(type)\n-         *\/\n-        static Set<String> retrieveISOCountryCodes(IsoCountryCode type) {\n-            return iso3166CodesMap.computeIfAbsent(type, IsoCountryCode::createCountryCodeSet);\n-        }\n+        PART3\n@@ -1007,1 +973,0 @@\n-\n@@ -1014,1 +979,1 @@\n-            return LocaleCache.cache(baseloc);\n+            return LOCALE_CACHE.get().computeIfAbsent(baseloc, LOCALE_CREATOR);\n@@ -1017,1 +982,1 @@\n-            return LocaleCache.cache(key);\n+            return LOCALE_CACHE.get().computeIfAbsent(key, LOCALE_CREATOR);\n@@ -1021,9 +986,7 @@\n-    private static final class LocaleCache implements Function<Object, Locale> {\n-        private static final ReferencedKeyMap<Object, Locale> LOCALE_CACHE\n-                = ReferencedKeyMap.create(true, ReferencedKeyMap.concurrentHashMapSupplier());\n-\n-        private static final Function<Object, Locale> LOCALE_CREATOR = new LocaleCache();\n-\n-        public static Locale cache(Object key) {\n-            return LOCALE_CACHE.computeIfAbsent(key, LOCALE_CREATOR);\n-        }\n+    private static final Supplier<ReferencedKeyMap<Object, Locale>> LOCALE_CACHE =\n+            StableValue.supplier(new Supplier<>() {\n+                @Override\n+                public ReferencedKeyMap<Object, Locale> get() {\n+                    return ReferencedKeyMap.create(true, ReferencedKeyMap.concurrentHashMapSupplier());\n+                }\n+            });\n@@ -1031,0 +994,1 @@\n+    private static final Function<Object, Locale> LOCALE_CREATOR = new Function<>() {\n@@ -1039,1 +1003,1 @@\n-    }\n+    };\n@@ -1304,6 +1268,2 @@\n-        if (isoCountries == null) {\n-            isoCountries = getISO2Table(LocaleISOData.isoCountryTable);\n-        }\n-        String[] result = new String[isoCountries.length];\n-        System.arraycopy(isoCountries, 0, result, 0, isoCountries.length);\n-        return result;\n+        String[] countries = LocaleISOData.ISO_3166_1_ALPHA2.get();\n+        return Arrays.copyOf(countries, countries.length);\n@@ -1313,1 +1273,1 @@\n-     * {@return a {@code Set} of ISO3166 country codes for the specified type}\n+     * {@return an unmodifiable {@code Set} of ISO3166 country codes for the specified type}\n@@ -1322,1 +1282,5 @@\n-        return IsoCountryCode.retrieveISOCountryCodes(type);\n+        return switch (type) {\n+            case PART1_ALPHA2 -> Set.of(LocaleISOData.ISO_3166_1_ALPHA2.get());\n+            case PART1_ALPHA3 -> LocaleISOData.ISO_3166_1_ALPHA3.get();\n+            case PART3 -> LocaleISOData.ISO_3166_3.get();\n+        };\n@@ -1342,16 +1306,2 @@\n-        String[] languages = Locale.isoLanguages;\n-        if (languages == null) {\n-            Locale.isoLanguages = languages = getISO2Table(LocaleISOData.isoLanguageTable);\n-        }\n-        String[] result = new String[languages.length];\n-        System.arraycopy(languages, 0, result, 0, languages.length);\n-        return result;\n-    }\n-\n-    private static String[] getISO2Table(String table) {\n-        int len = table.length() \/ 5;\n-        String[] isoTable = new String[len];\n-        for (int i = 0, j = 0; i < len; i++, j += 5) {\n-            isoTable[i] = table.substring(j, j + 2);\n-        }\n-        return isoTable;\n+        String[] languages = LocaleISOData.ISO_639.get();\n+        return Arrays.copyOf(languages, languages.length);\n@@ -1686,4 +1636,2 @@\n-        String lTag = this.languageTag;\n-        if (lTag != null) {\n-            return lTag;\n-        }\n+        return languageTag.get();\n+    }\n@@ -1691,0 +1639,1 @@\n+    private String computeLanguageTag() {\n@@ -1692,1 +1641,1 @@\n-        StringBuilder buf = new StringBuilder();\n+        StringBuilder bldr = new StringBuilder();\n@@ -1694,1 +1643,1 @@\n-        String subtag = tag.getLanguage();\n+        String subtag = tag.language();\n@@ -1696,1 +1645,1 @@\n-            buf.append(LanguageTag.canonicalizeLanguage(subtag));\n+            bldr.append(LanguageTag.canonicalizeLanguage(subtag));\n@@ -1699,1 +1648,1 @@\n-        subtag = tag.getScript();\n+        subtag = tag.script();\n@@ -1701,2 +1650,2 @@\n-            buf.append(LanguageTag.SEP);\n-            buf.append(LanguageTag.canonicalizeScript(subtag));\n+            bldr.append(LanguageTag.SEP);\n+            bldr.append(LanguageTag.canonicalizeScript(subtag));\n@@ -1705,1 +1654,1 @@\n-        subtag = tag.getRegion();\n+        subtag = tag.region();\n@@ -1707,2 +1656,2 @@\n-            buf.append(LanguageTag.SEP);\n-            buf.append(LanguageTag.canonicalizeRegion(subtag));\n+            bldr.append(LanguageTag.SEP);\n+            bldr.append(LanguageTag.canonicalizeRegion(subtag));\n@@ -1711,1 +1660,1 @@\n-        List<String>subtags = tag.getVariants();\n+        List<String>subtags = tag.variants();\n@@ -1713,1 +1662,1 @@\n-            buf.append(LanguageTag.SEP);\n+            bldr.append(LanguageTag.SEP);\n@@ -1715,1 +1664,1 @@\n-            buf.append(s);\n+            bldr.append(s);\n@@ -1718,1 +1667,1 @@\n-        subtags = tag.getExtensions();\n+        subtags = tag.extensions();\n@@ -1720,2 +1669,2 @@\n-            buf.append(LanguageTag.SEP);\n-            buf.append(LanguageTag.canonicalizeExtension(s));\n+            bldr.append(LanguageTag.SEP);\n+            bldr.append(LanguageTag.canonicalizeExtension(s));\n@@ -1724,1 +1673,1 @@\n-        subtag = tag.getPrivateuse();\n+        subtag = tag.privateuse();\n@@ -1726,2 +1675,2 @@\n-            if (buf.length() > 0) {\n-                buf.append(LanguageTag.SEP);\n+            if (bldr.length() > 0) {\n+                bldr.append(LanguageTag.SEP);\n@@ -1729,1 +1678,1 @@\n-            buf.append(LanguageTag.PRIVATEUSE).append(LanguageTag.SEP);\n+            bldr.append(LanguageTag.PRIVATEUSE).append(LanguageTag.SEP);\n@@ -1731,1 +1680,1 @@\n-            buf.append(subtag);\n+            bldr.append(subtag);\n@@ -1734,7 +1683,1 @@\n-        String langTag = buf.toString();\n-        synchronized (this) {\n-            if (this.languageTag == null) {\n-                this.languageTag = langTag;\n-            }\n-        }\n-        return langTag;\n+        return bldr.toString();\n@@ -1747,1 +1690,1 @@\n-     * that adheres to section 2.1.1. Formatting of Language Tags of RFC5646.\n+     * that adheres to section 2.1.1. Formatting of Language Tags of RFC 5646.\n@@ -1754,1 +1697,1 @@\n-     * legacy tags, (defined as \"grandfathered\" in RFC5646) are not always well-formed, this method\n+     * legacy tags, (defined as \"grandfathered\" in RFC 5646) are not always well-formed, this method\n@@ -1780,1 +1723,1 @@\n-     * of RFC5646).\n+     * of RFC 5646).\n@@ -1786,1 +1729,1 @@\n-     *       RFC5646 2.1. Syntax\n+     *       RFC 5646: 2.1. Syntax\n@@ -1788,1 +1731,1 @@\n-     *       RFC5646 2.1.1. Formatting of Language Tags\n+     *       RFC 5646: 2.1.1. Formatting of Language Tags\n@@ -1803,1 +1746,1 @@\n-     * <p>The following <b>conversions<\/b> are performed:<ul>\n+     * <p>The following <b id=\"langtag_conversions\">conversions<\/b> are performed:<ul>\n@@ -1829,3 +1772,6 @@\n-     * <li>When the languageTag argument contains an extlang subtag,\n-     * the first such subtag is used as the language, and the primary\n-     * language subtag and other extlang subtags are ignored:\n+     * <li> BCP 47 language tags permit up to three extlang subtags. However,\n+     * the second and third extlang subtags are always ignored. As such,\n+     * the first extlang subtag in {@code languageTag} is used as the language,\n+     * and the primary language subtag and other extlang subtags are ignored.\n+     * Language tags that exceed three extlang subtags are considered\n+     * ill-formed starting at the offending extlang subtag.\n@@ -1836,0 +1782,3 @@\n+     *     Locale.forLanguageTag(\"zh-yue-gan-cmn-czh-CN\").toString();\n+     *     \/\/ returns \"yue\"; \"czh\" exceeds the extlang limit, and subsequent\n+     *     \/\/ subtags are considered ill-formed\n@@ -1958,1 +1907,1 @@\n-        String language3 = getISO3Code(lang, LocaleISOData.isoLanguageTable);\n+        String language3 = LocaleISOData.getISO3LangCode(lang);\n@@ -1980,1 +1929,1 @@\n-        String country3 = getISO3Code(baseLocale.getRegion(), LocaleISOData.isoCountryTable);\n+        String country3 = LocaleISOData.getISO3CtryCode(baseLocale.getRegion());\n@@ -1988,21 +1937,0 @@\n-    private static String getISO3Code(String iso2Code, String table) {\n-        int codeLength = iso2Code.length();\n-        if (codeLength == 0) {\n-            return \"\";\n-        }\n-\n-        int tableLength = table.length();\n-        int index = tableLength;\n-        if (codeLength == 2) {\n-            char c1 = iso2Code.charAt(0);\n-            char c2 = iso2Code.charAt(1);\n-            for (index = 0; index < tableLength; index += 5) {\n-                if (table.charAt(index) == c1\n-                    && table.charAt(index + 1) == c2) {\n-                    break;\n-                }\n-            }\n-        }\n-        return index < tableLength ? table.substring(index + 2, index + 5) : null;\n-    }\n-\n@@ -2390,1 +2318,7 @@\n-    private transient volatile String languageTag;\n+    private final transient Supplier<String> languageTag =\n+            StableValue.supplier(new Supplier<>() {\n+                @Override\n+                public String get() {\n+                    return computeLanguageTag();\n+                }\n+            });\n@@ -2584,4 +2518,0 @@\n-    private static volatile String[] isoLanguages;\n-\n-    private static volatile String[] isoCountries;\n-\n@@ -2790,0 +2720,3 @@\n+         * <p>See {@link Locale##langtag_conversions converions} for a full list\n+         * of conversions that are performed on {@code languageTag}.\n+         *\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":81,"deletions":148,"binary":false,"changes":229,"status":"modified"},{"patch":"@@ -319,0 +319,4 @@\n+    \/\/ Parse the specified cipher transformation for algorithm and the\n+    \/\/ optional mode and padding. If the transformation contains only\n+    \/\/ algorithm, then only algorithm is returned. Otherwise, the\n+    \/\/ transformation must contain all 3 and they must be non-empty.\n@@ -325,1 +329,1 @@\n-         * array containing the components of a cipher transformation:\n+         * Components of a cipher transformation:\n@@ -327,3 +331,3 @@\n-         * index 0: algorithm component (e.g., AES)\n-         * index 1: feedback component (e.g., CFB)\n-         * index 2: padding component (e.g., PKCS5Padding)\n+         * 1) algorithm component (e.g., AES)\n+         * 2) feedback component (e.g., CFB) - optional\n+         * 3) padding component (e.g., PKCS5Padding) - optional\n@@ -331,1 +335,0 @@\n-        String[] parts = { \"\", \"\", \"\" };\n@@ -340,3 +343,11 @@\n-        if (endIdx == -1) {\n-            \/\/ algorithm\n-            parts[0] = transformation.trim();\n+\n+        boolean algorithmOnly = (endIdx == -1);\n+        String algo = (algorithmOnly ? transformation.trim() :\n+                transformation.substring(0, endIdx).trim());\n+        if (algo.isEmpty()) {\n+            throw new NoSuchAlgorithmException(\"Invalid transformation: \" +\n+                                   \"algorithm not specified-\"\n+                                   + transformation);\n+        }\n+        if (algorithmOnly) { \/\/ done\n+            return new String[] { algo };\n@@ -344,2 +355,1 @@\n-            \/\/ algorithm\/mode\/padding\n-            parts[0] = transformation.substring(0, endIdx).trim();\n+            \/\/ continue parsing mode and padding\n@@ -352,6 +362,6 @@\n-            parts[1] = transformation.substring(startIdx, endIdx).trim();\n-            parts[2] = transformation.substring(endIdx+1).trim();\n-        }\n-        if (parts[0].isEmpty()) {\n-            throw new NoSuchAlgorithmException(\"Invalid transformation: \" +\n-                                   \"algorithm not specified-\"\n+            String mode = transformation.substring(startIdx, endIdx).trim();\n+            String padding = transformation.substring(endIdx+1).trim();\n+            \/\/ ensure mode and padding are specified\n+            if (mode.isEmpty() || padding.isEmpty()) {\n+                throw new NoSuchAlgorithmException(\"Invalid transformation: \" +\n+                                   \"missing mode and\/or padding-\"\n@@ -359,0 +369,2 @@\n+            }\n+            return new String[] { algo, mode, padding };\n@@ -360,1 +372,0 @@\n-        return parts;\n@@ -456,5 +467,1 @@\n-        String alg = parts[0];\n-        String mode = parts[1];\n-        String pad = parts[2];\n-\n-        if ((mode.length() == 0) && (pad.length() == 0)) {\n+        if (parts.length == 1) {\n@@ -462,2 +469,1 @@\n-            Transform tr = new Transform(alg, \"\", null, null);\n-            return Collections.singletonList(tr);\n+            return List.of(new Transform(parts[0], \"\", null, null));\n@@ -465,7 +471,7 @@\n-            \/\/ Algorithm w\/ at least mode or padding or both\n-            List<Transform> list = new ArrayList<>(4);\n-            list.add(new Transform(alg, \"\/\" + mode + \"\/\" + pad, null, null));\n-            list.add(new Transform(alg, \"\/\" + mode, null, pad));\n-            list.add(new Transform(alg, \"\/\/\" + pad, mode, null));\n-            list.add(new Transform(alg, \"\", mode, pad));\n-            return list;\n+            \/\/ Algorithm w\/ both mode and padding\n+            return List.of(\n+                    new Transform(parts[0], \"\/\" + parts[1] + \"\/\" + parts[2],\n+                    null, null),\n+                    new Transform(parts[0], \"\/\" + parts[1], null, parts[2]),\n+                    new Transform(parts[0], \"\/\/\" + parts[2], parts[1], null),\n+                    new Transform(parts[0], \"\", parts[1], parts[2]));\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/Cipher.java","additions":37,"deletions":31,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,6 +47,5 @@\n-\/**\n- * ParserVerifier performs selected checks of the class file format according to\n- * {@jvms 4.8 Format Checking}\n- *\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/classFileParser.cpp\">hotspot\/share\/classfile\/classFileParser.cpp<\/a>\n- *\/\n+\/\/\/ ParserVerifier performs selected checks of the class file format according to\n+\/\/\/ {@jvms 4.8 Format Checking}.\n+\/\/\/\n+\/\/\/ From `classFileParser.cpp`.\n+\/\/\/\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/ParserVerifier.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,4 +32,1 @@\n-\/**\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/interpreter\/bytecodes.hpp\">hotspot\/share\/interpreter\/bytecodes.hpp<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/interpreter\/bytecodes.cpp\">hotspot\/share\/interpreter\/bytecodes.cpp<\/a>\n- *\/\n+\/\/\/ From `bytecodes.cpp`.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationBytecodes.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,4 +29,1 @@\n-\/**\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/stackMapFrame.hpp\">hotspot\/share\/classfile\/stackMapFrame.hpp<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/stackMapFrame.cpp\">hotspot\/share\/classfile\/stackMapFrame.cpp<\/a>\n- *\/\n+\/\/\/ From `stackMapFrame.cpp`.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationFrame.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+\/\/\/ Relevant parts from `signatures.cpp`, such as `SignatureStream`.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationSignature.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,3 @@\n+import java.util.ArrayList;\n+import java.util.List;\n+\n@@ -31,4 +34,1 @@\n-\/**\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/stackMapTable.hpp\">hotspot\/share\/classfile\/stackMapTable.hpp<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/stackMapTable.cpp\">hotspot\/share\/classfile\/stackMapTable.cpp<\/a>\n- *\/\n+\/\/\/ From `stackMapTable.cpp`.\n@@ -39,1 +39,1 @@\n-    private final VerificationFrame[] _frame_array;\n+    private final List<VerificationFrame> _frame_array;\n@@ -47,1 +47,1 @@\n-        return _frame_array[index].offset();\n+        return _frame_array.get(index).offset();\n@@ -79,1 +79,1 @@\n-    VerificationTable(byte[] stackmap_data, VerificationFrame init_frame, int max_locals, int max_stack, byte[] code_data, int code_len,\n+    VerificationTable(StackMapReader reader,\n@@ -82,4 +82,3 @@\n-        var reader = new StackMapReader(stackmap_data, code_data, code_len, cp, v);\n-        _code_length = code_len;\n-        _frame_count = reader.get_frame_count();\n-        _frame_array = new VerificationFrame[_frame_count];\n+        _code_length = reader.code_length();\n+        int _frame_count = reader.get_frame_count();\n+        _frame_array = new ArrayList<>(_frame_count);\n@@ -87,7 +86,4 @@\n-            VerificationFrame pre_frame = init_frame;\n-            for (int i = 0; i < _frame_count; i++) {\n-                VerificationFrame frame = reader.next(pre_frame, i == 0, max_locals, max_stack);\n-                _frame_array[i] = frame;\n-                int offset = frame.offset();\n-                if (offset >= code_len || code_data[offset] == 0) {\n-                    _verifier.verifyError(\"StackMapTable error: bad offset\");\n+            while (!reader.at_end()) {\n+                VerificationFrame frame = reader.next();\n+                if (frame != null) {\n+                    _frame_array.add(frame);\n@@ -95,1 +91,0 @@\n-                pre_frame = frame;\n@@ -99,0 +94,1 @@\n+        this._frame_count = _frame_array.size();\n@@ -104,1 +100,1 @@\n-            if (_frame_array[i].offset() == offset) {\n+            if (_frame_array.get(i).offset() == offset) {\n@@ -120,1 +116,1 @@\n-        VerificationFrame stackmap_frame = _frame_array[frame_index];\n+        VerificationFrame stackmap_frame = _frame_array.get(frame_index);\n@@ -154,0 +150,4 @@\n+        private int _parsed_frame_count;\n+        private VerificationFrame _prev_frame;\n+        char _max_locals, _max_stack;\n+        boolean _first;\n@@ -170,0 +170,27 @@\n+        public VerificationFrame prev_frame() {\n+            return _prev_frame;\n+        }\n+\n+        public byte[] code_data() {\n+            return _code_data;\n+        }\n+\n+        public int code_length() {\n+            return _code_length;\n+        }\n+\n+        public boolean at_end() {\n+            return _stream.at_end();\n+        }\n+\n+        public VerificationFrame next() {\n+            _parsed_frame_count++;\n+            check_size();\n+            VerificationFrame frame = next_helper();\n+            if (frame != null) {\n+                check_offset(frame);\n+                _prev_frame = frame;\n+            }\n+            return frame;\n+        }\n+\n@@ -171,2 +198,2 @@\n-            if (!_stream.at_end()) {\n-                _verifier.classError(\"wrong attribute size\");\n+            if (_frame_count != _parsed_frame_count) {\n+                _verifier.verifyError(\"wrong attribute size\");\n@@ -178,1 +205,3 @@\n-        public StackMapReader(byte[] stackmapData, byte[] code_data, int code_len, VerificationWrapper.ConstantPoolWrapper cp, VerifierImpl context) {\n+        public StackMapReader(byte[] stackmapData, byte[] code_data, int code_len,\n+                              VerificationFrame init_frame, char max_locals, char max_stack,\n+                              VerificationWrapper.ConstantPoolWrapper cp, VerifierImpl context) {\n@@ -181,0 +210,7 @@\n+            _code_data = code_data;\n+            _code_length = code_len;\n+            _parsed_frame_count = 0;\n+            _prev_frame = init_frame;\n+            _max_locals = max_locals;\n+            _max_stack = max_stack;\n+            _first = true;\n@@ -182,0 +218,1 @@\n+                _cp = cp;\n@@ -184,0 +221,1 @@\n+                _cp = null;\n@@ -186,3 +224,13 @@\n-            _code_data = code_data;\n-            _code_length = code_len;\n-            _cp = cp;\n+        }\n+\n+        void check_offset(VerificationFrame frame) {\n+            int offset = frame.offset();\n+            if (offset >= _code_length || _code_data[offset] == 0) {\n+                _verifier.verifyError(\"StackMapTable error: bad offset\");\n+            }\n+        }\n+\n+        void check_size() {\n+            if (_frame_count < _parsed_frame_count) {\n+                _verifier.verifyError(\"wrong attribute size\");\n+            }\n@@ -235,1 +283,1 @@\n-        public VerificationFrame next(VerificationFrame pre_frame, boolean first, int max_locals, int max_stack) {\n+        VerificationFrame next_helper() {\n@@ -241,1 +289,1 @@\n-                if (first) {\n+                if (_first) {\n@@ -243,2 +291,2 @@\n-                    if (pre_frame.locals_size() > 0) {\n-                        locals = new VerificationType[pre_frame.locals_size()];\n+                    if (_prev_frame.locals_size() > 0) {\n+                        locals = new VerificationType[_prev_frame.locals_size()];\n@@ -247,2 +295,2 @@\n-                    offset = pre_frame.offset() + frame_type + 1;\n-                    locals = pre_frame.locals();\n+                    offset = _prev_frame.offset() + frame_type + 1;\n+                    locals = _prev_frame.locals();\n@@ -250,3 +298,3 @@\n-                frame = new VerificationFrame(offset, pre_frame.flags(), pre_frame.locals_size(), 0, max_locals, max_stack, locals, null, _verifier);\n-                if (first && locals != null) {\n-                    frame.copy_locals(pre_frame);\n+                frame = new VerificationFrame(offset, _prev_frame.flags(), _prev_frame.locals_size(), 0, _max_locals, _max_stack, locals, null, _verifier);\n+                if (_first && locals != null) {\n+                    frame.copy_locals(_prev_frame);\n@@ -254,0 +302,1 @@\n+                _first = false;\n@@ -257,1 +306,1 @@\n-                if (first) {\n+                if (_first) {\n@@ -259,2 +308,2 @@\n-                    if (pre_frame.locals_size() > 0) {\n-                        locals = new VerificationType[pre_frame.locals_size()];\n+                    if (_prev_frame.locals_size() > 0) {\n+                        locals = new VerificationType[_prev_frame.locals_size()];\n@@ -263,2 +312,2 @@\n-                    offset = pre_frame.offset() + frame_type - 63;\n-                    locals = pre_frame.locals();\n+                    offset = _prev_frame.offset() + frame_type - 63;\n+                    locals = _prev_frame.locals();\n@@ -273,4 +322,4 @@\n-                check_verification_type_array_size(stack_size, max_stack);\n-                frame = new VerificationFrame(offset, pre_frame.flags(), pre_frame.locals_size(), stack_size, max_locals, max_stack, locals, stack, _verifier);\n-                if (first && locals != null) {\n-                    frame.copy_locals(pre_frame);\n+                check_verification_type_array_size(stack_size, _max_stack);\n+                frame = new VerificationFrame(offset, _prev_frame.flags(), _prev_frame.locals_size(), stack_size, _max_locals, _max_stack, locals, stack, _verifier);\n+                if (_first && locals != null) {\n+                    frame.copy_locals(_prev_frame);\n@@ -278,0 +327,1 @@\n+                _first = false;\n@@ -285,1 +335,1 @@\n-                if (first) {\n+                if (_first) {\n@@ -287,2 +337,2 @@\n-                    if (pre_frame.locals_size() > 0) {\n-                        locals = new VerificationType[pre_frame.locals_size()];\n+                    if (_prev_frame.locals_size() > 0) {\n+                        locals = new VerificationType[_prev_frame.locals_size()];\n@@ -291,2 +341,2 @@\n-                    offset = pre_frame.offset() + offset_delta + 1;\n-                    locals = pre_frame.locals();\n+                    offset = _prev_frame.offset() + offset_delta + 1;\n+                    locals = _prev_frame.locals();\n@@ -301,4 +351,4 @@\n-                check_verification_type_array_size(stack_size, max_stack);\n-                frame = new VerificationFrame(offset, pre_frame.flags(), pre_frame.locals_size(), stack_size, max_locals, max_stack, locals, stack, _verifier);\n-                if (first && locals != null) {\n-                    frame.copy_locals(pre_frame);\n+                check_verification_type_array_size(stack_size, _max_stack);\n+                frame = new VerificationFrame(offset, _prev_frame.flags(), _prev_frame.locals_size(), stack_size, _max_locals, _max_stack, locals, stack, _verifier);\n+                if (_first && locals != null) {\n+                    frame.copy_locals(_prev_frame);\n@@ -306,0 +356,1 @@\n+                _first = false;\n@@ -309,2 +360,2 @@\n-                locals = pre_frame.locals();\n-                int length = pre_frame.locals_size();\n+                locals = _prev_frame.locals();\n+                int length = _prev_frame.locals_size();\n@@ -313,1 +364,1 @@\n-                int flags = pre_frame.flags();\n+                int flags = _prev_frame.flags();\n@@ -316,1 +367,1 @@\n-                    check_verification_type_array_size(new_length, max_locals);\n+                    check_verification_type_array_size(new_length, _max_locals);\n@@ -325,1 +376,1 @@\n-                if (first) {\n+                if (_first) {\n@@ -333,1 +384,1 @@\n-                    offset = pre_frame.offset() + offset_delta + 1;\n+                    offset = _prev_frame.offset() + offset_delta + 1;\n@@ -335,3 +386,3 @@\n-                frame = new VerificationFrame(offset, flags, new_length, 0, max_locals, max_stack, locals, null, _verifier);\n-                if (first && locals != null) {\n-                    frame.copy_locals(pre_frame);\n+                frame = new VerificationFrame(offset, flags, new_length, 0, _max_locals, _max_stack, locals, null, _verifier);\n+                if (_first && locals != null) {\n+                    frame.copy_locals(_prev_frame);\n@@ -339,0 +390,1 @@\n+                _first = false;\n@@ -342,1 +394,1 @@\n-                int real_length = pre_frame.locals_size();\n+                int real_length = _prev_frame.locals_size();\n@@ -345,1 +397,1 @@\n-                VerificationType[] pre_locals = pre_frame.locals();\n+                VerificationType[] pre_locals = _prev_frame.locals();\n@@ -347,1 +399,1 @@\n-                for (i=0; i<pre_frame.locals_size(); i++) {\n+                for (i=0; i< _prev_frame.locals_size(); i++) {\n@@ -350,1 +402,1 @@\n-                int[] flags = new int[]{pre_frame.flags()};\n+                int[] flags = new int[]{_prev_frame.flags()};\n@@ -359,2 +411,2 @@\n-                check_verification_type_array_size(real_length, max_locals);\n-                if (first) {\n+                check_verification_type_array_size(real_length, _max_locals);\n+                if (_first) {\n@@ -363,1 +415,1 @@\n-                    offset = pre_frame.offset() + offset_delta + 1;\n+                    offset = _prev_frame.offset() + offset_delta + 1;\n@@ -365,1 +417,2 @@\n-                frame = new VerificationFrame(offset, flags[0], real_length, 0, max_locals, max_stack, locals, null, _verifier);\n+                frame = new VerificationFrame(offset, flags[0], real_length, 0, _max_locals, _max_stack, locals, null, _verifier);\n+                _first = false;\n@@ -380,1 +433,1 @@\n-                            locals[real_locals_size].to_category2_2nd(_verifier);\n+                                locals[real_locals_size].to_category2_2nd(_verifier);\n@@ -385,1 +438,1 @@\n-                check_verification_type_array_size(real_locals_size, max_locals);\n+                check_verification_type_array_size(real_locals_size, _max_locals);\n@@ -400,2 +453,2 @@\n-                check_verification_type_array_size(real_stack_size, max_stack);\n-                if (first) {\n+                check_verification_type_array_size(real_stack_size, _max_stack);\n+                if (_first) {\n@@ -404,1 +457,1 @@\n-                    offset = pre_frame.offset() + offset_delta + 1;\n+                    offset = _prev_frame.offset() + offset_delta + 1;\n@@ -406,1 +459,2 @@\n-                frame = new VerificationFrame(offset, flags[0], real_locals_size, real_stack_size, max_locals, max_stack, locals, stack, _verifier);\n+                frame = new VerificationFrame(offset, flags[0], real_locals_size, real_stack_size, _max_locals, _max_stack, locals, stack, _verifier);\n+                _first = false;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationTable.java","additions":132,"deletions":78,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,4 +38,1 @@\n-\/**\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/verificationType.hpp\">hotspot\/share\/classfile\/verificationType.hpp<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/verificationType.cpp\">hotspot\/share\/classfile\/verificationType.cpp<\/a>\n- *\/\n+\/\/\/ From `verificationType.cpp`.\n@@ -335,1 +332,1 @@\n-                        return is_reference_assignable_from(from, context);\n+                        return is_reference_assignable_from(from, context, null);\n@@ -382,1 +379,2 @@\n-    boolean resolve_and_check_assignability(ClassHierarchyImpl assignResolver, String name, String from_name, boolean from_is_array, boolean from_is_object) {\n+    boolean resolve_and_check_assignability(ClassHierarchyImpl assignResolver, String target_name, String from_name,\n+                                            boolean from_is_array, boolean from_is_object, boolean[] target_is_interface) {\n@@ -384,3 +382,9 @@\n-        var desc = Util.toClassDesc(name);\n-        if (assignResolver.isInterface(desc)) {\n-            return !from_is_array || \"java\/lang\/Cloneable\".equals(name) || \"java\/io\/Serializable\".equals(name);\n+        var targetClass = Util.toClassDesc(target_name);\n+        boolean isInterface = assignResolver.isInterface(targetClass);\n+\n+        if (target_is_interface != null) {\n+            target_is_interface[0] = isInterface;\n+        }\n+\n+        if (isInterface) {\n+            return !from_is_array || \"java\/lang\/Cloneable\".equals(target_name) || \"java\/io\/Serializable\".equals(target_name);\n@@ -388,1 +392,1 @@\n-            return assignResolver.isAssignableFrom(desc, Util.toClassDesc(from_name));\n+            return assignResolver.isAssignableFrom(targetClass, Util.toClassDesc(from_name));\n@@ -393,1 +397,1 @@\n-    boolean is_reference_assignable_from(VerificationType from, VerifierImpl context) {\n+    boolean is_reference_assignable_from(VerificationType from, VerifierImpl context, boolean[] target_is_interface) {\n@@ -405,1 +409,1 @@\n-            return resolve_and_check_assignability(clsTree, name(), from.name(), from.is_array(), from.is_object());\n+            return resolve_and_check_assignability(clsTree, name(), from.name(), from.is_array(), from.is_object(), target_is_interface);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationType.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,10 +45,6 @@\n-\/**\n- * VerifierImpl performs selected checks and verifications of the class file\n- * format according to {@jvms 4.8 Format Checking},\n- * {@jvms 4.9 Constraints on Java Virtual Machine code},\n- * {@jvms 4.10 Verification of class Files} and {@jvms 6.5 Instructions}\n- *\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/java.base\/share\/native\/include\/classfile_constants.h.template\">java.base\/share\/native\/include\/classfile_constants.h.template<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/verifier.hpp\">hotspot\/share\/classfile\/verifier.hpp<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/verifier.cpp\">hotspot\/share\/classfile\/verifier.cpp<\/a>\n- *\/\n+\/\/\/ VerifierImpl performs selected checks and verifications of the class file\n+\/\/\/ format according to {@jvms 4.8 Format Checking},\n+\/\/\/ {@jvms 4.9 Constraints on Java Virtual Machine code},\n+\/\/\/ {@jvms 4.10 Verification of class Files} and {@jvms 6.5 Instructions}\n+\/\/\/\n+\/\/\/ From `verifier.cpp`.\n@@ -145,5 +141,2 @@\n-        String name = klass.thisClassName();\n-        return !java_lang_Object.equals(name) &&\n-                !java_lang_Class.equals(name) &&\n-                !java_lang_String.equals(name) &&\n-                !java_lang_Throwable.equals(name);\n+        \/\/ 8330606 Not applicable here\n+        return true;\n@@ -326,1 +319,3 @@\n-        VerificationTable stackmap_table = new VerificationTable(stackmap_data, current_frame, max_locals, max_stack, code_data, code_length, cp, this);\n+        var reader = new VerificationTable.StackMapReader(stackmap_data, code_data, code_length, current_frame,\n+                (char) max_locals, (char) max_stack, cp, this);\n+        VerificationTable stackmap_table = new VerificationTable(reader, cp, this);\n@@ -1273,0 +1268,1 @@\n+                \/\/ 8267118 Not applicable here\n@@ -1356,1 +1352,1 @@\n-        if ((types & (1 << tag))== 0) {\n+        if (tag > JVM_CONSTANT_ExternalMax || (types & (1 << tag))== 0) {\n@@ -1435,2 +1431,2 @@\n-            keys = high - low + 1;\n-            if (keys < 0) {\n+            long keys64 = ((long) high - low) + 1;\n+            if (keys64 > 65535) {  \/\/ Max code length\n@@ -1439,0 +1435,1 @@\n+            keys = (int) keys64;\n@@ -1495,0 +1492,1 @@\n+                \/\/ 8270398 Not applicable here\n@@ -1646,3 +1644,16 @@\n-            boolean have_imr_indirect = cp.tagAt(index) == JVM_CONSTANT_InterfaceMethodref;\n-            boolean subtype = ref_class_type.is_assignable_from(current_type(), this);\n-            if (!subtype) {\n+\n+            \/\/ We know it is not current class, direct superinterface or immediate superclass. That means it\n+            \/\/ could be:\n+            \/\/ - a totally unrelated class or interface\n+            \/\/ - an indirect superinterface\n+            \/\/ - an indirect superclass (including Object)\n+            \/\/ We use the assignability test to see if it is a superclass, or else an interface, and keep track\n+            \/\/ of the latter. Note that subtype can be true if we are dealing with an interface that is not actually\n+            \/\/ implemented as assignability treats all interfaces as Object.\n+\n+            boolean[] is_interface = {false}; \/\/ This can only be set true if the assignability check will return true\n+                                              \/\/ and we loaded the class. For any other \"true\" returns (e.g. same class\n+                                              \/\/ or Object) we either can't get here (same class already excluded above)\n+                                              \/\/ or we know it is not an interface (i.e. Object).\n+            boolean subtype = ref_class_type.is_reference_assignable_from(current_type(), this, is_interface);\n+            if (!subtype) {  \/\/ Totally unrelated class\n@@ -1650,2 +1661,6 @@\n-            } else if (have_imr_indirect) {\n-                verifyError(\"Bad invokespecial instruction: interface method reference is in an indirect superinterface.\");\n+            } else {\n+                \/\/ Indirect superclass (including Object), indirect interface, or unrelated interface.\n+                \/\/ Any interface use is an error.\n+                if (is_interface[0]) {\n+                    verifyError(\"Bad invokespecial instruction: interface method to invoke is not in a direct superinterface.\");\n+                }\n@@ -1820,1 +1835,1 @@\n-            verifyError(\"Method expects a return value\");\n+            verifyError(\"Method does not expect a return value\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerifierImpl.java","additions":41,"deletions":26,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -0,0 +1,20 @@\n+The Class-File Verifier\n+===\n+The Class-File API provides a verifier, a debug utility that reports as many\n+verification errors as possible in a class file.\n+\n+Currently, the verifier closely follows the C++ code that implements the hotspot\n+verifier. However, there are a few differences:\n+- The Class-File API verifier tries to collect as many errors as possible, while\n+  the hotspot verifier fails fast.\n+- The hotspot verifier has access to other classes and can check access control;\n+  the Class-File API verifier cannot.\n+\n+Thus, this verifier cannot serve as a complete implementation of the verifier\n+specified in the JVMS because it has no access to other class files or loaded\n+classes.  However, it is still in our interest to make this verifier up to date:\n+for example, this should not fail upon encountering new language features, and\n+should at best include all new checks hotspot has as long as the required\n+information are accessible to the Class-File API.\n+\n+Last sync: jdk-26+5, July 3rd 2025\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/verifier.md","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.ref.Cleaner;\n@@ -31,0 +30,1 @@\n+import sun.nio.Cleaner;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,150 +1,0 @@\n-\/*\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.ref;\n-\n-import java.lang.ref.*;\n-\n-\n-\/**\n- * General-purpose phantom-reference-based cleaners.\n- *\n- * <p> Cleaners are a lightweight and more robust alternative to finalization.\n- * They are lightweight because they are not created by the VM and thus do not\n- * require a JNI upcall to be created, and because their cleanup code is\n- * invoked directly by the reference-handler thread rather than by the\n- * finalizer thread.  They are more robust because they use phantom references,\n- * the weakest type of reference object, thereby avoiding the nasty ordering\n- * problems inherent to finalization.\n- *\n- * <p> A cleaner tracks a referent object and encapsulates a thunk of arbitrary\n- * cleanup code.  Some time after the GC detects that a cleaner's referent has\n- * become phantom-reachable, the reference-handler thread will run the cleaner.\n- * Cleaners may also be invoked directly; they are thread safe and ensure that\n- * they run their thunks at most once.\n- *\n- * <p> Cleaners are not a replacement for finalization.  They should be used\n- * only when the cleanup code is extremely simple and straightforward.\n- * Nontrivial cleaners are inadvisable since they risk blocking the\n- * reference-handler thread and delaying further cleanup and finalization.\n- *\n- *\n- * @author Mark Reinhold\n- *\/\n-\n-public class Cleaner\n-    extends PhantomReference<Object>\n-{\n-\n-    \/\/ Dummy reference queue, needed because the PhantomReference constructor\n-    \/\/ insists that we pass a queue.  Nothing will ever be placed on this queue\n-    \/\/ since the reference handler invokes cleaners explicitly.\n-    \/\/\n-    private static final ReferenceQueue<Object> dummyQueue = new ReferenceQueue<>();\n-\n-    \/\/ Doubly-linked list of live cleaners, which prevents the cleaners\n-    \/\/ themselves from being GC'd before their referents\n-    \/\/\n-    private static Cleaner first = null;\n-\n-    private Cleaner\n-        next = null,\n-        prev = null;\n-\n-    private static synchronized Cleaner add(Cleaner cl) {\n-        if (first != null) {\n-            cl.next = first;\n-            first.prev = cl;\n-        }\n-        first = cl;\n-        return cl;\n-    }\n-\n-    private static synchronized boolean remove(Cleaner cl) {\n-\n-        \/\/ If already removed, do nothing\n-        if (cl.next == cl)\n-            return false;\n-\n-        \/\/ Update list\n-        if (first == cl) {\n-            if (cl.next != null)\n-                first = cl.next;\n-            else\n-                first = cl.prev;\n-        }\n-        if (cl.next != null)\n-            cl.next.prev = cl.prev;\n-        if (cl.prev != null)\n-            cl.prev.next = cl.next;\n-\n-        \/\/ Indicate removal by pointing the cleaner to itself\n-        cl.next = cl;\n-        cl.prev = cl;\n-        return true;\n-\n-    }\n-\n-    private final Runnable thunk;\n-\n-    private Cleaner(Object referent, Runnable thunk) {\n-        super(referent, dummyQueue);\n-        this.thunk = thunk;\n-    }\n-\n-    \/**\n-     * Creates a new cleaner.\n-     *\n-     * @param  ob the referent object to be cleaned\n-     * @param  thunk\n-     *         The cleanup code to be run when the cleaner is invoked.  The\n-     *         cleanup code is run directly from the reference-handler thread,\n-     *         so it should be as simple and straightforward as possible.\n-     *\n-     * @return  The new cleaner\n-     *\/\n-    public static Cleaner create(Object ob, Runnable thunk) {\n-        if (thunk == null)\n-            return null;\n-        return add(new Cleaner(ob, thunk));\n-    }\n-\n-    \/**\n-     * Runs this cleaner, if it has not been run before.\n-     *\/\n-    public void clean() {\n-        if (!remove(this))\n-            return;\n-        try {\n-            thunk.run();\n-        } catch (final Throwable x) {\n-            if (System.err != null) {\n-                new Error(\"Cleaner terminated abnormally\", x)\n-                        .printStackTrace();\n-            }\n-            System.exit(1);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/Cleaner.java","additions":0,"deletions":150,"binary":false,"changes":150,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -494,2 +494,2 @@\n-                  Object base, long offset,\n-                  W index_vector,\n+                  int indexLength, Object base, long offset,\n+                  W indexVector1, W indexVector2, W indexVector3, W indexVector4,\n@@ -561,2 +561,2 @@\n-                      Object base, long offset,\n-                      W index_vector,\n+                      int indexLength, Object base, long offset,\n+                      W indexVector,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio;\n+\n+\/**\n+ * {@code Cleaner} represents an object and a cleaning action.\n+ *\/\n+public interface Cleaner {\n+    \/**\n+     * Unregisters the cleaner and invokes the cleaning action.\n+     * The cleaner's cleaning action is invoked at most once,\n+     * regardless of the number of calls to {@code clean}.\n+     *\/\n+    void clean();\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/Cleaner.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import jdk.internal.ref.Cleaner;\n+import sun.nio.Cleaner;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DirectBuffer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,0 @@\n-import jdk.internal.ref.Cleaner;\n@@ -66,0 +65,1 @@\n+import sun.nio.Cleaner;\n@@ -267,1 +267,1 @@\n-        long start = 0;\n+        long start = FileReadEvent.timestamp();\n@@ -269,1 +269,0 @@\n-            start = FileReadEvent.timestamp();\n@@ -272,8 +271,1 @@\n-            long duration = FileReadEvent.timestamp() - start;\n-            if (FileReadEvent.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n+            FileReadEvent.offer(start, path, bytesRead);\n@@ -329,1 +321,1 @@\n-        long start = 0;\n+        long start = FileReadEvent.timestamp();\n@@ -331,1 +323,0 @@\n-            start = FileReadEvent.timestamp();\n@@ -334,8 +325,1 @@\n-            long duration = FileReadEvent.timestamp() - start;\n-            if (FileReadEvent.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n+            FileReadEvent.offer(start, path, bytesRead);\n@@ -388,1 +372,1 @@\n-        long start = 0;\n+        long start = FileWriteEvent.timestamp();\n@@ -390,1 +374,0 @@\n-            start = FileWriteEvent.timestamp();\n@@ -393,5 +376,1 @@\n-            long duration = FileWriteEvent.timestamp() - start;\n-            if (FileWriteEvent.shouldCommit(duration)) {\n-                long bytes = bytesWritten > 0 ? bytesWritten : 0;\n-                FileWriteEvent.commit(start, duration, path, bytes);\n-            }\n+            FileWriteEvent.offer(start, path, bytesWritten);\n@@ -444,1 +423,1 @@\n-        long start = 0;\n+        long start = FileWriteEvent.timestamp();\n@@ -446,1 +425,0 @@\n-            start = FileWriteEvent.timestamp();\n@@ -449,5 +427,1 @@\n-            long duration = FileWriteEvent.timestamp() - start;\n-            if (FileWriteEvent.shouldCommit(duration)) {\n-                long bytes = bytesWritten > 0 ? bytesWritten : 0;\n-                FileWriteEvent.commit(start, duration, path, bytes);\n-            }\n+            FileWriteEvent.offer(start, path, bytesWritten);\n@@ -1202,1 +1176,1 @@\n-        long start = 0;\n+        long start = FileReadEvent.timestamp();\n@@ -1204,1 +1178,0 @@\n-            start = FileReadEvent.timestamp();\n@@ -1207,8 +1180,1 @@\n-            long duration = FileReadEvent.timestamp() - start;\n-            if (FileReadEvent.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n+            FileReadEvent.offer(start, path, bytesRead);\n@@ -1274,1 +1240,1 @@\n-        long start = 0;\n+        long start = FileWriteEvent.timestamp();\n@@ -1276,1 +1242,0 @@\n-            start = FileWriteEvent.timestamp();\n@@ -1279,5 +1244,1 @@\n-            long duration = FileWriteEvent.timestamp() - start;\n-            if (FileWriteEvent.shouldCommit(duration)) {\n-                long bytes = bytesWritten > 0 ? bytesWritten : 0;\n-                FileWriteEvent.commit(start, duration, path, bytes);\n-            }\n+            FileWriteEvent.offer(start, path, bytesWritten);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":14,"deletions":53,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -1452,3 +1452,4 @@\n-        (JVM) shuts down. This option is not available if the disk option is set\n-        to false. For a list of available views, see `jfr help view`. By default,\n-        no report is generated.\n+        (JVM) shuts down. To specify more than one view, use the report-on-exit\n+        parameter repeatedly. This option is not available if the disk option\n+        is set to false. For a list of available views, see `jfr help view`.\n+        By default, no report is generated.\n@@ -1517,0 +1518,9 @@\n+`-XX:+UseCompactObjectHeaders`\n+:   Enables compact object headers. By default, this option is disabled.\n+    Enabling this option reduces memory footprint in the Java heap by\n+    4 bytes per object (on average) and often improves performance.\n+\n+    The feature remains disabled by default while it continues to be evaluated.\n+    In a future release it is expected to be enabled by default, and\n+    eventually will be the only mode of operation.\n+\n@@ -2703,3 +2713,0 @@\n-`-XX:+ParallelRefProcEnabled`\n-:   Enables parallel reference processing. By default, this option is disabled.\n-\n@@ -2901,0 +2908,8 @@\n+`-XX:+ParallelRefProcEnabled`\n+:   Enables parallel reference processing. By default, collectors employing multiple\n+    threads perform parallel reference processing if the number of parallel threads\n+    to use is larger than one.\n+    The option is available only when the throughput or G1 garbage collector is used\n+    (`-XX:+UseParallelGC` or `-XX:+UseG1GC`). Other collectors employing multiple\n+    threads always perform reference processing in parallel.\n+\n@@ -2915,62 +2930,1 @@\n-These `java` options have been removed in JDK @@VERSION_SPECIFICATION@@ and using them results in an error of:\n-\n->   `Unrecognized VM option` *option-name*\n-\n-`-XX:RTMAbortRatio=`*abort\\_ratio*\n-:   Specifies the RTM abort ratio is specified as a percentage (%) of all\n-    executed RTM transactions. If a number of aborted transactions becomes\n-    greater than this ratio, then the compiled code is deoptimized. This ratio\n-    is used when the `-XX:+UseRTMDeopt` option is enabled. The default value of\n-    this option is 50. This means that the compiled code is deoptimized if 50%\n-    of all transactions are aborted.\n-\n-`-XX:RTMRetryCount=`*number\\_of\\_retries*\n-:   Specifies the number of times that the RTM locking code is retried, when it\n-    is aborted or busy, before falling back to the normal locking mechanism.\n-    The default value for this option is 5. The `-XX:UseRTMLocking` option must\n-    be enabled.\n-\n-`-XX:+UseRTMDeopt`\n-:   Autotunes RTM locking depending on the abort ratio. This ratio is specified\n-    by the `-XX:RTMAbortRatio` option. If the number of aborted transactions\n-    exceeds the abort ratio, then the method containing the lock is deoptimized\n-    and recompiled with all locks as normal locks. This option is disabled by\n-    default. The `-XX:+UseRTMLocking` option must be enabled.\n-\n-`-XX:+UseRTMLocking`\n-:   Generates Restricted Transactional Memory (RTM) locking code for all\n-    inflated locks, with the normal locking mechanism as the fallback handler.\n-    This option is disabled by default. Options related to RTM are available\n-    only on x86 CPUs that support Transactional Synchronization Extensions (TSX).\n-\n-    RTM is part of Intel's TSX, which is an x86 instruction set extension and\n-    facilitates the creation of multithreaded applications. RTM introduces the\n-    new instructions `XBEGIN`, `XABORT`, `XEND`, and `XTEST`. The `XBEGIN` and\n-    `XEND` instructions enclose a set of instructions to run as a transaction.\n-    If no conflict is found when running the transaction, then the memory and\n-    register modifications are committed together at the `XEND` instruction.\n-    The `XABORT` instruction can be used to explicitly abort a transaction and\n-    the `XTEST` instruction checks if a set of instructions is being run in a\n-    transaction.\n-\n-    A lock on a transaction is inflated when another thread tries to access the\n-    same transaction, thereby blocking the thread that didn't originally\n-    request access to the transaction. RTM requires that a fallback set of\n-    operations be specified in case a transaction aborts or fails. An RTM lock\n-    is a lock that has been delegated to the TSX's system.\n-\n-    RTM improves performance for highly contended locks with low conflict in a\n-    critical region (which is code that must not be accessed by more than one\n-    thread concurrently). RTM also improves the performance of coarse-grain\n-    locking, which typically doesn't perform well in multithreaded\n-    applications. (Coarse-grain locking is the strategy of holding locks for\n-    long periods to minimize the overhead of taking and releasing locks, while\n-    fine-grained locking is the strategy of trying to achieve maximum\n-    parallelism by locking only when necessary and unlocking as soon as\n-    possible.) Also, for lightly contended locks that are used by different\n-    threads, RTM can reduce false cache line sharing, also known as cache line\n-    ping-pong. This occurs when multiple threads from different processors are\n-    accessing different resources, but the resources share the same cache line.\n-    As a result, the processors repeatedly invalidate the cache lines of other\n-    processors, which forces them to read from main memory instead of their\n-    cache.\n+No documented java options have been removed in JDK @@VERSION_SPECIFICATION@@.\n@@ -2980,0 +2934,2 @@\n+-   [The `java` Command, Release 25](https:\/\/docs.oracle.com\/en\/java\/javase\/25\/docs\/specs\/man\/java.html)\n+\n@@ -3804,3 +3760,4 @@\n-(The names \"static\" and \"dynamic\" are used for historical reasons.\n-The only significance is that the \"static\" archive is loaded first and\n-the \"dynamic\" archive is loaded second).\n+The names \"static\" and \"dynamic\" are used for historical reasons. The dynamic\n+archive, while still useful, supports fewer optimizations than\n+available for the static CDS archive. If the full set of CDS\/AOT\n+optimizations are desired, consider using the AOT cache described below.\n@@ -3998,2 +3955,2 @@\n-To diagnose problems with the above options, you can add `-Xlog:cds` to the application's VM\n-arguments. For example, if `--add-modules jdk.jconcole` was specified during archive creation\n+To diagnose problems with the AOT options, you can add `-Xlog:aot` to the application's VM\n+arguments. For example, if `--add-modules jdk.jconsole` was specified during archive creation\n@@ -4048,1 +4005,1 @@\n-`-XX:AOTCache:=`*cachefile*\n+`-XX:AOTCache=`*cachefile*\n@@ -4050,2 +4007,6 @@\n-    If `-XX:AOTCache` is specified but `-XX:AOTMode` is not specified,\n-    then `AOTMode` will be given the value of `auto`.\n+    This option cannot be used together with `-XX:AOTCacheOutput`.\n+\n+    This option is compatible with `AOTMode` settings of `on`, `create`, or `auto` (the default).\n+    The *cachefile* is read in AOT modes `on` and `auto`, and is ignored by mode `off`.\n+    The *cachefile* is written by AOT mode `create`.  In that case, this option is\n+    equivalent to `-XX:AOTCacheOutput=`*cachefile*.\n@@ -4053,1 +4014,7 @@\n-`-XX:AOTConfiguration:=`*configfile*\n+`-XX:AOTCacheOutput=`*cachefile*\n+:   Specifies the location of the AOT cache to write. The standard extension for *cachefile* is `.aot`.\n+    This option cannot be used together with `-XX:AOTCache`.\n+\n+    This option is compatible with `AOTMode` settings of `record`, `create`, or `auto` (the default).\n+\n+`-XX:AOTConfiguration=`*configfile*\n@@ -4055,1 +4022,0 @@\n-    This option can be used only with `-XX:AOTMode=record` and `-XX:AOTMode=create`.\n@@ -4058,2 +4024,3 @@\n-`-XX:+AOTMode:=`*mode*\n-:   *mode* must be one of the following: `off`, `record`, `create`, `auto`, or `on`.\n+    This option is compatible with `AOTMode` settings of `record`, `create`, or `auto` (the default).\n+    The *configfile* is read by AOT mode `create`, and written by the other applicable modes.\n+    If the AOT mode is `auto`, then `AOTCacheOutput` must also be present.\n@@ -4061,1 +4028,3 @@\n--   `off`: no AOT cache is used.\n+`-XX:AOTMode=`*mode*\n+:   Specifies the AOT Mode for this run.\n+    *mode* must be one of the following: `auto`, `off`, `record`, `create`, or `on`.\n@@ -4063,3 +4032,9 @@\n--   `record`: Execute the application in the Training phase.\n-    `-XX:AOTConfiguration=`*configfile* must be specified. The JVM gathers\n-     statistical data and stores them into *configfile*.\n+-   `auto`: This AOT mode is the default, and takes effect if no `-XX:AOTMode` option\n+    is present.  It automatically sets the AOT mode to `record`, `on`, or `off`, as follows:\n+     - If `-XX:AOTCacheOutput=`*cachefile* is specified, the AOT mode is changed to `record`\n+       (a training run, with a subsequent `create` operation).\n+     - Otherwise, if an AOT cache can be loaded, the AOT mode is changed to `on` (a production run).\n+     - Otherwise, the AOT mode is changed to `off` (a production run with no AOT cache).\n+\n+-   `off`: No AOT cache is used.\n+    Other AOT command line options are ignored.\n@@ -4067,3 +4042,20 @@\n--   `create`: Perform the Assembly phase. `-XX:AOTConfiguration=`*configfile*\n-     and `-XX:AOTCache=`*cachefile*  must be specified. The JVM reads the statistical\n-     data from *configfile* and writes the optimization artifacts into *cachefile*.\n+-   `record`: Execute the application in the training phase.\n+     At least one of `-XX:AOTConfiguration=`*configfile* and\/or\n+     `-XX:AOTCacheOutput=`*cachefile* must be specified.\n+     If `-XX:AOTConfiguration=`*configfile* is specified, the JVM gathers\n+     statistical data and stores them into *configfile*.\n+     If `-XX:AOTConfiguration=`*configfile* is not specified, the JVM uses\n+     a temporary file name, which may be the string `AOTCacheOutput+\".config\"`,\n+     or else a fresh implementation-dependent temporary file name.\n+     If `-XX:AOTCacheOutput=`*cachefile* is specified, a second JVM process is launched\n+     to perform the Assembly phase to write the optimization artifacts into *cachefile*.\n+\n+     Extra JVM options can be passed to the second JVM process using the environment\n+     variable `JDK_AOT_VM_OPTIONS`, with the same format as the environment variable\n+     `JAVA_TOOL_OPTIONS`, which is\n+     [defined by JVMTI](https:\/\/docs.oracle.com\/en\/java\/javase\/24\/docs\/specs\/jvmti.html#tooloptions).\n+\n+-   `create`: Perform the Assembly phase. `-XX:AOTConfiguration=`*configfile* must be\n+     specified.\n+     The JVM reads history and statistics\n+     from *configfile* and writes the optimization artifacts into *cachefile*.\n@@ -4072,1 +4064,1 @@\n--   `auto` or `on`: These modes should be used in the Production phase.\n+-   `on`: Execute the application in the Production phase.\n@@ -4089,1 +4081,1 @@\n-       list of scenarios that may be incompatible with the AOT cache for JDK 24.\n+       list of scenarios that may be incompatible with the AOT cache.\n@@ -4096,1 +4088,1 @@\n-     - If `AOTMode` is `auto`, the JVM will continue execution without using the\n+     - If `AOTMode` was originally `auto`, the JVM will continue execution without using the\n@@ -4106,1 +4098,1 @@\n-       `-XX:AOTMode=auto -Xlog:cds` to see if the AOT cache can be used or not.\n+       `-XX:AOTMode=auto -Xlog:aot` to see if the AOT cache can be used or not.\n@@ -4123,0 +4115,10 @@\n+The first occurrence of the special sequence `%p` in `*configfile* and `*cachefile* is replaced\n+with the process ID of the JVM process launched in the command-line, and likewise the\n+first occurrence of `%t` is replace by the JVM's startup timestamp.\n+(After replacement there must be no further occurrences of `%p` or `%t`, to prevent\n+problems with sub-processes.)  For example:\n+\n+>   `java -XX:AOTConfiguration=foo%p.aotconfig -XX:AOTCacheOutput=foo%p.aot -cp foo.jar Foo`\n+\n+will create two files: `foopid123.aotconfig` and `foopid123.aot`, where `123` is the\n+process ID of the JVM that has executed the application `Foo`.\n","filename":"src\/java.base\/share\/man\/java.md","additions":93,"deletions":91,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -582,0 +582,1 @@\n+#ifdef USE_MMAP\n@@ -583,0 +584,1 @@\n+#endif\n@@ -607,0 +609,1 @@\n+#ifdef USE_MMAP\n@@ -608,0 +611,1 @@\n+#endif\n","filename":"src\/java.base\/share\/native\/libzip\/zip_util.c","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -359,1 +359,3 @@\n-            return target;\n+\n+            \/\/ return normalized path string\n+            return WindowsPathParser.parse(target).path();\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsLinkSupport.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -968,1 +968,1 @@\n-    int got = 0;\n+ \/\/ int got = 0;\n@@ -972,1 +972,2 @@\n-            got = getLocaleInfoWrapper(langtag,\n+         \/\/ got =\n+                  getLocaleInfoWrapper(langtag,\n@@ -976,1 +977,2 @@\n-            got = getLocaleInfoWrapper(langtag,\n+         \/\/ got =\n+                  getLocaleInfoWrapper(langtag,\n@@ -982,1 +984,2 @@\n-            got = getLocaleInfoWrapper(langtag,\n+         \/\/ got =\n+                  getLocaleInfoWrapper(langtag,\n@@ -986,1 +989,2 @@\n-            got = getLocaleInfoWrapper(langtag,\n+         \/\/ got =\n+                  getLocaleInfoWrapper(langtag,\n@@ -990,1 +994,2 @@\n-            got = getLocaleInfoWrapper(langtag,\n+         \/\/ got =\n+                  getLocaleInfoWrapper(langtag,\n","filename":"src\/java.base\/windows\/native\/libjava\/HostLocaleProviderAdapter_md.c","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-        int onlyMapID;\n+     \/\/ int onlyMapID;\n@@ -307,1 +307,1 @@\n-        onlyMapID = 0;\n+     \/\/ onlyMapID = 0;\n@@ -328,1 +328,1 @@\n-                onlyMapID = 1;\n+             \/\/ onlyMapID = 1;\n","filename":"src\/java.base\/windows\/native\/libjava\/TimeZone_md.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-static HINSTANCE lib = NULL;\n+\/\/ static HINSTANCE lib = NULL;\n","filename":"src\/java.base\/windows\/native\/libnet\/NTLMAuthSequence.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -363,2 +363,0 @@\n-filename.-monotype-timesnewromanwt-medium-r-normal--*-%d-75-75-*-*-gb2312.1980-0=\/usr\/lpp\/X11\/lib\/X11\/fonts\/TrueType\/tnrwt_s.ttf\n-filename.-monotype-wt_serif_sc-medium-r-normal--*-%d-75-75-*-*-iso10646-1=\/usr\/lpp\/X11\/lib\/X11\/fonts\/TrueType\/wt__s__b.ttf\n","filename":"src\/java.desktop\/aix\/data\/fontconfig\/fontconfig.properties","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+import static sun.java2d.cmm.ProfileDataVerifier.HEADER_SIZE;\n+\n@@ -767,2 +769,0 @@\n-    private static final int HEADER_SIZE = 128;\n-\n@@ -802,0 +802,1 @@\n+        verifyHeader(data);\n@@ -804,4 +805,0 @@\n-            byte[] theHeader = new byte[HEADER_SIZE];\n-            System.arraycopy(data, 0, theHeader, 0, HEADER_SIZE);\n-            verifyHeader(theHeader);\n-\n@@ -814,3 +811,2 @@\n-            if (getColorSpaceType(p) == ColorSpace.TYPE_GRAY\n-                    && getData(p, icSigMediaWhitePointTag) != null\n-                    && getData(p, icSigGrayTRCTag) != null) {\n+            int type = getColorSpaceType(data);\n+            if (type == ColorSpace.TYPE_GRAY) {\n@@ -818,9 +814,1 @@\n-            }\n-            if (getColorSpaceType(p) == ColorSpace.TYPE_RGB\n-                    && getData(p, icSigMediaWhitePointTag) != null\n-                    && getData(p, icSigRedColorantTag) != null\n-                    && getData(p, icSigGreenColorantTag) != null\n-                    && getData(p, icSigBlueColorantTag) != null\n-                    && getData(p, icSigRedTRCTag) != null\n-                    && getData(p, icSigGreenTRCTag) != null\n-                    && getData(p, icSigBlueTRCTag) != null) {\n+            } else if (type == ColorSpace.TYPE_RGB) {\n@@ -916,1 +904,1 @@\n-        bis.mark(128); \/\/ 128 is the length of the ICC profile header\n+        bis.mark(HEADER_SIZE);\n@@ -918,3 +906,3 @@\n-        byte[] header = bis.readNBytes(128);\n-        if (header.length < 128 || header[36] != 0x61 || header[37] != 0x63 ||\n-            header[38] != 0x73 || header[39] != 0x70) {\n+        byte[] header = bis.readNBytes(HEADER_SIZE);\n+        if (header.length < HEADER_SIZE || header[36] != 0x61 ||\n+            header[37] != 0x63 || header[38] != 0x73 || header[39] != 0x70) {\n@@ -972,1 +960,1 @@\n-        return getData(icSigHead)[8];\n+        return getData(cmmProfile(), icSigHead)[8];\n@@ -981,1 +969,1 @@\n-        return getData(icSigHead)[9];\n+        return getData(cmmProfile(), icSigHead)[9];\n@@ -994,1 +982,1 @@\n-        byte[] theHeader = getData(icSigHead);\n+        byte[] theHeader = getData(cmmProfile(), icSigHead);\n@@ -998,2 +986,2 @@\n-    private static int getProfileClass(byte[] theHeader) {\n-        int theClassSig = intFromBigEndian(theHeader, icHdrDeviceClass);\n+    private static int getProfileClass(byte[] data) {\n+        int theClassSig = intFromBigEndian(data, icHdrDeviceClass);\n@@ -1031,7 +1019,2 @@\n-        return getColorSpaceType(cmmProfile());\n-    }\n-\n-    private static int getColorSpaceType(Profile p) {\n-        byte[] theHeader = getData(p, icSigHead);\n-        int theColorSpaceSig = intFromBigEndian(theHeader, icHdrColorSpace);\n-        return iccCStoJCS(theColorSpaceSig);\n+        byte[] theHeader = getData(cmmProfile(), icSigHead);\n+        return getColorSpaceType(theHeader);\n@@ -1040,2 +1023,2 @@\n-    private static int getColorSpaceType(byte[] theHeader) {\n-        int theColorSpaceSig = intFromBigEndian(theHeader, icHdrColorSpace);\n+    private static int getColorSpaceType(byte[] data) {\n+        int theColorSpaceSig = intFromBigEndian(data, icHdrColorSpace);\n@@ -1059,3 +1042,2 @@\n-        byte[] theHeader = getData(icSigHead);\n-        int thePCSSig = intFromBigEndian(theHeader, icHdrPcs);\n-        return iccCStoJCS(thePCSSig);\n+        byte[] theHeader = getData(cmmProfile(), icSigHead);\n+        return getPCSType(theHeader);\n@@ -1064,3 +1046,3 @@\n-    private static int getPCSType(byte[] theHeader) {\n-        int thePCSSig = intFromBigEndian(theHeader, icHdrPcs);\n-        int theDeviceClass = intFromBigEndian(theHeader, icHdrDeviceClass);\n+    private static int getPCSType(byte[] data) {\n+        int thePCSSig = intFromBigEndian(data, icHdrPcs);\n+        int theDeviceClass = intFromBigEndian(data, icHdrDeviceClass);\n@@ -1129,6 +1111,1 @@\n-        byte[] t = getData(cmmProfile(), tagSignature);\n-        return t != null ? t.clone() : null;\n-    }\n-\n-    private static byte[] getData(Profile p, int tagSignature) {\n-            return CMSManager.getModule().getTagData(p, tagSignature);\n+            return getData(cmmProfile(), tagSignature).clone();\n@@ -1141,0 +1118,14 @@\n+    \/**\n+     * Returns a particular tagged data element from the profile as a non-null\n+     * byte array. The returned byte array is not cloned. It must not be exposed\n+     * to or used by public APIs. It is intended strictly for internal use only.\n+     *\n+     * @param  p the CMM profile from which to retrieve the tag data\n+     * @param  tagSignature the ICC tag signature for the data to retrieve\n+     * @return a non-null byte array containing the tag data\n+     * @throws CMMException if the specified tag doesn't exist\n+     *\/\n+    static byte[] getData(Profile p, int tagSignature) {\n+        return CMSManager.getModule().getTagData(p, tagSignature);\n+    }\n+\n@@ -1192,1 +1183,1 @@\n-    private static boolean checkRenderingIntent(byte[] header) {\n+    private static void checkRenderingIntent(byte[] data) {\n@@ -1194,5 +1185,4 @@\n-\n-        \/* According to ICC spec, only the least-significant 16 bits shall be\n-         * used to encode the rendering intent. The most significant 16 bits\n-         * shall be set to zero. Thus, we are ignoring two most significant\n-         * bytes here. Please refer ICC Spec Document for more details.\n+        \/*\n+         * ICC spec: only the least-significant 16 bits encode the rendering\n+         * intent. The most significant 16 bits must be zero and can be ignored.\n+         * https:\/\/www.color.org\/specification\/ICC.1-2022-05.pdf, section 7.2.15\n@@ -1200,9 +1190,6 @@\n-        int renderingIntent = ((header[index+2] & 0xff) <<  8) |\n-                              (header[index+3] & 0xff);\n-\n-        switch (renderingIntent) {\n-            case icPerceptual, icMediaRelativeColorimetric,\n-                    icSaturation, icAbsoluteColorimetric -> {\n-                return true;\n-            }\n-            default -> throw new IllegalArgumentException(\"Unknown Rendering Intent\");\n+        \/\/ Extract 16-bit unsigned rendering intent (065535)\n+        int intent = (data[index + 2] & 0xff) << 8 | data[index + 3] & 0xff;\n+        \/\/ Only check upper bound since intent can't be negative\n+        if (intent > icICCAbsoluteColorimetric) {\n+            throw new IllegalArgumentException(\n+                    \"Unknown Rendering Intent: %d\".formatted(intent));\n@@ -1225,1 +1212,1 @@\n-        byte[] theHeader = getData(icSigHead);\n+        byte[] theHeader = getData(cmmProfile(), icSigHead);\n@@ -1264,1 +1251,1 @@\n-        byte[] theData = getData(tagSignature);\n+        byte[] theData = getData(cmmProfile(), tagSignature);\n@@ -1288,1 +1275,1 @@\n-        byte[] theTRCData = getData(tagSignature);\n+        byte[] theTRCData = getData(cmmProfile(), tagSignature);\n@@ -1319,1 +1306,1 @@\n-        byte[] theTRCData = getData(tagSignature);\n+        byte[] theTRCData = getData(cmmProfile(), tagSignature);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_Profile.java","additions":54,"deletions":67,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,4 @@\n-     * Constructs a new {@code ICC_ProfileGray} from a CMM ID.\n+     * Constructs a new {@code ICC_ProfileGray} from the specified CMM profile.\n+     *\n+     * @param  p the CMM profile used to create this ICC profile\n+     * @throws CMMException if the required tags are missing\n@@ -81,0 +84,2 @@\n+        getData(p, icSigMediaWhitePointTag);\n+        getData(p, icSigGrayTRCTag);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_ProfileGray.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,1 +107,1 @@\n-     * Constructs an new {@code ICC_ProfileRGB} from a CMM ID.\n+     * Constructs a new {@code ICC_ProfileRGB} from the specified CMM profile.\n@@ -109,1 +109,2 @@\n-     * @param  p the CMM ID for the profile.\n+     * @param  p the CMM profile used to create this ICC profile\n+     * @throws CMMException if the required tags are missing\n@@ -113,0 +114,7 @@\n+        getData(p, icSigMediaWhitePointTag);\n+        getData(p, icSigRedColorantTag);\n+        getData(p, icSigGreenColorantTag);\n+        getData(p, icSigBlueColorantTag);\n+        getData(p, icSigRedTRCTag);\n+        getData(p, icSigGreenTRCTag);\n+        getData(p, icSigBlueTRCTag);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_ProfileRGB.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,2 @@\n+import static sun.java2d.pipe.Region.clipRound;\n+\n@@ -164,1 +166,1 @@\n-            int offs = this.thickness * (int) scaleFactor;\n+            int offs = clipRound(this.thickness * scaleFactor);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/border\/LineBorder.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -411,1 +411,1 @@\n-     * of currency, if the model supports being updated asynchronously.\n+     * of concurrency, if the model supports being updated asynchronously.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/AbstractDocument.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2501,15 +2501,2 @@\n-    \/\/ It's entirely possible that our native resources have been destroyed\n-    \/\/ before our java peer - if we're dispose()d, for instance.\n-    \/\/ Alert caller w\/ IllegalComponentStateException.\n-    if (self == NULL) {\n-        JNU_ThrowByName(env, \"java\/awt\/IllegalComponentStateException\",\n-                        \"Peer null in JNI\");\n-        return 0;\n-    }\n-    PDATA pData = JNI_GET_PDATA(self);\n-    if (pData == NULL) {\n-        JNU_ThrowByName(env, \"java\/awt\/IllegalComponentStateException\",\n-                        \"Native resources unavailable\");\n-        env->DeleteGlobalRef(self);\n-        return 0;\n-    }\n+    jint result = -1;\n+    AwtWindow* window = NULL;\n@@ -2517,3 +2504,6 @@\n-    jint result = 0;\n-    AwtWindow *w = (AwtWindow *)pData;\n-    if (::IsWindow(w->GetHWnd()))\n+    \/\/ Our native resources may have been destroyed before the Java peer,\n+    \/\/ e.g., if dispose() was called. In that case, return the default screen.\n+    PDATA pData;\n+    JNI_CHECK_PEER_GOTO(self, ret);\n+    window = (AwtWindow *)pData;\n+    if (::IsWindow(window->GetHWnd()))\n@@ -2521,1 +2511,1 @@\n-        result = (jint)w->GetScreenImOn();\n+        result = (jint)window->GetScreenImOn();\n@@ -2524,0 +2514,1 @@\n+  ret:\n@@ -2525,2 +2516,1 @@\n-\n-    return result;\n+    return (result != -1) ? result : AwtWin32GraphicsDevice::GetDefaultDeviceIndex();\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Window.cpp","additions":11,"deletions":21,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import java.util.function.Function;\n@@ -44,1 +43,0 @@\n-import jdk.internal.net.http.common.TimeSource;\n@@ -60,1 +58,0 @@\n-    private volatile int unsuccessfulAttempts;\n@@ -64,6 +61,0 @@\n-    \/\/ Indicates whether a connection attempt has succeeded or should be retried.\n-    \/\/ If the attempt failed, and shouldn't be retried, there will be an exception\n-    \/\/ instead.\n-    private enum ConnectState { SUCCESS, RETRY }\n-\n-\n@@ -118,1 +109,1 @@\n-        private final CompletableFuture<ConnectState> cf;\n+        private final CompletableFuture<Void> cf;\n@@ -121,1 +112,1 @@\n-        ConnectEvent(CompletableFuture<ConnectState> cf, Exchange<?> exchange) {\n+        ConnectEvent(CompletableFuture<Void> cf, Exchange<?> exchange) {\n@@ -150,1 +141,2 @@\n-                    cf.completeAsync(() -> ConnectState.SUCCESS, client().theExecutor());\n+                    if (debug.on()) debug.log(\"%s has been connected asynchronously\", label());\n+                    cf.completeAsync(() -> null, client().theExecutor());\n@@ -153,6 +145,0 @@\n-                if (canRetryConnect(e)) {\n-                    unsuccessfulAttempts++;\n-                    \/\/ complete async since the event runs on the SelectorManager thread\n-                    cf.completeAsync(() -> ConnectState.RETRY, client().theExecutor());\n-                    return;\n-                }\n@@ -177,1 +163,1 @@\n-        CompletableFuture<ConnectState> cf = new MinimalFuture<>();\n+        CompletableFuture<Void> cf = new MinimalFuture<>();\n@@ -215,1 +201,2 @@\n-                    cf.complete(ConnectState.SUCCESS);\n+                    if (debug.on()) debug.log(\"%s has been connected\", label());\n+                    cf.complete(null);\n@@ -235,2 +222,1 @@\n-        return cf.handle((r,t) -> checkRetryConnect(r, t, exchange))\n-                .thenCompose(Function.identity());\n+        return cf;\n@@ -257,36 +243,0 @@\n-    \/**\n-     * On some platforms, a ConnectEvent may be raised and a ConnectionException\n-     * may occur with the message \"Connection timed out: no further information\"\n-     * before our actual connection timeout has expired. In this case, this\n-     * method will be called with a {@code connect} state of {@code ConnectState.RETRY)}\n-     * and we will retry once again.\n-     * @param connect indicates whether the connection was successful or should be retried\n-     * @param failed the failure if the connection failed\n-     * @param exchange the exchange\n-     * @return a completable future that will take care of retrying the connection if needed.\n-     *\/\n-    private CompletableFuture<Void> checkRetryConnect(ConnectState connect, Throwable failed, Exchange<?> exchange) {\n-        \/\/ first check if the connection failed\n-        if (failed != null) return MinimalFuture.failedFuture(failed);\n-        \/\/ then check if the connection should be retried\n-        if (connect == ConnectState.RETRY) {\n-            int attempts = unsuccessfulAttempts;\n-            assert attempts <= 1;\n-            if (debug.on())\n-                debug.log(\"Retrying connect after %d attempts\", attempts);\n-            return connectAsync(exchange);\n-        }\n-        \/\/ Otherwise, the connection was successful;\n-        assert connect == ConnectState.SUCCESS;\n-        return MinimalFuture.completedFuture(null);\n-    }\n-\n-    private boolean canRetryConnect(Throwable e) {\n-        if (!MultiExchange.RETRY_CONNECT) return false;\n-        if (!(e instanceof ConnectException)) return false;\n-        if (unsuccessfulAttempts > 0) return false;\n-        ConnectTimerEvent timer = connectTimerEvent;\n-        if (timer == null) return true;\n-        return timer.deadline().isAfter(TimeSource.now());\n-    }\n-\n@@ -313,2 +263,3 @@\n-    PlainHttpConnection(InetSocketAddress addr, HttpClientImpl client, String label) {\n-        super(addr, client, label);\n+    PlainHttpConnection(Origin originServer, InetSocketAddress addr, HttpClientImpl client,\n+                        String label) {\n+        super(originServer, addr, client, label);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainHttpConnection.java","additions":11,"deletions":60,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Map;\n@@ -85,1 +86,1 @@\n-public interface Connection  extends Wrapper, AutoCloseable {\n+public interface Connection extends Wrapper, AutoCloseable {\n@@ -139,2 +140,1 @@\n-    PreparedStatement prepareStatement(String sql)\n-        throws SQLException;\n+    PreparedStatement prepareStatement(String sql) throws SQLException;\n@@ -501,1 +501,0 @@\n-\n@@ -532,2 +531,1 @@\n-    Statement createStatement(int resultSetType, int resultSetConcurrency)\n-        throws SQLException;\n+    Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException;\n@@ -629,1 +627,1 @@\n-    java.util.Map<String,Class<?>> getTypeMap() throws SQLException;\n+    Map<String, Class<?>> getTypeMap() throws SQLException;\n@@ -657,1 +655,1 @@\n-    void setTypeMap(java.util.Map<String,Class<?>> map) throws SQLException;\n+    void setTypeMap(Map<String, Class<?>> map) throws SQLException;\n@@ -661,1 +659,0 @@\n-\n@@ -897,1 +894,0 @@\n-\n@@ -940,2 +936,1 @@\n-    PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)\n-        throws SQLException;\n+    PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException;\n@@ -988,2 +983,1 @@\n-    PreparedStatement prepareStatement(String sql, int columnIndexes[])\n-        throws SQLException;\n+    PreparedStatement prepareStatement(String sql, int columnIndexes[]) throws SQLException;\n@@ -1036,2 +1030,1 @@\n-    PreparedStatement prepareStatement(String sql, String columnNames[])\n-        throws SQLException;\n+    PreparedStatement prepareStatement(String sql, String columnNames[]) throws SQLException;\n@@ -1102,81 +1095,80 @@\n-        \/**\n-         * Returns true if the connection has not been closed and is still valid.\n-         * The driver shall submit a query on the connection or use some other\n-         * mechanism that positively verifies the connection is still valid when\n-         * this method is called.\n-         * <p>\n-         * The query submitted by the driver to validate the connection shall be\n-         * executed in the context of the current transaction.\n-         *\n-         * @param timeout The time in seconds to wait for the database operation\n-         *                used to validate the connection to complete.  If the\n-         *                timeout period expires before the operationcompletes,\n-         *                this method returns false.  A value of 0 indicates a\n-         *                timeout is not applied to the database operation.\n-         *\n-         * @return true if the connection is valid, false otherwise\n-         * @throws SQLException if the value supplied for {@code timeout}\n-         * is less than 0\n-         * @since 1.6\n-         *\n-         * @see java.sql.DatabaseMetaData#getClientInfoProperties\n-         *\/\n-         boolean isValid(int timeout) throws SQLException;\n-\n-        \/**\n-         * Sets the value of the client info property specified by name to the\n-         * value specified by value.\n-         * <p>\n-         * Applications may use the {@code DatabaseMetaData.getClientInfoProperties}\n-         * method to determine the client info properties supported by the driver\n-         * and the maximum length that may be specified for each property.\n-         * <p>\n-         * The driver stores the value specified in a suitable location in the\n-         * database.  For example in a special register, session parameter, or\n-         * system table column.  For efficiency the driver may defer setting the\n-         * value in the database until the next time a statement is executed or\n-         * prepared.  Other than storing the client information in the appropriate\n-         * place in the database, these methods shall not alter the behavior of\n-         * the connection in anyway.  The values supplied to these methods are\n-         * used for accounting, diagnostics and debugging purposes only.\n-         * <p>\n-         * The driver shall generate a warning if the client info name specified\n-         * is not recognized by the driver.\n-         * <p>\n-         * If the value specified to this method is greater than the maximum\n-         * length for the property the driver may either truncate the value and\n-         * generate a warning or generate a {@code SQLClientInfoException}.  If the driver\n-         * generates a {@code SQLClientInfoException}, the value specified was not set on the\n-         * connection.\n-         * <p>\n-         * The following are standard client info properties.  Drivers are not\n-         * required to support these properties however if the driver supports a\n-         * client info property that can be described by one of the standard\n-         * properties, the standard property name should be used.\n-         *\n-         * <ul>\n-         * <li>ApplicationName  -       The name of the application currently utilizing\n-         *                                                      the connection<\/li>\n-         * <li>ClientUser               -       The name of the user that the application using\n-         *                                                      the connection is performing work for.  This may\n-         *                                                      not be the same as the user name that was used\n-         *                                                      in establishing the connection.<\/li>\n-         * <li>ClientHostname   -       The hostname of the computer the application\n-         *                                                      using the connection is running on.<\/li>\n-         * <\/ul>\n-         *\n-         * @param name          The name of the client info property to set\n-         * @param value         The value to set the client info property to.  If the\n-         *                                      value is null, the current value of the specified\n-         *                                      property is cleared.\n-         *\n-         * @throws      SQLClientInfoException if the database server returns an error while\n-         *                      setting the client info value on the database server or this method\n-         * is called on a closed connection\n-         *\n-         * @since 1.6\n-         *\/\n-         void setClientInfo(String name, String value)\n-                throws SQLClientInfoException;\n-\n-        \/**\n+    \/**\n+     * Returns true if the connection has not been closed and is still valid.\n+     * The driver shall submit a query on the connection or use some other\n+     * mechanism that positively verifies the connection is still valid when\n+     * this method is called.\n+     * <p>\n+     * The query submitted by the driver to validate the connection shall be\n+     * executed in the context of the current transaction.\n+     *\n+     * @param timeout The time in seconds to wait for the database operation\n+     *                used to validate the connection to complete.  If the\n+     *                timeout period expires before the operationcompletes,\n+     *                this method returns false.  A value of 0 indicates a\n+     *                timeout is not applied to the database operation.\n+     *\n+     * @return true if the connection is valid, false otherwise\n+     * @throws SQLException if the value supplied for {@code timeout}\n+     * is less than 0\n+     * @since 1.6\n+     *\n+     * @see java.sql.DatabaseMetaData#getClientInfoProperties\n+     *\/\n+    boolean isValid(int timeout) throws SQLException;\n+\n+    \/**\n+     * Sets the value of the client info property specified by name to the\n+     * value specified by value.\n+     * <p>\n+     * Applications may use the {@code DatabaseMetaData.getClientInfoProperties}\n+     * method to determine the client info properties supported by the driver\n+     * and the maximum length that may be specified for each property.\n+     * <p>\n+     * The driver stores the value specified in a suitable location in the\n+     * database.  For example in a special register, session parameter, or\n+     * system table column.  For efficiency the driver may defer setting the\n+     * value in the database until the next time a statement is executed or\n+     * prepared.  Other than storing the client information in the appropriate\n+     * place in the database, these methods shall not alter the behavior of\n+     * the connection in anyway.  The values supplied to these methods are\n+     * used for accounting, diagnostics and debugging purposes only.\n+     * <p>\n+     * The driver shall generate a warning if the client info name specified\n+     * is not recognized by the driver.\n+     * <p>\n+     * If the value specified to this method is greater than the maximum\n+     * length for the property the driver may either truncate the value and\n+     * generate a warning or generate a {@code SQLClientInfoException}.  If the driver\n+     * generates a {@code SQLClientInfoException}, the value specified was not set on the\n+     * connection.\n+     * <p>\n+     * The following are standard client info properties.  Drivers are not\n+     * required to support these properties however if the driver supports a\n+     * client info property that can be described by one of the standard\n+     * properties, the standard property name should be used.\n+     *\n+     * <ul>\n+     * <li>ApplicationName -       The name of the application currently utilizing\n+     *                                                      the connection<\/li>\n+     * <li>ClientUser      -       The name of the user that the application using\n+     *                                                      the connection is performing work for.  This may\n+     *                                                      not be the same as the user name that was used\n+     *                                                      in establishing the connection.<\/li>\n+     * <li>ClientHostname  -       The hostname of the computer the application\n+     *                                                      using the connection is running on.<\/li>\n+     * <\/ul>\n+     *\n+     * @param name          The name of the client info property to set\n+     * @param value         The value to set the client info property to.  If the\n+     *                                      value is null, the current value of the specified\n+     *                                      property is cleared.\n+     *\n+     * @throws      SQLClientInfoException if the database server returns an error while\n+     *                      setting the client info value on the database server or this method\n+     * is called on a closed connection\n+     *\n+     * @since 1.6\n+     *\/\n+    void setClientInfo(String name, String value) throws SQLClientInfoException;\n+\n+    \/**\n@@ -1212,45 +1204,1 @@\n-         void setClientInfo(Properties properties)\n-                throws SQLClientInfoException;\n-\n-        \/**\n-         * Returns the value of the client info property specified by name.  This\n-         * method may return null if the specified client info property has not\n-         * been set and does not have a default value.  This method will also\n-         * return null if the specified client info property name is not supported\n-         * by the driver.\n-         * <p>\n-         * Applications may use the {@code DatabaseMetaData.getClientInfoProperties}\n-         * method to determine the client info properties supported by the driver.\n-         *\n-         * @param name          The name of the client info property to retrieve\n-         *\n-         * @return                      The value of the client info property specified\n-         *\n-         * @throws SQLException         if the database server returns an error when\n-         *                              fetching the client info value from the database\n-         *                              or this method is called on a closed connection\n-         *\n-         * @since 1.6\n-         *\n-         * @see java.sql.DatabaseMetaData#getClientInfoProperties\n-         *\/\n-         String getClientInfo(String name)\n-                throws SQLException;\n-\n-        \/**\n-         * Returns a list containing the name and current value of each client info\n-         * property supported by the driver.  The value of a client info property\n-         * may be null if the property has not been set and does not have a\n-         * default value.\n-         *\n-         * @return      A {@code Properties} object that contains the name and current value of\n-         *                      each of the client info properties supported by the driver.\n-         *\n-         * @throws      SQLException if the database server returns an error when\n-         *                      fetching the client info values from the database\n-         * or this method is called on a closed connection\n-         *\n-         * @since 1.6\n-         *\/\n-         Properties getClientInfo()\n-                throws SQLException;\n+    void setClientInfo(Properties properties) throws SQLClientInfoException;\n@@ -1258,28 +1206,23 @@\n-\/**\n-  * Factory method for creating Array objects.\n-  *<p>\n-  * <b>Note: <\/b>When {@code createArrayOf} is used to create an array object\n-  * that maps to a primitive data type, then it is implementation-defined\n-  * whether the {@code Array} object is an array of that primitive\n-  * data type or an array of {@code Object}.\n-  * <p>\n-  * <b>Note: <\/b>The JDBC driver is responsible for mapping the elements\n-  * {@code Object} array to the default JDBC SQL type defined in\n-  * java.sql.Types for the given class of {@code Object}. The default\n-  * mapping is specified in Appendix B of the JDBC specification.  If the\n-  * resulting JDBC type is not the appropriate type for the given typeName then\n-  * it is implementation defined whether an {@code SQLException} is\n-  * thrown or the driver supports the resulting conversion.\n-  *\n-  * @param typeName the SQL name of the type the elements of the array map to. The typeName is a\n-  * database-specific name which may be the name of a built-in type, a user-defined type or a standard  SQL type supported by this database. This\n-  *  is the value returned by {@code Array.getBaseTypeName}\n-  * @param elements the elements that populate the returned object\n-  * @return an Array object whose elements map to the specified SQL type\n-  * @throws SQLException if a database error occurs, the JDBC type is not\n-  *  appropriate for the typeName and the conversion is not supported, the typeName is null or this method is called on a closed connection\n-  * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this data type\n-  * @since 1.6\n-  *\/\n- Array createArrayOf(String typeName, Object[] elements) throws\n-SQLException;\n+    \/**\n+     * Returns the value of the client info property specified by name.  This\n+     * method may return null if the specified client info property has not\n+     * been set and does not have a default value.  This method will also\n+     * return null if the specified client info property name is not supported\n+     * by the driver.\n+     * <p>\n+     * Applications may use the {@code DatabaseMetaData.getClientInfoProperties}\n+     * method to determine the client info properties supported by the driver.\n+     *\n+     * @param name          The name of the client info property to retrieve\n+     *\n+     * @return                      The value of the client info property specified\n+     *\n+     * @throws SQLException         if the database server returns an error when\n+     *                              fetching the client info value from the database\n+     *                              or this method is called on a closed connection\n+     *\n+     * @since 1.6\n+     *\n+     * @see java.sql.DatabaseMetaData#getClientInfoProperties\n+     *\/\n+    String getClientInfo(String name) throws SQLException;\n@@ -1287,16 +1230,60 @@\n-\/**\n-  * Factory method for creating Struct objects.\n-  *\n-  * @param typeName the SQL type name of the SQL structured type that this {@code Struct}\n-  * object maps to. The typeName is the name of  a user-defined type that\n-  * has been defined for this database. It is the value returned by\n-  * {@code Struct.getSQLTypeName}.\n-\n-  * @param attributes the attributes that populate the returned object\n-  * @return a Struct object that maps to the given SQL type and is populated with the given attributes\n-  * @throws SQLException if a database error occurs, the typeName is null or this method is called on a closed connection\n-  * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this data type\n-  * @since 1.6\n-  *\/\n- Struct createStruct(String typeName, Object[] attributes)\n-throws SQLException;\n+    \/**\n+     * Returns a list containing the name and current value of each client info\n+     * property supported by the driver.  The value of a client info property\n+     * may be null if the property has not been set and does not have a\n+     * default value.\n+     *\n+     * @return      A {@code Properties} object that contains the name and current value of\n+     *                      each of the client info properties supported by the driver.\n+     *\n+     * @throws      SQLException if the database server returns an error when\n+     *                      fetching the client info values from the database\n+     * or this method is called on a closed connection\n+     *\n+     * @since 1.6\n+     *\/\n+    Properties getClientInfo() throws SQLException;\n+\n+    \/**\n+     * Factory method for creating Array objects.\n+     * <p>\n+     * <b>Note: <\/b>When {@code createArrayOf} is used to create an array object\n+     * that maps to a primitive data type, then it is implementation-defined\n+     * whether the {@code Array} object is an array of that primitive\n+     * data type or an array of {@code Object}.\n+     * <p>\n+     * <b>Note: <\/b>The JDBC driver is responsible for mapping the elements\n+     * {@code Object} array to the default JDBC SQL type defined in\n+     * java.sql.Types for the given class of {@code Object}. The default\n+     * mapping is specified in Appendix B of the JDBC specification.  If the\n+     * resulting JDBC type is not the appropriate type for the given typeName then\n+     * it is implementation defined whether an {@code SQLException} is\n+     * thrown or the driver supports the resulting conversion.\n+     *\n+     * @param typeName the SQL name of the type the elements of the array map to. The typeName is a\n+     * database-specific name which may be the name of a built-in type, a user-defined type or a standard  SQL type supported by this database. This\n+     *  is the value returned by {@code Array.getBaseTypeName}\n+     * @param elements the elements that populate the returned object\n+     * @return an Array object whose elements map to the specified SQL type\n+     * @throws SQLException if a database error occurs, the JDBC type is not\n+     *  appropriate for the typeName and the conversion is not supported, the typeName is null or this method is called on a closed connection\n+     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this data type\n+     * @since 1.6\n+     *\/\n+    Array createArrayOf(String typeName, Object[] elements) throws SQLException;\n+\n+    \/**\n+     * Factory method for creating Struct objects.\n+     *\n+     * @param typeName the SQL type name of the SQL structured type that this {@code Struct}\n+     * object maps to. The typeName is the name of  a user-defined type that\n+     * has been defined for this database. It is the value returned by\n+     * {@code Struct.getSQLTypeName}.\n+     *\n+     * @param attributes the attributes that populate the returned object\n+     * @return a Struct object that maps to the given SQL type and is populated with the given attributes\n+     * @throws SQLException if a database error occurs, the typeName is null or this method is called on a closed connection\n+     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this data type\n+     * @since 1.6\n+     *\/\n+    Struct createStruct(String typeName, Object[] attributes) throws SQLException;\n@@ -1466,1 +1453,1 @@\n-     \/**\n+    \/**\n@@ -1537,1 +1524,1 @@\n-     *<p>\n+     * <p>\n@@ -1568,1 +1555,1 @@\n-            \/\/ Default method takes no action\n+        \/\/ Default method takes no action\n@@ -1689,2 +1676,1 @@\n-    default void setShardingKey(ShardingKey shardingKey)\n-            throws SQLException {\n+    default void setShardingKey(ShardingKey shardingKey) throws SQLException {\n@@ -1693,0 +1679,1 @@\n+\n","filename":"src\/java.sql\/share\/classes\/java\/sql\/Connection.java","additions":179,"deletions":192,"binary":false,"changes":371,"status":"modified"},{"patch":"@@ -275,2 +275,0 @@\n-                Check.instance(this).clear(); \/\/clear mandatory warning handlers\n-                Preview.instance(this).clear(); \/\/clear mandatory warning handlers\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTaskPool.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -253,1 +253,1 @@\n-    public static final long DEFAULT = 1L<<43;\n+    public static final long DEFAULT = 1L<<43; \/\/ part of ExtendedStandardFlags, cannot be reused\n@@ -281,2 +281,2 @@\n-    \/*\n-     * Currently available: Bit 48.\n+    \/**\n+     * Flag to indicate sealed class\/interface declaration.\n@@ -284,0 +284,1 @@\n+    public static final long SEALED = 1L<<48; \/\/ part of ExtendedStandardFlags, cannot be reused\n@@ -392,1 +393,1 @@\n-     * Flag to indicate sealed class\/interface declaration.\n+     * Flag to indicate restricted method declaration.\n@@ -395,1 +396,1 @@\n-    public static final long SEALED = 1L<<62; \/\/ ClassSymbols\n+    public static final long RESTRICTED = 1L<<62; \/\/ MethodSymbols\n@@ -398,1 +399,1 @@\n-     * Flag to indicate restricted method declaration.\n+     * Flag to indicate parameters that require identity.\n@@ -400,1 +401,1 @@\n-    public static final long RESTRICTED = 1L<<62; \/\/ MethodSymbols\n+    public static final long REQUIRES_IDENTITY = 1L<<62; \/\/ VarSymbols (parameters)\n@@ -410,1 +411,1 @@\n-    public static final long NON_SEALED = 1L<<63; \/\/ ClassSymbols\n+    public static final long NON_SEALED = 1L<<63;  \/\/ part of ExtendedStandardFlags, cannot be reused\n@@ -441,0 +442,1 @@\n+        \/\/NOTE: flags in ExtendedStandardFlags cannot be overlayed across Symbol kinds:\n@@ -548,1 +550,1 @@\n-        \/\/ Bit 48 is currently available\n+        SEALED(Flags.SEALED),\n@@ -557,1 +559,1 @@\n-        SEALED(Flags.SEALED),\n+        RESTRICTED(Flags.RESTRICTED),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.ArrayList;\n@@ -29,0 +30,1 @@\n+import java.util.Collections;\n@@ -30,0 +32,2 @@\n+import java.util.LinkedHashMap;\n+import java.util.List;\n@@ -32,1 +36,1 @@\n-import java.util.concurrent.ConcurrentHashMap;\n+import java.util.Set;\n@@ -122,1 +126,1 @@\n-    private static final Map<String, LintCategory> map = new ConcurrentHashMap<>(20);\n+    private static final Map<String, LintCategory> map = new LinkedHashMap<>(40);\n@@ -152,1 +156,1 @@\n-        if (options.isSet(Option.XLINT) || options.isSet(Option.XLINT_CUSTOM, \"all\")) {\n+        if (options.isSet(Option.XLINT) || options.isSet(Option.XLINT_CUSTOM, Option.LINT_CUSTOM_ALL)) {\n@@ -155,1 +159,1 @@\n-        } else if (options.isSet(Option.XLINT_CUSTOM, \"none\")) {\n+        } else if (options.isSet(Option.XLINT_CUSTOM, Option.LINT_CUSTOM_NONE)) {\n@@ -176,1 +180,1 @@\n-            values.add(LintCategory.SYNCHRONIZATION);\n+            values.add(LintCategory.IDENTITY);\n@@ -182,1 +186,1 @@\n-            if (options.isSet(Option.XLINT_CUSTOM, lc.option)) {\n+            if (options.isLintExplicitlyEnabled(lc)) {\n@@ -184,1 +188,1 @@\n-            } else if (options.isSet(Option.XLINT_CUSTOM, \"-\" + lc.option)) {\n+            } else if (options.isLintExplicitlyDisabled(lc)) {\n@@ -264,0 +268,5 @@\n+        \/**\n+         * Warn about uses of @ValueBased classes where an identity class is expected.\n+         *\/\n+        IDENTITY(\"identity\", true, \"synchronization\"),\n+\n@@ -366,5 +375,0 @@\n-        \/**\n-         * Warn about synchronization attempts on instances of @ValueBased classes.\n-         *\/\n-        SYNCHRONIZATION(\"synchronization\"),\n-\n@@ -413,1 +417,1 @@\n-        LintCategory(String option, boolean annotationSuppression) {\n+        LintCategory(String option, boolean annotationSuppression, String... aliases) {\n@@ -416,1 +420,5 @@\n-            map.put(option, this);\n+            ArrayList<String> optionList = new ArrayList<>(1 + aliases.length);\n+            optionList.add(option);\n+            Collections.addAll(optionList, aliases);\n+            this.optionList = Collections.unmodifiableList(optionList);\n+            this.optionList.forEach(ident -> map.put(ident, this));\n@@ -429,0 +437,7 @@\n+        \/**\n+         * Get all lint category option strings and aliases.\n+         *\/\n+        public static Set<String> options() {\n+            return Collections.unmodifiableSet(map.keySet());\n+        }\n+\n@@ -433,1 +448,1 @@\n-        \/** Get the string representing this category in @SuppressAnnotations and -Xlint options. *\/\n+        \/** Get the \"canonical\" string representing this category in @SuppressAnnotations and -Xlint options. *\/\n@@ -436,0 +451,3 @@\n+        \/** Get a list containing \"option\" followed by zero or more aliases. *\/\n+        public final List<String> optionList;\n+\n@@ -499,14 +517,0 @@\n-    \/**\n-     * Retrieve the recognized lint categories suppressed by the given @SuppressWarnings annotation.\n-     *\n-     * @param annotation @SuppressWarnings annotation, or null\n-     * @return set of lint categories, possibly empty but never null\n-     *\/\n-    private EnumSet<LintCategory> suppressionsFrom(JCAnnotation annotation) {\n-        initializeSymbolsIfNeeded();\n-        if (annotation == null)\n-            return LintCategory.newEmptySet();\n-        Assert.check(annotation.attribute.type.tsym == syms.suppressWarningsType.tsym);\n-        return suppressionsFrom(Stream.of(annotation).map(anno -> anno.attribute));\n-    }\n-\n@@ -529,1 +533,3 @@\n-            Optional.of((String)((Attribute.Constant)value).value)\n+            Optional.of(value)\n+              .filter(val -> val instanceof Attribute.Constant)\n+              .map(val -> (String) ((Attribute.Constant) val).value)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":36,"deletions":30,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import com.sun.tools.javac.util.MandatoryWarningHandler;\n@@ -74,3 +73,0 @@\n-    \/** the diag handler to manage preview feature usage diagnostics *\/\n-    private final MandatoryWarningHandler previewHandler;\n-\n@@ -108,1 +104,0 @@\n-        previewHandler = new MandatoryWarningHandler(log, source, verbose, true, LintCategory.PREVIEW);\n@@ -179,1 +174,2 @@\n-        previewHandler.report(pos, feature.isPlural() ?\n+        log.mandatoryWarning(pos,\n+            feature.isPlural() ?\n@@ -206,4 +202,0 @@\n-    public void reportPreviewWarning(DiagnosticPosition pos, LintWarning warnKey) {\n-        previewHandler.report(pos, warnKey);\n-    }\n-\n@@ -272,11 +264,0 @@\n-    \/**\n-     * Report any deferred diagnostics.\n-     *\/\n-    public void reportDeferredDiagnostics() {\n-        previewHandler.reportDeferredDiagnostic();\n-    }\n-\n-    public void clear() {\n-        previewHandler.clear();\n-    }\n-\n@@ -286,1 +267,1 @@\n-            log.error(JCDiagnostic.DiagnosticFlag.SOURCE_LEVEL, pos, disabledError(feature));\n+            log.error(pos, disabledError(feature));\n@@ -289,2 +270,1 @@\n-                log.error(JCDiagnostic.DiagnosticFlag.SOURCE_LEVEL, pos,\n-                          feature.error(source.name));\n+                log.error(pos, feature.error(source.name));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":4,"deletions":24,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;\n@@ -1050,1 +1049,1 @@\n-            if (tree.restype != null && !tree.restype.type.hasTag(VOID))\n+            if (tree.restype != null && !tree.restype.type.hasTag(VOID)) {\n@@ -1052,0 +1051,2 @@\n+            }\n+            chk.checkRequiresIdentity(tree, env.info.lint);\n@@ -1238,2 +1239,2 @@\n-                \/\/ Start of constructor prologue\n-                localEnv.info.ctorPrologue = isConstructor;\n+                \/\/ Start of constructor prologue (if not in java.lang.Object constructor)\n+                localEnv.info.ctorPrologue = isConstructor && owner.type != syms.objectType;\n@@ -1331,0 +1332,1 @@\n+            chk.checkRequiresIdentity(tree, env.info.lint);\n@@ -1952,1 +1954,1 @@\n-        if (isValueBased(tree.lock.type)) {\n+        if (tree.lock.type != null && tree.lock.type.isValueBased()) {\n@@ -1958,5 +1960,0 @@\n-        \/\/ where\n-        private boolean isValueBased(Type t) {\n-            return t != null && t.tsym != null && (t.tsym.flags() & VALUE_BASED) != 0;\n-        }\n-\n@@ -2675,0 +2672,1 @@\n+        chk.checkRequiresIdentity(tree, env.info.lint);\n@@ -2838,1 +2836,1 @@\n-            if (cdef == null && !isSpeculativeDiamondInferenceRound && \/\/ class body may be nulled out in speculative tree copy\n+            if (cdef == null && !tree.classDeclRemoved() && !isSpeculativeDiamondInferenceRound && \/\/ class body may be nulled out in speculative tree copy\n@@ -2917,0 +2915,2 @@\n+            chk.checkRequiresIdentity(tree, env.info.lint);\n+\n@@ -3796,0 +3796,1 @@\n+            chk.checkRequiresIdentity(that, localEnv.info.lint);\n@@ -4099,0 +4100,1 @@\n+        chk.checkRequiresIdentity(tree, env.info.lint);\n@@ -4146,2 +4148,1 @@\n-                    log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n-                              Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF.error(this.sourceName));\n+                    log.error(tree.pos(), Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF.error(this.sourceName));\n@@ -4167,2 +4168,1 @@\n-                    log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n-                            Feature.REIFIABLE_TYPES_INSTANCEOF.error(this.sourceName));\n+                    log.error(tree.pos(), Feature.REIFIABLE_TYPES_INSTANCEOF.error(this.sourceName));\n@@ -4240,0 +4240,1 @@\n+        chk.checkRequiresIdentity(tree, env.info.lint);\n@@ -5474,2 +5475,7 @@\n-                                log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),\n-                                        Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subType)));\n+                                if(c.isInterface()) {\n+                                    log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),\n+                                            Errors.InvalidPermitsClause(Fragments.DoesntImplementSealed(kindName(subType.tsym), subType)));\n+                                } else {\n+                                    log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),\n+                                            Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subType)));\n+                                }\n@@ -5593,0 +5599,2 @@\n+        chk.checkRequiresIdentity(tree, env.info.lint);\n+\n@@ -5708,1 +5716,1 @@\n-            tree.vartype = make.at(Position.NOPOS).Erroneous();\n+            tree.vartype = make.at(tree.pos()).Erroneous();\n@@ -5710,1 +5718,1 @@\n-            tree.vartype = make.at(Position.NOPOS).Type(type);\n+            tree.vartype = make.at(tree.pos()).Type(type);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":27,"deletions":19,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.function.Function;\n@@ -49,0 +50,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties;\n@@ -165,12 +167,0 @@\n-        boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);\n-        boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);\n-        boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);\n-        boolean enforceMandatoryWarnings = true;\n-\n-        deprecationHandler = new MandatoryWarningHandler(log, null, verboseDeprecated,\n-                enforceMandatoryWarnings, LintCategory.DEPRECATION, \"deprecated\");\n-        removalHandler = new MandatoryWarningHandler(log, null, verboseRemoval,\n-                enforceMandatoryWarnings, LintCategory.REMOVAL);\n-        uncheckedHandler = new MandatoryWarningHandler(log, null, verboseUnchecked,\n-                enforceMandatoryWarnings, LintCategory.UNCHECKED);\n-\n@@ -193,12 +183,0 @@\n-    \/** A handler for messages about deprecated usage.\n-     *\/\n-    private MandatoryWarningHandler deprecationHandler;\n-\n-    \/** A handler for messages about deprecated-for-removal usage.\n-     *\/\n-    private MandatoryWarningHandler removalHandler;\n-\n-    \/** A handler for messages about unchecked or unsafe usage.\n-     *\/\n-    private MandatoryWarningHandler uncheckedHandler;\n-\n@@ -254,0 +232,1 @@\n+        LintWarning warningKey = null;\n@@ -257,1 +236,1 @@\n-                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemovalModule(sym));\n+                    warningKey = LintWarnings.HasBeenDeprecatedForRemovalModule(sym);\n@@ -259,1 +238,1 @@\n-                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location()));\n+                    warningKey = LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location());\n@@ -264,1 +243,1 @@\n-                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecatedModule(sym));\n+                warningKey = LintWarnings.HasBeenDeprecatedModule(sym);\n@@ -266,1 +245,1 @@\n-                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecated(sym, sym.location()));\n+                warningKey = LintWarnings.HasBeenDeprecated(sym, sym.location());\n@@ -269,0 +248,2 @@\n+        if (warningKey != null)\n+            log.mandatoryWarning(pos, warningKey);\n@@ -277,1 +258,1 @@\n-            preview.reportPreviewWarning(pos, warnKey);\n+            log.mandatoryWarning(pos, warnKey);\n@@ -294,1 +275,1 @@\n-            uncheckedHandler.report(pos, warnKey);\n+            log.mandatoryWarning(pos, warnKey);\n@@ -297,10 +278,0 @@\n-    \/**\n-     * Report any deferred diagnostics.\n-     *\/\n-    public void reportDeferredDiagnostics() {\n-        deprecationHandler.reportDeferredDiagnostic();\n-        removalHandler.reportDeferredDiagnostic();\n-        uncheckedHandler.reportDeferredDiagnostic();\n-    }\n-\n-\n@@ -312,1 +283,1 @@\n-        log.error(JCDiagnostic.DiagnosticFlag.NON_DEFERRABLE, pos, Errors.CantAccess(ex.sym, ex.getDetailValue()));\n+        log.error(DiagnosticFlag.NON_DEFERRABLE, pos, Errors.CantAccess(ex.sym, ex.getDetailValue()));\n@@ -475,6 +446,0 @@\n-    public void clear() {\n-        deprecationHandler.clear();\n-        removalHandler.clear();\n-        uncheckedHandler.clear();\n-    }\n-\n@@ -5670,0 +5635,181 @@\n+    void checkRequiresIdentity(JCTree tree, Lint lint) {\n+        switch (tree) {\n+            case JCClassDecl classDecl -> {\n+                Type st = types.supertype(classDecl.sym.type);\n+                if (st != null &&\n+                        \/\/ no need to recheck j.l.Object, shortcut,\n+                        st.tsym != syms.objectType.tsym &&\n+                        \/\/ this one could be null, no explicit extends\n+                        classDecl.extending != null) {\n+                    checkIfIdentityIsExpected(classDecl.extending.pos(), st, lint);\n+                }\n+                for (JCExpression intrface: classDecl.implementing) {\n+                    checkIfIdentityIsExpected(intrface.pos(), intrface.type, lint);\n+                }\n+                for (JCTypeParameter tp : classDecl.typarams) {\n+                    checkIfIdentityIsExpected(tp.pos(), tp.type, lint);\n+                }\n+            }\n+            case JCVariableDecl variableDecl -> {\n+                if (variableDecl.vartype != null &&\n+                        (variableDecl.sym.flags_field & RECORD) == 0 ||\n+                        (variableDecl.sym.flags_field & ~(Flags.PARAMETER | RECORD | GENERATED_MEMBER)) != 0) {\n+                    \/* we don't want to warn twice so if this variable is a compiler generated parameter of\n+                     * a canonical record constructor, we don't want to issue a warning as we will warn the\n+                     * corresponding compiler generated private record field anyways\n+                     *\/\n+                    checkIfIdentityIsExpected(variableDecl.vartype.pos(), variableDecl.vartype.type, lint);\n+                }\n+            }\n+            case JCTypeCast typeCast -> checkIfIdentityIsExpected(typeCast.clazz.pos(), typeCast.clazz.type, lint);\n+            case JCBindingPattern bindingPattern -> {\n+                if (bindingPattern.var.vartype != null) {\n+                    checkIfIdentityIsExpected(bindingPattern.var.vartype.pos(), bindingPattern.var.vartype.type, lint);\n+                }\n+            }\n+            case JCMethodDecl methodDecl -> {\n+                for (JCTypeParameter tp : methodDecl.typarams) {\n+                    checkIfIdentityIsExpected(tp.pos(), tp.type, lint);\n+                }\n+                if (methodDecl.restype != null && !methodDecl.restype.type.hasTag(VOID)) {\n+                    checkIfIdentityIsExpected(methodDecl.restype.pos(), methodDecl.restype.type, lint);\n+                }\n+            }\n+            case JCMemberReference mref -> {\n+                checkIfIdentityIsExpected(mref.expr.pos(), mref.target, lint);\n+                checkIfTypeParamsRequiresIdentity(mref.sym.getMetadata(), mref.typeargs, lint);\n+            }\n+            case JCPolyExpression poly\n+                when (poly instanceof JCNewClass || poly instanceof JCMethodInvocation) -> {\n+                if (poly instanceof JCNewClass newClass) {\n+                    checkIfIdentityIsExpected(newClass.clazz.pos(), newClass.clazz.type, lint);\n+                }\n+                List<JCExpression> argExps = poly instanceof JCNewClass ?\n+                        ((JCNewClass)poly).args :\n+                        ((JCMethodInvocation)poly).args;\n+                Symbol msym = TreeInfo.symbolFor(poly);\n+                if (msym != null) {\n+                    if (!argExps.isEmpty() && msym instanceof MethodSymbol ms && ms.params != null) {\n+                        VarSymbol lastParam = ms.params.head;\n+                        for (VarSymbol param: ms.params) {\n+                            if ((param.flags_field & REQUIRES_IDENTITY) != 0 && argExps.head.type.isValueBased()) {\n+                                lint.logIfEnabled(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                            }\n+                            lastParam = param;\n+                            argExps = argExps.tail;\n+                        }\n+                        while (argExps != null && !argExps.isEmpty() && lastParam != null) {\n+                            if ((lastParam.flags_field & REQUIRES_IDENTITY) != 0 && argExps.head.type.isValueBased()) {\n+                                lint.logIfEnabled(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                            }\n+                            argExps = argExps.tail;\n+                        }\n+                    }\n+                    checkIfTypeParamsRequiresIdentity(\n+                            msym.getMetadata(),\n+                            poly instanceof JCNewClass ?\n+                                ((JCNewClass)poly).typeargs :\n+                                ((JCMethodInvocation)poly).typeargs,\n+                            lint);\n+                }\n+            }\n+            default -> throw new AssertionError(\"unexpected tree \" + tree);\n+        }\n+    }\n+\n+    \/** Check if a type required an identity class\n+     *\/\n+    private boolean checkIfIdentityIsExpected(DiagnosticPosition pos, Type t, Lint lint) {\n+        if (t != null &&\n+                lint != null &&\n+                lint.isEnabled(LintCategory.IDENTITY)) {\n+            RequiresIdentityVisitor requiresIdentityVisitor = new RequiresIdentityVisitor();\n+            \/\/ we need to avoid recursion due to self referencing type vars or captures, this is why we need a set\n+            requiresIdentityVisitor.visit(t, new HashSet<>());\n+            if (requiresIdentityVisitor.requiresWarning) {\n+                lint.logIfEnabled(pos, LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/\/ where\n+    private class RequiresIdentityVisitor extends Types.SimpleVisitor<Void, Set<Type>> {\n+        boolean requiresWarning = false;\n+\n+        @Override\n+        public Void visitType(Type t, Set<Type> seen) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitWildcardType(WildcardType t, Set<Type> seen) {\n+            return visit(t.type, seen);\n+        }\n+\n+        @Override\n+        public Void visitTypeVar(TypeVar t, Set<Type> seen) {\n+            if (seen.add(t)) {\n+                visit(t.getUpperBound(), seen);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitCapturedType(CapturedType t, Set<Type> seen) {\n+            if (seen.add(t)) {\n+                visit(t.getUpperBound(), seen);\n+                visit(t.getLowerBound(), seen);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitArrayType(ArrayType t, Set<Type> seen) {\n+            return visit(t.elemtype, seen);\n+        }\n+\n+        @Override\n+        public Void visitClassType(ClassType t, Set<Type> seen) {\n+            if (t != null && t.tsym != null) {\n+                SymbolMetadata sm = t.tsym.getMetadata();\n+                if (sm != null && !t.getTypeArguments().isEmpty()) {\n+                    if (sm.getTypeAttributes().stream()\n+                            .filter(ta -> isRequiresIdentityAnnotation(ta.type.tsym) &&\n+                                    t.getTypeArguments().get(ta.position.parameter_index) != null &&\n+                                    t.getTypeArguments().get(ta.position.parameter_index).isValueBased()).findAny().isPresent()) {\n+                        requiresWarning = true;\n+                        return null;\n+                    }\n+                }\n+            }\n+            visit(t.getEnclosingType(), seen);\n+            for (Type targ : t.getTypeArguments()) {\n+                visit(targ, seen);\n+            }\n+            return null;\n+        }\n+    } \/\/ RequiresIdentityVisitor\n+\n+    private void checkIfTypeParamsRequiresIdentity(SymbolMetadata sm,\n+                                                     List<JCExpression> typeParamTrees,\n+                                                     Lint lint) {\n+        if (typeParamTrees != null && !typeParamTrees.isEmpty()) {\n+            for (JCExpression targ : typeParamTrees) {\n+                checkIfIdentityIsExpected(targ.pos(), targ.type, lint);\n+            }\n+            if (sm != null)\n+                sm.getTypeAttributes().stream()\n+                        .filter(ta -> isRequiresIdentityAnnotation(ta.type.tsym) &&\n+                                typeParamTrees.get(ta.position.parameter_index).type != null &&\n+                                typeParamTrees.get(ta.position.parameter_index).type.isValueBased())\n+                        .forEach(ta -> lint.logIfEnabled(typeParamTrees.get(ta.position.parameter_index).pos(),\n+                                CompilerProperties.LintWarnings.AttemptToUseValueBasedWhereIdentityExpected));\n+        }\n+    }\n+\n+    private boolean isRequiresIdentityAnnotation(TypeSymbol annoType) {\n+        return annoType == syms.requiresIdentityType.tsym ||\n+               annoType.flatName() == syms.requiresIdentityInternalType.tsym.flatName();\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":193,"deletions":47,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -2834,1 +2834,2 @@\n-            JCExpression exactnessCheck = null;\n+            JCStatement prefixStatement;\n+            JCExpression exactnessCheck;\n@@ -2837,8 +2838,2 @@\n-            \/\/ preserving the side effects of the value\n-            VarSymbol dollar_s = new VarSymbol(FINAL | SYNTHETIC,\n-                    names.fromString(\"tmp\" + variableIndex++ + this.target.syntheticNameChar()),\n-                    types.erasure(tree.expr.type),\n-                    currentMethodSym);\n-            JCStatement var = make.at(tree.pos())\n-                    .VarDef(dollar_s, instanceOfExpr);\n-\n+                \/\/ instanceOfExpr; true\n+                prefixStatement = make.Exec(instanceOfExpr);\n@@ -2847,7 +2842,5 @@\n-            }\n-            else if (tree.expr.type.isReference()) {\n-                JCExpression nullCheck =\n-                        makeBinary(NE,\n-                            make.Ident(dollar_s),\n-                            makeNull());\n-\n+            } else if (tree.expr.type.isPrimitive()) {\n+                \/\/ ExactConversionSupport.isXxxExact(instanceOfExpr)\n+                prefixStatement = null;\n+                exactnessCheck = getExactnessCheck(tree, instanceOfExpr);\n+            } else if (tree.expr.type.isReference()) {\n@@ -2855,6 +2848,3 @@\n-                    exactnessCheck = nullCheck;\n-                } else if (types.unboxedType(tree.expr.type).isPrimitive()) {\n-                    exactnessCheck =\n-                        makeBinary(AND,\n-                            nullCheck,\n-                            getExactnessCheck(tree, boxIfNeeded(make.Ident(dollar_s), types.unboxedType(tree.expr.type))));\n+                    \/\/ instanceOfExpr != null\n+                    prefixStatement = null;\n+                    exactnessCheck = makeBinary(NE, instanceOfExpr, makeNull());\n@@ -2862,6 +2852,26 @@\n-                    exactnessCheck =\n-                        makeBinary(AND,\n-                            nullCheck,\n-                            make.at(tree.pos())\n-                                .TypeTest(make.Ident(dollar_s), make.Type(types.boxedClass(tree.pattern.type).type))\n-                                .setType(syms.booleanType));\n+                    \/\/ We read the result of instanceOfExpr, so create variable\n+                    VarSymbol dollar_s = new VarSymbol(FINAL | SYNTHETIC,\n+                            names.fromString(\"tmp\" + variableIndex++ + this.target.syntheticNameChar()),\n+                            types.erasure(tree.expr.type),\n+                            currentMethodSym);\n+                    prefixStatement = make.at(tree.pos())\n+                            .VarDef(dollar_s, instanceOfExpr);\n+\n+                    JCExpression nullCheck =\n+                            makeBinary(NE,\n+                                    make.Ident(dollar_s),\n+                                    makeNull());\n+\n+                    if (types.unboxedType(tree.expr.type).isPrimitive()) {\n+                        exactnessCheck =\n+                            makeBinary(AND,\n+                                nullCheck,\n+                                getExactnessCheck(tree, boxIfNeeded(make.Ident(dollar_s), types.unboxedType(tree.expr.type))));\n+                    } else {\n+                        exactnessCheck =\n+                            makeBinary(AND,\n+                                nullCheck,\n+                                make.at(tree.pos())\n+                                    .TypeTest(make.Ident(dollar_s), make.Type(types.boxedClass(tree.pattern.type).type))\n+                                    .setType(syms.booleanType));\n+                    }\n@@ -2869,0 +2879,2 @@\n+            } else {\n+                throw Assert.error(\"Non primitive or reference type: \" + tree.expr.type);\n@@ -2870,5 +2882,1 @@\n-            else if (tree.expr.type.isPrimitive()) {\n-                exactnessCheck = getExactnessCheck(tree, make.Ident(dollar_s));\n-            }\n-\n-            result = make.LetExpr(List.of(var), exactnessCheck)\n+            result = (prefixStatement == null ? exactnessCheck : make.LetExpr(List.of(prefixStatement), exactnessCheck))\n@@ -3700,1 +3708,1 @@\n-            body.endpos = TreeInfo.endPos(tree.body);\n+            body.bracePos = TreeInfo.endPos(tree.body);\n@@ -4161,1 +4169,1 @@\n-                res.endpos = TreeInfo.endPos(tree);\n+                res.bracePos = TreeInfo.endPos(tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":43,"deletions":35,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import com.sun.tools.javac.code.Preview;\n+import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -36,0 +36,1 @@\n+import com.sun.tools.javac.util.Log;\n@@ -123,1 +124,4 @@\n-        MemoryPreview.registerInstance(context);\n+\n+        \/\/ This suppresses diagnostics like \"Note: Recompile with -Xlint:preview for details.\"\n+        Log.instance(context).suppressAggregatedWarningNotes(LintCategory.PREVIEW);\n+\n@@ -272,15 +276,0 @@\n-\n-    static class MemoryPreview extends Preview {\n-        static void registerInstance(Context context) {\n-            context.put(previewKey, (Factory<Preview>)MemoryPreview::new);\n-        }\n-\n-        MemoryPreview(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public void reportDeferredDiagnostics() {\n-            \/\/ suppress diagnostics like \"Note: Recompile with -Xlint:preview for details.\"\n-        }\n-    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/MemoryContext.java","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -62,0 +61,1 @@\n+import com.sun.tools.javac.code.Symbol.ModuleSymbol;\n@@ -88,4 +88,0 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.code.Lint.LintCategory;\n-import com.sun.tools.javac.code.Symbol.ModuleSymbol;\n-\n@@ -277,4 +273,0 @@\n-    \/** The preview language version.\n-     *\/\n-    protected Preview preview;\n-\n@@ -416,1 +408,0 @@\n-        preview = Preview.instance(context);\n@@ -1855,2 +1846,1 @@\n-        chk.reportDeferredDiagnostics();\n-        preview.reportDeferredDiagnostics();\n+        log.reportOutstandingNotes();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-            lexError(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));\n+            lexError(pos, preview.disabledError(feature));\n@@ -187,1 +187,1 @@\n-            lexError(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));\n+            lexError(pos, feature.error(source.name));\n@@ -202,14 +202,1 @@\n-        tk = TokenKind.ERROR;\n-        errPos = pos;\n-    }\n-\n-    \/**\n-     * Report an error at the given position using the provided arguments.\n-     *\n-     * @param flags  diagnostic flags.\n-     * @param pos    position in input buffer.\n-     * @param key    error key to report.\n-     *\/\n-    protected void lexError(DiagnosticFlag flags, int pos, JCDiagnostic.Error key) {\n-        log.error(flags, pos, key);\n-        if (flags != DiagnosticFlag.SOURCE_LEVEL) {\n+        if (!key.hasFlag(DiagnosticFlag.SOURCE_LEVEL)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -234,2 +234,2 @@\n-                ? new SimpleEndPosTable(this)\n-                : new EmptyEndPosTable(this);\n+                ? new SimpleEndPosTable()\n+                : new MinimalEndPosTable();\n@@ -636,0 +636,1 @@\n+     *  @return {@code tree}\n@@ -637,1 +638,1 @@\n-    protected void attach(JCTree tree, Comment dc) {\n+    protected <T extends JCTree> T attach(T tree, Comment dc) {\n@@ -642,0 +643,1 @@\n+        return tree;\n@@ -705,2 +707,9 @@\n-    protected void storeEnd(JCTree tree, int endpos) {\n-        endPosTable.storeEnd(tree, endpos);\n+    \/**\n+     * Store ending position for a tree, the value of which is the greater of\n+     * last error position in {@link #endPosTable} and the given ending position.\n+     * @param tree tree node\n+     * @param endpos the ending position to associate with {@code tree}\n+     * @return {@code tree}\n+     *\/\n+    protected <T extends JCTree> T storeEnd(T tree, int endpos) {\n+        return endPosTable.storeEnd(tree, endpos);\n@@ -709,2 +718,8 @@\n-    protected <T extends JCTree> T to(T t) {\n-        return endPosTable.to(t);\n+    \/**\n+     * Store current token's ending position for a tree, the value of which\n+     * will be the greater of last error position in {@link #endPosTable}\n+     * and the ending position of the current token.\n+     * @param tree tree node\n+     *\/\n+    protected <T extends JCTree> T to(T tree) {\n+        return storeEnd(tree, token.endPos);\n@@ -713,2 +728,8 @@\n-    protected <T extends JCTree> T toP(T t) {\n-        return endPosTable.toP(t);\n+    \/**\n+     * Store current token's ending position for a tree, the value of which\n+     * will be the greater of last error position in {@link #endPosTable}\n+     * and the ending position of the previous token.\n+     * @param tree tree node\n+     *\/\n+    protected <T extends JCTree> T toP(T tree) {\n+        return storeEnd(tree, S.prevToken().endPos);\n@@ -1744,1 +1765,1 @@\n-                    e.endpos = token.pos;\n+                    e.bracePos = token.pos;\n@@ -2822,1 +2843,1 @@\n-        \/\/ the Block node has a field \"endpos\" for first char of last token, which is\n+        \/\/ the Block node has a field \"bracePos\" for first char of last token, which is\n@@ -2824,1 +2845,1 @@\n-        t.endpos = token.pos;\n+        t.bracePos = token.pos;\n@@ -3145,1 +3166,1 @@\n-            t.endpos = token.endPos;\n+            t.bracePos = token.endPos;\n@@ -3661,3 +3682,1 @@\n-\n-        storeEnd(ann, S.prevToken().endPos);\n-        return ann;\n+        return toP(ann);\n@@ -3838,2 +3857,1 @@\n-        attach(result, dc);\n-        return result;\n+        return attach(result, dc);\n@@ -4134,1 +4152,1 @@\n-        List<JCTree> topLevelDefs = isImplicitClass ?  constructImplicitClass(defs.toList()) : defs.toList();\n+        List<JCTree> topLevelDefs = isImplicitClass ? constructImplicitClass(defs.toList(), S.prevToken().endPos) : defs.toList();\n@@ -4144,1 +4162,0 @@\n-        this.endPosTable.setParser(null); \/\/ remove reference to parser\n@@ -4150,1 +4167,1 @@\n-    private List<JCTree> constructImplicitClass(List<JCTree> origDefs) {\n+    private List<JCTree> constructImplicitClass(List<JCTree> origDefs, int endPos) {\n@@ -4180,0 +4197,1 @@\n+        storeEnd(implicit, endPos);\n@@ -4195,0 +4213,1 @@\n+        int endPos = S.prevToken().endPos;\n@@ -4197,3 +4216,3 @@\n-        JCModuleDecl result = toP(F.at(pos).ModuleDef(mods, kind, name, directives));\n-        attach(result, dc);\n-        return result;\n+        JCModuleDecl result = F.at(pos).ModuleDef(mods, kind, name, directives);\n+        storeEnd(result, endPos);\n+        return attach(result, dc);\n@@ -4389,2 +4408,1 @@\n-        attach(result, dc);\n-        return result;\n+        return attach(result, dc);\n@@ -4437,2 +4455,1 @@\n-        attach(result, dc);\n-        return result;\n+        return attach(result, dc);\n@@ -4477,2 +4494,1 @@\n-        attach(result, dc);\n-        return result;\n+        return attach(result, dc);\n@@ -4525,2 +4541,1 @@\n-        attach(result, dc);\n-        return result;\n+        return attach(result, dc);\n@@ -4667,2 +4682,1 @@\n-        attach(result, dc);\n-        return result;\n+        return attach(result, dc);\n@@ -5100,2 +5114,1 @@\n-            attach(result, dc);\n-            return result;\n+            return attach(result, dc);\n@@ -5398,2 +5411,1 @@\n-            storeEnd(type, origEndPos);\n-            return type;\n+            return storeEnd(type, origEndPos);\n@@ -5602,1 +5614,1 @@\n-            log.error(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));\n+            log.error(pos, preview.disabledError(feature));\n@@ -5605,1 +5617,1 @@\n-            log.error(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));\n+            log.error(pos, feature.error(source.name));\n@@ -5625,2 +5637,2 @@\n-    \/*\n-     * a functional source tree and end position mappings\n+    \/**\n+     * A straightforward {@link EndPosTable} implementation.\n@@ -5630,10 +5642,1 @@\n-        private final IntHashTable endPosMap;\n-\n-        SimpleEndPosTable(JavacParser parser) {\n-            super(parser);\n-            endPosMap = new IntHashTable();\n-        }\n-\n-        public void storeEnd(JCTree tree, int endpos) {\n-            endPosMap.put(tree, errorEndPos > endpos ? errorEndPos : endpos);\n-        }\n+        private final IntHashTable endPosMap = new IntHashTable();\n@@ -5641,8 +5644,4 @@\n-        protected <T extends JCTree> T to(T t) {\n-            storeEnd(t, parser.token.endPos);\n-            return t;\n-        }\n-\n-        protected <T extends JCTree> T toP(T t) {\n-            storeEnd(t, parser.S.prevToken().endPos);\n-            return t;\n+        @Override\n+        public <T extends JCTree> T storeEnd(T tree, int endpos) {\n+            endPosMap.put(tree, Math.max(endpos, errorEndPos));\n+            return tree;\n@@ -5651,0 +5650,1 @@\n+        @Override\n@@ -5657,0 +5657,1 @@\n+        @Override\n@@ -5659,1 +5660,1 @@\n-            if (pos != -1) {\n+            if (pos != -1 && newTree != null) {\n@@ -5661,2 +5662,1 @@\n-                return pos;\n-            return Position.NOPOS;\n+            return pos;\n@@ -5667,2 +5667,2 @@\n-    \/*\n-     * a default skeletal implementation without any mapping overhead.\n+    \/**\n+     * A minimal implementation that only stores what's required.\n@@ -5670,19 +5670,1 @@\n-    protected static class EmptyEndPosTable extends AbstractEndPosTable {\n-\n-        EmptyEndPosTable(JavacParser parser) {\n-            super(parser);\n-        }\n-\n-        public void storeEnd(JCTree tree, int endpos) { \/* empty *\/ }\n-\n-        protected <T extends JCTree> T to(T t) {\n-            return t;\n-        }\n-\n-        protected <T extends JCTree> T toP(T t) {\n-            return t;\n-        }\n-\n-        public int getEndPos(JCTree tree) {\n-            return Position.NOPOS;\n-        }\n+    protected static class MinimalEndPosTable extends SimpleEndPosTable {\n@@ -5690,2 +5672,13 @@\n-        public int replaceTree(JCTree oldTree, JCTree newTree) {\n-            return Position.NOPOS;\n+        @Override\n+        public <T extends JCTree> T storeEnd(T tree, int endpos) {\n+            switch (tree.getTag()) {\n+            case MODULEDEF:\n+            case PACKAGEDEF:\n+            case CLASSDEF:\n+            case METHODDEF:\n+            case VARDEF:\n+                break;\n+            default:\n+                return tree;\n+            }\n+            return super.storeEnd(tree, endpos);\n@@ -5693,1 +5686,0 @@\n-\n@@ -5697,4 +5689,0 @@\n-        \/**\n-         * The current parser.\n-         *\/\n-        protected JavacParser parser;\n@@ -5707,25 +5695,1 @@\n-        public AbstractEndPosTable(JavacParser parser) {\n-            this.parser = parser;\n-        }\n-\n-        \/**\n-         * Store current token's ending position for a tree, the value of which\n-         * will be the greater of last error position and the ending position of\n-         * the current token.\n-         * @param t The tree.\n-         *\/\n-        protected abstract <T extends JCTree> T to(T t);\n-\n-        \/**\n-         * Store current token's ending position for a tree, the value of which\n-         * will be the greater of last error position and the ending position of\n-         * the previous token.\n-         * @param t The tree.\n-         *\/\n-        protected abstract <T extends JCTree> T toP(T t);\n-\n-        \/**\n-         * Set the error position during the parsing phases, the value of which\n-         * will be set only if it is greater than the last stored error position.\n-         * @param errPos The error position\n-         *\/\n+        @Override\n@@ -5737,4 +5701,0 @@\n-\n-        public void setParser(JavacParser parser) {\n-            this.parser = parser;\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":80,"deletions":120,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -1926,0 +1926,1 @@\n+# flags: aggregate\n@@ -1931,0 +1932,1 @@\n+# flags: aggregate\n@@ -1936,0 +1938,1 @@\n+# flags: aggregate\n@@ -1946,0 +1949,1 @@\n+# flags: aggregate\n@@ -1957,0 +1961,1 @@\n+# flags: aggregate\n@@ -1962,0 +1967,1 @@\n+# flags: aggregate\n@@ -2360,0 +2366,1 @@\n+# flags: aggregate\n@@ -2365,0 +2372,1 @@\n+# flags: aggregate\n@@ -2374,0 +2382,1 @@\n+# flags: aggregate\n@@ -2381,0 +2390,1 @@\n+# flags: aggregate\n@@ -2386,0 +2396,1 @@\n+# flags: aggregate\n@@ -2784,0 +2795,1 @@\n+# flags: aggregate\n@@ -3180,0 +3192,1 @@\n+# flags: aggregate\n@@ -3186,0 +3199,1 @@\n+# flags: aggregate\n@@ -3249,0 +3263,1 @@\n+# flags: source-level\n@@ -3254,0 +3269,1 @@\n+# flags: source-level\n@@ -3269,0 +3285,1 @@\n+# flags: source-level\n@@ -3274,0 +3291,1 @@\n+# flags: source-level\n@@ -3285,0 +3303,1 @@\n+# flags: aggregate\n@@ -3290,0 +3309,1 @@\n+# flags: aggregate\n@@ -3960,1 +3980,5 @@\n-    subclass {0} must extend sealed class\n+    class {0} must extend sealed class\n+\n+# 0: kind name, 1: type\n+compiler.misc.doesnt.implement.sealed=\\\n+    {0} {1} must extend sealed interface\n@@ -4248,0 +4272,1 @@\n+# flags: aggregate\n@@ -4251,1 +4276,1 @@\n-# lint: synchronization\n+# lint: identity\n@@ -4255,0 +4280,4 @@\n+# lint: identity\n+compiler.warn.attempt.to.use.value.based.where.identity.expected=\\\n+    use of a value-based class with an operation that expects reliable identity\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":31,"deletions":2,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -294,0 +294,1 @@\n+# L10N: do not localize: identity synchronization\n@@ -295,1 +296,7 @@\n-    Warn about synchronization attempts on instances of value-based classes.\n+    Warn about synchronization attempts on instances of value-based classes.\\n\\\n+\\                         This key is a deprecated alias for ''identity'', which has the same uses and\\n\\\n+\\                         effects. Users are encouraged to use the ''identity'' category for all future\\n\\\n+\\                         and existing uses of ''synchronization''.\n+\n+javac.opt.Xlint.desc.identity=\\\n+    Warn about uses of value-based classes where an identity class is expected.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Arrays;\n@@ -240,1 +241,1 @@\n-            return create(EnumSet.noneOf(DiagnosticFlag.class), source, pos, DiagnosticInfo.of(kind, prefix, key, args));\n+            return create(EnumSet.noneOf(DiagnosticFlag.class), source, pos, DiagnosticInfo.of(kind, null, prefix, key, args));\n@@ -255,1 +256,1 @@\n-            return create(EnumSet.noneOf(DiagnosticFlag.class), source, pos, DiagnosticInfo.of(kind, prefix, key, args), rewriter);\n+            return create(EnumSet.noneOf(DiagnosticFlag.class), source, pos, DiagnosticInfo.of(kind, null, prefix, key, args), rewriter);\n@@ -282,1 +283,1 @@\n-            return create(flags, source, pos, DiagnosticInfo.of(kind, lc, prefix, key, args));\n+            return create(flags, source, pos, DiagnosticInfo.of(kind, null, lc, prefix, key, args));\n@@ -306,1 +307,2 @@\n-                return DiagnosticInfo.of(diagnosticInfo.type, category, diagnosticInfo.prefix, diagnosticInfo.code,\n+                return DiagnosticInfo.of(diagnosticInfo.type, diagnosticInfo.flags,\n+                        category, diagnosticInfo.prefix, diagnosticInfo.code,\n@@ -317,1 +319,1 @@\n-            return (Error)DiagnosticInfo.of(ERROR, prefix, code, args);\n+            return (Error)DiagnosticInfo.of(ERROR, null, prefix, code, args);\n@@ -324,1 +326,1 @@\n-            return (Warning)DiagnosticInfo.of(WARNING, lintCategory, prefix, code, args);\n+            return (Warning)DiagnosticInfo.of(WARNING, null, lintCategory, prefix, code, args);\n@@ -331,1 +333,1 @@\n-            return (Note)DiagnosticInfo.of(NOTE, prefix, code, args);\n+            return (Note)DiagnosticInfo.of(NOTE, null, prefix, code, args);\n@@ -338,1 +340,1 @@\n-            return (Fragment)DiagnosticInfo.of(FRAGMENT, prefix, code, args);\n+            return (Fragment)DiagnosticInfo.of(FRAGMENT, null, prefix, code, args);\n@@ -354,0 +356,1 @@\n+                                      null,\n@@ -450,0 +453,3 @@\n+        \/** Flags mandatory warnings that should pass through a mandatory warning aggregator.\n+         *\/\n+        AGGREGATE,\n@@ -506,0 +512,3 @@\n+        \/** A set of diagnostic flags to be automatically added to newly created JCDiagnostics. *\/\n+        Set<DiagnosticFlag> flags;\n+\n@@ -516,1 +525,1 @@\n-        private DiagnosticInfo(DiagnosticType type, String prefix, String code, Object... args) {\n+        private DiagnosticInfo(DiagnosticType type, Set<DiagnosticFlag> flags, String prefix, String code, Object... args) {\n@@ -518,0 +527,1 @@\n+            this.flags = flags != null ? flags : EnumSet.noneOf(DiagnosticFlag.class);\n@@ -533,2 +543,3 @@\n-        public static DiagnosticInfo of(DiagnosticType type, String prefix, String code, Object... args) {\n-            return of(type, null, prefix, code, args);\n+        public static DiagnosticInfo of(DiagnosticType type, Set<DiagnosticFlag> flags,\n+            String prefix, String code, Object... args) {\n+            return of(type, flags, null, prefix, code, args);\n@@ -537,1 +548,2 @@\n-        public static DiagnosticInfo of(DiagnosticType type, LintCategory lc, String prefix, String code, Object... args) {\n+        public static DiagnosticInfo of(DiagnosticType type, Set<DiagnosticFlag> flags,\n+            LintCategory lc, String prefix, String code, Object... args) {\n@@ -540,1 +552,1 @@\n-                    return new Error(prefix, code, args);\n+                    return new Error(flags, prefix, code, args);\n@@ -543,2 +555,2 @@\n-                            new Warning(prefix, code, args) :\n-                            new LintWarning(lc, prefix, code, args);\n+                            new Warning(flags, prefix, code, args) :\n+                            new LintWarning(flags, lc, prefix, code, args);\n@@ -546,1 +558,1 @@\n-                    return new Note(prefix, code, args);\n+                    return new Note(flags, prefix, code, args);\n@@ -548,1 +560,1 @@\n-                    return new Fragment(prefix, code, args);\n+                    return new Fragment(flags, prefix, code, args);\n@@ -572,0 +584,4 @@\n+\n+        public boolean hasFlag(DiagnosticFlag flag) {\n+            return flags.contains(flag);\n+        }\n@@ -578,2 +594,2 @@\n-        public Error(String prefix, String key, Object... args) {\n-            super(DiagnosticType.ERROR, prefix, key, args);\n+        public Error(Set<DiagnosticFlag> flags, String prefix, String key, Object... args) {\n+            super(DiagnosticType.ERROR, flags, prefix, key, args);\n@@ -587,2 +603,2 @@\n-        public Warning(String prefix, String key, Object... args) {\n-            super(DiagnosticType.WARNING, prefix, key, args);\n+        public Warning(Set<DiagnosticFlag> flags, String prefix, String key, Object... args) {\n+            super(DiagnosticType.WARNING, flags, prefix, key, args);\n@@ -598,2 +614,2 @@\n-        public LintWarning(LintCategory category, String prefix, String key, Object... args) {\n-            super(prefix, key, args);\n+        public LintWarning(Set<DiagnosticFlag> flags, LintCategory category, String prefix, String key, Object... args) {\n+            super(flags, prefix, key, args);\n@@ -612,2 +628,2 @@\n-        public Note(String prefix, String key, Object... args) {\n-            super(DiagnosticType.NOTE, prefix, key, args);\n+        public Note(Set<DiagnosticFlag> flags, String prefix, String key, Object... args) {\n+            super(DiagnosticType.NOTE, flags, prefix, key, args);\n@@ -621,2 +637,2 @@\n-        public Fragment(String prefix, String key, Object... args) {\n-            super(DiagnosticType.FRAGMENT, prefix, key, args);\n+        public Fragment(Set<DiagnosticFlag> flags, String prefix, String key, Object... args) {\n+            super(DiagnosticType.FRAGMENT, flags, prefix, key, args);\n@@ -667,0 +683,2 @@\n+\n+        this.flags.addAll(diagnosticInfo.flags);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/JCDiagnostic.java","additions":45,"deletions":27,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.EnumSet;\n@@ -44,0 +45,3 @@\n+import com.sun.tools.javac.code.Lint;\n+import com.sun.tools.javac.code.Lint.LintCategory;\n+import com.sun.tools.javac.code.Source;\n@@ -47,1 +51,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;\n@@ -53,0 +56,1 @@\n+import static com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag.*;\n@@ -151,1 +155,1 @@\n-            return !(diag.isFlagSet(DiagnosticFlag.NON_DEFERRABLE) && passOnNonDeferrable) && filter.test(diag);\n+            return !(diag.isFlagSet(NON_DEFERRABLE) && passOnNonDeferrable) && filter.test(diag);\n@@ -240,0 +244,10 @@\n+    \/**\n+     * The compilation context.\n+     *\/\n+    private final Context context;\n+\n+    \/**\n+     * The root {@link Lint} singleton.\n+     *\/\n+    private Lint rootLint;\n+\n@@ -337,0 +351,1 @@\n+        this.context = context;\n@@ -520,1 +535,1 @@\n-        if (!d.isFlagSet(DiagnosticFlag.SOURCE_LEVEL))\n+        if (!d.isFlagSet(SOURCE_LEVEL))\n@@ -684,1 +699,42 @@\n-     }\n+    }\n+\n+    \/\/ Obtain root Lint singleton lazily to avoid init loops\n+    private Lint rootLint() {\n+        if (rootLint == null)\n+            rootLint = Lint.instance(context);\n+        return rootLint;\n+    }\n+\n+\/\/ Mandatory Warnings\n+\n+    private final EnumMap<LintCategory, WarningAggregator> aggregators = new EnumMap<>(LintCategory.class);\n+\n+    private final EnumSet<LintCategory> suppressedDeferredMandatory = EnumSet.noneOf(LintCategory.class);\n+\n+    \/**\n+     * Suppress aggregated mandatory warning notes for the specified category.\n+     *\/\n+    public void suppressAggregatedWarningNotes(LintCategory category) {\n+        suppressedDeferredMandatory.add(category);\n+    }\n+\n+    \/**\n+     * Report any remaining unreported aggregated mandatory warning notes.\n+     *\/\n+    public void reportOutstandingNotes() {\n+        aggregators.entrySet().stream()\n+          .filter(entry -> !suppressedDeferredMandatory.contains(entry.getKey()))\n+          .map(Map.Entry::getValue)\n+          .map(WarningAggregator::aggregationNotes)\n+          .flatMap(List::stream)\n+          .forEach(this::report);\n+        aggregators.clear();\n+    }\n+\n+    private WarningAggregator aggregatorFor(LintCategory lc) {\n+        return switch (lc) {\n+        case PREVIEW -> aggregators.computeIfAbsent(lc, c -> new WarningAggregator(this, Source.instance(context), c));\n+        case DEPRECATION -> aggregators.computeIfAbsent(lc, c -> new WarningAggregator(this, null, c, \"deprecated\"));\n+        default -> aggregators.computeIfAbsent(lc, c -> new WarningAggregator(this, null, c));\n+        };\n+    }\n@@ -698,0 +754,2 @@\n+        aggregators.clear();\n+        suppressedDeferredMandatory.clear();\n@@ -700,0 +758,2 @@\n+\/\/ DefaultDiagnosticHandler\n+\n@@ -706,0 +766,1 @@\n+\n@@ -730,0 +791,10 @@\n+\n+                \/\/ Apply the appropriate mandatory warning aggregator, if needed\n+                if (diagnostic.isFlagSet(AGGREGATE)) {\n+                    LintCategory category = diagnostic.getLintCategory();\n+                    boolean verbose = rootLint().isEnabled(category);\n+                    if (!aggregatorFor(category).aggregate(diagnostic, verbose))\n+                        return;\n+                }\n+\n+                \/\/ Emit warning unless not mandatory and warnings are disabled\n@@ -741,2 +812,1 @@\n-                if (diagnostic.isFlagSet(DiagnosticFlag.API) ||\n-                     shouldReport(diagnostic)) {\n+                if (diagnostic.isFlagSet(API) || shouldReport(diagnostic)) {\n@@ -752,1 +822,1 @@\n-            if (diagnostic.isFlagSet(JCDiagnostic.DiagnosticFlag.COMPRESSED)) {\n+            if (diagnostic.isFlagSet(COMPRESSED)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Log.java","additions":77,"deletions":7,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -1,309 +1,0 @@\n-\/*\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.javac.util;\n-\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.Set;\n-import javax.tools.JavaFileObject;\n-\n-import com.sun.tools.javac.code.Lint.LintCategory;\n-import com.sun.tools.javac.code.Source;\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n-import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n-import com.sun.tools.javac.util.JCDiagnostic.Note;\n-import com.sun.tools.javac.util.JCDiagnostic.Warning;\n-\n-\n-\/**\n- * A handler to process mandatory warnings, setting up a deferred diagnostic\n- * to be printed at the end of the compilation if some warnings get suppressed\n- * because too many warnings have already been generated.\n- *\n- * <p>\n- * Note that the SuppressWarnings annotation can be used to suppress warnings\n- * about conditions that would otherwise merit a warning. Such processing\n- * is done when the condition is detected, and in those cases, no call is\n- * made on any API to generate a warning at all. In consequence, this handler only\n- * Returns to handle those warnings that JLS says must be generated.\n- *\n- * <p>\n- * All warnings must be in the same {@link LintCategory} provided to the constructor.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class MandatoryWarningHandler {\n-\n-    \/**\n-     * The kinds of different deferred diagnostics that might be generated\n-     * if a mandatory warning is suppressed because too many warnings have\n-     * already been output.\n-     *\n-     * The parameter is a fragment used to build an I18N message key for Log.\n-     *\/\n-    private enum DeferredDiagnosticKind {\n-        \/**\n-         * This kind is used when a single specific file is found to have warnings\n-         * and no similar warnings have already been given.\n-         * It generates a message like:\n-         *      FILE has ISSUES\n-         *\/\n-        IN_FILE(\".filename\"),\n-        \/**\n-         * This kind is used when a single specific file is found to have warnings\n-         * and when similar warnings have already been reported for the file.\n-         * It generates a message like:\n-         *      FILE has additional ISSUES\n-         *\/\n-        ADDITIONAL_IN_FILE(\".filename.additional\"),\n-        \/**\n-         * This kind is used when multiple files have been found to have warnings,\n-         * and none of them have had any similar warnings.\n-         * It generates a message like:\n-         *      Some files have ISSUES\n-         *\/\n-        IN_FILES(\".plural\"),\n-        \/**\n-         * This kind is used when multiple files have been found to have warnings,\n-         * and some of them have had already had specific similar warnings.\n-         * It generates a message like:\n-         *      Some files have additional ISSUES\n-         *\/\n-        ADDITIONAL_IN_FILES(\".plural.additional\");\n-\n-        DeferredDiagnosticKind(String v) { value = v; }\n-        String getKey(String prefix) { return prefix + value; }\n-\n-        private final String value;\n-    }\n-\n-\n-    \/**\n-     * Create a handler for mandatory warnings.\n-     *\n-     * @param log     The log on which to generate any diagnostics\n-     * @param source  Associated source file, or null for none\n-     * @param verbose Specify whether or not detailed messages about\n-     *                individual instances should be given, or whether an aggregate\n-     *                message should be generated at the end of the compilation.\n-     *                Typically set via  -Xlint:option.\n-     * @param enforceMandatory\n-     *                True if mandatory warnings and notes are being enforced.\n-     * @param lc      The lint category for all warnings\n-     *\/\n-    public MandatoryWarningHandler(Log log, Source source, boolean verbose, boolean enforceMandatory, LintCategory lc) {\n-        this(log, source, verbose, enforceMandatory, lc, null);\n-    }\n-\n-    \/**\n-     * Create a handler for mandatory warnings.\n-     *\n-     * @param log     The log on which to generate any diagnostics\n-     * @param source  Associated source file, or null for none\n-     * @param verbose Specify whether or not detailed messages about\n-     *                individual instances should be given, or whether an aggregate\n-     *                message should be generated at the end of the compilation.\n-     *                Typically set via  -Xlint:option.\n-     * @param enforceMandatory\n-     *                True if mandatory warnings and notes are being enforced.\n-     * @param lc      The lint category for all warnings\n-     * @param prefix  A common prefix for the set of message keys for the messages\n-     *                that may be generated, or null to infer from the lint category.\n-     *\/\n-    public MandatoryWarningHandler(Log log, Source source, boolean verbose, boolean enforceMandatory, LintCategory lc, String prefix) {\n-        this.log = log;\n-        this.source = source;\n-        this.verbose = verbose;\n-        this.prefix = prefix != null ? prefix : lc.option;\n-        this.enforceMandatory = enforceMandatory;\n-        this.lintCategory = lc;\n-    }\n-\n-    \/**\n-     * Report a mandatory warning.\n-     *\n-     * @param pos source code position\n-     * @param warnKey lint warning\n-     *\/\n-    public void report(DiagnosticPosition pos, LintWarning warnKey) {\n-        JavaFileObject currentSource = log.currentSourceFile();\n-        Assert.check(warnKey.getLintCategory() == lintCategory);\n-\n-        if (verbose) {\n-            if (sourcesWithReportedWarnings == null)\n-                sourcesWithReportedWarnings = new HashSet<>();\n-\n-            if (log.nwarnings < log.MaxWarnings) {\n-                \/\/ generate message and remember the source file\n-                logMandatoryWarning(pos, warnKey);\n-                sourcesWithReportedWarnings.add(currentSource);\n-            } else if (deferredDiagnosticKind == null) {\n-                \/\/ set up deferred message\n-                if (sourcesWithReportedWarnings.contains(currentSource)) {\n-                    \/\/ more errors in a file that already has reported warnings\n-                    deferredDiagnosticKind = DeferredDiagnosticKind.ADDITIONAL_IN_FILE;\n-                } else {\n-                    \/\/ warnings in a new source file\n-                    deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILE;\n-                }\n-                deferredDiagnosticSource = currentSource;\n-                deferredDiagnosticArg = currentSource;\n-            } else if ((deferredDiagnosticKind == DeferredDiagnosticKind.IN_FILE\n-                        || deferredDiagnosticKind == DeferredDiagnosticKind.ADDITIONAL_IN_FILE)\n-                       && !Objects.equals(deferredDiagnosticSource, currentSource)) {\n-                \/\/ additional errors in more than one source file\n-                deferredDiagnosticKind = DeferredDiagnosticKind.ADDITIONAL_IN_FILES;\n-                deferredDiagnosticArg = null;\n-            }\n-        } else {\n-            if (deferredDiagnosticKind == null) {\n-                \/\/ warnings in a single source\n-                deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILE;\n-                deferredDiagnosticSource = currentSource;\n-                deferredDiagnosticArg = currentSource;\n-            }  else if (deferredDiagnosticKind == DeferredDiagnosticKind.IN_FILE &&\n-                        !Objects.equals(deferredDiagnosticSource, currentSource)) {\n-                \/\/ warnings in multiple source files\n-                deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILES;\n-                deferredDiagnosticArg = null;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Report any diagnostic that might have been deferred by previous calls of report().\n-     *\/\n-    public void reportDeferredDiagnostic() {\n-        if (deferredDiagnosticKind != null) {\n-            if (deferredDiagnosticArg == null) {\n-                if (source != null) {\n-                    logMandatoryNote(deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), source);\n-                } else {\n-                    logMandatoryNote(deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix));\n-                }\n-            } else {\n-                if (source != null) {\n-                    logMandatoryNote(deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), deferredDiagnosticArg, source);\n-                } else {\n-                    logMandatoryNote(deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), deferredDiagnosticArg);\n-                }\n-            }\n-\n-            if (!verbose)\n-                logMandatoryNote(deferredDiagnosticSource, prefix + \".recompile\");\n-        }\n-    }\n-\n-    \/**\n-     * The log to which to report warnings.\n-     *\/\n-    private final Log log;\n-    private final Source source;\n-\n-    \/**\n-     * Whether or not to report individual warnings, or simply to report a\n-     * single aggregate warning at the end of the compilation.\n-     *\/\n-    private final boolean verbose;\n-\n-    \/**\n-     * The common prefix for all I18N message keys generated by this handler.\n-     *\/\n-    private final String prefix;\n-\n-    \/**\n-     * A set containing the names of the source files for which specific\n-     * warnings have been generated -- i.e. in verbose mode.  If a source name\n-     * appears in this list, then deferred diagnostics will be phrased to\n-     * include \"additionally\"...\n-     *\/\n-    private Set<JavaFileObject> sourcesWithReportedWarnings;\n-\n-    \/**\n-     * A variable indicating the latest best guess at what the final\n-     * deferred diagnostic will be. Initially as specific and helpful\n-     * as possible, as more warnings are reported, the scope of the\n-     * diagnostic will be broadened.\n-     *\/\n-    private DeferredDiagnosticKind deferredDiagnosticKind;\n-\n-    \/**\n-     * If deferredDiagnosticKind is IN_FILE or ADDITIONAL_IN_FILE, this variable\n-     * gives the value of log.currentSource() for the file in question.\n-     *\/\n-    private JavaFileObject deferredDiagnosticSource;\n-\n-    \/**\n-     * An optional argument to be used when constructing the\n-     * deferred diagnostic message, based on deferredDiagnosticKind.\n-     * This variable should normally be set\/updated whenever\n-     * deferredDiagnosticKind is updated.\n-     *\/\n-    private Object deferredDiagnosticArg;\n-\n-    \/**\n-     * True if mandatory warnings and notes are being enforced.\n-     *\/\n-    private final boolean enforceMandatory;\n-\n-    \/**\n-     * A LintCategory to be included in point-of-use diagnostics to indicate\n-     * how messages might be suppressed (i.e. with @SuppressWarnings).\n-     *\/\n-    private final LintCategory lintCategory;\n-\n-    \/**\n-     * Reports a mandatory warning to the log.  If mandatory warnings\n-     * are not being enforced, treat this as an ordinary warning.\n-     *\/\n-    private void logMandatoryWarning(DiagnosticPosition pos, LintWarning warnKey) {\n-        if (enforceMandatory)\n-            log.mandatoryWarning(pos, warnKey);\n-        else\n-            log.warning(pos, warnKey);\n-    }\n-\n-    \/**\n-     * Reports a mandatory note to the log.  If mandatory notes are\n-     * not being enforced, treat this as an ordinary note.\n-     *\/\n-    private void logMandatoryNote(JavaFileObject file, String msg, Object... args) {\n-        if (enforceMandatory)\n-            log.mandatoryNote(file, new Note(\"compiler\", msg, args));\n-        else\n-            log.note(file, new Note(\"compiler\", msg, args));\n-    }\n-\n-    public void clear() {\n-        sourcesWithReportedWarnings = null;\n-        deferredDiagnosticKind = null;\n-        deferredDiagnosticSource = null;\n-        deferredDiagnosticArg = null;\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/MandatoryWarningHandler.java","additions":0,"deletions":309,"binary":false,"changes":309,"status":"deleted"},{"patch":"@@ -0,0 +1,270 @@\n+\/*\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.util;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import javax.tools.JavaFileObject;\n+\n+import com.sun.tools.javac.code.Lint;\n+import com.sun.tools.javac.code.Lint.LintCategory;\n+import com.sun.tools.javac.code.Source;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n+import com.sun.tools.javac.util.JCDiagnostic.Note;\n+import com.sun.tools.javac.util.JCDiagnostic.Warning;\n+\n+\n+\/**\n+ * An aggregator for warnings, setting up a deferred diagnostic\n+ * to be printed at the end of the compilation if some warnings get suppressed\n+ * because the lint category is not enabled or too many warnings have already\n+ * been generated.\n+ *\n+ * <p>\n+ * All warnings must be in the same {@link LintCategory} provided to the constructor.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+class WarningAggregator {\n+\n+    \/**\n+     * The kinds of different deferred diagnostics that might be generated\n+     * if a warning is suppressed because too many warnings have already been output.\n+     *\n+     * The parameter is a fragment used to build an I18N message key for Log.\n+     *\/\n+    private enum DeferredDiagnosticKind {\n+        \/**\n+         * This kind is used when a single specific file is found to have warnings\n+         * and no similar warnings have already been given.\n+         * It generates a message like:\n+         *      FILE has ISSUES\n+         *\/\n+        IN_FILE(\".filename\"),\n+        \/**\n+         * This kind is used when a single specific file is found to have warnings\n+         * and when similar warnings have already been reported for the file.\n+         * It generates a message like:\n+         *      FILE has additional ISSUES\n+         *\/\n+        ADDITIONAL_IN_FILE(\".filename.additional\"),\n+        \/**\n+         * This kind is used when multiple files have been found to have warnings,\n+         * and none of them have had any similar warnings.\n+         * It generates a message like:\n+         *      Some files have ISSUES\n+         *\/\n+        IN_FILES(\".plural\"),\n+        \/**\n+         * This kind is used when multiple files have been found to have warnings,\n+         * and some of them have had already had specific similar warnings.\n+         * It generates a message like:\n+         *      Some files have additional ISSUES\n+         *\/\n+        ADDITIONAL_IN_FILES(\".plural.additional\");\n+\n+        DeferredDiagnosticKind(String v) { value = v; }\n+        String getKey(String prefix) { return prefix + value; }\n+\n+        private final String value;\n+    }\n+\n+\n+    \/**\n+     * Create an aggregator for warnings.\n+     *\n+     * @param log     The log on which to generate any diagnostics\n+     * @param source  Associated source file, or null for none\n+     * @param lc      The lint category for all warnings\n+     *\/\n+    public WarningAggregator(Log log, Source source, LintCategory lc) {\n+        this(log, source, lc, null);\n+    }\n+\n+    \/**\n+     * Create an aggregator for warnings.\n+     *\n+     * @param log     The log on which to generate any diagnostics\n+     * @param source  Associated source file, or null for none\n+     * @param lc      The lint category for all warnings\n+     * @param prefix  A common prefix for the set of message keys for the messages\n+     *                that may be generated, or null to infer from the lint category.\n+     *\/\n+    public WarningAggregator(Log log, Source source, LintCategory lc, String prefix) {\n+        this.log = log;\n+        this.source = source;\n+        this.prefix = prefix != null ? prefix : lc.option;\n+        this.lintCategory = lc;\n+    }\n+\n+    \/**\n+     * Aggregate a warning and determine whether to emit it.\n+     *\n+     * @param diagnostic the warning\n+     * @param verbose whether the warning's lint category is enabled\n+     * @return true if diagnostic should be emitted, otherwise false\n+     *\/\n+    public boolean aggregate(JCDiagnostic diagnostic, boolean verbose) {\n+        Assert.check(diagnostic.getLintCategory() == lintCategory);\n+        JavaFileObject currentSource = log.currentSourceFile();\n+        if (verbose) {\n+            if (sourcesWithReportedWarnings == null)\n+                sourcesWithReportedWarnings = new HashSet<>();\n+            if (log.nwarnings < log.MaxWarnings) {\n+                \/\/ generate message and remember the source file\n+                sourcesWithReportedWarnings.add(currentSource);\n+                anyWarningEmitted = true;\n+                return true;\n+            } else if (deferredDiagnosticKind == null) {\n+                \/\/ set up deferred message\n+                if (sourcesWithReportedWarnings.contains(currentSource)) {\n+                    \/\/ more errors in a file that already has reported warnings\n+                    deferredDiagnosticKind = DeferredDiagnosticKind.ADDITIONAL_IN_FILE;\n+                } else {\n+                    \/\/ warnings in a new source file\n+                    deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILE;\n+                }\n+                deferredDiagnosticSource = currentSource;\n+                deferredDiagnosticArg = currentSource;\n+            } else if ((deferredDiagnosticKind == DeferredDiagnosticKind.IN_FILE\n+                        || deferredDiagnosticKind == DeferredDiagnosticKind.ADDITIONAL_IN_FILE)\n+                       && !Objects.equals(deferredDiagnosticSource, currentSource)) {\n+                \/\/ additional errors in more than one source file\n+                deferredDiagnosticKind = DeferredDiagnosticKind.ADDITIONAL_IN_FILES;\n+                deferredDiagnosticArg = null;\n+            }\n+        } else {\n+            if (deferredDiagnosticKind == null) {\n+                \/\/ warnings in a single source\n+                deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILE;\n+                deferredDiagnosticSource = currentSource;\n+                deferredDiagnosticArg = currentSource;\n+            }  else if (deferredDiagnosticKind == DeferredDiagnosticKind.IN_FILE &&\n+                        !Objects.equals(deferredDiagnosticSource, currentSource)) {\n+                \/\/ warnings in multiple source files\n+                deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILES;\n+                deferredDiagnosticArg = null;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Build and return any accumulated aggregation notes.\n+     *\/\n+    public List<JCDiagnostic> aggregationNotes() {\n+        List<JCDiagnostic> list = new ArrayList<>(2);\n+        if (deferredDiagnosticKind != null) {\n+            if (deferredDiagnosticArg == null) {\n+                if (source != null) {\n+                    addNote(list, deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), source);\n+                } else {\n+                    addNote(list, deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix));\n+                }\n+            } else {\n+                if (source != null) {\n+                    addNote(list, deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), deferredDiagnosticArg, source);\n+                } else {\n+                    addNote(list, deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), deferredDiagnosticArg);\n+                }\n+            }\n+            if (!anyWarningEmitted)\n+                addNote(list, deferredDiagnosticSource, prefix + \".recompile\");\n+        }\n+        return list;\n+    }\n+\n+    private void addNote(List<JCDiagnostic> list, JavaFileObject file, String msg, Object... args) {\n+        list.add(log.diags.mandatoryNote(log.getSource(file), new Note(null, \"compiler\", msg, args)));\n+    }\n+\n+    \/**\n+     * The log to which to report warnings.\n+     *\/\n+    private final Log log;\n+    private final Source source;\n+\n+    \/**\n+     * The common prefix for all I18N message keys generated by this handler.\n+     *\/\n+    private final String prefix;\n+\n+    \/**\n+     * A set containing the names of the source files for which specific\n+     * warnings have been generated -- i.e. in verbose mode.  If a source name\n+     * appears in this list, then deferred diagnostics will be phrased to\n+     * include \"additionally\"...\n+     *\/\n+    private Set<JavaFileObject> sourcesWithReportedWarnings;\n+\n+    \/**\n+     * A variable indicating the latest best guess at what the final\n+     * deferred diagnostic will be. Initially as specific and helpful\n+     * as possible, as more warnings are reported, the scope of the\n+     * diagnostic will be broadened.\n+     *\/\n+    private DeferredDiagnosticKind deferredDiagnosticKind;\n+\n+    \/**\n+     * If deferredDiagnosticKind is IN_FILE or ADDITIONAL_IN_FILE, this variable\n+     * gives the value of log.currentSource() for the file in question.\n+     *\/\n+    private JavaFileObject deferredDiagnosticSource;\n+\n+    \/**\n+     * An optional argument to be used when constructing the\n+     * deferred diagnostic message, based on deferredDiagnosticKind.\n+     * This variable should normally be set\/updated whenever\n+     * deferredDiagnosticKind is updated.\n+     *\/\n+    private Object deferredDiagnosticArg;\n+\n+    \/**\n+     * Whether we have actually emitted a warning or just deferred everything.\n+     * In the latter case, the \"recompile\" notice is included in the summary.\n+     *\/\n+    private boolean anyWarningEmitted;\n+\n+    \/**\n+     * A LintCategory to be included in point-of-use diagnostics to indicate\n+     * how messages might be suppressed (i.e. with @SuppressWarnings).\n+     *\/\n+    private final LintCategory lintCategory;\n+\n+    public void clear() {\n+        sourcesWithReportedWarnings = null;\n+        deferredDiagnosticKind = null;\n+        deferredDiagnosticSource = null;\n+        deferredDiagnosticArg = null;\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/WarningAggregator.java","additions":270,"deletions":0,"binary":false,"changes":270,"status":"added"},{"patch":"@@ -1316,0 +1316,1 @@\n+    \/*\n@@ -1324,0 +1325,1 @@\n+    *\/\n","filename":"src\/jdk.crypto.mscapi\/windows\/native\/libsunmscapi\/security.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3123,5 +3123,18 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n+        }\n+\n+        IntVector vix2 = null;\n+        IntVector vix3 = null;\n+        if (vlen == idx_vlen * 4) {\n+            vix2 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 2).add(offset);\n+            VectorIntrinsics.checkIndex(vix2, a.length);\n+            vix3 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 3).add(offset);\n+            VectorIntrinsics.checkIndex(vix3, a.length);\n@@ -3132,2 +3145,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, null,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, vix2, vix3, null,\n@@ -3885,5 +3898,18 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n+        }\n+\n+        IntVector vix2 = null;\n+        IntVector vix3 = null;\n+        if (vlen == idx_vlen * 4) {\n+            vix2 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 2).add(offset);\n+            VectorIntrinsics.checkIndex(vix2, a.length);\n+            vix3 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 3).add(offset);\n+            VectorIntrinsics.checkIndex(vix3, a.length);\n@@ -3894,2 +3920,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, m,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, vix2, vix3, m,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":40,"deletions":14,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2940,2 +2940,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, null,\n@@ -3231,1 +3231,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n@@ -3426,2 +3426,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, m,\n@@ -3542,1 +3542,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2946,2 +2946,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, null,\n@@ -3218,1 +3218,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n@@ -3395,2 +3395,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, m,\n@@ -3492,1 +3492,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3100,2 +3100,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, null,\n@@ -3372,1 +3372,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n@@ -3549,2 +3549,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, m,\n@@ -3646,1 +3646,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2979,2 +2979,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, null,\n@@ -3270,1 +3270,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n@@ -3465,2 +3465,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, m,\n@@ -3581,1 +3581,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3124,5 +3124,9 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n@@ -3133,2 +3137,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, null,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, null, null, null,\n@@ -3871,5 +3875,9 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n@@ -3880,2 +3888,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, m,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, null, null, m,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -3766,5 +3766,19 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n+        }\n+\n+#if[byte]\n+        IntVector vix2 = null;\n+        IntVector vix3 = null;\n+        if (vlen == idx_vlen * 4) {\n+            vix2 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 2).add(offset);\n+            VectorIntrinsics.checkIndex(vix2, a.length);\n+            vix3 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 3).add(offset);\n+            VectorIntrinsics.checkIndex(vix3, a.length);\n@@ -3775,2 +3789,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, null,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, vix2, vix3, null,\n@@ -3780,0 +3794,9 @@\n+#else[byte]\n+        return VectorSupport.loadWithMap(\n+            vectorType, null, $type$.class, vsp.laneCount(),\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, null, null, null,\n+            a, offset, indexMap, mapOffset, vsp,\n+            (c, idx, iMap, idy, s, vm) ->\n+            s.vOp(n -> c[idx + iMap[idy+n]]));\n+#end[byte]\n@@ -3827,2 +3850,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, null,\n@@ -4453,1 +4476,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n@@ -4974,5 +4997,19 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n+        }\n+\n+#if[byte]\n+        IntVector vix2 = null;\n+        IntVector vix3 = null;\n+        if (vlen == idx_vlen * 4) {\n+            vix2 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 2).add(offset);\n+            VectorIntrinsics.checkIndex(vix2, a.length);\n+            vix3 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 3).add(offset);\n+            VectorIntrinsics.checkIndex(vix3, a.length);\n@@ -4983,2 +5020,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, m,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, vix2, vix3, m,\n@@ -4988,0 +5025,9 @@\n+#else[byte]\n+        return VectorSupport.loadWithMap(\n+            vectorType, maskClass, $type$.class, vsp.laneCount(),\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, null, null, m,\n+            a, offset, indexMap, mapOffset, vsp,\n+            (c, idx, iMap, idy, s, vm) ->\n+            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+#end[byte]\n@@ -5037,2 +5083,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, m,\n@@ -5228,1 +5274,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":66,"deletions":20,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -390,0 +390,7 @@\n+\n+    \/**\n+     * Returns a copy of the array describing the Java kinds in {@link #values}.\n+     *\/\n+    public JavaKind[] getSlotKinds() {\n+        return (slotKinds == null) ? null : slotKinds.clone();\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/BytecodeFrame.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,2 @@\n+     * @param profileDeopt specifies if HotSpot should profile deoptimizations for the\n+     *            {@code nmethod} associated with this object.\n@@ -50,2 +52,2 @@\n-    default InstalledCode addCode(ResolvedJavaMethod method, CompiledCode compiledCode, SpeculationLog log, InstalledCode installedCode) {\n-        return installCode(method, compiledCode, installedCode, log, false);\n+    default InstalledCode addCode(ResolvedJavaMethod method, CompiledCode compiledCode, SpeculationLog log, InstalledCode installedCode, boolean profileDeopt) {\n+        return installCode(method, compiledCode, installedCode, log, false, profileDeopt);\n@@ -67,1 +69,1 @@\n-        return installCode(method, compiledCode, null, null, true);\n+        return installCode(method, compiledCode, null, null, true, true);\n@@ -84,0 +86,2 @@\n+     * @param profileDeopt specifies if HotSpot should profile deoptimizations for the\n+     *            {@code nmethod} associated with this object.\n@@ -87,1 +91,1 @@\n-    InstalledCode installCode(ResolvedJavaMethod method, CompiledCode compiledCode, InstalledCode installedCode, SpeculationLog log, boolean isDefault);\n+    InstalledCode installCode(ResolvedJavaMethod method, CompiledCode compiledCode, InstalledCode installedCode, SpeculationLog log, boolean isDefault, boolean profileDeopt);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/CodeCacheProvider.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -292,3 +292,4 @@\n-        if (o instanceof VirtualObject) {\n-            VirtualObject l = (VirtualObject) o;\n-            if (!l.type.equals(type) || l.values.length != values.length) {\n+        if (o instanceof VirtualObject that) {\n+            int thatValuesLength = (that.values == null) ? 0 : that.values.length;\n+            int valuesLength = (values == null) ? 0 : values.length;\n+            if (!that.type.equals(type) || thatValuesLength != valuesLength) {\n@@ -297,1 +298,1 @@\n-            for (int i = 0; i < values.length; i++) {\n+            for (int i = 0; i < valuesLength; i++) {\n@@ -302,1 +303,1 @@\n-                if (!same(values[i], l.values[i])) {\n+                if (!same(values[i], that.values[i])) {\n@@ -314,0 +315,7 @@\n+\n+    \/**\n+     * Returns a copy of the array containing the Java kinds of the values stored in this virtual object.\n+     *\/\n+    public JavaKind[] getSlotKinds() {\n+        return (slotKinds == null) ? null : slotKinds.clone();\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/VirtualObject.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,1 @@\n- * interface. The method\n- * {@link jdk.vm.ci.code.CodeCacheProvider#addCode(jdk.vm.ci.meta.ResolvedJavaMethod, CompiledCode, jdk.vm.ci.meta.SpeculationLog, InstalledCode)}\n- * can be used to install code.\n+ * interface. The method {@link jdk.vm.ci.code.CodeCacheProvider#addCode} can be used to install code.\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/package-info.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-    public final int hashCode() {\n-        throw new UnsupportedOperationException(\"hashCode\");\n+    public int hashCode() {\n+        return 41 * pcOffset;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/site\/Site.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-    public InstalledCode installCode(ResolvedJavaMethod method, CompiledCode compiledCode, InstalledCode installedCode, SpeculationLog log, boolean isDefault) {\n+    public InstalledCode installCode(ResolvedJavaMethod method, CompiledCode compiledCode, InstalledCode installedCode, SpeculationLog log, boolean isDefault, boolean profileDeopt) {\n@@ -134,1 +134,1 @@\n-            HotSpotNmethod nmethod = new HotSpotNmethod(hsMethod, name, isDefault, hsCompiledNmethod.id);\n+            HotSpotNmethod nmethod = new HotSpotNmethod(hsMethod, name, isDefault, profileDeopt, hsCompiledNmethod.id);\n@@ -157,2 +157,1 @@\n-    @Override\n-    public void invalidateInstalledCode(InstalledCode installedCode) {\n+    public void invalidateInstalledCode(InstalledCode installedCode, int invalidationReason) {\n@@ -161,1 +160,1 @@\n-            nmethod.invalidate(true);\n+            nmethod.invalidate(true, invalidationReason);\n@@ -167,0 +166,5 @@\n+    @Override\n+    public void invalidateInstalledCode(InstalledCode installedCode) {\n+        invalidateInstalledCode(installedCode, jvmciInvalidationReason());\n+    }\n+\n@@ -204,0 +208,4 @@\n+\n+    private static int jvmciInvalidationReason() {\n+        return HotSpotJVMCIRuntime.runtime().config.getConstant(\"nmethod::InvalidationReason::JVMCI_INVALIDATE\", Integer.class);\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotCodeCacheProvider.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -191,0 +191,84 @@\n+\n+    \/**\n+     * Returns a copy of the compiled machine code.\n+     *\/\n+    public byte[] getTargetCode() {\n+        return (targetCode == null) ? null : targetCode.clone();\n+    }\n+\n+    \/**\n+     * Gets the size of the compiled machine code in bytes.\n+     *\/\n+    public int getTargetCodeSize() {\n+        return targetCodeSize;\n+    }\n+\n+    \/**\n+     * Returns a copy of the code annotations describing special sites in {@link #targetCode}.\n+     *\/\n+    public Site[] getSites() {\n+        return (sites == null) ? null : sites.clone();\n+    }\n+\n+    \/**\n+     * Returns an array copy of the assumptions this code relies on.\n+     *\/\n+    public Assumption[] getAssumptions() {\n+        return (assumptions == null) ? null : assumptions.clone();\n+    }\n+\n+    \/**\n+     * Returns an array copy of the methods whose bytecodes were used as input to the compilation.\n+     *\/\n+    public ResolvedJavaMethod[] getMethods() {\n+        return (methods == null) ? null : methods.clone();\n+    }\n+\n+    \/**\n+     * Returns an array copy of the comments that are included in code dumps.\n+     *\/\n+    public Comment[] getComments() {\n+        return (comments == null) ? null : comments.clone();\n+    }\n+\n+    \/**\n+     * Returns a copy of the data section containing serialized constants for the emitted machine code.\n+     *\/\n+    public byte[] getDataSection() {\n+        return (dataSection == null) ? null : dataSection.clone();\n+    }\n+\n+    \/**\n+     * Gets the minimum alignment of the data section.\n+     *\/\n+    public int getDataSectionAlignment() {\n+        return dataSectionAlignment;\n+    }\n+\n+    \/**\n+     * Returns a copy of the {@link #dataSection} relocations.\n+     *\/\n+    public DataPatch[] getDataSectionPatches() {\n+        return (dataSectionPatches == null) ? null : dataSectionPatches.clone();\n+    }\n+\n+    \/**\n+     * Checks if this compiled code is immutable and position independent.\n+     *\/\n+    public boolean isImmutablePIC() {\n+        return isImmutablePIC;\n+    }\n+\n+    \/**\n+     * Gets the total size of the stack frame of this compiled method.\n+     *\/\n+    public int getTotalFrameSize() {\n+        return totalFrameSize;\n+    }\n+\n+    \/**\n+     * Gets the deoptimization rescue slot associated with this compiled code.\n+     *\/\n+    public StackSlot getDeoptRescueSlot() {\n+        return deoptRescueSlot;\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotCompiledCode.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -121,0 +121,40 @@\n+    \/**\n+     * Returns the method to which this compiled nmethod belongs.\n+     *\/\n+    public HotSpotResolvedJavaMethod getMethod() {\n+        return method;\n+    }\n+\n+    \/**\n+     * Returns the bytecode index (BCI) in the {@link #getMethod() method} that is the beginning of this compiled\n+     * nmethod. -1 denotes the beginning of the method.\n+     *\n+     * @return the entry BCI of this nmethod or -1 if the entry is the method's beginning\n+     *\/\n+    public int getEntryBCI() {\n+        return entryBCI;\n+    }\n+\n+    \/**\n+     * Returns the identifier of the compilation request.\n+     *\/\n+    public int getId() {\n+        return id;\n+    }\n+\n+    \/**\n+     * Returns the address of a native {@code JVMCICompileState} object associated with this compiled nmethod.\n+     * If no such object exists, it returns 0L.\n+     *\n+     * @return the address of the native {@code JVMCICompileState} object or 0L if it does not exist\n+     *\/\n+    public long getCompileState() {\n+        return compileState;\n+    }\n+\n+    \/**\n+     * Checks if this compiled nmethod has a memory access via the {@code Unsafe} class.\n+     *\/\n+    public boolean hasUnsafeAccess() {\n+        return hasUnsafeAccess;\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotCompiledNmethod.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    public final String getName() {\n+    public String getName() {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJavaType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.vm.ci.common.JVMCIError;\n@@ -56,0 +57,7 @@\n+    \/**\n+     * Specifies whether HotSpot should profile deoptimizations for the {@code nmethod} associated\n+     * with this object. This is particularly useful for whitebox testing scenarios that involve\n+     * deoptimization.\n+     *\/\n+    private final boolean profileDeopt;\n+\n@@ -79,1 +87,7 @@\n-    HotSpotNmethod(HotSpotResolvedJavaMethodImpl method, String name, boolean isDefault, long compileId) {\n+    \/**\n+     * Identify the reason that caused this nmethod to be invalidated.\n+     * A value of -1 means that the nmethod was not invalidated.\n+     *\/\n+    private int invalidationReason;\n+\n+    HotSpotNmethod(HotSpotResolvedJavaMethodImpl method, String name, boolean isDefault, boolean profileDeopt, long compileId) {\n@@ -83,0 +97,1 @@\n+        this.profileDeopt = profileDeopt;\n@@ -85,0 +100,1 @@\n+        this.invalidationReason = -1;\n@@ -98,1 +114,1 @@\n-     *\n+     * <p>\n@@ -103,1 +119,2 @@\n-    @SuppressWarnings(\"unused\") private HotSpotSpeculationLog speculationLog;\n+    @SuppressWarnings(\"unused\")\n+    private HotSpotSpeculationLog speculationLog;\n@@ -113,0 +130,8 @@\n+    \/**\n+     * Determines if HotSpot should profile deoptimization for the {@code nmethod} associated\n+     * with this object.\n+     *\/\n+    public boolean profileDeopt() {\n+        return profileDeopt;\n+    }\n+\n@@ -125,0 +150,11 @@\n+    \/**\n+     * Invalidate this nmethod using the reason specified in {@code invalidationReason} and\n+     * optionally deoptimize the method if {@code deoptimize} is set.\n+     *\n+     * @param deoptimize         whether or not to deoptimize the method.\n+     * @param invalidationReason invalidation reason code.\n+     *\/\n+    public void invalidate(boolean deoptimize, int invalidationReason) {\n+        compilerToVM().invalidateHotSpotNmethod(this, deoptimize, invalidationReason);\n+    }\n+\n@@ -127,1 +163,1 @@\n-        compilerToVM().invalidateHotSpotNmethod(this, deoptimize);\n+        invalidate(deoptimize, jvmciInvalidationReason());\n@@ -149,1 +185,1 @@\n-                        method, getAddress(), isDefault, name, inOopsTable());\n+                method, getAddress(), isDefault, name, inOopsTable());\n@@ -168,1 +204,1 @@\n-     *\n+     * <p>\n@@ -191,0 +227,18 @@\n+\n+    \/**\n+     * @return an integer representing the reason why this nmethod was invalidated.\n+     *\/\n+    public int getInvalidationReason() {\n+        return invalidationReason;\n+    }\n+\n+    \/**\n+     * @return a String describing the reason why this nmethod was invalidated.\n+     *\/\n+    public String getInvalidationReasonDescription() {\n+        return compilerToVM().getInvalidationReasonDescription(this.getInvalidationReason());\n+    }\n+\n+    private static int jvmciInvalidationReason() {\n+        return HotSpotJVMCIRuntime.runtime().config.getConstant(\"nmethod::InvalidationReason::JVMCI_INVALIDATE\", Integer.class);\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotNmethod.java","additions":61,"deletions":7,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-import java.lang.invoke.CallSite;\n-import java.util.Objects;\n-\n@@ -33,0 +30,4 @@\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.ConstantCallSite;\n+import java.util.Objects;\n+\n@@ -64,1 +65,20 @@\n-    JavaConstant getCallSiteTarget(Assumptions assumptions);\n+    default JavaConstant getCallSiteTarget(Assumptions assumptions) {\n+        Assumptions.AssumptionResult<JavaConstant> result = getCallSiteTarget();\n+        if (!result.canRecordTo(assumptions)) {\n+            return null;\n+        }\n+        result.recordTo(assumptions);\n+        return result.getResult();\n+    }\n+\n+    \/**\n+     * Gets the result of {@link CallSite#getTarget()} for the {@link CallSite} object represented\n+     * by this constant. The target is bound to an assumption if this is not a fully initialized\n+     * {@link ConstantCallSite}.\n+     *\n+     * @return a call-site target (possibly bound to an assumption) or {@code null} if this constant\n+     * does not represent a {@link CallSite} object\n+     *\/\n+    default Assumptions.AssumptionResult<JavaConstant> getCallSiteTarget() {\n+        throw new UnsupportedOperationException(\"getCallSiteTarget\");\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotObjectConstant.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-    public JavaConstant getCallSiteTarget(Assumptions assumptions) {\n+    public Assumptions.AssumptionResult<JavaConstant> getCallSiteTarget() {\n@@ -97,4 +97,1 @@\n-                return readTarget();\n-            }\n-            if (assumptions == null) {\n-                return null;\n+                return new Assumptions.AssumptionResult<>(readTarget());\n@@ -103,2 +100,1 @@\n-            assumptions.record(new Assumptions.CallSiteTargetValue(this, result));\n-            return result;\n+            return new Assumptions.AssumptionResult<>(result, new Assumptions.CallSiteTargetValue(this, result));\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotObjectConstantImpl.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import static jdk.vm.ci.hotspot.HotSpotResolvedJavaType.checkAreAnnotations;\n+import static jdk.vm.ci.hotspot.HotSpotResolvedJavaType.checkIsAnnotation;\n+import static jdk.vm.ci.hotspot.HotSpotResolvedJavaType.getFirstAnnotationOrNull;\n@@ -237,0 +240,1 @@\n+            checkIsAnnotation(annotationType);\n@@ -239,1 +243,1 @@\n-        return getAnnotationData0(annotationType).get(0);\n+        return getFirstAnnotationOrNull(getAnnotationData0(annotationType));\n@@ -244,0 +248,3 @@\n+        checkIsAnnotation(type1);\n+        checkIsAnnotation(type2);\n+        checkAreAnnotations(types);\n@@ -245,1 +252,1 @@\n-            return Collections.emptyList();\n+            return List.of();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaFieldImpl.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+import static jdk.vm.ci.hotspot.HotSpotResolvedJavaType.checkAreAnnotations;\n+import static jdk.vm.ci.hotspot.HotSpotResolvedJavaType.checkIsAnnotation;\n+import static jdk.vm.ci.hotspot.HotSpotResolvedJavaType.getFirstAnnotationOrNull;\n@@ -492,1 +495,1 @@\n-            info = new HotSpotProfilingInfo(methodData, this, includeNormal, includeOSR);\n+            info = new HotSpotProfilingInfoImpl(methodData, this, includeNormal, includeOSR);\n@@ -576,0 +579,13 @@\n+    \/*\n+     * Currently in hotspot a method can either be a \"normal\" or an \"overpass\"\n+     * method. Overpass methods are instance methods which are created when\n+     * otherwise a valid candidate for method resolution would not be found.\n+     *\/\n+    @Override\n+    public boolean isDeclared() {\n+        if (isConstructor() || isClassInitializer()) {\n+            return false;\n+        }\n+        return (getConstMethodFlags() & config().constMethodFlagsIsOverpass) == 0;\n+    }\n+\n@@ -765,0 +781,1 @@\n+            checkIsAnnotation(type);\n@@ -767,1 +784,1 @@\n-        return getAnnotationData0(type).get(0);\n+        return getFirstAnnotationOrNull(getAnnotationData0(type));\n@@ -772,0 +789,3 @@\n+        checkIsAnnotation(type1);\n+        checkIsAnnotation(type2);\n+        checkAreAnnotations(types);\n@@ -773,1 +793,1 @@\n-            return Collections.emptyList();\n+            return List.of();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+import java.util.List;\n+\n+import jdk.vm.ci.meta.AnnotationData;\n@@ -30,1 +33,1 @@\n-    HotSpotResolvedObjectTypeImpl arrayOfType;\n+    HotSpotResolvedObjectType arrayOfType;\n@@ -32,1 +35,1 @@\n-    HotSpotResolvedJavaType(String name) {\n+    protected HotSpotResolvedJavaType(String name) {\n@@ -40,1 +43,1 @@\n-    public final int hashCode() {\n+    public int hashCode() {\n@@ -44,1 +47,4 @@\n-    abstract JavaConstant getJavaMirror();\n+    \/**\n+     * Gets the runtime representation of the {@link Class} object of this type.\n+     *\/\n+    public abstract JavaConstant getJavaMirror();\n@@ -46,1 +52,4 @@\n-    abstract HotSpotResolvedObjectTypeImpl getArrayType();\n+    \/**\n+     * Gets the array type of this type without caching the result.\n+     *\/\n+    protected abstract HotSpotResolvedObjectType getArrayType();\n@@ -49,1 +58,1 @@\n-    public final HotSpotResolvedObjectType getArrayClass() {\n+    public HotSpotResolvedObjectType getArrayClass() {\n@@ -63,1 +72,17 @@\n-    abstract boolean isBeingInitialized();\n+    protected abstract boolean isBeingInitialized();\n+\n+    static void checkIsAnnotation(ResolvedJavaType type) {\n+        if (!type.isAnnotation()) {\n+            throw new IllegalArgumentException(type.toJavaName() + \" is not an annotation interface\");\n+        }\n+    }\n+\n+    static void checkAreAnnotations(ResolvedJavaType... types) {\n+        for (ResolvedJavaType type : types) {\n+            checkIsAnnotation(type);\n+        }\n+    }\n+\n+    static AnnotationData getFirstAnnotationOrNull(List<AnnotationData> list) {\n+        return list.isEmpty() ? null : list.get(0);\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaType.java","additions":32,"deletions":7,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -83,0 +83,7 @@\n+    \/**\n+     * Gets the runtime representation of the {@link Class} object of this type.\n+     *\/\n+    default JavaConstant getJavaMirror() {\n+        throw new UnsupportedOperationException(\"getJavaMirror\");\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectType.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -675,1 +675,1 @@\n-    JavaConstant getJavaMirror() {\n+    public JavaConstant getJavaMirror() {\n@@ -680,1 +680,1 @@\n-    HotSpotResolvedObjectTypeImpl getArrayType() {\n+    protected HotSpotResolvedObjectTypeImpl getArrayType() {\n@@ -1070,0 +1070,8 @@\n+    @Override\n+    public List<ResolvedJavaMethod> getAllMethods(boolean forceLink) {\n+        if (forceLink) {\n+            link();\n+        }\n+        return List.of(runtime().compilerToVm.getAllMethods(this));\n+    }\n+\n@@ -1115,0 +1123,1 @@\n+            checkIsAnnotation(annotationType);\n@@ -1117,1 +1126,1 @@\n-        return getAnnotationData0(annotationType).get(0);\n+        return getFirstAnnotationOrNull(getAnnotationData0(annotationType));\n@@ -1123,1 +1132,4 @@\n-            return Collections.emptyList();\n+            checkIsAnnotation(type1);\n+            checkIsAnnotation(type2);\n+            checkAreAnnotations(types);\n+            return List.of();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -64,1 +64,7 @@\n-    static HotSpotResolvedPrimitiveType forKind(JavaKind kind) {\n+    \/**\n+     * Returns a primitive type instance corresponding to the given {@link JavaKind}.\n+     *\n+     * @param kind the Java kind of the primitive type\n+     * @return the primitive type instance for the given Java kind\n+     *\/\n+    public static HotSpotResolvedPrimitiveType forKind(JavaKind kind) {\n@@ -87,1 +93,1 @@\n-    HotSpotResolvedObjectTypeImpl getArrayType() {\n+    protected HotSpotResolvedObjectType getArrayType() {\n@@ -299,0 +305,5 @@\n+    @Override\n+    public List<ResolvedJavaMethod> getAllMethods(boolean forceLink) {\n+        return List.of();\n+    }\n+\n@@ -319,1 +330,1 @@\n-    JavaConstant getJavaMirror() {\n+    public JavaConstant getJavaMirror() {\n@@ -325,0 +336,1 @@\n+        checkIsAnnotation(type);\n@@ -330,1 +342,4 @@\n-        return Collections.emptyList();\n+        checkIsAnnotation(type1);\n+        checkIsAnnotation(type2);\n+        checkAreAnnotations(types);\n+        return List.of();\n@@ -332,1 +347,0 @@\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedPrimitiveType.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Objects;\n@@ -133,1 +134,1 @@\n-        HotSpotSpeculation(SpeculationReason reason, JavaConstant id, byte[] encoding) {\n+        public HotSpotSpeculation(SpeculationReason reason, JavaConstant id, byte[] encoding) {\n@@ -143,0 +144,7 @@\n+        \/**\n+         * Returns a copy of the speculation reason encoding.\n+         *\/\n+        public byte[] getReasonEncoding() {\n+            return (encoding == null) ? null : encoding.clone();\n+        }\n+\n@@ -150,0 +158,14 @@\n+\n+        @Override\n+        public boolean equals(Object object) {\n+            if (object instanceof HotSpotSpeculation that) {\n+                return getReason().equals(that.getReason()) && id.equals(that.id) && Arrays.equals(encoding, that.encoding);\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(getReason(), id, Arrays.hashCode(encoding));\n+        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotSpeculationLog.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-    private VMField getField(String name, String cppType, boolean required) {\n+    public VMField getField(String name, String cppType, boolean required) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfigAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    VMField(String name, String type, long offset, long address, Object value) {\n+    public VMField(String name, String type, long offset, long address, Object value) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/VMField.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -116,0 +116,21 @@\n+\n+    \/**\n+     * Returns the group ID of this speculation reason.\n+     *\/\n+    public int getGroupId() {\n+        return groupId;\n+    }\n+\n+    \/**\n+     * Returns the group name of this speculation reason.\n+     *\/\n+    public String getGroupName() {\n+        return groupName;\n+    }\n+\n+    \/**\n+     * Returns a copy of the array of context objects.\n+     *\/\n+    public Object[] getContext() {\n+        return (context == null) ? null : context.clone();\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/EncodedSpeculationReason.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.util.List;\n@@ -52,0 +53,9 @@\n+    \/**\n+     * Returns true if this type represents an annotation interface.\n+     *\n+     * @return {@code true} if this type represents an annotation interface\n+     *\/\n+    default boolean isAnnotation() {\n+        return (getModifiers() & java.lang.reflect.AccessFlag.ANNOTATION.mask()) != 0;\n+    }\n+\n@@ -368,0 +378,11 @@\n+    \/**\n+     * Returns a list containing all methods present within this type. This list can\n+     * include methods implicitly created and used by the VM that are not present in\n+     * {@link #getDeclaredMethods}. The returned List is unmodifiable; calls to any\n+     * mutator method will always cause {@code UnsupportedOperationException} to be\n+     * thrown.\n+     *\n+     * @param forceLink if {@code true}, forces this type to be {@link #link linked}\n+     *\/\n+    List<ResolvedJavaMethod> getAllMethods(boolean forceLink);\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaType.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -681,8 +681,7 @@\n-        \/\/ Multiple-Inheritance: remove the interface method that may have\n-        \/\/ been overridden by another interface method in the hierarchy\n-        \/\/\n-        \/\/ Note: The following approach is very simplistic and is compatible\n-        \/\/ with old VMM. A future enhancement, may include a contention breaker,\n-        \/\/ to correctly eliminate those methods that are merely definitions\n-        \/\/ in favor of concrete overriding methods, for instance those that have\n-        \/\/ API documentation and are not abstract OR default methods.\n+        \/\/ Multiple-Inheritance: No Contention. In Java's method resolution,\n+        \/\/ any override of a signature (whether by a subclass or by a subinterface,\n+        \/\/ including when it is final from superclasses) always takes precedence\n+        \/\/ over the original interface definition. All interface methods have low resolution priority.\n+        \/\/ Therefore, when considering an interface inherited method, as soon as\n+        \/\/ at least one overrider exists in the inheritance chain,\n+        \/\/ we do not inherit the older interface definition.\n@@ -691,6 +690,1 @@\n-            if (list != null) {\n-                boolean found = list.stream()\n-                        .anyMatch(this::isDeclaredInInterface);\n-                if (found)\n-                    return false;\n-            }\n+            if (list != null && !list.isEmpty()) return false;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -40,2 +40,0 @@\n-static HANDLE memHandle = NULL;\n-\n","filename":"src\/jdk.jdi\/windows\/native\/libdt_shmem\/shmem_md.c","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-#define MUTEX_LOCK(x)           \/* FIXUP? *\/\n-#define MUTEX_UNLOCK(x)         \/* FIXUP? *\/\n+#define MUTEX_LOCK(x)   ((void) (x))        \/* FIXUP? *\/\n+#define MUTEX_UNLOCK(x) ((void) (x))        \/* FIXUP? *\/\n","filename":"src\/jdk.jdwp.agent\/windows\/native\/libjdwp\/proc_md.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.events;\n+\n+import jdk.jfr.Category;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.Timespan;\n+import jdk.jfr.internal.RemoveFields;\n+import jdk.jfr.Description;\n+\n+@Name(\"jdk.MethodTiming\")\n+@Label(\"Method Timing\")\n+@Category({ \"Java Virtual Machine\", \"Method Tracing\" })\n+@RemoveFields({ \"duration\", \"eventThread\", \"stackTrace\" })\n+@Description(\"Measures the approximate time it takes for a method to execute, including all delays, not just CPU processing time\")\n+public final class MethodTimingEvent extends AbstractJDKEvent {\n+\n+    @Label(\"Method\")\n+    public long method;\n+\n+    @Label(\"Invocations\")\n+    public long invocations;\n+\n+    @Label(\"Minimum Time\")\n+    @Description(\"The value may be missing (Long.MIN_VALUE) if the clock-resolution is too low to establish a minimum time\")\n+    @Timespan(Timespan.TICKS)\n+    public long minimum;\n+\n+    @Label(\"Average Time\")\n+    @Description(\"The value may be missing (Long.MIN_VALUE) if the clock-resolution is too low to establish an average time\")\n+    @Timespan(Timespan.TICKS)\n+    public long average;\n+\n+    @Label(\"Maximum Time\")\n+    @Description(\"The value may be missing (Long.MIN_VALUE) if the clock-resolution is too low to establish a maximum time\")\n+    @Timespan(Timespan.TICKS)\n+    public long maximum;\n+\n+    public static void commit(long start, long method, long invocations, long minimum, long average, long maximum) {\n+        \/\/ Generated by JFR\n+    }\n+\n+    public static long timestamp() {\n+        \/\/ Generated by JFR\n+        return 0;\n+    }\n+\n+    public static boolean enabled() {\n+        \/\/ Generated by JFR\n+        return false;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/MethodTimingEvent.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -63,1 +63,8 @@\n-final class EventInstrumentation {\n+public final class EventInstrumentation {\n+    public static final long MASK_THROTTLE               = 1L << 62;\n+    public static final long MASK_THROTTLE_CHECK         = 1L << 63;\n+    public static final long MASK_THROTTLE_BITS          = MASK_THROTTLE | MASK_THROTTLE_CHECK;\n+    public static final long MASK_THROTTLE_CHECK_SUCCESS = MASK_THROTTLE_CHECK | MASK_THROTTLE;\n+    public static final long MASK_THROTTLE_CHECK_FAIL    = MASK_THROTTLE_CHECK | 0;\n+    public static final long MASK_NON_THROTTLE_BITS      = ~MASK_THROTTLE_BITS;\n+\n@@ -74,0 +81,1 @@\n+    private static final MethodDesc METHOD_THROTTLE = MethodDesc.of(\"throttle\", \"(JJ)J\");\n@@ -76,1 +84,4 @@\n-    private static final MethodDesc METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT = MethodDesc.of(\"shouldCommit\", \"(J)Z\");\n+    private static final MethodDesc METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT_LONG = MethodDesc.of(\"shouldCommit\", \"(J)Z\");\n+    private static final MethodDesc METHOD_EVENT_CONFIGURATION_SHOULD_THROTTLE_COMMIT_LONG_LONG = MethodDesc.of(\"shouldThrottleCommit\", \"(JJ)Z\");\n+    private static final MethodDesc METHOD_EVENT_CONFIGURATION_SHOULD_THROTTLE_COMMIT_LONG = MethodDesc.of(\"shouldThrottleCommit\", \"(J)Z\");\n+\n@@ -79,0 +90,2 @@\n+    private static final MethodDesc METHOD_EVENT_SHOULD_THROTTLE_COMMIT_LONG_LONG = MethodDesc.of(\"shouldThrottleCommit\", \"(JJ)Z\");\n+    private static final MethodDesc METHOD_EVENT_SHOULD_THROTTLE_COMMIT_LONG = MethodDesc.of(\"shouldThrottleCommit\", \"(J)Z\");\n@@ -91,0 +104,1 @@\n+    private final boolean throttled;\n@@ -113,0 +127,5 @@\n+        if (inspector.isJDK()) {\n+            this.throttled = inspector.hasStaticMethod(METHOD_EVENT_SHOULD_THROTTLE_COMMIT_LONG_LONG);\n+        } else {\n+            this.throttled = inspector.isThrottled();\n+        }\n@@ -150,0 +169,6 @@\n+            if (isMethod(method, METHOD_EVENT_SHOULD_THROTTLE_COMMIT_LONG_LONG)) {\n+                return this::methodShouldCommitThrottleStaticLongLong;\n+            }\n+            if (isMethod(method, METHOD_EVENT_SHOULD_THROTTLE_COMMIT_LONG)) {\n+                return this::methodShouldCommitThrottleStaticLong;\n+            }\n@@ -191,5 +216,5 @@\n-            codeBuilder.aload(0);\n-            codeBuilder.aload(0);\n-            getfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_START_TIME);\n-            invokestatic(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_DURATION);\n-            putfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_DURATION);\n+            setDuration(codeBuilder, cb -> {\n+                codeBuilder.aload(0);\n+                getfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_START_TIME);\n+                invokestatic(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_DURATION);\n+            });\n@@ -208,3 +233,2 @@\n-        codeBuilder.aload(0);\n-        getfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_DURATION);\n-        invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT);\n+        getDuration(codeBuilder);\n+        invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT_LONG);\n@@ -225,0 +249,24 @@\n+        if (throttled) {\n+            \/\/ long d =  eventConfiguration.throttle(this.duration);\n+            \/\/ this.duration = d;\n+            \/\/ if (d & MASK_THROTTLE_BIT == 0) {\n+            \/\/   goto fail;\n+            \/\/ }\n+            getEventConfiguration(codeBuilder);\n+            codeBuilder.aload(0);\n+            getfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_START_TIME);\n+            codeBuilder.aload(0);\n+            getfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_DURATION);\n+            Bytecode.invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_THROTTLE);\n+            int result = codeBuilder.allocateLocal(TypeKind.LONG);\n+            codeBuilder.lstore(result);\n+            codeBuilder.aload(0);\n+            codeBuilder.lload(result);\n+            putfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_DURATION);\n+            codeBuilder.lload(result);\n+            codeBuilder.ldc(MASK_THROTTLE);\n+            codeBuilder.land();\n+            codeBuilder.lconst_0();\n+            codeBuilder.lcmp();\n+            codeBuilder.ifeq(fail);\n+         }\n@@ -297,0 +345,11 @@\n+        methodShouldCommitStatic(codeBuilder, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT_LONG);\n+    }\n+\n+    private void methodShouldCommitThrottleStaticLongLong(CodeBuilder codeBuilder) {\n+        methodShouldCommitStatic(codeBuilder, METHOD_EVENT_CONFIGURATION_SHOULD_THROTTLE_COMMIT_LONG_LONG);\n+    }\n+    private void methodShouldCommitThrottleStaticLong(CodeBuilder codeBuilder) {\n+        methodShouldCommitStatic(codeBuilder, METHOD_EVENT_CONFIGURATION_SHOULD_THROTTLE_COMMIT_LONG);\n+    }\n+\n+    private void methodShouldCommitStatic(CodeBuilder codeBuilder, MethodDesc method) {\n@@ -305,2 +364,4 @@\n-        codeBuilder.lload(0);\n-        codeBuilder.invokevirtual(TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT.name(), METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT.descriptor());\n+        for (int i = 0 ; i < method.descriptor().parameterCount(); i++) {\n+            codeBuilder.lload(2 * i);\n+        }\n+        codeBuilder.invokevirtual(TYPE_EVENT_CONFIGURATION, method.name(), method.descriptor());\n@@ -424,0 +485,5 @@\n+        if (throttled) {\n+            blockCodeBuilder.aload(0);\n+            blockCodeBuilder.lload(1);\n+            putfield(blockCodeBuilder, eventClassDesc, ImplicitFields.FIELD_START_TIME);\n+        }\n@@ -433,1 +499,1 @@\n-        blockCodeBuilder.lconst_0();\n+        blockCodeBuilder.lconst_0(); \/\/ also blocks throttled event\n@@ -469,3 +535,1 @@\n-            blockCodeBuilder.aload(0);\n-            \/\/ stack: [EW] [EW] [this]\n-            getfield(blockCodeBuilder, eventClassDesc, ImplicitFields.FIELD_DURATION);\n+            getDuration(blockCodeBuilder);\n@@ -518,0 +582,22 @@\n+    private void getDuration(CodeBuilder codeBuilder) {\n+        codeBuilder.aload(0);\n+        getfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_DURATION);\n+        if (throttled) {\n+            codeBuilder.loadConstant(MASK_NON_THROTTLE_BITS);\n+            codeBuilder.land();\n+        }\n+    }\n+\n+    private void setDuration(CodeBuilder codeBuilder, Consumer<CodeBuilder> expression) {\n+        codeBuilder.aload(0);\n+        expression.accept(codeBuilder);\n+        if (throttled) {\n+            codeBuilder.aload(0);\n+            getfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_DURATION);\n+            codeBuilder.loadConstant(MASK_THROTTLE_BITS);\n+            codeBuilder.land();\n+            codeBuilder.lor();\n+        }\n+        putfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_DURATION);\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":102,"deletions":16,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-; Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+; Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,2 @@\n-                missing:whitespace, missing:whitespace, missing:whitespace\n+                missing:whitespace, missing:whitespace, missing:whitespace,\n+                missing:whitespace\n@@ -397,1 +398,1 @@\n-label = \"Java Methods that Executes the Most\"\n+label = \"Java Methods that Execute the Most\"\n@@ -403,0 +404,22 @@\n+[application.cpu-time-hot-methods]\n+label = \"Java Methods that Execute the Most from CPU Time Sampler\"\n+table = \"COLUMN 'Method', 'Samples', 'Percent'\n+         FORMAT none, none, normalized\n+         SELECT stackTrace.topFrame AS T, COUNT(*), COUNT(*)\n+         FROM CPUTimeSample GROUP BY T LIMIT 25\"\n+\n+[application.cpu-time-statistics]\n+label = \"CPU Time Sample Statistics\"\n+form = \"COLUMN 'Successful Samples', 'Failed Samples', 'Biased Samples', 'Total Samples', 'Lost Samples'\n+        SELECT COUNT(S.startTime), COUNT(F.startTime), COUNT(B.startTime), Count(A.startTime), SUM(L.lostSamples)\n+        FROM\n+          CPUTimeSample AS S,\n+          CPUTimeSample AS F,\n+          CPUTimeSample AS A,\n+          CPUTimeSample AS B,\n+          CPUTimeSamplesLost AS L\n+        WHERE\n+          S.failed = 'false' AND\n+          F.failed = 'true'  AND\n+          B.biased = 'true'\"\n+\n@@ -449,0 +472,13 @@\n+[application.method-timing]\n+label = \"Method Timing\"\n+table = \"COLUMN 'Timed Method', 'Invocations', 'Minimum Time', 'Average Time', 'Maximum Time'\n+         FORMAT none, none, ms-precision:6, ms-precision:6, ms-precision:6\n+         SELECT LAST_BATCH(method) AS M, LAST_BATCH(invocations), LAST_BATCH(minimum), LAST_BATCH(average), LAST_BATCH(maximum)\n+         FROM jdk.MethodTiming GROUP BY method ORDER BY average\"\n+\n+[application.method-calls]\n+label = \"Method Calls\"\n+table = \"COLUMN 'Traced Method', 'Caller', 'Invocations'\n+         SELECT method as M, stackTrace.topFrame.method AS S, COUNT(*) AS C\n+         FROM jdk.MethodTrace GROUP BY M, S ORDER BY C DESC\"\n+\n@@ -485,4 +521,4 @@\n-table = \"COLUMN 'Method', 'Samples', 'Percent'\n-         FORMAT none, none, normalized\n-         SELECT stackTrace.topFrame AS T, COUNT(*), COUNT(*)\n-         FROM NativeMethodSample GROUP BY T\"\n+table = \"COLUMN 'Method', 'Samples'\n+         FORMAT none, none\n+         SELECT stackTrace.topFrame AS T, COUNT(*) AS C\n+         FROM NativeMethodSample GROUP BY T ORDER BY C DESC\"\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/view.ini","additions":43,"deletions":7,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.tracing;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.Collection;\n+\n+import jdk.jfr.events.MethodTimingEvent;\n+\n+\/**\n+ * Holds timed method for a class. Used when publishing method ids.\n+ *\/\n+public final class TimedClass {\n+    private static final long MISSING = Long.MIN_VALUE;\n+    private final ConcurrentHashMap<Long, TimedMethod> methods = new ConcurrentHashMap<>();\n+\n+    public TimedMethod add(Method method) {\n+        return methods.computeIfAbsent(method.methodId(), id -> new TimedMethod(method));\n+    }\n+\n+    public void remove(Method method) {\n+        methods.remove(method.methodId());\n+    }\n+\n+    public void publish() {\n+        for (TimedMethod t : methods.values()) {\n+            t.published().set(true);\n+            t.method().log(\"Timing entry published\");\n+        }\n+    }\n+\n+    Collection<TimedMethod> methods() {\n+        return methods.values();\n+    }\n+\n+    public void emit(long timestamp) {\n+        for (var tm : methods.values()) {\n+            if (tm.published().get()) {\n+                long methodId = tm.method().methodId();\n+                long invocations = tm.invocations().get();\n+                long time = tm.time().get();\n+                long min = tm.minimum().get();\n+                long max = tm.maximum().get();\n+                if (time == 0 || invocations == 0) {\n+                    \/\/ If time is zero, it's a low resolution clock and more invocations are needed.\n+                    MethodTimingEvent.commit(timestamp, methodId, invocations, MISSING, MISSING, MISSING);\n+                } else {\n+                    long average = (time + invocations \/ 2) \/ invocations;\n+                    if (min == Long.MAX_VALUE) {\n+                        min = average;\n+                    }\n+                    if (max == Long.MIN_VALUE) {\n+                        max = average;\n+                    }\n+                    min = Math.min(min, average);\n+                    max = Math.max(max, average);\n+                    MethodTimingEvent.commit(timestamp, methodId, invocations, min, average, max);\n+                }\n+                tm.method().log(\"Emitted event\");\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/TimedClass.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.tracing;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\/**\n+ * Record class that holds invocation measurements used by the MethodTiming\n+ * event.\n+ * <p>\n+ * Fields in record classes are truly final so might help to have a record here.\n+ *\/\n+record TimedMethod(AtomicLong invocations, AtomicLong time, AtomicLong minimum, AtomicLong maximum, Method method, AtomicBoolean published) {\n+    TimedMethod(Method method) {\n+        this(new AtomicLong(), new AtomicLong(), new AtomicLong(Long.MAX_VALUE), new AtomicLong(Long.MIN_VALUE), method, new AtomicBoolean());\n+    }\n+\n+    public void updateMinMax(long duration) {\n+        if (duration == 0) {\n+            return; \/\/ Ignore data due to low-resolution clock\n+        }\n+        if (duration > maximum.getPlain()) {\n+            while (true) {\n+                long max = maximum.get();\n+                if (duration <= max) {\n+                    return;\n+                }\n+                if (maximum.weakCompareAndSetVolatile(max, duration)) {\n+                    return;\n+                }\n+            }\n+        }\n+        if (duration < minimum.getPlain()) {\n+            while (true) {\n+                long min = minimum.get();\n+                if (duration >= min) {\n+                    return;\n+                }\n+                if (minimum.weakCompareAndSetVolatile(min, duration)) {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/TimedMethod.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,1 +183,0 @@\n-    const DWORD neutralLangId = (0x04b0 | MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL) << 16);\n","filename":"src\/jdk.jpackage\/windows\/native\/libjpackage\/VersionInfo.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -162,4 +163,9 @@\n-            terminal = TerminalBuilder.builder().exec(allowExecTerminal).inputStreamWrapper(in -> {\n-                input.setInputStream(in);\n-                return nonBlockingInput;\n-            }).nativeSignals(false).build();\n+            terminal = TerminalBuilder.builder()\n+                                      .exec(allowExecTerminal)\n+                                      .inputStreamWrapper(in -> {\n+                                          input.setInputStream(in);\n+                                          return nonBlockingInput;\n+                                      })\n+                                      .nativeSignals(false)\n+                                      .encoding(System.getProperty(\"stdin.encoding\"))\n+                                      .build();\n@@ -840,1 +846,1 @@\n-            pendingLine = null;\n+            pendingLineCharacters = null;\n@@ -971,2 +977,5 @@\n-    private String pendingLine;\n-    private int pendingLinePointer;\n+    private static final Charset stdinCharset =\n+            Charset.forName(System.getProperty(\"stdin.encoding\"),\n+                            Charset.defaultCharset());\n+    private char[] pendingLineCharacters;\n+    private int pendingLineCharactersPointer;\n@@ -979,2 +988,21 @@\n-            char userChar = readUserInputChar();\n-            pendingBytes = String.valueOf(userChar).getBytes();\n+            int userCharInput = readUserInputChar();\n+            if (userCharInput == (-1)) {\n+                return -1;\n+            }\n+            char userChar = (char) userCharInput;\n+            StringBuilder dataToConvert = new StringBuilder();\n+            dataToConvert.append(userChar);\n+            if (Character.isHighSurrogate(userChar)) {\n+                \/\/surrogates cannot be converted independently,\n+                \/\/read the low surrogate and append it to dataToConvert:\n+                int lowSurrogateInput = readUserInputChar();\n+                if (lowSurrogateInput == (-1)) {\n+                    \/\/end of input, ignore at this stage\n+                } else if (Character.isLowSurrogate((char) lowSurrogateInput)) {\n+                    dataToConvert.append((char) lowSurrogateInput);\n+                } else {\n+                    \/\/if not the low surrogate, rollback the reading of the character:\n+                    pendingLineCharactersPointer--;\n+                }\n+            }\n+            pendingBytes = dataToConvert.toString().getBytes(stdinCharset);\n@@ -987,4 +1015,13 @@\n-    public synchronized char readUserInputChar() throws IOException {\n-        while (pendingLine == null || pendingLine.length() <= pendingLinePointer) {\n-            pendingLine = doReadUserLine(\"\", null) + System.getProperty(\"line.separator\");\n-            pendingLinePointer = 0;\n+    public synchronized int readUserInputChar() throws IOException {\n+        if (pendingLineCharacters != null && pendingLineCharacters.length == 0) {\n+            return -1;\n+        }\n+        while (pendingLineCharacters == null || pendingLineCharacters.length <= pendingLineCharactersPointer) {\n+            String readLine = doReadUserLine(\"\", null);\n+            if (readLine == null) {\n+                pendingLineCharacters = new char[0];\n+                return -1;\n+            } else {\n+                pendingLineCharacters = (readLine + System.getProperty(\"line.separator\")).toCharArray();\n+            }\n+            pendingLineCharactersPointer = 0;\n@@ -992,1 +1029,1 @@\n-        return pendingLine.charAt(pendingLinePointer++);\n+        return pendingLineCharacters[pendingLineCharactersPointer++];\n@@ -998,2 +1035,6 @@\n-        if (pendingLine != null && pendingLine.length() > pendingLinePointer) {\n-            return pendingLine.substring(pendingLinePointer);\n+        if (pendingLineCharacters != null && pendingLineCharacters.length > pendingLineCharactersPointer) {\n+            String result = new String(pendingLineCharacters,\n+                                       pendingLineCharactersPointer,\n+                                       pendingLineCharacters.length - pendingLineCharactersPointer);\n+            pendingLineCharacters = null;\n+            return result;\n@@ -1022,0 +1063,2 @@\n+        } catch (EndOfFileException ex) {\n+            return null; \/\/ Signal that Ctrl+D or similar happened\n@@ -1032,1 +1075,5 @@\n-        return doReadUserLine(prompt, '\\0').toCharArray();\n+        String line = doReadUserLine(prompt, '\\0');\n+        if (line == null) {\n+            return null;\n+        }\n+        return line.toCharArray();\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/ConsoleIOContext.java","additions":65,"deletions":18,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.org.jline.reader.UserInterruptException;\n@@ -62,2 +61,2 @@\n-    public char readUserInputChar() throws IOException {\n-        throw new UserInterruptException(\"\");\n+    public int readUserInputChar() throws IOException {\n+        return -1;\n@@ -69,1 +68,1 @@\n-        throw new UserInterruptException(\"\");\n+        return null;\n@@ -73,1 +72,1 @@\n-        throw new UserInterruptException(\"\");\n+        return null;\n@@ -83,1 +82,1 @@\n-        throw new UserInterruptException(\"\");\n+        return null;\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/IOContext.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -4124,1 +4124,5 @@\n-                            cbuf[off] = input.readUserInputChar();\n+                            int r = input.readUserInputChar();\n+                            if (r == (-1)) {\n+                                return -1;\n+                            }\n+                            cbuf[off] = (char) r;\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/JShellTool.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        public JdkConsole console(boolean isTTY, Charset charset) {\n+        public JdkConsole console(boolean isTTY, Charset inCharset, Charset outCharset) {\n@@ -185,0 +185,3 @@\n+                        if (len == 0) {\n+                            return 0;\n+                        }\n@@ -187,1 +190,7 @@\n-                            return readChars(cbuf, off, len);\n+                            int r = readInt();\n+                            if (r == (-1)) {\n+                                return -1;\n+                            } else {\n+                                cbuf[off] = (char) r;\n+                                return 1;\n+                            }\n@@ -377,7 +386,3 @@\n-                    if (bp >= 5) {\n-                        int len = readInt(1);\n-                        int c = console.reader().read();\n-                        \/\/XXX: EOF handling!\n-                        sendChars(sinkOutput, new char[] {(char) c}, 0, 1);\n-                        bp = 0;\n-                    }\n+                    int c = console.reader().read();\n+                    sendInt(sinkOutput, c);\n+                    bp = 0;\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/impl\/ConsoleImpl.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    old = new ShenandoahOldGeneration(8, 1024 * 1024, 1024);\n+    old = new ShenandoahOldGeneration(8, 1024 * 1024);\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahOldGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-TEST(GuardedMemory, basic) {\n+TEST_VM(GuardedMemory, basic) {\n@@ -81,1 +81,1 @@\n-TEST(GuardedMemory, odd_sizes) {\n+TEST_VM(GuardedMemory, odd_sizes) {\n@@ -102,1 +102,1 @@\n-TEST(GuardedMemory, buffer_overrun_head) {\n+TEST_VM(GuardedMemory, buffer_overrun_head) {\n@@ -114,1 +114,1 @@\n-TEST(GuardedMemory, buffer_overrun_tail) {\n+TEST_VM(GuardedMemory, buffer_overrun_tail) {\n@@ -131,1 +131,1 @@\n-TEST(GuardedMemory, wrap) {\n+TEST_VM(GuardedMemory, wrap) {\n@@ -149,0 +149,7 @@\n+\n+\/\/ Test passing back a bogus GuardedMemory region\n+TEST_VM(GuardedMemory, unmapped) {\n+  char* unmapped_base = (char*) (GuardedMemoryTest::get_guard_header_size() + 0x1000 + 1); \/\/ Avoids assert in constructor\n+  GuardedMemory guarded(unmapped_base);\n+  EXPECT_FALSE(guarded.verify_guards()) << \"Guard was not broken as expected\";\n+}\n","filename":"test\/hotspot\/gtest\/memory\/test_guardedMemory.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @requires os.arch==\"aarch64\" | os.arch==\"amd64\" | os.arch == \"ppc64le\" | os.arch == \"riscv64\"\n+ * @requires os.arch==\"aarch64\" | os.arch==\"amd64\" | os.arch == \"ppc64\" | os.arch == \"ppc64le\" | os.arch == \"riscv64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestBit.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\",\n+                                   \"-XX:-UseCompactObjectHeaders\",\n@@ -51,1 +51,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\",\n+                                   \"-XX:-UseCompactObjectHeaders\",\n@@ -54,1 +54,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\",\n+                                   \"-XX:+UseCompactObjectHeaders\",\n@@ -57,1 +57,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\",\n+                                   \"-XX:+UseCompactObjectHeaders\",\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestCastX2NotProcessedIGVN.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n+                                   \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n@@ -50,1 +50,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n+                                   \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n@@ -52,1 +52,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n+                                   \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n@@ -54,1 +54,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n+                                   \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorConditionalMove.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\",\n+                                   \"-XX:-UseCompactObjectHeaders\",\n@@ -58,1 +58,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\",\n+                                   \"-XX:-UseCompactObjectHeaders\",\n@@ -61,1 +61,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\",\n+                                   \"-XX:+UseCompactObjectHeaders\",\n@@ -64,1 +64,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\",\n+                                   \"-XX:+UseCompactObjectHeaders\",\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizationMismatchedAccess.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\",\n+                                   \"-XX:-UseCompactObjectHeaders\",\n@@ -49,1 +49,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\",\n+                                   \"-XX:-UseCompactObjectHeaders\",\n@@ -52,1 +52,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\",\n+                                   \"-XX:+UseCompactObjectHeaders\",\n@@ -55,1 +55,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\",\n+                                   \"-XX:+UseCompactObjectHeaders\",\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizationNotRun.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2025, Institute of Software, Chinese Academy of Sciences.\n+ * All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests.stringopts;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/**\n+ * @test\n+ * @bug 8359270\n+ * @requires vm.debug == true & vm.compiler2.enabled\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"riscv64\" | os.arch==\"aarch64\"\n+ * @summary C2: alignment check should consider base offset when emitting arraycopy runtime call.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stringopts.TestArrayCopySelect\n+ *\/\n+\n+public class TestArrayCopySelect {\n+\n+    public static final String input_strU = \"\\u0f21\\u0f22\\u0f23\\u0f24\\u0f25\\u0f26\\u0f27\\u0f28\";\n+    public static final char[] input_arrU = new char[] {'\\u0f21', '\\u0f22', '\\u0f23', '\\u0f24',\n+                                                        '\\u0f25', '\\u0f26', '\\u0f27', '\\u0f28'};\n+\n+    public static String output_strU;\n+    public static char[] output_arrU;\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:-UseCompactObjectHeaders\",\n+                                   \"-XX:-CompactStrings\",\n+                                   \"-XX:CompileCommand=inline,java.lang.StringBuilder::toString\",\n+                                   \"-XX:CompileCommand=inline,java.lang.StringUTF16::getChars\",\n+                                   \"-XX:CompileCommand=inline,java.lang.StringUTF16::toBytes\");\n+\n+        TestFramework.runWithFlags(\"-XX:+UseCompactObjectHeaders\",\n+                                   \"-XX:-CompactStrings\",\n+                                   \"-XX:CompileCommand=inline,java.lang.StringBuilder::toString\",\n+                                   \"-XX:CompileCommand=inline,java.lang.StringUTF16::getChars\",\n+                                   \"-XX:CompileCommand=inline,java.lang.StringUTF16::toBytes\");\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.CALL_OF, \"arrayof_jshort_disjoint_arraycopy\", \">0\"})\n+    static void testSBToStringAligned() {\n+        \/\/ Exercise the StringBuilder.toString API\n+        StringBuilder sb = new StringBuilder(input_strU);\n+        output_strU = sb.append(input_strU).toString();\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.CALL_OF, \"arrayof_jshort_disjoint_arraycopy\", \">0\"})\n+    static void testStrUGetCharsAligned() {\n+        \/\/ Exercise the StringUTF16.getChars API\n+        output_arrU = input_strU.toCharArray();\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.CALL_OF, \"arrayof_jshort_disjoint_arraycopy\", \">0\"})\n+    static void testStrUtoBytesAligned() {\n+        \/\/ Exercise the StringUTF16.toBytes API\n+        output_strU = String.valueOf(input_arrU);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stringopts\/TestArrayCopySelect.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,378 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=GetAndSet\n+ * @bug 8020282\n+ * @summary Test that we do not generate redundant leas on x86 for AtomicReference.getAndSet.\n+ * @requires os.simpleArch == \"x64\" & vm.opt.TieredCompilation != false\n+ * @modules jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/test\/lib \/\n+ * @run driver compiler.codegen.TestRedundantLea GetAndSet\n+ *\/\n+\n+\/*\n+ * @test id=StringEquals\n+ * @bug 8020282\n+ * @summary Test that we do not generate redundant leas on x86 for String.Equals.\n+ * @requires os.simpleArch == \"x64\" & vm.opt.TieredCompilation != false\n+ * @modules jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/test\/lib \/\n+ * @run driver compiler.codegen.TestRedundantLea StringEquals\n+ *\/\n+\n+\/*\n+ * @test id=StringInflate\n+ * @bug 8020282\n+ * @summary Test that we do not generate redundant leas on x86 for StringConcat intrinsics.\n+ * @requires os.simpleArch == \"x64\" & vm.opt.TieredCompilation != false\n+ * @modules jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/test\/lib \/\n+ * @run driver compiler.codegen.TestRedundantLea StringInflate\n+ *\/\n+\n+\/*\n+ * @test id=RegexFind\n+ * @bug 8020282\n+ * @summary Test that we do not generate redundant leas on x86 when performing regex matching.\n+ * @requires os.simpleArch == \"x64\" & vm.opt.TieredCompilation != false & vm.opt.UseAvx == 3\n+ * @modules jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/test\/lib \/\n+ * @run driver compiler.codegen.TestRedundantLea RegexFind\n+ *\/\n+\n+\/*\n+ * @test id=StoreNSerial\n+ * @bug 8020282\n+ * @summary Test that we do not generate redundant leas on x86 when storing narrow oops to object arrays.\n+ * @requires os.simpleArch == \"x64\" & vm.gc.Serial\n+ * @modules jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/test\/lib \/\n+ * @run driver compiler.codegen.TestRedundantLea StoreNSerial\n+ *\/\n+\n+\/*\n+ * @test id=StoreNParallel\n+ * @bug 8020282\n+ * @summary Test that we do not generate redundant leas on x86 when storing narrow oops to object arrays.\n+ * @requires os.simpleArch == \"x64\" & vm.gc.Parallel\n+ * @modules jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/test\/lib \/\n+ * @run driver compiler.codegen.TestRedundantLea StoreNParallel\n+ *\/\n+\n+\n+package compiler.codegen;\n+\n+import java.util.concurrent.atomic.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import com.sun.tools.javac.util.*;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/\/ The following tests ensure that we do not generate a redundant lea instruction on x86.\n+\/\/ These get generated on chained dereferences for the rules leaPCompressedOopOffset,\n+\/\/ leaP8Narrow, and leaP32Narrow and stem from a decodeHeapOopNotNull that is not needed\n+\/\/ unless the derived oop is added to an oop map. The redundant lea is removed with an\n+\/\/ opto assembly peephole optimization. Hence, all tests below feature a negative test\n+\/\/ run with -XX:-OptoPeephole to detect changes that obsolete that peephole.\n+\/\/ Further, all tests are run with different max heap sizes to trigger the generation of\n+\/\/ different lea match rules: -XX:MaxHeapSize=32m generates leaP(8|32)Narrow and\n+\/\/ -XX:MaxHeapSize=4g generates leaPCompressedOopOffset, since the address computation\n+\/\/ needs to shift left by 3.\n+public class TestRedundantLea {\n+    public static void main(String[] args) {\n+        String testName = args[0];\n+        TestFramework framework;\n+        switch (testName) {\n+            case \"GetAndSet\" -> {\n+                framework = new TestFramework(GetAndSetTest.class);\n+            }\n+            case \"StringEquals\" -> {\n+                framework = new TestFramework(StringEqualsTest.class);\n+                framework.addHelperClasses(StringEqualsTestHelper.class);\n+            }\n+            case \"StringInflate\" -> {\n+                framework = new TestFramework(StringInflateTest.class);\n+                framework.addFlags(\"--add-exports=jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\");\n+            }\n+            case \"RegexFind\" -> {\n+                framework = new TestFramework(RegexFindTest.class);\n+            }\n+            case \"StoreNSerial\" -> {\n+                framework = new TestFramework(StoreNTest.class);\n+                framework.addFlags(\"-XX:+UseSerialGC\");\n+            }\n+            case \"StoreNParallel\" -> {\n+                framework = new TestFramework(StoreNTest.class);\n+                framework.addFlags(\"-XX:+UseParallelGC\");\n+            }\n+            default -> {\n+                throw new IllegalArgumentException(\"Unknown test name \\\"\" + testName +\"\\\"\");\n+            }\n+        }\n+\n+        Scenario[] scenarios = new Scenario[2];\n+        \/\/ Scenario for the negative test without peephole optimizations.\n+        scenarios[0] = new Scenario(0, \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-OptoPeephole\");\n+        \/\/ Scenario for the positive test with +OptoPeephole (the default on x64).\n+        scenarios[1] = new Scenario(1);\n+        framework.addScenarios(scenarios).start();\n+    }\n+}\n+\n+\/\/ This generates a leaP* rule for the chained dereference of obj.value that\n+\/\/ gets passed to the get and set VM intrinsic.\n+class GetAndSetTest {\n+    private static final Object CURRENT = new Object();\n+    private final AtomicReference<Object> obj = new AtomicReference<Object>();\n+\n+    @Test\n+    @IR(counts = {IRNode.LEA_P, \"=1\"},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIfPlatform = {\"mac\", \"false\"})\n+    \/\/ Negative test\n+    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \"=1\"},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIf = {\"OptoPeephole\", \"false\"})\n+    \/\/ Test that the peephole worked for leaP(8|32)Narrow\n+    @IR(failOn = {IRNode.DECODE_HEAP_OOP_NOT_NULL},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIf = {\"OptoPeephole\", \"true\"})\n+    public void testGetAndSet() {\n+        obj.getAndSet(CURRENT);\n+    }\n+}\n+\n+\/\/ This generates leaP* rules for the chained dereferences of the String.value\n+\/\/ fields that are used in the string_equals VM intrinsic.\n+class StringEqualsTest {\n+    final StringEqualsTestHelper strEqHelper = new StringEqualsTestHelper(\"I am the string that is tested against\");\n+\n+    @Setup\n+    private static Object[] setup() {\n+        return new Object[]{\"I will be compared!\"};\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LEA_P, \"=2\"},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIfPlatform = {\"mac\", \"false\"})\n+    \/\/ Negative test\n+    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \"=3\"},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIf = {\"OptoPeephole\", \"false\"})\n+    \/\/ Test that the peephole worked for leaPCompressedOopOffset\n+    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \"=1\"},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIf = {\"OptoPeephole\", \"true\"})\n+    @Arguments(setup = \"setup\")\n+    public boolean test(String str) {\n+        return strEqHelper.doEquals(str);\n+    }\n+}\n+\n+class StringEqualsTestHelper {\n+    private String str;\n+\n+    public StringEqualsTestHelper(String str) {\n+        this.str = str;\n+    }\n+\n+    @ForceInline\n+    public boolean doEquals(String other) {\n+        return this.str.equals(other);\n+    }\n+}\n+\n+\/\/ With all VM instrinsics disabled, this test only generates a leaP* rule\n+\/\/ before the string_inflate intrinsic (with -XX:-OptimizeStringConcat no\n+\/\/ leaP* rule is generated). With VM intrinsics enabled (this is the case\n+\/\/ here) leaP* rules are also generated for the string_equals and arrays_hashcode\n+\/\/ VM instrinsics.\n+\/\/ This generates a larger number of decodes for -XX:UseAVX={0,1} than for\n+\/\/ other flags.\n+class StringInflateTest {\n+    @Setup\n+    private static Object[] setup() {\n+        Names names = new Names(new Context());\n+        Name n1 = names.fromString(\"one\");\n+        Name n2 = names.fromString(\"two\");\n+        return new Object[] {n1, n2};\n+    }\n+\n+    @Test\n+    \/\/ TODO: Make tests more precise\n+    @IR(counts = {IRNode.LEA_P, \"=2\"},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIfPlatform = {\"mac\", \"false\"})\n+    \/\/ Negative\n+    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \">=5\"},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIf = {\"OptoPeephole\", \"false\"})\n+    \/\/ 2 decodes get removed\n+    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \">=3\"},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIf = {\"OptoPeephole\", \"true\"})\n+    @Arguments(setup = \"setup\")\n+    public static Name test(Name n1, Name n2) {\n+        return n1.append(n2);\n+    }\n+}\n+\n+\/\/ This test case generates leaP* rules before arrayof_jint_fill intrinsics,\n+\/\/ but only with -XX:+UseAVX3.\n+class RegexFindTest {\n+    @Setup\n+    private static Object[] setup() {\n+        Pattern pat = Pattern.compile(\"27\");\n+        Matcher m = pat.matcher(\" 274  leaPCompressedOopOffset  === _ 275 277  [[ 2246 165 294 ]] #16\/0x0000000000000010byte[int:>=0]\");\n+        return new Object[] { m };\n+    }\n+\n+    @Test\n+    \/\/ TODO: Make tests more precise\n+    @IR(counts = {IRNode.LEA_P, \"=1\"},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIfPlatform = {\"mac\", \"false\"})\n+    \/\/ Due to unpredictable code generation, we cannot match the exact number of decodes below.\n+    \/\/ Negative test\n+    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \">=7\"},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIfAnd = {\"OptoPeephole\", \"false\", \"UseAVX\", \"=3\"})\n+    \/\/ Test that the peephole worked for leaPCompressedOopOffset\n+    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \">=6\"},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIfAnd = {\"OptoPeephole\", \"true\", \"UseAVX\", \"=3\"})\n+    @Arguments(setup = \"setup\")\n+    public boolean test(Matcher m) {\n+        return m.find();\n+    }\n+}\n+\n+\/\/ The matcher generates leaP* rules for storing an object in an array of objects\n+\/\/ at a constant offset, but only when using the Serial or Parallel GC.\n+\/\/ Here, we can also manipulate the offset such that we get a leaP32Narrow rule\n+\/\/ and we can demonstrate that the peephole also removes simple cases of unneeded\n+\/\/ spills.\n+class StoreNTest {\n+    private static final int SOME_SIZE = 42;\n+    private static final int OFFSET8BIT_IDX = 3;\n+    private static final int OFFSET32BIT_IDX = 33;\n+\n+    private static final Object CURRENT = new Object();\n+    private static final Object OTHER = new Object();\n+\n+    private StoreNTestHelper[] classArr8bit = new StoreNTestHelper[SOME_SIZE];\n+    private StoreNTestHelper[] classArr32bit = new StoreNTestHelper[SOME_SIZE];\n+    private Object[] objArr8bit = new Object[SOME_SIZE];\n+    private Object[] objArr32bit = new Object[SOME_SIZE];\n+\n+    @Test\n+    @IR(counts = {IRNode.LEA_P, \"=2\"},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIfPlatform = {\"mac\", \"false\"})\n+    \/\/ Negative test\n+    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \"=2\"},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIf = {\"OptoPeephole\", \"false\"})\n+    \/\/ Test that the peephole worked for leaPCompressedOopOffset\n+    @IR(failOn = {IRNode.DECODE_HEAP_OOP_NOT_NULL},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIf = {\"OptoPeephole\", \"true\"})\n+    \/\/ Test that the peephole removes a spill.\n+    @IR(counts = {IRNode.MEM_TO_REG_SPILL_COPY, \"=4\"},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIfAnd ={\"OptoPeephole\", \"false\", \"UseCompactObjectHeaders\", \"false\"})\n+    @IR(counts = {IRNode.MEM_TO_REG_SPILL_COPY, \"=3\"},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIfAnd ={\"OptoPeephole\", \"true\", \"UseCompactObjectHeaders\", \"false\"})\n+    public void testRemoveSpill() {\n+        this.classArr8bit[OFFSET8BIT_IDX] = new StoreNTestHelper(CURRENT, OTHER);\n+        this.classArr32bit[OFFSET32BIT_IDX] = new StoreNTestHelper(OTHER, CURRENT);\n+    }\n+\n+    \/\/ This variation of the test above generates a split spill register path.\n+    \/\/ Due to the complicated graph structure with the phis, the peephole\n+    \/\/ cannot remove the redundant decode shared by both leaP*s.\n+    @Test\n+    @IR(counts = {IRNode.LEA_P, \"=2\"},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIfPlatform = {\"mac\", \"false\"})\n+    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \"=1\"},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIf = {\"OptoPeephole\", \"false\"})\n+    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \"=1\"},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIf = {\"OptoPeephole\", \"true\"})\n+    public void testPhiSpill() {\n+        this.classArr8bit[OFFSET8BIT_IDX] = new StoreNTestHelper(CURRENT, OTHER);\n+        this.classArr8bit[OFFSET32BIT_IDX] = new StoreNTestHelper(CURRENT, OTHER);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LEA_P, \"=2\"},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIfPlatform = {\"mac\", \"false\"})\n+    \/\/ Negative test\n+    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \"=2\"},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIf = {\"OptoPeephole\", \"false\"})\n+    \/\/ Test that the peephole worked for leaPCompressedOopOffset\n+    @IR(failOn = {IRNode.DECODE_HEAP_OOP_NOT_NULL},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIf = {\"OptoPeephole\", \"true\"})\n+    public void testNoAlloc() {\n+        this.objArr8bit[OFFSET8BIT_IDX] = CURRENT;\n+        this.objArr32bit[OFFSET32BIT_IDX] = OTHER;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LEA_P, \"=2\"},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIfPlatform = {\"mac\", \"false\"})\n+    \/\/ Negative test\n+    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \"=1\"},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIf = {\"OptoPeephole\", \"false\"})\n+    \/\/ Test that the peephole worked for leaPCompressedOopOffset\n+    @IR(failOn = {IRNode.DECODE_HEAP_OOP_NOT_NULL},\n+        phase = {CompilePhase.FINAL_CODE},\n+        applyIf = {\"OptoPeephole\", \"true\"})\n+    public void testNoAllocSameArray() {\n+        this.objArr8bit[OFFSET8BIT_IDX] = CURRENT;\n+        this.objArr8bit[OFFSET32BIT_IDX] = OTHER;\n+    }\n+}\n+\n+class StoreNTestHelper {\n+    Object o1;\n+    Object o2;\n+\n+    public StoreNTestHelper(Object o1, Object o2) {\n+        this.o1 = o1;\n+        this.o2 = o2;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestRedundantLea.java","additions":378,"deletions":0,"binary":false,"changes":378,"status":"added"},{"patch":"@@ -33,1 +33,2 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"ppc64\" | os.arch==\"ppc64le\"\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestCompareUnsigned.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import jdk.vm.ci.code.RegisterArray;\n@@ -116,1 +115,1 @@\n-        return codeCache.addCode(dummyMethod, code, log, installedCode);\n+        return codeCache.addCode(dummyMethod, code, log, installedCode, true);\n@@ -121,2 +120,1 @@\n-        RegisterArray allRegs = arch.getAvailableValueRegisters();\n-        for (Register reg : allRegs) {\n+        for (Register reg : arch.getAvailableValueRegisters()) {\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/CodeInstallerTest.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -232,2 +232,2 @@\n-    public static void invalidateHotSpotNmethod(HotSpotNmethod nmethodMirror, boolean deoptimize) {\n-        CTVM.invalidateHotSpotNmethod(nmethodMirror, deoptimize);\n+    public static void invalidateHotSpotNmethod(HotSpotNmethod nmethodMirror, boolean deoptimize, int invalidationReason) {\n+        CTVM.invalidateHotSpotNmethod(nmethodMirror, deoptimize, invalidationReason);\n@@ -309,1 +309,1 @@\n-            super(method, name, false, 0);\n+            super(method, name, false, true, 0);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/patches\/jdk.internal.vm.ci\/jdk\/vm\/ci\/hotspot\/CompilerToVMHelper.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-            InstalledCode installed = codeCache.addCode(resolvedMethod, code, null, null);\n+            InstalledCode installed = codeCache.addCode(resolvedMethod, code, null, null, true);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/CodeInstallationTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-                codeCache.installCode(null, stub, null, null, true);\n+                codeCache.installCode(null, stub, null, null, true, true);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/RuntimeStubAllocFailTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -161,0 +161,10 @@\n+    @Test\n+    public void isAnnotationTest() {\n+        for (Class<?> c : classes) {\n+            ResolvedJavaType type = metaAccess.lookupJavaType(c);\n+            boolean expected = c.isAnnotation();\n+            boolean actual = type.isAnnotation();\n+            assertEquals(expected, actual);\n+        }\n+    }\n+\n@@ -1022,0 +1032,12 @@\n+    @Test\n+    public void getAllMethodsTest() {\n+        for (Class<?> c : classes) {\n+            ResolvedJavaType type = metaAccess.lookupJavaType(c);\n+            Set<ResolvedJavaMethod> allMethods = new HashSet<>(type.getAllMethods(true));\n+            Stream<ResolvedJavaMethod> allKnownMethods = Stream.concat(Arrays.stream(type.getDeclaredMethods()), Arrays.stream(type.getDeclaredConstructors()));\n+            allKnownMethods = Stream.concat(allKnownMethods, Stream.ofNullable(type.getClassInitializer()));\n+            List<ResolvedJavaMethod> missingMethods = allKnownMethods.filter(m -> !allMethods.contains(m)).toList();\n+            assertTrue(missingMethods.toString(), missingMethods.isEmpty());\n+        }\n+    }\n+\n@@ -1258,0 +1280,15 @@\n+    private static void getAnnotationDataExpectedToFail(Annotated annotated, ResolvedJavaType... annotationTypes) {\n+        try {\n+            if (annotationTypes.length == 1) {\n+                annotated.getAnnotationData(annotationTypes[0]);\n+            } else {\n+                var tail = Arrays.copyOfRange(annotationTypes, 2, annotationTypes.length);\n+                annotated.getAnnotationData(annotationTypes[0], annotationTypes[1], tail);\n+            }\n+            String s = Stream.of(annotationTypes).map(ResolvedJavaType::toJavaName).collect(Collectors.joining(\", \"));\n+            throw new AssertionError(\"Expected IllegalArgumentException for retrieving (\" + s + \" from \" + annotated);\n+        } catch (IllegalArgumentException iae) {\n+            assertTrue(iae.getMessage(), iae.getMessage().contains(\"not an annotation interface\"));\n+        }\n+    }\n+\n@@ -1263,1 +1300,1 @@\n-     * @param annotated a {@link Class}, {@link Method} or {@link Field} object\n+     * @param annotatedElement a {@link Class}, {@link Method} or {@link Field} object\n@@ -1265,5 +1302,20 @@\n-    public static void getAnnotationDataTest(AnnotatedElement annotated) throws Exception {\n-        testGetAnnotationData(annotated, List.of(annotated.getAnnotations()));\n-    }\n-\n-    private static void testGetAnnotationData(AnnotatedElement annotated, List<Annotation> annotations) throws AssertionError {\n+    public static void getAnnotationDataTest(AnnotatedElement annotatedElement) throws Exception {\n+        Annotated annotated = toAnnotated(annotatedElement);\n+        ResolvedJavaType objectType = metaAccess.lookupJavaType(Object.class);\n+        ResolvedJavaType suppressWarningsType = metaAccess.lookupJavaType(SuppressWarnings.class);\n+        getAnnotationDataExpectedToFail(annotated, objectType);\n+        getAnnotationDataExpectedToFail(annotated, suppressWarningsType, objectType);\n+        getAnnotationDataExpectedToFail(annotated, suppressWarningsType, suppressWarningsType, objectType);\n+\n+        \/\/ Check that querying a missing annotation returns null or an empty list\n+        assertNull(annotated.getAnnotationData(suppressWarningsType));\n+        List<AnnotationData> data = annotated.getAnnotationData(suppressWarningsType, suppressWarningsType);\n+        assertTrue(data.toString(), data.isEmpty());\n+        data = annotated.getAnnotationData(suppressWarningsType, suppressWarningsType, suppressWarningsType, suppressWarningsType);\n+        assertTrue(data.toString(), data.isEmpty());\n+\n+        testGetAnnotationData(annotatedElement, annotated, List.of(annotatedElement.getAnnotations()));\n+    }\n+\n+    private static void testGetAnnotationData(AnnotatedElement annotatedElement, Annotated annotated, List<Annotation> annotations) throws AssertionError {\n+        ResolvedJavaType suppressWarningsType = metaAccess.lookupJavaType(SuppressWarnings.class);\n@@ -1271,1 +1323,2 @@\n-            AnnotationData ad = toAnnotated(annotated).getAnnotationData(metaAccess.lookupJavaType(a.annotationType()));\n+            var annotationType = metaAccess.lookupJavaType(a.annotationType());\n+            AnnotationData ad = annotated.getAnnotationData(annotationType);\n@@ -1275,1 +1328,1 @@\n-            AnnotationData ad2 = toAnnotated(annotated).getAnnotationData(metaAccess.lookupJavaType(a.annotationType()));\n+            AnnotationData ad2 = annotated.getAnnotationData(annotationType);\n@@ -1277,0 +1330,3 @@\n+\n+            List<AnnotationData> annotationData = annotated.getAnnotationData(annotationType, suppressWarningsType, suppressWarningsType);\n+            assertEquals(1, annotationData.size());\n@@ -1289,1 +1345,1 @@\n-            List<AnnotationData> annotationData = toAnnotated(annotated).getAnnotationData(type1, type2, types);\n+            List<AnnotationData> annotationData = annotated.getAnnotationData(type1, type2, types);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":65,"deletions":9,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -117,5 +117,5 @@\n-            case \"NoAlignVector\"         -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"AlignVector\"           -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n-            case \"VerifyAlignVector\"     -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+VerifyAlignVector\"); }\n-            case \"NoAlignVector-COH\"     -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"VerifyAlignVector-COH\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+VerifyAlignVector\"); }\n+            case \"NoAlignVector\"         -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"AlignVector\"           -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"VerifyAlignVector\"     -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+VerifyAlignVector\"); }\n+            case \"NoAlignVector-COH\"     -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"VerifyAlignVector-COH\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+VerifyAlignVector\"); }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAlignVector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -85,4 +85,4 @@\n-            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n-            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestIndependentPacksWithCyclicDependency.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,4 +80,4 @@\n-        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-AlignVector\", \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaers\");\n-        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+AlignVector\", \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaers\");\n-        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-AlignVector\", \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaers\");\n-        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+AlignVector\", \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaers\");\n+        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-AlignVector\", \"-XX:-UseCompactObjectHeaers\");\n+        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+AlignVector\", \"-XX:-UseCompactObjectHeaers\");\n+        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-AlignVector\", \"-XX:+UseCompactObjectHeaers\");\n+        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+AlignVector\", \"-XX:+UseCompactObjectHeaers\");\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMulAddS2I.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -64,4 +64,4 @@\n-            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n-            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestScheduleReordersScalarMemops.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -79,4 +79,4 @@\n-            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n-            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestSplitPacks.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,4 +42,4 @@\n-        TestFramework.runWithFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n-        TestFramework.runWithFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n-        TestFramework.runWithFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n-        TestFramework.runWithFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n+        TestFramework.runWithFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n+        TestFramework.runWithFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n+        TestFramework.runWithFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n+        TestFramework.runWithFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestUnorderedReductionPartialVectorization.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -53,4 +53,4 @@\n-            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n-            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -56,4 +56,4 @@\n-            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n-            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVectorNaN.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,4 +72,4 @@\n-            case \"nCOH_nAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"};\n-            case \"nCOH_yAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"};\n-            case \"yCOH_nAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"};\n-            case \"yCOH_yAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"};\n+            case \"nCOH_nAV\" -> new String[]{\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"};\n+            case \"nCOH_yAV\" -> new String[]{\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"};\n+            case \"yCOH_nAV\" -> new String[]{\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"};\n+            case \"yCOH_yAV\" -> new String[]{\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"};\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayTypeConvertTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -70,4 +70,4 @@\n-            case \"nCOH_nAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"};\n-            case \"nCOH_yAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"};\n-            case \"yCOH_nAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"};\n-            case \"yCOH_yAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"};\n+            case \"nCOH_nAV\" -> new String[]{\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"};\n+            case \"nCOH_yAV\" -> new String[]{\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"};\n+            case \"yCOH_nAV\" -> new String[]{\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"};\n+            case \"yCOH_yAV\" -> new String[]{\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"};\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopCombinedOpTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -197,1 +197,1 @@\n-        new LogMessageWithLevel(\"Expand Heap After Collection:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Resize Heap After Collection:\", Level.DEBUG),\n@@ -323,2 +323,1 @@\n-        output.shouldContain(\"Expand the heap. requested expansion amount: \");\n-        output.shouldContain(\"B expansion amount: \");\n+        output.shouldContain(\"Heap resize: \");\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n-\/*\n- * @test id=passive\n+\/**\n+ * @test id=satb-adaptive\n@@ -31,2 +31,3 @@\n- * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=passive\n+ * @run main\/othervm -Xms100m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info -Dtarget=10000\n+ *      -XX:ShenandoahGCMode=satb\n@@ -34,1 +35,1 @@\n- *      -Dtarget=10000\n+ *      -XX:ShenandoahGCHeuristics=adaptive\n@@ -37,5 +38,0 @@\n- * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=passive\n- *      -XX:-ShenandoahDegeneratedGC\n- *      -Dtarget=10000\n- *      TestDynamicSoftMaxHeapSize\n@@ -44,2 +40,2 @@\n-\/*\n- * @test id=aggressive\n+\/**\n+ * @test id=satb-aggressive\n@@ -49,3 +45,5 @@\n- * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=aggressive\n- *      -Dtarget=1000\n+ * @run main\/othervm -Xms100m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info -Dtarget=10000\n+ *      -XX:ShenandoahGCMode=satb\n+ *      -XX:+ShenandoahDegeneratedGC\n+ *      -XX:ShenandoahGCHeuristics=aggressive\n@@ -53,0 +51,1 @@\n+ *\n@@ -55,2 +54,2 @@\n-\/*\n- * @test id=adaptive\n+\/**\n+ * @test id=satb-compact\n@@ -60,3 +59,5 @@\n- * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive\n- *      -Dtarget=10000\n+ * @run main\/othervm -Xms100m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info -Dtarget=10000\n+ *      -XX:ShenandoahGCMode=satb\n+ *      -XX:+ShenandoahDegeneratedGC\n+ *      -XX:ShenandoahGCHeuristics=compact\n@@ -64,0 +65,1 @@\n+ *\n@@ -66,2 +68,2 @@\n-\/*\n- * @test id=generational\n+\/**\n+ * @test id=satb-static\n@@ -71,3 +73,5 @@\n- * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n- *      -Dtarget=10000\n+ * @run main\/othervm -Xms100m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info -Dtarget=10000\n+ *      -XX:ShenandoahGCMode=satb\n+ *      -XX:+ShenandoahDegeneratedGC\n+ *      -XX:ShenandoahGCHeuristics=static\n@@ -75,0 +79,1 @@\n+ *\n@@ -77,2 +82,2 @@\n-\/*\n- * @test id=static\n+\/**\n+ * @test id=passive\n@@ -83,1 +88,8 @@\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=static\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=passive\n+ *      -XX:+ShenandoahDegeneratedGC\n+ *      -Dtarget=10000\n+ *      TestDynamicSoftMaxHeapSize\n+ *\n+ * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=passive\n+ *      -XX:-ShenandoahDegeneratedGC\n@@ -88,2 +100,2 @@\n-\/*\n- * @test id=compact\n+\/**\n+ * @test id=generational\n@@ -93,4 +105,6 @@\n- * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=compact\n- *      -Dtarget=1000\n- *     TestDynamicSoftMaxHeapSize\n+ * @run main\/othervm -Xms100m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info -Dtarget=10000\n+ *      -XX:ShenandoahGCMode=generational\n+ *      -XX:ShenandoahGCHeuristics=adaptive\n+ *      TestDynamicSoftMaxHeapSize\n+ *\n@@ -99,1 +113,12 @@\n-import java.util.Random;\n+\/**\n+ * @test id=generational-softMaxHeapSizeValidation\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -DvalidateSoftMaxHeap=true\n+ *      TestDynamicSoftMaxHeapSize\n+ *      -Xms100m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info -Dtarget=10000 -DverifySoftMaxHeapValue=true\n+ *      -XX:ShenandoahGCMode=generational\n+ *      -XX:ShenandoahGCHeuristics=adaptive\n+ *\/\n@@ -105,0 +130,5 @@\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+\n@@ -106,0 +136,7 @@\n+    static final int K = 1024;\n+    static final int XMS_MB = 100;\n+    static final int XMX_MB = 512;\n+\n+    public static void main(String[] args) throws Exception {\n+        if (\"true\".equals(System.getProperty(\"validateSoftMaxHeap\"))) {\n+            List<String> flagArgs = new ArrayList<>(Arrays.asList(args));\n@@ -107,2 +144,4 @@\n-    static final long TARGET_MB = Long.getLong(\"target\", 10_000); \/\/ 10 Gb allocation\n-    static final long STRIDE = 10_000_000;\n+            int softMaxInMb = Utils.getRandomInstance().nextInt(XMS_MB, XMX_MB);\n+            flagArgs.add(\"-DsoftMaxCapacity=\" + softMaxInMb * K * K);\n+            flagArgs.add(\"-Dtest.jdk=\" + System.getProperty(\"test.jdk\"));\n+            flagArgs.add(\"-Dcompile.jdk=\" + System.getProperty(\"compile.jdk\"));\n@@ -110,1 +149,1 @@\n-    static volatile Object sink;\n+            flagArgs.add(SoftMaxWithExpectationTest.class.getName());\n@@ -112,10 +151,27 @@\n-    public static void main(String[] args) throws Exception {\n-        long count = TARGET_MB * 1024 * 1024 \/ 16;\n-        Random r = Utils.getRandomInstance();\n-        PidJcmdExecutor jcmd = new PidJcmdExecutor();\n-\n-        for (long c = 0; c < count; c += STRIDE) {\n-            \/\/ Sizes specifically include heaps below Xms and above Xmx to test saturation code.\n-            jcmd.execute(\"VM.set_flag SoftMaxHeapSize \" + r.nextInt(768*1024*1024), true);\n-            for (long s = 0; s < STRIDE; s++) {\n-                sink = new Object();\n+            ProcessBuilder genShenPbValidateFlag = ProcessTools.createLimitedTestJavaProcessBuilder(flagArgs);\n+            OutputAnalyzer output = new OutputAnalyzer(genShenPbValidateFlag.start());\n+            output.shouldHaveExitValue(0);\n+            output.shouldContain(String.format(\"Soft Max Heap Size: %dM -> %dM\", XMX_MB, softMaxInMb)); \/\/ By default, the soft max heap size is Xmx\n+        } else {\n+            SoftMaxSetFlagOnlyTest.test();\n+        }\n+    }\n+\n+    public static class SoftMaxSetFlagOnlyTest {\n+        static final long TARGET_MB = Long.getLong(\"target\", 10_000); \/\/ 10 Gb allocation\n+        static final long STRIDE = 10_000_000;\n+\n+        static volatile Object sink;\n+\n+        public static void test() throws Exception {\n+            long count = TARGET_MB * 1024 * 1024 \/ 16;\n+            Random r = Utils.getRandomInstance();\n+            PidJcmdExecutor jcmd = new PidJcmdExecutor();\n+\n+            for (long c = 0; c < count; c += STRIDE) {\n+                \/\/ Sizes specifically include heaps below Xms and above Xmx to test saturation code.\n+                jcmd.execute(\"VM.set_flag SoftMaxHeapSize \" + r.nextInt(768*1024*1024), true);\n+                for (long s = 0; s < STRIDE; s++) {\n+                    sink = new Object();\n+                }\n+                Thread.sleep(1);\n@@ -123,1 +179,0 @@\n-            Thread.sleep(1);\n@@ -127,0 +182,15 @@\n+    public static class SoftMaxWithExpectationTest {\n+        static final long TOTAL = 100_000_000;\n+\n+        static volatile Object sink;\n+\n+        public static void main(String[] args) throws Exception {\n+            int expectedSoftMaxHeapSize = Integer.getInteger(\"softMaxCapacity\", 0);\n+            PidJcmdExecutor jcmd = new PidJcmdExecutor();\n+            jcmd.execute(\"VM.set_flag SoftMaxHeapSize \" + expectedSoftMaxHeapSize, false);\n+\n+            for (long s = 0; s < TOTAL; s++) {\n+                sink = new Object();\n+            }\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestDynamicSoftMaxHeapSize.java","additions":119,"deletions":49,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2021, 2025, Red Hat, Inc. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"ppc64le\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"ppc64\" | os.arch == \"ppc64le\"\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestLinkToNativeRBP.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UnlockExperimentalVMOptions -XX:+UseCompressedOops -XX:+UseCompressedClassPointers -XX:-UseCompactObjectHeaders BaseOffsets\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseCompressedOops -XX:+UseCompressedClassPointers -XX:-UseCompactObjectHeaders BaseOffsets\n@@ -42,1 +42,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UnlockExperimentalVMOptions -XX:-UseCompressedOops -XX:+UseCompressedClassPointers -XX:-UseCompactObjectHeaders BaseOffsets\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-UseCompressedOops -XX:+UseCompressedClassPointers -XX:-UseCompactObjectHeaders BaseOffsets\n@@ -52,1 +52,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UnlockExperimentalVMOptions -XX:+UseCompressedOops -XX:-UseCompressedClassPointers -XX:-UseCompactObjectHeaders BaseOffsets\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseCompressedOops -XX:-UseCompressedClassPointers -XX:-UseCompactObjectHeaders BaseOffsets\n@@ -62,1 +62,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UnlockExperimentalVMOptions -XX:-UseCompressedOops -XX:-UseCompressedClassPointers -XX:-UseCompactObjectHeaders BaseOffsets\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-UseCompressedOops -XX:-UseCompressedClassPointers -XX:-UseCompactObjectHeaders BaseOffsets\n@@ -72,1 +72,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UnlockExperimentalVMOptions -XX:+UseCompressedOops -XX:+UseCompactObjectHeaders BaseOffsets\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseCompressedOops -XX:+UseCompactObjectHeaders BaseOffsets\n@@ -82,1 +82,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UnlockExperimentalVMOptions -XX:-UseCompressedOops -XX:+UseCompactObjectHeaders BaseOffsets\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-UseCompressedOops -XX:+UseCompactObjectHeaders BaseOffsets\n","filename":"test\/hotspot\/jtreg\/runtime\/FieldLayout\/BaseOffsets.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,1 @@\n-            .addPrefix(\"-Xlog:cds+map*=trace:file=\" + mapName + \":none:filesize=0\")\n+            .addPrefix(\"-Xlog:aot+map*=trace:file=\" + mapName + \":none:filesize=0\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/DeterministicDump.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-        int n = 2;\n@@ -130,24 +129,14 @@\n-            String[] sizes = {\n-                \"4m\",   \/\/ usually this will success load the archived heap\n-                \"2m\",   \/\/ usually this will fail to load the archived heap, but app can launch\n-                        \/\/ or fail with \"GC triggered before VM initialization completed\"\n-                \"1m\"    \/\/ usually this will cause VM launch to fail with \"Too small maximum heap\"\n-            };\n-            for (String sz : sizes) {\n-                String xmx = \"-Xmx\" + sz;\n-                System.out.println(\"=======\\n\" + n + \". Exec with \" + execGC + \" \" + xmx);\n-                out = TestCommon.exec(helloJar,\n-                                      execGC,\n-                                      small1,\n-                                      small2,\n-                                      xmx,\n-                                      coops,\n-                                      \"-Xlog:cds\",\n-                                      \"Hello\");\n-                if (out.getExitValue() == 0) {\n-                    out.shouldContain(HELLO);\n-                    out.shouldNotContain(errMsg);\n-                } else {\n-                    out.shouldNotHaveFatalError();\n-                }\n-                n++;\n+            System.out.println(\"2. Exec with \" + execGC);\n+            out = TestCommon.exec(helloJar,\n+                                    execGC,\n+                                    small1,\n+                                    small2,\n+                                    \"-Xmx4m\",\n+                                    coops,\n+                                    \"-Xlog:cds\",\n+                                    \"Hello\");\n+            if (out.getExitValue() == 0) {\n+                out.shouldContain(HELLO);\n+                out.shouldNotContain(errMsg);\n+            } else {\n+                out.shouldNotHaveFatalError();\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestParallelGCWithCDS.java","additions":14,"deletions":25,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -0,0 +1,284 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test how various AOT optimizations handle classes that are excluded from the AOT cache.\n+ * @requires vm.cds.write.archived.java.heap\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/test-classes\n+ * @build ExcludedClasses CustyWithLoop\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *                 TestApp\n+ *                 TestApp$Foo\n+ *                 TestApp$Foo$Bar\n+ *                 TestApp$Foo$ShouldBeExcluded\n+ *                 TestApp$Foo$ShouldBeExcludedChild\n+ *                 TestApp$Foo$Taz\n+ *                 TestApp$MyInvocationHandler\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar cust.jar\n+ *                 CustyWithLoop\n+ * @run driver ExcludedClasses\n+ *\/\n+\n+import java.io.File;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+\n+import jdk.jfr.Event;\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class ExcludedClasses {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+    static final String mainClass = \"TestApp\";\n+\n+    public static void main(String[] args) throws Exception {\n+        Tester tester = new Tester();\n+        tester.runAOTWorkflow(\"AOT\", \"--two-step-training\");\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+        public Tester() {\n+            super(mainClass);\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            return new String[] {\n+                \"-Xlog:aot=debug\",\n+                \"-Xlog:aot+class=debug\",\n+                \"-Xlog:aot+resolve=trace\",\n+                \"-Xlog:aot+verification=trace\",\n+                \"-Xlog:class+load\",\n+            };\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                mainClass, runMode.name()\n+            };\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) {\n+            if (runMode == RunMode.ASSEMBLY) {\n+                out.shouldNotMatch(\"aot,resolve.*archived field.*TestApp.Foo => TestApp.Foo.ShouldBeExcluded.f:I\");\n+            } else if (runMode == RunMode.PRODUCTION) {\n+                out.shouldContain(\"check_verification_constraint: TestApp$Foo$Taz: TestApp$Foo$ShouldBeExcludedChild must be subclass of TestApp$Foo$ShouldBeExcluded\");\n+                out.shouldContain(\"jdk.jfr.Event source: jrt:\/jdk.jfr\");\n+                out.shouldMatch(\"TestApp[$]Foo[$]ShouldBeExcluded source: .*\/app.jar\");\n+                out.shouldMatch(\"TestApp[$]Foo[$]ShouldBeExcludedChild source: .*\/app.jar\");\n+            }\n+        }\n+    }\n+}\n+\n+class TestApp {\n+    static volatile Object custInstance;\n+    static volatile Object custArrayInstance;\n+\n+    public static void main(String args[]) throws Exception {\n+        \/\/ In AOT workflow, classes from custom loaders are passed from the preimage\n+        \/\/ to the final image. See FinalImageRecipes::record_all_classes().\n+        custInstance = initFromCustomLoader();\n+        custArrayInstance = Array.newInstance(custInstance.getClass(), 0);\n+        System.out.println(custArrayInstance);\n+        System.out.println(\"Counter = \" + Foo.hotSpot());\n+    }\n+\n+    static Object initFromCustomLoader() throws Exception {\n+        String path = \"cust.jar\";\n+        URL url = new File(path).toURI().toURL();\n+        URL[] urls = new URL[] {url};\n+        URLClassLoader urlClassLoader =\n+            new URLClassLoader(\"MyLoader\", urls, null);\n+        Class c = Class.forName(\"CustyWithLoop\", true, urlClassLoader);\n+        return c.newInstance();\n+    }\n+\n+    static class MyInvocationHandler implements InvocationHandler {\n+        volatile static int cnt;\n+\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            long start = System.currentTimeMillis();\n+            while (System.currentTimeMillis() - start < 20) {\n+                cnt += 2;\n+                for (int i = 0; i < 1000; i++) {\n+                    int n = cnt - 2;\n+                    if (n < 2) {\n+                        n = 2;\n+                    }\n+                    cnt += (i + cnt) % n + cnt % 2;\n+                }\n+            }\n+            return Integer.valueOf(cnt);\n+        }\n+    }\n+\n+    static class Foo {\n+        volatile static int counter;\n+        static Class c = ShouldBeExcluded.class;\n+\n+        static Map mapProxy = (Map) Proxy.newProxyInstance(\n+            Foo.class.getClassLoader(),\n+            new Class[] { Map.class },\n+            new MyInvocationHandler());\n+\n+        static int hotSpot() {\n+            ShouldBeExcluded s = new ShouldBeExcluded();\n+            Bar b = new Bar();\n+\n+            long start = System.currentTimeMillis();\n+            while (System.currentTimeMillis() - start < 1000) {\n+                lambdaHotSpot();\n+                s.hotSpot2();\n+                b.hotSpot3();\n+                Taz.hotSpot4();\n+\n+                \/\/ In JDK mainline, generated proxy classes are excluded from the AOT cache.\n+                \/\/ In Leyden\/premain, generated proxy classes included. The following code should\n+                \/\/ work with either repos.\n+                Integer i = (Integer)mapProxy.get(null);\n+                counter += i.intValue();\n+\n+                if (custInstance != null) {\n+                    \/\/ Classes loaded by custom loaders are included in the AOT cache\n+                    \/\/ but their array classes are excluded.\n+                    counter += custInstance.equals(null) ? 1 : 2;\n+                }\n+\n+                if (custArrayInstance != null) {\n+                    if ((counter % 3) == 0) {\n+                        counter += (custArrayInstance instanceof String) ? 0 : 1;\n+                    } else {\n+                        counter += (custArrayInstance instanceof Object) ? 0 : 1;\n+                    }\n+                }\n+            }\n+\n+            return counter + s.m() + s.f + b.m() + b.f;\n+        }\n+\n+        static void f() {\n+            if (counter % 2 == 1) {\n+                counter ++;\n+            }\n+        }\n+\n+        \/\/ Generated Lambda classes should be excluded from CDS preimage.\n+        static void lambdaHotSpot() {\n+            long start = System.currentTimeMillis();\n+            while (System.currentTimeMillis() - start < 20) {\n+                doit(() -> counter ++ );\n+            }\n+        }\n+\n+        static void doit(Runnable r) {\n+            r.run();\n+        }\n+\n+        \/\/ All subclasses of jdk.jfr.Event are excluded from the CDS archive.\n+        static class ShouldBeExcluded extends jdk.jfr.Event {\n+            int f = (int)(System.currentTimeMillis()) + 123;\n+            int m() {\n+                return f + 456;\n+            }\n+\n+            void hotSpot2() {\n+                long start = System.currentTimeMillis();\n+                while (System.currentTimeMillis() - start < 20) {\n+                    for (int i = 0; i < 50000; i++) {\n+                        counter += i;\n+                    }\n+                    f();\n+                }\n+            }\n+            int func() {\n+                return 1;\n+            }\n+        }\n+\n+        static class ShouldBeExcludedChild extends ShouldBeExcluded {\n+            @Override\n+            int func() {\n+                return 2;\n+            }\n+        }\n+\n+        static class Bar {\n+            int f = (int)(System.currentTimeMillis()) + 123;\n+            int m() {\n+                return f + 456;\n+            }\n+\n+            void hotSpot3() {\n+                long start = System.currentTimeMillis();\n+                while (System.currentTimeMillis() - start < 20) {\n+                    for (int i = 0; i < 50000; i++) {\n+                        counter += i;\n+                    }\n+                    f();\n+                }\n+            }\n+        }\n+\n+        static class Taz {\n+            static ShouldBeExcluded m() {\n+                \/\/ When verifying this method, we need to check the constraint that\n+                \/\/ ShouldBeExcluded must be a supertype of ShouldBeExcludedChild. This information\n+                \/\/ is checked by SystemDictionaryShared::check_verification_constraints() when the Taz\n+                \/\/ class is linked during the production run.\n+                \/\/\n+                \/\/ Because ShouldBeExcluded is excluded from the AOT archive, it must be loaded\n+                \/\/ dynamically from app.jar inside SystemDictionaryShared::check_verification_constraints().\n+                \/\/ This must happen after the app class loader has been fully restored from the AOT cache.\n+                return new ShouldBeExcludedChild();\n+            }\n+            static void hotSpot4() {\n+                long start = System.currentTimeMillis();\n+                while (System.currentTimeMillis() - start < 20) {\n+                    for (int i = 0; i < 50000; i++) {\n+                        counter += i;\n+                    }\n+                    f();\n+                }\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/ExcludedClasses.java","additions":284,"deletions":0,"binary":false,"changes":284,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8357601\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native TestCharArrayReleasing 0 0\n+ * @run main\/othervm\/native TestCharArrayReleasing 1 0\n+ * @run main\/othervm\/native TestCharArrayReleasing 2 0\n+ * @run main\/othervm\/native TestCharArrayReleasing 3 0\n+ * @run main\/othervm\/native TestCharArrayReleasing 4 0\n+ * @run main\/othervm\/native TestCharArrayReleasing 0 1\n+ * @run main\/othervm\/native TestCharArrayReleasing 1 1\n+ * @run main\/othervm\/native TestCharArrayReleasing 2 1\n+ * @run main\/othervm\/native TestCharArrayReleasing 3 1\n+ * @run main\/othervm\/native TestCharArrayReleasing 4 1\n+ * @run main\/othervm\/native TestCharArrayReleasing 0 2\n+ * @run main\/othervm\/native TestCharArrayReleasing 1 2\n+ * @run main\/othervm\/native TestCharArrayReleasing 2 2\n+ * @run main\/othervm\/native TestCharArrayReleasing 3 2\n+ * @run main\/othervm\/native TestCharArrayReleasing 4 2\n+ * @run main\/othervm\/native TestCharArrayReleasing 0 3\n+ * @run main\/othervm\/native TestCharArrayReleasing 1 3\n+ * @run main\/othervm\/native TestCharArrayReleasing 2 3\n+ * @run main\/othervm\/native TestCharArrayReleasing 3 3\n+ * @run main\/othervm\/native TestCharArrayReleasing 4 3\n+ *\/\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/\/ Test the behaviour of the JNI \"char\" releasing functions, under Xcheck:jni,\n+\/\/ when they are passed \"char\" arrays obtained from different sources:\n+\/\/ - source_mode indicates which array to use\n+\/\/   - 0: use a raw malloc'd array\n+\/\/   - 1: use an array from GetCharArrayElements\n+\/\/   - 2: use an array from GetStringChars\n+\/\/   - 3: use an array from GetStringUTFChars\n+\/\/   - 4: use an array from GetPrimitiveArrayCritical\n+\/\/ - release_mode indicates which releasing function to use\n+\/\/   - 0: ReleaseCharArrayElements\n+\/\/   - 1: ReleaseStringChars\n+\/\/   - 2: ReleaseStringUTFChars\n+\/\/   - 3: ReleasePrimitiveArrayCritical\n+\n+public class TestCharArrayReleasing {\n+\n+    static native void testIt(int srcMode, int releaseMode);\n+\n+    static class Driver {\n+\n+        static {\n+            System.loadLibrary(\"CharArrayReleasing\");\n+        }\n+\n+        public static void main(String[] args) {\n+            int srcMode = Integer.parseInt(args[0]);\n+            int relMode = Integer.parseInt(args[1]);\n+            testIt(srcMode, relMode);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        int ABRT = 1;\n+        int[][] errorCodes = new int[][] {\n+            { ABRT, 0, ABRT, ABRT, ABRT },\n+            { ABRT, ABRT, 0, ABRT, ABRT },\n+            { ABRT, ABRT, ABRT, 0, ABRT },\n+            { ABRT, ABRT, ABRT, ABRT, 0 },\n+        };\n+\n+        String rcae = \"ReleaseCharArrayElements called on something allocated by GetStringChars\";\n+        String rcaeUTF = \"ReleaseCharArrayElements called on something allocated by GetStringUTFChars\";\n+        String rcaeCrit = \"ReleaseCharArrayElements called on something allocated by GetPrimitiveArrayCritical\";\n+        String rcaeBounds = \"ReleaseCharArrayElements: release array failed bounds check\";\n+        String rsc = \"ReleaseStringChars called on something not allocated by GetStringChars\";\n+        String rscBounds = \"ReleaseStringChars: release chars failed bounds check\";\n+        String rsuc = \"ReleaseStringUTFChars called on something not allocated by GetStringUTFChars\";\n+        String rsucBounds = \"ReleaseStringUTFChars: release chars failed bounds check\";\n+        String rpac = \"ReleasePrimitiveArrayCritical called on something not allocated by GetPrimitiveArrayCritical\";\n+        String rpacBounds = \"ReleasePrimitiveArrayCritical: release array failed bounds check\";\n+        String rpacStr = \"ReleasePrimitiveArrayCritical called on something allocated by GetStringChars\";\n+        String rpacStrUTF = \"ReleasePrimitiveArrayCritical called on something allocated by GetStringUTFChars\";\n+\n+        String[][] errorMsgs = new String[][] {\n+            { rcaeBounds, \"\", rcae, rcaeUTF, rcaeCrit },\n+            { rscBounds, rsc, \"\", rsc, rsc },\n+            { rsucBounds, rsuc, rsuc, \"\", rsuc },\n+            { rpacBounds, rpac, rpacStr, rpacStrUTF, \"\" },\n+        };\n+\n+        int srcMode = Integer.parseInt(args[0]);\n+        int relMode = Integer.parseInt(args[1]);\n+\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+             \"-Djava.library.path=\" + System.getProperty(\"test.nativepath\"),\n+             \"--enable-native-access=ALL-UNNAMED\",\n+             \"-XX:-CreateCoredumpOnCrash\",\n+             \"-Xcheck:jni\",\n+             \"TestCharArrayReleasing$Driver\",\n+             args[0], args[1]);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(errorCodes[relMode][srcMode]);\n+        output.shouldContain(errorMsgs[relMode][srcMode]);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/TestCharArrayReleasing.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+\n+\/\/ Test the behaviour of the JNI \"char\" releasing functions, under Xcheck:jni,\n+\/\/ when they are passed \"char\" arrays obtained from different sources:\n+\/\/ - source_mode indicates which array to use\n+\/\/   - 0: use a raw malloc'd array\n+\/\/   - 1: use an array from GetCharArrayElements\n+\/\/   - 2: use an array from GetStringChars\n+\/\/   - 3: use an array from GetStringUTFChars\n+\/\/   - 4: use an array from GetPrimitiveArrayCritical\n+\/\/ - release_mode indicates which releasing function to use\n+\/\/   - 0: ReleaseCharArrayElements\n+\/\/   - 1: ReleaseStringChars\n+\/\/   - 2: ReleaseStringUTFChars\n+\/\/   - 3: ReleasePrimitiveArrayCritical\n+\/\/\n+\n+static char* source[] = {\n+  \"malloc\",\n+  \"GetCharArrayElements\",\n+  \"GetStringChars\",\n+  \"GetStringUTFChars\",\n+  \"GetPrimitiveArrayCritical\"\n+};\n+\n+static char* release_func[] = {\n+  \"ReleaseCharArrayElements\",\n+  \"ReleaseStringChars\",\n+  \"ReleaseStringUTFChars\",\n+  \"ReleasePrimitiveArrayCritical\"\n+};\n+\n+JNIEXPORT void JNICALL\n+Java_TestCharArrayReleasing_testIt(JNIEnv *env, jclass cls, jint source_mode,\n+                               jint release_mode) {\n+\n+  \/\/ First create some Java objects to be used as the sources for jchar[]\n+  \/\/ extraction.\n+  const int len = 10;\n+  jcharArray ca = (*env)->NewCharArray(env, len);\n+  jstring str = (*env)->NewStringUTF(env, \"A_String\");\n+\n+  jthrowable exc = (*env)->ExceptionOccurred(env);\n+  if (exc != NULL) {\n+    fprintf(stderr, \"ERROR: Unexpected exception during test set up:\\n\");\n+    (*env)->ExceptionDescribe(env);\n+    exit(2);\n+  }\n+\n+  fprintf(stdout, \"Testing release function %s with array from %s\\n\",\n+          release_func[release_mode], source[source_mode]);\n+  fflush(stdout);\n+\n+  jboolean is_copy = JNI_FALSE;\n+  jchar* to_release;\n+  switch(source_mode) {\n+  case 0: {\n+    to_release = malloc(10 * sizeof(jchar));\n+    break;\n+  }\n+  case 1: {\n+    to_release = (*env)->GetCharArrayElements(env, ca, &is_copy);\n+    break;\n+  }\n+  case 2: {\n+    to_release = (jchar*) (*env)->GetStringChars(env, str, &is_copy);\n+    break;\n+  }\n+  case 3: {\n+    to_release = (jchar*) (*env)->GetStringUTFChars(env, str, &is_copy);\n+    break;\n+  }\n+  case 4: {\n+    to_release = (jchar*) (*env)->GetPrimitiveArrayCritical(env, ca, &is_copy);\n+    break;\n+  }\n+  default: fprintf(stderr, \"Unexpected source_mode %d\\n\", source_mode);\n+    exit(1);\n+  }\n+\n+  switch (release_mode) {\n+  case 0:\n+    (*env)->ReleaseCharArrayElements(env, ca, to_release, 0);\n+    break;\n+  case 1:\n+    (*env)->ReleaseStringChars(env, str, to_release);\n+    break;\n+  case 2:\n+    (*env)->ReleaseStringUTFChars(env, str, (const char*)to_release);\n+    break;\n+  case 3:\n+    (*env)->ReleasePrimitiveArrayCritical(env, ca, to_release, 0);\n+    break;\n+  default: fprintf(stderr, \"Unexpected release_mode %d\\n\", source_mode);\n+    exit(1);\n+  }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/libCharArrayReleasing.c","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"arm\" | os.arch==\"aarch64\" | os.arch==\"ppc64\" | os.arch==\"s390\" | os.arch==\"riscv64\"\n+ * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"arm\" | os.arch==\"aarch64\" | os.arch==\"ppc64\" | os.arch==\"ppc64le\" | os.arch==\"s390\" | os.arch==\"riscv64\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/AsyncGetCallTrace\/MyPackage\/ASGCTBaseTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-        Debugee debuggee = binder.startLocalDebugee(cmd);\n+        Debugee debuggee = binder.startDebugee(cmd);\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/framework\/TestProcessLauncher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import utils.JstatGcCauseTool;\n@@ -39,1 +40,1 @@\n-    private final TmTool<? extends JstatResults> jstatTool;\n+    private final JstatGcCauseTool jstatTool;\n@@ -41,1 +42,1 @@\n-    public GarbageProducerTest(TmTool<? extends JstatResults> tool) {\n+    public GarbageProducerTest(JstatGcCauseTool tool) {\n@@ -48,4 +49,4 @@\n-        \/\/ Run once and get the  results asserting that they are reasonable\n-        JstatResults measurement1 = jstatTool.measure();\n-        measurement1.assertConsistency();\n-        \/\/ Eat metaspace and heap then run the tool again and get the results  asserting that they are reasonable\n+        \/\/ Run once and get the results asserting that they are reasonable\n+        JstatResults measurement1 = jstatTool.measureAndAssertConsistency();\n+\n+        \/\/ Eat metaspace and heap then run the tool again and get the results, asserting that they are reasonable\n","filename":"test\/hotspot\/jtreg\/serviceability\/tmtools\/jstat\/GarbageProducerTest.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,1 @@\n-        JstatGcNewResults measurement1 = jstatGcTool.measure();\n-        measurement1.assertConsistency();\n+        JstatGcNewResults measurement1 = jstatGcTool.measureAndAssertConsistency();\n@@ -54,2 +53,1 @@\n-        JstatGcNewResults measurement2 = jstatGcTool.measure();\n-        measurement2.assertConsistency();\n+        JstatGcNewResults measurement2 = jstatGcTool.measureAndAssertConsistency();\n@@ -63,2 +61,1 @@\n-        JstatGcNewResults measurement3 = jstatGcTool.measure();\n-        measurement3.assertConsistency();\n+        JstatGcNewResults measurement3 = jstatGcTool.measureAndAssertConsistency();\n","filename":"test\/hotspot\/jtreg\/serviceability\/tmtools\/jstat\/GcNewTest.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,3 +50,2 @@\n-        \/\/ Run once and get the  results asserting that they are reasonable\n-        JstatGcResults measurement1 = jstatGcTool.measure();\n-        measurement1.assertConsistency();\n+        \/\/ Run once and get the results asserting that they are reasonable\n+        JstatGcResults measurement1 = jstatGcTool.measureAndAssertConsistency();\n@@ -59,2 +58,1 @@\n-        JstatGcResults measurement2 = jstatGcTool.measure();\n-        measurement2.assertConsistency();\n+        JstatGcResults measurement2 = jstatGcTool.measureAndAssertConsistency();\n@@ -69,2 +67,1 @@\n-        JstatGcResults measurement3 = jstatGcTool.measure();\n-        measurement3.assertConsistency();\n+        JstatGcResults measurement3 = jstatGcTool.measureAndAssertConsistency();\n@@ -75,2 +72,0 @@\n-\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/tmtools\/jstat\/GcTest01.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-        new GarbageProducerTest(new JstatGcTool(ProcessHandle.current().pid())).run();\n+        new GarbageProducerTest(new JstatGcCauseTool(ProcessHandle.current().pid())).run();\n","filename":"test\/hotspot\/jtreg\/serviceability\/tmtools\/jstat\/GcTest02.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-public class JstatGcCapacityTool extends TmTool<JstatGcCapacityResults> {\n+public class JstatGcCapacityTool extends JstatTool<JstatGcCapacityResults> {\n@@ -36,1 +36,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/tmtools\/jstat\/utils\/JstatGcCapacityTool.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-public class JstatGcCauseTool extends TmTool<JstatGcCauseResults> {\n+public class JstatGcCauseTool extends JstatTool<JstatGcCauseResults> {\n@@ -36,1 +36,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/tmtools\/jstat\/utils\/JstatGcCauseTool.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-public class JstatGcNewTool extends TmTool<JstatGcNewResults> {\n+public class JstatGcNewTool extends JstatTool<JstatGcNewResults> {\n@@ -36,1 +36,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/tmtools\/jstat\/utils\/JstatGcNewTool.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-public class JstatGcTool extends TmTool<JstatGcResults> {\n+public class JstatGcTool extends JstatTool<JstatGcResults> {\n@@ -36,1 +36,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/tmtools\/jstat\/utils\/JstatGcTool.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-abstract public class JstatResults extends ToolResults {\n+public abstract class JstatResults extends ToolResults {\n@@ -184,1 +184,1 @@\n-    abstract public void assertConsistency();\n+     public abstract void assertConsistency();\n","filename":"test\/hotspot\/jtreg\/serviceability\/tmtools\/jstat\/utils\/JstatResults.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package utils;\n+\n+import common.TmTool;\n+\n+\/**\n+ * Common base class for Jstat tools.\n+ *\/\n+public class JstatTool<T extends JstatResults> extends TmTool<T> {\n+\n+    private static final int TRIES = 3;\n+\n+     public JstatTool(Class<T> resultsClz, String toolName, String otherArgs) {\n+        super(resultsClz, toolName, otherArgs);\n+    }\n+\n+    \/**\n+     * Measure, and call assertConsistency() on the results,\n+     * tolerating a set number of failures to account for inconsistencies in PerfData.\n+     *\/\n+    public T measureAndAssertConsistency() throws Exception {\n+        T results = null;\n+        for (int i = 1; i <= TRIES; i++) {\n+            try {\n+                results = measure();\n+                results.assertConsistency();\n+            } catch (RuntimeException e) {\n+                System.out.println(\"Attempt \" + i + \": \" + e);\n+                if (i == TRIES) {\n+                    System.out.println(\"Too many failures.\");\n+                    throw(e);\n+                }\n+                \/\/ Will retry.\n+            }\n+        }\n+        return results;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/tmtools\/jstat\/utils\/JstatTool.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.reflect.Constructor;\n@@ -32,0 +33,1 @@\n+import java.lang.reflect.Method;\n@@ -82,2 +84,8 @@\n-        \/\/ Make sure the class is initialized.\n-        UNSAFE.ensureClassInitialized(aClass);\n+        \/\/ Attempt to initialize the class. If initialization is not possible\n+        \/\/ due to NCDFE, accept this, and try compile anyway.\n+        try {\n+            UNSAFE.ensureClassInitialized(aClass);\n+        } catch (NoClassDefFoundError e) {\n+            CompileTheWorld.OUT.printf(\"[%d]\\t%s\\tNOTE unable to init class : %s%n\",\n+                id, aClass.getName(), e);\n+        }\n@@ -86,0 +94,21 @@\n+        \/\/ Getting constructor\/methods with unresolvable signatures would fail with NCDFE.\n+        \/\/ Try to get as much as possible, and compile everything else.\n+        \/\/ TODO: Would be good to have a Whitebox method that returns the subset of resolvable\n+        \/\/ constructors\/methods without throwing NCDFE. This would extend the testing scope.\n+        Constructor[] constructors = new Constructor[0];\n+        Method[] methods = new Method[0];\n+\n+        try {\n+            constructors = aClass.getDeclaredConstructors();\n+        } catch (NoClassDefFoundError e) {\n+            CompileTheWorld.OUT.printf(\"[%d]\\t%s\\tNOTE unable to get constructors : %s%n\",\n+                id, aClass.getName(), e);\n+        }\n+\n+        try {\n+            methods = aClass.getDeclaredMethods();\n+        } catch (NoClassDefFoundError e) {\n+            CompileTheWorld.OUT.printf(\"[%d]\\t%s\\tNOTE unable to get methods : %s%n\",\n+                id, aClass.getName(), e);\n+        }\n+\n@@ -88,1 +117,1 @@\n-        for (Executable e : aClass.getDeclaredConstructors()) {\n+        for (Executable e : constructors) {\n@@ -91,1 +120,1 @@\n-        for (Executable e : aClass.getDeclaredMethods()) {\n+        for (Executable e : methods) {\n@@ -97,1 +126,1 @@\n-        for (Executable e : aClass.getDeclaredConstructors()) {\n+        for (Executable e : constructors) {\n@@ -101,1 +130,1 @@\n-        for (Executable e : aClass.getDeclaredMethods()) {\n+        for (Executable e : methods) {\n@@ -130,0 +159,3 @@\n+            } catch (NoClassDefFoundError e) {\n+                CompileTheWorld.OUT.printf(\"[%d]\\t%s\\tNOTE unable to preload : %s%n\",\n+                    id, className, e);\n@@ -131,2 +163,2 @@\n-                CompileTheWorld.OUT.println(String.format(\"[%d]\\t%s\\tWARNING preloading failed : %s\",\n-                         id, className, t));\n+                CompileTheWorld.OUT.printf(\"[%d]\\t%s\\tWARNING preloading failed : %s%n\",\n+                    id, className, t);\n@@ -173,0 +205,5 @@\n+            \/\/ Make sure method is not compiled at any level before starting\n+            \/\/ progressive compilations. No deopt in-between tiers is needed,\n+            \/\/ as long as we increase the compilation levels one by one.\n+            WHITE_BOX.deoptimizeMethod(method);\n+\n@@ -176,1 +213,0 @@\n-                    WHITE_BOX.deoptimizeMethod(method);\n@@ -183,1 +219,2 @@\n-            \/\/ Make the method eligible for sweeping sooner\n+            \/\/ Ditch all the compiled versions of the code, make the method\n+            \/\/ eligible for sweeping sooner.\n","filename":"test\/hotspot\/jtreg\/testlibrary\/ctw\/src\/sun\/hotspot\/tools\/ctw\/Compiler.java","additions":47,"deletions":10,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -248,0 +248,3 @@\n+            } catch (NoClassDefFoundError e) {\n+                CompileTheWorld.OUT.printf(\"[%d]\\t%s\\tNOTE unable to load\/compile, skipped: %s%n\",\n+                    id, name, e);\n@@ -249,2 +252,2 @@\n-                CompileTheWorld.OUT.println(String.format(\"[%d]\\t%s\\tWARNING skipped: %s\",\n-                        id, name, e));\n+                CompileTheWorld.OUT.printf(\"[%d]\\t%s\\tWARNING skipped: %s%n\",\n+                    id, name, e);\n","filename":"test\/hotspot\/jtreg\/testlibrary\/ctw\/src\/sun\/hotspot\/tools\/ctw\/PathHandler.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+\n+#Unstable methods\n+*::hashCode\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/conf\/exclude.methods.lst","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.jittester;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Executable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.Asserts;\n+\n+import static java.util.function.Predicate.not;\n+\n+\n+\/**\n+ * A wrapper for string method templates, similar to the CompileCommand patterns.\n+ *\/\n+public final class MethodTemplate {\n+\n+    \/**\n+     * String that can have wildcard symbols on its ends, allowing it to match a family of strings.\n+     * For example, \"abc*\" matches \"abc123\", and so on.\n+     *\/\n+    public static class WildcardString {\n+        private final String pattern;\n+        private final boolean frontWildcarded;\n+        private final boolean tailWildcarded;\n+\n+        \/**\n+         * Creates a WildcardString from given string.\n+         * @param pattern   string pattern, like \"some*\"\n+         *\/\n+        public WildcardString(String pattern) {\n+            \/\/ check for the leading '*'\n+            frontWildcarded = pattern.charAt(0) == '*';\n+            pattern = frontWildcarded ? pattern.substring(1) : pattern;\n+\n+            \/\/ check for the trailing '*'\n+            tailWildcarded = pattern.length() > 0 && pattern.charAt(pattern.length() - 1) == '*';\n+            pattern = tailWildcarded ? pattern.substring(0, pattern.length() - 1) : pattern;\n+\n+            this.pattern = pattern;\n+        }\n+\n+        \/**\n+         * Returns true it this WildcardString matches given other string.\n+         * @param other the string that this WildcardString should be matched against\n+         * @return      true in case of a match.\n+         *\/\n+        public boolean matches(String other) {\n+            boolean result = pattern.equals(other);\n+            result |= frontWildcarded ? other.endsWith(pattern) : result;\n+            result |= tailWildcarded ? other.startsWith(pattern) : result;\n+            result |= tailWildcarded && frontWildcarded ? other.contains(pattern) : result;\n+            return result;\n+        }\n+    }\n+\n+    private static final Pattern METHOD_PATTERN = Pattern.compile(generateMethodPattern());\n+\n+    private final WildcardString klassName;\n+    private final WildcardString methodName;\n+    private final Optional<List<Class<?>>> signature;\n+\n+    private MethodTemplate(String klassName, String methodName, Optional<List<Class<?>>> signature) {\n+        this.klassName = new WildcardString(klassName);\n+        this.methodName = new WildcardString(methodName);\n+        this.signature = signature;\n+    }\n+\n+    private static String generateMethodPattern() {\n+        \/\/ Sample valid template(s):    java\/lang\/String::indexOf(Ljava\/lang\/String;I)\n+        \/\/                              java\/lang\/::*(Ljava\/lang\/String;I)\n+        \/\/                              *String::indexOf(*)\n+        \/\/                              java\/lang\/*::indexOf\n+\n+        String primitiveType = \"[ZBSCIJFD]\";        \/\/ Simply a letter, like 'I'\n+        String referenceType = \"L[\\\\w\/$]+;\";        \/\/ Like 'Ljava\/lang\/String;'\n+        String primOrRefType =\n+            \"\\\\[?\" + primitiveType +                \/\/ Bracket is optional: '[Z', or 'Z'\n+            \"|\" +\n+            \"\\\\[?\" + referenceType;                 \/\/ Bracket is optional: '[LSomeObject;' or 'LSomeObject;'\n+        String argTypesOrWildcard = \"(\" +           \/\/ Method argument(s) Ljava\/lang\/String;Z...\n+                \"(\" + primOrRefType + \")*\" +\n+            \")|\\\\*\";                                \/\/ .. or a wildcard:\n+\n+        return\n+            \"(?<klassName>[\\\\w\/$]*\\\\*?)\" +          \/\/ Class name, like 'java\/lang\/String'\n+            \"::\" +                                  \/\/ Simply '::'\n+            \"(?<methodName>\\\\*?[\\\\w$]+\\\\*?)\" +      \/\/ method name, 'indexOf''\n+            \"(\\\\((?<argTypes>\" +                    \/\/ Method argument(s) in brackets:\n+                argTypesOrWildcard +                \/\/     (Ljava\/lang\/String;Z) or '*' or nothing\n+            \")\\\\))?\";\n+    }\n+\n+    \/**\n+     * Returns true iff none of the given MethodTemplates matches the given Executable.\n+     *\n+     * @param templates     the collection of templates to check\n+     * @param method        the executable to match the colletions templates\n+     * @return              true if none of the given templates matches the method, false otherwise\n+     *\/\n+    public static boolean noneMatches(Collection<MethodTemplate> templates, Executable method) {\n+        for (MethodTemplate template : templates) {\n+            if (template.matches(method)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Returns true if this MethodTemplate matches the given Executable.\n+     *\n+     * @param other     the Executable to try to match to\n+     * @return          whether the other matches this MethodTemplate\n+     *\/\n+    public boolean matches(Executable other) {\n+        boolean result = klassName.matches(other.getDeclaringClass().getName());\n+\n+        result &= (other instanceof Constructor)\n+            ? result\n+            : methodName.matches(other.getName());\n+\n+        return result &&\n+            signature.map(Arrays.asList(other.getParameterTypes())::equals)\n+                     .orElse(true);\n+    }\n+\n+    \/**\n+     * Parses the given string and returs a MethodTemplate.\n+     *\n+     * @param methodStr     the string to parse\n+     * @return              created MethodTemplate\n+     *\/\n+    public static MethodTemplate parse(String methodStr) {\n+        Matcher matcher = METHOD_PATTERN.matcher(methodStr);\n+        String msg = String.format(\"Format of the methods exclude input file is incorrect,\"\n+                + \" methodStr \\\"%s\\\" has wrong format\", methodStr);\n+        Asserts.assertTrue(matcher.matches(), msg);\n+\n+        String klassName = matcher.group(\"klassName\").replaceAll(\"\/\", \"\\\\.\");\n+        String methodName = matcher.group(\"methodName\");\n+        Optional<List<Class<?>>> signature = Optional.ofNullable(matcher.group(\"argTypes\"))\n+                                                     .filter(not(\"*\"::equals))\n+                                                     .map(MethodTemplate::parseSignature);\n+        return new MethodTemplate(klassName, methodName, signature);\n+    }\n+\n+    private static List<Class<?>> parseSignature(String signature) {\n+        List<Class<?>> sigClasses = new ArrayList<>();\n+        char typeChar;\n+        boolean isArray;\n+        String klassName;\n+        StringBuilder sb;\n+        StringBuilder arrayDim;\n+        try (StringReader str = new StringReader(signature)) {\n+            int symbol = str.read();\n+            while (symbol != -1) {\n+                typeChar = (char) symbol;\n+                arrayDim = new StringBuilder();\n+                Class<?> primArrayClass = null;\n+                if (typeChar == '[') {\n+                    isArray = true;\n+                    arrayDim.append('[');\n+                    symbol = str.read();\n+                    while (symbol == '[') {\n+                        arrayDim.append('[');\n+                        symbol = str.read();\n+                    }\n+                    typeChar = (char) symbol;\n+                    if (typeChar != 'L') {\n+                        primArrayClass = Class.forName(arrayDim.toString() + typeChar);\n+                    }\n+                } else {\n+                    isArray = false;\n+                }\n+                switch (typeChar) {\n+                    case 'Z':\n+                        sigClasses.add(isArray ? primArrayClass : boolean.class);\n+                        break;\n+                    case 'I':\n+                        sigClasses.add(isArray ? primArrayClass : int.class);\n+                        break;\n+                    case 'J':\n+                        sigClasses.add(isArray ? primArrayClass : long.class);\n+                        break;\n+                    case 'F':\n+                        sigClasses.add(isArray ? primArrayClass : float.class);\n+                        break;\n+                    case 'D':\n+                        sigClasses.add(isArray ? primArrayClass : double.class);\n+                        break;\n+                    case 'B':\n+                        sigClasses.add(isArray ? primArrayClass : byte.class);\n+                        break;\n+                    case 'S':\n+                        sigClasses.add(isArray ? primArrayClass : short.class);\n+                        break;\n+                    case 'C':\n+                        sigClasses.add(isArray ? primArrayClass : char.class);\n+                        break;\n+                    case 'L':\n+                        sb = new StringBuilder();\n+                        symbol = str.read();\n+                        while (symbol != ';') {\n+                            sb.append((char) symbol);\n+                            symbol = str.read();\n+                        }\n+                        klassName = sb.toString().replaceAll(\"\/\", \"\\\\.\");\n+                        if (isArray) {\n+                            klassName = arrayDim.toString() + \"L\" + klassName + \";\";\n+                        }\n+                        Class<?> klass = Class.forName(klassName);\n+                        sigClasses.add(klass);\n+                        break;\n+                    default:\n+                        throw new Error(\"Unknown type \" + typeChar);\n+                }\n+                symbol = str.read();\n+            }\n+        } catch (IOException | ClassNotFoundException ex) {\n+            throw new Error(\"Unexpected exception while parsing exclude methods file\", ex);\n+        }\n+        return sigClasses;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/MethodTemplate.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import java.io.File;\n-import java.io.StringReader;\n@@ -38,3 +36,3 @@\n-import java.util.HashSet;\n-import java.util.LinkedList;\n-import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n@@ -47,0 +45,2 @@\n+import static java.util.function.Predicate.not;\n+\n@@ -52,0 +52,2 @@\n+    private List<MethodTemplate> methodsToExclude;\n+\n@@ -54,0 +56,5 @@\n+    private static String trimComment(String source) {\n+        int commentStart = source.indexOf('#');\n+        return commentStart == -1 ? source : source.substring(0, commentStart);\n+    }\n+\n@@ -65,21 +72,15 @@\n-        List<Class<?>> klasses = parseKlasses(klassesFileName);\n-        Set<Executable> methodsToExclude;\n-        if (exMethodsFileName != null && !exMethodsFileName.isEmpty()) {\n-            methodsToExclude = parseMethods(exMethodsFileName);\n-        } else {\n-            methodsToExclude = new HashSet<>();\n-        }\n-        klasses.stream().forEach(klass -> {\n-            TypeKlass typeKlass = (TypeKlass) getType(klass);\n-            if (TypeList.isReferenceType(typeKlass)) {\n-                return;\n-            }\n-            TypeList.add(typeKlass);\n-            Set<Executable> methods = new HashSet<>();\n-            methods.addAll(Arrays.asList(klass.getMethods()));\n-            methods.addAll(Arrays.asList(klass.getConstructors()));\n-            methods.removeAll(methodsToExclude);\n-            methods.stream().forEach(method -> {\n-                if (method.isSynthetic()) {\n-                    return;\n-                }\n+        TypesParser theParser = new TypesParser();\n+        theParser.initMethodsToExclude(exMethodsFileName);\n+        parseKlasses(klassesFileName)\n+            .stream()\n+            .filter(klass -> !TypeList.isReferenceType(getTypeKlass(klass)))\n+            .forEach(theParser::processKlass);\n+    }\n+\n+    private void processKlass(Class<?> klass) {\n+        TypeKlass typeKlass = getTypeKlass(klass);\n+        TypeList.add(typeKlass);\n+        Stream.concat(Arrays.stream(klass.getMethods()), Arrays.stream(klass.getConstructors()))\n+            .filter(not(Executable::isSynthetic))\n+            .filter(method -> MethodTemplate.noneMatches(methodsToExclude, method))\n+            .forEach(method -> {\n@@ -109,2 +110,1 @@\n-                typeKlass.addSymbol(new FunctionInfo(name, typeKlass, returnType, 1, flags,\n-                        paramList));\n+                typeKlass.addSymbol(new FunctionInfo(name, typeKlass, returnType, 1, flags, paramList));\n@@ -112,1 +112,0 @@\n-        });\n@@ -158,0 +157,4 @@\n+    private static TypeKlass getTypeKlass(Class<?> klass) {\n+        return (TypeKlass) getType(klass);\n+    }\n+\n@@ -237,31 +240,3 @@\n-    private static Set<Executable> parseMethods(String methodsFileName) {\n-        Asserts.assertNotNull(methodsFileName, \"Methods exclude input file name is null\");\n-        Asserts.assertFalse(methodsFileName.isEmpty(), \"Methods exclude input file name is empty\");\n-        LinkedList<String> methodNamesList = new LinkedList<>();\n-        Path klassesFilePath = Paths.get(methodsFileName);\n-        try {\n-            Files.lines(klassesFilePath).forEach(line -> {\n-                line = line.trim();\n-                if (line.isEmpty()) {\n-                    return;\n-                }\n-                String msg = String.format(\"Format of the methods exclude input file \\\"%s\\\" is incorrect,\"\n-                        + \" line \\\"%s\\\" has wrong format\", methodsFileName, line);\n-                Asserts.assertTrue(line.matches(\"\\\\w[\\\\w\/$]*::[\\\\w$]+\\\\((\\\\[?[ZBSCIJFD]|\\\\[?L[\\\\w\/$]+;)*\\\\)\"), msg);\n-                methodNamesList.add(line.substring(0, line.length() - 1));\n-            });\n-        } catch (IOException ex) {\n-            throw new Error(\"Error reading exclude method file\", ex);\n-        }\n-        Set<Executable> methodsList = new HashSet<>();\n-        methodNamesList.forEach(methodName -> {\n-            String[] klassAndNameAndSig = methodName.split(\"::\");\n-            String klassName = klassAndNameAndSig[0].replaceAll(\"\/\", \"\\\\.\");\n-            String[] nameAndSig = klassAndNameAndSig[1].split(\"[\\\\(\\\\)]\");\n-            String name = nameAndSig[0];\n-            String signature = \"\";\n-            if (nameAndSig.length > 1) {\n-                signature = nameAndSig[1];\n-            }\n-            Class<?> klass = null;\n-            List<Class<?>> signatureTypes = null;\n+    private void initMethodsToExclude(String methodsFileName) {\n+        if (methodsFileName != null && !methodsFileName.isEmpty()) {\n+            Path methodsFilePath = Paths.get(methodsFileName);\n@@ -269,19 +244,5 @@\n-                klass = Class.forName(klassName);\n-                signatureTypes = parseSignature(signature);\n-            } catch (ClassNotFoundException ex) {\n-                throw new Error(\"Unexpected exception while parsing exclude methods file\", ex);\n-            }\n-            try {\n-                Executable method;\n-                if (name.equals(klass.getSimpleName())) {\n-                    method = klass.getConstructor(signatureTypes.toArray(new Class<?>[0]));\n-                } else {\n-                    method = klass.getMethod(name, signatureTypes.toArray(new Class<?>[0]));\n-                }\n-                methodsList.add(method);\n-            } catch (NoSuchMethodException | SecurityException ex) {\n-                throw new Error(\"Unexpected exception while parsing exclude methods file\", ex);\n-            }\n-        });\n-        return methodsList;\n-    }\n+                methodsToExclude = Files.lines(methodsFilePath)\n+                    \/\/ Cleaning nonimportant parts\n+                    .map(TypesParser::trimComment)\n+                    .map(String::trim)\n+                    .filter(not(String::isEmpty))\n@@ -289,71 +250,5 @@\n-    private static List<Class<?>> parseSignature(String signature) throws ClassNotFoundException {\n-        LinkedList<Class<?>> sigClasses = new LinkedList<>();\n-        char typeChar;\n-        boolean isArray;\n-        String klassName;\n-        StringBuilder sb;\n-        StringBuilder arrayDim;\n-        try (StringReader str = new StringReader(signature)) {\n-            int symbol = str.read();\n-            while (symbol != -1){\n-                typeChar = (char) symbol;\n-                arrayDim = new StringBuilder();\n-                Class<?> primArrayClass = null;\n-                if (typeChar == '[') {\n-                    isArray = true;\n-                    arrayDim.append('[');\n-                    symbol = str.read();\n-                    while (symbol == '['){\n-                        arrayDim.append('[');\n-                        symbol = str.read();\n-                    }\n-                    typeChar = (char) symbol;\n-                    if (typeChar != 'L') {\n-                        primArrayClass = Class.forName(arrayDim.toString() + typeChar);\n-                    }\n-                } else {\n-                    isArray = false;\n-                }\n-                switch (typeChar) {\n-                    case 'Z':\n-                        sigClasses.add(isArray ? primArrayClass : boolean.class);\n-                        break;\n-                    case 'I':\n-                        sigClasses.add(isArray ? primArrayClass : int.class);\n-                        break;\n-                    case 'J':\n-                        sigClasses.add(isArray ? primArrayClass : long.class);\n-                        break;\n-                    case 'F':\n-                        sigClasses.add(isArray ? primArrayClass : float.class);\n-                        break;\n-                    case 'D':\n-                        sigClasses.add(isArray ? primArrayClass : double.class);\n-                        break;\n-                    case 'B':\n-                        sigClasses.add(isArray ? primArrayClass : byte.class);\n-                        break;\n-                    case 'S':\n-                        sigClasses.add(isArray ? primArrayClass : short.class);\n-                        break;\n-                    case 'C':\n-                        sigClasses.add(isArray ? primArrayClass : char.class);\n-                        break;\n-                    case 'L':\n-                        sb = new StringBuilder();\n-                        symbol = str.read();\n-                        while (symbol != ';') {\n-                            sb.append((char) symbol);\n-                            symbol = str.read();\n-                        }\n-                        klassName = sb.toString().replaceAll(\"\/\", \"\\\\.\");\n-                        if (isArray) {\n-                            klassName = arrayDim.toString() + \"L\" + klassName + \";\";\n-                        }\n-                        Class<?> klass = Class.forName(klassName);\n-                        sigClasses.add(klass);\n-                        break;\n-                    default:\n-                        throw new Error(\"Unknown type \" + typeChar);\n-                }\n-                symbol = str.read();\n+                    \/\/ Actual parsing\n+                    .map(MethodTemplate::parse)\n+                    .collect(Collectors.toList());\n+            } catch (IOException ex) {\n+                throw new Error(\"Error reading exclude method file\", ex);\n@@ -361,2 +256,2 @@\n-        } catch (IOException ex) {\n-            throw new Error(\"Unexpected exception while parsing exclude methods file\", ex);\n+        } else {\n+            methodsToExclude = new ArrayList<>();\n@@ -364,1 +259,0 @@\n-        return sigClasses;\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/TypesParser.java","additions":48,"deletions":154,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,1 @@\n-        Debugee debugee = binder.startLocalDebugee(cmd);\n+        Debugee debugee = binder.startDebugee(cmd);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/AttachingConnector\/attach\/attach001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,1 @@\n-        Debugee debugee = binder.startLocalDebugee(cmd);\n+        Debugee debugee = binder.startDebugee(cmd);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/AttachingConnector\/attach\/attach002.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,1 @@\n-        Debugee debugee = binder.startLocalDebugee(cmd);\n+        Debugee debugee = binder.startDebugee(cmd);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/AttachingConnector\/attachnosuspend\/attachnosuspend001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,1 @@\n-        Debugee debugee = binder.makeLocalDebugee(vm.process());\n+        Debugee debugee = binder.makeDebugee(vm.process());\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/LaunchingConnector\/launchnosuspend\/launchnosuspend001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-        Debugee debugee = binder.startLocalDebugee(cmd);\n+        Debugee debugee = binder.startDebugee(cmd);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ListeningConnector\/accept\/accept001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,1 +93,1 @@\n-        Debugee debugee = binder.startLocalDebugee(cmd);\n+        Debugee debugee = binder.startDebugee(cmd);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ListeningConnector\/accept\/accept002.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-        Debugee debugee = binder.startLocalDebugee(cmd);\n+        Debugee debugee = binder.startDebugee(cmd);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ListeningConnector\/listennosuspend\/listennosuspend001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -171,1 +171,1 @@\n-            debugee = binder.startLocalDebugee(cmd);\n+            debugee = binder.startDebugee(cmd);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ListeningConnector\/startListening\/startlis001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,1 +146,1 @@\n-            debugee = binder.startLocalDebugee(cmd);\n+            debugee = binder.startDebugee(cmd);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ListeningConnector\/startListening\/startlis002.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,1 +153,1 @@\n-            debugee = binder.startLocalDebugee(commandToRun);\n+            debugee = binder.startDebugee(commandToRun);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachineManager\/createVirtualMachine\/createVM002.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,1 +154,1 @@\n-            debugee = binder.startLocalDebugee(commandToRun);\n+            debugee = binder.startDebugee(commandToRun);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachineManager\/createVirtualMachine\/createVM003.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,1 +157,1 @@\n-            debugee = binder.startLocalDebugee(commandToRun);\n+            debugee = binder.startDebugee(commandToRun);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachineManager\/createVirtualMachine\/createVM004.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,1 +153,1 @@\n-            debugee = binder.startLocalDebugee(commandToRun);\n+            debugee = binder.startDebugee(commandToRun);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachineManager\/createVirtualMachine\/createVM005.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,3 @@\n+ * @comment We test with arguments out of scope of the jvmti enums, which causes\n+ *          ubsan issues.\n+ * @requires !vm.ubsan\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetErrorName\/geterrname002\/TestDescription.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,3 @@\n+ * @comment We test with arguments out of scope of the jvmti enums, which causes\n+ *          ubsan issues.\n+ * @requires !vm.ubsan\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetVerboseFlag\/setvrbflag002\/TestDescription.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-     * Launch debuggee on local host.\n+     * Launch debuggee.\n@@ -62,1 +62,1 @@\n-        launcher.display(\"Starting local debuggee.\");\n+        launcher.display(\"Starting debuggee.\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdb\/Debuggee.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,2 @@\n- * This class provides launching of <code>jdb<\/code> and debuggee in local\n- * or remote mode according to test command line options.\n+ * This class provides launching of <code>jdb<\/code> and debuggee\n+ * according to test command line options.\n@@ -97,1 +97,1 @@\n-     * Defines mode (local or remote) and type of connector (default, launching,\n+     * Defines type of connector (default, launching,\n@@ -100,1 +100,1 @@\n-     * and debuggee in defined mode.\n+     * and debuggee.\n@@ -107,1 +107,1 @@\n-            localDefaultLaunch(jdbCmdArgs, classToExecute);\n+            defaultLaunch(jdbCmdArgs, classToExecute);\n@@ -109,1 +109,1 @@\n-            localRawLaunch(jdbCmdArgs, classToExecute);\n+            rawLaunch(jdbCmdArgs, classToExecute);\n@@ -111,1 +111,1 @@\n-            localLaunch(jdbCmdArgs, classToExecute);\n+            launchFromJdb(jdbCmdArgs, classToExecute);\n@@ -113,1 +113,1 @@\n-            localLaunchAndAttach(jdbCmdArgs, classToExecute);\n+            launchAndAttach(jdbCmdArgs, classToExecute);\n@@ -115,1 +115,1 @@\n-            localLaunchAndListen(jdbCmdArgs, classToExecute);\n+            launchAndListen(jdbCmdArgs, classToExecute);\n@@ -117,1 +117,1 @@\n-            throw new TestBug(\"Unexpected connector type for local launch mode\"\n+            throw new TestBug(\"Unexpected connector type: \"\n@@ -258,1 +258,1 @@\n-     * Run test in local mode using default connector.\n+     * Run test using default connector.\n@@ -260,1 +260,1 @@\n-    private void localDefaultLaunch\n+    private void defaultLaunch\n@@ -262,1 +262,1 @@\n-        localLaunch(jdbCmdArgs, classToExecute);\n+        launchFromJdb(jdbCmdArgs, classToExecute);\n@@ -266,1 +266,1 @@\n-     * Run test in local mode using raw launching connector.\n+     * Run test using raw launching connector.\n@@ -268,1 +268,1 @@\n-    private void localRawLaunch\n+    private void rawLaunch\n@@ -270,1 +270,1 @@\n-        localLaunch(jdbCmdArgs, classToExecute);\n+        launchFromJdb(jdbCmdArgs, classToExecute);\n@@ -274,1 +274,1 @@\n-     * Run test in local mode using launching connector.\n+     * Run test using launching connector.\n@@ -276,1 +276,1 @@\n-    private void localLaunch\n+    private void launchFromJdb\n@@ -280,1 +280,1 @@\n-        display(\"Starting jdb launching local debuggee\");\n+        display(\"Starting jdb launching debuggee\");\n@@ -290,1 +290,1 @@\n-     * Run test in local mode using attaching connector.\n+     * Run test using attaching connector.\n@@ -292,1 +292,1 @@\n-    private void localLaunchAndAttach\n+    private void launchAndAttach\n@@ -300,1 +300,1 @@\n-        display(\"Start jdb attaching to local debuggee\");\n+        display(\"Starting jdb attaching to debuggee\");\n@@ -306,1 +306,1 @@\n-     * Run test in local mode using listening connector.\n+     * Run test using listening connector.\n@@ -308,1 +308,1 @@\n-    private void localLaunchAndListen\n+    private void launchAndListen\n@@ -312,1 +312,1 @@\n-        display(\"Starting jdb listening to local debuggee\");\n+        display(\"Starting jdb listening to debuggee\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdb\/Launcher.java","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -477,8 +477,0 @@\n-\/*\n-        if (! isLaunchedLocally() && ! isDefaultJVMDIStrictMode()) {\n-            throw new BadOption(\"inconsistent options: \"\n-                                + \"-launch.mode=\" + getLaunchMode()\n-                                + \" and -jvmdi.strict=\" + getJVMDIStrictMode());\n-        }\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdi\/ArgumentHandler.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,1 @@\n-     * Make initial <code>Debugee<\/code> object for local debuggee process\n+     * Make initial <code>Debugee<\/code> object for debuggee process\n@@ -129,1 +129,1 @@\n-    public Debugee makeLocalDebugee(Process process) {\n+    public Debugee makeDebugee(Process process) {\n@@ -134,1 +134,1 @@\n-     * Launch local debuggee process with specified command line\n+     * Launch debuggee process with specified command line\n@@ -137,1 +137,1 @@\n-    public Debugee startLocalDebugee(String cmd) {\n+    public Debugee startDebugee(String cmd) {\n@@ -144,1 +144,1 @@\n-            throw new Failure(\"Caught exception while launching local debuggee VM process:\\n\\t\"\n+            throw new Failure(\"Caught exception while launching debuggee VM process:\\n\\t\"\n@@ -148,1 +148,1 @@\n-        return makeLocalDebugee(process);\n+        return makeDebugee(process);\n@@ -157,1 +157,1 @@\n-        Debugee debugee = makeLocalDebugee(proc);\n+        Debugee debugee = makeDebugee(proc);\n@@ -192,1 +192,1 @@\n-            debugee = localDefaultLaunchDebugee(vmm, classToExecute, classPath);\n+            debugee = defaultLaunchDebugee(vmm, classToExecute, classPath);\n@@ -194,1 +194,1 @@\n-            debugee = localRawLaunchDebugee(vmm, classToExecute, classPath);\n+            debugee = rawLaunchDebugee(vmm, classToExecute, classPath);\n@@ -196,1 +196,1 @@\n-            debugee = localLaunchDebugee(vmm, classToExecute, classPath);\n+            debugee = launchDebugee(vmm, classToExecute, classPath);\n@@ -198,1 +198,1 @@\n-            debugee = localLaunchAndAttachDebugee(vmm, classToExecute, classPath);\n+            debugee = launchAndAttachDebugee(vmm, classToExecute, classPath);\n@@ -200,1 +200,1 @@\n-            debugee = localLaunchAndListenDebugee(vmm, classToExecute, classPath);\n+            debugee = launchAndListenDebugee(vmm, classToExecute, classPath);\n@@ -202,1 +202,1 @@\n-            throw new TestBug(\"Unexpected connector type for local debugee launch mode\"\n+            throw new TestBug(\"Unexpected connector type for debugee: \"\n@@ -234,1 +234,1 @@\n-     * Launch debugee locally via the default LaunchingConnector.\n+     * Launch debugee via the default LaunchingConnector.\n@@ -236,1 +236,1 @@\n-    private Debugee localDefaultLaunchDebugee (VirtualMachineManager vmm,\n+    private Debugee defaultLaunchDebugee (VirtualMachineManager vmm,\n@@ -260,1 +260,1 @@\n-        Debugee debugee = makeLocalDebugee(process);\n+        Debugee debugee = makeDebugee(process);\n@@ -269,1 +269,1 @@\n-     * Launch debugee locally via the default LaunchingConnector.\n+     * Launch debugee via the default LaunchingConnector.\n@@ -271,1 +271,1 @@\n-    private Debugee localLaunchDebugee (VirtualMachineManager vmm,\n+    private Debugee launchDebugee (VirtualMachineManager vmm,\n@@ -298,1 +298,1 @@\n-        Debugee debugee = makeLocalDebugee(process);\n+        Debugee debugee = makeDebugee(process);\n@@ -306,1 +306,1 @@\n-     * Launch debugee locally via the RawLaunchingConnector.\n+     * Launch debugee via the RawLaunchingConnector.\n@@ -308,1 +308,1 @@\n-    private Debugee localRawLaunchDebugee (VirtualMachineManager vmm,\n+    private Debugee rawLaunchDebugee (VirtualMachineManager vmm,\n@@ -334,1 +334,1 @@\n-        Debugee debugee = makeLocalDebugee(process);\n+        Debugee debugee = makeDebugee(process);\n@@ -342,2 +342,1 @@\n-     * Launch debugee VM locally as a local process and connect to it using\n-     * <code>AttachingConnector<\/code>.\n+     * Launch debugee VM and connect to it using <code>AttachingConnector<\/code>.\n@@ -345,1 +344,1 @@\n-    private Debugee localLaunchAndAttachDebugee (VirtualMachineManager vmm,\n+    private Debugee launchAndAttachDebugee (VirtualMachineManager vmm,\n@@ -359,1 +358,1 @@\n-        Debugee debugee = startLocalDebugee(cmdLineArgs);\n+        Debugee debugee = startDebugee(cmdLineArgs);\n@@ -394,2 +393,1 @@\n-     * Launch debugee VM locally as a local process and connect to it using\n-     * <code>ListeningConnector<\/code>.\n+     * Launch debugee VM and connect to it using <code>ListeningConnector<\/code>.\n@@ -397,1 +395,1 @@\n-    private Debugee localLaunchAndListenDebugee (VirtualMachineManager vmm,\n+    private Debugee launchAndListenDebugee (VirtualMachineManager vmm,\n@@ -422,1 +420,1 @@\n-        Debugee debugee = startLocalDebugee(cmdLineArgs);\n+        Debugee debugee = startDebugee(cmdLineArgs);\n@@ -521,1 +519,1 @@\n-        arg.setValue(\"y\");\n+        arg.setValue(argumentHandler.isIncludeVirtualThreads() ? \"y\" : \"n\");\n@@ -688,1 +686,1 @@\n-     * Launch local debuggee process with specified command line arguments\n+     * Launch debuggee process with specified command line arguments\n@@ -691,1 +689,1 @@\n-    protected Debugee startLocalDebugee(String[] cmdArgs) {\n+    protected Debugee startDebugee(String[] cmdArgs) {\n@@ -698,1 +696,1 @@\n-            throw new Failure(\"Caught exception while launching local debuggee VM process:\\n\\t\"\n+            throw new Failure(\"Caught exception while launching debuggee VM process:\\n\\t\"\n@@ -702,1 +700,1 @@\n-        return makeLocalDebugee(process);\n+        return makeDebugee(process);\n@@ -753,1 +751,1 @@\n-}\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdi\/Binder.java","additions":35,"deletions":37,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,5 +41,0 @@\n- * This is an abstract class that declares abstract methods to control\n- * debugee VM process.\n- * Derived classes should implement these methods corresponding to the mode\n- * that the process should be started in (locally, remotely or manually).\n- * <p>\n@@ -55,1 +50,1 @@\n-abstract public class DebugeeProcess {\n+public class DebugeeProcess {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/DebugeeProcess.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8356870\n+ * @summary Test HotSpotDiagnosticMXBean.dumpThreads with a thread owning a monitor for\n+ *     an object that is scalar replaced\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @requires (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @modules jdk.management\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:CompileCommand=inline,java\/lang\/String*.* DumpThreadsWithEliminatedLock plain platform\n+ * @run main\/othervm -XX:CompileCommand=inline,java\/lang\/String*.* DumpThreadsWithEliminatedLock plain virtual\n+ * @run main\/othervm -XX:CompileCommand=inline,java\/lang\/String*.* DumpThreadsWithEliminatedLock json platform\n+ * @run main\/othervm -XX:CompileCommand=inline,java\/lang\/String*.* DumpThreadsWithEliminatedLock json virtual\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.management.ManagementFactory;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+import com.sun.management.HotSpotDiagnosticMXBean;\n+import jdk.test.lib.threaddump.ThreadDump;\n+import jdk.test.lib.thread.VThreadRunner;\n+\n+public class DumpThreadsWithEliminatedLock {\n+\n+    public static void main(String[] args) throws Exception {\n+        boolean plain = switch (args[0]) {\n+            case \"plain\" -> true;\n+            case \"json\"  -> false;\n+            default      -> throw new RuntimeException(\"Unknown dump format\");\n+        };\n+\n+        ThreadFactory factory = switch (args[1]) {\n+            case \"platform\" -> Thread.ofPlatform().factory();\n+            case \"virtual\"  -> Thread.ofVirtual().factory();\n+            default         -> throw new RuntimeException(\"Unknown thread kind\");\n+        };\n+\n+        \/\/ need at least two carriers for JTREG_TEST_THREAD_FACTORY=Virtual\n+        if (Thread.currentThread().isVirtual()) {\n+            VThreadRunner.ensureParallelism(2);\n+        }\n+\n+        \/\/ A thread that spins creating and adding to a StringBuffer. StringBuffer is\n+        \/\/ synchronized, assume object will be scalar replaced and the lock eliminated.\n+        var done = new AtomicBoolean();\n+        var ref = new AtomicReference<String>();\n+        Thread thread = factory.newThread(() -> {\n+            while (!done.get()) {\n+                StringBuffer sb = new StringBuffer();\n+                sb.append(System.currentTimeMillis());\n+                String s = sb.toString();\n+                ref.set(s);\n+            }\n+        });\n+        try {\n+            thread.start();\n+            if (plain) {\n+                testPlainFormat();\n+            } else {\n+                testJsonFormat(thread.threadId());\n+            }\n+        } finally {\n+            done.set(true);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Invoke HotSpotDiagnosticMXBean.dumpThreads to generate a thread dump in plain text\n+     * format until \"lock is eliminated\" is found in the output.\n+     *\/\n+    private static void testPlainFormat() {\n+        try {\n+            Path file = genOutputPath(\".txt\");\n+            boolean found = false;\n+            int attempts = 0;\n+            while (!found) {\n+                attempts++;\n+                Files.deleteIfExists(file);\n+                ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class)\n+                        .dumpThreads(file.toString(), HotSpotDiagnosticMXBean.ThreadDumpFormat.TEXT_PLAIN);\n+                try (Stream<String> stream = Files.lines(file)) {\n+                    found = stream.map(String::trim)\n+                            .anyMatch(l -> l.contains(\"- lock is eliminated\"));\n+                }\n+                System.out.format(\"%s Attempt %d, found: %b%n\", Instant.now(), attempts, found);\n+            }\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        }\n+    }\n+\n+    \/**\n+     * Invoke HotSpotDiagnosticMXBean.dumpThreads to generate a thread dump in JSON format\n+     * until the monitorsOwned.locks array for the given thread has a null lock.\n+     *\/\n+    private static void testJsonFormat(long tid) {\n+        try {\n+            Path file = genOutputPath(\".json\");\n+            boolean found = false;\n+            int attempts = 0;\n+            while (!found) {\n+                attempts++;\n+                Files.deleteIfExists(file);\n+                ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class)\n+                        .dumpThreads(file.toString(), HotSpotDiagnosticMXBean.ThreadDumpFormat.JSON);\n+\n+                \/\/ parse thread dump as JSON and find thread\n+                String jsonText = Files.readString(file);\n+                ThreadDump threadDump = ThreadDump.parse(jsonText);\n+                ThreadDump.ThreadInfo ti = threadDump.rootThreadContainer()\n+                        .findThread(tid)\n+                        .orElse(null);\n+                if (ti == null) {\n+                    throw new RuntimeException(\"Thread \" + tid + \" not found in thread dump\");\n+                }\n+\n+                \/\/ look for null element in ownedMonitors\/locks array\n+                found = ti.ownedMonitors()\n+                        .values()\n+                        .stream()\n+                        .flatMap(List::stream)\n+                        .anyMatch(o -> o == null);\n+                System.out.format(\"%s Attempt %d, found: %b%n\", Instant.now(), attempts, found);\n+            }\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        }\n+    }\n+\n+    \/**\n+     * Generate a file path with the given suffix to use as an output file.\n+     *\/\n+    private static Path genOutputPath(String suffix) throws IOException {\n+        Path dir = Path.of(\".\").toAbsolutePath();\n+        Path file = Files.createTempFile(dir, \"dump\", suffix);\n+        Files.delete(file);\n+        return file;\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/management\/HotSpotDiagnosticMXBean\/DumpThreadsWithEliminatedLock.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Window;\n+\n+\/**\n+ * @test\n+ * @bug 8346952\n+ * @summary Verifies no exception occurs when triggering updateCG()\n+ * for an ownerless window.\n+ * @key headful\n+ *\/\n+public final class BogusFocusableWindowState {\n+\n+    public static void main(String[] args) {\n+        Window frame = new Window(null) {\n+            @Override\n+            public boolean getFocusableWindowState() {\n+                removeNotify();\n+                return true;\n+            }\n+        };\n+        try {\n+            frame.pack();\n+            frame.setVisible(true);\n+        } finally {\n+            frame.dispose();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/BogusFocusableWindowState\/BogusFocusableWindowState.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n- * @bug 8235638 8235739 8285094\n+ * @bug 8235638 8235739 8285094 8346952\n","filename":"test\/jdk\/java\/awt\/Frame\/GetGraphicsStressTest\/GetGraphicsStressTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.color.ColorSpace;\n+import java.awt.color.ICC_Profile;\n+\n+\/**\n+ * @test\n+ * @bug 8358623\n+ * @summary Verifies ICC profile version of built-in color spaces\n+ *\/\n+public final class CheckVersions {\n+\n+    public static void main(String[] args) {\n+        test(ColorSpace.CS_CIEXYZ, 2, 3, 0);\n+        test(ColorSpace.CS_GRAY, 2, 3, 0);\n+        test(ColorSpace.CS_LINEAR_RGB, 2, 3, 0);\n+        test(ColorSpace.CS_PYCC, 4, 0, 0);\n+        test(ColorSpace.CS_sRGB, 2, 3, 0);\n+    }\n+\n+    private static void test(int cs, int expMajor, int expMinor, int expPatch) {\n+        ICC_Profile profile = ICC_Profile.getInstance(cs);\n+\n+        int major = profile.getMajorVersion();\n+        int minorRaw = profile.getMinorVersion();\n+        int minor = (minorRaw >> 4) & 0x0F;\n+        int patch = minorRaw & 0x0F;\n+\n+        if (major != expMajor || minor != expMinor || patch != expPatch) {\n+            System.err.println(\"Expected major: \" + expMajor);\n+            System.err.println(\"Expected minor: \" + expMinor);\n+            System.err.println(\"Expected patch: \" + expPatch);\n+\n+            System.err.println(\"Actual major: \" + major);\n+            System.err.println(\"Actual minor: \" + minor);\n+            System.err.println(\"Actual patch: \" + patch);\n+            throw new RuntimeException(\"Test failed for ColorSpace: \" + cs);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/CheckVersions.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8354724\n+ * @summary Test Reader readAllLines and readAllAstring methods\n+ * @library .. \/test\/lib\n+ * @build jdk.test.lib.Platform jdk.test.lib.RandomFactory\n+ * @run junit ReadAll\n+ * @key randomness\n+ *\/\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+\n+import jdk.test.lib.RandomFactory;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class ReadAll {\n+    private static final String PHRASE =\n+        \"Ange plein de gaiet, connaissez-vous l'angoisse\";\n+\n+    private static File file;\n+    private static Path path;\n+    private static Random rnd;\n+\n+    @BeforeAll\n+    public static void setup() throws IOException {\n+        path = Files.createTempFile(Path.of(\".\"), \"foo\", \"bar\");\n+        file = path.toFile();\n+\n+        rnd = RandomFactory.getRandom();\n+        int size = rnd.nextInt(2, 16386);\n+\n+        int plen = PHRASE.length();\n+        StringBuilder sb = new StringBuilder(plen);\n+        List<String> strings = new ArrayList<>(size);\n+        while (strings.size() < size) {\n+            int fromIndex = rnd.nextInt(0, plen \/ 2);\n+            int toIndex = rnd.nextInt(fromIndex, plen);\n+            String s = PHRASE.substring(fromIndex, toIndex);\n+            sb.append(s);\n+            int bound = toIndex - fromIndex;\n+            if (bound > 0) {\n+                int offset = bound\/2;\n+                int n = rnd.nextInt(0, bound);\n+                for (int i = 0; i < n; i++) {\n+                    String f = null;\n+                    switch (rnd.nextInt(7)) {\n+                    case 0 -> f = \"\";\n+                    case 1 -> f = \"\\r\";\n+                    case 2 -> f = \"\\n\";\n+                    case 3 -> f = \"\\r\\n\";\n+                    case 4 -> f = \"\\r\\r\";\n+                    case 5 -> f = \"\\n\\n\";\n+                    case 6 -> f = \" \";\n+                    }\n+                    sb.insert(offset, f);\n+                }\n+            }\n+            strings.add(sb.toString());\n+            sb.setLength(0);\n+        }\n+\n+        String p4096  = PHRASE.repeat((4096 + plen - 1)\/plen);\n+        String p8192  = PHRASE.repeat((8192 + plen - 1)\/plen);\n+        String p16384 = PHRASE.repeat((16384 + plen - 1)\/plen);\n+\n+        for (int i = 0; i < 64; i++) {\n+            for (int j = 0; j < 32; j++) {\n+                switch (rnd.nextInt(8)) {\n+                case 0 -> sb.append(\"\");\n+                case 1 -> sb.append(\" \");\n+                case 2 -> sb.append(\"\\n\");\n+                case 3 -> sb.append(PHRASE);\n+                case 5 -> sb.append(p4096);\n+                case 6 -> sb.append(p8192);\n+                case 7 -> sb.append(p16384);\n+                }\n+            }\n+            strings.add(sb.toString());\n+            sb.setLength(0);\n+        }\n+\n+        Files.write(path, strings);\n+        System.out.println(strings.size() + \" lines written\");\n+    }\n+\n+    @AfterAll\n+    public static void cleanup() throws IOException {\n+        if (file != null)\n+            file.delete();\n+    }\n+\n+    @Test\n+    public void readAllLines() throws IOException {\n+        \/\/ Reader implementation\n+        System.out.println(\"Reader implementation\");\n+        List<String> lines;\n+        try (FileReader fr = new FileReader(file)) {\n+            lines = fr.readAllLines();\n+        }\n+        System.out.println(lines.size() + \" lines read\");\n+\n+        List<String> linesExpected = Files.readAllLines(path);\n+        int count = linesExpected.size();\n+        if (lines.size() != count)\n+            throw new RuntimeException(\"Size mismatch: \" + lines.size() + \" != \" + count);\n+        for (int i = 0; i < count; i++) {\n+            String expected = linesExpected.get(i);\n+            String actual = lines.get(i);\n+            if (!actual.equals(expected)) {\n+                String msg = String.format(\"%d: \\\"%s\\\" != \\\"%s\\\"\",\n+                                           i, actual, expected);\n+                throw new RuntimeException(msg);\n+            }\n+        }\n+\n+        \/\/ Reader.of implementation\n+        System.out.println(\"Reader.of implementation\");\n+        String stringExpected = Files.readString(path);\n+        int n = rnd.nextInt(stringExpected.length()\/2);\n+        String substringExpected = stringExpected.substring(n);\n+        linesExpected = substringExpected.lines().toList();\n+        try (Reader r = new StringReader(stringExpected)) {\n+            r.skip(n);\n+            lines = r.readAllLines();\n+        }\n+        count = linesExpected.size();\n+        if (lines.size() != count)\n+            throw new RuntimeException(\"Size mismatch: \" + lines.size() + \" != \" + count);\n+        for (int i = 0; i < count; i++) {\n+            String expected = linesExpected.get(i);\n+            String actual = lines.get(i);\n+            if (!actual.equals(expected)) {\n+                String msg = String.format(\"%d: \\\"%s\\\" != \\\"%s\\\"\",\n+                                           i, actual, expected);\n+                throw new RuntimeException(msg);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void readAllAsString() throws IOException {\n+        \/\/ Reader implementation\n+        String string;\n+        try (FileReader fr = new FileReader(file)) {\n+            string = fr.readAllAsString();\n+        }\n+        String stringExpected = Files.readString(path);\n+        assertEquals(stringExpected, string);\n+\n+        \/\/ Reader.of implementation\n+        int n = rnd.nextInt(stringExpected.length()\/2);\n+        try (Reader r = Reader.of(stringExpected)) {\n+            r.skip(n);\n+            string = r.readAllAsString();\n+        }\n+        assertEquals(stringExpected.substring(n), string);\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Reader\/ReadAll.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -39,1 +39,1 @@\n- * @bug 8343110\n+ * @bug 8343110 8361299\n@@ -74,0 +74,13 @@\n+    @Test\n+    public void testSrcBeginIsNegationOfPosition() {\n+        CB.position(1);\n+        Assert.assertThrows(IndexOutOfBoundsException.class,\n+                            () -> {\n+                                try {\n+                                    CB.getChars(-1, 3, new char[4], 0);\n+                                } finally {\n+                                    CB.position(0);\n+                                }\n+                            });\n+    }\n+\n@@ -203,1 +216,1 @@\n-        cb.getChars(cb.position(), cb.limit(), dst, 0);\n+        cb.getChars(0, cb.remaining(), dst, 0);\n","filename":"test\/jdk\/java\/nio\/Buffer\/GetChars.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025 IBM Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8359388\n+ * @summary test that the Cipher.getInstance() would reject improper\n+ *     transformations with empty mode and\/or padding.\n+ *\/\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.Security;\n+import javax.crypto.Cipher;\n+\n+public class TestEmptyModePadding {\n+\n+    public static void main(String[] args) throws Exception {\n+        Provider provider = Security.getProvider(\n+                System.getProperty(\"test.provider.name\", \"SunJCE\"));\n+\n+        System.out.println(\"Testing against \" + provider.getName());\n+\n+        String[] testTransformations = {\n+            \/\/ transformations w\/ only 1 component, i.e. algo\n+            \" \",\n+            \/\/ transformations w\/ only 2 components\n+            \"AES\/\",\n+            \"AES\/ \",\n+            \"AES\/CBC\",\n+            \"PBEWithHmacSHA512\/224AndAES_128\/\",\n+            \"PBEWithHmacSHA512\/256AndAES_128\/ \",\n+            \"PBEWithHmacSHA512\/224AndAES_128\/CBC\",\n+            \/\/ 3-component transformations w\/ empty component(s)\n+            \"AES\/\/\",\n+            \"AES\/ \/\",\n+            \"AES\/\/ \",\n+            \"AES\/ \/ \",\n+            \"AES\/CBC\/\", \"AES\/CBC\/ \",\n+            \"AES\/\/PKCS5Padding\", \"AES\/ \/NoPadding\",\n+            \"PBEWithHmacSHA512\/224AndAES_128\/\/\",\n+            \"PBEWithHmacSHA512\/224AndAES_128\/ \/\",\n+            \"PBEWithHmacSHA512\/224AndAES_128\/\/ \",\n+            \"PBEWithHmacSHA512\/224AndAES_128\/ \/ \",\n+            \"PBEWithHmacSHA512\/256AndAES_128\/CBC\/\",\n+            \"PBEWithHmacSHA512\/256AndAES_128\/CBC\/ \",\n+            \"PBEWithHmacSHA512\/256AndAES_128\/\/PKCS5Padding\",\n+            \"PBEWithHmacSHA512\/256AndAES_128\/ \/PKCS5Padding\",\n+        };\n+\n+        for (String t : testTransformations) {\n+            test(t, provider);\n+        }\n+    }\n+\n+    private static void test(String t, Provider p) throws Exception {\n+        try {\n+            Cipher c = Cipher.getInstance(t, p);\n+            throw new RuntimeException(\"Should throw NSAE for \\'\" + t + \"\\'\");\n+        } catch (NoSuchAlgorithmException nsae) {\n+            \/\/ transformation info is already in the NSAE message\n+            System.out.println(\"Expected NSAE: \" + nsae.getMessage());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/Cipher\/TestEmptyModePadding.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-                throw new Error(\"Failed 4276920: BasicComboPopup.hide() caused unnecessary repaint()\");\n+                throw new RuntimeException(\"Failed 4276920: BasicComboPopup.hide() caused unnecessary repaint()\");\n","filename":"test\/jdk\/javax\/swing\/JComboBox\/bug4276920.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test\n+ * @test id=metal\n@@ -28,2 +28,1 @@\n- * @summary\n- *     This test checks if menu items lay out correctly when their\n+ * @summary Verifies if menu items lay out correctly when their\n@@ -31,3 +30,0 @@\n- *     The tester is asked to compare left-to-right and\n- *     right-to-left menus and judge whether they are mirror images of each\n- *     other.\n@@ -36,1 +32,23 @@\n- * @run main\/manual RightLeftOrientation\n+ * @run main\/manual RightLeftOrientation metal\n+ *\/\n+\n+\/*\n+ * @test id=motif\n+ * @bug 4211052\n+ * @requires (os.family == \"windows\")\n+ * @summary Verifies if menu items lay out correctly when their\n+ *     ComponentOrientation property is set to RIGHT_TO_LEFT.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual RightLeftOrientation motif\n+ *\/\n+\n+\/*\n+ * @test id=windows\n+ * @bug 4211052\n+ * @requires (os.family == \"windows\")\n+ * @summary Verifies if menu items lay out correctly when their\n+ *     ComponentOrientation property is set to RIGHT_TO_LEFT.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual RightLeftOrientation windows\n@@ -55,1 +73,1 @@\n-import javax.swing.LookAndFeel;\n+import javax.swing.SwingUtilities;\n@@ -62,5 +80,1 @@\n-        A menu bar is shown containing a menu for each look and feel.\n-        A disabled menu means that the look and feel is not available for\n-        testing in this environment.\n-        Every effort should be made to run this test\n-        in an environment that covers all look and feels.\n+        A menu bar is shown with a menu.\n@@ -68,1 +82,1 @@\n-        Each menu is divided into two halves. The upper half is oriented\n+        The menu is divided into two halves. The upper half is oriented\n@@ -70,1 +84,1 @@\n-        For each menu, ensure that the lower half mirrors the upper half.\n+        Ensure that the lower half mirrors the upper half.\n@@ -76,0 +90,23 @@\n+        if (args.length < 1) {\n+            throw new IllegalArgumentException(\"Look-and-Feel keyword is required\");\n+        }\n+\n+        final String lafClassName;\n+        switch (args[0]) {\n+            case \"metal\" -> lafClassName = UIManager.getCrossPlatformLookAndFeelClassName();\n+            case \"motif\" -> lafClassName = \"com.sun.java.swing.plaf.motif.MotifLookAndFeel\";\n+            case \"windows\" -> lafClassName = \"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\";\n+            default -> throw new IllegalArgumentException(\n+                           \"Unsupported Look-and-Feel keyword for this test: \" + args[0]);\n+        }\n+\n+        SwingUtilities.invokeAndWait(() -> {\n+            try {\n+                UIManager.setLookAndFeel(lafClassName);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+\n+        System.out.println(\"Test for LookAndFeel \" + lafClassName);\n+\n@@ -77,1 +114,0 @@\n-                .title(\"RightLeftOrientation Instructions\")\n@@ -89,6 +125,1 @@\n-        menuBar.add(createMenu(\"javax.swing.plaf.metal.MetalLookAndFeel\",\n-                                \"Metal\"));\n-        menuBar.add(createMenu(\"com.sun.java.swing.plaf.motif.MotifLookAndFeel\",\n-                                \"Motif\"));\n-        menuBar.add(createMenu(\"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\",\n-                                \"Windows\"));\n+        menuBar.add(createMenu());\n@@ -97,1 +128,1 @@\n-        frame.pack();\n+        frame.setSize(250, 70);\n@@ -102,13 +133,5 @@\n-    static JMenu createMenu(String laf, String name) {\n-        JMenu menu = new JMenu(name);\n-        try {\n-            LookAndFeel save = UIManager.getLookAndFeel();\n-            UIManager.setLookAndFeel(laf);\n-            addMenuItems(menu, ComponentOrientation.LEFT_TO_RIGHT);\n-            menu.addSeparator();\n-            addMenuItems(menu, ComponentOrientation.RIGHT_TO_LEFT);\n-            UIManager.setLookAndFeel(save);\n-        } catch (Exception e) {\n-            menu = new JMenu(name);\n-            menu.setEnabled(false);\n-        }\n+    static JMenu createMenu() {\n+        JMenu menu = new JMenu(UIManager.getLookAndFeel().getID());\n+        addMenuItems(menu, ComponentOrientation.LEFT_TO_RIGHT);\n+        menu.addSeparator();\n+        addMenuItems(menu, ComponentOrientation.RIGHT_TO_LEFT);\n","filename":"test\/jdk\/javax\/swing\/JMenuItem\/RightLeftOrientation.java","additions":59,"deletions":36,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,2 @@\n+import static sun.java2d.pipe.Region.clipRound;\n+\n@@ -47,1 +49,1 @@\n- * @bug 8282958\n+ * @bug 8282958 8349188\n@@ -50,0 +52,1 @@\n+ * @modules java.desktop\/sun.java2d.pipe\n@@ -53,1 +56,1 @@\n-    private static final Dimension SIZE = new Dimension(120, 25);\n+    private static final Dimension SIZE = new Dimension(250, 50);\n@@ -62,0 +65,7 @@\n+    private static final int[] thickness = {1, 4, 10, 15};\n+\n+    private record TestImage(BufferedImage image,\n+                             List<Point> panelLocations,\n+                             double scale,\n+                             int thickness) {\n+    }\n@@ -63,2 +73,4 @@\n-    private static final List<BufferedImage> images =\n-            new ArrayList<>(scales.length);\n+    private record TestUI(JComponent content,\n+                          List<Point> panelLocations,\n+                          int thickness) {\n+    }\n@@ -66,2 +78,0 @@\n-    private static final List<Point> panelLocations =\n-            new ArrayList<>(4);\n@@ -77,3 +87,14 @@\n-        JComponent content = createUI();\n-        if (showFrame) {\n-            showFrame(content);\n+        for (int thickness : thickness) {\n+            TestUI testUI = createUI(thickness);\n+            if (showFrame) {\n+                showFrame(testUI.content);\n+            }\n+\n+            List<TestImage> images = paintToImages(testUI, saveImages);\n+            verifyBorderRendering(images, saveImages);\n+        }\n+\n+        if (errorCount > 0) {\n+            throw new Error(\"Test failed: \"\n+                    + errorCount + \" error(s) detected - \"\n+                    + errorMessage);\n@@ -82,2 +103,0 @@\n-        paintToImages(content, saveImages);\n-        verifyBorderRendering(saveImages);\n@@ -86,8 +105,2 @@\n-    private static void verifyBorderRendering(final boolean saveImages) {\n-        String errorMessage = null;\n-        int errorCount = 0;\n-        for (int i = 0; i < images.size(); i++) {\n-            BufferedImage img = images.get(i);\n-            double scaling = scales[i];\n-            try {\n-                int thickness = (int) Math.floor(scaling);\n+    private static String errorMessage = null;\n+    private static int errorCount = 0;\n@@ -95,1 +108,7 @@\n-                checkVerticalBorders(SIZE.width \/ 2, thickness, img);\n+    private static void verifyBorderRendering(final List<TestImage> images,\n+                                              final boolean saveImages) {\n+        for (TestImage test : images) {\n+            final BufferedImage img = test.image;\n+            final int effectiveThickness = clipRound(test.thickness * test.scale);\n+            try {\n+                checkVerticalBorders((int) (SIZE.width * test.scale \/ 2), effectiveThickness, img);\n@@ -97,3 +116,3 @@\n-                for (Point p : panelLocations) {\n-                    int y = (int) (p.y * scaling) + SIZE.height \/ 2;\n-                    checkHorizontalBorder(y, thickness, img);\n+                for (Point p : test.panelLocations) {\n+                    int y = (int) ((p.y + (SIZE.height \/ 2)) * test.scale);\n+                    checkHorizontalBorder(y, effectiveThickness, img);\n@@ -107,1 +126,2 @@\n-                System.err.printf(\"Scaling: %.2f\\n\", scaling);\n+                System.err.printf(\"Scale: %.2f; thickness: %d, effective: %d\\n\",\n+                        test.scale, test.thickness, effectiveThickness);\n@@ -110,4 +130,1 @@\n-                \/\/ Save the image if it wasn't already saved\n-                if (!saveImages) {\n-                    saveImage(img, getImageFileName(scaling));\n-                }\n+                saveImage(img, getImageFileName(test.scale, test.thickness));\n@@ -116,6 +133,0 @@\n-\n-        if (errorCount > 0) {\n-            throw new Error(\"Test failed: \"\n-                    + errorCount + \" error(s) detected - \"\n-                    + errorMessage);\n-        }\n@@ -223,1 +234,1 @@\n-    private static JComponent createUI() {\n+    private static TestUI createUI(int thickness) {\n@@ -227,0 +238,2 @@\n+        List<Point> panelLocations = new ArrayList<>(4);\n+\n@@ -233,1 +246,1 @@\n-            filler.setBorder(BorderFactory.createLineBorder(BORDER_COLOR));\n+            filler.setBorder(BorderFactory.createLineBorder(BORDER_COLOR, thickness));\n@@ -251,1 +264,1 @@\n-        return contentPanel;\n+        return new TestUI(contentPanel, panelLocations, thickness);\n@@ -263,3 +276,5 @@\n-    private static void paintToImages(final JComponent content,\n-                                      final boolean saveImages) {\n-        for (double scaling : scales) {\n+    private static List<TestImage> paintToImages(final TestUI testUI,\n+                                                 final boolean saveImages) {\n+        final List<TestImage> images = new ArrayList<>(scales.length);\n+        final JComponent content = testUI.content;\n+        for (double scale : scales) {\n@@ -267,2 +282,2 @@\n-                    new BufferedImage((int) Math.ceil(content.getWidth() * scaling),\n-                            (int) Math.ceil(content.getHeight() * scaling),\n+                    new BufferedImage((int) Math.ceil(content.getWidth() * scale),\n+                            (int) Math.ceil(content.getHeight() * scale),\n@@ -272,1 +287,1 @@\n-            g2d.scale(scaling, scaling);\n+            g2d.scale(scale, scale);\n@@ -277,1 +292,1 @@\n-                saveImage(image, getImageFileName(scaling));\n+                saveImage(image, getImageFileName(scale, testUI.thickness));\n@@ -279,1 +294,2 @@\n-            images.add(image);\n+            images.add(new TestImage(image, testUI.panelLocations,\n+                    scale, testUI.thickness));\n@@ -281,0 +297,1 @@\n+        return images;\n@@ -283,2 +300,3 @@\n-    private static String getImageFileName(final double scaling) {\n-        return String.format(\"test%.2f.png\", scaling);\n+    private static String getImageFileName(final double scaling,\n+                                           final int thickness) {\n+        return String.format(\"test%02d@%.2f.png\", thickness, scaling);\n","filename":"test\/jdk\/javax\/swing\/border\/LineBorder\/ScaledLineBorderTest.java","additions":66,"deletions":48,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,2 @@\n+import static sun.java2d.pipe.Region.clipRound;\n+\n@@ -49,1 +51,1 @@\n- * @bug 8282958\n+ * @bug 8282958 8349188\n@@ -53,0 +55,1 @@\n+ * @modules java.desktop\/sun.java2d.pipe\n@@ -95,1 +98,1 @@\n-                int thickness = (int) Math.floor(scaling);\n+                int thickness = clipRound(scaling);\n","filename":"test\/jdk\/javax\/swing\/border\/LineBorder\/ScaledTextFieldBorderTest.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8361615\n@@ -49,0 +50,1 @@\n+                assertThrows(IndexOutOfBoundsException.class, () -> xb.parameterSlot(-1));\n@@ -53,0 +55,2 @@\n+                assertThrows(IndexOutOfBoundsException.class, () -> xb.parameterSlot(3));\n+                assertThrows(IndexOutOfBoundsException.class, () -> xb.parameterSlot(Integer.MAX_VALUE));\n@@ -59,0 +63,3 @@\n+                              assertThrows(IndexOutOfBoundsException.class, () -> xb.parameterSlot(Integer.MIN_VALUE));\n+                              assertThrows(IndexOutOfBoundsException.class, () -> xb.parameterSlot(-1));\n+                              assertThrows(IllegalStateException.class, () -> xb.receiverSlot());\n@@ -62,0 +69,1 @@\n+                              assertThrows(IndexOutOfBoundsException.class, () -> xb.parameterSlot(3));\n","filename":"test\/jdk\/jdk\/classfile\/BuilderParamTest.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 8333812\n+ * @bug 8333812 8361526\n@@ -34,0 +34,2 @@\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.classfile.ClassFile.JAVA_8_VERSION;\n@@ -36,0 +38,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -45,0 +48,1 @@\n+import java.util.Map;\n@@ -416,0 +420,23 @@\n+\n+    @Test \/\/ JDK-8350029\n+    void testInvokeSpecialInterfacePatch() {\n+        var runClass = ClassDesc.of(\"Run\");\n+        var testClass = ClassDesc.of(\"Test\");\n+        var runnableClass = Runnable.class.describeConstable().orElseThrow();\n+        var chr = ClassHierarchyResolver.of(List.of(), Map.of(runClass, CD_Object))\n+                .orElse(ClassHierarchyResolver.defaultResolver()).cached();\n+        var context = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(chr));\n+\n+        for (var isInterface : new boolean[] {true, false}) {\n+            var bytes = context.build(testClass, clb -> clb\n+                    .withVersion(JAVA_8_VERSION, 0)\n+                    .withSuperclass(runClass)\n+                    .withMethodBody(\"test\", MethodTypeDesc.of(CD_void, testClass), ACC_STATIC, cob -> cob\n+                            .aload(0)\n+                            .invokespecial(runnableClass, \"run\", MTD_void, isInterface)\n+                            .return_()));\n+            var errors = context.verify(bytes);\n+            assertNotEquals(List.of(), errors, \"invokespecial, isInterface = \" + isInterface);\n+            assertTrue(errors.getFirst().getMessage().contains(\"interface method to invoke is not in a direct superinterface\"), errors.getFirst().getMessage());\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/VerifierSelfTest.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1,64 +1,0 @@\n-\/*\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4954921 8009259\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.ref\n- * @build jdk.test.lib.Utils\n- *        jdk.test.lib.Asserts\n- *        jdk.test.lib.JDKToolFinder\n- *        jdk.test.lib.JDKToolLauncher\n- *        jdk.test.lib.Platform\n- *        jdk.test.lib.process.*\n- * @run main ExitOnThrow\n- * @summary Ensure that if a cleaner throws an exception then the VM exits\n- *\/\n-\n-import jdk.internal.ref.Cleaner;\n-\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class ExitOnThrow {\n-\n-    public static void main(String[] args) throws Exception {\n-        if (args.length == 0) {\n-            ProcessTools.executeTestJava(\"--add-exports\", \"java.base\/jdk.internal.ref=ALL-UNNAMED\",\n-                                         \"ExitOnThrow\",\n-                                         \"-executeCleaner\")\n-                        .outputTo(System.out)\n-                        .errorTo(System.out)\n-                        .shouldHaveExitValue(1)\n-                        .shouldContain(\"java.lang.RuntimeException: Foo!\");\n-        } else {\n-            Cleaner.create(new Object(),\n-                           () -> { throw new RuntimeException(\"Foo!\"); } );\n-            while (true) {\n-                System.gc();\n-                Thread.sleep(100);\n-            }\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/jdk\/internal\/ref\/Cleaner\/ExitOnThrow.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -0,0 +1,313 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.api.metadata.annotations;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Recording;\n+import jdk.jfr.SettingControl;\n+import jdk.jfr.SettingDefinition;\n+import jdk.jfr.Threshold;\n+import jdk.jfr.Throttle;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.jfr.consumer.RecordingStream;\n+\n+\/**\n+ * @test\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.api.metadata.annotations.TestThrottle\n+ *\/\n+public class TestThrottle {\n+\n+    public static class UnthrottledEvent extends Event {\n+    }\n+\n+    @Throttle(\"off\")\n+    @Enabled(false)\n+    public static class ThrottledDisabledEvent extends Event {\n+    }\n+\n+    @Throttle(\"off\")\n+    public static class ThrottledOffEvent extends Event {\n+    }\n+\n+    @Throttle(\"0\/s\")\n+    public static class ThrottledZeroRateEvent extends Event {\n+    }\n+\n+    @Throttle(\"10000000\/s\")\n+    public static class ThrottledHighRateEvent extends Event {\n+    }\n+\n+    @Throttle(\"off\")\n+    @Threshold(\"5 h\")\n+    public static class ThrottledThresholdedEvent extends Event {\n+    }\n+\n+    @Throttle(\"50\/s\")\n+    public static class ThrottledNormalRateEvent extends Event {\n+        public int index;\n+    }\n+\n+    static class TestSetting extends SettingControl {\n+        private boolean value;\n+\n+        @Override\n+        public String combine(Set<String> values) {\n+            if (values.contains(\"true\")) {\n+                return \"true\";\n+            }\n+            if (values.contains(\"false\")) {\n+                return \"false\";\n+            }\n+            return \"true\";\n+        }\n+\n+        @Override\n+        public void setValue(String text) {\n+            value = Boolean.parseBoolean(text);\n+        }\n+\n+        @Override\n+        public String getValue() {\n+            return \"\" + value;\n+        }\n+    }\n+\n+    @Throttle(\"10000000\/s\")\n+    public static class ThrottledUserdefinedEvent extends Event {\n+        @SettingDefinition\n+        public boolean test(TestSetting control) {\n+            return control.value;\n+        }\n+    }\n+\n+    @Throttle(\"50\/s\")\n+    public static class ThrottledReuseEvent extends Event {\n+        public int index;\n+    }\n+\n+    private static Instant startTime;\n+\n+    public static void main(String[] args) throws Exception {\n+        startTime = determineMinimumTime();\n+        testUnthrottled(); \/\/ To ensure problem is specific to throttled events\n+        testThrottleDisabled();\n+        testThrottledOff();\n+        testThottleZeroRate();\n+        testThrottleHighRate();\n+        testThrottleThresholded();\n+        testThrottleNormalRate();\n+        testThrottleUserdefined();\n+    }\n+\n+    private static void testUnthrottled() throws Exception {\n+        testEvent(UnthrottledEvent.class, true);\n+    }\n+\n+    private static Instant determineMinimumTime() throws IOException {\n+        try (Recording r = new Recording()) {\n+            r.enable(\"jdk.JVMInformation\");\n+            r.start();\n+            Path p = Path.of(\"start.jfr\");\n+            r.dump(p);\n+            return RecordingFile.readAllEvents(p).get(0).getStartTime();\n+        }\n+    }\n+\n+    private static void testThrottleDisabled() throws Exception {\n+        testEvent(ThrottledDisabledEvent.class, false);\n+    }\n+\n+    private static void testThrottledOff() throws Exception {\n+        testEvent(ThrottledOffEvent.class, true);\n+    }\n+\n+    private static void testThottleZeroRate() throws Exception {\n+        testEvent(ThrottledZeroRateEvent.class, false);\n+    }\n+\n+    private static void testThrottleHighRate() throws Exception {\n+        testEvent(ThrottledHighRateEvent.class, true);\n+    }\n+\n+    private static void testThrottleThresholded() throws Exception {\n+        testEvent(ThrottledThresholdedEvent.class, false);\n+    }\n+\n+    private static void testThrottleNormalRate() throws Exception {\n+        try (RecordingStream rs = new RecordingStream()) {\n+            AtomicInteger lastIndex = new AtomicInteger();\n+            AtomicInteger throttled = new AtomicInteger();\n+            rs.onEvent(ThrottledNormalRateEvent.class.getName(), e -> {\n+                int index = e.getInt(\"index\");\n+                if (lastIndex.get() + 1 != index) {\n+                    throttled.incrementAndGet();\n+                }\n+                lastIndex.set(index);\n+            });\n+            rs.startAsync();\n+            int index = 1;\n+            while (throttled.get() < 30) {\n+                ThrottledNormalRateEvent e = new ThrottledNormalRateEvent();\n+                e.index = index;\n+                e.commit();\n+                index++;\n+                Thread.sleep(3);\n+            }\n+        }\n+    }\n+\n+    private static void testThrottleUserdefined() throws Exception {\n+        testThrottleUserdefined(\"false\", \"1000000\/s\", false);\n+        testThrottleUserdefined(\"true\", \"10000000\/s\", true);\n+        testThrottleUserdefined(\"true\", \"0\/s\", false);\n+        testThrottleUserdefined(\"true\", \"off\", true);\n+        testThrottleUserdefined(\"false\", \"off\", false);\n+    }\n+\n+    private static void testThrottleUserdefined(String test, String throttle, boolean emit) throws Exception {\n+        String eventName = ThrottledUserdefinedEvent.class.getName();\n+        try (Recording r = new Recording()) {\n+            r.enable(eventName).with(\"test\", test).with(\"throttle\", throttle);\n+            r.start();\n+\n+            ThrottledUserdefinedEvent e1 = new ThrottledUserdefinedEvent();\n+            e1.commit();\n+\n+            ThrottledUserdefinedEvent e2 = new ThrottledUserdefinedEvent();\n+            e2.begin();\n+            e2.commit();\n+\n+            ThrottledUserdefinedEvent e3 = new ThrottledUserdefinedEvent();\n+            e3.begin();\n+            e3.end();\n+            e3.commit();\n+\n+            ThrottledUserdefinedEvent e4 = new ThrottledUserdefinedEvent();\n+            if (e4.shouldCommit()) {\n+                e4.commit();\n+            }\n+            assertShouldCommit(e4, emit);\n+\n+            ThrottledUserdefinedEvent e5 = new ThrottledUserdefinedEvent();\n+            assertShouldCommit(e5, emit);\n+            if (e5.shouldCommit()) {\n+                e5.commit();\n+            }\n+            assertEvents(r, eventName, emit ? 5 : 0);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static void testEvent(Class<? extends Event> eventClass, boolean shouldCommit) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.start();\n+            Constructor<Event> c = (Constructor<Event>) eventClass.getConstructor();\n+            for (int i = 0; i < 17; i++) {\n+                Event e = c.newInstance();\n+                if (i % 5 == 0) {\n+                    assertShouldCommit(e, shouldCommit);\n+                }\n+                e.commit();\n+                if (i % 3 == 0) {\n+                    assertShouldCommit(e, shouldCommit);\n+                }\n+            }\n+            for (int i = 0; i < 50; i++) {\n+                Event e = c.newInstance();\n+                e.begin();\n+                if (i % 5 == 0) {\n+                    assertShouldCommit(e, shouldCommit);\n+                }\n+                e.end();\n+                if (i % 3 == 0) {\n+                    assertShouldCommit(e, shouldCommit);\n+                }\n+                e.commit();\n+                if (i % 7 == 0) {\n+                    assertShouldCommit(e, shouldCommit);\n+                }\n+            }\n+            for (int i = 0; i < 11; i++) {\n+                Event e = c.newInstance();\n+                e.begin();\n+                e.commit();\n+                if (i % 7 == 0) {\n+                    assertShouldCommit(e, shouldCommit);\n+                }\n+            }\n+            if (shouldCommit) {\n+                assertEvents(r, eventClass.getName(), 17 + 50 + 11);\n+            }\n+        }\n+    }\n+\n+    private static void assertEvents(Recording r, String name, int expected) throws Exception {\n+        int count = 0;\n+        r.stop();\n+        Duration d = Duration.between(r.getStartTime(), r.getStopTime());\n+        Path file = Path.of(\"dump.jfr\");\n+        r.dump(file);\n+        for (RecordedEvent event : RecordingFile.readAllEvents(file)) {\n+            if (event.getEventType().getName().equals(name)) {\n+                count++;\n+            }\n+            if (event.getDuration().isNegative()) {\n+                System.out.println(event);\n+                throw new Exception(\"Unexpected negative duration\");\n+            }\n+            if (event.getStartTime().isBefore(startTime)) {\n+                System.out.println(event);\n+                throw new Exception(\"Unexpected early start time\");\n+            }\n+            if (event.getDuration().toMillis() > 2 * d.toMillis()) {\n+                System.out.println(event);\n+                throw new Exception(\"Duration exceed twice the length of the recording\");\n+            }\n+        }\n+        if (count != expected) {\n+            throw new Exception(\"Expected \" + expected + \" \" + name + \" events, but found \" + count);\n+        }\n+        Files.delete(file);\n+    }\n+\n+    private static void assertShouldCommit(Event e, boolean expected) throws Exception {\n+        if (e.shouldCommit() != expected) {\n+            throw new Exception(\"Expected \" + e.getClass() + \"::shouldCommit() to return \" + expected);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/metadata\/annotations\/TestThrottle.java","additions":313,"deletions":0,"binary":false,"changes":313,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8346884\n+ * @summary Test for `@since` in jdk.editpad module\n+ * @library \/test\/lib \/test\/jdk\/tools\/sincechecker\n+ * @run main SinceChecker jdk.editpad\n+ *\/\n","filename":"test\/jdk\/tools\/sincechecker\/modules\/jdk.editpad\/JdkEditpadCheckSince.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8177100\n+ * @summary Test to check for duplicate methods across different inheritance patterns\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestDuplicateMethods\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestDuplicateMethods extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestDuplicateMethods();\n+        tester.runTests();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+    Path src = Path.of(\"src\");\n+\n+\n+    TestDuplicateMethods() throws IOException {\n+        \/\/ Diamond class inheritance\n+        tb.writeJavaFiles(src, \"\"\"\n+                package p;\n+                interface A {\n+                    \/**\n+                     * JavaDoc for method in interface A.\n+                     *\/\n+                    abstract void testA( );\n+                }\"\"\", \"\"\"\n+                package p;\n+                interface B extends A {\n+                    \/**\n+                     * JavaDoc for method in interface B.\n+                     *\/\n+                    abstract void testB( );\n+                }\"\"\", \"\"\"\n+                package p;\n+                abstract class C implements A {\n+                    \/**\n+                     * Inherited JavaDoc for method in class C.\n+                     *\/\n+                    public final void testA( ) {\n+                        \/\/ Do nothing.\n+                    }\n+                }\"\"\",\"\"\"\n+                package p;\n+                public final class D extends C implements B {\n+                    \/**\n+                     * Inherited JavaDoc.\n+                     *\/\n+                    public final void testB() {\n+                        \/\/ Do nothing.\n+                    }\n+                }\n+                \"\"\");\n+\n+        \/\/ Mirrors the implementation of StringBuilder\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                package sb;\n+                public interface I {\n+                    \/**\n+                     * JavaDoc for method in public interface I.\n+                     *\/\n+                    void testI();\n+                }\n+                \"\"\", \"\"\"\n+                package sb;\n+                abstract class P implements I {\n+                    \/**\n+                     * Inherited JavaDoc for method in class P.\n+                     *\/\n+                    public final void testI() {\n+                        \/\/ Do nothing.\n+                    }\n+                }\n+                \"\"\", \"\"\"\n+                package sb;\n+                public class U extends P implements I {\n+                    \/\/ No overrides\n+                }\n+                \"\"\"\n+        );\n+\n+        \/\/ Mirrors the implementation of HashMap\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                package hm;\n+                public interface J {\n+                    \/**\n+                     * JavaDoc for method in public interface J.\n+                     *\/\n+                    void testJ();\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package hm;\n+                public abstract class PubJ implements J {\n+                    \/**\n+                     * Inherited JavaDoc for method in public abstract class PubJ.\n+                     *\/\n+                    public final void testJ() {\n+                        \/\/ Do nothing.\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package hm;\n+                public class V extends PubJ implements J {\n+                    \/\/ No override\n+                }\n+                \"\"\"\n+        );\n+    }\n+\n+    @Test\n+    public void testDiamondInheritance(Path base) {\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"p\/D.html\", true,\n+                \"\"\"\n+                <div class=\"block\">Inherited JavaDoc for method in class C.<\/div>\n+                \"\"\", \"\"\"\n+                <div class=\"member-signature\"><span class=\"modifiers\">public final<\/span>&nbsp;<span class=\"return-type\">void<\/span>&nbsp;<span class=\"element-name\">testA<\/span>()<\/div>\n+                <div class=\"block\">Inherited JavaDoc for method in class C.<\/div>\n+                \"\"\"\n+        );\n+\n+        checkOutput(\"p\/D.html\", false, \"\"\"\n+                <div class=\"block\">JavaDoc for method in Interface A.<\/div>\"\"\", \"\"\"\n+                <div class=\"member-signature\"><span class=\"return-type\">void<\/span>&nbsp;<span class=\"element-name\">testA<\/span>()<\/div>\n+                <div class=\"block\">JavaDoc for method in Interface A.<\/div>\"\"\");\n+\n+\n+        checkOutput(\"p\/D.html\", false,\n+                \"\"\"\n+                <div class=\"block\">JavaDoc for method in interface A.<\/div>\n+                \"\"\");\n+    }\n+\n+    @Test\n+    public void testStringBuilderInheritance(Path base) {\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"sb\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"sb\/U.html\", false,\n+                \"\"\"\n+                <div class=\"inherited-list\">\n+                <h3 id=\"methods-inherited-from-class-sb.I\">Methods inherited from interface&nbsp;<a href=\"I.html#method-summary\" title=\"interface in sb\">I<\/a><\/h3>\n+                <code><a href=\"I.html#testI()\" title=\"testI()\">testI<\/a><\/code><\/div>\n+                \"\"\");\n+\n+        checkOutput(\"sb\/U.html\", true,\n+                \"\"\"\n+                <h3>testI<\/h3>\n+                <div class=\"horizontal-scroll\">\n+                <div class=\"member-signature\"><span class=\"modifiers\">public final<\/span>&nbsp;<span class=\"return-type\">void<\/span>&nbsp;<span class=\"element-name\">testI<\/span>()<\/div>\n+                <div class=\"block\">Inherited JavaDoc for method in class P.<\/div>\n+                <dl class=\"notes\">\n+                <dt>Specified by:<\/dt>\n+                <dd><code><a href=\"I.html#testI()\">testI<\/a><\/code>&nbsp;in interface&nbsp;<code><a href=\"I.html\" title=\"interface in sb\">I<\/a><\/code><\/dd>\n+                <\/dl>\"\"\");\n+    }\n+\n+    @Test\n+    public void testHashMapInheritance(Path base) {\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"hm\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"hm\/V.html\", false,\n+                \"\"\"\n+                <div class=\"inherited-list\">\n+                <h3 id=\"methods-inherited-from-class-hm.J\">Methods inherited from interface&nbsp;<a href=\"J.html#method-summary\" title=\"interface in hm\">J<\/a><\/h3>\n+                <code><a href=\"J.html#testJ()\" title=\"testJ()\">testJ<\/a><\/code><\/div>\"\"\");\n+\n+        checkOutput(\"hm\/V.html\", true,\n+                \"\"\"\n+                <div class=\"inherited-list\">\n+                <h3 id=\"methods-inherited-from-class-hm.PubJ\">Methods inherited from class&nbsp;<a href=\"PubJ.html#method-summary\" title=\"class in hm\">PubJ<\/a><\/h3>\n+                <code><a href=\"PubJ.html#testJ()\" title=\"testJ()\">testJ<\/a><\/code><\/div>\n+                \"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDuplicateMethodsWarn\/TestDuplicateMethods.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8356165 8358552\n+ * @summary Check user input works properly\n+ * @modules\n+ *     jdk.compiler\/com.sun.tools.javac.api\n+ *     jdk.compiler\/com.sun.tools.javac.main\n+ *     jdk.jshell\/jdk.internal.jshell.tool:open\n+ *     jdk.jshell\/jdk.internal.jshell.tool.resources:open\n+ *     jdk.jshell\/jdk.jshell:open\n+ * @library \/tools\/lib\n+ * @build toolbox.ToolBox toolbox.JarTask toolbox.JavacTask\n+ * @build Compiler UITesting\n+ * @compile InputUITest.java\n+ * @run testng\/othervm -Dstderr.encoding=UTF-8 -Dstdin.encoding=UTF-8 -Dstdout.encoding=UTF-8 InputUITest\n+ *\/\n+\n+import java.util.Map;\n+import java.util.function.Function;\n+import org.testng.annotations.Test;\n+\n+@Test\n+public class InputUITest extends UITesting {\n+\n+    static final String LINE_SEPARATOR = System.getProperty(\"line.separator\");\n+    static final String LINE_SEPARATOR_ESCAPED = LINE_SEPARATOR.replace(\"\\n\", \"\\\\n\")\n+                                                               .replace(\"\\r\", \"\\\\r\");\n+\n+    public InputUITest() {\n+        super(true);\n+    }\n+\n+    public void testUserInputWithSurrogates() throws Exception {\n+        Function<Integer, String> genSnippet =\n+                realCharsToRead -> \"new String(System.in.readNBytes(\" +\n+                                   (realCharsToRead + LINE_SEPARATOR.length()) +\n+                                   \"))\\n\";\n+        doRunTest((inputSink, out) -> {\n+            inputSink.write(genSnippet.apply(4) + \"\\uD83D\\uDE03\\n\");\n+            waitOutput(out, patternQuote(\"\\\"\\uD83D\\uDE03\" + LINE_SEPARATOR_ESCAPED + \"\\\"\"));\n+            inputSink.write(genSnippet.apply(1) + \"\\uD83D\\n\");\n+            waitOutput(out, patternQuote(\"\\\"?\" + LINE_SEPARATOR_ESCAPED + \"\\\"\"));\n+            inputSink.write(genSnippet.apply(1) + \"\\uDE03\\n\");\n+            waitOutput(out, patternQuote(\"\\\"?\" + LINE_SEPARATOR_ESCAPED + \"\\\"\"));\n+        }, false);\n+    }\n+\n+    public void testCloseInputSinkWhileReadingUserInputSimulatingCtrlD() throws Exception {\n+        var snippets = Map.of(\n+                \"System.in.read()\",                 \" ==> -1\",\n+                \"System.console().reader().read()\", \" ==> -1\",\n+                \"System.console().readLine()\",      \" ==> null\",\n+                \"System.console().readPassword()\",  \" ==> null\",\n+                \"IO.readln()\",                      \" ==> null\",\n+                \"System.in.readAllBytes()\",         \" ==> byte[0] {  }\"\n+            );\n+        for (var snippet : snippets.entrySet()) {\n+            doRunTest((inputSink, out) -> {\n+                inputSink.write(snippet.getKey() + \"\\n\");\n+                inputSink.close(); \/\/ Does not work: inputSink.write(\"\\u0004\"); \/\/ CTRL + D\n+                waitOutput(out, patternQuote(snippet.getValue()), patternQuote(\"EndOfFileException\"));\n+            }, false);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/jdk\/jshell\/InputUITest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,1 @@\n+import java.io.ByteArrayOutputStream;\n@@ -65,0 +66,4 @@\n+        doRunTest(test, true);\n+    }\n+\n+    protected void doRunTest(Test test, boolean setUserInput) throws Exception {\n@@ -90,1 +95,1 @@\n-                        .in(input, input)\n+                        .in(input, setUserInput ? input : null)\n@@ -104,0 +109,1 @@\n+            boolean closed = false;\n@@ -106,0 +112,1 @@\n+                if (closed) return; \/\/ prevents exception thrown due to closed writer\n@@ -109,0 +116,6 @@\n+\n+            @Override\n+            public void close() throws IOException {\n+                super.close();\n+                closed = true;\n+            }\n","filename":"test\/langtools\/jdk\/jshell\/UITesting.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\n+\/*\n+ * @test\n+ * @bug 8361481\n+ * @modules jdk.compiler\n+ * @summary Flexible Constructor Bodies generates a compilation error when compiling a user supplied java.lang.Object class\n+ *\/\n+\n+import java.io.*;\n+import java.util.*;\n+\n+public class T8361481 {\n+    static String testSrc = System.getProperty(\"test.src\", \".\");\n+\n+    public static void main(String... args) throws Exception {\n+        new T8361481().run();\n+    }\n+\n+    public void run() throws Exception {\n+        \/\/ compile modified Object.java, using patch-module to avoid errors\n+        File x = new File(testSrc, \"x\");\n+        String[] jcArgs = { \"-d\", \".\", \"--patch-module\", \"java.base=\" + x.getAbsolutePath(),\n+                new File(new File(new File(x, \"java\"), \"lang\"), \"Object.java\").getPath()};\n+        compile(jcArgs);\n+    }\n+\n+    void compile(String... args) {\n+        int rc = com.sun.tools.javac.Main.compile(args);\n+        if (rc != 0)\n+            throw new Error(\"javac failed: \" + Arrays.asList(args) + \": \" + rc);\n+    }\n+}\n+\n","filename":"test\/langtools\/tools\/javac\/ObjectEarlyContext\/T8361481.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+public class Object {\n+    public Object() {\n+        foo(); \/\/ valid, not in early constructor context\n+    }\n+\n+    void foo() { }\n+}\n","filename":"test\/langtools\/tools\/javac\/ObjectEarlyContext\/x\/java\/lang\/Object.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8361570\n+ * @summary Verify no flags in ExtendedStandardFlags have overlays for different\n+ *          Symbol kinds.\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.code\n+ * @compile ExtendedStandardFlagsOverlayFlagsConflict.java\n+ * @run main ExtendedStandardFlagsOverlayFlagsConflict\n+ *\/\n+\n+import com.sun.tools.javac.code.Flags;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/* Flags in ExtendedStandardFlags are checked using masks, and if they have\n+ * Symbol-kind specific meaning, they can lead to confusing errors. Hence,\n+ * Flags in ExtendedStandardFlags should have the same meaning for all Symbols.\n+ *\/\n+public class ExtendedStandardFlagsOverlayFlagsConflict {\n+\n+    public static void main(String... args) throws Exception {\n+        ExtendedStandardFlagsOverlayFlagsConflict t =\n+                new ExtendedStandardFlagsOverlayFlagsConflict();\n+        t.run();\n+    }\n+\n+    public void run() throws Exception {\n+        Map<Long, List<Field>> value2FlagFields = new HashMap<>();\n+\n+        for (Field f : Flags.class.getFields()) {\n+            if (!Modifier.isStatic(f.getModifiers())) {\n+                continue;\n+            }\n+            if (f.getName().startsWith(\"ACC_\")) {\n+                continue;\n+            }\n+            long flag = ((Number) f.get(null)).longValue();\n+            value2FlagFields.computeIfAbsent(flag, _ -> new ArrayList<>())\n+                            .add(f);\n+        }\n+\n+        long pendingFlags2Check = Flags.ExtendedStandardFlags;\n+\n+        while (pendingFlags2Check != 0) {\n+            long flag = Long.highestOneBit(pendingFlags2Check);\n+            List<Field> flagFields = value2FlagFields.get(flag);\n+            if (flagFields.size() != 1) {\n+                throw new AssertionError(\"Flag: \" + flag +\n+                                         \" has more than one flag field: \" + flagFields);\n+            }\n+            pendingFlags2Check &= ~flag;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/flags\/ExtendedStandardFlagsOverlayFlagsConflict.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,21 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8361570\n+ * @summary Verify there's no fake sealed not allowed here error when sealed\n+ *          and requires-identity Flags clash\n+ * @modules java.base\/jdk.internal\n+ * @compile NoFalseSealedError.java\n+ *\/\n+\n+import java.lang.ref.WeakReference;\n+import java.util.WeakHashMap;\n+\n+void main(String[] args) {\n+    new RequiresIdentity(null) {};\n+    new WeakReference<>(null) {};\n+    new WeakHashMap<>() {};\n+}\n+\n+static class RequiresIdentity {\n+    RequiresIdentity(@jdk.internal.RequiresIdentity Object o) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/flags\/NoFalseSealedError.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8361214\n+ * @summary An anonymous class is erroneously being classify as an abstract class\n+ * @compile AnonymousLabeledAsAbstractTest.java\n+ *\/\n+\n+class AnonymousLabeledAsAbstractTest {\n+    abstract class Base<T> {}\n+    abstract class Derived1<T> extends Base<T> {}\n+    abstract class Derived2<T> extends Base<T> {\n+        Derived2(Derived1<T> obj){}\n+    }\n+    abstract class Derived3<T> extends Base<T> {\n+        Derived3(Derived2<T> obj){}\n+    }\n+\n+    Base<String> obj = new Derived2<>(new Derived1<>(){}){};\n+    Base<String> obj2 = new Derived3<String>(new Derived2<>(new Derived1<>(){}){}){};\n+    Base<String> obj3 = new Derived3<>(new Derived2<>(new Derived1<>(){}){}){};\n+}\n","filename":"test\/langtools\/tools\/javac\/generics\/diamond\/AnonymousLabeledAsAbstractTest.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @clean ClassRefDupInConstantPoolTest$Duplicates\n+ * @clean ClassRefDupInConstantPoolTest ClassRefDupInConstantPoolTest$Duplicates\n","filename":"test\/langtools\/tools\/javac\/jvm\/ClassRefDupInConstantPoolTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.instruction.LoadInstruction;\n+import java.lang.classfile.instruction.StoreInstruction;\n+import java.util.BitSet;\n+import java.util.Map;\n+\n+import jdk.test.lib.compiler.InMemoryJavaCompiler;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/*\n+ * @test\n+ * @bug 8357185\n+ * @enablePreview\n+ * @summary No unused local variable in unconditionally exact primitive patterns\n+ * @library \/test\/lib\n+ * @run junit PrimitiveInstanceOfBytecodeTest\n+ *\/\n+public class PrimitiveInstanceOfBytecodeTest {\n+\n+    private static final String SOURCE = \"\"\"\n+            public class Test {\n+                public record A(int i) {}\n+                public Integer get(A a) {\n+                    if (a instanceof A(int i)) {\n+                        return i;\n+                    }\n+                    return null;\n+                }\n+            }\n+            \"\"\";\n+\n+    @Test\n+    public void testNoUnusedVarInRecordPattern() {\n+        var testBytes = InMemoryJavaCompiler.compile(Map.of(\"Test\", SOURCE)).get(\"Test\");\n+        var code = ClassFile.of().parse(testBytes).methods().stream()\n+                .filter(m -> m.methodName().equalsString(\"get\")).findFirst()\n+                .orElseThrow().findAttribute(Attributes.code()).orElseThrow();\n+        BitSet stores = new BitSet(code.maxLocals());\n+        BitSet loads = new BitSet(code.maxLocals());\n+        code.forEach(ce -> {\n+            switch (ce) {\n+                case StoreInstruction store -> stores.set(store.slot());\n+                case LoadInstruction load -> loads.set(load.slot());\n+                default -> {}\n+            }\n+        });\n+        \/\/ [this, a] are built-in locals that may be unused\n+        loads.clear(0, 2);\n+        stores.clear(0, 2);\n+        if (!loads.equals(stores)) {\n+            System.err.println(\"Loads: \" + loads);\n+            System.err.println(\"Stores: \" + stores);\n+            System.err.println(code.toDebugString());\n+            fail(\"Store and load mismatch, see stderr\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfBytecodeTest.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8304487 8325257 8327683 8330387\n+ * @bug 8304487 8325257 8327683 8330387 8357185\n@@ -55,0 +55,1 @@\n+        assertEquals(true,  exprMethodSideEffect());\n@@ -176,0 +177,7 @@\n+    static int sideEffect;\n+    public static Integer methSideEffect() { sideEffect++; return 42;}\n+    public static boolean exprMethodSideEffect() {\n+        sideEffect = 5;\n+        return methSideEffect() instanceof int ii && sideEffect == 6;\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfPatternOpWithTopLevelPatterns.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8304487 8325257 8327683 8330387\n+ * @bug 8304487 8325257 8327683 8330387 8357185\n@@ -55,0 +55,1 @@\n+        assertEquals(true,  exprMethodSideEffect());\n@@ -176,0 +177,7 @@\n+    static int sideEffect;\n+    public static Integer methSideEffect() { sideEffect++; return 42;}\n+    public static boolean exprMethodSideEffect() {\n+        sideEffect = 5;\n+        return methSideEffect() instanceof int && sideEffect == 6;\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfTypeComparisonOp.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8356894\n+ * @summary Verify source level checks are performed properly\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main RequiresIdentityTest\n+*\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class RequiresIdentityTest extends TestRunner {\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new RequiresIdentityTest().runTests();\n+    }\n+\n+    RequiresIdentityTest() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testReleaseWorksAsCurrentVersion(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path classes = base.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          import java.util.WeakHashMap;\n+                          import java.util.Optional;\n+\n+                          public class Test {\n+                              void test() {\n+                                  WeakHashMap<Optional<Integer>, Object> m = null;\n+                                  m.put(Optional.empty(), 1);\n+                              }\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        var expectedErrors = List.of(\n+            \"Test.java:6:20: compiler.warn.attempt.to.use.value.based.where.identity.expected\",\n+            \"Test.java:7:29: compiler.warn.attempt.to.use.value.based.where.identity.expected\",\n+            \"2 warnings\"\n+        );\n+\n+        {\n+            var actualErrors =\n+                    new JavacTask(tb)\n+                        .options(\"-XDrawDiagnostics\")\n+                        .outdir(classes)\n+                        .files(tb.findJavaFiles(src))\n+                        .run()\n+                        .writeAll()\n+                        .getOutputLines(Task.OutputKind.DIRECT);\n+            if (!expectedErrors.equals(actualErrors)) {\n+                throw new AssertionError(\"Incorrect errors, expected: \" + List.of(expectedErrors) +\n+                                          \", actual: \" + actualErrors);\n+            }\n+        }\n+\n+        {\n+            var actualErrors =\n+                    new JavacTask(tb)\n+                        .options(\"--release\", System.getProperty(\"java.specification.version\"),\n+                                 \"-XDrawDiagnostics\")\n+                        .outdir(classes)\n+                        .files(tb.findJavaFiles(src))\n+                        .run()\n+                        .writeAll()\n+                        .getOutputLines(Task.OutputKind.DIRECT);\n+            if (!expectedErrors.equals(actualErrors)) {\n+                throw new AssertionError(\"Incorrect errors, expected: \" + List.of(expectedErrors) +\n+                                          \", actual: \" + actualErrors);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testModel(Path base) throws Exception {\n+        {\n+            List<String> printed =\n+                new JavacTask(tb)\n+                    .options(\"-Xprint\")\n+                    .classes(\"java.util.WeakHashMap\")\n+                    .run()\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            printed.removeIf(l -> !l.contains(\"put(\") && !l.contains(\"class WeakHashMap<\"));\n+\n+            List<String> expected = List.of(\n+                \"public class WeakHashMap<@jdk.internal.RequiresIdentity K, V> extends java.util.AbstractMap<K,V> implements java.util.Map<K,V> {\",\n+                \"  public V put(@jdk.internal.RequiresIdentity K key,\"\n+            );\n+            if (!expected.equals(printed)) {\n+                throw new AssertionError(\"Expected: \" + expected +\n+                                         \", but got: \" + printed);\n+            }\n+        }\n+\n+        {\n+            List<String> printed =\n+                new JavacTask(tb)\n+                    .options(\"--release\", System.getProperty(\"java.specification.version\"),\n+                             \"-Xprint\")\n+                    .classes(\"java.util.WeakHashMap\")\n+                    .run()\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            printed.removeIf(l -> !l.contains(\"put(\") && !l.contains(\"class WeakHashMap<\"));\n+\n+            List<String> expected = List.of(\n+                \"public class WeakHashMap<K, V> extends java.util.AbstractMap<K,V> implements java.util.Map<K,V> {\",\n+                \"  public V put(K arg0,\"\n+            );\n+            if (!expected.equals(printed)) {\n+                throw new AssertionError(\"Expected: \" + expected +\n+                                         \", but got: \" + printed);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/platform\/RequiresIdentityTest.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8270139\n+ * @bug 8270139 8361445\n@@ -36,0 +36,1 @@\n+import java.util.HashSet;\n@@ -38,0 +39,1 @@\n+import java.util.Set;\n@@ -113,0 +115,112 @@\n+    @Test \/\/JDK-8361445\n+    public void testSuppressWarningsErroneousAttribute1() throws Exception {\n+        String code = \"\"\"\n+                      @SuppressWarnings(CONST)\n+                      public class Test {\n+                          public static final String CONST = \"\";\n+                      }\n+                      \"\"\";\n+        Path curPath = Path.of(\".\");\n+        List<String> actual = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\", \"-XDdev\")\n+                .sources(code)\n+                .outdir(curPath)\n+                .run(Expect.FAIL)\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+        List<String> expected = List.of(\n+                \"Test.java:1:19: compiler.err.cant.resolve: kindname.variable, CONST, , \",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(actual, expected)) {\n+            error(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n+    @Test \/\/JDK-8361445\n+    public void testSuppressWarningsErroneousAttribute2() throws Exception {\n+        String code = \"\"\"\n+                      @SuppressWarnings(0)\n+                      public class Test {\n+                      }\n+                      \"\"\";\n+        Path curPath = Path.of(\".\");\n+        List<String> actual = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\", \"-XDdev\")\n+                .sources(code)\n+                .outdir(curPath)\n+                .run(Expect.FAIL)\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+        List<String> expected = List.of(\n+                \"Test.java:1:19: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.String)\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(actual, expected)) {\n+            error(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n+    @Test \/\/JDK-8361445\n+    public void testSuppressWarningsErroneousAttribute3() throws Exception {\n+        String[] attributeValues = {\n+            \"Test.BOOLEAN\",\n+            \"Test.BYTE\",\n+            \"Test.SHORT\",\n+            \"Test.INT\",\n+            \"Test.LONG\",\n+            \"Test.FLOAT\",\n+            \"Test.DOUBLE\",\n+            \"Test.CHAR\",\n+            \"Test.class\",\n+            \"@Deprecated\",\n+            \"E.A\",\n+        };\n+        Set<String> variants = new HashSet<>();\n+\n+        for (String attributeValue : attributeValues) {\n+            variants.add(attributeValue);\n+            variants.add(\"{\" + attributeValue + \"}\");\n+        }\n+\n+        for (String attributeValue1 : attributeValues) {\n+            for (String attributeValue2 : attributeValues) {\n+                variants.add(\"{\" + attributeValue1 + \", \" + attributeValue2 + \"}\");\n+            }\n+        }\n+\n+        String code = \"\"\"\n+                      @SuppressWarnings($ATTRIBUTE_VALUE)\n+                      public class Test {\n+                          public static final boolean BOOLEAN = false;\n+                          public static final byte BYTE = 0;\n+                          public static final short SHORT = 0;\n+                          public static final int INT = 0;\n+                          public static final long LONG = 0l;\n+                          public static final float FLOAT = 0.0;\n+                          public static final double DOUBLE = 0.0;\n+                          public static final char CHAR = '\\0';\n+                      }\n+                      enum E {\n+                          A\n+                      }\n+                      \"\"\";\n+\n+        for (String variant : variants) {\n+            System.out.println(\"current variant: \" + variant);\n+            Path curPath = Path.of(\".\");\n+            List<String> actual = new JavacTask(tb)\n+                    .options(\"-XDrawDiagnostics\", \"-XDdev\")\n+                    .sources(code.replace(\"$ATTRIBUTE_VALUE\", variant))\n+                    .outdir(curPath)\n+                    .run(Expect.FAIL)\n+                    .getOutputLines(OutputKind.DIRECT);\n+\n+            if (actual.isEmpty() || !actual.get(actual.size() - 1).contains(\"error\")) {\n+                error(\"Incorrect actual errors: \" + actual + \" for variant: \" + variant);\n+            }\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/recovery\/AnnotationRecovery.java","additions":116,"deletions":2,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.jittester;\n+\n+import java.lang.reflect.Executable;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @summary Unit tests for JITTester string method templates\n+ *\n+ * @library \/test\/lib\n+ *          \/test\/hotspot\/jtreg\/testlibrary\/jittester\/src\n+ *\n+ * @run testng jdk.test.lib.jittester.MethodTemplateTest\n+ *\/\n+public class MethodTemplateTest {\n+\n+    @Test\n+    public void testMatchingPatterns() throws NoSuchMethodException {\n+        Tester.forMethod(System.class, \"getenv\", String.class)\n+            .assertMatches(\"java\/lang\/System::getenv(Ljava\/lang\/String;)\")\n+            .assertMatches(\"*::getenv(Ljava\/lang\/String;)\")\n+            .assertMatches(\"java\/lang\/*::getenv(Ljava\/lang\/String;)\")\n+            .assertMatches(\"java\/lang\/System::*env*(Ljava\/lang\/String;)\")\n+            .assertMatches(\"java\/lang\/System::getenv\")\n+            .assertMatches(\"java\/lang\/System::getenv(*)\");\n+\n+        Tester.forCtor(RuntimeException.class, Throwable.class)\n+            .assertMatches(\"java\/lang\/RuntimeException::RuntimeException(Ljava\/lang\/Throwable;)\");\n+\n+        Tester.forMethod(String.class, \"regionMatches\", int.class, String.class, int.class, int.class)\n+            .assertMatches(\"java\/lang\/String::regionMatches(ILjava\/lang\/String;II)\");\n+    }\n+\n+    @Test\n+    public void testNonMatchingPatterns() throws NoSuchMethodException {\n+        Tester.forMethod(String.class, \"regionMatches\", int.class, String.class, int.class, int.class)\n+            .assertDoesNotMatch(\"java\/lang\/String::regionMatches(IIILjava\/lang\/String;)\");\n+\n+        Tester.forMethod(String.class, \"endsWith\", String.class)\n+              .assertDoesNotMatch(\"java\/lang\/String::startsWith(Ljava\/lang\/String;)\");\n+    }\n+\n+    @Test\n+    public void testWildcardStrings() {\n+        assertTrue(new MethodTemplate.WildcardString(\"Torment\")\n+                .matches(\"Torment\"));\n+\n+        assertTrue(new MethodTemplate.WildcardString(\"Torm*\")\n+                .matches(\"Torment\"));\n+\n+        assertTrue(new MethodTemplate.WildcardString(\"*ent\")\n+                .matches(\"Torment\"));\n+\n+        assertTrue(new MethodTemplate.WildcardString(\"*\")\n+                .matches(\"Something\"));\n+\n+        assertTrue(new MethodTemplate.WildcardString(\"**\")\n+                .matches(\"Something\"));\n+\n+        assertTrue(new MethodTemplate.WildcardString(\"*Middle*\")\n+                .matches(\"OnlyMiddleMatches\"));\n+\n+        assertFalse(new MethodTemplate.WildcardString(\"Wrong\")\n+                .matches(\"Correct\"));\n+        assertFalse(new MethodTemplate.WildcardString(\"Joy\")\n+                .matches(\"Joyfull\"));\n+        assertFalse(new MethodTemplate.WildcardString(\"*Torm*\")\n+                .matches(\"Sorrow\"));\n+    }\n+\n+    static final class Tester {\n+        private final Executable executable;\n+\n+        private Tester(Executable executable) {\n+            this.executable = executable;\n+        }\n+\n+        public Tester assertMatches(String stringTemplate) {\n+            MethodTemplate template = MethodTemplate.parse(stringTemplate);\n+            assertTrue(template.matches(executable),\n+                    \"Method '\" + executable + \"' does not match template '\" + stringTemplate + \"'\");\n+            return this;\n+        }\n+\n+        public Tester assertDoesNotMatch(String stringTemplate) {\n+            MethodTemplate template = MethodTemplate.parse(stringTemplate);\n+            assertFalse(template.matches(executable),\n+                    \"Method '\" + executable + \"' erroneously matches template '\" + stringTemplate + \"'\");\n+            return this;\n+        }\n+\n+        public static Tester forMethod(Class klass, String name, Class<?>... arguments)\n+                throws  NoSuchMethodException {\n+            return new Tester(klass.getDeclaredMethod(name, arguments));\n+        }\n+\n+        public static Tester forCtor(Class klass, Class<?>... arguments)\n+                throws  NoSuchMethodException {\n+                return new Tester(klass.getConstructor(arguments));\n+        }\n+    }\n+\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/jittester\/MethodTemplateTest.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -125,2 +125,2 @@\n-                    \"JVM process should have exit value '%d'.%n%s\",\n-                    exitCode.value, exitErrorMessage);\n+                    \"JVM process should have exit value '%d', but has '%d'.%n%s\",\n+                    exitCode.value, outputAnalyzer.getExitValue(), exitErrorMessage);\n@@ -305,0 +305,3 @@\n+            String observedValue = outputAnalyzer.firstMatch(String.format(\n+                CommandLineOptionTest.PRINT_FLAGS_FINAL_FORMAT,\n+                optionName, \"\\\\S\"));\n@@ -306,2 +309,2 @@\n-                    \"Option '%s' is expected to have '%s' value%n%s\",\n-                    optionName, expectedValue,\n+                    \"Option '%s' is expected to have '%s' value, but is '%s'.%n%s\",\n+                    optionName, expectedValue, observedValue,\n","filename":"test\/lib\/jdk\/test\/lib\/cli\/CommandLineOptionTest.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.io;\n+\n+import java.io.CharArrayReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.List;\n+import java.util.Random;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+\n+@State(Scope.Benchmark)\n+public class ReaderReadAllLines {\n+\n+    private char[] chars = null;\n+\n+    @Setup\n+    public void setup() throws IOException {\n+        final int len = 128_000;\n+        chars = new char[len];\n+        Random rnd = new Random(System.nanoTime());\n+        int off = 0;\n+        while (off < len) {\n+            int lineLen = 40 + rnd.nextInt(8192);\n+            if (lineLen > len - off) {\n+                off = len;\n+            } else {\n+                chars[off + lineLen] = '\\n';\n+                off += lineLen;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public List<String> readAllLines() throws IOException {\n+        List<String> lines;\n+        try (Reader reader = new CharArrayReader(chars)) {\n+            lines = reader.readAllLines();\n+        }\n+        return lines;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/io\/ReaderReadAllLines.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -83,0 +83,10 @@\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int thousandUnboundQueries(Blackhole bh) throws Exception {\n+        var result = 0;\n+        for (int i = 0; i < 1_000; i++) {\n+            result += ScopedValuesData.unbound.isBound() ? 1 : 0;\n+        }\n+        return result;\n+    }\n+\n@@ -216,0 +226,7 @@\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public Object newInstance() {\n+        ScopedValue<Integer> val = ScopedValue.newInstance();\n+        return val;\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ScopedValues.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-            tl1.get();  \/\/ Create the ScopedValue cache as a side effect\n@@ -64,1 +63,4 @@\n-                  .run(action);\n+                  .run(() -> {\n+                      sl1.get();  \/\/ Create the ScopedValue cache as a side effect\n+                      action.run();\n+                  });\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ScopedValuesData.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.nio;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3, jvmArgs = {\"-Xmx256m\", \"-Xms256m\", \"-XX:+AlwaysPreTouch\"})\n+public class DirectByteBufferChurn {\n+\n+    @Param({\"128\", \"256\", \"512\", \"1024\", \"2048\"})\n+    int recipFreq;\n+\n+    @Benchmark\n+    public Object test() {\n+        boolean direct = ThreadLocalRandom.current().nextInt(recipFreq) == 0;\n+        return direct ? ByteBuffer.allocateDirect(1) : ByteBuffer.allocate(1);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/DirectByteBufferChurn.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.nio;\n+\n+import java.nio.ByteBuffer;\n+import java.util.LinkedList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3, jvmArgs = {\"-Xmx1g\", \"-Xms1g\", \"-XX:+AlwaysPreTouch\"})\n+public class DirectByteBufferGC {\n+\n+    @Param({\"16384\", \"65536\", \"262144\", \"1048576\", \"4194304\"})\n+    int count;\n+\n+    \/\/ Make sure all buffers are reachable and available for GC. Buffers\n+    \/\/ directly reference their Cleanables, so we do not want to provide\n+    \/\/ excess GC parallelism opportunities here, this is why reference\n+    \/\/ buffers from a linked list.\n+    \/\/\n+    \/\/ This exposes the potential GC parallelism problem in Cleaner lists.\n+    LinkedList<ByteBuffer> buffers;\n+\n+    @Setup\n+    public void setup() {\n+        buffers = new LinkedList<>();\n+        for (int c = 0; c < count; c++) {\n+            buffers.add(ByteBuffer.allocateDirect(1));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void test() {\n+        System.gc();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/DirectByteBufferGC.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -39,0 +41,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -52,0 +56,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/AllDead.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -39,0 +41,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -52,0 +56,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/AllLive.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -38,0 +40,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -52,0 +56,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/DifferentObjectSizesArray.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -39,0 +41,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -53,0 +57,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/DifferentObjectSizesHashMap.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -39,0 +41,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -52,0 +56,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/DifferentObjectSizesTreeMap.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -39,0 +41,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -53,0 +57,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/HalfDeadFirstPart.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -39,0 +41,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -53,0 +57,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/HalfDeadInterleaved.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -39,0 +41,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -53,0 +57,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/HalfDeadInterleavedChunks.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -39,0 +41,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -53,0 +57,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/HalfDeadSecondPart.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -39,0 +41,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -53,0 +57,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/HalfHashedHalfDead.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import org.openjdk.jmh.annotations.Level;\n@@ -29,0 +30,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -30,0 +32,4 @@\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -34,0 +40,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -36,0 +44,1 @@\n+@State(Scope.Benchmark)\n@@ -46,0 +55,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/NoObjects.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -38,0 +40,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -52,0 +56,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/OneBigObject.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}