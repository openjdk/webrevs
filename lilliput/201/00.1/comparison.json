{"files":[{"patch":"@@ -54,0 +54,4 @@\n+      dry-run:\n+        required: false\n+        type: boolean\n+        default: false\n@@ -107,0 +111,1 @@\n+        if: ${{ inputs.dry-run == false }}\n@@ -113,0 +118,1 @@\n+        if: ${{ inputs.dry-run == false }}\n","filename":".github\/workflows\/build-alpine-linux.yml","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,0 +43,4 @@\n+      dry-run:\n+        required: false\n+        type: boolean\n+        default: false\n@@ -192,1 +196,1 @@\n-        if: steps.create-sysroot.outcome == 'success' || steps.get-cached-sysroot.outputs.cache-hit == 'true'\n+        if: ((steps.create-sysroot.outcome == 'success' || steps.get-cached-sysroot.outputs.cache-hit == 'true') && inputs.dry-run == false)\n","filename":".github\/workflows\/build-cross-compile.yml","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,0 +64,4 @@\n+      dry-run:\n+        required: false\n+        type: boolean\n+        default: false\n@@ -142,0 +146,1 @@\n+        if: ${{ inputs.dry-run == false }}\n@@ -150,0 +155,1 @@\n+        if: ${{ inputs.dry-run == false }}\n","filename":".github\/workflows\/build-linux.yml","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,0 +57,4 @@\n+      dry-run:\n+        required: false\n+        type: boolean\n+        default: false\n@@ -121,0 +125,1 @@\n+        if: ${{ inputs.dry-run == false }}\n@@ -127,0 +132,1 @@\n+        if: ${{ inputs.dry-run == false }}\n","filename":".github\/workflows\/build-macos.yml","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,0 +57,4 @@\n+      dry-run:\n+        required: false\n+        type: boolean\n+        default: false\n@@ -142,0 +146,1 @@\n+        if: ${{ inputs.dry-run == false }}\n@@ -150,0 +155,1 @@\n+        if: ${{ inputs.dry-run == false }}\n@@ -156,0 +162,1 @@\n+        if: ${{ inputs.dry-run == false }}\n","filename":".github\/workflows\/build-windows.yml","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-      - master\n-      - jdk*\n@@ -46,0 +44,3 @@\n+      dry-run:\n+        description: 'Dry run: skip actual builds and tests'\n+        required: false\n@@ -73,0 +74,1 @@\n+      dry-run: ${{ steps.include.outputs.dry-run }}\n@@ -146,0 +148,29 @@\n+          function check_dry_run() {\n+            if [[ $GITHUB_EVENT_NAME == workflow_dispatch ]]; then\n+              # Take the user-specified one.\n+              echo '${{ github.event.inputs.dry-run }}'\n+              return\n+            elif [[ $GITHUB_EVENT_NAME == push ]]; then\n+              # Cut out the real branch name\n+              BRANCH=${GITHUB_REF##*\/}\n+\n+              # Dry run rebuilds the caches in current branch, so they can be reused\n+              # for any child PR branches. Because of this, we want to trigger this\n+              # workflow in master branch, so that actual PR branches can use the cache.\n+              # This workflow would trigger every time contributors sync their master\n+              # branches in their personal forks.\n+              if [[ $BRANCH == \"master\" ]]; then\n+                echo 'true'\n+                return\n+              fi\n+\n+              # ...same for stabilization branches\n+              if [[ $BRANCH =~ \"jdk(.*)\" ]]; then\n+                echo 'true'\n+                return\n+              fi\n+            fi\n+\n+            echo 'false'\n+          }\n+\n@@ -155,0 +186,1 @@\n+          echo \"dry-run=$(check_dry_run)\" >> $GITHUB_OUTPUT\n@@ -169,0 +201,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -183,0 +216,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -197,0 +231,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -211,0 +246,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -226,0 +262,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -241,0 +278,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -257,0 +295,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -271,0 +310,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -281,0 +321,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -293,0 +334,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -305,0 +347,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -317,0 +360,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -331,0 +375,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -347,0 +392,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -356,0 +402,1 @@\n+      - prepare\n@@ -362,0 +409,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -367,0 +415,1 @@\n+      - prepare\n@@ -374,0 +423,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -379,0 +429,1 @@\n+      - prepare\n@@ -385,0 +436,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n@@ -391,0 +443,1 @@\n+      - prepare\n@@ -397,0 +450,1 @@\n+      dry-run: ${{ needs.prepare.outputs.dry-run == 'true' }}\n","filename":".github\/workflows\/main.yml","additions":56,"deletions":2,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -43,0 +43,4 @@\n+      dry-run:\n+        required: false\n+        type: boolean\n+        default: false\n@@ -150,0 +154,1 @@\n+        if: ${{ inputs.dry-run == false }}\n@@ -202,0 +207,1 @@\n+        if: ${{ inputs.dry-run == false }}\n","filename":".github\/workflows\/test.yml","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1017,1 +1017,1 @@\n-    jdk.compiler-gendata: jdk.compiler-launchers\n+    jdk.compiler-gendata: jdk.compiler-launchers java.base-launchers\n","filename":"make\/Main.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+import java.util.Locale;\n@@ -96,1 +97,3 @@\n-        LINT_CATEGORY(\"lint.category\");\n+        LINT_CATEGORY(\"lint.category\"),\n+        DIAGNOSTIC_FLAGS_EMPTY(\"diagnostic.flags.empty\"),\n+        DIAGNOSTIC_FLAGS_NON_EMPTY(\"diagnostic.flags.non-empty\");\n@@ -262,0 +265,7 @@\n+        String diagnosticFlags = lines.stream()\n+                .filter(MessageLine::isDiagnosticFlags)\n+                .map(MessageLine::diagnosticFlags)\n+                .flatMap(Stream::of)\n+                .map(s -> s.replace('-', '_'))\n+                .map(s -> s.toUpperCase(Locale.ROOT))\n+                .collect(Collectors.joining(\", \"));\n@@ -268,0 +278,3 @@\n+                        diagnosticFlags.isEmpty() ?\n+                          StubKind.DIAGNOSTIC_FLAGS_EMPTY.format() :\n+                          StubKind.DIAGNOSTIC_FLAGS_NON_EMPTY.format(diagnosticFlags),\n@@ -273,0 +286,3 @@\n+                        diagnosticFlags.isEmpty() ?\n+                          StubKind.DIAGNOSTIC_FLAGS_EMPTY.format() :\n+                          StubKind.DIAGNOSTIC_FLAGS_NON_EMPTY.format(diagnosticFlags),\n@@ -290,0 +306,3 @@\n+                            diagnosticFlags.isEmpty() ?\n+                              StubKind.DIAGNOSTIC_FLAGS_EMPTY.format() :\n+                              StubKind.DIAGNOSTIC_FLAGS_NON_EMPTY.format(diagnosticFlags),\n@@ -295,0 +314,3 @@\n+                            diagnosticFlags.isEmpty() ?\n+                              StubKind.DIAGNOSTIC_FLAGS_EMPTY.format() :\n+                              StubKind.DIAGNOSTIC_FLAGS_NON_EMPTY.format(diagnosticFlags),\n","filename":"make\/langtools\/tools\/propertiesparser\/gen\/ClassGenerator.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n- * such as {0}, {1}, etc within the property value.\n+ * such as {0}, {1}, etc within the property value, a lint category,\n+ * and\/or a list of diagnostic flags.\n@@ -52,1 +53,1 @@\n-            if (l != null && l.isLint()) {\n+            while (l != null && (l.isLint() || l.isDiagnosticFlags())) {\n@@ -77,1 +78,1 @@\n-            if (l.prev != null && (l.prev.isInfo() || l.prev.isLint()))\n+            while (l.prev != null && (l.prev.isInfo() || l.prev.isLint() || l.prev.isDiagnosticFlags()))\n","filename":"make\/langtools\/tools\/propertiesparser\/parser\/Message.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.List;\n@@ -42,0 +43,1 @@\n+    static final Pattern diagnosticFlagsPattern = Pattern.compile(\"# flags: ([a-z\\\\-]+(, ([a-z\\\\-]+))*)\");\n@@ -72,0 +74,13 @@\n+    public boolean isDiagnosticFlags() {\n+        return diagnosticFlagsPattern.matcher(text).matches();\n+    }\n+\n+    public String[] diagnosticFlags() {\n+        Matcher matcher = diagnosticFlagsPattern.matcher(text);\n+        if (matcher.matches()) {\n+            return matcher.group(1).split(\", \", -1);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n","filename":"make\/langtools\/tools\/propertiesparser\/parser\/MessageLine.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+    import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;\\n\\\n@@ -37,0 +38,4 @@\n+    import java.util.EnumSet;\\n\\\n+    \\n\\\n+    import static com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag.*;\\n\\\n+    \\n\\\n@@ -61,1 +66,1 @@\n-    return new {0}({1}, {2}, {3});\n+    return new {0}({1}, {2}, {3}, {4});\n@@ -64,1 +69,1 @@\n-    return new {0}({1}, {2}, {3}, {4});\n+    return new {0}({1}, {2}, {3}, {4}, {5});\n@@ -70,1 +75,1 @@\n-    public static final {0} {1} = new {0}({2}, {3});\n+    public static final {0} {1} = new {0}({2}, {3}, {4});\n@@ -76,1 +81,1 @@\n-    public static final {0} {1} = new {0}({2}, {3}, {4});\n+    public static final {0} {1} = new {0}({2}, {3}, {4}, {5});\n@@ -87,0 +92,6 @@\n+diagnostic.flags.empty=\\\n+  EnumSet.noneOf(DiagnosticFlag.class)\n+\n+diagnostic.flags.non-empty=\\\n+  EnumSet.of({0})\n+\n","filename":"make\/langtools\/tools\/propertiesparser\/resources\/templates.properties","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-export SOURCE := 7\n+export SOURCE := 8\n@@ -37,1 +37,1 @@\n-export TARGET := 7\n+export TARGET := 8\n","filename":"src\/demo\/share\/java2d\/J2DBench\/Makefile","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  <condition property=\"source\" value=\"7\">\n+  <condition property=\"source\" value=\"8\">\n@@ -47,1 +47,1 @@\n-  <condition property=\"target\" value=\"7\">\n+  <condition property=\"target\" value=\"8\">\n@@ -57,5 +57,0 @@\n-  <condition property=\"javac\" value=\"javac\">\n-     <not>\n-        <isset property=\"javac\"\/>\n-     <\/not>\n-  <\/condition>\n@@ -73,1 +68,1 @@\n-    <javac debug=\"off\" source=\"${source}\" target=\"${target}\" srcdir=\"${src}\" destdir=\"${build}\" fork=\"true\" executable=\"${javac}\"\/>\n+    <javac debug=\"off\" source=\"${source}\" target=\"${target}\" srcdir=\"${src}\" destdir=\"${build}\"\/>\n","filename":"src\/demo\/share\/java2d\/J2DBench\/build.xml","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-                System.out.println(\"    Overall average:  \"+overallscore);\n+                System.out.printf( \"    Overall average:  %-10.4f%n\", overallscore);\n","filename":"src\/demo\/share\/java2d\/J2DBench\/src\/j2dbench\/report\/J2DAnalyzer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5802,0 +5802,3 @@\n+opclass memory_noindex(indirect,\n+                       indOffI1, indOffL1,indOffI2, indOffL2, indOffI4, indOffL4, indOffI8, indOffL8,\n+                       indirectN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n@@ -6739,1 +6742,1 @@\n-instruct loadNKlassCompactHeaders(iRegNNoSp dst, memory4 mem)\n+instruct loadNKlassCompactHeaders(iRegNNoSp dst, memory_noindex mem)\n@@ -6747,1 +6750,1 @@\n-    \"lsrw  $dst, $dst, markWord::klass_shift_at_offset\"\n+    \"lsrw  $dst, $dst, markWord::klass_shift\"\n@@ -6750,4 +6753,5 @@\n-    \/\/ inlined aarch64_enc_ldrw\n-    loadStore(masm, &MacroAssembler::ldrw, $dst$$Register, $mem->opcode(),\n-              as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);\n-    __ lsrw($dst$$Register, $dst$$Register, markWord::klass_shift_at_offset);\n+    assert($mem$$index$$Register == noreg, \"must not have indexed address\");\n+    \/\/ The incoming address is pointing into obj-start + klass_offset_in_bytes. We need to extract\n+    \/\/ obj-start, so that we can load from the object's mark-word instead.\n+    __ ldrw($dst$$Register, Address($mem$$base$$Register, $mem$$disp - Type::klass_offset()));\n+    __ lsrw($dst$$Register, $dst$$Register, markWord::klass_shift);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::counter_overflow_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_counter_overflow_id)));\n@@ -68,1 +68,1 @@\n-    address a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+    address a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -81,1 +81,1 @@\n-  C1StubId stub_id;\n+  StubId stub_id;\n@@ -83,1 +83,1 @@\n-    stub_id = C1StubId::throw_index_exception_id;\n+    stub_id = StubId::c1_throw_index_exception_id;\n@@ -87,1 +87,1 @@\n-    stub_id = C1StubId::throw_range_check_failed_id;\n+    stub_id = StubId::c1_throw_range_check_failed_id;\n@@ -102,1 +102,1 @@\n-  address a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+  address a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -114,1 +114,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::throw_div0_exception_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_throw_div0_exception_id)));\n@@ -126,1 +126,1 @@\n-NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, C1StubId stub_id) {\n+NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, StubId stub_id) {\n@@ -131,3 +131,3 @@\n-  assert(stub_id == C1StubId::new_instance_id                 ||\n-         stub_id == C1StubId::fast_new_instance_id            ||\n-         stub_id == C1StubId::fast_new_instance_init_check_id,\n+  assert(stub_id == StubId::c1_new_instance_id                 ||\n+         stub_id == StubId::c1_fast_new_instance_id            ||\n+         stub_id == StubId::c1_fast_new_instance_init_check_id,\n@@ -169,1 +169,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::new_type_array_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_new_type_array_id)));\n@@ -192,1 +192,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::new_object_array_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_new_object_array_id)));\n@@ -204,1 +204,1 @@\n-  C1StubId enter_id;\n+  StubId enter_id;\n@@ -206,1 +206,1 @@\n-    enter_id = C1StubId::monitorenter_id;\n+    enter_id = StubId::c1_monitorenter_id;\n@@ -208,1 +208,1 @@\n-    enter_id = C1StubId::monitorenter_nofpu_id;\n+    enter_id = StubId::c1_monitorenter_nofpu_id;\n@@ -225,1 +225,1 @@\n-  C1StubId exit_id;\n+  StubId exit_id;\n@@ -227,1 +227,1 @@\n-    exit_id = C1StubId::monitorexit_id;\n+    exit_id = StubId::c1_monitorexit_id;\n@@ -229,1 +229,1 @@\n-    exit_id = C1StubId::monitorexit_nofpu_id;\n+    exit_id = StubId::c1_monitorexit_nofpu_id;\n@@ -257,1 +257,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::deoptimize_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_deoptimize_id)));\n@@ -267,1 +267,1 @@\n-    a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+    a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -269,1 +269,1 @@\n-    a = Runtime1::entry_for(C1StubId::throw_null_pointer_exception_id);\n+    a = Runtime1::entry_for(StubId::c1_throw_null_pointer_exception_id);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -323,1 +323,1 @@\n-    target = Runtime1::entry_for(C1StubId::access_field_patching_id);\n+    target = Runtime1::entry_for(StubId::c1_access_field_patching_id);\n@@ -327,1 +327,1 @@\n-    target = Runtime1::entry_for(C1StubId::load_klass_patching_id);\n+    target = Runtime1::entry_for(StubId::c1_load_klass_patching_id);\n@@ -331,1 +331,1 @@\n-    target = Runtime1::entry_for(C1StubId::load_mirror_patching_id);\n+    target = Runtime1::entry_for(StubId::c1_load_mirror_patching_id);\n@@ -335,1 +335,1 @@\n-    target = Runtime1::entry_for(C1StubId::load_appendix_patching_id);\n+    target = Runtime1::entry_for(StubId::c1_load_appendix_patching_id);\n@@ -377,1 +377,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::handle_exception_from_callee_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_handle_exception_from_callee_id)));\n@@ -434,1 +434,1 @@\n-  __ far_jump(RuntimeAddress(Runtime1::entry_for(C1StubId::unwind_exception_id)));\n+  __ far_jump(RuntimeAddress(Runtime1::entry_for(StubId::c1_unwind_exception_id)));\n@@ -877,1 +877,1 @@\n-    target = Runtime1::entry_for(C1StubId::access_field_patching_id);\n+    target = Runtime1::entry_for(StubId::c1_access_field_patching_id);\n@@ -881,1 +881,1 @@\n-    target = Runtime1::entry_for(C1StubId::load_klass_patching_id);\n+    target = Runtime1::entry_for(StubId::c1_load_klass_patching_id);\n@@ -885,1 +885,1 @@\n-    target = Runtime1::entry_for(C1StubId::load_mirror_patching_id);\n+    target = Runtime1::entry_for(StubId::c1_load_mirror_patching_id);\n@@ -889,1 +889,1 @@\n-    target = Runtime1::entry_for(C1StubId::load_appendix_patching_id);\n+    target = Runtime1::entry_for(StubId::c1_load_appendix_patching_id);\n@@ -1361,1 +1361,1 @@\n-        __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+        __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n@@ -1372,1 +1372,1 @@\n-      __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+      __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n@@ -1450,1 +1450,1 @@\n-    __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+    __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n@@ -2036,1 +2036,1 @@\n-  C1StubId unwind_id;\n+  StubId unwind_id;\n@@ -2055,1 +2055,1 @@\n-    unwind_id = C1StubId::handle_exception_id;\n+    unwind_id = StubId::c1_handle_exception_id;\n@@ -2057,1 +2057,1 @@\n-    unwind_id = C1StubId::handle_exception_nofpu_id;\n+    unwind_id = StubId::c1_handle_exception_nofpu_id;\n@@ -2328,1 +2328,1 @@\n-      __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+      __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1248,1 +1248,1 @@\n-  __ call_runtime(Runtime1::entry_for(C1StubId::new_multi_array_id),\n+  __ call_runtime(Runtime1::entry_for(StubId::c1_new_multi_array_id),\n@@ -1279,1 +1279,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);\n+    stub = new SimpleExceptionStub(StubId::c1_throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);\n@@ -1286,1 +1286,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_class_cast_exception_id, obj.result(), info_for_exception);\n+    stub = new SimpleExceptionStub(StubId::c1_throw_class_cast_exception_id, obj.result(), info_for_exception);\n@@ -1321,1 +1321,1 @@\n-  return Runtime1::entry_for(C1StubId::is_instance_of_id);\n+  return Runtime1::entry_for(StubId::c1_is_instance_of_id);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -274,1 +274,1 @@\n-    far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::dtrace_object_alloc_id)));\n+    far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_dtrace_object_alloc_id)));\n@@ -315,1 +315,1 @@\n-    far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::dtrace_object_alloc_id)));\n+    far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_dtrace_object_alloc_id)));\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-    } else if (_stub_id == (int)C1StubId::forward_exception_id) {\n+    } else if (_stub_id == (int)StubId::c1_forward_exception_id) {\n@@ -105,1 +105,1 @@\n-      far_jump(RuntimeAddress(Runtime1::entry_for(C1StubId::forward_exception_id)));\n+      far_jump(RuntimeAddress(Runtime1::entry_for(StubId::c1_forward_exception_id)));\n@@ -353,2 +353,2 @@\n-  assert(cb == Runtime1::blob_for(C1StubId::monitorenter_id) ||\n-         cb == Runtime1::blob_for(C1StubId::monitorenter_nofpu_id), \"must be\");\n+  assert(cb == Runtime1::blob_for(StubId::c1_monitorenter_id) ||\n+         cb == Runtime1::blob_for(StubId::c1_monitorenter_nofpu_id), \"must be\");\n@@ -380,1 +380,1 @@\n-OopMapSet* Runtime1::generate_handle_exception(C1StubId id, StubAssembler *sasm) {\n+OopMapSet* Runtime1::generate_handle_exception(StubId id, StubAssembler *sasm) {\n@@ -392,1 +392,1 @@\n-  case C1StubId::forward_exception_id:\n+  case StubId::c1_forward_exception_id:\n@@ -412,2 +412,2 @@\n-  case C1StubId::handle_exception_nofpu_id:\n-  case C1StubId::handle_exception_id:\n+  case StubId::c1_handle_exception_nofpu_id:\n+  case StubId::c1_handle_exception_id:\n@@ -415,1 +415,1 @@\n-    oop_map = save_live_registers(sasm, id != C1StubId::handle_exception_nofpu_id);\n+    oop_map = save_live_registers(sasm, id != StubId::c1_handle_exception_nofpu_id);\n@@ -417,1 +417,1 @@\n-  case C1StubId::handle_exception_from_callee_id: {\n+  case StubId::c1_handle_exception_from_callee_id: {\n@@ -475,3 +475,3 @@\n-  case C1StubId::forward_exception_id:\n-  case C1StubId::handle_exception_nofpu_id:\n-  case C1StubId::handle_exception_id:\n+  case StubId::c1_forward_exception_id:\n+  case StubId::c1_handle_exception_nofpu_id:\n+  case StubId::c1_handle_exception_id:\n@@ -479,1 +479,1 @@\n-    restore_live_registers(sasm, id != C1StubId::handle_exception_nofpu_id);\n+    restore_live_registers(sasm, id != StubId::c1_handle_exception_nofpu_id);\n@@ -481,1 +481,1 @@\n-  case C1StubId::handle_exception_from_callee_id:\n+  case StubId::c1_handle_exception_from_callee_id:\n@@ -633,1 +633,1 @@\n-OopMapSet* Runtime1::generate_code_for(C1StubId id, StubAssembler* sasm) {\n+OopMapSet* Runtime1::generate_code_for(StubId id, StubAssembler* sasm) {\n@@ -650,1 +650,1 @@\n-    case C1StubId::forward_exception_id:\n+    case StubId::c1_forward_exception_id:\n@@ -658,1 +658,1 @@\n-    case C1StubId::throw_div0_exception_id:\n+    case StubId::c1_throw_div0_exception_id:\n@@ -664,1 +664,1 @@\n-    case C1StubId::throw_null_pointer_exception_id:\n+    case StubId::c1_throw_null_pointer_exception_id:\n@@ -670,3 +670,3 @@\n-    case C1StubId::new_instance_id:\n-    case C1StubId::fast_new_instance_id:\n-    case C1StubId::fast_new_instance_init_check_id:\n+    case StubId::c1_new_instance_id:\n+    case StubId::c1_fast_new_instance_id:\n+    case StubId::c1_fast_new_instance_init_check_id:\n@@ -677,1 +677,1 @@\n-        if (id == C1StubId::new_instance_id) {\n+        if (id == StubId::c1_new_instance_id) {\n@@ -679,1 +679,1 @@\n-        } else if (id == C1StubId::fast_new_instance_id) {\n+        } else if (id == StubId::c1_fast_new_instance_id) {\n@@ -682,1 +682,1 @@\n-          assert(id == C1StubId::fast_new_instance_init_check_id, \"bad C1StubId\");\n+          assert(id == StubId::c1_fast_new_instance_init_check_id, \"bad StubId\");\n@@ -701,1 +701,1 @@\n-    case C1StubId::counter_overflow_id:\n+    case StubId::c1_counter_overflow_id:\n@@ -719,2 +719,2 @@\n-    case C1StubId::new_type_array_id:\n-    case C1StubId::new_object_array_id:\n+    case StubId::c1_new_type_array_id:\n+    case StubId::c1_new_object_array_id:\n@@ -726,1 +726,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -739,1 +739,1 @@\n-          int tag = ((id == C1StubId::new_type_array_id)\n+          int tag = ((id == StubId::c1_new_type_array_id)\n@@ -754,1 +754,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -772,1 +772,1 @@\n-    case C1StubId::new_multi_array_id:\n+    case StubId::c1_new_multi_array_id:\n@@ -792,1 +792,1 @@\n-    case C1StubId::register_finalizer_id:\n+    case StubId::c1_register_finalizer_id:\n@@ -824,1 +824,1 @@\n-    case C1StubId::throw_class_cast_exception_id:\n+    case StubId::c1_throw_class_cast_exception_id:\n@@ -830,1 +830,1 @@\n-    case C1StubId::throw_incompatible_class_change_error_id:\n+    case StubId::c1_throw_incompatible_class_change_error_id:\n@@ -836,1 +836,1 @@\n-    case C1StubId::slow_subtype_check_id:\n+    case StubId::c1_slow_subtype_check_id:\n@@ -885,1 +885,1 @@\n-    case C1StubId::monitorenter_nofpu_id:\n+    case StubId::c1_monitorenter_nofpu_id:\n@@ -888,1 +888,1 @@\n-    case C1StubId::monitorenter_id:\n+    case StubId::c1_monitorenter_id:\n@@ -906,1 +906,1 @@\n-    case C1StubId::is_instance_of_id:\n+    case StubId::c1_is_instance_of_id:\n@@ -955,1 +955,1 @@\n-    case C1StubId::monitorexit_nofpu_id:\n+    case StubId::c1_monitorexit_nofpu_id:\n@@ -958,1 +958,1 @@\n-    case C1StubId::monitorexit_id:\n+    case StubId::c1_monitorexit_id:\n@@ -978,1 +978,1 @@\n-    case C1StubId::deoptimize_id:\n+    case StubId::c1_deoptimize_id:\n@@ -995,1 +995,1 @@\n-    case C1StubId::throw_range_check_failed_id:\n+    case StubId::c1_throw_range_check_failed_id:\n@@ -1001,1 +1001,1 @@\n-    case C1StubId::unwind_exception_id:\n+    case StubId::c1_unwind_exception_id:\n@@ -1009,1 +1009,1 @@\n-    case C1StubId::access_field_patching_id:\n+    case StubId::c1_access_field_patching_id:\n@@ -1016,1 +1016,1 @@\n-    case C1StubId::load_klass_patching_id:\n+    case StubId::c1_load_klass_patching_id:\n@@ -1023,1 +1023,1 @@\n-    case C1StubId::load_mirror_patching_id:\n+    case StubId::c1_load_mirror_patching_id:\n@@ -1030,1 +1030,1 @@\n-    case C1StubId::load_appendix_patching_id:\n+    case StubId::c1_load_appendix_patching_id:\n@@ -1037,2 +1037,2 @@\n-    case C1StubId::handle_exception_nofpu_id:\n-    case C1StubId::handle_exception_id:\n+    case StubId::c1_handle_exception_nofpu_id:\n+    case StubId::c1_handle_exception_id:\n@@ -1044,1 +1044,1 @@\n-    case C1StubId::handle_exception_from_callee_id:\n+    case StubId::c1_handle_exception_from_callee_id:\n@@ -1050,1 +1050,1 @@\n-    case C1StubId::throw_index_exception_id:\n+    case StubId::c1_throw_index_exception_id:\n@@ -1056,1 +1056,1 @@\n-    case C1StubId::throw_array_store_exception_id:\n+    case StubId::c1_throw_array_store_exception_id:\n@@ -1064,1 +1064,1 @@\n-    case C1StubId::predicate_failed_trap_id:\n+    case StubId::c1_predicate_failed_trap_id:\n@@ -1082,1 +1082,1 @@\n-    case C1StubId::dtrace_object_alloc_id:\n+    case StubId::c1_dtrace_object_alloc_id:\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":55,"deletions":55,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -444,2 +444,2 @@\n-  if (cb == Runtime1::blob_for(C1StubId::monitorenter_id) ||\n-      cb == Runtime1::blob_for(C1StubId::monitorenter_nofpu_id)) {\n+  if (cb == Runtime1::blob_for(StubId::c1_monitorenter_id) ||\n+      cb == Runtime1::blob_for(StubId::c1_monitorenter_nofpu_id)) {\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5043,2 +5043,2 @@\n-  ldr(dst, Address(src, oopDesc::mark_offset_in_bytes()));\n-  lsr(dst, dst, markWord::klass_shift);\n+  ldrw(dst, Address(src, oopDesc::mark_offset_in_bytes()));\n+  lsrw(dst, dst, markWord::klass_shift);\n@@ -5898,0 +5898,1 @@\n+  Register cnt2 = tmp2;  \/\/ cnt2 only used in array length compare\n@@ -5900,1 +5901,0 @@\n-  int klass_offset  = arrayOopDesc::klass_offset_in_bytes();\n@@ -5904,10 +5904,0 @@\n-  \/\/ When the length offset is not aligned to 8 bytes,\n-  \/\/ then we align it down. This is valid because the new\n-  \/\/ offset will always be the klass which is the same\n-  \/\/ for type arrays.\n-  int start_offset = align_down(length_offset, BytesPerWord);\n-  int extra_length = base_offset - start_offset;\n-  assert(start_offset == length_offset || start_offset == klass_offset,\n-         \"start offset must be 8-byte-aligned or be the klass offset\");\n-  assert(base_offset != start_offset, \"must include the length field\");\n-  extra_length = extra_length \/ elem_size; \/\/ We count in elements, not bytes.\n@@ -5947,4 +5937,5 @@\n-    \/\/ Increase loop counter by diff between base- and actual start-offset.\n-    addw(cnt1, cnt1, extra_length);\n-    lea(a1, Address(a1, start_offset));\n-    lea(a2, Address(a2, start_offset));\n+    ldrw(cnt2, Address(a2, length_offset));\n+    eorw(tmp5, cnt1, cnt2);\n+    cbnzw(tmp5, DONE);\n+    lea(a1, Address(a1, base_offset));\n+    lea(a2, Address(a2, base_offset));\n@@ -6013,3 +6004,1 @@\n-    \/\/ Increase loop counter by diff between base- and actual start-offset.\n-    addw(cnt1, cnt1, extra_length);\n-\n+    ldrw(cnt2, Address(a2, length_offset));\n@@ -6020,1 +6009,1 @@\n-    ldr(tmp3, Address(pre(a1, start_offset)));\n+    ldr(tmp3, Address(pre(a1, base_offset)));\n@@ -6023,1 +6012,1 @@\n-    ldr(tmp4, Address(pre(a2, start_offset)));\n+    ldr(tmp4, Address(pre(a2, base_offset)));\n@@ -6025,0 +6014,2 @@\n+    cmp(cnt2, cnt1);\n+    br(NE, DONE);\n@@ -6056,1 +6047,3 @@\n-    ldr(tmp4, Address(pre(a2, start_offset)));\n+    ldr(tmp4, Address(pre(a2, base_offset)));\n+    cmp(cnt2, cnt1);\n+    br(NE, DONE);\n@@ -6077,0 +6070,3 @@\n+    cmp(cnt2, cnt1);\n+    br(NE, DONE);\n+    cbz(cnt1, SAME);\n@@ -6078,2 +6074,2 @@\n-    ldr(tmp3, Address(a1, start_offset));\n-    ldr(tmp4, Address(a2, start_offset));\n+    ldr(tmp3, Address(a1, base_offset));\n+    ldr(tmp4, Address(a2, base_offset));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":21,"deletions":25,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -64,2 +64,2 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n-  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, (uint)OptoStubId::uncommon_trap_id, name);\n+  const char* name = OptoRuntime::stub_name(StubId::c2_uncommon_trap_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, BlobId::c2_uncommon_trap_id);\n@@ -257,1 +257,1 @@\n-  AOTCodeCache::store_code_blob(*ut_blob, AOTCodeEntry::C2Blob, (uint)OptoStubId::uncommon_trap_id, name);\n+  AOTCodeCache::store_code_blob(*ut_blob, AOTCodeEntry::C2Blob, BlobId::c2_uncommon_trap_id);\n@@ -294,2 +294,2 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n-  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, (uint)OptoStubId::exception_id, name);\n+  const char* name = OptoRuntime::stub_name(StubId::c2_exception_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, (uint)BlobId::c2_exception_id, name);\n@@ -401,1 +401,1 @@\n-  AOTCodeCache::store_code_blob(*ex_blob, AOTCodeEntry::C2Blob, (uint)OptoStubId::exception_id, name);\n+  AOTCodeCache::store_code_blob(*ex_blob, AOTCodeEntry::C2Blob, BlobId::c2_exception_id);\n","filename":"src\/hotspot\/cpu\/aarch64\/runtime_aarch64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2204,2 +2204,2 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::deopt_id);\n-  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)SharedStubId::deopt_id, name);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_deopt_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, BlobId::shared_deopt_id);\n@@ -2575,1 +2575,1 @@\n-  AOTCodeCache::store_code_blob(*_deopt_blob, AOTCodeEntry::SharedBlob, (uint)SharedStubId::deopt_id, name);\n+  AOTCodeCache::store_code_blob(*_deopt_blob, AOTCodeEntry::SharedBlob, BlobId::shared_deopt_id);\n@@ -2601,1 +2601,1 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(StubId id, address call_ptr) {\n@@ -2606,1 +2606,1 @@\n-  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n@@ -2620,2 +2620,2 @@\n-  bool cause_return = (id == SharedStubId::polling_page_return_handler_id);\n-  RegisterSaver reg_save(id == SharedStubId::polling_page_vectors_safepoint_handler_id \/* save_vectors *\/);\n+  bool cause_return = (id == StubId::shared_polling_page_return_handler_id);\n+  RegisterSaver reg_save(id == StubId::shared_polling_page_vectors_safepoint_handler_id \/* save_vectors *\/);\n@@ -2724,1 +2724,1 @@\n-  AOTCodeCache::store_code_blob(*sp_blob, AOTCodeEntry::SharedBlob, (uint)id, name);\n+  AOTCodeCache::store_code_blob(*sp_blob, AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n@@ -2736,1 +2736,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(StubId id, address destination) {\n@@ -2741,1 +2741,1 @@\n-  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n@@ -2822,1 +2822,1 @@\n-  AOTCodeCache::store_code_blob(*rs_blob, AOTCodeEntry::SharedBlob, (uint)id, name);\n+  AOTCodeCache::store_code_blob(*rs_blob, AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n@@ -2842,1 +2842,1 @@\n-RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+RuntimeStub* SharedRuntime::generate_throw_exception(StubId id, address runtime_entry) {\n@@ -2866,1 +2866,1 @@\n-  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n@@ -2931,1 +2931,1 @@\n-  AOTCodeCache::store_code_blob(*stub, AOTCodeEntry::SharedBlob, (uint)id, name);\n+  AOTCodeCache::store_code_blob(*stub, AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n@@ -2962,1 +2962,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_write_checkpoint_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_jfr_write_checkpoint_id);\n@@ -3001,1 +3001,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_return_lease_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_jfr_return_lease_id);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-    StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+    StubId stub_id = StubId::stubgen_call_stub_id;\n@@ -425,1 +425,1 @@\n-    StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+    StubId stub_id = StubId::stubgen_catch_exception_id;\n@@ -481,1 +481,1 @@\n-    StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+    StubId stub_id = StubId::stubgen_forward_exception_id;\n@@ -571,1 +571,1 @@\n-    StubGenStubId stub_id = StubGenStubId::verify_oop_id;\n+    StubId stub_id = StubId::stubgen_verify_oop_id;\n@@ -620,1 +620,1 @@\n-  address generate_iota_indices(StubGenStubId stub_id) {\n+  address generate_iota_indices(StubId stub_id) {\n@@ -665,1 +665,1 @@\n-    StubGenStubId stub_id = StubGenStubId::zero_blocks_id;\n+    StubId stub_id = StubId::stubgen_zero_blocks_id;\n@@ -805,1 +805,1 @@\n-  void generate_copy_longs(StubGenStubId stub_id, DecoratorSet decorators, Label &start, Register s, Register d, Register count) {\n+  void generate_copy_longs(StubId stub_id, DecoratorSet decorators, Label &start, Register s, Register d, Register count) {\n@@ -810,1 +810,1 @@\n-    case copy_byte_f_id:\n+    case StubId::stubgen_copy_byte_f_id:\n@@ -814,1 +814,1 @@\n-    case copy_byte_b_id:\n+    case StubId::stubgen_copy_byte_b_id:\n@@ -818,1 +818,1 @@\n-    case copy_oop_f_id:\n+    case StubId::stubgen_copy_oop_f_id:\n@@ -822,1 +822,1 @@\n-    case copy_oop_b_id:\n+    case StubId::stubgen_copy_oop_b_id:\n@@ -826,1 +826,1 @@\n-    case copy_oop_uninit_f_id:\n+    case StubId::stubgen_copy_oop_uninit_f_id:\n@@ -830,1 +830,1 @@\n-    case copy_oop_uninit_b_id:\n+    case StubId::stubgen_copy_oop_uninit_b_id:\n@@ -1529,1 +1529,1 @@\n-  address generate_disjoint_copy(StubGenStubId stub_id, address *entry) {\n+  address generate_disjoint_copy(StubId stub_id, address *entry) {\n@@ -1537,1 +1537,1 @@\n-    case jbyte_disjoint_arraycopy_id:\n+    case StubId::stubgen_jbyte_disjoint_arraycopy_id:\n@@ -1543,1 +1543,1 @@\n-    case arrayof_jbyte_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id:\n@@ -1549,1 +1549,1 @@\n-    case jshort_disjoint_arraycopy_id:\n+    case StubId::stubgen_jshort_disjoint_arraycopy_id:\n@@ -1555,1 +1555,1 @@\n-    case arrayof_jshort_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id:\n@@ -1561,1 +1561,1 @@\n-    case jint_disjoint_arraycopy_id:\n+    case StubId::stubgen_jint_disjoint_arraycopy_id:\n@@ -1567,1 +1567,1 @@\n-    case arrayof_jint_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jint_disjoint_arraycopy_id:\n@@ -1573,1 +1573,1 @@\n-    case jlong_disjoint_arraycopy_id:\n+    case StubId::stubgen_jlong_disjoint_arraycopy_id:\n@@ -1575,1 +1575,1 @@\n-      \/\/ stub as for case arrayof_jlong_disjoint_arraycopy\n+      \/\/ stub as for case StubId::stubgen_arrayof_jlong_disjoint_arraycopy\n@@ -1578,1 +1578,1 @@\n-    case arrayof_jlong_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id:\n@@ -1584,1 +1584,1 @@\n-    case oop_disjoint_arraycopy_id:\n+    case StubId::stubgen_oop_disjoint_arraycopy_id:\n@@ -1590,1 +1590,1 @@\n-    case arrayof_oop_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_oop_disjoint_arraycopy_id:\n@@ -1596,1 +1596,1 @@\n-    case oop_disjoint_arraycopy_uninit_id:\n+    case StubId::stubgen_oop_disjoint_arraycopy_uninit_id:\n@@ -1602,1 +1602,1 @@\n-    case arrayof_oop_disjoint_arraycopy_uninit_id:\n+    case StubId::stubgen_arrayof_oop_disjoint_arraycopy_uninit_id:\n@@ -1685,1 +1685,1 @@\n-  address generate_conjoint_copy(StubGenStubId stub_id, address nooverlap_target, address *entry) {\n+  address generate_conjoint_copy(StubId stub_id, address nooverlap_target, address *entry) {\n@@ -1693,1 +1693,1 @@\n-    case jbyte_arraycopy_id:\n+    case StubId::stubgen_jbyte_arraycopy_id:\n@@ -1699,1 +1699,1 @@\n-    case arrayof_jbyte_arraycopy_id:\n+    case StubId::stubgen_arrayof_jbyte_arraycopy_id:\n@@ -1705,1 +1705,1 @@\n-    case jshort_arraycopy_id:\n+    case StubId::stubgen_jshort_arraycopy_id:\n@@ -1711,1 +1711,1 @@\n-    case arrayof_jshort_arraycopy_id:\n+    case StubId::stubgen_arrayof_jshort_arraycopy_id:\n@@ -1717,1 +1717,1 @@\n-    case jint_arraycopy_id:\n+    case StubId::stubgen_jint_arraycopy_id:\n@@ -1723,1 +1723,1 @@\n-    case arrayof_jint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jint_arraycopy_id:\n@@ -1729,1 +1729,1 @@\n-    case jlong_arraycopy_id:\n+    case StubId::stubgen_jlong_arraycopy_id:\n@@ -1731,1 +1731,1 @@\n-      \/\/ stub as for case arrayof_jlong_disjoint_arraycopy\n+      \/\/ stub as for case StubId::stubgen_arrayof_jlong_disjoint_arraycopy\n@@ -1734,1 +1734,1 @@\n-    case arrayof_jlong_arraycopy_id:\n+    case StubId::stubgen_arrayof_jlong_arraycopy_id:\n@@ -1740,1 +1740,1 @@\n-    case oop_arraycopy_id:\n+    case StubId::stubgen_oop_arraycopy_id:\n@@ -1746,1 +1746,1 @@\n-    case arrayof_oop_arraycopy_id:\n+    case StubId::stubgen_arrayof_oop_arraycopy_id:\n@@ -1752,1 +1752,1 @@\n-    case oop_arraycopy_uninit_id:\n+    case StubId::stubgen_oop_arraycopy_uninit_id:\n@@ -1758,1 +1758,1 @@\n-    case arrayof_oop_arraycopy_uninit_id:\n+    case StubId::stubgen_arrayof_oop_arraycopy_uninit_id:\n@@ -1853,1 +1853,1 @@\n-  address generate_checkcast_copy(StubGenStubId stub_id, address *entry) {\n+  address generate_checkcast_copy(StubId stub_id, address *entry) {\n@@ -1856,1 +1856,1 @@\n-    case checkcast_arraycopy_id:\n+    case StubId::stubgen_checkcast_arraycopy_id:\n@@ -1859,1 +1859,1 @@\n-    case checkcast_arraycopy_uninit_id:\n+    case StubId::stubgen_checkcast_arraycopy_uninit_id:\n@@ -2074,1 +2074,1 @@\n-    StubGenStubId stub_id = StubGenStubId::unsafe_arraycopy_id;\n+    StubId stub_id = StubId::stubgen_unsafe_arraycopy_id;\n@@ -2127,1 +2127,1 @@\n-    StubGenStubId stub_id = StubGenStubId::generic_arraycopy_id;\n+    StubId stub_id = StubId::stubgen_generic_arraycopy_id;\n@@ -2398,1 +2398,1 @@\n-  address generate_fill(StubGenStubId stub_id) {\n+  address generate_fill(StubId stub_id) {\n@@ -2403,1 +2403,1 @@\n-    case jbyte_fill_id:\n+    case StubId::stubgen_jbyte_fill_id:\n@@ -2407,1 +2407,1 @@\n-    case jshort_fill_id:\n+    case StubId::stubgen_jshort_fill_id:\n@@ -2411,1 +2411,1 @@\n-    case jint_fill_id:\n+    case StubId::stubgen_jint_fill_id:\n@@ -2415,1 +2415,1 @@\n-    case arrayof_jbyte_fill_id:\n+    case StubId::stubgen_arrayof_jbyte_fill_id:\n@@ -2419,1 +2419,1 @@\n-    case arrayof_jshort_fill_id:\n+    case StubId::stubgen_arrayof_jshort_fill_id:\n@@ -2423,1 +2423,1 @@\n-    case arrayof_jint_fill_id:\n+    case StubId::stubgen_arrayof_jint_fill_id:\n@@ -2593,1 +2593,1 @@\n-    StubCodeMark mark(this, StubGenStubId::unsafe_setmemory_id);\n+    StubCodeMark mark(this, StubId::stubgen_unsafe_setmemory_id);\n@@ -2691,1 +2691,1 @@\n-    StubGenStubId stub_id = StubGenStubId::data_cache_writeback_id;\n+    StubId stub_id = StubId::stubgen_data_cache_writeback_id;\n@@ -2708,1 +2708,1 @@\n-    StubGenStubId stub_id = StubGenStubId::data_cache_writeback_sync_id;\n+    StubId stub_id = StubId::stubgen_data_cache_writeback_sync_id;\n@@ -2738,2 +2738,2 @@\n-    generate_copy_longs(StubGenStubId::copy_byte_f_id, IN_HEAP | IS_ARRAY, copy_f, r0, r1, r15);\n-    generate_copy_longs(StubGenStubId::copy_byte_b_id, IN_HEAP | IS_ARRAY, copy_b, r0, r1, r15);\n+    generate_copy_longs(StubId::stubgen_copy_byte_f_id, IN_HEAP | IS_ARRAY, copy_f, r0, r1, r15);\n+    generate_copy_longs(StubId::stubgen_copy_byte_b_id, IN_HEAP | IS_ARRAY, copy_b, r0, r1, r15);\n@@ -2741,2 +2741,2 @@\n-    generate_copy_longs(StubGenStubId::copy_oop_f_id, IN_HEAP | IS_ARRAY, copy_obj_f, r0, r1, r15);\n-    generate_copy_longs(StubGenStubId::copy_oop_b_id, IN_HEAP | IS_ARRAY, copy_obj_b, r0, r1, r15);\n+    generate_copy_longs(StubId::stubgen_copy_oop_f_id, IN_HEAP | IS_ARRAY, copy_obj_f, r0, r1, r15);\n+    generate_copy_longs(StubId::stubgen_copy_oop_b_id, IN_HEAP | IS_ARRAY, copy_obj_b, r0, r1, r15);\n@@ -2744,2 +2744,2 @@\n-    generate_copy_longs(StubGenStubId::copy_oop_uninit_f_id, IN_HEAP | IS_ARRAY | IS_DEST_UNINITIALIZED, copy_obj_uninit_f, r0, r1, r15);\n-    generate_copy_longs(StubGenStubId::copy_oop_uninit_b_id, IN_HEAP | IS_ARRAY | IS_DEST_UNINITIALIZED, copy_obj_uninit_b, r0, r1, r15);\n+    generate_copy_longs(StubId::stubgen_copy_oop_uninit_f_id, IN_HEAP | IS_ARRAY | IS_DEST_UNINITIALIZED, copy_obj_uninit_f, r0, r1, r15);\n+    generate_copy_longs(StubId::stubgen_copy_oop_uninit_b_id, IN_HEAP | IS_ARRAY | IS_DEST_UNINITIALIZED, copy_obj_uninit_b, r0, r1, r15);\n@@ -2751,4 +2751,4 @@\n-    StubRoutines::_jbyte_disjoint_arraycopy         = generate_disjoint_copy(StubGenStubId::jbyte_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_jbyte_arraycopy                  = generate_conjoint_copy(StubGenStubId::jbyte_arraycopy_id, entry, &entry_jbyte_arraycopy);\n-    StubRoutines::_arrayof_jbyte_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jbyte_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jbyte_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jbyte_arraycopy_id, entry, nullptr);\n+    StubRoutines::_jbyte_disjoint_arraycopy         = generate_disjoint_copy(StubId::stubgen_jbyte_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jbyte_arraycopy                  = generate_conjoint_copy(StubId::stubgen_jbyte_arraycopy_id, entry, &entry_jbyte_arraycopy);\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jbyte_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jbyte_arraycopy_id, entry, nullptr);\n@@ -2758,4 +2758,4 @@\n-    StubRoutines::_jshort_disjoint_arraycopy         = generate_disjoint_copy(StubGenStubId::jshort_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_jshort_arraycopy                  = generate_conjoint_copy(StubGenStubId::jshort_arraycopy_id, entry, &entry_jshort_arraycopy);\n-    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jshort_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jshort_arraycopy_id, entry, nullptr);\n+    StubRoutines::_jshort_disjoint_arraycopy         = generate_disjoint_copy(StubId::stubgen_jshort_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jshort_arraycopy                  = generate_conjoint_copy(StubId::stubgen_jshort_arraycopy_id, entry, &entry_jshort_arraycopy);\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jshort_arraycopy_id, entry, nullptr);\n@@ -2765,2 +2765,2 @@\n-    StubRoutines::_arrayof_jint_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jint_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jint_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jint_arraycopy_id, entry, &entry_jint_arraycopy);\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jint_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jint_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jint_arraycopy_id, entry, &entry_jint_arraycopy);\n@@ -2769,2 +2769,2 @@\n-    StubRoutines::_jint_disjoint_arraycopy         = generate_disjoint_copy(StubGenStubId::jint_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_jint_arraycopy                  = generate_conjoint_copy(StubGenStubId::jint_arraycopy_id, entry, &entry_jint_arraycopy);\n+    StubRoutines::_jint_disjoint_arraycopy         = generate_disjoint_copy(StubId::stubgen_jint_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jint_arraycopy                  = generate_conjoint_copy(StubId::stubgen_jint_arraycopy_id, entry, &entry_jint_arraycopy);\n@@ -2774,2 +2774,2 @@\n-    StubRoutines::_arrayof_jlong_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jlong_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jlong_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jlong_arraycopy_id, entry, &entry_jlong_arraycopy);\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jlong_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jlong_arraycopy_id, entry, &entry_jlong_arraycopy);\n@@ -2786,1 +2786,1 @@\n-        = generate_disjoint_copy(StubGenStubId::arrayof_oop_disjoint_arraycopy_id, &entry);\n+        = generate_disjoint_copy(StubId::stubgen_arrayof_oop_disjoint_arraycopy_id, &entry);\n@@ -2788,1 +2788,1 @@\n-        = generate_conjoint_copy(StubGenStubId::arrayof_oop_arraycopy_id, entry, &entry_oop_arraycopy);\n+        = generate_conjoint_copy(StubId::stubgen_arrayof_oop_arraycopy_id, entry, &entry_oop_arraycopy);\n@@ -2791,1 +2791,1 @@\n-        = generate_disjoint_copy(StubGenStubId::arrayof_oop_disjoint_arraycopy_uninit_id, &entry);\n+        = generate_disjoint_copy(StubId::stubgen_arrayof_oop_disjoint_arraycopy_uninit_id, &entry);\n@@ -2793,1 +2793,1 @@\n-        = generate_conjoint_copy(StubGenStubId::arrayof_oop_arraycopy_uninit_id, entry, nullptr);\n+        = generate_conjoint_copy(StubId::stubgen_arrayof_oop_arraycopy_uninit_id, entry, nullptr);\n@@ -2801,2 +2801,2 @@\n-    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_id, &entry_checkcast_arraycopy);\n-    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_uninit_id, nullptr);\n+    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubId::stubgen_checkcast_arraycopy_id, &entry_checkcast_arraycopy);\n+    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubId::stubgen_checkcast_arraycopy_uninit_id, nullptr);\n@@ -2816,6 +2816,6 @@\n-    StubRoutines::_jbyte_fill = generate_fill(StubGenStubId::jbyte_fill_id);\n-    StubRoutines::_jshort_fill = generate_fill(StubGenStubId::jshort_fill_id);\n-    StubRoutines::_jint_fill = generate_fill(StubGenStubId::jint_fill_id);\n-    StubRoutines::_arrayof_jbyte_fill = generate_fill(StubGenStubId::arrayof_jbyte_fill_id);\n-    StubRoutines::_arrayof_jshort_fill = generate_fill(StubGenStubId::arrayof_jshort_fill_id);\n-    StubRoutines::_arrayof_jint_fill = generate_fill(StubGenStubId::arrayof_jint_fill_id);\n+    StubRoutines::_jbyte_fill = generate_fill(StubId::stubgen_jbyte_fill_id);\n+    StubRoutines::_jshort_fill = generate_fill(StubId::stubgen_jshort_fill_id);\n+    StubRoutines::_jint_fill = generate_fill(StubId::stubgen_jint_fill_id);\n+    StubRoutines::_arrayof_jbyte_fill = generate_fill(StubId::stubgen_arrayof_jbyte_fill_id);\n+    StubRoutines::_arrayof_jshort_fill = generate_fill(StubId::stubgen_arrayof_jshort_fill_id);\n+    StubRoutines::_arrayof_jint_fill = generate_fill(StubId::stubgen_arrayof_jint_fill_id);\n@@ -2835,1 +2835,1 @@\n-    StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+    StubId stub_id = StubId::stubgen_aescrypt_encryptBlock_id;\n@@ -2869,1 +2869,1 @@\n-    StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+    StubId stub_id = StubId::stubgen_aescrypt_decryptBlock_id;\n@@ -2908,1 +2908,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_encryptAESCrypt_id;\n+    StubId stub_id = StubId::stubgen_cipherBlockChaining_encryptAESCrypt_id;\n@@ -3013,1 +3013,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_decryptAESCrypt_id;\n+    StubId stub_id = StubId::stubgen_cipherBlockChaining_decryptAESCrypt_id;\n@@ -3200,1 +3200,1 @@\n-    StubGenStubId stub_id = StubGenStubId::counterMode_AESCrypt_id;\n+    StubId stub_id = StubId::stubgen_counterMode_AESCrypt_id;\n@@ -3410,1 +3410,1 @@\n-    StubGenStubId stub_id = StubGenStubId::galoisCounterMode_AESCrypt_id;\n+    StubId stub_id = StubId::stubgen_galoisCounterMode_AESCrypt_id;\n@@ -3620,1 +3620,1 @@\n-  address generate_md5_implCompress(StubGenStubId stub_id) {\n+  address generate_md5_implCompress(StubId stub_id) {\n@@ -3623,1 +3623,1 @@\n-    case md5_implCompress_id:\n+    case StubId::stubgen_md5_implCompress_id:\n@@ -3626,1 +3626,1 @@\n-    case md5_implCompressMB_id:\n+    case StubId::stubgen_md5_implCompressMB_id:\n@@ -3773,1 +3773,1 @@\n-  address generate_sha1_implCompress(StubGenStubId stub_id) {\n+  address generate_sha1_implCompress(StubId stub_id) {\n@@ -3776,1 +3776,1 @@\n-    case sha1_implCompress_id:\n+    case StubId::stubgen_sha1_implCompress_id:\n@@ -3779,1 +3779,1 @@\n-    case sha1_implCompressMB_id:\n+    case StubId::stubgen_sha1_implCompressMB_id:\n@@ -3878,1 +3878,1 @@\n-  address generate_sha256_implCompress(StubGenStubId stub_id) {\n+  address generate_sha256_implCompress(StubId stub_id) {\n@@ -3881,1 +3881,1 @@\n-    case sha256_implCompress_id:\n+    case StubId::stubgen_sha256_implCompress_id:\n@@ -3884,1 +3884,1 @@\n-    case sha256_implCompressMB_id:\n+    case StubId::stubgen_sha256_implCompressMB_id:\n@@ -4034,1 +4034,1 @@\n-  address generate_sha512_implCompress(StubGenStubId stub_id) {\n+  address generate_sha512_implCompress(StubId stub_id) {\n@@ -4037,1 +4037,1 @@\n-    case sha512_implCompress_id:\n+    case StubId::stubgen_sha512_implCompress_id:\n@@ -4040,1 +4040,1 @@\n-    case sha512_implCompressMB_id:\n+    case StubId::stubgen_sha512_implCompressMB_id:\n@@ -4284,1 +4284,1 @@\n-  address generate_sha3_implCompress(StubGenStubId stub_id) {\n+  address generate_sha3_implCompress(StubId stub_id) {\n@@ -4287,1 +4287,1 @@\n-    case sha3_implCompress_id:\n+    case StubId::stubgen_sha3_implCompress_id:\n@@ -4290,1 +4290,1 @@\n-    case sha3_implCompressMB_id:\n+    case StubId::stubgen_sha3_implCompressMB_id:\n@@ -4570,1 +4570,1 @@\n-    StubGenStubId stub_id = StubGenStubId::chacha20Block_id;\n+    StubId stub_id = StubId::stubgen_chacha20Block_id;\n@@ -5206,1 +5206,1 @@\n-    StubGenStubId stub_id = StubGenStubId::kyberNtt_id;\n+    StubId stub_id = StubId::stubgen_kyberNtt_id;\n@@ -5444,1 +5444,1 @@\n-    StubGenStubId stub_id = StubGenStubId::kyberInverseNtt_id;\n+    StubId stub_id = StubId::stubgen_kyberInverseNtt_id;\n@@ -5731,1 +5731,1 @@\n-    StubGenStubId stub_id = StubGenStubId::kyberNttMult_id;\n+    StubId stub_id = StubId::stubgen_kyberNttMult_id;\n@@ -5848,1 +5848,1 @@\n-    StubGenStubId stub_id = StubGenStubId::kyberAddPoly_2_id;\n+    StubId stub_id = StubId::stubgen_kyberAddPoly_2_id;\n@@ -5933,1 +5933,1 @@\n-    StubGenStubId stub_id = StubGenStubId::kyberAddPoly_3_id;\n+    StubId stub_id = StubId::stubgen_kyberAddPoly_3_id;\n@@ -6041,1 +6041,1 @@\n-    StubGenStubId stub_id = StubGenStubId::kyber12To16_id;\n+    StubId stub_id = StubId::stubgen_kyber12To16_id;\n@@ -6244,1 +6244,1 @@\n-    StubGenStubId stub_id = StubGenStubId::kyberBarrettReduce_id;\n+    StubId stub_id = StubId::stubgen_kyberBarrettReduce_id;\n@@ -6491,1 +6491,1 @@\n-    StubGenStubId stub_id = StubGenStubId::dilithiumAlmostNtt_id;\n+    StubId stub_id = StubId::stubgen_dilithiumAlmostNtt_id;\n@@ -6698,1 +6698,1 @@\n-    StubGenStubId stub_id = StubGenStubId::dilithiumAlmostInverseNtt_id;\n+    StubId stub_id = StubId::stubgen_dilithiumAlmostInverseNtt_id;\n@@ -6811,1 +6811,1 @@\n-    StubGenStubId stub_id = StubGenStubId::dilithiumNttMult_id;\n+    StubId stub_id = StubId::stubgen_dilithiumNttMult_id;\n@@ -6875,1 +6875,1 @@\n-    StubGenStubId stub_id = StubGenStubId::dilithiumMontMulByConstant_id;\n+    StubId stub_id = StubId::stubgen_dilithiumMontMulByConstant_id;\n@@ -6939,1 +6939,1 @@\n-    StubGenStubId stub_id = StubGenStubId::dilithiumDecomposePoly_id;\n+    StubId stub_id = StubId::stubgen_dilithiumDecomposePoly_id;\n@@ -7208,1 +7208,1 @@\n-  address generate_sha3_implCompress_gpr(StubGenStubId stub_id) {\n+  address generate_sha3_implCompress_gpr(StubId stub_id) {\n@@ -7211,1 +7211,1 @@\n-    case sha3_implCompress_id:\n+    case StubId::stubgen_sha3_implCompress_id:\n@@ -7214,1 +7214,1 @@\n-    case sha3_implCompressMB_id:\n+    case StubId::stubgen_sha3_implCompressMB_id:\n@@ -7459,1 +7459,1 @@\n-    StubGenStubId stub_id = StubGenStubId::updateBytesCRC32_id;\n+    StubId stub_id = StubId::stubgen_updateBytesCRC32_id;\n@@ -7501,1 +7501,1 @@\n-    StubGenStubId stub_id = StubGenStubId::updateBytesCRC32C_id;\n+    StubId stub_id = StubId::stubgen_updateBytesCRC32C_id;\n@@ -7540,1 +7540,1 @@\n-    StubGenStubId stub_id = StubGenStubId::updateBytesAdler32_id;\n+    StubId stub_id = StubId::stubgen_updateBytesAdler32_id;\n@@ -7762,1 +7762,1 @@\n-    StubGenStubId stub_id = StubGenStubId::multiplyToLen_id;\n+    StubId stub_id = StubId::stubgen_multiplyToLen_id;\n@@ -7795,1 +7795,1 @@\n-    StubGenStubId stub_id = StubGenStubId::squareToLen_id;\n+    StubId stub_id = StubId::stubgen_squareToLen_id;\n@@ -7829,1 +7829,1 @@\n-    StubGenStubId stub_id = StubGenStubId::mulAdd_id;\n+    StubId stub_id = StubId::stubgen_mulAdd_id;\n@@ -7860,1 +7860,1 @@\n-    StubGenStubId stub_id = StubGenStubId::bigIntegerRightShiftWorker_id;\n+    StubId stub_id = StubId::stubgen_bigIntegerRightShiftWorker_id;\n@@ -7983,1 +7983,1 @@\n-    StubGenStubId stub_id = StubGenStubId::bigIntegerLeftShiftWorker_id;\n+    StubId stub_id = StubId::stubgen_bigIntegerLeftShiftWorker_id;\n@@ -8092,1 +8092,1 @@\n-    StubGenStubId stub_id = StubGenStubId::count_positives_id;\n+    StubId stub_id = StubId::stubgen_count_positives_id;\n@@ -8354,1 +8354,1 @@\n-    StubGenStubId stub_id = StubGenStubId::large_array_equals_id;\n+    StubId stub_id = StubId::stubgen_large_array_equals_id;\n@@ -8480,1 +8480,1 @@\n-    StubGenStubId stub_id;\n+    StubId stub_id;\n@@ -8483,1 +8483,1 @@\n-      stub_id = StubGenStubId::large_arrays_hashcode_boolean_id;\n+      stub_id = StubId::stubgen_large_arrays_hashcode_boolean_id;\n@@ -8486,1 +8486,1 @@\n-      stub_id = StubGenStubId::large_arrays_hashcode_byte_id;\n+      stub_id = StubId::stubgen_large_arrays_hashcode_byte_id;\n@@ -8489,1 +8489,1 @@\n-      stub_id = StubGenStubId::large_arrays_hashcode_char_id;\n+      stub_id = StubId::stubgen_large_arrays_hashcode_char_id;\n@@ -8492,1 +8492,1 @@\n-      stub_id = StubGenStubId::large_arrays_hashcode_short_id;\n+      stub_id = StubId::stubgen_large_arrays_hashcode_short_id;\n@@ -8495,1 +8495,1 @@\n-      stub_id = StubGenStubId::large_arrays_hashcode_int_id;\n+      stub_id = StubId::stubgen_large_arrays_hashcode_int_id;\n@@ -8498,1 +8498,1 @@\n-      stub_id = StubGenStubId::NO_STUBID;\n+      stub_id = StubId::NO_STUBID;\n@@ -8741,1 +8741,1 @@\n-    StubGenStubId stub_id = (isCos ? StubGenStubId::dcos_id : StubGenStubId::dsin_id);\n+    StubId stub_id = (isCos ? StubId::stubgen_dcos_id : StubId::stubgen_dsin_id);\n@@ -8793,1 +8793,1 @@\n-    StubGenStubId stub_id = (isLU ? StubGenStubId::compare_long_string_LU_id : StubGenStubId::compare_long_string_UL_id);\n+    StubId stub_id = (isLU ? StubId::stubgen_compare_long_string_LU_id : StubId::stubgen_compare_long_string_UL_id);\n@@ -8903,1 +8903,1 @@\n-    StubGenStubId stub_id = StubGenStubId::hf2f_id;\n+    StubId stub_id = StubId::stubgen_hf2f_id;\n@@ -8917,1 +8917,1 @@\n-    StubGenStubId stub_id = StubGenStubId::f2hf_id;\n+    StubId stub_id = StubId::stubgen_f2hf_id;\n@@ -8928,1 +8928,1 @@\n-    StubGenStubId stub_id = StubGenStubId::method_entry_barrier_id;\n+    StubId stub_id = StubId::stubgen_method_entry_barrier_id;\n@@ -8994,1 +8994,1 @@\n-    StubGenStubId stub_id = (isLL ? StubGenStubId::compare_long_string_LL_id : StubGenStubId::compare_long_string_UU_id);\n+    StubId stub_id = (isLL ? StubId::stubgen_compare_long_string_LL_id : StubId::stubgen_compare_long_string_UU_id);\n@@ -9125,1 +9125,1 @@\n-    StubGenStubId stub_id;\n+    StubId stub_id;\n@@ -9127,4 +9127,4 @@\n-      case LL: stub_id = StubGenStubId::compare_long_string_LL_id;  break;\n-      case LU: stub_id = StubGenStubId::compare_long_string_LU_id; break;\n-      case UL: stub_id = StubGenStubId::compare_long_string_UL_id; break;\n-      case UU: stub_id = StubGenStubId::compare_long_string_UU_id; break;\n+      case LL: stub_id = StubId::stubgen_compare_long_string_LL_id;  break;\n+      case LU: stub_id = StubId::stubgen_compare_long_string_LU_id; break;\n+      case UL: stub_id = StubId::stubgen_compare_long_string_UL_id; break;\n+      case UU: stub_id = StubId::stubgen_compare_long_string_UU_id; break;\n@@ -9261,1 +9261,1 @@\n-    StubGenStubId stub_id;\n+    StubId stub_id;\n@@ -9264,1 +9264,1 @@\n-        stub_id = StubGenStubId::string_indexof_linear_ll_id;\n+        stub_id = StubId::stubgen_string_indexof_linear_ll_id;\n@@ -9266,1 +9266,1 @@\n-        stub_id = StubGenStubId::string_indexof_linear_ul_id;\n+        stub_id = StubId::stubgen_string_indexof_linear_ul_id;\n@@ -9272,1 +9272,1 @@\n-        stub_id = StubGenStubId::string_indexof_linear_uu_id;\n+        stub_id = StubId::stubgen_string_indexof_linear_uu_id;\n@@ -9574,1 +9574,1 @@\n-    StubGenStubId stub_id = StubGenStubId::large_byte_array_inflate_id;\n+    StubId stub_id = StubId::stubgen_large_byte_array_inflate_id;\n@@ -9640,1 +9640,1 @@\n-    StubGenStubId stub_id = StubGenStubId::ghash_processBlocks_id;\n+    StubId stub_id = StubId::stubgen_ghash_processBlocks_id;\n@@ -9707,1 +9707,1 @@\n-    StubGenStubId stub_id = StubGenStubId::ghash_processBlocks_wide_id;\n+    StubId stub_id = StubId::stubgen_ghash_processBlocks_wide_id;\n@@ -9819,1 +9819,1 @@\n-    StubGenStubId stub_id = StubGenStubId::base64_encodeBlock_id;\n+    StubId stub_id = StubId::stubgen_base64_encodeBlock_id;\n@@ -10088,1 +10088,1 @@\n-    StubGenStubId stub_id = StubGenStubId::base64_decodeBlock_id;\n+    StubId stub_id = StubId::stubgen_base64_decodeBlock_id;\n@@ -10205,1 +10205,1 @@\n-    StubGenStubId stub_id = StubGenStubId::spin_wait_id;\n+    StubId stub_id = StubId::stubgen_spin_wait_id;\n@@ -10216,1 +10216,1 @@\n-    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n+    StubId stub_id = StubId::stubgen_lookup_secondary_supers_table_id;\n@@ -10245,1 +10245,1 @@\n-    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_slow_path_id;\n+    StubId stub_id = StubId::stubgen_lookup_secondary_supers_table_slow_path_id;\n@@ -10400,1 +10400,1 @@\n-    StubGenStubId stub_id = StubGenStubId::atomic_entry_points_id;\n+    StubId stub_id = StubId::stubgen_atomic_entry_points_id;\n@@ -10560,1 +10560,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cont_thaw_id;\n+    StubId stub_id = StubId::stubgen_cont_thaw_id;\n@@ -10571,1 +10571,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cont_returnBarrier_id;\n+    StubId stub_id = StubId::stubgen_cont_returnBarrier_id;\n@@ -10583,1 +10583,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cont_returnBarrierExc_id;\n+    StubId stub_id = StubId::stubgen_cont_returnBarrierExc_id;\n@@ -10594,1 +10594,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cont_preempt_id;\n+    StubId stub_id = StubId::stubgen_cont_preempt_id;\n@@ -10677,1 +10677,1 @@\n-    StubGenStubId stub_id = StubGenStubId::poly1305_processBlocks_id;\n+    StubId stub_id = StubId::stubgen_poly1305_processBlocks_id;\n@@ -10792,1 +10792,1 @@\n-    StubGenStubId stub_id = StubGenStubId::upcall_stub_exception_handler_id;\n+    StubId stub_id = StubId::stubgen_upcall_stub_exception_handler_id;\n@@ -10810,1 +10810,1 @@\n-    StubGenStubId stub_id = StubGenStubId::upcall_stub_load_target_id;\n+    StubId stub_id = StubId::stubgen_upcall_stub_load_target_id;\n@@ -11755,1 +11755,1 @@\n-      StubRoutines::aarch64::_vector_iota_indices = generate_iota_indices(StubGenStubId::vector_iota_indices_id);\n+      StubRoutines::aarch64::_vector_iota_indices = generate_iota_indices(StubId::stubgen_vector_iota_indices_id);\n@@ -11799,1 +11799,1 @@\n-      StubGenStubId stub_id = StubGenStubId::montgomeryMultiply_id;\n+      StubId stub_id = StubId::stubgen_montgomeryMultiply_id;\n@@ -11806,1 +11806,1 @@\n-      StubGenStubId stub_id = StubGenStubId::montgomerySquare_id;\n+      StubId stub_id = StubId::stubgen_montgomerySquare_id;\n@@ -11863,2 +11863,2 @@\n-      StubRoutines::_md5_implCompress      = generate_md5_implCompress(StubGenStubId::md5_implCompress_id);\n-      StubRoutines::_md5_implCompressMB    = generate_md5_implCompress(StubGenStubId::md5_implCompressMB_id);\n+      StubRoutines::_md5_implCompress      = generate_md5_implCompress(StubId::stubgen_md5_implCompress_id);\n+      StubRoutines::_md5_implCompressMB    = generate_md5_implCompress(StubId::stubgen_md5_implCompressMB_id);\n@@ -11867,2 +11867,2 @@\n-      StubRoutines::_sha1_implCompress     = generate_sha1_implCompress(StubGenStubId::sha1_implCompress_id);\n-      StubRoutines::_sha1_implCompressMB   = generate_sha1_implCompress(StubGenStubId::sha1_implCompressMB_id);\n+      StubRoutines::_sha1_implCompress     = generate_sha1_implCompress(StubId::stubgen_sha1_implCompress_id);\n+      StubRoutines::_sha1_implCompressMB   = generate_sha1_implCompress(StubId::stubgen_sha1_implCompressMB_id);\n@@ -11871,2 +11871,2 @@\n-      StubRoutines::_sha256_implCompress   = generate_sha256_implCompress(StubGenStubId::sha256_implCompress_id);\n-      StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(StubGenStubId::sha256_implCompressMB_id);\n+      StubRoutines::_sha256_implCompress   = generate_sha256_implCompress(StubId::stubgen_sha256_implCompress_id);\n+      StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(StubId::stubgen_sha256_implCompressMB_id);\n@@ -11875,2 +11875,2 @@\n-      StubRoutines::_sha512_implCompress   = generate_sha512_implCompress(StubGenStubId::sha512_implCompress_id);\n-      StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(StubGenStubId::sha512_implCompressMB_id);\n+      StubRoutines::_sha512_implCompress   = generate_sha512_implCompress(StubId::stubgen_sha512_implCompress_id);\n+      StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(StubId::stubgen_sha512_implCompressMB_id);\n@@ -11882,2 +11882,2 @@\n-         StubRoutines::_sha3_implCompress     = generate_sha3_implCompress(StubGenStubId::sha3_implCompress_id);\n-         StubRoutines::_sha3_implCompressMB   = generate_sha3_implCompress(StubGenStubId::sha3_implCompressMB_id);\n+         StubRoutines::_sha3_implCompress     = generate_sha3_implCompress(StubId::stubgen_sha3_implCompress_id);\n+         StubRoutines::_sha3_implCompressMB   = generate_sha3_implCompress(StubId::stubgen_sha3_implCompressMB_id);\n@@ -11885,2 +11885,2 @@\n-         StubRoutines::_sha3_implCompress     = generate_sha3_implCompress_gpr(StubGenStubId::sha3_implCompress_id);\n-         StubRoutines::_sha3_implCompressMB   = generate_sha3_implCompress_gpr(StubGenStubId::sha3_implCompressMB_id);\n+         StubRoutines::_sha3_implCompress     = generate_sha3_implCompress_gpr(StubId::stubgen_sha3_implCompress_id);\n+         StubRoutines::_sha3_implCompressMB   = generate_sha3_implCompress_gpr(StubId::stubgen_sha3_implCompressMB_id);\n@@ -11903,1 +11903,1 @@\n-  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+  StubGenerator(CodeBuffer* code, BlobId blob_id) : StubCodeGenerator(code, blob_id) {\n@@ -11905,1 +11905,1 @@\n-    case preuniverse_id:\n+    case BlobId::stubgen_preuniverse_id:\n@@ -11908,1 +11908,1 @@\n-    case initial_id:\n+    case BlobId::stubgen_initial_id:\n@@ -11911,1 +11911,1 @@\n-     case continuation_id:\n+     case BlobId::stubgen_continuation_id:\n@@ -11914,1 +11914,1 @@\n-    case compiler_id:\n+    case BlobId::stubgen_compiler_id:\n@@ -11917,1 +11917,1 @@\n-    case final_id:\n+    case BlobId::stubgen_final_id:\n@@ -11921,1 +11921,1 @@\n-      fatal(\"unexpected blob id: %d\", blob_id);\n+      fatal(\"unexpected blob id: %s\", StubInfo::name(blob_id));\n@@ -11927,1 +11927,1 @@\n-void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+void StubGenerator_generate(CodeBuffer* code, BlobId blob_id) {\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":196,"deletions":196,"binary":false,"changes":392,"status":"modified"},{"patch":"@@ -3638,1 +3638,0 @@\n-    assert(is_aligned(header_size, BytesPerLong), \"oop header size must be 8-byte-aligned\");\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  __ call(Runtime1::entry_for(C1StubId::counter_overflow_id), relocInfo::runtime_call_type);\n+  __ call(Runtime1::entry_for(StubId::c1_counter_overflow_id), relocInfo::runtime_call_type);\n@@ -59,1 +59,1 @@\n-    __ call(Runtime1::entry_for(C1StubId::predicate_failed_trap_id), relocInfo::runtime_call_type);\n+    __ call(Runtime1::entry_for(StubId::c1_predicate_failed_trap_id), relocInfo::runtime_call_type);\n@@ -75,1 +75,1 @@\n-    __ call(Runtime1::entry_for(C1StubId::throw_index_exception_id), relocInfo::runtime_call_type);\n+    __ call(Runtime1::entry_for(StubId::c1_throw_index_exception_id), relocInfo::runtime_call_type);\n@@ -78,1 +78,1 @@\n-    __ call(Runtime1::entry_for(C1StubId::throw_range_check_failed_id), relocInfo::runtime_call_type);\n+    __ call(Runtime1::entry_for(StubId::c1_throw_range_check_failed_id), relocInfo::runtime_call_type);\n@@ -91,1 +91,1 @@\n-  __ call(Runtime1::entry_for(C1StubId::predicate_failed_trap_id), relocInfo::runtime_call_type);\n+  __ call(Runtime1::entry_for(StubId::c1_predicate_failed_trap_id), relocInfo::runtime_call_type);\n@@ -102,1 +102,1 @@\n-  __ call(Runtime1::entry_for(C1StubId::throw_div0_exception_id),\n+  __ call(Runtime1::entry_for(StubId::c1_throw_div0_exception_id),\n@@ -111,1 +111,1 @@\n-NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, C1StubId stub_id) {\n+NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, StubId stub_id) {\n@@ -116,3 +116,3 @@\n-  assert(stub_id == C1StubId::new_instance_id                 ||\n-         stub_id == C1StubId::fast_new_instance_id            ||\n-         stub_id == C1StubId::fast_new_instance_init_check_id,\n+  assert(stub_id == StubId::c1_new_instance_id                 ||\n+         stub_id == StubId::c1_fast_new_instance_id            ||\n+         stub_id == StubId::c1_fast_new_instance_init_check_id,\n@@ -150,1 +150,1 @@\n-  __ call(Runtime1::entry_for(C1StubId::new_type_array_id), relocInfo::runtime_call_type);\n+  __ call(Runtime1::entry_for(StubId::c1_new_type_array_id), relocInfo::runtime_call_type);\n@@ -172,1 +172,1 @@\n-  __ call(Runtime1::entry_for(C1StubId::new_object_array_id), relocInfo::runtime_call_type);\n+  __ call(Runtime1::entry_for(StubId::c1_new_object_array_id), relocInfo::runtime_call_type);\n@@ -191,3 +191,3 @@\n-  C1StubId enter_id = ce->compilation()->has_fpu_code() ?\n-                              C1StubId::monitorenter_id :\n-                              C1StubId::monitorenter_nofpu_id;\n+  StubId enter_id = ce->compilation()->has_fpu_code() ?\n+                              StubId::c1_monitorenter_id :\n+                              StubId::c1_monitorenter_nofpu_id;\n@@ -212,3 +212,3 @@\n-  C1StubId exit_id = ce->compilation()->has_fpu_code() ?\n-                             C1StubId::monitorexit_id :\n-                             C1StubId::monitorexit_nofpu_id;\n+  StubId exit_id = ce->compilation()->has_fpu_code() ?\n+                             StubId::c1_monitorexit_id :\n+                             StubId::c1_monitorexit_nofpu_id;\n@@ -324,4 +324,4 @@\n-    case access_field_id:  target = Runtime1::entry_for(C1StubId::access_field_patching_id); break;\n-    case load_klass_id:    target = Runtime1::entry_for(C1StubId::load_klass_patching_id); reloc_type = relocInfo::metadata_type; break;\n-    case load_mirror_id:   target = Runtime1::entry_for(C1StubId::load_mirror_patching_id); reloc_type = relocInfo::oop_type; break;\n-    case load_appendix_id: target = Runtime1::entry_for(C1StubId::load_appendix_patching_id); reloc_type = relocInfo::oop_type; break;\n+    case access_field_id:  target = Runtime1::entry_for(StubId::c1_access_field_patching_id); break;\n+    case load_klass_id:    target = Runtime1::entry_for(StubId::c1_load_klass_patching_id); reloc_type = relocInfo::metadata_type; break;\n+    case load_mirror_id:   target = Runtime1::entry_for(StubId::c1_load_mirror_patching_id); reloc_type = relocInfo::oop_type; break;\n+    case load_appendix_id: target = Runtime1::entry_for(StubId::c1_load_appendix_patching_id); reloc_type = relocInfo::oop_type; break;\n@@ -353,1 +353,1 @@\n-  __ call(Runtime1::entry_for(C1StubId::deoptimize_id), relocInfo::runtime_call_type);\n+  __ call(Runtime1::entry_for(StubId::c1_deoptimize_id), relocInfo::runtime_call_type);\n@@ -364,1 +364,1 @@\n-    a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+    a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -366,1 +366,1 @@\n-    a = Runtime1::entry_for(C1StubId::throw_null_pointer_exception_id);\n+    a = Runtime1::entry_for(StubId::c1_throw_null_pointer_exception_id);\n","filename":"src\/hotspot\/cpu\/arm\/c1_CodeStubs_arm.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-  __ call(Runtime1::entry_for(C1StubId::handle_exception_from_callee_id), relocInfo::runtime_call_type);\n+  __ call(Runtime1::entry_for(StubId::c1_handle_exception_from_callee_id), relocInfo::runtime_call_type);\n@@ -255,1 +255,1 @@\n-  __ jump(Runtime1::entry_for(C1StubId::unwind_exception_id), relocInfo::runtime_call_type, Rtemp);\n+  __ jump(Runtime1::entry_for(StubId::c1_unwind_exception_id), relocInfo::runtime_call_type, Rtemp);\n@@ -1139,1 +1139,1 @@\n-      __ call(Runtime1::entry_for(C1StubId::slow_subtype_check_id), relocInfo::runtime_call_type);\n+      __ call(Runtime1::entry_for(StubId::c1_slow_subtype_check_id), relocInfo::runtime_call_type);\n@@ -1213,1 +1213,1 @@\n-          __ call(Runtime1::entry_for(C1StubId::slow_subtype_check_id), relocInfo::runtime_call_type);\n+          __ call(Runtime1::entry_for(StubId::c1_slow_subtype_check_id), relocInfo::runtime_call_type);\n@@ -1230,1 +1230,1 @@\n-        __ call(Runtime1::entry_for(C1StubId::slow_subtype_check_id), relocInfo::runtime_call_type);\n+        __ call(Runtime1::entry_for(StubId::c1_slow_subtype_check_id), relocInfo::runtime_call_type);\n@@ -1306,1 +1306,1 @@\n-          __ call(Runtime1::entry_for(C1StubId::slow_subtype_check_id), relocInfo::runtime_call_type);\n+          __ call(Runtime1::entry_for(StubId::c1_slow_subtype_check_id), relocInfo::runtime_call_type);\n@@ -1337,1 +1337,1 @@\n-        __ call(Runtime1::entry_for(C1StubId::slow_subtype_check_id), relocInfo::runtime_call_type);\n+        __ call(Runtime1::entry_for(StubId::c1_slow_subtype_check_id), relocInfo::runtime_call_type);\n@@ -1984,3 +1984,3 @@\n-  C1StubId handle_id = compilation()->has_fpu_code() ?\n-                               C1StubId::handle_exception_id :\n-                               C1StubId::handle_exception_nofpu_id;\n+  StubId handle_id = compilation()->has_fpu_code() ?\n+                               StubId::c1_handle_exception_id :\n+                               StubId::c1_handle_exception_nofpu_id;\n@@ -2263,1 +2263,1 @@\n-      __ call(Runtime1::entry_for(C1StubId::slow_subtype_check_id), relocInfo::runtime_call_type); \/\/ does not blow any registers except R0, LR and Rtemp\n+      __ call(Runtime1::entry_for(StubId::c1_slow_subtype_check_id), relocInfo::runtime_call_type); \/\/ does not blow any registers except R0, LR and Rtemp\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1060,1 +1060,1 @@\n-  __ call_runtime(Runtime1::entry_for(C1StubId::new_multi_array_id),\n+  __ call_runtime(Runtime1::entry_for(StubId::c1_new_multi_array_id),\n@@ -1089,1 +1089,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_incompatible_class_change_error_id,\n+    stub = new SimpleExceptionStub(StubId::c1_throw_incompatible_class_change_error_id,\n@@ -1097,1 +1097,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_class_cast_exception_id,\n+    stub = new SimpleExceptionStub(StubId::c1_throw_class_cast_exception_id,\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRGenerator_arm.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-  if (_stub_id != (int)C1StubId::forward_exception_id) {\n+  if (_stub_id != (int)StubId::c1_forward_exception_id) {\n@@ -83,1 +83,1 @@\n-  if (_stub_id != (int)C1StubId::forward_exception_id) {\n+  if (_stub_id != (int)StubId::c1_forward_exception_id) {\n@@ -86,1 +86,1 @@\n-    jump(Runtime1::entry_for(C1StubId::forward_exception_id), relocInfo::runtime_call_type, Rtemp, ne);\n+    jump(Runtime1::entry_for(StubId::c1_forward_exception_id), relocInfo::runtime_call_type, Rtemp, ne);\n@@ -286,1 +286,1 @@\n-OopMapSet* Runtime1::generate_handle_exception(C1StubId id, StubAssembler* sasm) {\n+OopMapSet* Runtime1::generate_handle_exception(StubId id, StubAssembler* sasm) {\n@@ -296,1 +296,1 @@\n-  case C1StubId::forward_exception_id: {\n+  case StubId::c1_forward_exception_id: {\n@@ -305,1 +305,1 @@\n-  case C1StubId::handle_exception_id:\n+  case StubId::c1_handle_exception_id:\n@@ -308,1 +308,1 @@\n-  case C1StubId::handle_exception_nofpu_id:\n+  case StubId::c1_handle_exception_nofpu_id:\n@@ -312,1 +312,1 @@\n-  case C1StubId::handle_exception_from_callee_id:\n+  case StubId::c1_handle_exception_from_callee_id:\n@@ -334,3 +334,3 @@\n-  case C1StubId::forward_exception_id:\n-  case C1StubId::handle_exception_nofpu_id:\n-  case C1StubId::handle_exception_id:\n+  case StubId::c1_forward_exception_id:\n+  case StubId::c1_handle_exception_nofpu_id:\n+  case StubId::c1_handle_exception_id:\n@@ -340,1 +340,1 @@\n-  case C1StubId::handle_exception_from_callee_id:\n+  case StubId::c1_handle_exception_from_callee_id:\n@@ -409,1 +409,1 @@\n-OopMapSet* Runtime1::generate_code_for(C1StubId id, StubAssembler* sasm) {\n+OopMapSet* Runtime1::generate_code_for(StubId id, StubAssembler* sasm) {\n@@ -417,1 +417,1 @@\n-    case C1StubId::forward_exception_id:\n+    case StubId::c1_forward_exception_id:\n@@ -424,3 +424,3 @@\n-    case C1StubId::new_instance_id:\n-    case C1StubId::fast_new_instance_id:\n-    case C1StubId::fast_new_instance_init_check_id:\n+    case StubId::c1_new_instance_id:\n+    case StubId::c1_fast_new_instance_id:\n+    case StubId::c1_fast_new_instance_init_check_id:\n@@ -442,1 +442,1 @@\n-    case C1StubId::counter_overflow_id:\n+    case StubId::c1_counter_overflow_id:\n@@ -454,2 +454,2 @@\n-    case C1StubId::new_type_array_id:\n-    case C1StubId::new_object_array_id:\n+    case StubId::c1_new_type_array_id:\n+    case StubId::c1_new_object_array_id:\n@@ -457,1 +457,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -469,1 +469,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -483,1 +483,1 @@\n-    case C1StubId::new_multi_array_id:\n+    case StubId::c1_new_multi_array_id:\n@@ -506,1 +506,1 @@\n-    case C1StubId::register_finalizer_id:\n+    case StubId::c1_register_finalizer_id:\n@@ -527,1 +527,1 @@\n-    case C1StubId::throw_range_check_failed_id:\n+    case StubId::c1_throw_range_check_failed_id:\n@@ -534,1 +534,1 @@\n-    case C1StubId::throw_index_exception_id:\n+    case StubId::c1_throw_index_exception_id:\n@@ -541,1 +541,1 @@\n-    case C1StubId::throw_div0_exception_id:\n+    case StubId::c1_throw_div0_exception_id:\n@@ -548,1 +548,1 @@\n-    case C1StubId::throw_null_pointer_exception_id:\n+    case StubId::c1_throw_null_pointer_exception_id:\n@@ -555,2 +555,2 @@\n-    case C1StubId::handle_exception_nofpu_id:\n-    case C1StubId::handle_exception_id:\n+    case StubId::c1_handle_exception_nofpu_id:\n+    case StubId::c1_handle_exception_id:\n@@ -563,1 +563,1 @@\n-    case C1StubId::handle_exception_from_callee_id:\n+    case StubId::c1_handle_exception_from_callee_id:\n@@ -570,1 +570,1 @@\n-    case C1StubId::unwind_exception_id:\n+    case StubId::c1_unwind_exception_id:\n@@ -577,1 +577,1 @@\n-    case C1StubId::throw_array_store_exception_id:\n+    case StubId::c1_throw_array_store_exception_id:\n@@ -584,1 +584,1 @@\n-    case C1StubId::throw_class_cast_exception_id:\n+    case StubId::c1_throw_class_cast_exception_id:\n@@ -591,1 +591,1 @@\n-    case C1StubId::throw_incompatible_class_change_error_id:\n+    case StubId::c1_throw_incompatible_class_change_error_id:\n@@ -598,1 +598,1 @@\n-    case C1StubId::slow_subtype_check_id:\n+    case StubId::c1_slow_subtype_check_id:\n@@ -631,1 +631,1 @@\n-    case C1StubId::monitorenter_nofpu_id:\n+    case StubId::c1_monitorenter_nofpu_id:\n@@ -634,1 +634,1 @@\n-    case C1StubId::monitorenter_id:\n+    case StubId::c1_monitorenter_id:\n@@ -649,1 +649,1 @@\n-    case C1StubId::monitorexit_nofpu_id:\n+    case StubId::c1_monitorexit_nofpu_id:\n@@ -652,1 +652,1 @@\n-    case C1StubId::monitorexit_id:\n+    case StubId::c1_monitorexit_id:\n@@ -665,1 +665,1 @@\n-    case C1StubId::deoptimize_id:\n+    case StubId::c1_deoptimize_id:\n@@ -681,1 +681,1 @@\n-    case C1StubId::access_field_patching_id:\n+    case StubId::c1_access_field_patching_id:\n@@ -688,1 +688,1 @@\n-    case C1StubId::load_klass_patching_id:\n+    case StubId::c1_load_klass_patching_id:\n@@ -695,1 +695,1 @@\n-    case C1StubId::load_appendix_patching_id:\n+    case StubId::c1_load_appendix_patching_id:\n@@ -702,1 +702,1 @@\n-    case C1StubId::load_mirror_patching_id:\n+    case StubId::c1_load_mirror_patching_id:\n@@ -709,1 +709,1 @@\n-    case C1StubId::predicate_failed_trap_id:\n+    case StubId::c1_predicate_failed_trap_id:\n","filename":"src\/hotspot\/cpu\/arm\/c1_Runtime1_arm.cpp","additions":46,"deletions":46,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n+  const char* name = OptoRuntime::stub_name(StubId::c2_uncommon_trap_id);\n@@ -213,1 +213,1 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n+  const char* name = OptoRuntime::stub_name(StubId::c2_exception_id);\n","filename":"src\/hotspot\/cpu\/arm\/runtime_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1369,1 +1369,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::deopt_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_deopt_id);\n@@ -1611,1 +1611,1 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(StubId id, address call_ptr) {\n@@ -1621,1 +1621,1 @@\n-  bool cause_return = (id == SharedStubId::polling_page_return_handler_id);\n+  bool cause_return = (id == StubId::shared_polling_page_return_handler_id);\n@@ -1683,1 +1683,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(StubId id, address destination) {\n@@ -1747,1 +1747,1 @@\n-RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+RuntimeStub* SharedRuntime::generate_throw_exception(StubId id, address runtime_entry) {\n@@ -1811,1 +1811,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_write_checkpoint_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_jfr_write_checkpoint_id);\n@@ -1855,1 +1855,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_return_lease_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_jfr_return_lease_id);\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  do_arch_entry(Arm, initial, atomic_load_long,                         \\\n+  do_arch_entry(Arm, initial, atomic_store_long,                        \\\n","filename":"src\/hotspot\/cpu\/arm\/stubDeclarations_arm.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-    StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+    StubId stub_id = StubId::stubgen_call_stub_id;\n@@ -255,1 +255,1 @@\n-    StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+    StubId stub_id = StubId::stubgen_catch_exception_id;\n@@ -268,1 +268,1 @@\n-    StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+    StubId stub_id = StubId::stubgen_forward_exception_id;\n@@ -318,1 +318,1 @@\n-    StubGenStubId stub_id = StubGenStubId::idiv_irem_id;\n+    StubId stub_id = StubId::stubgen_idiv_irem_id;\n@@ -461,1 +461,1 @@\n-    StubGenStubId stub_id = StubGenStubId::atomic_add_id;\n+    StubId stub_id = StubId::stubgen_atomic_add_id;\n@@ -513,1 +513,1 @@\n-    StubGenStubId stub_id = StubGenStubId::atomic_xchg_id;\n+    StubId stub_id = StubId::stubgen_atomic_xchg_id;\n@@ -564,1 +564,1 @@\n-    StubGenStubId stub_id = StubGenStubId::atomic_cmpxchg_id;\n+    StubId stub_id = StubId::stubgen_atomic_cmpxchg_id;\n@@ -603,1 +603,1 @@\n-    StubGenStubId stub_id = StubGenStubId::atomic_cmpxchg_long_id;\n+    StubId stub_id = StubId::stubgen_atomic_cmpxchg_long_id;\n@@ -641,1 +641,1 @@\n-    StubGenStubId stub_id = StubGenStubId::atomic_load_long_id;\n+    StubId stub_id = StubId::stubgen_atomic_load_long_id;\n@@ -666,1 +666,1 @@\n-    StubGenStubId stub_id = StubGenStubId::atomic_store_long_id;\n+    StubId stub_id = StubId::stubgen_atomic_store_long_id;\n@@ -709,1 +709,1 @@\n-    StubGenStubId stub_id = StubGenStubId::partial_subtype_check_id;\n+    StubId stub_id = StubId::stubgen_partial_subtype_check_id;\n@@ -799,1 +799,1 @@\n-    StubGenStubId stub_id = StubGenStubId::verify_oop_id;\n+    StubId stub_id = StubId::stubgen_verify_oop_id;\n@@ -2030,1 +2030,1 @@\n-  address generate_primitive_copy(StubGenStubId stub_id, address nooverlap_target = nullptr) {\n+  address generate_primitive_copy(StubId stub_id, address nooverlap_target = nullptr) {\n@@ -2037,1 +2037,1 @@\n-    case jbyte_disjoint_arraycopy_id:\n+    case StubId::stubgen_jbyte_disjoint_arraycopy_id:\n@@ -2043,1 +2043,1 @@\n-    case jshort_disjoint_arraycopy_id:\n+    case StubId::stubgen_jshort_disjoint_arraycopy_id:\n@@ -2049,1 +2049,1 @@\n-    case jint_disjoint_arraycopy_id:\n+    case StubId::stubgen_jint_disjoint_arraycopy_id:\n@@ -2055,1 +2055,1 @@\n-    case jlong_disjoint_arraycopy_id:\n+    case StubId::stubgen_jlong_disjoint_arraycopy_id:\n@@ -2061,1 +2061,1 @@\n-    case arrayof_jbyte_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id:\n@@ -2067,1 +2067,1 @@\n-    case arrayof_jshort_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id:\n@@ -2073,1 +2073,1 @@\n-    case arrayof_jint_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jint_disjoint_arraycopy_id:\n@@ -2079,1 +2079,1 @@\n-    case arrayof_jlong_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id:\n@@ -2085,1 +2085,1 @@\n-    case jbyte_arraycopy_id:\n+    case StubId::stubgen_jbyte_arraycopy_id:\n@@ -2091,1 +2091,1 @@\n-    case jshort_arraycopy_id:\n+    case StubId::stubgen_jshort_arraycopy_id:\n@@ -2097,1 +2097,1 @@\n-    case jint_arraycopy_id:\n+    case StubId::stubgen_jint_arraycopy_id:\n@@ -2103,1 +2103,1 @@\n-    case jlong_arraycopy_id:\n+    case StubId::stubgen_jlong_arraycopy_id:\n@@ -2109,1 +2109,1 @@\n-    case arrayof_jbyte_arraycopy_id:\n+    case StubId::stubgen_arrayof_jbyte_arraycopy_id:\n@@ -2115,1 +2115,1 @@\n-    case arrayof_jshort_arraycopy_id:\n+    case StubId::stubgen_arrayof_jshort_arraycopy_id:\n@@ -2121,1 +2121,1 @@\n-    case arrayof_jint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jint_arraycopy_id:\n@@ -2304,1 +2304,1 @@\n-  address generate_oop_copy(StubGenStubId stub_id, address nooverlap_target = nullptr) {\n+  address generate_oop_copy(StubId stub_id, address nooverlap_target = nullptr) {\n@@ -2310,1 +2310,1 @@\n-    case oop_disjoint_arraycopy_id:\n+    case StubId::stubgen_oop_disjoint_arraycopy_id:\n@@ -2315,1 +2315,1 @@\n-    case arrayof_oop_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_oop_disjoint_arraycopy_id:\n@@ -2320,1 +2320,1 @@\n-    case oop_arraycopy_id:\n+    case StubId::stubgen_oop_arraycopy_id:\n@@ -2325,1 +2325,1 @@\n-    case arrayof_oop_arraycopy_id:\n+    case StubId::stubgen_arrayof_oop_arraycopy_id:\n@@ -2479,1 +2479,1 @@\n-    StubGenStubId stub_id = StubGenStubId::unsafe_arraycopy_id;\n+    StubId stub_id = StubId::stubgen_unsafe_arraycopy_id;\n@@ -2607,1 +2607,1 @@\n-    StubGenStubId stub_id = StubGenStubId::checkcast_arraycopy_id;\n+    StubId stub_id = StubId::stubgen_checkcast_arraycopy_id;\n@@ -2775,1 +2775,1 @@\n-    StubGenStubId stub_id = StubGenStubId::generic_arraycopy_id;\n+    StubId stub_id = StubId::stubgen_generic_arraycopy_id;\n@@ -3011,11 +3011,11 @@\n-    StubRoutines::_jbyte_disjoint_arraycopy  = generate_primitive_copy(StubGenStubId::jbyte_disjoint_arraycopy_id);\n-    StubRoutines::_jshort_disjoint_arraycopy = generate_primitive_copy(StubGenStubId::jshort_disjoint_arraycopy_id);\n-    StubRoutines::_jint_disjoint_arraycopy   = generate_primitive_copy(StubGenStubId::jint_disjoint_arraycopy_id);\n-    StubRoutines::_jlong_disjoint_arraycopy  = generate_primitive_copy(StubGenStubId::jlong_disjoint_arraycopy_id);\n-    StubRoutines::_oop_disjoint_arraycopy    = generate_oop_copy      (StubGenStubId::oop_disjoint_arraycopy_id);\n-\n-    StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = generate_primitive_copy(StubGenStubId::arrayof_jbyte_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_primitive_copy(StubGenStubId::arrayof_jshort_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_jint_disjoint_arraycopy   = generate_primitive_copy(StubGenStubId::arrayof_jint_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_jlong_disjoint_arraycopy  = generate_primitive_copy(StubGenStubId::arrayof_jlong_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_oop_disjoint_arraycopy    = generate_oop_copy      (StubGenStubId::arrayof_oop_disjoint_arraycopy_id);\n+    StubRoutines::_jbyte_disjoint_arraycopy  = generate_primitive_copy(StubId::stubgen_jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_jshort_disjoint_arraycopy = generate_primitive_copy(StubId::stubgen_jshort_disjoint_arraycopy_id);\n+    StubRoutines::_jint_disjoint_arraycopy   = generate_primitive_copy(StubId::stubgen_jint_disjoint_arraycopy_id);\n+    StubRoutines::_jlong_disjoint_arraycopy  = generate_primitive_copy(StubId::stubgen_jlong_disjoint_arraycopy_id);\n+    StubRoutines::_oop_disjoint_arraycopy    = generate_oop_copy      (StubId::stubgen_oop_disjoint_arraycopy_id);\n+\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = generate_primitive_copy(StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_primitive_copy(StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy   = generate_primitive_copy(StubId::stubgen_arrayof_jint_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy  = generate_primitive_copy(StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy    = generate_oop_copy      (StubId::stubgen_arrayof_oop_disjoint_arraycopy_id);\n@@ -3024,8 +3024,8 @@\n-    StubRoutines::_jbyte_arraycopy  = generate_primitive_copy(StubGenStubId::jbyte_arraycopy_id, StubRoutines::_jbyte_disjoint_arraycopy);\n-    StubRoutines::_jshort_arraycopy = generate_primitive_copy(StubGenStubId::jshort_arraycopy_id, StubRoutines::_jshort_disjoint_arraycopy);\n-    StubRoutines::_jint_arraycopy   = generate_primitive_copy(StubGenStubId::jint_arraycopy_id, StubRoutines::_jint_disjoint_arraycopy);\n-    StubRoutines::_jlong_arraycopy  = generate_primitive_copy(StubGenStubId::jlong_arraycopy_id, StubRoutines::_jlong_disjoint_arraycopy);\n-    StubRoutines::_oop_arraycopy    = generate_oop_copy      (StubGenStubId::oop_arraycopy_id, StubRoutines::_oop_disjoint_arraycopy);\n-\n-    StubRoutines::_arrayof_jbyte_arraycopy    = generate_primitive_copy(StubGenStubId::arrayof_jbyte_arraycopy_id, StubRoutines::_arrayof_jbyte_disjoint_arraycopy);\n-    StubRoutines::_arrayof_jshort_arraycopy   = generate_primitive_copy(StubGenStubId::arrayof_jshort_arraycopy_id, StubRoutines::_arrayof_jshort_disjoint_arraycopy);\n+    StubRoutines::_jbyte_arraycopy  = generate_primitive_copy(StubId::stubgen_jbyte_arraycopy_id, StubRoutines::_jbyte_disjoint_arraycopy);\n+    StubRoutines::_jshort_arraycopy = generate_primitive_copy(StubId::stubgen_jshort_arraycopy_id, StubRoutines::_jshort_disjoint_arraycopy);\n+    StubRoutines::_jint_arraycopy   = generate_primitive_copy(StubId::stubgen_jint_arraycopy_id, StubRoutines::_jint_disjoint_arraycopy);\n+    StubRoutines::_jlong_arraycopy  = generate_primitive_copy(StubId::stubgen_jlong_arraycopy_id, StubRoutines::_jlong_disjoint_arraycopy);\n+    StubRoutines::_oop_arraycopy    = generate_oop_copy      (StubId::stubgen_oop_arraycopy_id, StubRoutines::_oop_disjoint_arraycopy);\n+\n+    StubRoutines::_arrayof_jbyte_arraycopy    = generate_primitive_copy(StubId::stubgen_arrayof_jbyte_arraycopy_id, StubRoutines::_arrayof_jbyte_disjoint_arraycopy);\n+    StubRoutines::_arrayof_jshort_arraycopy   = generate_primitive_copy(StubId::stubgen_arrayof_jshort_arraycopy_id, StubRoutines::_arrayof_jshort_disjoint_arraycopy);\n@@ -3034,1 +3034,1 @@\n-    StubRoutines::_arrayof_jint_arraycopy     = generate_primitive_copy(StubGenStubId::arrayof_jint_arraycopy_id, StubRoutines::_arrayof_jint_disjoint_arraycopy);\n+    StubRoutines::_arrayof_jint_arraycopy     = generate_primitive_copy(StubId::stubgen_arrayof_jint_arraycopy_id, StubRoutines::_arrayof_jint_disjoint_arraycopy);\n@@ -3039,1 +3039,1 @@\n-      StubRoutines::_arrayof_oop_arraycopy    = generate_oop_copy      (StubGenStubId::arrayof_oop_arraycopy_id, StubRoutines::_arrayof_oop_disjoint_arraycopy);\n+      StubRoutines::_arrayof_oop_arraycopy    = generate_oop_copy      (StubId::stubgen_arrayof_oop_arraycopy_id, StubRoutines::_arrayof_oop_disjoint_arraycopy);\n@@ -3054,1 +3054,1 @@\n-    StubGenStubId stub_id = StubGenStubId::method_entry_barrier_id;\n+    StubId stub_id = StubId::stubgen_method_entry_barrier_id;\n@@ -3108,1 +3108,1 @@\n-  address generate_cont_thaw(StubGenStubId stub_id) {\n+  address generate_cont_thaw(StubId stub_id) {\n@@ -3115,1 +3115,1 @@\n-    return generate_cont_thaw(StubGenStubId::cont_thaw_id);\n+    return generate_cont_thaw(StubId::stubgen_cont_thaw_id);\n@@ -3119,1 +3119,1 @@\n-    return generate_cont_thaw(StubGenStubId::cont_returnBarrier_id);\n+    return generate_cont_thaw(StubId::stubgen_cont_returnBarrier_id);\n@@ -3123,1 +3123,1 @@\n-    return generate_cont_thaw(StubGenStubId::cont_returnBarrierExc_id);\n+    return generate_cont_thaw(StubId::stubgen_cont_returnBarrierExc_id);\n@@ -3206,1 +3206,1 @@\n-  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+  StubGenerator(CodeBuffer* code, BlobId blob_id) : StubCodeGenerator(code, blob_id) {\n@@ -3208,1 +3208,1 @@\n-    case preuniverse_id:\n+    case BlobId::stubgen_preuniverse_id:\n@@ -3211,1 +3211,1 @@\n-    case initial_id:\n+    case BlobId::stubgen_initial_id:\n@@ -3214,1 +3214,1 @@\n-     case continuation_id:\n+     case BlobId::stubgen_continuation_id:\n@@ -3217,1 +3217,1 @@\n-    case compiler_id:\n+    case BlobId::stubgen_compiler_id:\n@@ -3220,1 +3220,1 @@\n-    case final_id:\n+    case BlobId::stubgen_final_id:\n@@ -3224,1 +3224,1 @@\n-      fatal(\"unexpected blob id: %d\", blob_id);\n+      fatal(\"unexpected blob id: %s\", StubInfo::name(blob_id));\n@@ -3230,1 +3230,1 @@\n-void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+void StubGenerator_generate(CodeBuffer* code, BlobId blob_id) {\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":70,"deletions":70,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,1 +122,1 @@\n-  StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+  StubId stub_id = StubId::stubgen_aescrypt_encryptBlock_id;\n@@ -320,1 +320,1 @@\n-  StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+  StubId stub_id = StubId::stubgen_aescrypt_decryptBlock_id;\n@@ -541,1 +541,1 @@\n-  StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_encryptAESCrypt_id;\n+  StubId stub_id = StubId::stubgen_cipherBlockChaining_encryptAESCrypt_id;\n@@ -607,1 +607,1 @@\n-  StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_decryptAESCrypt_id;\n+  StubId stub_id = StubId::stubgen_cipherBlockChaining_decryptAESCrypt_id;\n","filename":"src\/hotspot\/cpu\/arm\/stubRoutinesCrypto_arm.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -760,0 +760,1 @@\n+    VNEGW_OPCODE   = (4u  << OPCODE_SHIFT |  6u << 16 | 1538u),\n@@ -2375,0 +2376,1 @@\n+  inline void vnegw(    VectorRegister d, VectorRegister b);\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1095,0 +1095,3 @@\n+\/\/ Vector Negate Word (introduced with Power 9)\n+inline void Assembler::vnegw(   VectorRegister d, VectorRegister b)                   { emit_int32( VNEGW_OPCODE    | vrt(d) | vrb(b)); }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    address a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+    address a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -64,2 +64,2 @@\n-  address stub = _throw_index_out_of_bounds_exception ? Runtime1::entry_for(C1StubId::throw_index_exception_id)\n-                                                      : Runtime1::entry_for(C1StubId::throw_range_check_failed_id);\n+  address stub = _throw_index_out_of_bounds_exception ? Runtime1::entry_for(StubId::c1_throw_index_exception_id)\n+                                                      : Runtime1::entry_for(StubId::c1_throw_range_check_failed_id);\n@@ -94,1 +94,1 @@\n-  address a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+  address a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -118,1 +118,1 @@\n-  address a = Runtime1::entry_for(C1StubId::counter_overflow_id);\n+  address a = Runtime1::entry_for(StubId::c1_counter_overflow_id);\n@@ -135,1 +135,1 @@\n-  address stub = Runtime1::entry_for(C1StubId::throw_div0_exception_id);\n+  address stub = Runtime1::entry_for(StubId::c1_throw_div0_exception_id);\n@@ -150,1 +150,1 @@\n-    a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+    a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -152,1 +152,1 @@\n-    a = Runtime1::entry_for(C1StubId::throw_null_pointer_exception_id);\n+    a = Runtime1::entry_for(StubId::c1_throw_null_pointer_exception_id);\n@@ -184,1 +184,1 @@\n-NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, C1StubId stub_id) {\n+NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, StubId stub_id) {\n@@ -189,3 +189,3 @@\n-  assert(stub_id == C1StubId::new_instance_id                 ||\n-         stub_id == C1StubId::fast_new_instance_id            ||\n-         stub_id == C1StubId::fast_new_instance_init_check_id,\n+  assert(stub_id == StubId::c1_new_instance_id                 ||\n+         stub_id == StubId::c1_fast_new_instance_id            ||\n+         stub_id == StubId::c1_fast_new_instance_init_check_id,\n@@ -221,1 +221,1 @@\n-  address entry = Runtime1::entry_for(C1StubId::new_type_array_id);\n+  address entry = Runtime1::entry_for(StubId::c1_new_type_array_id);\n@@ -244,1 +244,1 @@\n-  address entry = Runtime1::entry_for(C1StubId::new_object_array_id);\n+  address entry = Runtime1::entry_for(StubId::c1_new_object_array_id);\n@@ -257,1 +257,1 @@\n-  address stub = Runtime1::entry_for(ce->compilation()->has_fpu_code() ? C1StubId::monitorenter_id : C1StubId::monitorenter_nofpu_id);\n+  address stub = Runtime1::entry_for(ce->compilation()->has_fpu_code() ? StubId::c1_monitorenter_id : StubId::c1_monitorenter_nofpu_id);\n@@ -274,1 +274,1 @@\n-  address stub = Runtime1::entry_for(ce->compilation()->has_fpu_code() ? C1StubId::monitorexit_id : C1StubId::monitorexit_nofpu_id);\n+  address stub = Runtime1::entry_for(ce->compilation()->has_fpu_code() ? StubId::c1_monitorexit_id : StubId::c1_monitorexit_nofpu_id);\n@@ -388,2 +388,2 @@\n-    case access_field_id:  target = Runtime1::entry_for(C1StubId::access_field_patching_id); break;\n-    case load_klass_id:    target = Runtime1::entry_for(C1StubId::load_klass_patching_id);\n+    case access_field_id:  target = Runtime1::entry_for(StubId::c1_access_field_patching_id); break;\n+    case load_klass_id:    target = Runtime1::entry_for(StubId::c1_load_klass_patching_id);\n@@ -391,1 +391,1 @@\n-    case load_mirror_id:   target = Runtime1::entry_for(C1StubId::load_mirror_patching_id);\n+    case load_mirror_id:   target = Runtime1::entry_for(StubId::c1_load_mirror_patching_id);\n@@ -393,1 +393,1 @@\n-    case load_appendix_id: target = Runtime1::entry_for(C1StubId::load_appendix_patching_id);\n+    case load_appendix_id: target = Runtime1::entry_for(StubId::c1_load_appendix_patching_id);\n@@ -419,1 +419,1 @@\n-  address stub = Runtime1::entry_for(C1StubId::deoptimize_id);\n+  address stub = Runtime1::entry_for(StubId::c1_deoptimize_id);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_CodeStubs_ppc.cpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-  address entry_point = CAST_FROM_FN_PTR(address, Runtime1::entry_for(C1StubId::handle_exception_from_callee_id));\n+  address entry_point = CAST_FROM_FN_PTR(address, Runtime1::entry_for(StubId::c1_handle_exception_from_callee_id));\n@@ -244,1 +244,1 @@\n-  address unwind_stub = Runtime1::entry_for(C1StubId::unwind_exception_id);\n+  address unwind_stub = Runtime1::entry_for(StubId::c1_unwind_exception_id);\n@@ -1791,2 +1791,2 @@\n-  address stub = Runtime1::entry_for(compilation()->has_fpu_code() ? C1StubId::handle_exception_id\n-                                                                   : C1StubId::handle_exception_nofpu_id);\n+  address stub = Runtime1::entry_for(compilation()->has_fpu_code() ? StubId::c1_handle_exception_id\n+                                                                   : StubId::c1_handle_exception_nofpu_id);\n@@ -1983,1 +1983,1 @@\n-      address slow_stc = Runtime1::entry_for(C1StubId::slow_subtype_check_id);\n+      address slow_stc = Runtime1::entry_for(StubId::c1_slow_subtype_check_id);\n@@ -2411,1 +2411,1 @@\n-      address entry = Runtime1::entry_for(C1StubId::slow_subtype_check_id);\n+      address entry = Runtime1::entry_for(StubId::c1_slow_subtype_check_id);\n@@ -2502,1 +2502,1 @@\n-    const address slow_path = Runtime1::entry_for(C1StubId::slow_subtype_check_id);\n+    const address slow_path = Runtime1::entry_for(StubId::c1_slow_subtype_check_id);\n@@ -2804,3 +2804,3 @@\n-  if (dest == Runtime1::entry_for(C1StubId::register_finalizer_id) ||\n-      dest == Runtime1::entry_for(C1StubId::new_multi_array_id   ) ||\n-      dest == Runtime1::entry_for(C1StubId::is_instance_of_id    )) {\n+  if (dest == Runtime1::entry_for(StubId::c1_register_finalizer_id) ||\n+      dest == Runtime1::entry_for(StubId::c1_new_multi_array_id   ) ||\n+      dest == Runtime1::entry_for(StubId::c1_is_instance_of_id    )) {\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -979,1 +979,1 @@\n-  __ call_runtime(Runtime1::entry_for(C1StubId::new_multi_array_id),\n+  __ call_runtime(Runtime1::entry_for(StubId::c1_new_multi_array_id),\n@@ -1014,1 +1014,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_incompatible_class_change_error_id,\n+    stub = new SimpleExceptionStub(StubId::c1_throw_incompatible_class_change_error_id,\n@@ -1022,1 +1022,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_class_cast_exception_id, obj.result(), info_for_exception);\n+    stub = new SimpleExceptionStub(StubId::c1_throw_class_cast_exception_id, obj.result(), info_for_exception);\n@@ -1056,1 +1056,1 @@\n-  return Runtime1::entry_for(C1StubId::is_instance_of_id);\n+  return Runtime1::entry_for(StubId::c1_is_instance_of_id);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -310,1 +310,1 @@\n-\/\/    call(CAST_FROM_FN_PTR(address, Runtime1::entry_for(C1StubId::dtrace_object_alloc_id)),\n+\/\/    call(CAST_FROM_FN_PTR(address, Runtime1::entry_for(StubId::c1_dtrace_object_alloc_id)),\n@@ -386,1 +386,1 @@\n-    \/\/call(CAST_FROM_FN_PTR(address, Runtime1::entry_for(C1StubId::dtrace_object_alloc_id)),\n+    \/\/call(CAST_FROM_FN_PTR(address, Runtime1::entry_for(StubId::c1_dtrace_object_alloc_id)),\n@@ -415,1 +415,1 @@\n-    \/\/const address exception_entry = Runtime1::entry_for(C1StubId::throw_null_pointer_exception_id);\n+    \/\/const address exception_entry = Runtime1::entry_for(StubId::c1_throw_null_pointer_exception_id);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-    } else if (_stub_id == (int)C1StubId::forward_exception_id) {\n+    } else if (_stub_id == (int)StubId::c1_forward_exception_id) {\n@@ -104,2 +104,2 @@\n-      \/\/load_const_optimized(R0, Runtime1::entry_for(C1StubId::forward_exception_id));\n-      add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(Runtime1::entry_for(C1StubId::forward_exception_id)));\n+      \/\/load_const_optimized(R0, Runtime1::entry_for(StubId::c1_forward_exception_id));\n+      add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(Runtime1::entry_for(StubId::c1_forward_exception_id)));\n@@ -394,1 +394,1 @@\n-OopMapSet* Runtime1::generate_code_for(C1StubId id, StubAssembler* sasm) {\n+OopMapSet* Runtime1::generate_code_for(StubId id, StubAssembler* sasm) {\n@@ -403,1 +403,1 @@\n-    case C1StubId::forward_exception_id:\n+    case StubId::c1_forward_exception_id:\n@@ -409,3 +409,3 @@\n-    case C1StubId::new_instance_id:\n-    case C1StubId::fast_new_instance_id:\n-    case C1StubId::fast_new_instance_init_check_id:\n+    case StubId::c1_new_instance_id:\n+    case StubId::c1_fast_new_instance_id:\n+    case StubId::c1_fast_new_instance_init_check_id:\n@@ -413,1 +413,1 @@\n-        if (id == C1StubId::new_instance_id) {\n+        if (id == StubId::c1_new_instance_id) {\n@@ -415,1 +415,1 @@\n-        } else if (id == C1StubId::fast_new_instance_id) {\n+        } else if (id == StubId::c1_fast_new_instance_id) {\n@@ -418,1 +418,1 @@\n-          assert(id == C1StubId::fast_new_instance_init_check_id, \"bad C1StubId\");\n+          assert(id == StubId::c1_fast_new_instance_init_check_id, \"bad StubId\");\n@@ -428,1 +428,1 @@\n-    case C1StubId::counter_overflow_id:\n+    case StubId::c1_counter_overflow_id:\n@@ -433,2 +433,2 @@\n-    case C1StubId::new_type_array_id:\n-    case C1StubId::new_object_array_id:\n+    case StubId::c1_new_type_array_id:\n+    case StubId::c1_new_object_array_id:\n@@ -436,1 +436,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -445,1 +445,1 @@\n-          int tag = (id == C1StubId::new_type_array_id) ? Klass::_lh_array_tag_type_value : Klass::_lh_array_tag_obj_value;\n+          int tag = (id == StubId::c1_new_type_array_id) ? Klass::_lh_array_tag_type_value : Klass::_lh_array_tag_obj_value;\n@@ -459,1 +459,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -467,1 +467,1 @@\n-    case C1StubId::new_multi_array_id:\n+    case StubId::c1_new_multi_array_id:\n@@ -477,1 +477,1 @@\n-    case C1StubId::register_finalizer_id:\n+    case StubId::c1_register_finalizer_id:\n@@ -507,1 +507,1 @@\n-    case C1StubId::throw_range_check_failed_id:\n+    case StubId::c1_throw_range_check_failed_id:\n@@ -514,1 +514,1 @@\n-    case C1StubId::throw_index_exception_id:\n+    case StubId::c1_throw_index_exception_id:\n@@ -521,1 +521,1 @@\n-    case C1StubId::throw_div0_exception_id:\n+    case StubId::c1_throw_div0_exception_id:\n@@ -528,1 +528,1 @@\n-    case C1StubId::throw_null_pointer_exception_id:\n+    case StubId::c1_throw_null_pointer_exception_id:\n@@ -535,2 +535,2 @@\n-    case C1StubId::handle_exception_nofpu_id:\n-    case C1StubId::handle_exception_id:\n+    case StubId::c1_handle_exception_nofpu_id:\n+    case StubId::c1_handle_exception_id:\n@@ -543,1 +543,1 @@\n-    case C1StubId::handle_exception_from_callee_id:\n+    case StubId::c1_handle_exception_from_callee_id:\n@@ -550,1 +550,1 @@\n-    case C1StubId::unwind_exception_id:\n+    case StubId::c1_unwind_exception_id:\n@@ -578,1 +578,1 @@\n-    case C1StubId::throw_array_store_exception_id:\n+    case StubId::c1_throw_array_store_exception_id:\n@@ -585,1 +585,1 @@\n-    case C1StubId::throw_class_cast_exception_id:\n+    case StubId::c1_throw_class_cast_exception_id:\n@@ -592,1 +592,1 @@\n-    case C1StubId::throw_incompatible_class_change_error_id:\n+    case StubId::c1_throw_incompatible_class_change_error_id:\n@@ -599,1 +599,1 @@\n-    case C1StubId::slow_subtype_check_id:\n+    case StubId::c1_slow_subtype_check_id:\n@@ -610,1 +610,1 @@\n-    case C1StubId::is_instance_of_id:\n+    case StubId::c1_is_instance_of_id:\n@@ -677,2 +677,2 @@\n-    case C1StubId::monitorenter_nofpu_id:\n-    case C1StubId::monitorenter_id:\n+    case StubId::c1_monitorenter_nofpu_id:\n+    case StubId::c1_monitorenter_id:\n@@ -682,1 +682,1 @@\n-        int save_fpu_registers = (id == C1StubId::monitorenter_id);\n+        int save_fpu_registers = (id == StubId::c1_monitorenter_id);\n@@ -696,2 +696,2 @@\n-    case C1StubId::monitorexit_nofpu_id:\n-    case C1StubId::monitorexit_id:\n+    case StubId::c1_monitorexit_nofpu_id:\n+    case StubId::c1_monitorexit_id:\n@@ -704,1 +704,1 @@\n-        int save_fpu_registers = (id == C1StubId::monitorexit_id);\n+        int save_fpu_registers = (id == StubId::c1_monitorexit_id);\n@@ -718,1 +718,1 @@\n-    case C1StubId::deoptimize_id:\n+    case StubId::c1_deoptimize_id:\n@@ -734,1 +734,1 @@\n-    case C1StubId::access_field_patching_id:\n+    case StubId::c1_access_field_patching_id:\n@@ -741,1 +741,1 @@\n-    case C1StubId::load_klass_patching_id:\n+    case StubId::c1_load_klass_patching_id:\n@@ -748,1 +748,1 @@\n-    case C1StubId::load_mirror_patching_id:\n+    case StubId::c1_load_mirror_patching_id:\n@@ -755,1 +755,1 @@\n-    case C1StubId::load_appendix_patching_id:\n+    case StubId::c1_load_appendix_patching_id:\n@@ -762,1 +762,1 @@\n-    case C1StubId::dtrace_object_alloc_id:\n+    case StubId::c1_dtrace_object_alloc_id:\n@@ -782,1 +782,1 @@\n-    case C1StubId::predicate_failed_trap_id:\n+    case StubId::c1_predicate_failed_trap_id:\n@@ -826,1 +826,1 @@\n-OopMapSet* Runtime1::generate_handle_exception(C1StubId id, StubAssembler* sasm) {\n+OopMapSet* Runtime1::generate_handle_exception(StubId id, StubAssembler* sasm) {\n@@ -836,1 +836,1 @@\n-  case C1StubId::forward_exception_id:\n+  case StubId::c1_forward_exception_id:\n@@ -852,2 +852,2 @@\n-  case C1StubId::handle_exception_nofpu_id:\n-  case C1StubId::handle_exception_id:\n+  case StubId::c1_handle_exception_nofpu_id:\n+  case StubId::c1_handle_exception_id:\n@@ -855,1 +855,1 @@\n-    oop_map = save_live_registers(sasm, id != C1StubId::handle_exception_nofpu_id, Rexception_pc);\n+    oop_map = save_live_registers(sasm, id != StubId::c1_handle_exception_nofpu_id, Rexception_pc);\n@@ -857,1 +857,1 @@\n-  case C1StubId::handle_exception_from_callee_id:\n+  case StubId::c1_handle_exception_from_callee_id:\n@@ -896,4 +896,4 @@\n-  case C1StubId::forward_exception_id:\n-  case C1StubId::handle_exception_nofpu_id:\n-  case C1StubId::handle_exception_id:\n-    restore_live_registers(sasm, noreg, noreg, id != C1StubId::handle_exception_nofpu_id);\n+  case StubId::c1_forward_exception_id:\n+  case StubId::c1_handle_exception_nofpu_id:\n+  case StubId::c1_handle_exception_id:\n+    restore_live_registers(sasm, noreg, noreg, id != StubId::c1_handle_exception_nofpu_id);\n@@ -902,1 +902,1 @@\n-  case C1StubId::handle_exception_from_callee_id: {\n+  case StubId::c1_handle_exception_from_callee_id: {\n","filename":"src\/hotspot\/cpu\/ppc\/c1_Runtime1_ppc.cpp","additions":56,"deletions":56,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -2196,0 +2196,1 @@\n+    case Op_NegVI:\n@@ -2206,0 +2207,2 @@\n+    case Op_UMinV:\n+    case Op_UMaxV:\n@@ -2271,0 +2274,2 @@\n+    case Op_UMinV:\n+    case Op_UMaxV:\n@@ -2272,0 +2277,2 @@\n+    case Op_NegVI:\n+      return PowerArchitecturePPC64 >= 9 && bt == T_INT;\n@@ -8425,0 +8432,12 @@\n+instruct uMulHighL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{\n+  match(Set dst (UMulHiL src1 src2));\n+  ins_cost(DEFAULT_COST);\n+\n+  format %{ \"MULHDU   $dst $src1, $src2 \\t\/\/ unsigned long\" %}\n+  size(4);\n+  ins_encode %{\n+    __ mulhdu($dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n@@ -10786,0 +10805,30 @@\n+instruct cmpU3_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{\n+  match(Set dst (CmpU3 src1 src2));\n+  effect(KILL cr0);\n+  ins_cost(DEFAULT_COST * 5);\n+  size((VM_Version::has_brw() ? 16 : 20));\n+\n+  format %{ \"cmpU3_reg_reg $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ cmplw(CR0, $src1$$Register, $src2$$Register);\n+    __ set_cmp3($dst$$Register);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct cmpUL3_reg_reg(iRegIdst dst, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{\n+  match(Set dst (CmpUL3 src1 src2));\n+  effect(KILL cr0);\n+  ins_cost(DEFAULT_COST * 5);\n+  size((VM_Version::has_brw() ? 16 : 20));\n+\n+  format %{ \"cmpUL3_reg_reg $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ cmpld(CR0, $src1$$Register, $src2$$Register);\n+    __ set_cmp3($dst$$Register);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n@@ -13350,0 +13399,40 @@\n+instruct vminu_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (UMinV src1 src2));\n+  format %{ \"VMINU  $dst,$src1,$src2\\t\/\/ vector unsigned min\" %}\n+  size(4);\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    switch (bt) {\n+      case T_INT:\n+        __ vminuw($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+        break;\n+      case T_LONG:\n+        __ vminud($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct vmaxu_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (UMaxV src1 src2));\n+  format %{ \"VMAXU  $dst,$src1,$src2\\t\/\/ vector unsigned max\" %}\n+  size(4);\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    switch (bt) {\n+      case T_INT:\n+        __ vmaxuw($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+        break;\n+      case T_LONG:\n+        __ vmaxud($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n@@ -13510,0 +13599,11 @@\n+instruct vneg4I_reg(vecX dst, vecX src) %{\n+  match(Set dst (NegVI src));\n+  predicate(PowerArchitecturePPC64 >= 9 && Matcher::vector_element_basic_type(n) == T_INT);\n+  format %{ \"VNEGW $dst,$src\\t\/\/ negate int vector\" %}\n+  size(4);\n+  ins_encode %{\n+    __ vnegw($dst$$VectorRegister, $src$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":100,"deletions":0,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n+  const char* name = OptoRuntime::stub_name(StubId::c2_exception_id);\n","filename":"src\/hotspot\/cpu\/ppc\/runtime_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2950,1 +2950,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::deopt_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_deopt_id);\n@@ -3173,1 +3173,1 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n+  const char* name = OptoRuntime::stub_name(StubId::c2_uncommon_trap_id);\n@@ -3305,1 +3305,1 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(StubId id, address call_ptr) {\n@@ -3323,1 +3323,1 @@\n-  bool cause_return = (id == SharedStubId::polling_page_return_handler_id);\n+  bool cause_return = (id == StubId::shared_polling_page_return_handler_id);\n@@ -3333,1 +3333,1 @@\n-  bool save_vectors = (id == SharedStubId::polling_page_vectors_safepoint_handler_id);\n+  bool save_vectors = (id == StubId::shared_polling_page_vectors_safepoint_handler_id);\n@@ -3420,1 +3420,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(StubId id, address destination) {\n@@ -3524,1 +3524,1 @@\n-RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+RuntimeStub* SharedRuntime::generate_throw_exception(StubId id, address runtime_entry) {\n@@ -3847,1 +3847,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_write_checkpoint_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_jfr_write_checkpoint_id);\n@@ -3884,1 +3884,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_return_lease_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_jfr_return_lease_id);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-    StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+    StubId stub_id = StubId::stubgen_call_stub_id;\n@@ -368,1 +368,1 @@\n-    StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+    StubId stub_id = StubId::stubgen_catch_exception_id;\n@@ -424,1 +424,1 @@\n-    StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+    StubId stub_id = StubId::stubgen_forward_exception_id;\n@@ -709,1 +709,1 @@\n-  address generate_fill(StubGenStubId stub_id) {\n+  address generate_fill(StubId stub_id) {\n@@ -714,1 +714,1 @@\n-    case jbyte_fill_id:\n+    case StubId::stubgen_jbyte_fill_id:\n@@ -718,1 +718,1 @@\n-    case jshort_fill_id:\n+    case StubId::stubgen_jshort_fill_id:\n@@ -722,1 +722,1 @@\n-    case jint_fill_id:\n+    case StubId::stubgen_jint_fill_id:\n@@ -726,1 +726,1 @@\n-    case arrayof_jbyte_fill_id:\n+    case StubId::stubgen_arrayof_jbyte_fill_id:\n@@ -730,1 +730,1 @@\n-    case arrayof_jshort_fill_id:\n+    case StubId::stubgen_arrayof_jshort_fill_id:\n@@ -734,1 +734,1 @@\n-    case arrayof_jint_fill_id:\n+    case StubId::stubgen_arrayof_jint_fill_id:\n@@ -987,1 +987,1 @@\n-  address generate_disjoint_byte_copy(StubGenStubId stub_id) {\n+  address generate_disjoint_byte_copy(StubId stub_id) {\n@@ -990,1 +990,1 @@\n-    case jbyte_disjoint_arraycopy_id:\n+    case StubId::stubgen_jbyte_disjoint_arraycopy_id:\n@@ -993,1 +993,1 @@\n-    case arrayof_jbyte_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id:\n@@ -1157,1 +1157,1 @@\n-  address generate_conjoint_byte_copy(StubGenStubId stub_id) {\n+  address generate_conjoint_byte_copy(StubId stub_id) {\n@@ -1160,1 +1160,1 @@\n-    case jbyte_arraycopy_id:\n+    case StubId::stubgen_jbyte_arraycopy_id:\n@@ -1163,1 +1163,1 @@\n-    case arrayof_jbyte_arraycopy_id:\n+    case StubId::stubgen_arrayof_jbyte_arraycopy_id:\n@@ -1258,1 +1258,1 @@\n-  address generate_disjoint_short_copy(StubGenStubId stub_id) {\n+  address generate_disjoint_short_copy(StubId stub_id) {\n@@ -1261,1 +1261,1 @@\n-    case jshort_disjoint_arraycopy_id:\n+    case StubId::stubgen_jshort_disjoint_arraycopy_id:\n@@ -1264,1 +1264,1 @@\n-    case arrayof_jshort_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id:\n@@ -1435,1 +1435,1 @@\n-  address generate_conjoint_short_copy(StubGenStubId stub_id) {\n+  address generate_conjoint_short_copy(StubId stub_id) {\n@@ -1438,1 +1438,1 @@\n-    case jshort_arraycopy_id:\n+    case StubId::stubgen_jshort_arraycopy_id:\n@@ -1441,1 +1441,1 @@\n-    case arrayof_jshort_arraycopy_id:\n+    case StubId::stubgen_arrayof_jshort_arraycopy_id:\n@@ -1598,1 +1598,1 @@\n-  address generate_disjoint_int_copy(StubGenStubId stub_id) {\n+  address generate_disjoint_int_copy(StubId stub_id) {\n@@ -1601,1 +1601,1 @@\n-    case jint_disjoint_arraycopy_id:\n+    case StubId::stubgen_jint_disjoint_arraycopy_id:\n@@ -1604,1 +1604,1 @@\n-    case arrayof_jint_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jint_disjoint_arraycopy_id:\n@@ -1739,1 +1739,1 @@\n-  address generate_conjoint_int_copy(StubGenStubId stub_id) {\n+  address generate_conjoint_int_copy(StubId stub_id) {\n@@ -1742,1 +1742,1 @@\n-    case jint_arraycopy_id:\n+    case StubId::stubgen_jint_arraycopy_id:\n@@ -1745,1 +1745,1 @@\n-    case arrayof_jint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jint_arraycopy_id:\n@@ -1863,1 +1863,1 @@\n-  address generate_disjoint_long_copy(StubGenStubId stub_id) {\n+  address generate_disjoint_long_copy(StubId stub_id) {\n@@ -1866,1 +1866,1 @@\n-    case jlong_disjoint_arraycopy_id:\n+    case StubId::stubgen_jlong_disjoint_arraycopy_id:\n@@ -1869,1 +1869,1 @@\n-    case arrayof_jlong_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id:\n@@ -1983,1 +1983,1 @@\n-  address generate_conjoint_long_copy(StubGenStubId stub_id) {\n+  address generate_conjoint_long_copy(StubId stub_id) {\n@@ -1986,1 +1986,1 @@\n-    case jlong_arraycopy_id:\n+    case StubId::stubgen_jlong_arraycopy_id:\n@@ -1989,1 +1989,1 @@\n-    case arrayof_jlong_arraycopy_id:\n+    case StubId::stubgen_arrayof_jlong_arraycopy_id:\n@@ -2024,1 +2024,1 @@\n-  address generate_conjoint_oop_copy(StubGenStubId stub_id) {\n+  address generate_conjoint_oop_copy(StubId stub_id) {\n@@ -2028,1 +2028,1 @@\n-    case oop_arraycopy_id:\n+    case StubId::stubgen_oop_arraycopy_id:\n@@ -2032,1 +2032,1 @@\n-    case arrayof_oop_arraycopy_id:\n+    case StubId::stubgen_arrayof_oop_arraycopy_id:\n@@ -2036,1 +2036,1 @@\n-    case oop_arraycopy_uninit_id:\n+    case StubId::stubgen_oop_arraycopy_uninit_id:\n@@ -2040,1 +2040,1 @@\n-    case arrayof_oop_arraycopy_uninit_id:\n+    case StubId::stubgen_arrayof_oop_arraycopy_uninit_id:\n@@ -2095,1 +2095,1 @@\n-  address generate_disjoint_oop_copy(StubGenStubId stub_id) {\n+  address generate_disjoint_oop_copy(StubId stub_id) {\n@@ -2099,1 +2099,1 @@\n-    case oop_disjoint_arraycopy_id:\n+    case StubId::stubgen_oop_disjoint_arraycopy_id:\n@@ -2103,1 +2103,1 @@\n-    case arrayof_oop_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_oop_disjoint_arraycopy_id:\n@@ -2107,1 +2107,1 @@\n-    case oop_disjoint_arraycopy_uninit_id:\n+    case StubId::stubgen_oop_disjoint_arraycopy_uninit_id:\n@@ -2111,1 +2111,1 @@\n-    case arrayof_oop_disjoint_arraycopy_uninit_id:\n+    case StubId::stubgen_arrayof_oop_disjoint_arraycopy_uninit_id:\n@@ -2187,1 +2187,1 @@\n-  address generate_checkcast_copy(StubGenStubId stub_id) {\n+  address generate_checkcast_copy(StubId stub_id) {\n@@ -2203,1 +2203,1 @@\n-    case checkcast_arraycopy_id:\n+    case StubId::stubgen_checkcast_arraycopy_id:\n@@ -2206,1 +2206,1 @@\n-    case checkcast_arraycopy_uninit_id:\n+    case StubId::stubgen_checkcast_arraycopy_uninit_id:\n@@ -2345,1 +2345,1 @@\n-    StubGenStubId stub_id = StubGenStubId::unsafe_arraycopy_id;\n+    StubId stub_id = StubId::stubgen_unsafe_arraycopy_id;\n@@ -2458,1 +2458,1 @@\n-    StubCodeMark mark(this, StubGenStubId::unsafe_setmemory_id);\n+    StubCodeMark mark(this, StubId::stubgen_unsafe_setmemory_id);\n@@ -2551,1 +2551,1 @@\n-    StubGenStubId stub_id = StubGenStubId::generic_arraycopy_id;\n+    StubId stub_id = StubId::stubgen_generic_arraycopy_id;\n@@ -2754,1 +2754,1 @@\n-    StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+    StubId stub_id = StubId::stubgen_aescrypt_encryptBlock_id;\n@@ -2962,1 +2962,1 @@\n-    StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+    StubId stub_id = StubId::stubgen_aescrypt_decryptBlock_id;\n@@ -3200,1 +3200,1 @@\n-  address generate_sha256_implCompress(StubGenStubId stub_id) {\n+  address generate_sha256_implCompress(StubId stub_id) {\n@@ -3204,1 +3204,1 @@\n-    case sha256_implCompress_id:\n+    case StubId::stubgen_sha256_implCompress_id:\n@@ -3207,1 +3207,1 @@\n-    case sha256_implCompressMB_id:\n+    case StubId::stubgen_sha256_implCompressMB_id:\n@@ -3222,1 +3222,1 @@\n-  address generate_sha512_implCompress(StubGenStubId stub_id) {\n+  address generate_sha512_implCompress(StubId stub_id) {\n@@ -3226,1 +3226,1 @@\n-    case sha512_implCompress_id:\n+    case StubId::stubgen_sha512_implCompress_id:\n@@ -3229,1 +3229,1 @@\n-    case sha512_implCompressMB_id:\n+    case StubId::stubgen_sha512_implCompressMB_id:\n@@ -3246,1 +3246,1 @@\n-    StubGenStubId stub_id = StubGenStubId::data_cache_writeback_id;\n+    StubId stub_id = StubId::stubgen_data_cache_writeback_id;\n@@ -3260,1 +3260,1 @@\n-    StubGenStubId stub_id = StubGenStubId::data_cache_writeback_sync_id;\n+    StubId stub_id = StubId::stubgen_data_cache_writeback_sync_id;\n@@ -3281,6 +3281,6 @@\n-    StubRoutines::_jbyte_disjoint_arraycopy       = generate_disjoint_byte_copy(StubGenStubId::jbyte_disjoint_arraycopy_id);\n-    StubRoutines::_jshort_disjoint_arraycopy      = generate_disjoint_short_copy(StubGenStubId::jshort_disjoint_arraycopy_id);\n-    StubRoutines::_jint_disjoint_arraycopy        = generate_disjoint_int_copy(StubGenStubId::jint_disjoint_arraycopy_id);\n-    StubRoutines::_jlong_disjoint_arraycopy       = generate_disjoint_long_copy(StubGenStubId::jlong_disjoint_arraycopy_id);\n-    StubRoutines::_oop_disjoint_arraycopy         = generate_disjoint_oop_copy(StubGenStubId::oop_disjoint_arraycopy_id);\n-    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_oop_copy(StubGenStubId::oop_disjoint_arraycopy_uninit_id);\n+    StubRoutines::_jbyte_disjoint_arraycopy       = generate_disjoint_byte_copy(StubId::stubgen_jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_jshort_disjoint_arraycopy      = generate_disjoint_short_copy(StubId::stubgen_jshort_disjoint_arraycopy_id);\n+    StubRoutines::_jint_disjoint_arraycopy        = generate_disjoint_int_copy(StubId::stubgen_jint_disjoint_arraycopy_id);\n+    StubRoutines::_jlong_disjoint_arraycopy       = generate_disjoint_long_copy(StubId::stubgen_jlong_disjoint_arraycopy_id);\n+    StubRoutines::_oop_disjoint_arraycopy         = generate_disjoint_oop_copy(StubId::stubgen_oop_disjoint_arraycopy_id);\n+    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_oop_copy(StubId::stubgen_oop_disjoint_arraycopy_uninit_id);\n@@ -3289,6 +3289,6 @@\n-    StubRoutines::_arrayof_jbyte_disjoint_arraycopy      = generate_disjoint_byte_copy(StubGenStubId::arrayof_jbyte_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_jshort_disjoint_arraycopy     = generate_disjoint_short_copy(StubGenStubId::arrayof_jshort_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_jint_disjoint_arraycopy       = generate_disjoint_int_copy(StubGenStubId::arrayof_jint_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_jlong_disjoint_arraycopy      = generate_disjoint_long_copy(StubGenStubId::arrayof_jlong_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_oop_disjoint_arraycopy        = generate_disjoint_oop_copy(StubGenStubId::arrayof_oop_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy(StubGenStubId::oop_disjoint_arraycopy_uninit_id);\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy      = generate_disjoint_byte_copy(StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy     = generate_disjoint_short_copy(StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy       = generate_disjoint_int_copy(StubId::stubgen_arrayof_jint_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy      = generate_disjoint_long_copy(StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy        = generate_disjoint_oop_copy(StubId::stubgen_arrayof_oop_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy(StubId::stubgen_oop_disjoint_arraycopy_uninit_id);\n@@ -3297,6 +3297,6 @@\n-    StubRoutines::_jbyte_arraycopy      = generate_conjoint_byte_copy(StubGenStubId::jbyte_arraycopy_id);\n-    StubRoutines::_jshort_arraycopy     = generate_conjoint_short_copy(StubGenStubId::jshort_arraycopy_id);\n-    StubRoutines::_jint_arraycopy       = generate_conjoint_int_copy(StubGenStubId::jint_arraycopy_id);\n-    StubRoutines::_jlong_arraycopy      = generate_conjoint_long_copy(StubGenStubId::jlong_arraycopy_id);\n-    StubRoutines::_oop_arraycopy        = generate_conjoint_oop_copy(StubGenStubId::oop_arraycopy_id);\n-    StubRoutines::_oop_arraycopy_uninit = generate_conjoint_oop_copy(StubGenStubId::oop_arraycopy_uninit_id);\n+    StubRoutines::_jbyte_arraycopy      = generate_conjoint_byte_copy(StubId::stubgen_jbyte_arraycopy_id);\n+    StubRoutines::_jshort_arraycopy     = generate_conjoint_short_copy(StubId::stubgen_jshort_arraycopy_id);\n+    StubRoutines::_jint_arraycopy       = generate_conjoint_int_copy(StubId::stubgen_jint_arraycopy_id);\n+    StubRoutines::_jlong_arraycopy      = generate_conjoint_long_copy(StubId::stubgen_jlong_arraycopy_id);\n+    StubRoutines::_oop_arraycopy        = generate_conjoint_oop_copy(StubId::stubgen_oop_arraycopy_id);\n+    StubRoutines::_oop_arraycopy_uninit = generate_conjoint_oop_copy(StubId::stubgen_oop_arraycopy_uninit_id);\n@@ -3305,6 +3305,6 @@\n-    StubRoutines::_arrayof_jbyte_arraycopy      = generate_conjoint_byte_copy(StubGenStubId::arrayof_jbyte_arraycopy_id);\n-    StubRoutines::_arrayof_jshort_arraycopy     = generate_conjoint_short_copy(StubGenStubId::arrayof_jshort_arraycopy_id);\n-    StubRoutines::_arrayof_jint_arraycopy       = generate_conjoint_int_copy(StubGenStubId::arrayof_jint_arraycopy_id);\n-    StubRoutines::_arrayof_jlong_arraycopy      = generate_conjoint_long_copy(StubGenStubId::arrayof_jlong_arraycopy_id);\n-    StubRoutines::_arrayof_oop_arraycopy        = generate_conjoint_oop_copy(StubGenStubId::arrayof_oop_arraycopy_id);\n-    StubRoutines::_arrayof_oop_arraycopy_uninit = generate_conjoint_oop_copy(StubGenStubId::arrayof_oop_arraycopy_id);\n+    StubRoutines::_arrayof_jbyte_arraycopy      = generate_conjoint_byte_copy(StubId::stubgen_arrayof_jbyte_arraycopy_id);\n+    StubRoutines::_arrayof_jshort_arraycopy     = generate_conjoint_short_copy(StubId::stubgen_arrayof_jshort_arraycopy_id);\n+    StubRoutines::_arrayof_jint_arraycopy       = generate_conjoint_int_copy(StubId::stubgen_arrayof_jint_arraycopy_id);\n+    StubRoutines::_arrayof_jlong_arraycopy      = generate_conjoint_long_copy(StubId::stubgen_arrayof_jlong_arraycopy_id);\n+    StubRoutines::_arrayof_oop_arraycopy        = generate_conjoint_oop_copy(StubId::stubgen_arrayof_oop_arraycopy_id);\n+    StubRoutines::_arrayof_oop_arraycopy_uninit = generate_conjoint_oop_copy(StubId::stubgen_arrayof_oop_arraycopy_id);\n@@ -3313,2 +3313,2 @@\n-    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_id);\n-    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_uninit_id);\n+    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubId::stubgen_checkcast_arraycopy_id);\n+    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubId::stubgen_checkcast_arraycopy_uninit_id);\n@@ -3331,6 +3331,6 @@\n-      StubRoutines::_jbyte_fill          = generate_fill(StubGenStubId::jbyte_fill_id);\n-      StubRoutines::_jshort_fill         = generate_fill(StubGenStubId::jshort_fill_id);\n-      StubRoutines::_jint_fill           = generate_fill(StubGenStubId::jint_fill_id);\n-      StubRoutines::_arrayof_jbyte_fill  = generate_fill(StubGenStubId::arrayof_jbyte_fill_id);\n-      StubRoutines::_arrayof_jshort_fill = generate_fill(StubGenStubId::arrayof_jshort_fill_id);\n-      StubRoutines::_arrayof_jint_fill   = generate_fill(StubGenStubId::arrayof_jint_fill_id);\n+      StubRoutines::_jbyte_fill          = generate_fill(StubId::stubgen_jbyte_fill_id);\n+      StubRoutines::_jshort_fill         = generate_fill(StubId::stubgen_jshort_fill_id);\n+      StubRoutines::_jint_fill           = generate_fill(StubId::stubgen_jint_fill_id);\n+      StubRoutines::_arrayof_jbyte_fill  = generate_fill(StubId::stubgen_arrayof_jbyte_fill_id);\n+      StubRoutines::_arrayof_jshort_fill = generate_fill(StubId::stubgen_arrayof_jshort_fill_id);\n+      StubRoutines::_arrayof_jint_fill   = generate_fill(StubId::stubgen_arrayof_jint_fill_id);\n@@ -3355,1 +3355,1 @@\n-    StubGenStubId stub_id = StubGenStubId::multiplyToLen_id;\n+    StubId stub_id = StubId::stubgen_multiplyToLen_id;\n@@ -3432,1 +3432,1 @@\n-    StubGenStubId stub_id = StubGenStubId::mulAdd_id;\n+    StubId stub_id = StubId::stubgen_mulAdd_id;\n@@ -3463,1 +3463,1 @@\n-    StubGenStubId stub_id = StubGenStubId::squareToLen_id;\n+    StubId stub_id = StubId::stubgen_squareToLen_id;\n@@ -3697,1 +3697,1 @@\n-  address generate_CRC32_updateBytes(StubGenStubId stub_id) {\n+  address generate_CRC32_updateBytes(StubId stub_id) {\n@@ -3700,1 +3700,1 @@\n-    case updateBytesCRC32_id:\n+    case StubId::stubgen_updateBytesCRC32_id:\n@@ -3703,1 +3703,1 @@\n-    case updateBytesCRC32C_id:\n+    case StubId::stubgen_updateBytesCRC32C_id:\n@@ -3737,1 +3737,1 @@\n-    StubGenStubId stub_id = StubGenStubId::method_entry_barrier_id;\n+    StubId stub_id = StubId::stubgen_method_entry_barrier_id;\n@@ -3835,1 +3835,1 @@\n-    StubGenStubId stub_id = StubGenStubId::base64_decodeBlock_id;\n+    StubId stub_id = StubId::stubgen_base64_decodeBlock_id;\n@@ -4424,1 +4424,1 @@\n-    StubGenStubId stub_id = StubGenStubId::base64_encodeBlock_id;\n+    StubId stub_id = StubId::stubgen_base64_encodeBlock_id;\n@@ -4715,1 +4715,1 @@\n-    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n+    StubId stub_id = StubId::stubgen_lookup_secondary_supers_table_id;\n@@ -4738,1 +4738,1 @@\n-    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_slow_path_id;\n+    StubId stub_id = StubId::stubgen_lookup_secondary_supers_table_slow_path_id;\n@@ -4756,1 +4756,1 @@\n-  address generate_cont_thaw(StubGenStubId stub_id) {\n+  address generate_cont_thaw(StubId stub_id) {\n@@ -4764,1 +4764,1 @@\n-    case cont_thaw_id:\n+    case StubId::stubgen_cont_thaw_id:\n@@ -4769,1 +4769,1 @@\n-    case cont_returnBarrier_id:\n+    case StubId::stubgen_cont_returnBarrier_id:\n@@ -4774,1 +4774,1 @@\n-    case cont_returnBarrierExc_id:\n+    case StubId::stubgen_cont_returnBarrierExc_id:\n@@ -4871,1 +4871,1 @@\n-    return generate_cont_thaw(StubGenStubId::cont_thaw_id);\n+    return generate_cont_thaw(StubId::stubgen_cont_thaw_id);\n@@ -4877,1 +4877,1 @@\n-    return generate_cont_thaw(StubGenStubId::cont_returnBarrier_id);\n+    return generate_cont_thaw(StubId::stubgen_cont_returnBarrier_id);\n@@ -4881,1 +4881,1 @@\n-    return generate_cont_thaw(StubGenStubId::cont_returnBarrierExc_id);\n+    return generate_cont_thaw(StubId::stubgen_cont_returnBarrierExc_id);\n@@ -4886,1 +4886,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cont_preempt_id;\n+    StubId stub_id = StubId::stubgen_cont_preempt_id;\n@@ -4922,1 +4922,1 @@\n-    StubGenStubId stub_id = StubGenStubId::upcall_stub_exception_handler_id;\n+    StubId stub_id = StubId::stubgen_upcall_stub_exception_handler_id;\n@@ -4941,1 +4941,1 @@\n-    StubGenStubId stub_id = StubGenStubId::upcall_stub_load_target_id;\n+    StubId stub_id = StubId::stubgen_upcall_stub_load_target_id;\n@@ -4986,1 +4986,1 @@\n-      StubRoutines::_updateBytesCRC32 = generate_CRC32_updateBytes(StubGenStubId::updateBytesCRC32_id);\n+      StubRoutines::_updateBytesCRC32 = generate_CRC32_updateBytes(StubId::stubgen_updateBytesCRC32_id);\n@@ -4992,1 +4992,1 @@\n-      StubRoutines::_updateBytesCRC32C = generate_CRC32_updateBytes(StubGenStubId::updateBytesCRC32C_id);\n+      StubRoutines::_updateBytesCRC32C = generate_CRC32_updateBytes(StubId::stubgen_updateBytesCRC32C_id);\n@@ -5074,2 +5074,2 @@\n-      StubRoutines::_sha256_implCompress   = generate_sha256_implCompress(StubGenStubId::sha256_implCompress_id);\n-      StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(StubGenStubId::sha256_implCompressMB_id);\n+      StubRoutines::_sha256_implCompress   = generate_sha256_implCompress(StubId::stubgen_sha256_implCompress_id);\n+      StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(StubId::stubgen_sha256_implCompressMB_id);\n@@ -5078,2 +5078,2 @@\n-      StubRoutines::_sha512_implCompress   = generate_sha512_implCompress(StubGenStubId::sha512_implCompress_id);\n-      StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(StubGenStubId::sha512_implCompressMB_id);\n+      StubRoutines::_sha512_implCompress   = generate_sha512_implCompress(StubId::stubgen_sha512_implCompress_id);\n+      StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(StubId::stubgen_sha512_implCompressMB_id);\n@@ -5093,1 +5093,1 @@\n-  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+  StubGenerator(CodeBuffer* code, BlobId blob_id) : StubCodeGenerator(code, blob_id) {\n@@ -5095,1 +5095,1 @@\n-    case preuniverse_id:\n+    case BlobId::stubgen_preuniverse_id:\n@@ -5098,1 +5098,1 @@\n-    case initial_id:\n+    case BlobId::stubgen_initial_id:\n@@ -5101,1 +5101,1 @@\n-     case continuation_id:\n+    case BlobId::stubgen_continuation_id:\n@@ -5104,1 +5104,1 @@\n-    case compiler_id:\n+    case BlobId::stubgen_compiler_id:\n@@ -5107,1 +5107,1 @@\n-    case final_id:\n+    case BlobId::stubgen_final_id:\n@@ -5111,1 +5111,1 @@\n-      fatal(\"unexpected blob id: %d\", blob_id);\n+      fatal(\"unexpected blob id: %s\", StubInfo::name(blob_id));\n@@ -5117,1 +5117,1 @@\n-void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+void StubGenerator_generate(CodeBuffer* code, BlobId blob_id) {\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":127,"deletions":127,"binary":false,"changes":254,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::counter_overflow_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_counter_overflow_id)));\n@@ -69,1 +69,1 @@\n-    address a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+    address a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -82,1 +82,1 @@\n-  C1StubId stub_id;\n+  StubId stub_id;\n@@ -84,1 +84,1 @@\n-    stub_id = C1StubId::throw_index_exception_id;\n+    stub_id = StubId::c1_throw_index_exception_id;\n@@ -88,1 +88,1 @@\n-    stub_id = C1StubId::throw_range_check_failed_id;\n+    stub_id = StubId::c1_throw_range_check_failed_id;\n@@ -104,1 +104,1 @@\n-  address a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+  address a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -116,1 +116,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::throw_div0_exception_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_throw_div0_exception_id)));\n@@ -125,1 +125,1 @@\n-NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, C1StubId stub_id) {\n+NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, StubId stub_id) {\n@@ -130,3 +130,3 @@\n-  assert(stub_id == C1StubId::new_instance_id                 ||\n-         stub_id == C1StubId::fast_new_instance_id            ||\n-         stub_id == C1StubId::fast_new_instance_init_check_id,\n+  assert(stub_id == StubId::c1_new_instance_id                 ||\n+         stub_id == StubId::c1_fast_new_instance_id            ||\n+         stub_id == StubId::c1_fast_new_instance_init_check_id,\n@@ -161,1 +161,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::new_type_array_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_new_type_array_id)));\n@@ -181,1 +181,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::new_object_array_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_new_object_array_id)));\n@@ -193,1 +193,1 @@\n-  C1StubId enter_id;\n+  StubId enter_id;\n@@ -195,1 +195,1 @@\n-    enter_id = C1StubId::monitorenter_id;\n+    enter_id = StubId::c1_monitorenter_id;\n@@ -197,1 +197,1 @@\n-    enter_id = C1StubId::monitorenter_nofpu_id;\n+    enter_id = StubId::c1_monitorenter_nofpu_id;\n@@ -213,1 +213,1 @@\n-  C1StubId exit_id;\n+  StubId exit_id;\n@@ -215,1 +215,1 @@\n-    exit_id = C1StubId::monitorexit_id;\n+    exit_id = StubId::c1_monitorexit_id;\n@@ -217,1 +217,1 @@\n-    exit_id = C1StubId::monitorexit_nofpu_id;\n+    exit_id = StubId::c1_monitorexit_nofpu_id;\n@@ -242,1 +242,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::deoptimize_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_deoptimize_id)));\n@@ -251,1 +251,1 @@\n-    a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+    a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -253,1 +253,1 @@\n-    a = Runtime1::entry_for(C1StubId::throw_null_pointer_exception_id);\n+    a = Runtime1::entry_for(StubId::c1_throw_null_pointer_exception_id);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_CodeStubs_riscv.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -228,1 +228,1 @@\n-    __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+    __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_arraycopy_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -307,1 +307,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::handle_exception_from_callee_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_handle_exception_from_callee_id)));\n@@ -363,1 +363,1 @@\n-  __ far_jump(RuntimeAddress(Runtime1::entry_for(C1StubId::unwind_exception_id)));\n+  __ far_jump(RuntimeAddress(Runtime1::entry_for(StubId::c1_unwind_exception_id)));\n@@ -1099,1 +1099,1 @@\n-      __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+      __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n@@ -1114,1 +1114,1 @@\n-    __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+    __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n@@ -1402,1 +1402,1 @@\n-  C1StubId unwind_id;\n+  StubId unwind_id;\n@@ -1421,1 +1421,1 @@\n-    unwind_id = C1StubId::handle_exception_id;\n+    unwind_id = StubId::c1_handle_exception_id;\n@@ -1423,1 +1423,1 @@\n-    unwind_id = C1StubId::handle_exception_nofpu_id;\n+    unwind_id = StubId::c1_handle_exception_nofpu_id;\n@@ -2056,1 +2056,1 @@\n-      target = Runtime1::entry_for(C1StubId::access_field_patching_id);\n+      target = Runtime1::entry_for(StubId::c1_access_field_patching_id);\n@@ -2059,1 +2059,1 @@\n-      target = Runtime1::entry_for(C1StubId::load_klass_patching_id);\n+      target = Runtime1::entry_for(StubId::c1_load_klass_patching_id);\n@@ -2062,1 +2062,1 @@\n-      target = Runtime1::entry_for(C1StubId::load_mirror_patching_id);\n+      target = Runtime1::entry_for(StubId::c1_load_mirror_patching_id);\n@@ -2065,1 +2065,1 @@\n-      target = Runtime1::entry_for(C1StubId::load_appendix_patching_id);\n+      target = Runtime1::entry_for(StubId::c1_load_appendix_patching_id);\n@@ -2154,1 +2154,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1032,1 +1032,1 @@\n-  __ call_runtime(Runtime1::entry_for(C1StubId::new_multi_array_id),\n+  __ call_runtime(Runtime1::entry_for(StubId::c1_new_multi_array_id),\n@@ -1064,1 +1064,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr,\n+    stub = new SimpleExceptionStub(StubId::c1_throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr,\n@@ -1072,1 +1072,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_class_cast_exception_id, obj.result(), info_for_exception);\n+    stub = new SimpleExceptionStub(StubId::c1_throw_class_cast_exception_id, obj.result(), info_for_exception);\n@@ -1107,1 +1107,1 @@\n-  return Runtime1::entry_for(C1StubId::is_instance_of_id);\n+  return Runtime1::entry_for(StubId::c1_is_instance_of_id);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRGenerator_riscv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-    far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::dtrace_object_alloc_id)));\n+    far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_dtrace_object_alloc_id)));\n@@ -324,1 +324,1 @@\n-    far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::dtrace_object_alloc_id)));\n+    far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_dtrace_object_alloc_id)));\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-    } else if (_stub_id == (int)C1StubId::forward_exception_id) {\n+    } else if (_stub_id == (int)StubId::c1_forward_exception_id) {\n@@ -103,1 +103,1 @@\n-      far_jump(RuntimeAddress(Runtime1::entry_for(C1StubId::forward_exception_id)));\n+      far_jump(RuntimeAddress(Runtime1::entry_for(StubId::c1_forward_exception_id)));\n@@ -373,2 +373,2 @@\n-  assert(cb == Runtime1::blob_for(C1StubId::monitorenter_id) ||\n-         cb == Runtime1::blob_for(C1StubId::monitorenter_nofpu_id), \"must be\");\n+  assert(cb == Runtime1::blob_for(StubId::c1_monitorenter_id) ||\n+         cb == Runtime1::blob_for(StubId::c1_monitorenter_nofpu_id), \"must be\");\n@@ -402,1 +402,1 @@\n-OopMapSet* Runtime1::generate_handle_exception(C1StubId id, StubAssembler *sasm) {\n+OopMapSet* Runtime1::generate_handle_exception(StubId id, StubAssembler *sasm) {\n@@ -414,1 +414,1 @@\n-    case C1StubId::forward_exception_id:\n+    case StubId::c1_forward_exception_id:\n@@ -433,2 +433,2 @@\n-    case C1StubId::handle_exception_nofpu_id:\n-    case C1StubId::handle_exception_id:\n+    case StubId::c1_handle_exception_nofpu_id:\n+    case StubId::c1_handle_exception_id:\n@@ -436,1 +436,1 @@\n-      oop_map = save_live_registers(sasm, id != C1StubId::handle_exception_nofpu_id);\n+      oop_map = save_live_registers(sasm, id != StubId::c1_handle_exception_nofpu_id);\n@@ -438,1 +438,1 @@\n-    case C1StubId::handle_exception_from_callee_id: {\n+    case StubId::c1_handle_exception_from_callee_id: {\n@@ -495,3 +495,3 @@\n-    case C1StubId::forward_exception_id:\n-    case C1StubId::handle_exception_nofpu_id:\n-    case C1StubId::handle_exception_id:\n+    case StubId::c1_forward_exception_id:\n+    case StubId::c1_handle_exception_nofpu_id:\n+    case StubId::c1_handle_exception_id:\n@@ -499,1 +499,1 @@\n-      restore_live_registers(sasm, id != C1StubId::handle_exception_nofpu_id);\n+      restore_live_registers(sasm, id != StubId::c1_handle_exception_nofpu_id);\n@@ -501,1 +501,1 @@\n-    case C1StubId::handle_exception_from_callee_id:\n+    case StubId::c1_handle_exception_from_callee_id:\n@@ -647,1 +647,1 @@\n-OopMapSet* Runtime1::generate_code_for(C1StubId id, StubAssembler* sasm) {\n+OopMapSet* Runtime1::generate_code_for(StubId id, StubAssembler* sasm) {\n@@ -658,1 +658,1 @@\n-    case C1StubId::forward_exception_id:\n+    case StubId::c1_forward_exception_id:\n@@ -666,1 +666,1 @@\n-    case C1StubId::throw_div0_exception_id:\n+    case StubId::c1_throw_div0_exception_id:\n@@ -673,1 +673,1 @@\n-    case C1StubId::throw_null_pointer_exception_id:\n+    case StubId::c1_throw_null_pointer_exception_id:\n@@ -679,3 +679,3 @@\n-    case C1StubId::new_instance_id:\n-    case C1StubId::fast_new_instance_id:\n-    case C1StubId::fast_new_instance_init_check_id:\n+    case StubId::c1_new_instance_id:\n+    case StubId::c1_fast_new_instance_id:\n+    case StubId::c1_fast_new_instance_init_check_id:\n@@ -686,1 +686,1 @@\n-        if (id == C1StubId::new_instance_id) {\n+        if (id == StubId::c1_new_instance_id) {\n@@ -688,1 +688,1 @@\n-        } else if (id == C1StubId::fast_new_instance_id) {\n+        } else if (id == StubId::c1_fast_new_instance_id) {\n@@ -691,1 +691,1 @@\n-          assert(id == C1StubId::fast_new_instance_init_check_id, \"bad C1StubId\");\n+          assert(id == StubId::c1_fast_new_instance_init_check_id, \"bad StubId\");\n@@ -712,1 +712,1 @@\n-    case C1StubId::counter_overflow_id:\n+    case StubId::c1_counter_overflow_id:\n@@ -736,2 +736,2 @@\n-    case C1StubId::new_type_array_id:\n-    case C1StubId::new_object_array_id:\n+    case StubId::c1_new_type_array_id:\n+    case StubId::c1_new_object_array_id:\n@@ -743,1 +743,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -756,1 +756,1 @@\n-          int tag = ((id == C1StubId::new_type_array_id) ? Klass::_lh_array_tag_type_value : Klass::_lh_array_tag_obj_value);\n+          int tag = ((id == StubId::c1_new_type_array_id) ? Klass::_lh_array_tag_type_value : Klass::_lh_array_tag_obj_value);\n@@ -769,1 +769,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -788,1 +788,1 @@\n-    case C1StubId::new_multi_array_id:\n+    case StubId::c1_new_multi_array_id:\n@@ -811,1 +811,1 @@\n-    case C1StubId::register_finalizer_id:\n+    case StubId::c1_register_finalizer_id:\n@@ -845,1 +845,1 @@\n-    case C1StubId::throw_class_cast_exception_id:\n+    case StubId::c1_throw_class_cast_exception_id:\n@@ -852,1 +852,1 @@\n-    case C1StubId::throw_incompatible_class_change_error_id:\n+    case StubId::c1_throw_incompatible_class_change_error_id:\n@@ -860,1 +860,1 @@\n-    case C1StubId::slow_subtype_check_id:\n+    case StubId::c1_slow_subtype_check_id:\n@@ -906,1 +906,1 @@\n-    case C1StubId::monitorenter_nofpu_id:\n+    case StubId::c1_monitorenter_nofpu_id:\n@@ -909,1 +909,1 @@\n-    case C1StubId::monitorenter_id:\n+    case StubId::c1_monitorenter_id:\n@@ -928,1 +928,1 @@\n-    case C1StubId::is_instance_of_id:\n+    case StubId::c1_is_instance_of_id:\n@@ -974,1 +974,1 @@\n-    case C1StubId::monitorexit_nofpu_id:\n+    case StubId::c1_monitorexit_nofpu_id:\n@@ -977,1 +977,1 @@\n-    case C1StubId::monitorexit_id:\n+    case StubId::c1_monitorexit_id:\n@@ -998,1 +998,1 @@\n-    case C1StubId::deoptimize_id:\n+    case StubId::c1_deoptimize_id:\n@@ -1017,1 +1017,1 @@\n-    case C1StubId::throw_range_check_failed_id:\n+    case StubId::c1_throw_range_check_failed_id:\n@@ -1024,1 +1024,1 @@\n-    case C1StubId::unwind_exception_id:\n+    case StubId::c1_unwind_exception_id:\n@@ -1033,1 +1033,1 @@\n-    case C1StubId::access_field_patching_id:\n+    case StubId::c1_access_field_patching_id:\n@@ -1041,1 +1041,1 @@\n-    case C1StubId::load_klass_patching_id:\n+    case StubId::c1_load_klass_patching_id:\n@@ -1049,1 +1049,1 @@\n-    case C1StubId::load_mirror_patching_id:\n+    case StubId::c1_load_mirror_patching_id:\n@@ -1057,1 +1057,1 @@\n-    case C1StubId::load_appendix_patching_id:\n+    case StubId::c1_load_appendix_patching_id:\n@@ -1065,2 +1065,2 @@\n-    case C1StubId::handle_exception_nofpu_id:\n-    case C1StubId::handle_exception_id:\n+    case StubId::c1_handle_exception_nofpu_id:\n+    case StubId::c1_handle_exception_id:\n@@ -1073,1 +1073,1 @@\n-    case C1StubId::handle_exception_from_callee_id:\n+    case StubId::c1_handle_exception_from_callee_id:\n@@ -1080,1 +1080,1 @@\n-    case C1StubId::throw_index_exception_id:\n+    case StubId::c1_throw_index_exception_id:\n@@ -1087,1 +1087,1 @@\n-    case C1StubId::throw_array_store_exception_id:\n+    case StubId::c1_throw_array_store_exception_id:\n@@ -1096,1 +1096,1 @@\n-    case C1StubId::predicate_failed_trap_id:\n+    case StubId::c1_predicate_failed_trap_id:\n@@ -1116,1 +1116,1 @@\n-    case C1StubId::dtrace_object_alloc_id:\n+    case StubId::c1_dtrace_object_alloc_id:\n","filename":"src\/hotspot\/cpu\/riscv\/c1_Runtime1_riscv.cpp","additions":55,"deletions":55,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -417,2 +417,2 @@\n-  if (cb == Runtime1::blob_for(C1StubId::monitorenter_id) ||\n-      cb == Runtime1::blob_for(C1StubId::monitorenter_nofpu_id)) {\n+  if (cb == Runtime1::blob_for(StubId::c1_monitorenter_id) ||\n+      cb == Runtime1::blob_for(StubId::c1_monitorenter_nofpu_id)) {\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4695,2 +4695,3 @@\n-    __ lwu(as_Register($dst$$reg), Address(as_Register($mem$$base), $mem$$disp));\n-    __ srli(as_Register($dst$$reg), as_Register($dst$$reg), (unsigned) markWord::klass_shift_at_offset);\n+    Unimplemented();\n+    \/\/ __ lwu(as_Register($dst$$reg), Address(as_Register($mem$$base), $mem$$disp));\n+    \/\/ __ srli(as_Register($dst$$reg), as_Register($dst$$reg), (unsigned) markWord::klass_shift_at_offset);\n@@ -8429,0 +8430,11 @@\n+instruct castVVMask(vRegMask dst)\n+%{\n+  match(Set dst (CastVV dst));\n+\n+  size(0);\n+  format %{ \"# castVV of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n+  const char* name = OptoRuntime::stub_name(StubId::c2_uncommon_trap_id);\n@@ -286,1 +286,1 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n+  const char* name = OptoRuntime::stub_name(StubId::c2_exception_id);\n","filename":"src\/hotspot\/cpu\/riscv\/runtime_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2103,1 +2103,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::deopt_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_deopt_id);\n@@ -2486,1 +2486,1 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(StubId id, address call_ptr) {\n@@ -2503,2 +2503,2 @@\n-  bool cause_return = (id == SharedStubId::polling_page_return_handler_id);\n-  RegisterSaver reg_saver(id == SharedStubId::polling_page_vectors_safepoint_handler_id \/* save_vectors *\/);\n+  bool cause_return = (id == StubId::shared_polling_page_return_handler_id);\n+  RegisterSaver reg_saver(id == StubId::shared_polling_page_vectors_safepoint_handler_id \/* save_vectors *\/);\n@@ -2611,1 +2611,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(StubId id, address destination) {\n@@ -2708,1 +2708,1 @@\n-RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+RuntimeStub* SharedRuntime::generate_throw_exception(StubId id, address runtime_entry) {\n@@ -2819,1 +2819,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_write_checkpoint_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_jfr_write_checkpoint_id);\n@@ -2858,1 +2858,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_return_lease_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_jfr_return_lease_id);\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-    StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+    StubId stub_id = StubId::stubgen_call_stub_id;\n@@ -479,1 +479,1 @@\n-    StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+    StubId stub_id = StubId::stubgen_catch_exception_id;\n@@ -532,1 +532,1 @@\n-    StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+    StubId stub_id = StubId::stubgen_forward_exception_id;\n@@ -619,1 +619,1 @@\n-    StubGenStubId stub_id = StubGenStubId::verify_oop_id;\n+    StubId stub_id = StubId::stubgen_verify_oop_id;\n@@ -681,1 +681,1 @@\n-    StubGenStubId stub_id = StubGenStubId::zero_blocks_id;\n+    StubId stub_id = StubId::stubgen_zero_blocks_id;\n@@ -734,1 +734,1 @@\n-  void generate_copy_longs(StubGenStubId stub_id, Label &start,\n+  void generate_copy_longs(StubId stub_id, Label &start,\n@@ -739,1 +739,1 @@\n-    case copy_byte_f_id:\n+    case StubId::stubgen_copy_byte_f_id:\n@@ -743,1 +743,1 @@\n-    case copy_byte_b_id:\n+    case StubId::stubgen_copy_byte_b_id:\n@@ -1117,1 +1117,1 @@\n-  address generate_disjoint_copy(StubGenStubId stub_id, address* entry) {\n+  address generate_disjoint_copy(StubId stub_id, address* entry) {\n@@ -1123,1 +1123,1 @@\n-    case jbyte_disjoint_arraycopy_id:\n+    case StubId::stubgen_jbyte_disjoint_arraycopy_id:\n@@ -1129,1 +1129,1 @@\n-    case arrayof_jbyte_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id:\n@@ -1135,1 +1135,1 @@\n-    case jshort_disjoint_arraycopy_id:\n+    case StubId::stubgen_jshort_disjoint_arraycopy_id:\n@@ -1141,1 +1141,1 @@\n-    case arrayof_jshort_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id:\n@@ -1147,1 +1147,1 @@\n-    case jint_disjoint_arraycopy_id:\n+    case StubId::stubgen_jint_disjoint_arraycopy_id:\n@@ -1153,1 +1153,1 @@\n-    case arrayof_jint_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jint_disjoint_arraycopy_id:\n@@ -1159,1 +1159,1 @@\n-    case jlong_disjoint_arraycopy_id:\n+    case StubId::stubgen_jlong_disjoint_arraycopy_id:\n@@ -1164,1 +1164,1 @@\n-    case arrayof_jlong_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id:\n@@ -1170,1 +1170,1 @@\n-    case oop_disjoint_arraycopy_id:\n+    case StubId::stubgen_oop_disjoint_arraycopy_id:\n@@ -1176,1 +1176,1 @@\n-    case arrayof_oop_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_oop_disjoint_arraycopy_id:\n@@ -1182,1 +1182,1 @@\n-    case oop_disjoint_arraycopy_uninit_id:\n+    case StubId::stubgen_oop_disjoint_arraycopy_uninit_id:\n@@ -1188,1 +1188,1 @@\n-    case arrayof_oop_disjoint_arraycopy_uninit_id:\n+    case StubId::stubgen_arrayof_oop_disjoint_arraycopy_uninit_id:\n@@ -1274,1 +1274,1 @@\n-  address generate_conjoint_copy(StubGenStubId stub_id, address nooverlap_target, address *entry) {\n+  address generate_conjoint_copy(StubId stub_id, address nooverlap_target, address *entry) {\n@@ -1282,1 +1282,1 @@\n-    case jbyte_arraycopy_id:\n+    case StubId::stubgen_jbyte_arraycopy_id:\n@@ -1288,1 +1288,1 @@\n-    case arrayof_jbyte_arraycopy_id:\n+    case StubId::stubgen_arrayof_jbyte_arraycopy_id:\n@@ -1294,1 +1294,1 @@\n-    case jshort_arraycopy_id:\n+    case StubId::stubgen_jshort_arraycopy_id:\n@@ -1300,1 +1300,1 @@\n-    case arrayof_jshort_arraycopy_id:\n+    case StubId::stubgen_arrayof_jshort_arraycopy_id:\n@@ -1306,1 +1306,1 @@\n-    case jint_arraycopy_id:\n+    case StubId::stubgen_jint_arraycopy_id:\n@@ -1312,1 +1312,1 @@\n-    case arrayof_jint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jint_arraycopy_id:\n@@ -1318,1 +1318,1 @@\n-    case jlong_arraycopy_id:\n+    case StubId::stubgen_jlong_arraycopy_id:\n@@ -1323,1 +1323,1 @@\n-    case arrayof_jlong_arraycopy_id:\n+    case StubId::stubgen_arrayof_jlong_arraycopy_id:\n@@ -1329,1 +1329,1 @@\n-    case oop_arraycopy_id:\n+    case StubId::stubgen_oop_arraycopy_id:\n@@ -1335,1 +1335,1 @@\n-    case arrayof_oop_arraycopy_id:\n+    case StubId::stubgen_arrayof_oop_arraycopy_id:\n@@ -1341,1 +1341,1 @@\n-    case oop_arraycopy_uninit_id:\n+    case StubId::stubgen_oop_arraycopy_uninit_id:\n@@ -1347,1 +1347,1 @@\n-    case arrayof_oop_arraycopy_uninit_id:\n+    case StubId::stubgen_arrayof_oop_arraycopy_uninit_id:\n@@ -1447,1 +1447,1 @@\n-  address generate_checkcast_copy(StubGenStubId stub_id, address* entry) {\n+  address generate_checkcast_copy(StubId stub_id, address* entry) {\n@@ -1450,1 +1450,1 @@\n-    case checkcast_arraycopy_id:\n+    case StubId::stubgen_checkcast_arraycopy_id:\n@@ -1453,1 +1453,1 @@\n-    case checkcast_arraycopy_uninit_id:\n+    case StubId::stubgen_checkcast_arraycopy_uninit_id:\n@@ -1656,1 +1656,1 @@\n-    StubGenStubId stub_id = StubGenStubId::unsafe_setmemory_id;\n+    StubId stub_id = StubId::stubgen_unsafe_setmemory_id;\n@@ -1779,1 +1779,1 @@\n-    StubGenStubId stub_id = StubGenStubId::unsafe_arraycopy_id;\n+    StubId stub_id = StubId::stubgen_unsafe_arraycopy_id;\n@@ -1846,1 +1846,1 @@\n-    StubGenStubId stub_id = StubGenStubId::generic_arraycopy_id;\n+    StubId stub_id = StubId::stubgen_generic_arraycopy_id;\n@@ -2103,1 +2103,1 @@\n-  address generate_fill(StubGenStubId stub_id) {\n+  address generate_fill(StubId stub_id) {\n@@ -2108,1 +2108,1 @@\n-    case jbyte_fill_id:\n+    case StubId::stubgen_jbyte_fill_id:\n@@ -2112,1 +2112,1 @@\n-    case jshort_fill_id:\n+    case StubId::stubgen_jshort_fill_id:\n@@ -2116,1 +2116,1 @@\n-    case jint_fill_id:\n+    case StubId::stubgen_jint_fill_id:\n@@ -2120,1 +2120,1 @@\n-    case arrayof_jbyte_fill_id:\n+    case StubId::stubgen_arrayof_jbyte_fill_id:\n@@ -2124,1 +2124,1 @@\n-    case arrayof_jshort_fill_id:\n+    case StubId::stubgen_arrayof_jshort_fill_id:\n@@ -2128,1 +2128,1 @@\n-    case arrayof_jint_fill_id:\n+    case StubId::stubgen_arrayof_jint_fill_id:\n@@ -2304,2 +2304,2 @@\n-    generate_copy_longs(StubGenStubId::copy_byte_f_id, copy_f, c_rarg0, c_rarg1, t1);\n-    generate_copy_longs(StubGenStubId::copy_byte_b_id, copy_b, c_rarg0, c_rarg1, t1);\n+    generate_copy_longs(StubId::stubgen_copy_byte_f_id, copy_f, c_rarg0, c_rarg1, t1);\n+    generate_copy_longs(StubId::stubgen_copy_byte_b_id, copy_b, c_rarg0, c_rarg1, t1);\n@@ -2314,4 +2314,4 @@\n-    StubRoutines::_jbyte_disjoint_arraycopy          = generate_disjoint_copy(StubGenStubId::jbyte_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_jbyte_arraycopy                   = generate_conjoint_copy(StubGenStubId::jbyte_arraycopy_id, entry, &entry_jbyte_arraycopy);\n-    StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = generate_disjoint_copy(StubGenStubId::arrayof_jbyte_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jbyte_arraycopy           = generate_conjoint_copy(StubGenStubId::arrayof_jbyte_arraycopy_id, entry, nullptr);\n+    StubRoutines::_jbyte_disjoint_arraycopy          = generate_disjoint_copy(StubId::stubgen_jbyte_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jbyte_arraycopy                   = generate_conjoint_copy(StubId::stubgen_jbyte_arraycopy_id, entry, &entry_jbyte_arraycopy);\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = generate_disjoint_copy(StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jbyte_arraycopy           = generate_conjoint_copy(StubId::stubgen_arrayof_jbyte_arraycopy_id, entry, nullptr);\n@@ -2321,4 +2321,4 @@\n-    StubRoutines::_jshort_disjoint_arraycopy         = generate_disjoint_copy(StubGenStubId::jshort_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_jshort_arraycopy                  = generate_conjoint_copy(StubGenStubId::jshort_arraycopy_id, entry, &entry_jshort_arraycopy);\n-    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jshort_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jshort_arraycopy_id, entry, nullptr);\n+    StubRoutines::_jshort_disjoint_arraycopy         = generate_disjoint_copy(StubId::stubgen_jshort_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jshort_arraycopy                  = generate_conjoint_copy(StubId::stubgen_jshort_arraycopy_id, entry, &entry_jshort_arraycopy);\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jshort_arraycopy_id, entry, nullptr);\n@@ -2328,2 +2328,2 @@\n-    StubRoutines::_arrayof_jint_disjoint_arraycopy   = generate_disjoint_copy(StubGenStubId::arrayof_jint_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jint_arraycopy            = generate_conjoint_copy(StubGenStubId::arrayof_jint_arraycopy_id, entry, &entry_jint_arraycopy);\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy   = generate_disjoint_copy(StubId::stubgen_arrayof_jint_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jint_arraycopy            = generate_conjoint_copy(StubId::stubgen_arrayof_jint_arraycopy_id, entry, &entry_jint_arraycopy);\n@@ -2332,2 +2332,2 @@\n-    StubRoutines::_jint_disjoint_arraycopy           = generate_disjoint_copy(StubGenStubId::jint_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_jint_arraycopy                  = generate_conjoint_copy(StubGenStubId::jint_arraycopy_id, entry, &entry_jint_arraycopy);\n+    StubRoutines::_jint_disjoint_arraycopy           = generate_disjoint_copy(StubId::stubgen_jint_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jint_arraycopy                  = generate_conjoint_copy(StubId::stubgen_jint_arraycopy_id, entry, &entry_jint_arraycopy);\n@@ -2337,2 +2337,2 @@\n-    StubRoutines::_arrayof_jlong_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jlong_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jlong_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jlong_arraycopy_id, entry, &entry_jlong_arraycopy);\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jlong_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jlong_arraycopy_id, entry, &entry_jlong_arraycopy);\n@@ -2344,1 +2344,1 @@\n-      = generate_disjoint_copy(StubGenStubId::arrayof_oop_disjoint_arraycopy_id, &entry);\n+      = generate_disjoint_copy(StubId::stubgen_arrayof_oop_disjoint_arraycopy_id, &entry);\n@@ -2346,1 +2346,1 @@\n-      = generate_conjoint_copy(StubGenStubId::arrayof_oop_arraycopy_id, entry, &entry_oop_arraycopy);\n+      = generate_conjoint_copy(StubId::stubgen_arrayof_oop_arraycopy_id, entry, &entry_oop_arraycopy);\n@@ -2349,1 +2349,1 @@\n-      = generate_disjoint_copy(StubGenStubId::arrayof_oop_disjoint_arraycopy_uninit_id, &entry);\n+      = generate_disjoint_copy(StubId::stubgen_arrayof_oop_disjoint_arraycopy_uninit_id, &entry);\n@@ -2351,1 +2351,1 @@\n-      = generate_conjoint_copy(StubGenStubId::arrayof_oop_arraycopy_uninit_id, entry, nullptr);\n+      = generate_conjoint_copy(StubId::stubgen_arrayof_oop_arraycopy_uninit_id, entry, nullptr);\n@@ -2358,2 +2358,2 @@\n-    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_id, &entry_checkcast_arraycopy);\n-    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_uninit_id, nullptr);\n+    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubId::stubgen_checkcast_arraycopy_id, &entry_checkcast_arraycopy);\n+    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubId::stubgen_checkcast_arraycopy_uninit_id, nullptr);\n@@ -2374,6 +2374,6 @@\n-    StubRoutines::_jbyte_fill = generate_fill(StubGenStubId::jbyte_fill_id);\n-    StubRoutines::_jshort_fill = generate_fill(StubGenStubId::jshort_fill_id);\n-    StubRoutines::_jint_fill = generate_fill(StubGenStubId::jint_fill_id);\n-    StubRoutines::_arrayof_jbyte_fill = generate_fill(StubGenStubId::arrayof_jbyte_fill_id);\n-    StubRoutines::_arrayof_jshort_fill = generate_fill(StubGenStubId::arrayof_jshort_fill_id);\n-    StubRoutines::_arrayof_jint_fill = generate_fill(StubGenStubId::arrayof_jint_fill_id);\n+    StubRoutines::_jbyte_fill = generate_fill(StubId::stubgen_jbyte_fill_id);\n+    StubRoutines::_jshort_fill = generate_fill(StubId::stubgen_jshort_fill_id);\n+    StubRoutines::_jint_fill = generate_fill(StubId::stubgen_jint_fill_id);\n+    StubRoutines::_arrayof_jbyte_fill = generate_fill(StubId::stubgen_arrayof_jbyte_fill_id);\n+    StubRoutines::_arrayof_jshort_fill = generate_fill(StubId::stubgen_arrayof_jshort_fill_id);\n+    StubRoutines::_arrayof_jint_fill = generate_fill(StubId::stubgen_arrayof_jint_fill_id);\n@@ -2417,1 +2417,1 @@\n-    StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+    StubId stub_id = StubId::stubgen_aescrypt_encryptBlock_id;\n@@ -2496,1 +2496,1 @@\n-    StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+    StubId stub_id = StubId::stubgen_aescrypt_decryptBlock_id;\n@@ -2598,1 +2598,1 @@\n-  address generate_compare_long_string_different_encoding(StubGenStubId stub_id) {\n+  address generate_compare_long_string_different_encoding(StubId stub_id) {\n@@ -2601,1 +2601,1 @@\n-    case compare_long_string_LU_id:\n+    case StubId::stubgen_compare_long_string_LU_id:\n@@ -2604,1 +2604,1 @@\n-    case compare_long_string_UL_id:\n+    case StubId::stubgen_compare_long_string_UL_id:\n@@ -2700,1 +2700,1 @@\n-    StubGenStubId stub_id = StubGenStubId::method_entry_barrier_id;\n+    StubId stub_id = StubId::stubgen_method_entry_barrier_id;\n@@ -2771,1 +2771,1 @@\n-  address generate_compare_long_string_same_encoding(StubGenStubId stub_id) {\n+  address generate_compare_long_string_same_encoding(StubId stub_id) {\n@@ -2774,1 +2774,1 @@\n-    case compare_long_string_LL_id:\n+    case StubId::stubgen_compare_long_string_LL_id:\n@@ -2777,1 +2777,1 @@\n-    case compare_long_string_UU_id:\n+    case StubId::stubgen_compare_long_string_UU_id:\n@@ -2883,4 +2883,4 @@\n-    StubRoutines::riscv::_compare_long_string_LL = generate_compare_long_string_same_encoding(StubGenStubId::compare_long_string_LL_id);\n-    StubRoutines::riscv::_compare_long_string_UU = generate_compare_long_string_same_encoding(StubGenStubId::compare_long_string_UU_id);\n-    StubRoutines::riscv::_compare_long_string_LU = generate_compare_long_string_different_encoding(StubGenStubId::compare_long_string_LU_id);\n-    StubRoutines::riscv::_compare_long_string_UL = generate_compare_long_string_different_encoding(StubGenStubId::compare_long_string_UL_id);\n+    StubRoutines::riscv::_compare_long_string_LL = generate_compare_long_string_same_encoding(StubId::stubgen_compare_long_string_LL_id);\n+    StubRoutines::riscv::_compare_long_string_UU = generate_compare_long_string_same_encoding(StubId::stubgen_compare_long_string_UU_id);\n+    StubRoutines::riscv::_compare_long_string_LU = generate_compare_long_string_different_encoding(StubId::stubgen_compare_long_string_LU_id);\n+    StubRoutines::riscv::_compare_long_string_UL = generate_compare_long_string_different_encoding(StubId::stubgen_compare_long_string_UL_id);\n@@ -2894,1 +2894,1 @@\n-  address generate_string_indexof_linear(StubGenStubId stub_id)\n+  address generate_string_indexof_linear(StubId stub_id)\n@@ -2899,1 +2899,1 @@\n-    case string_indexof_linear_ll_id:\n+    case StubId::stubgen_string_indexof_linear_ll_id:\n@@ -2903,1 +2903,1 @@\n-    case string_indexof_linear_ul_id:\n+    case StubId::stubgen_string_indexof_linear_ul_id:\n@@ -2907,1 +2907,1 @@\n-    case string_indexof_linear_uu_id:\n+    case StubId::stubgen_string_indexof_linear_uu_id:\n@@ -3143,3 +3143,3 @@\n-    StubRoutines::riscv::_string_indexof_linear_ll = generate_string_indexof_linear(StubGenStubId::string_indexof_linear_ll_id);\n-    StubRoutines::riscv::_string_indexof_linear_uu = generate_string_indexof_linear(StubGenStubId::string_indexof_linear_uu_id);\n-    StubRoutines::riscv::_string_indexof_linear_ul = generate_string_indexof_linear(StubGenStubId::string_indexof_linear_ul_id);\n+    StubRoutines::riscv::_string_indexof_linear_ll = generate_string_indexof_linear(StubId::stubgen_string_indexof_linear_ll_id);\n+    StubRoutines::riscv::_string_indexof_linear_uu = generate_string_indexof_linear(StubId::stubgen_string_indexof_linear_uu_id);\n+    StubRoutines::riscv::_string_indexof_linear_ul = generate_string_indexof_linear(StubId::stubgen_string_indexof_linear_ul_id);\n@@ -3150,1 +3150,1 @@\n-    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n+    StubId stub_id = StubId::stubgen_lookup_secondary_supers_table_id;\n@@ -3176,1 +3176,1 @@\n-    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_slow_path_id;\n+    StubId stub_id = StubId::stubgen_lookup_secondary_supers_table_slow_path_id;\n@@ -3198,1 +3198,1 @@\n-    StubGenStubId stub_id = StubGenStubId::mulAdd_id;\n+    StubId stub_id = StubId::stubgen_mulAdd_id;\n@@ -3232,1 +3232,1 @@\n-    StubGenStubId stub_id = StubGenStubId::multiplyToLen_id;\n+    StubId stub_id = StubId::stubgen_multiplyToLen_id;\n@@ -3263,1 +3263,1 @@\n-    StubGenStubId stub_id = StubGenStubId::squareToLen_id;\n+    StubId stub_id = StubId::stubgen_squareToLen_id;\n@@ -3304,1 +3304,1 @@\n-    StubGenStubId stub_id = StubGenStubId::bigIntegerLeftShiftWorker_id;\n+    StubId stub_id = StubId::stubgen_bigIntegerLeftShiftWorker_id;\n@@ -3356,1 +3356,1 @@\n-    StubGenStubId stub_id = StubGenStubId::bigIntegerRightShiftWorker_id;\n+    StubId stub_id = StubId::stubgen_bigIntegerRightShiftWorker_id;\n@@ -4183,1 +4183,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cont_thaw_id;\n+    StubId stub_id = StubId::stubgen_cont_thaw_id;\n@@ -4194,1 +4194,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cont_returnBarrier_id;\n+    StubId stub_id = StubId::stubgen_cont_returnBarrier_id;\n@@ -4206,1 +4206,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cont_returnBarrierExc_id;\n+    StubId stub_id = StubId::stubgen_cont_returnBarrierExc_id;\n@@ -4217,1 +4217,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cont_preempt_id;\n+    StubId stub_id = StubId::stubgen_cont_preempt_id;\n@@ -4255,1 +4255,1 @@\n-      address generate_sha256_implCompress(StubGenStubId stub_id) {\n+      address generate_sha256_implCompress(StubId stub_id) {\n@@ -4258,1 +4258,1 @@\n-      address generate_sha512_implCompress(StubGenStubId stub_id) {\n+      address generate_sha512_implCompress(StubId stub_id) {\n@@ -4392,1 +4392,1 @@\n-    address generate_sha2_implCompress(Assembler::SEW vset_sew, StubGenStubId stub_id) {\n+    address generate_sha2_implCompress(Assembler::SEW vset_sew, StubId stub_id) {\n@@ -4444,1 +4444,1 @@\n-      case sha256_implCompress_id:\n+      case StubId::stubgen_sha256_implCompress_id:\n@@ -4448,1 +4448,1 @@\n-      case sha256_implCompressMB_id:\n+      case StubId::stubgen_sha256_implCompressMB_id:\n@@ -4452,1 +4452,1 @@\n-      case sha512_implCompress_id:\n+      case StubId::stubgen_sha512_implCompress_id:\n@@ -4456,1 +4456,1 @@\n-      case sha512_implCompressMB_id:\n+      case StubId::stubgen_sha512_implCompressMB_id:\n@@ -4811,1 +4811,1 @@\n-  address generate_md5_implCompress(StubGenStubId stub_id) {\n+  address generate_md5_implCompress(StubId stub_id) {\n@@ -4815,1 +4815,1 @@\n-    case md5_implCompress_id:\n+    case StubId::stubgen_md5_implCompress_id:\n@@ -4818,1 +4818,1 @@\n-    case md5_implCompressMB_id:\n+    case StubId::stubgen_md5_implCompressMB_id:\n@@ -5078,1 +5078,1 @@\n-    StubGenStubId stub_id = StubGenStubId::chacha20Block_id;\n+    StubId stub_id = StubId::stubgen_chacha20Block_id;\n@@ -5378,1 +5378,1 @@\n-  address generate_sha1_implCompress(StubGenStubId stub_id) {\n+  address generate_sha1_implCompress(StubId stub_id) {\n@@ -5381,1 +5381,1 @@\n-      case sha1_implCompress_id:\n+      case StubId::stubgen_sha1_implCompress_id:\n@@ -5384,1 +5384,1 @@\n-      case sha1_implCompressMB_id:\n+      case StubId::stubgen_sha1_implCompressMB_id:\n@@ -5601,1 +5601,1 @@\n-    StubGenStubId stub_id = StubGenStubId::base64_encodeBlock_id;\n+    StubId stub_id = StubId::stubgen_base64_encodeBlock_id;\n@@ -5858,1 +5858,1 @@\n-    StubGenStubId stub_id = StubGenStubId::base64_decodeBlock_id;\n+    StubId stub_id = StubId::stubgen_base64_decodeBlock_id;\n@@ -6103,1 +6103,1 @@\n-    StubGenStubId stub_id = StubGenStubId::updateBytesAdler32_id;\n+    StubId stub_id = StubId::stubgen_updateBytesAdler32_id;\n@@ -6281,1 +6281,1 @@\n-    StubGenStubId stub_id = StubGenStubId::hf2f_id;\n+    StubId stub_id = StubId::stubgen_hf2f_id;\n@@ -6332,1 +6332,1 @@\n-    StubGenStubId stub_id = StubGenStubId::f2hf_id;\n+    StubId stub_id = StubId::stubgen_f2hf_id;\n@@ -6460,1 +6460,1 @@\n-    StubGenStubId stub_id = StubGenStubId::poly1305_processBlocks_id;\n+    StubId stub_id = StubId::stubgen_poly1305_processBlocks_id;\n@@ -6598,1 +6598,1 @@\n-    StubGenStubId stub_id = StubGenStubId::updateBytesCRC32_id;\n+    StubId stub_id = StubId::stubgen_updateBytesCRC32_id;\n@@ -6623,1 +6623,1 @@\n-    StubGenStubId stub_id = StubGenStubId::upcall_stub_exception_handler_id;\n+    StubId stub_id = StubId::stubgen_upcall_stub_exception_handler_id;\n@@ -6641,1 +6641,1 @@\n-    StubGenStubId stub_id = StubGenStubId::upcall_stub_load_target_id;\n+    StubId stub_id = StubId::stubgen_upcall_stub_load_target_id;\n@@ -6750,1 +6750,1 @@\n-      StubGenStubId stub_id = StubGenStubId::montgomeryMultiply_id;\n+      StubId stub_id = StubId::stubgen_montgomeryMultiply_id;\n@@ -6757,1 +6757,1 @@\n-      StubGenStubId stub_id = StubGenStubId::montgomerySquare_id;\n+      StubId stub_id = StubId::stubgen_montgomerySquare_id;\n@@ -6779,2 +6779,2 @@\n-      StubRoutines::_sha256_implCompress   = sha2.generate_sha256_implCompress(StubGenStubId::sha256_implCompress_id);\n-      StubRoutines::_sha256_implCompressMB = sha2.generate_sha256_implCompress(StubGenStubId::sha256_implCompressMB_id);\n+      StubRoutines::_sha256_implCompress   = sha2.generate_sha256_implCompress(StubId::stubgen_sha256_implCompress_id);\n+      StubRoutines::_sha256_implCompressMB = sha2.generate_sha256_implCompress(StubId::stubgen_sha256_implCompressMB_id);\n@@ -6785,2 +6785,2 @@\n-      StubRoutines::_sha512_implCompress   = sha2.generate_sha512_implCompress(StubGenStubId::sha512_implCompress_id);\n-      StubRoutines::_sha512_implCompressMB = sha2.generate_sha512_implCompress(StubGenStubId::sha512_implCompressMB_id);\n+      StubRoutines::_sha512_implCompress   = sha2.generate_sha512_implCompress(StubId::stubgen_sha512_implCompress_id);\n+      StubRoutines::_sha512_implCompressMB = sha2.generate_sha512_implCompress(StubId::stubgen_sha512_implCompressMB_id);\n@@ -6790,2 +6790,2 @@\n-      StubRoutines::_md5_implCompress   = generate_md5_implCompress(StubGenStubId::md5_implCompress_id);\n-      StubRoutines::_md5_implCompressMB = generate_md5_implCompress(StubGenStubId::md5_implCompressMB_id);\n+      StubRoutines::_md5_implCompress   = generate_md5_implCompress(StubId::stubgen_md5_implCompress_id);\n+      StubRoutines::_md5_implCompressMB = generate_md5_implCompress(StubId::stubgen_md5_implCompressMB_id);\n@@ -6799,2 +6799,2 @@\n-      StubRoutines::_sha1_implCompress     = generate_sha1_implCompress(StubGenStubId::sha1_implCompress_id);\n-      StubRoutines::_sha1_implCompressMB   = generate_sha1_implCompress(StubGenStubId::sha1_implCompressMB_id);\n+      StubRoutines::_sha1_implCompress     = generate_sha1_implCompress(StubId::stubgen_sha1_implCompress_id);\n+      StubRoutines::_sha1_implCompressMB   = generate_sha1_implCompress(StubId::stubgen_sha1_implCompressMB_id);\n@@ -6820,1 +6820,1 @@\n-  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+  StubGenerator(CodeBuffer* code, BlobId blob_id) : StubCodeGenerator(code, blob_id) {\n@@ -6822,1 +6822,1 @@\n-    case preuniverse_id:\n+    case BlobId::stubgen_preuniverse_id:\n@@ -6825,1 +6825,1 @@\n-    case initial_id:\n+    case BlobId::stubgen_initial_id:\n@@ -6828,1 +6828,1 @@\n-     case continuation_id:\n+    case BlobId::stubgen_continuation_id:\n@@ -6831,1 +6831,1 @@\n-    case compiler_id:\n+    case BlobId::stubgen_compiler_id:\n@@ -6834,1 +6834,1 @@\n-    case final_id:\n+    case BlobId::stubgen_final_id:\n@@ -6838,1 +6838,1 @@\n-      fatal(\"unexpected blob id: %d\", blob_id);\n+      fatal(\"unexpected blob id: %s\", StubInfo::name(blob_id));\n@@ -6844,1 +6844,1 @@\n-void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+void StubGenerator_generate(CodeBuffer* code, BlobId blob_id) {\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":147,"deletions":147,"binary":false,"changes":294,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-    address a = Runtime1::entry_for (C1StubId::predicate_failed_trap_id);\n+    address a = Runtime1::entry_for (StubId::c1_predicate_failed_trap_id);\n@@ -66,1 +66,1 @@\n-  C1StubId stub_id;\n+  StubId stub_id;\n@@ -68,1 +68,1 @@\n-    stub_id = C1StubId::throw_index_exception_id;\n+    stub_id = StubId::c1_throw_index_exception_id;\n@@ -70,1 +70,1 @@\n-    stub_id = C1StubId::throw_range_check_failed_id;\n+    stub_id = StubId::c1_throw_range_check_failed_id;\n@@ -86,1 +86,1 @@\n-  address a = Runtime1::entry_for (C1StubId::predicate_failed_trap_id);\n+  address a = Runtime1::entry_for (StubId::c1_predicate_failed_trap_id);\n@@ -104,1 +104,1 @@\n-  ce->emit_call_c(Runtime1::entry_for (C1StubId::counter_overflow_id));\n+  ce->emit_call_c(Runtime1::entry_for (StubId::c1_counter_overflow_id));\n@@ -116,1 +116,1 @@\n-  ce->emit_call_c(Runtime1::entry_for (C1StubId::throw_div0_exception_id));\n+  ce->emit_call_c(Runtime1::entry_for (StubId::c1_throw_div0_exception_id));\n@@ -126,1 +126,1 @@\n-    a = Runtime1::entry_for (C1StubId::predicate_failed_trap_id);\n+    a = Runtime1::entry_for (StubId::c1_predicate_failed_trap_id);\n@@ -128,1 +128,1 @@\n-    a = Runtime1::entry_for (C1StubId::throw_null_pointer_exception_id);\n+    a = Runtime1::entry_for (StubId::c1_throw_null_pointer_exception_id);\n@@ -153,1 +153,1 @@\n-NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, C1StubId stub_id) {\n+NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, StubId stub_id) {\n@@ -158,3 +158,3 @@\n-  assert(stub_id == C1StubId::new_instance_id                 ||\n-         stub_id == C1StubId::fast_new_instance_id            ||\n-         stub_id == C1StubId::fast_new_instance_init_check_id,\n+  assert(stub_id == StubId::c1_new_instance_id                 ||\n+         stub_id == StubId::c1_fast_new_instance_id            ||\n+         stub_id == StubId::c1_fast_new_instance_init_check_id,\n@@ -188,1 +188,1 @@\n-  address a = Runtime1::entry_for (C1StubId::new_type_array_id);\n+  address a = Runtime1::entry_for (StubId::c1_new_type_array_id);\n@@ -208,1 +208,1 @@\n-  address a = Runtime1::entry_for (C1StubId::new_object_array_id);\n+  address a = Runtime1::entry_for (StubId::c1_new_object_array_id);\n@@ -219,1 +219,1 @@\n-  C1StubId enter_id;\n+  StubId enter_id;\n@@ -221,1 +221,1 @@\n-    enter_id = C1StubId::monitorenter_id;\n+    enter_id = StubId::c1_monitorenter_id;\n@@ -223,1 +223,1 @@\n-    enter_id = C1StubId::monitorenter_nofpu_id;\n+    enter_id = StubId::c1_monitorenter_nofpu_id;\n@@ -244,1 +244,1 @@\n-  C1StubId exit_id;\n+  StubId exit_id;\n@@ -246,1 +246,1 @@\n-    exit_id = C1StubId::monitorexit_id;\n+    exit_id = StubId::c1_monitorexit_id;\n@@ -248,1 +248,1 @@\n-    exit_id = C1StubId::monitorexit_nofpu_id;\n+    exit_id = StubId::c1_monitorexit_nofpu_id;\n@@ -380,4 +380,4 @@\n-    case access_field_id:  target = Runtime1::entry_for (C1StubId::access_field_patching_id); break;\n-    case load_klass_id:    target = Runtime1::entry_for (C1StubId::load_klass_patching_id); reloc_type = relocInfo::metadata_type; break;\n-    case load_mirror_id:   target = Runtime1::entry_for (C1StubId::load_mirror_patching_id); reloc_type = relocInfo::oop_type; break;\n-    case load_appendix_id: target = Runtime1::entry_for (C1StubId::load_appendix_patching_id); reloc_type = relocInfo::oop_type; break;\n+    case access_field_id:  target = Runtime1::entry_for (StubId::c1_access_field_patching_id); break;\n+    case load_klass_id:    target = Runtime1::entry_for (StubId::c1_load_klass_patching_id); reloc_type = relocInfo::metadata_type; break;\n+    case load_mirror_id:   target = Runtime1::entry_for (StubId::c1_load_mirror_patching_id); reloc_type = relocInfo::oop_type; break;\n+    case load_appendix_id: target = Runtime1::entry_for (StubId::c1_load_appendix_patching_id); reloc_type = relocInfo::oop_type; break;\n@@ -408,1 +408,1 @@\n-  ce->emit_call_c(Runtime1::entry_for (C1StubId::deoptimize_id));\n+  ce->emit_call_c(Runtime1::entry_for (StubId::c1_deoptimize_id));\n","filename":"src\/hotspot\/cpu\/s390\/c1_CodeStubs_s390.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-  address a = Runtime1::entry_for (C1StubId::handle_exception_from_callee_id);\n+  address a = Runtime1::entry_for (StubId::c1_handle_exception_from_callee_id);\n@@ -228,1 +228,1 @@\n-    \/\/ C1StubId::monitorexit_id expects lock address in Z_R1_scratch.\n+    \/\/ StubId::c1_monitorexit_id expects lock address in Z_R1_scratch.\n@@ -261,1 +261,1 @@\n-  __ load_const_optimized(Z_R5, Runtime1::entry_for (C1StubId::unwind_exception_id));\n+  __ load_const_optimized(Z_R5, Runtime1::entry_for (StubId::c1_unwind_exception_id));\n@@ -1934,2 +1934,2 @@\n-  address stub = Runtime1::entry_for (compilation()->has_fpu_code() ? C1StubId::handle_exception_id\n-                                                                    : C1StubId::handle_exception_nofpu_id);\n+  address stub = Runtime1::entry_for (compilation()->has_fpu_code() ? StubId::c1_handle_exception_id\n+                                                                    : StubId::c1_handle_exception_nofpu_id);\n@@ -2132,1 +2132,1 @@\n-      emit_call_c(Runtime1::entry_for (C1StubId::slow_subtype_check_id));\n+      emit_call_c(Runtime1::entry_for (StubId::c1_slow_subtype_check_id));\n@@ -2552,1 +2552,1 @@\n-      address a = Runtime1::entry_for (C1StubId::slow_subtype_check_id);\n+      address a = Runtime1::entry_for (StubId::c1_slow_subtype_check_id);\n@@ -2627,1 +2627,1 @@\n-    address a = Runtime1::entry_for (C1StubId::slow_subtype_check_id);\n+    address a = Runtime1::entry_for (StubId::c1_slow_subtype_check_id);\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -893,1 +893,1 @@\n-  __ call_runtime(Runtime1::entry_for (C1StubId::new_multi_array_id),\n+  __ call_runtime(Runtime1::entry_for (StubId::c1_new_multi_array_id),\n@@ -924,1 +924,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);\n+    stub = new SimpleExceptionStub(StubId::c1_throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);\n@@ -931,1 +931,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_class_cast_exception_id, obj.result(), info_for_exception);\n+    stub = new SimpleExceptionStub(StubId::c1_throw_class_cast_exception_id, obj.result(), info_for_exception);\n@@ -964,1 +964,1 @@\n-  return Runtime1::entry_for(C1StubId::is_instance_of_id);\n+  return Runtime1::entry_for(StubId::c1_is_instance_of_id);\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRGenerator_s390.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-  \/\/    call(RuntimeAddress(Runtime1::entry_for (C1StubId::dtrace_object_alloc_id)));\n+  \/\/    call(RuntimeAddress(Runtime1::entry_for (StubId::c1_dtrace_object_alloc_id)));\n@@ -326,1 +326,1 @@\n-  \/\/   call(RuntimeAddress(Runtime1::entry_for (C1StubId::dtrace_object_alloc_id)));\n+  \/\/   call(RuntimeAddress(Runtime1::entry_for (StubId::c1_dtrace_object_alloc_id)));\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-    } else if (_stub_id == (int)C1StubId::forward_exception_id) {\n+    } else if (_stub_id == (int)StubId::c1_forward_exception_id) {\n@@ -103,1 +103,1 @@\n-      load_const_optimized(Z_R1, Runtime1::entry_for (C1StubId::forward_exception_id));\n+      load_const_optimized(Z_R1, Runtime1::entry_for (StubId::c1_forward_exception_id));\n@@ -312,1 +312,1 @@\n-OopMapSet* Runtime1::generate_code_for(C1StubId id, StubAssembler* sasm) {\n+OopMapSet* Runtime1::generate_code_for(StubId id, StubAssembler* sasm) {\n@@ -325,1 +325,1 @@\n-    case C1StubId::forward_exception_id:\n+    case StubId::c1_forward_exception_id:\n@@ -332,3 +332,3 @@\n-    case C1StubId::new_instance_id:\n-    case C1StubId::fast_new_instance_id:\n-    case C1StubId::fast_new_instance_init_check_id:\n+    case StubId::c1_new_instance_id:\n+    case StubId::c1_fast_new_instance_id:\n+    case StubId::c1_fast_new_instance_init_check_id:\n@@ -339,1 +339,1 @@\n-        if (id == C1StubId::new_instance_id) {\n+        if (id == StubId::c1_new_instance_id) {\n@@ -341,1 +341,1 @@\n-        } else if (id == C1StubId::fast_new_instance_id) {\n+        } else if (id == StubId::c1_fast_new_instance_id) {\n@@ -344,1 +344,1 @@\n-          assert(id == C1StubId::fast_new_instance_init_check_id, \"bad C1StubId\");\n+          assert(id == StubId::c1_fast_new_instance_init_check_id, \"bad StubId\");\n@@ -359,1 +359,1 @@\n-    case C1StubId::counter_overflow_id:\n+    case StubId::c1_counter_overflow_id:\n@@ -378,2 +378,2 @@\n-    case C1StubId::new_type_array_id:\n-    case C1StubId::new_object_array_id:\n+    case StubId::c1_new_type_array_id:\n+    case StubId::c1_new_object_array_id:\n@@ -385,1 +385,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -398,1 +398,1 @@\n-          int tag = ((id == C1StubId::new_type_array_id)\n+          int tag = ((id == StubId::c1_new_type_array_id)\n@@ -410,1 +410,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -425,1 +425,1 @@\n-    case C1StubId::new_multi_array_id:\n+    case StubId::c1_new_multi_array_id:\n@@ -443,1 +443,1 @@\n-    case C1StubId::register_finalizer_id:\n+    case StubId::c1_register_finalizer_id:\n@@ -466,1 +466,1 @@\n-    case C1StubId::throw_range_check_failed_id:\n+    case StubId::c1_throw_range_check_failed_id:\n@@ -472,1 +472,1 @@\n-    case C1StubId::throw_index_exception_id:\n+    case StubId::c1_throw_index_exception_id:\n@@ -477,1 +477,1 @@\n-    case C1StubId::throw_div0_exception_id:\n+    case StubId::c1_throw_div0_exception_id:\n@@ -482,1 +482,1 @@\n-    case C1StubId::throw_null_pointer_exception_id:\n+    case StubId::c1_throw_null_pointer_exception_id:\n@@ -487,2 +487,2 @@\n-    case C1StubId::handle_exception_nofpu_id:\n-    case C1StubId::handle_exception_id:\n+    case StubId::c1_handle_exception_nofpu_id:\n+    case StubId::c1_handle_exception_id:\n@@ -493,1 +493,1 @@\n-    case C1StubId::handle_exception_from_callee_id:\n+    case StubId::c1_handle_exception_from_callee_id:\n@@ -498,1 +498,1 @@\n-    case C1StubId::unwind_exception_id:\n+    case StubId::c1_unwind_exception_id:\n@@ -505,1 +505,1 @@\n-    case C1StubId::throw_array_store_exception_id:\n+    case StubId::c1_throw_array_store_exception_id:\n@@ -510,1 +510,1 @@\n-    case C1StubId::throw_class_cast_exception_id:\n+    case StubId::c1_throw_class_cast_exception_id:\n@@ -516,1 +516,1 @@\n-    case C1StubId::throw_incompatible_class_change_error_id:\n+    case StubId::c1_throw_incompatible_class_change_error_id:\n@@ -521,1 +521,1 @@\n-    case C1StubId::slow_subtype_check_id:\n+    case StubId::c1_slow_subtype_check_id:\n@@ -592,1 +592,1 @@\n-    case C1StubId::is_instance_of_id:\n+    case StubId::c1_is_instance_of_id:\n@@ -653,2 +653,2 @@\n-    case C1StubId::monitorenter_nofpu_id:\n-    case C1StubId::monitorenter_id:\n+    case StubId::c1_monitorenter_nofpu_id:\n+    case StubId::c1_monitorenter_id:\n@@ -659,1 +659,1 @@\n-        int save_fpu_registers = (id == C1StubId::monitorenter_id);\n+        int save_fpu_registers = (id == StubId::c1_monitorenter_id);\n@@ -673,2 +673,2 @@\n-    case C1StubId::monitorexit_nofpu_id:\n-    case C1StubId::monitorexit_id:\n+    case StubId::c1_monitorexit_nofpu_id:\n+    case StubId::c1_monitorexit_id:\n@@ -681,1 +681,1 @@\n-        int save_fpu_registers = (id == C1StubId::monitorexit_id);\n+        int save_fpu_registers = (id == StubId::c1_monitorexit_id);\n@@ -695,1 +695,1 @@\n-    case C1StubId::deoptimize_id:\n+    case StubId::c1_deoptimize_id:\n@@ -712,1 +712,1 @@\n-    case C1StubId::access_field_patching_id:\n+    case StubId::c1_access_field_patching_id:\n@@ -718,1 +718,1 @@\n-    case C1StubId::load_klass_patching_id:\n+    case StubId::c1_load_klass_patching_id:\n@@ -725,1 +725,1 @@\n-    case C1StubId::load_mirror_patching_id:\n+    case StubId::c1_load_mirror_patching_id:\n@@ -731,1 +731,1 @@\n-    case C1StubId::load_appendix_patching_id:\n+    case StubId::c1_load_appendix_patching_id:\n@@ -737,1 +737,1 @@\n-    case C1StubId::dtrace_object_alloc_id:\n+    case StubId::c1_dtrace_object_alloc_id:\n@@ -752,1 +752,1 @@\n-    case C1StubId::fpu2long_stub_id:\n+    case StubId::c1_fpu2long_stub_id:\n@@ -827,1 +827,1 @@\n-    case C1StubId::predicate_failed_trap_id:\n+    case StubId::c1_predicate_failed_trap_id:\n@@ -855,1 +855,1 @@\n-OopMapSet* Runtime1::generate_handle_exception(C1StubId id, StubAssembler *sasm) {\n+OopMapSet* Runtime1::generate_handle_exception(StubId id, StubAssembler *sasm) {\n@@ -866,1 +866,1 @@\n-    case C1StubId::forward_exception_id: {\n+    case StubId::c1_forward_exception_id: {\n@@ -893,2 +893,2 @@\n-    case C1StubId::handle_exception_nofpu_id:\n-    case C1StubId::handle_exception_id:\n+    case StubId::c1_handle_exception_nofpu_id:\n+    case StubId::c1_handle_exception_id:\n@@ -897,1 +897,1 @@\n-      oop_map = save_live_registers(sasm, id != C1StubId::handle_exception_nofpu_id, Z_EXC_PC);\n+      oop_map = save_live_registers(sasm, id != StubId::c1_handle_exception_nofpu_id, Z_EXC_PC);\n@@ -899,1 +899,1 @@\n-    case C1StubId::handle_exception_from_callee_id: {\n+    case StubId::c1_handle_exception_from_callee_id: {\n@@ -948,3 +948,3 @@\n-    case C1StubId::forward_exception_id:\n-    case C1StubId::handle_exception_nofpu_id:\n-    case C1StubId::handle_exception_id:\n+    case StubId::c1_forward_exception_id:\n+    case StubId::c1_handle_exception_nofpu_id:\n+    case StubId::c1_handle_exception_id:\n@@ -953,1 +953,1 @@\n-      restore_live_registers(sasm, id != C1StubId::handle_exception_nofpu_id);  \/\/ Pops as well the frame.\n+      restore_live_registers(sasm, id != StubId::c1_handle_exception_nofpu_id);  \/\/ Pops as well the frame.\n@@ -956,1 +956,1 @@\n-    case C1StubId::handle_exception_from_callee_id: {\n+    case StubId::c1_handle_exception_from_callee_id: {\n","filename":"src\/hotspot\/cpu\/s390\/c1_Runtime1_s390.cpp","additions":56,"deletions":56,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n+  const char* name = OptoRuntime::stub_name(StubId::c2_exception_id);\n","filename":"src\/hotspot\/cpu\/s390\/runtime_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2547,1 +2547,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::deopt_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_deopt_id);\n@@ -2770,1 +2770,1 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n+  const char* name = OptoRuntime::stub_name(StubId::c2_uncommon_trap_id);\n@@ -2898,1 +2898,1 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(StubId id, address call_ptr) {\n@@ -2916,1 +2916,1 @@\n-  bool cause_return = (id == SharedStubId::polling_page_return_handler_id);\n+  bool cause_return = (id == StubId::shared_polling_page_return_handler_id);\n@@ -2922,1 +2922,1 @@\n-  bool save_vectors = (id == SharedStubId::polling_page_vectors_safepoint_handler_id);\n+  bool save_vectors = (id == StubId::shared_polling_page_vectors_safepoint_handler_id);\n@@ -3002,1 +3002,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(StubId id, address destination) {\n@@ -3101,1 +3101,1 @@\n-RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+RuntimeStub* SharedRuntime::generate_throw_exception(StubId id, address runtime_entry) {\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-    StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+    StubId stub_id = StubId::stubgen_call_stub_id;\n@@ -462,1 +462,1 @@\n-    StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+    StubId stub_id = StubId::stubgen_catch_exception_id;\n@@ -514,1 +514,1 @@\n-    StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+    StubId stub_id = StubId::stubgen_forward_exception_id;\n@@ -595,1 +595,1 @@\n-    StubGenStubId stub_id = StubGenStubId::partial_subtype_check_id;\n+    StubId stub_id = StubId::stubgen_partial_subtype_check_id;\n@@ -629,1 +629,1 @@\n-    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n+    StubId stub_id = StubId::stubgen_lookup_secondary_supers_table_id;\n@@ -652,1 +652,1 @@\n-    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_slow_path_id;\n+    StubId stub_id = StubId::stubgen_lookup_secondary_supers_table_slow_path_id;\n@@ -1268,1 +1268,1 @@\n-  address generate_disjoint_nonoop_copy(StubGenStubId stub_id) {\n+  address generate_disjoint_nonoop_copy(StubId stub_id) {\n@@ -1272,1 +1272,1 @@\n-    case jbyte_disjoint_arraycopy_id:\n+    case StubId::stubgen_jbyte_disjoint_arraycopy_id:\n@@ -1276,1 +1276,1 @@\n-    case arrayof_jbyte_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id:\n@@ -1280,1 +1280,1 @@\n-    case jshort_disjoint_arraycopy_id:\n+    case StubId::stubgen_jshort_disjoint_arraycopy_id:\n@@ -1284,1 +1284,1 @@\n-    case arrayof_jshort_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id:\n@@ -1288,1 +1288,1 @@\n-    case jint_disjoint_arraycopy_id:\n+    case StubId::stubgen_jint_disjoint_arraycopy_id:\n@@ -1292,1 +1292,1 @@\n-    case arrayof_jint_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jint_disjoint_arraycopy_id:\n@@ -1296,1 +1296,1 @@\n-    case jlong_disjoint_arraycopy_id:\n+    case StubId::stubgen_jlong_disjoint_arraycopy_id:\n@@ -1300,1 +1300,1 @@\n-    case arrayof_jlong_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id:\n@@ -1313,1 +1313,1 @@\n-  address generate_disjoint_oop_copy(StubGenStubId stub_id) {\n+  address generate_disjoint_oop_copy(StubId stub_id) {\n@@ -1317,1 +1317,1 @@\n-    case oop_disjoint_arraycopy_id:\n+    case StubId::stubgen_oop_disjoint_arraycopy_id:\n@@ -1321,1 +1321,1 @@\n-    case arrayof_oop_disjoint_arraycopy_id:\n+    case StubId::stubgen_arrayof_oop_disjoint_arraycopy_id:\n@@ -1325,1 +1325,1 @@\n-    case oop_disjoint_arraycopy_uninit_id:\n+    case StubId::stubgen_oop_disjoint_arraycopy_uninit_id:\n@@ -1329,1 +1329,1 @@\n-    case arrayof_oop_disjoint_arraycopy_uninit_id:\n+    case StubId::stubgen_arrayof_oop_disjoint_arraycopy_uninit_id:\n@@ -1360,1 +1360,1 @@\n-  address generate_conjoint_nonoop_copy(StubGenStubId stub_id) {\n+  address generate_conjoint_nonoop_copy(StubId stub_id) {\n@@ -1365,1 +1365,1 @@\n-    case jbyte_arraycopy_id:\n+    case StubId::stubgen_jbyte_arraycopy_id:\n@@ -1370,1 +1370,1 @@\n-    case arrayof_jbyte_arraycopy_id:\n+    case StubId::stubgen_arrayof_jbyte_arraycopy_id:\n@@ -1375,1 +1375,1 @@\n-    case jshort_arraycopy_id:\n+    case StubId::stubgen_jshort_arraycopy_id:\n@@ -1380,1 +1380,1 @@\n-    case arrayof_jshort_arraycopy_id:\n+    case StubId::stubgen_arrayof_jshort_arraycopy_id:\n@@ -1385,1 +1385,1 @@\n-    case jint_arraycopy_id:\n+    case StubId::stubgen_jint_arraycopy_id:\n@@ -1390,1 +1390,1 @@\n-    case arrayof_jint_arraycopy_id:\n+    case StubId::stubgen_arrayof_jint_arraycopy_id:\n@@ -1395,1 +1395,1 @@\n-    case jlong_arraycopy_id:\n+    case StubId::stubgen_jlong_arraycopy_id:\n@@ -1400,1 +1400,1 @@\n-    case arrayof_jlong_arraycopy_id:\n+    case StubId::stubgen_arrayof_jlong_arraycopy_id:\n@@ -1415,1 +1415,1 @@\n-  address generate_conjoint_oop_copy(StubGenStubId stub_id) {\n+  address generate_conjoint_oop_copy(StubId stub_id) {\n@@ -1420,1 +1420,1 @@\n-    case oop_arraycopy_id:\n+    case StubId::stubgen_oop_arraycopy_id:\n@@ -1425,1 +1425,1 @@\n-    case arrayof_oop_arraycopy_id:\n+    case StubId::stubgen_arrayof_oop_arraycopy_id:\n@@ -1430,1 +1430,1 @@\n-    case oop_arraycopy_uninit_id:\n+    case StubId::stubgen_oop_arraycopy_uninit_id:\n@@ -1435,1 +1435,1 @@\n-    case arrayof_oop_arraycopy_uninit_id:\n+    case StubId::stubgen_arrayof_oop_arraycopy_uninit_id:\n@@ -1483,1 +1483,1 @@\n-    StubCodeMark mark(this, StubGenStubId::unsafe_setmemory_id);\n+    StubCodeMark mark(this, StubId::stubgen_unsafe_setmemory_id);\n@@ -1585,27 +1585,27 @@\n-    StubRoutines::_jbyte_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubGenStubId::jbyte_disjoint_arraycopy_id);\n-    StubRoutines::_jshort_disjoint_arraycopy     = generate_disjoint_nonoop_copy(StubGenStubId::jshort_disjoint_arraycopy_id);\n-    StubRoutines::_jint_disjoint_arraycopy       = generate_disjoint_nonoop_copy  (StubGenStubId::jint_disjoint_arraycopy_id);\n-    StubRoutines::_jlong_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubGenStubId::jlong_disjoint_arraycopy_id);\n-    StubRoutines::_oop_disjoint_arraycopy        = generate_disjoint_oop_copy  (StubGenStubId::oop_disjoint_arraycopy_id);\n-    StubRoutines::_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy  (StubGenStubId::oop_disjoint_arraycopy_uninit_id);\n-\n-    StubRoutines::_arrayof_jbyte_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubGenStubId::arrayof_jbyte_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_jshort_disjoint_arraycopy     = generate_disjoint_nonoop_copy(StubGenStubId::arrayof_jshort_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_jint_disjoint_arraycopy       = generate_disjoint_nonoop_copy  (StubGenStubId::arrayof_jint_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_jlong_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubGenStubId::arrayof_jlong_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_oop_disjoint_arraycopy        = generate_disjoint_oop_copy  (StubGenStubId::arrayof_oop_disjoint_arraycopy_id);\n-    StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy  (StubGenStubId::arrayof_oop_disjoint_arraycopy_uninit_id);\n-\n-    StubRoutines::_jbyte_arraycopy           = generate_conjoint_nonoop_copy(StubGenStubId::jbyte_arraycopy_id);\n-    StubRoutines::_jshort_arraycopy          = generate_conjoint_nonoop_copy(StubGenStubId::jshort_arraycopy_id);\n-    StubRoutines::_jint_arraycopy            = generate_conjoint_nonoop_copy(StubGenStubId::jint_arraycopy_id);\n-    StubRoutines::_jlong_arraycopy           = generate_conjoint_nonoop_copy(StubGenStubId::jlong_arraycopy_id);\n-    StubRoutines::_oop_arraycopy             = generate_conjoint_oop_copy(StubGenStubId::oop_arraycopy_id);\n-    StubRoutines::_oop_arraycopy_uninit      = generate_conjoint_oop_copy(StubGenStubId::oop_arraycopy_uninit_id);\n-\n-    StubRoutines::_arrayof_jbyte_arraycopy      = generate_conjoint_nonoop_copy(StubGenStubId::arrayof_jbyte_arraycopy_id);\n-    StubRoutines::_arrayof_jshort_arraycopy     = generate_conjoint_nonoop_copy(StubGenStubId::arrayof_jshort_arraycopy_id);\n-    StubRoutines::_arrayof_jint_arraycopy       = generate_conjoint_nonoop_copy (StubGenStubId::arrayof_jint_arraycopy_id);\n-    StubRoutines::_arrayof_jlong_arraycopy      = generate_conjoint_nonoop_copy(StubGenStubId::arrayof_jlong_arraycopy_id);\n-    StubRoutines::_arrayof_oop_arraycopy        = generate_conjoint_oop_copy(StubGenStubId::arrayof_oop_arraycopy_id);\n-    StubRoutines::_arrayof_oop_arraycopy_uninit = generate_conjoint_oop_copy(StubGenStubId::arrayof_oop_arraycopy_uninit_id);\n+    StubRoutines::_jbyte_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubId::stubgen_jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_jshort_disjoint_arraycopy     = generate_disjoint_nonoop_copy(StubId::stubgen_jshort_disjoint_arraycopy_id);\n+    StubRoutines::_jint_disjoint_arraycopy       = generate_disjoint_nonoop_copy  (StubId::stubgen_jint_disjoint_arraycopy_id);\n+    StubRoutines::_jlong_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubId::stubgen_jlong_disjoint_arraycopy_id);\n+    StubRoutines::_oop_disjoint_arraycopy        = generate_disjoint_oop_copy  (StubId::stubgen_oop_disjoint_arraycopy_id);\n+    StubRoutines::_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy  (StubId::stubgen_oop_disjoint_arraycopy_uninit_id);\n+\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy     = generate_disjoint_nonoop_copy(StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy       = generate_disjoint_nonoop_copy  (StubId::stubgen_arrayof_jint_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy        = generate_disjoint_oop_copy  (StubId::stubgen_arrayof_oop_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy  (StubId::stubgen_arrayof_oop_disjoint_arraycopy_uninit_id);\n+\n+    StubRoutines::_jbyte_arraycopy           = generate_conjoint_nonoop_copy(StubId::stubgen_jbyte_arraycopy_id);\n+    StubRoutines::_jshort_arraycopy          = generate_conjoint_nonoop_copy(StubId::stubgen_jshort_arraycopy_id);\n+    StubRoutines::_jint_arraycopy            = generate_conjoint_nonoop_copy(StubId::stubgen_jint_arraycopy_id);\n+    StubRoutines::_jlong_arraycopy           = generate_conjoint_nonoop_copy(StubId::stubgen_jlong_arraycopy_id);\n+    StubRoutines::_oop_arraycopy             = generate_conjoint_oop_copy(StubId::stubgen_oop_arraycopy_id);\n+    StubRoutines::_oop_arraycopy_uninit      = generate_conjoint_oop_copy(StubId::stubgen_oop_arraycopy_uninit_id);\n+\n+    StubRoutines::_arrayof_jbyte_arraycopy      = generate_conjoint_nonoop_copy(StubId::stubgen_arrayof_jbyte_arraycopy_id);\n+    StubRoutines::_arrayof_jshort_arraycopy     = generate_conjoint_nonoop_copy(StubId::stubgen_arrayof_jshort_arraycopy_id);\n+    StubRoutines::_arrayof_jint_arraycopy       = generate_conjoint_nonoop_copy (StubId::stubgen_arrayof_jint_arraycopy_id);\n+    StubRoutines::_arrayof_jlong_arraycopy      = generate_conjoint_nonoop_copy(StubId::stubgen_arrayof_jlong_arraycopy_id);\n+    StubRoutines::_arrayof_oop_arraycopy        = generate_conjoint_oop_copy(StubId::stubgen_arrayof_oop_arraycopy_id);\n+    StubRoutines::_arrayof_oop_arraycopy_uninit = generate_conjoint_oop_copy(StubId::stubgen_arrayof_oop_arraycopy_uninit_id);\n@@ -1901,1 +1901,1 @@\n-    StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+    StubId stub_id = StubId::stubgen_aescrypt_encryptBlock_id;\n@@ -1913,1 +1913,1 @@\n-    StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+    StubId stub_id = StubId::stubgen_aescrypt_decryptBlock_id;\n@@ -1974,1 +1974,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_encryptAESCrypt_id;\n+    StubId stub_id = StubId::stubgen_cipherBlockChaining_encryptAESCrypt_id;\n@@ -1986,1 +1986,1 @@\n-    StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_decryptAESCrypt_id;\n+    StubId stub_id = StubId::stubgen_cipherBlockChaining_decryptAESCrypt_id;\n@@ -2693,1 +2693,1 @@\n-    StubGenStubId stub_id = StubGenStubId::counterMode_AESCrypt_id;\n+    StubId stub_id = StubId::stubgen_counterMode_AESCrypt_id;\n@@ -2707,1 +2707,1 @@\n-    StubGenStubId stub_id = StubGenStubId::ghash_processBlocks_id;\n+    StubId stub_id = StubId::stubgen_ghash_processBlocks_id;\n@@ -2785,1 +2785,1 @@\n-  address generate_SHA1_stub(StubGenStubId stub_id) {\n+  address generate_SHA1_stub(StubId stub_id) {\n@@ -2788,1 +2788,1 @@\n-    case sha1_implCompress_id:\n+    case StubId::stubgen_sha1_implCompress_id:\n@@ -2791,1 +2791,1 @@\n-    case sha1_implCompressMB_id:\n+    case StubId::stubgen_sha1_implCompressMB_id:\n@@ -2878,1 +2878,1 @@\n-  address generate_SHA256_stub(StubGenStubId stub_id) {\n+  address generate_SHA256_stub(StubId stub_id) {\n@@ -2881,1 +2881,1 @@\n-    case sha256_implCompress_id:\n+    case StubId::stubgen_sha256_implCompress_id:\n@@ -2884,1 +2884,1 @@\n-    case sha256_implCompressMB_id:\n+    case StubId::stubgen_sha256_implCompressMB_id:\n@@ -2969,1 +2969,1 @@\n-  address generate_SHA512_stub(StubGenStubId stub_id) {\n+  address generate_SHA512_stub(StubId stub_id) {\n@@ -2972,1 +2972,1 @@\n-    case sha512_implCompress_id:\n+    case StubId::stubgen_sha512_implCompress_id:\n@@ -2975,1 +2975,1 @@\n-    case sha512_implCompressMB_id:\n+    case StubId::stubgen_sha512_implCompressMB_id:\n@@ -3105,1 +3105,1 @@\n-    StubGenStubId stub_id =  StubGenStubId::updateBytesCRC32_id;\n+    StubId stub_id =  StubId::stubgen_updateBytesCRC32_id;\n@@ -3125,1 +3125,1 @@\n-    StubGenStubId stub_id =  StubGenStubId::updateBytesCRC32C_id;\n+    StubId stub_id =  StubId::stubgen_updateBytesCRC32C_id;\n@@ -3150,1 +3150,1 @@\n-    StubGenStubId stub_id =  StubGenStubId::multiplyToLen_id;\n+    StubId stub_id =  StubId::stubgen_multiplyToLen_id;\n@@ -3182,1 +3182,1 @@\n-    StubGenStubId stub_id =  StubGenStubId::method_entry_barrier_id;\n+    StubId stub_id =  StubId::stubgen_method_entry_barrier_id;\n@@ -3248,1 +3248,1 @@\n-    StubGenStubId stub_id =  StubGenStubId::upcall_stub_exception_handler_id;\n+    StubId stub_id =  StubId::stubgen_upcall_stub_exception_handler_id;\n@@ -3266,1 +3266,1 @@\n-    StubGenStubId stub_id =  StubGenStubId::upcall_stub_load_target_id;\n+    StubId stub_id =  StubId::stubgen_upcall_stub_load_target_id;\n@@ -3394,2 +3394,2 @@\n-      StubRoutines::_sha1_implCompress     = generate_SHA1_stub(StubGenStubId::sha1_implCompress_id);\n-      StubRoutines::_sha1_implCompressMB   = generate_SHA1_stub(StubGenStubId::sha1_implCompressMB_id);\n+      StubRoutines::_sha1_implCompress     = generate_SHA1_stub(StubId::stubgen_sha1_implCompress_id);\n+      StubRoutines::_sha1_implCompressMB   = generate_SHA1_stub(StubId::stubgen_sha1_implCompressMB_id);\n@@ -3398,2 +3398,2 @@\n-      StubRoutines::_sha256_implCompress   = generate_SHA256_stub(StubGenStubId::sha256_implCompress_id);\n-      StubRoutines::_sha256_implCompressMB = generate_SHA256_stub(StubGenStubId::sha256_implCompressMB_id);\n+      StubRoutines::_sha256_implCompress   = generate_SHA256_stub(StubId::stubgen_sha256_implCompress_id);\n+      StubRoutines::_sha256_implCompressMB = generate_SHA256_stub(StubId::stubgen_sha256_implCompressMB_id);\n@@ -3402,2 +3402,2 @@\n-      StubRoutines::_sha512_implCompress   = generate_SHA512_stub(StubGenStubId::sha512_implCompress_id);\n-      StubRoutines::_sha512_implCompressMB = generate_SHA512_stub(StubGenStubId::sha512_implCompressMB_id);\n+      StubRoutines::_sha512_implCompress   = generate_SHA512_stub(StubId::stubgen_sha512_implCompress_id);\n+      StubRoutines::_sha512_implCompressMB = generate_SHA512_stub(StubId::stubgen_sha512_implCompressMB_id);\n@@ -3423,1 +3423,1 @@\n-  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+  StubGenerator(CodeBuffer* code, BlobId blob_id) : StubCodeGenerator(code, blob_id) {\n@@ -3425,1 +3425,1 @@\n-    case preuniverse_id:\n+    case BlobId::stubgen_preuniverse_id:\n@@ -3428,1 +3428,1 @@\n-    case initial_id:\n+    case BlobId::stubgen_initial_id:\n@@ -3431,1 +3431,1 @@\n-     case continuation_id:\n+    case BlobId::stubgen_continuation_id:\n@@ -3434,1 +3434,1 @@\n-    case compiler_id:\n+    case BlobId::stubgen_compiler_id:\n@@ -3437,1 +3437,1 @@\n-    case final_id:\n+    case BlobId::stubgen_final_id:\n@@ -3441,1 +3441,1 @@\n-      fatal(\"unexpected blob id: %d\", blob_id);\n+      fatal(\"unexpected blob id: %s\", StubInfo::name(blob_id));\n@@ -3480,1 +3480,1 @@\n-void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+void StubGenerator_generate(CodeBuffer* code, BlobId blob_id) {\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":97,"deletions":97,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -15764,0 +15764,2 @@\n+    \/\/ Restore the original contents of RAX register.\n+    movq(rax, Address(rax));\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::counter_overflow_id)));\n+  __ call(RuntimeAddress(Runtime1::entry_for(StubId::c1_counter_overflow_id)));\n@@ -67,1 +67,1 @@\n-    address a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+    address a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -81,1 +81,1 @@\n-  C1StubId stub_id;\n+  StubId stub_id;\n@@ -83,1 +83,1 @@\n-    stub_id = C1StubId::throw_index_exception_id;\n+    stub_id = StubId::c1_throw_index_exception_id;\n@@ -85,1 +85,1 @@\n-    stub_id = C1StubId::throw_range_check_failed_id;\n+    stub_id = StubId::c1_throw_range_check_failed_id;\n@@ -100,1 +100,1 @@\n-  address a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+  address a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -112,1 +112,1 @@\n-  __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::throw_div0_exception_id)));\n+  __ call(RuntimeAddress(Runtime1::entry_for(StubId::c1_throw_div0_exception_id)));\n@@ -120,1 +120,1 @@\n-NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, C1StubId stub_id) {\n+NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, StubId stub_id) {\n@@ -125,3 +125,3 @@\n-  assert(stub_id == C1StubId::new_instance_id                 ||\n-         stub_id == C1StubId::fast_new_instance_id            ||\n-         stub_id == C1StubId::fast_new_instance_init_check_id,\n+  assert(stub_id == StubId::c1_new_instance_id                 ||\n+         stub_id == StubId::c1_fast_new_instance_id            ||\n+         stub_id == StubId::c1_fast_new_instance_init_check_id,\n@@ -160,1 +160,1 @@\n-  __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::new_type_array_id)));\n+  __ call(RuntimeAddress(Runtime1::entry_for(StubId::c1_new_type_array_id)));\n@@ -183,1 +183,1 @@\n-  __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::new_object_array_id)));\n+  __ call(RuntimeAddress(Runtime1::entry_for(StubId::c1_new_object_array_id)));\n@@ -195,1 +195,1 @@\n-  C1StubId enter_id;\n+  StubId enter_id;\n@@ -197,1 +197,1 @@\n-    enter_id = C1StubId::monitorenter_id;\n+    enter_id = StubId::c1_monitorenter_id;\n@@ -199,1 +199,1 @@\n-    enter_id = C1StubId::monitorenter_nofpu_id;\n+    enter_id = StubId::c1_monitorenter_nofpu_id;\n@@ -216,1 +216,1 @@\n-  C1StubId exit_id;\n+  StubId exit_id;\n@@ -218,1 +218,1 @@\n-    exit_id = C1StubId::monitorexit_id;\n+    exit_id = StubId::c1_monitorexit_id;\n@@ -220,1 +220,1 @@\n-    exit_id = C1StubId::monitorexit_nofpu_id;\n+    exit_id = StubId::c1_monitorexit_nofpu_id;\n@@ -349,4 +349,4 @@\n-    case access_field_id:  target = Runtime1::entry_for(C1StubId::access_field_patching_id); break;\n-    case load_klass_id:    target = Runtime1::entry_for(C1StubId::load_klass_patching_id); reloc_type = relocInfo::metadata_type; break;\n-    case load_mirror_id:   target = Runtime1::entry_for(C1StubId::load_mirror_patching_id); reloc_type = relocInfo::oop_type; break;\n-    case load_appendix_id:      target = Runtime1::entry_for(C1StubId::load_appendix_patching_id); reloc_type = relocInfo::oop_type; break;\n+    case access_field_id:  target = Runtime1::entry_for(StubId::c1_access_field_patching_id); break;\n+    case load_klass_id:    target = Runtime1::entry_for(StubId::c1_load_klass_patching_id); reloc_type = relocInfo::metadata_type; break;\n+    case load_mirror_id:   target = Runtime1::entry_for(StubId::c1_load_mirror_patching_id); reloc_type = relocInfo::oop_type; break;\n+    case load_appendix_id:      target = Runtime1::entry_for(StubId::c1_load_appendix_patching_id); reloc_type = relocInfo::oop_type; break;\n@@ -382,1 +382,1 @@\n-  __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::deoptimize_id)));\n+  __ call(RuntimeAddress(Runtime1::entry_for(StubId::c1_deoptimize_id)));\n@@ -392,1 +392,1 @@\n-    a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n+    a = Runtime1::entry_for(StubId::c1_predicate_failed_trap_id);\n@@ -394,1 +394,1 @@\n-    a = Runtime1::entry_for(C1StubId::throw_null_pointer_exception_id);\n+    a = Runtime1::entry_for(StubId::c1_throw_null_pointer_exception_id);\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -380,1 +380,1 @@\n-  __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::handle_exception_from_callee_id)));\n+  __ call(RuntimeAddress(Runtime1::entry_for(StubId::c1_handle_exception_from_callee_id)));\n@@ -436,1 +436,1 @@\n-  __ jump(RuntimeAddress(Runtime1::entry_for(C1StubId::unwind_exception_id)));\n+  __ jump(RuntimeAddress(Runtime1::entry_for(StubId::c1_unwind_exception_id)));\n@@ -1390,1 +1390,1 @@\n-        __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+        __ call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n@@ -1404,1 +1404,1 @@\n-      __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+      __ call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n@@ -1483,1 +1483,1 @@\n-    __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+    __ call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n@@ -2220,1 +2220,1 @@\n-  C1StubId unwind_id;\n+  StubId unwind_id;\n@@ -2232,1 +2232,1 @@\n-    unwind_id = C1StubId::handle_exception_id;\n+    unwind_id = StubId::c1_handle_exception_id;\n@@ -2234,1 +2234,1 @@\n-    unwind_id = C1StubId::handle_exception_nofpu_id;\n+    unwind_id = StubId::c1_handle_exception_nofpu_id;\n@@ -2549,1 +2549,1 @@\n-      __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n+      __ call(RuntimeAddress(Runtime1::entry_for(StubId::c1_slow_subtype_check_id)));\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1246,1 +1246,1 @@\n-  __ call_runtime(Runtime1::entry_for(C1StubId::new_multi_array_id),\n+  __ call_runtime(Runtime1::entry_for(StubId::c1_new_multi_array_id),\n@@ -1279,1 +1279,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);\n+    stub = new SimpleExceptionStub(StubId::c1_throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);\n@@ -1284,1 +1284,1 @@\n-    stub = new SimpleExceptionStub(C1StubId::throw_class_cast_exception_id, obj.result(), info_for_exception);\n+    stub = new SimpleExceptionStub(StubId::c1_throw_class_cast_exception_id, obj.result(), info_for_exception);\n@@ -1320,1 +1320,1 @@\n-  return Runtime1::entry_for(C1StubId::is_instance_of_id);\n+  return Runtime1::entry_for(StubId::c1_is_instance_of_id);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-    call(RuntimeAddress(Runtime1::entry_for(C1StubId::dtrace_object_alloc_id)));\n+    call(RuntimeAddress(Runtime1::entry_for(StubId::c1_dtrace_object_alloc_id)));\n@@ -294,1 +294,1 @@\n-    call(RuntimeAddress(Runtime1::entry_for(C1StubId::dtrace_object_alloc_id)));\n+    call(RuntimeAddress(Runtime1::entry_for(StubId::c1_dtrace_object_alloc_id)));\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  align_stack = (stub_id() == (int)C1StubId::handle_exception_from_callee_id);\n+  align_stack = (stub_id() == (int)StubId::c1_handle_exception_from_callee_id);\n@@ -114,1 +114,1 @@\n-    } else if (_stub_id == (int)C1StubId::forward_exception_id) {\n+    } else if (_stub_id == (int)StubId::c1_forward_exception_id) {\n@@ -117,1 +117,1 @@\n-      jump(RuntimeAddress(Runtime1::entry_for(C1StubId::forward_exception_id)));\n+      jump(RuntimeAddress(Runtime1::entry_for(StubId::c1_forward_exception_id)));\n@@ -506,1 +506,1 @@\n-OopMapSet* Runtime1::generate_handle_exception(C1StubId id, StubAssembler *sasm) {\n+OopMapSet* Runtime1::generate_handle_exception(StubId id, StubAssembler *sasm) {\n@@ -519,1 +519,1 @@\n-  case C1StubId::forward_exception_id:\n+  case StubId::c1_forward_exception_id:\n@@ -538,2 +538,2 @@\n-  case C1StubId::handle_exception_nofpu_id:\n-  case C1StubId::handle_exception_id:\n+  case StubId::c1_handle_exception_nofpu_id:\n+  case StubId::c1_handle_exception_id:\n@@ -541,1 +541,1 @@\n-    oop_map = save_live_registers(sasm, 1 \/*thread*\/, id != C1StubId::handle_exception_nofpu_id);\n+    oop_map = save_live_registers(sasm, 1 \/*thread*\/, id != StubId::c1_handle_exception_nofpu_id);\n@@ -543,1 +543,1 @@\n-  case C1StubId::handle_exception_from_callee_id: {\n+  case StubId::c1_handle_exception_from_callee_id: {\n@@ -600,3 +600,3 @@\n-  case C1StubId::forward_exception_id:\n-  case C1StubId::handle_exception_nofpu_id:\n-  case C1StubId::handle_exception_id:\n+  case StubId::c1_forward_exception_id:\n+  case StubId::c1_handle_exception_nofpu_id:\n+  case StubId::c1_handle_exception_id:\n@@ -604,1 +604,1 @@\n-    restore_live_registers(sasm, id != C1StubId::handle_exception_nofpu_id);\n+    restore_live_registers(sasm, id != StubId::c1_handle_exception_nofpu_id);\n@@ -606,1 +606,1 @@\n-  case C1StubId::handle_exception_from_callee_id:\n+  case StubId::c1_handle_exception_from_callee_id:\n@@ -742,1 +742,1 @@\n-               RuntimeAddress(Runtime1::entry_for(C1StubId::forward_exception_id)));\n+               RuntimeAddress(Runtime1::entry_for(StubId::c1_forward_exception_id)));\n@@ -814,1 +814,1 @@\n-OopMapSet* Runtime1::generate_code_for(C1StubId id, StubAssembler* sasm) {\n+OopMapSet* Runtime1::generate_code_for(StubId id, StubAssembler* sasm) {\n@@ -826,1 +826,1 @@\n-    case C1StubId::forward_exception_id:\n+    case StubId::c1_forward_exception_id:\n@@ -834,3 +834,3 @@\n-    case C1StubId::new_instance_id:\n-    case C1StubId::fast_new_instance_id:\n-    case C1StubId::fast_new_instance_init_check_id:\n+    case StubId::c1_new_instance_id:\n+    case StubId::c1_fast_new_instance_id:\n+    case StubId::c1_fast_new_instance_init_check_id:\n@@ -841,1 +841,1 @@\n-        if (id == C1StubId::new_instance_id) {\n+        if (id == StubId::c1_new_instance_id) {\n@@ -843,1 +843,1 @@\n-        } else if (id == C1StubId::fast_new_instance_id) {\n+        } else if (id == StubId::c1_fast_new_instance_id) {\n@@ -846,1 +846,1 @@\n-          assert(id == C1StubId::fast_new_instance_init_check_id, \"bad C1StubId\");\n+          assert(id == StubId::c1_fast_new_instance_init_check_id, \"bad StubId\");\n@@ -865,1 +865,1 @@\n-    case C1StubId::counter_overflow_id:\n+    case StubId::c1_counter_overflow_id:\n@@ -883,2 +883,2 @@\n-    case C1StubId::new_type_array_id:\n-    case C1StubId::new_object_array_id:\n+    case StubId::c1_new_type_array_id:\n+    case StubId::c1_new_object_array_id:\n@@ -890,1 +890,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -903,1 +903,1 @@\n-          int tag = ((id == C1StubId::new_type_array_id)\n+          int tag = ((id == StubId::c1_new_type_array_id)\n@@ -917,1 +917,1 @@\n-        if (id == C1StubId::new_type_array_id) {\n+        if (id == StubId::c1_new_type_array_id) {\n@@ -935,1 +935,1 @@\n-    case C1StubId::new_multi_array_id:\n+    case StubId::c1_new_multi_array_id:\n@@ -952,1 +952,1 @@\n-    case C1StubId::register_finalizer_id:\n+    case StubId::c1_register_finalizer_id:\n@@ -985,1 +985,1 @@\n-    case C1StubId::throw_range_check_failed_id:\n+    case StubId::c1_throw_range_check_failed_id:\n@@ -991,1 +991,1 @@\n-    case C1StubId::throw_index_exception_id:\n+    case StubId::c1_throw_index_exception_id:\n@@ -997,1 +997,1 @@\n-    case C1StubId::throw_div0_exception_id:\n+    case StubId::c1_throw_div0_exception_id:\n@@ -1003,1 +1003,1 @@\n-    case C1StubId::throw_null_pointer_exception_id:\n+    case StubId::c1_throw_null_pointer_exception_id:\n@@ -1009,2 +1009,2 @@\n-    case C1StubId::handle_exception_nofpu_id:\n-    case C1StubId::handle_exception_id:\n+    case StubId::c1_handle_exception_nofpu_id:\n+    case StubId::c1_handle_exception_id:\n@@ -1016,1 +1016,1 @@\n-    case C1StubId::handle_exception_from_callee_id:\n+    case StubId::c1_handle_exception_from_callee_id:\n@@ -1022,1 +1022,1 @@\n-    case C1StubId::unwind_exception_id:\n+    case StubId::c1_unwind_exception_id:\n@@ -1030,1 +1030,1 @@\n-    case C1StubId::throw_array_store_exception_id:\n+    case StubId::c1_throw_array_store_exception_id:\n@@ -1038,1 +1038,1 @@\n-    case C1StubId::throw_class_cast_exception_id:\n+    case StubId::c1_throw_class_cast_exception_id:\n@@ -1044,1 +1044,1 @@\n-    case C1StubId::throw_incompatible_class_change_error_id:\n+    case StubId::c1_throw_incompatible_class_change_error_id:\n@@ -1050,1 +1050,1 @@\n-    case C1StubId::slow_subtype_check_id:\n+    case StubId::c1_slow_subtype_check_id:\n@@ -1103,1 +1103,1 @@\n-    case C1StubId::is_instance_of_id:\n+    case StubId::c1_is_instance_of_id:\n@@ -1157,1 +1157,1 @@\n-    case C1StubId::monitorenter_nofpu_id:\n+    case StubId::c1_monitorenter_nofpu_id:\n@@ -1160,1 +1160,1 @@\n-    case C1StubId::monitorenter_id:\n+    case StubId::c1_monitorenter_id:\n@@ -1178,1 +1178,1 @@\n-    case C1StubId::monitorexit_nofpu_id:\n+    case StubId::c1_monitorexit_nofpu_id:\n@@ -1181,1 +1181,1 @@\n-    case C1StubId::monitorexit_id:\n+    case StubId::c1_monitorexit_id:\n@@ -1201,1 +1201,1 @@\n-    case C1StubId::deoptimize_id:\n+    case StubId::c1_deoptimize_id:\n@@ -1218,1 +1218,1 @@\n-    case C1StubId::access_field_patching_id:\n+    case StubId::c1_access_field_patching_id:\n@@ -1225,1 +1225,1 @@\n-    case C1StubId::load_klass_patching_id:\n+    case StubId::c1_load_klass_patching_id:\n@@ -1232,1 +1232,1 @@\n-    case C1StubId::load_mirror_patching_id:\n+    case StubId::c1_load_mirror_patching_id:\n@@ -1239,1 +1239,1 @@\n-    case C1StubId::load_appendix_patching_id:\n+    case StubId::c1_load_appendix_patching_id:\n@@ -1246,1 +1246,1 @@\n-    case C1StubId::dtrace_object_alloc_id:\n+    case StubId::c1_dtrace_object_alloc_id:\n@@ -1260,1 +1260,1 @@\n-    case C1StubId::fpu2long_stub_id:\n+    case StubId::c1_fpu2long_stub_id:\n@@ -1276,1 +1276,1 @@\n-    case C1StubId::predicate_failed_trap_id:\n+    case StubId::c1_predicate_failed_trap_id:\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":56,"deletions":56,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -1601,6 +1601,4 @@\n-void C2_MacroAssembler::vgather8b_masked_offset(BasicType elem_bt,\n-                                                XMMRegister dst, Register base,\n-                                                Register idx_base,\n-                                                Register offset, Register mask,\n-                                                Register mask_idx, Register rtmp,\n-                                                int vlen_enc) {\n+void C2_MacroAssembler::vgather8b_masked(BasicType elem_bt, XMMRegister dst,\n+                                         Register base, Register idx_base,\n+                                         Register mask, Register mask_idx,\n+                                         Register rtmp, int vlen_enc) {\n@@ -1610,1 +1608,1 @@\n-      \/\/ dst[i] = mask[i] ? src[offset + idx_base[i]] : 0\n+      \/\/ dst[i] = mask[i] ? src[idx_base[i]] : 0\n@@ -1615,3 +1613,0 @@\n-      if (offset != noreg) {\n-        addl(rtmp, offset);\n-      }\n@@ -1625,1 +1620,1 @@\n-      \/\/ dst[i] = mask[i] ? src[offset + idx_base[i]] : 0\n+      \/\/ dst[i] = mask[i] ? src[idx_base[i]] : 0\n@@ -1630,3 +1625,0 @@\n-      if (offset != noreg) {\n-        addl(rtmp, offset);\n-      }\n@@ -1640,4 +1632,3 @@\n-void C2_MacroAssembler::vgather8b_offset(BasicType elem_bt, XMMRegister dst,\n-                                         Register base, Register idx_base,\n-                                         Register offset, Register rtmp,\n-                                         int vlen_enc) {\n+void C2_MacroAssembler::vgather8b(BasicType elem_bt, XMMRegister dst,\n+                                  Register base, Register idx_base,\n+                                  Register rtmp, int vlen_enc) {\n@@ -1647,1 +1638,1 @@\n-      \/\/ dst[i] = src[offset + idx_base[i]]\n+      \/\/ dst[i] = src[idx_base[i]]\n@@ -1649,3 +1640,0 @@\n-      if (offset != noreg) {\n-        addl(rtmp, offset);\n-      }\n@@ -1657,1 +1645,1 @@\n-      \/\/ dst[i] = src[offset + idx_base[i]]\n+      \/\/ dst[i] = src[idx_base[i]]\n@@ -1659,3 +1647,0 @@\n-      if (offset != noreg) {\n-        addl(rtmp, offset);\n-      }\n@@ -1690,5 +1675,4 @@\n-                                        Register offset, Register mask,\n-                                        XMMRegister xtmp1, XMMRegister xtmp2,\n-                                        XMMRegister temp_dst, Register rtmp,\n-                                        Register mask_idx, Register length,\n-                                        int vector_len, int vlen_enc) {\n+                                        Register mask, XMMRegister xtmp1,\n+                                        XMMRegister xtmp2, XMMRegister temp_dst,\n+                                        Register rtmp, Register mask_idx,\n+                                        Register length, int vector_len, int vlen_enc) {\n@@ -1708,1 +1692,1 @@\n-      vgather8b_offset(elem_ty, temp_dst, base, idx_base, offset, rtmp, vlen_enc);\n+      vgather8b(elem_ty, temp_dst, base, idx_base, rtmp, vlen_enc);\n@@ -1710,1 +1694,1 @@\n-      vgather8b_masked_offset(elem_ty, temp_dst, base, idx_base, offset, mask, mask_idx, rtmp, vlen_enc);\n+      vgather8b_masked(elem_ty, temp_dst, base, idx_base, mask, mask_idx, rtmp, vlen_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":17,"deletions":33,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -498,2 +498,2 @@\n-  void vgather_subword(BasicType elem_ty, XMMRegister dst,  Register base, Register idx_base, Register offset,\n-                       Register mask, XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp,\n+  void vgather_subword(BasicType elem_ty, XMMRegister dst,  Register base, Register idx_base, Register mask,\n+                       XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp,\n@@ -502,5 +502,4 @@\n-  void vgather8b_masked_offset(BasicType elem_bt, XMMRegister dst, Register base, Register idx_base,\n-                               Register offset, Register mask, Register midx, Register rtmp, int vlen_enc);\n-\n-  void vgather8b_offset(BasicType elem_bt, XMMRegister dst, Register base, Register idx_base,\n-                              Register offset, Register rtmp, int vlen_enc);\n+  void vgather8b_masked(BasicType elem_bt, XMMRegister dst, Register base, Register idx_base,\n+                        Register mask, Register midx, Register rtmp, int vlen_enc);\n+  void vgather8b(BasicType elem_bt, XMMRegister dst, Register base, Register idx_base,\n+                 Register rtmp, int vlen_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2024, 2025, Intel Corporation. All rights reserved.\n@@ -208,1 +208,1 @@\n-  StubGenStubId stub_id = (isLL ?  StubGenStubId::string_indexof_linear_ll_id : (isUL ? StubGenStubId::string_indexof_linear_ul_id : StubGenStubId::string_indexof_linear_uu_id));\n+  StubId stub_id = (isLL ?  StubId::stubgen_string_indexof_linear_ll_id : (isUL ? StubId::stubgen_string_indexof_linear_ul_id : StubId::stubgen_string_indexof_linear_uu_id));\n","filename":"src\/hotspot\/cpu\/x86\/c2_stubGenerator_x86_64_string.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/*\n+ \/*\n@@ -37,1 +37,1 @@\n-         CompressedKlassPointers::narrow_klass_pointer_bits() == 22, \"Rethink if we ever use different nKlass bit sizes\");\n+         CompressedKlassPointers::narrow_klass_pointer_bits() == 19, \"Rethink if we ever use different nKlass bit sizes\");\n","filename":"src\/hotspot\/cpu\/x86\/compressedKlass_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -433,2 +433,2 @@\n-  if (cb == Runtime1::blob_for(C1StubId::monitorenter_id) ||\n-      cb == Runtime1::blob_for(C1StubId::monitorenter_nofpu_id)) {\n+  if (cb == Runtime1::blob_for(StubId::c1_monitorenter_id) ||\n+      cb == Runtime1::blob_for(StubId::c1_monitorenter_nofpu_id)) {\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -356,1 +356,1 @@\n-  uint num_saved_regs = 4 + (dst != rax ? 1 : 0) + 4;\n+  uint num_saved_regs = 4 + (dst != rax ? 1 : 0) + 4 + (UseAPX ? 16 : 0);\n@@ -370,0 +370,19 @@\n+  \/\/ Save APX extended registers r16r31 if enabled\n+  if (UseAPX) {\n+    __ movptr(Address(rsp, (--slot) * wordSize), r16);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r17);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r18);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r19);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r20);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r21);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r22);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r23);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r24);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r25);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r26);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r27);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r28);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r29);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r30);\n+    __ movptr(Address(rsp, (--slot) * wordSize), r31);\n+  }\n@@ -401,0 +420,19 @@\n+  \/\/ Restore APX extended registers r31r16 if previously saved\n+  if (UseAPX) {\n+    __ movptr(r31, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r30, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r29, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r28, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r27, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r26, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r25, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r24, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r23, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r22, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r21, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r20, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r19, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r18, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r17, Address(rsp, (slot++) * wordSize));\n+    __ movptr(r16, Address(rsp, (slot++) * wordSize));\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":39,"deletions":1,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -5139,2 +5139,2 @@\n-  movq(dst, Address(src, oopDesc::mark_offset_in_bytes()));\n-  shrq(dst, markWord::klass_shift);\n+  movl(dst, Address(src, oopDesc::mark_offset_in_bytes()));\n+  shrl(dst, markWord::klass_shift);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -349,1 +349,1 @@\n-      dependant_lea->set_req(AddPNode::Base, decode_address);\n+      dependant_lea->set_req(AddPNode::Base, lea_derived_oop->in(AddPNode::Address));\n","filename":"src\/hotspot\/cpu\/x86\/peephole_x86_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,2 +60,2 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n-  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, (uint)OptoStubId::uncommon_trap_id, name);\n+  const char* name = OptoRuntime::stub_name(StubId::c2_uncommon_trap_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, BlobId::c2_uncommon_trap_id);\n@@ -239,1 +239,1 @@\n-  AOTCodeCache::store_code_blob(*ut_blob, AOTCodeEntry::C2Blob, (uint)OptoStubId::uncommon_trap_id, name);\n+  AOTCodeCache::store_code_blob(*ut_blob, AOTCodeEntry::C2Blob, BlobId::c2_uncommon_trap_id);\n@@ -276,2 +276,2 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n-  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, (uint)OptoStubId::exception_id, name);\n+  const char* name = OptoRuntime::stub_name(StubId::c2_exception_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, BlobId::c2_exception_id);\n@@ -380,1 +380,1 @@\n-  AOTCodeCache::store_code_blob(*ex_blob, AOTCodeEntry::C2Blob, (uint)OptoStubId::exception_id, name);\n+  AOTCodeCache::store_code_blob(*ex_blob, AOTCodeEntry::C2Blob, BlobId::c2_exception_id);\n","filename":"src\/hotspot\/cpu\/x86\/runtime_x86_64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2620,2 +2620,2 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::deopt_id);\n-  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)SharedStubId::deopt_id, name);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_deopt_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, BlobId::shared_deopt_id);\n@@ -2979,1 +2979,1 @@\n-  AOTCodeCache::store_code_blob(*_deopt_blob, AOTCodeEntry::SharedBlob, (uint)SharedStubId::deopt_id, name);\n+  AOTCodeCache::store_code_blob(*_deopt_blob, AOTCodeEntry::SharedBlob, BlobId::shared_deopt_id);\n@@ -2987,1 +2987,1 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(StubId id, address call_ptr) {\n@@ -2994,1 +2994,1 @@\n-  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n@@ -3008,2 +3008,2 @@\n-  bool cause_return = (id == SharedStubId::polling_page_return_handler_id);\n-  bool save_wide_vectors = (id == SharedStubId::polling_page_vectors_safepoint_handler_id);\n+  bool cause_return = (id == StubId::shared_polling_page_return_handler_id);\n+  bool save_wide_vectors = (id == StubId::shared_polling_page_vectors_safepoint_handler_id);\n@@ -3163,1 +3163,1 @@\n-  AOTCodeCache::store_code_blob(*sp_blob, AOTCodeEntry::SharedBlob, (uint)id, name);\n+  AOTCodeCache::store_code_blob(*sp_blob, AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n@@ -3175,1 +3175,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(StubId id, address destination) {\n@@ -3180,1 +3180,1 @@\n-  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n@@ -3257,1 +3257,1 @@\n-  AOTCodeCache::store_code_blob(*rs_blob, AOTCodeEntry::SharedBlob, (uint)id, name);\n+  AOTCodeCache::store_code_blob(*rs_blob, AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n@@ -3276,1 +3276,1 @@\n-RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+RuntimeStub* SharedRuntime::generate_throw_exception(StubId id, address runtime_entry) {\n@@ -3299,1 +3299,1 @@\n-  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n@@ -3362,1 +3362,1 @@\n-  AOTCodeCache::store_code_blob(*stub, AOTCodeEntry::SharedBlob, (uint)id, name);\n+  AOTCodeCache::store_code_blob(*stub, AOTCodeEntry::SharedBlob, StubInfo::blob(id));\n@@ -3646,1 +3646,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_write_checkpoint_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_jfr_write_checkpoint_id);\n@@ -3691,1 +3691,1 @@\n-  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_return_lease_id);\n+  const char* name = SharedRuntime::stub_name(StubId::shared_jfr_return_lease_id);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-  do_arch_entry(x86, compiler, vector_int_shuffle_mask,                 \\\n+  do_arch_entry(x86, compiler, vector_byte_shuffle_mask,                 \\\n@@ -121,1 +121,1 @@\n-  do_arch_entry(x86, compiler, vector_int_shuffle_mask,                 \\\n+  do_arch_entry(x86, compiler, vector_short_shuffle_mask,               \\\n","filename":"src\/hotspot\/cpu\/x86\/stubDeclarations_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-  StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+  StubId stub_id = StubId::stubgen_call_stub_id;\n@@ -413,1 +413,1 @@\n-  StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+  StubId stub_id = StubId::stubgen_catch_exception_id;\n@@ -469,1 +469,1 @@\n-  StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+  StubId stub_id = StubId::stubgen_forward_exception_id;\n@@ -533,1 +533,1 @@\n-  StubGenStubId stub_id = StubGenStubId::fence_id;\n+  StubId stub_id = StubId::stubgen_fence_id;\n@@ -549,1 +549,1 @@\n-  StubGenStubId stub_id = StubGenStubId::get_previous_sp_id;\n+  StubId stub_id = StubId::stubgen_get_previous_sp_id;\n@@ -568,1 +568,1 @@\n-  StubGenStubId stub_id = StubGenStubId::verify_mxcsr_id;\n+  StubId stub_id = StubId::stubgen_verify_mxcsr_id;\n@@ -597,1 +597,1 @@\n-  StubGenStubId stub_id = StubGenStubId::f2i_fixup_id;\n+  StubId stub_id = StubId::stubgen_f2i_fixup_id;\n@@ -636,1 +636,1 @@\n-  StubGenStubId stub_id = StubGenStubId::f2l_fixup_id;\n+  StubId stub_id = StubId::stubgen_f2l_fixup_id;\n@@ -674,1 +674,1 @@\n-  StubGenStubId stub_id = StubGenStubId::d2i_fixup_id;\n+  StubId stub_id = StubId::stubgen_d2i_fixup_id;\n@@ -722,1 +722,1 @@\n-  StubGenStubId stub_id = StubGenStubId::d2l_fixup_id;\n+  StubId stub_id = StubId::stubgen_d2l_fixup_id;\n@@ -771,1 +771,1 @@\n-  StubGenStubId stub_id = StubGenStubId::vector_count_leading_zeros_lut_id;\n+  StubId stub_id = StubId::stubgen_vector_count_leading_zeros_lut_id;\n@@ -789,1 +789,1 @@\n-  StubGenStubId stub_id = StubGenStubId::vector_popcount_lut_id;\n+  StubId stub_id = StubId::stubgen_vector_popcount_lut_id;\n@@ -807,1 +807,1 @@\n-  StubGenStubId stub_id = StubGenStubId::vector_iota_indices_id;\n+  StubId stub_id = StubId::stubgen_vector_iota_indices_id;\n@@ -869,1 +869,1 @@\n-  StubGenStubId stub_id = StubGenStubId::vector_reverse_bit_lut_id;\n+  StubId stub_id = StubId::stubgen_vector_reverse_bit_lut_id;\n@@ -887,1 +887,1 @@\n-  StubGenStubId stub_id = StubGenStubId::vector_reverse_byte_perm_mask_long_id;\n+  StubId stub_id = StubId::stubgen_vector_reverse_byte_perm_mask_long_id;\n@@ -905,1 +905,1 @@\n-  StubGenStubId stub_id = StubGenStubId::vector_reverse_byte_perm_mask_int_id;\n+  StubId stub_id = StubId::stubgen_vector_reverse_byte_perm_mask_int_id;\n@@ -923,1 +923,1 @@\n-  StubGenStubId stub_id = StubGenStubId::vector_reverse_byte_perm_mask_short_id;\n+  StubId stub_id = StubId::stubgen_vector_reverse_byte_perm_mask_short_id;\n@@ -941,1 +941,1 @@\n-  StubGenStubId stub_id = StubGenStubId::vector_byte_shuffle_mask_id;\n+  StubId stub_id = StubId::stubgen_vector_byte_shuffle_mask_id;\n@@ -953,1 +953,1 @@\n-address StubGenerator::generate_fp_mask(StubGenStubId stub_id, int64_t mask) {\n+address StubGenerator::generate_fp_mask(StubId stub_id, int64_t mask) {\n@@ -964,1 +964,1 @@\n-address StubGenerator::generate_compress_perm_table(StubGenStubId stub_id) {\n+address StubGenerator::generate_compress_perm_table(StubId stub_id) {\n@@ -967,1 +967,1 @@\n-  case compress_perm_table32_id:\n+  case StubId::stubgen_compress_perm_table32_id:\n@@ -970,1 +970,1 @@\n-  case compress_perm_table64_id:\n+  case StubId::stubgen_compress_perm_table64_id:\n@@ -1019,1 +1019,1 @@\n-address StubGenerator::generate_expand_perm_table(StubGenStubId stub_id) {\n+address StubGenerator::generate_expand_perm_table(StubId stub_id) {\n@@ -1022,1 +1022,1 @@\n-  case expand_perm_table32_id:\n+  case StubId::stubgen_expand_perm_table32_id:\n@@ -1025,1 +1025,1 @@\n-  case expand_perm_table64_id:\n+  case StubId::stubgen_expand_perm_table64_id:\n@@ -1072,1 +1072,1 @@\n-address StubGenerator::generate_vector_mask(StubGenStubId stub_id, int64_t mask) {\n+address StubGenerator::generate_vector_mask(StubId stub_id, int64_t mask) {\n@@ -1091,1 +1091,1 @@\n-  StubGenStubId stub_id = StubGenStubId::vector_byte_perm_mask_id;\n+  StubId stub_id = StubId::stubgen_vector_byte_perm_mask_id;\n@@ -1107,1 +1107,1 @@\n-address StubGenerator::generate_vector_fp_mask(StubGenStubId stub_id, int64_t mask) {\n+address StubGenerator::generate_vector_fp_mask(StubId stub_id, int64_t mask) {\n@@ -1124,1 +1124,1 @@\n-address StubGenerator::generate_vector_custom_i32(StubGenStubId stub_id, Assembler::AvxVectorLen len,\n+address StubGenerator::generate_vector_custom_i32(StubId stub_id, Assembler::AvxVectorLen len,\n@@ -1174,1 +1174,1 @@\n-  StubGenStubId stub_id = StubGenStubId::verify_oop_id;\n+  StubId stub_id = StubId::stubgen_verify_oop_id;\n@@ -1372,1 +1372,1 @@\n-  StubGenStubId stub_id = StubGenStubId::data_cache_writeback_id;\n+  StubId stub_id = StubId::stubgen_data_cache_writeback_id;\n@@ -1390,1 +1390,1 @@\n-  StubGenStubId stub_id = StubGenStubId::data_cache_writeback_sync_id;\n+  StubId stub_id = StubId::stubgen_data_cache_writeback_sync_id;\n@@ -1412,1 +1412,1 @@\n-address StubGenerator::generate_md5_implCompress(StubGenStubId stub_id) {\n+address StubGenerator::generate_md5_implCompress(StubId stub_id) {\n@@ -1415,1 +1415,1 @@\n-  case md5_implCompress_id:\n+  case StubId::stubgen_md5_implCompress_id:\n@@ -1418,1 +1418,1 @@\n-  case md5_implCompressMB_id:\n+  case StubId::stubgen_md5_implCompressMB_id:\n@@ -1461,1 +1461,1 @@\n-  StubGenStubId stub_id = StubGenStubId::upper_word_mask_id;\n+  StubId stub_id = StubId::stubgen_upper_word_mask_id;\n@@ -1473,1 +1473,1 @@\n-  StubGenStubId stub_id = StubGenStubId::shuffle_byte_flip_mask_id;\n+  StubId stub_id = StubId::stubgen_shuffle_byte_flip_mask_id;\n@@ -1485,1 +1485,1 @@\n-address StubGenerator::generate_sha1_implCompress(StubGenStubId stub_id) {\n+address StubGenerator::generate_sha1_implCompress(StubId stub_id) {\n@@ -1488,1 +1488,1 @@\n-  case sha1_implCompress_id:\n+  case StubId::stubgen_sha1_implCompress_id:\n@@ -1491,1 +1491,1 @@\n-  case sha1_implCompressMB_id:\n+  case StubId::stubgen_sha1_implCompressMB_id:\n@@ -1533,1 +1533,1 @@\n-  StubGenStubId stub_id = StubGenStubId::pshuffle_byte_flip_mask_id;\n+  StubId stub_id = StubId::stubgen_pshuffle_byte_flip_mask_id;\n@@ -1561,1 +1561,1 @@\n-  StubGenStubId stub_id = StubGenStubId::pshuffle_byte_flip_mask_sha512_id;\n+  StubId stub_id = StubId::stubgen_pshuffle_byte_flip_mask_sha512_id;\n@@ -1581,1 +1581,1 @@\n-address StubGenerator::generate_sha256_implCompress(StubGenStubId stub_id) {\n+address StubGenerator::generate_sha256_implCompress(StubId stub_id) {\n@@ -1584,1 +1584,1 @@\n-  case sha256_implCompress_id:\n+  case StubId::stubgen_sha256_implCompress_id:\n@@ -1587,1 +1587,1 @@\n-  case sha256_implCompressMB_id:\n+  case StubId::stubgen_sha256_implCompressMB_id:\n@@ -1634,1 +1634,1 @@\n-address StubGenerator::generate_sha512_implCompress(StubGenStubId stub_id) {\n+address StubGenerator::generate_sha512_implCompress(StubId stub_id) {\n@@ -1637,1 +1637,1 @@\n-  case sha512_implCompress_id:\n+  case StubId::stubgen_sha512_implCompress_id:\n@@ -1640,1 +1640,1 @@\n-  case sha512_implCompressMB_id:\n+  case StubId::stubgen_sha512_implCompressMB_id:\n@@ -1684,1 +1684,1 @@\n-  StubGenStubId stub_id = StubGenStubId::shuffle_base64_id;\n+  StubId stub_id = StubId::stubgen_shuffle_base64_id;\n@@ -1704,1 +1704,1 @@\n-  StubGenStubId stub_id = StubGenStubId::avx2_shuffle_base64_id;\n+  StubId stub_id = StubId::stubgen_avx2_shuffle_base64_id;\n@@ -1718,1 +1718,1 @@\n-  StubGenStubId stub_id = StubGenStubId::avx2_input_mask_base64_id;\n+  StubId stub_id = StubId::stubgen_avx2_input_mask_base64_id;\n@@ -1732,1 +1732,1 @@\n-  StubGenStubId stub_id = StubGenStubId::avx2_lut_base64_id;\n+  StubId stub_id = StubId::stubgen_avx2_lut_base64_id;\n@@ -1752,1 +1752,1 @@\n-  StubGenStubId stub_id = StubGenStubId::encoding_table_base64_id;\n+  StubId stub_id = StubId::stubgen_encoding_table_base64_id;\n@@ -1786,1 +1786,1 @@\n-  StubGenStubId stub_id = StubGenStubId::base64_encodeBlock_id;\n+  StubId stub_id = StubId::stubgen_base64_encodeBlock_id;\n@@ -2169,1 +2169,1 @@\n-  StubGenStubId stub_id = StubGenStubId::lookup_lo_base64_id;\n+  StubId stub_id = StubId::stubgen_lookup_lo_base64_id;\n@@ -2189,1 +2189,1 @@\n-  StubGenStubId stub_id = StubGenStubId::lookup_hi_base64_id;\n+  StubId stub_id = StubId::stubgen_lookup_hi_base64_id;\n@@ -2208,1 +2208,1 @@\n-  StubGenStubId stub_id = StubGenStubId::lookup_lo_base64url_id;\n+  StubId stub_id = StubId::stubgen_lookup_lo_base64url_id;\n@@ -2228,1 +2228,1 @@\n-  StubGenStubId stub_id = StubGenStubId::lookup_hi_base64url_id;\n+  StubId stub_id = StubId::stubgen_lookup_hi_base64url_id;\n@@ -2248,1 +2248,1 @@\n-  StubGenStubId stub_id = StubGenStubId::pack_vec_base64_id;\n+  StubId stub_id = StubId::stubgen_pack_vec_base64_id;\n@@ -2268,1 +2268,1 @@\n-  StubGenStubId stub_id = StubGenStubId::join_0_1_base64_id;\n+  StubId stub_id = StubId::stubgen_join_0_1_base64_id;\n@@ -2288,1 +2288,1 @@\n-  StubGenStubId stub_id = StubGenStubId::join_1_2_base64_id;\n+  StubId stub_id = StubId::stubgen_join_1_2_base64_id;\n@@ -2308,1 +2308,1 @@\n-  StubGenStubId stub_id = StubGenStubId::join_2_3_base64_id;\n+  StubId stub_id = StubId::stubgen_join_2_3_base64_id;\n@@ -2328,1 +2328,1 @@\n-  StubGenStubId stub_id = StubGenStubId::avx2_decode_tables_base64_id;\n+  StubId stub_id = StubId::stubgen_avx2_decode_tables_base64_id;\n@@ -2363,1 +2363,1 @@\n-  StubGenStubId stub_id = StubGenStubId::avx2_decode_lut_tables_base64_id;\n+  StubId stub_id = StubId::stubgen_avx2_decode_lut_tables_base64_id;\n@@ -2403,1 +2403,1 @@\n-  StubGenStubId stub_id = StubGenStubId::decoding_table_base64_id;\n+  StubId stub_id = StubId::stubgen_decoding_table_base64_id;\n@@ -2486,1 +2486,1 @@\n-  StubGenStubId stub_id = StubGenStubId::base64_decodeBlock_id;\n+  StubId stub_id = StubId::stubgen_base64_decodeBlock_id;\n@@ -3020,1 +3020,1 @@\n-  StubGenStubId stub_id = StubGenStubId::updateBytesCRC32_id;\n+  StubId stub_id = StubId::stubgen_updateBytesCRC32_id;\n@@ -3077,1 +3077,1 @@\n-  StubGenStubId stub_id = StubGenStubId::updateBytesCRC32C_id;\n+  StubId stub_id = StubId::stubgen_updateBytesCRC32C_id;\n@@ -3158,1 +3158,1 @@\n-  StubGenStubId stub_id = StubGenStubId::multiplyToLen_id;\n+  StubId stub_id = StubId::stubgen_multiplyToLen_id;\n@@ -3215,1 +3215,1 @@\n-  StubGenStubId stub_id = StubGenStubId::vectorizedMismatch_id;\n+  StubId stub_id = StubId::stubgen_vectorizedMismatch_id;\n@@ -3267,1 +3267,1 @@\n-  StubGenStubId stub_id = StubGenStubId::squareToLen_id;\n+  StubId stub_id = StubId::stubgen_squareToLen_id;\n@@ -3303,1 +3303,1 @@\n-  StubGenStubId stub_id = StubGenStubId::method_entry_barrier_id;\n+  StubId stub_id = StubId::stubgen_method_entry_barrier_id;\n@@ -3393,1 +3393,1 @@\n-  StubGenStubId stub_id = StubGenStubId::mulAdd_id;\n+  StubId stub_id = StubId::stubgen_mulAdd_id;\n@@ -3435,1 +3435,1 @@\n-  StubGenStubId stub_id = StubGenStubId::bigIntegerRightShiftWorker_id;\n+  StubId stub_id = StubId::stubgen_bigIntegerRightShiftWorker_id;\n@@ -3571,1 +3571,1 @@\n-  StubGenStubId stub_id = StubGenStubId::bigIntegerLeftShiftWorker_id;\n+  StubId stub_id = StubId::stubgen_bigIntegerLeftShiftWorker_id;\n@@ -3723,1 +3723,1 @@\n-  StubGenStubId stub_id = StubGenStubId::hf2f_id;\n+  StubId stub_id = StubId::stubgen_hf2f_id;\n@@ -3749,1 +3749,1 @@\n-  StubGenStubId stub_id = StubGenStubId::f2hf_id;\n+  StubId stub_id = StubId::stubgen_f2hf_id;\n@@ -3765,1 +3765,1 @@\n-address StubGenerator::generate_cont_thaw(StubGenStubId stub_id) {\n+address StubGenerator::generate_cont_thaw(StubId stub_id) {\n@@ -3773,1 +3773,1 @@\n-  case cont_thaw_id:\n+  case StubId::stubgen_cont_thaw_id:\n@@ -3778,1 +3778,1 @@\n-  case cont_returnBarrier_id:\n+  case StubId::stubgen_cont_returnBarrier_id:\n@@ -3783,1 +3783,1 @@\n-  case cont_returnBarrierExc_id:\n+  case StubId::stubgen_cont_returnBarrierExc_id:\n@@ -3909,1 +3909,1 @@\n-  return generate_cont_thaw(StubGenStubId::cont_thaw_id);\n+  return generate_cont_thaw(StubId::stubgen_cont_thaw_id);\n@@ -3915,1 +3915,1 @@\n-  return generate_cont_thaw(StubGenStubId::cont_returnBarrier_id);\n+  return generate_cont_thaw(StubId::stubgen_cont_returnBarrier_id);\n@@ -3919,1 +3919,1 @@\n-  return generate_cont_thaw(StubGenStubId::cont_returnBarrierExc_id);\n+  return generate_cont_thaw(StubId::stubgen_cont_returnBarrierExc_id);\n@@ -3924,1 +3924,1 @@\n-  StubGenStubId stub_id = StubGenStubId::cont_preempt_id;\n+  StubId stub_id = StubId::stubgen_cont_preempt_id;\n@@ -3955,1 +3955,1 @@\n-  StubGenStubId stub_id = StubGenStubId::upcall_stub_exception_handler_id;\n+  StubId stub_id = StubId::stubgen_upcall_stub_exception_handler_id;\n@@ -3976,1 +3976,1 @@\n-  StubGenStubId stub_id = StubGenStubId::upcall_stub_load_target_id;\n+  StubId stub_id = StubId::stubgen_upcall_stub_load_target_id;\n@@ -3996,1 +3996,1 @@\n-  StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n+  StubId stub_id = StubId::stubgen_lookup_secondary_supers_table_id;\n@@ -4016,1 +4016,1 @@\n-  StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_slow_path_id;\n+  StubId stub_id = StubId::stubgen_lookup_secondary_supers_table_slow_path_id;\n@@ -4092,4 +4092,4 @@\n-  StubRoutines::x86::_float_sign_mask       = generate_fp_mask(StubGenStubId::float_sign_mask_id,  0x7FFFFFFF7FFFFFFF);\n-  StubRoutines::x86::_float_sign_flip       = generate_fp_mask(StubGenStubId::float_sign_flip_id,  0x8000000080000000);\n-  StubRoutines::x86::_double_sign_mask      = generate_fp_mask(StubGenStubId::double_sign_mask_id, 0x7FFFFFFFFFFFFFFF);\n-  StubRoutines::x86::_double_sign_flip      = generate_fp_mask(StubGenStubId::double_sign_flip_id, 0x8000000000000000);\n+  StubRoutines::x86::_float_sign_mask       = generate_fp_mask(StubId::stubgen_float_sign_mask_id,  0x7FFFFFFF7FFFFFFF);\n+  StubRoutines::x86::_float_sign_flip       = generate_fp_mask(StubId::stubgen_float_sign_flip_id,  0x8000000080000000);\n+  StubRoutines::x86::_double_sign_mask      = generate_fp_mask(StubId::stubgen_double_sign_mask_id, 0x7FFFFFFFFFFFFFFF);\n+  StubRoutines::x86::_double_sign_flip      = generate_fp_mask(StubId::stubgen_double_sign_flip_id, 0x8000000000000000);\n@@ -4168,7 +4168,7 @@\n-  StubRoutines::x86::_vector_float_sign_mask = generate_vector_mask(StubGenStubId::vector_float_sign_mask_id, 0x7FFFFFFF7FFFFFFF);\n-  StubRoutines::x86::_vector_float_sign_flip = generate_vector_mask(StubGenStubId::vector_float_sign_flip_id, 0x8000000080000000);\n-  StubRoutines::x86::_vector_double_sign_mask = generate_vector_mask(StubGenStubId::vector_double_sign_mask_id, 0x7FFFFFFFFFFFFFFF);\n-  StubRoutines::x86::_vector_double_sign_flip = generate_vector_mask(StubGenStubId::vector_double_sign_flip_id, 0x8000000000000000);\n-  StubRoutines::x86::_vector_all_bits_set = generate_vector_mask(StubGenStubId::vector_all_bits_set_id, 0xFFFFFFFFFFFFFFFF);\n-  StubRoutines::x86::_vector_int_mask_cmp_bits = generate_vector_mask(StubGenStubId::vector_int_mask_cmp_bits_id, 0x0000000100000001);\n-  StubRoutines::x86::_vector_short_to_byte_mask = generate_vector_mask(StubGenStubId::vector_short_to_byte_mask_id, 0x00ff00ff00ff00ff);\n+  StubRoutines::x86::_vector_float_sign_mask = generate_vector_mask(StubId::stubgen_vector_float_sign_mask_id, 0x7FFFFFFF7FFFFFFF);\n+  StubRoutines::x86::_vector_float_sign_flip = generate_vector_mask(StubId::stubgen_vector_float_sign_flip_id, 0x8000000080000000);\n+  StubRoutines::x86::_vector_double_sign_mask = generate_vector_mask(StubId::stubgen_vector_double_sign_mask_id, 0x7FFFFFFFFFFFFFFF);\n+  StubRoutines::x86::_vector_double_sign_flip = generate_vector_mask(StubId::stubgen_vector_double_sign_flip_id, 0x8000000000000000);\n+  StubRoutines::x86::_vector_all_bits_set = generate_vector_mask(StubId::stubgen_vector_all_bits_set_id, 0xFFFFFFFFFFFFFFFF);\n+  StubRoutines::x86::_vector_int_mask_cmp_bits = generate_vector_mask(StubId::stubgen_vector_int_mask_cmp_bits_id, 0x0000000100000001);\n+  StubRoutines::x86::_vector_short_to_byte_mask = generate_vector_mask(StubId::stubgen_vector_short_to_byte_mask_id, 0x00ff00ff00ff00ff);\n@@ -4176,3 +4176,3 @@\n-  StubRoutines::x86::_vector_int_to_byte_mask = generate_vector_mask(StubGenStubId::vector_int_to_byte_mask_id, 0x000000ff000000ff);\n-  StubRoutines::x86::_vector_int_to_short_mask = generate_vector_mask(StubGenStubId::vector_int_to_short_mask_id, 0x0000ffff0000ffff);\n-  StubRoutines::x86::_vector_32_bit_mask = generate_vector_custom_i32(StubGenStubId::vector_32_bit_mask_id, Assembler::AVX_512bit,\n+  StubRoutines::x86::_vector_int_to_byte_mask = generate_vector_mask(StubId::stubgen_vector_int_to_byte_mask_id, 0x000000ff000000ff);\n+  StubRoutines::x86::_vector_int_to_short_mask = generate_vector_mask(StubId::stubgen_vector_int_to_short_mask_id, 0x0000ffff0000ffff);\n+  StubRoutines::x86::_vector_32_bit_mask = generate_vector_custom_i32(StubId::stubgen_vector_32_bit_mask_id, Assembler::AVX_512bit,\n@@ -4180,1 +4180,1 @@\n-  StubRoutines::x86::_vector_64_bit_mask = generate_vector_custom_i32(StubGenStubId::vector_64_bit_mask_id, Assembler::AVX_512bit,\n+  StubRoutines::x86::_vector_64_bit_mask = generate_vector_custom_i32(StubId::stubgen_vector_64_bit_mask_id, Assembler::AVX_512bit,\n@@ -4182,1 +4182,1 @@\n-  StubRoutines::x86::_vector_int_shuffle_mask = generate_vector_mask(StubGenStubId::vector_int_shuffle_mask_id, 0x0302010003020100);\n+  StubRoutines::x86::_vector_int_shuffle_mask = generate_vector_mask(StubId::stubgen_vector_int_shuffle_mask_id, 0x0302010003020100);\n@@ -4184,3 +4184,3 @@\n-  StubRoutines::x86::_vector_short_shuffle_mask = generate_vector_mask(StubGenStubId::vector_short_shuffle_mask_id, 0x0100010001000100);\n-  StubRoutines::x86::_vector_long_shuffle_mask = generate_vector_mask(StubGenStubId::vector_long_shuffle_mask_id, 0x0000000100000000);\n-  StubRoutines::x86::_vector_long_sign_mask = generate_vector_mask(StubGenStubId::vector_long_sign_mask_id, 0x8000000000000000);\n+  StubRoutines::x86::_vector_short_shuffle_mask = generate_vector_mask(StubId::stubgen_vector_short_shuffle_mask_id, 0x0100010001000100);\n+  StubRoutines::x86::_vector_long_shuffle_mask = generate_vector_mask(StubId::stubgen_vector_long_shuffle_mask_id, 0x0000000100000000);\n+  StubRoutines::x86::_vector_long_sign_mask = generate_vector_mask(StubId::stubgen_vector_long_sign_mask_id, 0x8000000000000000);\n@@ -4195,4 +4195,4 @@\n-    StubRoutines::x86::_compress_perm_table32 = generate_compress_perm_table(StubGenStubId::compress_perm_table32_id);\n-    StubRoutines::x86::_compress_perm_table64 = generate_compress_perm_table(StubGenStubId::compress_perm_table64_id);\n-    StubRoutines::x86::_expand_perm_table32 = generate_expand_perm_table(StubGenStubId::expand_perm_table32_id);\n-    StubRoutines::x86::_expand_perm_table64 = generate_expand_perm_table(StubGenStubId::expand_perm_table64_id);\n+    StubRoutines::x86::_compress_perm_table32 = generate_compress_perm_table(StubId::stubgen_compress_perm_table32_id);\n+    StubRoutines::x86::_compress_perm_table64 = generate_compress_perm_table(StubId::stubgen_compress_perm_table64_id);\n+    StubRoutines::x86::_expand_perm_table32 = generate_expand_perm_table(StubId::stubgen_expand_perm_table32_id);\n+    StubRoutines::x86::_expand_perm_table64 = generate_expand_perm_table(StubId::stubgen_expand_perm_table64_id);\n@@ -4242,2 +4242,2 @@\n-    StubRoutines::_md5_implCompress = generate_md5_implCompress(StubGenStubId::md5_implCompress_id);\n-    StubRoutines::_md5_implCompressMB = generate_md5_implCompress(StubGenStubId::md5_implCompressMB_id);\n+    StubRoutines::_md5_implCompress = generate_md5_implCompress(StubId::stubgen_md5_implCompress_id);\n+    StubRoutines::_md5_implCompressMB = generate_md5_implCompress(StubId::stubgen_md5_implCompressMB_id);\n@@ -4249,2 +4249,2 @@\n-    StubRoutines::_sha1_implCompress = generate_sha1_implCompress(StubGenStubId::sha1_implCompress_id);\n-    StubRoutines::_sha1_implCompressMB = generate_sha1_implCompress(StubGenStubId::sha1_implCompressMB_id);\n+    StubRoutines::_sha1_implCompress = generate_sha1_implCompress(StubId::stubgen_sha1_implCompress_id);\n+    StubRoutines::_sha1_implCompressMB = generate_sha1_implCompress(StubId::stubgen_sha1_implCompressMB_id);\n@@ -4263,2 +4263,2 @@\n-    StubRoutines::_sha256_implCompress = generate_sha256_implCompress(StubGenStubId::sha256_implCompress_id);\n-    StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(StubGenStubId::sha256_implCompressMB_id);\n+    StubRoutines::_sha256_implCompress = generate_sha256_implCompress(StubId::stubgen_sha256_implCompress_id);\n+    StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(StubId::stubgen_sha256_implCompressMB_id);\n@@ -4270,2 +4270,2 @@\n-    StubRoutines::_sha512_implCompress = generate_sha512_implCompress(StubGenStubId::sha512_implCompress_id);\n-    StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(StubGenStubId::sha512_implCompressMB_id);\n+    StubRoutines::_sha512_implCompress = generate_sha512_implCompress(StubId::stubgen_sha512_implCompress_id);\n+    StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(StubId::stubgen_sha512_implCompressMB_id);\n@@ -4347,1 +4347,1 @@\n-StubGenerator::StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+StubGenerator::StubGenerator(CodeBuffer* code, BlobId blob_id) : StubCodeGenerator(code, blob_id) {\n@@ -4349,1 +4349,1 @@\n-  case preuniverse_id:\n+  case BlobId::stubgen_preuniverse_id:\n@@ -4352,1 +4352,1 @@\n-  case initial_id:\n+  case BlobId::stubgen_initial_id:\n@@ -4355,1 +4355,1 @@\n-  case continuation_id:\n+  case BlobId::stubgen_continuation_id:\n@@ -4358,1 +4358,1 @@\n-  case compiler_id:\n+  case BlobId::stubgen_compiler_id:\n@@ -4361,1 +4361,1 @@\n-  case final_id:\n+  case BlobId::stubgen_final_id:\n@@ -4365,1 +4365,1 @@\n-    fatal(\"unexpected blob id: %d\", blob_id);\n+    fatal(\"unexpected blob id: %s\", StubInfo::name(blob_id));\n@@ -4370,1 +4370,1 @@\n-void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+void StubGenerator_generate(CodeBuffer* code, BlobId blob_id) {\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":128,"deletions":128,"binary":false,"changes":256,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-  address generate_fp_mask(StubGenStubId stub_id, int64_t mask);\n+  address generate_fp_mask(StubId stub_id, int64_t mask);\n@@ -103,1 +103,1 @@\n-  address generate_compress_perm_table(StubGenStubId stub_id);\n+  address generate_compress_perm_table(StubId stub_id);\n@@ -105,1 +105,1 @@\n-  address generate_expand_perm_table(StubGenStubId stub_id);\n+  address generate_expand_perm_table(StubId stub_id);\n@@ -107,1 +107,1 @@\n-  address generate_vector_mask(StubGenStubId stub_id, int64_t mask);\n+  address generate_vector_mask(StubId stub_id, int64_t mask);\n@@ -111,1 +111,1 @@\n-  address generate_vector_fp_mask(StubGenStubId stub_id, int64_t mask);\n+  address generate_vector_fp_mask(StubId stub_id, int64_t mask);\n@@ -113,1 +113,1 @@\n-  address generate_vector_custom_i32(StubGenStubId stub_id, Assembler::AvxVectorLen len,\n+  address generate_vector_custom_i32(StubId stub_id, Assembler::AvxVectorLen len,\n@@ -183,1 +183,1 @@\n-  address generate_disjoint_copy_avx3_masked(StubGenStubId stub_id, address* entry);\n+  address generate_disjoint_copy_avx3_masked(StubId stub_id, address* entry);\n@@ -185,1 +185,1 @@\n-  address generate_conjoint_copy_avx3_masked(StubGenStubId stub_id, address* entry,\n+  address generate_conjoint_copy_avx3_masked(StubId stub_id, address* entry,\n@@ -233,1 +233,1 @@\n-  address generate_fill(StubGenStubId stub_id);\n+  address generate_fill(StubId stub_id);\n@@ -236,2 +236,2 @@\n-  address generate_disjoint_int_oop_copy(StubGenStubId stub_id, address* entry);\n-  address generate_conjoint_int_oop_copy(StubGenStubId stub_id, address nooverlap_target,\n+  address generate_disjoint_int_oop_copy(StubId stub_id, address* entry);\n+  address generate_conjoint_int_oop_copy(StubId stub_id, address nooverlap_target,\n@@ -239,2 +239,2 @@\n-  address generate_disjoint_long_oop_copy(StubGenStubId stub_id, address* entry);\n-  address generate_conjoint_long_oop_copy(StubGenStubId stub_id, address nooverlap_target,\n+  address generate_disjoint_long_oop_copy(StubId stub_id, address* entry);\n+  address generate_conjoint_long_oop_copy(StubId stub_id, address nooverlap_target,\n@@ -251,1 +251,1 @@\n-  address generate_checkcast_copy(StubGenStubId stub_id, address *entry);\n+  address generate_checkcast_copy(StubId stub_id, address *entry);\n@@ -297,1 +297,1 @@\n-  address generate_md5_implCompress(StubGenStubId stub_id);\n+  address generate_md5_implCompress(StubId stub_id);\n@@ -304,1 +304,1 @@\n-  address generate_sha1_implCompress(StubGenStubId stub_id);\n+  address generate_sha1_implCompress(StubId stub_id);\n@@ -308,2 +308,2 @@\n-  address generate_sha256_implCompress(StubGenStubId stub_id);\n-  address generate_sha512_implCompress(StubGenStubId stub_id);\n+  address generate_sha256_implCompress(StubId stub_id);\n+  address generate_sha512_implCompress(StubId stub_id);\n@@ -593,1 +593,1 @@\n-  address generate_cont_thaw(StubGenStubId stub_id);\n+  address generate_cont_thaw(StubId stub_id);\n@@ -644,1 +644,1 @@\n-  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id);\n+  StubGenerator(CodeBuffer* code, BlobId blob_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2021, 2024, Intel Corporation. All rights reserved.\n+* Copyright (c) 2021, 2025, Intel Corporation. All rights reserved.\n@@ -69,1 +69,1 @@\n-  StubGenStubId stub_id = StubGenStubId::updateBytesAdler32_id;\n+  StubId stub_id = StubId::stubgen_updateBytesAdler32_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_adler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2019, 2024, Intel Corporation. All rights reserved.\n+* Copyright (c) 2019, 2025, Intel Corporation. All rights reserved.\n@@ -252,1 +252,1 @@\n-  StubGenStubId stub_id = StubGenStubId::galoisCounterMode_AESCrypt_id;\n+  StubId stub_id = StubId::stubgen_galoisCounterMode_AESCrypt_id;\n@@ -339,1 +339,1 @@\n-  StubGenStubId stub_id = StubGenStubId::galoisCounterMode_AESCrypt_id;\n+  StubId stub_id = StubId::stubgen_galoisCounterMode_AESCrypt_id;\n@@ -411,1 +411,1 @@\n-  StubGenStubId stub_id = StubGenStubId::counterMode_AESCrypt_id;\n+  StubId stub_id = StubId::stubgen_counterMode_AESCrypt_id;\n@@ -500,1 +500,1 @@\n-  StubGenStubId stub_id = StubGenStubId::counterMode_AESCrypt_id;\n+  StubId stub_id = StubId::stubgen_counterMode_AESCrypt_id;\n@@ -788,1 +788,1 @@\n-  StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_decryptAESCrypt_id;\n+  StubId stub_id = StubId::stubgen_cipherBlockChaining_decryptAESCrypt_id;\n@@ -1071,1 +1071,1 @@\n-  StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+  StubId stub_id = StubId::stubgen_aescrypt_encryptBlock_id;\n@@ -1166,1 +1166,1 @@\n-  StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+  StubId stub_id = StubId::stubgen_aescrypt_decryptBlock_id;\n@@ -1268,1 +1268,1 @@\n-  StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_encryptAESCrypt_id;\n+  StubId stub_id = StubId::stubgen_cipherBlockChaining_encryptAESCrypt_id;\n@@ -1420,1 +1420,1 @@\n-  StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_decryptAESCrypt_id;\n+  StubId stub_id = StubId::stubgen_cipherBlockChaining_decryptAESCrypt_id;\n@@ -1663,1 +1663,1 @@\n-  StubGenStubId stub_id = StubGenStubId::electronicCodeBook_encryptAESCrypt_id;\n+  StubId stub_id = StubId::stubgen_electronicCodeBook_encryptAESCrypt_id;\n@@ -1684,1 +1684,1 @@\n-  StubGenStubId stub_id = StubGenStubId::electronicCodeBook_decryptAESCrypt_id;\n+  StubId stub_id = StubId::stubgen_electronicCodeBook_decryptAESCrypt_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_aes.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -93,2 +93,2 @@\n-  StubRoutines::_jint_disjoint_arraycopy   = generate_disjoint_int_oop_copy(StubGenStubId::jint_disjoint_arraycopy_id, &entry);\n-  StubRoutines::_jint_arraycopy            = generate_conjoint_int_oop_copy(StubGenStubId::jint_arraycopy_id, entry, &entry_jint_arraycopy);\n+  StubRoutines::_jint_disjoint_arraycopy   = generate_disjoint_int_oop_copy(StubId::stubgen_jint_disjoint_arraycopy_id, &entry);\n+  StubRoutines::_jint_arraycopy            = generate_conjoint_int_oop_copy(StubId::stubgen_jint_arraycopy_id, entry, &entry_jint_arraycopy);\n@@ -96,2 +96,2 @@\n-  StubRoutines::_jlong_disjoint_arraycopy  = generate_disjoint_long_oop_copy(StubGenStubId::jlong_disjoint_arraycopy_id, &entry);\n-  StubRoutines::_jlong_arraycopy           = generate_conjoint_long_oop_copy(StubGenStubId::jlong_arraycopy_id, entry, &entry_jlong_arraycopy);\n+  StubRoutines::_jlong_disjoint_arraycopy  = generate_disjoint_long_oop_copy(StubId::stubgen_jlong_disjoint_arraycopy_id, &entry);\n+  StubRoutines::_jlong_arraycopy           = generate_conjoint_long_oop_copy(StubId::stubgen_jlong_arraycopy_id, entry, &entry_jlong_arraycopy);\n@@ -99,4 +99,4 @@\n-    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_int_oop_copy(StubGenStubId::oop_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_oop_arraycopy           = generate_conjoint_int_oop_copy(StubGenStubId::oop_arraycopy_id, entry, &entry_oop_arraycopy);\n-    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_int_oop_copy(StubGenStubId::oop_disjoint_arraycopy_uninit_id, &entry);\n-    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_int_oop_copy(StubGenStubId::oop_arraycopy_uninit_id, entry, nullptr);\n+    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_int_oop_copy(StubId::stubgen_oop_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_oop_arraycopy           = generate_conjoint_int_oop_copy(StubId::stubgen_oop_arraycopy_id, entry, &entry_oop_arraycopy);\n+    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_int_oop_copy(StubId::stubgen_oop_disjoint_arraycopy_uninit_id, &entry);\n+    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_int_oop_copy(StubId::stubgen_oop_arraycopy_uninit_id, entry, nullptr);\n@@ -104,4 +104,4 @@\n-    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_long_oop_copy(StubGenStubId::oop_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_oop_arraycopy           = generate_conjoint_long_oop_copy(StubGenStubId::oop_arraycopy_id, entry, &entry_oop_arraycopy);\n-    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_long_oop_copy(StubGenStubId::oop_disjoint_arraycopy_uninit_id, &entry);\n-    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_long_oop_copy(StubGenStubId::oop_arraycopy_uninit_id, entry, nullptr);\n+    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_long_oop_copy(StubId::stubgen_oop_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_oop_arraycopy           = generate_conjoint_long_oop_copy(StubId::stubgen_oop_arraycopy_id, entry, &entry_oop_arraycopy);\n+    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_long_oop_copy(StubId::stubgen_oop_disjoint_arraycopy_uninit_id, &entry);\n+    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_long_oop_copy(StubId::stubgen_oop_arraycopy_uninit_id, entry, nullptr);\n@@ -110,2 +110,2 @@\n-  StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_id, &entry_checkcast_arraycopy);\n-  StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_uninit_id, nullptr);\n+  StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubId::stubgen_checkcast_arraycopy_id, &entry_checkcast_arraycopy);\n+  StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubId::stubgen_checkcast_arraycopy_uninit_id, nullptr);\n@@ -124,6 +124,6 @@\n-  StubRoutines::_jbyte_fill = generate_fill(StubGenStubId::jbyte_fill_id);\n-  StubRoutines::_jshort_fill = generate_fill(StubGenStubId::jshort_fill_id);\n-  StubRoutines::_jint_fill = generate_fill(StubGenStubId::jint_fill_id);\n-  StubRoutines::_arrayof_jbyte_fill = generate_fill(StubGenStubId::arrayof_jbyte_fill_id);\n-  StubRoutines::_arrayof_jshort_fill = generate_fill(StubGenStubId::arrayof_jshort_fill_id);\n-  StubRoutines::_arrayof_jint_fill = generate_fill(StubGenStubId::arrayof_jint_fill_id);\n+  StubRoutines::_jbyte_fill = generate_fill(StubId::stubgen_jbyte_fill_id);\n+  StubRoutines::_jshort_fill = generate_fill(StubId::stubgen_jshort_fill_id);\n+  StubRoutines::_jint_fill = generate_fill(StubId::stubgen_jint_fill_id);\n+  StubRoutines::_arrayof_jbyte_fill = generate_fill(StubId::stubgen_arrayof_jbyte_fill_id);\n+  StubRoutines::_arrayof_jshort_fill = generate_fill(StubId::stubgen_arrayof_jshort_fill_id);\n+  StubRoutines::_arrayof_jint_fill = generate_fill(StubId::stubgen_arrayof_jint_fill_id);\n@@ -487,1 +487,1 @@\n-address StubGenerator::generate_disjoint_copy_avx3_masked(StubGenStubId stub_id, address* entry) {\n+address StubGenerator::generate_disjoint_copy_avx3_masked(StubId stub_id, address* entry) {\n@@ -495,1 +495,1 @@\n-  case jbyte_disjoint_arraycopy_id:\n+  case StubId::stubgen_jbyte_disjoint_arraycopy_id:\n@@ -500,1 +500,1 @@\n-  case jshort_disjoint_arraycopy_id:\n+  case StubId::stubgen_jshort_disjoint_arraycopy_id:\n@@ -505,1 +505,1 @@\n-  case jint_disjoint_arraycopy_id:\n+  case StubId::stubgen_jint_disjoint_arraycopy_id:\n@@ -510,1 +510,1 @@\n-  case jlong_disjoint_arraycopy_id:\n+  case StubId::stubgen_jlong_disjoint_arraycopy_id:\n@@ -515,1 +515,1 @@\n-  case oop_disjoint_arraycopy_id:\n+  case StubId::stubgen_oop_disjoint_arraycopy_id:\n@@ -520,1 +520,1 @@\n-  case oop_disjoint_arraycopy_uninit_id:\n+  case StubId::stubgen_oop_disjoint_arraycopy_uninit_id:\n@@ -825,1 +825,1 @@\n-address StubGenerator::generate_conjoint_copy_avx3_masked(StubGenStubId stub_id, address* entry, address nooverlap_target) {\n+address StubGenerator::generate_conjoint_copy_avx3_masked(StubId stub_id, address* entry, address nooverlap_target) {\n@@ -833,1 +833,1 @@\n-  case jbyte_arraycopy_id:\n+  case StubId::stubgen_jbyte_arraycopy_id:\n@@ -838,1 +838,1 @@\n-  case jshort_arraycopy_id:\n+  case StubId::stubgen_jshort_arraycopy_id:\n@@ -843,1 +843,1 @@\n-  case jint_arraycopy_id:\n+  case StubId::stubgen_jint_arraycopy_id:\n@@ -848,1 +848,1 @@\n-  case jlong_arraycopy_id:\n+  case StubId::stubgen_jlong_arraycopy_id:\n@@ -853,1 +853,1 @@\n-  case oop_arraycopy_id:\n+  case StubId::stubgen_oop_arraycopy_id:\n@@ -858,1 +858,1 @@\n-  case oop_arraycopy_uninit_id:\n+  case StubId::stubgen_oop_arraycopy_uninit_id:\n@@ -1337,1 +1337,1 @@\n-  StubGenStubId stub_id = StubGenStubId::jbyte_disjoint_arraycopy_id;\n+  StubId stub_id = StubId::stubgen_jbyte_disjoint_arraycopy_id;\n@@ -1455,1 +1455,1 @@\n-  StubGenStubId stub_id = StubGenStubId::jbyte_arraycopy_id;\n+  StubId stub_id = StubId::stubgen_jbyte_arraycopy_id;\n@@ -1568,1 +1568,1 @@\n-  StubGenStubId stub_id = StubGenStubId::jshort_disjoint_arraycopy_id;\n+  StubId stub_id = StubId::stubgen_jshort_disjoint_arraycopy_id;\n@@ -1665,1 +1665,1 @@\n-address StubGenerator::generate_fill(StubGenStubId stub_id) {\n+address StubGenerator::generate_fill(StubId stub_id) {\n@@ -1670,1 +1670,1 @@\n-  case jbyte_fill_id:\n+  case StubId::stubgen_jbyte_fill_id:\n@@ -1674,1 +1674,1 @@\n-  case jshort_fill_id:\n+  case StubId::stubgen_jshort_fill_id:\n@@ -1678,1 +1678,1 @@\n-  case jint_fill_id:\n+  case StubId::stubgen_jint_fill_id:\n@@ -1682,1 +1682,1 @@\n-  case arrayof_jbyte_fill_id:\n+  case StubId::stubgen_arrayof_jbyte_fill_id:\n@@ -1686,1 +1686,1 @@\n-  case arrayof_jshort_fill_id:\n+  case StubId::stubgen_arrayof_jshort_fill_id:\n@@ -1690,1 +1690,1 @@\n-  case arrayof_jint_fill_id:\n+  case StubId::stubgen_arrayof_jint_fill_id:\n@@ -1740,1 +1740,1 @@\n-  StubGenStubId stub_id = StubGenStubId::jshort_arraycopy_id;\n+  StubId stub_id = StubId::stubgen_jshort_arraycopy_id;\n@@ -1846,1 +1846,1 @@\n-address StubGenerator::generate_disjoint_int_oop_copy(StubGenStubId stub_id, address* entry) {\n+address StubGenerator::generate_disjoint_int_oop_copy(StubId stub_id, address* entry) {\n@@ -1852,1 +1852,1 @@\n-  case StubGenStubId::jint_disjoint_arraycopy_id:\n+  case StubId::stubgen_jint_disjoint_arraycopy_id:\n@@ -1856,1 +1856,1 @@\n-  case StubGenStubId::oop_disjoint_arraycopy_id:\n+  case StubId::stubgen_oop_disjoint_arraycopy_id:\n@@ -1861,1 +1861,1 @@\n-  case StubGenStubId::oop_disjoint_arraycopy_uninit_id:\n+  case StubId::stubgen_oop_disjoint_arraycopy_uninit_id:\n@@ -1977,1 +1977,1 @@\n-address StubGenerator::generate_conjoint_int_oop_copy(StubGenStubId stub_id, address nooverlap_target, address *entry) {\n+address StubGenerator::generate_conjoint_int_oop_copy(StubId stub_id, address nooverlap_target, address *entry) {\n@@ -1983,1 +1983,1 @@\n-  case StubGenStubId::jint_arraycopy_id:\n+  case StubId::stubgen_jint_arraycopy_id:\n@@ -1987,1 +1987,1 @@\n-  case StubGenStubId::oop_arraycopy_id:\n+  case StubId::stubgen_oop_arraycopy_id:\n@@ -1992,1 +1992,1 @@\n-  case StubGenStubId::oop_arraycopy_uninit_id:\n+  case StubId::stubgen_oop_arraycopy_uninit_id:\n@@ -2110,1 +2110,1 @@\n-address StubGenerator::generate_disjoint_long_oop_copy(StubGenStubId stub_id, address *entry) {\n+address StubGenerator::generate_disjoint_long_oop_copy(StubId stub_id, address *entry) {\n@@ -2116,1 +2116,1 @@\n-  case StubGenStubId::jlong_disjoint_arraycopy_id:\n+  case StubId::stubgen_jlong_disjoint_arraycopy_id:\n@@ -2120,1 +2120,1 @@\n-  case StubGenStubId::oop_disjoint_arraycopy_id:\n+  case StubId::stubgen_oop_disjoint_arraycopy_id:\n@@ -2125,1 +2125,1 @@\n-  case StubGenStubId::oop_disjoint_arraycopy_uninit_id:\n+  case StubId::stubgen_oop_disjoint_arraycopy_uninit_id:\n@@ -2243,1 +2243,1 @@\n-address StubGenerator::generate_conjoint_long_oop_copy(StubGenStubId stub_id, address nooverlap_target, address *entry) {\n+address StubGenerator::generate_conjoint_long_oop_copy(StubId stub_id, address nooverlap_target, address *entry) {\n@@ -2249,1 +2249,1 @@\n-  case StubGenStubId::jlong_arraycopy_id:\n+  case StubId::stubgen_jlong_arraycopy_id:\n@@ -2253,1 +2253,1 @@\n-  case StubGenStubId::oop_arraycopy_id:\n+  case StubId::stubgen_oop_arraycopy_id:\n@@ -2258,1 +2258,1 @@\n-  case StubGenStubId::oop_arraycopy_uninit_id:\n+  case StubId::stubgen_oop_arraycopy_uninit_id:\n@@ -2394,1 +2394,1 @@\n-address StubGenerator::generate_checkcast_copy(StubGenStubId stub_id, address *entry) {\n+address StubGenerator::generate_checkcast_copy(StubId stub_id, address *entry) {\n@@ -2398,1 +2398,1 @@\n-  case StubGenStubId::checkcast_arraycopy_id:\n+  case StubId::stubgen_checkcast_arraycopy_id:\n@@ -2401,1 +2401,1 @@\n-  case StubGenStubId::checkcast_arraycopy_uninit_id:\n+  case StubId::stubgen_checkcast_arraycopy_uninit_id:\n@@ -2626,1 +2626,1 @@\n-  StubGenStubId stub_id = StubGenStubId::unsafe_arraycopy_id;\n+  StubId stub_id = StubId::stubgen_unsafe_arraycopy_id;\n@@ -2762,1 +2762,1 @@\n-  StubGenStubId stub_id = StubGenStubId::unsafe_setmemory_id;\n+  StubId stub_id = StubId::stubgen_unsafe_setmemory_id;\n@@ -2932,1 +2932,1 @@\n-  StubGenStubId stub_id = StubGenStubId::generic_arraycopy_id;\n+  StubId stub_id = StubId::stubgen_generic_arraycopy_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":67,"deletions":67,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-  StubGenStubId stub_id = StubGenStubId::dcbrt_id;\n+  StubId stub_id = StubId::stubgen_dcbrt_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_cbrt.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-  StubGenStubId stub_id = StubGenStubId::chacha20Block_id;\n+  StubId stub_id = StubId::stubgen_chacha20Block_id;\n@@ -304,1 +304,1 @@\n-  StubGenStubId stub_id = StubGenStubId::chacha20Block_id;\n+  StubId stub_id = StubId::stubgen_chacha20Block_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_chacha.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2016, 2024, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2016, 2025, Intel Corporation. All rights reserved.\n@@ -176,1 +176,1 @@\n-  StubGenStubId stub_id = StubGenStubId::dcos_id;\n+  StubId stub_id = StubId::stubgen_dcos_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_cos.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -277,1 +277,1 @@\n-  StubGenStubId stub_id = dilithiumAlmostNtt_id;\n+  StubId stub_id = StubId::stubgen_dilithiumAlmostNtt_id;\n@@ -467,1 +467,1 @@\n-  StubGenStubId stub_id = dilithiumAlmostInverseNtt_id;\n+  StubId stub_id = StubId::stubgen_dilithiumAlmostInverseNtt_id;\n@@ -648,1 +648,1 @@\n-  StubGenStubId stub_id = dilithiumNttMult_id;\n+  StubId stub_id = StubId::stubgen_dilithiumNttMult_id;\n@@ -712,1 +712,1 @@\n-  StubGenStubId stub_id = dilithiumMontMulByConstant_id;\n+  StubId stub_id = StubId::stubgen_dilithiumMontMulByConstant_id;\n@@ -776,1 +776,1 @@\n-  StubGenStubId stub_id = dilithiumDecomposePoly_id;\n+  StubId stub_id = StubId::stubgen_dilithiumDecomposePoly_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_dilithium.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2024, Intel Corporation. All rights reserved.\n+* Copyright (c) 2016, 2025, Intel Corporation. All rights reserved.\n@@ -168,1 +168,1 @@\n-  StubGenStubId stub_id = StubGenStubId::dexp_id;\n+  StubId stub_id = StubId::stubgen_dexp_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_exp.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2023, 2025, Intel Corporation. All rights reserved.\n@@ -76,1 +76,1 @@\n-  StubGenStubId stub_id = StubGenStubId::fmod_id;\n+  StubId stub_id = StubId::stubgen_fmod_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_fmod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2019, 2024, Intel Corporation. All rights reserved.\n+* Copyright (c) 2019, 2025, Intel Corporation. All rights reserved.\n@@ -85,1 +85,1 @@\n-  StubGenStubId stub_id = StubGenStubId::ghash_processBlocks_id;\n+  StubId stub_id = StubId::stubgen_ghash_processBlocks_id;\n@@ -222,1 +222,1 @@\n-  StubGenStubId stub_id = StubGenStubId::ghash_processBlocks_id;\n+  StubId stub_id = StubId::stubgen_ghash_processBlocks_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_ghash.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -371,1 +371,1 @@\n-  StubGenStubId stub_id = kyberNtt_id;\n+  StubId stub_id = StubId::stubgen_kyberNtt_id;\n@@ -468,1 +468,1 @@\n-  StubGenStubId stub_id = kyberInverseNtt_id;\n+  StubId stub_id = StubId::stubgen_kyberInverseNtt_id;\n@@ -593,1 +593,1 @@\n-  StubGenStubId stub_id = kyberNttMult_id;\n+  StubId stub_id = StubId::stubgen_kyberNttMult_id;\n@@ -713,1 +713,1 @@\n-  StubGenStubId stub_id = kyberAddPoly_2_id;\n+  StubId stub_id = StubId::stubgen_kyberAddPoly_2_id;\n@@ -759,1 +759,1 @@\n-  StubGenStubId stub_id = kyberAddPoly_3_id;\n+  StubId stub_id = StubId::stubgen_kyberAddPoly_3_id;\n@@ -813,1 +813,1 @@\n-  StubGenStubId stub_id = kyber12To16_id;\n+  StubId stub_id = StubId::stubgen_kyber12To16_id;\n@@ -910,1 +910,1 @@\n-  StubGenStubId stub_id = kyberBarrettReduce_id;\n+  StubId stub_id = StubId::stubgen_kyberBarrettReduce_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_kyber.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2024, Intel Corporation. All rights reserved.\n+* Copyright (c) 2016, 2025, Intel Corporation. All rights reserved.\n@@ -179,1 +179,1 @@\n-  StubGenStubId stub_id = StubGenStubId::dlog_id;\n+  StubId stub_id = StubId::stubgen_dlog_id;\n@@ -518,1 +518,1 @@\n-  StubGenStubId stub_id = StubGenStubId::dlog10_id;\n+  StubId stub_id = StubId::stubgen_dlog10_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_log.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2022, 2025, Intel Corporation. All rights reserved.\n@@ -913,1 +913,1 @@\n-  StubGenStubId stub_id = StubGenStubId::poly1305_processBlocks_id;\n+  StubId stub_id = StubId::stubgen_poly1305_processBlocks_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly1305.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -562,1 +562,1 @@\n-  StubGenStubId stub_id = StubGenStubId::intpoly_montgomeryMult_P256_id;\n+  StubId stub_id = StubId::stubgen_intpoly_montgomeryMult_P256_id;\n@@ -684,1 +684,1 @@\n-  StubGenStubId stub_id = StubGenStubId::intpoly_assign_id;\n+  StubId stub_id = StubId::stubgen_intpoly_assign_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly_mont.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2024, Intel Corporation. All rights reserved.\n+* Copyright (c) 2016, 2025, Intel Corporation. All rights reserved.\n@@ -762,1 +762,1 @@\n-  StubGenStubId stub_id = StubGenStubId::dpow_id;\n+  StubId stub_id = StubId::stubgen_dpow_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_pow.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-static address generate_sha3_implCompress(StubGenStubId stub_id,\n+static address generate_sha3_implCompress(StubId stub_id,\n@@ -98,1 +98,1 @@\n-  case sha3_implCompress_id:\n+  case StubId::stubgen_sha3_implCompress_id:\n@@ -101,1 +101,1 @@\n-  case sha3_implCompressMB_id:\n+  case StubId::stubgen_sha3_implCompressMB_id:\n@@ -330,1 +330,1 @@\n-  StubGenStubId stub_id = double_keccak_id;\n+  StubId stub_id = StubId::stubgen_double_keccak_id;\n@@ -504,1 +504,1 @@\n-      generate_sha3_implCompress(StubGenStubId::sha3_implCompress_id, this, _masm);\n+      generate_sha3_implCompress(StubId::stubgen_sha3_implCompress_id, this, _masm);\n@@ -508,1 +508,1 @@\n-      generate_sha3_implCompress(StubGenStubId::sha3_implCompressMB_id, this, _masm);\n+      generate_sha3_implCompress(StubId::stubgen_sha3_implCompressMB_id, this, _masm);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_sha3.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2016, 2025, Intel Corporation. All rights reserved.\n@@ -183,1 +183,1 @@\n-  StubGenStubId stub_id = StubGenStubId::dsin_id;\n+  StubId stub_id = StubId::stubgen_dsin_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_sin.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2024, Intel Corporation. All rights reserved.\n+* Copyright (c) 2016, 2025, Intel Corporation. All rights reserved.\n@@ -458,1 +458,1 @@\n-  StubGenStubId stub_id = StubGenStubId::dtan_id;\n+  StubId stub_id = StubId::stubgen_dtan_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_tan.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-  StubGenStubId stub_id = StubGenStubId::dtanh_id;\n+  StubId stub_id = StubId::stubgen_dtanh_id;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_tanh.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3569,2 +3569,1 @@\n-      assert(is_aligned(oopDesc::base_offset_in_bytes(), BytesPerLong), \"oop base offset must be 8-byte-aligned\");\n-      __ decrement(rdx, oopDesc::base_offset_in_bytes());\n+      __ decrement(rdx, align_up(oopDesc::base_offset_in_bytes(), BytesPerLong));\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4026,1 +4026,1 @@\n-instruct vgather_subwordLE8B(vec dst, memory mem, rRegP idx_base, immI_0 offset, rRegP tmp, rRegI rtmp) %{\n+instruct vgather_subwordLE8B(vec dst, memory mem, rRegP idx_base, rRegP tmp, rRegI rtmp) %{\n@@ -4028,1 +4028,1 @@\n-  match(Set dst (LoadVectorGather mem (Binary idx_base offset)));\n+  match(Set dst (LoadVectorGather mem idx_base));\n@@ -4035,1 +4035,1 @@\n-    __ vgather8b_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, noreg, $rtmp$$Register, vlen_enc);\n+    __ vgather8b(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $rtmp$$Register, vlen_enc);\n@@ -4040,1 +4040,1 @@\n-instruct vgather_subwordGT8B(vec dst, memory mem, rRegP idx_base, immI_0 offset, rRegP tmp, rRegP idx_base_temp,\n+instruct vgather_subwordGT8B(vec dst, memory mem, rRegP idx_base, rRegP tmp, rRegP idx_base_temp,\n@@ -4043,1 +4043,1 @@\n-  match(Set dst (LoadVectorGather mem (Binary idx_base offset)));\n+  match(Set dst (LoadVectorGather mem idx_base));\n@@ -4052,1 +4052,1 @@\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, noreg, noreg, $xtmp1$$XMMRegister,\n+    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, noreg, $xtmp1$$XMMRegister,\n@@ -4058,35 +4058,1 @@\n-instruct vgather_subwordLE8B_off(vec dst, memory mem, rRegP idx_base, rRegI offset, rRegP tmp, rRegI rtmp, rFlagsReg cr) %{\n-  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) <= 8);\n-  match(Set dst (LoadVectorGather mem (Binary idx_base offset)));\n-  effect(TEMP tmp, TEMP rtmp, KILL cr);\n-  format %{ \"vector_gatherLE8_off $dst, $mem, $idx_base, $offset\\t! using $tmp and $rtmp as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ vgather8b_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $offset$$Register, $rtmp$$Register, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\n-instruct vgather_subwordGT8B_off(vec dst, memory mem, rRegP idx_base, rRegI offset, rRegP tmp, rRegP idx_base_temp,\n-                                 vec xtmp1, vec xtmp2, vec xtmp3, rRegI rtmp, rRegI length, rFlagsReg cr) %{\n-  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) > 8);\n-  match(Set dst (LoadVectorGather mem (Binary idx_base offset)));\n-  effect(TEMP_DEF dst, TEMP tmp, TEMP idx_base_temp, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, TEMP length, KILL cr);\n-  format %{ \"vector_gatherGT8_off $dst, $mem, $idx_base, $offset\\t! using $tmp, $idx_base_temp, $xtmp1, $xtmp2, $xtmp3, $rtmp and $length as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    int vector_len = Matcher::vector_length(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ movptr($idx_base_temp$$Register, $idx_base$$Register);\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, $offset$$Register, noreg, $xtmp1$$XMMRegister,\n-                       $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $rtmp$$Register, noreg, $length$$Register, vector_len, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\n-instruct vgather_masked_subwordLE8B_avx3(vec dst, memory mem, rRegP idx_base, immI_0 offset, kReg mask, rRegL mask_idx, rRegP tmp, rRegI rtmp, rRegL rtmp2, rFlagsReg cr) %{\n+instruct vgather_masked_subwordLE8B_avx3(vec dst, memory mem, rRegP idx_base, kReg mask, rRegL mask_idx, rRegP tmp, rRegI rtmp, rRegL rtmp2, rFlagsReg cr) %{\n@@ -4094,1 +4060,1 @@\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base mask)));\n@@ -4103,1 +4069,1 @@\n-    __ vgather8b_masked_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, noreg, $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n+    __ vgather8b_masked(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n@@ -4108,1 +4074,1 @@\n-instruct vgather_masked_subwordGT8B_avx3(vec dst, memory mem, rRegP idx_base, immI_0 offset, kReg mask, rRegP tmp, rRegP idx_base_temp,\n+instruct vgather_masked_subwordGT8B_avx3(vec dst, memory mem, rRegP idx_base, kReg mask, rRegP tmp, rRegP idx_base_temp,\n@@ -4111,1 +4077,1 @@\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base mask)));\n@@ -4122,1 +4088,1 @@\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, noreg, $rtmp2$$Register, $xtmp1$$XMMRegister,\n+    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, $rtmp2$$Register, $xtmp1$$XMMRegister,\n@@ -4128,38 +4094,1 @@\n-instruct vgather_masked_subwordLE8B_off_avx3(vec dst, memory mem, rRegP idx_base, rRegI offset, kReg mask, rRegL mask_idx, rRegP tmp, rRegI rtmp, rRegL rtmp2, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_avx512bw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) <= 8);\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n-  effect(TEMP mask_idx, TEMP tmp, TEMP rtmp, TEMP rtmp2, KILL cr);\n-  format %{ \"vector_masked_gatherLE8_off $dst, $mem, $idx_base, $offset, $mask\\t! using $mask_idx, $tmp, $rtmp and $rtmp2 as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ xorq($mask_idx$$Register, $mask_idx$$Register);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ kmovql($rtmp2$$Register, $mask$$KRegister);\n-    __ vgather8b_masked_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $offset$$Register,\n-                                $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vgather_masked_subwordGT8B_off_avx3(vec dst, memory mem, rRegP idx_base, rRegI offset, kReg mask, rRegP tmp, rRegP idx_base_temp,\n-                                             vec xtmp1, vec xtmp2, vec xtmp3, rRegI rtmp, rRegL rtmp2, rRegL mask_idx, rRegI length, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_avx512bw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) > 8);\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n-  effect(TEMP_DEF dst, TEMP tmp, TEMP idx_base_temp, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, TEMP rtmp2, TEMP mask_idx, TEMP length, KILL cr);\n-  format %{ \"vector_gatherGT8_masked_off $dst, $mem, $idx_base, $offset, $mask\\t! using $tmp, $idx_base_temp, $xtmp1, $xtmp2, $xtmp3, $rtmp, $rtmp2, $mask_idx and $length as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    int vector_len = Matcher::vector_length(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ xorq($mask_idx$$Register, $mask_idx$$Register);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ movptr($idx_base_temp$$Register, $idx_base$$Register);\n-    __ kmovql($rtmp2$$Register, $mask$$KRegister);\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, $offset$$Register, $rtmp2$$Register, $xtmp1$$XMMRegister,\n-                       $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $rtmp$$Register, $mask_idx$$Register, $length$$Register, vector_len, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vgather_masked_subwordLE8B_avx2(vec dst, memory mem, rRegP idx_base, immI_0 offset, vec mask, rRegI mask_idx, rRegP tmp, rRegI rtmp, rRegI rtmp2, rFlagsReg cr) %{\n+instruct vgather_masked_subwordLE8B_avx2(vec dst, memory mem, rRegP idx_base, vec mask, rRegI mask_idx, rRegP tmp, rRegI rtmp, rRegI rtmp2, rFlagsReg cr) %{\n@@ -4167,1 +4096,1 @@\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base mask)));\n@@ -4180,1 +4109,1 @@\n-    __ vgather8b_masked_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, noreg, $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n+    __ vgather8b_masked(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n@@ -4185,1 +4114,1 @@\n-instruct vgather_masked_subwordGT8B_avx2(vec dst, memory mem, rRegP idx_base, immI_0 offset, vec mask, rRegP tmp, rRegP idx_base_temp,\n+instruct vgather_masked_subwordGT8B_avx2(vec dst, memory mem, rRegP idx_base, vec mask, rRegP tmp, rRegP idx_base_temp,\n@@ -4188,1 +4117,1 @@\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base mask)));\n@@ -4203,47 +4132,1 @@\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, noreg, $rtmp2$$Register, $xtmp1$$XMMRegister,\n-                       $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $rtmp$$Register, $mask_idx$$Register, $length$$Register, vector_len, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vgather_masked_subwordLE8B_off_avx2(vec dst, memory mem, rRegP idx_base, rRegI offset, vec mask, rRegI mask_idx, rRegP tmp, rRegI rtmp, rRegI rtmp2, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512vlbw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) <= 8);\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n-  effect(TEMP mask_idx, TEMP tmp, TEMP rtmp, TEMP rtmp2, KILL cr);\n-  format %{ \"vector_masked_gatherLE8_off $dst, $mem, $idx_base, $offset, $mask\\t! using $mask_idx, $tmp, $rtmp and $rtmp2 as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ vpmovmskb($rtmp2$$Register, $mask$$XMMRegister, vlen_enc);\n-    if (elem_bt == T_SHORT) {\n-      __ movl($mask_idx$$Register, 0x55555555);\n-      __ pextl($rtmp2$$Register, $rtmp2$$Register, $mask_idx$$Register);\n-    }\n-    __ xorl($mask_idx$$Register, $mask_idx$$Register);\n-    __ vgather8b_masked_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $offset$$Register,\n-                                $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vgather_masked_subwordGT8B_off_avx2(vec dst, memory mem, rRegP idx_base, rRegI offset, vec mask, rRegP tmp, rRegP idx_base_temp,\n-                                             vec xtmp1, vec xtmp2, vec xtmp3, rRegI rtmp, rRegI rtmp2, rRegI mask_idx, rRegI length, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512vlbw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) > 8);\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n-  effect(TEMP_DEF dst, TEMP tmp, TEMP idx_base_temp, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, TEMP rtmp2, TEMP mask_idx, TEMP length, KILL cr);\n-  format %{ \"vector_gatherGT8_masked_off $dst, $mem, $idx_base, $offset, $mask\\t! using $tmp, $idx_base_temp, $xtmp1, $xtmp2, $xtmp3, $rtmp, $rtmp2, $mask_idx and $length as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    int vector_len = Matcher::vector_length(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ xorl($mask_idx$$Register, $mask_idx$$Register);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ movptr($idx_base_temp$$Register, $idx_base$$Register);\n-    __ vpmovmskb($rtmp2$$Register, $mask$$XMMRegister, vlen_enc);\n-    if (elem_bt == T_SHORT) {\n-      __ movl($mask_idx$$Register, 0x55555555);\n-      __ pextl($rtmp2$$Register, $rtmp2$$Register, $mask_idx$$Register);\n-    }\n-    __ xorl($mask_idx$$Register, $mask_idx$$Register);\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, $offset$$Register, $rtmp2$$Register, $xtmp1$$XMMRegister,\n+    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, $rtmp2$$Register, $xtmp1$$XMMRegister,\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":18,"deletions":135,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -4399,1 +4399,1 @@\n-    \"shrl    $dst, markWord::klass_shift_at_offset\"\n+    \"shrl    $dst, markWord::klass_shift\"\n@@ -4402,0 +4402,4 @@\n+    \/\/ The incoming address is pointing into obj-start + Type::klass_offset(). We need to extract\n+    \/\/ obj-start, so that we can load from the object's mark-word instead.\n+    Register d = $dst$$Register;\n+    Address  s = ($mem$$Address).plus_disp(-Type::klass_offset());\n@@ -4403,5 +4407,4 @@\n-      __ eshrl($dst$$Register, $mem$$Address, markWord::klass_shift_at_offset, false);\n-    }\n-    else {\n-      __ movl($dst$$Register, $mem$$Address);\n-      __ shrl($dst$$Register, markWord::klass_shift_at_offset);\n+      __ eshrl(d, s, markWord::klass_shift, false);\n+    } else {\n+      __ movl(d, s);\n+      __ shrl(d, markWord::klass_shift);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(StubId id, address call_ptr) {\n@@ -115,1 +115,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(StubId id, address destination) {\n@@ -119,1 +119,1 @@\n-RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+RuntimeStub* SharedRuntime::generate_throw_exception(StubId id, address runtime_entry) {\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+  StubGenerator(CodeBuffer* code, BlobId blob_id) : StubCodeGenerator(code, blob_id) {\n@@ -220,1 +220,1 @@\n-    case preuniverse_id:\n+    case BlobId::stubgen_preuniverse_id:\n@@ -223,1 +223,1 @@\n-    case initial_id:\n+    case BlobId::stubgen_initial_id:\n@@ -226,1 +226,1 @@\n-     case continuation_id:\n+     case BlobId::stubgen_continuation_id:\n@@ -229,1 +229,1 @@\n-    case compiler_id:\n+    case BlobId::stubgen_compiler_id:\n@@ -232,1 +232,1 @@\n-    case final_id:\n+    case BlobId::stubgen_final_id:\n@@ -236,1 +236,1 @@\n-      fatal(\"unexpected blob id: %d\", blob_id);\n+      fatal(\"unexpected blob id: %s\", StubInfo::name(blob_id));\n@@ -242,1 +242,1 @@\n-void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+void StubGenerator_generate(CodeBuffer* code, BlobId blob_id) {\n","filename":"src\/hotspot\/cpu\/zero\/stubGenerator_zero.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-static const char* sem_init_strerror(kern_return_t value) {\n+static const char* sem_strerror(kern_return_t value) {\n@@ -36,3 +36,7 @@\n-    case KERN_INVALID_ARGUMENT:  return \"Invalid argument\";\n-    case KERN_RESOURCE_SHORTAGE: return \"Resource shortage\";\n-    default:                     return \"Unknown\";\n+    case KERN_INVALID_ARGUMENT:    return \"Invalid argument\";\n+    case KERN_RESOURCE_SHORTAGE:   return \"Resource shortage\";\n+    case KERN_TERMINATED:          return \"Resource has been destroyed\";\n+    case KERN_ABORTED:             return \"Operation was aborted\";\n+    case KERN_INVALID_VALUE:       return \"Invalid time specified\";\n+    case KERN_OPERATION_TIMED_OUT: return \"Operation timed-out\";\n+    default:                       return \"Unknown\";\n@@ -45,1 +49,2 @@\n-  guarantee(ret == KERN_SUCCESS, \"Failed to create semaphore: %s\", sem_init_strerror(ret));\n+  guarantee(ret == KERN_SUCCESS, \"Failed to create semaphore: %s (0x%x)\",\n+            sem_strerror(ret), (uint)ret);\n@@ -56,1 +61,2 @@\n-    assert(ret == KERN_SUCCESS, \"Failed to signal semaphore\");\n+    assert(ret == KERN_SUCCESS, \"Failed to signal semaphore: %s (0x%x)\",\n+           sem_strerror(ret), (uint)ret);\n@@ -65,1 +71,2 @@\n-  assert(ret == KERN_SUCCESS, \"Failed to wait on semaphore\");\n+  assert(ret == KERN_SUCCESS, \"Failed to wait on semaphore: %s (0x%x)\",\n+         sem_strerror(ret), (uint)ret);\n@@ -103,0 +110,4 @@\n+  assert(kr == KERN_SUCCESS || kr == KERN_OPERATION_TIMED_OUT,\n+         \"Failed to timed-wait on semaphore: %s (0x%x)\",\n+         sem_strerror(kr), (uint)kr);\n+\n","filename":"src\/hotspot\/os\/bsd\/semaphore_bsd.cpp","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+#include <sys\/resource.h>\n@@ -1602,0 +1603,11 @@\n+double os::elapsed_process_cpu_time() {\n+  struct rusage usage;\n+  int retval = getrusage(RUSAGE_SELF, &usage);\n+  if (retval == 0) {\n+    return usage.ru_utime.tv_sec + usage.ru_stime.tv_sec +\n+         (usage.ru_utime.tv_usec + usage.ru_stime.tv_usec) \/ (1000.0 * 1000.0);\n+  } else {\n+    return -1;\n+  }\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1197,0 +1197,32 @@\n+double os::elapsed_process_cpu_time() {\n+  FILETIME create;\n+  FILETIME exit;\n+  FILETIME kernel;\n+  FILETIME user;\n+\n+  if (GetProcessTimes(GetCurrentProcess(), &create, &exit, &kernel, &user) == 0) {\n+    return -1;\n+  }\n+\n+  SYSTEMTIME user_total;\n+  if (FileTimeToSystemTime(&user, &user_total) == 0) {\n+    return -1;\n+  }\n+\n+  SYSTEMTIME kernel_total;\n+  if (FileTimeToSystemTime(&kernel, &kernel_total) == 0) {\n+    return -1;\n+  }\n+\n+  double user_seconds =\n+      double(user_total.wHour) * 3600.0 + double(user_total.wMinute) * 60.0 +\n+      double(user_total.wSecond) + double(user_total.wMilliseconds) \/ 1000.0;\n+\n+  double kernel_seconds = double(kernel_total.wHour) * 3600.0 +\n+                          double(kernel_total.wMinute) * 60.0 +\n+                          double(kernel_total.wSecond) +\n+                          double(kernel_total.wMilliseconds) \/ 1000.0;\n+\n+  return user_seconds + kernel_seconds;\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -267,1 +267,1 @@\n-  C1StubId         _stub_id;\n+  StubId           _stub_id;\n@@ -270,1 +270,1 @@\n-  NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, C1StubId stub_id);\n+  NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, StubId stub_id);\n@@ -518,1 +518,1 @@\n-  C1StubId         _stub;\n+  StubId           _stub;\n@@ -522,1 +522,1 @@\n-  SimpleExceptionStub(C1StubId stub, LIR_Opr obj, CodeEmitInfo* info):\n+  SimpleExceptionStub(StubId stub, LIR_Opr obj, CodeEmitInfo* info):\n@@ -549,1 +549,1 @@\n-  ArrayStoreExceptionStub(LIR_Opr obj, CodeEmitInfo* info): SimpleExceptionStub(C1StubId::throw_array_store_exception_id, obj, info) {}\n+  ArrayStoreExceptionStub(LIR_Opr obj, CodeEmitInfo* info): SimpleExceptionStub(StubId::c1_throw_array_store_exception_id, obj, info) {}\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-#if defined(X86) || defined(AARCH64) || defined(S390) || defined(RISCV) || defined(PPC64)\n+#if defined(X86) || defined(AARCH64) || defined(S390) || defined(RISCV64) || defined(PPC64)\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -353,1 +353,1 @@\n-#if defined(X86) || defined(AARCH64) || defined(S390) || defined(RISCV) || defined(PPC64)\n+#if defined(X86) || defined(AARCH64) || defined(S390) || defined(RISCV64) || defined(PPC64)\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -626,1 +626,0 @@\n-  if (!GenerateSynchronizationCode) return;\n@@ -636,1 +635,0 @@\n-  if (!GenerateSynchronizationCode) return;\n@@ -661,1 +659,1 @@\n-    C1StubId stub_id = klass->is_initialized() ? C1StubId::fast_new_instance_id : C1StubId::fast_new_instance_init_check_id;\n+    StubId stub_id = klass->is_initialized() ? StubId::c1_fast_new_instance_id : StubId::c1_fast_new_instance_init_check_id;\n@@ -672,1 +670,1 @@\n-    CodeStub* slow_path = new NewInstanceStub(klass_reg, dst, klass, info, C1StubId::new_instance_id);\n+    CodeStub* slow_path = new NewInstanceStub(klass_reg, dst, klass, info, StubId::c1_new_instance_id);\n@@ -1399,1 +1397,1 @@\n-               CAST_FROM_FN_PTR(address, Runtime1::entry_for(C1StubId::register_finalizer_id)),\n+               CAST_FROM_FN_PTR(address, Runtime1::entry_for(StubId::c1_register_finalizer_id)),\n@@ -2588,1 +2586,1 @@\n-    if (method()->is_synchronized() && GenerateSynchronizationCode) {\n+    if (method()->is_synchronized()) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+#include \"runtime\/stubInfo.hpp\"\n@@ -106,8 +107,1 @@\n-\n-CodeBlob* Runtime1::_blobs[(int)C1StubId::NUM_STUBIDS];\n-\n-#define C1_BLOB_NAME_DEFINE(name)  \"C1 Runtime \" # name \"_blob\",\n-const char *Runtime1::_blob_names[] = {\n-  C1_STUBS_DO(C1_BLOB_NAME_DEFINE)\n-};\n-#undef C1_STUB_NAME_DEFINE\n+CodeBlob* Runtime1::_blobs[StubInfo::C1_STUB_COUNT];\n@@ -191,1 +185,1 @@\n-class C1StubIdStubAssemblerCodeGenClosure: public StubAssemblerCodeGenClosure {\n+class C1StubAssemblerCodeGenClosure: public StubAssemblerCodeGenClosure {\n@@ -193,1 +187,1 @@\n-  C1StubId _id;\n+  StubId _id;\n@@ -195,1 +189,3 @@\n-  C1StubIdStubAssemblerCodeGenClosure(C1StubId id) : _id(id) {}\n+  C1StubAssemblerCodeGenClosure(StubId id) : _id(id) {\n+    assert(StubInfo::is_c1(_id), \"not a c1 stub id %s\", StubInfo::name(_id));\n+  }\n@@ -201,3 +197,3 @@\n-CodeBlob* Runtime1::generate_blob(BufferBlob* buffer_blob, C1StubId id, const char* name, bool expect_oop_map, StubAssemblerCodeGenClosure* cl) {\n-  if ((int)id >= 0) {\n-    CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C1Blob, (uint)id, name, 0, nullptr);\n+CodeBlob* Runtime1::generate_blob(BufferBlob* buffer_blob, StubId id, const char* name, bool expect_oop_map, StubAssemblerCodeGenClosure* cl) {\n+  if (id != StubId::NO_STUBID) {\n+    CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C1Blob, StubInfo::blob(id));\n@@ -243,1 +239,1 @@\n-    AOTCodeCache::store_code_blob(*blob, AOTCodeEntry::C1Blob, (uint)id, name, 0, nullptr);\n+    AOTCodeCache::store_code_blob(*blob, AOTCodeEntry::C1Blob, StubInfo::blob(id));\n@@ -248,2 +244,2 @@\n-bool Runtime1::generate_blob_for(BufferBlob* buffer_blob, C1StubId id) {\n-  assert(C1StubId::NO_STUBID < id && id < C1StubId::NUM_STUBIDS, \"illegal stub id\");\n+bool Runtime1::generate_blob_for(BufferBlob* buffer_blob, StubId id) {\n+  assert(StubInfo::is_c1(id), \"not a c1 stub %s\", StubInfo::name(id));\n@@ -255,6 +251,6 @@\n-  case C1StubId::dtrace_object_alloc_id:\n-  case C1StubId::slow_subtype_check_id:\n-  case C1StubId::fpu2long_stub_id:\n-  case C1StubId::unwind_exception_id:\n-  case C1StubId::counter_overflow_id:\n-  case C1StubId::is_instance_of_id:\n+  case StubId::c1_dtrace_object_alloc_id:\n+  case StubId::c1_slow_subtype_check_id:\n+  case StubId::c1_fpu2long_stub_id:\n+  case StubId::c1_unwind_exception_id:\n+  case StubId::c1_counter_overflow_id:\n+  case StubId::c1_is_instance_of_id:\n@@ -267,1 +263,1 @@\n-  C1StubIdStubAssemblerCodeGenClosure cl(id);\n+  C1StubAssemblerCodeGenClosure cl(id);\n@@ -270,1 +266,2 @@\n-  _blobs[(int)id] = blob;\n+  int idx = StubInfo::c1_offset(id);   \/\/ will assert on non-c1 id\n+  _blobs[idx] = blob;\n@@ -277,4 +274,5 @@\n-  \/\/ generate stubs\n-  int limit = (int)C1StubId::NUM_STUBIDS;\n-  for (int id = 0; id <= (int)C1StubId::forward_exception_id; id++) {\n-    if (!generate_blob_for(blob, (C1StubId) id)) {\n+  \/\/ iterate blobs in C1 group and generate a single stub per blob\n+  StubId id = StubInfo::stub_base(StubGroup::C1);\n+  StubId limit = StubInfo::next(StubInfo::stub_max(StubGroup::C1));\n+  for (; id != limit; id = StubInfo::next(id)) {\n+    if (!generate_blob_for(blob, id)) {\n@@ -283,5 +281,3 @@\n-  }\n-  AOTCodeCache::init_early_c1_table();\n-  for (int id = (int)C1StubId::forward_exception_id+1; id < limit; id++) {\n-    if (!generate_blob_for(blob, (C1StubId) id)) {\n-      return false;\n+    if (id == StubId::c1_forward_exception_id) {\n+      \/\/ publish early c1 stubs at this point so later stubs can refer to them\n+      AOTCodeCache::init_early_c1_table();\n@@ -294,4 +290,6 @@\n-    for (int id = 0; id < limit; id++) {\n-      _blobs[id]->print();\n-      if (_blobs[id]->oop_maps() != nullptr) {\n-        _blobs[id]->oop_maps()->print();\n+    id = StubInfo::stub_base(StubGroup::C1);\n+    for (; id != limit; id = StubInfo::next(id)) {\n+      CodeBlob* blob = blob_for(id);\n+      blob->print();\n+      if (blob->oop_maps() != nullptr) {\n+        blob->oop_maps()->print();\n@@ -306,3 +304,3 @@\n-CodeBlob* Runtime1::blob_for(C1StubId id) {\n-  assert(C1StubId::NO_STUBID < id && id < C1StubId::NUM_STUBIDS, \"illegal stub id\");\n-  return _blobs[(int)id];\n+CodeBlob* Runtime1::blob_for(StubId id) {\n+  int idx = StubInfo::c1_offset(id);   \/\/ will assert on non-c1 id\n+  return _blobs[idx];\n@@ -312,3 +310,2 @@\n-const char* Runtime1::name_for(C1StubId id) {\n-  assert(C1StubId::NO_STUBID < id && id < C1StubId::NUM_STUBIDS, \"illegal stub id\");\n-  return _blob_names[(int)id];\n+const char* Runtime1::name_for(StubId id) {\n+  return StubInfo::name(id);\n@@ -318,4 +315,5 @@\n-  int limit = (int)C1StubId::NUM_STUBIDS;\n-  for (int i = 0; i < limit; i++) {\n-    C1StubId id = (C1StubId)i;\n-    if (entry == entry_for(id)) return name_for(id);\n+  \/\/ iterate stubs starting from C1 group base\n+  StubId id = StubInfo::stub_base(StubGroup::C1);\n+  StubId limit = StubInfo::next(StubInfo::stub_max(StubGroup::C1));\n+  for (; id != limit; id = StubInfo::next(id)) {\n+    if (entry == entry_for(id)) return StubInfo::name(id);\n@@ -453,1 +451,1 @@\n-JRT_ENTRY(void, Runtime1::unimplemented_entry(JavaThread* current, C1StubId id))\n+JRT_ENTRY(void, Runtime1::unimplemented_entry(JavaThread* current, StubId id))\n@@ -553,2 +551,2 @@\n-  if (current->last_frame().cb() == Runtime1::blob_for(C1StubId::handle_exception_from_callee_id)) {\n-    \/\/ The C1StubId::handle_exception_from_callee_id handler is invoked after the\n+  if (current->last_frame().cb() == Runtime1::blob_for(StubId::c1_handle_exception_from_callee_id)) {\n+    \/\/ The StubId::c1_handle_exception_from_callee_id handler is invoked after the\n@@ -950,1 +948,1 @@\n-JRT_ENTRY(void, Runtime1::patch_code(JavaThread* current, C1StubId stub_id ))\n+JRT_ENTRY(void, Runtime1::patch_code(JavaThread* current, StubId stub_id ))\n@@ -987,1 +985,1 @@\n-    (stub_id == C1StubId::load_klass_patching_id || stub_id == C1StubId::load_mirror_patching_id);\n+    (stub_id == StubId::c1_load_klass_patching_id || stub_id == StubId::c1_load_mirror_patching_id);\n@@ -989,1 +987,1 @@\n-  if (stub_id == C1StubId::access_field_patching_id) {\n+  if (stub_id == StubId::c1_access_field_patching_id) {\n@@ -1072,1 +1070,1 @@\n-  } else if (stub_id == C1StubId::load_appendix_patching_id) {\n+  } else if (stub_id == StubId::c1_load_appendix_patching_id) {\n@@ -1156,1 +1154,1 @@\n-                        p2i(instr_pc), (stub_id == C1StubId::access_field_patching_id) ? \"field\" : \"klass\");\n+                        p2i(instr_pc), (stub_id == StubId::c1_access_field_patching_id) ? \"field\" : \"klass\");\n@@ -1172,1 +1170,1 @@\n-        if (stub_id == C1StubId::access_field_patching_id) {\n+        if (stub_id == StubId::c1_access_field_patching_id) {\n@@ -1198,1 +1196,1 @@\n-            if (stub_id == C1StubId::load_klass_patching_id) {\n+            if (stub_id == StubId::c1_load_klass_patching_id) {\n@@ -1210,1 +1208,1 @@\n-        } else if (stub_id == C1StubId::load_appendix_patching_id) {\n+        } else if (stub_id == StubId::c1_load_appendix_patching_id) {\n@@ -1229,1 +1227,1 @@\n-              stub_id == C1StubId::load_appendix_patching_id) &&\n+              stub_id == StubId::c1_load_appendix_patching_id) &&\n@@ -1237,2 +1235,2 @@\n-                assert(stub_id == C1StubId::load_mirror_patching_id ||\n-                       stub_id == C1StubId::load_appendix_patching_id, \"wrong stub id\");\n+                assert(stub_id == StubId::c1_load_mirror_patching_id ||\n+                       stub_id == StubId::c1_load_appendix_patching_id, \"wrong stub id\");\n@@ -1243,1 +1241,1 @@\n-                assert(stub_id == C1StubId::load_klass_patching_id, \"wrong stub id\");\n+                assert(stub_id == StubId::c1_load_klass_patching_id, \"wrong stub id\");\n@@ -1266,1 +1264,1 @@\n-              stub_id == C1StubId::load_appendix_patching_id) {\n+              stub_id == StubId::c1_load_appendix_patching_id) {\n@@ -1268,1 +1266,1 @@\n-              (stub_id == C1StubId::load_klass_patching_id) ?\n+              (stub_id == StubId::c1_load_klass_patching_id) ?\n@@ -1302,3 +1300,3 @@\n-static bool is_patching_needed(JavaThread* current, C1StubId stub_id) {\n-  if (stub_id == C1StubId::load_klass_patching_id ||\n-      stub_id == C1StubId::load_mirror_patching_id) {\n+static bool is_patching_needed(JavaThread* current, StubId stub_id) {\n+  if (stub_id == StubId::c1_load_klass_patching_id ||\n+      stub_id == StubId::c1_load_mirror_patching_id) {\n@@ -1333,1 +1331,1 @@\n-void Runtime1::patch_code(JavaThread* current, C1StubId stub_id) {\n+void Runtime1::patch_code(JavaThread* current, StubId stub_id) {\n@@ -1388,1 +1386,1 @@\n-    patch_code(current, C1StubId::load_klass_patching_id);\n+    patch_code(current, StubId::c1_load_klass_patching_id);\n@@ -1405,1 +1403,1 @@\n-    patch_code(current, C1StubId::load_mirror_patching_id);\n+    patch_code(current, StubId::c1_load_mirror_patching_id);\n@@ -1422,1 +1420,1 @@\n-    patch_code(current, C1StubId::load_appendix_patching_id);\n+    patch_code(current, StubId::c1_load_appendix_patching_id);\n@@ -1449,1 +1447,1 @@\n-    patch_code(current, C1StubId::access_field_patching_id);\n+    patch_code(current, StubId::c1_access_field_patching_id);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":71,"deletions":73,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/stubInfo.hpp\"\n@@ -45,10 +46,0 @@\n-\/\/ define C1StubId enum tags: unwind_exception_id etc\n-\n-#define C1_STUB_ID_ENUM_DECLARE(name) STUB_ID_NAME(name),\n-enum class C1StubId :int {\n-  NO_STUBID = -1,\n-  C1_STUBS_DO(C1_STUB_ID_ENUM_DECLARE)\n-  NUM_STUBIDS\n-};\n-#undef C1_STUB_ID_ENUM_DECLARE\n-\n@@ -83,2 +74,1 @@\n-  static CodeBlob* _blobs[(int)C1StubId::NUM_STUBIDS];\n-  static const char* _blob_names[];\n+  static CodeBlob* _blobs[(int)StubInfo::C1_STUB_COUNT];\n@@ -88,3 +78,3 @@\n-  static CodeBlob*  generate_blob(BufferBlob* buffer_blob, C1StubId id, const char* name, bool expect_oop_map, StubAssemblerCodeGenClosure *cl);\n-  static bool       generate_blob_for(BufferBlob* blob, C1StubId id);\n-  static OopMapSet* generate_code_for(C1StubId id, StubAssembler* sasm);\n+  static CodeBlob*  generate_blob(BufferBlob* buffer_blob, StubId id, const char* name, bool expect_oop_map, StubAssemblerCodeGenClosure *cl);\n+  static bool       generate_blob_for(BufferBlob* blob, StubId id);\n+  static OopMapSet* generate_code_for(StubId id, StubAssembler* sasm);\n@@ -93,1 +83,1 @@\n-  static OopMapSet* generate_handle_exception(C1StubId id, StubAssembler* sasm);\n+  static OopMapSet* generate_handle_exception(StubId id, StubAssembler* sasm);\n@@ -108,1 +98,1 @@\n-  static void unimplemented_entry(JavaThread* current, C1StubId id);\n+  static void unimplemented_entry(JavaThread* current, StubId id);\n@@ -130,1 +120,1 @@\n-  static void patch_code(JavaThread* current, C1StubId stub_id);\n+  static void patch_code(JavaThread* current, StubId stub_id);\n@@ -141,3 +131,3 @@\n-  static CodeBlob* blob_for (C1StubId id);\n-  static address   entry_for(C1StubId id)          { return blob_for(id)->code_begin(); }\n-  static const char* name_for (C1StubId id);\n+  static CodeBlob* blob_for (StubId id);\n+  static address   entry_for(StubId id)          { return blob_for(id)->code_begin(); }\n+  static const char* name_for (StubId id);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":11,"deletions":21,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"classfile\/classLoaderExt.hpp\"\n@@ -1334,1 +1333,3 @@\n-        byte_size = source_oop->size() * BytesPerWord;\n+        size_t old_size = source_oop->size();\n+        size_t new_size = source_oop->copy_size_cds(old_size, source_oop->mark());\n+        byte_size = new_size * BytesPerWord;\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -426,1 +426,3 @@\n-  size_t byte_size = src_obj->size() * HeapWordSize;\n+  size_t old_size = src_obj->size();\n+  size_t new_size = src_obj->copy_size_cds(old_size, src_obj->mark());\n+  size_t byte_size = new_size * HeapWordSize;\n@@ -447,1 +449,1 @@\n-  memcpy(to, from, byte_size);\n+  memcpy(to, from, old_size * HeapWordSize);\n@@ -587,0 +589,1 @@\n+    assert(fake_oop->mark().narrow_klass() != 0, \"must not be null\");\n@@ -599,1 +602,7 @@\n-      fake_oop->set_mark(markWord::prototype().set_narrow_klass(nk).copy_set_hash(src_hash));\n+      markWord m = markWord::prototype().set_narrow_klass(nk);\n+      m = m.copy_hashctrl_from(src_obj->mark());\n+      fake_oop->set_mark(m);\n+      if (m.is_hashed_not_expanded()) {\n+        fake_oop->initialize_hash_if_necessary(src_obj, src_klass, m);\n+      }\n+      assert(!fake_oop->mark().is_not_hashed_expanded() && !fake_oop->mark().is_hashed_not_expanded(), \"must not be not-hashed-moved and not be hashed-not-moved\");\n@@ -602,0 +611,2 @@\n+      DEBUG_ONLY(intptr_t archived_hash = fake_oop->identity_hash());\n+      assert(src_hash == archived_hash, \"Different hash codes: original \" INTPTR_FORMAT \", archived \" INTPTR_FORMAT, src_hash, archived_hash);\n@@ -604,3 +615,0 @@\n-\n-    DEBUG_ONLY(intptr_t archived_hash = fake_oop->identity_hash());\n-    assert(src_hash == archived_hash, \"Different hash codes: original \" INTPTR_FORMAT \", archived \" INTPTR_FORMAT, src_hash, archived_hash);\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"classfile\/classLoaderExt.hpp\"\n","filename":"src\/hotspot\/share\/cds\/cdsProtectionDomain.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"classfile\/classLoaderExt.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#include \"classfile\/classLoaderExt.hpp\"\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"classfile\/classLoaderExt.hpp\"\n@@ -420,1 +419,1 @@\n-      oop m = java_lang_Class::create_basic_type_mirror(type2name(bt), bt, CHECK);\n+      oop m = java_lang_Class::create_basic_type_mirror(type2name(bt), bt, true, CHECK);\n@@ -595,0 +594,1 @@\n+  assert(!UseCompactObjectHeaders || scratch_m->mark().is_not_hashed_expanded(), \"scratch mirror must have not-hashed-expanded state\");\n@@ -596,0 +596,1 @@\n+    intptr_t orig_mark = orig_mirror->mark().value();\n@@ -598,2 +599,17 @@\n-      narrowKlass nk = CompressedKlassPointers::encode(orig_mirror->klass());\n-      scratch_m->set_mark(markWord::prototype().set_narrow_klass(nk).copy_set_hash(src_hash));\n+      \/\/ We leave the cases not_hashed\/not_hashed_expanded as they are.\n+      assert(orig_mirror->mark().is_hashed_not_expanded() || orig_mirror->mark().is_hashed_expanded(), \"must be hashed\");\n+      Klass* orig_klass = orig_mirror->klass();\n+      narrowKlass nk = CompressedKlassPointers::encode(orig_klass);\n+      markWord mark = markWord::prototype().set_narrow_klass(nk);\n+      mark = mark.copy_hashctrl_from(orig_mirror->mark());\n+      if (mark.is_hashed_not_expanded()) {\n+        scratch_m->initialize_hash_if_necessary(orig_mirror, orig_klass, mark);\n+      } else {\n+        assert(mark.is_hashed_expanded(), \"must be hashed & moved\");\n+        int offset = orig_klass->hash_offset_in_bytes(orig_mirror, mark);\n+        assert(offset >= 8, \"hash offset must not be in header\");\n+        scratch_m->int_field_put(offset, (jint) src_hash);\n+        scratch_m->set_mark(mark);\n+      }\n+      assert(scratch_m->mark().is_hashed_expanded(), \"must be hashed & moved\");\n+      assert(scratch_m->mark().is_not_hashed_expanded() || scratch_m->mark().is_hashed_expanded(), \"must be not hashed and expanded\");\n@@ -602,0 +618,2 @@\n+      DEBUG_ONLY(intptr_t archived_hash = scratch_m->identity_hash());\n+      assert(src_hash == archived_hash, \"Different hash codes: original \" INTPTR_FORMAT \", archived \" INTPTR_FORMAT, src_hash, archived_hash);\n@@ -604,3 +622,0 @@\n-\n-    DEBUG_ONLY(intptr_t archived_hash = scratch_m->identity_hash());\n-    assert(src_hash == archived_hash, \"Different hash codes: original \" INTPTR_FORMAT \", archived \" INTPTR_FORMAT, src_hash, archived_hash);\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-#include \"classfile\/classLoaderExt.hpp\"\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -298,0 +298,4 @@\n+  int hash_offset_in_bytes() const {\n+    return get_instanceKlass()->hash_offset_in_bytes(nullptr, markWord(0));\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4899,0 +4899,4 @@\n+int ClassFileParser::hash_offset() const {\n+  return _field_info->_hash_offset;\n+}\n+\n@@ -5179,1 +5183,1 @@\n-  Handle module_handle(THREAD, module_entry->module());\n+  Handle module_handle(THREAD, module_entry->module_oop());\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+  int _hash_offset;\n@@ -508,0 +509,1 @@\n+  int hash_offset() const;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/dynamicArchive.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"classfile\/classLoaderExt.hpp\"\n@@ -1286,1 +1286,41 @@\n-  ClassLoaderExt::record_result_for_builtin_loader(checked_cast<s2>(classpath_index), ik, redefined);\n+  record_result_for_builtin_loader(checked_cast<s2>(classpath_index), ik, redefined);\n+}\n+\n+void ClassLoader::record_result_for_builtin_loader(s2 classpath_index, InstanceKlass* result, bool redefined) {\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n+\n+  oop loader = result->class_loader();\n+  if (SystemDictionary::is_system_class_loader(loader)) {\n+    AOTClassLocationConfig::dumptime_set_has_app_classes();\n+  } else if (SystemDictionary::is_platform_class_loader(loader)) {\n+    AOTClassLocationConfig::dumptime_set_has_platform_classes();\n+  } else {\n+    precond(loader == nullptr);\n+  }\n+\n+  if (CDSConfig::is_dumping_preimage_static_archive() || CDSConfig::is_dumping_dynamic_archive()) {\n+    if (!AOTClassLocationConfig::dumptime()->is_valid_classpath_index(classpath_index, result)) {\n+      classpath_index = -1;\n+    }\n+  }\n+\n+  AOTClassLocationConfig::dumptime_update_max_used_index(classpath_index);\n+  result->set_shared_classpath_index(classpath_index);\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (CDSConfig::is_dumping_heap() && AllowArchivingWithJavaAgent && result->defined_by_boot_loader() &&\n+      classpath_index < 0 && redefined) {\n+    \/\/ When dumping the heap (which happens only during static dump), classes for the built-in\n+    \/\/ loaders are always loaded from known locations (jimage, classpath or modulepath),\n+    \/\/ so classpath_index should always be >= 0.\n+    \/\/ The only exception is when a java agent is used during dump time (for testing\n+    \/\/ purposes only). If a class is transformed by the agent, the AOTClassLocation of\n+    \/\/ this class may point to an unknown location. This may break heap object archiving,\n+    \/\/ which requires all the boot classes to be from known locations. This is an\n+    \/\/ uncommon scenario (even in test cases). Let's simply disable heap object archiving.\n+    ResourceMark rm;\n+    log_warning(aot)(\"heap objects cannot be written because class %s maybe modified by ClassFileLoadHook.\",\n+                     result->external_name());\n+    CDSConfig::disable_heap_dumping();\n+  }\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n@@ -1311,0 +1351,11 @@\n+\n+void ClassLoader::append_boot_classpath(ClassPathEntry* new_entry) {\n+  if (CDSConfig::is_using_archive()) {\n+    warning(\"Sharing is only supported for boot loader classes because bootstrap classpath has been appended\");\n+    FileMapInfo::current_info()->set_has_platform_or_app_classes(false);\n+    if (DynamicArchive::is_mapped()) {\n+      FileMapInfo::dynamic_info()->set_has_platform_or_app_classes(false);\n+    }\n+  }\n+  add_to_boot_append_entries(new_entry);\n+}\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":53,"deletions":2,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -348,0 +348,1 @@\n+  static void record_result_for_builtin_loader(s2 classpath_index, InstanceKlass* result, bool redefined);\n@@ -349,0 +350,1 @@\n+  static void append_boot_classpath(ClassPathEntry* new_entry);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-  return _archived_javabase_moduleEntry->module();\n+  return _archived_javabase_moduleEntry->module_oop();\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,108 +1,0 @@\n-\/*\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"cds\/aotClassLocation.hpp\"\n-#include \"cds\/cds_globals.hpp\"\n-#include \"cds\/cdsConfig.hpp\"\n-#include \"cds\/dynamicArchive.hpp\"\n-#include \"cds\/filemap.hpp\"\n-#include \"cds\/heapShared.hpp\"\n-#include \"classfile\/classFileParser.hpp\"\n-#include \"classfile\/classLoader.inline.hpp\"\n-#include \"classfile\/classLoaderExt.hpp\"\n-#include \"classfile\/classLoaderData.inline.hpp\"\n-#include \"classfile\/classLoadInfo.hpp\"\n-#include \"classfile\/klassFactory.hpp\"\n-#include \"classfile\/modules.hpp\"\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"classfile\/vmSymbols.hpp\"\n-#include \"gc\/shared\/collectedHeap.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/instanceKlass.hpp\"\n-#include \"oops\/klass.inline.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"oops\/symbol.hpp\"\n-#include \"runtime\/arguments.hpp\"\n-#include \"runtime\/handles.inline.hpp\"\n-#include \"runtime\/java.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"utilities\/checkedCast.hpp\"\n-#include \"utilities\/stringUtils.hpp\"\n-\n-void ClassLoaderExt::append_boot_classpath(ClassPathEntry* new_entry) {\n-  if (CDSConfig::is_using_archive()) {\n-    warning(\"Sharing is only supported for boot loader classes because bootstrap classpath has been appended\");\n-    FileMapInfo::current_info()->set_has_platform_or_app_classes(false);\n-    if (DynamicArchive::is_mapped()) {\n-      FileMapInfo::dynamic_info()->set_has_platform_or_app_classes(false);\n-    }\n-  }\n-  ClassLoader::add_to_boot_append_entries(new_entry);\n-}\n-\n-int ClassLoaderExt::compare_module_names(const char** p1, const char** p2) {\n-  return strcmp(*p1, *p2);\n-}\n-\n-void ClassLoaderExt::record_result_for_builtin_loader(s2 classpath_index, InstanceKlass* result, bool redefined) {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-\n-  oop loader = result->class_loader();\n-  if (SystemDictionary::is_system_class_loader(loader)) {\n-    AOTClassLocationConfig::dumptime_set_has_app_classes();\n-  } else if (SystemDictionary::is_platform_class_loader(loader)) {\n-    AOTClassLocationConfig::dumptime_set_has_platform_classes();\n-  } else {\n-    precond(loader == nullptr);\n-  }\n-\n-  if (CDSConfig::is_dumping_preimage_static_archive() || CDSConfig::is_dumping_dynamic_archive()) {\n-    if (!AOTClassLocationConfig::dumptime()->is_valid_classpath_index(classpath_index, result)) {\n-      classpath_index = -1;\n-    }\n-  }\n-\n-  AOTClassLocationConfig::dumptime_update_max_used_index(classpath_index);\n-  result->set_shared_classpath_index(classpath_index);\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-  if (CDSConfig::is_dumping_heap() && AllowArchivingWithJavaAgent && result->defined_by_boot_loader() &&\n-      classpath_index < 0 && redefined) {\n-    \/\/ When dumping the heap (which happens only during static dump), classes for the built-in\n-    \/\/ loaders are always loaded from known locations (jimage, classpath or modulepath),\n-    \/\/ so classpath_index should always be >= 0.\n-    \/\/ The only exception is when a java agent is used during dump time (for testing\n-    \/\/ purposes only). If a class is transformed by the agent, the AOTClassLocation of\n-    \/\/ this class may point to an unknown location. This may break heap object archiving,\n-    \/\/ which requires all the boot classes to be from known locations. This is an\n-    \/\/ uncommon scenario (even in test cases). Let's simply disable heap object archiving.\n-    ResourceMark rm;\n-    log_warning(aot)(\"heap objects cannot be written because class %s maybe modified by ClassFileLoadHook.\",\n-                     result->external_name());\n-    CDSConfig::disable_heap_dumping();\n-  }\n-#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n-}\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,47 +1,0 @@\n-\/*\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_CLASSFILE_CLASSLOADEREXT_HPP\n-#define SHARE_CLASSFILE_CLASSLOADEREXT_HPP\n-\n-#include \"classfile\/classLoader.hpp\"\n-#include \"classfile\/moduleEntry.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-class ClassListParser;\n-\n-class ClassLoaderExt: public ClassLoader { \/\/ AllStatic\n-public:\n-#if INCLUDE_CDS\n-public:\n-  \/\/ Called by JVMTI code to add boot classpath\n-\n-  static void append_boot_classpath(ClassPathEntry* new_entry);\n-\n-  static int compare_module_names(const char** p1, const char** p2);\n-  static void record_result_for_builtin_loader(s2 classpath_index, InstanceKlass* result, bool redefined);\n-#endif \/\/ INCLUDE_CDS\n-};\n-\n-#endif \/\/ SHARE_CLASSFILE_CLASSLOADEREXT_HPP\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.hpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -213,0 +213,17 @@\n+\/\/ Finds a slot for the identity hash-code.\n+\/\/ Same basic algorithm as above add() method, but simplified\n+\/\/ and does not actually insert the field.\n+int FieldLayout::find_hash_offset() {\n+  LayoutRawBlock* start = this->_start;\n+  LayoutRawBlock* last = last_block();\n+  LayoutRawBlock* cursor = start;\n+  while (cursor != last) {\n+    assert(cursor != nullptr, \"Sanity check\");\n+    if (cursor->kind() == LayoutRawBlock::EMPTY && cursor->fit(4, 1)) {\n+      break;\n+    }\n+    cursor = cursor->next_block();\n+  }\n+  return cursor->offset();\n+}\n+\n@@ -700,0 +717,3 @@\n+  if (UseCompactObjectHeaders) {\n+    _info->_hash_offset   = _layout->find_hash_offset();\n+  }\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1039,1 +1039,1 @@\n-      assert(javabase_entry != nullptr && javabase_entry->module() != nullptr,\n+      assert(javabase_entry != nullptr && javabase_entry->module_oop() != nullptr,\n@@ -1041,1 +1041,1 @@\n-      Handle javabase_handle(current, javabase_entry->module());\n+      Handle javabase_handle(current, javabase_entry->module_oop());\n@@ -1047,1 +1047,1 @@\n-            (module() == ModuleEntryTable::javabase_moduleEntry()->module())),\n+            (module() == ModuleEntryTable::javabase_moduleEntry()->module_oop())),\n@@ -1067,1 +1067,1 @@\n-  oop mirror_oop = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(k, CHECK);\n+  oop mirror_oop = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(k, is_scratch, CHECK);\n@@ -1368,1 +1368,1 @@\n-oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {\n+oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, bool is_scratch, TRAPS) {\n@@ -1370,1 +1370,1 @@\n-  oop java_class = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(nullptr, CHECK_NULL);\n+  oop java_class = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(nullptr, is_scratch, CHECK_NULL);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-oop ModuleEntry::module() const { return _module.resolve(); }\n+oop ModuleEntry::module_oop() const { return _module_handle.resolve(); }\n@@ -287,1 +287,1 @@\n-    _module = loader_data->add_handle(module_handle);\n+    _module_handle = loader_data->add_handle(module_handle);\n@@ -404,1 +404,1 @@\n-    archived_entry->_archived_module_index = HeapShared::append_root(module());\n+    archived_entry->_archived_module_index = HeapShared::append_root(module_oop());\n@@ -425,1 +425,1 @@\n-  archived_entry->_module = null_handle;\n+  archived_entry->_module_handle = null_handle;\n@@ -529,1 +529,1 @@\n-  set_module(loader_data->add_handle(module_handle));\n+  set_module_handle(loader_data->add_handle(module_handle));\n@@ -665,1 +665,1 @@\n-  jb_module->set_module(boot_loader_data->add_handle(module_handle));\n+  jb_module->set_module_handle(boot_loader_data->add_handle(module_handle));\n@@ -703,1 +703,1 @@\n-      Handle unnamed_module_handle(current, unnamed_module->module());\n+      Handle unnamed_module_handle(current, unnamed_module->module_oop());\n@@ -748,1 +748,1 @@\n-               p2i(module()),\n+               p2i(module_oop()),\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-\/\/   - pointer to the java.lang.Module for this module.\n+\/\/   - pointer to the java.lang.Module: the representation of this module as a Java object\n@@ -66,1 +66,1 @@\n-  OopHandle _module;                   \/\/ java.lang.Module\n+  OopHandle _module_handle;            \/\/ java.lang.Module\n@@ -99,3 +99,3 @@\n-  oop              module() const;\n-  OopHandle        module_handle() const               { return _module; }\n-  void             set_module(OopHandle j)             { _module = j; }\n+  oop              module_oop() const;\n+  OopHandle        module_handle() const               { return _module_handle; }\n+  void             set_module_handle(OopHandle j)      { _module_handle = j; }\n@@ -265,1 +265,1 @@\n-                                           (_javabase_module->module() != nullptr)); }\n+                                           (_javabase_module->module_oop() != nullptr)); }\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"classfile\/classLoaderExt.hpp\"\n@@ -628,0 +627,5 @@\n+\n+static int compare_module_names(const char** p1, const char** p2) {\n+  return strcmp(*p1, *p2);\n+}\n+\n@@ -668,1 +672,1 @@\n-  list.sort(ClassLoaderExt::compare_module_names);\n+  list.sort(compare_module_names);\n@@ -776,1 +780,1 @@\n-  unnamed_module->set_module(boot_loader_data->add_handle(module));\n+  unnamed_module->set_module_handle(boot_loader_data->add_handle(module));\n@@ -957,2 +961,2 @@\n-  if (module_entry != nullptr && module_entry->module() != nullptr && module_entry->is_named()) {\n-    return module_entry->module();\n+  if (module_entry != nullptr && module_entry->module_oop() != nullptr && module_entry->is_named()) {\n+    return module_entry->module_oop();\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"compiler\/compileBroker.hpp\"\n@@ -118,0 +119,1 @@\n+DEBUG_ONLY(static bool _disable_interning_during_cds_dump = false);\n@@ -349,0 +351,4 @@\n+size_t StringTable::items_count_acquire() {\n+  return Atomic::load_acquire(&_items_count);\n+}\n+\n@@ -507,0 +513,3 @@\n+  assert(!Atomic::load_acquire(&_disable_interning_during_cds_dump),\n+         \"All threads that may intern strings should have been stopped before CDS starts copying the interned string table\");\n+\n@@ -796,1 +805,1 @@\n-class VerifyCompStrings : StackObj {\n+class StringTable::VerifyCompStrings : StackObj {\n@@ -808,1 +817,1 @@\n-  VerifyCompStrings() : _table(unsigned(_items_count \/ 8) + 1, 0 \/* do not resize *\/), _errors(0) {}\n+  VerifyCompStrings() : _table(unsigned(items_count_acquire() \/ 8) + 1, 0 \/* do not resize *\/), _errors(0) {}\n@@ -942,3 +951,2 @@\n-\/\/ This is called BEFORE we enter the CDS safepoint. We can allocate heap objects.\n-\/\/ This should be called when we know no more strings will be added (which will be easy\n-\/\/ to guarantee because CDS runs with a single Java thread. See JDK-8253495.)\n+\/\/ This is called BEFORE we enter the CDS safepoint. We can still allocate Java object arrays to\n+\/\/ be used by the shared strings table.\n@@ -949,3 +957,15 @@\n-  assert(CDSConfig::allow_only_single_java_thread(), \"No more interned strings can be added\");\n-  if (_items_count > (size_t)max_jint) {\n-    fatal(\"Too many strings to be archived: %zu\", _items_count);\n+  CompileBroker::wait_for_no_active_tasks();\n+\n+  precond(CDSConfig::allow_only_single_java_thread());\n+\n+  \/\/ At this point, no more strings will be added:\n+  \/\/ - There's only a single Java thread (this thread). It no longer executes Java bytecodes\n+  \/\/   so JIT compilation will eventually stop.\n+  \/\/ - CompileBroker has no more active tasks, so all JIT requests have been processed.\n+\n+  \/\/ This flag will be cleared after intern table dumping has completed, so we can run the\n+  \/\/ compiler again (for future AOT method compilation, etc).\n+  DEBUG_ONLY(Atomic::release_store(&_disable_interning_during_cds_dump, true));\n+\n+  if (items_count_acquire() > (size_t)max_jint) {\n+    fatal(\"Too many strings to be archived: %zu\", items_count_acquire());\n@@ -955,1 +975,1 @@\n-  int total = (int)_items_count;\n+  int total = (int)items_count_acquire();\n@@ -975,1 +995,1 @@\n-      log_error(aot)(\"Too many strings to be archived: %zu\", _items_count);\n+      log_error(aot)(\"Too many strings to be archived: %zu\", items_count_acquire());\n@@ -1073,1 +1093,1 @@\n-  CompactHashtableWriter writer((int)_items_count, ArchiveBuilder::string_stats());\n+  CompactHashtableWriter writer((int)items_count_acquire(), ArchiveBuilder::string_stats());\n@@ -1087,0 +1107,2 @@\n+\n+  DEBUG_ONLY(Atomic::release_store(&_disable_interning_during_cds_dump, false));\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":33,"deletions":11,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-\n+  class VerifyCompStrings;\n@@ -77,0 +77,1 @@\n+  static size_t items_count_acquire();\n","filename":"src\/hotspot\/share\/classfile\/stringTable.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"classfile\/classLoaderExt.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"classfile\/classLoaderExt.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1272,0 +1272,1 @@\n+                                     \"I\"                                                                                                       \\\n@@ -1275,0 +1276,3 @@\n+                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                           \\\n+                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                           \\\n+                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                           \\\n@@ -1289,0 +1293,1 @@\n+                                      \"I\"                                                                                                      \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"runtime\/stubInfo.hpp\"\n@@ -150,0 +151,1 @@\n+    assert(StubInfo::is_shared(static_cast<BlobId>(id)), \"not a shared blob id %d\", id);\n@@ -152,1 +154,2 @@\n-    return (int)SharedStubId::NUM_STUBIDS + id;\n+    assert(StubInfo::is_c1(static_cast<BlobId>(id)), \"not a c1 blob id %d\", id);\n+    return id;\n@@ -155,1 +158,2 @@\n-    return (int)SharedStubId::NUM_STUBIDS + COMPILER1_PRESENT((int)C1StubId::NUM_STUBIDS) + id;\n+    assert(StubInfo::is_c2(static_cast<BlobId>(id)), \"not a c2 blob id %d\", id);\n+    return id;\n@@ -902,0 +906,6 @@\n+bool AOTCodeCache::store_code_blob(CodeBlob& blob, AOTCodeEntry::Kind entry_kind, BlobId id, int entry_offset_count, int* entry_offsets) {\n+  assert(AOTCodeEntry::is_blob(entry_kind),\n+         \"wrong entry kind for blob id %s\", StubInfo::name(id));\n+  return store_code_blob(blob, entry_kind, (uint)id, StubInfo::name(id), entry_offset_count, entry_offsets);\n+}\n+\n@@ -929,0 +939,6 @@\n+CodeBlob* AOTCodeCache::load_code_blob(AOTCodeEntry::Kind entry_kind, BlobId id, int entry_offset_count, int* entry_offsets) {\n+  assert(AOTCodeEntry::is_blob(entry_kind),\n+         \"wrong entry kind for blob id %s\", StubInfo::name(id));\n+  return load_code_blob(entry_kind, (uint)id, StubInfo::name(id), entry_offset_count, entry_offsets);\n+}\n+\n@@ -1301,0 +1317,1 @@\n+    SET_ADDRESS(_extrs, SharedRuntime::throw_StackOverflowError);\n@@ -1462,2 +1479,4 @@\n-  for (int i = 0; i <= (int)C1StubId::forward_exception_id; i++) {\n-    C1StubId id = (C1StubId)i;\n+  StubId id = StubInfo::stub_base(StubGroup::C1);\n+  \/\/ include forward_exception in range we publish\n+  StubId limit = StubInfo::next(StubId::c1_forward_exception_id);\n+  for (; id != limit; id = StubInfo::next(id)) {\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"runtime\/stubInfo.hpp\"\n+\n@@ -330,0 +332,1 @@\n+  \/\/ save and restore API for non-enumerable code blobs\n@@ -341,0 +344,12 @@\n+  \/\/ save and restore API for enumerable code blobs\n+  static bool store_code_blob(CodeBlob& blob,\n+                              AOTCodeEntry::Kind entry_kind,\n+                              BlobId id,\n+                              int entry_offset_count = 0,\n+                              int* entry_offsets = nullptr) NOT_CDS_RETURN_(false);\n+\n+  static CodeBlob* load_code_blob(AOTCodeEntry::Kind kind,\n+                                  BlobId id,\n+                                  int entry_offset_count = 0,\n+                                  int* entry_offsets = nullptr) NOT_CDS_RETURN_(nullptr);\n+\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-    assert(_mutable_data = blob_end(), \"sanity\");\n+    assert(_mutable_data == blob_end(), \"sanity\");\n@@ -180,0 +180,1 @@\n+  _mutable_data_size(0),\n@@ -188,1 +189,1 @@\n-  assert(_mutable_data = blob_end(), \"sanity\");\n+  assert(_mutable_data == blob_end(), \"sanity\");\n@@ -198,0 +199,2 @@\n+  } else {\n+    _mutable_data = blob_end(); \/\/ default value\n@@ -200,0 +203,1 @@\n+    assert(_mutable_data_size > 0, \"relocation is part of mutable data section\");\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -250,1 +250,1 @@\n-  int relocation_size() const    { return pointer_delta_as_int((address) relocation_end(), (address) relocation_begin()); }\n+  int relocation_size() const    { return _relocation_size; }\n@@ -460,0 +460,1 @@\n+  static const int ENTRY_COUNT = 1;\n@@ -562,0 +563,1 @@\n+  static const int ENTRY_COUNT = 4 JVMTI_ONLY(+ 2);\n@@ -692,0 +694,1 @@\n+  static const int ENTRY_COUNT = 1;\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1939,4 +1939,1 @@\n-  \/\/ Deoptimization count is used by the CompileBroker to reason about compilations\n-  \/\/ it requests so do not pollute the count for deoptimizations in non-default (i.e.\n-  \/\/ non-CompilerBroker) compilations.\n-  if (is_jvmci_hosted()) {\n+  if (jvmci_skip_profile_deopt()) {\n@@ -4069,2 +4066,2 @@\n-bool nmethod::is_jvmci_hosted() const {\n-  return jvmci_nmethod_data() != nullptr && !jvmci_nmethod_data()->is_default();\n+bool nmethod::jvmci_skip_profile_deopt() const {\n+  return jvmci_nmethod_data() != nullptr && !jvmci_nmethod_data()->profile_deopt();\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -917,3 +917,3 @@\n-  \/\/ Returns true if a JVMCI compiled method is non-default,\n-  \/\/ i.e., not triggered by CompilerBroker\n-  bool is_jvmci_hosted() const;\n+  \/\/ Returns true if the runtime should NOT collect deoptimization profile for a JVMCI\n+  \/\/ compiled method\n+  bool jvmci_skip_profile_deopt() const;\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-          \/\/ The waiting thread timed out and thus did not free the task.\n+          \/\/ The waiting thread timed out and thus did not delete the task.\n@@ -252,2 +252,2 @@\n-      \/\/ The task can only be freed once the task lock is released.\n-      CompileTask::free(task);\n+      \/\/ The task can only be deleted once the task lock is released.\n+      delete task;\n@@ -258,3 +258,3 @@\n-    \/\/ By convention, the compiling thread is responsible for\n-    \/\/ recycling a non-blocking CompileTask.\n-    CompileTask::free(task);\n+    \/\/ By convention, the compiling thread is responsible for deleting\n+    \/\/ a non-blocking CompileTask.\n+    delete task;\n@@ -363,3 +363,3 @@\n- * Empties compilation queue by putting all compilation tasks onto\n- * a freelist. Furthermore, the method wakes up all threads that are\n- * waiting on a compilation task to finish. This can happen if background\n+ * Empties compilation queue by deleting all compilation tasks.\n+ * Furthermore, the method wakes up all threads that are waiting\n+ * on a compilation task to finish. This can happen if background\n@@ -368,1 +368,1 @@\n-void CompileQueue::free_all() {\n+void CompileQueue::delete_all() {\n@@ -388,5 +388,4 @@\n-      \/\/ If no one was waiting for this task, we need to free it ourselves. In this case, the task\n-      \/\/ is also certainly unlocked, because, again, there is no waiter.\n-      \/\/ Otherwise, by convention, it's the waiters responsibility to free the task.\n-      \/\/ Put the task back on the freelist.\n-      CompileTask::free(current);\n+      \/\/ If no one was waiting for this task, we need to delete it ourselves.\n+      \/\/ In this case, the task is also certainly unlocked, because, again, there is no waiter.\n+      \/\/ Otherwise, by convention, it's the waiters responsibility to delete the task.\n+      delete current;\n@@ -1630,4 +1629,2 @@\n-  CompileTask* new_task = CompileTask::allocate();\n-  new_task->initialize(compile_id, method, osr_bci, comp_level,\n-                       hot_count, compile_reason,\n-                       blocking);\n+  CompileTask* new_task = new CompileTask(compile_id, method, osr_bci, comp_level,\n+                                          hot_count, compile_reason, blocking);\n@@ -1654,1 +1651,1 @@\n- * @return true if this thread needs to free\/recycle the task\n+ * @return true if this thread needs to delete the task\n@@ -1737,1 +1734,1 @@\n-      CompileTask::free(task);\n+      delete task;\n@@ -1742,1 +1739,1 @@\n-    \/\/ completion is a stable property (until the task object is recycled).\n+    \/\/ completion is a stable property (until the task object is deleted).\n@@ -1745,1 +1742,1 @@\n-    \/\/ By convention, the waiter is responsible for recycling a\n+    \/\/ By convention, the waiter is responsible for deleting a\n@@ -1748,2 +1745,2 @@\n-    \/\/ be using this CompileTask; we can free it.\n-    CompileTask::free(task);\n+    \/\/ be using this CompileTask; we can delete it.\n+    delete task;\n@@ -1753,0 +1750,4 @@\n+void CompileBroker::wait_for_no_active_tasks() {\n+  CompileTask::wait_for_no_active_tasks();\n+}\n+\n@@ -1826,1 +1827,1 @@\n-      _c1_compile_queue->free_all();\n+      _c1_compile_queue->delete_all();\n@@ -1830,1 +1831,1 @@\n-      _c2_compile_queue->free_all();\n+      _c2_compile_queue->delete_all();\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":28,"deletions":27,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  void free_all();\n+  void delete_all();\n@@ -386,0 +386,3 @@\n+\n+  static void wait_for_no_active_tasks();\n+\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -34,1 +35,1 @@\n-CompileLog* CompileLog::_first = nullptr;\n+CompileLog* volatile CompileLog::_list_head = nullptr;\n@@ -52,3 +53,6 @@\n-  { MutexLocker locker(CompileTaskAlloc_lock);\n-    _next = _first;\n-    _first = this;\n+  while (true) {\n+    CompileLog* head = Atomic::load_acquire(&_list_head);\n+    _next = head;\n+    if (Atomic::cmpxchg(&_list_head, head, this) == head) {\n+      break;\n+    }\n@@ -205,1 +209,1 @@\n-  CompileLog* log = _first;\n+  CompileLog* log = Atomic::load_acquire(&_list_head);\n@@ -293,1 +297,1 @@\n-  _first = nullptr;\n+  Atomic::store(&_list_head, (CompileLog*)nullptr);\n","filename":"src\/hotspot\/share\/compiler\/compileLog.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  static CompileLog* _first;     \/\/ head of static chain\n+  static CompileLog* volatile _list_head; \/\/ head of static chain\n","filename":"src\/hotspot\/share\/compiler\/compileLog.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-CompileTask*  CompileTask::_task_free_list = nullptr;\n+int CompileTask::_active_tasks = 0;\n@@ -41,51 +41,7 @@\n-\/**\n- * Allocate a CompileTask, from the free list if possible.\n- *\/\n-CompileTask* CompileTask::allocate() {\n-  MutexLocker locker(CompileTaskAlloc_lock);\n-  CompileTask* task = nullptr;\n-\n-  if (_task_free_list != nullptr) {\n-    task = _task_free_list;\n-    _task_free_list = task->next();\n-    task->set_next(nullptr);\n-  } else {\n-    task = new CompileTask();\n-    task->set_next(nullptr);\n-    task->set_is_free(true);\n-  }\n-  assert(task->is_free(), \"Task must be free.\");\n-  task->set_is_free(false);\n-  return task;\n-}\n-\n-\/**\n-* Add a task to the free list.\n-*\/\n-void CompileTask::free(CompileTask* task) {\n-  MutexLocker locker(CompileTaskAlloc_lock);\n-  if (!task->is_free()) {\n-    if ((task->_method_holder != nullptr && JNIHandles::is_weak_global_handle(task->_method_holder))) {\n-      JNIHandles::destroy_weak_global(task->_method_holder);\n-    } else {\n-      JNIHandles::destroy_global(task->_method_holder);\n-    }\n-    if (task->_failure_reason_on_C_heap && task->_failure_reason != nullptr) {\n-      os::free((void*) task->_failure_reason);\n-    }\n-    task->_failure_reason = nullptr;\n-    task->_failure_reason_on_C_heap = false;\n-\n-    task->set_is_free(true);\n-    task->set_next(_task_free_list);\n-    _task_free_list = task;\n-  }\n-}\n-\n-void CompileTask::initialize(int compile_id,\n-                             const methodHandle& method,\n-                             int osr_bci,\n-                             int comp_level,\n-                             int hot_count,\n-                             CompileTask::CompileReason compile_reason,\n-                             bool is_blocking) {\n+CompileTask::CompileTask(int compile_id,\n+                         const methodHandle& method,\n+                         int osr_bci,\n+                         int comp_level,\n+                         int hot_count,\n+                         CompileReason compile_reason,\n+                         bool is_blocking) {\n@@ -123,0 +79,27 @@\n+\n+  Atomic::add(&_active_tasks, 1, memory_order_relaxed);\n+}\n+\n+CompileTask::~CompileTask() {\n+  if (_method_holder != nullptr && JNIHandles::is_weak_global_handle(_method_holder)) {\n+    JNIHandles::destroy_weak_global(_method_holder);\n+  } else {\n+    JNIHandles::destroy_global(_method_holder);\n+  }\n+  if (_failure_reason_on_C_heap && _failure_reason != nullptr) {\n+    os::free((void*) _failure_reason);\n+    _failure_reason = nullptr;\n+    _failure_reason_on_C_heap = false;\n+  }\n+\n+  if (Atomic::sub(&_active_tasks, 1, memory_order_relaxed) == 0) {\n+    MonitorLocker wait_ml(CompileTaskWait_lock);\n+    wait_ml.notify_all();\n+  }\n+}\n+\n+void CompileTask::wait_for_no_active_tasks() {\n+  MonitorLocker locker(CompileTaskWait_lock);\n+  while (Atomic::load(&_active_tasks) > 0) {\n+    locker.wait();\n+  }\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":35,"deletions":52,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-  static CompileTask*  _task_free_list;\n+  static int           _active_tasks;\n@@ -106,1 +106,0 @@\n-  bool                 _is_free;\n@@ -119,7 +118,4 @@\n-  CompileTask() : _failure_reason(nullptr), _failure_reason_on_C_heap(false) {}\n-  void initialize(int compile_id, const methodHandle& method, int osr_bci, int comp_level,\n-                  int hot_count,\n-                  CompileTask::CompileReason compile_reason, bool is_blocking);\n-\n-  static CompileTask* allocate();\n-  static void         free(CompileTask* task);\n+  CompileTask(int compile_id, const methodHandle& method, int osr_bci, int comp_level,\n+              int hot_count, CompileReason compile_reason, bool is_blocking);\n+  ~CompileTask();\n+  static void wait_for_no_active_tasks();\n@@ -207,2 +203,0 @@\n-  bool         is_free() const                   { return _is_free; }\n-  void         set_is_free(bool val)             { _is_free = val; }\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -52,0 +52,3 @@\n+  void print_tracing_info() const override;\n+  void stop() override {};\n+\n@@ -131,1 +134,0 @@\n-  void print_tracing_info() const override;\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-  _pre_barrier_c1_runtime_code_blob = Runtime1::generate_blob(buffer_blob, C1StubId::NO_STUBID, \"g1_pre_barrier_slow\",\n+  _pre_barrier_c1_runtime_code_blob = Runtime1::generate_blob(buffer_blob, StubId::NO_STUBID, \"g1_pre_barrier_slow\",\n@@ -223,1 +223,1 @@\n-  _post_barrier_c1_runtime_code_blob = Runtime1::generate_blob(buffer_blob, C1StubId::NO_STUBID, \"g1_post_barrier_slow\",\n+  _post_barrier_c1_runtime_code_blob = Runtime1::generate_blob(buffer_blob, StubId::NO_STUBID, \"g1_post_barrier_slow\",\n","filename":"src\/hotspot\/share\/gc\/g1\/c1\/g1BarrierSetC1.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-  uint number_of_recorded_pause_times() const {\n+  static constexpr uint max_num_of_recorded_pause_times() {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"gc\/shared\/fullGCForwarding.hpp\"\n@@ -199,2 +198,2 @@\n-    \/\/ We set it here to ~8%.\n-    FLAG_SET_DEFAULT(GCTimeRatio, 12);\n+    \/\/ We set it here to 4%.\n+    FLAG_SET_DEFAULT(GCTimeRatio, 24);\n@@ -249,2 +248,0 @@\n-\n-  FullGCForwarding::initialize_flags(heap_reserved_size_bytes());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-#include \"gc\/shared\/fullGCForwarding.hpp\"\n+#include \"gc\/shared\/fullGCForwarding.inline.hpp\"\n@@ -798,2 +798,1 @@\n-  resize_heap_if_necessary(allocation_word_size);\n-  uncommit_regions_if_necessary();\n+  resize_heap_after_full_collection(allocation_word_size);\n@@ -882,1 +881,11 @@\n-void G1CollectedHeap::resize_heap_if_necessary(size_t allocation_word_size) {\n+\n+void G1CollectedHeap::resize_heap(size_t resize_bytes, bool should_expand) {\n+  if (should_expand) {\n+    expand(resize_bytes, _workers);\n+  } else {\n+    shrink(resize_bytes);\n+    uncommit_regions_if_necessary();\n+  }\n+}\n+\n+void G1CollectedHeap::resize_heap_after_full_collection(size_t allocation_word_size) {\n@@ -886,1 +895,1 @@\n-  size_t resize_amount = _heap_sizing_policy->full_collection_resize_amount(should_expand, allocation_word_size);\n+  size_t resize_bytes = _heap_sizing_policy->full_collection_resize_amount(should_expand, allocation_word_size);\n@@ -888,6 +897,2 @@\n-  if (resize_amount == 0) {\n-    return;\n-  } else if (should_expand) {\n-    expand(resize_amount, _workers);\n-  } else {\n-    shrink(resize_amount);\n+  if (resize_bytes != 0) {\n+    resize_heap(resize_bytes, should_expand);\n@@ -897,0 +902,14 @@\n+void G1CollectedHeap::resize_heap_after_young_collection(size_t allocation_word_size) {\n+  Ticks start = Ticks::now();\n+\n+  bool should_expand;\n+\n+  size_t resize_bytes = _heap_sizing_policy->young_collection_resize_amount(should_expand, allocation_word_size);\n+\n+  if (resize_bytes != 0) {\n+    resize_heap(resize_bytes, should_expand);\n+  }\n+\n+  phase_times()->record_resize_heap_time((Ticks::now() - start).seconds() * 1000.0);\n+}\n+\n@@ -1005,0 +1024,2 @@\n+  assert(expand_bytes > 0, \"precondition\");\n+\n@@ -1008,2 +1029,4 @@\n-  log_debug(gc, ergo, heap)(\"Expand the heap. requested expansion amount: %zuB expansion amount: %zuB\",\n-                            expand_bytes, aligned_expand_bytes);\n+  uint num_regions_to_expand = (uint)(aligned_expand_bytes \/ G1HeapRegion::GrainBytes);\n+\n+  log_debug(gc, ergo, heap)(\"Heap resize. Requested expansion amount: %zuB aligned expansion amount: %zuB (%u regions)\",\n+                            expand_bytes, aligned_expand_bytes, num_regions_to_expand);\n@@ -1012,1 +1035,1 @@\n-    log_debug(gc, ergo, heap)(\"Did not expand the heap (heap already fully expanded)\");\n+    log_debug(gc, ergo, heap)(\"Heap resize. Did not expand the heap (heap already fully expanded)\");\n@@ -1016,5 +1039,1 @@\n-  uint regions_to_expand = (uint)(aligned_expand_bytes \/ G1HeapRegion::GrainBytes);\n-  assert(regions_to_expand > 0, \"Must expand by at least one region\");\n-\n-  uint expanded_by = _hrm.expand_by(regions_to_expand, pretouch_workers);\n-  assert(expanded_by > 0, \"must have failed during commit.\");\n+  uint expanded_by = _hrm.expand_by(num_regions_to_expand, pretouch_workers);\n@@ -1043,2 +1062,5 @@\n-  size_t aligned_shrink_bytes = os::align_down_vm_page_size(shrink_bytes);\n-  aligned_shrink_bytes = align_down(aligned_shrink_bytes, G1HeapRegion::GrainBytes);\n+  assert(shrink_bytes > 0, \"must be\");\n+  assert(is_aligned(shrink_bytes, G1HeapRegion::GrainBytes),\n+         \"Shrink request for %zuB not aligned to heap region size %zuB\",\n+         shrink_bytes, G1HeapRegion::GrainBytes);\n+\n@@ -1050,2 +1072,2 @@\n-  log_debug(gc, ergo, heap)(\"Shrink the heap. requested shrinking amount: %zuB aligned shrinking amount: %zuB actual amount shrunk: %zuB\",\n-                            shrink_bytes, aligned_shrink_bytes, shrunk_bytes);\n+  log_debug(gc, ergo, heap)(\"Heap resize. Requested shrinking amount: %zuB actual shrinking amount: %zuB (%u regions)\",\n+                            shrink_bytes, shrunk_bytes, num_regions_removed);\n@@ -1053,1 +1075,0 @@\n-    log_debug(gc, heap)(\"Uncommittable regions after shrink: %u\", num_regions_removed);\n@@ -1056,1 +1077,1 @@\n-    log_debug(gc, ergo, heap)(\"Did not shrink the heap (heap shrinking operation failed)\");\n+    log_debug(gc, ergo, heap)(\"Heap resize. Did not shrink the heap (heap shrinking operation failed)\");\n@@ -1061,0 +1082,19 @@\n+  if (capacity() == min_capacity()) {\n+    log_debug(gc, ergo, heap)(\"Heap resize. Did not shrink the heap (heap already at minimum)\");\n+    return;\n+  }\n+\n+  size_t aligned_shrink_bytes = os::align_down_vm_page_size(shrink_bytes);\n+  aligned_shrink_bytes = align_down(aligned_shrink_bytes, G1HeapRegion::GrainBytes);\n+\n+  aligned_shrink_bytes = capacity() - MAX2(capacity() - aligned_shrink_bytes, min_capacity());\n+  assert(is_aligned(aligned_shrink_bytes, G1HeapRegion::GrainBytes), \"Bytes to shrink %zuB not aligned\", aligned_shrink_bytes);\n+\n+  log_debug(gc, ergo, heap)(\"Heap resize. Requested shrink amount: %zuB aligned shrink amount: %zuB\",\n+                            shrink_bytes, aligned_shrink_bytes);\n+\n+  if (aligned_shrink_bytes == 0) {\n+    log_debug(gc, ergo, heap)(\"Heap resize. Did not shrink the heap (shrink request too small)\");\n+    return;\n+  }\n+\n@@ -1072,1 +1112,1 @@\n-  shrink_helper(shrink_bytes);\n+  shrink_helper(aligned_shrink_bytes);\n@@ -1341,1 +1381,1 @@\n-                       MinHeapSize,\n+                       min_capacity(),\n@@ -2027,1 +2067,1 @@\n-  return (_policy->young_list_target_length() - _survivor.length()) * G1HeapRegion::GrainBytes;\n+  return eden_target_length() * G1HeapRegion::GrainBytes;\n@@ -2048,0 +2088,4 @@\n+size_t G1CollectedHeap::min_capacity() const {\n+  return MinHeapSize;\n+}\n+\n@@ -2393,14 +2437,1 @@\n-void G1CollectedHeap::expand_heap_after_young_collection(){\n-  size_t expand_bytes = _heap_sizing_policy->young_collection_expansion_amount();\n-  if (expand_bytes > 0) {\n-    \/\/ No need for an ergo logging here,\n-    \/\/ expansion_amount() does this when it returns a value > 0.\n-    Ticks expand_start = Ticks::now();\n-    if (expand(expand_bytes, _workers)) {\n-      double expand_ms = (Ticks::now() - expand_start).seconds() * MILLIUNITS;\n-      phase_times()->record_expand_heap_time(expand_ms);\n-    }\n-  }\n-}\n-\n-void G1CollectedHeap::do_collection_pause_at_safepoint() {\n+void G1CollectedHeap::do_collection_pause_at_safepoint(size_t allocation_word_size) {\n@@ -2410,1 +2441,1 @@\n-  do_collection_pause_at_safepoint_helper();\n+  do_collection_pause_at_safepoint_helper(allocation_word_size);\n@@ -2474,1 +2505,1 @@\n-void G1CollectedHeap::do_collection_pause_at_safepoint_helper() {\n+void G1CollectedHeap::do_collection_pause_at_safepoint_helper(size_t allocation_word_size) {\n@@ -2492,1 +2523,1 @@\n-  G1YoungCollector collector(gc_cause());\n+  G1YoungCollector collector(gc_cause(), allocation_word_size);\n@@ -2614,0 +2645,7 @@\n+  uint total_allocated = _survivor_evac_stats.regions_filled() + _old_evac_stats.regions_filled();\n+\n+  log_debug(gc)(\"Allocated %u survivor %u old percent total %1.2f%% (%u%%)\",\n+                _survivor_evac_stats.regions_filled(), _old_evac_stats.regions_filled(),\n+                percent_of(total_allocated, num_committed_regions() - total_allocated),\n+                G1ReservePercent);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":83,"deletions":45,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -476,0 +476,2 @@\n+  void resize_heap(size_t resize_bytes, bool should_expand);\n+\n@@ -561,1 +563,2 @@\n-  void resize_heap_if_necessary(size_t allocation_word_size);\n+  void resize_heap_after_young_collection(size_t allocation_word_size);\n+  void resize_heap_after_full_collection(size_t allocation_word_size);\n@@ -746,1 +749,1 @@\n-  void do_collection_pause_at_safepoint();\n+  void do_collection_pause_at_safepoint(size_t allocation_word_size = 0);\n@@ -750,1 +753,1 @@\n-  void do_collection_pause_at_safepoint_helper();\n+  void do_collection_pause_at_safepoint_helper(size_t allocation_word_size);\n@@ -767,2 +770,0 @@\n-  void expand_heap_after_young_collection();\n-  \/\/ Update object copying statistics.\n@@ -885,0 +886,4 @@\n+\n+  void print_tracing_info() const override;\n+  void stop() override;\n+\n@@ -894,1 +899,0 @@\n-  void stop() override;\n@@ -1025,0 +1029,2 @@\n+  bool last_gc_was_periodic() { return _gc_lastcause == GCCause::_g1_periodic_collection; }\n+\n@@ -1193,0 +1199,1 @@\n+  size_t min_capacity() const;\n@@ -1207,0 +1214,1 @@\n+  inline uint eden_target_length() const;\n@@ -1312,3 +1320,0 @@\n-  \/\/ Override\n-  void print_tracing_info() const override;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -319,0 +319,4 @@\n+inline uint G1CollectedHeap::eden_target_length() const {\n+  return _policy->young_list_target_length() - survivor_regions_count();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1453,2 +1453,7 @@\n-    _g1h->resize_heap_if_necessary(size_t(0) \/* allocation_word_size *\/);\n-    _g1h->uncommit_regions_if_necessary();\n+    \/\/ For Remark Pauses that may have been triggered by PeriodicGCs, we maintain\n+    \/\/ resizing based on MinHeapFreeRatio or MaxHeapFreeRatio. If a PeriodicGC is\n+    \/\/ triggered, it likely means there are very few regular GCs, making resizing\n+    \/\/ based on gc heuristics less effective.\n+    if (_g1h->last_gc_was_periodic()) {\n+      _g1h->resize_heap_after_full_collection(0 \/* allocation_word_size *\/);\n+    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -214,0 +214,2 @@\n+  FullGCForwarding::begin();\n+\n@@ -226,0 +228,2 @@\n+  FullGCForwarding::end();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-  _cur_expand_heap_time_ms = 0.0;\n+  _cur_resize_heap_time_ms = 0.0;\n@@ -491,1 +491,1 @@\n-                        _cur_expand_heap_time_ms;\n+                        _cur_resize_heap_time_ms;\n@@ -540,1 +540,1 @@\n-  debug_time(\"Expand Heap After Collection\", _cur_expand_heap_time_ms);\n+  debug_time(\"Resize Heap After Collection\", _cur_resize_heap_time_ms);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-  double _cur_expand_heap_time_ms;\n+  double _cur_resize_heap_time_ms;\n@@ -286,2 +286,2 @@\n-  void record_expand_heap_time(double ms) {\n-    _cur_expand_heap_time_ms = ms;\n+  void record_resize_heap_time(double ms) {\n+    _cur_resize_heap_time_ms = ms;\n@@ -408,2 +408,2 @@\n-  double cur_expand_heap_time_ms() {\n-    return _cur_expand_heap_time_ms;\n+  double cur_resize_heap_time_ms() {\n+    return _cur_resize_heap_time_ms;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n@@ -41,1 +41,6 @@\n-  _num_prev_pauses_for_heuristics(analytics->number_of_recorded_pause_times()) {\n+  \/\/ Bias for expansion at startup; the +1 is to counter the first sample always\n+  \/\/ being 0.0, i.e. lower than any threshold.\n+  _gc_cpu_usage_deviation_counter((G1CPUUsageExpandThreshold \/ 2) + 1),\n+  _recent_cpu_usage_deltas(long_term_count_limit()),\n+  _long_term_count(0) {\n+}\n@@ -43,2 +48,4 @@\n-  assert(MinOverThresholdForGrowth < _num_prev_pauses_for_heuristics, \"Threshold must be less than %u\", _num_prev_pauses_for_heuristics);\n-  clear_ratio_check_data();\n+void G1HeapSizingPolicy::reset_cpu_usage_tracking_data() {\n+  _long_term_count = 0;\n+  _gc_cpu_usage_deviation_counter = 0;\n+  \/\/ Keep the recent GC CPU usage data.\n@@ -47,4 +54,4 @@\n-void G1HeapSizingPolicy::clear_ratio_check_data() {\n-  _ratio_over_threshold_count = 0;\n-  _ratio_over_threshold_sum = 0.0;\n-  _pauses_since_start = 0;\n+void G1HeapSizingPolicy::decay_cpu_usage_tracking_data() {\n+  _long_term_count = 0;\n+  _gc_cpu_usage_deviation_counter \/= 2;\n+  \/\/ Keep the recent GC CPU usage data.\n@@ -53,2 +60,2 @@\n-double G1HeapSizingPolicy::scale_with_heap(double pause_time_threshold) {\n-  double threshold = pause_time_threshold;\n+double G1HeapSizingPolicy::scale_with_heap(double gc_cpu_usage_target) {\n+  double target = gc_cpu_usage_target;\n@@ -59,2 +66,2 @@\n-    threshold *= (double)_g1h->capacity() \/ (double)(_g1h->max_capacity() \/ 2);\n-    threshold = MAX2(threshold, 0.01);\n+    target *= (double)_g1h->capacity() \/ (double)(_g1h->max_capacity() \/ 2);\n+    target = MAX2(target, 0.01);\n@@ -63,1 +70,1 @@\n-  return threshold;\n+  return target;\n@@ -66,17 +73,21 @@\n-static void log_expansion(double short_term_pause_time_ratio,\n-                          double long_term_pause_time_ratio,\n-                          double threshold,\n-                          double pause_time_ratio,\n-                          bool fully_expanded,\n-                          size_t resize_bytes) {\n-\n-  log_debug(gc, ergo, heap)(\"Heap expansion: \"\n-                            \"short term pause time ratio %1.2f%% long term pause time ratio %1.2f%% \"\n-                            \"threshold %1.2f%% pause time ratio %1.2f%% fully expanded %s \"\n-                            \"resize by %zuB\",\n-                            short_term_pause_time_ratio * 100.0,\n-                            long_term_pause_time_ratio * 100.0,\n-                            threshold * 100.0,\n-                            pause_time_ratio * 100.0,\n-                            BOOL_TO_STR(fully_expanded),\n-                            resize_bytes);\n+static void log_resize(double short_term_cpu_usage,\n+                       double long_term_cpu_usage,\n+                       double lower_threshold,\n+                       double upper_threshold,\n+                       double cpu_usage_target,\n+                       bool at_limit,\n+                       size_t resize_bytes,\n+                       bool expand) {\n+\n+  log_debug(gc, ergo, heap)(\"Heap resize: \"\n+                            \"short term GC CPU usage %1.2f%% long term GC CPU usage %1.2f%% \"\n+                            \"lower threshold %1.2f%% upper threshold %1.2f%% GC CPU usage target %1.2f%% \"\n+                            \"at limit %s resize by %zuB expand %s\",\n+                            short_term_cpu_usage * 100.0,\n+                            long_term_cpu_usage * 100.0,\n+                            lower_threshold * 100.0,\n+                            upper_threshold * 100.0,\n+                            cpu_usage_target * 100.0,\n+                            BOOL_TO_STR(at_limit),\n+                            resize_bytes,\n+                            BOOL_TO_STR(expand));\n@@ -85,2 +96,7 @@\n-size_t G1HeapSizingPolicy::young_collection_expansion_amount() {\n-  assert(GCTimeRatio > 0, \"must be\");\n+\/\/ Logistic function, returns values in the range [0,1]\n+static double sigmoid_function(double value) {\n+  \/\/ Sigmoid Parameters:\n+  double inflection_point = 1.0; \/\/ Inflection point (midpoint of the sigmoid).\n+  double steepness = 6.0;\n+  return 1.0 \/ (1.0 + exp(-steepness * (value - inflection_point)));\n+}\n@@ -88,4 +104,33 @@\n-  double long_term_pause_time_ratio = _analytics->long_term_pause_time_ratio();\n-  double short_term_pause_time_ratio = _analytics->short_term_pause_time_ratio();\n-  const double pause_time_threshold = 1.0 \/ (1.0 + GCTimeRatio);\n-  double threshold = scale_with_heap(pause_time_threshold);\n+\/\/ Computes a smooth scaling factor based on the relative deviation of actual gc_cpu_usage\n+\/\/ from the gc_cpu_usage_target, using a sigmoid function to transition between\n+\/\/ the specified minimum and maximum scaling factors.\n+\/\/\n+\/\/ The input cpu_usage_delta represents the relative deviation of the current gc_cpu_usage to the\n+\/\/ gc_cpu_usage_target. This value is passed through a sigmoid function that produces a smooth\n+\/\/ output between 0 and 1, which is then scaled to the range [min_scale_factor, max_scale_factor].\n+\/\/\n+\/\/ The sigmoid's inflection point is set at cpu_usage_delta = 1.0 (a 100% deviation), where the scaling\n+\/\/ response increases most rapidly.\n+\/\/\n+\/\/ The steepness parameter controls how sharply the scale factor changes near the inflection point.\n+\/\/  * Low steepness (1-3): gradual scaling over a wide range of deviations (more conservative).\n+\/\/  * High steepness (7-10): rapid scaling near the inflection point; small deviations result\n+\/\/                           in very low scaling, but larger deviations ramp up scaling quickly.\n+\/\/                           Steepness at 10 is nearly a step function.\n+\/\/\n+\/\/ In this case, we choose a steepness of 6.0:\n+\/\/ - For small deviations, the sigmoid output is close to 0, resulting in scale factors near the\n+\/\/   lower bound, preventing excessive resizing.\n+\/\/ - As cpu_usage_delta grows toward 1.0, the steepness value makes the transition sharper, enabling\n+\/\/   more aggressive scaling for large deviations.\n+\/\/\n+\/\/ This helps avoid overreacting to small gc_cpu_usage deviations but respond appropriately\n+\/\/ when necessary.\n+double G1HeapSizingPolicy::scale_cpu_usage_delta(double cpu_usage_delta,\n+                                                 double min_scale_factor,\n+                                                 double max_scale_factor) const {\n+  double sigmoid = sigmoid_function(cpu_usage_delta);\n+\n+  double scale_factor = min_scale_factor + (max_scale_factor - min_scale_factor) * sigmoid;\n+  return scale_factor;\n+}\n@@ -93,1 +138,4 @@\n-  size_t expand_bytes = 0;\n+\/\/ Calculate the relative difference between a and b.\n+static double rel_diff(double a, double b) {\n+  return (a - b) \/ b;\n+}\n@@ -95,5 +143,48 @@\n-  if (_g1h->capacity() == _g1h->max_capacity()) {\n-    log_expansion(short_term_pause_time_ratio, long_term_pause_time_ratio,\n-                  threshold, pause_time_threshold, true, 0);\n-    clear_ratio_check_data();\n-    return expand_bytes;\n+size_t G1HeapSizingPolicy::young_collection_expand_amount(double cpu_usage_delta) const {\n+  assert(cpu_usage_delta >= 0.0, \"must be\");\n+\n+  size_t reserved_bytes = _g1h->max_capacity();\n+  size_t committed_bytes = _g1h->capacity();\n+  size_t uncommitted_bytes = reserved_bytes - committed_bytes;\n+  size_t expand_bytes_via_pct = uncommitted_bytes * G1ExpandByPercentOfAvailable \/ 100;\n+  size_t min_expand_bytes = MIN2(G1HeapRegion::GrainBytes, uncommitted_bytes);\n+\n+  \/\/ Take the current size or G1ExpandByPercentOfAvailable % of\n+  \/\/ the available expansion space, whichever is smaller, as the base\n+  \/\/ expansion size. Then possibly scale this size according to how much the\n+  \/\/ GC CPU usage (on average) has exceeded the target.\n+  const double min_scale_factor = 0.2;\n+  const double max_scale_factor = 2.0;\n+\n+  double scale_factor = scale_cpu_usage_delta(cpu_usage_delta,\n+                                              min_scale_factor,\n+                                              max_scale_factor);\n+\n+  size_t resize_bytes = MIN2(expand_bytes_via_pct, committed_bytes);\n+\n+  resize_bytes = static_cast<size_t>(resize_bytes * scale_factor);\n+\n+  \/\/ Ensure the expansion size is at least the minimum growth amount\n+  \/\/ and at most the remaining uncommitted byte size.\n+  return clamp(resize_bytes, min_expand_bytes, uncommitted_bytes);\n+}\n+\n+size_t G1HeapSizingPolicy::young_collection_shrink_amount(double cpu_usage_delta, size_t allocation_word_size) const {\n+  assert(cpu_usage_delta >= 0.0, \"must be\");\n+\n+  const double max_scale_factor = G1ShrinkByPercentOfAvailable \/ 100.0;\n+  const double min_scale_factor = max_scale_factor \/ 10.0;\n+\n+  double scale_factor = scale_cpu_usage_delta(cpu_usage_delta,\n+                                              min_scale_factor,\n+                                              max_scale_factor);\n+  assert(scale_factor <= max_scale_factor, \"must be\");\n+\n+  \/\/ We are at the end of GC, so free regions are at maximum. Do not try to shrink\n+  \/\/ to have less than the reserve or the number of regions we are most certainly\n+  \/\/ going to use during this mutator phase.\n+  uint target_regions_to_shrink = _g1h->num_free_regions();\n+\n+  uint needed_for_allocation = _g1h->eden_target_length();\n+  if (_g1h->is_humongous(allocation_word_size)) {\n+    needed_for_allocation += (uint) _g1h->humongous_obj_size_in_regions(allocation_word_size);\n@@ -102,6 +193,96 @@\n-  \/\/ If the last GC time ratio is over the threshold, increment the count of\n-  \/\/ times it has been exceeded, and add this ratio to the sum of exceeded\n-  \/\/ ratios.\n-  if (short_term_pause_time_ratio > threshold) {\n-    _ratio_over_threshold_count++;\n-    _ratio_over_threshold_sum += short_term_pause_time_ratio;\n+  if (target_regions_to_shrink >= needed_for_allocation) {\n+    target_regions_to_shrink -= needed_for_allocation;\n+  } else {\n+    target_regions_to_shrink = 0;\n+  }\n+\n+  size_t resize_bytes = (double)G1HeapRegion::GrainBytes * target_regions_to_shrink * scale_factor;\n+\n+  log_debug(gc, ergo, heap)(\"Shrink log: scale factor %1.2f%% \"\n+                            \"total free regions %u \"\n+                            \"needed for alloc %u \"\n+                            \"base targeted for shrinking %u \"\n+                            \"resize_bytes %zd ( %zu regions)\",\n+                            scale_factor * 100.0,\n+                            _g1h->num_free_regions(),\n+                            needed_for_allocation,\n+                            target_regions_to_shrink,\n+                            resize_bytes,\n+                            (resize_bytes \/ G1HeapRegion::GrainBytes));\n+\n+  return resize_bytes;\n+}\n+\n+size_t G1HeapSizingPolicy::young_collection_resize_amount(bool& expand, size_t allocation_word_size) {\n+  assert(GCTimeRatio > 0, \"must be\");\n+  expand = false;\n+\n+  const double long_term_gc_cpu_usage = _analytics->long_term_pause_time_ratio();\n+  const double short_term_gc_cpu_usage = _analytics->short_term_pause_time_ratio();\n+\n+  double gc_cpu_usage_target = 1.0 \/ (1.0 + GCTimeRatio);\n+  gc_cpu_usage_target = scale_with_heap(gc_cpu_usage_target);\n+\n+  \/\/ Calculate gc_cpu_usage acceptable deviation thresholds:\n+  \/\/ - upper_threshold, do not want to exceed this.\n+  \/\/ - lower_threshold, we do not want to go below.\n+  const double gc_cpu_usage_margin = G1CPUUsageDeviationPercent \/ 100.0;\n+  const double upper_threshold = gc_cpu_usage_target * (1 + gc_cpu_usage_margin);\n+  const double lower_threshold = gc_cpu_usage_target * (1 - gc_cpu_usage_margin);\n+\n+  \/\/ Decide to expand\/shrink based on how far the current GC CPU usage deviates\n+  \/\/ from the target. This allows the policy to respond more quickly to GC pressure\n+  \/\/ when the heap is small relative to the maximum heap.\n+  const double long_term_delta = rel_diff(long_term_gc_cpu_usage, gc_cpu_usage_target);\n+  const double short_term_delta = rel_diff(short_term_gc_cpu_usage, gc_cpu_usage_target);\n+\n+  \/\/ If the short term GC CPU usage exceeds the upper threshold, increment the deviation\n+  \/\/ counter. If it falls below the lower_threshold, decrement the deviation counter.\n+  if (short_term_gc_cpu_usage > upper_threshold) {\n+    _gc_cpu_usage_deviation_counter++;\n+  } else if (short_term_gc_cpu_usage < lower_threshold) {\n+    _gc_cpu_usage_deviation_counter--;\n+  }\n+  \/\/ Ignore very first sample as it is garbage.\n+  if (_long_term_count != 0 || _recent_cpu_usage_deltas.num() != 0) {\n+    _recent_cpu_usage_deltas.add(short_term_delta);\n+  }\n+  _long_term_count++;\n+\n+  log_trace(gc, ergo, heap)(\"Heap resize triggers: long term count: %u \"\n+                            \"long term count limit: %u \"\n+                            \"short term delta: %1.2f \"\n+                            \"recent recorded short term deltas: %u\"\n+                            \"GC CPU usage deviation counter: %d\",\n+                            _long_term_count,\n+                            long_term_count_limit(),\n+                            short_term_delta,\n+                            _recent_cpu_usage_deltas.num(),\n+                            _gc_cpu_usage_deviation_counter);\n+\n+  \/\/ Check if there is a short- or long-term need for resizing, expansion first.\n+  \/\/\n+  \/\/ Short-term resizing need is detected by exceeding the upper or lower thresholds\n+  \/\/ multiple times, tracked in _gc_cpu_usage_deviation_counter. If it contains a large\n+  \/\/ positive or negative (larger than the respective thresholds), we trigger\n+  \/\/ resizing calculation.\n+  \/\/\n+  \/\/ Slowly occurring long-term changes to the actual GC CPU usage are checked\n+  \/\/ only every once in a while.\n+  \/\/\n+  \/\/ The _gc_cpu_usage_deviation_counter value is reset after each resize, or slowly\n+  \/\/ decayed if no resizing happens.\n+\n+  size_t resize_bytes = 0;\n+\n+  const bool use_long_term_delta = (_long_term_count == long_term_count_limit());\n+  const double avg_short_term_delta = _recent_cpu_usage_deltas.avg();\n+\n+  double delta;\n+  if (use_long_term_delta) {\n+    \/\/ For expansion, deltas are positive, and we want to expand aggressively.\n+    \/\/ For shrinking, deltas are negative, so the MAX2 below selects the least\n+    \/\/ aggressive one as we are using the absolute value for scaling.\n+    delta = MAX2(avg_short_term_delta, long_term_delta);\n+  } else {\n+    delta = avg_short_term_delta;\n@@ -109,0 +290,5 @@\n+  \/\/ Delta is negative when shrinking, but the calculation of the resize amount\n+  \/\/ always expects an absolute value. Do that here unconditionally.\n+  delta = fabsd(delta);\n+\n+  int count_threshold_for_shrink = (int)G1CPUUsageShrinkThreshold;\n@@ -110,61 +296,10 @@\n-  log_trace(gc, ergo, heap)(\"Heap expansion triggers: pauses since start: %u \"\n-                            \"num prev pauses for heuristics: %u \"\n-                            \"ratio over threshold count: %u\",\n-                            _pauses_since_start,\n-                            _num_prev_pauses_for_heuristics,\n-                            _ratio_over_threshold_count);\n-\n-  \/\/ Check if we've had enough GC time ratio checks that were over the\n-  \/\/ threshold to trigger an expansion. We'll also expand if we've\n-  \/\/ reached the end of the history buffer and the average of all entries\n-  \/\/ is still over the threshold. This indicates a smaller number of GCs were\n-  \/\/ long enough to make the average exceed the threshold.\n-  bool filled_history_buffer = _pauses_since_start == _num_prev_pauses_for_heuristics;\n-  if ((_ratio_over_threshold_count == MinOverThresholdForGrowth) ||\n-      (filled_history_buffer && (long_term_pause_time_ratio > threshold))) {\n-    size_t min_expand_bytes = G1HeapRegion::GrainBytes;\n-    size_t reserved_bytes = _g1h->max_capacity();\n-    size_t committed_bytes = _g1h->capacity();\n-    size_t uncommitted_bytes = reserved_bytes - committed_bytes;\n-    size_t expand_bytes_via_pct =\n-      uncommitted_bytes * G1ExpandByPercentOfAvailable \/ 100;\n-    double scale_factor = 1.0;\n-\n-    \/\/ If the current size is less than 1\/4 of the Initial heap size, expand\n-    \/\/ by half of the delta between the current and Initial sizes. IE, grow\n-    \/\/ back quickly.\n-    \/\/\n-    \/\/ Otherwise, take the current size, or G1ExpandByPercentOfAvailable % of\n-    \/\/ the available expansion space, whichever is smaller, as the base\n-    \/\/ expansion size. Then possibly scale this size according to how much the\n-    \/\/ threshold has (on average) been exceeded by. If the delta is small\n-    \/\/ (less than the StartScaleDownAt value), scale the size down linearly, but\n-    \/\/ not by less than MinScaleDownFactor. If the delta is large (greater than\n-    \/\/ the StartScaleUpAt value), scale up, but adding no more than MaxScaleUpFactor\n-    \/\/ times the base size. The scaling will be linear in the range from\n-    \/\/ StartScaleUpAt to (StartScaleUpAt + ScaleUpRange). In other words,\n-    \/\/ ScaleUpRange sets the rate of scaling up.\n-    if (committed_bytes < InitialHeapSize \/ 4) {\n-      expand_bytes = (InitialHeapSize - committed_bytes) \/ 2;\n-    } else {\n-      double const MinScaleDownFactor = 0.2;\n-      double const MaxScaleUpFactor = 2;\n-      double const StartScaleDownAt = pause_time_threshold;\n-      double const StartScaleUpAt = pause_time_threshold * 1.5;\n-      double const ScaleUpRange = pause_time_threshold * 2.0;\n-\n-      double ratio_delta;\n-      if (filled_history_buffer) {\n-        ratio_delta = long_term_pause_time_ratio - threshold;\n-      } else {\n-        ratio_delta = (_ratio_over_threshold_sum \/ _ratio_over_threshold_count) - threshold;\n-      }\n-\n-      expand_bytes = MIN2(expand_bytes_via_pct, committed_bytes);\n-      if (ratio_delta < StartScaleDownAt) {\n-        scale_factor = ratio_delta \/ StartScaleDownAt;\n-        scale_factor = MAX2(scale_factor, MinScaleDownFactor);\n-      } else if (ratio_delta > StartScaleUpAt) {\n-        scale_factor = 1 + ((ratio_delta - StartScaleUpAt) \/ ScaleUpRange);\n-        scale_factor = MIN2(scale_factor, MaxScaleUpFactor);\n-      }\n+  if ((_gc_cpu_usage_deviation_counter >= (int)G1CPUUsageExpandThreshold) ||\n+      (use_long_term_delta && (long_term_gc_cpu_usage > upper_threshold))) {\n+    expand = true;\n+\n+    \/\/ Short-cut calculation if already at maximum capacity.\n+    if (_g1h->capacity() == _g1h->max_capacity()) {\n+      log_resize(short_term_gc_cpu_usage, long_term_gc_cpu_usage,\n+                 lower_threshold, upper_threshold, gc_cpu_usage_target, true, 0, expand);\n+      reset_cpu_usage_tracking_data();\n+      return resize_bytes;\n@@ -173,1 +308,2 @@\n-    expand_bytes = static_cast<size_t>(expand_bytes * scale_factor);\n+    log_trace(gc, ergo, heap)(\"expand deltas long %1.2f short %1.2f use long term %u delta %1.2f\",\n+                              long_term_delta, avg_short_term_delta, use_long_term_delta, delta);\n@@ -175,3 +311,1 @@\n-    \/\/ Ensure the expansion size is at least the minimum growth amount\n-    \/\/ and at most the remaining uncommitted byte size.\n-    expand_bytes = clamp(expand_bytes, min_expand_bytes, uncommitted_bytes);\n+    resize_bytes = young_collection_expand_amount(delta);\n@@ -179,11 +313,10 @@\n-    clear_ratio_check_data();\n-  } else {\n-    \/\/ An expansion was not triggered. If we've started counting, increment\n-    \/\/ the number of checks we've made in the current window.  If we've\n-    \/\/ reached the end of the window without resizing, clear the counters to\n-    \/\/ start again the next time we see a ratio above the threshold.\n-    if (_ratio_over_threshold_count > 0) {\n-      _pauses_since_start++;\n-      if (_pauses_since_start > _num_prev_pauses_for_heuristics) {\n-        clear_ratio_check_data();\n-      }\n+    reset_cpu_usage_tracking_data();\n+  } else if ((_gc_cpu_usage_deviation_counter <= -count_threshold_for_shrink) ||\n+             (use_long_term_delta && (long_term_gc_cpu_usage < lower_threshold))) {\n+    expand = false;\n+    \/\/ Short-cut calculation if already at minimum capacity.\n+    if (_g1h->capacity() == _g1h->min_capacity()) {\n+      log_resize(short_term_gc_cpu_usage, long_term_gc_cpu_usage,\n+                 lower_threshold, upper_threshold, gc_cpu_usage_target, true, 0, expand);\n+      reset_cpu_usage_tracking_data();\n+      return resize_bytes;\n@@ -191,0 +324,11 @@\n+\n+    log_trace(gc, ergo, heap)(\"expand deltas long %1.2f short %1.2f use long term %u delta %1.2f\",\n+                              long_term_delta, avg_short_term_delta, use_long_term_delta, delta);\n+\n+    resize_bytes = young_collection_shrink_amount(delta, allocation_word_size);\n+\n+    reset_cpu_usage_tracking_data();\n+  } else if (use_long_term_delta) {\n+    \/\/ A resize has not been triggered, but the long term counter overflowed.\n+    decay_cpu_usage_tracking_data();\n+    expand = false; \/\/ Does not matter.\n@@ -193,2 +337,3 @@\n-  log_expansion(short_term_pause_time_ratio, long_term_pause_time_ratio,\n-                threshold, pause_time_threshold, false, expand_bytes);\n+  log_resize(short_term_gc_cpu_usage, long_term_gc_cpu_usage,\n+             lower_threshold, upper_threshold, gc_cpu_usage_target,\n+             false, resize_bytes, expand);\n@@ -196,1 +341,1 @@\n-  return expand_bytes;\n+  return resize_bytes;\n@@ -260,1 +405,1 @@\n-  minimum_desired_capacity = MIN2(minimum_desired_capacity, MaxHeapSize);\n+  minimum_desired_capacity = MIN2(minimum_desired_capacity, _g1h->max_capacity());\n@@ -264,1 +409,1 @@\n-  maximum_desired_capacity =  MAX2(maximum_desired_capacity, MinHeapSize);\n+  maximum_desired_capacity = MAX2(maximum_desired_capacity, _g1h->min_capacity());\n@@ -270,1 +415,1 @@\n-    log_debug(gc, ergo, heap)(\"Attempt heap expansion (capacity lower than min desired capacity). \"\n+    log_debug(gc, ergo, heap)(\"Heap resize. Attempt heap expansion (capacity lower than min desired capacity). \"\n@@ -282,1 +427,1 @@\n-    log_debug(gc, ergo, heap)(\"Attempt heap shrinking (capacity higher than max desired capacity). \"\n+    log_debug(gc, ergo, heap)(\"Heap resize. Attempt heap shrinking (capacity higher than max desired capacity). \"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":276,"deletions":131,"binary":false,"changes":407,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1Analytics.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"utilities\/numberSeq.hpp\"\n@@ -30,1 +32,0 @@\n-class G1Analytics;\n@@ -33,0 +34,34 @@\n+\/\/\n+\/\/ Contains heuristics to resize the heap, i.e. expand or shrink, during operation.\n+\/\/\n+\/\/ For young collections, this heuristics is based on GC CPU usage, i.e. trying to\n+\/\/ change the heap so that the GC CPU usage stays approximately close to the target\n+\/\/ GC CPU usage set by the user.\n+\/\/\n+\/\/ The heuristics track both short and long term GC behavior to affect heap resizing.\n+\/\/\n+\/\/ Short term tracking is based on the short-term GC CPU usage i.e we count events\n+\/\/ for which short-term GC CPU usage is outside the range:\n+\/\/ gc_cpu_usage_target  [1 - d, 1 + d], where d = G1CPUUsageDeviationPercent \/ 100\n+\/\/ If below that range, we decrement that counter, if above, we increment it.\n+\/\/\n+\/\/ If that counter reaches the G1CPUUsageExpandThreshold we consider expansion,\n+\/\/ if that counter reaches -G1CPUUsageShrinkThreshold we consider shrinking the heap.\n+\/\/\n+\/\/ While doing so, we accumulate the relative difference to the target GC CPU usage\n+\/\/ to guide the expansion\/shrinking amount.\n+\/\/\n+\/\/ Furthermore, if there is no short-term based resizing event for a \"long\" time,\n+\/\/ we decay that counter, i.e. drop it towards zero again to avoid that previous\n+\/\/ intermediate length short term behavior followed by a quiet time and a single\n+\/\/ short term event causes unnecessary resizes.\n+\/\/\n+\/\/ Long term behavior is solely managed by regularly comparing actual long term\n+\/\/ GC CPU usage with the boundaries of acceptable deviation range. If the actual\n+\/\/ long term GC CPU usage is outside this range, expand or shrink accordingly.\n+\/\/\n+\/\/ The mechanism is meant to filter out short term events because heap resizing\n+\/\/ has some overhead.\n+\/\/\n+\/\/ For full collections, we base resize decisions only on Min\/MaxHeapFreeRatio.\n+\/\/\n@@ -34,5 +69,0 @@\n-  \/\/ MinOverThresholdForGrowth must be less than the number of recorded\n-  \/\/ pause times in G1Analytics, representing the minimum number of pause\n-  \/\/ time ratios that exceed GCTimeRatio before a heap expansion will be triggered.\n-  const static uint MinOverThresholdForGrowth = 4;\n-\n@@ -42,5 +72,12 @@\n-  const uint _num_prev_pauses_for_heuristics;\n-  \/\/ Ratio check data for determining if heap growth is necessary.\n-  uint _ratio_over_threshold_count;\n-  double _ratio_over_threshold_sum;\n-  uint _pauses_since_start;\n+  \/\/ Number of times short-term GC CPU usage crossed the lower or upper threshold\n+  \/\/ recently; every time the upper threshold is exceeded, it is incremented, and\n+  \/\/ decremented if the lower threshold is exceeded.\n+  int _gc_cpu_usage_deviation_counter;\n+  \/\/ Recent GC CPU usage deviations relative to the gc_cpu_usage_target\n+  TruncatedSeq _recent_cpu_usage_deltas;\n+  uint _long_term_count;\n+\n+  \/\/ Clear GC CPU usage tracking data used by young_collection_resize_amount().\n+  void reset_cpu_usage_tracking_data();\n+  \/\/ Decay (move towards \"no changes\") GC CPU usage tracking data.\n+  void decay_cpu_usage_tracking_data();\n@@ -48,1 +85,1 @@\n-  \/\/ Scale \"full\" gc pause time threshold with heap size as we want to resize more\n+  \/\/ Scale the gc_cpu_usage_target with heap size as we want to resize more\n@@ -50,1 +87,7 @@\n-  double scale_with_heap(double pause_time_threshold);\n+  double scale_with_heap(double gc_cpu_usage_target);\n+\n+  \/\/ Scale the cpu usage delta depending on the relative difference from the target gc_cpu_usage.\n+  double scale_cpu_usage_delta(double cpu_usage_delta, double min_scale_factor, double max_scale_factor) const;\n+\n+  size_t young_collection_expand_amount(double cpu_usage_delta) const;\n+  size_t young_collection_shrink_amount(double cpu_usage_delta, size_t allocation_word_size) const;\n@@ -55,3 +98,7 @@\n-  \/\/ If an expansion would be appropriate, because recent GC overhead had\n-  \/\/ exceeded the desired limit, return an amount to expand by.\n-  size_t young_collection_expansion_amount();\n+  static constexpr uint long_term_count_limit() {\n+    return G1Analytics::max_num_of_recorded_pause_times();\n+  }\n+  \/\/ Return by how many bytes the heap should be changed based on recent GC CPU\n+  \/\/ usage after young collection. If expand is set, the heap should be expanded,\n+  \/\/ otherwise shrunk.\n+  size_t young_collection_resize_amount(bool& expand, size_t allocation_word_size);\n@@ -62,2 +109,0 @@\n-  \/\/ Clear ratio tracking data used by expansion_amount().\n-  void clear_ratio_check_data();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.hpp","additions":63,"deletions":18,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -478,1 +478,2 @@\n-  const size_t word_sz = old->size_given_klass(klass);\n+  const size_t old_size = old->size_given_mark_and_klass(old_mark, klass);\n+  const size_t word_sz = old->copy_size(old_size, old_mark);\n@@ -516,1 +517,1 @@\n-  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(old), obj_ptr, word_sz);\n+  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(old), obj_ptr, old_size);\n@@ -533,0 +534,2 @@\n+    obj->initialize_hash_if_necessary(old);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1062,1 +1062,1 @@\n-  _g1h->expand_heap_after_young_collection();\n+  _g1h->resize_heap_after_young_collection(_allocation_word_size);\n@@ -1077,1 +1077,2 @@\n-G1YoungCollector::G1YoungCollector(GCCause::Cause gc_cause) :\n+G1YoungCollector::G1YoungCollector(GCCause::Cause gc_cause,\n+                                   size_t allocation_word_size) :\n@@ -1080,0 +1081,1 @@\n+  _allocation_word_size(allocation_word_size),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,0 +82,1 @@\n+  size_t _allocation_word_size;\n@@ -140,1 +141,2 @@\n-  G1YoungCollector(GCCause::Cause gc_cause);\n+  G1YoungCollector(GCCause::Cause gc_cause,\n+                   size_t allocation_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -161,1 +161,2 @@\n-          \"When expanding, % of uncommitted space to claim.\")               \\\n+          \"When expanding, % of uncommitted space to expand the heap by in \"\\\n+          \"a single expand attempt.\")                                       \\\n@@ -164,0 +165,26 @@\n+  product(uint, G1ShrinkByPercentOfAvailable, 50, DIAGNOSTIC,               \\\n+          \"When shrinking, maximum % of free space to free for a single \"   \\\n+          \"shrink attempt.\")                                                \\\n+          range(0, 100)                                                     \\\n+                                                                            \\\n+  product(uint, G1CPUUsageDeviationPercent, 25, DIAGNOSTIC,                 \\\n+          \"The acceptable deviation (in percent) from the target GC CPU \"   \\\n+          \"usage (based on GCTimeRatio). Creates a tolerance range \"        \\\n+          \"around the target to deal with short-term fluctuations without \" \\\n+          \"triggering GC resizing mechanism prematurely.\")                  \\\n+          range(0, 100)                                                     \\\n+                                                                            \\\n+  product(uint, G1CPUUsageExpandThreshold, 4, DIAGNOSTIC,                   \\\n+          \"If the GC CPU usage deviation counter exceeds this threshold, \"  \\\n+          \"a heap expansion may be triggered. The counter is incremented \"  \\\n+          \"when short-term GC CPU usage exceeds the upper bound of the \"    \\\n+          \"acceptable deviation range.\")                                    \\\n+          constraint(G1CPUUsageExpandConstraintFunc, AfterErgo)             \\\n+                                                                            \\\n+  product(uint, G1CPUUsageShrinkThreshold, 8, DIAGNOSTIC,                   \\\n+          \"If the GC CPU usage deviation counter drops below the negative \" \\\n+          \"of this threshold, a heap shrink may be triggered. The counter \" \\\n+          \"is decremented when short-term GC CPU usage is below the lower \" \\\n+          \"bound of acceptable deviation range.\")                           \\\n+          constraint(G1CPUUsageShrinkConstraintFunc, AfterErgo)             \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/g1\/g1HeapSizingPolicy.hpp\"\n@@ -213,0 +214,29 @@\n+\n+JVMFlag::Error gc_cpu_usage_threshold_helper(JVMFlagsEnum flagid,\n+                                             uint value,\n+                                             bool verbose) {\n+  if (UseG1GC) {\n+    JVMFlag* flag = JVMFlag::flag_from_enum(flagid);\n+    const uint min_count = 1;\n+    const uint max_count = G1HeapSizingPolicy::long_term_count_limit();\n+    if (value < min_count || value > max_count) {\n+      JVMFlag::printError(verbose,\n+                          \"%s (%u) must be in range [%u, %u]\\n\",\n+                          flag->name(), value, min_count, max_count);\n+      return JVMFlag::VIOLATES_CONSTRAINT;\n+    }\n+  }\n+  return JVMFlag::SUCCESS;\n+}\n+\n+JVMFlag::Error G1CPUUsageExpandConstraintFunc(uint value, bool verbose) {\n+  return gc_cpu_usage_threshold_helper(FLAG_MEMBER_ENUM(G1CPUUsageExpandThreshold),\n+                                       value,\n+                                       verbose);\n+}\n+\n+JVMFlag::Error G1CPUUsageShrinkConstraintFunc(uint value, bool verbose) {\n+  return gc_cpu_usage_threshold_helper(FLAG_MEMBER_ENUM(G1CPUUsageShrinkThreshold),\n+                                       value,\n+                                       verbose);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,4 @@\n+                                                      \\\n+  \/* G1 GC deviation counter threshold constraints *\/ \\\n+  f(uint, G1CPUUsageExpandConstraintFunc)             \\\n+  f(uint, G1CPUUsageShrinkConstraintFunc)             \\\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/shared\/fullGCForwarding.hpp\"\n@@ -97,2 +96,0 @@\n-\n-  FullGCForwarding::initialize_flags(heap_reserved_size_bytes());\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelArguments.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/parallel\/psParallelCompactNew.inline.hpp\"\n@@ -122,2 +123,8 @@\n-  if (!PSParallelCompact::initialize_aux_data()) {\n-    return JNI_ENOMEM;\n+  if (UseCompactObjectHeaders) {\n+    if (!PSParallelCompactNew::initialize_aux_data()) {\n+      return JNI_ENOMEM;\n+    }\n+  } else {\n+    if (!PSParallelCompact::initialize_aux_data()) {\n+      return JNI_ENOMEM;\n+    }\n@@ -186,1 +193,5 @@\n-  PSParallelCompact::post_initialize();\n+  if (UseCompactObjectHeaders) {\n+    PSParallelCompactNew::post_initialize();\n+  } else {\n+    PSParallelCompact::post_initialize();\n+  }\n@@ -387,1 +398,5 @@\n-  PSParallelCompact::invoke(clear_all_soft_refs);\n+  if (UseCompactObjectHeaders) {\n+    PSParallelCompactNew::invoke(clear_all_soft_refs, false \/* serial *\/);\n+  } else {\n+    PSParallelCompact::invoke(clear_all_soft_refs);\n+  }\n@@ -425,1 +440,5 @@\n-    PSParallelCompact::invoke(clear_all_soft_refs);\n+    if (UseCompactObjectHeaders) {\n+      PSParallelCompactNew::invoke(clear_all_soft_refs, false \/* serial *\/);\n+    } else {\n+      PSParallelCompact::invoke(clear_all_soft_refs);\n+    }\n@@ -436,0 +455,9 @@\n+  if (UseCompactObjectHeaders) {\n+    PSParallelCompactNew::invoke(true \/* clear_soft_refs *\/, true \/* serial *\/);\n+  }\n+\n+  result = expand_heap_and_allocate(size, is_tlab);\n+  if (result != nullptr) {\n+    return result;\n+  }\n+\n@@ -518,1 +546,5 @@\n-  PSParallelCompact::invoke(clear_soft_refs);\n+  if (UseCompactObjectHeaders) {\n+    PSParallelCompactNew::invoke(clear_soft_refs, false \/* serial *\/);\n+  } else {\n+    PSParallelCompact::invoke(clear_soft_refs);\n+  }\n@@ -661,1 +693,5 @@\n-  PSParallelCompact::print_on(st);\n+  if (UseCompactObjectHeaders) {\n+    PSParallelCompactNew::print_on(st);\n+  } else {\n+    PSParallelCompact::print_on(st);\n+  }\n@@ -671,1 +707,5 @@\n-  log_debug(gc, heap, exit)(\"Accumulated old generation GC time %3.7f secs\", PSParallelCompact::accumulated_time()->seconds());\n+  if (UseCompactObjectHeaders) {\n+    log_debug(gc, heap, exit)(\"Accumulated old generation GC time %3.7f secs\", PSParallelCompactNew::accumulated_time()->seconds());\n+  } else {\n+    log_debug(gc, heap, exit)(\"Accumulated old generation GC time %3.7f secs\", PSParallelCompact::accumulated_time()->seconds());\n+  }\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":48,"deletions":8,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -114,0 +114,3 @@\n+  void print_tracing_info() const override;\n+  void stop() override {};\n+\n@@ -215,1 +218,0 @@\n-  void print_tracing_info() const override;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"gc\/parallel\/objectStartArray.hpp\"\n+#include \"gc\/parallel\/parMarkBitMap.inline.hpp\"\n+#include \"gc\/parallel\/parallelScavengeHeap.hpp\"\n+#include \"gc\/parallel\/psCompactionManagerNew.inline.hpp\"\n+#include \"gc\/parallel\/psOldGen.hpp\"\n+#include \"gc\/parallel\/psParallelCompactNew.inline.hpp\"\n+#include \"gc\/shared\/partialArraySplitter.inline.hpp\"\n+#include \"gc\/shared\/partialArrayState.hpp\"\n+#include \"gc\/shared\/preservedMarks.inline.hpp\"\n+#include \"memory\/iterator.inline.hpp\"\n+\n+PSOldGen*                  ParCompactionManagerNew::_old_gen = nullptr;\n+ParCompactionManagerNew**  ParCompactionManagerNew::_manager_array = nullptr;\n+\n+ParCompactionManagerNew::PSMarkTasksQueueSet*  ParCompactionManagerNew::_marking_stacks = nullptr;\n+PartialArrayStateManager* ParCompactionManagerNew::_partial_array_state_manager = nullptr;\n+\n+ObjectStartArray*    ParCompactionManagerNew::_start_array = nullptr;\n+ParMarkBitMap*       ParCompactionManagerNew::_mark_bitmap = nullptr;\n+\n+PreservedMarksSet* ParCompactionManagerNew::_preserved_marks_set = nullptr;\n+\n+ParCompactionManagerNew::ParCompactionManagerNew(PreservedMarks* preserved_marks,\n+                                           ReferenceProcessor* ref_processor,\n+                                           uint parallel_gc_threads)\n+  :_partial_array_splitter(_partial_array_state_manager, parallel_gc_threads, ObjArrayMarkingStride),\n+   _mark_and_push_closure(this, ref_processor) {\n+\n+  _old_gen = ParallelScavengeHeap::old_gen();\n+  _start_array = old_gen()->start_array();\n+\n+  _preserved_marks = preserved_marks;\n+}\n+\n+void ParCompactionManagerNew::initialize(ParMarkBitMap* mbm) {\n+  assert(ParallelScavengeHeap::heap() != nullptr, \"Needed for initialization\");\n+  assert(PSParallelCompactNew::ref_processor() != nullptr, \"precondition\");\n+  assert(ParallelScavengeHeap::heap()->workers().max_workers() != 0, \"Not initialized?\");\n+\n+  _mark_bitmap = mbm;\n+\n+  uint parallel_gc_threads = ParallelScavengeHeap::heap()->workers().max_workers();\n+\n+  assert(_manager_array == nullptr, \"Attempt to initialize twice\");\n+  _manager_array = NEW_C_HEAP_ARRAY(ParCompactionManagerNew*, parallel_gc_threads, mtGC);\n+\n+  assert(_partial_array_state_manager == nullptr, \"Attempt to initialize twice\");\n+  _partial_array_state_manager\n+    = new PartialArrayStateManager(parallel_gc_threads);\n+  _marking_stacks = new PSMarkTasksQueueSet(parallel_gc_threads);\n+\n+  _preserved_marks_set = new PreservedMarksSet(true);\n+  _preserved_marks_set->init(parallel_gc_threads);\n+\n+  \/\/ Create and register the ParCompactionManagerNew(s) for the worker threads.\n+  for(uint i=0; i<parallel_gc_threads; i++) {\n+    _manager_array[i] = new ParCompactionManagerNew(_preserved_marks_set->get(i),\n+                                                 PSParallelCompactNew::ref_processor(),\n+                                                 parallel_gc_threads);\n+    marking_stacks()->register_queue(i, _manager_array[i]->marking_stack());\n+  }\n+}\n+\n+void ParCompactionManagerNew::flush_all_string_dedup_requests() {\n+  uint parallel_gc_threads = ParallelScavengeHeap::heap()->workers().max_workers();\n+  for (uint i=0; i<parallel_gc_threads; i++) {\n+    _manager_array[i]->flush_string_dedup_requests();\n+  }\n+}\n+\n+ParCompactionManagerNew*\n+ParCompactionManagerNew::gc_thread_compaction_manager(uint index) {\n+  assert(index < ParallelGCThreads, \"index out of range\");\n+  assert(_manager_array != nullptr, \"Sanity\");\n+  return _manager_array[index];\n+}\n+\n+void ParCompactionManagerNew::push_objArray(oop obj) {\n+  assert(obj->is_objArray(), \"precondition\");\n+  _mark_and_push_closure.do_klass(obj->klass());\n+\n+  objArrayOop obj_array = objArrayOop(obj);\n+  size_t array_length = obj_array->length();\n+  size_t initial_chunk_size =\n+    _partial_array_splitter.start(&_marking_stack, obj_array, nullptr, array_length);\n+  follow_array(obj_array, 0, initial_chunk_size);\n+}\n+\n+void ParCompactionManagerNew::process_array_chunk(PartialArrayState* state, bool stolen) {\n+  \/\/ Access before release by claim().\n+  oop obj = state->source();\n+  PartialArraySplitter::Claim claim =\n+    _partial_array_splitter.claim(state, &_marking_stack, stolen);\n+  follow_array(objArrayOop(obj), claim._start, claim._end);\n+}\n+\n+void ParCompactionManagerNew::follow_marking_stacks() {\n+  ScannerTask task;\n+  do {\n+    \/\/ First, try to move tasks from the overflow stack into the shared buffer, so\n+    \/\/ that other threads can steal. Otherwise process the overflow stack first.\n+    while (marking_stack()->pop_overflow(task)) {\n+      if (!marking_stack()->try_push_to_taskqueue(task)) {\n+        follow_contents(task, false);\n+      }\n+    }\n+    while (marking_stack()->pop_local(task)) {\n+      follow_contents(task, false);\n+    }\n+  } while (!marking_stack_empty());\n+\n+  assert(marking_stack_empty(), \"Sanity\");\n+}\n+\n+#if TASKQUEUE_STATS\n+void ParCompactionManagerNew::print_and_reset_taskqueue_stats() {\n+  marking_stacks()->print_and_reset_taskqueue_stats(\"Marking Stacks\");\n+\n+  auto get_pa_stats = [&](uint i) {\n+    return _manager_array[i]->partial_array_task_stats();\n+  };\n+  PartialArrayTaskStats::log_set(ParallelGCThreads, get_pa_stats,\n+                                 \"Partial Array Task Stats\");\n+  uint parallel_gc_threads = ParallelScavengeHeap::heap()->workers().max_workers();\n+  for (uint i = 0; i < parallel_gc_threads; ++i) {\n+    get_pa_stats(i)->reset();\n+  }\n+}\n+\n+PartialArrayTaskStats* ParCompactionManagerNew::partial_array_task_stats() {\n+  return _partial_array_splitter.stats();\n+}\n+#endif \/\/ TASKQUEUE_STATS\n+\n+#ifdef ASSERT\n+void ParCompactionManagerNew::verify_all_marking_stack_empty() {\n+  uint parallel_gc_threads = ParallelGCThreads;\n+  for (uint i = 0; i < parallel_gc_threads; i++) {\n+    assert(_manager_array[i]->marking_stack_empty(), \"Marking stack should be empty\");\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManagerNew.cpp","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -552,1 +552,1 @@\n-class PCAdjustPointerClosure: public BasicOopIterateClosure {\n+class PCAdjustPointerClosureNew: public BasicOopIterateClosure {\n@@ -563,1 +563,1 @@\n-static PCAdjustPointerClosure pc_adjust_pointer_closure;\n+static PCAdjustPointerClosureNew pc_adjust_pointer_closure;\n@@ -1060,0 +1060,2 @@\n+    FullGCForwarding::begin();\n+\n@@ -1066,0 +1068,2 @@\n+    FullGCForwarding::end();\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,1146 @@\n+\/*\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"code\/codeCache.hpp\"\n+#include \"compiler\/oopMap.hpp\"\n+#include \"gc\/parallel\/objectStartArray.inline.hpp\"\n+#include \"gc\/parallel\/parallelArguments.hpp\"\n+#include \"gc\/parallel\/parallelScavengeHeap.inline.hpp\"\n+#include \"gc\/parallel\/parMarkBitMap.inline.hpp\"\n+#include \"gc\/parallel\/psAdaptiveSizePolicy.hpp\"\n+#include \"gc\/parallel\/psCompactionManagerNew.inline.hpp\"\n+#include \"gc\/parallel\/psOldGen.hpp\"\n+#include \"gc\/parallel\/psParallelCompactNew.inline.hpp\"\n+#include \"gc\/parallel\/psPromotionManager.inline.hpp\"\n+#include \"gc\/parallel\/psScavenge.hpp\"\n+#include \"gc\/parallel\/psYoungGen.hpp\"\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n+#include \"gc\/shared\/fullGCForwarding.inline.hpp\"\n+#include \"gc\/shared\/gcCause.hpp\"\n+#include \"gc\/shared\/gcHeapSummary.hpp\"\n+#include \"gc\/shared\/gcId.hpp\"\n+#include \"gc\/shared\/gcLocker.hpp\"\n+#include \"gc\/shared\/gcTimer.hpp\"\n+#include \"gc\/shared\/gcTrace.hpp\"\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n+#include \"gc\/shared\/gcVMOperations.hpp\"\n+#include \"gc\/shared\/isGCActiveMark.hpp\"\n+#include \"gc\/shared\/oopStorageSetParState.inline.hpp\"\n+#include \"gc\/shared\/preservedMarks.inline.hpp\"\n+#include \"gc\/shared\/referencePolicy.hpp\"\n+#include \"gc\/shared\/referenceProcessor.hpp\"\n+#include \"gc\/shared\/referenceProcessorPhaseTimes.hpp\"\n+#include \"gc\/shared\/spaceDecorator.hpp\"\n+#include \"gc\/shared\/strongRootsScope.hpp\"\n+#include \"gc\/shared\/taskTerminator.hpp\"\n+#include \"gc\/shared\/weakProcessor.inline.hpp\"\n+#include \"gc\/shared\/workerPolicy.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n+#include \"gc\/shared\/workerUtils.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/iterator.inline.hpp\"\n+#include \"memory\/memoryReserver.hpp\"\n+#include \"memory\/metaspaceUtils.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"nmt\/memTracker.hpp\"\n+#include \"oops\/methodData.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/threads.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+#include \"services\/memoryService.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/events.hpp\"\n+#include \"utilities\/formatBuffer.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmci.hpp\"\n+#endif\n+\n+SpaceInfoNew PSParallelCompactNew::_space_info[PSParallelCompactNew::last_space_id];\n+\n+size_t PSParallelCompactNew::_num_regions;\n+PCRegionData* PSParallelCompactNew::_region_data_array;\n+size_t PSParallelCompactNew::_num_regions_serial;\n+PCRegionData* PSParallelCompactNew::_region_data_array_serial;\n+PCRegionData** PSParallelCompactNew::_per_worker_region_data;\n+bool PSParallelCompactNew::_serial = false;\n+\n+SpanSubjectToDiscoveryClosure PSParallelCompactNew::_span_based_discoverer;\n+ReferenceProcessor* PSParallelCompactNew::_ref_processor = nullptr;\n+\n+void PSParallelCompactNew::print_on(outputStream* st) {\n+  _mark_bitmap.print_on(st);\n+}\n+\n+STWGCTimer          PSParallelCompactNew::_gc_timer;\n+ParallelOldTracer   PSParallelCompactNew::_gc_tracer;\n+elapsedTimer        PSParallelCompactNew::_accumulated_time;\n+unsigned int        PSParallelCompactNew::_maximum_compaction_gc_num = 0;\n+CollectorCounters*  PSParallelCompactNew::_counters = nullptr;\n+ParMarkBitMap       PSParallelCompactNew::_mark_bitmap;\n+\n+PSParallelCompactNew::IsAliveClosure PSParallelCompactNew::_is_alive_closure;\n+\n+class PCAdjustPointerClosure: public BasicOopIterateClosure {\n+  template <typename T>\n+  void do_oop_work(T* p) { PSParallelCompactNew::adjust_pointer(p); }\n+\n+public:\n+  void do_oop(oop* p) final          { do_oop_work(p); }\n+  void do_oop(narrowOop* p) final    { do_oop_work(p); }\n+\n+  ReferenceIterationMode reference_iteration_mode() final { return DO_FIELDS; }\n+};\n+\n+static PCAdjustPointerClosure pc_adjust_pointer_closure;\n+\n+class IsAliveClosure: public BoolObjectClosure {\n+public:\n+  bool do_object_b(oop p) final;\n+};\n+\n+\n+bool PSParallelCompactNew::IsAliveClosure::do_object_b(oop p) { return mark_bitmap()->is_marked(p); }\n+\n+void PSParallelCompactNew::post_initialize() {\n+  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n+  _span_based_discoverer.set_span(heap->reserved_region());\n+  _ref_processor =\n+    new ReferenceProcessor(&_span_based_discoverer,\n+                           ParallelGCThreads,   \/\/ mt processing degree\n+                           ParallelGCThreads,   \/\/ mt discovery degree\n+                           false,               \/\/ concurrent_discovery\n+                           &_is_alive_closure); \/\/ non-header is alive closure\n+\n+  _counters = new CollectorCounters(\"Parallel full collection pauses\", 1);\n+\n+  \/\/ Initialize static fields in ParCompactionManager.\n+  ParCompactionManagerNew::initialize(mark_bitmap());\n+}\n+\n+bool PSParallelCompactNew::initialize_aux_data() {\n+  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n+  MemRegion mr = heap->reserved_region();\n+  assert(mr.byte_size() != 0, \"heap should be reserved\");\n+\n+  initialize_space_info();\n+\n+  if (!_mark_bitmap.initialize(mr)) {\n+    vm_shutdown_during_initialization(\n+      err_msg(\"Unable to allocate %zuKB bitmaps for parallel \"\n+      \"garbage collection for the requested %zuKB heap.\",\n+      _mark_bitmap.reserved_byte_size()\/K, mr.byte_size()\/K));\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+void PSParallelCompactNew::initialize_space_info()\n+{\n+  memset(&_space_info, 0, sizeof(_space_info));\n+\n+  PSYoungGen* young_gen = ParallelScavengeHeap::young_gen();\n+\n+  _space_info[old_space_id].set_space(ParallelScavengeHeap::old_gen()->object_space());\n+  _space_info[eden_space_id].set_space(young_gen->eden_space());\n+  _space_info[from_space_id].set_space(young_gen->from_space());\n+  _space_info[to_space_id].set_space(young_gen->to_space());\n+\n+  _space_info[old_space_id].set_start_array(ParallelScavengeHeap::old_gen()->start_array());\n+}\n+\n+void\n+PSParallelCompactNew::clear_data_covering_space(SpaceId id)\n+{\n+  \/\/ At this point, top is the value before GC, new_top() is the value that will\n+  \/\/ be set at the end of GC.  The marking bitmap is cleared to top; nothing\n+  \/\/ should be marked above top.\n+  MutableSpace* const space = _space_info[id].space();\n+  HeapWord* const bot = space->bottom();\n+  HeapWord* const top = space->top();\n+\n+  _mark_bitmap.clear_range(bot, top);\n+}\n+\n+void PSParallelCompactNew::pre_compact()\n+{\n+  \/\/ Update the from & to space pointers in space_info, since they are swapped\n+  \/\/ at each young gen gc.  Do the update unconditionally (even though a\n+  \/\/ promotion failure does not swap spaces) because an unknown number of young\n+  \/\/ collections will have swapped the spaces an unknown number of times.\n+  GCTraceTime(Debug, gc, phases) tm(\"Pre Compact\", &_gc_timer);\n+  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n+  _space_info[from_space_id].set_space(ParallelScavengeHeap::young_gen()->from_space());\n+  _space_info[to_space_id].set_space(ParallelScavengeHeap::young_gen()->to_space());\n+\n+  \/\/ Increment the invocation count\n+  heap->increment_total_collections(true);\n+\n+  CodeCache::on_gc_marking_cycle_start();\n+\n+  heap->print_before_gc();\n+  heap->trace_heap_before_gc(&_gc_tracer);\n+\n+  \/\/ Fill in TLABs\n+  heap->ensure_parsability(true);  \/\/ retire TLABs\n+\n+  if (VerifyBeforeGC && heap->total_collections() >= VerifyGCStartAt) {\n+    Universe::verify(\"Before GC\");\n+  }\n+\n+  DEBUG_ONLY(mark_bitmap()->verify_clear();)\n+}\n+\n+void PSParallelCompactNew::post_compact()\n+{\n+  GCTraceTime(Info, gc, phases) tm(\"Post Compact\", &_gc_timer);\n+\n+  CodeCache::on_gc_marking_cycle_finish();\n+  CodeCache::arm_all_nmethods();\n+\n+  for (unsigned int id = old_space_id; id < last_space_id; ++id) {\n+    \/\/ Clear the marking bitmap, summary data and split info.\n+    clear_data_covering_space(SpaceId(id));\n+  }\n+\n+  {\n+    PCRegionData* last_live[last_space_id];\n+    for (uint i = old_space_id; i < last_space_id; ++i) {\n+      last_live[i] = nullptr;\n+    }\n+\n+    \/\/ Figure out last region in each space that has live data.\n+    uint space_id = old_space_id;\n+    MutableSpace* space = _space_info[space_id].space();\n+    size_t num_regions = get_num_regions();\n+    PCRegionData* region_data_array = get_region_data_array();\n+    last_live[space_id] = &region_data_array[0];\n+    for (size_t idx = 0; idx < num_regions; idx++) {\n+      PCRegionData* rd = region_data_array + idx;\n+      if(!space->contains(rd->bottom())) {\n+        ++space_id;\n+        assert(space_id < last_space_id, \"invariant\");\n+        space = _space_info[space_id].space();\n+        log_develop_trace(gc, compaction)(\"Last live for space: %u: %zu\", space_id, idx);\n+        last_live[space_id] = rd;\n+      }\n+      assert(space->contains(rd->bottom()), \"next space should contain next region\");\n+      log_develop_trace(gc, compaction)(\"post-compact region: idx: %zu, bottom: \" PTR_FORMAT \", new_top: \" PTR_FORMAT \", end: \" PTR_FORMAT, rd->idx(), p2i(rd->bottom()), p2i(rd->new_top()), p2i(rd->end()));\n+      if (rd->new_top() > rd->bottom()) {\n+        last_live[space_id] = rd;\n+        log_develop_trace(gc, compaction)(\"Bump last live for space: %u\", space_id);\n+      }\n+    }\n+\n+    for (uint i = old_space_id; i < last_space_id; ++i) {\n+      PCRegionData* rd = last_live[i];\n+        log_develop_trace(gc, compaction)(\n+                \"Last live region in space: %u, compaction region, \" PTR_FORMAT \", #%zu: [\" PTR_FORMAT \", \" PTR_FORMAT \"), new_top: \" PTR_FORMAT,\n+                i, p2i(rd), rd->idx(),\n+                p2i(rd->bottom()), p2i(rd->end()), p2i(rd->new_top()));\n+    }\n+\n+    \/\/ Fill all gaps and update the space boundaries.\n+    space_id = old_space_id;\n+    space = _space_info[space_id].space();\n+    size_t total_live = 0;\n+    size_t total_waste = 0;\n+    for (size_t idx = 0; idx < num_regions; idx++) {\n+      PCRegionData* rd = &region_data_array[idx];\n+      PCRegionData* last_live_in_space = last_live[space_id];\n+      assert(last_live_in_space != nullptr, \"last live must not be null\");\n+      if (rd != last_live_in_space) {\n+        if (rd->new_top() < rd->end()) {\n+          ObjectStartArray* sa = start_array(SpaceId(space_id));\n+          if (sa != nullptr) {\n+            sa->update_for_block(rd->new_top(), rd->end());\n+          }\n+          ParallelScavengeHeap::heap()->fill_with_dummy_object(rd->new_top(), rd->end(), false);\n+        }\n+        size_t live = pointer_delta(rd->new_top(), rd->bottom());\n+        size_t waste = pointer_delta(rd->end(), rd->new_top());\n+        total_live += live;\n+        total_waste += waste;\n+        log_develop_trace(gc, compaction)(\n+                \"Live compaction region, #%zu: [\" PTR_FORMAT \", \" PTR_FORMAT \"), new_top: \" PTR_FORMAT \", live: %zu, waste: %zu\",\n+                rd->idx(),\n+                p2i(rd->bottom()), p2i(rd->end()), p2i(rd->new_top()), live, waste);\n+      } else {\n+        \/\/ Update top of space.\n+        space->set_top(rd->new_top());\n+        size_t live = pointer_delta(rd->new_top(), rd->bottom());\n+        total_live += live;\n+        log_develop_trace(gc, compaction)(\n+                \"Live compaction region, #%zu: [\" PTR_FORMAT \", \" PTR_FORMAT \"), new_top: \" PTR_FORMAT \", live: %zu, waste: %zu\",\n+                rd->idx(),\n+                p2i(rd->bottom()), p2i(rd->end()), p2i(rd->new_top()), live, size_t(0));\n+\n+        \/\/ Fast-Forward to next space.\n+        for (; idx < num_regions - 1; idx++) {\n+          rd = &region_data_array[idx + 1];\n+          if (!space->contains(rd->bottom())) {\n+            space_id++;\n+            assert(space_id < last_space_id, \"must be\");\n+            space = _space_info[space_id].space();\n+            assert(space->contains(rd->bottom()), \"space must contain region\");\n+            break;\n+          }\n+        }\n+      }\n+    }\n+    log_develop_debug(gc, compaction)(\"total live: %zu, total waste: %zu, ratio: %f\", total_live, total_waste, ((float)total_waste)\/((float)(total_live + total_waste)));\n+  }\n+  {\n+    FREE_C_HEAP_ARRAY(PCRegionData*, _per_worker_region_data);\n+    FREE_C_HEAP_ARRAY(PCRegionData, _region_data_array);\n+    FREE_C_HEAP_ARRAY(PCRegionData, _region_data_array_serial);\n+  }\n+#ifdef ASSERT\n+  {\n+    mark_bitmap()->verify_clear();\n+  }\n+#endif\n+\n+  ParCompactionManagerNew::flush_all_string_dedup_requests();\n+\n+  MutableSpace* const eden_space = _space_info[eden_space_id].space();\n+  MutableSpace* const from_space = _space_info[from_space_id].space();\n+  MutableSpace* const to_space   = _space_info[to_space_id].space();\n+\n+  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n+  bool eden_empty = eden_space->is_empty();\n+\n+  \/\/ Update heap occupancy information which is used as input to the soft ref\n+  \/\/ clearing policy at the next gc.\n+  Universe::heap()->update_capacity_and_used_at_gc();\n+\n+  bool young_gen_empty = eden_empty && from_space->is_empty() &&\n+    to_space->is_empty();\n+\n+  PSCardTable* ct = heap->card_table();\n+  MemRegion old_mr = ParallelScavengeHeap::old_gen()->committed();\n+  if (young_gen_empty) {\n+    ct->clear_MemRegion(old_mr);\n+  } else {\n+    ct->dirty_MemRegion(old_mr);\n+  }\n+\n+  {\n+    \/\/ Delete metaspaces for unloaded class loaders and clean up loader_data graph\n+    GCTraceTime(Debug, gc, phases) t(\"Purge Class Loader Data\", gc_timer());\n+    ClassLoaderDataGraph::purge(true \/* at_safepoint *\/);\n+    DEBUG_ONLY(MetaspaceUtils::verify();)\n+  }\n+\n+  \/\/ Need to clear claim bits for the next mark.\n+  ClassLoaderDataGraph::clear_claimed_marks();\n+\n+  heap->prune_scavengable_nmethods();\n+\n+#if COMPILER2_OR_JVMCI\n+  DerivedPointerTable::update_pointers();\n+#endif\n+\n+  \/\/ Signal that we have completed a visit to all live objects.\n+  Universe::heap()->record_whole_heap_examined_timestamp();\n+}\n+\n+void PSParallelCompactNew::setup_regions_parallel() {\n+  static const size_t REGION_SIZE_WORDS = (SpaceAlignment \/ HeapWordSize);\n+  size_t num_regions = 0;\n+  for (uint i = old_space_id; i < last_space_id; ++i) {\n+    MutableSpace* const space = _space_info[i].space();\n+    size_t const space_size_words = space->capacity_in_words();\n+    num_regions += align_up(space_size_words, REGION_SIZE_WORDS) \/ REGION_SIZE_WORDS;\n+  }\n+  _region_data_array = NEW_C_HEAP_ARRAY(PCRegionData, num_regions, mtGC);\n+\n+  size_t region_idx = 0;\n+  for (uint i = old_space_id; i < last_space_id; ++i) {\n+    const MutableSpace* space = _space_info[i].space();\n+    HeapWord* addr = space->bottom();\n+    HeapWord* sp_end = space->end();\n+    HeapWord* sp_top = space->top();\n+    while (addr < sp_end) {\n+      HeapWord* end = MIN2(align_up(addr + REGION_SIZE_WORDS, REGION_SIZE_WORDS), space->end());\n+      if (addr < sp_top) {\n+        HeapWord* prev_obj_start = _mark_bitmap.find_obj_beg_reverse(addr, end);\n+        if (prev_obj_start < end) {\n+          HeapWord* prev_obj_end = prev_obj_start + cast_to_oop(prev_obj_start)->size();\n+          if (end < prev_obj_end) {\n+            \/\/ Object crosses region boundary, adjust end to be after object's last word.\n+            end = prev_obj_end;\n+          }\n+        }\n+      }\n+      assert(region_idx < num_regions, \"must not exceed number of regions: region_idx: %zu, num_regions: %zu\", region_idx, num_regions);\n+      HeapWord* top;\n+      if (sp_top < addr) {\n+        top = addr;\n+      } else if (sp_top >= end) {\n+        top = end;\n+      } else {\n+        top = sp_top;\n+      }\n+      assert(ParallelScavengeHeap::heap()->is_in_reserved(addr), \"addr must be in heap: \" PTR_FORMAT, p2i(addr));\n+      new (_region_data_array + region_idx) PCRegionData(region_idx, addr, top, end);\n+      addr = end;\n+      region_idx++;\n+    }\n+  }\n+  _num_regions = region_idx;\n+  log_info(gc)(\"Number of regions: %zu\", _num_regions);\n+}\n+\n+void PSParallelCompactNew::setup_regions_serial() {\n+  _num_regions_serial = last_space_id;\n+  _region_data_array_serial = NEW_C_HEAP_ARRAY(PCRegionData, _num_regions_serial, mtGC);\n+  new (_region_data_array_serial + old_space_id)  PCRegionData(old_space_id, space(old_space_id)->bottom(), space(old_space_id)->top(), space(old_space_id)->end());\n+  new (_region_data_array_serial + eden_space_id) PCRegionData(eden_space_id, space(eden_space_id)->bottom(), space(eden_space_id)->top(), space(eden_space_id)->end());\n+  new (_region_data_array_serial + from_space_id) PCRegionData(from_space_id, space(from_space_id)->bottom(), space(from_space_id)->top(), space(from_space_id)->end());\n+  new (_region_data_array_serial + to_space_id)   PCRegionData(to_space_id, space(to_space_id)->bottom(), space(to_space_id)->top(), space(to_space_id)->end());\n+}\n+\n+bool PSParallelCompactNew::check_maximum_compaction() {\n+\n+  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n+\n+  \/\/ Check System.GC\n+  bool is_max_on_system_gc = UseMaximumCompactionOnSystemGC\n+                          && GCCause::is_user_requested_gc(heap->gc_cause());\n+\n+  \/\/ JVM flags\n+  const uint total_invocations = heap->total_full_collections();\n+  assert(total_invocations >= _maximum_compaction_gc_num, \"sanity\");\n+  const size_t gcs_since_max = total_invocations - _maximum_compaction_gc_num;\n+  const bool is_interval_ended = gcs_since_max > HeapMaximumCompactionInterval;\n+\n+  if (is_max_on_system_gc || is_interval_ended) {\n+    _maximum_compaction_gc_num = total_invocations;\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+void PSParallelCompactNew::summary_phase() {\n+  GCTraceTime(Info, gc, phases) tm(\"Summary Phase\", &_gc_timer);\n+\n+  setup_regions_serial();\n+  setup_regions_parallel();\n+\n+#ifndef PRODUCT\n+  for (size_t idx = 0; idx < _num_regions; idx++) {\n+    PCRegionData* rd = &_region_data_array[idx];\n+    log_develop_trace(gc, compaction)(\"Compaction region #%zu: [\" PTR_FORMAT \", \" PTR_FORMAT \")\", rd->idx(), p2i(\n+            rd->bottom()), p2i(rd->end()));\n+  }\n+#endif\n+}\n+\n+\/\/ This method should contain all heap-specific policy for invoking a full\n+\/\/ collection.  invoke_no_policy() will only attempt to compact the heap; it\n+\/\/ will do nothing further.  If we need to bail out for policy reasons, scavenge\n+\/\/ before full gc, or any other specialized behavior, it needs to be added here.\n+\/\/\n+\/\/ Note that this method should only be called from the vm_thread while at a\n+\/\/ safepoint.\n+\/\/\n+\/\/ Note that the all_soft_refs_clear flag in the soft ref policy\n+\/\/ may be true because this method can be called without intervening\n+\/\/ activity.  For example when the heap space is tight and full measure\n+\/\/ are being taken to free space.\n+bool PSParallelCompactNew::invoke(bool clear_all_soft_refs, bool serial) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"should be at safepoint\");\n+  assert(Thread::current() == (Thread*)VMThread::vm_thread(),\n+         \"should be in vm thread\");\n+\n+  SvcGCMarker sgcm(SvcGCMarker::FULL);\n+  IsSTWGCActiveMark mark;\n+\n+  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n+  clear_all_soft_refs = clear_all_soft_refs\n+                     || heap->soft_ref_policy()->should_clear_all_soft_refs();\n+\n+  return PSParallelCompactNew::invoke_no_policy(clear_all_soft_refs, serial);\n+}\n+\n+\/\/ This method contains no policy. You should probably\n+\/\/ be calling invoke() instead.\n+bool PSParallelCompactNew::invoke_no_policy(bool clear_all_soft_refs, bool serial) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"must be at a safepoint\");\n+  assert(ref_processor() != nullptr, \"Sanity\");\n+\n+  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n+\n+  GCIdMark gc_id_mark;\n+  _gc_timer.register_gc_start();\n+  _gc_tracer.report_gc_start(heap->gc_cause(), _gc_timer.gc_start());\n+\n+  GCCause::Cause gc_cause = heap->gc_cause();\n+  PSYoungGen* young_gen = ParallelScavengeHeap::young_gen();\n+  PSOldGen* old_gen = ParallelScavengeHeap::old_gen();\n+  PSAdaptiveSizePolicy* size_policy = heap->size_policy();\n+\n+  \/\/ The scope of casr should end after code that can change\n+  \/\/ SoftRefPolicy::_should_clear_all_soft_refs.\n+  ClearedAllSoftRefs casr(clear_all_soft_refs,\n+                          heap->soft_ref_policy());\n+\n+  \/\/ Make sure data structures are sane, make the heap parsable, and do other\n+  \/\/ miscellaneous bookkeeping.\n+  pre_compact();\n+\n+  const PreGenGCValues pre_gc_values = heap->get_pre_gc_values();\n+\n+  {\n+    const uint active_workers =\n+      WorkerPolicy::calc_active_workers(ParallelScavengeHeap::heap()->workers().max_workers(),\n+                                        ParallelScavengeHeap::heap()->workers().active_workers(),\n+                                        Threads::number_of_non_daemon_threads());\n+    ParallelScavengeHeap::heap()->workers().set_active_workers(active_workers);\n+\n+    if (serial || check_maximum_compaction()) {\n+      \/\/ Serial compaction executes the forwarding and compaction phases serially,\n+      \/\/ thus achieving perfect compaction.\n+      \/\/ Marking and ajust-references would still be executed in parallel threads.\n+      _serial = true;\n+    } else {\n+      _serial = false;\n+    }\n+\n+    GCTraceCPUTime tcpu(&_gc_tracer);\n+    GCTraceTime(Info, gc) tm(\"Pause Full\", nullptr, gc_cause, true);\n+\n+    heap->pre_full_gc_dump(&_gc_timer);\n+\n+    TraceCollectorStats tcs(counters());\n+    TraceMemoryManagerStats tms(heap->old_gc_manager(), gc_cause, \"end of major GC\");\n+\n+    if (log_is_enabled(Debug, gc, heap, exit)) {\n+      accumulated_time()->start();\n+    }\n+\n+    \/\/ Let the size policy know we're starting\n+    size_policy->major_collection_begin();\n+\n+#if COMPILER2_OR_JVMCI\n+    DerivedPointerTable::clear();\n+#endif\n+\n+    ref_processor()->start_discovery(clear_all_soft_refs);\n+\n+    ClassUnloadingContext ctx(1 \/* num_nmethod_unlink_workers *\/,\n+                              false \/* unregister_nmethods_during_purge *\/,\n+                              false \/* lock_nmethod_free_separately *\/);\n+\n+    marking_phase(&_gc_tracer);\n+\n+    summary_phase();\n+\n+#if COMPILER2_OR_JVMCI\n+    assert(DerivedPointerTable::is_active(), \"Sanity\");\n+    DerivedPointerTable::set_active(false);\n+#endif\n+\n+    FullGCForwarding::begin();\n+\n+    forward_to_new_addr();\n+\n+    adjust_pointers();\n+\n+    compact();\n+\n+    FullGCForwarding::end();\n+\n+    ParCompactionManagerNew::_preserved_marks_set->restore(&ParallelScavengeHeap::heap()->workers());\n+\n+    \/\/ Reset the mark bitmap, summary data, and do other bookkeeping.  Must be\n+    \/\/ done before resizing.\n+    post_compact();\n+\n+    \/\/ Let the size policy know we're done\n+    size_policy->major_collection_end(old_gen->used_in_bytes(), gc_cause);\n+\n+    if (UseAdaptiveSizePolicy) {\n+      log_debug(gc, ergo)(\"AdaptiveSizeStart: collection: %d \", heap->total_collections());\n+      log_trace(gc, ergo)(\"old_gen_capacity: %zu young_gen_capacity: %zu\",\n+                          old_gen->capacity_in_bytes(), young_gen->capacity_in_bytes());\n+\n+      \/\/ Don't check if the size_policy is ready here.  Let\n+      \/\/ the size_policy check that internally.\n+      if (UseAdaptiveGenerationSizePolicyAtMajorCollection &&\n+          AdaptiveSizePolicy::should_update_promo_stats(gc_cause)) {\n+        \/\/ Swap the survivor spaces if from_space is empty. The\n+        \/\/ resize_young_gen() called below is normally used after\n+        \/\/ a successful young GC and swapping of survivor spaces;\n+        \/\/ otherwise, it will fail to resize the young gen with\n+        \/\/ the current implementation.\n+        if (young_gen->from_space()->is_empty()) {\n+          young_gen->from_space()->clear(SpaceDecorator::Mangle);\n+          young_gen->swap_spaces();\n+        }\n+\n+        \/\/ Calculate optimal free space amounts\n+        assert(young_gen->max_gen_size() >\n+          young_gen->from_space()->capacity_in_bytes() +\n+          young_gen->to_space()->capacity_in_bytes(),\n+          \"Sizes of space in young gen are out-of-bounds\");\n+\n+        size_t young_live = young_gen->used_in_bytes();\n+        size_t eden_live = young_gen->eden_space()->used_in_bytes();\n+        size_t old_live = old_gen->used_in_bytes();\n+        size_t cur_eden = young_gen->eden_space()->capacity_in_bytes();\n+        size_t max_old_gen_size = old_gen->max_gen_size();\n+        size_t max_eden_size = young_gen->max_gen_size() -\n+          young_gen->from_space()->capacity_in_bytes() -\n+          young_gen->to_space()->capacity_in_bytes();\n+\n+        \/\/ Used for diagnostics\n+        size_policy->clear_generation_free_space_flags();\n+\n+        size_policy->compute_generations_free_space(young_live,\n+                                                    eden_live,\n+                                                    old_live,\n+                                                    cur_eden,\n+                                                    max_old_gen_size,\n+                                                    max_eden_size,\n+                                                    true \/* full gc*\/);\n+\n+        size_policy->check_gc_overhead_limit(eden_live,\n+                                             max_old_gen_size,\n+                                             max_eden_size,\n+                                             true \/* full gc*\/,\n+                                             gc_cause,\n+                                             heap->soft_ref_policy());\n+\n+        size_policy->decay_supplemental_growth(true \/* full gc*\/);\n+\n+        heap->resize_old_gen(\n+          size_policy->calculated_old_free_size_in_bytes());\n+\n+        heap->resize_young_gen(size_policy->calculated_eden_size_in_bytes(),\n+                               size_policy->calculated_survivor_size_in_bytes());\n+      }\n+\n+      log_debug(gc, ergo)(\"AdaptiveSizeStop: collection: %d \", heap->total_collections());\n+    }\n+\n+    if (UsePerfData) {\n+      PSGCAdaptivePolicyCounters* const counters = ParallelScavengeHeap::gc_policy_counters();\n+      counters->update_counters();\n+      counters->update_old_capacity(old_gen->capacity_in_bytes());\n+      counters->update_young_capacity(young_gen->capacity_in_bytes());\n+    }\n+\n+    heap->resize_all_tlabs();\n+\n+    \/\/ Resize the metaspace capacity after a collection\n+    MetaspaceGC::compute_new_size();\n+\n+    if (log_is_enabled(Debug, gc, heap, exit)) {\n+      accumulated_time()->stop();\n+    }\n+\n+    heap->print_heap_change(pre_gc_values);\n+\n+    \/\/ Track memory usage and detect low memory\n+    MemoryService::track_memory_usage();\n+    heap->update_counters();\n+\n+    heap->post_full_gc_dump(&_gc_timer);\n+  }\n+\n+  if (VerifyAfterGC && heap->total_collections() >= VerifyGCStartAt) {\n+    Universe::verify(\"After GC\");\n+  }\n+\n+  heap->print_after_gc();\n+  heap->trace_heap_after_gc(&_gc_tracer);\n+\n+  AdaptiveSizePolicyOutput::print(size_policy, heap->total_collections());\n+\n+  _gc_timer.register_gc_end();\n+\n+  _gc_tracer.report_gc_end(_gc_timer.gc_end(), _gc_timer.time_partitions());\n+\n+  return true;\n+}\n+\n+class PCAddThreadRootsMarkingTaskClosureNew : public ThreadClosure {\n+private:\n+  uint _worker_id;\n+\n+public:\n+  explicit PCAddThreadRootsMarkingTaskClosureNew(uint worker_id) : _worker_id(worker_id) { }\n+  void do_thread(Thread* thread) final {\n+    assert(ParallelScavengeHeap::heap()->is_stw_gc_active(), \"called outside gc\");\n+\n+    ResourceMark rm;\n+\n+    ParCompactionManagerNew* cm = ParCompactionManagerNew::gc_thread_compaction_manager(_worker_id);\n+\n+    MarkingNMethodClosure mark_and_push_in_blobs(&cm->_mark_and_push_closure,\n+                                                 !NMethodToOopClosure::FixRelocations,\n+                                                 true \/* keepalive nmethods *\/);\n+\n+    thread->oops_do(&cm->_mark_and_push_closure, &mark_and_push_in_blobs);\n+\n+    \/\/ Do the real work\n+    cm->follow_marking_stacks();\n+  }\n+};\n+\n+void steal_marking_work_new(TaskTerminator& terminator, uint worker_id) {\n+  assert(ParallelScavengeHeap::heap()->is_stw_gc_active(), \"called outside gc\");\n+\n+  ParCompactionManagerNew* cm =\n+    ParCompactionManagerNew::gc_thread_compaction_manager(worker_id);\n+\n+  do {\n+    ScannerTask task;\n+    if (ParCompactionManagerNew::steal(worker_id, task)) {\n+      cm->follow_contents(task, true);\n+    }\n+    cm->follow_marking_stacks();\n+  } while (!terminator.offer_termination());\n+}\n+\n+class MarkFromRootsTaskNew : public WorkerTask {\n+  StrongRootsScope _strong_roots_scope; \/\/ needed for Threads::possibly_parallel_threads_do\n+  OopStorageSetStrongParState<false \/* concurrent *\/, false \/* is_const *\/> _oop_storage_set_par_state;\n+  TaskTerminator _terminator;\n+  uint _active_workers;\n+\n+public:\n+  explicit MarkFromRootsTaskNew(uint active_workers) :\n+      WorkerTask(\"MarkFromRootsTaskNew\"),\n+      _strong_roots_scope(active_workers),\n+      _terminator(active_workers, ParCompactionManagerNew::marking_stacks()),\n+      _active_workers(active_workers) {}\n+\n+  void work(uint worker_id) final {\n+    ParCompactionManagerNew* cm = ParCompactionManagerNew::gc_thread_compaction_manager(worker_id);\n+    {\n+      CLDToOopClosure cld_closure(&cm->_mark_and_push_closure, ClassLoaderData::_claim_stw_fullgc_mark);\n+      ClassLoaderDataGraph::always_strong_cld_do(&cld_closure);\n+\n+      \/\/ Do the real work\n+      cm->follow_marking_stacks();\n+    }\n+\n+    {\n+      PCAddThreadRootsMarkingTaskClosureNew closure(worker_id);\n+      Threads::possibly_parallel_threads_do(_active_workers > 1 \/* is_par *\/, &closure);\n+    }\n+\n+    \/\/ Mark from OopStorages\n+    {\n+      _oop_storage_set_par_state.oops_do(&cm->_mark_and_push_closure);\n+      \/\/ Do the real work\n+      cm->follow_marking_stacks();\n+    }\n+\n+    if (_active_workers > 1) {\n+      steal_marking_work_new(_terminator, worker_id);\n+    }\n+  }\n+};\n+\n+class ParallelCompactRefProcProxyTaskNew : public RefProcProxyTask {\n+  TaskTerminator _terminator;\n+\n+public:\n+  explicit ParallelCompactRefProcProxyTaskNew(uint max_workers)\n+    : RefProcProxyTask(\"ParallelCompactRefProcProxyTaskNew\", max_workers),\n+      _terminator(_max_workers, ParCompactionManagerNew::marking_stacks()) {}\n+\n+  void work(uint worker_id) final {\n+    assert(worker_id < _max_workers, \"sanity\");\n+    ParCompactionManagerNew* cm = (_tm == RefProcThreadModel::Single) ? ParCompactionManagerNew::get_vmthread_cm() : ParCompactionManagerNew::gc_thread_compaction_manager(worker_id);\n+    BarrierEnqueueDiscoveredFieldClosure enqueue;\n+    ParCompactionManagerNew::FollowStackClosure complete_gc(cm, (_tm == RefProcThreadModel::Single) ? nullptr : &_terminator, worker_id);\n+    _rp_task->rp_work(worker_id, PSParallelCompactNew::is_alive_closure(), &cm->_mark_and_push_closure, &enqueue, &complete_gc);\n+  }\n+\n+  void prepare_run_task_hook() final {\n+    _terminator.reset_for_reuse(_queue_count);\n+  }\n+};\n+\n+void PSParallelCompactNew::marking_phase(ParallelOldTracer *gc_tracer) {\n+  \/\/ Recursively traverse all live objects and mark them\n+  GCTraceTime(Info, gc, phases) tm(\"Marking Phase\", &_gc_timer);\n+\n+  uint active_gc_threads = ParallelScavengeHeap::heap()->workers().active_workers();\n+\n+  ClassLoaderDataGraph::verify_claimed_marks_cleared(ClassLoaderData::_claim_stw_fullgc_mark);\n+  {\n+    GCTraceTime(Debug, gc, phases) pm_tm(\"Par Mark\", &_gc_timer);\n+\n+    MarkFromRootsTaskNew task(active_gc_threads);\n+    ParallelScavengeHeap::heap()->workers().run_task(&task);\n+  }\n+\n+  \/\/ Process reference objects found during marking\n+  {\n+    GCTraceTime(Debug, gc, phases) rp_tm(\"Reference Processing\", &_gc_timer);\n+\n+    ReferenceProcessorStats stats;\n+    ReferenceProcessorPhaseTimes pt(&_gc_timer, ref_processor()->max_num_queues());\n+\n+    ParallelCompactRefProcProxyTaskNew task(ref_processor()->max_num_queues());\n+    stats = ref_processor()->process_discovered_references(task, &ParallelScavengeHeap::heap()->workers(), pt);\n+\n+    gc_tracer->report_gc_reference_stats(stats);\n+    pt.print_all_references();\n+  }\n+\n+  \/\/ This is the point where the entire marking should have completed.\n+  ParCompactionManagerNew::verify_all_marking_stack_empty();\n+\n+  {\n+    GCTraceTime(Debug, gc, phases) wp_tm(\"Weak Processing\", &_gc_timer);\n+    WeakProcessor::weak_oops_do(&ParallelScavengeHeap::heap()->workers(),\n+                                is_alive_closure(),\n+                                &do_nothing_cl,\n+                                1);\n+  }\n+\n+  {\n+    GCTraceTime(Debug, gc, phases) tm_m(\"Class Unloading\", &_gc_timer);\n+\n+    ClassUnloadingContext* ctx = ClassUnloadingContext::context();\n+\n+    bool unloading_occurred;\n+    {\n+      CodeCache::UnlinkingScope scope(is_alive_closure());\n+\n+      \/\/ Follow system dictionary roots and unload classes.\n+      unloading_occurred = SystemDictionary::do_unloading(&_gc_timer);\n+\n+      \/\/ Unload nmethods.\n+      CodeCache::do_unloading(unloading_occurred);\n+    }\n+\n+    {\n+      GCTraceTime(Debug, gc, phases) t(\"Purge Unlinked NMethods\", gc_timer());\n+      \/\/ Release unloaded nmethod's memory.\n+      ctx->purge_nmethods();\n+    }\n+    {\n+      GCTraceTime(Debug, gc, phases) ur(\"Unregister NMethods\", &_gc_timer);\n+      ParallelScavengeHeap::heap()->prune_unlinked_nmethods();\n+    }\n+    {\n+      GCTraceTime(Debug, gc, phases) t(\"Free Code Blobs\", gc_timer());\n+      ctx->free_nmethods();\n+    }\n+\n+    \/\/ Prune dead klasses from subklass\/sibling\/implementor lists.\n+    Klass::clean_weak_klass_links(unloading_occurred);\n+\n+    \/\/ Clean JVMCI metadata handles.\n+    JVMCI_ONLY(JVMCI::do_unloading(unloading_occurred));\n+  }\n+\n+  {\n+    GCTraceTime(Debug, gc, phases) roc_tm(\"Report Object Count\", &_gc_timer);\n+    _gc_tracer.report_object_count_after_gc(is_alive_closure(), &ParallelScavengeHeap::heap()->workers());\n+  }\n+#if TASKQUEUE_STATS\n+  ParCompactionManagerNew::print_and_reset_taskqueue_stats();\n+#endif\n+}\n+\n+void PSParallelCompactNew::adjust_pointers_in_spaces(uint worker_id) {\n+  auto start_time = Ticks::now();\n+  for (size_t i = 0; i < _num_regions; i++) {\n+    PCRegionData* region = &_region_data_array[i];\n+    if (!region->claim()) {\n+      continue;\n+    }\n+    log_trace(gc, compaction)(\"Adjusting pointers in region: %zu (worker_id: %u)\", region->idx(), worker_id);\n+    HeapWord* end = region->top();\n+    HeapWord* current = _mark_bitmap.find_obj_beg(region->bottom(), end);\n+    while (current < end) {\n+      assert(_mark_bitmap.is_marked(current), \"must be marked\");\n+      oop obj = cast_to_oop(current);\n+      size_t size = obj->size();\n+      obj->oop_iterate(&pc_adjust_pointer_closure);\n+      current = _mark_bitmap.find_obj_beg(current + size, end);\n+    }\n+  }\n+  log_trace(gc, phases)(\"adjust_pointers_in_spaces worker %u: %.3f ms\", worker_id, (Ticks::now() - start_time).seconds() * 1000);\n+}\n+\n+class PSAdjustTaskNew final : public WorkerTask {\n+  SubTasksDone                               _sub_tasks;\n+  WeakProcessor::Task                        _weak_proc_task;\n+  OopStorageSetStrongParState<false, false>  _oop_storage_iter;\n+  uint                                       _nworkers;\n+\n+  enum PSAdjustSubTask {\n+    PSAdjustSubTask_code_cache,\n+\n+    PSAdjustSubTask_num_elements\n+  };\n+\n+public:\n+  explicit PSAdjustTaskNew(uint nworkers) :\n+    WorkerTask(\"PSAdjust task\"),\n+    _sub_tasks(PSAdjustSubTask_num_elements),\n+    _weak_proc_task(nworkers),\n+    _nworkers(nworkers) {\n+\n+    ClassLoaderDataGraph::verify_claimed_marks_cleared(ClassLoaderData::_claim_stw_fullgc_adjust);\n+    if (nworkers > 1) {\n+      Threads::change_thread_claim_token();\n+    }\n+  }\n+\n+  ~PSAdjustTaskNew() {\n+    Threads::assert_all_threads_claimed();\n+  }\n+\n+  void work(uint worker_id) final {\n+    ParCompactionManagerNew* cm = ParCompactionManagerNew::gc_thread_compaction_manager(worker_id);\n+    cm->preserved_marks()->adjust_during_full_gc();\n+    {\n+      \/\/ adjust pointers in all spaces\n+      PSParallelCompactNew::adjust_pointers_in_spaces(worker_id);\n+    }\n+    {\n+      ResourceMark rm;\n+      Threads::possibly_parallel_oops_do(_nworkers > 1, &pc_adjust_pointer_closure, nullptr);\n+    }\n+    _oop_storage_iter.oops_do(&pc_adjust_pointer_closure);\n+    {\n+      CLDToOopClosure cld_closure(&pc_adjust_pointer_closure, ClassLoaderData::_claim_stw_fullgc_adjust);\n+      ClassLoaderDataGraph::cld_do(&cld_closure);\n+    }\n+    {\n+      AlwaysTrueClosure always_alive;\n+      _weak_proc_task.work(worker_id, &always_alive, &pc_adjust_pointer_closure);\n+    }\n+    if (_sub_tasks.try_claim_task(PSAdjustSubTask_code_cache)) {\n+      NMethodToOopClosure adjust_code(&pc_adjust_pointer_closure, NMethodToOopClosure::FixRelocations);\n+      CodeCache::nmethods_do(&adjust_code);\n+    }\n+    _sub_tasks.all_tasks_claimed();\n+  }\n+};\n+\n+void PSParallelCompactNew::adjust_pointers() {\n+  \/\/ Adjust the pointers to reflect the new locations\n+  GCTraceTime(Info, gc, phases) tm(\"Adjust Pointers\", &_gc_timer);\n+  uint num_workers = ParallelScavengeHeap::heap()->workers().active_workers();\n+  PSAdjustTaskNew task(num_workers);\n+  ParallelScavengeHeap::heap()->workers().run_task(&task);\n+}\n+\n+void PSParallelCompactNew::forward_to_new_addr() {\n+  GCTraceTime(Info, gc, phases) tm(\"Forward\", &_gc_timer);\n+  uint num_workers = get_num_workers();\n+  _per_worker_region_data = NEW_C_HEAP_ARRAY(PCRegionData*, num_workers, mtGC);\n+  for (uint i = 0; i < num_workers; i++) {\n+    _per_worker_region_data[i] = nullptr;\n+  }\n+\n+  class ForwardState {\n+    uint _worker_id;\n+    PCRegionData* _compaction_region;\n+    HeapWord* _compaction_point;\n+\n+    void ensure_compaction_point() {\n+      if (_compaction_point == nullptr) {\n+        assert(_compaction_region == nullptr, \"invariant\");\n+        _compaction_region = _per_worker_region_data[_worker_id];\n+        assert(_compaction_region != nullptr, \"invariant\");\n+        _compaction_point = _compaction_region->bottom();\n+      }\n+    }\n+  public:\n+    explicit ForwardState(uint worker_id) :\n+            _worker_id(worker_id),\n+            _compaction_region(nullptr),\n+            _compaction_point(nullptr) {\n+    }\n+\n+    size_t available() const {\n+      return pointer_delta(_compaction_region->end(), _compaction_point);\n+    }\n+\n+    void forward_objs_in_region(ParCompactionManagerNew* cm, PCRegionData* region) {\n+      ensure_compaction_point();\n+      HeapWord* end = region->end();\n+      HeapWord* current = _mark_bitmap.find_obj_beg(region->bottom(), end);\n+      while (current < end) {\n+        assert(_mark_bitmap.is_marked(current), \"must be marked\");\n+        oop obj = cast_to_oop(current);\n+        assert(region->contains(obj), \"object must not cross region boundary: obj: \" PTR_FORMAT \", obj_end: \" PTR_FORMAT \", region start: \" PTR_FORMAT \", region end: \" PTR_FORMAT, p2i(obj), p2i(cast_from_oop<HeapWord*>(obj) + obj->size()), p2i(region->bottom()), p2i(region->end()));\n+        size_t old_size = obj->size();\n+        size_t new_size = obj->copy_size(old_size, obj->mark());\n+        size_t size = (current == _compaction_point) ? old_size : new_size;\n+        while (size > available()) {\n+          _compaction_region->set_new_top(_compaction_point);\n+          _compaction_region = _compaction_region->local_next();\n+          assert(_compaction_region != nullptr, \"must find a compaction region\");\n+          _compaction_point = _compaction_region->bottom();\n+          size = (current == _compaction_point) ? old_size : new_size;\n+        }\n+        \/\/log_develop_trace(gc, compaction)(\"Forwarding obj: \" PTR_FORMAT \", to: \" PTR_FORMAT, p2i(obj), p2i(_compaction_point));\n+        if (current != _compaction_point) {\n+          cm->preserved_marks()->push_if_necessary(obj, obj->mark());\n+          FullGCForwarding::forward_to(obj, cast_to_oop(_compaction_point));\n+        }\n+        _compaction_point += size;\n+        assert(_compaction_point <= _compaction_region->end(), \"object must fit in region\");\n+        current += old_size;\n+        assert(current <= end, \"object must not cross region boundary\");\n+        current = _mark_bitmap.find_obj_beg(current, end);\n+      }\n+    }\n+    void finish() {\n+      if (_compaction_region != nullptr) {\n+        _compaction_region->set_new_top(_compaction_point);\n+      }\n+    }\n+  };\n+\n+  struct ForwardTask final : public WorkerTask {\n+    ForwardTask() : WorkerTask(\"PSForward task\") {}\n+\n+    void work(uint worker_id) override {\n+      ParCompactionManagerNew* cm = ParCompactionManagerNew::gc_thread_compaction_manager(worker_id);\n+      ForwardState state(worker_id);\n+      PCRegionData** last_link = &_per_worker_region_data[worker_id];\n+      size_t idx = worker_id;\n+      uint num_workers = get_num_workers();\n+      size_t num_regions = get_num_regions();\n+      PCRegionData* region_data_array = get_region_data_array();\n+      while (idx < num_regions) {\n+        PCRegionData* region = region_data_array + idx;\n+        *last_link = region;\n+        last_link = region->local_next_addr();\n+        state.forward_objs_in_region(cm, region);\n+        idx += num_workers;\n+      }\n+      state.finish();\n+    }\n+  } task;\n+\n+  uint par_workers = ParallelScavengeHeap::heap()->workers().active_workers();\n+  ParallelScavengeHeap::heap()->workers().set_active_workers(num_workers);\n+  ParallelScavengeHeap::heap()->workers().run_task(&task);\n+  ParallelScavengeHeap::heap()->workers().set_active_workers(par_workers);\n+\n+#ifndef PRODUCT\n+  for (uint wid = 0; wid < num_workers; wid++) {\n+    for (PCRegionData* rd = _per_worker_region_data[wid]; rd != nullptr; rd = rd->local_next()) {\n+      log_develop_trace(gc, compaction)(\"Per worker compaction region, worker: %d, #%zu: [\" PTR_FORMAT \", \" PTR_FORMAT \"), new_top: \" PTR_FORMAT, wid, rd->idx(),\n+                                        p2i(rd->bottom()), p2i(rd->end()), p2i(rd->new_top()));\n+    }\n+  }\n+#endif\n+}\n+\n+void PSParallelCompactNew::compact() {\n+  GCTraceTime(Info, gc, phases) tm(\"Compaction Phase\", &_gc_timer);\n+  class CompactTask final : public WorkerTask {\n+    static void compact_region(PCRegionData* region) {\n+      HeapWord* bottom = region->bottom();\n+      HeapWord* end = region->top();\n+      if (bottom == end) {\n+        return;\n+      }\n+      HeapWord* current = _mark_bitmap.find_obj_beg(bottom, end);\n+      while (current < end) {\n+        oop obj = cast_to_oop(current);\n+        size_t size = obj->size();\n+        if (FullGCForwarding::is_forwarded(obj)) {\n+          oop fwd = FullGCForwarding::forwardee(obj);\n+          auto* dst = cast_from_oop<HeapWord*>(fwd);\n+          ObjectStartArray* sa = start_array(space_id(dst));\n+          if (sa != nullptr) {\n+            assert(dst != current, \"expect moving object\");\n+            size_t new_words = obj->copy_size(size, obj->mark());\n+            sa->update_for_block(dst, dst + new_words);\n+          }\n+\n+          Copy::aligned_conjoint_words(current, dst, size);\n+          fwd->init_mark();\n+          fwd->initialize_hash_if_necessary(obj);\n+        } else {\n+          \/\/ The start_array must be updated even if the object is not moving.\n+          ObjectStartArray* sa = start_array(space_id(current));\n+          if (sa != nullptr) {\n+            sa->update_for_block(current, current + size);\n+          }\n+        }\n+        current = _mark_bitmap.find_obj_beg(current + size, end);\n+      }\n+    }\n+  public:\n+    explicit CompactTask() : WorkerTask(\"PSCompact task\") {}\n+    void work(uint worker_id) override {\n+      PCRegionData* region = _per_worker_region_data[worker_id];\n+      while (region != nullptr) {\n+        log_trace(gc)(\"Compact worker: %u, compacting region: %zu\", worker_id, region->idx());\n+        compact_region(region);\n+        region = region->local_next();\n+      }\n+    }\n+  } task;\n+\n+  uint num_workers = get_num_workers();\n+  uint par_workers = ParallelScavengeHeap::heap()->workers().active_workers();\n+  ParallelScavengeHeap::heap()->workers().set_active_workers(num_workers);\n+  ParallelScavengeHeap::heap()->workers().run_task(&task);\n+  ParallelScavengeHeap::heap()->workers().set_active_workers(par_workers);\n+}\n+\n+\/\/ Return the SpaceId for the space containing addr.  If addr is not in the\n+\/\/ heap, last_space_id is returned.  In debug mode it expects the address to be\n+\/\/ in the heap and asserts such.\n+PSParallelCompactNew::SpaceId PSParallelCompactNew::space_id(HeapWord* addr) {\n+  assert(ParallelScavengeHeap::heap()->is_in_reserved(addr), \"addr not in the heap\");\n+\n+  for (unsigned int id = old_space_id; id < last_space_id; ++id) {\n+    if (_space_info[id].space()->contains(addr)) {\n+      return SpaceId(id);\n+    }\n+  }\n+\n+  assert(false, \"no space contains the addr\");\n+  return last_space_id;\n+}\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompactNew.cpp","additions":1146,"deletions":0,"binary":false,"changes":1146,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/parallel\/psCompactionManagerNew.hpp\"\n@@ -206,1 +207,1 @@\n-      _terminator(max_workers, ParCompactionManager::marking_stacks()) {}\n+      _terminator(max_workers, UseCompactObjectHeaders ? ParCompactionManagerNew::marking_stacks() : ParCompactionManager::marking_stacks()) {}\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -691,7 +691,1 @@\n-      if (obj->is_self_forwarded()) {\n-        obj->unset_self_forwarded();\n-      } else if (obj->is_forwarded()) {\n-        \/\/ To restore the klass-bits in the header.\n-        \/\/ Needed for object iteration to work properly.\n-        obj->set_mark(obj->forwardee()->prototype_mark());\n-      }\n+      obj->reset_forwarded();\n@@ -728,1 +722,3 @@\n-  size_t s = old->size();\n+  size_t old_size = old->size();\n+  size_t s = old->copy_size(old_size, old->mark());\n+\n@@ -753,1 +749,1 @@\n-  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(old), cast_from_oop<HeapWord*>(obj), s);\n+  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(old), cast_from_oop<HeapWord*>(obj), old_size);\n@@ -763,0 +759,2 @@\n+  obj->initialize_hash_if_necessary(old);\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"gc\/shared\/fullGCForwarding.hpp\"\n@@ -30,5 +29,0 @@\n-void SerialArguments::initialize() {\n-  GCArguments::initialize();\n-  FullGCForwarding::initialize_flags(MaxHeapSize);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialArguments.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -193,1 +193,2 @@\n-  HeapWord* alloc(size_t words) {\n+  HeapWord* alloc(size_t old_size, size_t new_size, HeapWord* old_obj) {\n+    size_t words = (old_obj == _spaces[_index]._compaction_top) ? old_size : new_size;\n@@ -209,0 +210,1 @@\n+      words = (old_obj == _spaces[_index]._compaction_top) ? old_size : new_size;\n@@ -230,1 +232,1 @@\n-  static void forward_obj(oop obj, HeapWord* new_addr) {\n+  static void forward_obj(oop obj, HeapWord* new_addr, bool after_first_dead) {\n@@ -236,2 +238,7 @@\n-      \/\/ This obj will stay in-place. Fix the markword.\n-      obj->init_mark();\n+      if (!after_first_dead) {\n+        \/\/ This obj will stay in-place and we'll not see it during relocation.\n+        \/\/ Fix the markword.\n+        obj->init_mark();\n+      } else {\n+        FullGCForwarding::forward_to(obj, cast_to_oop(new_addr));\n+      }\n@@ -260,2 +267,0 @@\n-    assert(addr != new_addr, \"inv\");\n-    prefetch_write_copy(new_addr);\n@@ -264,1 +269,4 @@\n-    Copy::aligned_conjoint_words(addr, new_addr, obj_size);\n+    if (addr != new_addr) {\n+      prefetch_write_copy(new_addr);\n+      Copy::aligned_conjoint_words(addr, new_addr, obj_size);\n+    }\n@@ -266,0 +274,3 @@\n+    if (addr != new_addr) {\n+      new_obj->initialize_hash_if_necessary(obj);\n+    }\n@@ -301,0 +312,1 @@\n+        size_t new_size = obj->copy_size(obj_size, obj->mark());\n@@ -302,2 +314,3 @@\n-          HeapWord* new_addr = alloc(obj_size);\n-          forward_obj(obj, new_addr);\n+          HeapWord* new_addr = alloc(obj_size, new_size, cur_addr);\n+          forward_obj(obj, new_addr, record_first_dead_done);\n+          assert(obj->size() == obj_size, \"size must not change after forwarding\");\n@@ -310,1 +323,2 @@\n-            alloc(pointer_delta(next_live_addr, cur_addr));\n+            size_t size = pointer_delta(next_live_addr, cur_addr);\n+            alloc(size, size, cur_addr);\n@@ -596,1 +610,1 @@\n-  obj->set_mark(obj->prototype_mark().set_marked());\n+  obj->set_mark(mark.set_marked());\n@@ -699,0 +713,2 @@\n+  FullGCForwarding::begin();\n+\n@@ -742,0 +758,2 @@\n+  FullGCForwarding::end();\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/serialFullGC.cpp","additions":29,"deletions":11,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#include \"gc\/shared\/fullGCForwarding.hpp\"\n+#include \"gc\/shared\/fullGCForwarding.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,0 +121,3 @@\n+  void print_tracing_info() const override;\n+  void stop() override {};\n+\n@@ -212,1 +215,0 @@\n-  void print_tracing_info() const override;\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -390,1 +390,1 @@\n-  assert(obj_size == obj->size(), \"bad obj_size passed in\");\n+  assert(obj_size == obj->size() || UseCompactObjectHeaders, \"bad obj_size passed in\");\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"gc\/shared\/stringdedup\/stringDedupProcessor.hpp\"\n@@ -203,0 +204,28 @@\n+class CPUTimeThreadClosure : public ThreadClosure {\n+private:\n+  jlong _cpu_time = 0;\n+\n+public:\n+  virtual void do_thread(Thread* thread) {\n+    jlong cpu_time = os::thread_cpu_time(thread);\n+    if (cpu_time != -1) {\n+      _cpu_time += cpu_time;\n+    }\n+  }\n+  jlong cpu_time() { return _cpu_time; };\n+};\n+\n+double CollectedHeap::elapsed_gc_cpu_time() const {\n+  double string_dedup_cpu_time = UseStringDeduplication ?\n+    os::thread_cpu_time((Thread*)StringDedup::_processor->_thread) : 0;\n+\n+  if (string_dedup_cpu_time == -1) {\n+    string_dedup_cpu_time = 0;\n+  }\n+\n+  CPUTimeThreadClosure cl;\n+  gc_threads_do(&cl);\n+\n+  return (double)(cl.cpu_time() + _vmthread_cpu_time + string_dedup_cpu_time) \/ NANOSECS_PER_SEC;\n+}\n+\n@@ -284,0 +313,1 @@\n+  _vmthread_cpu_time(0),\n@@ -606,0 +636,34 @@\n+void CollectedHeap::log_gc_cpu_time() const {\n+  LogTarget(Info, gc, cpu) out;\n+  if (os::is_thread_cpu_time_supported() && out.is_enabled()) {\n+    double process_cpu_time = os::elapsed_process_cpu_time();\n+    double gc_cpu_time = elapsed_gc_cpu_time();\n+\n+    if (process_cpu_time == -1 || gc_cpu_time == -1) {\n+      log_warning(gc, cpu)(\"Could not sample CPU time\");\n+      return;\n+    }\n+\n+    double usage;\n+    if (gc_cpu_time > process_cpu_time ||\n+        process_cpu_time == 0 || gc_cpu_time == 0) {\n+      \/\/ This can happen e.g. for short running processes with\n+      \/\/ low CPU utilization\n+      usage = 0;\n+    } else {\n+      usage = 100 * gc_cpu_time \/ process_cpu_time;\n+    }\n+    out.print(\"GC CPU usage: %.2f%% (Process: %.4fs GC: %.4fs)\", usage, process_cpu_time, gc_cpu_time);\n+  }\n+}\n+\n+void CollectedHeap::before_exit() {\n+  print_tracing_info();\n+\n+  \/\/ Log GC CPU usage.\n+  log_gc_cpu_time();\n+\n+  \/\/ Stop any on-going concurrent work and prepare for exit.\n+  stop();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -135,0 +135,2 @@\n+  jlong _vmthread_cpu_time;\n+\n@@ -209,0 +211,7 @@\n+  \/\/ Print any relevant tracing info that flags imply.\n+  \/\/ Default implementation does nothing.\n+  virtual void print_tracing_info() const = 0;\n+\n+  \/\/ Stop any onging concurrent work and prepare for exit.\n+  virtual void stop() = 0;\n+\n@@ -242,2 +251,1 @@\n-  \/\/ Stop any onging concurrent work and prepare for exit.\n-  virtual void stop() {}\n+  void before_exit();\n@@ -249,0 +257,2 @@\n+  void add_vmthread_cpu_time(jlong time);\n+\n@@ -282,1 +292,1 @@\n-  oop class_allocate(Klass* klass, size_t size, TRAPS);\n+  oop class_allocate(Klass* klass, size_t size, size_t base_size, TRAPS);\n@@ -422,0 +432,2 @@\n+  void log_gc_cpu_time() const;\n+\n@@ -454,3 +466,1 @@\n-  \/\/ Print any relevant tracing info that flags imply.\n-  \/\/ Default implementation does nothing.\n-  virtual void print_tracing_info() const = 0;\n+  double elapsed_gc_cpu_time() const;\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -44,2 +44,2 @@\n-inline oop CollectedHeap::class_allocate(Klass* klass, size_t size, TRAPS) {\n-  ClassAllocator allocator(klass, size, THREAD);\n+inline oop CollectedHeap::class_allocate(Klass* klass, size_t size, size_t base_size, TRAPS) {\n+  ClassAllocator allocator(klass, size, base_size, THREAD);\n@@ -49,0 +49,4 @@\n+inline void CollectedHeap::add_vmthread_cpu_time(jlong time) {\n+  _vmthread_cpu_time += time;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.inline.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,56 +1,0 @@\n-\/*\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"gc\/shared\/fullGCForwarding.hpp\"\n-#include \"memory\/memRegion.hpp\"\n-#include \"runtime\/globals_extension.hpp\"\n-\n-HeapWord* FullGCForwarding::_heap_base = nullptr;\n-int FullGCForwarding::_num_low_bits = 0;\n-\n-void FullGCForwarding::initialize_flags(size_t max_heap_size) {\n-#ifdef _LP64\n-  size_t max_narrow_heap_size = right_n_bits(NumLowBitsNarrow - Shift);\n-  if (UseCompactObjectHeaders && max_heap_size > max_narrow_heap_size * HeapWordSize) {\n-    warning(\"Compact object headers require a java heap size smaller than %zu\"\n-            \"%s (given: %zu%s). Disabling compact object headers.\",\n-            byte_size_in_proper_unit(max_narrow_heap_size * HeapWordSize),\n-            proper_unit_for_byte_size(max_narrow_heap_size * HeapWordSize),\n-            byte_size_in_proper_unit(max_heap_size),\n-            proper_unit_for_byte_size(max_heap_size));\n-    FLAG_SET_ERGO(UseCompactObjectHeaders, false);\n-  }\n-#endif\n-}\n-\n-void FullGCForwarding::initialize(MemRegion heap) {\n-#ifdef _LP64\n-  _heap_base = heap.start();\n-  if (UseCompactObjectHeaders) {\n-    _num_low_bits = NumLowBitsNarrow;\n-  } else {\n-    _num_low_bits = NumLowBitsWide;\n-  }\n-#endif\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/fullGCForwarding.cpp","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"memory\/allStatic.hpp\"\n+#include \"memory\/allocation.hpp\"\n@@ -33,10 +33,84 @@\n-\/*\n- * Implements forwarding for the Full GCs of Serial, Parallel, G1 and Shenandoah in\n- * a way that preserves upper N bits of object mark-words, which contain crucial\n- * Klass* information when running with compact headers. The encoding is similar to\n- * compressed-oops encoding: it basically subtracts the forwardee address from the\n- * heap-base, shifts that difference into the right place, and sets the lowest two\n- * bits (to indicate 'forwarded' state as usual).\n- * With compact-headers, we have 40 bits to encode forwarding pointers. This is\n- * enough to address 8TB of heap. If the heap size exceeds that limit, we turn off\n- * compact headers.\n+class FallbackTable;\n+\n+\/**\n+ * FullGCForwarding is a method to store forwarding information in a compressed form into the object header,\n+ * that has been specifically designed for sliding compacting GCs and compact object headers. With compact object\n+ * headers, we store the compressed class pointer in the header, which would be overwritten by full forwarding\n+ * pointers, if we allow the legacy forwarding code to act. This would lose the class information for the object,\n+ * which is required later in GC cycle to iterate the reference fields and get the object size for copying.\n+ *\n+ * FullGCForwarding requires only small side tables and guarantees constant-time access and modification.\n+ *\n+ * The key advantage of sliding compaction for encoding efficiency:\n+ * - It forwards objects linearily, starting at the heap bottom and moving up to the top, sliding\n+ *   live objects towards the bottom of the heap. (The reality in parallel or regionalized GCs is a bit more\n+ *   complex, but conceptually it is the same.)\n+ * - Objects starting in any one block can only be forwarded to a memory region that is not larger than\n+ *   a block. (There are exceptions to this rule which are discussed below.)\n+ *\n+ * This is an intuitive property: when we slide the compact block full of data, it can not take up more\n+ * memory afterwards.\n+ * This property allows us to use a side table to record the addresses of the target memory region for\n+ * each block. The table holds N entries for N blocks. For each block, it gives the base\n+ * address of the target regions, or a special placeholder if not used.\n+ *\n+ * This encoding efficiency allows to store the forwarding information in the object header _together_ with the\n+ * compressed class pointer.\n+ *\n+ * The idea is to use a pointer compression scheme very similar to the one that is used for compressed oops.\n+ * We divide the heap into number of equal-sized blocks. Each block spans a maximum of 2^NUM_OFFSET_BITS words.\n+ * We maintain a side-table of target-base-addresses, with one address entry per block.\n+ *\n+ * When recording the sliding forwarding, the mark word would look roughly like this:\n+ *\n+ *   32                               0\n+ *    [.....................OOOOOOOOOTT]\n+ *                                    ^------ tag-bits, indicates 'forwarded'\n+ *                                  ^-------- in-region offset\n+ *                         ^----------------- protected area, *not touched* by this code, useful for\n+ *                                            compressed class pointer with compact object headers\n+ *\n+ * Adding a forwarding then generally works as follows:\n+ *   1. Compute the index of the block of the \"from\" address.\n+ *   2. Load the target-base-offset of the from-block from the side-table.\n+ *   3. If the base-offset is not-yet set, set it to the to-address of the forwarding.\n+ *      (In other words, the first forwarding of a block determines the target base-offset.)\n+ *   4. Compute the offset of the to-address in the target region.\n+ *   4. Store offset in the object header.\n+ *\n+ * Similarly, looking up the target address, given an original object address generally works as follows:\n+ *   1. Compute the index of the block of the \"from\" address.\n+ *   2. Load the target-base-offset of the from-block from the side-table.\n+ *   3. Extract the offset from the object header.\n+ *   4. Compute the \"to\" address from \"to\" region base and \"offset\"\n+ *\n+ * We reserve one special value for the offset:\n+ *  - 111111111: Indicates an exceptional forwarding (see below), for which a fallback hash-table\n+ *               is used to look up the target address.\n+ *\n+ * In order to support this, we need to make a change to the above algorithm:\n+ *  - Forwardings that would use offsets >= 111111111 (i.e. the last slot)\n+ *    would also need to use the fallback-table. We expect that to be relatively rare for two reasons:\n+ *    1. It only affects 1 out of 512 possible offsets, in other words, 1\/512th of all situations in an equal\n+ *       distribution.\n+ *    2. Forwardings are not equally-distributed, because normally we 'skip' unreachable objects,\n+ *       thus compacting the block. Forwardings tend to cluster at the beginning of the target region,\n+ *       and become less likely towards the end of the possible encodable target address range.\n+ *       Which means in reality it will be much less frequent than 1\/512.\n+ *\n+ * There are several conditions when the above algorithm would be broken because the assumption that\n+ * 'objects from each block can only get forwarded to a region of block-size' is violated:\n+ * - G1 last-ditch serial compaction: there, object from a single region can be forwarded to multiple,\n+ *   more than two regions. G1 serial compaction is not very common - it is the last-last-ditch GC\n+ *   that is used when the JVM is scrambling to squeeze more space out of the heap, and at that point,\n+ *   ultimate performance is no longer the main concern.\n+ * - When forwarding hits a space (or G1\/Shenandoah region) boundary, then latter objects of a block\n+ *   need to be forwarded to a different address range than earlier objects in the same block.\n+ *   This is rare.\n+ * - With compact identity hash-code, objects can grow, and in the worst case use up more memory in\n+ *   the target block than we can address. We expect that to be rare.\n+ *\n+ * To deal with that, we initialize a fallback-hashtable for storing those extra forwardings, and use a special\n+ * offset pattern (0b11...1) to indicate that the forwardee is not encoded but should be looked-up in the hashtable.\n+ * This implies that this particular offset (the last word of a block) can not be used directly as forwarding,\n+ * but also has to be handled by the fallback-table.\n@@ -44,4 +118,16 @@\n-class FullGCForwarding : public AllStatic {\n-  static const int NumLowBitsNarrow = LP64_ONLY(markWord::klass_shift) NOT_LP64(0 \/*unused*\/);\n-  static const int NumLowBitsWide   = BitsPerWord;\n-  static const int Shift            = markWord::lock_bits + markWord::lock_shift;\n+template <int BITS>\n+class FullGCForwardingImpl : public AllStatic {\n+  friend class FullGCForwardingTest;\n+  static constexpr int AVAILABLE_LOW_BITS        = BITS;\n+  static constexpr uintptr_t AVAILABLE_BITS_MASK = right_n_bits(AVAILABLE_LOW_BITS);\n+  \/\/ The offset bits start after the lock-bits, which are currently used by Serial GC\n+  \/\/ for marking objects. Could be 1 for Serial GC when being clever with the bits,\n+  \/\/ and 0 for all other GCs.\n+  static constexpr int OFFSET_BITS_SHIFT = markWord::lock_shift + markWord::lock_bits;\n+\n+  \/\/ How many bits we use for the offset\n+  static constexpr int NUM_OFFSET_BITS = AVAILABLE_LOW_BITS - OFFSET_BITS_SHIFT;\n+  static constexpr size_t BLOCK_SIZE_WORDS = 1ll << NUM_OFFSET_BITS;\n+  static constexpr int BLOCK_SIZE_BYTES_SHIFT = NUM_OFFSET_BITS + LogHeapWordSize;\n+  static constexpr size_t MAX_OFFSET = BLOCK_SIZE_WORDS - 2;\n+  static constexpr uintptr_t OFFSET_MASK = right_n_bits(NUM_OFFSET_BITS) << OFFSET_BITS_SHIFT;\n@@ -49,2 +135,48 @@\n-  static HeapWord* _heap_base;\n-  static int _num_low_bits;\n+  \/\/ This offset bit-pattern indicates that the actual mapping is handled by the\n+  \/\/ fallback-table. This also implies that this cannot be used as a valid offset,\n+  \/\/ and we must also use the fallback-table for mappings to the last word of a\n+  \/\/ block.\n+  static constexpr uintptr_t FALLBACK_PATTERN = right_n_bits(NUM_OFFSET_BITS);\n+  static constexpr uintptr_t FALLBACK_PATTERN_IN_PLACE = FALLBACK_PATTERN << OFFSET_BITS_SHIFT;\n+\n+  \/\/ Indicates an unused base address in the target base table.\n+  static HeapWord* const UNUSED_BASE;\n+\n+  static HeapWord*      _heap_start;\n+\n+  static size_t         _heap_start_region_bias;\n+  static size_t         _num_regions;\n+  static uintptr_t      _region_mask;\n+\n+  \/\/ The target base table memory.\n+  static HeapWord**     _bases_table;\n+  \/\/ Entries into the target base tables, biased to the start of the heap.\n+  static HeapWord**     _biased_bases;\n+\n+  static size_t _fallback_table_log2_start_size;\n+  static FallbackTable* _fallback_table;\n+\n+#ifndef PRODUCT\n+  static volatile uint64_t _num_forwardings;\n+  static volatile uint64_t _num_fallback_forwardings;\n+#endif\n+\n+  static size_t biased_region_index_containing(HeapWord* addr);\n+\n+  static bool is_fallback(uintptr_t encoded);\n+  static uintptr_t encode_forwarding(HeapWord* from, HeapWord* to);\n+  static HeapWord* decode_forwarding(HeapWord* from, uintptr_t encoded);\n+\n+  static void maybe_init_fallback_table();\n+  static void fallback_forward_to(HeapWord* from, HeapWord* to);\n+  static HeapWord* fallback_forwardee(HeapWord* from);\n+\n+  static void forward_to_impl(oop from, oop to);\n+  static oop forwardee_impl(oop from);\n+\n+  FullGCForwardingImpl() = delete;\n+\n+  \/\/ Used in unit-test, so that we can test fallback-table-growth.\n+  static void set_fallback_table_log2_start_size(size_t fallback_table_log2_start_size) {\n+    _fallback_table_log2_start_size = fallback_table_log2_start_size;\n+  }\n@@ -52,4 +184,8 @@\n-  static void initialize_flags(size_t max_heap_size);\n-  static inline void forward_to(oop from, oop to);\n-  static inline oop forwardee(oop from);\n-  static inline bool is_forwarded(oop obj);\n+\n+  static void begin();\n+  static void end();\n+\n+  static bool is_forwarded(oop obj);\n+\n+  static void forward_to(oop from, oop to);\n+  static oop forwardee(oop from);\n@@ -59,0 +195,8 @@\n+#ifdef _LP64\n+using FullGCForwarding = FullGCForwardingImpl<markWord::hashctrl_shift>;\n+#else\n+\/\/ On 32 bit, the BITS template argument is not used, but we still need\n+\/\/ to pass a value.\n+using FullGCForwarding = FullGCForwardingImpl<0>;\n+#endif\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/fullGCForwarding.hpp","additions":165,"deletions":21,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -22,1 +22,0 @@\n- *\n@@ -25,2 +24,2 @@\n-#ifndef GC_SHARED_FULLGCFORWARDING_INLINE_HPP\n-#define GC_SHARED_FULLGCFORWARDING_INLINE_HPP\n+#ifndef SHARE_GC_SHARED_FULLGCFORWARDING_INLINE_HPP\n+#define SHARE_GC_SHARED_FULLGCFORWARDING_INLINE_HPP\n@@ -28,1 +27,3 @@\n-\n+#include \"logging\/log.hpp\"\n+#include \"nmt\/memTag.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -31,1 +32,76 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/concurrentHashTable.inline.hpp\"\n+#include \"utilities\/fastHash.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+\n+\/\/ We cannot use 0, because that may already be a valid base address in zero-based heaps.\n+\/\/ 0x1 is safe because heap base addresses must be aligned by much larger alignment\n+template <int BITS>\n+HeapWord* const FullGCForwardingImpl<BITS>::UNUSED_BASE = reinterpret_cast<HeapWord*>(0x1);\n+\n+template <int BITS>\n+HeapWord* FullGCForwardingImpl<BITS>::_heap_start = nullptr;\n+template <int BITS>\n+size_t FullGCForwardingImpl<BITS>::_heap_start_region_bias = 0;\n+template <int BITS>\n+size_t FullGCForwardingImpl<BITS>::_num_regions = 0;\n+template <int BITS>\n+uintptr_t FullGCForwardingImpl<BITS>::_region_mask = 0;\n+template <int BITS>\n+HeapWord** FullGCForwardingImpl<BITS>::_biased_bases = nullptr;\n+template <int BITS>\n+HeapWord** FullGCForwardingImpl<BITS>::_bases_table = nullptr;\n+template <int BITS>\n+size_t FullGCForwardingImpl<BITS>::_fallback_table_log2_start_size = 9; \/\/ 512 entries.\n+template <int BITS>\n+FallbackTable* FullGCForwardingImpl<BITS>::_fallback_table = nullptr;\n+#ifndef PRODUCT\n+template <int BITS>\n+volatile uint64_t FullGCForwardingImpl<BITS>::_num_forwardings = 0;\n+template <int BITS>\n+volatile uint64_t FullGCForwardingImpl<BITS>::_num_fallback_forwardings = 0;\n+#endif\n+\n+template <int BITS>\n+bool FullGCForwardingImpl<BITS>::is_forwarded(oop obj) {\n+  return obj->is_forwarded();\n+}\n+\n+template <int BITS>\n+size_t FullGCForwardingImpl<BITS>::biased_region_index_containing(HeapWord* addr) {\n+  return reinterpret_cast<uintptr_t>(addr) >> BLOCK_SIZE_BYTES_SHIFT;\n+}\n+\n+template <int BITS>\n+bool FullGCForwardingImpl<BITS>::is_fallback(uintptr_t encoded) {\n+  return (encoded & OFFSET_MASK) == FALLBACK_PATTERN_IN_PLACE;\n+}\n+\n+template <int BITS>\n+uintptr_t FullGCForwardingImpl<BITS>::encode_forwarding(HeapWord* from, HeapWord* to) {\n+  size_t from_block_idx = biased_region_index_containing(from);\n+\n+  HeapWord* to_region_base = _biased_bases[from_block_idx];\n+  if (to_region_base == UNUSED_BASE) {\n+    HeapWord* prev = Atomic::cmpxchg(&_biased_bases[from_block_idx], UNUSED_BASE, to);\n+    if (prev == UNUSED_BASE) {\n+      to_region_base = to;\n+    } else {\n+      to_region_base = prev;\n+    }\n+    \/\/ _biased_bases[from_block_idx] = to_region_base = to;\n+  }\n+  \/\/ Avoid pointer_delta() on purpose: using an unsigned subtraction,\n+  \/\/ we get an underflow when to < to_region_base, which means\n+  \/\/ we can use a single comparison instead of:\n+  \/\/ if (to_region_base > to || (to - to_region_base) > MAX_OFFSET) { .. }\n+  size_t offset = static_cast<size_t>(to - to_region_base);\n+  if (offset > MAX_OFFSET) {\n+    offset = FALLBACK_PATTERN;\n+  }\n+  uintptr_t encoded = (offset << OFFSET_BITS_SHIFT) | markWord::marked_value;\n+\n+  assert(is_fallback(encoded) || to == decode_forwarding(from, encoded), \"must be reversible: \" PTR_FORMAT \" -> \" PTR_FORMAT \", reversed: \" PTR_FORMAT \", encoded: \" INTPTR_FORMAT \", to_region_base: \" PTR_FORMAT \", from_block_idx: %lu\", p2i(from), p2i(to), p2i(decode_forwarding(from, encoded)), encoded, p2i(to_region_base), from_block_idx);\n+  assert((encoded & ~AVAILABLE_BITS_MASK) == 0, \"must encode to available bits\");\n+  return encoded;\n+}\n@@ -33,1 +109,37 @@\n-void FullGCForwarding::forward_to(oop from, oop to) {\n+template <int BITS>\n+HeapWord* FullGCForwardingImpl<BITS>::decode_forwarding(HeapWord* from, uintptr_t encoded) {\n+  assert(!is_fallback(encoded), \"must not be fallback-forwarded, encoded: \" INTPTR_FORMAT \", OFFSET_MASK: \" INTPTR_FORMAT \", FALLBACK_PATTERN_IN_PLACE: \" INTPTR_FORMAT, encoded, OFFSET_MASK, FALLBACK_PATTERN_IN_PLACE);\n+  assert((encoded & ~AVAILABLE_BITS_MASK) == 0, \"must decode from available bits, encoded: \" INTPTR_FORMAT, encoded);\n+  uintptr_t offset = (encoded >> OFFSET_BITS_SHIFT);\n+\n+  size_t from_idx = biased_region_index_containing(from);\n+  HeapWord* base = _biased_bases[from_idx];\n+  assert(base != UNUSED_BASE, \"must not be unused base: encoded: \" INTPTR_FORMAT, encoded);\n+  HeapWord* decoded = base + offset;\n+  assert(decoded >= _heap_start,\n+         \"Address must be above heap start. encoded: \" INTPTR_FORMAT \", base: \" PTR_FORMAT,\n+          encoded, p2i(base));\n+\n+  return decoded;\n+}\n+\n+template <int BITS>\n+void FullGCForwardingImpl<BITS>::forward_to_impl(oop from, oop to) {\n+  assert(_bases_table != nullptr, \"call begin() before forwarding\");\n+\n+  markWord from_header = from->mark();\n+  HeapWord* from_hw = cast_from_oop<HeapWord*>(from);\n+  HeapWord* to_hw   = cast_from_oop<HeapWord*>(to);\n+  uintptr_t encoded = encode_forwarding(from_hw, to_hw);\n+  markWord new_header = markWord((from_header.value() & ~OFFSET_MASK) | encoded);\n+  from->set_mark(new_header);\n+\n+  if (is_fallback(encoded)) {\n+    fallback_forward_to(from_hw, to_hw);\n+  }\n+  NOT_PRODUCT(Atomic::inc(&_num_forwardings);)\n+}\n+\n+template <int BITS>\n+void FullGCForwardingImpl<BITS>::forward_to(oop obj, oop fwd) {\n+  assert(fwd != nullptr, \"no null forwarding\");\n@@ -35,6 +147,3 @@\n-  uintptr_t encoded = pointer_delta(cast_from_oop<HeapWord*>(to), _heap_base) << Shift;\n-  assert(encoded <= static_cast<uintptr_t>(right_n_bits(_num_low_bits)), \"encoded forwardee must fit\");\n-  uintptr_t mark = from->mark().value();\n-  mark &= ~right_n_bits(_num_low_bits);\n-  mark |= (encoded | markWord::marked_value);\n-  from->set_mark(markWord(mark));\n+  assert(_bases_table != nullptr, \"expect sliding forwarding initialized\");\n+  forward_to_impl(obj, fwd);\n+  \/\/ assert(forwardee(obj) == fwd, \"must be forwarded to correct forwardee, obj: \" PTR_FORMAT \", forwardee(obj): \" PTR_FORMAT \", fwd: \" PTR_FORMAT \", mark: \" INTPTR_FORMAT \", num-regions: %lu, base: \" PTR_FORMAT \", OFFSET_MASK: \" INTPTR_FORMAT \", encoded: \" PTR_FORMAT \", biased-base: \" PTR_FORMAT \", heap-start: \" PTR_FORMAT, p2i(obj), p2i(forwardee(obj)), p2i(fwd), obj->mark().value(), _num_regions, p2i(_bases_table[0]), OFFSET_MASK, encode_forwarding(cast_from_oop<HeapWord*>(obj), cast_from_oop<HeapWord*>(fwd)), p2i(_biased_bases[biased_region_index_containing(cast_from_oop<HeapWord*>(obj))]), p2i(_heap_start));\n@@ -42,1 +151,1 @@\n-  from->forward_to(to);\n+  obj->forward_to(fwd);\n@@ -46,1 +155,17 @@\n-oop FullGCForwarding::forwardee(oop from) {\n+template <int BITS>\n+oop FullGCForwardingImpl<BITS>::forwardee_impl(oop from) {\n+  assert(_bases_table != nullptr, \"call begin() before asking for forwarding\");\n+\n+  markWord header = from->mark();\n+  HeapWord* from_hw = cast_from_oop<HeapWord*>(from);\n+  if (is_fallback(header.value())) {\n+    HeapWord* to = fallback_forwardee(from_hw);\n+    return cast_to_oop(to);\n+  }\n+  uintptr_t encoded = header.value() & OFFSET_MASK;\n+  HeapWord* to = decode_forwarding(from_hw, encoded);\n+  return cast_to_oop(to);\n+}\n+\n+template <int BITS>\n+oop FullGCForwardingImpl<BITS>::forwardee(oop obj) {\n@@ -48,3 +173,2 @@\n-  uintptr_t mark = from->mark().value();\n-  HeapWord* decoded = _heap_base + ((mark & right_n_bits(_num_low_bits)) >> Shift);\n-  return cast_to_oop(decoded);\n+  assert(_bases_table != nullptr, \"expect sliding forwarding initialized\");\n+  return forwardee_impl(obj);\n@@ -52,1 +176,152 @@\n-  return from->forwardee();\n+  return obj->forwardee();\n+#endif\n+}\n+\n+static uintx hash(HeapWord* const& addr) {\n+  uint64_t val = reinterpret_cast<uint64_t>(addr);\n+  uint32_t hash = FastHash::get_hash32(static_cast<uint32_t>(val), static_cast<uint32_t>(val >> 32));\n+  return hash;\n+}\n+\n+struct ForwardingEntry {\n+  HeapWord* _from;\n+  HeapWord* _to;\n+  ForwardingEntry(HeapWord* from, HeapWord* to) : _from(from), _to(to) {}\n+};\n+\n+struct FallbackTableConfig {\n+  using Value = ForwardingEntry;\n+  static uintx get_hash(Value const& entry, bool* is_dead) {\n+    return hash(entry._from);\n+  }\n+  static void* allocate_node(void* context, size_t size, Value const& value) {\n+    return AllocateHeap(size, mtGC);\n+  }\n+  static void free_node(void* context, void* memory, Value const& value) {\n+    FreeHeap(memory);\n+  }\n+};\n+\n+class FallbackTable : public ConcurrentHashTable<FallbackTableConfig, mtGC> {\n+public:\n+  explicit FallbackTable(size_t log2size) : ConcurrentHashTable(log2size) {}\n+};\n+\n+class FallbackTableLookup : public StackObj {\n+  ForwardingEntry const _entry;\n+public:\n+  explicit FallbackTableLookup(HeapWord* from) : _entry(from, nullptr) {}\n+  uintx get_hash() const {\n+    return hash(_entry._from);\n+  }\n+  bool equals(const ForwardingEntry* value) const {\n+    return _entry._from == value->_from;\n+  }\n+  static bool is_dead(ForwardingEntry* value) { return false; }\n+};\n+\n+template <int BITS>\n+void FullGCForwardingImpl<BITS>::initialize(MemRegion heap) {\n+#ifdef _LP64\n+  _heap_start = heap.start();\n+\n+  size_t rounded_heap_size = MAX2(round_up_power_of_2(heap.byte_size()) \/ BytesPerWord, BLOCK_SIZE_WORDS);\n+\n+  _num_regions = rounded_heap_size \/ BLOCK_SIZE_WORDS;\n+\n+  _heap_start_region_bias = reinterpret_cast<uintptr_t>(_heap_start) >> BLOCK_SIZE_BYTES_SHIFT;\n+  _region_mask = ~((static_cast<uintptr_t>(1) << BLOCK_SIZE_BYTES_SHIFT) - 1);\n+\n+  assert(_bases_table == nullptr, \"should not be initialized yet\");\n+  assert(_fallback_table == nullptr, \"should not be initialized yet\");\n+#endif\n+}\n+\n+template <int BITS>\n+void FullGCForwardingImpl<BITS>::begin() {\n+#ifdef _LP64\n+  assert(_bases_table == nullptr, \"should not be initialized yet\");\n+  assert(_fallback_table == nullptr, \"should not be initialized yet\");\n+\n+  _fallback_table = nullptr;\n+\n+#ifndef PRODUCT\n+  _num_forwardings = 0;\n+  _num_fallback_forwardings = 0;\n+#endif\n+\n+  size_t max = _num_regions;\n+  _bases_table = NEW_C_HEAP_ARRAY(HeapWord*, max, mtGC);\n+  HeapWord** biased_start = _bases_table - _heap_start_region_bias;\n+  _biased_bases = biased_start;\n+  if (max == 1) {\n+    \/\/ Optimize the case when the block-size >= heap-size.\n+    \/\/ In this case we can use the heap-start as block-start,\n+    \/\/ and don't risk that competing GC threads set a higher\n+    \/\/ address as block-start, which would lead to unnecessary\n+    \/\/ fallback-usage.\n+    _bases_table[0] = _heap_start;\n+  } else {\n+    for (size_t i = 0; i < max; i++) {\n+      _bases_table[i] = UNUSED_BASE;\n+    }\n+  }\n+#endif\n+}\n+\n+template <int BITS>\n+void FullGCForwardingImpl<BITS>::end() {\n+#ifndef PRODUCT\n+  size_t fallback_table_size = _fallback_table != nullptr ? _fallback_table->get_mem_size(Thread::current()) : 0;\n+  log_info(gc)(\"Total forwardings: \" UINT64_FORMAT \", fallback forwardings: \" UINT64_FORMAT\n+                \", ratio: %f, memory used by fallback table: %zu%s, memory used by bases table: %zu%s\",\n+               _num_forwardings, _num_fallback_forwardings, static_cast<float>(_num_forwardings) \/ static_cast<float>(_num_fallback_forwardings),\n+               byte_size_in_proper_unit(fallback_table_size),\n+               proper_unit_for_byte_size(fallback_table_size),\n+               byte_size_in_proper_unit(sizeof(HeapWord*) * _num_regions),\n+               proper_unit_for_byte_size(sizeof(HeapWord*) * _num_regions));\n+#endif\n+#ifdef _LP64\n+  assert(_bases_table != nullptr, \"should be initialized\");\n+  FREE_C_HEAP_ARRAY(HeapWord*, _bases_table);\n+  _bases_table = nullptr;\n+  if (_fallback_table != nullptr) {\n+    delete _fallback_table;\n+    _fallback_table = nullptr;\n+  }\n+#endif\n+}\n+\n+template <int BITS>\n+void FullGCForwardingImpl<BITS>::maybe_init_fallback_table() {\n+  if (_fallback_table == nullptr) {\n+    FallbackTable* fallback_table = new FallbackTable(_fallback_table_log2_start_size);\n+    FallbackTable* prev = Atomic::cmpxchg(&_fallback_table, static_cast<FallbackTable*>(nullptr), fallback_table);\n+    if (prev != nullptr) {\n+      \/\/ Another thread won, discard our table.\n+      delete fallback_table;\n+    }\n+  }\n+}\n+\n+template <int BITS>\n+void FullGCForwardingImpl<BITS>::fallback_forward_to(HeapWord* from, HeapWord* to) {\n+  assert(to != nullptr, \"no null forwarding\");\n+  maybe_init_fallback_table();\n+  assert(_fallback_table != nullptr, \"should be initialized\");\n+  FallbackTableLookup lookup_f(from);\n+  ForwardingEntry entry(from, to);\n+  auto found_f = [&](ForwardingEntry* found) {\n+    \/\/ If dupe has been found, override it with new value.\n+    \/\/ This is also called when new entry is succussfully inserted.\n+    if (found->_to != to) {\n+      found->_to = to;\n+    }\n+  };\n+  Thread* current_thread = Thread::current();\n+  bool grow;\n+  bool added = _fallback_table->insert_get(current_thread, lookup_f, entry, found_f, &grow);\n+  NOT_PRODUCT(Atomic::inc(&_num_fallback_forwardings);)\n+#ifdef ASSERT\n+  assert(fallback_forwardee(from) != nullptr, \"must have entered forwarding\");\n+  assert(fallback_forwardee(from) == to, \"forwarding must be correct, added: %s, from: \" PTR_FORMAT \", to: \" PTR_FORMAT \", fwd: \" PTR_FORMAT, BOOL_TO_STR(added), p2i(from), p2i(to), p2i(fallback_forwardee(from)));\n@@ -54,0 +329,4 @@\n+  if (grow) {\n+    _fallback_table->grow(current_thread);\n+    log_debug(gc)(\"grow fallback table to size: %zu bytes\", _fallback_table->get_mem_size(current_thread));\n+  }\n@@ -56,2 +335,12 @@\n-bool FullGCForwarding::is_forwarded(oop obj) {\n-  return obj->mark().is_forwarded();\n+template <int BITS>\n+HeapWord* FullGCForwardingImpl<BITS>::fallback_forwardee(HeapWord* from) {\n+  assert(_fallback_table != nullptr, \"fallback table must be present\");\n+  HeapWord* result;\n+  FallbackTableLookup lookup_f(from);\n+  auto found_f = [&](const ForwardingEntry* found) {\n+    result = found->_to;\n+  };\n+  bool found = _fallback_table->get(Thread::current(), lookup_f, found_f);\n+  assert(found, \"something must have been found\");\n+  assert(result != nullptr, \"must have found forwarding\");\n+  return result;\n@@ -60,1 +349,1 @@\n-#endif \/\/ GC_SHARED_FULLGCFORWARDING_INLINE_HPP\n+#endif \/\/ SHARE_GC_SHARED_FULLGCFORWARDING_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/fullGCForwarding.inline.hpp","additions":310,"deletions":21,"binary":false,"changes":331,"status":"modified"},{"patch":"@@ -449,1 +449,1 @@\n-  assert(_word_size > 0, \"oop_size must be positive.\");\n+  assert(_base_size > 0, \"oop_size must be positive.\");\n@@ -451,1 +451,1 @@\n-  java_lang_Class::set_oop_size(mem, _word_size);\n+  java_lang_Class::set_oop_size(mem, _base_size);\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+class CollectedHeap;\n@@ -118,0 +119,1 @@\n+  friend class CollectedHeap;\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedup.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+class CollectedHeap;\n@@ -45,0 +46,2 @@\n+  friend class CollectedHeap;\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupProcessor.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_VMTHREADCPUTIMESCOPE_HPP\n+#define SHARE_GC_SHARED_VMTHREADCPUTIMESCOPE_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+\n+class VMThread;\n+\n+class VMThreadCPUTimeScope : public StackObj {\n+private:\n+  jlong   _start;\n+  bool    _enabled;\n+  bool    _is_gc_operation;\n+  VMThread* _thread;\n+\n+public:\n+  VMThreadCPUTimeScope(VMThread* thread, bool is_gc_operation);\n+  ~VMThreadCPUTimeScope();\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_VMTHREADCPUTIMESCOPE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/vmThreadCpuTimeScope.hpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"gc\/shared\/vmThreadCpuTimeScope.hpp\"\n+\n+#include \"gc\/shared\/collectedHeap.inline.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"runtime\/cpuTimeCounters.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+\n+inline VMThreadCPUTimeScope::VMThreadCPUTimeScope(VMThread* thread, bool is_gc_operation)\n+  : _start(0),\n+    _enabled(os::is_thread_cpu_time_supported()),\n+    _is_gc_operation(is_gc_operation),\n+    _thread(thread) {\n+  if (_is_gc_operation && _enabled) {\n+    _start = os::thread_cpu_time(_thread);\n+  }\n+}\n+\n+inline VMThreadCPUTimeScope::~VMThreadCPUTimeScope() {\n+  if (!_enabled) {\n+    return;\n+  }\n+\n+  jlong end = (_is_gc_operation || UsePerfData) ? os::thread_cpu_time(_thread) : 0;\n+\n+  if (_is_gc_operation) {\n+    jlong duration = end > _start ? end - _start : 0;\n+    Universe::heap()->add_vmthread_cpu_time(duration);\n+  }\n+\n+  if (UsePerfData) {\n+    CPUTimeCounters::update_counter(CPUTimeGroups::CPUTimeType::vm, end);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/vmThreadCpuTimeScope.inline.hpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -277,1 +277,1 @@\n-  _pre_barrier_c1_runtime_code_blob = Runtime1::generate_blob(buffer_blob, C1StubId::NO_STUBID,\n+  _pre_barrier_c1_runtime_code_blob = Runtime1::generate_blob(buffer_blob, StubId::NO_STUBID,\n@@ -285,1 +285,1 @@\n-    _load_reference_barrier_strong_rt_code_blob = Runtime1::generate_blob(buffer_blob, C1StubId::NO_STUBID,\n+    _load_reference_barrier_strong_rt_code_blob = Runtime1::generate_blob(buffer_blob, StubId::NO_STUBID,\n@@ -293,1 +293,1 @@\n-    _load_reference_barrier_strong_native_rt_code_blob = Runtime1::generate_blob(buffer_blob, C1StubId::NO_STUBID,\n+    _load_reference_barrier_strong_native_rt_code_blob = Runtime1::generate_blob(buffer_blob, StubId::NO_STUBID,\n@@ -301,1 +301,1 @@\n-    _load_reference_barrier_weak_rt_code_blob = Runtime1::generate_blob(buffer_blob, C1StubId::NO_STUBID,\n+    _load_reference_barrier_weak_rt_code_blob = Runtime1::generate_blob(buffer_blob, StubId::NO_STUBID,\n@@ -309,1 +309,1 @@\n-    _load_reference_barrier_phantom_rt_code_blob = Runtime1::generate_blob(buffer_blob, C1StubId::NO_STUBID,\n+    _load_reference_barrier_phantom_rt_code_blob = Runtime1::generate_blob(buffer_blob, StubId::NO_STUBID,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-  size_t capacity    = _space_info->soft_max_capacity();\n+  size_t capacity    = ShenandoahHeap::heap()->soft_max_capacity();\n@@ -236,1 +236,1 @@\n-  size_t capacity = _space_info->soft_max_capacity();\n+  size_t capacity = ShenandoahHeap::heap()->soft_max_capacity();\n@@ -352,4 +352,1 @@\n-  \/\/ Note that soft_max_capacity() \/ 100 * min_free_threshold is smaller than max_capacity() \/ 100 * min_free_threshold.\n-  \/\/ We want to behave conservatively here, so use max_capacity().  By returning a larger value, we cause the GC to\n-  \/\/ trigger when the remaining amount of free shrinks below the larger threshold.\n-  return _space_info->max_capacity() \/ 100 * ShenandoahMinFreeThreshold;\n+  return ShenandoahHeap::heap()->soft_max_capacity() \/ 100 * ShenandoahMinFreeThreshold;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  size_t capacity = _space_info->soft_max_capacity();\n+  size_t capacity = ShenandoahHeap::heap()->soft_max_capacity();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  size_t capacity = heap->young_generation()->max_capacity();\n+  size_t capacity = heap->soft_max_capacity();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGlobalHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  virtual size_t soft_max_capacity() const = 0;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  size_t capacity = _space_info->soft_max_capacity();\n+  size_t capacity = ShenandoahHeap::heap()->soft_max_capacity();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-  size_t capacity = heap->young_generation()->max_capacity();\n+  size_t capacity = heap->soft_max_capacity();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"gc\/shared\/fullGCForwarding.hpp\"\n@@ -196,2 +195,0 @@\n-\n-  FullGCForwarding::initialize_flags(MaxHeapSize);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -67,1 +67,3 @@\n-  msg.append(\"  \" PTR_FORMAT \" - klass \" PTR_FORMAT \" %s\\n\", p2i(obj), p2i(obj->klass()), obj->klass()->external_name());\n+  Klass* obj_klass = ShenandoahForwarding::klass(obj);\n+\n+  msg.append(\"  \" PTR_FORMAT \" - klass \" PTR_FORMAT \" %s\\n\", p2i(obj), p2i(obj_klass), obj_klass->external_name());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-  const size_t v_soft_max_capacity = soft_max_capacity();\n+  const size_t v_soft_max_capacity = ShenandoahHeap::heap()->soft_max_capacity();\n@@ -802,2 +802,1 @@\n-                                           size_t max_capacity,\n-                                           size_t soft_max_capacity) :\n+                                           size_t max_capacity) :\n@@ -809,1 +808,1 @@\n-  _max_capacity(max_capacity), _soft_max_capacity(soft_max_capacity),\n+  _max_capacity(max_capacity),\n@@ -955,1 +954,1 @@\n-  return available(soft_max_capacity());\n+  return available(ShenandoahHeap::heap()->soft_max_capacity());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-  size_t _soft_max_capacity;\n@@ -108,2 +107,1 @@\n-                       size_t max_capacity,\n-                       size_t soft_max_capacity);\n+                       size_t max_capacity);\n@@ -129,1 +127,0 @@\n-  size_t soft_max_capacity() const override { return _soft_max_capacity; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,15 +56,0 @@\n-\n-  void print_heap() override {\n-    ShenandoahInitLogger::print_heap();\n-\n-    ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n-\n-    ShenandoahYoungGeneration* young = heap->young_generation();\n-    log_info(gc, init)(\"Young Generation Soft Size: \" EXACTFMT, EXACTFMTARGS(young->soft_max_capacity()));\n-    log_info(gc, init)(\"Young Generation Max: \" EXACTFMT, EXACTFMTARGS(young->max_capacity()));\n-\n-    ShenandoahOldGeneration* old = heap->old_generation();\n-    log_info(gc, init)(\"Old Generation Soft Size: \" EXACTFMT, EXACTFMTARGS(old->soft_max_capacity()));\n-    log_info(gc, init)(\"Old Generation Max: \" EXACTFMT, EXACTFMTARGS(old->max_capacity()));\n-  }\n-\n@@ -144,2 +129,2 @@\n-  _young_generation = new ShenandoahYoungGeneration(max_workers(), max_capacity_young, initial_capacity_young);\n-  _old_generation = new ShenandoahOldGeneration(max_workers(), max_capacity_old, initial_capacity_old);\n+  _young_generation = new ShenandoahYoungGeneration(max_workers(), max_capacity_young);\n+  _old_generation = new ShenandoahOldGeneration(max_workers(), max_capacity_old);\n@@ -265,1 +250,8 @@\n-  size_t size = ShenandoahForwarding::size(p);\n+\n+  markWord mark = p->mark();\n+  if (ShenandoahForwarding::is_forwarded(mark)) {\n+    return ShenandoahForwarding::get_forwardee(p);\n+  }\n+  size_t old_size = ShenandoahForwarding::size(p);\n+  size_t size = p->copy_size(old_size, mark);\n+\n@@ -357,1 +349,1 @@\n-  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(p), copy, size);\n+  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(p), copy, old_size);\n@@ -375,0 +367,1 @@\n+    copy_val->initialize_hash_if_necessary(p);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":12,"deletions":19,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+  void print_tracing_info() const override;\n+  void stop() override;\n+\n@@ -56,1 +59,0 @@\n-  void print_tracing_info() const override;\n@@ -129,2 +131,0 @@\n-  void stop() override;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,4 +53,0 @@\n-size_t ShenandoahGlobalGeneration::soft_max_capacity() const {\n-  return ShenandoahHeap::heap()->soft_max_capacity();\n-}\n-\n@@ -68,2 +64,2 @@\n-  assert(max_capacity() >= soft_max_capacity(), \"Max capacity must be greater than soft max capacity.\");\n-  size_t soft_tail = max_capacity() - soft_max_capacity();\n+  assert(max_capacity() >= ShenandoahHeap::heap()->soft_max_capacity(), \"Max capacity must be greater than soft max capacity.\");\n+  size_t soft_tail = max_capacity() - ShenandoahHeap::heap()->soft_max_capacity();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-  ShenandoahGlobalGeneration(bool generational, uint max_queues, size_t max_capacity, size_t soft_max_capacity)\n-  : ShenandoahGeneration(generational ? GLOBAL : NON_GEN, max_queues, max_capacity, soft_max_capacity) { }\n+  ShenandoahGlobalGeneration(bool generational, uint max_queues, size_t max_capacity)\n+  : ShenandoahGeneration(generational ? GLOBAL : NON_GEN, max_queues, max_capacity) { }\n@@ -42,1 +42,0 @@\n-  size_t soft_max_capacity() const override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/shared\/fullGCForwarding.hpp\"\n+#include \"gc\/shared\/fullGCForwarding.inline.hpp\"\n@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -204,2 +205,1 @@\n-  \/\/ Default to max heap size.\n-  _soft_max_size = _num_regions * reg_size_bytes;\n+  _soft_max_size = SoftMaxHeapSize;\n@@ -527,1 +527,1 @@\n-  _global_generation = new ShenandoahGlobalGeneration(mode()->is_generational(), max_workers(), max_capacity(), max_capacity());\n+  _global_generation = new ShenandoahGlobalGeneration(mode()->is_generational(), max_workers(), max_capacity());\n@@ -1363,1 +1363,7 @@\n-  size_t size = ShenandoahForwarding::size(p);\n+\n+  markWord mark = p->mark();\n+  if (ShenandoahForwarding::is_forwarded(mark)) {\n+    return ShenandoahForwarding::get_forwardee(p);\n+  }\n+  size_t old_size = ShenandoahForwarding::size(p);\n+  size_t size = p->copy_size(old_size, mark);\n@@ -1393,1 +1399,1 @@\n-  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(p), copy, size);\n+  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(p), copy, old_size);\n@@ -1400,0 +1406,1 @@\n+    copy_val->initialize_hash_if_necessary(p);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -162,0 +162,4 @@\n+protected:\n+  void print_tracing_info() const override;\n+  void stop() override;\n+\n@@ -207,1 +211,0 @@\n-  void print_tracing_info()                    const override;\n@@ -210,2 +213,0 @@\n-  void stop() override;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+  log_info(gc, init)(\"Soft Max Heap Size: \" EXACTFMT, EXACTFMTARGS(ShenandoahHeap::heap()->soft_max_capacity()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahInitLogger.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-  size_t free_expected = (generation->max_capacity() \/ 100) * ShenandoahCriticalFreeThreshold;\n+  size_t free_expected = (ShenandoahHeap::heap()->soft_max_capacity() \/ 100) * ShenandoahCriticalFreeThreshold;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMetrics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -199,2 +199,2 @@\n-ShenandoahOldGeneration::ShenandoahOldGeneration(uint max_queues, size_t max_capacity, size_t soft_max_capacity)\n-  : ShenandoahGeneration(OLD, max_queues, max_capacity, soft_max_capacity),\n+ShenandoahOldGeneration::ShenandoahOldGeneration(uint max_queues, size_t max_capacity)\n+  : ShenandoahGeneration(OLD, max_queues, max_capacity),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-  ShenandoahOldGeneration(uint max_queues, size_t max_capacity, size_t soft_max_capacity);\n+  ShenandoahOldGeneration(uint max_queues, size_t max_capacity);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -627,1 +627,1 @@\n-  CardValue* end_bp = &(new_ptr)[_card_table->last_valid_index()];\n+  CardValue* end_bp = &(start_bp[_card_table->last_valid_index()]);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-ShenandoahYoungGeneration::ShenandoahYoungGeneration(uint max_queues, size_t max_capacity, size_t soft_max_capacity) :\n-  ShenandoahGeneration(YOUNG, max_queues, max_capacity, soft_max_capacity),\n+ShenandoahYoungGeneration::ShenandoahYoungGeneration(uint max_queues, size_t max_capacity) :\n+  ShenandoahGeneration(YOUNG, max_queues, max_capacity),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  ShenandoahYoungGeneration(uint max_queues, size_t max_capacity, size_t max_soft_capacity);\n+  ShenandoahYoungGeneration(uint max_queues, size_t max_capacity);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -509,1 +509,1 @@\n-  CodeBlob* const code_blob = Runtime1::generate_blob(blob, C1StubId::NO_STUBID \/* stub_id *\/, name, false \/* expect_oop_map*\/, &cl);\n+  CodeBlob* const code_blob = Runtime1::generate_blob(blob, StubId::NO_STUBID \/* stub_id *\/, name, false \/* expect_oop_map*\/, &cl);\n@@ -529,1 +529,1 @@\n-  CodeBlob* const code_blob = Runtime1::generate_blob(blob, C1StubId::NO_STUBID \/* stub_id *\/, name, false \/* expect_oop_map*\/, &cl);\n+  CodeBlob* const code_blob = Runtime1::generate_blob(blob, StubId::NO_STUBID \/* stub_id *\/, name, false \/* expect_oop_map*\/, &cl);\n","filename":"src\/hotspot\/share\/gc\/z\/c1\/zBarrierSetC1.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,0 +58,3 @@\n+  void print_tracing_info() const override;\n+  void stop() override;\n+\n@@ -66,1 +69,0 @@\n-  void stop() override;\n@@ -119,1 +121,0 @@\n-  void print_tracing_info() const override;\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -327,1 +327,2 @@\n-  const size_t size = ZUtils::object_size(from_addr);\n+  const size_t old_size = ZUtils::object_size(from_addr);\n+  const size_t size = ZUtils::copy_size(from_addr, old_size);\n@@ -337,0 +338,1 @@\n+  assert(to_addr != from_addr, \"addresses must be different\");\n@@ -339,1 +341,2 @@\n-  ZUtils::object_copy_disjoint(from_addr, to_addr, size);\n+  ZUtils::object_copy_disjoint(from_addr, to_addr, old_size);\n+  ZUtils::initialize_hash_if_necessary(to_addr, from_addr);\n@@ -593,1 +596,1 @@\n-  zaddress try_relocate_object_inner(zaddress from_addr) {\n+  zaddress try_relocate_object_inner(zaddress from_addr, size_t old_size) {\n@@ -595,2 +598,4 @@\n-\n-    const size_t size = ZUtils::object_size(from_addr);\n+    zoffset_end from_offset = to_zoffset_end(ZAddress::offset(from_addr));\n+    zoffset_end top = to_page != nullptr ? to_page->top() : to_zoffset_end(0);\n+    const size_t new_size = ZUtils::copy_size(from_addr, old_size);\n+    const size_t size = top == from_offset ? old_size : new_size;\n@@ -615,0 +620,4 @@\n+    if (old_size != new_size && ((top == from_offset) != (allocated_addr == from_addr))) {\n+      _allocator->undo_alloc_object(to_page, allocated_addr, size);\n+      return zaddress::null;\n+    }\n@@ -618,2 +627,2 @@\n-    if (_forwarding->in_place_relocation() && allocated_addr + size > from_addr) {\n-      ZUtils::object_copy_conjoint(from_addr, allocated_addr, size);\n+    if (_forwarding->in_place_relocation() && allocated_addr + old_size > from_addr) {\n+      ZUtils::object_copy_conjoint(from_addr, allocated_addr, old_size);\n@@ -621,1 +630,4 @@\n-      ZUtils::object_copy_disjoint(from_addr, allocated_addr, size);\n+      ZUtils::object_copy_disjoint(from_addr, allocated_addr, old_size);\n+    }\n+    if (from_addr != allocated_addr) {\n+      ZUtils::initialize_hash_if_necessary(allocated_addr, from_addr);\n@@ -635,1 +647,1 @@\n-  void update_remset_old_to_old(zaddress from_addr, zaddress to_addr) const {\n+  void update_remset_old_to_old(zaddress from_addr, zaddress to_addr, size_t size) const {\n@@ -657,4 +669,2 @@\n-\n-    \/\/ Read the size from the to-object, since the from-object\n-    \/\/ could have been overwritten during in-place relocation.\n-    const size_t size = ZUtils::object_size(to_addr);\n+    assert(size <= ZUtils::object_size(to_addr), \"old size must be <= new size\");\n+    assert(size > 0, \"size must be set\");\n@@ -785,1 +795,1 @@\n-  void update_remset_for_fields(zaddress from_addr, zaddress to_addr) const {\n+  void update_remset_for_fields(zaddress from_addr, zaddress to_addr, size_t size) const {\n@@ -793,1 +803,1 @@\n-      update_remset_old_to_old(from_addr, to_addr);\n+      update_remset_old_to_old(from_addr, to_addr, size);\n@@ -809,1 +819,2 @@\n-    const zaddress to_addr = try_relocate_object_inner(from_addr);\n+    size_t size = ZUtils::object_size(from_addr);\n+    const zaddress to_addr = try_relocate_object_inner(from_addr, size);\n@@ -815,1 +826,1 @@\n-    update_remset_for_fields(from_addr, to_addr);\n+    update_remset_for_fields(from_addr, to_addr, size);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":28,"deletions":17,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-    module = module_entry->module();\n+    module = module_entry->module_oop();\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrUpcalls.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -951,1 +951,2 @@\n-  <Event name=\"ExecutionSample\" category=\"Java Virtual Machine, Profiling\" label=\"Method Profiling Sample\" description=\"Snapshot of a threads state\"\n+  <Event name=\"ExecutionSample\" category=\"Java Virtual Machine, Profiling\" label=\"Java Execution Sample\"\n+         description=\"Snapshot of a thread executing Java code. Threads that are not executing Java code, including those waiting or executing native code, are not included.\"\n@@ -958,1 +959,2 @@\n-  <Event name=\"NativeMethodSample\" category=\"Java Virtual Machine, Profiling\" label=\"Method Profiling Sample Native\" description=\"Snapshot of a threads state when in native\"\n+  <Event name=\"NativeMethodSample\" category=\"Java Virtual Machine, Profiling\" label=\"Native Sample\"\n+         description=\"Snapshot of a thread in native code, executing or waiting. Threads that are executing Java code are not included.\"\n@@ -965,2 +967,2 @@\n-  <Event name=\"CPUTimeSample\" category=\"Java Virtual Machine, Profiling\" label=\"CPU Time Method Sample\"\n-    description=\"Snapshot of a threads state from the CPU time sampler. The throttle can be either an upper bound for the event emission rate, e.g. 100\/s, or the cpu-time period, e.g. 10ms, with s, ms, us and ns supported as time units.\"\n+  <Event name=\"CPUTimeSample\" category=\"Java Virtual Machine, Profiling\" label=\"CPU Time Sample\"\n+    description=\"Snapshot of a threads state from the CPU time sampler, both threads executing native and Java code are included. The throttle setting can be either an upper bound for the event emission rate, e.g. 100\/s, or the cpu-time period, e.g. 10ms, with s, ms, us and ns supported as time units.\"\n@@ -975,1 +977,1 @@\n-  <Event name=\"CPUTimeSamplesLost\" category=\"Java Virtual Machine, Profiling\" label=\"CPU Time Method Profiling Lost Samples\" description=\"Records that the CPU time sampler lost samples\"\n+  <Event name=\"CPUTimeSamplesLost\" category=\"Java Virtual Machine, Profiling\" label=\"CPU Time Samples Lost\" description=\"Records that the CPU time sampler lost samples\"\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-  const JvmtiAgentList::Iterator it =JvmtiAgentList::java_agents();\n+  JvmtiAgentList::Iterator it = JvmtiAgentList::java_agents();\n@@ -303,1 +303,1 @@\n-static void send_native_agent_events(const JvmtiAgentList::Iterator& it) {\n+static void send_native_agent_events(JvmtiAgentList::Iterator& it) {\n@@ -314,1 +314,1 @@\n-  const JvmtiAgentList::Iterator native_agents_it = JvmtiAgentList::native_agents();\n+  JvmtiAgentList::Iterator native_agents_it = JvmtiAgentList::native_agents();\n@@ -316,1 +316,1 @@\n-  const JvmtiAgentList::Iterator xrun_agents_it = JvmtiAgentList::xrun_agents();\n+  JvmtiAgentList::Iterator xrun_agents_it = JvmtiAgentList::xrun_agents();\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-          if (excludeModules->obj_at(i) == moduleEntry->module()) {\n+          if (excludeModules->obj_at(i) == moduleEntry->module_oop()) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -455,1 +455,1 @@\n-  if (offset == oopDesc::klass_offset_in_bytes()) {\n+  if (offset == 1 \/*oopDesc::klass_offset_in_bytes()*\/) {\n@@ -2893,0 +2893,1 @@\n+      jboolean profileDeopt = thisEnv->get_HotSpotNmethod_profileDeopt(obj);\n@@ -2897,1 +2898,1 @@\n-      result = PEER_JVMCIENV->new_HotSpotNmethod(mh, cstring, isDefault, compileIdSnapshot, JVMCI_CHECK_0);\n+      result = PEER_JVMCIENV->new_HotSpotNmethod(mh, cstring, isDefault, profileDeopt, compileIdSnapshot, JVMCI_CHECK_0);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-  oopDesc_klass_offset_in_bytes = oopDesc::klass_offset_in_bytes();\n+  oopDesc_klass_offset_in_bytes = 1; \/\/oopDesc::klass_offset_in_bytes();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1213,1 +1213,1 @@\n-JVMCIObject JVMCIEnv::new_HotSpotNmethod(const methodHandle& method, const char* name, jboolean isDefault, jlong compileId, JVMCI_TRAPS) {\n+JVMCIObject JVMCIEnv::new_HotSpotNmethod(const methodHandle& method, const char* name, jboolean isDefault, jboolean profileDeopt, jlong compileId, JVMCI_TRAPS) {\n@@ -1233,0 +1233,1 @@\n+    jargs.push_int(profileDeopt);\n@@ -1237,1 +1238,1 @@\n-                            vmSymbols::method_string_bool_long_signature(),\n+                            vmSymbols::method_string_bool_bool_long_signature(),\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -429,1 +429,1 @@\n-  JVMCIObject new_HotSpotNmethod(const methodHandle& method, const char* name, jboolean isDefault, jlong compileId, JVMCI_TRAPS);\n+  JVMCIObject new_HotSpotNmethod(const methodHandle& method, const char* name, jboolean isDefault, jboolean profileDeopt, jlong compileId, JVMCI_TRAPS);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,0 +103,1 @@\n+    boolean_field(HotSpotNmethod, profileDeopt)                                                               \\\n@@ -106,1 +107,1 @@\n-    jvmci_constructor(HotSpotNmethod, \"(Ljdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl;Ljava\/lang\/String;ZJ)V\") \\\n+    jvmci_constructor(HotSpotNmethod, \"(Ljdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl;Ljava\/lang\/String;ZZJ)V\") \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -750,0 +750,1 @@\n+                                  bool profile_deopt,\n@@ -764,0 +765,1 @@\n+  _properties.bits._profile_deopt = profile_deopt;\n@@ -767,1 +769,2 @@\n-  initialize(data->_nmethod_mirror_index, data->_nmethod_entry_patch_offset, data->name(), data->_properties.bits._is_default, data->_failed_speculations);\n+  initialize(data->_nmethod_mirror_index, data->_nmethod_entry_patch_offset, data->name(), data->_properties.bits._is_default,\n+             data->_properties.bits._profile_deopt, data->_failed_speculations);\n@@ -2089,0 +2092,1 @@\n+  bool profile_deopt = JVMCIENV->get_HotSpotNmethod_profileDeopt(nmethod_mirror) != 0;\n@@ -2157,0 +2161,1 @@\n+                                                        profile_deopt,\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-      uint8_t _has_name   : 1,\n+      uint8_t _has_name      : 1,\n@@ -58,2 +58,4 @@\n-              _is_default : 1,\n-                          : 6;\n+              _is_default    : 1,\n+      \/\/ HotSpotNmethod.profileDeopt\n+              _profile_deopt : 1,\n+                             : 5;\n@@ -90,0 +92,1 @@\n+                   bool profile_deopt,\n@@ -103,0 +106,1 @@\n+                                  bool profile_deopt,\n@@ -109,0 +113,1 @@\n+                       profile_deopt,\n@@ -156,0 +161,4 @@\n+\n+  bool profile_deopt() {\n+    return _properties.bits._profile_deopt;\n+  }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-  template(method_string_bool_long_signature,                     \"(Ljdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl;Ljava\/lang\/String;ZJ)V\") \\\n+  template(method_string_bool_bool_long_signature,                \"(Ljdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl;Ljava\/lang\/String;ZZJ)V\") \\\n","filename":"src\/hotspot\/share\/jvmci\/vmSymbols_jvmci.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+  NOT_PRODUCT(LOG_TAG(ihash)) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-void* GuardedMemory::wrap_copy(const void* ptr, const size_t len, const void* tag) {\n+void* GuardedMemory::wrap_copy(const void* ptr, const size_t len,\n+                               const void* tag, const void* tag2) {\n@@ -32,1 +33,1 @@\n-    GuardedMemory guarded(outerp, len, tag);\n+    GuardedMemory guarded(outerp, len, tag, tag2);\n@@ -61,2 +62,2 @@\n-      \" tag=\" PTR_FORMAT \" user_size=%zu user_data=\" PTR_FORMAT,\n-      p2i(this), p2i(_base_addr), p2i(get_tag()), get_user_size(), p2i(get_user_ptr()));\n+      \" tag=\" PTR_FORMAT \" tag2=\" PTR_FORMAT \" user_size=%zu user_data=\" PTR_FORMAT,\n+      p2i(this), p2i(_base_addr), p2i(get_tag()), p2i(get_tag2()), get_user_size(), p2i(get_user_ptr()));\n","filename":"src\/hotspot\/share\/memory\/guardedMemory.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -46,0 +47,1 @@\n+ * |+sizeof(uintptr_t) | <tag2>               | Tag word       |\n@@ -52,1 +54,1 @@\n- *  - tag word is general purpose\n+ *  - tag word and tag2 word are general purpose\n@@ -114,0 +116,4 @@\n+      \/\/ We may not be able to dereference directly.\n+      if (!os::is_readable_range((const void*) _guard, (const void*) (_guard + GUARD_SIZE))) {\n+        return false;\n+      }\n@@ -140,0 +146,1 @@\n+    void* _tag2;\n@@ -147,0 +154,2 @@\n+    void set_tag2(const void* tag2) { _tag2 = (void*) tag2; }\n+    void* get_tag2() const { return _tag2; }\n@@ -165,0 +174,1 @@\n+   * @param tag2      optional second general purpose tag.\n@@ -166,2 +176,3 @@\n-  GuardedMemory(void* base_ptr, const size_t user_size, const void* tag = nullptr) {\n-    wrap_with_guards(base_ptr, user_size, tag);\n+  GuardedMemory(void* base_ptr, const size_t user_size,\n+                const void* tag = nullptr, const void* tag2 = nullptr) {\n+    wrap_with_guards(base_ptr, user_size, tag, tag2);\n@@ -192,0 +203,1 @@\n+   * @param tag2      optional second general purpose tag.\n@@ -195,1 +207,2 @@\n-  void* wrap_with_guards(void* base_ptr, size_t user_size, const void* tag = nullptr) {\n+  void* wrap_with_guards(void* base_ptr, size_t user_size,\n+                         const void* tag = nullptr, const void* tag2 = nullptr) {\n@@ -202,0 +215,1 @@\n+    set_tag2(tag2);\n@@ -233,0 +247,14 @@\n+  \/**\n+   * Set the second general purpose tag.\n+   *\n+   * @param tag general purpose tag.\n+   *\/\n+  void set_tag2(const void* tag) { get_head_guard()->set_tag2(tag); }\n+\n+  \/**\n+   * Return the second general purpose tag.\n+   *\n+   * @return the second general purpose tag, defaults to null.\n+   *\/\n+  void* get_tag2() const { return get_head_guard()->get_tag2(); }\n+\n@@ -305,0 +333,1 @@\n+   * @param tag2 optional general purpose tag (see GuardedMemory::get_tag2())\n@@ -308,1 +337,2 @@\n-  static void* wrap_copy(const void* p, const size_t len, const void* tag = nullptr);\n+  static void* wrap_copy(const void* p, const size_t len,\n+                         const void* tag = nullptr, const void* tag2 = nullptr);\n","filename":"src\/hotspot\/share\/memory\/guardedMemory.hpp","additions":36,"deletions":6,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -571,1 +571,1 @@\n-          oop m = java_lang_Class::create_basic_type_mirror(type2name(bt), bt, CHECK);\n+          oop m = java_lang_Class::create_basic_type_mirror(type2name(bt), bt, false, CHECK);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,2 +123,2 @@\n-  oop module = (module_entry != nullptr) ? module_entry->module() : (oop)nullptr;\n-  java_lang_Class::create_mirror(k, Handle(THREAD, k->class_loader()), Handle(THREAD, module), Handle(), Handle(), CHECK);\n+  oop module_oop = (module_entry != nullptr) ? module_entry->module_oop() : (oop)nullptr;\n+  java_lang_Class::create_mirror(k, Handle(THREAD, k->class_loader()), Handle(THREAD, module_oop), Handle(), Handle(), CHECK);\n@@ -303,0 +303,8 @@\n+\n+int ArrayKlass::hash_offset_in_bytes(oop obj, markWord m) const {\n+  assert(UseCompactObjectHeaders, \"only with compact i-hash\");\n+  arrayOop ary = arrayOop(obj);\n+  BasicType type = element_type();\n+  int length = LP64_ONLY(m.array_length()) NOT_LP64(ary->length());\n+  return ary->base_offset_in_bytes(type) + (length << log2_element_size());\n+}\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -79,0 +79,4 @@\n+  \/\/ There is no technical reason preventing us from using other klass pointer bit lengths,\n+  \/\/ but it should be a deliberate choice\n+  ASSERT_HERE(_narrow_klass_pointer_bits == 32 || _narrow_klass_pointer_bits == 19);\n+\n@@ -225,1 +229,6 @@\n-    \/\/ In compact object header mode, with 22-bit narrowKlass, we don't attempt for\n+    \/\/ This handles the case that we - experimentally - reduce the number of\n+    \/\/ class pointer bits further, such that (shift + num bits) < 32.\n+    assert(len <= (size_t)nth_bit(narrow_klass_pointer_bits() + max_shift()),\n+           \"klass range size exceeds encoding, len: %zu, narrow_klass_pointer_bits: %d, max_shift: %d\", len, narrow_klass_pointer_bits(), max_shift());\n+\n+    \/\/ In compact object header mode, with 19-bit narrowKlass, we don't attempt for\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  static constexpr int narrow_klass_pointer_bits_coh = 22;\n+  static constexpr int narrow_klass_pointer_bits_coh = 19;\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -548,1 +548,2 @@\n-  _init_thread(nullptr)\n+  _init_thread(nullptr),\n+  _hash_offset(parser.hash_offset())\n@@ -3825,1 +3826,1 @@\n-  st->print_cr(BULLET\"---- fields (total size %zu words):\", oop_size(obj));\n+  st->print_cr(BULLET\"---- fields (total size %zu words):\", oop_size(obj, obj->mark()));\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -241,0 +241,2 @@\n+  int             _hash_offset;             \/\/ Offset of hidden field for i-hash\n+\n@@ -890,1 +892,1 @@\n-  size_t oop_size(oop obj)  const             { return size_helper(); }\n+  size_t oop_size(oop obj, markWord mark) const { return size_helper(); }\n@@ -951,0 +953,9 @@\n+  virtual int hash_offset_in_bytes(oop obj, markWord m) const {\n+    assert(UseCompactObjectHeaders, \"only with compact i-hash\");\n+    return _hash_offset;\n+  }\n+  static int hash_offset_offset_in_bytes() {\n+    assert(UseCompactObjectHeaders, \"only with compact i-hash\");\n+    return (int)offset_of(InstanceKlass, _hash_offset);\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-instanceOop InstanceMirrorKlass::allocate_instance(Klass* k, TRAPS) {\n+instanceOop InstanceMirrorKlass::allocate_instance(Klass* k, bool extend, TRAPS) {\n@@ -55,2 +55,6 @@\n-  size_t size = instance_size(k);\n-  assert(size > 0, \"total object size must be non-zero: %zu\", size);\n+  size_t base_size = instance_size(k);\n+  size_t size = base_size;\n+  if (extend && UseCompactObjectHeaders) {\n+    size = align_object_size(size + 1);\n+  }\n+  assert(base_size > 0, \"base object size must be non-zero: %zu\", base_size);\n@@ -60,1 +64,6 @@\n-  return (instanceOop)Universe::heap()->class_allocate(this, size, THREAD);\n+  instanceOop obj = (instanceOop)Universe::heap()->class_allocate(this, size, base_size, THREAD);\n+  if (extend && UseCompactObjectHeaders) {\n+    obj->set_mark(obj->mark().set_not_hashed_expanded());\n+    assert(expand_for_hash(obj, obj->mark()), \"must expand for hash\");\n+  }\n+  return obj;\n@@ -63,1 +72,1 @@\n-size_t InstanceMirrorKlass::oop_size(oop obj) const {\n+size_t InstanceMirrorKlass::oop_size(oop obj, markWord mark) const {\n@@ -75,0 +84,10 @@\n+int InstanceMirrorKlass::hash_offset_in_bytes(oop obj, markWord m) const {\n+  assert(UseCompactObjectHeaders, \"only with compact i-hash\");\n+  \/\/ TODO: There may be gaps that we could use, e.g. in the fields of Class,\n+  \/\/ between the fields of Class and the static fields or in or at the end of\n+  \/\/ the static fields block.\n+  \/\/ When implementing any change here, make sure that allocate_instance()\n+  \/\/ and corresponding code in InstanceMirrorKlass.java are in sync.\n+  return checked_cast<int>(obj->base_size_given_klass(m, this) * BytesPerWord);\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/instanceMirrorKlass.cpp","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"utilities\/numberSeq.hpp\"\n@@ -899,1 +900,1 @@\n-  Handle module_handle(THREAD, ((module_entry != nullptr) ? module_entry->module() : (oop)nullptr));\n+  Handle module_handle(THREAD, ((module_entry != nullptr) ? module_entry->module_oop() : (oop)nullptr));\n@@ -1359,0 +1360,13 @@\n+\n+static int expanded = 0;\n+static int not_expanded = 0;\n+static NumberSeq seq = NumberSeq();\n+\n+bool Klass::expand_for_hash(oop obj, markWord m) const {\n+  assert(UseCompactObjectHeaders, \"only with compact i-hash\");\n+  {\n+    ResourceMark rm;\n+    assert((size_t)hash_offset_in_bytes(obj,m ) <= (obj->base_size_given_klass(m, this) * HeapWordSize), \"hash offset must be eq or lt base size: hash offset: %d, base size: %zu, class-name: %s\", hash_offset_in_bytes(obj, m), obj->base_size_given_klass(m, this) * HeapWordSize, external_name());\n+  }\n+  return obj->base_size_given_klass(m, this) * HeapWordSize - hash_offset_in_bytes(obj, m) < (int)sizeof(uint32_t);\n+}\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -641,1 +641,2 @@\n-  virtual size_t oop_size(oop obj) const = 0;\n+  virtual size_t oop_size(oop obj, markWord mark) const = 0;\n+  size_t oop_size(oop obj) const;\n@@ -792,0 +793,4 @@\n+  virtual int hash_offset_in_bytes(oop obj, markWord m) const = 0;\n+  static int kind_offset_in_bytes() { return (int)offset_of(Klass, _kind); }\n+\n+  bool expand_for_hash(oop obj, markWord m) const;\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -187,0 +187,5 @@\n+\n+inline size_t Klass::oop_size(oop obj) const {\n+  return oop_size(obj, obj->mark());\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-size_t ObjArrayKlass::oop_size(oop obj) const {\n+size_t ObjArrayKlass::oop_size(oop obj, markWord mark) const {\n@@ -149,1 +149,2 @@\n-  return objArrayOop(obj)->object_size();\n+  int length = LP64_ONLY(UseCompactObjectHeaders ? mark.array_length() :) objArrayOop(obj)->length();\n+  return objArrayOop(obj)->object_size(length);\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-  size_t oop_size(oop obj) const;\n+  size_t oop_size(oop obj, markWord) const;\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -131,0 +132,17 @@\n+void oopDesc::initialize_hash_if_necessary(oop obj, Klass* k, markWord m) {\n+  assert(UseCompactObjectHeaders, \"only with compact object headers\");\n+  assert(!m.has_displaced_mark_helper(), \"must not be displaced header\");\n+  assert(m.is_hashed_not_expanded(), \"must be hashed but not moved\");\n+  assert(!m.is_hashed_expanded(), \"must not be moved: \" INTPTR_FORMAT, m.value());\n+  uint32_t hash = static_cast<uint32_t>(ObjectSynchronizer::get_next_hash(nullptr, obj));\n+  int offset = k->hash_offset_in_bytes(cast_to_oop(this), m);\n+  assert(offset >= 4, \"hash offset must not be in header\");\n+  log_develop_trace(gc)(\"Initializing hash for \" PTR_FORMAT \", old: \" PTR_FORMAT \", hash: %d, offset: %d, is_mirror: %s\", p2i(this), p2i(obj), hash, offset, BOOL_TO_STR(k->is_mirror_instance_klass()));\n+  int_field_put(offset, (jint) hash);\n+  m = m.set_hashed_expanded();\n+  assert(static_cast<uint32_t>(LightweightSynchronizer::get_hash(m, cast_to_oop(this), k)) == hash,\n+         \"hash must remain the same\");\n+  assert(m.narrow_klass() != 0, \"must not be null\");\n+  set_mark(m);\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-size_t TypeArrayKlass::oop_size(oop obj) const {\n+size_t TypeArrayKlass::oop_size(oop obj, markWord mark) const {\n@@ -180,1 +180,2 @@\n-  return t->object_size(this);\n+  int length = LP64_ONLY(UseCompactObjectHeaders ? mark.array_length() :) t->length();\n+  return t->object_size(this, length);\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  size_t oop_size(oop obj) const;\n+  size_t oop_size(oop obj, markWord mark) const;\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1454,8 +1454,2 @@\n-  if (GenerateSynchronizationCode) {\n-    ins_req(nextmon,   lock->box_node());\n-    ins_req(nextmon+1, lock->obj_node());\n-  } else {\n-    Node* top = Compile::current()->top();\n-    ins_req(nextmon, top);\n-    ins_req(nextmon, top);\n-  }\n+  ins_req(nextmon,   lock->box_node());\n+  ins_req(nextmon+1, lock->obj_node());\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -639,1 +639,1 @@\n-      _stub_id(-1),\n+      _stub_id(StubId::NO_STUBID),\n@@ -901,1 +901,1 @@\n-                 int stub_id,\n+                 StubId stub_id,\n@@ -967,1 +967,2 @@\n-    CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, _stub_id, stub_name);\n+    BlobId blob_id = StubInfo::blob(_stub_id);\n+    CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, blob_id);\n@@ -1382,1 +1383,1 @@\n-      } else if( offset == oopDesc::klass_offset_in_bytes() ) {\n+      } else if( offset == Type::klass_offset() ) {\n@@ -1555,1 +1556,1 @@\n-          (offset == oopDesc::klass_offset_in_bytes() && tj->base() == Type::AryPtr) ||\n+          (offset == Type::klass_offset() && tj->base() == Type::AryPtr) ||\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -311,1 +311,1 @@\n-  int                   _stub_id;               \/\/ unique id for stub or -1\n+  StubId                   _stub_id;               \/\/ unique id for stub or NO_STUBID\n@@ -575,1 +575,1 @@\n-  int               stub_id() const             { return _stub_id; }\n+  StubId            stub_id() const             { return _stub_id; }\n@@ -1148,1 +1148,1 @@\n-          int stub_id, int is_fancy_jump, bool pass_tls,\n+          StubId stub_id, int is_fancy_jump, bool pass_tls,\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3441,1 +3441,1 @@\n-  } else if (offset != oopDesc::klass_offset_in_bytes()) {\n+  } else if (offset != Type::klass_offset()) {\n@@ -4440,1 +4440,1 @@\n-      _compile->get_alias_index(tinst->add_offset(oopDesc::klass_offset_in_bytes()));\n+      _compile->get_alias_index(tinst->add_offset(Type::klass_offset()));\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1217,1 +1217,1 @@\n-  Node* k_adr = basic_plus_adr(obj, oopDesc::klass_offset_in_bytes());\n+  Node* k_adr = basic_plus_adr(obj, Type::klass_offset());\n@@ -3450,2 +3450,0 @@\n-  if( !GenerateSynchronizationCode )\n-    return nullptr;                \/\/ Not locking things?\n@@ -3514,2 +3512,0 @@\n-  if( !GenerateSynchronizationCode )\n-    return;\n@@ -3636,1 +3632,1 @@\n-    set_memory(minit_out, C->get_alias_index(oop_type->add_offset(oopDesc::klass_offset_in_bytes())));\n+    set_memory(minit_out, C->get_alias_index(oop_type->add_offset(Type::klass_offset())));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4698,1 +4698,1 @@\n-  enum { _slow_path = 1, _fast_path, _null_path, PATH_LIMIT };\n+  enum { _slow_path = 1, _null_path, _fast_path, _fast_path2, PATH_LIMIT };\n@@ -4746,6 +4746,34 @@\n-  \/\/ Get the header out of the object, use LoadMarkNode when available\n-  Node* header_addr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());\n-  \/\/ The control of the load must be null. Otherwise, the load can move before\n-  \/\/ the null check after castPP removal.\n-  Node* no_ctrl = nullptr;\n-  Node* header = make_load(no_ctrl, header_addr, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n+  if (UseCompactObjectHeaders) {\n+    \/\/ Get the header out of the object.\n+    Node* header_addr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());\n+    \/\/ The control of the load must be null. Otherwise, the load can move before\n+    \/\/ the null check after castPP removal.\n+    Node* no_ctrl = nullptr;\n+    Node* header = make_load(no_ctrl, header_addr, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n+\n+    \/\/ Test the header to see if the object is in hashed or copied state.\n+    Node* hashctrl_mask  = _gvn.MakeConX(markWord::hashctrl_mask_in_place);\n+    Node* masked_header  = _gvn.transform(new AndXNode(header, hashctrl_mask));\n+\n+    \/\/ Take slow-path when the object has not been hashed.\n+    Node* not_hashed_val = _gvn.MakeConX(0);\n+    Node* chk_hashed     = _gvn.transform(new CmpXNode(masked_header, not_hashed_val));\n+    Node* test_hashed    = _gvn.transform(new BoolNode(chk_hashed, BoolTest::eq));\n+\n+    generate_slow_guard(test_hashed, slow_region);\n+\n+    \/\/ Test whether the object is hashed or hashed&copied.\n+    Node* hashed_copied = _gvn.MakeConX(markWord::hashctrl_expanded_mask_in_place | markWord::hashctrl_hashed_mask_in_place);\n+    Node* chk_copied    = _gvn.transform(new CmpXNode(masked_header, hashed_copied));\n+    \/\/ If true, then object has been hashed&copied, otherwise it's only hashed.\n+    Node* test_copied   = _gvn.transform(new BoolNode(chk_copied, BoolTest::eq));\n+    IfNode* if_copied   = create_and_map_if(control(), test_copied, PROB_FAIR, COUNT_UNKNOWN);\n+    Node* if_true = _gvn.transform(new IfTrueNode(if_copied));\n+    Node* if_false = _gvn.transform(new IfFalseNode(if_copied));\n+\n+    \/\/ Hashed&Copied path: read hash-code out of the object.\n+    set_control(if_true);\n+    \/\/ result_val->del_req(_fast_path2);\n+    \/\/ result_reg->del_req(_fast_path2);\n+    \/\/ result_io->del_req(_fast_path2);\n+    \/\/ result_mem->del_req(_fast_path2);\n@@ -4753,8 +4781,19 @@\n-  if (!UseObjectMonitorTable) {\n-    \/\/ Test the header to see if it is safe to read w.r.t. locking.\n-    Node *lock_mask      = _gvn.MakeConX(markWord::lock_mask_in_place);\n-    Node *lmasked_header = _gvn.transform(new AndXNode(header, lock_mask));\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      Node *monitor_val   = _gvn.MakeConX(markWord::monitor_value);\n-      Node *chk_monitor   = _gvn.transform(new CmpXNode(lmasked_header, monitor_val));\n-      Node *test_monitor  = _gvn.transform(new BoolNode(chk_monitor, BoolTest::eq));\n+    Node* obj_klass = load_object_klass(obj);\n+    Node* hash_addr;\n+    const TypeKlassPtr* klass_t = _gvn.type(obj_klass)->isa_klassptr();\n+    bool load_offset_runtime = true;\n+\n+    if (klass_t != nullptr) {\n+      if (klass_t->klass_is_exact()  && klass_t->isa_instklassptr()) {\n+        ciInstanceKlass* ciKlass = reinterpret_cast<ciInstanceKlass*>(klass_t->is_instklassptr()->exact_klass());\n+        if (!ciKlass->is_mirror_instance_klass() && !ciKlass->is_reference_instance_klass()) {\n+          \/\/ We know the InstanceKlass, load hash_offset from there at compile-time.\n+          int hash_offset = ciKlass->hash_offset_in_bytes();\n+          hash_addr = basic_plus_adr(obj, hash_offset);\n+          Node* loaded_hash = make_load(control(), hash_addr, TypeInt::INT, T_INT, MemNode::unordered);\n+          result_val->init_req(_fast_path2, loaded_hash);\n+          result_reg->init_req(_fast_path2, control());\n+          load_offset_runtime = false;\n+        }\n+      }\n+    }\n@@ -4762,5 +4801,22 @@\n-      generate_slow_guard(test_monitor, slow_region);\n-    } else {\n-      Node *unlocked_val      = _gvn.MakeConX(markWord::unlocked_value);\n-      Node *chk_unlocked      = _gvn.transform(new CmpXNode(lmasked_header, unlocked_val));\n-      Node *test_not_unlocked = _gvn.transform(new BoolNode(chk_unlocked, BoolTest::ne));\n+    \/\/tty->print_cr(\"Load hash-offset at runtime: %s\", BOOL_TO_STR(load_offset_runtime));\n+\n+    if (load_offset_runtime) {\n+      \/\/ We don't know if it is an array or an exact type, figure it out at run-time.\n+      \/\/ If not an ordinary instance, then we need to take slow-path.\n+      Node* kind_addr = basic_plus_adr(obj_klass, Klass::kind_offset_in_bytes());\n+      Node* kind = make_load(control(), kind_addr, TypeInt::INT, T_INT, MemNode::unordered);\n+      Node* instance_val = _gvn.intcon(Klass::InstanceKlassKind);\n+      Node* chk_inst     = _gvn.transform(new CmpINode(kind, instance_val));\n+      Node* test_inst    = _gvn.transform(new BoolNode(chk_inst, BoolTest::ne));\n+      generate_slow_guard(test_inst, slow_region);\n+\n+      \/\/ Otherwise it's an instance and we can read the hash_offset from the InstanceKlass.\n+      Node* hash_offset_addr = basic_plus_adr(obj_klass, InstanceKlass::hash_offset_offset_in_bytes());\n+      Node* hash_offset = make_load(control(), hash_offset_addr, TypeInt::INT, T_INT, MemNode::unordered);\n+      \/\/ hash_offset->dump();\n+      Node* hash_addr = basic_plus_adr(obj, ConvI2X(hash_offset));\n+      Compile::current()->set_has_unsafe_access(true);\n+      Node* loaded_hash = make_load(control(), hash_addr, TypeInt::INT, T_INT, MemNode::unordered);\n+      result_val->init_req(_fast_path2, loaded_hash);\n+      result_reg->init_req(_fast_path2, control());\n+    }\n@@ -4768,1 +4824,78 @@\n-      generate_slow_guard(test_not_unlocked, slow_region);\n+    \/\/ Hashed-only path: recompute hash-code from object address.\n+    set_control(if_false);\n+    if (hashCode == 6) {\n+      \/\/ Our constants.\n+      Node* M = _gvn.intcon(0x337954D5);\n+      Node* A = _gvn.intcon(0xAAAAAAAA);\n+      \/\/ Split object address into lo and hi 32 bits.\n+      Node* obj_addr = _gvn.transform(new CastP2XNode(nullptr, obj));\n+      Node* x = _gvn.transform(new ConvL2INode(obj_addr));\n+      Node* upper_addr = _gvn.transform(new URShiftLNode(obj_addr, _gvn.intcon(32)));\n+      Node* y = _gvn.transform(new ConvL2INode(upper_addr));\n+\n+      Node* H0 = _gvn.transform(new XorINode(x, y));\n+      Node* L0 = _gvn.transform(new XorINode(x, A));\n+\n+      \/\/ Full multiplication of two 32 bit values L0 and M into a hi\/lo result in two 32 bit values V0 and U0.\n+      Node* L0_64 = _gvn.transform(new ConvI2LNode(L0));\n+      L0_64 = _gvn.transform(new AndLNode(L0_64, _gvn.longcon(0xFFFFFFFF)));\n+      Node* M_64 = _gvn.transform(new ConvI2LNode(M));\n+      \/\/ M_64 = _gvn.transform(new AndLNode(M_64, _gvn.longcon(0xFFFFFFFF)));\n+      Node* prod64 = _gvn.transform(new MulLNode(L0_64, M_64));\n+      Node* V0 = _gvn.transform(new ConvL2INode(prod64));\n+      Node* prod_upper = _gvn.transform(new URShiftLNode(prod64, _gvn.intcon(32)));\n+      Node* U0 = _gvn.transform(new ConvL2INode(prod_upper));\n+\n+      Node* Q0 = _gvn.transform(new MulINode(H0, M));\n+      Node* L1 = _gvn.transform(new XorINode(Q0, U0));\n+\n+      \/\/ Full multiplication of two 32 bit values L1 and M into a hi\/lo result in two 32 bit values V1 and U1.\n+      Node* L1_64 = _gvn.transform(new ConvI2LNode(L1));\n+      L1_64 = _gvn.transform(new AndLNode(L1_64, _gvn.longcon(0xFFFFFFFF)));\n+      prod64 = _gvn.transform(new MulLNode(L1_64, M_64));\n+      Node* V1 = _gvn.transform(new ConvL2INode(prod64));\n+      prod_upper = _gvn.transform(new URShiftLNode(prod64, _gvn.intcon(32)));\n+      Node* U1 = _gvn.transform(new ConvL2INode(prod_upper));\n+\n+      Node* P1 = _gvn.transform(new XorINode(V0, M));\n+\n+      \/\/ Right rotate P1 by distance L1.\n+      Node* distance = _gvn.transform(new AndINode(L1, _gvn.intcon(32 - 1)));\n+      Node* inverse_distance = _gvn.transform(new SubINode(_gvn.intcon(32), distance));\n+      Node* ror_part1 = _gvn.transform(new URShiftINode(P1, distance));\n+      Node* ror_part2 = _gvn.transform(new LShiftINode(P1, inverse_distance));\n+      Node* Q1 = _gvn.transform(new OrINode(ror_part1, ror_part2));\n+\n+      Node* L2 = _gvn.transform(new XorINode(Q1, U1));\n+      Node* hash = _gvn.transform(new XorINode(V1, L2));\n+      Node* hash_truncated = _gvn.transform(new AndINode(hash, _gvn.intcon(markWord::hash_mask)));\n+\n+      result_val->init_req(_fast_path, hash_truncated);\n+    } else if (hashCode == 2) {\n+      result_val->init_req(_fast_path, _gvn.intcon(1));\n+    }\n+  } else {\n+    \/\/ Get the header out of the object, use LoadMarkNode when available\n+    Node* header_addr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());\n+    \/\/ The control of the load must be null. Otherwise, the load can move before\n+    \/\/ the null check after castPP removal.\n+    Node* no_ctrl = nullptr;\n+    Node* header = make_load(no_ctrl, header_addr, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n+\n+    if (!UseObjectMonitorTable) {\n+      \/\/ Test the header to see if it is safe to read w.r.t. locking.\n+      Node *lock_mask      = _gvn.MakeConX(markWord::lock_mask_in_place);\n+      Node *lmasked_header = _gvn.transform(new AndXNode(header, lock_mask));\n+      if (LockingMode == LM_LIGHTWEIGHT) {\n+        Node *monitor_val   = _gvn.MakeConX(markWord::monitor_value);\n+        Node *chk_monitor   = _gvn.transform(new CmpXNode(lmasked_header, monitor_val));\n+        Node *test_monitor  = _gvn.transform(new BoolNode(chk_monitor, BoolTest::eq));\n+\n+        generate_slow_guard(test_monitor, slow_region);\n+      } else {\n+        Node *unlocked_val      = _gvn.MakeConX(markWord::unlocked_value);\n+        Node *chk_unlocked      = _gvn.transform(new CmpXNode(lmasked_header, unlocked_val));\n+        Node *test_not_unlocked = _gvn.transform(new BoolNode(chk_unlocked, BoolTest::ne));\n+\n+        generate_slow_guard(test_not_unlocked, slow_region);\n+      }\n@@ -4770,14 +4903,13 @@\n-  }\n-  \/\/ Get the hash value and check to see that it has been properly assigned.\n-  \/\/ We depend on hash_mask being at most 32 bits and avoid the use of\n-  \/\/ hash_mask_in_place because it could be larger than 32 bits in a 64-bit\n-  \/\/ vm: see markWord.hpp.\n-  Node *hash_mask      = _gvn.intcon(markWord::hash_mask);\n-  Node *hash_shift     = _gvn.intcon(markWord::hash_shift);\n-  Node *hshifted_header= _gvn.transform(new URShiftXNode(header, hash_shift));\n-  \/\/ This hack lets the hash bits live anywhere in the mark object now, as long\n-  \/\/ as the shift drops the relevant bits into the low 32 bits.  Note that\n-  \/\/ Java spec says that HashCode is an int so there's no point in capturing\n-  \/\/ an 'X'-sized hashcode (32 in 32-bit build or 64 in 64-bit build).\n-  hshifted_header      = ConvX2I(hshifted_header);\n-  Node *hash_val       = _gvn.transform(new AndINode(hshifted_header, hash_mask));\n+    \/\/ Get the hash value and check to see that it has been properly assigned.\n+    \/\/ We depend on hash_mask being at most 32 bits and avoid the use of\n+    \/\/ hash_mask_in_place because it could be larger than 32 bits in a 64-bit\n+    \/\/ vm: see markWord.hpp.\n+    Node *hash_mask      = _gvn.intcon(markWord::hash_mask);\n+    Node *hash_shift     = _gvn.intcon(markWord::hash_shift);\n+    Node *hshifted_header= _gvn.transform(new URShiftXNode(header, hash_shift));\n+    \/\/ This hack lets the hash bits live anywhere in the mark object now, as long\n+    \/\/ as the shift drops the relevant bits into the low 32 bits.  Note that\n+    \/\/ Java spec says that HashCode is an int so there's no point in capturing\n+    \/\/ an 'X'-sized hashcode (32 in 32-bit build or 64 in 64-bit build).\n+    hshifted_header      = ConvX2I(hshifted_header);\n+    Node *hash_val       = _gvn.transform(new AndINode(hshifted_header, hash_mask));\n@@ -4786,3 +4918,3 @@\n-  Node *no_hash_val    = _gvn.intcon(markWord::no_hash);\n-  Node *chk_assigned   = _gvn.transform(new CmpINode( hash_val, no_hash_val));\n-  Node *test_assigned  = _gvn.transform(new BoolNode( chk_assigned, BoolTest::eq));\n+    Node *no_hash_val    = _gvn.intcon(markWord::no_hash);\n+    Node *chk_assigned   = _gvn.transform(new CmpINode( hash_val, no_hash_val));\n+    Node *test_assigned  = _gvn.transform(new BoolNode( chk_assigned, BoolTest::eq));\n@@ -4790,1 +4922,10 @@\n-  generate_slow_guard(test_assigned, slow_region);\n+    generate_slow_guard(test_assigned, slow_region);\n+\n+    result_val->init_req(_fast_path, hash_val);\n+\n+    \/\/ _fast_path2 is not used here.\n+    result_val->del_req(_fast_path2);\n+    result_reg->del_req(_fast_path2);\n+    result_io->del_req(_fast_path2);\n+    result_mem->del_req(_fast_path2);\n+  }\n@@ -4797,1 +4938,0 @@\n-  result_val->init_req(_fast_path, hash_val);\n@@ -4802,0 +4942,5 @@\n+  if (UseCompactObjectHeaders) {\n+    result_io->init_req(_fast_path2, i_o());\n+    result_mem->init_req(_fast_path2, init_mem);\n+  }\n+\n@@ -4803,0 +4948,1 @@\n+  assert(slow_region != nullptr, \"must have slow_region\");\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":186,"deletions":40,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -1713,1 +1713,1 @@\n-    rawmem = make_store(control, rawmem, object, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);\n+    rawmem = make_store(control, rawmem, object, Type::klass_offset(), klass_node, T_METADATA);\n@@ -2340,1 +2340,1 @@\n-      Node* k_adr = basic_plus_adr(obj_or_subklass, oopDesc::klass_offset_in_bytes());\n+      Node* k_adr = basic_plus_adr(obj_or_subklass, Type::klass_offset());\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2520,16 +2520,1 @@\n-    case Op_LoadVectorGather:\n-      if (is_subword_type(n->bottom_type()->is_vect()->element_basic_type())) {\n-        Node* pair = new BinaryNode(n->in(MemNode::ValueIn), n->in(MemNode::ValueIn+1));\n-        n->set_req(MemNode::ValueIn, pair);\n-        n->del_req(MemNode::ValueIn+1);\n-      }\n-      break;\n-    case Op_LoadVectorGatherMasked:\n-      if (is_subword_type(n->bottom_type()->is_vect()->element_basic_type())) {\n-        Node* pair2 = new BinaryNode(n->in(MemNode::ValueIn + 1), n->in(MemNode::ValueIn + 2));\n-        Node* pair1 = new BinaryNode(n->in(MemNode::ValueIn), pair2);\n-        n->set_req(MemNode::ValueIn, pair1);\n-        n->del_req(MemNode::ValueIn+2);\n-        n->del_req(MemNode::ValueIn+1);\n-        break;\n-      } \/\/ fall-through\n+    case Op_LoadVectorGatherMasked: \/\/ fall-through\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-          adr_check->offset() == oopDesc::klass_offset_in_bytes() ||\n+          adr_check->offset() == Type::klass_offset() ||\n@@ -953,1 +953,1 @@\n-           adr_type->offset() == oopDesc::klass_offset_in_bytes()),\n+           adr_type->offset() == Type::klass_offset()),\n@@ -2464,1 +2464,1 @@\n-    if (offset == oopDesc::klass_offset_in_bytes()) {\n+    if (offset == Type::klass_offset()) {\n@@ -2472,1 +2472,1 @@\n-      tary->offset() == oopDesc::klass_offset_in_bytes()) {\n+      tary->offset() == Type::klass_offset()) {\n@@ -2538,1 +2538,1 @@\n-  if (offset == oopDesc::klass_offset_in_bytes()) {\n+  if (offset == Type::klass_offset()) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1077,2 +1077,1 @@\n-            num_mon > 0 ||\n-            !GenerateSynchronizationCode,\n+            num_mon > 0,\n@@ -3493,1 +3492,2 @@\n-        AOTCodeCache::store_code_blob(*rs, AOTCodeEntry::C2Blob, C->stub_id(), stub_name);\n+        BlobId blob_id = StubInfo::blob(C->stub_id());\n+        AOTCodeCache::store_code_blob(*rs, AOTCodeEntry::C2Blob, blob_id);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1068,1 +1068,1 @@\n-  bool do_synch = method()->is_synchronized() && GenerateSynchronizationCode;\n+  bool do_synch = method()->is_synchronized();\n@@ -2122,1 +2122,1 @@\n-  Node* klass_addr = basic_plus_adr( receiver, receiver, oopDesc::klass_offset_in_bytes() );\n+  Node* klass_addr = basic_plus_adr( receiver, receiver, Type::klass_offset() );\n@@ -2192,1 +2192,1 @@\n-  if (method()->is_synchronized() && GenerateSynchronizationCode) {\n+  if (method()->is_synchronized()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-  type OptoRuntime:: BLOB_FIELD_NAME(name)  = nullptr;\n+  type* OptoRuntime:: BLOB_FIELD_NAME(name)  = nullptr;\n@@ -102,10 +102,0 @@\n-#define C2_BLOB_NAME_DEFINE(name, type)  \"C2 Runtime \" # name \"_blob\",\n-#define C2_STUB_NAME_DEFINE(name, f, t, r)  \"C2 Runtime \" # name,\n-#define C2_JVMTI_STUB_NAME_DEFINE(name)  \"C2 Runtime \" # name,\n-const char* OptoRuntime::_stub_names[] = {\n-  C2_STUBS_DO(C2_BLOB_NAME_DEFINE, C2_STUB_NAME_DEFINE, C2_JVMTI_STUB_NAME_DEFINE)\n-};\n-#undef C2_BLOB_NAME_DEFINE\n-#undef C2_STUB_NAME_DEFINE\n-#undef C2_JVMTI_STUB_NAME_DEFINE\n-\n@@ -142,2 +132,2 @@\n-#define C2_STUB_NAME(name) stub_name(OptoStubId::name ## _id)\n-#define C2_STUB_ID(name) OptoStubId::name ## _id\n+#define C2_STUB_ID(name) StubId:: JOIN3(c2, name, id)\n+#define C2_STUB_NAME(name) stub_name(C2_STUB_ID(name))\n@@ -160,1 +150,1 @@\n-                  (int)C2_STUB_ID(name),                              \\\n+                  C2_STUB_ID(name),                                   \\\n@@ -174,1 +164,1 @@\n-                  (int)C2_STUB_ID(name),                              \\\n+                  C2_STUB_ID(name),                                   \\\n@@ -282,1 +272,1 @@\n-                                   const char *name, int stub_id,\n+                                   const char *name, StubId stub_id,\n@@ -437,1 +427,1 @@\n-    const size_t size = TypeArrayKlass::cast(array_type)->oop_size(result);\n+    const size_t size = TypeArrayKlass::cast(array_type)->oop_size(result, result->mark());\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":7,"deletions":17,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/stubInfo.hpp\"\n@@ -100,14 +101,0 @@\n-\/\/ define OptoStubId enum tags: uncommon_trap_id etc\n-\n-#define C2_BLOB_ID_ENUM_DECLARE(name, type) STUB_ID_NAME(name),\n-#define C2_STUB_ID_ENUM_DECLARE(name, f, t, r) STUB_ID_NAME(name),\n-#define C2_JVMTI_STUB_ID_ENUM_DECLARE(name) STUB_ID_NAME(name),\n-enum class OptoStubId :int {\n-  NO_STUBID = -1,\n-  C2_STUBS_DO(C2_BLOB_ID_ENUM_DECLARE, C2_STUB_ID_ENUM_DECLARE, C2_JVMTI_STUB_ID_ENUM_DECLARE)\n-  NUM_STUBIDS\n-};\n-#undef C2_BLOB_ID_ENUM_DECLARE\n-#undef C2_STUB_ID_ENUM_DECLARE\n-#undef C2_JVMTI_STUB_ID_ENUM_DECLARE\n-\n@@ -121,1 +108,1 @@\n-  static type        BLOB_FIELD_NAME(name);\n+  static type*       BLOB_FIELD_NAME(name);\n@@ -216,4 +203,1 @@\n-  \/\/ Stub names indexed by sharedStubId\n-  static const char *_stub_names[];\n-\n-  static address generate_stub(ciEnv* ci_env, TypeFunc_generator gen, address C_function, const char* name, int stub_id, int is_fancy_jump, bool pass_tls, bool return_pc);\n+  static address generate_stub(ciEnv* ci_env, TypeFunc_generator gen, address C_function, const char* name, StubId stub_id, int is_fancy_jump, bool pass_tls, bool return_pc);\n@@ -286,3 +270,3 @@\n-  static const char* stub_name(OptoStubId id) {\n-    assert(id > OptoStubId::NO_STUBID && id < OptoStubId::NUM_STUBIDS, \"stub id out of range\");\n-    return _stub_names[(int)id];\n+  static const char* stub_name(StubId id) {\n+    assert(StubInfo::is_c2(id), \"not a C2 stub %s\", StubInfo::name(id));\n+    return StubInfo::name(id);\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":6,"deletions":22,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1181,1 +1181,1 @@\n-  if (con2 == oopDesc::klass_offset_in_bytes()) {\n+  if (con2 == Type::klass_offset()) {\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -578,1 +578,1 @@\n-                                           false, nullptr, oopDesc::klass_offset_in_bytes());\n+                                           false, nullptr, Type::klass_offset());\n@@ -3453,1 +3453,1 @@\n-    if (_offset == oopDesc::klass_offset_in_bytes()) {\n+    if (_offset == Type::klass_offset()) {\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -203,0 +203,11 @@\n+  \/\/ This is used as a marker to identify narrow Klass* loads, which\n+  \/\/ are really extracted from the mark-word, but we still want to\n+  \/\/ distinguish it.\n+  static int klass_offset() {\n+    if (UseCompactObjectHeaders) {\n+      return 1;\n+    } else {\n+      return oopDesc::klass_offset_in_bytes();\n+    }\n+  }\n+\n@@ -1622,1 +1633,1 @@\n-        _offset != arrayOopDesc::klass_offset_in_bytes()) {\n+        _offset != Type::klass_offset()) {\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1206,12 +1206,13 @@\n-\/\/ <C,\n-\/\/  V extends Vector<?>,\n-\/\/  W extends Vector<Integer>,\n-\/\/  S extends VectorSpecies<E>,\n-\/\/  M extends VectorMask<E>,\n-\/\/  E>\n-\/\/ V loadWithMap(Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType, int length,\n-\/\/               Class<? extends Vector<Integer>> vectorIndexClass,\n-\/\/               Object base, long offset, \/\/ Unsafe addressing\n-\/\/               W index_vector, M m,\n-\/\/               C container, int index, int[] indexMap, int indexM, S s, \/\/ Arguments for default implementation\n-\/\/               LoadVectorOperationWithMap<C, V, E, S, M> defaultImpl)\n+\/\/\n+\/\/  <C,\n+\/\/   V extends Vector<?>,\n+\/\/   W extends Vector<Integer>,\n+\/\/   S extends VectorSpecies<E>,\n+\/\/   M extends VectorMask<E>,\n+\/\/   E>\n+\/\/   V loadWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass, int length,\n+\/\/                 Class<? extends Vector<Integer>> vectorIndexClass, int indexLength,\n+\/\/                 Object base, long offset,\n+\/\/                 W indexVector1, W indexVector2, W indexVector3, W indexVector4,\n+\/\/                 M m, C container, int index, int[] indexMap, int indexM, S s,\n+\/\/                 LoadVectorOperationWithMap<C, V, S, M> defaultImpl)\n@@ -1224,5 +1225,6 @@\n-\/\/  void storeWithMap(Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType,\n-\/\/                    int length, Class<? extends Vector<Integer>> vectorIndexClass, Object base, long offset,    \/\/ Unsafe addressing\n-\/\/                    W index_vector, V v, M m,\n-\/\/                    C container, int index, int[] indexMap, int indexM, \/\/ Arguments for default implementation\n-\/\/                    StoreVectorOperationWithMap<C, V, M, E> defaultImpl)\n+\/\/   void storeWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass, int length,\n+\/\/                     Class<? extends Vector<Integer>> vectorIndexClass, int indexLength,\n+\/\/                     Object base, long offset, \/\/ Unsafe addressing\n+\/\/                     W indexVector, V v, M m,\n+\/\/                     C container, int index, int[] indexMap, int indexM, \/\/ Arguments for default implementation\n+\/\/                     StoreVectorOperationWithMap<C, V, M> defaultImpl)\n@@ -1236,0 +1238,1 @@\n+  const TypeInt*     idx_vlen         = gvn().type(argument(5))->isa_int();\n@@ -1240,2 +1243,3 @@\n-      vector_idx_klass == nullptr || vector_idx_klass->const_oop() == nullptr) {\n-    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s viclass=%s\",\n+      vector_idx_klass == nullptr || vector_idx_klass->const_oop() == nullptr ||\n+      idx_vlen         == nullptr || !idx_vlen->is_con()) {\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s viclass=%s idx_vlen=%s\",\n@@ -1245,1 +1249,2 @@\n-                    NodeClassNames[argument(4)->Opcode()]);\n+                    NodeClassNames[argument(4)->Opcode()],\n+                    NodeClassNames[argument(5)->Opcode()]);\n@@ -1262,0 +1267,1 @@\n+  int idx_num_elem = idx_vlen->get_con();\n@@ -1263,1 +1269,2 @@\n-  const Type* vmask_type = gvn().type(is_scatter ? argument(10) : argument(9));\n+  Node* m = is_scatter ? argument(11) : argument(13);\n+  const Type* vmask_type = gvn().type(m);\n@@ -1301,5 +1308,5 @@\n-  if (!is_subword_type(elem_bt) && !arch_supports_vector(Op_LoadVector, num_elem, T_INT, VecMaskNotUsed)) {\n-      log_if_needed(\"  ** not supported: arity=%d op=%s\/loadindex vlen=%d etype=int is_masked_op=%d\",\n-                      is_scatter, is_scatter ? \"scatter\" : \"gather\",\n-                      num_elem, is_masked_op ? 1 : 0);\n-      return false; \/\/ not supported\n+  if (!is_subword_type(elem_bt) && !arch_supports_vector(Op_LoadVector, idx_num_elem, T_INT, VecMaskNotUsed)) {\n+    log_if_needed(\"  ** not supported: arity=%d op=%s\/loadindex vlen=%d etype=int is_masked_op=%d\",\n+                  is_scatter, is_scatter ? \"scatter\" : \"gather\",\n+                  idx_num_elem, is_masked_op ? 1 : 0);\n+    return false; \/\/ not supported\n@@ -1308,2 +1315,2 @@\n-  Node* base = argument(5);\n-  Node* offset = ConvL2X(argument(6));\n+  Node* base = argument(6);\n+  Node* offset = ConvL2X(argument(7));\n@@ -1315,1 +1322,11 @@\n-  Node* addr = make_unsafe_address(base, offset, elem_bt, true);\n+  Node* addr = nullptr;\n+  if (!is_subword_type(elem_bt)) {\n+    addr = make_unsafe_address(base, offset, elem_bt, true);\n+  } else {\n+    assert(!is_scatter, \"Only supports gather operation for subword types now\");\n+    uint header = arrayOopDesc::base_offset_in_bytes(elem_bt);\n+    assert(offset->is_Con() && offset->bottom_type()->is_long()->get_con() == header,\n+           \"offset must be the array base offset\");\n+    Node* index = argument(15);\n+    addr = array_element_address(base, index, elem_bt);\n+  }\n@@ -1317,1 +1334,1 @@\n-  const TypePtr *addr_type = gvn().type(addr)->isa_ptr();\n+  const TypePtr* addr_type = gvn().type(addr)->isa_ptr();\n@@ -1339,1 +1356,2 @@\n-  Node* index_vect = nullptr;\n+  \/\/ Get the indexes for gather\/scatter.\n+  Node* indexes = nullptr;\n@@ -1341,3 +1359,8 @@\n-  if (!is_subword_type(elem_bt)) {\n-    index_vect = unbox_vector(argument(8), vbox_idx_type, T_INT, num_elem);\n-    if (index_vect == nullptr) {\n+  if (is_subword_type(elem_bt)) {\n+    Node* indexMap = argument(16);\n+    Node* indexM   = argument(17);\n+    indexes = array_element_address(indexMap, indexM, T_INT);\n+  } else {\n+    \/\/ Get the first index vector.\n+    indexes = unbox_vector(argument(9), vbox_idx_type, T_INT, idx_num_elem);\n+    if (indexes == nullptr) {\n@@ -1350,0 +1373,1 @@\n+  \/\/ Get the vector mask value.\n@@ -1354,1 +1378,1 @@\n-    mask = unbox_vector(is_scatter ? argument(10) : argument(9), mbox_type, elem_bt, num_elem);\n+    mask = unbox_vector(m, mbox_type, elem_bt, num_elem);\n@@ -1356,3 +1380,1 @@\n-      log_if_needed(\"  ** unbox failed mask=%s\",\n-                    is_scatter ? NodeClassNames[argument(10)->Opcode()]\n-                               : NodeClassNames[argument(9)->Opcode()]);\n+      log_if_needed(\"  ** unbox failed mask=%s\", NodeClassNames[m->Opcode()]);\n@@ -1367,1 +1389,1 @@\n-    Node* val = unbox_vector(argument(9), vbox_type, elem_bt, num_elem);\n+    Node* val = unbox_vector(argument(10), vbox_type, elem_bt, num_elem);\n@@ -1377,1 +1399,1 @@\n-      vstore = gvn().transform(new StoreVectorScatterMaskedNode(control(), memory(addr), addr, addr_type, val, index_vect, mask));\n+      vstore = gvn().transform(new StoreVectorScatterMaskedNode(control(), memory(addr), addr, addr_type, val, indexes, mask));\n@@ -1379,1 +1401,1 @@\n-      vstore = gvn().transform(new StoreVectorScatterNode(control(), memory(addr), addr, addr_type, val, index_vect));\n+      vstore = gvn().transform(new StoreVectorScatterNode(control(), memory(addr), addr, addr_type, val, indexes));\n@@ -1384,9 +1406,1 @@\n-    Node* index    = argument(11);\n-    Node* indexMap = argument(12);\n-    Node* indexM   = argument(13);\n-      if (is_subword_type(elem_bt)) {\n-        Node* index_arr_base = array_element_address(indexMap, indexM, T_INT);\n-        vload = gvn().transform(new LoadVectorGatherMaskedNode(control(), memory(addr), addr, addr_type, vector_type, index_arr_base, mask, index));\n-      } else {\n-        vload = gvn().transform(new LoadVectorGatherMaskedNode(control(), memory(addr), addr, addr_type, vector_type, index_vect, mask));\n-      }\n+      vload = gvn().transform(new LoadVectorGatherMaskedNode(control(), memory(addr), addr, addr_type, vector_type, indexes, mask));\n@@ -1395,6 +1409,1 @@\n-      if (is_subword_type(elem_bt)) {\n-        Node* index_arr_base = array_element_address(indexMap, indexM, T_INT);\n-        vload = gvn().transform(new LoadVectorGatherNode(control(), memory(addr), addr, addr_type, vector_type, index_arr_base, index));\n-      } else {\n-        vload = gvn().transform(new LoadVectorGatherNode(control(), memory(addr), addr, addr_type, vector_type, index_vect));\n-      }\n+      vload = gvn().transform(new LoadVectorGatherNode(control(), memory(addr), addr, addr_type, vector_type, indexes));\n@@ -1407,1 +1416,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":65,"deletions":57,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -1120,1 +1120,1 @@\n-  LoadVectorGatherNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* offset = nullptr)\n+  LoadVectorGatherNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices)\n@@ -1126,4 +1126,0 @@\n-    assert(is_subword || !offset, \"\");\n-    if (offset) {\n-      add_req(offset);\n-    }\n@@ -1135,4 +1131,1 @@\n-     return idx == MemNode::Address ||\n-            idx == MemNode::ValueIn ||\n-            ((is_subword_type(vect_type()->element_basic_type())) &&\n-              idx == MemNode::ValueIn + 1);\n+     return idx == MemNode::Address || idx == MemNode::ValueIn;\n@@ -1257,1 +1250,1 @@\n-  LoadVectorGatherMaskedNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* mask, Node* offset = nullptr)\n+  LoadVectorGatherMaskedNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* mask)\n@@ -1263,3 +1256,1 @@\n-    if (is_subword_type(vt->element_basic_type())) {\n-      add_req(offset);\n-    }\n+    assert(is_subword_type(vt->element_basic_type()) || indices->bottom_type()->is_vect(), \"indices must be in vector\");\n@@ -1271,3 +1262,1 @@\n-                                                   idx == MemNode::ValueIn + 1 ||\n-                                                   (is_subword_type(vect_type()->is_vect()->element_basic_type()) &&\n-                                                   idx == MemNode::ValueIn + 2); }\n+                                                   idx == MemNode::ValueIn + 1; }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -353,0 +353,9 @@\n+\/\/ Arbitrary (but well-known) tag for GetStringChars\n+const void* STRING_TAG = (void*)0x47114711;\n+\n+\/\/ Arbitrary (but well-known) tag for GetStringUTFChars\n+const void* STRING_UTF_TAG = (void*) 0x48124812;\n+\n+\/\/ Arbitrary (but well-known) tag for GetPrimitiveArrayCritical\n+const void* CRITICAL_TAG = (void*)0x49134913;\n+\n@@ -358,1 +367,1 @@\n-    void* orig_elements) {\n+                                       void* orig_elements, jboolean is_critical = JNI_FALSE) {\n@@ -364,1 +373,1 @@\n-    result = GuardedMemory::wrap_copy(orig_elements, len, orig_elements);\n+    result = GuardedMemory::wrap_copy(orig_elements, len, orig_elements, is_critical ? CRITICAL_TAG : nullptr);\n@@ -370,1 +379,1 @@\n-    void* obj, void* carray, size_t* rsz) {\n+                                 void* obj, void* carray, size_t* rsz, jboolean is_critical) {\n@@ -389,0 +398,23 @@\n+  if (orig_result == STRING_TAG || orig_result == STRING_UTF_TAG) {\n+    bool was_utf = orig_result == STRING_UTF_TAG;\n+    tty->print_cr(\"%s: called on something allocated by %s\",\n+                  fn_name, was_utf ? \"GetStringUTFChars\" : \"GetStringChars\");\n+    DEBUG_ONLY(guarded.print_on(tty);) \/\/ This may crash.\n+    NativeReportJNIFatalError(thr, err_msg(\"%s called on something allocated by %s\",\n+                                           fn_name, was_utf ? \"GetStringUTFChars\" : \"GetStringChars\"));\n+  }\n+\n+  if (is_critical && (guarded.get_tag2() != CRITICAL_TAG)) {\n+    tty->print_cr(\"%s: called on something not allocated by GetPrimitiveArrayCritical\", fn_name);\n+    DEBUG_ONLY(guarded.print_on(tty);) \/\/ This may crash.\n+    NativeReportJNIFatalError(thr, err_msg(\"%s called on something not allocated by GetPrimitiveArrayCritical\",\n+                                           fn_name));\n+  }\n+\n+  if (!is_critical && (guarded.get_tag2() == CRITICAL_TAG)) {\n+    tty->print_cr(\"%s: called on something allocated by GetPrimitiveArrayCritical\", fn_name);\n+    DEBUG_ONLY(guarded.print_on(tty);) \/\/ This may crash.\n+    NativeReportJNIFatalError(thr, err_msg(\"%s called on something allocated by GetPrimitiveArrayCritical\",\n+                                           fn_name));\n+  }\n+\n@@ -398,1 +430,1 @@\n-  void* orig_result = check_wrapped_array(thr, fn_name, obj, carray, &sz);\n+  void* orig_result = check_wrapped_array(thr, fn_name, obj, carray, &sz, is_critical);\n@@ -1433,3 +1465,0 @@\n-\/\/ Arbitrary (but well-known) tag\n-const void* STRING_TAG = (void*)0x47114711;\n-\n@@ -1538,3 +1567,0 @@\n-\/\/ Arbitrary (but well-known) tag - different than GetStringChars\n-const void* STRING_UTF_TAG = (void*) 0x48124812;\n-\n@@ -1862,1 +1888,1 @@\n-      result = check_jni_wrap_copy_array(thr, array, result);\n+      result = check_jni_wrap_copy_array(thr, array, result, JNI_TRUE);\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":37,"deletions":11,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -85,5 +86,1 @@\n-  return _next;\n-}\n-\n-void JvmtiAgent::set_next(JvmtiAgent* agent) {\n-  _next = agent;\n+  return Atomic::load_acquire(&_next);\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-  void set_next(JvmtiAgent* agent);\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-JvmtiAgent* JvmtiAgentList::_list = nullptr;\n+JvmtiAgent* JvmtiAgentList::_head = nullptr;\n@@ -64,19 +64,1 @@\n-static inline JvmtiAgent* head(JvmtiAgent** list) {\n-  assert(list != nullptr, \"invariant\");\n-  return Atomic::load_acquire(list);\n-}\n-\n-\/\/ The storage list is a single cas-linked-list, to allow for concurrent iterations.\n-\/\/ Especially during initial loading of agents, there exist an order requirement to iterate oldest -> newest.\n-\/\/ Our concurrent storage linked-list is newest -> oldest.\n-\/\/ The correct order is preserved by the iterator, by storing a filtered set of entries in a stack.\n-JvmtiAgentList::Iterator::Iterator(JvmtiAgent** list, Filter filter) :\n-  _stack(new GrowableArrayCHeap<JvmtiAgent*, mtServiceability>(16)), _filter(filter) {\n-  JvmtiAgent* next = head(list);\n-  while (next != nullptr) {\n-    next = select(next);\n-    if (next != nullptr) {\n-      _stack->push(next);\n-      next = next->next();\n-    }\n-  }\n+JvmtiAgentList::Iterator::Iterator(JvmtiAgent* head, Filter filter) : _filter(filter), _next(select(head)) {\n@@ -86,7 +68,1 @@\n-  assert(_stack != nullptr, \"invariant\");\n-  return _stack->is_nonempty();\n-}\n-\n-const JvmtiAgent* JvmtiAgentList::Iterator::next() const {\n-  assert(has_next(), \"invariant\");\n-  return _stack->pop();\n+  return _next != nullptr;\n@@ -96,1 +72,5 @@\n-  return const_cast<JvmtiAgent*>(const_cast<const Iterator*>(this)->next());\n+  assert(_next != nullptr, \"must be\");\n+  JvmtiAgent* result = _next;\n+  _next = select(_next->next());\n+  return result;\n+\n@@ -100,1 +80,1 @@\n-  return Iterator(&_list, Iterator::NOT_XRUN);\n+  return Iterator(head(), Iterator::NOT_XRUN);\n@@ -104,1 +84,1 @@\n-  return Iterator(&_list, Iterator::JAVA);\n+  return Iterator(head(), Iterator::JAVA);\n@@ -108,1 +88,1 @@\n-  return Iterator(&_list, Iterator::NATIVE);\n+  return Iterator(head(), Iterator::NATIVE);\n@@ -112,1 +92,1 @@\n-  return Iterator(&_list, Iterator::XRUN);\n+  return Iterator(head(), Iterator::XRUN);\n@@ -116,1 +96,1 @@\n-  return Iterator(&_list, Iterator::ALL);\n+  return Iterator(head(), Iterator::ALL);\n@@ -121,5 +101,16 @@\n-  JvmtiAgent* next;\n-  do {\n-    next = head(&_list);\n-    agent->set_next(next);\n-  } while (Atomic::cmpxchg(&_list, next, agent) != next);\n+\n+  \/\/ address of the pointer to add new agent (&_head when the list is empty or &agent->_next of the last agent in the list)\n+  JvmtiAgent** tail_ptr = &_head;\n+  while (true) {\n+    JvmtiAgent* next = Atomic::load(tail_ptr);\n+    if (next == nullptr) {\n+      \/\/ *tail_ptr == nullptr here\n+      if (Atomic::cmpxchg(tail_ptr, (JvmtiAgent*)nullptr, agent) != nullptr) {\n+        \/\/ another thread added an agent, reload next from tail_ptr\n+        continue;\n+      }\n+      \/\/ successfully set, exit\n+      break;\n+    }\n+    tail_ptr = &next->_next;\n+  }\n@@ -146,0 +137,4 @@\n+JvmtiAgent* JvmtiAgentList::head() {\n+  return Atomic::load_acquire(&_head);\n+}\n+\n@@ -286,1 +281,1 @@\n-  _list = nullptr; \/\/ Pretend that no agents have been added.\n+  _head = nullptr; \/\/ Pretend that no agents have been added.\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.cpp","additions":34,"deletions":39,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"nmt\/memTag.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n@@ -34,1 +32,1 @@\n-\/\/ Maintains a single cas linked-list of JvmtiAgents.\n+\/\/ Maintains thread-safe linked list of JvmtiAgents.\n@@ -36,1 +34,0 @@\n-  friend class Iterator;\n@@ -49,3 +46,3 @@\n-    GrowableArrayCHeap<JvmtiAgent*, mtServiceability>* _stack;\n-    Iterator() : _stack(nullptr), _filter(ALL) {}\n-    Iterator(JvmtiAgent** list, Filter filter);\n+    JvmtiAgent* _next;\n+    Iterator(): _filter(ALL), _next(nullptr) {}\n+    Iterator(JvmtiAgent* head, Filter filter);\n@@ -57,2 +54,0 @@\n-    const JvmtiAgent* next() const NOT_JVMTI_RETURN_(nullptr);\n-    ~Iterator() { delete _stack; }\n@@ -62,1 +57,3 @@\n-  static JvmtiAgent* _list;\n+  static JvmtiAgent* _head;\n+\n+  static JvmtiAgent* head();\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.hpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"classfile\/classLoaderExt.hpp\"\n@@ -678,1 +677,1 @@\n-    ClassLoaderExt::append_boot_classpath(zip_entry);\n+    ClassLoader::append_boot_classpath(zip_entry);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -946,1 +946,1 @@\n-            module_entry->module() != nullptr &&\n+            module_entry->module_oop() != nullptr &&\n@@ -951,1 +951,1 @@\n-            Handle class_module(_thread, module_entry->module()); \/\/ Obtain j.l.r.Module\n+            Handle class_module(_thread, module_entry->module_oop()); \/\/ Obtain j.l.r.Module\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -947,0 +947,1 @@\n+  assert(o != nullptr, \"Heap iteration should never produce null!\");\n@@ -956,1 +957,1 @@\n-  if (o != nullptr && o->klass()->java_mirror() == nullptr) {\n+  if (o->klass()->java_mirror() == nullptr) {\n@@ -1035,0 +1036,1 @@\n+  assert(obj != nullptr, \"Heap iteration should never produce null!\");\n@@ -1042,1 +1044,1 @@\n-  if (obj != nullptr &&   obj->klass()->java_mirror() == nullptr) {\n+  if (obj->klass()->java_mirror() == nullptr) {\n@@ -2781,1 +2783,1 @@\n-  CLDToOopClosure cld_closure(&blk, false);\n+  CLDToOopClosure cld_closure(&blk, ClassLoaderData::_claim_none);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3768,0 +3768,3 @@\n+  if (UseCompactObjectHeaders && FLAG_IS_DEFAULT(hashCode)) {\n+    hashCode = 6;\n+  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2370,1 +2370,1 @@\n-    if (nm->is_jvmci_hosted()) {\n+    if (nm->jvmci_skip_profile_deopt()) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -954,4 +954,0 @@\n-  develop(bool, GenerateSynchronizationCode, true,                          \\\n-          \"generate locking\/unlocking code for synchronized methods and \"   \\\n-          \"monitors\")                                                       \\\n-                                                                            \\\n@@ -1408,1 +1404,1 @@\n-  product(size_t, CompressedClassSpaceSize, 1*G,                            \\\n+  product(size_t, CompressedClassSpaceSize, 128*M,                          \\\n@@ -1573,3 +1569,1 @@\n-          \"Start aggressive sweeping if X[%] of the code cache is free.\"    \\\n-          \"Segmented code cache: X[%] of the non-profiled heap.\"            \\\n-          \"Non-segmented code cache: X[%] of the total code cache\")         \\\n+          \"Start aggressive sweeping if less than X[%] of the total code cache is free.\")\\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+void initialize_stub_info();    \/\/ must precede all blob\/stub generation\n@@ -133,0 +134,2 @@\n+  \/\/ ensure we know about all blobs, stubs and entries\n+  initialize_stub_info();\n@@ -149,1 +152,1 @@\n-  initial_stubs_init();      \/\/ initial stub routines\n+  initial_stubs_init();      \/\/ stubgen initial stub routines\n@@ -151,0 +154,1 @@\n+  AOTCodeCache::init_early_stubs_table();  \/\/ need this after stubgen initial stubs and before shared runtime initial stubs\n@@ -152,1 +156,0 @@\n-  AOTCodeCache::init_early_stubs_table();  \/\/ need this after initial_stubs\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -474,3 +474,2 @@\n-  Universe::heap()->print_tracing_info();\n-  \/\/ Stop concurrent GC threads\n-  Universe::heap()->stop();\n+  \/\/ Run before exit and then stop concurrent GC threads\n+  Universe::heap()->before_exit();\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -87,1 +87,0 @@\n-Mutex*   CompileTaskAlloc_lock        = nullptr;\n@@ -349,1 +348,0 @@\n-  MUTEX_DEFL(CompileTaskAlloc_lock          , PaddedMutex  , MethodCompileQueue_lock);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,0 @@\n-extern Mutex*   CompileTaskAlloc_lock;           \/\/ a lock held when CompileTasks are allocated\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1128,1 +1128,1 @@\n-  const JvmtiAgentList::Iterator it = JvmtiAgentList::all();\n+  JvmtiAgentList::Iterator it = JvmtiAgentList::all();\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -296,0 +296,2 @@\n+  static double elapsed_process_cpu_time();\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -554,3 +554,3 @@\n-        oop jlm = module_to->module();\n-        assert(jlm != nullptr, \"Null jlm in module_to ModuleEntry\");\n-        intptr_t identity_hash = jlm->identity_hash();\n+        oop module_oop = module_to->module_oop();\n+        assert(module_oop != nullptr, \"should have been initialized\");\n+        intptr_t identity_hash = module_oop->identity_hash();\n@@ -581,3 +581,3 @@\n-        oop jlm = module_from->module();\n-        assert(jlm != nullptr, \"Null jlm in module_from ModuleEntry\");\n-        intptr_t identity_hash = jlm->identity_hash();\n+        oop module_oop = module_from->module_oop();\n+        assert(module_oop != nullptr, \"should have been initialized\");\n+        intptr_t identity_hash = module_oop->identity_hash();\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-  type        SharedRuntime::BLOB_FIELD_NAME(name);\n+  type*       SharedRuntime::BLOB_FIELD_NAME(name);\n@@ -104,0 +104,2 @@\n+#if 0\n+\/\/ TODO tweak global stub name generation to match this\n@@ -108,0 +110,1 @@\n+#endif\n@@ -113,1 +116,1 @@\n-    generate_throw_exception(SharedStubId::throw_StackOverflowError_id,\n+    generate_throw_exception(StubId::shared_throw_StackOverflowError_id,\n@@ -119,1 +122,1 @@\n-    generate_resolve_blob(SharedStubId::wrong_method_id,\n+    generate_resolve_blob(StubId::shared_wrong_method_id,\n@@ -122,1 +125,1 @@\n-    generate_resolve_blob(SharedStubId::wrong_method_abstract_id,\n+    generate_resolve_blob(StubId::shared_wrong_method_abstract_id,\n@@ -125,1 +128,1 @@\n-    generate_resolve_blob(SharedStubId::ic_miss_id,\n+    generate_resolve_blob(StubId::shared_ic_miss_id,\n@@ -128,1 +131,1 @@\n-    generate_resolve_blob(SharedStubId::resolve_opt_virtual_call_id,\n+    generate_resolve_blob(StubId::shared_resolve_opt_virtual_call_id,\n@@ -131,1 +134,1 @@\n-    generate_resolve_blob(SharedStubId::resolve_virtual_call_id,\n+    generate_resolve_blob(StubId::shared_resolve_virtual_call_id,\n@@ -134,1 +137,1 @@\n-    generate_resolve_blob(SharedStubId::resolve_static_call_id,\n+    generate_resolve_blob(StubId::shared_resolve_static_call_id,\n@@ -138,1 +141,1 @@\n-    generate_throw_exception(SharedStubId::throw_delayed_StackOverflowError_id,\n+    generate_throw_exception(StubId::shared_throw_delayed_StackOverflowError_id,\n@@ -142,1 +145,1 @@\n-    generate_throw_exception(SharedStubId::throw_AbstractMethodError_id,\n+    generate_throw_exception(StubId::shared_throw_AbstractMethodError_id,\n@@ -146,1 +149,1 @@\n-    generate_throw_exception(SharedStubId::throw_IncompatibleClassChangeError_id,\n+    generate_throw_exception(StubId::shared_throw_IncompatibleClassChangeError_id,\n@@ -150,1 +153,1 @@\n-    generate_throw_exception(SharedStubId::throw_NullPointerException_at_call_id,\n+    generate_throw_exception(StubId::shared_throw_NullPointerException_at_call_id,\n@@ -158,1 +161,1 @@\n-      generate_handler_blob(SharedStubId::polling_page_vectors_safepoint_handler_id,\n+      generate_handler_blob(StubId::shared_polling_page_vectors_safepoint_handler_id,\n@@ -163,1 +166,1 @@\n-    generate_handler_blob(SharedStubId::polling_page_safepoint_handler_id,\n+    generate_handler_blob(StubId::shared_polling_page_safepoint_handler_id,\n@@ -166,1 +169,1 @@\n-    generate_handler_blob(SharedStubId::polling_page_return_handler_id,\n+    generate_handler_blob(StubId::shared_polling_page_return_handler_id,\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"runtime\/stubDeclarations.hpp\"\n+#include \"runtime\/stubInfo.hpp\"\n@@ -48,10 +48,0 @@\n-\/\/ define SharedStubId enum tags: wrong_method_id, etc\n-\n-#define SHARED_STUB_ID_ENUM_DECLARE(name, type) STUB_ID_NAME(name),\n-enum class SharedStubId :int {\n-  NO_STUBID = -1,\n-  SHARED_STUBS_DO(SHARED_STUB_ID_ENUM_DECLARE)\n-  NUM_STUBIDS\n-};\n-#undef SHARED_STUB_ID_ENUM_DECLARE\n-\n@@ -62,1 +52,1 @@\n-  static type        BLOB_FIELD_NAME(name);\n+  static type*       BLOB_FIELD_NAME(name);\n@@ -67,7 +57,7 @@\n-  static bool is_resolve_id(SharedStubId id) {\n-    return (id == SharedStubId::wrong_method_id ||\n-            id == SharedStubId::wrong_method_abstract_id ||\n-            id == SharedStubId::ic_miss_id ||\n-            id == SharedStubId::resolve_opt_virtual_call_id ||\n-            id == SharedStubId::resolve_virtual_call_id ||\n-            id == SharedStubId::resolve_static_call_id);\n+  static bool is_resolve_id(StubId id) {\n+    return (id == StubId::shared_wrong_method_id ||\n+            id == StubId::shared_wrong_method_abstract_id ||\n+            id == StubId::shared_ic_miss_id ||\n+            id == StubId::shared_resolve_opt_virtual_call_id ||\n+            id == StubId::shared_resolve_virtual_call_id ||\n+            id == StubId::shared_resolve_static_call_id);\n@@ -75,4 +65,4 @@\n-  static bool is_polling_page_id(SharedStubId id) {\n-    return (id == SharedStubId::polling_page_vectors_safepoint_handler_id ||\n-            id == SharedStubId::polling_page_safepoint_handler_id ||\n-            id == SharedStubId::polling_page_return_handler_id);\n+  static bool is_polling_page_id(StubId id) {\n+    return (id == StubId::shared_polling_page_vectors_safepoint_handler_id ||\n+            id == StubId::shared_polling_page_safepoint_handler_id ||\n+            id == StubId::shared_polling_page_return_handler_id);\n@@ -80,6 +70,6 @@\n-  static bool is_throw_id(SharedStubId id) {\n-    return (id == SharedStubId::throw_AbstractMethodError_id ||\n-            id == SharedStubId::throw_IncompatibleClassChangeError_id ||\n-            id == SharedStubId::throw_NullPointerException_at_call_id ||\n-            id == SharedStubId::throw_StackOverflowError_id ||\n-            id == SharedStubId::throw_delayed_StackOverflowError_id);\n+  static bool is_throw_id(StubId id) {\n+    return (id == StubId::shared_throw_AbstractMethodError_id ||\n+            id == StubId::shared_throw_IncompatibleClassChangeError_id ||\n+            id == StubId::shared_throw_NullPointerException_at_call_id ||\n+            id == StubId::shared_throw_StackOverflowError_id ||\n+            id == StubId::shared_throw_delayed_StackOverflowError_id);\n@@ -95,3 +85,0 @@\n-  \/\/ Stub names indexed by SharedStubId\n-  static const char *_stub_names[];\n-\n@@ -104,3 +91,3 @@\n-  static SafepointBlob* generate_handler_blob(SharedStubId id, address call_ptr);\n-  static RuntimeStub*   generate_resolve_blob(SharedStubId id, address destination);\n-  static RuntimeStub*   generate_throw_exception(SharedStubId id, address runtime_entry);\n+  static SafepointBlob* generate_handler_blob(StubId id, address call_ptr);\n+  static RuntimeStub*   generate_resolve_blob(StubId id, address destination);\n+  static RuntimeStub*   generate_throw_exception(StubId id, address runtime_entry);\n@@ -121,3 +108,3 @@\n-  static const char *stub_name(SharedStubId id) {\n-    assert(id > SharedStubId::NO_STUBID && id < SharedStubId::NUM_STUBIDS, \"stub id out of range\");\n-    return _stub_names[(int)id];\n+  static const char *stub_name(StubId id) {\n+    assert(StubInfo::is_shared(id), \"not a shared stub %s\", StubInfo::name(id));\n+    return StubInfo::name(id);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":25,"deletions":38,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-  _blob_id = StubGenBlobId::NO_BLOBID;\n+  _blob_id = BlobId::NO_BLOBID;\n@@ -76,1 +76,3 @@\n-StubCodeGenerator::StubCodeGenerator(CodeBuffer* code, StubGenBlobId blob_id, bool print_code) {\n+StubCodeGenerator::StubCodeGenerator(CodeBuffer* code, BlobId blob_id, bool print_code) {\n+  assert(StubInfo::is_stubgen(blob_id),\n+         \"not a stubgen blob %s\", StubInfo::name(blob_id));\n@@ -122,1 +124,1 @@\n-void StubCodeGenerator::verify_stub(StubGenStubId stub_id) {\n+void StubCodeGenerator::verify_stub(StubId stub_id) {\n@@ -137,1 +139,1 @@\n-StubCodeMark::StubCodeMark(StubCodeGenerator* cgen, StubGenStubId stub_id) : StubCodeMark(cgen, \"StubRoutines\", StubRoutines::get_stub_name(stub_id)) {\n+StubCodeMark::StubCodeMark(StubCodeGenerator* cgen, StubId stub_id) : StubCodeMark(cgen, \"StubRoutines\", StubRoutines::get_stub_name(stub_id)) {\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"runtime\/stubInfo.hpp\"\n@@ -101,3 +102,0 @@\n-enum StubGenBlobId : int;\n-enum StubGenStubId : int;\n-\n@@ -110,1 +108,1 @@\n-  StubGenBlobId _blob_id;\n+  BlobId _blob_id;\n@@ -116,1 +114,1 @@\n-  StubCodeGenerator(CodeBuffer* code, StubGenBlobId blob_id, bool print_code = false);\n+  StubCodeGenerator(CodeBuffer* code, BlobId blob_id, bool print_code = false);\n@@ -120,1 +118,1 @@\n-  StubGenBlobId blob_id()                        { return _blob_id; }\n+  BlobId blob_id()                               { return _blob_id; }\n@@ -126,1 +124,1 @@\n-  void verify_stub(StubGenStubId stub_id);\n+  void verify_stub(StubId stub_id);\n@@ -142,1 +140,1 @@\n-  StubCodeMark(StubCodeGenerator* cgen, StubGenStubId stub_id);\n+  StubCodeMark(StubCodeGenerator* cgen, StubId stub_id);\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.hpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"code\/codeBlob.hpp\"\n+#include \"oops\/klass.hpp\"\n@@ -31,2 +33,17 @@\n-\/\/ macros for generating definitions and declarations for shared, c1\n-\/\/ and opto blob fields and associated stub ids\n+\/\/ Macros for generating definitions and declarations for shared, c1,\n+\/\/ opto and stubgen blobs and associated stub and entry ids.\n+\/\/\n+\/\/ The template macros that follow define blobs, stubs and entries in\n+\/\/ each stub group. Invocations of the macros with different macro\n+\/\/ arguments can be used to generate definitions and declarations of\n+\/\/ types, data and methods\/functions which support blob, stub and\n+\/\/ entry management.\n+\/\/\n+\/\/ In particular, they are used to generate 3 global enums that list\n+\/\/ all blobs, stubs and entries across stub groups. They are also used\n+\/\/ to generate local (per-stub group) enums listing every stub in the\n+\/\/ group. The former are provided ot allow systematic management of\n+\/\/ blobs, stubs and entries by generic code. The latter are used by\n+\/\/ code which generates and consumes stubs in a specific group. An API\n+\/\/ is provided to convert between global and local ids where needed\n+\/\/ (see class StubInfo).\n@@ -34,2 +51,25 @@\n-\/\/ Different shared stubs can have different blob types and may\n-\/\/ include some JFR stubs\n+\/\/ Shared stub declarations\n+\/\/\n+\/\/ Every shared stub has a unique associated blob whose type must be\n+\/\/ defined as part of the stub declaration. The blob type determines\n+\/\/ how many entries are associated with the stub, normally 1. A build\n+\/\/ may optionally include some JFR stubs.\n+\/\/\n+\/\/ n.b resolve, handler and throw stubs must remain grouped\n+\/\/ contiguously and in the same order so that id values can be range\n+\/\/ checked\n+\/\/\n+\/\/ Alongside the global and local enums, shared declations are used to\n+\/\/ generate the following code elements in class SharedRuntime:\n+\/\/\n+\/\/ Shared Stub blob fields\n+\/\/\n+\/\/ Static field declarations\/definitons for fields of class\n+\/\/ SharedRuntime are generated to store shared blobs\n+\/\/\n+\/\/ static <blobtype>* _<stubname>;\n+\/\/\n+\/\/ Shared stub field names\n+\/\/\n+\/\/ Stubs are provided with names in the format \"Shared Runtime\n+\/\/ <stubname> _blob\".\n@@ -37,2 +77,0 @@\n-\/\/ n.b resolve, handler and throw stubs must remain grouped in the\n-\/\/ same order to allow id values to be range checked\n@@ -43,2 +81,2 @@\n-  do_blob(jfr_write_checkpoint, RuntimeStub*)                          \\\n-  do_blob(jfr_return_lease, RuntimeStub*)                              \\\n+  do_blob(jfr_write_checkpoint, RuntimeStub)                           \\\n+  do_blob(jfr_return_lease, RuntimeStub)                               \\\n@@ -54,1 +92,1 @@\n-  do_blob(deopt, DeoptimizationBlob*)                                  \\\n+  do_blob(deopt, DeoptimizationBlob)                                   \\\n@@ -56,6 +94,6 @@\n-  do_blob(wrong_method, RuntimeStub*)                                  \\\n-  do_blob(wrong_method_abstract, RuntimeStub*)                         \\\n-  do_blob(ic_miss, RuntimeStub*)                                       \\\n-  do_blob(resolve_opt_virtual_call, RuntimeStub*)                      \\\n-  do_blob(resolve_virtual_call, RuntimeStub*)                          \\\n-  do_blob(resolve_static_call, RuntimeStub*)                           \\\n+  do_blob(wrong_method, RuntimeStub)                                   \\\n+  do_blob(wrong_method_abstract, RuntimeStub)                          \\\n+  do_blob(ic_miss, RuntimeStub)                                        \\\n+  do_blob(resolve_opt_virtual_call, RuntimeStub)                       \\\n+  do_blob(resolve_virtual_call, RuntimeStub)                           \\\n+  do_blob(resolve_static_call, RuntimeStub)                            \\\n@@ -63,3 +101,3 @@\n-  do_blob(polling_page_vectors_safepoint_handler, SafepointBlob*)      \\\n-  do_blob(polling_page_safepoint_handler, SafepointBlob*)              \\\n-  do_blob(polling_page_return_handler, SafepointBlob*)                 \\\n+  do_blob(polling_page_vectors_safepoint_handler, SafepointBlob)       \\\n+  do_blob(polling_page_safepoint_handler, SafepointBlob)               \\\n+  do_blob(polling_page_return_handler, SafepointBlob)                  \\\n@@ -67,5 +105,5 @@\n-  do_blob(throw_AbstractMethodError, RuntimeStub*)                     \\\n-  do_blob(throw_IncompatibleClassChangeError, RuntimeStub*)            \\\n-  do_blob(throw_NullPointerException_at_call, RuntimeStub*)            \\\n-  do_blob(throw_StackOverflowError, RuntimeStub*)                      \\\n-  do_blob(throw_delayed_StackOverflowError, RuntimeStub*)              \\\n+  do_blob(throw_AbstractMethodError, RuntimeStub)                      \\\n+  do_blob(throw_IncompatibleClassChangeError, RuntimeStub)             \\\n+  do_blob(throw_NullPointerException_at_call, RuntimeStub)             \\\n+  do_blob(throw_StackOverflowError, RuntimeStub)                       \\\n+  do_blob(throw_delayed_StackOverflowError, RuntimeStub)               \\\n@@ -75,1 +113,6 @@\n-\/\/ C1 stubs are always generated in a generic CodeBlob\n+\/\/ C1 stub declarations\n+\/\/\n+\/\/ C1 stubs are always generated in a unique associated generic\n+\/\/ CodeBlob with a single entry. C1 stubs are stored in an array\n+\/\/ indexed by local enum. So, no other code elements need to be\n+\/\/ generated via this macro.\n@@ -121,2 +164,1 @@\n-\/\/ Opto stubs can be stored as entries with just an address or as\n-\/\/ blobs of different types. The former may include some JVMTI stubs.\n+\/\/ C2 stub declarations\n@@ -124,1 +166,9 @@\n-\/\/ n.b. blobs and stub defines are generated in the order defined by\n+\/\/ C2 stubs are always generated in a unique associated generic\n+\/\/ CodeBlob and have a single entry. In some cases, including JVMTI\n+\/\/ stubs, a standard code blob is employed and only the stub entry\n+\/\/ address is retained. In others a specialized code blob with\n+\/\/ stub-specific properties (e.g. frame size) is required so the blob\n+\/\/ address needs to be stored. In these latter cases the declaration\n+\/\/ includes the relevant storage type.\n+\/\/\n+\/\/ n.b. blob and stub enum tags are generated in the order defined by\n@@ -129,0 +179,21 @@\n+\/\/\n+\/\/ Alongside the local and global enums, C2 declarations are used to\n+\/\/ generate several elements of class OptoRuntime.\n+\/\/\n+\/\/ C2 Stub blob\/address fields\n+\/\/\n+\/\/ Static field declarations\/definitions for fields of class\n+\/\/ OptoRuntime are generated to store either C2 blob or C2 blob entry\n+\/\/ addresses:\n+\/\/\n+\/\/ static <blobtype>* _<stubname>_Java;\n+\/\/ static address _<stubname>;\n+\/\/\n+\/\/ C2 stub blob\/field names\n+\/\/\n+\/\/ C2 stubs are provided with names in the format \"C2 Runtime\n+\/\/ <stubname> _blob\".\n+\/\/\n+\/\/ A stub creation method OptoRuntime::generate(ciEnv* env) is\n+\/\/ generated which invokes the C2 compiler to generate each stub in\n+\/\/ declaration order.\n@@ -149,3 +220,11 @@\n-\/\/ n.b. non-jvmti stubs may employ a special type of jump (0, 1 or 2)\n-\/\/ and require access to TLS and the return pc. jvmti stubs always\n-\/\/ employ jump 0, and require no special access\n+\/\/ do_blob is used for stubs that are generated via direct invocation\n+\/\/ of the assembler to write into a blob of the appropriate type\n+\/\/\n+\/\/ do_stub is used for stubs that are generated as C2 compiler IR\n+\/\/ intrinsics, using the supplied arguments to determine wheher nodes\n+\/\/ in the IR graph employ a special type of jump (0, 1 or 2) or\n+\/\/ provide access to TLS and the return pc.\n+\/\/\n+\/\/ do_jvmti_stub generates a JVMTI stub as an IR intrinsic which\n+\/\/ employs jump 0, and requires no special access\n+\n@@ -153,2 +232,2 @@\n-  do_blob(uncommon_trap, UncommonTrapBlob*)                            \\\n-  do_blob(exception, ExceptionBlob*)                                   \\\n+  do_blob(uncommon_trap, UncommonTrapBlob)                             \\\n+  do_blob(exception, ExceptionBlob)                                    \\\n@@ -175,1 +254,3 @@\n-\/\/ Stub Generator Blobs and Stubs Overview\n+\/\/ Stubgen stub declarations\n+\/\/\n+\/\/ Stub Generator Blobs, Stubs and Entries Overview\n@@ -186,1 +267,4 @@\n-\/\/ Creation of each successive BufferBlobs is staged to ensure that\n+\/\/ Most StubGen stubs have a single entry point. However, in some\n+\/\/ cases there are additional entry points.\n+\/\/\n+\/\/ Creation of each successive BufferBlob is staged to ensure that\n@@ -188,1 +272,1 @@\n-\/\/ initialized before generated code attempt to reference data or\n+\/\/ initialized before generated code attempts to reference data or\n@@ -193,42 +277,21 @@\n-\/\/ StubGenerator stubs are declared using template macros, one set of\n-\/\/ declarations per blob (see below), with arch-specific stubs for any\n-\/\/ gven blob declared after generic stubs for that blob. Blobs are\n-\/\/ created in a fixed order during startup, which is reflected in the\n-\/\/ order of the declaration set. Stubs within a blob are currently\n-\/\/ created in an order determined by the arch-specific generator code\n-\/\/ which may not reflect the order of stub declarations. It is not\n-\/\/ straightforward to enforce a strict ordering. not least because\n-\/\/ arch-specific stub creation may need to be interleaved with generic\n-\/\/ stub creation.\n-\/\/\n-\/\/ Blob and stub declaration templates are used to generate a variety\n-\/\/ of C++ code elements needed to manage stubs.\n-\/\/\n-\/\/ Blob identifiers:\n-\/\/\n-\/\/ public enum StubGenBlobId is generated to identify each of the\n-\/\/ StubGenerator blobs in blob declaration order. This enum is\n-\/\/ provided for use by client code to identify a specific blob. For a\n-\/\/ blob declared with name <blob_name> the associated enum value is\n-\/\/ StubGenBlobId::<blob_name>_id.\n-\/\/\n-\/\/ Global stub identifiers:\n-\/\/\n-\/\/ public enum StubGenStubId is generated to identify all declared\n-\/\/ stubs across all blobs, sorted first by blob declaration order and\n-\/\/ then within a blob by stub declaration order, generic stubs before\n-\/\/ arch-specific stubs. This enum is provided for use by client code\n-\/\/ to identify a specific stub, independent of the blob it belongs to.\n-\/\/ For a stub declared with name <stub_name> the associated enum value\n-\/\/ is StubGenStubId::<stub_name>_id.\n-\/\/\n-\/\/ Blob-local stub identifiers:\n-\/\/\n-\/\/ For each blob <blob_name>, public enum StubGenStubId_<blob_name> is\n-\/\/ generated to enumerate all stubs within the blob in stub\n-\/\/ declaration order, generic stubs before arch-specific stubs. This\n-\/\/ enum is provided only in a non-product build and is intended for\n-\/\/ internal use by class StubRoutines to validate stub declarations.\n-\/\/ For a stub declared with name <stub_name> belonging to blob\n-\/\/ <blob_name> the associated enum value is\n-\/\/ StubGenStubId::<blob_name>_<stub_name>_id.\n+\/\/ StubGen blobs, stubs and entries are declared using template\n+\/\/ macros, grouped hierarchically by blob and stub, with arch-specific\n+\/\/ stubs for any given blob declared after generic stubs for that\n+\/\/ blob. Stub declarations must follow the blob start (do_blob)\n+\/\/ declaration for their containing blob. Entry declarations must\n+\/\/ follow the the stub start (do_stub) declaration for their\n+\/\/ containing stub.\n+\/\/\n+\/\/ Blob and stub declarations are used to generate a variety of C++\n+\/\/ code elements needed to manage stubs, including the global and\n+\/\/ local blob, stub and entry enum types mentioned above. The blob\n+\/\/ declaration order must reflect the order in which blob create\n+\/\/ operations are invoked during startup. Stubs within a blob are\n+\/\/ currently generated in an order determined by the arch-specific\n+\/\/ generator code which may not always reflect the order of stub\n+\/\/ declarations (it is not straightforward to enforce a strict\n+\/\/ ordering, not least because arch-specific stub creation may need to\n+\/\/ be interleaved with generic stub creation).\n+\/\/\n+\/\/ Alongside the global enums, the stubgen declarations are used to\n+\/\/ define the following elements of class StubRoutines:\n@@ -238,5 +301,2 @@\n-\/\/ Two private static fields are generated to hold the names of the\n-\/\/ four generated blobs and all the generated stubs.\n-\/\/\n-\/\/  const char* StubRoutines::_blob_names[];\n-\/\/  const char* StubRoutines::_stub_names[];\n+\/\/ Name strings are generated for each blob where a blob declared with\n+\/\/ name argument <blob_name> will be named using string \"<blob_name>\".\n@@ -244,5 +304,3 @@\n-\/\/ The entry in _blob_names for a blob declared with name <blob_name>\n-\/\/ will be \"<blob_name>\".\n-\/\/\n-\/\/ The entry in _stub_names for a stub declared with name <stub_name>\n-\/\/ will be \"<stub_name>\".\n+\/\/ Name strings are also generated for each stub where a stub declared\n+\/\/ with name argument <stub_name> will be named using string\n+\/\/ \"<stub_name>\".\n@@ -253,2 +311,2 @@\n-\/\/  const char* StubRoutines::get_blob_name(StubGenBlobId id)\n-\/\/  const char* StubRoutines::get_stub_name(StubGenStubId id)\n+\/\/  const char* StubRoutines::get_blob_name(BlobId id)\n+\/\/  const char* StubRoutines::get_stub_name(StubId id)\n@@ -352,1 +410,0 @@\n-\n@@ -418,1 +475,2 @@\n-\/\/ The do_stub template receives a blob name and stub name as argument.\n+\/\/ The do_stub template receives a blob name and stub name as\n+\/\/ argument.\n@@ -422,5 +480,6 @@\n-\/\/ do_stub is primarily used to define a global enum tag for a stub\n-\/\/ and a constant string name, both for use by client code. It is also\n-\/\/ used to declare a tag within the blob-local enum type used to\n-\/\/ validate correct use of stubs within their declared blob. Finally,\n-\/\/ it is also used to declare a name for each stub.\n+\/\/ do_stub is primarily used to define values associated with the stub\n+\/\/ wiht name stub_name, a global enum tag for it and a constant string\n+\/\/ name, both for use by client code. It is also used to declare a tag\n+\/\/ within the blob-local enum type used to validate correct use of\n+\/\/ stubs within their declared blob. Finally, it is also used to\n+\/\/ declare a name string for the stub.\n@@ -456,0 +515,8 @@\n+\/\/ All the above entry macros are used to declare enum tages that\n+\/\/ identify the entry. Three different enums are generated via these\n+\/\/ macros: a per-stub enum that indexes and provides a count for the\n+\/\/ entries associated with the owning stub; a per-blob enume that\n+\/\/ indexes and provides a count for the entries associated with the\n+\/\/ owning blob; and a global enum that indexes and provides a count\n+\/\/ for all entries associated with generated stubs.\n+\/\/\n@@ -637,1 +704,2 @@\n-                                      do_arch_entry, do_arch_entry_init) \\\n+                                      do_arch_entry,                    \\\n+                                      do_arch_entry_init)               \\\n@@ -642,1 +710,1 @@\n-  do_entry(continuation, cont_prempt, cont_preempt_stub,                \\\n+  do_entry(continuation, cont_preempt, cont_preempt_stub,               \\\n@@ -651,1 +719,1 @@\n-  STUBGEN_CONTINUATION_BLOBS_ARCH_DO(do_stub,  do_arch_blob,            \\\n+  STUBGEN_CONTINUATION_BLOBS_ARCH_DO(do_stub, do_arch_blob,             \\\n@@ -805,1 +873,1 @@\n-  STUBGEN_COMPILER_BLOBS_ARCH_DO(do_stub,  do_arch_blob,                \\\n+  STUBGEN_COMPILER_BLOBS_ARCH_DO(do_stub, do_arch_blob,                 \\\n@@ -974,0 +1042,41 @@\n+\/\/ The whole shebang!\n+\/\/\n+\/\/ client macro for emitting StubGenerator blobs, stubs and entries\n+\n+#define STUBGEN_ALL_DO(do_blob, end_blob,                               \\\n+                       do_stub,                                         \\\n+                       do_entry, do_entry_init,                         \\\n+                       do_entry_array,                                  \\\n+                       do_arch_blob,                                    \\\n+                       do_arch_entry, do_arch_entry_init)               \\\n+  STUBGEN_PREUNIVERSE_BLOBS_DO(do_blob, end_blob,                       \\\n+                               do_stub,                                 \\\n+                               do_entry, do_entry_init,                 \\\n+                               do_entry_array,                          \\\n+                               do_arch_blob,                            \\\n+                               do_arch_entry, do_arch_entry_init)       \\\n+  STUBGEN_INITIAL_BLOBS_DO(do_blob, end_blob,                           \\\n+                           do_stub,                                     \\\n+                           do_entry, do_entry_init,                     \\\n+                           do_entry_array,                              \\\n+                           do_arch_blob,                                \\\n+                           do_arch_entry, do_arch_entry_init)           \\\n+  STUBGEN_CONTINUATION_BLOBS_DO(do_blob, end_blob,                      \\\n+                                do_stub,                                \\\n+                                do_entry, do_entry_init,                \\\n+                                do_entry_array,                         \\\n+                                do_arch_blob,                           \\\n+                                do_arch_entry, do_arch_entry_init)      \\\n+  STUBGEN_COMPILER_BLOBS_DO(do_blob, end_blob,                          \\\n+                            do_stub,                                    \\\n+                            do_entry, do_entry_init,                    \\\n+                            do_entry_array,                             \\\n+                            do_arch_blob,                               \\\n+                            do_arch_entry, do_arch_entry_init)          \\\n+  STUBGEN_FINAL_BLOBS_DO(do_blob, end_blob,                             \\\n+                         do_stub,                                       \\\n+                         do_entry, do_entry_init,                       \\\n+                         do_entry_array,                                \\\n+                         do_arch_blob,                                  \\\n+                         do_arch_entry, do_arch_entry_init)             \\\n+\n@@ -976,1 +1085,10 @@\n-#define STUB_ID_NAME(base) base##_id\n+#define JOIN2(name, suffix)                     \\\n+  name ## _ ## suffix\n+\n+#define JOIN3(prefix, name, suffix)             \\\n+  prefix ## _ ## name ## _ ## suffix\n+\n+#define JOIN4(prefix, prefix2, name, suffix)            \\\n+  prefix ## _ ## prefix2 ## _ ## name ## _ ## suffix\n+\n+#define STUB_ID_NAME(base) JOIN2(base, id)\n@@ -984,1 +1102,1 @@\n-#define BLOB_FIELD_NAME(base) _##base##_blob\n+#define BLOB_FIELD_NAME(base) _## base ## _blob\n@@ -990,0 +1108,23 @@\n+\/\/ first some macros that add an increment\n+\n+#define COUNT1(_1)                              \\\n+  + 1\n+\n+#define COUNT2(_1, _2)                          \\\n+  + 1\n+\n+#define COUNT4(_1, _2, _3, _4)                  \\\n+  + 1\n+\n+#define COUNT5(_1, _2, _3, _4, _5)              \\\n+  + 1\n+\n+#define COUNT6(_1, _2, _3, _4, _5, _6)          \\\n+  + 1\n+\n+#define SHARED_COUNT2(_1, type)                 \\\n+  + type :: ENTRY_COUNT\n+\n+#define STUBGEN_COUNT5(_1, _2, _3, _4, count)   \\\n+  + count\n+\n@@ -1023,41 +1164,0 @@\n-\/\/ The whole shebang!\n-\/\/\n-\/\/ client macro for emitting StubGenerator blobs, stubs and entries\n-\n-#define STUBGEN_ALL_DO(do_blob, end_blob,                               \\\n-                       do_stub,                                         \\\n-                       do_entry, do_entry_init,                         \\\n-                       do_entry_array,                                  \\\n-                       do_arch_blob,                                    \\\n-                       do_arch_entry, do_arch_entry_init)               \\\n-  STUBGEN_PREUNIVERSE_BLOBS_DO(do_blob, end_blob,                       \\\n-                               do_stub,                                 \\\n-                               do_entry, do_entry_init,                 \\\n-                               do_entry_array,                          \\\n-                               do_arch_blob,                            \\\n-                               do_arch_entry, do_arch_entry_init)       \\\n-  STUBGEN_INITIAL_BLOBS_DO(do_blob, end_blob,                           \\\n-                           do_stub,                                     \\\n-                           do_entry, do_entry_init,                     \\\n-                           do_entry_array,                              \\\n-                           do_arch_blob,                                \\\n-                           do_arch_entry, do_arch_entry_init)           \\\n-  STUBGEN_CONTINUATION_BLOBS_DO(do_blob, end_blob,                      \\\n-                                do_stub,                                \\\n-                                do_entry, do_entry_init,                \\\n-                                do_entry_array,                         \\\n-                                do_arch_blob,                           \\\n-                                do_arch_entry, do_arch_entry_init)      \\\n-  STUBGEN_COMPILER_BLOBS_DO(do_blob, end_blob,                          \\\n-                            do_stub,                                    \\\n-                            do_entry, do_entry_init,                    \\\n-                            do_entry_array,                             \\\n-                            do_arch_blob,                               \\\n-                            do_arch_entry, do_arch_entry_init)          \\\n-  STUBGEN_FINAL_BLOBS_DO(do_blob, end_blob,                             \\\n-                         do_stub,                                       \\\n-                         do_entry, do_entry_init,                       \\\n-                         do_entry_array,                                \\\n-                         do_arch_blob,                                  \\\n-                         do_arch_entry, do_arch_entry_init)             \\\n-\n@@ -1084,1 +1184,1 @@\n-\/\/ client macro to operate only on StubGenerator blobs and stubs\n+\/\/ client macros to operate only on StubGenerator blobs and stubs\n@@ -1094,0 +1194,11 @@\n+\/\/ client macro to operate only on StubGenerator generci and arch entries\n+\n+#define STUBGEN_ALL_ENTRIES_DO(do_entry, do_entry_init, do_entry_array, \\\n+                               do_arch_entry, do_arch_entry_init)       \\\n+  STUBGEN_ALL_DO(DO_BLOB_EMPTY1, DO_BLOB_EMPTY1,                        \\\n+                 DO_STUB_EMPTY2,                                        \\\n+                 do_entry, do_entry_init,                               \\\n+                 do_entry_array,                                        \\\n+                 DO_ARCH_BLOB_EMPTY2,                                   \\\n+                 do_arch_entry, do_arch_entry_init)                     \\\n+\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":255,"deletions":144,"binary":false,"changes":399,"status":"modified"},{"patch":"@@ -0,0 +1,1080 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"code\/codeBlob.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/stubDeclarations.hpp\"\n+#include \"runtime\/stubInfo.hpp\"\n+\n+\/\/ define static data fields of class Stubdata\n+\n+struct StubInfo::GroupDetails StubInfo::_group_table[StubInfo::GROUP_TABLE_SIZE];\n+struct StubInfo::BlobDetails StubInfo::_blob_table[StubInfo::BLOB_TABLE_SIZE];\n+struct StubInfo::StubDetails StubInfo::_stub_table[StubInfo::STUB_TABLE_SIZE];\n+struct StubInfo::EntryDetails StubInfo::_entry_table[StubInfo::ENTRY_TABLE_SIZE];\n+\n+\/\/ helpers to access table elements using enums as indices\n+\n+struct StubInfo::GroupDetails& StubInfo::group_details(StubGroup g) {\n+  int idx = static_cast<int>(g);\n+  assert(idx >= 0 && idx < GROUP_TABLE_SIZE, \"invalid stub group index %d\", idx);\n+  return _group_table[idx];\n+}\n+\n+struct StubInfo::BlobDetails& StubInfo::blob_details(BlobId b) {\n+  int idx = static_cast<int>(b);\n+  assert(idx >= 0 && idx < BLOB_TABLE_SIZE, \"invalid blob index %d\", idx);\n+  return _blob_table[idx];\n+}\n+\n+struct StubInfo::StubDetails& StubInfo::stub_details(StubId s) {\n+  int idx = static_cast<int>(s);\n+  assert(idx >= 0 && idx < STUB_TABLE_SIZE, \"invalid stub index %d\", idx);\n+  return _stub_table[idx];\n+}\n+\n+struct StubInfo::EntryDetails& StubInfo::entry_details(EntryId e) {\n+  int idx = static_cast<int>(e);\n+  assert(idx >= 0 && idx < ENTRY_TABLE_SIZE, \"invalid entry index %d\", idx);\n+  return _entry_table[idx];\n+}\n+\n+\/\/ helpers to step through blob, stub or entry enum sequences\n+\n+BlobId StubInfo::next(BlobId id) {\n+  int idx = static_cast<int>(id);\n+  \/\/ allow for id to be NO_BLOBID but not NUM_BLOBIDS\n+  assert(idx >= -1 && idx < BLOB_TABLE_SIZE, \"invalid blob index %d\", idx);\n+  return static_cast<BlobId>(idx + 1);\n+}\n+\n+StubId StubInfo::next(StubId id) {\n+  int idx = static_cast<int>(id);\n+  \/\/ allow for id to be NO_STUBID but not NUM_STUBIDS\n+  assert(idx >= -1 && idx < STUB_TABLE_SIZE, \"invalid stub index %d\", idx);\n+  return static_cast<StubId>(idx + 1);\n+}\n+\n+EntryId StubInfo::next(EntryId id) {\n+  int idx = static_cast<int>(id);\n+  \/\/ allow for id to be NO_ENTRYID but not NUM_ENTRYIDS\n+  assert(idx >= -1 && idx < ENTRY_TABLE_SIZE, \"invalid entry index %d\", idx);\n+  return static_cast<EntryId>(idx + 1);\n+}\n+\n+BlobId StubInfo::next_in_group(StubGroup stub_group, BlobId blob_id) {\n+  int idx = static_cast<int>(blob_id);\n+  \/\/ id must be strictly between NO_BLOBID and NUM_BLOBIDS\n+  assert(idx > -1 && idx < STUB_TABLE_SIZE, \"invalid stub index %d\", idx);\n+  assert(blob_details(blob_id)._group == stub_group, \"blob does not belong to stub group!\");\n+  struct GroupDetails& group = group_details(stub_group);\n+  if (blob_id == group._max) {\n+    return BlobId::NO_BLOBID;\n+  } else {\n+    return static_cast<BlobId>(idx + 1);\n+  }\n+}\n+\n+StubId StubInfo::next_in_blob(BlobId blob_id, StubId stub_id) {\n+  int idx = static_cast<int>(stub_id);\n+  \/\/ id must be strictly between NO_STUBID and NUM_STUBIDS\n+  assert(idx > -1 && idx < STUB_TABLE_SIZE, \"invalid stub index %d\", idx);\n+  assert(stub_details(stub_id)._blob == blob_id, \"stub does not belong to blob!\");\n+  struct BlobDetails& blob = blob_details(blob_id);\n+  if (stub_id == blob._max) {\n+    return StubId::NO_STUBID;\n+  } else {\n+    return static_cast<StubId>(idx + 1);\n+  }\n+}\n+\n+EntryId StubInfo::next_in_stub(StubId stub_id, EntryId entry_id) {\n+  int idx = static_cast<int>(entry_id);\n+  \/\/ id must be strictly between NO_ENTRYID and NUM_ENTRYIDS\n+  assert(idx > -1 && idx < ENTRY_TABLE_SIZE, \"invalid entry index %d\", idx);\n+  assert(entry_details(entry_id)._stub == stub_id, \"entry does not belong to stub!\");\n+  struct StubDetails& stub = stub_details(stub_id);\n+  if (entry_id == stub._max) {\n+    return EntryId::NO_ENTRYID;\n+  } else {\n+    return static_cast<EntryId>(idx + 1);\n+  }\n+}\n+\n+\/\/ name retrieval\n+\n+const char* StubInfo::name(StubGroup stub_group) {\n+  return group_details(stub_group)._name;\n+}\n+\n+const char* StubInfo::name(BlobId id) {\n+  return blob_details(id)._name;\n+}\n+\n+const char* StubInfo::name(StubId id) {\n+  return stub_details(id)._name;\n+}\n+\n+const char* StubInfo::name(EntryId id) {\n+  return entry_details(id)._name;\n+}\n+\n+int StubInfo::span(EntryId second, EntryId first) {\n+  \/\/ normally when the two ids are equal the entry span is 1 but we\n+  \/\/ have a special case when the base and max are both NO_ENTRYID in\n+  \/\/ which case the entry count is 0\n+  int idx1 = static_cast<int>(first);\n+  int idx2 = static_cast<int>(second);\n+  assert ((idx1 < 0 && idx2  < 0) || (idx1 >= 0 && idx2 >= idx1), \"bad entry ids first %d and second %d\", idx1, idx2);\n+  if (idx1 < 0) {\n+    return 0;\n+  }\n+  \/\/ span is inclusive of first and second\n+  return idx2 + 1 - idx1;\n+}\n+\n+int StubInfo::span(StubId second, StubId first) {\n+  int idx1 = static_cast<int>(first);\n+  int idx2 = static_cast<int>(second);\n+  assert(idx2 >= 0 && idx2 >= idx1, \"bad stub ids first %d and second %d\", idx1, idx2);\n+  \/\/ span is inclusive of first and second\n+  return idx2 + 1 - idx1;\n+}\n+\n+int StubInfo::span(BlobId second, BlobId first) {\n+  int idx1 = static_cast<int>(first);\n+  int idx2 = static_cast<int>(second);\n+  assert(idx2 >= 0 && idx2 >= idx1, \"bad blob ids first %d and second %d\", idx1, idx2);\n+  \/\/ span is inclusive of first and second\n+  return idx2 + 1 - idx1;\n+}\n+\n+#ifdef ASSERT\n+\/\/ helpers to check sequencing of blobs stubs and entries\n+bool StubInfo::is_next(BlobId second, BlobId first) {\n+  return next(first) == second;\n+}\n+\n+bool StubInfo::is_next(StubId second, StubId first) {\n+  return next(first) == second;\n+}\n+\n+bool StubInfo::is_next(EntryId second, EntryId first) {\n+  return next(first) == second;\n+}\n+#endif \/\/ ASSERT\n+\n+\/\/ implementation of the counting methods used to populate the\n+\/\/ stubgroup, blob, stub and entry tables\n+\n+void StubInfo::process_shared_blob(StubGroup& group_cursor,\n+                                   BlobId&  blob_cursor,\n+                                   StubId& stub_cursor,\n+                                   EntryId& entry_cursor,\n+                                   const char* name,\n+                                   BlobId declaredBlob,\n+                                   StubId declaredStub,\n+                                   EntryId declaredEntry,\n+                                   EntryId declaredMax) {\n+  \/\/ for shared declarations we update the blob, stub and entry tables\n+  \/\/ all in one go based on each unique blob declaration. We may need\n+  \/\/ to write more than one entry table element if the stub has\n+  \/\/ multiple entries\n+  assert(group_cursor == StubGroup::SHARED, \"must be\");\n+  assert(is_next (declaredBlob, blob_cursor), \"Out of order declaration for shared blob %s\", name);\n+  assert(is_next(declaredStub, stub_cursor), \"Out of order declaration for shared stub %s\", name);\n+  assert(is_next(declaredEntry, entry_cursor), \"Out of order declaration for shared entry %s\", name);\n+  assert(span(declaredMax, declaredEntry) > 0, \"Invalid entry count %d for entry %s\", span(declaredMax, declaredEntry), name);\n+  \/\/ if this is the first shared blob then record it as teh base id\n+  \/\/ and also update entry base\n+  if (group_details(group_cursor)._base == BlobId::NO_BLOBID) {\n+    group_details(group_cursor)._base = declaredBlob;\n+    group_details(group_cursor)._entry_base = declaredEntry;\n+  }\n+  \/\/ update the high water mark for blobs and entries in the stub\n+  \/\/ group unconditionally\n+  group_details(group_cursor)._max = declaredBlob;\n+  group_details(group_cursor)._entry_max = declaredMax;\n+  \/\/ move forward to this blob\n+  blob_cursor = declaredBlob;\n+  \/\/ link the blob to its group and its unique stub\n+  blob_details(blob_cursor)._group = group_cursor;\n+  blob_details(blob_cursor)._base = declaredStub;\n+  blob_details(blob_cursor)._max = declaredStub;\n+  blob_details(blob_cursor)._name = name;\n+  \/\/ move forward to this stub\n+  stub_cursor = declaredStub;\n+  \/\/ link the stub to its blob and its entries\n+  stub_details(stub_cursor)._blob = declaredBlob;\n+  stub_details(stub_cursor)._base = declaredEntry;\n+  stub_details(stub_cursor)._max = declaredMax;\n+  stub_details(stub_cursor)._is_entry_array = false;\n+  stub_details(stub_cursor)._name = name;\n+  \/\/ move forward to last entry\n+  entry_cursor = declaredMax;\n+  \/\/ fill out the entry table for the the declared entry up to last entry\n+  EntryId id = declaredEntry;\n+  entry_details(id)._stub = declaredStub;\n+  entry_details(id)._array_base = EntryId::NO_ENTRYID;\n+  entry_details(id)._name = name;\n+  \/\/ fill any subsequent entries\n+  while (id != declaredMax) {\n+    id = next(id);\n+    entry_details(id)._stub = declaredStub;\n+    entry_details(id)._array_base = EntryId::NO_ENTRYID;\n+    entry_details(id)._name = name;\n+  }\n+}\n+\n+void StubInfo::process_c1_blob(StubGroup& group_cursor,\n+                               BlobId&  blob_cursor,\n+                               StubId& stub_cursor,\n+                               EntryId& entry_cursor,\n+                               const char* name,\n+                               BlobId declaredBlob,\n+                               StubId declaredStub,\n+                               EntryId declaredEntry) {\n+  \/\/ for c1 declarations we update the blob, stub and entry tables all\n+  \/\/ in one go based on each unique blob declaration\n+  assert(group_cursor == StubGroup::C1, \"must be\");\n+  assert(is_next(declaredBlob, blob_cursor), \"Out of order declaration for c1 blob %s\", name);\n+  assert(is_next(declaredStub, stub_cursor), \"Out of order declaration for c1 stub %s\", name);\n+  assert(is_next(declaredEntry, entry_cursor), \"Out of order declaration for c1 entry %s\", name);\n+  \/\/ if this is the first c1 blob then record it and the entry\n+  if (group_details(group_cursor)._base == BlobId::NO_BLOBID) {\n+    group_details(group_cursor)._base = declaredBlob;\n+    group_details(group_cursor)._entry_base = declaredEntry;\n+  }\n+  \/\/ update the high water mark for blobs and entries in the stub\n+  \/\/ group unconditionally\n+  group_details(group_cursor)._max = declaredBlob;\n+  group_details(group_cursor)._entry_max = declaredEntry;\n+  \/\/ move forward to this blob\n+  blob_cursor = declaredBlob;\n+  \/\/ link the blob to its group and its unique stub\n+  blob_details(blob_cursor)._group = group_cursor;\n+  blob_details(blob_cursor)._base = declaredStub;\n+  blob_details(blob_cursor)._max = declaredStub;\n+  blob_details(blob_cursor)._name = name;\n+  \/\/ move forward to this stub\n+  stub_cursor = declaredStub;\n+  \/\/ link the stub to its blob and its entries\n+  stub_details(stub_cursor)._blob = declaredBlob;\n+  stub_details(stub_cursor)._base = declaredEntry;\n+  stub_details(stub_cursor)._max = declaredEntry;\n+  stub_details(stub_cursor)._is_entry_array = false;\n+  stub_details(stub_cursor)._name = name;\n+  \/\/ move forward to entry\n+  entry_cursor = declaredEntry;\n+  \/\/ fill out the entry table element\n+  entry_details(entry_cursor)._stub = declaredStub;\n+  entry_details(entry_cursor)._array_base = EntryId::NO_ENTRYID;\n+  entry_details(entry_cursor)._name = name;\n+}\n+\n+void StubInfo::process_c2_blob(StubGroup& group_cursor,\n+                               BlobId&  blob_cursor,\n+                               StubId& stub_cursor,\n+                               EntryId& entry_cursor,\n+                               const char* name,\n+                               BlobId declaredBlob,\n+                               StubId declaredStub,\n+                               EntryId declaredEntry) {\n+  \/\/ for c2 declarations we update the blob, stub and entry tables all\n+  \/\/ in one go based on the same details garnered from each unique\n+  \/\/ blob, stub r jvmti stub declaration\n+  assert(group_cursor == StubGroup::C2, \"must be\");\n+  assert(is_next(declaredBlob, blob_cursor), \"Out of order declaration for c2 blob %s\", name);\n+  assert(is_next(declaredStub, stub_cursor), \"Out of order declaration for c2 stub %s\", name);\n+  assert(is_next(declaredEntry, entry_cursor), \"Out of order declaration for c2 entry %s\", name);\n+  \/\/ if this is the first c2 blob then record it and the entry\n+  if (group_details(group_cursor)._base == BlobId::NO_BLOBID) {\n+    group_details(group_cursor)._base = declaredBlob;\n+    group_details(group_cursor)._entry_base = declaredEntry;\n+  }\n+  \/\/ update the high water mark for blobs and entries in the stub\n+  \/\/ group unconditionally\n+  group_details(group_cursor)._max = declaredBlob;\n+  group_details(group_cursor)._entry_max = declaredEntry;\n+  \/\/ move forward to this blob\n+  blob_cursor = declaredBlob;\n+  \/\/ link the blob to its group and its unique stub\n+  blob_details(blob_cursor)._group = group_cursor;\n+  blob_details(blob_cursor)._base = declaredStub;\n+  blob_details(blob_cursor)._max = declaredStub;\n+  blob_details(blob_cursor)._name = name;\n+  \/\/ move forward to this stub\n+  stub_cursor = declaredStub;\n+  \/\/ link the stub to its blob and its entries\n+  stub_details(stub_cursor)._blob = declaredBlob;\n+  stub_details(stub_cursor)._base = declaredEntry;\n+  stub_details(stub_cursor)._max = declaredEntry;\n+  stub_details(stub_cursor)._is_entry_array = false;\n+  stub_details(stub_cursor)._name = name;\n+  \/\/ move forward to entry\n+  entry_cursor = declaredEntry;\n+  \/\/ fill out the entry table element\n+  entry_details(entry_cursor)._stub = declaredStub;\n+  entry_details(entry_cursor)._array_base = EntryId::NO_ENTRYID;\n+  entry_details(entry_cursor)._name = name;\n+}\n+\n+void StubInfo::process_stubgen_blob(StubGroup& group_cursor,\n+                                    BlobId&  blob_cursor,\n+                                    StubId& stub_cursor,\n+                                    EntryId& entry_cursor,\n+                                    const char* name,\n+                                    BlobId declaredBlob) {\n+  \/\/ for stubgen blob declarations we update the blob table, allowing\n+  \/\/ us to link subsequent stubs to that blob\n+  assert(group_cursor == StubGroup::STUBGEN, \"must be\");\n+  assert(is_next(declaredBlob, blob_cursor), \"Out of order declaration for stubgen blob %s\", name);\n+  \/\/ if this is the first stubgen blob then record it\n+  if (group_details(group_cursor)._base == BlobId::NO_BLOBID) {\n+    group_details(group_cursor)._base = declaredBlob;\n+  }\n+  \/\/ update the high water mark for blobs in the stub group unconditionally\n+  group_details(group_cursor)._max = declaredBlob;\n+  \/\/ move forward to this blob\n+  blob_cursor = declaredBlob;\n+  \/\/ link the blob to its group\n+  blob_details(blob_cursor)._group = group_cursor;\n+  \/\/ clear the blob table base and max - they are set when we first\n+  \/\/ encounter a stub. likewise the blob table entry base and entry\n+  \/\/ max -- they are set when we first encounter an entry\n+  blob_details(blob_cursor)._base = StubId::NO_STUBID;\n+  blob_details(blob_cursor)._max = StubId::NO_STUBID;\n+  blob_details(blob_cursor)._entry_base = EntryId::NO_ENTRYID;\n+  blob_details(blob_cursor)._entry_max = EntryId::NO_ENTRYID;\n+  blob_details(blob_cursor)._name = name;\n+}\n+\n+void StubInfo::process_stubgen_stub(StubGroup& group_cursor,\n+                                    BlobId&  blob_cursor,\n+                                    StubId& stub_cursor,\n+                                    EntryId& entry_cursor,\n+                                    const char* name,\n+                                    BlobId declaredBlob,\n+                                    StubId declaredStub) {\n+  \/\/ for stubgen stub declarations we update the stub table, allowing\n+  \/\/ us to link subsequent entries to that stub\n+  assert(group_cursor == StubGroup::STUBGEN, \"must be\");\n+  \/\/ FIXME use stub name here\n+  assert(declaredBlob == blob_cursor, \"Stubgen stub %s in scope of incorrect blob %s\", name, blob_details(blob_cursor)._name);\n+  assert(is_next(declaredStub, stub_cursor), \"Out of order declaration for stubgen stub %s\", name);\n+  \/\/ if this is the first stubgen stub then record it\n+  if (blob_details(blob_cursor)._base == StubId::NO_STUBID) {\n+    blob_details(blob_cursor)._base = declaredStub;\n+  }\n+  \/\/ update the high water mark for stubs in the blob unconditionally\n+  blob_details(blob_cursor)._max = declaredStub;\n+  \/\/ move forward to this stub\n+  stub_cursor = declaredStub;\n+  \/\/ link the stub to its blob\n+  stub_details(stub_cursor)._blob = blob_cursor;\n+  \/\/ clear the stub table base and max - they are set when we\n+  \/\/ encounter an entry\n+  stub_details(stub_cursor)._base = EntryId::NO_ENTRYID;\n+  stub_details(stub_cursor)._max = EntryId::NO_ENTRYID;\n+  stub_details(stub_cursor)._name = name;;\n+}\n+\n+void StubInfo::process_stubgen_entry(StubGroup& group_cursor,\n+                                     BlobId&  blob_cursor,\n+                                     StubId& stub_cursor,\n+                                     EntryId& entry_cursor,\n+                                     const char* name,\n+                                     BlobId declaredBlob,\n+                                     StubId declaredStub,\n+                                     EntryId declaredEntry,\n+                                     int arrayCount) {\n+  \/\/ for stubgen entry declarations we update the entry table\n+  assert(group_cursor == StubGroup::STUBGEN, \"must be\");\n+  assert(declaredBlob == blob_cursor, \"Stubgen entry %s in scope of wrong blob %s\", name, blob_details(blob_cursor)._name);\n+  assert(declaredStub == stub_cursor, \"Stubgen entry %s declares stub in scope of wrong stub %s\", name, stub_details(stub_cursor)._name);\n+  assert(is_next(declaredEntry, entry_cursor), \"Out of order declaration for stubgen entry %s\", name);\n+  assert(arrayCount >= 0, \"Invalid array count %d\", arrayCount);\n+  \/\/ if this is the first stubgen entry in the group then record it\n+  if (group_details(group_cursor)._entry_base == EntryId::NO_ENTRYID) {\n+    group_details(group_cursor)._entry_base = declaredEntry;\n+  }\n+  \/\/ update the high water mark for entries in the group unconditionally\n+  group_details(group_cursor)._entry_max = declaredEntry;\n+  \/\/ if this is the first stubgen entry in the blob then record it\n+  if (blob_details(blob_cursor)._entry_base == EntryId::NO_ENTRYID) {\n+    blob_details(blob_cursor)._entry_base = declaredEntry;\n+  }\n+  \/\/ update the high water mark for entries in the group unconditionally\n+  blob_details(blob_cursor)._entry_max = declaredEntry;\n+  \/\/ if this is the first stubgen entry in the stub then record it\n+  if (stub_details(stub_cursor)._base == EntryId::NO_ENTRYID) {\n+    stub_details(stub_cursor)._base = declaredEntry;\n+  }\n+  \/\/ move forward to this entry\n+  if (arrayCount == 0) {\n+    \/\/ simply link the entry to its blob\n+    entry_cursor = declaredEntry;\n+    entry_details(entry_cursor)._stub = stub_cursor;\n+    entry_details(entry_cursor)._array_base = EntryId::NO_ENTRYID;\n+    entry_details(entry_cursor)._name = name;\n+  } else {\n+    \/\/ populate multiple entries and link them all to the first entry\n+    for (int i = 0; i < arrayCount; i++) {\n+      entry_cursor = next(entry_cursor);\n+      entry_details(entry_cursor)._stub = stub_cursor;\n+      entry_details(entry_cursor)._array_base = declaredEntry;\n+      \/\/ TODO: consider allocating names labelled with index\n+      entry_details(entry_cursor)._name = name;\n+    }\n+  }\n+  \/\/ update the high water mark for entries in the stub unconditionally\n+  stub_details(stub_cursor)._max = entry_cursor;\n+}\n+\n+\/\/ The stubgroup, blob, stub and entry tables defined above are\n+\/\/ populated by iterating over all blob, stub and entry declarations\n+\/\/ and incrementally updating the associated table entries. The\n+\/\/ following macros invoke static methods of StubInfo that receive\n+\/\/ and, where appropriate, update cursors identifying current\n+\/\/ positions in each table.\n+\n+#define PROCESS_SHARED_BLOB(name, type)                                 \\\n+  process_shared_blob(_group_cursor, _blob_cursor,                      \\\n+                      _stub_cursor, _entry_cursor,                      \\\n+                      \"Shared Runtime \" # name \"_blob\",                 \\\n+                      BlobId:: JOIN3(shared, name, id),                 \\\n+                      StubId:: JOIN3(shared, name, id),                 \\\n+                      EntryId:: JOIN3(shared, name, id),                \\\n+                      EntryId:: JOIN3(shared, name, max));              \\\n+\n+#define PROCESS_C1_BLOB(name)                                     \\\n+  process_c1_blob(_group_cursor, _blob_cursor,                    \\\n+                  _stub_cursor, _entry_cursor,                    \\\n+                  \"C1 Runtime \" # name \"_blob\",                   \\\n+                  BlobId:: JOIN3(c1, name, id),                   \\\n+                  StubId:: JOIN3(c1, name, id),                   \\\n+                  EntryId:: JOIN3(c1, name, id));                 \\\n+\n+#define PROCESS_C2_BLOB(name, type)                         \\\n+  process_c2_blob(_group_cursor, _blob_cursor,              \\\n+                  _stub_cursor, _entry_cursor,              \\\n+                  \"C2 Runtime \" # name \"_blob\",             \\\n+                  BlobId:: JOIN3(c2, name, id),             \\\n+                  StubId:: JOIN3(c2, name, id),             \\\n+                  EntryId:: JOIN3(c2, name, id));           \\\n+\n+#define PROCESS_C2_STUB(name, fancy_jump, pass_tls, return_pc)    \\\n+  process_c2_blob(_group_cursor, _blob_cursor,                    \\\n+                  _stub_cursor, _entry_cursor,                    \\\n+                  \"C2 Runtime \" # name \"_blob\",                   \\\n+                  BlobId:: JOIN3(c2, name, id),                   \\\n+                  StubId:: JOIN3(c2, name, id),                   \\\n+                  EntryId:: JOIN3(c2, name, id));                 \\\n+\n+#define PROCESS_C2_JVMTI_STUB(name)                               \\\n+  process_c2_blob(_group_cursor, _blob_cursor,                    \\\n+                  _stub_cursor, _entry_cursor,                    \\\n+                  \"C2 Runtime \" # name \"_blob\",                   \\\n+                  BlobId:: JOIN3(c2, name, id),                   \\\n+                  StubId:: JOIN3(c2, name, id),                   \\\n+                  EntryId:: JOIN3(c2, name, id));                 \\\n+\n+#define PROCESS_STUBGEN_BLOB(blob)                                \\\n+  process_stubgen_blob(_group_cursor, _blob_cursor,               \\\n+                       _stub_cursor, _entry_cursor,               \\\n+                       \"Stub Generator \" # blob \"_blob\",          \\\n+                       BlobId:: JOIN3(stubgen, blob, id));        \\\n+\n+#define PROCESS_STUBGEN_STUB(blob, stub)                          \\\n+  process_stubgen_stub(_group_cursor, _blob_cursor,               \\\n+                       _stub_cursor, _entry_cursor,               \\\n+                       \"Stub Generator \" # stub \"_stub\",          \\\n+                       BlobId:: JOIN3(stubgen, blob, id),         \\\n+                       StubId:: JOIN3(stubgen, stub, id));        \\\n+\n+#define PROCESS_STUBGEN_ENTRY(blob, stub, field_name, getter_name)      \\\n+  process_stubgen_entry(_group_cursor, _blob_cursor,                    \\\n+                        _stub_cursor, _entry_cursor,                    \\\n+                        \"Stub Generator \" # field_name \"_entry\",        \\\n+                        BlobId:: JOIN3(stubgen, blob, id),              \\\n+                        StubId:: JOIN3(stubgen, stub, id),              \\\n+                        EntryId:: JOIN3(stubgen, field_name, id),       \\\n+                        0);                                             \\\n+\n+#define PROCESS_STUBGEN_ENTRY_INIT(blob, stub, field_name, getter_name, \\\n+                                   init_funcion)                        \\\n+  process_stubgen_entry(_group_cursor, _blob_cursor,                    \\\n+                        _stub_cursor, _entry_cursor,                    \\\n+                        \"Stub Generator \" # field_name \"_entry\",        \\\n+                        BlobId:: JOIN3(stubgen, blob, id),              \\\n+                        StubId:: JOIN3(stubgen, stub, id),              \\\n+                        EntryId:: JOIN3(stubgen, field_name, id),       \\\n+                        0);                                             \\\n+\n+#define PROCESS_STUBGEN_ENTRY_ARRAY(blob, stub, field_name, getter_name, \\\n+                                    count)                              \\\n+  process_stubgen_entry(_group_cursor, _blob_cursor,                    \\\n+                        _stub_cursor, _entry_cursor,                    \\\n+                        \"Stub Generator \" # field_name \"_entry\",        \\\n+                        BlobId:: JOIN3(stubgen, blob, id),              \\\n+                        StubId:: JOIN3(stubgen, stub, id),              \\\n+                        EntryId:: JOIN3(stubgen, field_name, id),       \\\n+                        count);                                         \\\n+\n+#define PROCESS_STUBGEN_ENTRY_ARCH(arch_name, blob, stub, field_name,   \\\n+                                   getter_name)                         \\\n+  process_stubgen_entry(_group_cursor, _blob_cursor,                    \\\n+                        _stub_cursor, _entry_cursor,                    \\\n+                        #arch_name \"_\" # field_name,                    \\\n+                        BlobId:: JOIN3(stubgen, blob, id),              \\\n+                        StubId:: JOIN3(stubgen, stub, id),              \\\n+                        EntryId:: JOIN4(stubgen, arch_name,             \\\n+                                        field_name, id),                \\\n+                        0);                                             \\\n+\n+#define PROCESS_STUBGEN_ENTRY_ARCH_INIT(arch_name, blob, stub,          \\\n+                                        field_name, getter_name,        \\\n+                                        init_function)                  \\\n+  process_stubgen_entry(_group_cursor, _blob_cursor,                    \\\n+                        _stub_cursor, _entry_cursor,                    \\\n+                        \"Stub Generator \" # arch_name \"_\" # field_name \"_entry\", \\\n+                        BlobId:: JOIN3(stubgen, blob, id),              \\\n+                        StubId:: JOIN3(stubgen, stub, id),              \\\n+                        EntryId:: JOIN4(stubgen, arch_name,             \\\n+                                        field_name, id),                \\\n+                        0);                                             \\\n+\n+void StubInfo::populate_stub_tables() {\n+  StubGroup _group_cursor;\n+  BlobId _blob_cursor = BlobId::NO_BLOBID;\n+  StubId _stub_cursor = StubId::NO_STUBID;\n+  EntryId _entry_cursor = EntryId::NO_ENTRYID;\n+\n+  _group_cursor = StubGroup::SHARED;\n+  group_details(_group_cursor)._name = \"Shared Stubs\";\n+  group_details(_group_cursor)._base = BlobId::NO_BLOBID;\n+  group_details(_group_cursor)._max = BlobId::NO_BLOBID;\n+  group_details(_group_cursor)._entry_base = EntryId::NO_ENTRYID;\n+  group_details(_group_cursor)._entry_max = EntryId::NO_ENTRYID;\n+  SHARED_STUBS_DO(PROCESS_SHARED_BLOB);\n+\n+  _group_cursor = StubGroup::C1;\n+  group_details(_group_cursor)._name = \"C1 Stubs\";\n+  group_details(_group_cursor)._base = BlobId::NO_BLOBID;\n+  group_details(_group_cursor)._max = BlobId::NO_BLOBID;\n+  group_details(_group_cursor)._entry_base = EntryId::NO_ENTRYID;\n+  group_details(_group_cursor)._entry_max = EntryId::NO_ENTRYID;\n+  C1_STUBS_DO(PROCESS_C1_BLOB);\n+\n+  _group_cursor = StubGroup::C2;\n+  group_details(_group_cursor)._name = \"C2 Stubs\";\n+  group_details(_group_cursor)._base = BlobId::NO_BLOBID;\n+  group_details(_group_cursor)._max = BlobId::NO_BLOBID;\n+  group_details(_group_cursor)._entry_base = EntryId::NO_ENTRYID;\n+  group_details(_group_cursor)._entry_max = EntryId::NO_ENTRYID;\n+  C2_STUBS_DO(PROCESS_C2_BLOB, PROCESS_C2_STUB, PROCESS_C2_JVMTI_STUB);\n+\n+  _group_cursor = StubGroup::STUBGEN;\n+  group_details(_group_cursor)._name = \"StubGen Stubs\";\n+  group_details(_group_cursor)._base = BlobId::NO_BLOBID;\n+  group_details(_group_cursor)._max = BlobId::NO_BLOBID;\n+  group_details(_group_cursor)._entry_base = EntryId::NO_ENTRYID;\n+  group_details(_group_cursor)._entry_max = EntryId::NO_ENTRYID;\n+  STUBGEN_ALL_DO(PROCESS_STUBGEN_BLOB, DO_BLOB_EMPTY1,\n+                 PROCESS_STUBGEN_STUB,\n+                 PROCESS_STUBGEN_ENTRY, PROCESS_STUBGEN_ENTRY_INIT,\n+                 PROCESS_STUBGEN_ENTRY_ARRAY,\n+                 DO_ARCH_BLOB_EMPTY2,\n+                 PROCESS_STUBGEN_ENTRY_ARCH, PROCESS_STUBGEN_ENTRY_ARCH_INIT);\n+  assert(next(_blob_cursor) == BlobId::NUM_BLOBIDS, \"should have exhausted all blob ids!\");\n+  assert(next(_stub_cursor) == StubId::NUM_STUBIDS, \"should have exhausted all stub ids!\");\n+  assert(next(_entry_cursor) == EntryId::NUM_ENTRYIDS, \"should have exhausted all entry ids!\");\n+#ifdef ASSERT\n+  \/\/ run further sanity checks\n+  verify_stub_tables();\n+#endif \/\/ ASSERT\n+}\n+\n+#undef PROCESS_SHARED_BLOB\n+#undef PROCESS_C1_BLOB\n+#undef PROCESS_C2_BLOB\n+#undef PROCESS_C2_STUB\n+#undef PROCESS_C2_JVMTI_STUB\n+#undef PROCESS_STUBGEN_BLOB\n+#undef PROCESS_STUBGEN_STUB\n+#undef PROCESS_STUBGEN_ENTRY\n+#undef PROCESS_STUBGEN_ENTRY_INIT\n+#undef PROCESS_STUBGEN_ENTRY_ARRAY\n+#undef PROCESS_STUBGEN_ENTRY_ARCH\n+#undef PROCESS_STUBGEN_ENTRY_ARCH_INIT\n+\n+#ifdef ASSERT\n+\n+void StubInfo::verify_stub_tables() {\n+  \/\/ exercise the traversal and interconversion APIs\n+  const int NUM_STUBGROUPS = static_cast<int>(StubGroup::NUM_STUBGROUPS);\n+  StubGroup groups[NUM_STUBGROUPS] = {\n+    StubGroup::SHARED,\n+    StubGroup::C1,\n+    StubGroup::C2,\n+    StubGroup::STUBGEN };\n+\n+  \/\/ check that the statically defined blob, stub and entry counts\n+  \/\/ match the computed totals\n+  assert(blob_count(StubGroup::SHARED) == StubInfo::SHARED_STUB_COUNT,\n+         \"miscounted number of shared blobs %d vs %d\",\n+         blob_count(StubGroup::SHARED), StubInfo::SHARED_STUB_COUNT);\n+\n+  assert(stub_count(StubGroup::SHARED) == StubInfo::SHARED_STUB_COUNT,\n+         \"miscounted number of shared stubs %d vs %d\",\n+         stub_count(StubGroup::SHARED), StubInfo::SHARED_STUB_COUNT);\n+\n+  assert(entry_count(StubGroup::SHARED) == StubInfo::SHARED_ENTRY_COUNT,\n+         \"miscounted number of shared entries %d vs %d\",\n+         entry_count(StubGroup::SHARED), StubInfo::SHARED_ENTRY_COUNT);\n+\n+  assert(blob_count(StubGroup::C1) == StubInfo::C1_STUB_COUNT,\n+         \"miscounted number of c1 blobs %d vs %d\",\n+         blob_count(StubGroup::C1), StubInfo::C1_STUB_COUNT);\n+\n+  assert(stub_count(StubGroup::C1) == StubInfo::C1_STUB_COUNT,\n+         \"miscounted number of c1 stubs %d vs %d\",\n+         stub_count(StubGroup::C1), StubInfo::C1_STUB_COUNT);\n+\n+  assert(entry_count(StubGroup::C1) == StubInfo::C1_STUB_COUNT,\n+         \"miscounted number of c1 entries %d vs %d\",\n+         entry_count(StubGroup::C1), StubInfo::C1_STUB_COUNT);\n+\n+  assert(blob_count(StubGroup::C2) == StubInfo::C2_STUB_COUNT,\n+         \"miscounted number of c2 blobs %d vs %d\",\n+         blob_count(StubGroup::C2), StubInfo::C2_STUB_COUNT);\n+\n+  assert(stub_count(StubGroup::C2) == StubInfo::C2_STUB_COUNT,\n+         \"miscounted number of c2 stubs %d vs %d\",\n+         stub_count(StubGroup::C2), StubInfo::C2_STUB_COUNT);\n+\n+  assert(entry_count(StubGroup::C2) == StubInfo::C2_STUB_COUNT,\n+         \"miscounted number of c2 entries %d vs %d\",\n+         entry_count(StubGroup::C2), StubInfo::C2_STUB_COUNT);\n+\n+  assert(blob_count(StubGroup::STUBGEN) == StubInfo::STUBGEN_BLOB_COUNT,\n+         \"miscounted number of stubgen blobs %d vs %d\",\n+         blob_count(StubGroup::STUBGEN), StubInfo::STUBGEN_STUB_COUNT);\n+\n+  assert(stub_count(StubGroup::STUBGEN) == StubInfo::STUBGEN_STUB_COUNT,\n+         \"miscounted number of stubgen stubs %d vs %d\",\n+         stub_count(StubGroup::STUBGEN), StubInfo::STUBGEN_STUB_COUNT);\n+\n+  assert(entry_count(StubGroup::STUBGEN) == StubInfo::STUBGEN_ENTRY_COUNT,\n+         \"miscounted number of stubgen entries %d vs %d\",\n+         entry_count(StubGroup::STUBGEN), StubInfo::STUBGEN_ENTRY_COUNT);\n+\n+  \/\/ 1) check that the per-group blob counts add up\n+  for (int gidx = 0; gidx < NUM_STUBGROUPS ; gidx++) {\n+    StubGroup group = groups[gidx];\n+    BlobId blob = blob_base(group);\n+    int group_blob_total = blob_count(group);\n+    while (blob != BlobId::NO_BLOBID) {\n+      \/\/ predecrement total\n+      group_blob_total--;\n+      assert(group_blob_total > 0 || blob == blob_max(group), \"must be!\");\n+      assert(stubgroup(blob) == group, \"iterated out of group %s to blob %s\", name(group), name(blob));\n+      blob = next_in_group(group, blob);\n+    }\n+    assert(group_blob_total == 0, \"must be!\");\n+  }\n+\n+  \/\/ 2) check that the per-group and per-blob stub counts add up\n+  for (int gidx = 0; gidx < NUM_STUBGROUPS; gidx++) {\n+    StubGroup group = groups[gidx];\n+    BlobId blob = blob_base(group);\n+    StubId group_stub = stub_base(group);\n+    int group_stub_total = stub_count(group);\n+    while (blob != BlobId::NO_BLOBID) {\n+      StubId stub = stub_base(blob);\n+      int stub_total = stub_count(blob);\n+      while (stub != StubId::NO_STUBID) {\n+        \/\/ iterations via group and blob should proceed in parallel\n+        assert(stub == group_stub, \"must be!\");\n+        \/\/ predecrement totals\n+        group_stub_total--;\n+        stub_total--;\n+        assert(stub_total > 0 || stub == stub_max(blob), \"must be!\");\n+        assert(group_stub_total > 0 || stub == stub_max(group), \"must be!\");\n+        assert(stubgroup(stub) == group, \"iterated out of group %s to stub %s\", name(group), name(stub));\n+        stub = next_in_blob(blob, stub);\n+        group_stub = next(group_stub);\n+      }\n+      assert(stub_total == 0, \"must be!\");\n+      blob = next_in_group(group, blob);\n+    }\n+    assert(group_stub_total == 0, \"must be!\");\n+  }\n+\n+  \/\/ 3) check that the per-group, per-blob and per-stub entry counts add up\n+  for (int gidx = 0; gidx < NUM_STUBGROUPS; gidx++) {\n+    StubGroup group = groups[gidx];\n+    BlobId blob = blob_base(group);\n+    StubId group_stub = stub_base(group);\n+    EntryId group_entry = entry_base(group);\n+    int group_entry_total = entry_count(group);\n+    while (blob != BlobId::NO_BLOBID) {\n+      StubId stub = stub_base(blob);\n+      while (stub != StubId::NO_STUBID) {\n+        EntryId entry = entry_base(stub);\n+        int entry_total = entry_count(stub);\n+        while (entry != EntryId::NO_ENTRYID) {\n+          \/\/ iterations via group and blob should proceed in parallel\n+          assert(entry == group_entry, \"must be!\");\n+          \/\/ predecrement totals\n+          group_entry_total--;\n+          entry_total--;\n+          assert(entry_total > 0 || entry == entry_max(stub), \"must be!\");\n+          assert(group_entry_total > 0 || entry == entry_max(group), \"must be!\");\n+          assert(stubgroup(entry) == group, \"iterated out of group %s to entry %s\", name(group), name(entry));\n+          entry = next_in_stub(stub, entry);\n+          group_entry = next(group_entry);\n+        }\n+        assert(entry_total == 0, \"must be!\");\n+        stub = next_in_blob(blob, stub);\n+        group_stub = next(group_stub);\n+      }\n+      blob = next_in_group(group, blob);\n+    }\n+    assert(group_entry_total == 0, \"must be!\");\n+  }\n+}\n+\n+#endif \/\/ ASSERT\n+\n+\/\/ info support\n+\n+void StubInfo::dump_group_table(LogStream& ls) {\n+  ls.print_cr(\"STUB GROUP TABLE\");\n+  for (int i = 0; i < GROUP_TABLE_SIZE; i++) {\n+    GroupDetails& g = _group_table[i];\n+    ls.print_cr(\"%1d: %-8s\", i, g._name);\n+    if (g._base == g._max) {\n+      ls.print_cr(\"  blobs: %s(%d)\",\n+                  blob_details(g._base)._name,\n+                  static_cast<int>(g._base));\n+    } else {\n+      ls.print_cr(\" blobs: %s(%d) ... %s(%d)\",\n+                  blob_details(g._base)._name,\n+                  static_cast<int>(g._base),\n+                  blob_details(g._max)._name,\n+                  static_cast<int>(g._max));\n+    }\n+  }\n+}\n+\n+void StubInfo::dump_blob_table(LogStream& ls) {\n+  ls.print_cr(\"BLOB TABLE\");\n+  for (int i = 0; i < BLOB_TABLE_SIZE; i++) {\n+    BlobDetails& b = _blob_table[i];\n+    ls.print_cr(\"%-3d: %s\", i, b._name);\n+    if (b._base == b._max) {\n+      ls.print_cr(\"  stubs: %s(%d)\",\n+                  stub_details(b._base)._name,\n+                  static_cast<int>(b._base));\n+    } else {\n+      ls.print_cr(\"  stubs: %s(%d) ... %s(%d)\",\n+                  stub_details(b._base)._name,\n+                  static_cast<int>(b._base),\n+                  stub_details(b._max)._name,\n+                  static_cast<int>(b._max));\n+    }\n+  }\n+}\n+\n+void StubInfo::dump_stub_table(LogStream& ls) {\n+  ls.print_cr(\"STUB TABLE\");\n+  for (int i = 0; i < STUB_TABLE_SIZE; i++) {\n+    StubDetails& s = _stub_table[i];\n+    ls.print_cr(\"%-3d: %s %s\", i, s._name,\n+                (s._is_entry_array ? \"array\" : \"\"));\n+    ls.print_cr(\"  blob: %d\", static_cast<int>(s._blob));\n+    if (s._base == s._max) {\n+      \/\/ some stubs don't have an entry\n+      if (s._base == EntryId::NO_ENTRYID) {\n+        ls.print_cr(\"  entries: %s(%d)\",\n+                    \"no_entry\",\n+                    static_cast<int>(s._base));\n+      } else {\n+        ls.print_cr(\"  entries: %s(%d)\",\n+                    entry_details(s._base)._name,\n+                    static_cast<int>(s._base));\n+      }\n+    } else {\n+      ls.print_cr(\"  entries: %s(%d) ... %s(%d)\",\n+                  entry_details(s._base)._name,\n+                  static_cast<int>(s._base),\n+                  entry_details(s._max)._name,\n+                  static_cast<int>(s._max));\n+    }\n+  }\n+}\n+\n+void StubInfo::dump_entry_table(LogStream& ls) {\n+  ls.print_cr(\"ENTRY TABLE\");\n+  for (int i = 0; i < ENTRY_TABLE_SIZE; i++) {\n+    EntryDetails& e = _entry_table[i];\n+    ls.print_cr(\"%-3d: %s\", i, e._name);\n+    if (e._array_base != EntryId::NO_ENTRYID) {\n+      ls.print_cr(\"  array base: %d\", static_cast<int>(e._array_base));\n+    }\n+    ls.print_cr(\"  stub: %d\", static_cast<int>(e._stub));\n+  }\n+}\n+\n+void StubInfo::dump_tables(LogStream& ls) {\n+  dump_group_table(ls);\n+  ls.print_cr(\"\");\n+  dump_blob_table(ls);\n+  ls.print_cr(\"\");\n+  dump_stub_table(ls);\n+  ls.print_cr(\"\");\n+  dump_entry_table(ls);\n+}\n+\n+\/\/ Global Group\/Blob\/Stub\/Entry Id Hierarchy Traversal:\n+\n+\/\/ traverse up\n+\n+StubGroup StubInfo::stubgroup(EntryId id) {\n+  \/\/ delegate\n+  return stubgroup(stub(id));\n+}\n+\n+StubGroup StubInfo::stubgroup(BlobId id) {\n+  return blob_details(id)._group;\n+}\n+\n+StubGroup StubInfo::stubgroup(StubId id) {\n+  \/\/ delegate\n+  return stubgroup(blob(id));\n+}\n+\n+StubId StubInfo::stub(EntryId id) {\n+  return entry_details(id)._stub;\n+}\n+\n+BlobId StubInfo::blob(EntryId id) {\n+  \/\/ delegate\n+  return blob(stub(id));\n+}\n+\n+BlobId StubInfo::blob(StubId id) {\n+  return stub_details(id)._blob;\n+}\n+\n+\/\/ traverse down\n+\n+BlobId StubInfo::blob_base(StubGroup stub_group) {\n+  return group_details(stub_group)._base;\n+}\n+\n+BlobId StubInfo::blob_max(StubGroup stub_group) {\n+  return group_details(stub_group)._max;\n+}\n+\n+int StubInfo::blob_count(StubGroup stub_group) {\n+  return span(blob_max(stub_group), blob_base(stub_group));\n+}\n+\n+StubId StubInfo::stub_base(StubGroup stub_group) {\n+  \/\/ delegate\n+  return stub_base(blob_base(stub_group));\n+}\n+\n+StubId StubInfo::stub_max(StubGroup stub_group) {\n+  \/\/ delegate\n+  return stub_max(blob_max(stub_group));\n+}\n+\n+int StubInfo::stub_count(StubGroup stub_group) {\n+  return span(stub_max(stub_group), stub_base(stub_group));\n+}\n+\n+EntryId StubInfo::entry_base(StubGroup stub_group) {\n+  return group_details(stub_group)._entry_base;\n+}\n+\n+EntryId StubInfo::entry_max(StubGroup stub_group) {\n+  return group_details(stub_group)._entry_max;\n+}\n+\n+int StubInfo::entry_count(StubGroup stub_group) {\n+  return span(entry_max(stub_group), entry_base(stub_group));\n+}\n+\n+StubId StubInfo::stub_base(BlobId id) {\n+  return blob_details(id)._base;\n+}\n+\n+StubId StubInfo::stub_max(BlobId id) {\n+  return blob_details(id)._max;\n+}\n+\n+int StubInfo::stub_count(BlobId id) {\n+  return span(stub_max(id), stub_base(id));\n+}\n+\n+EntryId StubInfo::entry_base(StubId id) {\n+  return stub_details(id)._base;\n+}\n+\n+EntryId StubInfo::entry_max(StubId id) {\n+  return stub_details(id)._max;\n+}\n+\n+int StubInfo::entry_count(StubId id) {\n+  return span(entry_max(id), entry_base(id));\n+}\n+\n+EntryId StubInfo::entry_base(BlobId id) {\n+  return blob_details(id)._entry_base;\n+}\n+\n+EntryId StubInfo::entry_max(BlobId id) {\n+  return blob_details(id)._entry_max;\n+}\n+\n+int StubInfo::entry_count(BlobId id) {\n+  return span(entry_base(id), entry_max(id));\n+}\n+\n+\/\/ Global <-> Local Id Management:\n+\n+\/\/ private helpers\n+\n+bool StubInfo::has_group(BlobId id, StubGroup group) {\n+  return stubgroup(id) == group;\n+}\n+\n+bool StubInfo::has_group(StubId id, StubGroup group) {\n+  return stubgroup(id) == group;\n+}\n+\n+bool StubInfo::has_group(EntryId id, StubGroup group) {\n+  return stubgroup(id) == group;\n+}\n+\n+\/\/ Convert a blob, entry or stub id to a unique, zero-based offset in\n+\/\/ the range of blob\/stub\/entry ids for a given stub group.\n+\n+int StubInfo::local_offset(StubGroup group, BlobId id) {\n+  assert(has_group(id, group), \"id %s is not a %s blob!\", name(id), name(group));\n+  BlobId base = blob_base(group);\n+  int s = span(id, base);\n+  assert(s >= 1, \"must be\");\n+  return s - 1;\n+}\n+\n+int StubInfo::local_offset(StubGroup group, StubId id) {\n+  assert(has_group(id, group), \"id %s is not a %s stub!\", name(id), name(group));\n+  StubId base = stub_base(group);\n+  int s = span(id, base);\n+  assert(s >= 1, \"must be\");\n+  return s - 1;\n+}\n+\n+int StubInfo::local_offset(StubGroup group, EntryId id) {\n+  assert(has_group(id, group), \"id %s is not a %s entry!\", name(id), name(group));\n+  EntryId base = entry_base(group);\n+  int s = span(id, base);\n+  assert(s >= 1, \"must be\");\n+  return s - 1;\n+}\n+\n+\/\/ public API\n+\n+\/\/ check that a stub belongs to an expected stub group\n+\n+bool StubInfo::is_shared(StubId id) {\n+  return has_group(id, StubGroup::SHARED);\n+}\n+\n+bool StubInfo::is_c1(StubId id) {\n+  return has_group(id, StubGroup::C1);\n+}\n+\n+bool StubInfo::is_c2(StubId id) {\n+  return has_group(id, StubGroup::C2);\n+}\n+\n+bool StubInfo::is_stubgen(StubId id) {\n+  return has_group(id, StubGroup::STUBGEN);\n+}\n+\n+\/\/ check that a stub belongs to an expected stub group\n+\n+bool StubInfo::is_shared(BlobId id) {\n+  return has_group(id, StubGroup::SHARED);\n+}\n+\n+bool StubInfo::is_c1(BlobId id) {\n+  return has_group(id, StubGroup::C1);\n+}\n+\n+bool StubInfo::is_c2(BlobId id) {\n+  return has_group(id, StubGroup::C2);\n+}\n+\n+bool StubInfo::is_stubgen(BlobId id) {\n+  return has_group(id, StubGroup::STUBGEN);\n+}\n+\n+\/\/ Convert a stub id to a unique, zero-based offset in the range of\n+\/\/ stub ids for a given stub group.\n+\n+int StubInfo::shared_offset(StubId id) {\n+  return local_offset(StubGroup::SHARED, id);\n+}\n+\n+int StubInfo::c1_offset(StubId id) {\n+  return local_offset(StubGroup::C1, id);\n+}\n+\n+int StubInfo::c2_offset(StubId id) {\n+  return local_offset(StubGroup::C2, id);\n+}\n+\n+int StubInfo::stubgen_offset(StubId id) {\n+  return local_offset(StubGroup::STUBGEN, id);\n+}\n+\n+\/\/ initialization function called to populate blob. stub and entry\n+\/\/ tables. this must be called before any stubs are generated\n+void initialize_stub_info() {\n+  ResourceMark rm;\n+  StubInfo::populate_stub_tables();\n+\n+  LogTarget(Debug, stubs) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    StubInfo::dump_tables(ls);\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/stubInfo.cpp","additions":1080,"deletions":0,"binary":false,"changes":1080,"status":"added"},{"patch":"@@ -0,0 +1,684 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_STUBINFO_HPP\n+#define SHARE_RUNTIME_STUBINFO_HPP\n+\n+#include \"logging\/logStream.hpp\"\n+#include \"runtime\/stubDeclarations.hpp\"\n+\n+\/\/ class StubInfo records details of the global stubgroup, blob, stub\n+\/\/ and entry hierarchy and provides APIs that\n+\/\/\n+\/\/ 1) allow relationships between blobs, stubs and their entries to be\n+\/\/ identified.\n+\/\/\n+\/\/ 2) Support conversion from a global blob\/stub\/entry id to a\n+\/\/ corresponding, unique, group-local blob\/stub\/entry offset from the\n+\/\/ first blob\/stub\/entry in the same stubgroup\n+\n+\/\/ We have four distinct stub groups, each of which includes multiple\n+\/\/ blobs, stubs and entries.\n+\n+enum class StubGroup : int {\n+  SHARED,\n+  C1,\n+  C2,\n+  STUBGEN,\n+  NUM_STUBGROUPS\n+};\n+\n+\/\/ Generated code elements are used to implement the following enums:\n+\/\/\n+\/\/ Global and Stub Group Local Blob\/Stub\/Entry Enumerations:\n+\/\/\n+\/\/ The following enums uniquely list every generated blob, stub and\n+\/\/ entry across all four stub groups.\n+\/\/\n+\/\/ enum StubId;   \/\/ unique id for every stub in the above groups\n+\/\/ enum BlobId;   \/\/ unique id for every blob in the above groups\n+\/\/ enum EntryId;  \/\/ unique id for every entry in the above groups\n+\/\/\n+\/\/\n+\/\/ Management APIs for these enums are defined in class StubInfo. The\n+\/\/ API methods rely on a small amount of code and data genertaed from\n+\/\/ the blob, stub and entry declarations.\n+\/\/\n+\/\/ Global Group\/Blob\/Stub\/Entry Id Hierarchy Traversal:\n+\/\/\n+\/\/ traverse up\n+\/\/\n+\/\/ StubGroup StubInfo::stubgroup(EntryId);\n+\/\/ StubGroup StubInfo::stubgroup(BlobId);\n+\/\/ StubGroup StubInfo::stubgroup(StubId);\n+\/\/\n+\/\/ StubId  StubInfo::stub(EntryId);\n+\/\/ BlobId  StubInfo::blob(EntryId);\n+\/\/ BlobId  StubInfo::blob(StubId);\n+\/\/\n+\/\/ traverse down\n+\/\/\n+\/\/ BlobId  StubInfo::blob_base(StubGroup)\n+\/\/ BlobId  StubInfo::blob_max(StubGroup)\n+\/\/ int           StubInfo::blob_count(StubGroup)\n+\/\/\n+\/\/ StubId  StubInfo::stub_base(StubGroup)\n+\/\/ StubId  StubInfo::stub_max(StubGroup)\n+\/\/ int     StubInfo::stub_count(StubGroup)\n+\/\/\n+\/\/ EntryId StubInfo::entry_base(StubGroup)\n+\/\/ EntryId StubInfo::entry_max(StubGroup)\n+\/\/ int     StubInfo::entry_count(StubGroup)\n+\/\/\n+\/\/ StubId  StubInfo::stub_base(BlobId);\n+\/\/ StubId  StubInfo::stub_max(BlobId);\n+\/\/ int     StubInfo::stub_count(BlobId);\n+\/\/\n+\/\/ EntryId StubInfo::entry_base(StubId);\n+\/\/ EntryId StubInfo::entry_max(StubId);\n+\/\/ int     StubInfo::entry_count(StubId);\n+\/\/\n+\/\/ EntryId StubInfo::entry_base(BlobId);\n+\/\/ EntryId StubInfo::entry_max(BlobId);\n+\/\/ int     StubInfo::entry_count(BlobId);\n+\/\/\n+\/\/\n+\/\/ Global <-> Local Id Management:\n+\/\/\n+\/\/ check that a stub belongs to an expected stub group\n+\/\/\n+\/\/ bool StubInfo::is_shared(StubId id);\n+\/\/ bool StubInfo::is_c1(StubId id);\n+\/\/ bool StubInfo::is_c2(StubId id);\n+\/\/ bool StubInfo::is_stubgen(StubId id);\n+\/\/\n+\/\/ Convert a stub id to a unique, zero-based offset in the range of\n+\/\/ stub ids for a given stub group.\n+\/\/\n+\/\/ int  StubInfo::shared_offset(StubId id);\n+\/\/ int  StubInfo::c1_offset(StubId id);\n+\/\/ int  StubInfo::c2_offset(StubId id);\n+\/\/ int  StubInfo::stubgen_offset(StubId id);\n+\/\/\n+\/\/ Convert a blob id to a unique, zero-based offset in the range of\n+\/\/ blob ids for a given stub group. we only need this for stubgen\n+\/\/ blobs as for all other stub groups the stub indices and blob\n+\/\/ indices are identical.\n+\/\/\n+\/\/ int  StubInfo::stubgen_offset(BlobId id);\n+\/\/\n+\/\/ Convert an entry id to a unique, zero-based offset in the range\n+\/\/ of entry ids for a given stub group. we only need this for shared\n+\/\/ and stubgen blobs as for all other stub groups the stub indices\n+\/\/ and entry indices are identical.\n+\/\/\n+\/\/ int  StubInfo::shared_offset(EntryId id);\n+\/\/ int  StubInfo::stubgen_offset(EntryId id);\n+\/\/\n+\/\/ n.b. invalid interconversions from a global id to the wrong type of\n+\/\/ group id are caught by asserts\n+\n+\n+\/\/ Generate global blob, stub and entry enums from blob, stubs and\n+\/\/ entry declarations\n+\n+\/\/ Global enumeration for all blobs\n+\/\/\n+\/\/ n.b. the stubgroup is included in tag because the same name may be\n+\/\/ reused across groups (e.g. c1 and c2 both use new_instance)\n+\/\/\n+\/\/    enum BlobId {\n+\/\/      shared_deopt_id,\n+\/\/      . . .\n+\/\/      c1_unwind_exception_id,\n+\/\/      . . .\n+\/\/      c2_uncommon_trap_id,\n+\/\/      . . .\n+\/\/      stubgen_initial_id,\n+\/\/      . . .\n+\/\/      NUM_BLOBIDS,\n+\/\/    };\n+\n+\n+#define SHARED_DECLARE_TAG(name, type) JOIN3(shared, name, id) ,\n+#define C1_DECLARE_TAG(name) JOIN3(c1, name, id) ,\n+#define C2_DECLARE_TAG1(name) JOIN3(c2, name, id) ,\n+#define C2_DECLARE_TAG2(name, _1) JOIN3(c2, name, id) ,\n+#define C2_DECLARE_TAG4(name, _1, _2, _3) JOIN3(c2, name, id) ,\n+#define STUBGEN_DECLARE_TAG(name) JOIN3(stubgen, name, id) ,\n+\n+enum class BlobId : int {\n+  NO_BLOBID = -1,\n+  \/\/ declare an enum tag for each shared runtime blob\n+  SHARED_STUBS_DO(SHARED_DECLARE_TAG)\n+  \/\/ declare an enum tag for each c1 runtime blob\n+  C1_STUBS_DO(C1_DECLARE_TAG)\n+  \/\/ declare an enum tag for each opto runtime blob or stub\n+  C2_STUBS_DO(C2_DECLARE_TAG2,\n+              C2_DECLARE_TAG4,\n+              C2_DECLARE_TAG1)\n+  \/\/ declare an enum tag for each stubgen blob\n+  STUBGEN_BLOBS_DO(STUBGEN_DECLARE_TAG)\n+  NUM_BLOBIDS\n+};\n+\n+#undef SHARED_DECLARE_TAG\n+#undef C1_DECLARE_TAG\n+#undef C2_DECLARE_TAG1\n+#undef C2_DECLARE_TAG2\n+#undef C2_DECLARE_TAG4\n+#undef STUBGEN_DECLARE_TAG\n+\n+\/\/ Global enumeration for all stubs\n+\/\/\n+\/\/ n.b. the stubgroup is included in tag because the same name may be\n+\/\/ reused across groups (e.g. c1 and c2 both use new_instance). For\n+\/\/ stubgen stubs the blob name is omitted from the tag because all\n+\/\/ stub names may not be reused scross different stubgen blobs.\n+\/\/\n+\/\/    enum StubId {\n+\/\/      shared_deopt_id,\n+\/\/      . . .\n+\/\/      c1_unwind_exception_id,\n+\/\/      . . .\n+\/\/      c2_uncommon_trap_id,\n+\/\/      . . .\n+\/\/      stubgen_call_stub_id,\n+\/\/      stubgen_forward_exception_id,\n+\/\/      . . .\n+\/\/      NUM_BLOBIDS,\n+\/\/    };\n+\/\/\n+\n+#define SHARED_DECLARE_TAG(name, type) JOIN3(shared, name, id) ,\n+#define C1_DECLARE_TAG(name) JOIN3(c1, name, id) ,\n+#define C2_DECLARE_TAG1(name) JOIN3(c2, name, id) ,\n+#define C2_DECLARE_TAG2(name, _1) JOIN3(c2, name, id) ,\n+#define C2_DECLARE_TAG4(name, _1, _2, _3) JOIN3(c2, name, id) ,\n+#define STUBGEN_DECLARE_TAG(blob, name) JOIN3(stubgen, name, id) ,\n+\n+enum class StubId : int {\n+  NO_STUBID = -1,\n+  \/\/ declare an enum tag for each shared runtime blob\n+  SHARED_STUBS_DO(SHARED_DECLARE_TAG)\n+  \/\/ declare an enum tag for each c1 runtime blob\n+  C1_STUBS_DO(C1_DECLARE_TAG)\n+  \/\/ declare an enum tag for each opto runtime blob or stub\n+  C2_STUBS_DO(C2_DECLARE_TAG2,\n+              C2_DECLARE_TAG4,\n+              C2_DECLARE_TAG1)\n+  \/\/ declare an enum tag for each stubgen runtime stub\n+  STUBGEN_STUBS_DO(STUBGEN_DECLARE_TAG)\n+  NUM_STUBIDS\n+};\n+\n+#undef SHARED_DECLARE_TAG\n+#undef C1_DECLARE_TAG\n+#undef C2_DECLARE_TAG1\n+#undef C2_DECLARE_TAG2\n+#undef C2_DECLARE_TAG4\n+#undef STUBGEN_DECLARE_TAG\n+\n+\n+\/\/\n+\/\/ Global enumeration for all entries\n+\/\/\n+\/\/ n.b. the stubgroup is included in tag because the same name may be\n+\/\/ reused across groups (e.g. c1 and c2 both use new_instance)\n+\/\/\n+\/\/    enum EntryId : int {\n+\/\/      NO_ENTRYID = -1,\n+\/\/      shared_deopt_id,\n+\/\/      shared_deopt_max =\n+\/\/        shared_deopt_id + DeoptimzationBlob::NUM_ENTRIES -1,\n+\/\/      . . .\n+\/\/      c1_unwind_exception_id,\n+\/\/      . . .\n+\/\/      c2_uncommon_trap_id,\n+\/\/      . . .\n+\/\/      stubgen_call_stub_id,\n+\/\/      stubgen_call_stub_return_address_id,\n+\/\/      stubgen_forward_exception_id,\n+\/\/      . . .\n+\/\/      stubgen_aarch64_large_array_equals_id,\n+\/\/      . . .\n+\/\/      stubgen_lookup_secondary_supers_table_stubs_id,\n+\/\/      stubgen_lookup_secondary_supers_table_stubs_max =\n+\/\/        stubgen_lookup_secondary_supers_table_stubs_id +\n+\/\/        Klass::SECONDARY_SUPERS_TABLE_SIZE,\n+\/\/      . . .\n+\/\/      NUM_ENTRYIDS,\n+\/\/    };\n+\/\/\n+\/\/ - global id tags include a stub group prefix because some of the\n+\/\/ stub names are used in more than one group (e.g. new_instance,\n+\/\/ forward_exception). arch specific stubgen stubs also include the\n+\/\/ arch name in the tag.\n+\/\/\n+\/\/ - for shared stub entries we only need to allocate a single enum\n+\/\/ tag for most blobs since they have only one entry. However, we need\n+\/\/ to bump up the index by an extra 3 (or 5 with JVMCI included) when\n+\/\/ we are generating the deoptimization blob because it has 4\n+\/\/ (respectively, 6) entries. So, in that case we allocate a single\n+\/\/ enum tag identifying the index of the first entry and a max tag\n+\/\/ identifying the index of the last entry\n+\/\/\n+\/\/ - for stubgen stubs which employ an array of entries we allocate a\n+\/\/ single enum tag identifying the index of the first entry and a max\n+\/\/ tag identifying the index of the last entry e.g. for\n+\/\/ lookup_secondary_supers_table we generate\n+\/\/\n+\/\/      . . .\n+\/\/      stubgen_lookup_secondary_supers_table_stubs_id,\n+\/\/      stubgen_lookup_secondary_supers_table_stubs_max = stubgen_lookup_secondary_supers_table_stubs_id + Klass::SECONDARY_SUPERS_TABLE_SIZE,\n+\/\/      . . .\n+\/\/\n+\n+\/\/ macro to declare tags for shared entries with a base id for the\n+\/\/ first (and usually only) entry and a max id that identifies the\n+\/\/ last (usually same as first) entry in the blob, ensuring the entry\n+\/\/ for the next stub has the correct index.\n+\n+#define SHARED_DECLARE_TAG(name, type)                                  \\\n+  JOIN3(shared, name, id),                                              \\\n+  JOIN3(shared, name, max) = JOIN3(shared, name, id) +                  \\\n+    type ::ENTRY_COUNT - 1,                                             \\\n+\n+\/\/ macros to declare a tag for a C1 generated blob or a C2 generated\n+\/\/ blob, stub or JVMTI stub all of which have a single unique entry\n+\n+#define C1_DECLARE_TAG(name)           \\\n+  JOIN3(c1, name, id),                 \\\n+\n+#define C2_DECLARE_BLOB_TAG(name, type)                               \\\n+  JOIN3(c2, name, id),                                                \\\n+\n+#define C2_DECLARE_STUB_TAG(name, fancy_jump, pass_tls, return_pc)    \\\n+  JOIN3(c2, name, id),                                                \\\n+\n+#define C2_DECLARE_JVMTI_STUB_TAG(name)                               \\\n+  JOIN3(c2, name, id),                                                \\\n+\n+\/\/ macros to declare a tag for a StubGen normal entry or initialized\n+\/\/ entry\n+\n+#define STUBGEN_DECLARE_TAG(blob_name, stub_name,                       \\\n+                            field_name, getter_name)                    \\\n+  JOIN3(stubgen, field_name, id),                                       \\\n+\n+#define STUBGEN_DECLARE_INIT_TAG(blob_name, stub_name,                  \\\n+                                 field_name, getter_name,               \\\n+                                 init_function)                         \\\n+  JOIN3(stubgen, field_name, id),                                       \\\n+\n+\/\/ macro to declare a tag for a StubGen entry array. this macro\n+\/\/ declares a base id for the first entry then a max id that\n+\/\/ identifies the last entry in the array, ensuring the entry for the\n+\/\/ next stub has the correct index.\n+\n+#define STUBGEN_DECLARE_ARRAY_TAG(blob_name, stub_name,                 \\\n+                                  field_name, getter_name,              \\\n+                                  count)                                \\\n+  JOIN3(stubgen, field_name, id),                                       \\\n+  JOIN3(stubgen, field_name, max) = JOIN3(stubgen, field_name, id) +    \\\n+    count - 1,                                                          \\\n+\n+\/\/ macros to declare a tag for StubGen arch entries\n+\n+#define STUBGEN_DECLARE_ARCH_TAG(arch_name, blob_name, stub_name,       \\\n+                                 field_name, getter_name)               \\\n+  JOIN4(stubgen, arch_name, field_name, id),                            \\\n+\n+#define STUBGEN_DECLARE_ARCH_INIT_TAG(arch_name, blob_name, stub_name,  \\\n+                                      field_name, getter_name,          \\\n+                                      init_function)                    \\\n+  JOIN4(stubgen, arch_name, field_name, id),                            \\\n+\n+\/\/ the above macros are enough to declare the enum\n+\n+enum class EntryId : int {\n+  NO_ENTRYID = -1,\n+  \/\/ declare an enum tag for each shared runtime blob\n+  SHARED_STUBS_DO(SHARED_DECLARE_TAG)\n+  \/\/ declare an enum tag for each c1 runtime blob\n+  C1_STUBS_DO(C1_DECLARE_TAG)\n+  \/\/ declare an enum tag for each opto runtime blob or stub\n+  C2_STUBS_DO(C2_DECLARE_BLOB_TAG,\n+              C2_DECLARE_STUB_TAG,\n+              C2_DECLARE_JVMTI_STUB_TAG)\n+  \/\/ declare an enum tag for each stubgen entry or, in the case of an\n+  \/\/ array of entries for the first and last entries.\n+  STUBGEN_ALL_ENTRIES_DO(STUBGEN_DECLARE_TAG,\n+                         STUBGEN_DECLARE_INIT_TAG,\n+                         STUBGEN_DECLARE_ARRAY_TAG,\n+                         STUBGEN_DECLARE_ARCH_TAG,\n+                         STUBGEN_DECLARE_ARCH_INIT_TAG)\n+  NUM_ENTRYIDS\n+};\n+\n+#undef SHARED_DECLARE_TAG\n+#undef C1_DECLARE_TAG\n+#undef C2_DECLARE_BLOB_TAG\n+#undef C2_DECLARE_STUB_TAG\n+#undef C2_DECLARE_JVMTI_STUB_TAG\n+#undef STUBGEN_DECLARE_TAG\n+#undef STUBGEN_DECLARE_INIT_TAG\n+#undef STUBGEN_DECLARE_ARRAY_TAG\n+#undef STUBGEN_DECLARE_ARCH_TAG\n+#undef STUBGEN_DECLARE_ARCH_INIT_TAG\n+\n+\/\/ we need static init expressions for blob, stub and entry counts in\n+\/\/ each stubgroup\n+\n+#define SHARED_STUB_COUNT_INITIALIZER           \\\n+  0 SHARED_STUBS_DO(COUNT2)\n+\n+#define SHARED_ENTRY_COUNT_INITIALIZER          \\\n+  0 SHARED_STUBS_DO(SHARED_COUNT2)\n+\n+#define C1_STUB_COUNT_INITIALIZER               \\\n+  0 C1_STUBS_DO(COUNT1)\n+\n+#define C2_STUB_COUNT_INITIALIZER               \\\n+  0 C2_STUBS_DO(COUNT2, COUNT4, COUNT1)\n+\n+#define STUBGEN_BLOB_COUNT_INITIALIZER          \\\n+  0 STUBGEN_BLOBS_DO(COUNT1)\n+\n+#define STUBGEN_STUB_COUNT_INITIALIZER          \\\n+  0 STUBGEN_STUBS_DO(COUNT2)\n+\n+#define STUBGEN_ENTRY_COUNT_INITIALIZER          \\\n+  0 STUBGEN_ALL_ENTRIES_DO(COUNT4, COUNT5,       \\\n+                           STUBGEN_COUNT5,       \\\n+                           COUNT5, COUNT6)\n+\n+\/\/ Declare management class StubInfo\n+\n+class StubInfo: AllStatic {\n+private:\n+  \/\/ element types for tables recording stubgroup, blob, stub and\n+  \/\/ entry properties and relationships\n+\n+  \/\/ map each stubgroup to its initial and final blobs\n+  struct GroupDetails {\n+    BlobId _base;       \/\/ first blob id belonging to stub group\n+    BlobId _max;        \/\/ last blob id belonging to stub group\n+    \/\/ some stubs have no entries so we have to explicitly track the\n+    \/\/ first and last entry associated with the group rather than\n+    \/\/ deriving it from the first and last blob\/stub pair\n+    EntryId _entry_base;  \/\/ first entry id belonging to stub\n+    EntryId _entry_max;   \/\/ last entry id belonging to stub\n+    const char* _name;          \/\/ name of stubgroup\n+  };\n+\n+  \/\/ a blob table element enables the stub group of a guven blob to be\n+  \/\/ identified and all stubs within the blob to be identified\n+  \/\/\n+  \/\/ invariant: the number of stubs in a blob must be 1 unless the\n+  \/\/ blob belongs to the StubGen stub group\n+\n+  struct BlobDetails {\n+    StubGroup _group;           \/\/ stub group to which blob belongs\n+    StubId _base;         \/\/ first stub id belonging to blob\n+    StubId _max;          \/\/ last stub id belonging to blob\n+    \/\/ some stubs have no entries so we have to explicitly track the\n+    \/\/ first and last entry associated with the blob rather than\n+    \/\/ deriving it from the first and last stub\n+    EntryId _entry_base;  \/\/ first entry id belonging to stub\n+    EntryId _entry_max;   \/\/ last entry id belonging to stub\n+    const char* _name;          \/\/ name of blob\n+  };\n+\n+  \/\/ a stub table element enables the blob of a given stub to be\n+  \/\/ identified and all entries within the stub to be identified\n+  \/\/\n+  \/\/ invariant: the number of entries in a blob must be 1 unless the\n+  \/\/ blob belongs to the StubGen group or the Shared stub group\n+\n+  struct StubDetails {\n+    BlobId _blob;         \/\/ blob to which stub belongs\n+    EntryId _base;        \/\/ first entry id belonging to stub\n+    EntryId _max;         \/\/ last entry id belonging to stub\n+    bool _is_entry_array;       \/\/ true iff stub has array of entries\n+    const char* _name;          \/\/ name of stub\n+  };\n+\n+  \/\/ a stub table element enables the blob of a given stub to be\n+  \/\/ identified and all entries within the stub to be identified\n+  \/\/\n+  \/\/ invariant: the number of entries in a blob must be 1 unless the\n+  \/\/ blob belongs to the StubGen group or the Shared stub group\n+\n+  struct EntryDetails {\n+    StubId _stub;          \/\/ stub to which the entry belongs\n+    EntryId _array_base;   \/\/ base entry id for entry array stubs\n+    const char* _name;           \/\/ name of stub\n+  };\n+\n+  \/\/ tables are sized and indexed using the global ids\n+  static const int GROUP_TABLE_SIZE = static_cast<int>(StubGroup::NUM_STUBGROUPS);\n+  static const int BLOB_TABLE_SIZE = static_cast<int>(BlobId::NUM_BLOBIDS);\n+  static const int STUB_TABLE_SIZE = static_cast<int>(StubId::NUM_STUBIDS);\n+  static const int ENTRY_TABLE_SIZE = static_cast<int>(EntryId::NUM_ENTRYIDS);\n+\n+  static struct GroupDetails _group_table[GROUP_TABLE_SIZE];\n+  static struct BlobDetails _blob_table[BLOB_TABLE_SIZE];\n+  static struct StubDetails _stub_table[STUB_TABLE_SIZE];\n+  static struct EntryDetails _entry_table[ENTRY_TABLE_SIZE];\n+\n+  \/\/ helpers to access table elements using enums as indices\n+  static struct GroupDetails& group_details(StubGroup g);\n+  static struct BlobDetails& blob_details(BlobId b);\n+  static struct StubDetails& stub_details(StubId s);\n+  static struct EntryDetails& entry_details(EntryId e);\n+\n+  \/\/ helpers for counting entries\/stubs in a given stub\/blob\n+\n+  static int span(EntryId second, EntryId first);\n+  static int span(StubId second, StubId first);\n+  static int span(BlobId second, BlobId first);\n+\n+  \/\/ helper for testing whether a blob, stub or entry lies in a\n+  \/\/ specific stubgroup\n+  static bool has_group(BlobId id, StubGroup group);\n+  static bool has_group(StubId id, StubGroup group);\n+  static bool has_group(EntryId id, StubGroup group);\n+\n+  \/\/ helpers for computing blob, stub or entry offsets within\n+  \/\/ a specific stub group\n+\n+  static int local_offset(StubGroup group, BlobId id);\n+  static int local_offset(StubGroup group, StubId id);\n+  static int local_offset(StubGroup group, EntryId id);\n+\n+  \/\/ implementation of methods used to populate the stubgroup, blob,\n+  \/\/ stub and entry tables\n+  static void process_shared_blob(StubGroup& group_cursor,\n+                                  BlobId&  blob_cursor,\n+                                  StubId& stub_cursor,\n+                                  EntryId& entry_cursor,\n+                                  const char* name,\n+                                  BlobId declaredBlob,\n+                                  StubId declaredStub,\n+                                  EntryId declaredEntry,\n+                                  EntryId declaredMax);\n+  static void process_c1_blob(StubGroup& group_cursor,\n+                              BlobId&  blob_cursor,\n+                              StubId& stub_cursor,\n+                              EntryId& entry_cursor,\n+                              const char* name,\n+                              BlobId declaredBlob,\n+                              StubId declaredStub,\n+                              EntryId declaredEntry);\n+  static void process_c2_blob(StubGroup& group_cursor,\n+                              BlobId&  blob_cursor,\n+                              StubId& stub_cursor,\n+                              EntryId& entry_cursor,\n+                              const char* name,\n+                              BlobId declaredBlob,\n+                              StubId declaredStub,\n+                              EntryId declaredEntry);\n+  static void process_stubgen_blob(StubGroup& group_cursor,\n+                                   BlobId&  blob_cursor,\n+                                   StubId& stub_cursor,\n+                                   EntryId& entry_cursor,\n+                                   const char* name,\n+                                   BlobId declaredBlob);\n+  static void process_stubgen_stub(StubGroup& group_cursor,\n+                                   BlobId&  blob_cursor,\n+                                   StubId& stub_cursor,\n+                                   EntryId& entry_cursor,\n+                                   const char* name,\n+                                   BlobId declaredBlob,\n+                                   StubId declaredStub);\n+  static void process_stubgen_entry(StubGroup& group_cursor,\n+                                    BlobId&  blob_cursor,\n+                                    StubId& stub_cursor,\n+                                    EntryId& entry_cursor,\n+                                    const char* name,\n+                                    BlobId declaredBlob,\n+                                    StubId declaredStub,\n+                                    EntryId declaredEntry,\n+                                    int arrayCount);\n+\n+  static void dump_group_table(LogStream& ls);\n+  static void dump_blob_table(LogStream& ls);\n+  static void dump_stub_table(LogStream& ls);\n+  static void dump_entry_table(LogStream& ls);\n+\n+  static void verify_stub_tables();\n+public:\n+\n+  \/\/ Define statically sized counts for blobs, stubs and entries in\n+  \/\/ each stub group. n.b. we omit cases where the blob or entry count\n+  \/\/ equals the stub count.\n+  static const int SHARED_STUB_COUNT = SHARED_STUB_COUNT_INITIALIZER;\n+  static const int SHARED_ENTRY_COUNT = SHARED_ENTRY_COUNT_INITIALIZER;\n+\n+  static const int C1_STUB_COUNT = C1_STUB_COUNT_INITIALIZER;\n+\n+  static const int C2_STUB_COUNT = C2_STUB_COUNT_INITIALIZER;\n+\n+  static const int STUBGEN_STUB_COUNT = STUBGEN_STUB_COUNT_INITIALIZER;\n+  static const int STUBGEN_BLOB_COUNT = STUBGEN_BLOB_COUNT_INITIALIZER;\n+  static const int STUBGEN_ENTRY_COUNT = STUBGEN_ENTRY_COUNT_INITIALIZER;\n+\n+  \/\/ init method called from a static initializer\n+  static void populate_stub_tables();\n+  \/\/ for logging\n+  static void dump_tables(LogStream& ls);\n+\n+  \/\/ helpers to step through blob, stub or entry enum sequences.\n+  \/\/ input id may be NO_BLOB\/STUB\/ENTRYID. returned id may be\n+  \/\/ NUM_BLOB\/STUB\/ENTRYIDs\n+  static BlobId next(BlobId id);\n+  static StubId next(StubId id);\n+  static EntryId next(EntryId id);\n+\n+  \/\/ helpers to step through blob\/stub\/entry enum sequence within\n+  \/\/ (respectively) the enclosing group\/blob\/stub. returned id will be\n+  \/\/ a valid blob\/stub\/entry id or NO_BLOB\/STUB\/ENTRYID if the\n+  \/\/ group\/blob\/stub contains no more stubs\/entries.\n+  static BlobId next_in_group(StubGroup stub_group, BlobId blob_id);\n+  static StubId next_in_blob(BlobId blob_id, StubId stub_id);\n+  static EntryId next_in_stub(StubId stub_id, EntryId entry_id);\n+\n+#ifdef ASSERT\n+  \/\/ helpers to check sequencing of blobs stubs and entries\n+  static bool is_next(BlobId second, BlobId first);\n+  static bool is_next(StubId second, StubId first);\n+  static bool is_next(EntryId second, EntryId first);\n+#endif \/\/ ASSERT\n+\n+  \/\/ name retrieval\n+  static const char* name(StubGroup stub_group);\n+  static const char* name(BlobId id);\n+  static const char* name(StubId id);\n+  static const char* name(EntryId id);\n+\n+  \/\/ Global Group\/Blob\/Stub\/Entry Id Hierarchy Traversal:\n+\n+  \/\/ traverse up\n+\n+  static StubGroup stubgroup(EntryId id);\n+  static StubGroup stubgroup(BlobId id);\n+  static StubGroup stubgroup(StubId id);\n+\n+  static StubId  stub(EntryId id);\n+  static BlobId  blob(EntryId id);\n+  static BlobId  blob(StubId id);\n+\n+  \/\/ traverse down\n+\n+  static BlobId  blob_base(StubGroup stub_group);\n+  static BlobId  blob_max(StubGroup stub_group);\n+  static int     blob_count(StubGroup stub_group);\n+\n+  static StubId  stub_base(StubGroup stub_group);\n+  static StubId  stub_max(StubGroup stub_group);\n+  static int     stub_count(StubGroup stub_group);\n+\n+  static EntryId entry_base(StubGroup stub_group);\n+  static EntryId entry_max(StubGroup stub_group);\n+  static int     entry_count(StubGroup stub_group);\n+\n+  static StubId  stub_base(BlobId id);\n+  static StubId  stub_max(BlobId id);\n+  static int     stub_count(BlobId id);\n+\n+  static EntryId entry_base(BlobId id);\n+  static EntryId entry_max(BlobId id);\n+  static int     entry_count(BlobId id);\n+\n+  static EntryId entry_base(StubId id);\n+  static EntryId entry_max(StubId id);\n+  static int     entry_count(StubId id);\n+\n+  \/\/ Global <-> Local Id Management:\n+\n+  \/\/ check that a blob\/stub belongs to an expected stub group\n+\n+  static bool is_shared(StubId id);\n+  static bool is_c1(StubId id);\n+  static bool is_c2(StubId id);\n+  static bool is_stubgen(StubId id);\n+\n+  static bool is_shared(BlobId id);\n+  static bool is_c1(BlobId id);\n+  static bool is_c2(BlobId id);\n+  static bool is_stubgen(BlobId id);\n+\n+  \/\/ Convert a stub id to a unique, zero-based offset in the range of\n+  \/\/ stub ids for a given stub group.\n+\n+  static int  shared_offset(StubId id);\n+  static int  c1_offset(StubId id);\n+  static int  c2_offset(StubId id);\n+  static int  stubgen_offset(StubId id);\n+};\n+\n+\n+#endif \/\/ SHARE_RUNTIME_STUBINFO_HPP\n","filename":"src\/hotspot\/share\/runtime\/stubInfo.hpp","additions":684,"deletions":0,"binary":false,"changes":684,"status":"added"},{"patch":"@@ -51,23 +51,0 @@\n-\/\/ define arrays to hold stub and blob names\n-\n-\/\/ use a template to generate the initializer for the blob names array\n-\n-#define DEFINE_BLOB_NAME(blob_name)             \\\n-  # blob_name,\n-\n-const char* StubRoutines::_blob_names[StubGenBlobId::NUM_BLOBIDS] = {\n-  STUBGEN_BLOBS_DO(DEFINE_BLOB_NAME)\n-};\n-\n-#undef DEFINE_BLOB_NAME\n-\n-#define DEFINE_STUB_NAME(blob_name, stub_name)          \\\n-  # stub_name ,                                         \\\n-\n-\/\/ use a template to generate the initializer for the stub names array\n-const char* StubRoutines::_stub_names[StubGenStubId::NUM_STUBIDS] = {\n-  STUBGEN_STUBS_DO(DEFINE_STUB_NAME)\n-};\n-\n-#undef DEFINE_STUB_NAME\n-\n@@ -76,1 +53,1 @@\n-#define DEFINE_BLOB_FIELD(blob_name) \\\n+#define DEFINE_STUBGEN_BLOB_FIELD(blob_name)                            \\\n@@ -79,1 +56,1 @@\n-STUBGEN_BLOBS_DO(DEFINE_BLOB_FIELD)\n+STUBGEN_BLOBS_DO(DEFINE_STUBGEN_BLOB_FIELD)\n@@ -81,1 +58,1 @@\n-#undef DEFINE_BLOB_FIELD\n+#undef DEFINE_STUBGEN_BLOB_FIELD\n@@ -83,1 +60,1 @@\n-\/\/ Define fields used to store stub entries\n+\/\/ Define fields used to store stubgen stub entries\n@@ -85,1 +62,1 @@\n-#define DEFINE_ENTRY_FIELD(blob_name, stub_name, field_name, getter_name) \\\n+#define DEFINE_STUBGEN_ENTRY_FIELD(blob_name, stub_name, field_name, getter_name) \\\n@@ -88,1 +65,1 @@\n-#define DEFINE_ENTRY_FIELD_INIT(blob_name, stub_name, field_name, getter_name, init_function) \\\n+#define DEFINE_STUBGEN_ENTRY_FIELD_INIT(blob_name, stub_name, field_name, getter_name, init_function) \\\n@@ -91,1 +68,1 @@\n-#define DEFINE_ENTRY_FIELD_ARRAY(blob_name, stub_name, field_name, getter_name, count) \\\n+#define DEFINE_STUBGEN_ENTRY_FIELD_ARRAY(blob_name, stub_name, field_name, getter_name, count) \\\n@@ -94,1 +71,1 @@\n-STUBGEN_ENTRIES_DO(DEFINE_ENTRY_FIELD, DEFINE_ENTRY_FIELD_INIT, DEFINE_ENTRY_FIELD_ARRAY)\n+STUBGEN_ENTRIES_DO(DEFINE_STUBGEN_ENTRY_FIELD, DEFINE_STUBGEN_ENTRY_FIELD_INIT, DEFINE_STUBGEN_ENTRY_FIELD_ARRAY)\n@@ -96,3 +73,3 @@\n-#undef DEFINE_ENTRY_FIELD_ARRAY\n-#undef DEFINE_ENTRY_FIELD_INIT\n-#undef DEFINE_ENTRY_FIELD\n+#undef DEFINE_STUBGEN_ENTRY_FIELD_ARRAY\n+#undef DEFINE_STUBGEN_ENTRY_FIELD_INIT\n+#undef DEFINE_STUBGEN_ENTRY_FIELD\n@@ -105,3 +82,3 @@\n-const char* StubRoutines::get_blob_name(StubGenBlobId id) {\n-  assert(0 <= id && id < StubGenBlobId::NUM_BLOBIDS, \"invalid blob id\");\n-  return _blob_names[id];\n+const char* StubRoutines::get_blob_name(BlobId id) {\n+  assert(StubInfo::is_stubgen(id), \"not a stubgen blob %s\", StubInfo::name(id));\n+  return StubInfo::name(id);\n@@ -110,3 +87,3 @@\n-const char* StubRoutines::get_stub_name(StubGenStubId id) {\n-  assert(0 <= id && id < StubGenStubId::NUM_STUBIDS, \"invalid stub id\");\n-  return _stub_names[id];\n+const char* StubRoutines::get_stub_name(StubId id) {\n+  assert(StubInfo::is_stubgen(id), \"not a stubgen stub %s\", StubInfo::name(id));\n+  return StubInfo::name(id);\n@@ -116,0 +93,2 @@\n+\/\/ translate a stub id to an associated blob id while checking that it\n+\/\/ is a stubgen stub\n@@ -117,62 +96,3 @@\n-\/\/ array holding start and end indices for stub ids associated with a\n-\/\/ given blob. Given a blob with id (StubGenBlobId) blob_id for any\n-\/\/ stub with id (StubGenStubId) stub_id declared within the blob:\n-\/\/ _blob_offsets[blob_id] <= stub_id < _blob_offsets[blob_id+1]\n-\n-static int _blob_limits[StubGenBlobId::NUM_BLOBIDS + 1];\n-\n-\/\/ macro used to compute blob limits\n-#define BLOB_COUNT(blob_name)                                           \\\n-  counter += StubGenStubId_ ## blob_name :: NUM_STUBIDS_ ## blob_name;  \\\n-  _blob_limits[++index] = counter;                                      \\\n-\n-\/\/ macro that checks stubs are associated with the correct blobs\n-#define STUB_VERIFY(blob_name, stub_name)                               \\\n-  localStubId = (int) (StubGenStubId_ ## blob_name :: blob_name ## _ ## stub_name ## _id); \\\n-  globalStubId = (int) (StubGenStubId:: stub_name ## _id);              \\\n-  blobId = (int) (StubGenBlobId:: blob_name ## _id);                    \\\n-  assert((globalStubId >= _blob_limits[blobId] &&                       \\\n-          globalStubId < _blob_limits[blobId+1]),                       \\\n-         \"stub \" # stub_name \" uses incorrect blob name \" # blob_name); \\\n-  assert(globalStubId == _blob_limits[blobId] + localStubId,            \\\n-         \"stub \" # stub_name \" id found at wrong offset!\");             \\\n-\n-bool verifyStubIds() {\n-  \/\/ first compute the blob limits\n-  int counter = 0;\n-  int index = 0;\n-  \/\/ populate offsets table with cumulative total of local enum counts\n-  STUBGEN_BLOBS_DO(BLOB_COUNT);\n-\n-  \/\/ ensure 1) global stub ids lie in the range of the associated blob\n-  \/\/ and 2) each blob's base + local stub id == global stub id\n-  int globalStubId, blobId, localStubId;\n-  STUBGEN_STUBS_DO(STUB_VERIFY);\n-  return true;\n-}\n-\n-#undef BLOB_COUNT\n-#undef STUB_VERIFY\n-\n-\/\/ ensure we verify the blob ids when this compile unit is first entered\n-bool _verified_stub_ids = verifyStubIds();\n-\n-\n-\/\/ macro used by stub to blob translation\n-\n-#define BLOB_CHECK_OFFSET(blob_name)                                \\\n-  if (id < _blob_limits[((int)blobId) + 1]) { return blobId; }      \\\n-  blobId = StubGenBlobId:: blob_name ## _id;                        \\\n-\n-\/\/ translate a global stub id to an associated blob id based on the\n-\/\/ computed blob limits\n-\n-StubGenBlobId StubRoutines::stub_to_blob(StubGenStubId stubId) {\n-  int id = (int)stubId;\n-  assert(id > ((int)StubGenStubId::NO_STUBID) && id < ((int)StubGenStubId::NUM_STUBIDS), \"stub id out of range!\");\n-  \/\/ start with no blob to catch stub id == -1\n-  StubGenBlobId blobId = StubGenBlobId::NO_BLOBID;\n-  STUBGEN_BLOBS_DO(BLOB_CHECK_OFFSET);\n-  \/\/ if we reach here we should have the last blob id\n-  assert(blobId == StubGenBlobId::NUM_BLOBIDS - 1, \"unexpected blob id\");\n-  return blobId;\n+BlobId StubRoutines::stub_to_blob(StubId id) {\n+  assert(StubInfo::is_stubgen(id), \"not a stubgen stub %s\", StubInfo::name(id));\n+  return StubInfo::blob(id);\n@@ -184,1 +104,1 @@\n-extern void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id); \/\/ only interface to generators\n+extern void StubGenerator_generate(CodeBuffer* code, BlobId blob_id); \/\/ only interface to generators\n@@ -215,1 +135,1 @@\n-static BufferBlob* initialize_stubs(StubGenBlobId blob_id,\n+static BufferBlob* initialize_stubs(BlobId blob_id,\n@@ -220,0 +140,1 @@\n+  assert(StubInfo::is_stubgen(blob_id), \"not a stubgen blob %s\", StubInfo::name(blob_id));\n@@ -255,1 +176,1 @@\n-      StubGenBlobId blob_id = StubGenBlobId:: STUB_ID_NAME(blob_name);  \\\n+      BlobId blob_id = BlobId:: JOIN3(stubgen, blob_name, id);          \\\n@@ -259,1 +180,1 @@\n-      const char* name = \"StubRoutines (\" # blob_name \"stubs)\";         \\\n+      const char* name = \"StubRoutines (\" # blob_name \" stubs)\";        \\\n@@ -274,3 +195,3 @@\n-void blob_name ## _stubs_init()  {                      \\\n-  StubRoutines::initialize_ ## blob_name ## _stubs();   \\\n-}\n+  void blob_name ## _stubs_init()  {                    \\\n+    StubRoutines::initialize_ ## blob_name ## _stubs(); \\\n+  }\n@@ -286,1 +207,1 @@\n- * point and have adeterminate ordered init.\n+ * point and have a determinate ordered init.\n@@ -304,1 +225,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":31,"deletions":111,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/stubDeclarations.hpp\"\n+#include \"runtime\/stubInfo.hpp\"\n@@ -154,45 +154,0 @@\n-\/\/ declare stubgen blob id enum\n-\n-#define BLOB_ENUM_DECLARE(blob_name) \\\n-  STUB_ID_NAME(blob_name),\n-\n-enum StubGenBlobId : int {\n-  NO_BLOBID = -1,\n-  STUBGEN_BLOBS_DO(BLOB_ENUM_DECLARE)\n-  NUM_BLOBIDS\n-};\n-\n-#undef BLOB_ENUM_DECLARE\n-\n-\/\/ declare blob local stub id enums\n-\n-#define BLOB_LOCAL_ENUM_START(blob_name)        \\\n-  enum StubGenStubId_ ## blob_name {            \\\n-    NO_STUBID_ ## blob_name = -1,\n-\n-#define BLOB_LOCAL_ENUM_END(blob_name)   \\\n-    NUM_STUBIDS_ ## blob_name            \\\n-  };\n-\n-#define BLOB_LOCAL_STUB_ENUM_DECLARE(blob_name, stub_name) \\\n-  blob_name ## _ ## stub_name ## _id,\n-\n-STUBGEN_BLOBS_STUBS_DO(BLOB_LOCAL_ENUM_START, BLOB_LOCAL_ENUM_END, BLOB_LOCAL_STUB_ENUM_DECLARE)\n-\n-#undef BLOB_LOCAL_ENUM_START\n-#undef BLOB_LOCAL_ENUM_END\n-#undef BLOB_LOCAL_STUB_ENUM_DECLARE\n-\n-\/\/ declare global stub id enum\n-\n-#define STUB_ENUM_DECLARE(blob_name, stub_name) \\\n-  STUB_ID_NAME(stub_name) ,\n-\n-enum StubGenStubId : int {\n-  NO_STUBID = -1,\n-  STUBGEN_STUBS_DO(STUB_ENUM_DECLARE)\n-  NUM_STUBIDS\n-};\n-\n-#undef STUB_ENUM_DECLARE\n-\n@@ -211,11 +166,2 @@\n-\/\/ declare blob and stub name storage and associated lookup methods\n-\n-private:\n-  static bool _inited_names;\n-  static const char* _blob_names[StubGenBlobId::NUM_BLOBIDS];\n-  static const char* _stub_names[StubGenStubId::NUM_STUBIDS];\n-\n-public:\n-  static bool init_names();\n-  static const char* get_blob_name(StubGenBlobId id);\n-  static const char* get_stub_name(StubGenStubId id);\n+  static const char* get_blob_name(BlobId id);\n+  static const char* get_stub_name(StubId id);\n@@ -332,2 +278,1 @@\n-  \/\/ provide a translation from stub id to its associated blob id\n-  static StubGenBlobId stub_to_blob(StubGenStubId stubId);\n+  static BlobId stub_to_blob(StubId id);\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":4,"deletions":59,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+#include \"utilities\/fastHash.hpp\"\n@@ -928,1 +929,1 @@\n-static intptr_t get_next_hash(Thread* current, oop obj) {\n+intptr_t ObjectSynchronizer::get_next_hash(Thread* current, oop obj) {\n@@ -947,1 +948,1 @@\n-  } else {\n+  } else if (hashCode == 5) {\n@@ -960,0 +961,10 @@\n+  } else {\n+    assert(UseCompactObjectHeaders, \"Only with compact i-hash\");\n+#ifdef _LP64\n+    uint64_t val = cast_from_oop<uint64_t>(obj);\n+    uint32_t hash = FastHash::get_hash32((uint32_t)val, (uint32_t)(val >> 32));\n+#else\n+    uint32_t val = cast_from_oop<uint32_t>(obj);\n+    uint32_t hash = FastHash::get_hash32(val, UCONST64(0xAAAAAAAA));\n+#endif\n+    value= static_cast<intptr_t>(hash);\n@@ -963,2 +974,2 @@\n-  if (value == 0) value = 0xBAD;\n-  assert(value != markWord::no_hash, \"invariant\");\n+  if (hashCode != 6 && value == 0) value = 0xBAD;\n+  assert(value != markWord::no_hash || hashCode == 6, \"invariant\");\n@@ -973,4 +984,23 @@\n-    intptr_t hash = mark.hash();\n-    if (hash != 0) {\n-      return hash;\n-    }\n+    if (UseCompactObjectHeaders) {\n+      if (mark.is_hashed()) {\n+        return LightweightSynchronizer::get_hash(mark, obj);\n+      }\n+      intptr_t hash = ObjectSynchronizer::get_next_hash(current, obj);  \/\/ get a new hash\n+      markWord new_mark;\n+      if (mark.is_not_hashed_expanded()) {\n+        new_mark = mark.set_hashed_expanded();\n+        int offset = mark.klass()->hash_offset_in_bytes(obj, mark);\n+        obj->int_field_put(offset, (jint) hash);\n+      } else {\n+        new_mark = mark.set_hashed_not_expanded();\n+      }\n+      markWord old_mark = obj->cas_set_mark(new_mark, mark);\n+      if (old_mark == mark) {\n+        return hash;\n+      }\n+      mark = old_mark;\n+    } else {\n+      intptr_t hash = mark.hash();\n+      if (hash != 0) {\n+        return hash;\n+      }\n@@ -978,3 +1008,3 @@\n-    hash = get_next_hash(current, obj);\n-    const markWord old_mark = mark;\n-    const markWord new_mark = old_mark.copy_set_hash(hash);\n+      hash = ObjectSynchronizer::get_next_hash(current, obj);\n+      const markWord old_mark = mark;\n+      const markWord new_mark = old_mark.copy_set_hash(hash);\n@@ -982,3 +1012,4 @@\n-    mark = obj->cas_set_mark(new_mark, old_mark);\n-    if (old_mark == mark) {\n-      return hash;\n+      mark = obj->cas_set_mark(new_mark, old_mark);\n+      if (old_mark == mark) {\n+        return hash;\n+      }\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":45,"deletions":14,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -212,0 +212,1 @@\n+  nonstatic_field(InstanceKlass,               _hash_offset,                                  int)                                    \\\n@@ -1822,0 +1823,1 @@\n+  declare_constant(markWord::hashctrl_bits)                               \\\n@@ -1826,0 +1828,1 @@\n+  declare_constant(markWord::hashctrl_shift)                              \\\n@@ -1834,0 +1837,4 @@\n+  declare_constant(markWord::hashctrl_mask)                               \\\n+  declare_constant(markWord::hashctrl_mask_in_place)                      \\\n+  declare_constant(markWord::hashctrl_hashed_mask_in_place)               \\\n+  declare_constant(markWord::hashctrl_expanded_mask_in_place)             \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/vmThreadCpuTimeScope.inline.hpp\"\n@@ -278,1 +279,1 @@\n-                     (char *) op->name(), strlen(op->name()),\n+                     (char*) op->name(), strlen(op->name()),\n@@ -282,0 +283,1 @@\n+    VMThreadCPUTimeScope CPUTimeScope(this, op->is_gc_operation());\n@@ -288,1 +290,1 @@\n-                     (char *) op->name(), strlen(op->name()),\n+                     (char*) op->name(), strlen(op->name()),\n@@ -291,7 +293,0 @@\n-\n-  if (UsePerfData && os::is_thread_cpu_time_supported()) {\n-    assert(Thread::current() == this, \"Must be called from VM thread\");\n-    \/\/ Update vm_thread_cpu_time after each VM operation.\n-    ThreadTotalCPUTimeClosure tttc(CPUTimeGroups::CPUTimeType::vm);\n-    tttc.do_thread(this);\n-  }\n","filename":"src\/hotspot\/share\/runtime\/vmThread.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import java.util.ArrayList;\n+import java.util.Collections;\n@@ -32,0 +34,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -400,10 +403,0 @@\n-    private String readAllCharsAsString() throws IOException {\n-        StringBuilder result = new StringBuilder();\n-        char[] cbuf = new char[TRANSFER_BUFFER_SIZE];\n-        int nread;\n-        while ((nread = read(cbuf, 0, cbuf.length)) != -1) {\n-            result.append(cbuf, 0, nread);\n-        }\n-        return result.toString();\n-    }\n-\n@@ -460,1 +453,51 @@\n-        return readAllCharsAsString().lines().toList();\n+        List<String> lines = new ArrayList<>();\n+        char[] cb = new char[1024];\n+\n+        int start = 0;\n+        int pos = 0;\n+        int limit = 0;\n+        boolean skipLF = false;\n+        int n;\n+        while ((n = read(cb, pos, cb.length - pos)) != -1) {\n+            limit = pos + n;\n+            while (pos < limit) {\n+                if (skipLF) {\n+                    if (cb[pos] == '\\n') {\n+                        pos++;\n+                        start++;\n+                    }\n+                    skipLF = false;\n+                }\n+                while (pos < limit) {\n+                    char c = cb[pos++];\n+                    if (c == '\\n' || c == '\\r') {\n+                        lines.add(new String(cb, start, pos - 1 - start));\n+                        skipLF = (c == '\\r');\n+                        start = pos;\n+                        break;\n+                    }\n+                }\n+                if (pos == limit) {\n+                    int len = limit - start;\n+                    if (len >= cb.length\/2) {\n+                        \/\/ allocate larger buffer and copy chars to beginning\n+                        int newLength = ArraysSupport.newLength(cb.length,\n+                                            TRANSFER_BUFFER_SIZE, cb.length);\n+                        char[] tmp = new char[newLength];\n+                        System.arraycopy(cb, start, tmp, 0, len);\n+                        cb = tmp;\n+                    } else if (start != 0 && len != 0) {\n+                        \/\/ move fragment to beginning of buffer\n+                        System.arraycopy(cb, start, cb, 0, len);\n+                    }\n+                    pos = limit = len;\n+                    start = 0;\n+                    break;\n+                }\n+            }\n+        }\n+        \/\/ add a string if EOS terminates the last line\n+        if (limit > start)\n+            lines.add(new String(cb, start, limit - start));\n+\n+        return Collections.unmodifiableList(lines);\n@@ -502,1 +545,7 @@\n-        return readAllCharsAsString();\n+        StringBuilder result = new StringBuilder();\n+        char[] cbuf = new char[TRANSFER_BUFFER_SIZE];\n+        int nread;\n+        while ((nread = read(cbuf, 0, cbuf.length)) != -1) {\n+            result.append(cbuf, 0, nread);\n+        }\n+        return result.toString();\n","filename":"src\/java.base\/share\/classes\/java\/io\/Reader.java","additions":61,"deletions":12,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -120,5 +120,3 @@\n- * U+0000 to U+10FFFF, known as <em>Unicode scalar value<\/em>.\n- * (Refer to the <a\n- * href=\"http:\/\/www.unicode.org\/reports\/tr27\/#notation\"><i>\n- * definition<\/i><\/a> of the U+<i>n<\/i> notation in the Unicode\n- * Standard.)\n+ * U+0000 to U+10FFFF, known as\n+ * <em><a href=\"https:\/\/www.unicode.org\/glossary\/#unicode_scalar_value\">\n+ * Unicode scalar value<\/a><\/em>.\n@@ -176,1 +174,1 @@\n- * @spec https:\/\/www.unicode.org\/reports\/tr27 Unicode 3.1.0\n+ * @spec https:\/\/www.unicode.org\/reports\/tr44 Unicode Character Database\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Character.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * ProcessBuilder.start and Runtime.exec.\n+ * {@code ProcessBuilder.start} and {@code Runtime.exec}.\n@@ -81,4 +81,0 @@\n- * <p>The process is not killed when there are no more references to\n- * the {@code Process} object, but rather the process\n- * continues executing asynchronously.\n- *\n@@ -101,0 +97,43 @@\n+ * <h2>Resource Usage<\/h2>\n+ * {@linkplain ProcessBuilder#start() Starting a process} uses resources in both the invoking process and the invoked\n+ * process and for the communication streams between them.\n+ * The resources to control the process and for communication between the processes are retained\n+ * until there are no longer any references to the Process or the input, error, and output streams\n+ * or readers, or they have been closed.\n+ *\n+ * <p>The process is not killed when there are no more references to the {@code Process} object,\n+ * but rather the process continues executing asynchronously.\n+ * The process implementation closes file descriptors and handles for streams\n+ * that are no longer referenced to prevent leaking operating system resources.\n+ * Processes that have terminated or been terminated are monitored and their resources released.\n+ *\n+ * <p>Streams should be {@code closed} when they are no longer needed, to avoid delaying\n+ * releasing the operating system resources.\n+ * {@code Try-with-resources} can be used to open and close the streams.\n+ * <p>For example, to capture the output of a program known to produce some output and then exit:\n+ * {@snippet lang = \"java\" :\n+ * List<String> capture(List<String> args) throws Exception {\n+ *     ProcessBuilder pb = new ProcessBuilder(args);\n+ *     Process process = pb.start();\n+ *     try (BufferedReader in = process.inputReader()) {\n+ *         List<String> captured = in.readAllLines();\n+ *         int status = process.waitFor();\n+ *         if (status != 0) {\n+ *             throw new RuntimeException(\"Process %d: %s failed with %d\"\n+ *                         .formatted(process.pid(), args, status));\n+ *         }\n+ *         return captured;\n+ *     }\n+ * }\n+ * }\n+ * <p>Stream resources (file descriptor or handle) are always paired; one in the invoking process\n+ * and the other end of that connection in the invoked process.\n+ * Closing a stream at either end terminates communication but does not have any direct effect\n+ * on the other Process. The closing of the stream typically results in the other process exiting.\n+ *\n+ * <p> {@linkplain #destroy Destroying a process} signals the operating system to terminate the process.\n+ * It is up to the operating system to clean up and release the resources of that process.\n+ * Typically, file descriptors and handles are closed. When they are closed, any connections to\n+ * other processes are terminated and file descriptors and handles in the invoking process signal\n+ * end-of-file or closed. Usually, that is seen as an end-of-file or an exception.\n+ *\n@@ -130,0 +169,3 @@\n+     * <p>The output stream should be {@linkplain OutputStream#close closed}\n+     * when it is no longer needed.\n+     *\n@@ -162,0 +204,3 @@\n+     * <p>The input stream should be {@linkplain InputStream#close closed}\n+     * when it is no longer needed.\n+     *\n@@ -163,2 +208,5 @@\n-     * Use {@link #getInputStream()} and {@link #inputReader()} with extreme care.\n-     * The {@code BufferedReader} may have buffered input from the input stream.\n+     * Use either this method or an {@linkplain #inputReader() input reader}\n+     * but not both on the same {@code Process}.\n+     * The input reader consumes and buffers bytes from the input stream.\n+     * Bytes read from the input stream would not be seen by the reader and\n+     * buffer contents are unpredictable.\n@@ -188,0 +236,3 @@\n+     * <p>The error stream should be {@linkplain InputStream#close closed}\n+     * when it is no longer needed.\n+     *\n@@ -189,2 +240,5 @@\n-     * Use {@link #getErrorStream()} and {@link #errorReader()} with extreme care.\n-     * The {@code BufferedReader} may have buffered input from the error stream.\n+     * Use either this method or an {@linkplain #errorReader() error reader}\n+     * but not both on the same {@code Process}.\n+     * The error reader consumes and buffers bytes from the error stream.\n+     * Bytes read from the error stream would not be seen by the reader and the\n+     * buffer contents are unpredictable.\n@@ -211,0 +265,10 @@\n+     * <p>The reader should be {@linkplain BufferedReader#close closed}\n+     * when it is no longer needed.\n+     *\n+     * @apiNote\n+     * Use either this method or the {@linkplain #getInputStream input stream}\n+     * but not both on the same {@code Process}.\n+     * The input reader consumes and buffers bytes from the input stream.\n+     * Bytes read from the input stream would not be seen by the reader and the\n+     * buffer contents are unpredictable.\n+     *\n@@ -241,0 +305,3 @@\n+     * <p>The reader should be {@linkplain BufferedReader#close closed}\n+     * when it is no longer needed.\n+     *\n@@ -248,3 +315,5 @@\n-     * Using both {@link #getInputStream} and {@link #inputReader(Charset)} has\n-     * unpredictable behavior since the buffered reader reads ahead from the\n-     * input stream.\n+     * Use either this method or the {@linkplain #getInputStream input stream}\n+     * but not both on the same {@code Process}.\n+     * The input reader consumes and buffers bytes from the input stream.\n+     * Bytes read from the input stream would not be seen by the reader and the\n+     * buffer contents are unpredictable.\n@@ -286,0 +355,10 @@\n+     * <p>The error reader should be {@linkplain BufferedReader#close closed}\n+     * when it is no longer needed.\n+     *\n+     * @apiNote\n+     * Use either this method or the {@linkplain #getErrorStream error stream}\n+     * but not both on the same {@code Process}.\n+     * The error reader consumes and buffers bytes from the error stream.\n+     * Bytes read from the error stream would not be seen by the reader and the\n+     * buffer contents are unpredictable.\n+     *\n@@ -317,0 +396,3 @@\n+     * <p>The error reader should be {@linkplain BufferedReader#close closed}\n+     * when it is no longer needed.\n+     *\n@@ -318,3 +400,5 @@\n-     * Using both {@link #getErrorStream} and {@link #errorReader(Charset)} has\n-     * unpredictable behavior since the buffered reader reads ahead from the\n-     * error stream.\n+     * Use either this method or the {@linkplain #getErrorStream error stream}\n+     * but not both on the same {@code Process}.\n+     * The error reader consumes and buffers bytes from the error stream.\n+     * Bytes read from the error stream would not be seen by the reader and the\n+     * buffer contents are unpredictable.\n@@ -349,1 +433,1 @@\n-     * Writes text to a character-output stream, buffering characters so as to provide\n+     * Writes text to a character-output stream, buffering characters to provide\n@@ -357,0 +441,3 @@\n+     * <p>The output writer should be {@linkplain BufferedWriter#close closed}\n+     * when it is no longer needed.\n+     *\n@@ -368,1 +455,1 @@\n-     * Writes text to a character-output stream, buffering characters so as to provide\n+     * Writes text to a character-output stream, buffering characters to provide\n@@ -386,0 +473,3 @@\n+     * <p>The output writer should be {@linkplain BufferedWriter#close closed}\n+     * when it is no longer needed.\n+     *\n@@ -677,5 +767,6 @@\n-     * <pre> {@code   Process p = new ProcessBuilder(\"cmp\", \"f1\", \"f2\").start();\n-     *    Future<Boolean> identical = p.onExit().thenApply(p1 -> p1.exitValue() == 0);\n-     *    ...\n-     *    if (identical.get()) { ... }\n-     * }<\/pre>\n+     * {@snippet lang = \"java\" :\n+     *     Process p = new ProcessBuilder(\"cmp\", \"f1\", \"f2\").start();\n+     *     Future<Boolean> identical = p.onExit().thenApply(p1 -> p1.exitValue() == 0);\n+     *     ...\n+     *     if (identical.get()) { ... }\n+     * }\n@@ -698,1 +789,1 @@\n-     * <pre>{@code\n+     * {@snippet lang = \"java\" :\n@@ -702,1 +793,1 @@\n-     * }<\/pre>\n+     * }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Process.java","additions":116,"deletions":25,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,1 +153,2 @@\n- * <pre> {@code\n+ * {@snippet lang = \"java\" :\n+\n@@ -155,1 +156,2 @@\n- * }<\/pre>\n+ * }\n+\n@@ -161,16 +163,17 @@\n- * <pre> {@code\n- * ProcessBuilder pb =\n- *   new ProcessBuilder(\"myCommand\", \"myArg1\", \"myArg2\");\n- * Map<String, String> env = pb.environment();\n- * env.put(\"VAR1\", \"myValue\");\n- * env.remove(\"OTHERVAR\");\n- * env.put(\"VAR2\", env.get(\"VAR1\") + \"suffix\");\n- * pb.directory(new File(\"myDir\"));\n- * File log = new File(\"log\");\n- * pb.redirectErrorStream(true);\n- * pb.redirectOutput(Redirect.appendTo(log));\n- * Process p = pb.start();\n- * assert pb.redirectInput() == Redirect.PIPE;\n- * assert pb.redirectOutput().file() == log;\n- * assert p.getInputStream().read() == -1;\n- * }<\/pre>\n+ * {@snippet lang = \"java\":\n+ *     ProcessBuilder pb = new ProcessBuilder(\"myCommand\", \"myArg1\", \"myArg2\");\n+ *     Map<String, String> env = pb.environment();\n+ *     env.put(\"VAR1\", \"myValue\");\n+ *     env.remove(\"OTHERVAR\");\n+ *     env.put(\"VAR2\", env.get(\"VAR1\") + \"suffix\");\n+ *\n+ *     pb.directory(new File(\"myDir\"));\n+ *     File log = new File(\"log\");\n+ *     pb.redirectErrorStream(true);\n+ *     pb.redirectOutput(Redirect.appendTo(log));\n+ *\n+ *     Process p = pb.start();\n+ *     assert pb.redirectInput() == Redirect.PIPE;\n+ *     assert pb.redirectOutput().file() == log;\n+ *     assert p.getInputStream().read() == -1;\n+ * }\n@@ -509,4 +512,4 @@\n-         *  <pre> {@code\n-         * Redirect.PIPE.file() == null &&\n-         * Redirect.PIPE.type() == Redirect.Type.PIPE\n-         * }<\/pre>\n+         * {@snippet lang = \"java\" :\n+         *     Redirect.PIPE.file() == null &&\n+         *     Redirect.PIPE.type() == Redirect.Type.PIPE\n+         * }\n@@ -524,4 +527,4 @@\n-         *  <pre> {@code\n-         * Redirect.INHERIT.file() == null &&\n-         * Redirect.INHERIT.type() == Redirect.Type.INHERIT\n-         * }<\/pre>\n+         * {@snippet lang = \"java\" :\n+         *     Redirect.INHERIT.file() == null &&\n+         *     Redirect.INHERIT.type() == Redirect.Type.INHERIT\n+         * }\n@@ -540,5 +543,4 @@\n-         * <pre> {@code\n-         * Redirect.DISCARD.file() is the filename appropriate for the operating system\n-         * and may be null &&\n-         * Redirect.DISCARD.type() == Redirect.Type.WRITE\n-         * }<\/pre>\n+         * {@snippet lang = \"java\" :\n+         *     Redirect.DISCARD.file() != null && \/\/ is the filename appropriate for the operating system\n+         *     Redirect.DISCARD.type() == Redirect.Type.WRITE;\n+         * }\n@@ -575,4 +577,4 @@\n-         *  <pre> {@code\n-         * Redirect.from(file).file() == file &&\n-         * Redirect.from(file).type() == Redirect.Type.READ\n-         * }<\/pre>\n+         * {@snippet lang = \"java\" :\n+         *     Redirect.from(file).file() == file &&\n+         *     Redirect.from(file).type() == Redirect.Type.READ\n+         * }\n@@ -601,4 +603,4 @@\n-         *  <pre> {@code\n-         * Redirect.to(file).file() == file &&\n-         * Redirect.to(file).type() == Redirect.Type.WRITE\n-         * }<\/pre>\n+         * {@snippet lang = \"java\" :\n+         *     Redirect.to(file).file() == file &&\n+         *     Redirect.to(file).type() == Redirect.Type.WRITE\n+         * }\n@@ -631,4 +633,4 @@\n-         *  <pre> {@code\n-         * Redirect.appendTo(file).file() == file &&\n-         * Redirect.appendTo(file).type() == Redirect.Type.APPEND\n-         * }<\/pre>\n+         * {@snippet lang = \"java\" :\n+         *     Redirect.appendTo(file).file() == file &&\n+         *     Redirect.appendTo(file).type() == Redirect.Type.APPEND\n+         * }\n@@ -917,3 +919,3 @@\n-     *  <pre> {@code\n-     * pb.inheritIO()\n-     * }<\/pre>\n+     * {@snippet lang = \"java\" :\n+     *      pb.inheritIO()\n+     * }\n@@ -921,5 +923,5 @@\n-     *  <pre> {@code\n-     * pb.redirectInput(Redirect.INHERIT)\n-     *   .redirectOutput(Redirect.INHERIT)\n-     *   .redirectError(Redirect.INHERIT)\n-     * }<\/pre>\n+     * {@snippet lang = \"java\" :\n+     *      pb.redirectInput(Redirect.INHERIT)\n+     *          .redirectOutput(Redirect.INHERIT)\n+     *          .redirectError(Redirect.INHERIT)\n+     * }\n@@ -1179,3 +1181,3 @@\n-     * <pre>{@code\n-     * String directory = \"\/home\/duke\/src\";\n-     * ProcessBuilder[] builders = {\n+     * {@snippet lang = \"java\" :\n+     *     String directory = \"\/home\/duke\/src\";\n+     *     ProcessBuilder[] builders = {\n@@ -1186,4 +1188,3 @@\n-     * List<Process> processes = ProcessBuilder.startPipeline(\n-     *         Arrays.asList(builders));\n-     * Process last = processes.get(processes.size()-1);\n-     * try (InputStream is = last.getInputStream();\n+     *     List<Process> processes = ProcessBuilder.startPipeline( Arrays.asList(builders));\n+     *     Process last = processes.get(processes.size() - 1);\n+     *     try (InputStream is = last.getInputStream();\n@@ -1192,1 +1193,2 @@\n-     *     long count = r.lines().count();\n+     *         long count = r.lines().count();\n+     *     }\n@@ -1194,1 +1196,0 @@\n-     * }<\/pre>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ProcessBuilder.java","additions":62,"deletions":61,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.ref.Reference;\n@@ -31,2 +32,2 @@\n-import java.lang.ref.Reference;\n-import java.util.concurrent.StructuredTaskScope;\n+import java.util.concurrent.StructuredTaskScope;\n+import java.util.function.IntSupplier;\n@@ -37,0 +38,1 @@\n+import jdk.internal.vm.ScopedValueContainer;\n@@ -39,1 +41,1 @@\n-import jdk.internal.vm.ScopedValueContainer;\n+import jdk.internal.vm.annotation.Stable;\n@@ -247,0 +249,3 @@\n+    @Stable\n+    static IntSupplier hashGenerator;\n+\n@@ -529,1 +534,2 @@\n-        this.hash = generateKey();\n+        IntSupplier nextHash = hashGenerator;\n+        this.hash = nextHash != null ? nextHash.getAsInt() : generateKey();\n@@ -555,1 +561,1 @@\n-            int n = (hash & Cache.SLOT_MASK) * 2;\n+            int n = (hash & Cache.Constants.SLOT_MASK) * 2;\n@@ -559,1 +565,1 @@\n-            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n+            n = ((hash >>> Cache.INDEX_BITS) & Cache.Constants.SLOT_MASK) * 2;\n@@ -583,1 +589,1 @@\n-            int n = (hash & Cache.SLOT_MASK) * 2;\n+            int n = (hash & Cache.Constants.SLOT_MASK) * 2;\n@@ -587,1 +593,1 @@\n-            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n+            n = ((hash >>> Cache.INDEX_BITS) & Cache.Constants.SLOT_MASK) * 2;\n@@ -691,4 +697,4 @@\n-    \/\/ A Marsaglia xor-shift generator used to generate hashes. This one has full period, so\n-    \/\/ it generates 2**32 - 1 hashes before it repeats. We're going to use the lowest n bits\n-    \/\/ and the next n bits as cache indexes, so we make sure that those indexes map\n-    \/\/ to different slots in the cache.\n+    \/\/ A Marsaglia xor-shift generator used to generate hashes. This one has\n+    \/\/ full period, so it generates 2**32 - 1 hashes before it repeats. We're\n+    \/\/ going to use the lowest n bits and the next n bits as cache indexes, so\n+    \/\/ we make sure that those indexes map to different slots in the cache.\n@@ -701,1 +707,1 @@\n-        } while (Cache.primarySlot(x) == Cache.secondarySlot(x));\n+        } while (((Cache.primaryIndex(x) ^ Cache.secondaryIndex(x)) & 1) == 0);\n@@ -712,1 +718,1 @@\n-        return (1 << Cache.primaryIndex(this)) | (1 << (Cache.secondaryIndex(this) + Cache.TABLE_SIZE));\n+        return (1 << Cache.primaryIndex(hash)) | (1 << (Cache.secondaryIndex(hash) + Cache.TABLE_SIZE));\n@@ -730,18 +736,63 @@\n-        \/\/ The number of elements in the cache array, and a bit mask used to\n-        \/\/ select elements from it.\n-        private static final int CACHE_TABLE_SIZE, SLOT_MASK;\n-        \/\/ The largest cache we allow. Must be a power of 2 and greater than\n-        \/\/ or equal to 2.\n-        private static final int MAX_CACHE_SIZE = 16;\n-\n-        static {\n-            final String propertyName = \"java.lang.ScopedValue.cacheSize\";\n-            var sizeString = System.getProperty(propertyName, \"16\");\n-            var cacheSize = Integer.valueOf(sizeString);\n-            if (cacheSize < 2 || cacheSize > MAX_CACHE_SIZE) {\n-                cacheSize = MAX_CACHE_SIZE;\n-                System.err.println(propertyName + \" is out of range: is \" + sizeString);\n-            }\n-            if ((cacheSize & (cacheSize - 1)) != 0) {  \/\/ a power of 2\n-                cacheSize = MAX_CACHE_SIZE;\n-                System.err.println(propertyName + \" must be an integer power of 2: is \" + sizeString);\n+\n+        \/\/ This class serves to defer initialization of some values until they\n+        \/\/ are needed. In particular, we must not invoke System.getProperty\n+        \/\/ early in the JDK boot process, because that leads to a circular class\n+        \/\/ initialization dependency.\n+        \/\/\n+        \/\/ In more detail:\n+        \/\/\n+        \/\/  The size of the cache depends on System.getProperty. Generating the\n+        \/\/  hash of an instance of ScopedValue depends on ThreadLocalRandom.\n+        \/\/\n+        \/\/  Invoking either of these early in the JDK boot process will cause\n+        \/\/  startup to fail with an unrecoverable circular dependency.\n+        \/\/\n+        \/\/ To break these cycles we allow scoped values to be created (but not\n+        \/\/ used) without invoking either System.getProperty or\n+        \/\/ ThreadLocalRandom. To do this we defer querying System.getProperty\n+        \/\/ until the first reference to CACHE_TABLE_SIZE, and we define a local\n+        \/\/ hash generator which is used until CACHE_TABLE_SIZE is initialized.\n+\n+        private static class Constants {\n+            \/\/ The number of elements in the cache array, and a bit mask used to\n+            \/\/ select elements from it.\n+            private static final int CACHE_TABLE_SIZE, SLOT_MASK;\n+            \/\/ The largest cache we allow. Must be a power of 2 and greater than\n+            \/\/ or equal to 2.\n+            private static final int MAX_CACHE_SIZE = 16;\n+\n+            private static final JavaUtilConcurrentTLRAccess THREAD_LOCAL_RANDOM_ACCESS\n+                = SharedSecrets.getJavaUtilConcurrentTLRAccess();\n+\n+            static {\n+                final String propertyName = \"java.lang.ScopedValue.cacheSize\";\n+                var sizeString = System.getProperty(propertyName, \"16\");\n+                var cacheSize = Integer.valueOf(sizeString);\n+                if (cacheSize < 2 || cacheSize > MAX_CACHE_SIZE) {\n+                    cacheSize = MAX_CACHE_SIZE;\n+                    System.err.println(propertyName + \" is out of range: is \" + sizeString);\n+                }\n+                if ((cacheSize & (cacheSize - 1)) != 0) {  \/\/ a power of 2\n+                    cacheSize = MAX_CACHE_SIZE;\n+                    System.err.println(propertyName + \" must be an integer power of 2: is \" + sizeString);\n+                }\n+                CACHE_TABLE_SIZE = cacheSize;\n+                SLOT_MASK = cacheSize - 1;\n+\n+                \/\/ hashGenerator is set here (in class Constants rather than\n+                \/\/ in global scope) in order not to initialize\n+                \/\/ j.u.c.ThreadLocalRandom early in the JDK boot process.\n+                \/\/ After this static initialization, new instances of\n+                \/\/ ScopedValue will be initialized by a thread-local random\n+                \/\/ generator.\n+                hashGenerator = new IntSupplier() {\n+                    @Override\n+                    public int getAsInt() {\n+                        int x;\n+                        do {\n+                            x = THREAD_LOCAL_RANDOM_ACCESS\n+                                .nextSecondaryThreadLocalRandomSeed();\n+                        } while (Cache.primarySlot(x) == Cache.secondarySlot(x));\n+                        return x;\n+                    }\n+                };\n@@ -749,2 +800,0 @@\n-            CACHE_TABLE_SIZE = cacheSize;\n-            SLOT_MASK = cacheSize - 1;\n@@ -753,2 +802,2 @@\n-        static int primaryIndex(ScopedValue<?> key) {\n-            return key.hash & TABLE_MASK;\n+        static int primaryIndex(int hash) {\n+            return hash & Cache.TABLE_MASK;\n@@ -757,2 +806,2 @@\n-        static int secondaryIndex(ScopedValue<?> key) {\n-            return (key.hash >> INDEX_BITS) & TABLE_MASK;\n+        static int secondaryIndex(int hash) {\n+            return (hash >> INDEX_BITS) & Cache.TABLE_MASK;\n@@ -762,1 +811,1 @@\n-            return key.hashCode() & SLOT_MASK;\n+            return key.hashCode() & Constants.SLOT_MASK;\n@@ -766,1 +815,1 @@\n-            return (key.hash >> INDEX_BITS) & SLOT_MASK;\n+            return (key.hash >> INDEX_BITS) & Constants.SLOT_MASK;\n@@ -770,1 +819,1 @@\n-            return hash & SLOT_MASK;\n+            return hash & Constants.SLOT_MASK;\n@@ -774,1 +823,1 @@\n-            return (hash >> INDEX_BITS) & SLOT_MASK;\n+            return (hash >> INDEX_BITS) & Constants.SLOT_MASK;\n@@ -780,1 +829,1 @@\n-                theCache = new Object[CACHE_TABLE_SIZE * 2];\n+                theCache = new Object[Constants.CACHE_TABLE_SIZE * 2];\n@@ -816,3 +865,0 @@\n-        private static final JavaUtilConcurrentTLRAccess THREAD_LOCAL_RANDOM_ACCESS\n-                = SharedSecrets.getJavaUtilConcurrentTLRAccess();\n-\n@@ -824,1 +870,1 @@\n-            int r = THREAD_LOCAL_RANDOM_ACCESS.nextSecondaryThreadLocalRandomSeed();\n+            int r = Constants.THREAD_LOCAL_RANDOM_ACCESS.nextSecondaryThreadLocalRandomSeed();\n@@ -830,1 +876,1 @@\n-            toClearBits = (toClearBits >>> TABLE_SIZE) | (toClearBits & PRIMARY_MASK);\n+            toClearBits = ((toClearBits >>> Cache.TABLE_SIZE) | toClearBits) & PRIMARY_MASK;\n@@ -835,1 +881,1 @@\n-                    setKeyAndObjectAt(objects, index & SLOT_MASK, null, null);\n+                    setKeyAndObjectAt(objects, index & Constants.SLOT_MASK, null, null);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ScopedValue.java","additions":95,"deletions":49,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -135,0 +135,1 @@\n+     * @throws IndexOutOfBoundsException if the parameter index is out of bounds\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -33,1 +32,0 @@\n-import jdk.internal.ref.Cleaner;\n@@ -202,5 +200,0 @@\n-            \/\/ pre-load and initialize Cleaner class so that we don't\n-            \/\/ get into trouble later in the run loop if there's\n-            \/\/ memory shortage while loading\/initializing it lazily.\n-            Unsafe.getUnsafe().ensureClassInitialized(Cleaner.class);\n-\n@@ -256,12 +249,1 @@\n-\n-            if (ref instanceof Cleaner) {\n-                ((Cleaner)ref).clean();\n-                \/\/ Notify any waiters that progress has been made.\n-                \/\/ This improves latency for nio.Bits waiters, which\n-                \/\/ are the only important ones.\n-                synchronized (processPendingLock) {\n-                    processPendingLock.notifyAll();\n-                }\n-            } else {\n-                ref.enqueueFromPending();\n-            }\n+            ref.enqueueFromPending();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+    private static final long INITIAL_SLEEP = 1;\n@@ -106,0 +107,6 @@\n+    private static final Object RESERVE_SLOWPATH_LOCK = new Object();\n+\n+    \/\/ Token for detecting whether some other thread has done a GC since the\n+    \/\/ last time the checking thread went around the retry-with-GC loop.\n+    private static int RESERVE_GC_EPOCH = 0; \/\/ Never negative.\n+\n@@ -121,1 +128,2 @@\n-        final JavaLangRefAccess jlra = SharedSecrets.getJavaLangRefAccess();\n+        \/\/ Don't completely discard interruptions.  Instead, record them and\n+        \/\/ reapply when we're done here (whether successfully or OOME).\n@@ -124,6 +132,26 @@\n-\n-            \/\/ Retry allocation until success or there are no more\n-            \/\/ references (including Cleaners that might free direct\n-            \/\/ buffer memory) to process and allocation still fails.\n-            boolean refprocActive;\n-            do {\n+            \/\/ Keep trying to reserve until either succeed or there is no\n+            \/\/ further cleaning available from prior GCs. If the latter then\n+            \/\/ GC to hopefully find more cleaning to do. Once a thread GCs it\n+            \/\/ drops to the later retry with backoff loop.\n+            for (int cleanedEpoch = -1; true; ) {\n+                synchronized (RESERVE_SLOWPATH_LOCK) {\n+                    \/\/ Test if cleaning for prior GCs (from here) is complete.\n+                    \/\/ If so, GC to produce more cleaning work, and change\n+                    \/\/ the token to inform other threads that there may be\n+                    \/\/ more cleaning work to do.  This is done under the lock\n+                    \/\/ to close a race.  We could have multiple threads pass\n+                    \/\/ the test \"simultaneously\", resulting in back-to-back\n+                    \/\/ GCs.  For a STW GC the window is small, but for a\n+                    \/\/ concurrent GC it's quite large. If a thread were to\n+                    \/\/ somehow be stuck trying to take the lock while enough\n+                    \/\/ other threads succeeded for the epoch to wrap, it just\n+                    \/\/ does an excess GC.\n+                    if (RESERVE_GC_EPOCH == cleanedEpoch) {\n+                        \/\/ Increment with overflow to 0, so the value can\n+                        \/\/ never equal the initial\/reset cleanedEpoch value.\n+                        RESERVE_GC_EPOCH = Integer.max(0, RESERVE_GC_EPOCH + 1);\n+                        System.gc();\n+                        break;\n+                    }\n+                    cleanedEpoch = RESERVE_GC_EPOCH;\n+                }\n@@ -131,1 +159,3 @@\n-                    refprocActive = jlra.waitForReferenceProcessing();\n+                    if (tryReserveOrClean(size, cap)) {\n+                        return;\n+                    }\n@@ -133,2 +163,1 @@\n-                    \/\/ Defer interrupts and keep trying.\n-                    refprocActive = true;\n+                    cleanedEpoch = -1; \/\/ Reset when incomplete.\n@@ -137,7 +166,1 @@\n-                if (tryReserveMemory(size, cap)) {\n-                    return;\n-                }\n-            } while (refprocActive);\n-\n-            \/\/ trigger VM's Reference processing\n-            System.gc();\n+            }\n@@ -154,9 +177,1 @@\n-            long sleepTime = 1;\n-            int sleeps = 0;\n-            while (true) {\n-                if (tryReserveMemory(size, cap)) {\n-                    return;\n-                }\n-                if (sleeps >= MAX_SLEEPS) {\n-                    break;\n-                }\n+            for (int sleeps = 0; true; ) {\n@@ -164,4 +179,10 @@\n-                    if (!jlra.waitForReferenceProcessing()) {\n-                        Thread.sleep(sleepTime);\n-                        sleepTime <<= 1;\n-                        sleeps++;\n+                    if (tryReserveOrClean(size, cap)) {\n+                        return;\n+                    } else if (sleeps < MAX_SLEEPS) {\n+                        Thread.sleep(INITIAL_SLEEP << sleeps);\n+                        ++sleeps; \/\/ Only increment if sleep completed.\n+                    } else {\n+                        throw new OutOfMemoryError\n+                            (\"Cannot reserve \"\n+                             + size + \" bytes of direct buffer memory (allocated: \"\n+                             + RESERVED_MEMORY.get() + \", limit: \" + MAX_MEMORY +\")\");\n@@ -174,6 +195,1 @@\n-            \/\/ no luck\n-            throw new OutOfMemoryError\n-                (\"Cannot reserve \"\n-                 + size + \" bytes of direct buffer memory (allocated: \"\n-                 + RESERVED_MEMORY.get() + \", limit: \" + MAX_MEMORY +\")\");\n-\n+            \/\/ Reapply any deferred interruption.\n@@ -182,1 +198,0 @@\n-                \/\/ don't swallow interrupts\n@@ -188,0 +203,21 @@\n+    \/\/ Try to reserve memory, or failing that, try to make progress on\n+    \/\/ cleaning.  Returns true if successfully reserved memory, false if\n+    \/\/ failed and ran out of cleaning work.\n+    private static boolean tryReserveOrClean(long size, long cap)\n+        throws InterruptedException\n+    {\n+        JavaLangRefAccess jlra = SharedSecrets.getJavaLangRefAccess();\n+        boolean progressing = true;\n+        while (true) {\n+            if (tryReserveMemory(size, cap)) {\n+                return true;\n+            } else if (BufferCleaner.tryCleaning()) {\n+                progressing = true;\n+            } else if (!progressing) {\n+                return false;\n+            } else {\n+                progressing = jlra.waitForReferenceProcessing();\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Bits.java","additions":73,"deletions":37,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -0,0 +1,269 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.nio;\n+\n+import java.lang.ref.PhantomReference;\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.util.Objects;\n+import sun.nio.Cleaner;\n+\n+\/**\n+ * BufferCleaner supports PhantomReference-based management of native memory\n+ * referred to by Direct-XXX-Buffers. Unreferenced DBBs may be garbage\n+ * collected, deactivating the associated PRefs and making them available for\n+ * cleanup here.\n+ *\n+ * There is a configured limit to the amount of memory that may be allocated\n+ * by DBBs. When that limit is reached, the allocator may invoke the garbage\n+ * collector directly to attempt to trigger cleaning here, hopefully\n+ * permitting the allocation to complete. Only if that doesn't free sufficient\n+ * memory does the allocation fail.  See java.nio.Bits::reserveMemory() for\n+ * details.\n+ *\n+ * One of the requirements for that approach is having a way to determine that\n+ * deactivated cleaners have been cleaned. java.lang.ref.Cleaner doesn't\n+ * provide such a mechanism, and adding such a mechanism to that class to\n+ * satisfy this unique requirement was deemed undesirable. Instead, this class\n+ * uses the underlying primitives (PhantomReferences, ReferenceQueues) to\n+ * provide the functionality needed for DBB management.\n+ *\/\n+class BufferCleaner {\n+    private static final class PhantomCleaner\n+        extends PhantomReference<Object>\n+        implements Cleaner\n+    {\n+        private final Runnable action;\n+        \/\/ Position in the CleanerList.\n+        CleanerList.Node node;\n+        int index;\n+\n+        public PhantomCleaner(Object obj, Runnable action) {\n+            super(obj, queue);\n+            this.action = action;\n+        }\n+\n+        @Override\n+        public void clean() {\n+            if (cleanerList.remove(this)) {\n+                \/\/ If being cleaned explicitly by application, rather than via\n+                \/\/ reference processing by BufferCleaner, clear the referent so\n+                \/\/ reference processing is disabled for this object.\n+                clear();\n+                try {\n+                    action.run();\n+                } catch (Throwable x) {\n+                    \/\/ Long-standing behavior: when cleaning fails, VM exits.\n+                    if (System.err != null) {\n+                        new Error(\"nio Cleaner terminated abnormally\", x).printStackTrace();\n+                    }\n+                    System.exit(1);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Cribbed from jdk.internal.ref.CleanerImpl.\n+    static final class CleanerList {\n+        \/**\n+         * Capacity for a single node in the list.\n+         * This balances memory overheads vs locality vs GC walking costs.\n+         *\/\n+        static final int NODE_CAPACITY = 4096;\n+\n+        \/**\n+         * Head node. This is the only node where PhantomCleanabls are\n+         * added to or removed from. This is the only node with variable size,\n+         * all other nodes linked from the head are always at full capacity.\n+         *\/\n+        private Node head;\n+\n+        \/**\n+         * Cached node instance to provide better behavior near NODE_CAPACITY\n+         * threshold: if list size flips around NODE_CAPACITY, it would reuse\n+         * the cached node instead of wasting and re-allocating a new node all\n+         * the time.\n+         *\/\n+        private Node cache;\n+\n+        public CleanerList() {\n+            this.head = new Node();\n+        }\n+\n+        \/**\n+         * Insert this PhantomCleaner in the list.\n+         *\/\n+        public synchronized void insert(PhantomCleaner phc) {\n+            if (head.size == NODE_CAPACITY) {\n+                \/\/ Head node is full, insert new one.\n+                \/\/ If possible, pick a pre-allocated node from cache.\n+                Node newHead;\n+                if (cache != null) {\n+                    newHead = cache;\n+                    cache = null;\n+                } else {\n+                    newHead = new Node();\n+                }\n+                newHead.next = head;\n+                head = newHead;\n+            }\n+            assert head.size < NODE_CAPACITY;\n+\n+            \/\/ Put the incoming object in head node and record indexes.\n+            final int lastIndex = head.size;\n+            phc.node = head;\n+            phc.index = lastIndex;\n+            head.arr[lastIndex] = phc;\n+            head.size++;\n+        }\n+\n+        \/**\n+         * Remove this PhantomCleaner from the list.\n+         *\n+         * @return true if Cleaner was removed or false if not because\n+         * it had already been removed before\n+         *\/\n+        public synchronized boolean remove(PhantomCleaner phc) {\n+            if (phc.node == null) {\n+                \/\/ Not in the list.\n+                return false;\n+            }\n+            assert phc.node.arr[phc.index] == phc;\n+\n+            \/\/ Replace with another element from the head node, as long\n+            \/\/ as it is not the same element. This keeps all non-head\n+            \/\/ nodes at full capacity.\n+            final int lastIndex = head.size - 1;\n+            assert lastIndex >= 0;\n+            if (head != phc.node || (phc.index != lastIndex)) {\n+                PhantomCleaner mover = head.arr[lastIndex];\n+                mover.node = phc.node;\n+                mover.index = phc.index;\n+                phc.node.arr[phc.index] = mover;\n+            }\n+\n+            \/\/ Now we can unlink the removed element.\n+            phc.node = null;\n+\n+            \/\/ Remove the last element from the head node.\n+            head.arr[lastIndex] = null;\n+            head.size--;\n+\n+            \/\/ If head node becomes empty after this, and there are\n+            \/\/ nodes that follow it, replace the head node with another\n+            \/\/ full one. If needed, stash the now free node in cache.\n+            if (head.size == 0 && head.next != null) {\n+                Node newHead = head.next;\n+                if (cache == null) {\n+                    cache = head;\n+                    cache.next = null;\n+                }\n+                head = newHead;\n+            }\n+\n+            return true;\n+        }\n+\n+        \/**\n+         * Segment node.\n+         *\/\n+        static class Node {\n+            \/\/ Array of tracked cleaners, and the amount of elements in it.\n+            final PhantomCleaner[] arr = new PhantomCleaner[NODE_CAPACITY];\n+            int size;\n+\n+            \/\/ Linked list structure.\n+            Node next;\n+        }\n+    }\n+\n+    private static final class CleaningThread extends Thread {\n+        public CleaningThread() {}\n+\n+        @Override\n+        public void run() {\n+            while (true) {\n+                try {\n+                    Cleaner c = (Cleaner) queue.remove();\n+                    c.clean();\n+                } catch (InterruptedException e) {\n+                    \/\/ Ignore InterruptedException in cleaner thread.\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Try to do some cleaning. Takes a cleaner from the queue and executes it.\n+     *\n+     * @return true if a cleaner was found and executed, false if there\n+     * weren't any cleaners in the queue.\n+     *\/\n+    public static boolean tryCleaning() {\n+        Cleaner c = (Cleaner) queue.poll();\n+        if (c == null) {\n+            return false;\n+        } else {\n+            c.clean();\n+            return true;\n+        }\n+    }\n+\n+    private static final CleanerList cleanerList = new CleanerList();\n+    private static final ReferenceQueue<Object> queue = new ReferenceQueue<Object>();\n+    private static CleaningThread cleaningThread = null;\n+\n+    private static void startCleaningThreadIfNeeded() {\n+        synchronized (cleanerList) {\n+            if (cleaningThread != null) {\n+                return;\n+            }\n+            cleaningThread = new CleaningThread();\n+        }\n+        cleaningThread.setDaemon(true);\n+        cleaningThread.start();\n+    }\n+\n+    private BufferCleaner() {}\n+\n+    \/**\n+     * Construct a new Cleaner for obj, with the associated action.\n+     *\n+     * @param obj object to track.\n+     * @param action cleanup action for obj.\n+     * @return associated cleaner.\n+     *\n+     *\/\n+    public static Cleaner register(Object obj, Runnable action) {\n+        Objects.requireNonNull(obj, \"obj\");\n+        Objects.requireNonNull(action, \"action\");\n+        startCleaningThreadIfNeeded();\n+        PhantomCleaner cleaner = new PhantomCleaner(obj, action);\n+        cleanerList.insert(cleaner);\n+        Reference.reachabilityFence(obj);\n+        return cleaner;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/BufferCleaner.java","additions":269,"deletions":0,"binary":false,"changes":269,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+import java.nio.BufferCleaner;\n@@ -40,1 +41,1 @@\n-import jdk.internal.ref.Cleaner;\n+import sun.nio.Cleaner;\n@@ -125,1 +126,1 @@\n-            cleaner = Cleaner.create(this, new Deallocator(base, size, cap));\n+            cleaner = BufferCleaner.register(this, new Deallocator(base, size, cap));\n@@ -200,1 +201,1 @@\n-        cleaner = Cleaner.create(this, unmapper);\n+        cleaner = (unmapper == null) ? null : BufferCleaner.register(this, unmapper);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1900,1 +1900,1 @@\n-     * Absolute bulk <i>get<\/i> method.\n+     * Relative bulk <i>get<\/i> method.\n@@ -1903,3 +1903,10 @@\n-     * buffer into the given array, starting at index {@code srcBegin} in this\n-     * buffer and at offset {@code dstBegin} in the array. The position of this\n-     * buffer is unchanged.\n+     * buffer into the given array, starting at index\n+     * {@code position() + srcBegin} in this buffer and at offset\n+     * {@code dstBegin} in the array. The position of this buffer is unchanged.\n+     *\n+     * <p> An invocation of this method behaves exactly the same was as the\n+     * invocation\n+     *\n+     * {@snippet lang=java :\n+     *     get(position() + srcBegin, dst, dstBegin, srcEnd - srcBegin)\n+     * }\n@@ -1908,2 +1915,4 @@\n-     *         The index in this buffer from which the first character will be\n-     *         read; must be non-negative and less than {@code limit()}\n+     *         The index in this buffer, relative to the current position,\n+     *         of the first character to\n+     *         read; must be non-negative and less than\n+     *         {@code limit() - position()}\n@@ -1912,3 +1921,4 @@\n-     *         The index in this buffer directly before the last character to\n-     *         read; must be non-negative and less or equal than {@code limit()}\n-     *         and must be greater or equal than {@code srcBegin}\n+     *         The index in this buffer, relative to the current position,\n+     *         after the last character to read;\n+     *         must be greater than or equal to {@code srcBegin} and less than\n+     *         or equal to {@code limit() - position()}\n@@ -1927,3 +1937,0 @@\n-     * @implSpec This method is equivalent to\n-     *           {@code get(srcBegin, dst, dstBegin, srcEnd - srcBegin)}.\n-     *\n@@ -1934,1 +1941,6 @@\n-        get(srcBegin, dst, dstBegin, srcEnd - srcBegin);\n+        \/\/ Check [srcBegin,srcEnd) is a subset of [0,limit()-position)\n+        int pos = position();\n+        int lim = limit();\n+        Objects.checkFromToIndex(srcBegin, srcEnd, lim - pos);\n+\n+        get(pos + srcBegin, dst, dstBegin, srcEnd - srcBegin);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":25,"deletions":13,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.util.ByteArray;\n@@ -840,0 +841,10 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public long nextLong() {\n+        byte[] b = new byte[8];\n+        nextBytes(b); \/\/ Calls engineNextBytes internally\n+        return ByteArray.getLong(b, 0);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/security\/SecureRandom.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -564,2 +564,2 @@\n- * @spec https:\/\/unicode.org\/reports\/tr35\/\n- *      Unicode Locale Data Markup Language\n+ * @spec https:\/\/www.unicode.org\/reports\/tr35\n+ *      Unicode Locale Data Markup Language (LDML)\n@@ -1690,1 +1690,1 @@\n-     * that adheres to section 2.1.1. Formatting of Language Tags of RFC5646.\n+     * that adheres to section 2.1.1. Formatting of Language Tags of RFC 5646.\n@@ -1697,1 +1697,1 @@\n-     * legacy tags, (defined as \"grandfathered\" in RFC5646) are not always well-formed, this method\n+     * legacy tags, (defined as \"grandfathered\" in RFC 5646) are not always well-formed, this method\n@@ -1723,1 +1723,1 @@\n-     * of RFC5646).\n+     * of RFC 5646).\n@@ -1729,1 +1729,1 @@\n-     *       RFC5646 2.1. Syntax\n+     *       RFC 5646: 2.1. Syntax\n@@ -1731,1 +1731,1 @@\n-     *       RFC5646 2.1.1. Formatting of Language Tags\n+     *       RFC 5646: 2.1.1. Formatting of Language Tags\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -319,0 +319,4 @@\n+    \/\/ Parse the specified cipher transformation for algorithm and the\n+    \/\/ optional mode and padding. If the transformation contains only\n+    \/\/ algorithm, then only algorithm is returned. Otherwise, the\n+    \/\/ transformation must contain all 3 and they must be non-empty.\n@@ -325,1 +329,1 @@\n-         * array containing the components of a cipher transformation:\n+         * Components of a cipher transformation:\n@@ -327,3 +331,3 @@\n-         * index 0: algorithm component (e.g., AES)\n-         * index 1: feedback component (e.g., CFB)\n-         * index 2: padding component (e.g., PKCS5Padding)\n+         * 1) algorithm component (e.g., AES)\n+         * 2) feedback component (e.g., CFB) - optional\n+         * 3) padding component (e.g., PKCS5Padding) - optional\n@@ -331,1 +335,0 @@\n-        String[] parts = { \"\", \"\", \"\" };\n@@ -340,3 +343,11 @@\n-        if (endIdx == -1) {\n-            \/\/ algorithm\n-            parts[0] = transformation.trim();\n+\n+        boolean algorithmOnly = (endIdx == -1);\n+        String algo = (algorithmOnly ? transformation.trim() :\n+                transformation.substring(0, endIdx).trim());\n+        if (algo.isEmpty()) {\n+            throw new NoSuchAlgorithmException(\"Invalid transformation: \" +\n+                                   \"algorithm not specified-\"\n+                                   + transformation);\n+        }\n+        if (algorithmOnly) { \/\/ done\n+            return new String[] { algo };\n@@ -344,2 +355,1 @@\n-            \/\/ algorithm\/mode\/padding\n-            parts[0] = transformation.substring(0, endIdx).trim();\n+            \/\/ continue parsing mode and padding\n@@ -352,6 +362,6 @@\n-            parts[1] = transformation.substring(startIdx, endIdx).trim();\n-            parts[2] = transformation.substring(endIdx+1).trim();\n-        }\n-        if (parts[0].isEmpty()) {\n-            throw new NoSuchAlgorithmException(\"Invalid transformation: \" +\n-                                   \"algorithm not specified-\"\n+            String mode = transformation.substring(startIdx, endIdx).trim();\n+            String padding = transformation.substring(endIdx+1).trim();\n+            \/\/ ensure mode and padding are specified\n+            if (mode.isEmpty() || padding.isEmpty()) {\n+                throw new NoSuchAlgorithmException(\"Invalid transformation: \" +\n+                                   \"missing mode and\/or padding-\"\n@@ -359,0 +369,2 @@\n+            }\n+            return new String[] { algo, mode, padding };\n@@ -360,1 +372,0 @@\n-        return parts;\n@@ -456,5 +467,1 @@\n-        String alg = parts[0];\n-        String mode = (parts[1].length() == 0 ? null : parts[1]);\n-        String pad = (parts[2].length() == 0 ? null : parts[2]);\n-\n-        if ((mode == null) && (pad == null)) {\n+        if (parts.length == 1) {\n@@ -462,2 +469,1 @@\n-            Transform tr = new Transform(alg, \"\", null, null);\n-            return Collections.singletonList(tr);\n+            return List.of(new Transform(parts[0], \"\", null, null));\n@@ -465,13 +471,7 @@\n-            \/\/ Algorithm w\/ at least mode or padding or both\n-            List<Transform> list = new ArrayList<>(4);\n-            if ((mode != null) && (pad != null)) {\n-                list.add(new Transform(alg, \"\/\" + mode + \"\/\" + pad, null, null));\n-            }\n-            if (mode != null) {\n-                list.add(new Transform(alg, \"\/\" + mode, null, pad));\n-            }\n-            if (pad != null) {\n-                list.add(new Transform(alg, \"\/\/\" + pad, mode, null));\n-            }\n-            list.add(new Transform(alg, \"\", mode, pad));\n-            return list;\n+            \/\/ Algorithm w\/ both mode and padding\n+            return List.of(\n+                    new Transform(parts[0], \"\/\" + parts[1] + \"\/\" + parts[2],\n+                    null, null),\n+                    new Transform(parts[0], \"\/\" + parts[1], null, parts[2]),\n+                    new Transform(parts[0], \"\/\/\" + parts[2], parts[1], null),\n+                    new Transform(parts[0], \"\", parts[1], parts[2]));\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/Cipher.java","additions":37,"deletions":37,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,6 +47,5 @@\n-\/**\n- * ParserVerifier performs selected checks of the class file format according to\n- * {@jvms 4.8 Format Checking}\n- *\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/classFileParser.cpp\">hotspot\/share\/classfile\/classFileParser.cpp<\/a>\n- *\/\n+\/\/\/ ParserVerifier performs selected checks of the class file format according to\n+\/\/\/ {@jvms 4.8 Format Checking}.\n+\/\/\/\n+\/\/\/ From `classFileParser.cpp`.\n+\/\/\/\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/ParserVerifier.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,4 +32,1 @@\n-\/**\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/interpreter\/bytecodes.hpp\">hotspot\/share\/interpreter\/bytecodes.hpp<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/interpreter\/bytecodes.cpp\">hotspot\/share\/interpreter\/bytecodes.cpp<\/a>\n- *\/\n+\/\/\/ From `bytecodes.cpp`.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationBytecodes.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,4 +29,1 @@\n-\/**\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/stackMapFrame.hpp\">hotspot\/share\/classfile\/stackMapFrame.hpp<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/stackMapFrame.cpp\">hotspot\/share\/classfile\/stackMapFrame.cpp<\/a>\n- *\/\n+\/\/\/ From `stackMapFrame.cpp`.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationFrame.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+\/\/\/ Relevant parts from `signatures.cpp`, such as `SignatureStream`.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationSignature.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,3 @@\n+import java.util.ArrayList;\n+import java.util.List;\n+\n@@ -31,4 +34,1 @@\n-\/**\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/stackMapTable.hpp\">hotspot\/share\/classfile\/stackMapTable.hpp<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/stackMapTable.cpp\">hotspot\/share\/classfile\/stackMapTable.cpp<\/a>\n- *\/\n+\/\/\/ From `stackMapTable.cpp`.\n@@ -39,1 +39,1 @@\n-    private final VerificationFrame[] _frame_array;\n+    private final List<VerificationFrame> _frame_array;\n@@ -47,1 +47,1 @@\n-        return _frame_array[index].offset();\n+        return _frame_array.get(index).offset();\n@@ -79,1 +79,1 @@\n-    VerificationTable(byte[] stackmap_data, VerificationFrame init_frame, int max_locals, int max_stack, byte[] code_data, int code_len,\n+    VerificationTable(StackMapReader reader,\n@@ -82,4 +82,3 @@\n-        var reader = new StackMapReader(stackmap_data, code_data, code_len, cp, v);\n-        _code_length = code_len;\n-        _frame_count = reader.get_frame_count();\n-        _frame_array = new VerificationFrame[_frame_count];\n+        _code_length = reader.code_length();\n+        int _frame_count = reader.get_frame_count();\n+        _frame_array = new ArrayList<>(_frame_count);\n@@ -87,7 +86,4 @@\n-            VerificationFrame pre_frame = init_frame;\n-            for (int i = 0; i < _frame_count; i++) {\n-                VerificationFrame frame = reader.next(pre_frame, i == 0, max_locals, max_stack);\n-                _frame_array[i] = frame;\n-                int offset = frame.offset();\n-                if (offset >= code_len || code_data[offset] == 0) {\n-                    _verifier.verifyError(\"StackMapTable error: bad offset\");\n+            while (!reader.at_end()) {\n+                VerificationFrame frame = reader.next();\n+                if (frame != null) {\n+                    _frame_array.add(frame);\n@@ -95,1 +91,0 @@\n-                pre_frame = frame;\n@@ -99,0 +94,1 @@\n+        this._frame_count = _frame_array.size();\n@@ -104,1 +100,1 @@\n-            if (_frame_array[i].offset() == offset) {\n+            if (_frame_array.get(i).offset() == offset) {\n@@ -120,1 +116,1 @@\n-        VerificationFrame stackmap_frame = _frame_array[frame_index];\n+        VerificationFrame stackmap_frame = _frame_array.get(frame_index);\n@@ -154,0 +150,4 @@\n+        private int _parsed_frame_count;\n+        private VerificationFrame _prev_frame;\n+        char _max_locals, _max_stack;\n+        boolean _first;\n@@ -170,0 +170,27 @@\n+        public VerificationFrame prev_frame() {\n+            return _prev_frame;\n+        }\n+\n+        public byte[] code_data() {\n+            return _code_data;\n+        }\n+\n+        public int code_length() {\n+            return _code_length;\n+        }\n+\n+        public boolean at_end() {\n+            return _stream.at_end();\n+        }\n+\n+        public VerificationFrame next() {\n+            _parsed_frame_count++;\n+            check_size();\n+            VerificationFrame frame = next_helper();\n+            if (frame != null) {\n+                check_offset(frame);\n+                _prev_frame = frame;\n+            }\n+            return frame;\n+        }\n+\n@@ -171,2 +198,2 @@\n-            if (!_stream.at_end()) {\n-                _verifier.classError(\"wrong attribute size\");\n+            if (_frame_count != _parsed_frame_count) {\n+                _verifier.verifyError(\"wrong attribute size\");\n@@ -178,1 +205,3 @@\n-        public StackMapReader(byte[] stackmapData, byte[] code_data, int code_len, VerificationWrapper.ConstantPoolWrapper cp, VerifierImpl context) {\n+        public StackMapReader(byte[] stackmapData, byte[] code_data, int code_len,\n+                              VerificationFrame init_frame, char max_locals, char max_stack,\n+                              VerificationWrapper.ConstantPoolWrapper cp, VerifierImpl context) {\n@@ -181,0 +210,7 @@\n+            _code_data = code_data;\n+            _code_length = code_len;\n+            _parsed_frame_count = 0;\n+            _prev_frame = init_frame;\n+            _max_locals = max_locals;\n+            _max_stack = max_stack;\n+            _first = true;\n@@ -182,0 +218,1 @@\n+                _cp = cp;\n@@ -184,0 +221,1 @@\n+                _cp = null;\n@@ -186,3 +224,13 @@\n-            _code_data = code_data;\n-            _code_length = code_len;\n-            _cp = cp;\n+        }\n+\n+        void check_offset(VerificationFrame frame) {\n+            int offset = frame.offset();\n+            if (offset >= _code_length || _code_data[offset] == 0) {\n+                _verifier.verifyError(\"StackMapTable error: bad offset\");\n+            }\n+        }\n+\n+        void check_size() {\n+            if (_frame_count < _parsed_frame_count) {\n+                _verifier.verifyError(\"wrong attribute size\");\n+            }\n@@ -235,1 +283,1 @@\n-        public VerificationFrame next(VerificationFrame pre_frame, boolean first, int max_locals, int max_stack) {\n+        VerificationFrame next_helper() {\n@@ -241,1 +289,1 @@\n-                if (first) {\n+                if (_first) {\n@@ -243,2 +291,2 @@\n-                    if (pre_frame.locals_size() > 0) {\n-                        locals = new VerificationType[pre_frame.locals_size()];\n+                    if (_prev_frame.locals_size() > 0) {\n+                        locals = new VerificationType[_prev_frame.locals_size()];\n@@ -247,2 +295,2 @@\n-                    offset = pre_frame.offset() + frame_type + 1;\n-                    locals = pre_frame.locals();\n+                    offset = _prev_frame.offset() + frame_type + 1;\n+                    locals = _prev_frame.locals();\n@@ -250,3 +298,3 @@\n-                frame = new VerificationFrame(offset, pre_frame.flags(), pre_frame.locals_size(), 0, max_locals, max_stack, locals, null, _verifier);\n-                if (first && locals != null) {\n-                    frame.copy_locals(pre_frame);\n+                frame = new VerificationFrame(offset, _prev_frame.flags(), _prev_frame.locals_size(), 0, _max_locals, _max_stack, locals, null, _verifier);\n+                if (_first && locals != null) {\n+                    frame.copy_locals(_prev_frame);\n@@ -254,0 +302,1 @@\n+                _first = false;\n@@ -257,1 +306,1 @@\n-                if (first) {\n+                if (_first) {\n@@ -259,2 +308,2 @@\n-                    if (pre_frame.locals_size() > 0) {\n-                        locals = new VerificationType[pre_frame.locals_size()];\n+                    if (_prev_frame.locals_size() > 0) {\n+                        locals = new VerificationType[_prev_frame.locals_size()];\n@@ -263,2 +312,2 @@\n-                    offset = pre_frame.offset() + frame_type - 63;\n-                    locals = pre_frame.locals();\n+                    offset = _prev_frame.offset() + frame_type - 63;\n+                    locals = _prev_frame.locals();\n@@ -273,4 +322,4 @@\n-                check_verification_type_array_size(stack_size, max_stack);\n-                frame = new VerificationFrame(offset, pre_frame.flags(), pre_frame.locals_size(), stack_size, max_locals, max_stack, locals, stack, _verifier);\n-                if (first && locals != null) {\n-                    frame.copy_locals(pre_frame);\n+                check_verification_type_array_size(stack_size, _max_stack);\n+                frame = new VerificationFrame(offset, _prev_frame.flags(), _prev_frame.locals_size(), stack_size, _max_locals, _max_stack, locals, stack, _verifier);\n+                if (_first && locals != null) {\n+                    frame.copy_locals(_prev_frame);\n@@ -278,0 +327,1 @@\n+                _first = false;\n@@ -285,1 +335,1 @@\n-                if (first) {\n+                if (_first) {\n@@ -287,2 +337,2 @@\n-                    if (pre_frame.locals_size() > 0) {\n-                        locals = new VerificationType[pre_frame.locals_size()];\n+                    if (_prev_frame.locals_size() > 0) {\n+                        locals = new VerificationType[_prev_frame.locals_size()];\n@@ -291,2 +341,2 @@\n-                    offset = pre_frame.offset() + offset_delta + 1;\n-                    locals = pre_frame.locals();\n+                    offset = _prev_frame.offset() + offset_delta + 1;\n+                    locals = _prev_frame.locals();\n@@ -301,4 +351,4 @@\n-                check_verification_type_array_size(stack_size, max_stack);\n-                frame = new VerificationFrame(offset, pre_frame.flags(), pre_frame.locals_size(), stack_size, max_locals, max_stack, locals, stack, _verifier);\n-                if (first && locals != null) {\n-                    frame.copy_locals(pre_frame);\n+                check_verification_type_array_size(stack_size, _max_stack);\n+                frame = new VerificationFrame(offset, _prev_frame.flags(), _prev_frame.locals_size(), stack_size, _max_locals, _max_stack, locals, stack, _verifier);\n+                if (_first && locals != null) {\n+                    frame.copy_locals(_prev_frame);\n@@ -306,0 +356,1 @@\n+                _first = false;\n@@ -309,2 +360,2 @@\n-                locals = pre_frame.locals();\n-                int length = pre_frame.locals_size();\n+                locals = _prev_frame.locals();\n+                int length = _prev_frame.locals_size();\n@@ -313,1 +364,1 @@\n-                int flags = pre_frame.flags();\n+                int flags = _prev_frame.flags();\n@@ -316,1 +367,1 @@\n-                    check_verification_type_array_size(new_length, max_locals);\n+                    check_verification_type_array_size(new_length, _max_locals);\n@@ -325,1 +376,1 @@\n-                if (first) {\n+                if (_first) {\n@@ -333,1 +384,1 @@\n-                    offset = pre_frame.offset() + offset_delta + 1;\n+                    offset = _prev_frame.offset() + offset_delta + 1;\n@@ -335,3 +386,3 @@\n-                frame = new VerificationFrame(offset, flags, new_length, 0, max_locals, max_stack, locals, null, _verifier);\n-                if (first && locals != null) {\n-                    frame.copy_locals(pre_frame);\n+                frame = new VerificationFrame(offset, flags, new_length, 0, _max_locals, _max_stack, locals, null, _verifier);\n+                if (_first && locals != null) {\n+                    frame.copy_locals(_prev_frame);\n@@ -339,0 +390,1 @@\n+                _first = false;\n@@ -342,1 +394,1 @@\n-                int real_length = pre_frame.locals_size();\n+                int real_length = _prev_frame.locals_size();\n@@ -345,1 +397,1 @@\n-                VerificationType[] pre_locals = pre_frame.locals();\n+                VerificationType[] pre_locals = _prev_frame.locals();\n@@ -347,1 +399,1 @@\n-                for (i=0; i<pre_frame.locals_size(); i++) {\n+                for (i=0; i< _prev_frame.locals_size(); i++) {\n@@ -350,1 +402,1 @@\n-                int[] flags = new int[]{pre_frame.flags()};\n+                int[] flags = new int[]{_prev_frame.flags()};\n@@ -359,2 +411,2 @@\n-                check_verification_type_array_size(real_length, max_locals);\n-                if (first) {\n+                check_verification_type_array_size(real_length, _max_locals);\n+                if (_first) {\n@@ -363,1 +415,1 @@\n-                    offset = pre_frame.offset() + offset_delta + 1;\n+                    offset = _prev_frame.offset() + offset_delta + 1;\n@@ -365,1 +417,2 @@\n-                frame = new VerificationFrame(offset, flags[0], real_length, 0, max_locals, max_stack, locals, null, _verifier);\n+                frame = new VerificationFrame(offset, flags[0], real_length, 0, _max_locals, _max_stack, locals, null, _verifier);\n+                _first = false;\n@@ -380,1 +433,1 @@\n-                            locals[real_locals_size].to_category2_2nd(_verifier);\n+                                locals[real_locals_size].to_category2_2nd(_verifier);\n@@ -385,1 +438,1 @@\n-                check_verification_type_array_size(real_locals_size, max_locals);\n+                check_verification_type_array_size(real_locals_size, _max_locals);\n@@ -400,2 +453,2 @@\n-                check_verification_type_array_size(real_stack_size, max_stack);\n-                if (first) {\n+                check_verification_type_array_size(real_stack_size, _max_stack);\n+                if (_first) {\n@@ -404,1 +457,1 @@\n-                    offset = pre_frame.offset() + offset_delta + 1;\n+                    offset = _prev_frame.offset() + offset_delta + 1;\n@@ -406,1 +459,2 @@\n-                frame = new VerificationFrame(offset, flags[0], real_locals_size, real_stack_size, max_locals, max_stack, locals, stack, _verifier);\n+                frame = new VerificationFrame(offset, flags[0], real_locals_size, real_stack_size, _max_locals, _max_stack, locals, stack, _verifier);\n+                _first = false;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationTable.java","additions":132,"deletions":78,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,4 +38,1 @@\n-\/**\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/verificationType.hpp\">hotspot\/share\/classfile\/verificationType.hpp<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/verificationType.cpp\">hotspot\/share\/classfile\/verificationType.cpp<\/a>\n- *\/\n+\/\/\/ From `verificationType.cpp`.\n@@ -335,1 +332,1 @@\n-                        return is_reference_assignable_from(from, context);\n+                        return is_reference_assignable_from(from, context, null);\n@@ -382,1 +379,2 @@\n-    boolean resolve_and_check_assignability(ClassHierarchyImpl assignResolver, String name, String from_name, boolean from_is_array, boolean from_is_object) {\n+    boolean resolve_and_check_assignability(ClassHierarchyImpl assignResolver, String target_name, String from_name,\n+                                            boolean from_is_array, boolean from_is_object, boolean[] target_is_interface) {\n@@ -384,3 +382,9 @@\n-        var desc = Util.toClassDesc(name);\n-        if (assignResolver.isInterface(desc)) {\n-            return !from_is_array || \"java\/lang\/Cloneable\".equals(name) || \"java\/io\/Serializable\".equals(name);\n+        var targetClass = Util.toClassDesc(target_name);\n+        boolean isInterface = assignResolver.isInterface(targetClass);\n+\n+        if (target_is_interface != null) {\n+            target_is_interface[0] = isInterface;\n+        }\n+\n+        if (isInterface) {\n+            return !from_is_array || \"java\/lang\/Cloneable\".equals(target_name) || \"java\/io\/Serializable\".equals(target_name);\n@@ -388,1 +392,1 @@\n-            return assignResolver.isAssignableFrom(desc, Util.toClassDesc(from_name));\n+            return assignResolver.isAssignableFrom(targetClass, Util.toClassDesc(from_name));\n@@ -393,1 +397,1 @@\n-    boolean is_reference_assignable_from(VerificationType from, VerifierImpl context) {\n+    boolean is_reference_assignable_from(VerificationType from, VerifierImpl context, boolean[] target_is_interface) {\n@@ -405,1 +409,1 @@\n-            return resolve_and_check_assignability(clsTree, name(), from.name(), from.is_array(), from.is_object());\n+            return resolve_and_check_assignability(clsTree, name(), from.name(), from.is_array(), from.is_object(), target_is_interface);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationType.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,10 +45,6 @@\n-\/**\n- * VerifierImpl performs selected checks and verifications of the class file\n- * format according to {@jvms 4.8 Format Checking},\n- * {@jvms 4.9 Constraints on Java Virtual Machine code},\n- * {@jvms 4.10 Verification of class Files} and {@jvms 6.5 Instructions}\n- *\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/java.base\/share\/native\/include\/classfile_constants.h.template\">java.base\/share\/native\/include\/classfile_constants.h.template<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/verifier.hpp\">hotspot\/share\/classfile\/verifier.hpp<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/verifier.cpp\">hotspot\/share\/classfile\/verifier.cpp<\/a>\n- *\/\n+\/\/\/ VerifierImpl performs selected checks and verifications of the class file\n+\/\/\/ format according to {@jvms 4.8 Format Checking},\n+\/\/\/ {@jvms 4.9 Constraints on Java Virtual Machine code},\n+\/\/\/ {@jvms 4.10 Verification of class Files} and {@jvms 6.5 Instructions}\n+\/\/\/\n+\/\/\/ From `verifier.cpp`.\n@@ -145,5 +141,2 @@\n-        String name = klass.thisClassName();\n-        return !java_lang_Object.equals(name) &&\n-                !java_lang_Class.equals(name) &&\n-                !java_lang_String.equals(name) &&\n-                !java_lang_Throwable.equals(name);\n+        \/\/ 8330606 Not applicable here\n+        return true;\n@@ -326,1 +319,3 @@\n-        VerificationTable stackmap_table = new VerificationTable(stackmap_data, current_frame, max_locals, max_stack, code_data, code_length, cp, this);\n+        var reader = new VerificationTable.StackMapReader(stackmap_data, code_data, code_length, current_frame,\n+                (char) max_locals, (char) max_stack, cp, this);\n+        VerificationTable stackmap_table = new VerificationTable(reader, cp, this);\n@@ -1273,0 +1268,1 @@\n+                \/\/ 8267118 Not applicable here\n@@ -1356,1 +1352,1 @@\n-        if ((types & (1 << tag))== 0) {\n+        if (tag > JVM_CONSTANT_ExternalMax || (types & (1 << tag))== 0) {\n@@ -1435,2 +1431,2 @@\n-            keys = high - low + 1;\n-            if (keys < 0) {\n+            long keys64 = ((long) high - low) + 1;\n+            if (keys64 > 65535) {  \/\/ Max code length\n@@ -1439,0 +1435,1 @@\n+            keys = (int) keys64;\n@@ -1495,0 +1492,1 @@\n+                \/\/ 8270398 Not applicable here\n@@ -1646,3 +1644,16 @@\n-            boolean have_imr_indirect = cp.tagAt(index) == JVM_CONSTANT_InterfaceMethodref;\n-            boolean subtype = ref_class_type.is_assignable_from(current_type(), this);\n-            if (!subtype) {\n+\n+            \/\/ We know it is not current class, direct superinterface or immediate superclass. That means it\n+            \/\/ could be:\n+            \/\/ - a totally unrelated class or interface\n+            \/\/ - an indirect superinterface\n+            \/\/ - an indirect superclass (including Object)\n+            \/\/ We use the assignability test to see if it is a superclass, or else an interface, and keep track\n+            \/\/ of the latter. Note that subtype can be true if we are dealing with an interface that is not actually\n+            \/\/ implemented as assignability treats all interfaces as Object.\n+\n+            boolean[] is_interface = {false}; \/\/ This can only be set true if the assignability check will return true\n+                                              \/\/ and we loaded the class. For any other \"true\" returns (e.g. same class\n+                                              \/\/ or Object) we either can't get here (same class already excluded above)\n+                                              \/\/ or we know it is not an interface (i.e. Object).\n+            boolean subtype = ref_class_type.is_reference_assignable_from(current_type(), this, is_interface);\n+            if (!subtype) {  \/\/ Totally unrelated class\n@@ -1650,2 +1661,6 @@\n-            } else if (have_imr_indirect) {\n-                verifyError(\"Bad invokespecial instruction: interface method reference is in an indirect superinterface.\");\n+            } else {\n+                \/\/ Indirect superclass (including Object), indirect interface, or unrelated interface.\n+                \/\/ Any interface use is an error.\n+                if (is_interface[0]) {\n+                    verifyError(\"Bad invokespecial instruction: interface method to invoke is not in a direct superinterface.\");\n+                }\n@@ -1820,1 +1835,1 @@\n-            verifyError(\"Method expects a return value\");\n+            verifyError(\"Method does not expect a return value\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerifierImpl.java","additions":41,"deletions":26,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -0,0 +1,20 @@\n+The Class-File Verifier\n+===\n+The Class-File API provides a verifier, a debug utility that reports as many\n+verification errors as possible in a class file.\n+\n+Currently, the verifier closely follows the C++ code that implements the hotspot\n+verifier. However, there are a few differences:\n+- The Class-File API verifier tries to collect as many errors as possible, while\n+  the hotspot verifier fails fast.\n+- The hotspot verifier has access to other classes and can check access control;\n+  the Class-File API verifier cannot.\n+\n+Thus, this verifier cannot serve as a complete implementation of the verifier\n+specified in the JVMS because it has no access to other class files or loaded\n+classes.  However, it is still in our interest to make this verifier up to date:\n+for example, this should not fail upon encountering new language features, and\n+should at best include all new checks hotspot has as long as the required\n+information are accessible to the Class-File API.\n+\n+Last sync: jdk-26+5, July 3rd 2025\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/verifier.md","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.ref.Cleaner;\n@@ -31,0 +30,1 @@\n+import sun.nio.Cleaner;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,150 +1,0 @@\n-\/*\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.ref;\n-\n-import java.lang.ref.*;\n-\n-\n-\/**\n- * General-purpose phantom-reference-based cleaners.\n- *\n- * <p> Cleaners are a lightweight and more robust alternative to finalization.\n- * They are lightweight because they are not created by the VM and thus do not\n- * require a JNI upcall to be created, and because their cleanup code is\n- * invoked directly by the reference-handler thread rather than by the\n- * finalizer thread.  They are more robust because they use phantom references,\n- * the weakest type of reference object, thereby avoiding the nasty ordering\n- * problems inherent to finalization.\n- *\n- * <p> A cleaner tracks a referent object and encapsulates a thunk of arbitrary\n- * cleanup code.  Some time after the GC detects that a cleaner's referent has\n- * become phantom-reachable, the reference-handler thread will run the cleaner.\n- * Cleaners may also be invoked directly; they are thread safe and ensure that\n- * they run their thunks at most once.\n- *\n- * <p> Cleaners are not a replacement for finalization.  They should be used\n- * only when the cleanup code is extremely simple and straightforward.\n- * Nontrivial cleaners are inadvisable since they risk blocking the\n- * reference-handler thread and delaying further cleanup and finalization.\n- *\n- *\n- * @author Mark Reinhold\n- *\/\n-\n-public class Cleaner\n-    extends PhantomReference<Object>\n-{\n-\n-    \/\/ Dummy reference queue, needed because the PhantomReference constructor\n-    \/\/ insists that we pass a queue.  Nothing will ever be placed on this queue\n-    \/\/ since the reference handler invokes cleaners explicitly.\n-    \/\/\n-    private static final ReferenceQueue<Object> dummyQueue = new ReferenceQueue<>();\n-\n-    \/\/ Doubly-linked list of live cleaners, which prevents the cleaners\n-    \/\/ themselves from being GC'd before their referents\n-    \/\/\n-    private static Cleaner first = null;\n-\n-    private Cleaner\n-        next = null,\n-        prev = null;\n-\n-    private static synchronized Cleaner add(Cleaner cl) {\n-        if (first != null) {\n-            cl.next = first;\n-            first.prev = cl;\n-        }\n-        first = cl;\n-        return cl;\n-    }\n-\n-    private static synchronized boolean remove(Cleaner cl) {\n-\n-        \/\/ If already removed, do nothing\n-        if (cl.next == cl)\n-            return false;\n-\n-        \/\/ Update list\n-        if (first == cl) {\n-            if (cl.next != null)\n-                first = cl.next;\n-            else\n-                first = cl.prev;\n-        }\n-        if (cl.next != null)\n-            cl.next.prev = cl.prev;\n-        if (cl.prev != null)\n-            cl.prev.next = cl.next;\n-\n-        \/\/ Indicate removal by pointing the cleaner to itself\n-        cl.next = cl;\n-        cl.prev = cl;\n-        return true;\n-\n-    }\n-\n-    private final Runnable thunk;\n-\n-    private Cleaner(Object referent, Runnable thunk) {\n-        super(referent, dummyQueue);\n-        this.thunk = thunk;\n-    }\n-\n-    \/**\n-     * Creates a new cleaner.\n-     *\n-     * @param  ob the referent object to be cleaned\n-     * @param  thunk\n-     *         The cleanup code to be run when the cleaner is invoked.  The\n-     *         cleanup code is run directly from the reference-handler thread,\n-     *         so it should be as simple and straightforward as possible.\n-     *\n-     * @return  The new cleaner\n-     *\/\n-    public static Cleaner create(Object ob, Runnable thunk) {\n-        if (thunk == null)\n-            return null;\n-        return add(new Cleaner(ob, thunk));\n-    }\n-\n-    \/**\n-     * Runs this cleaner, if it has not been run before.\n-     *\/\n-    public void clean() {\n-        if (!remove(this))\n-            return;\n-        try {\n-            thunk.run();\n-        } catch (final Throwable x) {\n-            if (System.err != null) {\n-                new Error(\"Cleaner terminated abnormally\", x)\n-                        .printStackTrace();\n-            }\n-            System.exit(1);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/Cleaner.java","additions":0,"deletions":150,"binary":false,"changes":150,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -494,2 +494,2 @@\n-                  Object base, long offset,\n-                  W index_vector,\n+                  int indexLength, Object base, long offset,\n+                  W indexVector1, W indexVector2, W indexVector3, W indexVector4,\n@@ -561,2 +561,2 @@\n-                      Object base, long offset,\n-                      W index_vector,\n+                      int indexLength, Object base, long offset,\n+                      W indexVector,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio;\n+\n+\/**\n+ * {@code Cleaner} represents an object and a cleaning action.\n+ *\/\n+public interface Cleaner {\n+    \/**\n+     * Unregisters the cleaner and invokes the cleaning action.\n+     * The cleaner's cleaning action is invoked at most once,\n+     * regardless of the number of calls to {@code clean}.\n+     *\/\n+    void clean();\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/Cleaner.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import jdk.internal.ref.Cleaner;\n+import sun.nio.Cleaner;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DirectBuffer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-import jdk.internal.ref.Cleaner;\n@@ -66,0 +65,1 @@\n+import sun.nio.Cleaner;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3760,3 +3760,4 @@\n-(The names \"static\" and \"dynamic\" are used for historical reasons.\n-The only significance is that the \"static\" archive is loaded first and\n-the \"dynamic\" archive is loaded second).\n+The names \"static\" and \"dynamic\" are used for historical reasons. The dynamic\n+archive, while still useful, supports fewer optimizations than\n+available for the static CDS archive. If the full set of CDS\/AOT\n+optimizations are desired, consider using the AOT cache described below.\n","filename":"src\/java.base\/share\/man\/java.md","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -582,0 +582,1 @@\n+#ifdef USE_MMAP\n@@ -583,0 +584,1 @@\n+#endif\n@@ -607,0 +609,1 @@\n+#ifdef USE_MMAP\n@@ -608,0 +611,1 @@\n+#endif\n","filename":"src\/java.base\/share\/native\/libzip\/zip_util.c","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -359,1 +359,3 @@\n-            return target;\n+\n+            \/\/ return normalized path string\n+            return WindowsPathParser.parse(target).path();\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsLinkSupport.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -968,1 +968,1 @@\n-    int got = 0;\n+ \/\/ int got = 0;\n@@ -972,1 +972,2 @@\n-            got = getLocaleInfoWrapper(langtag,\n+         \/\/ got =\n+                  getLocaleInfoWrapper(langtag,\n@@ -976,1 +977,2 @@\n-            got = getLocaleInfoWrapper(langtag,\n+         \/\/ got =\n+                  getLocaleInfoWrapper(langtag,\n@@ -982,1 +984,2 @@\n-            got = getLocaleInfoWrapper(langtag,\n+         \/\/ got =\n+                  getLocaleInfoWrapper(langtag,\n@@ -986,1 +989,2 @@\n-            got = getLocaleInfoWrapper(langtag,\n+         \/\/ got =\n+                  getLocaleInfoWrapper(langtag,\n@@ -990,1 +994,2 @@\n-            got = getLocaleInfoWrapper(langtag,\n+         \/\/ got =\n+                  getLocaleInfoWrapper(langtag,\n","filename":"src\/java.base\/windows\/native\/libjava\/HostLocaleProviderAdapter_md.c","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-        int onlyMapID;\n+     \/\/ int onlyMapID;\n@@ -307,1 +307,1 @@\n-        onlyMapID = 0;\n+     \/\/ onlyMapID = 0;\n@@ -328,1 +328,1 @@\n-                onlyMapID = 1;\n+             \/\/ onlyMapID = 1;\n","filename":"src\/java.base\/windows\/native\/libjava\/TimeZone_md.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-static HINSTANCE lib = NULL;\n+\/\/ static HINSTANCE lib = NULL;\n","filename":"src\/java.base\/windows\/native\/libnet\/NTLMAuthSequence.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -363,2 +363,0 @@\n-filename.-monotype-timesnewromanwt-medium-r-normal--*-%d-75-75-*-*-gb2312.1980-0=\/usr\/lpp\/X11\/lib\/X11\/fonts\/TrueType\/tnrwt_s.ttf\n-filename.-monotype-wt_serif_sc-medium-r-normal--*-%d-75-75-*-*-iso10646-1=\/usr\/lpp\/X11\/lib\/X11\/fonts\/TrueType\/wt__s__b.ttf\n","filename":"src\/java.desktop\/aix\/data\/fontconfig\/fontconfig.properties","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -802,0 +802,1 @@\n+        verifyHeader(data);\n@@ -804,4 +805,0 @@\n-            byte[] theHeader = new byte[HEADER_SIZE];\n-            System.arraycopy(data, 0, theHeader, 0, HEADER_SIZE);\n-            verifyHeader(theHeader);\n-\n@@ -814,3 +811,2 @@\n-            if (getColorSpaceType(data) == ColorSpace.TYPE_GRAY\n-                    && getData(p, icSigMediaWhitePointTag) != null\n-                    && getData(p, icSigGrayTRCTag) != null) {\n+            int type = getColorSpaceType(data);\n+            if (type == ColorSpace.TYPE_GRAY) {\n@@ -818,9 +814,1 @@\n-            }\n-            if (getColorSpaceType(data) == ColorSpace.TYPE_RGB\n-                    && getData(p, icSigMediaWhitePointTag) != null\n-                    && getData(p, icSigRedColorantTag) != null\n-                    && getData(p, icSigGreenColorantTag) != null\n-                    && getData(p, icSigBlueColorantTag) != null\n-                    && getData(p, icSigRedTRCTag) != null\n-                    && getData(p, icSigGreenTRCTag) != null\n-                    && getData(p, icSigBlueTRCTag) != null) {\n+            } else if (type == ColorSpace.TYPE_RGB) {\n@@ -972,1 +960,1 @@\n-        return getData(icSigHead)[8];\n+        return getData(cmmProfile(), icSigHead)[8];\n@@ -981,1 +969,1 @@\n-        return getData(icSigHead)[9];\n+        return getData(cmmProfile(), icSigHead)[9];\n@@ -994,1 +982,1 @@\n-        byte[] theHeader = getData(icSigHead);\n+        byte[] theHeader = getData(cmmProfile(), icSigHead);\n@@ -998,2 +986,2 @@\n-    private static int getProfileClass(byte[] theHeader) {\n-        int theClassSig = intFromBigEndian(theHeader, icHdrDeviceClass);\n+    private static int getProfileClass(byte[] data) {\n+        int theClassSig = intFromBigEndian(data, icHdrDeviceClass);\n@@ -1035,2 +1023,2 @@\n-    private static int getColorSpaceType(byte[] theHeader) {\n-        int theColorSpaceSig = intFromBigEndian(theHeader, icHdrColorSpace);\n+    private static int getColorSpaceType(byte[] data) {\n+        int theColorSpaceSig = intFromBigEndian(data, icHdrColorSpace);\n@@ -1054,1 +1042,1 @@\n-        byte[] theHeader = getData(icSigHead);\n+        byte[] theHeader = getData(cmmProfile(), icSigHead);\n@@ -1058,3 +1046,3 @@\n-    private static int getPCSType(byte[] theHeader) {\n-        int thePCSSig = intFromBigEndian(theHeader, icHdrPcs);\n-        int theDeviceClass = intFromBigEndian(theHeader, icHdrDeviceClass);\n+    private static int getPCSType(byte[] data) {\n+        int thePCSSig = intFromBigEndian(data, icHdrPcs);\n+        int theDeviceClass = intFromBigEndian(data, icHdrDeviceClass);\n@@ -1123,6 +1111,1 @@\n-        byte[] t = getData(cmmProfile(), tagSignature);\n-        return t != null ? t.clone() : null;\n-    }\n-\n-    private static byte[] getData(Profile p, int tagSignature) {\n-            return CMSManager.getModule().getTagData(p, tagSignature);\n+            return getData(cmmProfile(), tagSignature).clone();\n@@ -1135,0 +1118,14 @@\n+    \/**\n+     * Returns a particular tagged data element from the profile as a non-null\n+     * byte array. The returned byte array is not cloned. It must not be exposed\n+     * to or used by public APIs. It is intended strictly for internal use only.\n+     *\n+     * @param  p the CMM profile from which to retrieve the tag data\n+     * @param  tagSignature the ICC tag signature for the data to retrieve\n+     * @return a non-null byte array containing the tag data\n+     * @throws CMMException if the specified tag doesn't exist\n+     *\/\n+    static byte[] getData(Profile p, int tagSignature) {\n+        return CMSManager.getModule().getTagData(p, tagSignature);\n+    }\n+\n@@ -1186,1 +1183,1 @@\n-    private static void checkRenderingIntent(byte[] header) {\n+    private static void checkRenderingIntent(byte[] data) {\n@@ -1194,1 +1191,1 @@\n-        int intent = (header[index + 2] & 0xff) << 8 | header[index + 3] & 0xff;\n+        int intent = (data[index + 2] & 0xff) << 8 | data[index + 3] & 0xff;\n@@ -1215,1 +1212,1 @@\n-        byte[] theHeader = getData(icSigHead);\n+        byte[] theHeader = getData(cmmProfile(), icSigHead);\n@@ -1254,1 +1251,1 @@\n-        byte[] theData = getData(tagSignature);\n+        byte[] theData = getData(cmmProfile(), tagSignature);\n@@ -1278,1 +1275,1 @@\n-        byte[] theTRCData = getData(tagSignature);\n+        byte[] theTRCData = getData(cmmProfile(), tagSignature);\n@@ -1309,1 +1306,1 @@\n-        byte[] theTRCData = getData(tagSignature);\n+        byte[] theTRCData = getData(cmmProfile(), tagSignature);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_Profile.java","additions":36,"deletions":39,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,4 @@\n-     * Constructs a new {@code ICC_ProfileGray} from a CMM ID.\n+     * Constructs a new {@code ICC_ProfileGray} from the specified CMM profile.\n+     *\n+     * @param  p the CMM profile used to create this ICC profile\n+     * @throws CMMException if the required tags are missing\n@@ -81,0 +84,2 @@\n+        getData(p, icSigMediaWhitePointTag);\n+        getData(p, icSigGrayTRCTag);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_ProfileGray.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,1 +107,1 @@\n-     * Constructs an new {@code ICC_ProfileRGB} from a CMM ID.\n+     * Constructs a new {@code ICC_ProfileRGB} from the specified CMM profile.\n@@ -109,1 +109,2 @@\n-     * @param  p the CMM ID for the profile.\n+     * @param  p the CMM profile used to create this ICC profile\n+     * @throws CMMException if the required tags are missing\n@@ -113,0 +114,7 @@\n+        getData(p, icSigMediaWhitePointTag);\n+        getData(p, icSigRedColorantTag);\n+        getData(p, icSigGreenColorantTag);\n+        getData(p, icSigBlueColorantTag);\n+        getData(p, icSigRedTRCTag);\n+        getData(p, icSigGreenTRCTag);\n+        getData(p, icSigBlueTRCTag);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_ProfileRGB.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,2 @@\n+import static sun.java2d.pipe.Region.clipRound;\n+\n@@ -164,1 +166,1 @@\n-            int offs = this.thickness * (int) scaleFactor;\n+            int offs = clipRound(this.thickness * scaleFactor);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/border\/LineBorder.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -411,1 +411,1 @@\n-     * of currency, if the model supports being updated asynchronously.\n+     * of concurrency, if the model supports being updated asynchronously.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/AbstractDocument.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2501,15 +2501,2 @@\n-    \/\/ It's entirely possible that our native resources have been destroyed\n-    \/\/ before our java peer - if we're dispose()d, for instance.\n-    \/\/ Alert caller w\/ IllegalComponentStateException.\n-    if (self == NULL) {\n-        JNU_ThrowByName(env, \"java\/awt\/IllegalComponentStateException\",\n-                        \"Peer null in JNI\");\n-        return 0;\n-    }\n-    PDATA pData = JNI_GET_PDATA(self);\n-    if (pData == NULL) {\n-        JNU_ThrowByName(env, \"java\/awt\/IllegalComponentStateException\",\n-                        \"Native resources unavailable\");\n-        env->DeleteGlobalRef(self);\n-        return 0;\n-    }\n+    jint result = -1;\n+    AwtWindow* window = NULL;\n@@ -2517,3 +2504,6 @@\n-    jint result = 0;\n-    AwtWindow *w = (AwtWindow *)pData;\n-    if (::IsWindow(w->GetHWnd()))\n+    \/\/ Our native resources may have been destroyed before the Java peer,\n+    \/\/ e.g., if dispose() was called. In that case, return the default screen.\n+    PDATA pData;\n+    JNI_CHECK_PEER_GOTO(self, ret);\n+    window = (AwtWindow *)pData;\n+    if (::IsWindow(window->GetHWnd()))\n@@ -2521,1 +2511,1 @@\n-        result = (jint)w->GetScreenImOn();\n+        result = (jint)window->GetScreenImOn();\n@@ -2524,0 +2514,1 @@\n+  ret:\n@@ -2525,2 +2516,1 @@\n-\n-    return result;\n+    return (result != -1) ? result : AwtWin32GraphicsDevice::GetDefaultDeviceIndex();\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Window.cpp","additions":11,"deletions":21,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import java.util.function.Function;\n@@ -44,1 +43,0 @@\n-import jdk.internal.net.http.common.TimeSource;\n@@ -60,1 +58,0 @@\n-    private volatile int unsuccessfulAttempts;\n@@ -64,6 +61,0 @@\n-    \/\/ Indicates whether a connection attempt has succeeded or should be retried.\n-    \/\/ If the attempt failed, and shouldn't be retried, there will be an exception\n-    \/\/ instead.\n-    private enum ConnectState { SUCCESS, RETRY }\n-\n-\n@@ -118,1 +109,1 @@\n-        private final CompletableFuture<ConnectState> cf;\n+        private final CompletableFuture<Void> cf;\n@@ -121,1 +112,1 @@\n-        ConnectEvent(CompletableFuture<ConnectState> cf, Exchange<?> exchange) {\n+        ConnectEvent(CompletableFuture<Void> cf, Exchange<?> exchange) {\n@@ -150,1 +141,2 @@\n-                    cf.completeAsync(() -> ConnectState.SUCCESS, client().theExecutor());\n+                    if (debug.on()) debug.log(\"%s has been connected asynchronously\", label());\n+                    cf.completeAsync(() -> null, client().theExecutor());\n@@ -153,6 +145,0 @@\n-                if (canRetryConnect(e)) {\n-                    unsuccessfulAttempts++;\n-                    \/\/ complete async since the event runs on the SelectorManager thread\n-                    cf.completeAsync(() -> ConnectState.RETRY, client().theExecutor());\n-                    return;\n-                }\n@@ -177,1 +163,1 @@\n-        CompletableFuture<ConnectState> cf = new MinimalFuture<>();\n+        CompletableFuture<Void> cf = new MinimalFuture<>();\n@@ -215,1 +201,2 @@\n-                    cf.complete(ConnectState.SUCCESS);\n+                    if (debug.on()) debug.log(\"%s has been connected\", label());\n+                    cf.complete(null);\n@@ -235,2 +222,1 @@\n-        return cf.handle((r,t) -> checkRetryConnect(r, t, exchange))\n-                .thenCompose(Function.identity());\n+        return cf;\n@@ -257,36 +243,0 @@\n-    \/**\n-     * On some platforms, a ConnectEvent may be raised and a ConnectionException\n-     * may occur with the message \"Connection timed out: no further information\"\n-     * before our actual connection timeout has expired. In this case, this\n-     * method will be called with a {@code connect} state of {@code ConnectState.RETRY)}\n-     * and we will retry once again.\n-     * @param connect indicates whether the connection was successful or should be retried\n-     * @param failed the failure if the connection failed\n-     * @param exchange the exchange\n-     * @return a completable future that will take care of retrying the connection if needed.\n-     *\/\n-    private CompletableFuture<Void> checkRetryConnect(ConnectState connect, Throwable failed, Exchange<?> exchange) {\n-        \/\/ first check if the connection failed\n-        if (failed != null) return MinimalFuture.failedFuture(failed);\n-        \/\/ then check if the connection should be retried\n-        if (connect == ConnectState.RETRY) {\n-            int attempts = unsuccessfulAttempts;\n-            assert attempts <= 1;\n-            if (debug.on())\n-                debug.log(\"Retrying connect after %d attempts\", attempts);\n-            return connectAsync(exchange);\n-        }\n-        \/\/ Otherwise, the connection was successful;\n-        assert connect == ConnectState.SUCCESS;\n-        return MinimalFuture.completedFuture(null);\n-    }\n-\n-    private boolean canRetryConnect(Throwable e) {\n-        if (!MultiExchange.RETRY_CONNECT) return false;\n-        if (!(e instanceof ConnectException)) return false;\n-        if (unsuccessfulAttempts > 0) return false;\n-        ConnectTimerEvent timer = connectTimerEvent;\n-        if (timer == null) return true;\n-        return timer.deadline().isAfter(TimeSource.now());\n-    }\n-\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainHttpConnection.java","additions":8,"deletions":58,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Map;\n@@ -85,1 +86,1 @@\n-public interface Connection  extends Wrapper, AutoCloseable {\n+public interface Connection extends Wrapper, AutoCloseable {\n@@ -139,2 +140,1 @@\n-    PreparedStatement prepareStatement(String sql)\n-        throws SQLException;\n+    PreparedStatement prepareStatement(String sql) throws SQLException;\n@@ -501,1 +501,0 @@\n-\n@@ -532,2 +531,1 @@\n-    Statement createStatement(int resultSetType, int resultSetConcurrency)\n-        throws SQLException;\n+    Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException;\n@@ -629,1 +627,1 @@\n-    java.util.Map<String,Class<?>> getTypeMap() throws SQLException;\n+    Map<String, Class<?>> getTypeMap() throws SQLException;\n@@ -657,1 +655,1 @@\n-    void setTypeMap(java.util.Map<String,Class<?>> map) throws SQLException;\n+    void setTypeMap(Map<String, Class<?>> map) throws SQLException;\n@@ -661,1 +659,0 @@\n-\n@@ -897,1 +894,0 @@\n-\n@@ -940,2 +936,1 @@\n-    PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)\n-        throws SQLException;\n+    PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException;\n@@ -988,2 +983,1 @@\n-    PreparedStatement prepareStatement(String sql, int columnIndexes[])\n-        throws SQLException;\n+    PreparedStatement prepareStatement(String sql, int columnIndexes[]) throws SQLException;\n@@ -1036,2 +1030,1 @@\n-    PreparedStatement prepareStatement(String sql, String columnNames[])\n-        throws SQLException;\n+    PreparedStatement prepareStatement(String sql, String columnNames[]) throws SQLException;\n@@ -1102,81 +1095,80 @@\n-        \/**\n-         * Returns true if the connection has not been closed and is still valid.\n-         * The driver shall submit a query on the connection or use some other\n-         * mechanism that positively verifies the connection is still valid when\n-         * this method is called.\n-         * <p>\n-         * The query submitted by the driver to validate the connection shall be\n-         * executed in the context of the current transaction.\n-         *\n-         * @param timeout The time in seconds to wait for the database operation\n-         *                used to validate the connection to complete.  If the\n-         *                timeout period expires before the operationcompletes,\n-         *                this method returns false.  A value of 0 indicates a\n-         *                timeout is not applied to the database operation.\n-         *\n-         * @return true if the connection is valid, false otherwise\n-         * @throws SQLException if the value supplied for {@code timeout}\n-         * is less than 0\n-         * @since 1.6\n-         *\n-         * @see java.sql.DatabaseMetaData#getClientInfoProperties\n-         *\/\n-         boolean isValid(int timeout) throws SQLException;\n-\n-        \/**\n-         * Sets the value of the client info property specified by name to the\n-         * value specified by value.\n-         * <p>\n-         * Applications may use the {@code DatabaseMetaData.getClientInfoProperties}\n-         * method to determine the client info properties supported by the driver\n-         * and the maximum length that may be specified for each property.\n-         * <p>\n-         * The driver stores the value specified in a suitable location in the\n-         * database.  For example in a special register, session parameter, or\n-         * system table column.  For efficiency the driver may defer setting the\n-         * value in the database until the next time a statement is executed or\n-         * prepared.  Other than storing the client information in the appropriate\n-         * place in the database, these methods shall not alter the behavior of\n-         * the connection in anyway.  The values supplied to these methods are\n-         * used for accounting, diagnostics and debugging purposes only.\n-         * <p>\n-         * The driver shall generate a warning if the client info name specified\n-         * is not recognized by the driver.\n-         * <p>\n-         * If the value specified to this method is greater than the maximum\n-         * length for the property the driver may either truncate the value and\n-         * generate a warning or generate a {@code SQLClientInfoException}.  If the driver\n-         * generates a {@code SQLClientInfoException}, the value specified was not set on the\n-         * connection.\n-         * <p>\n-         * The following are standard client info properties.  Drivers are not\n-         * required to support these properties however if the driver supports a\n-         * client info property that can be described by one of the standard\n-         * properties, the standard property name should be used.\n-         *\n-         * <ul>\n-         * <li>ApplicationName  -       The name of the application currently utilizing\n-         *                                                      the connection<\/li>\n-         * <li>ClientUser               -       The name of the user that the application using\n-         *                                                      the connection is performing work for.  This may\n-         *                                                      not be the same as the user name that was used\n-         *                                                      in establishing the connection.<\/li>\n-         * <li>ClientHostname   -       The hostname of the computer the application\n-         *                                                      using the connection is running on.<\/li>\n-         * <\/ul>\n-         *\n-         * @param name          The name of the client info property to set\n-         * @param value         The value to set the client info property to.  If the\n-         *                                      value is null, the current value of the specified\n-         *                                      property is cleared.\n-         *\n-         * @throws      SQLClientInfoException if the database server returns an error while\n-         *                      setting the client info value on the database server or this method\n-         * is called on a closed connection\n-         *\n-         * @since 1.6\n-         *\/\n-         void setClientInfo(String name, String value)\n-                throws SQLClientInfoException;\n-\n-        \/**\n+    \/**\n+     * Returns true if the connection has not been closed and is still valid.\n+     * The driver shall submit a query on the connection or use some other\n+     * mechanism that positively verifies the connection is still valid when\n+     * this method is called.\n+     * <p>\n+     * The query submitted by the driver to validate the connection shall be\n+     * executed in the context of the current transaction.\n+     *\n+     * @param timeout The time in seconds to wait for the database operation\n+     *                used to validate the connection to complete.  If the\n+     *                timeout period expires before the operationcompletes,\n+     *                this method returns false.  A value of 0 indicates a\n+     *                timeout is not applied to the database operation.\n+     *\n+     * @return true if the connection is valid, false otherwise\n+     * @throws SQLException if the value supplied for {@code timeout}\n+     * is less than 0\n+     * @since 1.6\n+     *\n+     * @see java.sql.DatabaseMetaData#getClientInfoProperties\n+     *\/\n+    boolean isValid(int timeout) throws SQLException;\n+\n+    \/**\n+     * Sets the value of the client info property specified by name to the\n+     * value specified by value.\n+     * <p>\n+     * Applications may use the {@code DatabaseMetaData.getClientInfoProperties}\n+     * method to determine the client info properties supported by the driver\n+     * and the maximum length that may be specified for each property.\n+     * <p>\n+     * The driver stores the value specified in a suitable location in the\n+     * database.  For example in a special register, session parameter, or\n+     * system table column.  For efficiency the driver may defer setting the\n+     * value in the database until the next time a statement is executed or\n+     * prepared.  Other than storing the client information in the appropriate\n+     * place in the database, these methods shall not alter the behavior of\n+     * the connection in anyway.  The values supplied to these methods are\n+     * used for accounting, diagnostics and debugging purposes only.\n+     * <p>\n+     * The driver shall generate a warning if the client info name specified\n+     * is not recognized by the driver.\n+     * <p>\n+     * If the value specified to this method is greater than the maximum\n+     * length for the property the driver may either truncate the value and\n+     * generate a warning or generate a {@code SQLClientInfoException}.  If the driver\n+     * generates a {@code SQLClientInfoException}, the value specified was not set on the\n+     * connection.\n+     * <p>\n+     * The following are standard client info properties.  Drivers are not\n+     * required to support these properties however if the driver supports a\n+     * client info property that can be described by one of the standard\n+     * properties, the standard property name should be used.\n+     *\n+     * <ul>\n+     * <li>ApplicationName -       The name of the application currently utilizing\n+     *                                                      the connection<\/li>\n+     * <li>ClientUser      -       The name of the user that the application using\n+     *                                                      the connection is performing work for.  This may\n+     *                                                      not be the same as the user name that was used\n+     *                                                      in establishing the connection.<\/li>\n+     * <li>ClientHostname  -       The hostname of the computer the application\n+     *                                                      using the connection is running on.<\/li>\n+     * <\/ul>\n+     *\n+     * @param name          The name of the client info property to set\n+     * @param value         The value to set the client info property to.  If the\n+     *                                      value is null, the current value of the specified\n+     *                                      property is cleared.\n+     *\n+     * @throws      SQLClientInfoException if the database server returns an error while\n+     *                      setting the client info value on the database server or this method\n+     * is called on a closed connection\n+     *\n+     * @since 1.6\n+     *\/\n+    void setClientInfo(String name, String value) throws SQLClientInfoException;\n+\n+    \/**\n@@ -1212,45 +1204,1 @@\n-         void setClientInfo(Properties properties)\n-                throws SQLClientInfoException;\n-\n-        \/**\n-         * Returns the value of the client info property specified by name.  This\n-         * method may return null if the specified client info property has not\n-         * been set and does not have a default value.  This method will also\n-         * return null if the specified client info property name is not supported\n-         * by the driver.\n-         * <p>\n-         * Applications may use the {@code DatabaseMetaData.getClientInfoProperties}\n-         * method to determine the client info properties supported by the driver.\n-         *\n-         * @param name          The name of the client info property to retrieve\n-         *\n-         * @return                      The value of the client info property specified\n-         *\n-         * @throws SQLException         if the database server returns an error when\n-         *                              fetching the client info value from the database\n-         *                              or this method is called on a closed connection\n-         *\n-         * @since 1.6\n-         *\n-         * @see java.sql.DatabaseMetaData#getClientInfoProperties\n-         *\/\n-         String getClientInfo(String name)\n-                throws SQLException;\n-\n-        \/**\n-         * Returns a list containing the name and current value of each client info\n-         * property supported by the driver.  The value of a client info property\n-         * may be null if the property has not been set and does not have a\n-         * default value.\n-         *\n-         * @return      A {@code Properties} object that contains the name and current value of\n-         *                      each of the client info properties supported by the driver.\n-         *\n-         * @throws      SQLException if the database server returns an error when\n-         *                      fetching the client info values from the database\n-         * or this method is called on a closed connection\n-         *\n-         * @since 1.6\n-         *\/\n-         Properties getClientInfo()\n-                throws SQLException;\n+    void setClientInfo(Properties properties) throws SQLClientInfoException;\n@@ -1258,28 +1206,23 @@\n-\/**\n-  * Factory method for creating Array objects.\n-  *<p>\n-  * <b>Note: <\/b>When {@code createArrayOf} is used to create an array object\n-  * that maps to a primitive data type, then it is implementation-defined\n-  * whether the {@code Array} object is an array of that primitive\n-  * data type or an array of {@code Object}.\n-  * <p>\n-  * <b>Note: <\/b>The JDBC driver is responsible for mapping the elements\n-  * {@code Object} array to the default JDBC SQL type defined in\n-  * java.sql.Types for the given class of {@code Object}. The default\n-  * mapping is specified in Appendix B of the JDBC specification.  If the\n-  * resulting JDBC type is not the appropriate type for the given typeName then\n-  * it is implementation defined whether an {@code SQLException} is\n-  * thrown or the driver supports the resulting conversion.\n-  *\n-  * @param typeName the SQL name of the type the elements of the array map to. The typeName is a\n-  * database-specific name which may be the name of a built-in type, a user-defined type or a standard  SQL type supported by this database. This\n-  *  is the value returned by {@code Array.getBaseTypeName}\n-  * @param elements the elements that populate the returned object\n-  * @return an Array object whose elements map to the specified SQL type\n-  * @throws SQLException if a database error occurs, the JDBC type is not\n-  *  appropriate for the typeName and the conversion is not supported, the typeName is null or this method is called on a closed connection\n-  * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this data type\n-  * @since 1.6\n-  *\/\n- Array createArrayOf(String typeName, Object[] elements) throws\n-SQLException;\n+    \/**\n+     * Returns the value of the client info property specified by name.  This\n+     * method may return null if the specified client info property has not\n+     * been set and does not have a default value.  This method will also\n+     * return null if the specified client info property name is not supported\n+     * by the driver.\n+     * <p>\n+     * Applications may use the {@code DatabaseMetaData.getClientInfoProperties}\n+     * method to determine the client info properties supported by the driver.\n+     *\n+     * @param name          The name of the client info property to retrieve\n+     *\n+     * @return                      The value of the client info property specified\n+     *\n+     * @throws SQLException         if the database server returns an error when\n+     *                              fetching the client info value from the database\n+     *                              or this method is called on a closed connection\n+     *\n+     * @since 1.6\n+     *\n+     * @see java.sql.DatabaseMetaData#getClientInfoProperties\n+     *\/\n+    String getClientInfo(String name) throws SQLException;\n@@ -1287,16 +1230,60 @@\n-\/**\n-  * Factory method for creating Struct objects.\n-  *\n-  * @param typeName the SQL type name of the SQL structured type that this {@code Struct}\n-  * object maps to. The typeName is the name of  a user-defined type that\n-  * has been defined for this database. It is the value returned by\n-  * {@code Struct.getSQLTypeName}.\n-\n-  * @param attributes the attributes that populate the returned object\n-  * @return a Struct object that maps to the given SQL type and is populated with the given attributes\n-  * @throws SQLException if a database error occurs, the typeName is null or this method is called on a closed connection\n-  * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this data type\n-  * @since 1.6\n-  *\/\n- Struct createStruct(String typeName, Object[] attributes)\n-throws SQLException;\n+    \/**\n+     * Returns a list containing the name and current value of each client info\n+     * property supported by the driver.  The value of a client info property\n+     * may be null if the property has not been set and does not have a\n+     * default value.\n+     *\n+     * @return      A {@code Properties} object that contains the name and current value of\n+     *                      each of the client info properties supported by the driver.\n+     *\n+     * @throws      SQLException if the database server returns an error when\n+     *                      fetching the client info values from the database\n+     * or this method is called on a closed connection\n+     *\n+     * @since 1.6\n+     *\/\n+    Properties getClientInfo() throws SQLException;\n+\n+    \/**\n+     * Factory method for creating Array objects.\n+     * <p>\n+     * <b>Note: <\/b>When {@code createArrayOf} is used to create an array object\n+     * that maps to a primitive data type, then it is implementation-defined\n+     * whether the {@code Array} object is an array of that primitive\n+     * data type or an array of {@code Object}.\n+     * <p>\n+     * <b>Note: <\/b>The JDBC driver is responsible for mapping the elements\n+     * {@code Object} array to the default JDBC SQL type defined in\n+     * java.sql.Types for the given class of {@code Object}. The default\n+     * mapping is specified in Appendix B of the JDBC specification.  If the\n+     * resulting JDBC type is not the appropriate type for the given typeName then\n+     * it is implementation defined whether an {@code SQLException} is\n+     * thrown or the driver supports the resulting conversion.\n+     *\n+     * @param typeName the SQL name of the type the elements of the array map to. The typeName is a\n+     * database-specific name which may be the name of a built-in type, a user-defined type or a standard  SQL type supported by this database. This\n+     *  is the value returned by {@code Array.getBaseTypeName}\n+     * @param elements the elements that populate the returned object\n+     * @return an Array object whose elements map to the specified SQL type\n+     * @throws SQLException if a database error occurs, the JDBC type is not\n+     *  appropriate for the typeName and the conversion is not supported, the typeName is null or this method is called on a closed connection\n+     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this data type\n+     * @since 1.6\n+     *\/\n+    Array createArrayOf(String typeName, Object[] elements) throws SQLException;\n+\n+    \/**\n+     * Factory method for creating Struct objects.\n+     *\n+     * @param typeName the SQL type name of the SQL structured type that this {@code Struct}\n+     * object maps to. The typeName is the name of  a user-defined type that\n+     * has been defined for this database. It is the value returned by\n+     * {@code Struct.getSQLTypeName}.\n+     *\n+     * @param attributes the attributes that populate the returned object\n+     * @return a Struct object that maps to the given SQL type and is populated with the given attributes\n+     * @throws SQLException if a database error occurs, the typeName is null or this method is called on a closed connection\n+     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this data type\n+     * @since 1.6\n+     *\/\n+    Struct createStruct(String typeName, Object[] attributes) throws SQLException;\n@@ -1466,1 +1453,1 @@\n-     \/**\n+    \/**\n@@ -1537,1 +1524,1 @@\n-     *<p>\n+     * <p>\n@@ -1568,1 +1555,1 @@\n-            \/\/ Default method takes no action\n+        \/\/ Default method takes no action\n@@ -1689,2 +1676,1 @@\n-    default void setShardingKey(ShardingKey shardingKey)\n-            throws SQLException {\n+    default void setShardingKey(ShardingKey shardingKey) throws SQLException {\n@@ -1693,0 +1679,1 @@\n+\n","filename":"src\/java.sql\/share\/classes\/java\/sql\/Connection.java","additions":179,"deletions":192,"binary":false,"changes":371,"status":"modified"},{"patch":"@@ -275,2 +275,0 @@\n-                Check.instance(this).clear(); \/\/clear mandatory warning handlers\n-                Preview.instance(this).clear(); \/\/clear mandatory warning handlers\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTaskPool.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -253,1 +253,1 @@\n-    public static final long DEFAULT = 1L<<43;\n+    public static final long DEFAULT = 1L<<43; \/\/ part of ExtendedStandardFlags, cannot be reused\n@@ -281,2 +281,2 @@\n-    \/*\n-     * Currently available: Bit 48.\n+    \/**\n+     * Flag to indicate sealed class\/interface declaration.\n@@ -284,0 +284,1 @@\n+    public static final long SEALED = 1L<<48; \/\/ part of ExtendedStandardFlags, cannot be reused\n@@ -392,5 +393,0 @@\n-    \/**\n-     * Flag to indicate sealed class\/interface declaration.\n-     *\/\n-    public static final long SEALED = 1L<<62; \/\/ ClassSymbols\n-\n@@ -415,1 +411,1 @@\n-    public static final long NON_SEALED = 1L<<63; \/\/ ClassSymbols\n+    public static final long NON_SEALED = 1L<<63;  \/\/ part of ExtendedStandardFlags, cannot be reused\n@@ -446,0 +442,1 @@\n+        \/\/NOTE: flags in ExtendedStandardFlags cannot be overlayed across Symbol kinds:\n@@ -553,1 +550,1 @@\n-        \/\/ Bit 48 is currently available\n+        SEALED(Flags.SEALED),\n@@ -562,1 +559,1 @@\n-        SEALED(Flags.SEALED),\n+        RESTRICTED(Flags.RESTRICTED),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -533,1 +533,3 @@\n-            Optional.of((String)((Attribute.Constant)value).value)\n+            Optional.of(value)\n+              .filter(val -> val instanceof Attribute.Constant)\n+              .map(val -> (String) ((Attribute.Constant) val).value)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import com.sun.tools.javac.util.MandatoryWarningHandler;\n@@ -74,3 +73,0 @@\n-    \/** the diag handler to manage preview feature usage diagnostics *\/\n-    private final MandatoryWarningHandler previewHandler;\n-\n@@ -108,1 +104,0 @@\n-        previewHandler = new MandatoryWarningHandler(log, source, verbose, true, LintCategory.PREVIEW);\n@@ -179,1 +174,2 @@\n-        previewHandler.report(pos, feature.isPlural() ?\n+        log.mandatoryWarning(pos,\n+            feature.isPlural() ?\n@@ -206,4 +202,0 @@\n-    public void reportPreviewWarning(DiagnosticPosition pos, LintWarning warnKey) {\n-        previewHandler.report(pos, warnKey);\n-    }\n-\n@@ -272,11 +264,0 @@\n-    \/**\n-     * Report any deferred diagnostics.\n-     *\/\n-    public void reportDeferredDiagnostics() {\n-        previewHandler.reportDeferredDiagnostic();\n-    }\n-\n-    public void clear() {\n-        previewHandler.clear();\n-    }\n-\n@@ -286,1 +267,1 @@\n-            log.error(JCDiagnostic.DiagnosticFlag.SOURCE_LEVEL, pos, disabledError(feature));\n+            log.error(pos, disabledError(feature));\n@@ -289,2 +270,1 @@\n-                log.error(JCDiagnostic.DiagnosticFlag.SOURCE_LEVEL, pos,\n-                          feature.error(source.name));\n+                log.error(pos, feature.error(source.name));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":4,"deletions":24,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;\n@@ -1240,2 +1239,2 @@\n-                \/\/ Start of constructor prologue\n-                localEnv.info.ctorPrologue = isConstructor;\n+                \/\/ Start of constructor prologue (if not in java.lang.Object constructor)\n+                localEnv.info.ctorPrologue = isConstructor && owner.type != syms.objectType;\n@@ -2837,1 +2836,1 @@\n-            if (cdef == null && !isSpeculativeDiamondInferenceRound && \/\/ class body may be nulled out in speculative tree copy\n+            if (cdef == null && !tree.classDeclRemoved() && !isSpeculativeDiamondInferenceRound && \/\/ class body may be nulled out in speculative tree copy\n@@ -4149,2 +4148,1 @@\n-                    log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n-                              Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF.error(this.sourceName));\n+                    log.error(tree.pos(), Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF.error(this.sourceName));\n@@ -4170,2 +4168,1 @@\n-                    log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n-                            Feature.REIFIABLE_TYPES_INSTANCEOF.error(this.sourceName));\n+                    log.error(tree.pos(), Feature.REIFIABLE_TYPES_INSTANCEOF.error(this.sourceName));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -167,12 +167,0 @@\n-        boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);\n-        boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);\n-        boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);\n-        boolean enforceMandatoryWarnings = true;\n-\n-        deprecationHandler = new MandatoryWarningHandler(log, null, verboseDeprecated,\n-                enforceMandatoryWarnings, LintCategory.DEPRECATION, \"deprecated\");\n-        removalHandler = new MandatoryWarningHandler(log, null, verboseRemoval,\n-                enforceMandatoryWarnings, LintCategory.REMOVAL);\n-        uncheckedHandler = new MandatoryWarningHandler(log, null, verboseUnchecked,\n-                enforceMandatoryWarnings, LintCategory.UNCHECKED);\n-\n@@ -195,12 +183,0 @@\n-    \/** A handler for messages about deprecated usage.\n-     *\/\n-    private MandatoryWarningHandler deprecationHandler;\n-\n-    \/** A handler for messages about deprecated-for-removal usage.\n-     *\/\n-    private MandatoryWarningHandler removalHandler;\n-\n-    \/** A handler for messages about unchecked or unsafe usage.\n-     *\/\n-    private MandatoryWarningHandler uncheckedHandler;\n-\n@@ -256,0 +232,1 @@\n+        LintWarning warningKey = null;\n@@ -259,1 +236,1 @@\n-                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemovalModule(sym));\n+                    warningKey = LintWarnings.HasBeenDeprecatedForRemovalModule(sym);\n@@ -261,1 +238,1 @@\n-                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location()));\n+                    warningKey = LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location());\n@@ -266,1 +243,1 @@\n-                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecatedModule(sym));\n+                warningKey = LintWarnings.HasBeenDeprecatedModule(sym);\n@@ -268,1 +245,1 @@\n-                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecated(sym, sym.location()));\n+                warningKey = LintWarnings.HasBeenDeprecated(sym, sym.location());\n@@ -271,0 +248,2 @@\n+        if (warningKey != null)\n+            log.mandatoryWarning(pos, warningKey);\n@@ -279,1 +258,1 @@\n-            preview.reportPreviewWarning(pos, warnKey);\n+            log.mandatoryWarning(pos, warnKey);\n@@ -296,1 +275,1 @@\n-            uncheckedHandler.report(pos, warnKey);\n+            log.mandatoryWarning(pos, warnKey);\n@@ -299,10 +278,0 @@\n-    \/**\n-     * Report any deferred diagnostics.\n-     *\/\n-    public void reportDeferredDiagnostics() {\n-        deprecationHandler.reportDeferredDiagnostic();\n-        removalHandler.reportDeferredDiagnostic();\n-        uncheckedHandler.reportDeferredDiagnostic();\n-    }\n-\n-\n@@ -314,1 +283,1 @@\n-        log.error(JCDiagnostic.DiagnosticFlag.NON_DEFERRABLE, pos, Errors.CantAccess(ex.sym, ex.getDetailValue()));\n+        log.error(DiagnosticFlag.NON_DEFERRABLE, pos, Errors.CantAccess(ex.sym, ex.getDetailValue()));\n@@ -477,6 +446,0 @@\n-    public void clear() {\n-        deprecationHandler.clear();\n-        removalHandler.clear();\n-        uncheckedHandler.clear();\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":10,"deletions":47,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2834,1 +2834,2 @@\n-            JCExpression exactnessCheck = null;\n+            JCStatement prefixStatement;\n+            JCExpression exactnessCheck;\n@@ -2837,8 +2838,2 @@\n-            \/\/ preserving the side effects of the value\n-            VarSymbol dollar_s = new VarSymbol(FINAL | SYNTHETIC,\n-                    names.fromString(\"tmp\" + variableIndex++ + this.target.syntheticNameChar()),\n-                    types.erasure(tree.expr.type),\n-                    currentMethodSym);\n-            JCStatement var = make.at(tree.pos())\n-                    .VarDef(dollar_s, instanceOfExpr);\n-\n+                \/\/ instanceOfExpr; true\n+                prefixStatement = make.Exec(instanceOfExpr);\n@@ -2847,7 +2842,5 @@\n-            }\n-            else if (tree.expr.type.isReference()) {\n-                JCExpression nullCheck =\n-                        makeBinary(NE,\n-                            make.Ident(dollar_s),\n-                            makeNull());\n-\n+            } else if (tree.expr.type.isPrimitive()) {\n+                \/\/ ExactConversionSupport.isXxxExact(instanceOfExpr)\n+                prefixStatement = null;\n+                exactnessCheck = getExactnessCheck(tree, instanceOfExpr);\n+            } else if (tree.expr.type.isReference()) {\n@@ -2855,6 +2848,3 @@\n-                    exactnessCheck = nullCheck;\n-                } else if (types.unboxedType(tree.expr.type).isPrimitive()) {\n-                    exactnessCheck =\n-                        makeBinary(AND,\n-                            nullCheck,\n-                            getExactnessCheck(tree, boxIfNeeded(make.Ident(dollar_s), types.unboxedType(tree.expr.type))));\n+                    \/\/ instanceOfExpr != null\n+                    prefixStatement = null;\n+                    exactnessCheck = makeBinary(NE, instanceOfExpr, makeNull());\n@@ -2862,6 +2852,26 @@\n-                    exactnessCheck =\n-                        makeBinary(AND,\n-                            nullCheck,\n-                            make.at(tree.pos())\n-                                .TypeTest(make.Ident(dollar_s), make.Type(types.boxedClass(tree.pattern.type).type))\n-                                .setType(syms.booleanType));\n+                    \/\/ We read the result of instanceOfExpr, so create variable\n+                    VarSymbol dollar_s = new VarSymbol(FINAL | SYNTHETIC,\n+                            names.fromString(\"tmp\" + variableIndex++ + this.target.syntheticNameChar()),\n+                            types.erasure(tree.expr.type),\n+                            currentMethodSym);\n+                    prefixStatement = make.at(tree.pos())\n+                            .VarDef(dollar_s, instanceOfExpr);\n+\n+                    JCExpression nullCheck =\n+                            makeBinary(NE,\n+                                    make.Ident(dollar_s),\n+                                    makeNull());\n+\n+                    if (types.unboxedType(tree.expr.type).isPrimitive()) {\n+                        exactnessCheck =\n+                            makeBinary(AND,\n+                                nullCheck,\n+                                getExactnessCheck(tree, boxIfNeeded(make.Ident(dollar_s), types.unboxedType(tree.expr.type))));\n+                    } else {\n+                        exactnessCheck =\n+                            makeBinary(AND,\n+                                nullCheck,\n+                                make.at(tree.pos())\n+                                    .TypeTest(make.Ident(dollar_s), make.Type(types.boxedClass(tree.pattern.type).type))\n+                                    .setType(syms.booleanType));\n+                    }\n@@ -2869,0 +2879,2 @@\n+            } else {\n+                throw Assert.error(\"Non primitive or reference type: \" + tree.expr.type);\n@@ -2870,5 +2882,1 @@\n-            else if (tree.expr.type.isPrimitive()) {\n-                exactnessCheck = getExactnessCheck(tree, make.Ident(dollar_s));\n-            }\n-\n-            result = make.LetExpr(List.of(var), exactnessCheck)\n+            result = (prefixStatement == null ? exactnessCheck : make.LetExpr(List.of(prefixStatement), exactnessCheck))\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":41,"deletions":33,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import com.sun.tools.javac.code.Preview;\n+import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -36,0 +36,1 @@\n+import com.sun.tools.javac.util.Log;\n@@ -123,1 +124,4 @@\n-        MemoryPreview.registerInstance(context);\n+\n+        \/\/ This suppresses diagnostics like \"Note: Recompile with -Xlint:preview for details.\"\n+        Log.instance(context).suppressAggregatedWarningNotes(LintCategory.PREVIEW);\n+\n@@ -272,15 +276,0 @@\n-\n-    static class MemoryPreview extends Preview {\n-        static void registerInstance(Context context) {\n-            context.put(previewKey, (Factory<Preview>)MemoryPreview::new);\n-        }\n-\n-        MemoryPreview(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public void reportDeferredDiagnostics() {\n-            \/\/ suppress diagnostics like \"Note: Recompile with -Xlint:preview for details.\"\n-        }\n-    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/MemoryContext.java","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -62,0 +61,1 @@\n+import com.sun.tools.javac.code.Symbol.ModuleSymbol;\n@@ -88,4 +88,0 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.code.Lint.LintCategory;\n-import com.sun.tools.javac.code.Symbol.ModuleSymbol;\n-\n@@ -277,4 +273,0 @@\n-    \/** The preview language version.\n-     *\/\n-    protected Preview preview;\n-\n@@ -416,1 +408,0 @@\n-        preview = Preview.instance(context);\n@@ -1855,2 +1846,1 @@\n-        chk.reportDeferredDiagnostics();\n-        preview.reportDeferredDiagnostics();\n+        log.reportOutstandingNotes();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-            lexError(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));\n+            lexError(pos, preview.disabledError(feature));\n@@ -187,1 +187,1 @@\n-            lexError(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));\n+            lexError(pos, feature.error(source.name));\n@@ -202,14 +202,1 @@\n-        tk = TokenKind.ERROR;\n-        errPos = pos;\n-    }\n-\n-    \/**\n-     * Report an error at the given position using the provided arguments.\n-     *\n-     * @param flags  diagnostic flags.\n-     * @param pos    position in input buffer.\n-     * @param key    error key to report.\n-     *\/\n-    protected void lexError(DiagnosticFlag flags, int pos, JCDiagnostic.Error key) {\n-        log.error(flags, pos, key);\n-        if (flags != DiagnosticFlag.SOURCE_LEVEL) {\n+        if (!key.hasFlag(DiagnosticFlag.SOURCE_LEVEL)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -5614,1 +5614,1 @@\n-            log.error(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));\n+            log.error(pos, preview.disabledError(feature));\n@@ -5617,1 +5617,1 @@\n-            log.error(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));\n+            log.error(pos, feature.error(source.name));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1926,0 +1926,1 @@\n+# flags: aggregate\n@@ -1931,0 +1932,1 @@\n+# flags: aggregate\n@@ -1936,0 +1938,1 @@\n+# flags: aggregate\n@@ -1946,0 +1949,1 @@\n+# flags: aggregate\n@@ -1957,0 +1961,1 @@\n+# flags: aggregate\n@@ -1962,0 +1967,1 @@\n+# flags: aggregate\n@@ -2360,0 +2366,1 @@\n+# flags: aggregate\n@@ -2365,0 +2372,1 @@\n+# flags: aggregate\n@@ -2374,0 +2382,1 @@\n+# flags: aggregate\n@@ -2381,0 +2390,1 @@\n+# flags: aggregate\n@@ -2386,0 +2396,1 @@\n+# flags: aggregate\n@@ -2784,0 +2795,1 @@\n+# flags: aggregate\n@@ -3180,0 +3192,1 @@\n+# flags: aggregate\n@@ -3186,0 +3199,1 @@\n+# flags: aggregate\n@@ -3249,0 +3263,1 @@\n+# flags: source-level\n@@ -3254,0 +3269,1 @@\n+# flags: source-level\n@@ -3269,0 +3285,1 @@\n+# flags: source-level\n@@ -3274,0 +3291,1 @@\n+# flags: source-level\n@@ -3285,0 +3303,1 @@\n+# flags: aggregate\n@@ -3290,0 +3309,1 @@\n+# flags: aggregate\n@@ -4252,0 +4272,1 @@\n+# flags: aggregate\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -294,0 +294,1 @@\n+# L10N: do not localize: identity synchronization\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Arrays;\n@@ -240,1 +241,1 @@\n-            return create(EnumSet.noneOf(DiagnosticFlag.class), source, pos, DiagnosticInfo.of(kind, prefix, key, args));\n+            return create(EnumSet.noneOf(DiagnosticFlag.class), source, pos, DiagnosticInfo.of(kind, null, prefix, key, args));\n@@ -255,1 +256,1 @@\n-            return create(EnumSet.noneOf(DiagnosticFlag.class), source, pos, DiagnosticInfo.of(kind, prefix, key, args), rewriter);\n+            return create(EnumSet.noneOf(DiagnosticFlag.class), source, pos, DiagnosticInfo.of(kind, null, prefix, key, args), rewriter);\n@@ -282,1 +283,1 @@\n-            return create(flags, source, pos, DiagnosticInfo.of(kind, lc, prefix, key, args));\n+            return create(flags, source, pos, DiagnosticInfo.of(kind, null, lc, prefix, key, args));\n@@ -306,1 +307,2 @@\n-                return DiagnosticInfo.of(diagnosticInfo.type, category, diagnosticInfo.prefix, diagnosticInfo.code,\n+                return DiagnosticInfo.of(diagnosticInfo.type, diagnosticInfo.flags,\n+                        category, diagnosticInfo.prefix, diagnosticInfo.code,\n@@ -317,1 +319,1 @@\n-            return (Error)DiagnosticInfo.of(ERROR, prefix, code, args);\n+            return (Error)DiagnosticInfo.of(ERROR, null, prefix, code, args);\n@@ -324,1 +326,1 @@\n-            return (Warning)DiagnosticInfo.of(WARNING, lintCategory, prefix, code, args);\n+            return (Warning)DiagnosticInfo.of(WARNING, null, lintCategory, prefix, code, args);\n@@ -331,1 +333,1 @@\n-            return (Note)DiagnosticInfo.of(NOTE, prefix, code, args);\n+            return (Note)DiagnosticInfo.of(NOTE, null, prefix, code, args);\n@@ -338,1 +340,1 @@\n-            return (Fragment)DiagnosticInfo.of(FRAGMENT, prefix, code, args);\n+            return (Fragment)DiagnosticInfo.of(FRAGMENT, null, prefix, code, args);\n@@ -354,0 +356,1 @@\n+                                      null,\n@@ -450,0 +453,3 @@\n+        \/** Flags mandatory warnings that should pass through a mandatory warning aggregator.\n+         *\/\n+        AGGREGATE,\n@@ -506,0 +512,3 @@\n+        \/** A set of diagnostic flags to be automatically added to newly created JCDiagnostics. *\/\n+        Set<DiagnosticFlag> flags;\n+\n@@ -516,1 +525,1 @@\n-        private DiagnosticInfo(DiagnosticType type, String prefix, String code, Object... args) {\n+        private DiagnosticInfo(DiagnosticType type, Set<DiagnosticFlag> flags, String prefix, String code, Object... args) {\n@@ -518,0 +527,1 @@\n+            this.flags = flags != null ? flags : EnumSet.noneOf(DiagnosticFlag.class);\n@@ -533,2 +543,3 @@\n-        public static DiagnosticInfo of(DiagnosticType type, String prefix, String code, Object... args) {\n-            return of(type, null, prefix, code, args);\n+        public static DiagnosticInfo of(DiagnosticType type, Set<DiagnosticFlag> flags,\n+            String prefix, String code, Object... args) {\n+            return of(type, flags, null, prefix, code, args);\n@@ -537,1 +548,2 @@\n-        public static DiagnosticInfo of(DiagnosticType type, LintCategory lc, String prefix, String code, Object... args) {\n+        public static DiagnosticInfo of(DiagnosticType type, Set<DiagnosticFlag> flags,\n+            LintCategory lc, String prefix, String code, Object... args) {\n@@ -540,1 +552,1 @@\n-                    return new Error(prefix, code, args);\n+                    return new Error(flags, prefix, code, args);\n@@ -543,2 +555,2 @@\n-                            new Warning(prefix, code, args) :\n-                            new LintWarning(lc, prefix, code, args);\n+                            new Warning(flags, prefix, code, args) :\n+                            new LintWarning(flags, lc, prefix, code, args);\n@@ -546,1 +558,1 @@\n-                    return new Note(prefix, code, args);\n+                    return new Note(flags, prefix, code, args);\n@@ -548,1 +560,1 @@\n-                    return new Fragment(prefix, code, args);\n+                    return new Fragment(flags, prefix, code, args);\n@@ -572,0 +584,4 @@\n+\n+        public boolean hasFlag(DiagnosticFlag flag) {\n+            return flags.contains(flag);\n+        }\n@@ -578,2 +594,2 @@\n-        public Error(String prefix, String key, Object... args) {\n-            super(DiagnosticType.ERROR, prefix, key, args);\n+        public Error(Set<DiagnosticFlag> flags, String prefix, String key, Object... args) {\n+            super(DiagnosticType.ERROR, flags, prefix, key, args);\n@@ -587,2 +603,2 @@\n-        public Warning(String prefix, String key, Object... args) {\n-            super(DiagnosticType.WARNING, prefix, key, args);\n+        public Warning(Set<DiagnosticFlag> flags, String prefix, String key, Object... args) {\n+            super(DiagnosticType.WARNING, flags, prefix, key, args);\n@@ -598,2 +614,2 @@\n-        public LintWarning(LintCategory category, String prefix, String key, Object... args) {\n-            super(prefix, key, args);\n+        public LintWarning(Set<DiagnosticFlag> flags, LintCategory category, String prefix, String key, Object... args) {\n+            super(flags, prefix, key, args);\n@@ -612,2 +628,2 @@\n-        public Note(String prefix, String key, Object... args) {\n-            super(DiagnosticType.NOTE, prefix, key, args);\n+        public Note(Set<DiagnosticFlag> flags, String prefix, String key, Object... args) {\n+            super(DiagnosticType.NOTE, flags, prefix, key, args);\n@@ -621,2 +637,2 @@\n-        public Fragment(String prefix, String key, Object... args) {\n-            super(DiagnosticType.FRAGMENT, prefix, key, args);\n+        public Fragment(Set<DiagnosticFlag> flags, String prefix, String key, Object... args) {\n+            super(DiagnosticType.FRAGMENT, flags, prefix, key, args);\n@@ -667,0 +683,2 @@\n+\n+        this.flags.addAll(diagnosticInfo.flags);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/JCDiagnostic.java","additions":45,"deletions":27,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.EnumSet;\n@@ -44,0 +45,3 @@\n+import com.sun.tools.javac.code.Lint;\n+import com.sun.tools.javac.code.Lint.LintCategory;\n+import com.sun.tools.javac.code.Source;\n@@ -47,1 +51,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;\n@@ -53,0 +56,1 @@\n+import static com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag.*;\n@@ -151,1 +155,1 @@\n-            return !(diag.isFlagSet(DiagnosticFlag.NON_DEFERRABLE) && passOnNonDeferrable) && filter.test(diag);\n+            return !(diag.isFlagSet(NON_DEFERRABLE) && passOnNonDeferrable) && filter.test(diag);\n@@ -240,0 +244,10 @@\n+    \/**\n+     * The compilation context.\n+     *\/\n+    private final Context context;\n+\n+    \/**\n+     * The root {@link Lint} singleton.\n+     *\/\n+    private Lint rootLint;\n+\n@@ -337,0 +351,1 @@\n+        this.context = context;\n@@ -520,1 +535,1 @@\n-        if (!d.isFlagSet(DiagnosticFlag.SOURCE_LEVEL))\n+        if (!d.isFlagSet(SOURCE_LEVEL))\n@@ -684,1 +699,42 @@\n-     }\n+    }\n+\n+    \/\/ Obtain root Lint singleton lazily to avoid init loops\n+    private Lint rootLint() {\n+        if (rootLint == null)\n+            rootLint = Lint.instance(context);\n+        return rootLint;\n+    }\n+\n+\/\/ Mandatory Warnings\n+\n+    private final EnumMap<LintCategory, WarningAggregator> aggregators = new EnumMap<>(LintCategory.class);\n+\n+    private final EnumSet<LintCategory> suppressedDeferredMandatory = EnumSet.noneOf(LintCategory.class);\n+\n+    \/**\n+     * Suppress aggregated mandatory warning notes for the specified category.\n+     *\/\n+    public void suppressAggregatedWarningNotes(LintCategory category) {\n+        suppressedDeferredMandatory.add(category);\n+    }\n+\n+    \/**\n+     * Report any remaining unreported aggregated mandatory warning notes.\n+     *\/\n+    public void reportOutstandingNotes() {\n+        aggregators.entrySet().stream()\n+          .filter(entry -> !suppressedDeferredMandatory.contains(entry.getKey()))\n+          .map(Map.Entry::getValue)\n+          .map(WarningAggregator::aggregationNotes)\n+          .flatMap(List::stream)\n+          .forEach(this::report);\n+        aggregators.clear();\n+    }\n+\n+    private WarningAggregator aggregatorFor(LintCategory lc) {\n+        return switch (lc) {\n+        case PREVIEW -> aggregators.computeIfAbsent(lc, c -> new WarningAggregator(this, Source.instance(context), c));\n+        case DEPRECATION -> aggregators.computeIfAbsent(lc, c -> new WarningAggregator(this, null, c, \"deprecated\"));\n+        default -> aggregators.computeIfAbsent(lc, c -> new WarningAggregator(this, null, c));\n+        };\n+    }\n@@ -698,0 +754,2 @@\n+        aggregators.clear();\n+        suppressedDeferredMandatory.clear();\n@@ -700,0 +758,2 @@\n+\/\/ DefaultDiagnosticHandler\n+\n@@ -706,0 +766,1 @@\n+\n@@ -730,0 +791,10 @@\n+\n+                \/\/ Apply the appropriate mandatory warning aggregator, if needed\n+                if (diagnostic.isFlagSet(AGGREGATE)) {\n+                    LintCategory category = diagnostic.getLintCategory();\n+                    boolean verbose = rootLint().isEnabled(category);\n+                    if (!aggregatorFor(category).aggregate(diagnostic, verbose))\n+                        return;\n+                }\n+\n+                \/\/ Emit warning unless not mandatory and warnings are disabled\n@@ -741,2 +812,1 @@\n-                if (diagnostic.isFlagSet(DiagnosticFlag.API) ||\n-                     shouldReport(diagnostic)) {\n+                if (diagnostic.isFlagSet(API) || shouldReport(diagnostic)) {\n@@ -752,1 +822,1 @@\n-            if (diagnostic.isFlagSet(JCDiagnostic.DiagnosticFlag.COMPRESSED)) {\n+            if (diagnostic.isFlagSet(COMPRESSED)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Log.java","additions":77,"deletions":7,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -1,309 +1,0 @@\n-\/*\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.javac.util;\n-\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.Set;\n-import javax.tools.JavaFileObject;\n-\n-import com.sun.tools.javac.code.Lint.LintCategory;\n-import com.sun.tools.javac.code.Source;\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n-import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n-import com.sun.tools.javac.util.JCDiagnostic.Note;\n-import com.sun.tools.javac.util.JCDiagnostic.Warning;\n-\n-\n-\/**\n- * A handler to process mandatory warnings, setting up a deferred diagnostic\n- * to be printed at the end of the compilation if some warnings get suppressed\n- * because too many warnings have already been generated.\n- *\n- * <p>\n- * Note that the SuppressWarnings annotation can be used to suppress warnings\n- * about conditions that would otherwise merit a warning. Such processing\n- * is done when the condition is detected, and in those cases, no call is\n- * made on any API to generate a warning at all. In consequence, this handler only\n- * Returns to handle those warnings that JLS says must be generated.\n- *\n- * <p>\n- * All warnings must be in the same {@link LintCategory} provided to the constructor.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class MandatoryWarningHandler {\n-\n-    \/**\n-     * The kinds of different deferred diagnostics that might be generated\n-     * if a mandatory warning is suppressed because too many warnings have\n-     * already been output.\n-     *\n-     * The parameter is a fragment used to build an I18N message key for Log.\n-     *\/\n-    private enum DeferredDiagnosticKind {\n-        \/**\n-         * This kind is used when a single specific file is found to have warnings\n-         * and no similar warnings have already been given.\n-         * It generates a message like:\n-         *      FILE has ISSUES\n-         *\/\n-        IN_FILE(\".filename\"),\n-        \/**\n-         * This kind is used when a single specific file is found to have warnings\n-         * and when similar warnings have already been reported for the file.\n-         * It generates a message like:\n-         *      FILE has additional ISSUES\n-         *\/\n-        ADDITIONAL_IN_FILE(\".filename.additional\"),\n-        \/**\n-         * This kind is used when multiple files have been found to have warnings,\n-         * and none of them have had any similar warnings.\n-         * It generates a message like:\n-         *      Some files have ISSUES\n-         *\/\n-        IN_FILES(\".plural\"),\n-        \/**\n-         * This kind is used when multiple files have been found to have warnings,\n-         * and some of them have had already had specific similar warnings.\n-         * It generates a message like:\n-         *      Some files have additional ISSUES\n-         *\/\n-        ADDITIONAL_IN_FILES(\".plural.additional\");\n-\n-        DeferredDiagnosticKind(String v) { value = v; }\n-        String getKey(String prefix) { return prefix + value; }\n-\n-        private final String value;\n-    }\n-\n-\n-    \/**\n-     * Create a handler for mandatory warnings.\n-     *\n-     * @param log     The log on which to generate any diagnostics\n-     * @param source  Associated source file, or null for none\n-     * @param verbose Specify whether or not detailed messages about\n-     *                individual instances should be given, or whether an aggregate\n-     *                message should be generated at the end of the compilation.\n-     *                Typically set via  -Xlint:option.\n-     * @param enforceMandatory\n-     *                True if mandatory warnings and notes are being enforced.\n-     * @param lc      The lint category for all warnings\n-     *\/\n-    public MandatoryWarningHandler(Log log, Source source, boolean verbose, boolean enforceMandatory, LintCategory lc) {\n-        this(log, source, verbose, enforceMandatory, lc, null);\n-    }\n-\n-    \/**\n-     * Create a handler for mandatory warnings.\n-     *\n-     * @param log     The log on which to generate any diagnostics\n-     * @param source  Associated source file, or null for none\n-     * @param verbose Specify whether or not detailed messages about\n-     *                individual instances should be given, or whether an aggregate\n-     *                message should be generated at the end of the compilation.\n-     *                Typically set via  -Xlint:option.\n-     * @param enforceMandatory\n-     *                True if mandatory warnings and notes are being enforced.\n-     * @param lc      The lint category for all warnings\n-     * @param prefix  A common prefix for the set of message keys for the messages\n-     *                that may be generated, or null to infer from the lint category.\n-     *\/\n-    public MandatoryWarningHandler(Log log, Source source, boolean verbose, boolean enforceMandatory, LintCategory lc, String prefix) {\n-        this.log = log;\n-        this.source = source;\n-        this.verbose = verbose;\n-        this.prefix = prefix != null ? prefix : lc.option;\n-        this.enforceMandatory = enforceMandatory;\n-        this.lintCategory = lc;\n-    }\n-\n-    \/**\n-     * Report a mandatory warning.\n-     *\n-     * @param pos source code position\n-     * @param warnKey lint warning\n-     *\/\n-    public void report(DiagnosticPosition pos, LintWarning warnKey) {\n-        JavaFileObject currentSource = log.currentSourceFile();\n-        Assert.check(warnKey.getLintCategory() == lintCategory);\n-\n-        if (verbose) {\n-            if (sourcesWithReportedWarnings == null)\n-                sourcesWithReportedWarnings = new HashSet<>();\n-\n-            if (log.nwarnings < log.MaxWarnings) {\n-                \/\/ generate message and remember the source file\n-                logMandatoryWarning(pos, warnKey);\n-                sourcesWithReportedWarnings.add(currentSource);\n-            } else if (deferredDiagnosticKind == null) {\n-                \/\/ set up deferred message\n-                if (sourcesWithReportedWarnings.contains(currentSource)) {\n-                    \/\/ more errors in a file that already has reported warnings\n-                    deferredDiagnosticKind = DeferredDiagnosticKind.ADDITIONAL_IN_FILE;\n-                } else {\n-                    \/\/ warnings in a new source file\n-                    deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILE;\n-                }\n-                deferredDiagnosticSource = currentSource;\n-                deferredDiagnosticArg = currentSource;\n-            } else if ((deferredDiagnosticKind == DeferredDiagnosticKind.IN_FILE\n-                        || deferredDiagnosticKind == DeferredDiagnosticKind.ADDITIONAL_IN_FILE)\n-                       && !Objects.equals(deferredDiagnosticSource, currentSource)) {\n-                \/\/ additional errors in more than one source file\n-                deferredDiagnosticKind = DeferredDiagnosticKind.ADDITIONAL_IN_FILES;\n-                deferredDiagnosticArg = null;\n-            }\n-        } else {\n-            if (deferredDiagnosticKind == null) {\n-                \/\/ warnings in a single source\n-                deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILE;\n-                deferredDiagnosticSource = currentSource;\n-                deferredDiagnosticArg = currentSource;\n-            }  else if (deferredDiagnosticKind == DeferredDiagnosticKind.IN_FILE &&\n-                        !Objects.equals(deferredDiagnosticSource, currentSource)) {\n-                \/\/ warnings in multiple source files\n-                deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILES;\n-                deferredDiagnosticArg = null;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Report any diagnostic that might have been deferred by previous calls of report().\n-     *\/\n-    public void reportDeferredDiagnostic() {\n-        if (deferredDiagnosticKind != null) {\n-            if (deferredDiagnosticArg == null) {\n-                if (source != null) {\n-                    logMandatoryNote(deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), source);\n-                } else {\n-                    logMandatoryNote(deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix));\n-                }\n-            } else {\n-                if (source != null) {\n-                    logMandatoryNote(deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), deferredDiagnosticArg, source);\n-                } else {\n-                    logMandatoryNote(deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), deferredDiagnosticArg);\n-                }\n-            }\n-\n-            if (!verbose)\n-                logMandatoryNote(deferredDiagnosticSource, prefix + \".recompile\");\n-        }\n-    }\n-\n-    \/**\n-     * The log to which to report warnings.\n-     *\/\n-    private final Log log;\n-    private final Source source;\n-\n-    \/**\n-     * Whether or not to report individual warnings, or simply to report a\n-     * single aggregate warning at the end of the compilation.\n-     *\/\n-    private final boolean verbose;\n-\n-    \/**\n-     * The common prefix for all I18N message keys generated by this handler.\n-     *\/\n-    private final String prefix;\n-\n-    \/**\n-     * A set containing the names of the source files for which specific\n-     * warnings have been generated -- i.e. in verbose mode.  If a source name\n-     * appears in this list, then deferred diagnostics will be phrased to\n-     * include \"additionally\"...\n-     *\/\n-    private Set<JavaFileObject> sourcesWithReportedWarnings;\n-\n-    \/**\n-     * A variable indicating the latest best guess at what the final\n-     * deferred diagnostic will be. Initially as specific and helpful\n-     * as possible, as more warnings are reported, the scope of the\n-     * diagnostic will be broadened.\n-     *\/\n-    private DeferredDiagnosticKind deferredDiagnosticKind;\n-\n-    \/**\n-     * If deferredDiagnosticKind is IN_FILE or ADDITIONAL_IN_FILE, this variable\n-     * gives the value of log.currentSource() for the file in question.\n-     *\/\n-    private JavaFileObject deferredDiagnosticSource;\n-\n-    \/**\n-     * An optional argument to be used when constructing the\n-     * deferred diagnostic message, based on deferredDiagnosticKind.\n-     * This variable should normally be set\/updated whenever\n-     * deferredDiagnosticKind is updated.\n-     *\/\n-    private Object deferredDiagnosticArg;\n-\n-    \/**\n-     * True if mandatory warnings and notes are being enforced.\n-     *\/\n-    private final boolean enforceMandatory;\n-\n-    \/**\n-     * A LintCategory to be included in point-of-use diagnostics to indicate\n-     * how messages might be suppressed (i.e. with @SuppressWarnings).\n-     *\/\n-    private final LintCategory lintCategory;\n-\n-    \/**\n-     * Reports a mandatory warning to the log.  If mandatory warnings\n-     * are not being enforced, treat this as an ordinary warning.\n-     *\/\n-    private void logMandatoryWarning(DiagnosticPosition pos, LintWarning warnKey) {\n-        if (enforceMandatory)\n-            log.mandatoryWarning(pos, warnKey);\n-        else\n-            log.warning(pos, warnKey);\n-    }\n-\n-    \/**\n-     * Reports a mandatory note to the log.  If mandatory notes are\n-     * not being enforced, treat this as an ordinary note.\n-     *\/\n-    private void logMandatoryNote(JavaFileObject file, String msg, Object... args) {\n-        if (enforceMandatory)\n-            log.mandatoryNote(file, new Note(\"compiler\", msg, args));\n-        else\n-            log.note(file, new Note(\"compiler\", msg, args));\n-    }\n-\n-    public void clear() {\n-        sourcesWithReportedWarnings = null;\n-        deferredDiagnosticKind = null;\n-        deferredDiagnosticSource = null;\n-        deferredDiagnosticArg = null;\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/MandatoryWarningHandler.java","additions":0,"deletions":309,"binary":false,"changes":309,"status":"deleted"},{"patch":"@@ -0,0 +1,270 @@\n+\/*\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.util;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import javax.tools.JavaFileObject;\n+\n+import com.sun.tools.javac.code.Lint;\n+import com.sun.tools.javac.code.Lint.LintCategory;\n+import com.sun.tools.javac.code.Source;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n+import com.sun.tools.javac.util.JCDiagnostic.Note;\n+import com.sun.tools.javac.util.JCDiagnostic.Warning;\n+\n+\n+\/**\n+ * An aggregator for warnings, setting up a deferred diagnostic\n+ * to be printed at the end of the compilation if some warnings get suppressed\n+ * because the lint category is not enabled or too many warnings have already\n+ * been generated.\n+ *\n+ * <p>\n+ * All warnings must be in the same {@link LintCategory} provided to the constructor.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+class WarningAggregator {\n+\n+    \/**\n+     * The kinds of different deferred diagnostics that might be generated\n+     * if a warning is suppressed because too many warnings have already been output.\n+     *\n+     * The parameter is a fragment used to build an I18N message key for Log.\n+     *\/\n+    private enum DeferredDiagnosticKind {\n+        \/**\n+         * This kind is used when a single specific file is found to have warnings\n+         * and no similar warnings have already been given.\n+         * It generates a message like:\n+         *      FILE has ISSUES\n+         *\/\n+        IN_FILE(\".filename\"),\n+        \/**\n+         * This kind is used when a single specific file is found to have warnings\n+         * and when similar warnings have already been reported for the file.\n+         * It generates a message like:\n+         *      FILE has additional ISSUES\n+         *\/\n+        ADDITIONAL_IN_FILE(\".filename.additional\"),\n+        \/**\n+         * This kind is used when multiple files have been found to have warnings,\n+         * and none of them have had any similar warnings.\n+         * It generates a message like:\n+         *      Some files have ISSUES\n+         *\/\n+        IN_FILES(\".plural\"),\n+        \/**\n+         * This kind is used when multiple files have been found to have warnings,\n+         * and some of them have had already had specific similar warnings.\n+         * It generates a message like:\n+         *      Some files have additional ISSUES\n+         *\/\n+        ADDITIONAL_IN_FILES(\".plural.additional\");\n+\n+        DeferredDiagnosticKind(String v) { value = v; }\n+        String getKey(String prefix) { return prefix + value; }\n+\n+        private final String value;\n+    }\n+\n+\n+    \/**\n+     * Create an aggregator for warnings.\n+     *\n+     * @param log     The log on which to generate any diagnostics\n+     * @param source  Associated source file, or null for none\n+     * @param lc      The lint category for all warnings\n+     *\/\n+    public WarningAggregator(Log log, Source source, LintCategory lc) {\n+        this(log, source, lc, null);\n+    }\n+\n+    \/**\n+     * Create an aggregator for warnings.\n+     *\n+     * @param log     The log on which to generate any diagnostics\n+     * @param source  Associated source file, or null for none\n+     * @param lc      The lint category for all warnings\n+     * @param prefix  A common prefix for the set of message keys for the messages\n+     *                that may be generated, or null to infer from the lint category.\n+     *\/\n+    public WarningAggregator(Log log, Source source, LintCategory lc, String prefix) {\n+        this.log = log;\n+        this.source = source;\n+        this.prefix = prefix != null ? prefix : lc.option;\n+        this.lintCategory = lc;\n+    }\n+\n+    \/**\n+     * Aggregate a warning and determine whether to emit it.\n+     *\n+     * @param diagnostic the warning\n+     * @param verbose whether the warning's lint category is enabled\n+     * @return true if diagnostic should be emitted, otherwise false\n+     *\/\n+    public boolean aggregate(JCDiagnostic diagnostic, boolean verbose) {\n+        Assert.check(diagnostic.getLintCategory() == lintCategory);\n+        JavaFileObject currentSource = log.currentSourceFile();\n+        if (verbose) {\n+            if (sourcesWithReportedWarnings == null)\n+                sourcesWithReportedWarnings = new HashSet<>();\n+            if (log.nwarnings < log.MaxWarnings) {\n+                \/\/ generate message and remember the source file\n+                sourcesWithReportedWarnings.add(currentSource);\n+                anyWarningEmitted = true;\n+                return true;\n+            } else if (deferredDiagnosticKind == null) {\n+                \/\/ set up deferred message\n+                if (sourcesWithReportedWarnings.contains(currentSource)) {\n+                    \/\/ more errors in a file that already has reported warnings\n+                    deferredDiagnosticKind = DeferredDiagnosticKind.ADDITIONAL_IN_FILE;\n+                } else {\n+                    \/\/ warnings in a new source file\n+                    deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILE;\n+                }\n+                deferredDiagnosticSource = currentSource;\n+                deferredDiagnosticArg = currentSource;\n+            } else if ((deferredDiagnosticKind == DeferredDiagnosticKind.IN_FILE\n+                        || deferredDiagnosticKind == DeferredDiagnosticKind.ADDITIONAL_IN_FILE)\n+                       && !Objects.equals(deferredDiagnosticSource, currentSource)) {\n+                \/\/ additional errors in more than one source file\n+                deferredDiagnosticKind = DeferredDiagnosticKind.ADDITIONAL_IN_FILES;\n+                deferredDiagnosticArg = null;\n+            }\n+        } else {\n+            if (deferredDiagnosticKind == null) {\n+                \/\/ warnings in a single source\n+                deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILE;\n+                deferredDiagnosticSource = currentSource;\n+                deferredDiagnosticArg = currentSource;\n+            }  else if (deferredDiagnosticKind == DeferredDiagnosticKind.IN_FILE &&\n+                        !Objects.equals(deferredDiagnosticSource, currentSource)) {\n+                \/\/ warnings in multiple source files\n+                deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILES;\n+                deferredDiagnosticArg = null;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Build and return any accumulated aggregation notes.\n+     *\/\n+    public List<JCDiagnostic> aggregationNotes() {\n+        List<JCDiagnostic> list = new ArrayList<>(2);\n+        if (deferredDiagnosticKind != null) {\n+            if (deferredDiagnosticArg == null) {\n+                if (source != null) {\n+                    addNote(list, deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), source);\n+                } else {\n+                    addNote(list, deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix));\n+                }\n+            } else {\n+                if (source != null) {\n+                    addNote(list, deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), deferredDiagnosticArg, source);\n+                } else {\n+                    addNote(list, deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), deferredDiagnosticArg);\n+                }\n+            }\n+            if (!anyWarningEmitted)\n+                addNote(list, deferredDiagnosticSource, prefix + \".recompile\");\n+        }\n+        return list;\n+    }\n+\n+    private void addNote(List<JCDiagnostic> list, JavaFileObject file, String msg, Object... args) {\n+        list.add(log.diags.mandatoryNote(log.getSource(file), new Note(null, \"compiler\", msg, args)));\n+    }\n+\n+    \/**\n+     * The log to which to report warnings.\n+     *\/\n+    private final Log log;\n+    private final Source source;\n+\n+    \/**\n+     * The common prefix for all I18N message keys generated by this handler.\n+     *\/\n+    private final String prefix;\n+\n+    \/**\n+     * A set containing the names of the source files for which specific\n+     * warnings have been generated -- i.e. in verbose mode.  If a source name\n+     * appears in this list, then deferred diagnostics will be phrased to\n+     * include \"additionally\"...\n+     *\/\n+    private Set<JavaFileObject> sourcesWithReportedWarnings;\n+\n+    \/**\n+     * A variable indicating the latest best guess at what the final\n+     * deferred diagnostic will be. Initially as specific and helpful\n+     * as possible, as more warnings are reported, the scope of the\n+     * diagnostic will be broadened.\n+     *\/\n+    private DeferredDiagnosticKind deferredDiagnosticKind;\n+\n+    \/**\n+     * If deferredDiagnosticKind is IN_FILE or ADDITIONAL_IN_FILE, this variable\n+     * gives the value of log.currentSource() for the file in question.\n+     *\/\n+    private JavaFileObject deferredDiagnosticSource;\n+\n+    \/**\n+     * An optional argument to be used when constructing the\n+     * deferred diagnostic message, based on deferredDiagnosticKind.\n+     * This variable should normally be set\/updated whenever\n+     * deferredDiagnosticKind is updated.\n+     *\/\n+    private Object deferredDiagnosticArg;\n+\n+    \/**\n+     * Whether we have actually emitted a warning or just deferred everything.\n+     * In the latter case, the \"recompile\" notice is included in the summary.\n+     *\/\n+    private boolean anyWarningEmitted;\n+\n+    \/**\n+     * A LintCategory to be included in point-of-use diagnostics to indicate\n+     * how messages might be suppressed (i.e. with @SuppressWarnings).\n+     *\/\n+    private final LintCategory lintCategory;\n+\n+    public void clear() {\n+        sourcesWithReportedWarnings = null;\n+        deferredDiagnosticKind = null;\n+        deferredDiagnosticSource = null;\n+        deferredDiagnosticArg = null;\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/WarningAggregator.java","additions":270,"deletions":0,"binary":false,"changes":270,"status":"added"},{"patch":"@@ -1316,0 +1316,1 @@\n+    \/*\n@@ -1324,0 +1325,1 @@\n+    *\/\n","filename":"src\/jdk.crypto.mscapi\/windows\/native\/libsunmscapi\/security.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3123,5 +3123,18 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n+        }\n+\n+        IntVector vix2 = null;\n+        IntVector vix3 = null;\n+        if (vlen == idx_vlen * 4) {\n+            vix2 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 2).add(offset);\n+            VectorIntrinsics.checkIndex(vix2, a.length);\n+            vix3 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 3).add(offset);\n+            VectorIntrinsics.checkIndex(vix3, a.length);\n@@ -3132,2 +3145,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, null,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, vix2, vix3, null,\n@@ -3885,5 +3898,18 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n+        }\n+\n+        IntVector vix2 = null;\n+        IntVector vix3 = null;\n+        if (vlen == idx_vlen * 4) {\n+            vix2 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 2).add(offset);\n+            VectorIntrinsics.checkIndex(vix2, a.length);\n+            vix3 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 3).add(offset);\n+            VectorIntrinsics.checkIndex(vix3, a.length);\n@@ -3894,2 +3920,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, m,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, vix2, vix3, m,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":40,"deletions":14,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2940,2 +2940,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, null,\n@@ -3231,1 +3231,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n@@ -3426,2 +3426,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, m,\n@@ -3542,1 +3542,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2946,2 +2946,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, null,\n@@ -3218,1 +3218,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n@@ -3395,2 +3395,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, m,\n@@ -3492,1 +3492,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3100,2 +3100,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, null,\n@@ -3372,1 +3372,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n@@ -3549,2 +3549,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, m,\n@@ -3646,1 +3646,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2979,2 +2979,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, null,\n@@ -3270,1 +3270,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n@@ -3465,2 +3465,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, m,\n@@ -3581,1 +3581,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3124,5 +3124,9 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n@@ -3133,2 +3137,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, null,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, null, null, null,\n@@ -3871,5 +3875,9 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n@@ -3880,2 +3888,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, m,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, null, null, m,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -3766,5 +3766,19 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n+        }\n+\n+#if[byte]\n+        IntVector vix2 = null;\n+        IntVector vix3 = null;\n+        if (vlen == idx_vlen * 4) {\n+            vix2 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 2).add(offset);\n+            VectorIntrinsics.checkIndex(vix2, a.length);\n+            vix3 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 3).add(offset);\n+            VectorIntrinsics.checkIndex(vix3, a.length);\n@@ -3775,2 +3789,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, null,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, vix2, vix3, null,\n@@ -3780,0 +3794,9 @@\n+#else[byte]\n+        return VectorSupport.loadWithMap(\n+            vectorType, null, $type$.class, vsp.laneCount(),\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, null, null, null,\n+            a, offset, indexMap, mapOffset, vsp,\n+            (c, idx, iMap, idy, s, vm) ->\n+            s.vOp(n -> c[idx + iMap[idy+n]]));\n+#end[byte]\n@@ -3827,2 +3850,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, null,\n@@ -4453,1 +4476,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n@@ -4974,5 +4997,19 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n+        }\n+\n+#if[byte]\n+        IntVector vix2 = null;\n+        IntVector vix3 = null;\n+        if (vlen == idx_vlen * 4) {\n+            vix2 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 2).add(offset);\n+            VectorIntrinsics.checkIndex(vix2, a.length);\n+            vix3 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 3).add(offset);\n+            VectorIntrinsics.checkIndex(vix3, a.length);\n@@ -4983,2 +5020,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, m,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, vix2, vix3, m,\n@@ -4988,0 +5025,9 @@\n+#else[byte]\n+        return VectorSupport.loadWithMap(\n+            vectorType, maskClass, $type$.class, vsp.laneCount(),\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, null, null, m,\n+            a, offset, indexMap, mapOffset, vsp,\n+            (c, idx, iMap, idy, s, vm) ->\n+            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+#end[byte]\n@@ -5037,2 +5083,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, m,\n@@ -5228,1 +5274,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":66,"deletions":20,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -390,0 +390,7 @@\n+\n+    \/**\n+     * Returns a copy of the array describing the Java kinds in {@link #values}.\n+     *\/\n+    public JavaKind[] getSlotKinds() {\n+        return (slotKinds == null) ? null : slotKinds.clone();\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/BytecodeFrame.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,2 @@\n+     * @param profileDeopt specifies if HotSpot should profile deoptimizations for the\n+     *            {@code nmethod} associated with this object.\n@@ -50,2 +52,2 @@\n-    default InstalledCode addCode(ResolvedJavaMethod method, CompiledCode compiledCode, SpeculationLog log, InstalledCode installedCode) {\n-        return installCode(method, compiledCode, installedCode, log, false);\n+    default InstalledCode addCode(ResolvedJavaMethod method, CompiledCode compiledCode, SpeculationLog log, InstalledCode installedCode, boolean profileDeopt) {\n+        return installCode(method, compiledCode, installedCode, log, false, profileDeopt);\n@@ -67,1 +69,1 @@\n-        return installCode(method, compiledCode, null, null, true);\n+        return installCode(method, compiledCode, null, null, true, true);\n@@ -84,0 +86,2 @@\n+     * @param profileDeopt specifies if HotSpot should profile deoptimizations for the\n+     *            {@code nmethod} associated with this object.\n@@ -87,1 +91,1 @@\n-    InstalledCode installCode(ResolvedJavaMethod method, CompiledCode compiledCode, InstalledCode installedCode, SpeculationLog log, boolean isDefault);\n+    InstalledCode installCode(ResolvedJavaMethod method, CompiledCode compiledCode, InstalledCode installedCode, SpeculationLog log, boolean isDefault, boolean profileDeopt);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/CodeCacheProvider.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -292,3 +292,4 @@\n-        if (o instanceof VirtualObject) {\n-            VirtualObject l = (VirtualObject) o;\n-            if (!l.type.equals(type) || l.values.length != values.length) {\n+        if (o instanceof VirtualObject that) {\n+            int thatValuesLength = (that.values == null) ? 0 : that.values.length;\n+            int valuesLength = (values == null) ? 0 : values.length;\n+            if (!that.type.equals(type) || thatValuesLength != valuesLength) {\n@@ -297,1 +298,1 @@\n-            for (int i = 0; i < values.length; i++) {\n+            for (int i = 0; i < valuesLength; i++) {\n@@ -302,1 +303,1 @@\n-                if (!same(values[i], l.values[i])) {\n+                if (!same(values[i], that.values[i])) {\n@@ -314,0 +315,7 @@\n+\n+    \/**\n+     * Returns a copy of the array containing the Java kinds of the values stored in this virtual object.\n+     *\/\n+    public JavaKind[] getSlotKinds() {\n+        return (slotKinds == null) ? null : slotKinds.clone();\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/VirtualObject.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,1 @@\n- * interface. The method\n- * {@link jdk.vm.ci.code.CodeCacheProvider#addCode(jdk.vm.ci.meta.ResolvedJavaMethod, CompiledCode, jdk.vm.ci.meta.SpeculationLog, InstalledCode)}\n- * can be used to install code.\n+ * interface. The method {@link jdk.vm.ci.code.CodeCacheProvider#addCode} can be used to install code.\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/package-info.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-    public final int hashCode() {\n-        throw new UnsupportedOperationException(\"hashCode\");\n+    public int hashCode() {\n+        return 41 * pcOffset;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/site\/Site.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-    public InstalledCode installCode(ResolvedJavaMethod method, CompiledCode compiledCode, InstalledCode installedCode, SpeculationLog log, boolean isDefault) {\n+    public InstalledCode installCode(ResolvedJavaMethod method, CompiledCode compiledCode, InstalledCode installedCode, SpeculationLog log, boolean isDefault, boolean profileDeopt) {\n@@ -134,1 +134,1 @@\n-            HotSpotNmethod nmethod = new HotSpotNmethod(hsMethod, name, isDefault, hsCompiledNmethod.id);\n+            HotSpotNmethod nmethod = new HotSpotNmethod(hsMethod, name, isDefault, profileDeopt, hsCompiledNmethod.id);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotCodeCacheProvider.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -191,0 +191,84 @@\n+\n+    \/**\n+     * Returns a copy of the compiled machine code.\n+     *\/\n+    public byte[] getTargetCode() {\n+        return (targetCode == null) ? null : targetCode.clone();\n+    }\n+\n+    \/**\n+     * Gets the size of the compiled machine code in bytes.\n+     *\/\n+    public int getTargetCodeSize() {\n+        return targetCodeSize;\n+    }\n+\n+    \/**\n+     * Returns a copy of the code annotations describing special sites in {@link #targetCode}.\n+     *\/\n+    public Site[] getSites() {\n+        return (sites == null) ? null : sites.clone();\n+    }\n+\n+    \/**\n+     * Returns an array copy of the assumptions this code relies on.\n+     *\/\n+    public Assumption[] getAssumptions() {\n+        return (assumptions == null) ? null : assumptions.clone();\n+    }\n+\n+    \/**\n+     * Returns an array copy of the methods whose bytecodes were used as input to the compilation.\n+     *\/\n+    public ResolvedJavaMethod[] getMethods() {\n+        return (methods == null) ? null : methods.clone();\n+    }\n+\n+    \/**\n+     * Returns an array copy of the comments that are included in code dumps.\n+     *\/\n+    public Comment[] getComments() {\n+        return (comments == null) ? null : comments.clone();\n+    }\n+\n+    \/**\n+     * Returns a copy of the data section containing serialized constants for the emitted machine code.\n+     *\/\n+    public byte[] getDataSection() {\n+        return (dataSection == null) ? null : dataSection.clone();\n+    }\n+\n+    \/**\n+     * Gets the minimum alignment of the data section.\n+     *\/\n+    public int getDataSectionAlignment() {\n+        return dataSectionAlignment;\n+    }\n+\n+    \/**\n+     * Returns a copy of the {@link #dataSection} relocations.\n+     *\/\n+    public DataPatch[] getDataSectionPatches() {\n+        return (dataSectionPatches == null) ? null : dataSectionPatches.clone();\n+    }\n+\n+    \/**\n+     * Checks if this compiled code is immutable and position independent.\n+     *\/\n+    public boolean isImmutablePIC() {\n+        return isImmutablePIC;\n+    }\n+\n+    \/**\n+     * Gets the total size of the stack frame of this compiled method.\n+     *\/\n+    public int getTotalFrameSize() {\n+        return totalFrameSize;\n+    }\n+\n+    \/**\n+     * Gets the deoptimization rescue slot associated with this compiled code.\n+     *\/\n+    public StackSlot getDeoptRescueSlot() {\n+        return deoptRescueSlot;\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotCompiledCode.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -121,0 +121,40 @@\n+    \/**\n+     * Returns the method to which this compiled nmethod belongs.\n+     *\/\n+    public HotSpotResolvedJavaMethod getMethod() {\n+        return method;\n+    }\n+\n+    \/**\n+     * Returns the bytecode index (BCI) in the {@link #getMethod() method} that is the beginning of this compiled\n+     * nmethod. -1 denotes the beginning of the method.\n+     *\n+     * @return the entry BCI of this nmethod or -1 if the entry is the method's beginning\n+     *\/\n+    public int getEntryBCI() {\n+        return entryBCI;\n+    }\n+\n+    \/**\n+     * Returns the identifier of the compilation request.\n+     *\/\n+    public int getId() {\n+        return id;\n+    }\n+\n+    \/**\n+     * Returns the address of a native {@code JVMCICompileState} object associated with this compiled nmethod.\n+     * If no such object exists, it returns 0L.\n+     *\n+     * @return the address of the native {@code JVMCICompileState} object or 0L if it does not exist\n+     *\/\n+    public long getCompileState() {\n+        return compileState;\n+    }\n+\n+    \/**\n+     * Checks if this compiled nmethod has a memory access via the {@code Unsafe} class.\n+     *\/\n+    public boolean hasUnsafeAccess() {\n+        return hasUnsafeAccess;\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotCompiledNmethod.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    public final String getName() {\n+    public String getName() {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJavaType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,7 @@\n+    \/**\n+     * Specifies whether HotSpot should profile deoptimizations for the {@code nmethod} associated\n+     * with this object. This is particularly useful for whitebox testing scenarios that involve\n+     * deoptimization.\n+     *\/\n+    private final boolean profileDeopt;\n+\n@@ -86,1 +93,1 @@\n-    HotSpotNmethod(HotSpotResolvedJavaMethodImpl method, String name, boolean isDefault, long compileId) {\n+    HotSpotNmethod(HotSpotResolvedJavaMethodImpl method, String name, boolean isDefault, boolean profileDeopt, long compileId) {\n@@ -90,0 +97,1 @@\n+        this.profileDeopt = profileDeopt;\n@@ -106,1 +114,1 @@\n-     *\n+     * <p>\n@@ -111,1 +119,2 @@\n-    @SuppressWarnings(\"unused\") private HotSpotSpeculationLog speculationLog;\n+    @SuppressWarnings(\"unused\")\n+    private HotSpotSpeculationLog speculationLog;\n@@ -121,0 +130,8 @@\n+    \/**\n+     * Determines if HotSpot should profile deoptimization for the {@code nmethod} associated\n+     * with this object.\n+     *\/\n+    public boolean profileDeopt() {\n+        return profileDeopt;\n+    }\n+\n@@ -136,1 +153,2 @@\n-     * @param deoptimize whether or not to deoptimize the method.\n+     *\n+     * @param deoptimize         whether or not to deoptimize the method.\n@@ -167,1 +185,1 @@\n-                        method, getAddress(), isDefault, name, inOopsTable());\n+                method, getAddress(), isDefault, name, inOopsTable());\n@@ -186,1 +204,1 @@\n-     *\n+     * <p>\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotNmethod.java","additions":25,"deletions":7,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-import java.lang.invoke.CallSite;\n-import java.util.Objects;\n-\n@@ -33,0 +30,4 @@\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.ConstantCallSite;\n+import java.util.Objects;\n+\n@@ -64,1 +65,20 @@\n-    JavaConstant getCallSiteTarget(Assumptions assumptions);\n+    default JavaConstant getCallSiteTarget(Assumptions assumptions) {\n+        Assumptions.AssumptionResult<JavaConstant> result = getCallSiteTarget();\n+        if (!result.canRecordTo(assumptions)) {\n+            return null;\n+        }\n+        result.recordTo(assumptions);\n+        return result.getResult();\n+    }\n+\n+    \/**\n+     * Gets the result of {@link CallSite#getTarget()} for the {@link CallSite} object represented\n+     * by this constant. The target is bound to an assumption if this is not a fully initialized\n+     * {@link ConstantCallSite}.\n+     *\n+     * @return a call-site target (possibly bound to an assumption) or {@code null} if this constant\n+     * does not represent a {@link CallSite} object\n+     *\/\n+    default Assumptions.AssumptionResult<JavaConstant> getCallSiteTarget() {\n+        throw new UnsupportedOperationException(\"getCallSiteTarget\");\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotObjectConstant.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-    public JavaConstant getCallSiteTarget(Assumptions assumptions) {\n+    public Assumptions.AssumptionResult<JavaConstant> getCallSiteTarget() {\n@@ -97,4 +97,1 @@\n-                return readTarget();\n-            }\n-            if (assumptions == null) {\n-                return null;\n+                return new Assumptions.AssumptionResult<>(readTarget());\n@@ -103,2 +100,1 @@\n-            assumptions.record(new Assumptions.CallSiteTargetValue(this, result));\n-            return result;\n+            return new Assumptions.AssumptionResult<>(result, new Assumptions.CallSiteTargetValue(this, result));\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotObjectConstantImpl.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import static jdk.vm.ci.hotspot.HotSpotResolvedJavaType.checkAreAnnotations;\n+import static jdk.vm.ci.hotspot.HotSpotResolvedJavaType.checkIsAnnotation;\n+import static jdk.vm.ci.hotspot.HotSpotResolvedJavaType.getFirstAnnotationOrNull;\n@@ -237,0 +240,1 @@\n+            checkIsAnnotation(annotationType);\n@@ -239,1 +243,1 @@\n-        return getAnnotationData0(annotationType).get(0);\n+        return getFirstAnnotationOrNull(getAnnotationData0(annotationType));\n@@ -244,0 +248,3 @@\n+        checkIsAnnotation(type1);\n+        checkIsAnnotation(type2);\n+        checkAreAnnotations(types);\n@@ -245,1 +252,1 @@\n-            return Collections.emptyList();\n+            return List.of();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaFieldImpl.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+import static jdk.vm.ci.hotspot.HotSpotResolvedJavaType.checkAreAnnotations;\n+import static jdk.vm.ci.hotspot.HotSpotResolvedJavaType.checkIsAnnotation;\n+import static jdk.vm.ci.hotspot.HotSpotResolvedJavaType.getFirstAnnotationOrNull;\n@@ -778,0 +781,1 @@\n+            checkIsAnnotation(type);\n@@ -780,1 +784,1 @@\n-        return getAnnotationData0(type).get(0);\n+        return getFirstAnnotationOrNull(getAnnotationData0(type));\n@@ -785,0 +789,3 @@\n+        checkIsAnnotation(type1);\n+        checkIsAnnotation(type2);\n+        checkAreAnnotations(types);\n@@ -786,1 +793,1 @@\n-            return Collections.emptyList();\n+            return List.of();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+import java.util.List;\n+\n+import jdk.vm.ci.meta.AnnotationData;\n@@ -30,1 +33,1 @@\n-    HotSpotResolvedObjectTypeImpl arrayOfType;\n+    HotSpotResolvedObjectType arrayOfType;\n@@ -32,1 +35,1 @@\n-    HotSpotResolvedJavaType(String name) {\n+    protected HotSpotResolvedJavaType(String name) {\n@@ -40,1 +43,1 @@\n-    public final int hashCode() {\n+    public int hashCode() {\n@@ -44,1 +47,4 @@\n-    abstract JavaConstant getJavaMirror();\n+    \/**\n+     * Gets the runtime representation of the {@link Class} object of this type.\n+     *\/\n+    public abstract JavaConstant getJavaMirror();\n@@ -46,1 +52,4 @@\n-    abstract HotSpotResolvedObjectTypeImpl getArrayType();\n+    \/**\n+     * Gets the array type of this type without caching the result.\n+     *\/\n+    protected abstract HotSpotResolvedObjectType getArrayType();\n@@ -49,1 +58,1 @@\n-    public final HotSpotResolvedObjectType getArrayClass() {\n+    public HotSpotResolvedObjectType getArrayClass() {\n@@ -63,1 +72,17 @@\n-    abstract boolean isBeingInitialized();\n+    protected abstract boolean isBeingInitialized();\n+\n+    static void checkIsAnnotation(ResolvedJavaType type) {\n+        if (!type.isAnnotation()) {\n+            throw new IllegalArgumentException(type.toJavaName() + \" is not an annotation interface\");\n+        }\n+    }\n+\n+    static void checkAreAnnotations(ResolvedJavaType... types) {\n+        for (ResolvedJavaType type : types) {\n+            checkIsAnnotation(type);\n+        }\n+    }\n+\n+    static AnnotationData getFirstAnnotationOrNull(List<AnnotationData> list) {\n+        return list.isEmpty() ? null : list.get(0);\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaType.java","additions":32,"deletions":7,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -83,0 +83,7 @@\n+    \/**\n+     * Gets the runtime representation of the {@link Class} object of this type.\n+     *\/\n+    default JavaConstant getJavaMirror() {\n+        throw new UnsupportedOperationException(\"getJavaMirror\");\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectType.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -675,1 +675,1 @@\n-    JavaConstant getJavaMirror() {\n+    public JavaConstant getJavaMirror() {\n@@ -680,1 +680,1 @@\n-    HotSpotResolvedObjectTypeImpl getArrayType() {\n+    protected HotSpotResolvedObjectTypeImpl getArrayType() {\n@@ -1123,0 +1123,1 @@\n+            checkIsAnnotation(annotationType);\n@@ -1125,1 +1126,1 @@\n-        return getAnnotationData0(annotationType).get(0);\n+        return getFirstAnnotationOrNull(getAnnotationData0(annotationType));\n@@ -1131,1 +1132,4 @@\n-            return Collections.emptyList();\n+            checkIsAnnotation(type1);\n+            checkIsAnnotation(type2);\n+            checkAreAnnotations(types);\n+            return List.of();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -64,1 +64,7 @@\n-    static HotSpotResolvedPrimitiveType forKind(JavaKind kind) {\n+    \/**\n+     * Returns a primitive type instance corresponding to the given {@link JavaKind}.\n+     *\n+     * @param kind the Java kind of the primitive type\n+     * @return the primitive type instance for the given Java kind\n+     *\/\n+    public static HotSpotResolvedPrimitiveType forKind(JavaKind kind) {\n@@ -87,1 +93,1 @@\n-    HotSpotResolvedObjectTypeImpl getArrayType() {\n+    protected HotSpotResolvedObjectType getArrayType() {\n@@ -324,1 +330,1 @@\n-    JavaConstant getJavaMirror() {\n+    public JavaConstant getJavaMirror() {\n@@ -330,0 +336,1 @@\n+        checkIsAnnotation(type);\n@@ -335,1 +342,4 @@\n-        return Collections.emptyList();\n+        checkIsAnnotation(type1);\n+        checkIsAnnotation(type2);\n+        checkAreAnnotations(types);\n+        return List.of();\n@@ -337,1 +347,0 @@\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedPrimitiveType.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Objects;\n@@ -133,1 +134,1 @@\n-        HotSpotSpeculation(SpeculationReason reason, JavaConstant id, byte[] encoding) {\n+        public HotSpotSpeculation(SpeculationReason reason, JavaConstant id, byte[] encoding) {\n@@ -143,0 +144,7 @@\n+        \/**\n+         * Returns a copy of the speculation reason encoding.\n+         *\/\n+        public byte[] getReasonEncoding() {\n+            return (encoding == null) ? null : encoding.clone();\n+        }\n+\n@@ -150,0 +158,14 @@\n+\n+        @Override\n+        public boolean equals(Object object) {\n+            if (object instanceof HotSpotSpeculation that) {\n+                return getReason().equals(that.getReason()) && id.equals(that.id) && Arrays.equals(encoding, that.encoding);\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(getReason(), id, Arrays.hashCode(encoding));\n+        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotSpeculationLog.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-    private VMField getField(String name, String cppType, boolean required) {\n+    public VMField getField(String name, String cppType, boolean required) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfigAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    VMField(String name, String type, long offset, long address, Object value) {\n+    public VMField(String name, String type, long offset, long address, Object value) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/VMField.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -116,0 +116,21 @@\n+\n+    \/**\n+     * Returns the group ID of this speculation reason.\n+     *\/\n+    public int getGroupId() {\n+        return groupId;\n+    }\n+\n+    \/**\n+     * Returns the group name of this speculation reason.\n+     *\/\n+    public String getGroupName() {\n+        return groupName;\n+    }\n+\n+    \/**\n+     * Returns a copy of the array of context objects.\n+     *\/\n+    public Object[] getContext() {\n+        return (context == null) ? null : context.clone();\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/EncodedSpeculationReason.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -53,0 +53,9 @@\n+    \/**\n+     * Returns true if this type represents an annotation interface.\n+     *\n+     * @return {@code true} if this type represents an annotation interface\n+     *\/\n+    default boolean isAnnotation() {\n+        return (getModifiers() & java.lang.reflect.AccessFlag.ANNOTATION.mask()) != 0;\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaType.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -681,8 +681,7 @@\n-        \/\/ Multiple-Inheritance: remove the interface method that may have\n-        \/\/ been overridden by another interface method in the hierarchy\n-        \/\/\n-        \/\/ Note: The following approach is very simplistic and is compatible\n-        \/\/ with old VMM. A future enhancement, may include a contention breaker,\n-        \/\/ to correctly eliminate those methods that are merely definitions\n-        \/\/ in favor of concrete overriding methods, for instance those that have\n-        \/\/ API documentation and are not abstract OR default methods.\n+        \/\/ Multiple-Inheritance: No Contention. In Java's method resolution,\n+        \/\/ any override of a signature (whether by a subclass or by a subinterface,\n+        \/\/ including when it is final from superclasses) always takes precedence\n+        \/\/ over the original interface definition. All interface methods have low resolution priority.\n+        \/\/ Therefore, when considering an interface inherited method, as soon as\n+        \/\/ at least one overrider exists in the inheritance chain,\n+        \/\/ we do not inherit the older interface definition.\n@@ -691,6 +690,1 @@\n-            if (list != null) {\n-                boolean found = list.stream()\n-                        .anyMatch(this::isDeclaredInInterface);\n-                if (found)\n-                    return false;\n-            }\n+            if (list != null && !list.isEmpty()) return false;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -40,2 +40,0 @@\n-static HANDLE memHandle = NULL;\n-\n","filename":"src\/jdk.jdi\/windows\/native\/libdt_shmem\/shmem_md.c","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-#define MUTEX_LOCK(x)           \/* FIXUP? *\/\n-#define MUTEX_UNLOCK(x)         \/* FIXUP? *\/\n+#define MUTEX_LOCK(x)   ((void) (x))        \/* FIXUP? *\/\n+#define MUTEX_UNLOCK(x) ((void) (x))        \/* FIXUP? *\/\n","filename":"src\/jdk.jdwp.agent\/windows\/native\/libjdwp\/proc_md.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.jfr.Description;\n@@ -37,0 +38,1 @@\n+@Description(\"Measures the approximate time it takes for a method to execute, including all delays, not just CPU processing time\")\n@@ -46,0 +48,1 @@\n+    @Description(\"The value may be missing (Long.MIN_VALUE) if the clock-resolution is too low to establish a minimum time\")\n@@ -50,0 +53,1 @@\n+    @Description(\"The value may be missing (Long.MIN_VALUE) if the clock-resolution is too low to establish an average time\")\n@@ -54,0 +58,1 @@\n+    @Description(\"The value may be missing (Long.MIN_VALUE) if the clock-resolution is too low to establish a maximum time\")\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/MethodTimingEvent.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -64,2 +64,2 @@\n-    public static final long MASK_THROTTLE               = 1 << 62;\n-    public static final long MASK_THROTTLE_CHECK         = 1 << 63;\n+    public static final long MASK_THROTTLE               = 1L << 62;\n+    public static final long MASK_THROTTLE_CHECK         = 1L << 63;\n@@ -485,0 +485,5 @@\n+        if (throttled) {\n+            blockCodeBuilder.aload(0);\n+            blockCodeBuilder.lload(1);\n+            putfield(blockCodeBuilder, eventClassDesc, ImplicitFields.FIELD_START_TIME);\n+        }\n@@ -494,1 +499,1 @@\n-        blockCodeBuilder.lconst_0();\n+        blockCodeBuilder.lconst_0(); \/\/ also blocks throttled event\n@@ -530,3 +535,1 @@\n-            blockCodeBuilder.aload(0);\n-            \/\/ stack: [EW] [EW] [this]\n-            getfield(blockCodeBuilder, eventClassDesc, ImplicitFields.FIELD_DURATION);\n+            getDuration(blockCodeBuilder);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -398,1 +398,1 @@\n-label = \"Java Methods that Executes the Most\"\n+label = \"Java Methods that Execute the Most\"\n@@ -474,1 +474,1 @@\n-table = \"COLUMN 'Timed Method', 'Invocations', 'Min. Time', 'Max. Time', 'Average Time'\n+table = \"COLUMN 'Timed Method', 'Invocations', 'Minimum Time', 'Average Time', 'Maximum Time'\n@@ -476,1 +476,1 @@\n-         SELECT LAST_BATCH(method) AS M, LAST_BATCH(invocations), LAST_BATCH(minimum), LAST_BATCH(maximum), LAST_BATCH(average)\n+         SELECT LAST_BATCH(method) AS M, LAST_BATCH(invocations), LAST_BATCH(minimum), LAST_BATCH(average), LAST_BATCH(maximum)\n@@ -521,4 +521,4 @@\n-table = \"COLUMN 'Method', 'Samples', 'Percent'\n-         FORMAT none, none, normalized\n-         SELECT stackTrace.topFrame AS T, COUNT(*), COUNT(*)\n-         FROM NativeMethodSample GROUP BY T\"\n+table = \"COLUMN 'Method', 'Samples'\n+         FORMAT none, none\n+         SELECT stackTrace.topFrame AS T, COUNT(*) AS C\n+         FROM NativeMethodSample GROUP BY T ORDER BY C DESC\"\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/view.ini","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+    private static final long MISSING = Long.MIN_VALUE;\n@@ -63,1 +64,0 @@\n-                long average = invocations == 0 ? Long.MIN_VALUE : time \/ invocations;\n@@ -65,3 +65,0 @@\n-                if (min == Long.MAX_VALUE) {\n-                    min = Long.MIN_VALUE; \/\/ Signals that the value is missing\n-                }\n@@ -69,1 +66,15 @@\n-                MethodTimingEvent.commit(timestamp, methodId, invocations, min, average, max);\n+                if (time == 0 || invocations == 0) {\n+                    \/\/ If time is zero, it's a low resolution clock and more invocations are needed.\n+                    MethodTimingEvent.commit(timestamp, methodId, invocations, MISSING, MISSING, MISSING);\n+                } else {\n+                    long average = (time + invocations \/ 2) \/ invocations;\n+                    if (min == Long.MAX_VALUE) {\n+                        min = average;\n+                    }\n+                    if (max == Long.MIN_VALUE) {\n+                        max = average;\n+                    }\n+                    min = Math.min(min, average);\n+                    max = Math.max(max, average);\n+                    MethodTimingEvent.commit(timestamp, methodId, invocations, min, average, max);\n+                }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/TimedClass.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -42,0 +42,3 @@\n+        if (duration == 0) {\n+            return; \/\/ Ignore data due to low-resolution clock\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/TimedMethod.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,1 +183,0 @@\n-    const DWORD neutralLangId = (0x04b0 | MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL) << 16);\n","filename":"src\/jdk.jpackage\/windows\/native\/libjpackage\/VersionInfo.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -846,1 +846,1 @@\n-            pendingLine = null;\n+            pendingLineCharacters = null;\n@@ -980,2 +980,2 @@\n-    private String pendingLine;\n-    private int pendingLinePointer;\n+    private char[] pendingLineCharacters;\n+    private int pendingLineCharactersPointer;\n@@ -988,1 +988,5 @@\n-            char userChar = readUserInputChar();\n+            int userCharInput = readUserInputChar();\n+            if (userCharInput == (-1)) {\n+                return -1;\n+            }\n+            char userChar = (char) userCharInput;\n@@ -994,3 +998,5 @@\n-                char lowSurrogate = readUserInputChar();\n-                if (Character.isLowSurrogate(lowSurrogate)) {\n-                    dataToConvert.append(lowSurrogate);\n+                int lowSurrogateInput = readUserInputChar();\n+                if (lowSurrogateInput == (-1)) {\n+                    \/\/end of input, ignore at this stage\n+                } else if (Character.isLowSurrogate((char) lowSurrogateInput)) {\n+                    dataToConvert.append((char) lowSurrogateInput);\n@@ -999,1 +1005,1 @@\n-                    pendingLinePointer--;\n+                    pendingLineCharactersPointer--;\n@@ -1009,4 +1015,13 @@\n-    public synchronized char readUserInputChar() throws IOException {\n-        while (pendingLine == null || pendingLine.length() <= pendingLinePointer) {\n-            pendingLine = doReadUserLine(\"\", null) + System.getProperty(\"line.separator\");\n-            pendingLinePointer = 0;\n+    public synchronized int readUserInputChar() throws IOException {\n+        if (pendingLineCharacters != null && pendingLineCharacters.length == 0) {\n+            return -1;\n+        }\n+        while (pendingLineCharacters == null || pendingLineCharacters.length <= pendingLineCharactersPointer) {\n+            String readLine = doReadUserLine(\"\", null);\n+            if (readLine == null) {\n+                pendingLineCharacters = new char[0];\n+                return -1;\n+            } else {\n+                pendingLineCharacters = (readLine + System.getProperty(\"line.separator\")).toCharArray();\n+            }\n+            pendingLineCharactersPointer = 0;\n@@ -1014,1 +1029,1 @@\n-        return pendingLine.charAt(pendingLinePointer++);\n+        return pendingLineCharacters[pendingLineCharactersPointer++];\n@@ -1020,2 +1035,6 @@\n-        if (pendingLine != null && pendingLine.length() > pendingLinePointer) {\n-            return pendingLine.substring(pendingLinePointer);\n+        if (pendingLineCharacters != null && pendingLineCharacters.length > pendingLineCharactersPointer) {\n+            String result = new String(pendingLineCharacters,\n+                                       pendingLineCharactersPointer,\n+                                       pendingLineCharacters.length - pendingLineCharactersPointer);\n+            pendingLineCharacters = null;\n+            return result;\n@@ -1044,0 +1063,2 @@\n+        } catch (EndOfFileException ex) {\n+            return null; \/\/ Signal that Ctrl+D or similar happened\n@@ -1054,1 +1075,5 @@\n-        return doReadUserLine(prompt, '\\0').toCharArray();\n+        String line = doReadUserLine(prompt, '\\0');\n+        if (line == null) {\n+            return null;\n+        }\n+        return line.toCharArray();\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/ConsoleIOContext.java","additions":41,"deletions":16,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.org.jline.reader.UserInterruptException;\n@@ -62,2 +61,2 @@\n-    public char readUserInputChar() throws IOException {\n-        throw new UserInterruptException(\"\");\n+    public int readUserInputChar() throws IOException {\n+        return -1;\n@@ -69,1 +68,1 @@\n-        throw new UserInterruptException(\"\");\n+        return null;\n@@ -73,1 +72,1 @@\n-        throw new UserInterruptException(\"\");\n+        return null;\n@@ -83,1 +82,1 @@\n-        throw new UserInterruptException(\"\");\n+        return null;\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/IOContext.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -4124,1 +4124,5 @@\n-                            cbuf[off] = input.readUserInputChar();\n+                            int r = input.readUserInputChar();\n+                            if (r == (-1)) {\n+                                return -1;\n+                            }\n+                            cbuf[off] = (char) r;\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/JShellTool.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -185,0 +185,3 @@\n+                        if (len == 0) {\n+                            return 0;\n+                        }\n@@ -187,1 +190,7 @@\n-                            return readChars(cbuf, off, len);\n+                            int r = readInt();\n+                            if (r == (-1)) {\n+                                return -1;\n+                            } else {\n+                                cbuf[off] = (char) r;\n+                                return 1;\n+                            }\n@@ -377,7 +386,3 @@\n-                    if (bp >= 5) {\n-                        int len = readInt(1);\n-                        int c = console.reader().read();\n-                        \/\/XXX: EOF handling!\n-                        sendChars(sinkOutput, new char[] {(char) c}, 0, 1);\n-                        bp = 0;\n-                    }\n+                    int c = console.reader().read();\n+                    sendInt(sinkOutput, c);\n+                    bp = 0;\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/impl\/ConsoleImpl.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    old = new ShenandoahOldGeneration(8, 1024 * 1024, 1024);\n+    old = new ShenandoahOldGeneration(8, 1024 * 1024);\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahOldGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-TEST(GuardedMemory, basic) {\n+TEST_VM(GuardedMemory, basic) {\n@@ -81,1 +81,1 @@\n-TEST(GuardedMemory, odd_sizes) {\n+TEST_VM(GuardedMemory, odd_sizes) {\n@@ -102,1 +102,1 @@\n-TEST(GuardedMemory, buffer_overrun_head) {\n+TEST_VM(GuardedMemory, buffer_overrun_head) {\n@@ -114,1 +114,1 @@\n-TEST(GuardedMemory, buffer_overrun_tail) {\n+TEST_VM(GuardedMemory, buffer_overrun_tail) {\n@@ -131,1 +131,1 @@\n-TEST(GuardedMemory, wrap) {\n+TEST_VM(GuardedMemory, wrap) {\n@@ -149,0 +149,7 @@\n+\n+\/\/ Test passing back a bogus GuardedMemory region\n+TEST_VM(GuardedMemory, unmapped) {\n+  char* unmapped_base = (char*) (GuardedMemoryTest::get_guard_header_size() + 0x1000 + 1); \/\/ Avoids assert in constructor\n+  GuardedMemory guarded(unmapped_base);\n+  EXPECT_FALSE(guarded.verify_guards()) << \"Guard was not broken as expected\";\n+}\n","filename":"test\/hotspot\/gtest\/memory\/test_guardedMemory.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @requires os.arch==\"aarch64\" | os.arch==\"amd64\" | os.arch == \"ppc64le\" | os.arch == \"riscv64\"\n+ * @requires os.arch==\"aarch64\" | os.arch==\"amd64\" | os.arch == \"ppc64\" | os.arch == \"ppc64le\" | os.arch == \"riscv64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestBit.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -87,5 +86,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                  UseCompactObjectHeaders=true\n-            \/\/ I_adr = base + 16 + 4*i  ->  i % 2 = 0         B_adr = base + 12 + 4*i  ->  i % 2 = 1\n-            \/\/ N_adr = base      + 4*i  ->  i % 2 = 0         N_adr = base      + 4*i  ->  i % 2 = 0\n-            \/\/ -> vectorize                                   -> no vectorization\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestCastX2NotProcessedIGVN.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -411,1 +411,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -417,4 +416,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                        UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 8*i      ->  always                adr = base + 12 + 8*i      ->  never\n-            \/\/ -> vectorize                                         -> no vectorization\n@@ -429,1 +424,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -435,4 +429,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                        UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 8*i      ->  always                adr = base + 12 + 8*i      ->  never\n-            \/\/ -> vectorize                                         -> no vectorization\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorConditionalMove.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -168,1 +168,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -176,5 +175,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                  UseCompactObjectHeaders=true\n-            \/\/ B_adr = base + 16 + 8*i  ->  always            B_adr = base + 12 + 8*i  ->  never\n-            \/\/ L_adr = base + 16 + 8*i  ->  always            L_adr = base + 16 + 8*i  ->  always\n-            \/\/ -> vectorize                                   -> no vectorization\n@@ -186,1 +180,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -193,5 +186,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                  UseCompactObjectHeaders=true\n-            \/\/ B_adr = base + 16 + 8*i  ->  always            B_adr = base + 12 + 8*i  ->  never\n-            \/\/ L_adr = base + 16 + 8*i  ->  always            L_adr = base + 16 + 8*i  ->  always\n-            \/\/ -> vectorize                                   -> no vectorization\n@@ -208,5 +196,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                  UseCompactObjectHeaders=true\n-            \/\/ B_adr = base + 64 + 8*i  ->  always            B_adr = base + 64 + 8*i  ->  always\n-            \/\/ L_adr = base + 16 + 8*i  ->  always            L_adr = base + 16 + 8*i  ->  always\n-            \/\/ -> vectorize                                   -> vectorize\n@@ -225,5 +208,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                  UseCompactObjectHeaders=true\n-            \/\/ B_adr = base + 64 + 8*i  ->  always            B_adr = base + 64 + 8*i  ->  always\n-            \/\/ L_adr = base + 16 + 8*i  ->  always            L_adr = base + 16 + 8*i  ->  always\n-            \/\/ -> vectorize                                   -> vectorize\n@@ -243,1 +221,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -251,5 +228,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                      UseCompactObjectHeaders=true\n-            \/\/ B_adr = base + 16 + 8*(i-1)  ->  always            B_adr = base + 12 + 8*(i-1)  ->  never\n-            \/\/ L_adr = base + 16 + 8*i      ->  always            L_adr = base + 16 + 8*i      ->  always\n-            \/\/ -> vectorize                                       -> no vectorization\n@@ -261,1 +233,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -268,5 +239,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                      UseCompactObjectHeaders=true\n-            \/\/ B_adr = base + 16 + 8*(i-1)  ->  always            B_adr = base + 12 + 8*(i-1)  ->  never\n-            \/\/ L_adr = base + 16 + 8*i      ->  always            L_adr = base + 16 + 8*i      ->  always\n-            \/\/ -> vectorize                                       -> no vectorization\n@@ -284,1 +250,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -292,5 +257,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                      UseCompactObjectHeaders=true\n-            \/\/ B_adr = base + 16 + 8*(i+1)  ->  always            B_adr = base + 12 + 8*(i+1)  ->  never\n-            \/\/ L_adr = base + 16 + 8*i      ->  always            L_adr = base + 16 + 8*i      ->  always\n-            \/\/ -> vectorize                                       -> no vectorization\n@@ -302,1 +262,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -309,5 +268,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                      UseCompactObjectHeaders=true\n-            \/\/ B_adr = base + 16 + 8*(i+1)  ->  always            B_adr = base + 12 + 8*(i+1)  ->  never\n-            \/\/ L_adr = base + 16 + 8*i      ->  always            L_adr = base + 16 + 8*i      ->  always\n-            \/\/ -> vectorize                                       -> no vectorization\n@@ -359,1 +313,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -367,5 +320,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                      UseCompactObjectHeaders=true\n-            \/\/ B_adr = base + 16 + 8*(i+x)  ->  always            B_adr = base + 12 + 8*(i+x)  ->  never\n-            \/\/ L_adr = base + 16 + 8*i      ->  always            L_adr = base + 16 + 8*i      ->  always\n-            \/\/ -> vectorize                                       -> no vectorization\n@@ -377,1 +325,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -384,5 +331,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                      UseCompactObjectHeaders=true\n-            \/\/ B_adr = base + 16 + 8*(i+x)  ->  always            B_adr = base + 12 + 8*(i+x)  ->  never\n-            \/\/ L_adr = base + 16 + 8*i      ->  always            L_adr = base + 16 + 8*i      ->  always\n-            \/\/ -> vectorize                                       -> no vectorization\n@@ -401,1 +343,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -409,5 +350,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                    UseCompactObjectHeaders=true\n-            \/\/ src_adr = base + 16 + 8*i  ->  always            src_adr = base + 12 + 8*i  ->  never\n-            \/\/ dst_adr = base + 16 + 8*i  ->  always            dst_adr = base + 12 + 8*i  ->  never\n-            \/\/ -> vectorize                                     -> no vectorization\n@@ -419,1 +355,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -426,5 +361,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                    UseCompactObjectHeaders=true\n-            \/\/ src_adr = base + 16 + 8*i  ->  always            src_adr = base + 12 + 8*i  ->  never\n-            \/\/ dst_adr = base + 16 + 8*i  ->  always            dst_adr = base + 12 + 8*i  ->  never\n-            \/\/ -> vectorize                                     -> no vectorization\n@@ -442,1 +372,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -450,5 +379,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                        UseCompactObjectHeaders=true\n-            \/\/ src_adr = base + 16 + 8*i      ->  always            src_adr = base + 12 + 8*i      ->  never\n-            \/\/ dst_adr = base + 16 + 8*(i-1)  ->  always            dst_adr = base + 12 + 8*(i-1)  ->  never\n-            \/\/ -> vectorize                                         -> no vectorization\n@@ -460,1 +384,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -467,5 +390,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                        UseCompactObjectHeaders=true\n-            \/\/ src_adr = base + 16 + 8*i      ->  always            src_adr = base + 12 + 8*i      ->  never\n-            \/\/ dst_adr = base + 16 + 8*(i-1)  ->  always            dst_adr = base + 12 + 8*(i-1)  ->  never\n-            \/\/ -> vectorize                                         -> no vectorization\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizationMismatchedAccess.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\" },\n@@ -75,4 +74,0 @@\n-            \/\/ For UseCompactObjectHeaders and AlignVector, we must 8-byte align all vector loads\/stores.\n-            \/\/ But the long-stores to the byte-array are never aligned:\n-            \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizationNotRun.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -64,2 +64,1 @@\n-    @IR(applyIf = {\"UseCompactObjectHeaders\", \"false\"},\n-        counts = {IRNode.CALL_OF, \"arrayof_jshort_disjoint_arraycopy\", \">0\"})\n+    @IR(counts = {IRNode.CALL_OF, \"arrayof_jshort_disjoint_arraycopy\", \">0\"})\n@@ -74,12 +73,1 @@\n-    @IR(applyIf = {\"UseCompactObjectHeaders\", \"true\"},\n-        counts = {IRNode.CALL_OF, \"arrayof_jshort_disjoint_arraycopy\", \"0\"})\n-    static void testSBToStringUnAligned() {\n-        \/\/ Exercise the StringBuilder.toString API\n-        StringBuilder sb = new StringBuilder(input_strU);\n-        output_strU = sb.append(input_strU).toString();\n-    }\n-\n-    @Test\n-    @Warmup(10000)\n-    @IR(applyIf = {\"UseCompactObjectHeaders\", \"false\"},\n-        counts = {IRNode.CALL_OF, \"arrayof_jshort_disjoint_arraycopy\", \">0\"})\n+    @IR(counts = {IRNode.CALL_OF, \"arrayof_jshort_disjoint_arraycopy\", \">0\"})\n@@ -93,11 +81,1 @@\n-    @IR(applyIf = {\"UseCompactObjectHeaders\", \"true\"},\n-        counts = {IRNode.CALL_OF, \"arrayof_jshort_disjoint_arraycopy\", \"0\"})\n-    static void testStrUGetCharsUnAligned() {\n-        \/\/ Exercise the StringUTF16.getChars API\n-        output_arrU = input_strU.toCharArray();\n-    }\n-\n-    @Test\n-    @Warmup(10000)\n-    @IR(applyIf = {\"UseCompactObjectHeaders\", \"false\"},\n-        counts = {IRNode.CALL_OF, \"arrayof_jshort_disjoint_arraycopy\", \">0\"})\n+    @IR(counts = {IRNode.CALL_OF, \"arrayof_jshort_disjoint_arraycopy\", \">0\"})\n@@ -109,9 +87,0 @@\n-    @Test\n-    @Warmup(10000)\n-    @IR(applyIf = {\"UseCompactObjectHeaders\", \"true\"},\n-        counts = {IRNode.CALL_OF, \"arrayof_jshort_disjoint_arraycopy\", \"0\"})\n-    static void testStrUtoBytesUnAligned() {\n-        \/\/ Exercise the StringUTF16.toBytes API\n-        output_strU = String.valueOf(input_arrU);\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stringopts\/TestArrayCopySelect.java","additions":3,"deletions":34,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -227,0 +227,1 @@\n+    \/\/ TODO: Make tests more precise\n@@ -231,1 +232,1 @@\n-    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \"=5\"},\n+    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \">=5\"},\n@@ -233,4 +234,1 @@\n-        applyIfAnd = {\"OptoPeephole\", \"false\", \"UseAVX\", \">=2\"})\n-    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \"=13\"},\n-        phase = {CompilePhase.FINAL_CODE},\n-        applyIfAnd = {\"OptoPeephole\", \"false\", \"UseAVX\", \"<2\"})\n+        applyIf = {\"OptoPeephole\", \"false\"})\n@@ -238,1 +236,1 @@\n-    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \"=3\"},\n+    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \">=3\"},\n@@ -240,4 +238,1 @@\n-        applyIfAnd = {\"OptoPeephole\", \"true\", \"UseAVX\", \">=2\"})\n-    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \"=11\"},\n-        phase = {CompilePhase.FINAL_CODE},\n-        applyIfAnd = {\"OptoPeephole\", \"true\", \"UseAVX\", \"<2\"})\n+        applyIf = {\"OptoPeephole\", \"true\"})\n@@ -261,0 +256,1 @@\n+    \/\/ TODO: Make tests more precise\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestRedundantLea.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -33,1 +33,2 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"ppc64\" | os.arch==\"ppc64le\"\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestCompareUnsigned.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-        return codeCache.addCode(dummyMethod, code, log, installedCode);\n+        return codeCache.addCode(dummyMethod, code, log, installedCode, true);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/CodeInstallerTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -309,1 +309,1 @@\n-            super(method, name, false, 0);\n+            super(method, name, false, true, 0);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/patches\/jdk.internal.vm.ci\/jdk\/vm\/ci\/hotspot\/CompilerToVMHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-            InstalledCode installed = codeCache.addCode(resolvedMethod, code, null, null);\n+            InstalledCode installed = codeCache.addCode(resolvedMethod, code, null, null, true);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/CodeInstallationTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-                codeCache.installCode(null, stub, null, null, true);\n+                codeCache.installCode(null, stub, null, null, true, true);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/RuntimeStubAllocFailTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -161,0 +161,10 @@\n+    @Test\n+    public void isAnnotationTest() {\n+        for (Class<?> c : classes) {\n+            ResolvedJavaType type = metaAccess.lookupJavaType(c);\n+            boolean expected = c.isAnnotation();\n+            boolean actual = type.isAnnotation();\n+            assertEquals(expected, actual);\n+        }\n+    }\n+\n@@ -1270,0 +1280,15 @@\n+    private static void getAnnotationDataExpectedToFail(Annotated annotated, ResolvedJavaType... annotationTypes) {\n+        try {\n+            if (annotationTypes.length == 1) {\n+                annotated.getAnnotationData(annotationTypes[0]);\n+            } else {\n+                var tail = Arrays.copyOfRange(annotationTypes, 2, annotationTypes.length);\n+                annotated.getAnnotationData(annotationTypes[0], annotationTypes[1], tail);\n+            }\n+            String s = Stream.of(annotationTypes).map(ResolvedJavaType::toJavaName).collect(Collectors.joining(\", \"));\n+            throw new AssertionError(\"Expected IllegalArgumentException for retrieving (\" + s + \" from \" + annotated);\n+        } catch (IllegalArgumentException iae) {\n+            assertTrue(iae.getMessage(), iae.getMessage().contains(\"not an annotation interface\"));\n+        }\n+    }\n+\n@@ -1275,1 +1300,1 @@\n-     * @param annotated a {@link Class}, {@link Method} or {@link Field} object\n+     * @param annotatedElement a {@link Class}, {@link Method} or {@link Field} object\n@@ -1277,5 +1302,20 @@\n-    public static void getAnnotationDataTest(AnnotatedElement annotated) throws Exception {\n-        testGetAnnotationData(annotated, List.of(annotated.getAnnotations()));\n-    }\n-\n-    private static void testGetAnnotationData(AnnotatedElement annotated, List<Annotation> annotations) throws AssertionError {\n+    public static void getAnnotationDataTest(AnnotatedElement annotatedElement) throws Exception {\n+        Annotated annotated = toAnnotated(annotatedElement);\n+        ResolvedJavaType objectType = metaAccess.lookupJavaType(Object.class);\n+        ResolvedJavaType suppressWarningsType = metaAccess.lookupJavaType(SuppressWarnings.class);\n+        getAnnotationDataExpectedToFail(annotated, objectType);\n+        getAnnotationDataExpectedToFail(annotated, suppressWarningsType, objectType);\n+        getAnnotationDataExpectedToFail(annotated, suppressWarningsType, suppressWarningsType, objectType);\n+\n+        \/\/ Check that querying a missing annotation returns null or an empty list\n+        assertNull(annotated.getAnnotationData(suppressWarningsType));\n+        List<AnnotationData> data = annotated.getAnnotationData(suppressWarningsType, suppressWarningsType);\n+        assertTrue(data.toString(), data.isEmpty());\n+        data = annotated.getAnnotationData(suppressWarningsType, suppressWarningsType, suppressWarningsType, suppressWarningsType);\n+        assertTrue(data.toString(), data.isEmpty());\n+\n+        testGetAnnotationData(annotatedElement, annotated, List.of(annotatedElement.getAnnotations()));\n+    }\n+\n+    private static void testGetAnnotationData(AnnotatedElement annotatedElement, Annotated annotated, List<Annotation> annotations) throws AssertionError {\n+        ResolvedJavaType suppressWarningsType = metaAccess.lookupJavaType(SuppressWarnings.class);\n@@ -1283,1 +1323,2 @@\n-            AnnotationData ad = toAnnotated(annotated).getAnnotationData(metaAccess.lookupJavaType(a.annotationType()));\n+            var annotationType = metaAccess.lookupJavaType(a.annotationType());\n+            AnnotationData ad = annotated.getAnnotationData(annotationType);\n@@ -1287,1 +1328,1 @@\n-            AnnotationData ad2 = toAnnotated(annotated).getAnnotationData(metaAccess.lookupJavaType(a.annotationType()));\n+            AnnotationData ad2 = annotated.getAnnotationData(annotationType);\n@@ -1289,0 +1330,3 @@\n+\n+            List<AnnotationData> annotationData = annotated.getAnnotationData(annotationType, suppressWarningsType, suppressWarningsType);\n+            assertEquals(1, annotationData.size());\n@@ -1301,1 +1345,1 @@\n-            List<AnnotationData> annotationData = toAnnotated(annotated).getAnnotationData(type1, type2, types);\n+            List<AnnotationData> annotationData = annotated.getAnnotationData(type1, type2, types);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":53,"deletions":9,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -140,2 +140,1 @@\n-        tests.put(\"test1a\",      () -> { return test1a(aB.clone(), bB.clone(), mB); });\n-        tests.put(\"test1b\",      () -> { return test1b(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test1\",       () -> { return test1(aB.clone(), bB.clone(), mB); });\n@@ -156,1 +155,0 @@\n-        tests.put(\"test10e\",     () -> { return test10e(aS.clone(), bS.clone(), mS); });\n@@ -226,2 +224,1 @@\n-                 \"test1a\",\n-                 \"test1b\",\n+                 \"test1\",\n@@ -240,1 +237,0 @@\n-                 \"test10e\",\n@@ -431,3 +427,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n-        \/\/ UNSAFE.ARRAY_BYTE_BASE_OFFSET = 16, but with compact object headers UNSAFE.ARRAY_BYTE_BASE_OFFSET=12.\n-        \/\/ If AlignVector=true, we need the offset to be 8-byte aligned, else the vectors are filtered out.\n@@ -436,1 +429,1 @@\n-    static Object[] test1a(byte[] a, byte[] b, byte mask) {\n+    static Object[] test1(byte[] a, byte[] b, byte mask) {\n@@ -450,23 +443,0 @@\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n-                  IRNode.AND_VB, \"> 0\",\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"true\", \"AlignVector\", \"false\"},\n-        \/\/ UNSAFE.ARRAY_BYTE_BASE_OFFSET = 16, but with compact object headers UNSAFE.ARRAY_BYTE_BASE_OFFSET=12.\n-        \/\/ If AlignVector=true, we need the offset to be 8-byte aligned, else the vectors are filtered out.\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    static Object[] test1b(byte[] a, byte[] b, byte mask) {\n-        for (int i = 4; i < RANGE-8; i+=8) {\n-            b[i+0] = (byte)(a[i+0] & mask); \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4 + iter*8\n-            b[i+1] = (byte)(a[i+1] & mask);\n-            b[i+2] = (byte)(a[i+2] & mask);\n-            b[i+3] = (byte)(a[i+3] & mask);\n-            b[i+4] = (byte)(a[i+4] & mask);\n-            b[i+5] = (byte)(a[i+5] & mask);\n-            b[i+6] = (byte)(a[i+6] & mask);\n-            b[i+7] = (byte)(a[i+7] & mask);\n-        }\n-        return new Object[]{ a, b };\n-    }\n-\n@@ -764,3 +734,1 @@\n-        applyIfAnd = {\"MaxVectorSize\", \">=16\", \"UseCompactObjectHeaders\", \"false\"},\n-        \/\/ UNSAFE.ARRAY_BYTE_BASE_OFFSET = 16, but with compact object headers UNSAFE.ARRAY_BYTE_BASE_OFFSET=12.\n-        \/\/ If AlignVector=true, we need the offset to be 8-byte aligned, else the vectors are filtered out.\n+        applyIf = {\"MaxVectorSize\", \">=16\"},\n@@ -780,20 +748,0 @@\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.AND_VS,        IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"MaxVectorSize\", \">=16\", \"UseCompactObjectHeaders\", \"true\"},\n-        \/\/ UNSAFE.ARRAY_BYTE_BASE_OFFSET = 16, but with compact object headers UNSAFE.ARRAY_BYTE_BASE_OFFSET=12.\n-        \/\/ If AlignVector=true, we need the offset to be 8-byte aligned, else the vectors are filtered out.\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    static Object[] test10e(short[] a, short[] b, short mask) {\n-        for (int i = 11; i < RANGE-16; i+=8) {\n-            \/\/ adr = base + UNSAFE.ARRAY_SHORT_BASE_OFFSET + 2*(3 + 11) + iter*16\n-            b[i+0+3] = (short)(a[i+0+3] & mask);\n-            b[i+1+3] = (short)(a[i+1+3] & mask);\n-            b[i+2+3] = (short)(a[i+2+3] & mask);\n-            b[i+3+3] = (short)(a[i+3+3] & mask);\n-        }\n-        return new Object[]{ a, b };\n-    }\n-\n@@ -1082,1 +1030,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -1087,13 +1034,0 @@\n-            \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET  + 4*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ For AlignVector, all adr must be 8-byte aligned. Let's see for which iteration this can hold:\n-            \/\/ If UseCompactObjectHeaders=false:\n-            \/\/   a: 0, 8, 16, 24, 32, ...\n-            \/\/   b: 0, 2,  4,  6,  8, ...\n-            \/\/   -> Ok, aligns every 8th iteration.\n-            \/\/ If UseCompactObjectHeaders=true:\n-            \/\/   a: 4, 12, 20, 28, 36, ...\n-            \/\/   b: 1,  3,  5,  7,  9, ...\n-            \/\/   -> we can never align both vectors!\n@@ -1112,1 +1046,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -1117,13 +1050,0 @@\n-            \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ adr = base + UNSAFE.ARRAY_SHORT_BASE_OFFSET + 2*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ For AlignVector, all adr must be 8-byte aligned. Let's see for which iteration this can hold:\n-            \/\/ If UseCompactObjectHeaders=false:\n-            \/\/   a: iter % 2 == 0\n-            \/\/   b: iter % 4 == 0\n-            \/\/   -> Ok, aligns every 4th iteration.\n-            \/\/ If UseCompactObjectHeaders=true:\n-            \/\/   a: iter % 2 = 1\n-            \/\/   b: iter % 4 = 2\n-            \/\/   -> we can never align both vectors!\n@@ -1146,1 +1066,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -1151,12 +1070,0 @@\n-            \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ adr = base + UNSAFE.ARRAY_SHORT_BASE_OFFSET + 2*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 4*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ adr = base + UNSAFE.ARRAY_LONG_BASE_OFFSET + 8*iter\n-            \/\/              = 16 (always)\n-            \/\/ If AlignVector and UseCompactObjectHeaders, and we want all adr 8-byte aligned:\n-            \/\/   a: iter % 8 = 4\n-            \/\/   c: iter % 2 = 1\n-            \/\/   -> can never align both vectors!\n@@ -1194,1 +1101,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -1199,8 +1105,0 @@\n-            \/\/ adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 4 + 4*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1 + 1*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ If AlignVector and UseCompactObjectHeaders, and we want all adr 8-byte aligned:\n-            \/\/   a: iter % 2 = 0\n-            \/\/   b: iter % 8 = 3\n-            \/\/   -> can never align both vectors!\n@@ -1219,1 +1117,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -1224,8 +1121,0 @@\n-            \/\/ adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 4 + 4*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ adr = base + UNSAFE.ARRAY_SHORT_BASE_OFFSET + 2 + 2*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ If AlignVector and UseCompactObjectHeaders, and we want all adr 8-byte aligned:\n-            \/\/   a: iter % 2 = 0\n-            \/\/   b: iter % 4 = 1\n-            \/\/   -> can never align both vectors!\n@@ -1248,1 +1137,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -1253,12 +1141,0 @@\n-            \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1 + 1*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ adr = base + UNSAFE.ARRAY_SHORT_BASE_OFFSET + 2 + 2*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 4 + 4*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ adr = base + UNSAFE.ARRAY_LONG_BASE_OFFSET + 8 + 8*iter\n-            \/\/              = 16 (always)\n-            \/\/ If AlignVector and UseCompactObjectHeaders, and we want all adr 8-byte aligned:\n-            \/\/   a: iter % 8 = 3\n-            \/\/   c: iter % 2 = 0\n-            \/\/   -> can never align both vectors!\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAlignVector.java","additions":4,"deletions":128,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -133,1 +133,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -143,4 +142,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 8*i   ->  always            adr = base + 12 + 8*i   ->  never\n-            \/\/ -> vectorize                                  -> no vectorization\n@@ -163,1 +158,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -173,4 +167,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 8*i   ->  always            adr = base + 12 + 8*i   ->  never\n-            \/\/ -> vectorize                                  -> no vectorization\n@@ -192,1 +182,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -202,4 +191,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 8*i   ->  always            adr = base + 12 + 8*i   ->  never\n-            \/\/ -> vectorize                                  -> no vectorization\n@@ -222,1 +207,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -234,4 +218,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 8*i   ->  always            adr = base + 12 + 8*i   ->  never\n-            \/\/ -> vectorize                                  -> no vectorization\n@@ -304,1 +284,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -323,4 +302,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 8*i   ->  always            adr = base + 12 + 8*i   ->  never\n-            \/\/ -> vectorize                                  -> no vectorization\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestIndependentPacksWithCyclicDependency.java","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -168,1 +168,0 @@\n-        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\" },\n@@ -171,1 +170,1 @@\n-        applyIfAnd = {\"MaxVectorSize\", \"16\", \"UseCompactObjectHeaders\", \"false\"}, \/\/ AD file requires vector_length = 16\n+        applyIf = {\"MaxVectorSize\", \"16\"}, \/\/ AD file requires vector_length = 16\n@@ -174,1 +173,0 @@\n-        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\" },\n@@ -181,7 +179,0 @@\n-            \/\/ Hand-unrolling can mess with AlignVector and UseCompactObjectHeaders.\n-            \/\/ We need all addresses 8-byte aligned.\n-            \/\/\n-            \/\/ out:\n-            \/\/   adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 8*iter\n-            \/\/                = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ -> never aligned!\n@@ -195,1 +186,0 @@\n-        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\" },\n@@ -198,1 +188,1 @@\n-        applyIfAnd = {\"MaxVectorSize\", \"16\", \"UseCompactObjectHeaders\", \"false\" }, \/\/ AD file requires vector_length = 16\n+        applyIf = {\"MaxVectorSize\", \"16\"}, \/\/ AD file requires vector_length = 16\n@@ -201,1 +191,0 @@\n-        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\" },\n@@ -208,7 +197,0 @@\n-            \/\/ Hand-unrolling can mess with AlignVector and UseCompactObjectHeaders.\n-            \/\/ We need all addresses 8-byte aligned.\n-            \/\/\n-            \/\/ out:\n-            \/\/   adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 8*iter\n-            \/\/                = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ -> never aligned!\n@@ -222,1 +204,0 @@\n-        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\" },\n@@ -225,1 +206,1 @@\n-        applyIfAnd = {\"MaxVectorSize\", \"16\", \"UseCompactObjectHeaders\", \"false\" }, \/\/ AD file requires vector_length = 16\n+        applyIf = {\"MaxVectorSize\", \"16\"}, \/\/ AD file requires vector_length = 16\n@@ -228,1 +209,0 @@\n-        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\" },\n@@ -235,7 +215,0 @@\n-            \/\/ Hand-unrolling can mess with AlignVector and UseCompactObjectHeaders.\n-            \/\/ We need all addresses 8-byte aligned.\n-            \/\/\n-            \/\/ out:\n-            \/\/   adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 8*iter\n-            \/\/                = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ -> never aligned!\n@@ -249,1 +222,0 @@\n-        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\" },\n@@ -252,1 +224,1 @@\n-        applyIfAnd = {\"MaxVectorSize\", \"16\", \"UseCompactObjectHeaders\", \"false\" }, \/\/ AD file requires vector_length = 16\n+        applyIf = {\"MaxVectorSize\", \"16\"}, \/\/ AD file requires vector_length = 16\n@@ -255,1 +227,0 @@\n-        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\" },\n@@ -262,7 +233,0 @@\n-            \/\/ Hand-unrolling can mess with AlignVector and UseCompactObjectHeaders.\n-            \/\/ We need all addresses 8-byte aligned.\n-            \/\/\n-            \/\/ out:\n-            \/\/   adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 8*iter\n-            \/\/                = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ -> never aligned!\n@@ -276,1 +240,0 @@\n-        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\" },\n@@ -279,1 +242,1 @@\n-        applyIfAnd = {\"MaxVectorSize\", \"16\", \"UseCompactObjectHeaders\", \"false\" }, \/\/ AD file requires vector_length = 16\n+        applyIf = {\"MaxVectorSize\", \"16\"}, \/\/ AD file requires vector_length = 16\n@@ -282,1 +245,0 @@\n-        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\" },\n@@ -289,7 +251,0 @@\n-            \/\/ Hand-unrolling can mess with AlignVector and UseCompactObjectHeaders.\n-            \/\/ We need all addresses 8-byte aligned.\n-            \/\/\n-            \/\/ out:\n-            \/\/   adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 8*iter\n-            \/\/                = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ -> never aligned!\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMulAddS2I.java","additions":5,"deletions":50,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -94,1 +94,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -119,4 +118,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 8*i   ->  always            adr = base + 12 + 8*i   ->  never\n-            \/\/ -> vectorize                                  -> no vectorization\n@@ -139,1 +134,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -149,4 +143,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 8*i   ->  always            adr = base + 12 + 8*i   ->  never\n-            \/\/ -> vectorize                                  -> no vectorization\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestScheduleReordersScalarMemops.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -281,9 +281,1 @@\n-        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"AlignVector\", \"false\"},\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n-                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n-                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseCompactObjectHeaders\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n@@ -314,4 +306,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 32*i  ->  always            adr = base + 12 + 32*i  ->  never\n-            \/\/ -> vectorize                                  -> no vectorization\n@@ -328,9 +316,1 @@\n-        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"AlignVector\", \"false\"},\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n-                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.ADD_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.MUL_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseCompactObjectHeaders\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n@@ -349,4 +329,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 32*i  ->  always            adr = base + 12 + 32*i  ->  never\n-            \/\/ -> vectorize                                  -> no vectorization\n@@ -363,9 +339,1 @@\n-        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"AlignVector\", \"false\"},\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n-                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.ADD_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n-                  IRNode.MUL_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseCompactObjectHeaders\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n@@ -384,4 +352,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 32*i  ->  always            adr = base + 12 + 32*i  ->  never\n-            \/\/ -> vectorize                                  -> no vectorization\n@@ -398,9 +362,1 @@\n-        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"AlignVector\", \"false\"},\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n-                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.ADD_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n-                  IRNode.MUL_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseCompactObjectHeaders\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n@@ -419,4 +375,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 32*i  ->  always            adr = base + 12 + 32*i  ->  never\n-            \/\/ -> vectorize                                  -> no vectorization\n@@ -433,9 +385,1 @@\n-        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"AlignVector\", \"false\"},\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n-                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.ADD_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.MUL_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseCompactObjectHeaders\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n@@ -454,4 +398,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 32*i  ->  always            adr = base + 12 + 32*i  ->  never\n-            \/\/ -> vectorize                                  -> no vectorization\n@@ -468,9 +408,1 @@\n-        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"AlignVector\", \"false\"},\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n-                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n-                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseCompactObjectHeaders\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n@@ -503,4 +435,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 32*i  ->  always            adr = base + 12 + 32*i  ->  never\n-            \/\/ -> vectorize                                  -> no vectorization\n@@ -517,9 +445,1 @@\n-        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"AlignVector\", \"false\"},\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n-                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n-                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseCompactObjectHeaders\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n@@ -552,4 +472,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 32*i  ->  always            adr = base + 12 + 32*i  ->  never\n-            \/\/ -> vectorize                                  -> no vectorization\n@@ -566,9 +482,1 @@\n-        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"AlignVector\", \"false\"},\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n-                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n-                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseCompactObjectHeaders\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n@@ -601,4 +509,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 32*i  ->  always            adr = base + 12 + 32*i  ->  never\n-            \/\/ -> vectorize                                  -> no vectorization\n@@ -615,9 +519,1 @@\n-        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"AlignVector\", \"false\"},\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n-                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n-                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseCompactObjectHeaders\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n@@ -650,4 +546,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 32*i  ->  always            adr = base + 12 + 32*i  ->  never\n-            \/\/ -> vectorize                                  -> no vectorization\n@@ -661,6 +553,1 @@\n-        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"AlignVector\", \"false\"},\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseCompactObjectHeaders\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n@@ -703,5 +590,0 @@\n-\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 8 + 32*i  ->  always        adr = base + 12 + 8 + 32*i  ->  never\n-            \/\/ -> vectorize                                  -> no vectorization\n@@ -861,9 +743,1 @@\n-        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"AlignVector\", \"false\"},\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,   IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.MUL_VI,          IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.AND_VI,          IRNode.VECTOR_SIZE_4, \"> 0\",\n-                  IRNode.ADD_VI,          IRNode.VECTOR_SIZE_4, \"> 0\", \/\/ reduction moved out of loop\n-                  IRNode.ADD_REDUCTION_V,                       \"> 0\"},\n-        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseCompactObjectHeaders\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n@@ -885,4 +759,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 32*i  ->  always            adr = base + 12 + 32*i  ->  never\n-            \/\/ -> vectorize                                  -> no vectorization\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestSplitPacks.java","additions":11,"deletions":141,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -67,1 +67,0 @@\n-        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n@@ -95,5 +94,0 @@\n-\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 8*i  ->  always             adr = base + 12 + 8*i  ->  never\n-            \/\/ -> vectorize                                  -> no vectorization\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestUnorderedReductionPartialVectorization.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -71,5 +70,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n-            \/\/ F_adr = base + 16 + 4*i   ->  i % 2 = 0       F_adr = base + 12 + 4*i   ->  i % 2 = 1\n-            \/\/ S_adr = base + 16 + 2*i   ->  i % 4 = 0       S_adr = base + 12 + 2*i   ->  i % 4 = 2\n-            \/\/ -> vectorize                                  -> no vectorization\n@@ -134,1 +128,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -140,5 +133,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n-            \/\/ F_adr = base + 16 + 4*i   ->  i % 2 = 0       F_adr = base + 12 + 4*i   ->  i % 2 = 1\n-            \/\/ S_adr = base + 16 + 2*i   ->  i % 4 = 0       S_adr = base + 12 + 2*i   ->  i % 4 = 2\n-            \/\/ -> vectorize                                  -> no vectorization\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVector.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"})\n@@ -72,5 +71,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n-            \/\/ F_adr = base + 16 + 4*i   ->  i % 2 = 0       F_adr = base + 12 + 4*i   ->  i % 2 = 1\n-            \/\/ S_adr = base + 16 + 2*i   ->  i % 4 = 0       S_adr = base + 12 + 2*i   ->  i % 4 = 2\n-            \/\/ -> vectorize                                  -> no vectorization\n@@ -149,2 +143,1 @@\n-    @IR(counts = {IRNode.VECTOR_CAST_HF2F, IRNode.VECTOR_SIZE + \"min(max_float, max_short)\", \"> 0\"},\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"})\n+    @IR(counts = {IRNode.VECTOR_CAST_HF2F, IRNode.VECTOR_SIZE + \"min(max_float, max_short)\", \"> 0\"})\n@@ -154,5 +147,0 @@\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n-            \/\/ F_adr = base + 16 + 4*i   ->  i % 2 = 0       F_adr = base + 12 + 4*i   ->  i % 2 = 1\n-            \/\/ S_adr = base + 16 + 2*i   ->  i % 4 = 0       S_adr = base + 12 + 2*i   ->  i % 4 = 2\n-            \/\/ -> vectorize                                  -> no vectorization\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVectorNaN.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-\/\/ This means it affects the alignment constraints.\n+\/\/ It should, however, not affect the alignment constraints.\n@@ -237,1 +237,0 @@\n-        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n@@ -243,7 +242,0 @@\n-            \/\/ AlignVector=true requires that all vector load\/store are 8-byte aligned.\n-            \/\/ F_adr = base + UNSAFE.ARRAY_FLOAT_BASE_OFFSET + 4*i\n-            \/\/                = 16 (UseCompactObjectHeaders=false)    -> i % 2 = 0\n-            \/\/                = 12 (UseCompactObjectHeaders=true )    -> i % 2 = 1\n-            \/\/ S_adr = base + UNSAFE.ARRAY_SHORT_BASE_OFFSET + 2*i\n-            \/\/                = 16 (UseCompactObjectHeaders=false)    -> i % 4 = 0  -> can align both\n-            \/\/                = 12 (UseCompactObjectHeaders=true )    -> i % 4 = 2  -> cannot align both\n@@ -340,1 +332,0 @@\n-        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n@@ -346,7 +337,0 @@\n-            \/\/ AlignVector=true requires that all vector load\/store are 8-byte aligned.\n-            \/\/ F_adr = base + UNSAFE.ARRAY_FLOAT_BASE_OFFSET + 4*i\n-            \/\/                = 16 (UseCompactObjectHeaders=false)    -> i % 2 = 0\n-            \/\/                = 12 (UseCompactObjectHeaders=true )    -> i % 2 = 1\n-            \/\/ S_adr = base + UNSAFE.ARRAY_SHORT_BASE_OFFSET + 2*i\n-            \/\/                = 16 (UseCompactObjectHeaders=false)    -> i % 4 = 0  -> can align both\n-            \/\/                = 12 (UseCompactObjectHeaders=true )    -> i % 4 = 2  -> cannot align both\n@@ -359,1 +343,0 @@\n-        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n@@ -365,7 +348,0 @@\n-            \/\/ AlignVector=true requires that all vector load\/store are 8-byte aligned.\n-            \/\/ F_adr = base + UNSAFE.ARRAY_FLOAT_BASE_OFFSET + 4*i\n-            \/\/                = 16 (UseCompactObjectHeaders=false)    -> i % 2 = 0\n-            \/\/                = 12 (UseCompactObjectHeaders=true )    -> i % 2 = 1\n-            \/\/ S_adr = base + UNSAFE.ARRAY_SHORT_BASE_OFFSET + 2*i\n-            \/\/                = 16 (UseCompactObjectHeaders=false)    -> i % 4 = 0  -> can align both\n-            \/\/                = 12 (UseCompactObjectHeaders=true )    -> i % 4 = 2  -> cannot align both\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayTypeConvertTest.java","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -210,1 +210,0 @@\n-        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -220,17 +219,0 @@\n-            \/\/ We have a mix of int and short loads\/stores.\n-            \/\/ With UseCompactObjectHeaders and AlignVector,\n-            \/\/ we must 8-byte align all vector loads\/stores.\n-            \/\/\n-            \/\/ int:\n-            \/\/ adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 4*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ If UseCompactObjectHeaders=false: iter % 2 = 0\n-            \/\/ If UseCompactObjectHeaders=true:  iter % 2 = 1\n-            \/\/\n-            \/\/ byte:\n-            \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ If UseCompactObjectHeaders=false: iter % 8 = 0\n-            \/\/ If UseCompactObjectHeaders=true:  iter % 8 = 4\n-            \/\/\n-            \/\/ -> we cannot align both if UseCompactObjectHeaders=true.\n@@ -243,1 +225,0 @@\n-        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -255,17 +236,0 @@\n-            \/\/ We have a mix of int and short loads\/stores.\n-            \/\/ With UseCompactObjectHeaders and AlignVector,\n-            \/\/ we must 8-byte align all vector loads\/stores.\n-            \/\/\n-            \/\/ int:\n-            \/\/ adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 4*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ If UseCompactObjectHeaders=false: iter % 2 = 0\n-            \/\/ If UseCompactObjectHeaders=true:  iter % 2 = 1\n-            \/\/\n-            \/\/ byte:\n-            \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ If UseCompactObjectHeaders=false: iter % 8 = 0\n-            \/\/ If UseCompactObjectHeaders=true:  iter % 8 = 4\n-            \/\/\n-            \/\/ -> we cannot align both if UseCompactObjectHeaders=true.\n@@ -293,1 +257,0 @@\n-        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -303,17 +266,0 @@\n-            \/\/ We have a mix of int and short loads\/stores.\n-            \/\/ With UseCompactObjectHeaders and AlignVector,\n-            \/\/ we must 8-byte align all vector loads\/stores.\n-            \/\/\n-            \/\/ int:\n-            \/\/ adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 4*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ If UseCompactObjectHeaders=false: iter % 2 = 0\n-            \/\/ If UseCompactObjectHeaders=true:  iter % 2 = 1\n-            \/\/\n-            \/\/ byte:\n-            \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ If UseCompactObjectHeaders=false: iter % 8 = 0\n-            \/\/ If UseCompactObjectHeaders=true:  iter % 8 = 4\n-            \/\/\n-            \/\/ -> we cannot align both if UseCompactObjectHeaders=true.\n@@ -326,1 +272,0 @@\n-        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -336,17 +281,0 @@\n-            \/\/ We have a mix of int and short loads\/stores.\n-            \/\/ With UseCompactObjectHeaders and AlignVector,\n-            \/\/ we must 8-byte align all vector loads\/stores.\n-            \/\/\n-            \/\/ int:\n-            \/\/ adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 4*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ If UseCompactObjectHeaders=false: iter % 2 = 0\n-            \/\/ If UseCompactObjectHeaders=true:  iter % 2 = 1\n-            \/\/\n-            \/\/ byte:\n-            \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ If UseCompactObjectHeaders=false: iter % 8 = 0\n-            \/\/ If UseCompactObjectHeaders=true:  iter % 8 = 4\n-            \/\/\n-            \/\/ -> we cannot align both if UseCompactObjectHeaders=true.\n@@ -359,1 +287,0 @@\n-        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -369,1 +296,0 @@\n-            \/\/ same argument as in multipleOpsWith2DifferentTypesAndInvariant.\n@@ -376,1 +302,0 @@\n-        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -387,17 +312,0 @@\n-            \/\/ We have a mix of int and short loads\/stores.\n-            \/\/ With UseCompactObjectHeaders and AlignVector,\n-            \/\/ we must 8-byte align all vector loads\/stores.\n-            \/\/\n-            \/\/ int:\n-            \/\/ adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 4*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ If UseCompactObjectHeaders=false: iter % 2 = 0\n-            \/\/ If UseCompactObjectHeaders=true:  iter % 2 = 1\n-            \/\/\n-            \/\/ byte:\n-            \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ If UseCompactObjectHeaders=false: iter % 8 = 0\n-            \/\/ If UseCompactObjectHeaders=true:  iter % 8 = 4\n-            \/\/\n-            \/\/ -> we cannot align both if UseCompactObjectHeaders=true.\n@@ -450,1 +358,0 @@\n-        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -457,9 +364,0 @@\n-            \/\/ Hand-unrolling can mess with alignment!\n-            \/\/\n-            \/\/ With UseCompactObjectHeaders and AlignVector,\n-            \/\/ we must 8-byte align all vector loads\/stores.\n-            \/\/\n-            \/\/ adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 8*iter\n-            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n-            \/\/ If UseCompactObjectHeaders=false: 16 divisible by 8 -> vectorize\n-            \/\/ If UseCompactObjectHeaders=true:  12 not divisibly by 8 -> not vectorize\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopCombinedOpTest.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -197,1 +197,1 @@\n-        new LogMessageWithLevel(\"Expand Heap After Collection:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Resize Heap After Collection:\", Level.DEBUG),\n@@ -323,2 +323,1 @@\n-        output.shouldContain(\"Expand the heap. requested expansion amount: \");\n-        output.shouldContain(\"B expansion amount: \");\n+        output.shouldContain(\"Heap resize: \");\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n-\/*\n- * @test id=passive\n+\/**\n+ * @test id=satb-adaptive\n@@ -31,2 +31,3 @@\n- * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=passive\n+ * @run main\/othervm -Xms100m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info -Dtarget=10000\n+ *      -XX:ShenandoahGCMode=satb\n@@ -34,1 +35,1 @@\n- *      -Dtarget=10000\n+ *      -XX:ShenandoahGCHeuristics=adaptive\n@@ -37,5 +38,0 @@\n- * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=passive\n- *      -XX:-ShenandoahDegeneratedGC\n- *      -Dtarget=10000\n- *      TestDynamicSoftMaxHeapSize\n@@ -44,2 +40,2 @@\n-\/*\n- * @test id=aggressive\n+\/**\n+ * @test id=satb-aggressive\n@@ -49,3 +45,5 @@\n- * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=aggressive\n- *      -Dtarget=1000\n+ * @run main\/othervm -Xms100m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info -Dtarget=10000\n+ *      -XX:ShenandoahGCMode=satb\n+ *      -XX:+ShenandoahDegeneratedGC\n+ *      -XX:ShenandoahGCHeuristics=aggressive\n@@ -53,0 +51,1 @@\n+ *\n@@ -55,2 +54,2 @@\n-\/*\n- * @test id=adaptive\n+\/**\n+ * @test id=satb-compact\n@@ -60,3 +59,5 @@\n- * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive\n- *      -Dtarget=10000\n+ * @run main\/othervm -Xms100m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info -Dtarget=10000\n+ *      -XX:ShenandoahGCMode=satb\n+ *      -XX:+ShenandoahDegeneratedGC\n+ *      -XX:ShenandoahGCHeuristics=compact\n@@ -64,0 +65,1 @@\n+ *\n@@ -66,2 +68,2 @@\n-\/*\n- * @test id=generational\n+\/**\n+ * @test id=satb-static\n@@ -71,3 +73,5 @@\n- * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n- *      -Dtarget=10000\n+ * @run main\/othervm -Xms100m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info -Dtarget=10000\n+ *      -XX:ShenandoahGCMode=satb\n+ *      -XX:+ShenandoahDegeneratedGC\n+ *      -XX:ShenandoahGCHeuristics=static\n@@ -75,0 +79,1 @@\n+ *\n@@ -77,2 +82,2 @@\n-\/*\n- * @test id=static\n+\/**\n+ * @test id=passive\n@@ -83,1 +88,8 @@\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=static\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=passive\n+ *      -XX:+ShenandoahDegeneratedGC\n+ *      -Dtarget=10000\n+ *      TestDynamicSoftMaxHeapSize\n+ *\n+ * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=passive\n+ *      -XX:-ShenandoahDegeneratedGC\n@@ -88,2 +100,2 @@\n-\/*\n- * @test id=compact\n+\/**\n+ * @test id=generational\n@@ -93,4 +105,6 @@\n- * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=compact\n- *      -Dtarget=1000\n- *     TestDynamicSoftMaxHeapSize\n+ * @run main\/othervm -Xms100m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info -Dtarget=10000\n+ *      -XX:ShenandoahGCMode=generational\n+ *      -XX:ShenandoahGCHeuristics=adaptive\n+ *      TestDynamicSoftMaxHeapSize\n+ *\n@@ -99,1 +113,12 @@\n-import java.util.Random;\n+\/**\n+ * @test id=generational-softMaxHeapSizeValidation\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -DvalidateSoftMaxHeap=true\n+ *      TestDynamicSoftMaxHeapSize\n+ *      -Xms100m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info -Dtarget=10000 -DverifySoftMaxHeapValue=true\n+ *      -XX:ShenandoahGCMode=generational\n+ *      -XX:ShenandoahGCHeuristics=adaptive\n+ *\/\n@@ -105,0 +130,5 @@\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+\n@@ -106,0 +136,7 @@\n+    static final int K = 1024;\n+    static final int XMS_MB = 100;\n+    static final int XMX_MB = 512;\n+\n+    public static void main(String[] args) throws Exception {\n+        if (\"true\".equals(System.getProperty(\"validateSoftMaxHeap\"))) {\n+            List<String> flagArgs = new ArrayList<>(Arrays.asList(args));\n@@ -107,2 +144,4 @@\n-    static final long TARGET_MB = Long.getLong(\"target\", 10_000); \/\/ 10 Gb allocation\n-    static final long STRIDE = 10_000_000;\n+            int softMaxInMb = Utils.getRandomInstance().nextInt(XMS_MB, XMX_MB);\n+            flagArgs.add(\"-DsoftMaxCapacity=\" + softMaxInMb * K * K);\n+            flagArgs.add(\"-Dtest.jdk=\" + System.getProperty(\"test.jdk\"));\n+            flagArgs.add(\"-Dcompile.jdk=\" + System.getProperty(\"compile.jdk\"));\n@@ -110,1 +149,1 @@\n-    static volatile Object sink;\n+            flagArgs.add(SoftMaxWithExpectationTest.class.getName());\n@@ -112,10 +151,27 @@\n-    public static void main(String[] args) throws Exception {\n-        long count = TARGET_MB * 1024 * 1024 \/ 16;\n-        Random r = Utils.getRandomInstance();\n-        PidJcmdExecutor jcmd = new PidJcmdExecutor();\n-\n-        for (long c = 0; c < count; c += STRIDE) {\n-            \/\/ Sizes specifically include heaps below Xms and above Xmx to test saturation code.\n-            jcmd.execute(\"VM.set_flag SoftMaxHeapSize \" + r.nextInt(768*1024*1024), true);\n-            for (long s = 0; s < STRIDE; s++) {\n-                sink = new Object();\n+            ProcessBuilder genShenPbValidateFlag = ProcessTools.createLimitedTestJavaProcessBuilder(flagArgs);\n+            OutputAnalyzer output = new OutputAnalyzer(genShenPbValidateFlag.start());\n+            output.shouldHaveExitValue(0);\n+            output.shouldContain(String.format(\"Soft Max Heap Size: %dM -> %dM\", XMX_MB, softMaxInMb)); \/\/ By default, the soft max heap size is Xmx\n+        } else {\n+            SoftMaxSetFlagOnlyTest.test();\n+        }\n+    }\n+\n+    public static class SoftMaxSetFlagOnlyTest {\n+        static final long TARGET_MB = Long.getLong(\"target\", 10_000); \/\/ 10 Gb allocation\n+        static final long STRIDE = 10_000_000;\n+\n+        static volatile Object sink;\n+\n+        public static void test() throws Exception {\n+            long count = TARGET_MB * 1024 * 1024 \/ 16;\n+            Random r = Utils.getRandomInstance();\n+            PidJcmdExecutor jcmd = new PidJcmdExecutor();\n+\n+            for (long c = 0; c < count; c += STRIDE) {\n+                \/\/ Sizes specifically include heaps below Xms and above Xmx to test saturation code.\n+                jcmd.execute(\"VM.set_flag SoftMaxHeapSize \" + r.nextInt(768*1024*1024), true);\n+                for (long s = 0; s < STRIDE; s++) {\n+                    sink = new Object();\n+                }\n+                Thread.sleep(1);\n@@ -123,1 +179,0 @@\n-            Thread.sleep(1);\n@@ -127,0 +182,15 @@\n+    public static class SoftMaxWithExpectationTest {\n+        static final long TOTAL = 100_000_000;\n+\n+        static volatile Object sink;\n+\n+        public static void main(String[] args) throws Exception {\n+            int expectedSoftMaxHeapSize = Integer.getInteger(\"softMaxCapacity\", 0);\n+            PidJcmdExecutor jcmd = new PidJcmdExecutor();\n+            jcmd.execute(\"VM.set_flag SoftMaxHeapSize \" + expectedSoftMaxHeapSize, false);\n+\n+            for (long s = 0; s < TOTAL; s++) {\n+                sink = new Object();\n+            }\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestDynamicSoftMaxHeapSize.java","additions":119,"deletions":49,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2021, 2025, Red Hat, Inc. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"ppc64le\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"ppc64\" | os.arch == \"ppc64le\"\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestLinkToNativeRBP.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -117,3 +117,3 @@\n-            INT_OFFSET = 8;\n-            INT_ARRAY_OFFSET = 12;\n-            LONG_ARRAY_OFFSET = 16;\n+            INT_OFFSET = 4;\n+            INT_ARRAY_OFFSET = 8;\n+            LONG_ARRAY_OFFSET = 8;\n","filename":"test\/hotspot\/jtreg\/runtime\/FieldLayout\/BaseOffsets.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -77,0 +77,2 @@\n+            baseArgs.add(\"-XX:+UnlockExperimentalVMOptions\");\n+            baseArgs.add(\"-XX:-UseCompactObjectHeaders\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/DeterministicDump.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires vm.opt.final.UseCompactObjectHeaders == false\n@@ -51,0 +52,1 @@\n+ * @requires vm.opt.final.UseCompactObjectHeaders == false\n@@ -124,1 +126,0 @@\n-        int n = 2;\n@@ -128,24 +129,14 @@\n-            String[] sizes = {\n-                \"4m\",   \/\/ usually this will success load the archived heap\n-                \"2m\",   \/\/ usually this will fail to load the archived heap, but app can launch\n-                        \/\/ or fail with \"GC triggered before VM initialization completed\"\n-                \"1m\"    \/\/ usually this will cause VM launch to fail with \"Too small maximum heap\"\n-            };\n-            for (String sz : sizes) {\n-                String xmx = \"-Xmx\" + sz;\n-                System.out.println(\"=======\\n\" + n + \". Exec with \" + execGC + \" \" + xmx);\n-                out = TestCommon.exec(helloJar,\n-                                      execGC,\n-                                      small1,\n-                                      small2,\n-                                      xmx,\n-                                      coops,\n-                                      \"-Xlog:cds\",\n-                                      \"Hello\");\n-                if (out.getExitValue() == 0) {\n-                    out.shouldContain(HELLO);\n-                    out.shouldNotContain(errMsg);\n-                } else {\n-                    out.shouldNotHaveFatalError();\n-                }\n-                n++;\n+            System.out.println(\"2. Exec with \" + execGC);\n+            out = TestCommon.exec(helloJar,\n+                                    execGC,\n+                                    small1,\n+                                    small2,\n+                                    \"-Xmx4m\",\n+                                    coops,\n+                                    \"-Xlog:cds\",\n+                                    \"Hello\");\n+            if (out.getExitValue() == 0) {\n+                out.shouldContain(HELLO);\n+                out.shouldNotContain(errMsg);\n+            } else {\n+                out.shouldNotHaveFatalError();\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestParallelGCWithCDS.java","additions":16,"deletions":25,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -99,3 +99,1 @@\n-            if (runMode == RunMode.TRAINING) {\n-                out.shouldMatch(\"aot,resolve.*reverted field.*TestApp.Foo => TestApp.Foo.ShouldBeExcluded.f:I\");\n-            } else if (runMode == RunMode.ASSEMBLY) {\n+            if (runMode == RunMode.ASSEMBLY) {\n@@ -103,1 +101,0 @@\n-                out.shouldMatch(\"aot,resolve.*archived method.*TestApp.Foo java\/lang\/Integer.intValue:[(][)]I => java\/lang\/Integer\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/ExcludedClasses.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8357601\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native TestCharArrayReleasing 0 0\n+ * @run main\/othervm\/native TestCharArrayReleasing 1 0\n+ * @run main\/othervm\/native TestCharArrayReleasing 2 0\n+ * @run main\/othervm\/native TestCharArrayReleasing 3 0\n+ * @run main\/othervm\/native TestCharArrayReleasing 4 0\n+ * @run main\/othervm\/native TestCharArrayReleasing 0 1\n+ * @run main\/othervm\/native TestCharArrayReleasing 1 1\n+ * @run main\/othervm\/native TestCharArrayReleasing 2 1\n+ * @run main\/othervm\/native TestCharArrayReleasing 3 1\n+ * @run main\/othervm\/native TestCharArrayReleasing 4 1\n+ * @run main\/othervm\/native TestCharArrayReleasing 0 2\n+ * @run main\/othervm\/native TestCharArrayReleasing 1 2\n+ * @run main\/othervm\/native TestCharArrayReleasing 2 2\n+ * @run main\/othervm\/native TestCharArrayReleasing 3 2\n+ * @run main\/othervm\/native TestCharArrayReleasing 4 2\n+ * @run main\/othervm\/native TestCharArrayReleasing 0 3\n+ * @run main\/othervm\/native TestCharArrayReleasing 1 3\n+ * @run main\/othervm\/native TestCharArrayReleasing 2 3\n+ * @run main\/othervm\/native TestCharArrayReleasing 3 3\n+ * @run main\/othervm\/native TestCharArrayReleasing 4 3\n+ *\/\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/\/ Test the behaviour of the JNI \"char\" releasing functions, under Xcheck:jni,\n+\/\/ when they are passed \"char\" arrays obtained from different sources:\n+\/\/ - source_mode indicates which array to use\n+\/\/   - 0: use a raw malloc'd array\n+\/\/   - 1: use an array from GetCharArrayElements\n+\/\/   - 2: use an array from GetStringChars\n+\/\/   - 3: use an array from GetStringUTFChars\n+\/\/   - 4: use an array from GetPrimitiveArrayCritical\n+\/\/ - release_mode indicates which releasing function to use\n+\/\/   - 0: ReleaseCharArrayElements\n+\/\/   - 1: ReleaseStringChars\n+\/\/   - 2: ReleaseStringUTFChars\n+\/\/   - 3: ReleasePrimitiveArrayCritical\n+\n+public class TestCharArrayReleasing {\n+\n+    static native void testIt(int srcMode, int releaseMode);\n+\n+    static class Driver {\n+\n+        static {\n+            System.loadLibrary(\"CharArrayReleasing\");\n+        }\n+\n+        public static void main(String[] args) {\n+            int srcMode = Integer.parseInt(args[0]);\n+            int relMode = Integer.parseInt(args[1]);\n+            testIt(srcMode, relMode);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        int ABRT = 1;\n+        int[][] errorCodes = new int[][] {\n+            { ABRT, 0, ABRT, ABRT, ABRT },\n+            { ABRT, ABRT, 0, ABRT, ABRT },\n+            { ABRT, ABRT, ABRT, 0, ABRT },\n+            { ABRT, ABRT, ABRT, ABRT, 0 },\n+        };\n+\n+        String rcae = \"ReleaseCharArrayElements called on something allocated by GetStringChars\";\n+        String rcaeUTF = \"ReleaseCharArrayElements called on something allocated by GetStringUTFChars\";\n+        String rcaeCrit = \"ReleaseCharArrayElements called on something allocated by GetPrimitiveArrayCritical\";\n+        String rcaeBounds = \"ReleaseCharArrayElements: release array failed bounds check\";\n+        String rsc = \"ReleaseStringChars called on something not allocated by GetStringChars\";\n+        String rscBounds = \"ReleaseStringChars: release chars failed bounds check\";\n+        String rsuc = \"ReleaseStringUTFChars called on something not allocated by GetStringUTFChars\";\n+        String rsucBounds = \"ReleaseStringUTFChars: release chars failed bounds check\";\n+        String rpac = \"ReleasePrimitiveArrayCritical called on something not allocated by GetPrimitiveArrayCritical\";\n+        String rpacBounds = \"ReleasePrimitiveArrayCritical: release array failed bounds check\";\n+        String rpacStr = \"ReleasePrimitiveArrayCritical called on something allocated by GetStringChars\";\n+        String rpacStrUTF = \"ReleasePrimitiveArrayCritical called on something allocated by GetStringUTFChars\";\n+\n+        String[][] errorMsgs = new String[][] {\n+            { rcaeBounds, \"\", rcae, rcaeUTF, rcaeCrit },\n+            { rscBounds, rsc, \"\", rsc, rsc },\n+            { rsucBounds, rsuc, rsuc, \"\", rsuc },\n+            { rpacBounds, rpac, rpacStr, rpacStrUTF, \"\" },\n+        };\n+\n+        int srcMode = Integer.parseInt(args[0]);\n+        int relMode = Integer.parseInt(args[1]);\n+\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+             \"-Djava.library.path=\" + System.getProperty(\"test.nativepath\"),\n+             \"--enable-native-access=ALL-UNNAMED\",\n+             \"-XX:-CreateCoredumpOnCrash\",\n+             \"-Xcheck:jni\",\n+             \"TestCharArrayReleasing$Driver\",\n+             args[0], args[1]);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(errorCodes[relMode][srcMode]);\n+        output.shouldContain(errorMsgs[relMode][srcMode]);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/TestCharArrayReleasing.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+\n+\/\/ Test the behaviour of the JNI \"char\" releasing functions, under Xcheck:jni,\n+\/\/ when they are passed \"char\" arrays obtained from different sources:\n+\/\/ - source_mode indicates which array to use\n+\/\/   - 0: use a raw malloc'd array\n+\/\/   - 1: use an array from GetCharArrayElements\n+\/\/   - 2: use an array from GetStringChars\n+\/\/   - 3: use an array from GetStringUTFChars\n+\/\/   - 4: use an array from GetPrimitiveArrayCritical\n+\/\/ - release_mode indicates which releasing function to use\n+\/\/   - 0: ReleaseCharArrayElements\n+\/\/   - 1: ReleaseStringChars\n+\/\/   - 2: ReleaseStringUTFChars\n+\/\/   - 3: ReleasePrimitiveArrayCritical\n+\/\/\n+\n+static char* source[] = {\n+  \"malloc\",\n+  \"GetCharArrayElements\",\n+  \"GetStringChars\",\n+  \"GetStringUTFChars\",\n+  \"GetPrimitiveArrayCritical\"\n+};\n+\n+static char* release_func[] = {\n+  \"ReleaseCharArrayElements\",\n+  \"ReleaseStringChars\",\n+  \"ReleaseStringUTFChars\",\n+  \"ReleasePrimitiveArrayCritical\"\n+};\n+\n+JNIEXPORT void JNICALL\n+Java_TestCharArrayReleasing_testIt(JNIEnv *env, jclass cls, jint source_mode,\n+                               jint release_mode) {\n+\n+  \/\/ First create some Java objects to be used as the sources for jchar[]\n+  \/\/ extraction.\n+  const int len = 10;\n+  jcharArray ca = (*env)->NewCharArray(env, len);\n+  jstring str = (*env)->NewStringUTF(env, \"A_String\");\n+\n+  jthrowable exc = (*env)->ExceptionOccurred(env);\n+  if (exc != NULL) {\n+    fprintf(stderr, \"ERROR: Unexpected exception during test set up:\\n\");\n+    (*env)->ExceptionDescribe(env);\n+    exit(2);\n+  }\n+\n+  fprintf(stdout, \"Testing release function %s with array from %s\\n\",\n+          release_func[release_mode], source[source_mode]);\n+  fflush(stdout);\n+\n+  jboolean is_copy = JNI_FALSE;\n+  jchar* to_release;\n+  switch(source_mode) {\n+  case 0: {\n+    to_release = malloc(10 * sizeof(jchar));\n+    break;\n+  }\n+  case 1: {\n+    to_release = (*env)->GetCharArrayElements(env, ca, &is_copy);\n+    break;\n+  }\n+  case 2: {\n+    to_release = (jchar*) (*env)->GetStringChars(env, str, &is_copy);\n+    break;\n+  }\n+  case 3: {\n+    to_release = (jchar*) (*env)->GetStringUTFChars(env, str, &is_copy);\n+    break;\n+  }\n+  case 4: {\n+    to_release = (jchar*) (*env)->GetPrimitiveArrayCritical(env, ca, &is_copy);\n+    break;\n+  }\n+  default: fprintf(stderr, \"Unexpected source_mode %d\\n\", source_mode);\n+    exit(1);\n+  }\n+\n+  switch (release_mode) {\n+  case 0:\n+    (*env)->ReleaseCharArrayElements(env, ca, to_release, 0);\n+    break;\n+  case 1:\n+    (*env)->ReleaseStringChars(env, str, to_release);\n+    break;\n+  case 2:\n+    (*env)->ReleaseStringUTFChars(env, str, (const char*)to_release);\n+    break;\n+  case 3:\n+    (*env)->ReleasePrimitiveArrayCritical(env, ca, to_release, 0);\n+    break;\n+  default: fprintf(stderr, \"Unexpected release_mode %d\\n\", source_mode);\n+    exit(1);\n+  }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/libCharArrayReleasing.c","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"arm\" | os.arch==\"aarch64\" | os.arch==\"ppc64\" | os.arch==\"s390\" | os.arch==\"riscv64\"\n+ * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"arm\" | os.arch==\"aarch64\" | os.arch==\"ppc64\" | os.arch==\"ppc64le\" | os.arch==\"s390\" | os.arch==\"riscv64\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/AsyncGetCallTrace\/MyPackage\/ASGCTBaseTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-        Debugee debuggee = binder.startLocalDebugee(cmd);\n+        Debugee debuggee = binder.startDebugee(cmd);\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/framework\/TestProcessLauncher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import utils.JstatGcCauseTool;\n@@ -39,1 +40,1 @@\n-    private final TmTool<? extends JstatResults> jstatTool;\n+    private final JstatGcCauseTool jstatTool;\n@@ -41,1 +42,1 @@\n-    public GarbageProducerTest(TmTool<? extends JstatResults> tool) {\n+    public GarbageProducerTest(JstatGcCauseTool tool) {\n@@ -48,4 +49,4 @@\n-        \/\/ Run once and get the  results asserting that they are reasonable\n-        JstatResults measurement1 = jstatTool.measure();\n-        measurement1.assertConsistency();\n-        \/\/ Eat metaspace and heap then run the tool again and get the results  asserting that they are reasonable\n+        \/\/ Run once and get the results asserting that they are reasonable\n+        JstatResults measurement1 = jstatTool.measureAndAssertConsistency();\n+\n+        \/\/ Eat metaspace and heap then run the tool again and get the results, asserting that they are reasonable\n","filename":"test\/hotspot\/jtreg\/serviceability\/tmtools\/jstat\/GarbageProducerTest.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,1 @@\n-        JstatGcNewResults measurement1 = jstatGcTool.measure();\n-        measurement1.assertConsistency();\n+        JstatGcNewResults measurement1 = jstatGcTool.measureAndAssertConsistency();\n@@ -54,2 +53,1 @@\n-        JstatGcNewResults measurement2 = jstatGcTool.measure();\n-        measurement2.assertConsistency();\n+        JstatGcNewResults measurement2 = jstatGcTool.measureAndAssertConsistency();\n@@ -63,2 +61,1 @@\n-        JstatGcNewResults measurement3 = jstatGcTool.measure();\n-        measurement3.assertConsistency();\n+        JstatGcNewResults measurement3 = jstatGcTool.measureAndAssertConsistency();\n","filename":"test\/hotspot\/jtreg\/serviceability\/tmtools\/jstat\/GcNewTest.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,3 +50,2 @@\n-        \/\/ Run once and get the  results asserting that they are reasonable\n-        JstatGcResults measurement1 = jstatGcTool.measure();\n-        measurement1.assertConsistency();\n+        \/\/ Run once and get the results asserting that they are reasonable\n+        JstatGcResults measurement1 = jstatGcTool.measureAndAssertConsistency();\n@@ -59,2 +58,1 @@\n-        JstatGcResults measurement2 = jstatGcTool.measure();\n-        measurement2.assertConsistency();\n+        JstatGcResults measurement2 = jstatGcTool.measureAndAssertConsistency();\n@@ -69,2 +67,1 @@\n-        JstatGcResults measurement3 = jstatGcTool.measure();\n-        measurement3.assertConsistency();\n+        JstatGcResults measurement3 = jstatGcTool.measureAndAssertConsistency();\n@@ -75,2 +72,0 @@\n-\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/tmtools\/jstat\/GcTest01.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-        new GarbageProducerTest(new JstatGcTool(ProcessHandle.current().pid())).run();\n+        new GarbageProducerTest(new JstatGcCauseTool(ProcessHandle.current().pid())).run();\n","filename":"test\/hotspot\/jtreg\/serviceability\/tmtools\/jstat\/GcTest02.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-public class JstatGcCapacityTool extends TmTool<JstatGcCapacityResults> {\n+public class JstatGcCapacityTool extends JstatTool<JstatGcCapacityResults> {\n@@ -36,1 +36,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/tmtools\/jstat\/utils\/JstatGcCapacityTool.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-public class JstatGcCauseTool extends TmTool<JstatGcCauseResults> {\n+public class JstatGcCauseTool extends JstatTool<JstatGcCauseResults> {\n@@ -36,1 +36,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/tmtools\/jstat\/utils\/JstatGcCauseTool.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-public class JstatGcNewTool extends TmTool<JstatGcNewResults> {\n+public class JstatGcNewTool extends JstatTool<JstatGcNewResults> {\n@@ -36,1 +36,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/tmtools\/jstat\/utils\/JstatGcNewTool.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-public class JstatGcTool extends TmTool<JstatGcResults> {\n+public class JstatGcTool extends JstatTool<JstatGcResults> {\n@@ -36,1 +36,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/tmtools\/jstat\/utils\/JstatGcTool.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-abstract public class JstatResults extends ToolResults {\n+public abstract class JstatResults extends ToolResults {\n@@ -184,1 +184,1 @@\n-    abstract public void assertConsistency();\n+     public abstract void assertConsistency();\n","filename":"test\/hotspot\/jtreg\/serviceability\/tmtools\/jstat\/utils\/JstatResults.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package utils;\n+\n+import common.TmTool;\n+\n+\/**\n+ * Common base class for Jstat tools.\n+ *\/\n+public class JstatTool<T extends JstatResults> extends TmTool<T> {\n+\n+    private static final int TRIES = 3;\n+\n+     public JstatTool(Class<T> resultsClz, String toolName, String otherArgs) {\n+        super(resultsClz, toolName, otherArgs);\n+    }\n+\n+    \/**\n+     * Measure, and call assertConsistency() on the results,\n+     * tolerating a set number of failures to account for inconsistencies in PerfData.\n+     *\/\n+    public T measureAndAssertConsistency() throws Exception {\n+        T results = null;\n+        for (int i = 1; i <= TRIES; i++) {\n+            try {\n+                results = measure();\n+                results.assertConsistency();\n+            } catch (RuntimeException e) {\n+                System.out.println(\"Attempt \" + i + \": \" + e);\n+                if (i == TRIES) {\n+                    System.out.println(\"Too many failures.\");\n+                    throw(e);\n+                }\n+                \/\/ Will retry.\n+            }\n+        }\n+        return results;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/tmtools\/jstat\/utils\/JstatTool.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.reflect.Constructor;\n@@ -32,0 +33,1 @@\n+import java.lang.reflect.Method;\n@@ -82,2 +84,8 @@\n-        \/\/ Make sure the class is initialized.\n-        UNSAFE.ensureClassInitialized(aClass);\n+        \/\/ Attempt to initialize the class. If initialization is not possible\n+        \/\/ due to NCDFE, accept this, and try compile anyway.\n+        try {\n+            UNSAFE.ensureClassInitialized(aClass);\n+        } catch (NoClassDefFoundError e) {\n+            CompileTheWorld.OUT.printf(\"[%d]\\t%s\\tNOTE unable to init class : %s%n\",\n+                id, aClass.getName(), e);\n+        }\n@@ -86,0 +94,21 @@\n+        \/\/ Getting constructor\/methods with unresolvable signatures would fail with NCDFE.\n+        \/\/ Try to get as much as possible, and compile everything else.\n+        \/\/ TODO: Would be good to have a Whitebox method that returns the subset of resolvable\n+        \/\/ constructors\/methods without throwing NCDFE. This would extend the testing scope.\n+        Constructor[] constructors = new Constructor[0];\n+        Method[] methods = new Method[0];\n+\n+        try {\n+            constructors = aClass.getDeclaredConstructors();\n+        } catch (NoClassDefFoundError e) {\n+            CompileTheWorld.OUT.printf(\"[%d]\\t%s\\tNOTE unable to get constructors : %s%n\",\n+                id, aClass.getName(), e);\n+        }\n+\n+        try {\n+            methods = aClass.getDeclaredMethods();\n+        } catch (NoClassDefFoundError e) {\n+            CompileTheWorld.OUT.printf(\"[%d]\\t%s\\tNOTE unable to get methods : %s%n\",\n+                id, aClass.getName(), e);\n+        }\n+\n@@ -88,1 +117,1 @@\n-        for (Executable e : aClass.getDeclaredConstructors()) {\n+        for (Executable e : constructors) {\n@@ -91,1 +120,1 @@\n-        for (Executable e : aClass.getDeclaredMethods()) {\n+        for (Executable e : methods) {\n@@ -97,1 +126,1 @@\n-        for (Executable e : aClass.getDeclaredConstructors()) {\n+        for (Executable e : constructors) {\n@@ -101,1 +130,1 @@\n-        for (Executable e : aClass.getDeclaredMethods()) {\n+        for (Executable e : methods) {\n@@ -130,0 +159,3 @@\n+            } catch (NoClassDefFoundError e) {\n+                CompileTheWorld.OUT.printf(\"[%d]\\t%s\\tNOTE unable to preload : %s%n\",\n+                    id, className, e);\n@@ -131,2 +163,2 @@\n-                CompileTheWorld.OUT.println(String.format(\"[%d]\\t%s\\tWARNING preloading failed : %s\",\n-                         id, className, t));\n+                CompileTheWorld.OUT.printf(\"[%d]\\t%s\\tWARNING preloading failed : %s%n\",\n+                    id, className, t);\n","filename":"test\/hotspot\/jtreg\/testlibrary\/ctw\/src\/sun\/hotspot\/tools\/ctw\/Compiler.java","additions":40,"deletions":8,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -248,0 +248,3 @@\n+            } catch (NoClassDefFoundError e) {\n+                CompileTheWorld.OUT.printf(\"[%d]\\t%s\\tNOTE unable to load\/compile, skipped: %s%n\",\n+                    id, name, e);\n@@ -249,2 +252,2 @@\n-                CompileTheWorld.OUT.println(String.format(\"[%d]\\t%s\\tWARNING skipped: %s\",\n-                        id, name, e));\n+                CompileTheWorld.OUT.printf(\"[%d]\\t%s\\tWARNING skipped: %s%n\",\n+                    id, name, e);\n","filename":"test\/hotspot\/jtreg\/testlibrary\/ctw\/src\/sun\/hotspot\/tools\/ctw\/PathHandler.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+\n+#Unstable methods\n+*::hashCode\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/conf\/exclude.methods.lst","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.jittester;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Executable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.Asserts;\n+\n+import static java.util.function.Predicate.not;\n+\n+\n+\/**\n+ * A wrapper for string method templates, similar to the CompileCommand patterns.\n+ *\/\n+public final class MethodTemplate {\n+\n+    \/**\n+     * String that can have wildcard symbols on its ends, allowing it to match a family of strings.\n+     * For example, \"abc*\" matches \"abc123\", and so on.\n+     *\/\n+    public static class WildcardString {\n+        private final String pattern;\n+        private final boolean frontWildcarded;\n+        private final boolean tailWildcarded;\n+\n+        \/**\n+         * Creates a WildcardString from given string.\n+         * @param pattern   string pattern, like \"some*\"\n+         *\/\n+        public WildcardString(String pattern) {\n+            \/\/ check for the leading '*'\n+            frontWildcarded = pattern.charAt(0) == '*';\n+            pattern = frontWildcarded ? pattern.substring(1) : pattern;\n+\n+            \/\/ check for the trailing '*'\n+            tailWildcarded = pattern.length() > 0 && pattern.charAt(pattern.length() - 1) == '*';\n+            pattern = tailWildcarded ? pattern.substring(0, pattern.length() - 1) : pattern;\n+\n+            this.pattern = pattern;\n+        }\n+\n+        \/**\n+         * Returns true it this WildcardString matches given other string.\n+         * @param other the string that this WildcardString should be matched against\n+         * @return      true in case of a match.\n+         *\/\n+        public boolean matches(String other) {\n+            boolean result = pattern.equals(other);\n+            result |= frontWildcarded ? other.endsWith(pattern) : result;\n+            result |= tailWildcarded ? other.startsWith(pattern) : result;\n+            result |= tailWildcarded && frontWildcarded ? other.contains(pattern) : result;\n+            return result;\n+        }\n+    }\n+\n+    private static final Pattern METHOD_PATTERN = Pattern.compile(generateMethodPattern());\n+\n+    private final WildcardString klassName;\n+    private final WildcardString methodName;\n+    private final Optional<List<Class<?>>> signature;\n+\n+    private MethodTemplate(String klassName, String methodName, Optional<List<Class<?>>> signature) {\n+        this.klassName = new WildcardString(klassName);\n+        this.methodName = new WildcardString(methodName);\n+        this.signature = signature;\n+    }\n+\n+    private static String generateMethodPattern() {\n+        \/\/ Sample valid template(s):    java\/lang\/String::indexOf(Ljava\/lang\/String;I)\n+        \/\/                              java\/lang\/::*(Ljava\/lang\/String;I)\n+        \/\/                              *String::indexOf(*)\n+        \/\/                              java\/lang\/*::indexOf\n+\n+        String primitiveType = \"[ZBSCIJFD]\";        \/\/ Simply a letter, like 'I'\n+        String referenceType = \"L[\\\\w\/$]+;\";        \/\/ Like 'Ljava\/lang\/String;'\n+        String primOrRefType =\n+            \"\\\\[?\" + primitiveType +                \/\/ Bracket is optional: '[Z', or 'Z'\n+            \"|\" +\n+            \"\\\\[?\" + referenceType;                 \/\/ Bracket is optional: '[LSomeObject;' or 'LSomeObject;'\n+        String argTypesOrWildcard = \"(\" +           \/\/ Method argument(s) Ljava\/lang\/String;Z...\n+                \"(\" + primOrRefType + \")*\" +\n+            \")|\\\\*\";                                \/\/ .. or a wildcard:\n+\n+        return\n+            \"(?<klassName>[\\\\w\/$]*\\\\*?)\" +          \/\/ Class name, like 'java\/lang\/String'\n+            \"::\" +                                  \/\/ Simply '::'\n+            \"(?<methodName>\\\\*?[\\\\w$]+\\\\*?)\" +      \/\/ method name, 'indexOf''\n+            \"(\\\\((?<argTypes>\" +                    \/\/ Method argument(s) in brackets:\n+                argTypesOrWildcard +                \/\/     (Ljava\/lang\/String;Z) or '*' or nothing\n+            \")\\\\))?\";\n+    }\n+\n+    \/**\n+     * Returns true iff none of the given MethodTemplates matches the given Executable.\n+     *\n+     * @param templates     the collection of templates to check\n+     * @param method        the executable to match the colletions templates\n+     * @return              true if none of the given templates matches the method, false otherwise\n+     *\/\n+    public static boolean noneMatches(Collection<MethodTemplate> templates, Executable method) {\n+        for (MethodTemplate template : templates) {\n+            if (template.matches(method)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Returns true if this MethodTemplate matches the given Executable.\n+     *\n+     * @param other     the Executable to try to match to\n+     * @return          whether the other matches this MethodTemplate\n+     *\/\n+    public boolean matches(Executable other) {\n+        boolean result = klassName.matches(other.getDeclaringClass().getName());\n+\n+        result &= (other instanceof Constructor)\n+            ? result\n+            : methodName.matches(other.getName());\n+\n+        return result &&\n+            signature.map(Arrays.asList(other.getParameterTypes())::equals)\n+                     .orElse(true);\n+    }\n+\n+    \/**\n+     * Parses the given string and returs a MethodTemplate.\n+     *\n+     * @param methodStr     the string to parse\n+     * @return              created MethodTemplate\n+     *\/\n+    public static MethodTemplate parse(String methodStr) {\n+        Matcher matcher = METHOD_PATTERN.matcher(methodStr);\n+        String msg = String.format(\"Format of the methods exclude input file is incorrect,\"\n+                + \" methodStr \\\"%s\\\" has wrong format\", methodStr);\n+        Asserts.assertTrue(matcher.matches(), msg);\n+\n+        String klassName = matcher.group(\"klassName\").replaceAll(\"\/\", \"\\\\.\");\n+        String methodName = matcher.group(\"methodName\");\n+        Optional<List<Class<?>>> signature = Optional.ofNullable(matcher.group(\"argTypes\"))\n+                                                     .filter(not(\"*\"::equals))\n+                                                     .map(MethodTemplate::parseSignature);\n+        return new MethodTemplate(klassName, methodName, signature);\n+    }\n+\n+    private static List<Class<?>> parseSignature(String signature) {\n+        List<Class<?>> sigClasses = new ArrayList<>();\n+        char typeChar;\n+        boolean isArray;\n+        String klassName;\n+        StringBuilder sb;\n+        StringBuilder arrayDim;\n+        try (StringReader str = new StringReader(signature)) {\n+            int symbol = str.read();\n+            while (symbol != -1) {\n+                typeChar = (char) symbol;\n+                arrayDim = new StringBuilder();\n+                Class<?> primArrayClass = null;\n+                if (typeChar == '[') {\n+                    isArray = true;\n+                    arrayDim.append('[');\n+                    symbol = str.read();\n+                    while (symbol == '[') {\n+                        arrayDim.append('[');\n+                        symbol = str.read();\n+                    }\n+                    typeChar = (char) symbol;\n+                    if (typeChar != 'L') {\n+                        primArrayClass = Class.forName(arrayDim.toString() + typeChar);\n+                    }\n+                } else {\n+                    isArray = false;\n+                }\n+                switch (typeChar) {\n+                    case 'Z':\n+                        sigClasses.add(isArray ? primArrayClass : boolean.class);\n+                        break;\n+                    case 'I':\n+                        sigClasses.add(isArray ? primArrayClass : int.class);\n+                        break;\n+                    case 'J':\n+                        sigClasses.add(isArray ? primArrayClass : long.class);\n+                        break;\n+                    case 'F':\n+                        sigClasses.add(isArray ? primArrayClass : float.class);\n+                        break;\n+                    case 'D':\n+                        sigClasses.add(isArray ? primArrayClass : double.class);\n+                        break;\n+                    case 'B':\n+                        sigClasses.add(isArray ? primArrayClass : byte.class);\n+                        break;\n+                    case 'S':\n+                        sigClasses.add(isArray ? primArrayClass : short.class);\n+                        break;\n+                    case 'C':\n+                        sigClasses.add(isArray ? primArrayClass : char.class);\n+                        break;\n+                    case 'L':\n+                        sb = new StringBuilder();\n+                        symbol = str.read();\n+                        while (symbol != ';') {\n+                            sb.append((char) symbol);\n+                            symbol = str.read();\n+                        }\n+                        klassName = sb.toString().replaceAll(\"\/\", \"\\\\.\");\n+                        if (isArray) {\n+                            klassName = arrayDim.toString() + \"L\" + klassName + \";\";\n+                        }\n+                        Class<?> klass = Class.forName(klassName);\n+                        sigClasses.add(klass);\n+                        break;\n+                    default:\n+                        throw new Error(\"Unknown type \" + typeChar);\n+                }\n+                symbol = str.read();\n+            }\n+        } catch (IOException | ClassNotFoundException ex) {\n+            throw new Error(\"Unexpected exception while parsing exclude methods file\", ex);\n+        }\n+        return sigClasses;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/MethodTemplate.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import java.io.File;\n-import java.io.StringReader;\n@@ -38,3 +36,3 @@\n-import java.util.HashSet;\n-import java.util.LinkedList;\n-import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n@@ -47,0 +45,2 @@\n+import static java.util.function.Predicate.not;\n+\n@@ -52,0 +52,2 @@\n+    private List<MethodTemplate> methodsToExclude;\n+\n@@ -54,0 +56,5 @@\n+    private static String trimComment(String source) {\n+        int commentStart = source.indexOf('#');\n+        return commentStart == -1 ? source : source.substring(0, commentStart);\n+    }\n+\n@@ -65,21 +72,15 @@\n-        List<Class<?>> klasses = parseKlasses(klassesFileName);\n-        Set<Executable> methodsToExclude;\n-        if (exMethodsFileName != null && !exMethodsFileName.isEmpty()) {\n-            methodsToExclude = parseMethods(exMethodsFileName);\n-        } else {\n-            methodsToExclude = new HashSet<>();\n-        }\n-        klasses.stream().forEach(klass -> {\n-            TypeKlass typeKlass = (TypeKlass) getType(klass);\n-            if (TypeList.isReferenceType(typeKlass)) {\n-                return;\n-            }\n-            TypeList.add(typeKlass);\n-            Set<Executable> methods = new HashSet<>();\n-            methods.addAll(Arrays.asList(klass.getMethods()));\n-            methods.addAll(Arrays.asList(klass.getConstructors()));\n-            methods.removeAll(methodsToExclude);\n-            methods.stream().forEach(method -> {\n-                if (method.isSynthetic()) {\n-                    return;\n-                }\n+        TypesParser theParser = new TypesParser();\n+        theParser.initMethodsToExclude(exMethodsFileName);\n+        parseKlasses(klassesFileName)\n+            .stream()\n+            .filter(klass -> !TypeList.isReferenceType(getTypeKlass(klass)))\n+            .forEach(theParser::processKlass);\n+    }\n+\n+    private void processKlass(Class<?> klass) {\n+        TypeKlass typeKlass = getTypeKlass(klass);\n+        TypeList.add(typeKlass);\n+        Stream.concat(Arrays.stream(klass.getMethods()), Arrays.stream(klass.getConstructors()))\n+            .filter(not(Executable::isSynthetic))\n+            .filter(method -> MethodTemplate.noneMatches(methodsToExclude, method))\n+            .forEach(method -> {\n@@ -109,2 +110,1 @@\n-                typeKlass.addSymbol(new FunctionInfo(name, typeKlass, returnType, 1, flags,\n-                        paramList));\n+                typeKlass.addSymbol(new FunctionInfo(name, typeKlass, returnType, 1, flags, paramList));\n@@ -112,1 +112,0 @@\n-        });\n@@ -158,0 +157,4 @@\n+    private static TypeKlass getTypeKlass(Class<?> klass) {\n+        return (TypeKlass) getType(klass);\n+    }\n+\n@@ -237,31 +240,3 @@\n-    private static Set<Executable> parseMethods(String methodsFileName) {\n-        Asserts.assertNotNull(methodsFileName, \"Methods exclude input file name is null\");\n-        Asserts.assertFalse(methodsFileName.isEmpty(), \"Methods exclude input file name is empty\");\n-        LinkedList<String> methodNamesList = new LinkedList<>();\n-        Path klassesFilePath = Paths.get(methodsFileName);\n-        try {\n-            Files.lines(klassesFilePath).forEach(line -> {\n-                line = line.trim();\n-                if (line.isEmpty()) {\n-                    return;\n-                }\n-                String msg = String.format(\"Format of the methods exclude input file \\\"%s\\\" is incorrect,\"\n-                        + \" line \\\"%s\\\" has wrong format\", methodsFileName, line);\n-                Asserts.assertTrue(line.matches(\"\\\\w[\\\\w\/$]*::[\\\\w$]+\\\\((\\\\[?[ZBSCIJFD]|\\\\[?L[\\\\w\/$]+;)*\\\\)\"), msg);\n-                methodNamesList.add(line.substring(0, line.length() - 1));\n-            });\n-        } catch (IOException ex) {\n-            throw new Error(\"Error reading exclude method file\", ex);\n-        }\n-        Set<Executable> methodsList = new HashSet<>();\n-        methodNamesList.forEach(methodName -> {\n-            String[] klassAndNameAndSig = methodName.split(\"::\");\n-            String klassName = klassAndNameAndSig[0].replaceAll(\"\/\", \"\\\\.\");\n-            String[] nameAndSig = klassAndNameAndSig[1].split(\"[\\\\(\\\\)]\");\n-            String name = nameAndSig[0];\n-            String signature = \"\";\n-            if (nameAndSig.length > 1) {\n-                signature = nameAndSig[1];\n-            }\n-            Class<?> klass = null;\n-            List<Class<?>> signatureTypes = null;\n+    private void initMethodsToExclude(String methodsFileName) {\n+        if (methodsFileName != null && !methodsFileName.isEmpty()) {\n+            Path methodsFilePath = Paths.get(methodsFileName);\n@@ -269,19 +244,5 @@\n-                klass = Class.forName(klassName);\n-                signatureTypes = parseSignature(signature);\n-            } catch (ClassNotFoundException ex) {\n-                throw new Error(\"Unexpected exception while parsing exclude methods file\", ex);\n-            }\n-            try {\n-                Executable method;\n-                if (name.equals(klass.getSimpleName())) {\n-                    method = klass.getConstructor(signatureTypes.toArray(new Class<?>[0]));\n-                } else {\n-                    method = klass.getMethod(name, signatureTypes.toArray(new Class<?>[0]));\n-                }\n-                methodsList.add(method);\n-            } catch (NoSuchMethodException | SecurityException ex) {\n-                throw new Error(\"Unexpected exception while parsing exclude methods file\", ex);\n-            }\n-        });\n-        return methodsList;\n-    }\n+                methodsToExclude = Files.lines(methodsFilePath)\n+                    \/\/ Cleaning nonimportant parts\n+                    .map(TypesParser::trimComment)\n+                    .map(String::trim)\n+                    .filter(not(String::isEmpty))\n@@ -289,71 +250,5 @@\n-    private static List<Class<?>> parseSignature(String signature) throws ClassNotFoundException {\n-        LinkedList<Class<?>> sigClasses = new LinkedList<>();\n-        char typeChar;\n-        boolean isArray;\n-        String klassName;\n-        StringBuilder sb;\n-        StringBuilder arrayDim;\n-        try (StringReader str = new StringReader(signature)) {\n-            int symbol = str.read();\n-            while (symbol != -1){\n-                typeChar = (char) symbol;\n-                arrayDim = new StringBuilder();\n-                Class<?> primArrayClass = null;\n-                if (typeChar == '[') {\n-                    isArray = true;\n-                    arrayDim.append('[');\n-                    symbol = str.read();\n-                    while (symbol == '['){\n-                        arrayDim.append('[');\n-                        symbol = str.read();\n-                    }\n-                    typeChar = (char) symbol;\n-                    if (typeChar != 'L') {\n-                        primArrayClass = Class.forName(arrayDim.toString() + typeChar);\n-                    }\n-                } else {\n-                    isArray = false;\n-                }\n-                switch (typeChar) {\n-                    case 'Z':\n-                        sigClasses.add(isArray ? primArrayClass : boolean.class);\n-                        break;\n-                    case 'I':\n-                        sigClasses.add(isArray ? primArrayClass : int.class);\n-                        break;\n-                    case 'J':\n-                        sigClasses.add(isArray ? primArrayClass : long.class);\n-                        break;\n-                    case 'F':\n-                        sigClasses.add(isArray ? primArrayClass : float.class);\n-                        break;\n-                    case 'D':\n-                        sigClasses.add(isArray ? primArrayClass : double.class);\n-                        break;\n-                    case 'B':\n-                        sigClasses.add(isArray ? primArrayClass : byte.class);\n-                        break;\n-                    case 'S':\n-                        sigClasses.add(isArray ? primArrayClass : short.class);\n-                        break;\n-                    case 'C':\n-                        sigClasses.add(isArray ? primArrayClass : char.class);\n-                        break;\n-                    case 'L':\n-                        sb = new StringBuilder();\n-                        symbol = str.read();\n-                        while (symbol != ';') {\n-                            sb.append((char) symbol);\n-                            symbol = str.read();\n-                        }\n-                        klassName = sb.toString().replaceAll(\"\/\", \"\\\\.\");\n-                        if (isArray) {\n-                            klassName = arrayDim.toString() + \"L\" + klassName + \";\";\n-                        }\n-                        Class<?> klass = Class.forName(klassName);\n-                        sigClasses.add(klass);\n-                        break;\n-                    default:\n-                        throw new Error(\"Unknown type \" + typeChar);\n-                }\n-                symbol = str.read();\n+                    \/\/ Actual parsing\n+                    .map(MethodTemplate::parse)\n+                    .collect(Collectors.toList());\n+            } catch (IOException ex) {\n+                throw new Error(\"Error reading exclude method file\", ex);\n@@ -361,2 +256,2 @@\n-        } catch (IOException ex) {\n-            throw new Error(\"Unexpected exception while parsing exclude methods file\", ex);\n+        } else {\n+            methodsToExclude = new ArrayList<>();\n@@ -364,1 +259,0 @@\n-        return sigClasses;\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/TypesParser.java","additions":48,"deletions":154,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,1 @@\n-        Debugee debugee = binder.startLocalDebugee(cmd);\n+        Debugee debugee = binder.startDebugee(cmd);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/AttachingConnector\/attach\/attach001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,1 @@\n-        Debugee debugee = binder.startLocalDebugee(cmd);\n+        Debugee debugee = binder.startDebugee(cmd);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/AttachingConnector\/attach\/attach002.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,1 @@\n-        Debugee debugee = binder.startLocalDebugee(cmd);\n+        Debugee debugee = binder.startDebugee(cmd);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/AttachingConnector\/attachnosuspend\/attachnosuspend001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,1 @@\n-        Debugee debugee = binder.makeLocalDebugee(vm.process());\n+        Debugee debugee = binder.makeDebugee(vm.process());\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/LaunchingConnector\/launchnosuspend\/launchnosuspend001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-        Debugee debugee = binder.startLocalDebugee(cmd);\n+        Debugee debugee = binder.startDebugee(cmd);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ListeningConnector\/accept\/accept001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,1 +93,1 @@\n-        Debugee debugee = binder.startLocalDebugee(cmd);\n+        Debugee debugee = binder.startDebugee(cmd);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ListeningConnector\/accept\/accept002.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-        Debugee debugee = binder.startLocalDebugee(cmd);\n+        Debugee debugee = binder.startDebugee(cmd);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ListeningConnector\/listennosuspend\/listennosuspend001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -171,1 +171,1 @@\n-            debugee = binder.startLocalDebugee(cmd);\n+            debugee = binder.startDebugee(cmd);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ListeningConnector\/startListening\/startlis001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,1 +146,1 @@\n-            debugee = binder.startLocalDebugee(cmd);\n+            debugee = binder.startDebugee(cmd);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ListeningConnector\/startListening\/startlis002.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,1 +153,1 @@\n-            debugee = binder.startLocalDebugee(commandToRun);\n+            debugee = binder.startDebugee(commandToRun);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachineManager\/createVirtualMachine\/createVM002.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,1 +154,1 @@\n-            debugee = binder.startLocalDebugee(commandToRun);\n+            debugee = binder.startDebugee(commandToRun);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachineManager\/createVirtualMachine\/createVM003.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,1 +157,1 @@\n-            debugee = binder.startLocalDebugee(commandToRun);\n+            debugee = binder.startDebugee(commandToRun);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachineManager\/createVirtualMachine\/createVM004.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,1 +153,1 @@\n-            debugee = binder.startLocalDebugee(commandToRun);\n+            debugee = binder.startDebugee(commandToRun);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachineManager\/createVirtualMachine\/createVM005.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,3 @@\n+ * @comment We test with arguments out of scope of the jvmti enums, which causes\n+ *          ubsan issues.\n+ * @requires !vm.ubsan\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetErrorName\/geterrname002\/TestDescription.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,3 @@\n+ * @comment We test with arguments out of scope of the jvmti enums, which causes\n+ *          ubsan issues.\n+ * @requires !vm.ubsan\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetVerboseFlag\/setvrbflag002\/TestDescription.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-     * Launch debuggee on local host.\n+     * Launch debuggee.\n@@ -62,1 +62,1 @@\n-        launcher.display(\"Starting local debuggee.\");\n+        launcher.display(\"Starting debuggee.\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdb\/Debuggee.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n- * This class provides launching of <code>jdb<\/code> and debuggee in local\n- * mode according to test command line options.\n+ * This class provides launching of <code>jdb<\/code> and debuggee\n+ * according to test command line options.\n@@ -97,1 +97,1 @@\n-     * Defines mode (local) and type of connector (default, launching,\n+     * Defines type of connector (default, launching,\n@@ -100,1 +100,1 @@\n-     * and debuggee in defined mode.\n+     * and debuggee.\n@@ -107,1 +107,1 @@\n-            localDefaultLaunch(jdbCmdArgs, classToExecute);\n+            defaultLaunch(jdbCmdArgs, classToExecute);\n@@ -109,1 +109,1 @@\n-            localRawLaunch(jdbCmdArgs, classToExecute);\n+            rawLaunch(jdbCmdArgs, classToExecute);\n@@ -111,1 +111,1 @@\n-            localLaunch(jdbCmdArgs, classToExecute);\n+            launchFromJdb(jdbCmdArgs, classToExecute);\n@@ -113,1 +113,1 @@\n-            localLaunchAndAttach(jdbCmdArgs, classToExecute);\n+            launchAndAttach(jdbCmdArgs, classToExecute);\n@@ -115,1 +115,1 @@\n-            localLaunchAndListen(jdbCmdArgs, classToExecute);\n+            launchAndListen(jdbCmdArgs, classToExecute);\n@@ -117,1 +117,1 @@\n-            throw new TestBug(\"Unexpected connector type for local launch mode\"\n+            throw new TestBug(\"Unexpected connector type: \"\n@@ -258,1 +258,1 @@\n-     * Run test in local mode using default connector.\n+     * Run test using default connector.\n@@ -260,1 +260,1 @@\n-    private void localDefaultLaunch\n+    private void defaultLaunch\n@@ -262,1 +262,1 @@\n-        localLaunch(jdbCmdArgs, classToExecute);\n+        launchFromJdb(jdbCmdArgs, classToExecute);\n@@ -266,1 +266,1 @@\n-     * Run test in local mode using raw launching connector.\n+     * Run test using raw launching connector.\n@@ -268,1 +268,1 @@\n-    private void localRawLaunch\n+    private void rawLaunch\n@@ -270,1 +270,1 @@\n-        localLaunch(jdbCmdArgs, classToExecute);\n+        launchFromJdb(jdbCmdArgs, classToExecute);\n@@ -274,1 +274,1 @@\n-     * Run test in local mode using launching connector.\n+     * Run test using launching connector.\n@@ -276,1 +276,1 @@\n-    private void localLaunch\n+    private void launchFromJdb\n@@ -280,1 +280,1 @@\n-        display(\"Starting jdb launching local debuggee\");\n+        display(\"Starting jdb launching debuggee\");\n@@ -290,1 +290,1 @@\n-     * Run test in local mode using attaching connector.\n+     * Run test using attaching connector.\n@@ -292,1 +292,1 @@\n-    private void localLaunchAndAttach\n+    private void launchAndAttach\n@@ -300,1 +300,1 @@\n-        display(\"Start jdb attaching to local debuggee\");\n+        display(\"Starting jdb attaching to debuggee\");\n@@ -306,1 +306,1 @@\n-     * Run test in local mode using listening connector.\n+     * Run test using listening connector.\n@@ -308,1 +308,1 @@\n-    private void localLaunchAndListen\n+    private void launchAndListen\n@@ -312,1 +312,1 @@\n-        display(\"Starting jdb listening to local debuggee\");\n+        display(\"Starting jdb listening to debuggee\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdb\/Launcher.java","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -477,8 +477,0 @@\n-\/*\n-        if (! isLaunchedLocally() && ! isDefaultJVMDIStrictMode()) {\n-            throw new BadOption(\"inconsistent options: \"\n-                                + \"-launch.mode=\" + getLaunchMode()\n-                                + \" and -jvmdi.strict=\" + getJVMDIStrictMode());\n-        }\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdi\/ArgumentHandler.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-     * Make initial <code>Debugee<\/code> object for local debuggee process\n+     * Make initial <code>Debugee<\/code> object for debuggee process\n@@ -129,1 +129,1 @@\n-    public Debugee makeLocalDebugee(Process process) {\n+    public Debugee makeDebugee(Process process) {\n@@ -134,1 +134,1 @@\n-     * Launch local debuggee process with specified command line\n+     * Launch debuggee process with specified command line\n@@ -137,1 +137,1 @@\n-    public Debugee startLocalDebugee(String cmd) {\n+    public Debugee startDebugee(String cmd) {\n@@ -144,1 +144,1 @@\n-            throw new Failure(\"Caught exception while launching local debuggee VM process:\\n\\t\"\n+            throw new Failure(\"Caught exception while launching debuggee VM process:\\n\\t\"\n@@ -148,1 +148,1 @@\n-        return makeLocalDebugee(process);\n+        return makeDebugee(process);\n@@ -157,1 +157,1 @@\n-        Debugee debugee = makeLocalDebugee(proc);\n+        Debugee debugee = makeDebugee(proc);\n@@ -192,1 +192,1 @@\n-            debugee = localDefaultLaunchDebugee(vmm, classToExecute, classPath);\n+            debugee = defaultLaunchDebugee(vmm, classToExecute, classPath);\n@@ -194,1 +194,1 @@\n-            debugee = localRawLaunchDebugee(vmm, classToExecute, classPath);\n+            debugee = rawLaunchDebugee(vmm, classToExecute, classPath);\n@@ -196,1 +196,1 @@\n-            debugee = localLaunchDebugee(vmm, classToExecute, classPath);\n+            debugee = launchDebugee(vmm, classToExecute, classPath);\n@@ -198,1 +198,1 @@\n-            debugee = localLaunchAndAttachDebugee(vmm, classToExecute, classPath);\n+            debugee = launchAndAttachDebugee(vmm, classToExecute, classPath);\n@@ -200,1 +200,1 @@\n-            debugee = localLaunchAndListenDebugee(vmm, classToExecute, classPath);\n+            debugee = launchAndListenDebugee(vmm, classToExecute, classPath);\n@@ -202,1 +202,1 @@\n-            throw new TestBug(\"Unexpected connector type for local debugee launch mode\"\n+            throw new TestBug(\"Unexpected connector type for debugee: \"\n@@ -234,1 +234,1 @@\n-     * Launch debugee locally via the default LaunchingConnector.\n+     * Launch debugee via the default LaunchingConnector.\n@@ -236,1 +236,1 @@\n-    private Debugee localDefaultLaunchDebugee (VirtualMachineManager vmm,\n+    private Debugee defaultLaunchDebugee (VirtualMachineManager vmm,\n@@ -260,1 +260,1 @@\n-        Debugee debugee = makeLocalDebugee(process);\n+        Debugee debugee = makeDebugee(process);\n@@ -269,1 +269,1 @@\n-     * Launch debugee locally via the default LaunchingConnector.\n+     * Launch debugee via the default LaunchingConnector.\n@@ -271,1 +271,1 @@\n-    private Debugee localLaunchDebugee (VirtualMachineManager vmm,\n+    private Debugee launchDebugee (VirtualMachineManager vmm,\n@@ -298,1 +298,1 @@\n-        Debugee debugee = makeLocalDebugee(process);\n+        Debugee debugee = makeDebugee(process);\n@@ -306,1 +306,1 @@\n-     * Launch debugee locally via the RawLaunchingConnector.\n+     * Launch debugee via the RawLaunchingConnector.\n@@ -308,1 +308,1 @@\n-    private Debugee localRawLaunchDebugee (VirtualMachineManager vmm,\n+    private Debugee rawLaunchDebugee (VirtualMachineManager vmm,\n@@ -334,1 +334,1 @@\n-        Debugee debugee = makeLocalDebugee(process);\n+        Debugee debugee = makeDebugee(process);\n@@ -342,2 +342,1 @@\n-     * Launch debugee VM locally as a local process and connect to it using\n-     * <code>AttachingConnector<\/code>.\n+     * Launch debugee VM and connect to it using <code>AttachingConnector<\/code>.\n@@ -345,1 +344,1 @@\n-    private Debugee localLaunchAndAttachDebugee (VirtualMachineManager vmm,\n+    private Debugee launchAndAttachDebugee (VirtualMachineManager vmm,\n@@ -359,1 +358,1 @@\n-        Debugee debugee = startLocalDebugee(cmdLineArgs);\n+        Debugee debugee = startDebugee(cmdLineArgs);\n@@ -394,2 +393,1 @@\n-     * Launch debugee VM locally as a local process and connect to it using\n-     * <code>ListeningConnector<\/code>.\n+     * Launch debugee VM and connect to it using <code>ListeningConnector<\/code>.\n@@ -397,1 +395,1 @@\n-    private Debugee localLaunchAndListenDebugee (VirtualMachineManager vmm,\n+    private Debugee launchAndListenDebugee (VirtualMachineManager vmm,\n@@ -422,1 +420,1 @@\n-        Debugee debugee = startLocalDebugee(cmdLineArgs);\n+        Debugee debugee = startDebugee(cmdLineArgs);\n@@ -688,1 +686,1 @@\n-     * Launch local debuggee process with specified command line arguments\n+     * Launch debuggee process with specified command line arguments\n@@ -691,1 +689,1 @@\n-    protected Debugee startLocalDebugee(String[] cmdArgs) {\n+    protected Debugee startDebugee(String[] cmdArgs) {\n@@ -698,1 +696,1 @@\n-            throw new Failure(\"Caught exception while launching local debuggee VM process:\\n\\t\"\n+            throw new Failure(\"Caught exception while launching debuggee VM process:\\n\\t\"\n@@ -702,1 +700,1 @@\n-        return makeLocalDebugee(process);\n+        return makeDebugee(process);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdi\/Binder.java","additions":32,"deletions":34,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -41,5 +41,0 @@\n- * This is an abstract class that declares abstract methods to control\n- * debugee VM process.\n- * Derived classes should implement these methods corresponding to the mode\n- * that the process should be started in (locally).\n- * <p>\n@@ -55,1 +50,1 @@\n-abstract public class DebugeeProcess {\n+public class DebugeeProcess {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/DebugeeProcess.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @requires !vm.debug & (vm.compMode != \"Xcomp\")\n+ * @requires vm.compMode != \"Xcomp\"\n@@ -33,4 +33,4 @@\n- * @run main\/othervm DumpThreadsWithEliminatedLock plain platform\n- * @run main\/othervm DumpThreadsWithEliminatedLock plain virtual\n- * @run main\/othervm DumpThreadsWithEliminatedLock json platform\n- * @run main\/othervm DumpThreadsWithEliminatedLock json virtual\n+ * @run main\/othervm -XX:CompileCommand=inline,java\/lang\/String*.* DumpThreadsWithEliminatedLock plain platform\n+ * @run main\/othervm -XX:CompileCommand=inline,java\/lang\/String*.* DumpThreadsWithEliminatedLock plain virtual\n+ * @run main\/othervm -XX:CompileCommand=inline,java\/lang\/String*.* DumpThreadsWithEliminatedLock json platform\n+ * @run main\/othervm -XX:CompileCommand=inline,java\/lang\/String*.* DumpThreadsWithEliminatedLock json virtual\n","filename":"test\/jdk\/com\/sun\/management\/HotSpotDiagnosticMXBean\/DumpThreadsWithEliminatedLock.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Window;\n+\n+\/**\n+ * @test\n+ * @bug 8346952\n+ * @summary Verifies no exception occurs when triggering updateCG()\n+ * for an ownerless window.\n+ * @key headful\n+ *\/\n+public final class BogusFocusableWindowState {\n+\n+    public static void main(String[] args) {\n+        Window frame = new Window(null) {\n+            @Override\n+            public boolean getFocusableWindowState() {\n+                removeNotify();\n+                return true;\n+            }\n+        };\n+        try {\n+            frame.pack();\n+            frame.setVisible(true);\n+        } finally {\n+            frame.dispose();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/BogusFocusableWindowState\/BogusFocusableWindowState.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n- * @bug 8235638 8235739 8285094\n+ * @bug 8235638 8235739 8285094 8346952\n","filename":"test\/jdk\/java\/awt\/Frame\/GetGraphicsStressTest\/GetGraphicsStressTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.color.ColorSpace;\n+import java.awt.color.ICC_Profile;\n+\n+\/**\n+ * @test\n+ * @bug 8358623\n+ * @summary Verifies ICC profile version of built-in color spaces\n+ *\/\n+public final class CheckVersions {\n+\n+    public static void main(String[] args) {\n+        test(ColorSpace.CS_CIEXYZ, 2, 3, 0);\n+        test(ColorSpace.CS_GRAY, 2, 3, 0);\n+        test(ColorSpace.CS_LINEAR_RGB, 2, 3, 0);\n+        test(ColorSpace.CS_PYCC, 4, 0, 0);\n+        test(ColorSpace.CS_sRGB, 2, 3, 0);\n+    }\n+\n+    private static void test(int cs, int expMajor, int expMinor, int expPatch) {\n+        ICC_Profile profile = ICC_Profile.getInstance(cs);\n+\n+        int major = profile.getMajorVersion();\n+        int minorRaw = profile.getMinorVersion();\n+        int minor = (minorRaw >> 4) & 0x0F;\n+        int patch = minorRaw & 0x0F;\n+\n+        if (major != expMajor || minor != expMinor || patch != expPatch) {\n+            System.err.println(\"Expected major: \" + expMajor);\n+            System.err.println(\"Expected minor: \" + expMinor);\n+            System.err.println(\"Expected patch: \" + expPatch);\n+\n+            System.err.println(\"Actual major: \" + major);\n+            System.err.println(\"Actual minor: \" + minor);\n+            System.err.println(\"Actual patch: \" + patch);\n+            throw new RuntimeException(\"Test failed for ColorSpace: \" + cs);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/CheckVersions.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -69,1 +69,2 @@\n-        List<String> strings = new ArrayList<String>(size);\n+        StringBuilder sb = new StringBuilder(plen);\n+        List<String> strings = new ArrayList<>(size);\n@@ -73,1 +74,22 @@\n-            strings.add(PHRASE.substring(fromIndex, toIndex));\n+            String s = PHRASE.substring(fromIndex, toIndex);\n+            sb.append(s);\n+            int bound = toIndex - fromIndex;\n+            if (bound > 0) {\n+                int offset = bound\/2;\n+                int n = rnd.nextInt(0, bound);\n+                for (int i = 0; i < n; i++) {\n+                    String f = null;\n+                    switch (rnd.nextInt(7)) {\n+                    case 0 -> f = \"\";\n+                    case 1 -> f = \"\\r\";\n+                    case 2 -> f = \"\\n\";\n+                    case 3 -> f = \"\\r\\n\";\n+                    case 4 -> f = \"\\r\\r\";\n+                    case 5 -> f = \"\\n\\n\";\n+                    case 6 -> f = \" \";\n+                    }\n+                    sb.insert(offset, f);\n+                }\n+            }\n+            strings.add(sb.toString());\n+            sb.setLength(0);\n@@ -75,0 +97,21 @@\n+\n+        String p4096  = PHRASE.repeat((4096 + plen - 1)\/plen);\n+        String p8192  = PHRASE.repeat((8192 + plen - 1)\/plen);\n+        String p16384 = PHRASE.repeat((16384 + plen - 1)\/plen);\n+\n+        for (int i = 0; i < 64; i++) {\n+            for (int j = 0; j < 32; j++) {\n+                switch (rnd.nextInt(8)) {\n+                case 0 -> sb.append(\"\");\n+                case 1 -> sb.append(\" \");\n+                case 2 -> sb.append(\"\\n\");\n+                case 3 -> sb.append(PHRASE);\n+                case 5 -> sb.append(p4096);\n+                case 6 -> sb.append(p8192);\n+                case 7 -> sb.append(p16384);\n+                }\n+            }\n+            strings.add(sb.toString());\n+            sb.setLength(0);\n+        }\n+\n@@ -88,0 +131,1 @@\n+        System.out.println(\"Reader implementation\");\n@@ -95,1 +139,12 @@\n-        assertEquals(linesExpected, lines);\n+        int count = linesExpected.size();\n+        if (lines.size() != count)\n+            throw new RuntimeException(\"Size mismatch: \" + lines.size() + \" != \" + count);\n+        for (int i = 0; i < count; i++) {\n+            String expected = linesExpected.get(i);\n+            String actual = lines.get(i);\n+            if (!actual.equals(expected)) {\n+                String msg = String.format(\"%d: \\\"%s\\\" != \\\"%s\\\"\",\n+                                           i, actual, expected);\n+                throw new RuntimeException(msg);\n+            }\n+        }\n@@ -98,0 +153,1 @@\n+        System.out.println(\"Reader.of implementation\");\n@@ -106,1 +162,12 @@\n-        assertEquals(linesExpected, lines);\n+        count = linesExpected.size();\n+        if (lines.size() != count)\n+            throw new RuntimeException(\"Size mismatch: \" + lines.size() + \" != \" + count);\n+        for (int i = 0; i < count; i++) {\n+            String expected = linesExpected.get(i);\n+            String actual = lines.get(i);\n+            if (!actual.equals(expected)) {\n+                String msg = String.format(\"%d: \\\"%s\\\" != \\\"%s\\\"\",\n+                                           i, actual, expected);\n+                throw new RuntimeException(msg);\n+            }\n+        }\n","filename":"test\/jdk\/java\/io\/Reader\/ReadAll.java","additions":71,"deletions":4,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @bug 8343110\n+ * @bug 8343110 8361299\n@@ -74,0 +74,13 @@\n+    @Test\n+    public void testSrcBeginIsNegationOfPosition() {\n+        CB.position(1);\n+        Assert.assertThrows(IndexOutOfBoundsException.class,\n+                            () -> {\n+                                try {\n+                                    CB.getChars(-1, 3, new char[4], 0);\n+                                } finally {\n+                                    CB.position(0);\n+                                }\n+                            });\n+    }\n+\n@@ -203,1 +216,1 @@\n-        cb.getChars(cb.position(), cb.limit(), dst, 0);\n+        cb.getChars(0, cb.remaining(), dst, 0);\n","filename":"test\/jdk\/java\/nio\/Buffer\/GetChars.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,4 +27,3 @@\n- * @bug 8358159\n- * @summary test that the Cipher.getInstance() handles\n- * transformations with empty mode and\/or padding\n- * @run main TestEmptyModePadding\n+ * @bug 8359388\n+ * @summary test that the Cipher.getInstance() would reject improper\n+ *     transformations with empty mode and\/or padding.\n@@ -33,3 +32,4 @@\n-\n-import java.security.*;\n-import javax.crypto.*;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.Security;\n+import javax.crypto.Cipher;\n@@ -40,1 +40,4 @@\n-        Provider provider = Security.getProvider(System.getProperty(\"test.provider.name\", \"SunJCE\"));\n+        Provider provider = Security.getProvider(\n+                System.getProperty(\"test.provider.name\", \"SunJCE\"));\n+\n+        System.out.println(\"Testing against \" + provider.getName());\n@@ -42,8 +45,26 @@\n-        test(\"AES\", provider);\n-        test(\"AES\/ECB\/PKCS5Padding\", provider);\n-        test(\"AES\/\/PKCS5Padding\", provider);        \/\/ Empty mode\n-        test(\"AES\/CBC\/\", provider);                 \/\/ Empty padding\n-        test(\"AES\/ \/NoPadding\", provider);          \/\/ Mode is a space\n-        test(\"AES\/CBC\/ \", provider);                \/\/ Padding is a space\n-        test(\"AES\/ \/ \", provider);                  \/\/ Both mode and padding are spaces\n-        test(\"AES\/\/\", provider);                    \/\/ Both mode and padding are missing\n+        String[] testTransformations = {\n+            \/\/ transformations w\/ only 1 component, i.e. algo\n+            \" \",\n+            \/\/ transformations w\/ only 2 components\n+            \"AES\/\",\n+            \"AES\/ \",\n+            \"AES\/CBC\",\n+            \"PBEWithHmacSHA512\/224AndAES_128\/\",\n+            \"PBEWithHmacSHA512\/256AndAES_128\/ \",\n+            \"PBEWithHmacSHA512\/224AndAES_128\/CBC\",\n+            \/\/ 3-component transformations w\/ empty component(s)\n+            \"AES\/\/\",\n+            \"AES\/ \/\",\n+            \"AES\/\/ \",\n+            \"AES\/ \/ \",\n+            \"AES\/CBC\/\", \"AES\/CBC\/ \",\n+            \"AES\/\/PKCS5Padding\", \"AES\/ \/NoPadding\",\n+            \"PBEWithHmacSHA512\/224AndAES_128\/\/\",\n+            \"PBEWithHmacSHA512\/224AndAES_128\/ \/\",\n+            \"PBEWithHmacSHA512\/224AndAES_128\/\/ \",\n+            \"PBEWithHmacSHA512\/224AndAES_128\/ \/ \",\n+            \"PBEWithHmacSHA512\/256AndAES_128\/CBC\/\",\n+            \"PBEWithHmacSHA512\/256AndAES_128\/CBC\/ \",\n+            \"PBEWithHmacSHA512\/256AndAES_128\/\/PKCS5Padding\",\n+            \"PBEWithHmacSHA512\/256AndAES_128\/ \/PKCS5Padding\",\n+        };\n@@ -51,0 +72,3 @@\n+        for (String t : testTransformations) {\n+            test(t, provider);\n+        }\n@@ -53,2 +77,8 @@\n-    private static void test(String transformation, Provider provider) throws Exception {\n-        Cipher c = Cipher.getInstance(transformation, provider);\n+    private static void test(String t, Provider p) throws Exception {\n+        try {\n+            Cipher c = Cipher.getInstance(t, p);\n+            throw new RuntimeException(\"Should throw NSAE for \\'\" + t + \"\\'\");\n+        } catch (NoSuchAlgorithmException nsae) {\n+            \/\/ transformation info is already in the NSAE message\n+            System.out.println(\"Expected NSAE: \" + nsae.getMessage());\n+        }\n","filename":"test\/jdk\/javax\/crypto\/Cipher\/TestEmptyModePadding.java","additions":48,"deletions":18,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-                throw new Error(\"Failed 4276920: BasicComboPopup.hide() caused unnecessary repaint()\");\n+                throw new RuntimeException(\"Failed 4276920: BasicComboPopup.hide() caused unnecessary repaint()\");\n","filename":"test\/jdk\/javax\/swing\/JComboBox\/bug4276920.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test\n+ * @test id=metal\n@@ -28,2 +28,1 @@\n- * @summary\n- *     This test checks if menu items lay out correctly when their\n+ * @summary Verifies if menu items lay out correctly when their\n@@ -31,3 +30,0 @@\n- *     The tester is asked to compare left-to-right and\n- *     right-to-left menus and judge whether they are mirror images of each\n- *     other.\n@@ -36,1 +32,23 @@\n- * @run main\/manual RightLeftOrientation\n+ * @run main\/manual RightLeftOrientation metal\n+ *\/\n+\n+\/*\n+ * @test id=motif\n+ * @bug 4211052\n+ * @requires (os.family == \"windows\")\n+ * @summary Verifies if menu items lay out correctly when their\n+ *     ComponentOrientation property is set to RIGHT_TO_LEFT.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual RightLeftOrientation motif\n+ *\/\n+\n+\/*\n+ * @test id=windows\n+ * @bug 4211052\n+ * @requires (os.family == \"windows\")\n+ * @summary Verifies if menu items lay out correctly when their\n+ *     ComponentOrientation property is set to RIGHT_TO_LEFT.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual RightLeftOrientation windows\n@@ -55,1 +73,1 @@\n-import javax.swing.LookAndFeel;\n+import javax.swing.SwingUtilities;\n@@ -62,5 +80,1 @@\n-        A menu bar is shown containing a menu for each look and feel.\n-        A disabled menu means that the look and feel is not available for\n-        testing in this environment.\n-        Every effort should be made to run this test\n-        in an environment that covers all look and feels.\n+        A menu bar is shown with a menu.\n@@ -68,1 +82,1 @@\n-        Each menu is divided into two halves. The upper half is oriented\n+        The menu is divided into two halves. The upper half is oriented\n@@ -70,1 +84,1 @@\n-        For each menu, ensure that the lower half mirrors the upper half.\n+        Ensure that the lower half mirrors the upper half.\n@@ -76,0 +90,23 @@\n+        if (args.length < 1) {\n+            throw new IllegalArgumentException(\"Look-and-Feel keyword is required\");\n+        }\n+\n+        final String lafClassName;\n+        switch (args[0]) {\n+            case \"metal\" -> lafClassName = UIManager.getCrossPlatformLookAndFeelClassName();\n+            case \"motif\" -> lafClassName = \"com.sun.java.swing.plaf.motif.MotifLookAndFeel\";\n+            case \"windows\" -> lafClassName = \"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\";\n+            default -> throw new IllegalArgumentException(\n+                           \"Unsupported Look-and-Feel keyword for this test: \" + args[0]);\n+        }\n+\n+        SwingUtilities.invokeAndWait(() -> {\n+            try {\n+                UIManager.setLookAndFeel(lafClassName);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+\n+        System.out.println(\"Test for LookAndFeel \" + lafClassName);\n+\n@@ -77,1 +114,0 @@\n-                .title(\"RightLeftOrientation Instructions\")\n@@ -89,6 +125,1 @@\n-        menuBar.add(createMenu(\"javax.swing.plaf.metal.MetalLookAndFeel\",\n-                                \"Metal\"));\n-        menuBar.add(createMenu(\"com.sun.java.swing.plaf.motif.MotifLookAndFeel\",\n-                                \"Motif\"));\n-        menuBar.add(createMenu(\"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\",\n-                                \"Windows\"));\n+        menuBar.add(createMenu());\n@@ -97,1 +128,1 @@\n-        frame.pack();\n+        frame.setSize(250, 70);\n@@ -102,13 +133,5 @@\n-    static JMenu createMenu(String laf, String name) {\n-        JMenu menu = new JMenu(name);\n-        try {\n-            LookAndFeel save = UIManager.getLookAndFeel();\n-            UIManager.setLookAndFeel(laf);\n-            addMenuItems(menu, ComponentOrientation.LEFT_TO_RIGHT);\n-            menu.addSeparator();\n-            addMenuItems(menu, ComponentOrientation.RIGHT_TO_LEFT);\n-            UIManager.setLookAndFeel(save);\n-        } catch (Exception e) {\n-            menu = new JMenu(name);\n-            menu.setEnabled(false);\n-        }\n+    static JMenu createMenu() {\n+        JMenu menu = new JMenu(UIManager.getLookAndFeel().getID());\n+        addMenuItems(menu, ComponentOrientation.LEFT_TO_RIGHT);\n+        menu.addSeparator();\n+        addMenuItems(menu, ComponentOrientation.RIGHT_TO_LEFT);\n","filename":"test\/jdk\/javax\/swing\/JMenuItem\/RightLeftOrientation.java","additions":59,"deletions":36,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,2 @@\n+import static sun.java2d.pipe.Region.clipRound;\n+\n@@ -47,1 +49,1 @@\n- * @bug 8282958\n+ * @bug 8282958 8349188\n@@ -50,0 +52,1 @@\n+ * @modules java.desktop\/sun.java2d.pipe\n@@ -53,1 +56,1 @@\n-    private static final Dimension SIZE = new Dimension(120, 25);\n+    private static final Dimension SIZE = new Dimension(250, 50);\n@@ -62,0 +65,7 @@\n+    private static final int[] thickness = {1, 4, 10, 15};\n+\n+    private record TestImage(BufferedImage image,\n+                             List<Point> panelLocations,\n+                             double scale,\n+                             int thickness) {\n+    }\n@@ -63,2 +73,4 @@\n-    private static final List<BufferedImage> images =\n-            new ArrayList<>(scales.length);\n+    private record TestUI(JComponent content,\n+                          List<Point> panelLocations,\n+                          int thickness) {\n+    }\n@@ -66,2 +78,0 @@\n-    private static final List<Point> panelLocations =\n-            new ArrayList<>(4);\n@@ -77,3 +87,14 @@\n-        JComponent content = createUI();\n-        if (showFrame) {\n-            showFrame(content);\n+        for (int thickness : thickness) {\n+            TestUI testUI = createUI(thickness);\n+            if (showFrame) {\n+                showFrame(testUI.content);\n+            }\n+\n+            List<TestImage> images = paintToImages(testUI, saveImages);\n+            verifyBorderRendering(images, saveImages);\n+        }\n+\n+        if (errorCount > 0) {\n+            throw new Error(\"Test failed: \"\n+                    + errorCount + \" error(s) detected - \"\n+                    + errorMessage);\n@@ -82,2 +103,0 @@\n-        paintToImages(content, saveImages);\n-        verifyBorderRendering(saveImages);\n@@ -86,8 +105,2 @@\n-    private static void verifyBorderRendering(final boolean saveImages) {\n-        String errorMessage = null;\n-        int errorCount = 0;\n-        for (int i = 0; i < images.size(); i++) {\n-            BufferedImage img = images.get(i);\n-            double scaling = scales[i];\n-            try {\n-                int thickness = (int) Math.floor(scaling);\n+    private static String errorMessage = null;\n+    private static int errorCount = 0;\n@@ -95,1 +108,7 @@\n-                checkVerticalBorders(SIZE.width \/ 2, thickness, img);\n+    private static void verifyBorderRendering(final List<TestImage> images,\n+                                              final boolean saveImages) {\n+        for (TestImage test : images) {\n+            final BufferedImage img = test.image;\n+            final int effectiveThickness = clipRound(test.thickness * test.scale);\n+            try {\n+                checkVerticalBorders((int) (SIZE.width * test.scale \/ 2), effectiveThickness, img);\n@@ -97,3 +116,3 @@\n-                for (Point p : panelLocations) {\n-                    int y = (int) (p.y * scaling) + SIZE.height \/ 2;\n-                    checkHorizontalBorder(y, thickness, img);\n+                for (Point p : test.panelLocations) {\n+                    int y = (int) ((p.y + (SIZE.height \/ 2)) * test.scale);\n+                    checkHorizontalBorder(y, effectiveThickness, img);\n@@ -107,1 +126,2 @@\n-                System.err.printf(\"Scaling: %.2f\\n\", scaling);\n+                System.err.printf(\"Scale: %.2f; thickness: %d, effective: %d\\n\",\n+                        test.scale, test.thickness, effectiveThickness);\n@@ -110,4 +130,1 @@\n-                \/\/ Save the image if it wasn't already saved\n-                if (!saveImages) {\n-                    saveImage(img, getImageFileName(scaling));\n-                }\n+                saveImage(img, getImageFileName(test.scale, test.thickness));\n@@ -116,6 +133,0 @@\n-\n-        if (errorCount > 0) {\n-            throw new Error(\"Test failed: \"\n-                    + errorCount + \" error(s) detected - \"\n-                    + errorMessage);\n-        }\n@@ -223,1 +234,1 @@\n-    private static JComponent createUI() {\n+    private static TestUI createUI(int thickness) {\n@@ -227,0 +238,2 @@\n+        List<Point> panelLocations = new ArrayList<>(4);\n+\n@@ -233,1 +246,1 @@\n-            filler.setBorder(BorderFactory.createLineBorder(BORDER_COLOR));\n+            filler.setBorder(BorderFactory.createLineBorder(BORDER_COLOR, thickness));\n@@ -251,1 +264,1 @@\n-        return contentPanel;\n+        return new TestUI(contentPanel, panelLocations, thickness);\n@@ -263,3 +276,5 @@\n-    private static void paintToImages(final JComponent content,\n-                                      final boolean saveImages) {\n-        for (double scaling : scales) {\n+    private static List<TestImage> paintToImages(final TestUI testUI,\n+                                                 final boolean saveImages) {\n+        final List<TestImage> images = new ArrayList<>(scales.length);\n+        final JComponent content = testUI.content;\n+        for (double scale : scales) {\n@@ -267,2 +282,2 @@\n-                    new BufferedImage((int) Math.ceil(content.getWidth() * scaling),\n-                            (int) Math.ceil(content.getHeight() * scaling),\n+                    new BufferedImage((int) Math.ceil(content.getWidth() * scale),\n+                            (int) Math.ceil(content.getHeight() * scale),\n@@ -272,1 +287,1 @@\n-            g2d.scale(scaling, scaling);\n+            g2d.scale(scale, scale);\n@@ -277,1 +292,1 @@\n-                saveImage(image, getImageFileName(scaling));\n+                saveImage(image, getImageFileName(scale, testUI.thickness));\n@@ -279,1 +294,2 @@\n-            images.add(image);\n+            images.add(new TestImage(image, testUI.panelLocations,\n+                    scale, testUI.thickness));\n@@ -281,0 +297,1 @@\n+        return images;\n@@ -283,2 +300,3 @@\n-    private static String getImageFileName(final double scaling) {\n-        return String.format(\"test%.2f.png\", scaling);\n+    private static String getImageFileName(final double scaling,\n+                                           final int thickness) {\n+        return String.format(\"test%02d@%.2f.png\", thickness, scaling);\n","filename":"test\/jdk\/javax\/swing\/border\/LineBorder\/ScaledLineBorderTest.java","additions":66,"deletions":48,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,2 @@\n+import static sun.java2d.pipe.Region.clipRound;\n+\n@@ -49,1 +51,1 @@\n- * @bug 8282958\n+ * @bug 8282958 8349188\n@@ -53,0 +55,1 @@\n+ * @modules java.desktop\/sun.java2d.pipe\n@@ -95,1 +98,1 @@\n-                int thickness = (int) Math.floor(scaling);\n+                int thickness = clipRound(scaling);\n","filename":"test\/jdk\/javax\/swing\/border\/LineBorder\/ScaledTextFieldBorderTest.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8361615\n@@ -49,0 +50,1 @@\n+                assertThrows(IndexOutOfBoundsException.class, () -> xb.parameterSlot(-1));\n@@ -53,0 +55,2 @@\n+                assertThrows(IndexOutOfBoundsException.class, () -> xb.parameterSlot(3));\n+                assertThrows(IndexOutOfBoundsException.class, () -> xb.parameterSlot(Integer.MAX_VALUE));\n@@ -59,0 +63,3 @@\n+                              assertThrows(IndexOutOfBoundsException.class, () -> xb.parameterSlot(Integer.MIN_VALUE));\n+                              assertThrows(IndexOutOfBoundsException.class, () -> xb.parameterSlot(-1));\n+                              assertThrows(IllegalStateException.class, () -> xb.receiverSlot());\n@@ -62,0 +69,1 @@\n+                              assertThrows(IndexOutOfBoundsException.class, () -> xb.parameterSlot(3));\n","filename":"test\/jdk\/jdk\/classfile\/BuilderParamTest.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 8333812\n+ * @bug 8333812 8361526\n@@ -34,0 +34,2 @@\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.classfile.ClassFile.JAVA_8_VERSION;\n@@ -36,0 +38,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -45,0 +48,1 @@\n+import java.util.Map;\n@@ -416,0 +420,23 @@\n+\n+    @Test \/\/ JDK-8350029\n+    void testInvokeSpecialInterfacePatch() {\n+        var runClass = ClassDesc.of(\"Run\");\n+        var testClass = ClassDesc.of(\"Test\");\n+        var runnableClass = Runnable.class.describeConstable().orElseThrow();\n+        var chr = ClassHierarchyResolver.of(List.of(), Map.of(runClass, CD_Object))\n+                .orElse(ClassHierarchyResolver.defaultResolver()).cached();\n+        var context = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(chr));\n+\n+        for (var isInterface : new boolean[] {true, false}) {\n+            var bytes = context.build(testClass, clb -> clb\n+                    .withVersion(JAVA_8_VERSION, 0)\n+                    .withSuperclass(runClass)\n+                    .withMethodBody(\"test\", MethodTypeDesc.of(CD_void, testClass), ACC_STATIC, cob -> cob\n+                            .aload(0)\n+                            .invokespecial(runnableClass, \"run\", MTD_void, isInterface)\n+                            .return_()));\n+            var errors = context.verify(bytes);\n+            assertNotEquals(List.of(), errors, \"invokespecial, isInterface = \" + isInterface);\n+            assertTrue(errors.getFirst().getMessage().contains(\"interface method to invoke is not in a direct superinterface\"), errors.getFirst().getMessage());\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/VerifierSelfTest.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1,64 +1,0 @@\n-\/*\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4954921 8009259\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.ref\n- * @build jdk.test.lib.Utils\n- *        jdk.test.lib.Asserts\n- *        jdk.test.lib.JDKToolFinder\n- *        jdk.test.lib.JDKToolLauncher\n- *        jdk.test.lib.Platform\n- *        jdk.test.lib.process.*\n- * @run main ExitOnThrow\n- * @summary Ensure that if a cleaner throws an exception then the VM exits\n- *\/\n-\n-import jdk.internal.ref.Cleaner;\n-\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class ExitOnThrow {\n-\n-    public static void main(String[] args) throws Exception {\n-        if (args.length == 0) {\n-            ProcessTools.executeTestJava(\"--add-exports\", \"java.base\/jdk.internal.ref=ALL-UNNAMED\",\n-                                         \"ExitOnThrow\",\n-                                         \"-executeCleaner\")\n-                        .outputTo(System.out)\n-                        .errorTo(System.out)\n-                        .shouldHaveExitValue(1)\n-                        .shouldContain(\"java.lang.RuntimeException: Foo!\");\n-        } else {\n-            Cleaner.create(new Object(),\n-                           () -> { throw new RuntimeException(\"Foo!\"); } );\n-            while (true) {\n-                System.gc();\n-                Thread.sleep(100);\n-            }\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/jdk\/internal\/ref\/Cleaner\/ExitOnThrow.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -26,5 +26,1 @@\n-import java.lang.annotation.Annotation;\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n+import java.io.IOException;\n@@ -32,0 +28,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -33,3 +31,1 @@\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n+import java.time.Instant;\n@@ -38,2 +34,0 @@\n-import java.util.concurrent.atomic.AtomicLong;\n-import java.util.concurrent.atomic.AtomicReference;\n@@ -41,6 +35,0 @@\n-import jdk.jfr.AnnotationElement;\n-import jdk.jfr.Event;\n-import jdk.jfr.EventType;\n-import jdk.jfr.MetadataDefinition;\n-import jdk.jfr.Name;\n-import jdk.jfr.Threshold;\n@@ -48,0 +36,1 @@\n+import jdk.jfr.Event;\n@@ -49,0 +38,1 @@\n+import jdk.jfr.SettingControl;\n@@ -50,1 +40,1 @@\n-import jdk.jfr.SettingDescriptor;\n+import jdk.jfr.Threshold;\n@@ -52,1 +42,0 @@\n-import jdk.jfr.ValueDescriptor;\n@@ -54,0 +43,1 @@\n+import jdk.jfr.consumer.RecordingFile;\n@@ -55,3 +45,0 @@\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.jfr.Events;\n-import jdk.jfr.SettingControl;\n@@ -68,0 +55,3 @@\n+    public static class UnthrottledEvent extends Event {\n+    }\n+\n@@ -133,0 +123,2 @@\n+    private static Instant startTime;\n+\n@@ -134,0 +126,2 @@\n+        startTime = determineMinimumTime();\n+        testUnthrottled(); \/\/ To ensure problem is specific to throttled events\n@@ -143,0 +137,14 @@\n+    private static void testUnthrottled() throws Exception {\n+        testEvent(UnthrottledEvent.class, true);\n+    }\n+\n+    private static Instant determineMinimumTime() throws IOException {\n+        try (Recording r = new Recording()) {\n+            r.enable(\"jdk.JVMInformation\");\n+            r.start();\n+            Path p = Path.of(\"start.jfr\");\n+            r.dump(p);\n+            return RecordingFile.readAllEvents(p).get(0).getStartTime();\n+        }\n+    }\n+\n@@ -223,2 +231,0 @@\n-\n-            r.stop();\n@@ -275,1 +281,5 @@\n-        for (RecordedEvent event : Events.fromRecording(r)) {\n+        r.stop();\n+        Duration d = Duration.between(r.getStartTime(), r.getStopTime());\n+        Path file = Path.of(\"dump.jfr\");\n+        r.dump(file);\n+        for (RecordedEvent event : RecordingFile.readAllEvents(file)) {\n@@ -279,0 +289,12 @@\n+            if (event.getDuration().isNegative()) {\n+                System.out.println(event);\n+                throw new Exception(\"Unexpected negative duration\");\n+            }\n+            if (event.getStartTime().isBefore(startTime)) {\n+                System.out.println(event);\n+                throw new Exception(\"Unexpected early start time\");\n+            }\n+            if (event.getDuration().toMillis() > 2 * d.toMillis()) {\n+                System.out.println(event);\n+                throw new Exception(\"Duration exceed twice the length of the recording\");\n+            }\n@@ -283,0 +305,1 @@\n+        Files.delete(file);\n","filename":"test\/jdk\/jdk\/jfr\/api\/metadata\/annotations\/TestThrottle.java","additions":47,"deletions":24,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8346884\n+ * @summary Test for `@since` in jdk.editpad module\n+ * @library \/test\/lib \/test\/jdk\/tools\/sincechecker\n+ * @run main SinceChecker jdk.editpad\n+ *\/\n","filename":"test\/jdk\/tools\/sincechecker\/modules\/jdk.editpad\/JdkEditpadCheckSince.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8177100\n+ * @summary Test to check for duplicate methods across different inheritance patterns\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestDuplicateMethods\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestDuplicateMethods extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestDuplicateMethods();\n+        tester.runTests();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+    Path src = Path.of(\"src\");\n+\n+\n+    TestDuplicateMethods() throws IOException {\n+        \/\/ Diamond class inheritance\n+        tb.writeJavaFiles(src, \"\"\"\n+                package p;\n+                interface A {\n+                    \/**\n+                     * JavaDoc for method in interface A.\n+                     *\/\n+                    abstract void testA( );\n+                }\"\"\", \"\"\"\n+                package p;\n+                interface B extends A {\n+                    \/**\n+                     * JavaDoc for method in interface B.\n+                     *\/\n+                    abstract void testB( );\n+                }\"\"\", \"\"\"\n+                package p;\n+                abstract class C implements A {\n+                    \/**\n+                     * Inherited JavaDoc for method in class C.\n+                     *\/\n+                    public final void testA( ) {\n+                        \/\/ Do nothing.\n+                    }\n+                }\"\"\",\"\"\"\n+                package p;\n+                public final class D extends C implements B {\n+                    \/**\n+                     * Inherited JavaDoc.\n+                     *\/\n+                    public final void testB() {\n+                        \/\/ Do nothing.\n+                    }\n+                }\n+                \"\"\");\n+\n+        \/\/ Mirrors the implementation of StringBuilder\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                package sb;\n+                public interface I {\n+                    \/**\n+                     * JavaDoc for method in public interface I.\n+                     *\/\n+                    void testI();\n+                }\n+                \"\"\", \"\"\"\n+                package sb;\n+                abstract class P implements I {\n+                    \/**\n+                     * Inherited JavaDoc for method in class P.\n+                     *\/\n+                    public final void testI() {\n+                        \/\/ Do nothing.\n+                    }\n+                }\n+                \"\"\", \"\"\"\n+                package sb;\n+                public class U extends P implements I {\n+                    \/\/ No overrides\n+                }\n+                \"\"\"\n+        );\n+\n+        \/\/ Mirrors the implementation of HashMap\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                package hm;\n+                public interface J {\n+                    \/**\n+                     * JavaDoc for method in public interface J.\n+                     *\/\n+                    void testJ();\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package hm;\n+                public abstract class PubJ implements J {\n+                    \/**\n+                     * Inherited JavaDoc for method in public abstract class PubJ.\n+                     *\/\n+                    public final void testJ() {\n+                        \/\/ Do nothing.\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package hm;\n+                public class V extends PubJ implements J {\n+                    \/\/ No override\n+                }\n+                \"\"\"\n+        );\n+    }\n+\n+    @Test\n+    public void testDiamondInheritance(Path base) {\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"p\/D.html\", true,\n+                \"\"\"\n+                <div class=\"block\">Inherited JavaDoc for method in class C.<\/div>\n+                \"\"\", \"\"\"\n+                <div class=\"member-signature\"><span class=\"modifiers\">public final<\/span>&nbsp;<span class=\"return-type\">void<\/span>&nbsp;<span class=\"element-name\">testA<\/span>()<\/div>\n+                <div class=\"block\">Inherited JavaDoc for method in class C.<\/div>\n+                \"\"\"\n+        );\n+\n+        checkOutput(\"p\/D.html\", false, \"\"\"\n+                <div class=\"block\">JavaDoc for method in Interface A.<\/div>\"\"\", \"\"\"\n+                <div class=\"member-signature\"><span class=\"return-type\">void<\/span>&nbsp;<span class=\"element-name\">testA<\/span>()<\/div>\n+                <div class=\"block\">JavaDoc for method in Interface A.<\/div>\"\"\");\n+\n+\n+        checkOutput(\"p\/D.html\", false,\n+                \"\"\"\n+                <div class=\"block\">JavaDoc for method in interface A.<\/div>\n+                \"\"\");\n+    }\n+\n+    @Test\n+    public void testStringBuilderInheritance(Path base) {\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"sb\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"sb\/U.html\", false,\n+                \"\"\"\n+                <div class=\"inherited-list\">\n+                <h3 id=\"methods-inherited-from-class-sb.I\">Methods inherited from interface&nbsp;<a href=\"I.html#method-summary\" title=\"interface in sb\">I<\/a><\/h3>\n+                <code><a href=\"I.html#testI()\" title=\"testI()\">testI<\/a><\/code><\/div>\n+                \"\"\");\n+\n+        checkOutput(\"sb\/U.html\", true,\n+                \"\"\"\n+                <h3>testI<\/h3>\n+                <div class=\"horizontal-scroll\">\n+                <div class=\"member-signature\"><span class=\"modifiers\">public final<\/span>&nbsp;<span class=\"return-type\">void<\/span>&nbsp;<span class=\"element-name\">testI<\/span>()<\/div>\n+                <div class=\"block\">Inherited JavaDoc for method in class P.<\/div>\n+                <dl class=\"notes\">\n+                <dt>Specified by:<\/dt>\n+                <dd><code><a href=\"I.html#testI()\">testI<\/a><\/code>&nbsp;in interface&nbsp;<code><a href=\"I.html\" title=\"interface in sb\">I<\/a><\/code><\/dd>\n+                <\/dl>\"\"\");\n+    }\n+\n+    @Test\n+    public void testHashMapInheritance(Path base) {\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"hm\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"hm\/V.html\", false,\n+                \"\"\"\n+                <div class=\"inherited-list\">\n+                <h3 id=\"methods-inherited-from-class-hm.J\">Methods inherited from interface&nbsp;<a href=\"J.html#method-summary\" title=\"interface in hm\">J<\/a><\/h3>\n+                <code><a href=\"J.html#testJ()\" title=\"testJ()\">testJ<\/a><\/code><\/div>\"\"\");\n+\n+        checkOutput(\"hm\/V.html\", true,\n+                \"\"\"\n+                <div class=\"inherited-list\">\n+                <h3 id=\"methods-inherited-from-class-hm.PubJ\">Methods inherited from class&nbsp;<a href=\"PubJ.html#method-summary\" title=\"class in hm\">PubJ<\/a><\/h3>\n+                <code><a href=\"PubJ.html#testJ()\" title=\"testJ()\">testJ<\/a><\/code><\/div>\n+                \"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDuplicateMethodsWarn\/TestDuplicateMethods.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8356165\n+ * @bug 8356165 8358552\n@@ -41,0 +41,1 @@\n+import java.util.Map;\n@@ -70,0 +71,17 @@\n+    public void testCloseInputSinkWhileReadingUserInputSimulatingCtrlD() throws Exception {\n+        var snippets = Map.of(\n+                \"System.in.read()\",                 \" ==> -1\",\n+                \"System.console().reader().read()\", \" ==> -1\",\n+                \"System.console().readLine()\",      \" ==> null\",\n+                \"System.console().readPassword()\",  \" ==> null\",\n+                \"IO.readln()\",                      \" ==> null\",\n+                \"System.in.readAllBytes()\",         \" ==> byte[0] {  }\"\n+            );\n+        for (var snippet : snippets.entrySet()) {\n+            doRunTest((inputSink, out) -> {\n+                inputSink.write(snippet.getKey() + \"\\n\");\n+                inputSink.close(); \/\/ Does not work: inputSink.write(\"\\u0004\"); \/\/ CTRL + D\n+                waitOutput(out, patternQuote(snippet.getValue()), patternQuote(\"EndOfFileException\"));\n+            }, false);\n+        }\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/InputUITest.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+            boolean closed = false;\n@@ -111,0 +112,1 @@\n+                if (closed) return; \/\/ prevents exception thrown due to closed writer\n@@ -114,0 +116,6 @@\n+\n+            @Override\n+            public void close() throws IOException {\n+                super.close();\n+                closed = true;\n+            }\n","filename":"test\/langtools\/jdk\/jshell\/UITesting.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\n+\/*\n+ * @test\n+ * @bug 8361481\n+ * @modules jdk.compiler\n+ * @summary Flexible Constructor Bodies generates a compilation error when compiling a user supplied java.lang.Object class\n+ *\/\n+\n+import java.io.*;\n+import java.util.*;\n+\n+public class T8361481 {\n+    static String testSrc = System.getProperty(\"test.src\", \".\");\n+\n+    public static void main(String... args) throws Exception {\n+        new T8361481().run();\n+    }\n+\n+    public void run() throws Exception {\n+        \/\/ compile modified Object.java, using patch-module to avoid errors\n+        File x = new File(testSrc, \"x\");\n+        String[] jcArgs = { \"-d\", \".\", \"--patch-module\", \"java.base=\" + x.getAbsolutePath(),\n+                new File(new File(new File(x, \"java\"), \"lang\"), \"Object.java\").getPath()};\n+        compile(jcArgs);\n+    }\n+\n+    void compile(String... args) {\n+        int rc = com.sun.tools.javac.Main.compile(args);\n+        if (rc != 0)\n+            throw new Error(\"javac failed: \" + Arrays.asList(args) + \": \" + rc);\n+    }\n+}\n+\n","filename":"test\/langtools\/tools\/javac\/ObjectEarlyContext\/T8361481.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+public class Object {\n+    public Object() {\n+        foo(); \/\/ valid, not in early constructor context\n+    }\n+\n+    void foo() { }\n+}\n","filename":"test\/langtools\/tools\/javac\/ObjectEarlyContext\/x\/java\/lang\/Object.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8361570\n+ * @summary Verify no flags in ExtendedStandardFlags have overlays for different\n+ *          Symbol kinds.\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.code\n+ * @compile ExtendedStandardFlagsOverlayFlagsConflict.java\n+ * @run main ExtendedStandardFlagsOverlayFlagsConflict\n+ *\/\n+\n+import com.sun.tools.javac.code.Flags;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/* Flags in ExtendedStandardFlags are checked using masks, and if they have\n+ * Symbol-kind specific meaning, they can lead to confusing errors. Hence,\n+ * Flags in ExtendedStandardFlags should have the same meaning for all Symbols.\n+ *\/\n+public class ExtendedStandardFlagsOverlayFlagsConflict {\n+\n+    public static void main(String... args) throws Exception {\n+        ExtendedStandardFlagsOverlayFlagsConflict t =\n+                new ExtendedStandardFlagsOverlayFlagsConflict();\n+        t.run();\n+    }\n+\n+    public void run() throws Exception {\n+        Map<Long, List<Field>> value2FlagFields = new HashMap<>();\n+\n+        for (Field f : Flags.class.getFields()) {\n+            if (!Modifier.isStatic(f.getModifiers())) {\n+                continue;\n+            }\n+            if (f.getName().startsWith(\"ACC_\")) {\n+                continue;\n+            }\n+            long flag = ((Number) f.get(null)).longValue();\n+            value2FlagFields.computeIfAbsent(flag, _ -> new ArrayList<>())\n+                            .add(f);\n+        }\n+\n+        long pendingFlags2Check = Flags.ExtendedStandardFlags;\n+\n+        while (pendingFlags2Check != 0) {\n+            long flag = Long.highestOneBit(pendingFlags2Check);\n+            List<Field> flagFields = value2FlagFields.get(flag);\n+            if (flagFields.size() != 1) {\n+                throw new AssertionError(\"Flag: \" + flag +\n+                                         \" has more than one flag field: \" + flagFields);\n+            }\n+            pendingFlags2Check &= ~flag;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/flags\/ExtendedStandardFlagsOverlayFlagsConflict.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,21 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8361570\n+ * @summary Verify there's no fake sealed not allowed here error when sealed\n+ *          and requires-identity Flags clash\n+ * @modules java.base\/jdk.internal\n+ * @compile NoFalseSealedError.java\n+ *\/\n+\n+import java.lang.ref.WeakReference;\n+import java.util.WeakHashMap;\n+\n+void main(String[] args) {\n+    new RequiresIdentity(null) {};\n+    new WeakReference<>(null) {};\n+    new WeakHashMap<>() {};\n+}\n+\n+static class RequiresIdentity {\n+    RequiresIdentity(@jdk.internal.RequiresIdentity Object o) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/flags\/NoFalseSealedError.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8361214\n+ * @summary An anonymous class is erroneously being classify as an abstract class\n+ * @compile AnonymousLabeledAsAbstractTest.java\n+ *\/\n+\n+class AnonymousLabeledAsAbstractTest {\n+    abstract class Base<T> {}\n+    abstract class Derived1<T> extends Base<T> {}\n+    abstract class Derived2<T> extends Base<T> {\n+        Derived2(Derived1<T> obj){}\n+    }\n+    abstract class Derived3<T> extends Base<T> {\n+        Derived3(Derived2<T> obj){}\n+    }\n+\n+    Base<String> obj = new Derived2<>(new Derived1<>(){}){};\n+    Base<String> obj2 = new Derived3<String>(new Derived2<>(new Derived1<>(){}){}){};\n+    Base<String> obj3 = new Derived3<>(new Derived2<>(new Derived1<>(){}){}){};\n+}\n","filename":"test\/langtools\/tools\/javac\/generics\/diamond\/AnonymousLabeledAsAbstractTest.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @clean ClassRefDupInConstantPoolTest$Duplicates\n+ * @clean ClassRefDupInConstantPoolTest ClassRefDupInConstantPoolTest$Duplicates\n","filename":"test\/langtools\/tools\/javac\/jvm\/ClassRefDupInConstantPoolTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.instruction.LoadInstruction;\n+import java.lang.classfile.instruction.StoreInstruction;\n+import java.util.BitSet;\n+import java.util.Map;\n+\n+import jdk.test.lib.compiler.InMemoryJavaCompiler;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/*\n+ * @test\n+ * @bug 8357185\n+ * @enablePreview\n+ * @summary No unused local variable in unconditionally exact primitive patterns\n+ * @library \/test\/lib\n+ * @run junit PrimitiveInstanceOfBytecodeTest\n+ *\/\n+public class PrimitiveInstanceOfBytecodeTest {\n+\n+    private static final String SOURCE = \"\"\"\n+            public class Test {\n+                public record A(int i) {}\n+                public Integer get(A a) {\n+                    if (a instanceof A(int i)) {\n+                        return i;\n+                    }\n+                    return null;\n+                }\n+            }\n+            \"\"\";\n+\n+    @Test\n+    public void testNoUnusedVarInRecordPattern() {\n+        var testBytes = InMemoryJavaCompiler.compile(Map.of(\"Test\", SOURCE)).get(\"Test\");\n+        var code = ClassFile.of().parse(testBytes).methods().stream()\n+                .filter(m -> m.methodName().equalsString(\"get\")).findFirst()\n+                .orElseThrow().findAttribute(Attributes.code()).orElseThrow();\n+        BitSet stores = new BitSet(code.maxLocals());\n+        BitSet loads = new BitSet(code.maxLocals());\n+        code.forEach(ce -> {\n+            switch (ce) {\n+                case StoreInstruction store -> stores.set(store.slot());\n+                case LoadInstruction load -> loads.set(load.slot());\n+                default -> {}\n+            }\n+        });\n+        \/\/ [this, a] are built-in locals that may be unused\n+        loads.clear(0, 2);\n+        stores.clear(0, 2);\n+        if (!loads.equals(stores)) {\n+            System.err.println(\"Loads: \" + loads);\n+            System.err.println(\"Stores: \" + stores);\n+            System.err.println(code.toDebugString());\n+            fail(\"Store and load mismatch, see stderr\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfBytecodeTest.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8304487 8325257 8327683 8330387\n+ * @bug 8304487 8325257 8327683 8330387 8357185\n@@ -55,0 +55,1 @@\n+        assertEquals(true,  exprMethodSideEffect());\n@@ -176,0 +177,7 @@\n+    static int sideEffect;\n+    public static Integer methSideEffect() { sideEffect++; return 42;}\n+    public static boolean exprMethodSideEffect() {\n+        sideEffect = 5;\n+        return methSideEffect() instanceof int ii && sideEffect == 6;\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfPatternOpWithTopLevelPatterns.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8304487 8325257 8327683 8330387\n+ * @bug 8304487 8325257 8327683 8330387 8357185\n@@ -55,0 +55,1 @@\n+        assertEquals(true,  exprMethodSideEffect());\n@@ -176,0 +177,7 @@\n+    static int sideEffect;\n+    public static Integer methSideEffect() { sideEffect++; return 42;}\n+    public static boolean exprMethodSideEffect() {\n+        sideEffect = 5;\n+        return methSideEffect() instanceof int && sideEffect == 6;\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfTypeComparisonOp.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-                \"  public V put(@jdk.internal.RequiresIdentity sealed K key,\"\n+                \"  public V put(@jdk.internal.RequiresIdentity K key,\"\n@@ -157,1 +157,1 @@\n-                \"  public V put(sealed K arg0,\"\n+                \"  public V put(K arg0,\"\n","filename":"test\/langtools\/tools\/javac\/platform\/RequiresIdentityTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8270139\n+ * @bug 8270139 8361445\n@@ -36,0 +36,1 @@\n+import java.util.HashSet;\n@@ -38,0 +39,1 @@\n+import java.util.Set;\n@@ -113,0 +115,112 @@\n+    @Test \/\/JDK-8361445\n+    public void testSuppressWarningsErroneousAttribute1() throws Exception {\n+        String code = \"\"\"\n+                      @SuppressWarnings(CONST)\n+                      public class Test {\n+                          public static final String CONST = \"\";\n+                      }\n+                      \"\"\";\n+        Path curPath = Path.of(\".\");\n+        List<String> actual = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\", \"-XDdev\")\n+                .sources(code)\n+                .outdir(curPath)\n+                .run(Expect.FAIL)\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+        List<String> expected = List.of(\n+                \"Test.java:1:19: compiler.err.cant.resolve: kindname.variable, CONST, , \",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(actual, expected)) {\n+            error(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n+    @Test \/\/JDK-8361445\n+    public void testSuppressWarningsErroneousAttribute2() throws Exception {\n+        String code = \"\"\"\n+                      @SuppressWarnings(0)\n+                      public class Test {\n+                      }\n+                      \"\"\";\n+        Path curPath = Path.of(\".\");\n+        List<String> actual = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\", \"-XDdev\")\n+                .sources(code)\n+                .outdir(curPath)\n+                .run(Expect.FAIL)\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+        List<String> expected = List.of(\n+                \"Test.java:1:19: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.String)\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(actual, expected)) {\n+            error(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n+    @Test \/\/JDK-8361445\n+    public void testSuppressWarningsErroneousAttribute3() throws Exception {\n+        String[] attributeValues = {\n+            \"Test.BOOLEAN\",\n+            \"Test.BYTE\",\n+            \"Test.SHORT\",\n+            \"Test.INT\",\n+            \"Test.LONG\",\n+            \"Test.FLOAT\",\n+            \"Test.DOUBLE\",\n+            \"Test.CHAR\",\n+            \"Test.class\",\n+            \"@Deprecated\",\n+            \"E.A\",\n+        };\n+        Set<String> variants = new HashSet<>();\n+\n+        for (String attributeValue : attributeValues) {\n+            variants.add(attributeValue);\n+            variants.add(\"{\" + attributeValue + \"}\");\n+        }\n+\n+        for (String attributeValue1 : attributeValues) {\n+            for (String attributeValue2 : attributeValues) {\n+                variants.add(\"{\" + attributeValue1 + \", \" + attributeValue2 + \"}\");\n+            }\n+        }\n+\n+        String code = \"\"\"\n+                      @SuppressWarnings($ATTRIBUTE_VALUE)\n+                      public class Test {\n+                          public static final boolean BOOLEAN = false;\n+                          public static final byte BYTE = 0;\n+                          public static final short SHORT = 0;\n+                          public static final int INT = 0;\n+                          public static final long LONG = 0l;\n+                          public static final float FLOAT = 0.0;\n+                          public static final double DOUBLE = 0.0;\n+                          public static final char CHAR = '\\0';\n+                      }\n+                      enum E {\n+                          A\n+                      }\n+                      \"\"\";\n+\n+        for (String variant : variants) {\n+            System.out.println(\"current variant: \" + variant);\n+            Path curPath = Path.of(\".\");\n+            List<String> actual = new JavacTask(tb)\n+                    .options(\"-XDrawDiagnostics\", \"-XDdev\")\n+                    .sources(code.replace(\"$ATTRIBUTE_VALUE\", variant))\n+                    .outdir(curPath)\n+                    .run(Expect.FAIL)\n+                    .getOutputLines(OutputKind.DIRECT);\n+\n+            if (actual.isEmpty() || !actual.get(actual.size() - 1).contains(\"error\")) {\n+                error(\"Incorrect actual errors: \" + actual + \" for variant: \" + variant);\n+            }\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/recovery\/AnnotationRecovery.java","additions":116,"deletions":2,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.jittester;\n+\n+import java.lang.reflect.Executable;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @summary Unit tests for JITTester string method templates\n+ *\n+ * @library \/test\/lib\n+ *          \/test\/hotspot\/jtreg\/testlibrary\/jittester\/src\n+ *\n+ * @run testng jdk.test.lib.jittester.MethodTemplateTest\n+ *\/\n+public class MethodTemplateTest {\n+\n+    @Test\n+    public void testMatchingPatterns() throws NoSuchMethodException {\n+        Tester.forMethod(System.class, \"getenv\", String.class)\n+            .assertMatches(\"java\/lang\/System::getenv(Ljava\/lang\/String;)\")\n+            .assertMatches(\"*::getenv(Ljava\/lang\/String;)\")\n+            .assertMatches(\"java\/lang\/*::getenv(Ljava\/lang\/String;)\")\n+            .assertMatches(\"java\/lang\/System::*env*(Ljava\/lang\/String;)\")\n+            .assertMatches(\"java\/lang\/System::getenv\")\n+            .assertMatches(\"java\/lang\/System::getenv(*)\");\n+\n+        Tester.forCtor(RuntimeException.class, Throwable.class)\n+            .assertMatches(\"java\/lang\/RuntimeException::RuntimeException(Ljava\/lang\/Throwable;)\");\n+\n+        Tester.forMethod(String.class, \"regionMatches\", int.class, String.class, int.class, int.class)\n+            .assertMatches(\"java\/lang\/String::regionMatches(ILjava\/lang\/String;II)\");\n+    }\n+\n+    @Test\n+    public void testNonMatchingPatterns() throws NoSuchMethodException {\n+        Tester.forMethod(String.class, \"regionMatches\", int.class, String.class, int.class, int.class)\n+            .assertDoesNotMatch(\"java\/lang\/String::regionMatches(IIILjava\/lang\/String;)\");\n+\n+        Tester.forMethod(String.class, \"endsWith\", String.class)\n+              .assertDoesNotMatch(\"java\/lang\/String::startsWith(Ljava\/lang\/String;)\");\n+    }\n+\n+    @Test\n+    public void testWildcardStrings() {\n+        assertTrue(new MethodTemplate.WildcardString(\"Torment\")\n+                .matches(\"Torment\"));\n+\n+        assertTrue(new MethodTemplate.WildcardString(\"Torm*\")\n+                .matches(\"Torment\"));\n+\n+        assertTrue(new MethodTemplate.WildcardString(\"*ent\")\n+                .matches(\"Torment\"));\n+\n+        assertTrue(new MethodTemplate.WildcardString(\"*\")\n+                .matches(\"Something\"));\n+\n+        assertTrue(new MethodTemplate.WildcardString(\"**\")\n+                .matches(\"Something\"));\n+\n+        assertTrue(new MethodTemplate.WildcardString(\"*Middle*\")\n+                .matches(\"OnlyMiddleMatches\"));\n+\n+        assertFalse(new MethodTemplate.WildcardString(\"Wrong\")\n+                .matches(\"Correct\"));\n+        assertFalse(new MethodTemplate.WildcardString(\"Joy\")\n+                .matches(\"Joyfull\"));\n+        assertFalse(new MethodTemplate.WildcardString(\"*Torm*\")\n+                .matches(\"Sorrow\"));\n+    }\n+\n+    static final class Tester {\n+        private final Executable executable;\n+\n+        private Tester(Executable executable) {\n+            this.executable = executable;\n+        }\n+\n+        public Tester assertMatches(String stringTemplate) {\n+            MethodTemplate template = MethodTemplate.parse(stringTemplate);\n+            assertTrue(template.matches(executable),\n+                    \"Method '\" + executable + \"' does not match template '\" + stringTemplate + \"'\");\n+            return this;\n+        }\n+\n+        public Tester assertDoesNotMatch(String stringTemplate) {\n+            MethodTemplate template = MethodTemplate.parse(stringTemplate);\n+            assertFalse(template.matches(executable),\n+                    \"Method '\" + executable + \"' erroneously matches template '\" + stringTemplate + \"'\");\n+            return this;\n+        }\n+\n+        public static Tester forMethod(Class klass, String name, Class<?>... arguments)\n+                throws  NoSuchMethodException {\n+            return new Tester(klass.getDeclaredMethod(name, arguments));\n+        }\n+\n+        public static Tester forCtor(Class klass, Class<?>... arguments)\n+                throws  NoSuchMethodException {\n+                return new Tester(klass.getConstructor(arguments));\n+        }\n+    }\n+\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/jittester\/MethodTemplateTest.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -125,2 +125,2 @@\n-                    \"JVM process should have exit value '%d'.%n%s\",\n-                    exitCode.value, exitErrorMessage);\n+                    \"JVM process should have exit value '%d', but has '%d'.%n%s\",\n+                    exitCode.value, outputAnalyzer.getExitValue(), exitErrorMessage);\n@@ -305,0 +305,3 @@\n+            String observedValue = outputAnalyzer.firstMatch(String.format(\n+                CommandLineOptionTest.PRINT_FLAGS_FINAL_FORMAT,\n+                optionName, \"\\\\S\"));\n@@ -306,2 +309,2 @@\n-                    \"Option '%s' is expected to have '%s' value%n%s\",\n-                    optionName, expectedValue,\n+                    \"Option '%s' is expected to have '%s' value, but is '%s'.%n%s\",\n+                    optionName, expectedValue, observedValue,\n","filename":"test\/lib\/jdk\/test\/lib\/cli\/CommandLineOptionTest.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.io;\n+\n+import java.io.CharArrayReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.List;\n+import java.util.Random;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+\n+@State(Scope.Benchmark)\n+public class ReaderReadAllLines {\n+\n+    private char[] chars = null;\n+\n+    @Setup\n+    public void setup() throws IOException {\n+        final int len = 128_000;\n+        chars = new char[len];\n+        Random rnd = new Random(System.nanoTime());\n+        int off = 0;\n+        while (off < len) {\n+            int lineLen = 40 + rnd.nextInt(8192);\n+            if (lineLen > len - off) {\n+                off = len;\n+            } else {\n+                chars[off + lineLen] = '\\n';\n+                off += lineLen;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public List<String> readAllLines() throws IOException {\n+        List<String> lines;\n+        try (Reader reader = new CharArrayReader(chars)) {\n+            lines = reader.readAllLines();\n+        }\n+        return lines;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/io\/ReaderReadAllLines.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -83,0 +83,10 @@\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int thousandUnboundQueries(Blackhole bh) throws Exception {\n+        var result = 0;\n+        for (int i = 0; i < 1_000; i++) {\n+            result += ScopedValuesData.unbound.isBound() ? 1 : 0;\n+        }\n+        return result;\n+    }\n+\n@@ -216,0 +226,7 @@\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public Object newInstance() {\n+        ScopedValue<Integer> val = ScopedValue.newInstance();\n+        return val;\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ScopedValues.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-            tl1.get();  \/\/ Create the ScopedValue cache as a side effect\n@@ -64,1 +63,4 @@\n-                  .run(action);\n+                  .run(() -> {\n+                      sl1.get();  \/\/ Create the ScopedValue cache as a side effect\n+                      action.run();\n+                  });\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ScopedValuesData.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.nio;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3, jvmArgs = {\"-Xmx256m\", \"-Xms256m\", \"-XX:+AlwaysPreTouch\"})\n+public class DirectByteBufferChurn {\n+\n+    @Param({\"128\", \"256\", \"512\", \"1024\", \"2048\"})\n+    int recipFreq;\n+\n+    @Benchmark\n+    public Object test() {\n+        boolean direct = ThreadLocalRandom.current().nextInt(recipFreq) == 0;\n+        return direct ? ByteBuffer.allocateDirect(1) : ByteBuffer.allocate(1);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/DirectByteBufferChurn.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.nio;\n+\n+import java.nio.ByteBuffer;\n+import java.util.LinkedList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3, jvmArgs = {\"-Xmx1g\", \"-Xms1g\", \"-XX:+AlwaysPreTouch\"})\n+public class DirectByteBufferGC {\n+\n+    @Param({\"16384\", \"65536\", \"262144\", \"1048576\", \"4194304\"})\n+    int count;\n+\n+    \/\/ Make sure all buffers are reachable and available for GC. Buffers\n+    \/\/ directly reference their Cleanables, so we do not want to provide\n+    \/\/ excess GC parallelism opportunities here, this is why reference\n+    \/\/ buffers from a linked list.\n+    \/\/\n+    \/\/ This exposes the potential GC parallelism problem in Cleaner lists.\n+    LinkedList<ByteBuffer> buffers;\n+\n+    @Setup\n+    public void setup() {\n+        buffers = new LinkedList<>();\n+        for (int c = 0; c < count; c++) {\n+            buffers.add(ByteBuffer.allocateDirect(1));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void test() {\n+        System.gc();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/DirectByteBufferGC.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -39,0 +41,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -52,0 +56,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/AllDead.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -39,0 +41,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -52,0 +56,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/AllLive.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -38,0 +40,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -52,0 +56,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/DifferentObjectSizesArray.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -39,0 +41,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -53,0 +57,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/DifferentObjectSizesHashMap.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -39,0 +41,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -52,0 +56,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/DifferentObjectSizesTreeMap.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -39,0 +41,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -53,0 +57,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/HalfDeadFirstPart.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -39,0 +41,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -53,0 +57,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/HalfDeadInterleaved.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -39,0 +41,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -53,0 +57,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/HalfDeadInterleavedChunks.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -39,0 +41,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -53,0 +57,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/HalfDeadSecondPart.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -39,0 +41,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -53,0 +57,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/HalfHashedHalfDead.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import org.openjdk.jmh.annotations.Level;\n@@ -29,0 +30,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -30,0 +32,4 @@\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -34,0 +40,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -36,0 +44,1 @@\n+@State(Scope.Benchmark)\n@@ -46,0 +55,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/NoObjects.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -38,0 +40,2 @@\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n@@ -52,0 +56,6 @@\n+    @Setup(Level.Trial)\n+    public void preRun() {\n+        \/\/ Compact right now, kicking out all unrelated objects\n+        System.gc();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/systemgc\/OneBigObject.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}