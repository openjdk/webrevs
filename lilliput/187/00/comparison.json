{"files":[{"patch":"@@ -74,1 +74,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -578,1 +578,22 @@\n-bool LightweightSynchronizer::fast_lock_spin_enter(oop obj, JavaThread* current, bool observed_deflation) {\n+inline bool LightweightSynchronizer::check_unlocked(oop obj, LockStack& lock_stack, JavaThread* current) {\n+  markWord mark = obj->mark();\n+  while (mark.is_unlocked()) {\n+    ensure_lock_stack_space(current);\n+    assert(!lock_stack.is_full(), \"must have made room on the lock stack\");\n+    assert(!lock_stack.contains(obj), \"thread must not already hold the lock\");\n+    \/\/ Try to swing into 'fast-locked' state.\n+    markWord locked_mark = mark.set_fast_locked();\n+    markWord old_mark = mark;\n+    mark = obj->cas_set_mark(locked_mark, old_mark);\n+    if (old_mark == mark) {\n+      \/\/ Successfully fast-locked, push object to lock-stack and return.\n+      lock_stack.push(obj);\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+\n+bool LightweightSynchronizer::fast_lock_spin_enter(oop obj, LockStack& lock_stack, JavaThread* current, bool observed_deflation) {\n+  assert(UseObjectMonitorTable, \"must be\");\n@@ -580,1 +601,1 @@\n-  const int log_spin_limit = os::is_MP() || !UseObjectMonitorTable ? LightweightFastLockingSpins : 1;\n+  const int log_spin_limit = os::is_MP() ? LightweightFastLockingSpins : 1;\n@@ -583,2 +604,0 @@\n-  LockStack& lock_stack = current->lock_stack();\n-\n@@ -616,15 +635,1 @@\n-    mark = obj->mark();\n-    while (mark.is_unlocked()) {\n-      ensure_lock_stack_space(current);\n-      assert(!lock_stack.is_full(), \"must have made room on the lock stack\");\n-      assert(!lock_stack.contains(obj), \"thread must not already hold the lock\");\n-      \/\/ Try to swing into 'fast-locked' state.\n-      markWord locked_mark = mark.set_fast_locked();\n-      markWord old_mark = mark;\n-      mark = obj->cas_set_mark(locked_mark, old_mark);\n-      if (old_mark == mark) {\n-        \/\/ Successfully fast-locked, push object to lock-stack and return.\n-        lock_stack.push(obj);\n-        return true;\n-      }\n-    }\n+    if (check_unlocked(obj, lock_stack, current)) return true;\n@@ -703,1 +708,3 @@\n-    if (fast_lock_spin_enter(obj(), current, observed_deflation)) {\n+    if (check_unlocked(obj(), lock_stack, current)) {\n+      return;\n+    } else if (UseObjectMonitorTable && fast_lock_spin_enter(obj(), lock_stack, current, observed_deflation)) {\n@@ -1182,0 +1189,4 @@\n+  const markWord mark = obj->mark();\n+\n+#ifndef _LP64\n+  \/\/ Only for 32bit which have limited support for fast locking outside the runtime.\n@@ -1189,2 +1200,0 @@\n-  const markWord mark = obj->mark();\n-\n@@ -1200,0 +1209,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":32,"deletions":22,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -60,1 +60,2 @@\n-  static bool fast_lock_spin_enter(oop obj, JavaThread* current, bool observed_deflation);\n+  static inline bool check_unlocked(oop obj, LockStack& lock_stack, JavaThread* current);\n+  static bool fast_lock_spin_enter(oop obj, LockStack& lock_stack, JavaThread* current, bool observed_deflation);\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/lockStack.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -385,5 +385,7 @@\n-  void* cur = try_set_owner_from(nullptr, current);\n-  if (cur == nullptr) {\n-    assert(_recursions == 0, \"invariant\");\n-    return true;\n-  }\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    \/\/ TryLock avoids the CAS\n+    TryLockResult r = TryLock(current);\n+    if (r == TryLockResult::Success) {\n+      assert(_recursions == 0, \"invariant\");\n+      return true;\n+    }\n@@ -391,4 +393,5 @@\n-  if (cur == current) {\n-    _recursions++;\n-    return true;\n-  }\n+    if (r == TryLockResult::HasOwner && owner() == current) {\n+      _recursions++;\n+      return true;\n+    }\n+    return false;\n@@ -396,5 +399,18 @@\n-  if (LockingMode != LM_LIGHTWEIGHT && current->is_lock_owned((address)cur)) {\n-    assert(_recursions == 0, \"internal state error\");\n-    _recursions = 1;\n-    set_owner_from_BasicLock(cur, current);  \/\/ Convert from BasicLock* to Thread*.\n-    return true;\n+  } else {\n+    void* cur = try_set_owner_from(nullptr, current);\n+    if (cur == nullptr) {\n+      assert(_recursions == 0, \"invariant\");\n+      return true;\n+    }\n+\n+    if (cur == current) {\n+      _recursions++;\n+      return true;\n+    }\n+\n+    if (LockingMode == LM_LEGACY && current->is_lock_owned((address)cur)) {\n+      assert(_recursions == 0, \"internal state error\");\n+      _recursions = 1;\n+      set_owner_from_BasicLock(cur, current);  \/\/ Convert from BasicLock* to Thread*.\n+      return true;\n+    }\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":30,"deletions":14,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -403,1 +403,1 @@\n-bool ObjectSynchronizer::quick_enter(oop obj, JavaThread* current,\n+bool ObjectSynchronizer::quick_enter_legacy(oop obj, JavaThread* current,\n@@ -406,6 +406,0 @@\n-  NoSafepointVerifier nsv;\n-  if (obj == nullptr) return false;       \/\/ Need to throw NPE\n-\n-  if (obj->klass()->is_value_based()) {\n-    return false;\n-  }\n@@ -553,7 +547,1 @@\n-void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n-  assert(current == Thread::current(), \"must be\");\n-\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    return LightweightSynchronizer::enter(obj, lock, current);\n-  }\n-\n+void ObjectSynchronizer::enter_legacy(Handle obj, BasicLock* lock, JavaThread* current) {\n@@ -621,6 +609,2 @@\n-void ObjectSynchronizer::exit(oop object, BasicLock* lock, JavaThread* current) {\n-  current->dec_held_monitor_count();\n-\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    return LightweightSynchronizer::exit(object, current);\n-  }\n+void ObjectSynchronizer::exit_legacy(oop object, BasicLock* lock, JavaThread* current) {\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"Use LightweightSynchronizer\");\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":4,"deletions":20,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -96,2 +96,3 @@\n-  static void enter(Handle obj, BasicLock* lock, JavaThread* current);\n-  static void exit(oop obj, BasicLock* lock, JavaThread* current);\n+  static inline void enter(Handle obj, BasicLock* lock, JavaThread* current);\n+  static inline void exit(oop obj, BasicLock* lock, JavaThread* current);\n+\n@@ -109,0 +110,3 @@\n+  static bool quick_enter_legacy(oop obj, JavaThread* current, BasicLock* Lock);\n+  static void enter_legacy(Handle obj, BasicLock* Lock, JavaThread* current);\n+  static void exit_legacy(oop obj, BasicLock* lock, JavaThread* current);\n@@ -121,1 +125,1 @@\n-  static bool quick_enter(oop obj, JavaThread* current, BasicLock* Lock);\n+  static inline bool quick_enter(oop obj, JavaThread* current, BasicLock* Lock);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/safepointVerifiers.hpp\"\n@@ -40,0 +41,38 @@\n+\n+void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n+  assert(current == Thread::current(), \"must be\");\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    LightweightSynchronizer::enter(obj, lock, current);\n+  } else {\n+    enter_legacy(obj, lock, current);\n+  }\n+}\n+\n+bool ObjectSynchronizer::quick_enter(oop obj, JavaThread* current,\n+                                     BasicLock * lock) {\n+  assert(current->thread_state() == _thread_in_Java, \"invariant\");\n+  NoSafepointVerifier nsv;\n+  if (obj == nullptr) return false;       \/\/ Need to throw NPE\n+\n+  if (obj->klass()->is_value_based()) {\n+    return false;\n+  }\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    return LightweightSynchronizer::quick_enter(obj, current, lock);\n+  } else {\n+    return quick_enter_legacy(obj, current, lock);\n+  }\n+}\n+\n+void ObjectSynchronizer::exit(oop object, BasicLock* lock, JavaThread* current) {\n+  current->dec_held_monitor_count();\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    LightweightSynchronizer::exit(object, current);\n+  } else {\n+    exit_legacy(object, lock, current);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.inline.hpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"}]}