{"files":[{"patch":"@@ -1745,1 +1745,1 @@\n-  if (C->stub_function() == nullptr && BarrierSet::barrier_set()->barrier_set_nmethod() != nullptr) {\n+  if (C->stub_function() == nullptr) {\n@@ -1795,18 +1795,14 @@\n-    if (BarrierSet::barrier_set()->barrier_set_nmethod() != nullptr) {\n-      \/\/ Dummy labels for just measuring the code size\n-      Label dummy_slow_path;\n-      Label dummy_continuation;\n-      Label dummy_guard;\n-      Label* slow_path = &dummy_slow_path;\n-      Label* continuation = &dummy_continuation;\n-      Label* guard = &dummy_guard;\n-      if (!Compile::current()->output()->in_scratch_emit_size()) {\n-        \/\/ Use real labels from actual stub when not emitting code for the purpose of measuring its size\n-        C2EntryBarrierStub* stub = new (Compile::current()->comp_arena()) C2EntryBarrierStub();\n-        Compile::current()->output()->add_stub(stub);\n-        slow_path = &stub->entry();\n-        continuation = &stub->continuation();\n-        guard = &stub->guard();\n-      }\n-      \/\/ In the C2 code, we move the non-hot part of nmethod entry barriers out-of-line to a stub.\n-      bs->nmethod_entry_barrier(masm, slow_path, continuation, guard);\n+    \/\/ Dummy labels for just measuring the code size\n+    Label dummy_slow_path;\n+    Label dummy_continuation;\n+    Label dummy_guard;\n+    Label* slow_path = &dummy_slow_path;\n+    Label* continuation = &dummy_continuation;\n+    Label* guard = &dummy_guard;\n+    if (!Compile::current()->output()->in_scratch_emit_size()) {\n+      \/\/ Use real labels from actual stub when not emitting code for the purpose of measuring its size\n+      C2EntryBarrierStub* stub = new (Compile::current()->comp_arena()) C2EntryBarrierStub();\n+      Compile::current()->output()->add_stub(stub);\n+      slow_path = &stub->entry();\n+      continuation = &stub->continuation();\n+      guard = &stub->guard();\n@@ -1814,0 +1810,2 @@\n+    \/\/ In the C2 code, we move the non-hot part of nmethod entry barriers out-of-line to a stub.\n+    bs->nmethod_entry_barrier(masm, slow_path, continuation, guard);\n@@ -4544,0 +4542,1 @@\n+            SHENANDOAHGC_ONLY(!BarrierSet::barrier_set()->is_a(BarrierSet::ShenandoahBarrierSet) &&)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":18,"deletions":19,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1351,1 +1351,1 @@\n-  if (C->stub_function() == nullptr && BarrierSet::barrier_set()->barrier_set_nmethod() != nullptr) {\n+  if (C->stub_function() == nullptr) {\n@@ -1401,18 +1401,14 @@\n-    if (BarrierSet::barrier_set()->barrier_set_nmethod() != nullptr) {\n-      \/\/ Dummy labels for just measuring the code size\n-      Label dummy_slow_path;\n-      Label dummy_continuation;\n-      Label dummy_guard;\n-      Label* slow_path = &dummy_slow_path;\n-      Label* continuation = &dummy_continuation;\n-      Label* guard = &dummy_guard;\n-      if (!Compile::current()->output()->in_scratch_emit_size()) {\n-        \/\/ Use real labels from actual stub when not emitting code for purpose of measuring its size\n-        C2EntryBarrierStub* stub = new (Compile::current()->comp_arena()) C2EntryBarrierStub();\n-        Compile::current()->output()->add_stub(stub);\n-        slow_path = &stub->entry();\n-        continuation = &stub->continuation();\n-        guard = &stub->guard();\n-      }\n-      \/\/ In the C2 code, we move the non-hot part of nmethod entry barriers out-of-line to a stub.\n-      bs->nmethod_entry_barrier(masm, slow_path, continuation, guard);\n+    \/\/ Dummy labels for just measuring the code size\n+    Label dummy_slow_path;\n+    Label dummy_continuation;\n+    Label dummy_guard;\n+    Label* slow_path = &dummy_slow_path;\n+    Label* continuation = &dummy_continuation;\n+    Label* guard = &dummy_guard;\n+    if (!Compile::current()->output()->in_scratch_emit_size()) {\n+      \/\/ Use real labels from actual stub when not emitting code for purpose of measuring its size\n+      C2EntryBarrierStub* stub = new (Compile::current()->comp_arena()) C2EntryBarrierStub();\n+      Compile::current()->output()->add_stub(stub);\n+      slow_path = &stub->entry();\n+      continuation = &stub->continuation();\n+      guard = &stub->guard();\n@@ -1420,0 +1416,2 @@\n+    \/\/ In the C2 code, we move the non-hot part of nmethod entry barriers out-of-line to a stub.\n+    bs->nmethod_entry_barrier(masm, slow_path, continuation, guard);\n@@ -1901,0 +1899,4 @@\n+    case Op_ReverseI:\n+    case Op_ReverseL:\n+      return UseZbkb;\n+\n@@ -1921,0 +1923,3 @@\n+      return VM_Version::supports_float16_float_conversion();\n+    case Op_ReinterpretS2HF:\n+    case Op_ReinterpretHF2S:\n@@ -1922,0 +1927,9 @@\n+    case Op_AddHF:\n+    case Op_DivHF:\n+    case Op_FmaHF:\n+    case Op_MaxHF:\n+    case Op_MinHF:\n+    case Op_MulHF:\n+    case Op_SubHF:\n+    case Op_SqrtHF:\n+      return UseZfh;\n@@ -2474,58 +2488,0 @@\n-  \/\/ arithmetic encodings\n-\n-  enc_class riscv_enc_divw(iRegI dst, iRegI src1, iRegI src2) %{\n-    Register dst_reg = as_Register($dst$$reg);\n-    Register src1_reg = as_Register($src1$$reg);\n-    Register src2_reg = as_Register($src2$$reg);\n-    __ corrected_idivl(dst_reg, src1_reg, src2_reg, \/* want_remainder *\/ false, \/* is_signed *\/ true);\n-  %}\n-\n-  enc_class riscv_enc_divuw(iRegI dst, iRegI src1, iRegI src2) %{\n-    Register dst_reg = as_Register($dst$$reg);\n-    Register src1_reg = as_Register($src1$$reg);\n-    Register src2_reg = as_Register($src2$$reg);\n-    __ corrected_idivl(dst_reg, src1_reg, src2_reg, \/* want_remainder *\/ false, \/* is_signed *\/ false);\n-  %}\n-\n-  enc_class riscv_enc_div(iRegI dst, iRegI src1, iRegI src2) %{\n-    Register dst_reg = as_Register($dst$$reg);\n-    Register src1_reg = as_Register($src1$$reg);\n-    Register src2_reg = as_Register($src2$$reg);\n-    __ corrected_idivq(dst_reg, src1_reg, src2_reg, \/* want_remainder *\/ false, \/* is_signed *\/ true);\n-  %}\n-\n-  enc_class riscv_enc_divu(iRegI dst, iRegI src1, iRegI src2) %{\n-    Register dst_reg = as_Register($dst$$reg);\n-    Register src1_reg = as_Register($src1$$reg);\n-    Register src2_reg = as_Register($src2$$reg);\n-    __ corrected_idivq(dst_reg, src1_reg, src2_reg, \/* want_remainder *\/ false, \/* is_signed *\/ false);\n-  %}\n-\n-  enc_class riscv_enc_modw(iRegI dst, iRegI src1, iRegI src2) %{\n-    Register dst_reg = as_Register($dst$$reg);\n-    Register src1_reg = as_Register($src1$$reg);\n-    Register src2_reg = as_Register($src2$$reg);\n-    __ corrected_idivl(dst_reg, src1_reg, src2_reg, \/* want_remainder *\/ true, \/* is_signed *\/ true);\n-  %}\n-\n-  enc_class riscv_enc_moduw(iRegI dst, iRegI src1, iRegI src2) %{\n-    Register dst_reg = as_Register($dst$$reg);\n-    Register src1_reg = as_Register($src1$$reg);\n-    Register src2_reg = as_Register($src2$$reg);\n-    __ corrected_idivl(dst_reg, src1_reg, src2_reg, \/* want_remainder *\/ true, \/* is_signed *\/ false);\n-  %}\n-\n-  enc_class riscv_enc_mod(iRegI dst, iRegI src1, iRegI src2) %{\n-    Register dst_reg = as_Register($dst$$reg);\n-    Register src1_reg = as_Register($src1$$reg);\n-    Register src2_reg = as_Register($src2$$reg);\n-    __ corrected_idivq(dst_reg, src1_reg, src2_reg, \/* want_remainder *\/ true, \/* is_signed *\/ true);\n-  %}\n-\n-  enc_class riscv_enc_modu(iRegI dst, iRegI src1, iRegI src2) %{\n-    Register dst_reg = as_Register($dst$$reg);\n-    Register src1_reg = as_Register($src1$$reg);\n-    Register src2_reg = as_Register($src2$$reg);\n-    __ corrected_idivq(dst_reg, src1_reg, src2_reg, \/* want_remainder *\/ true, \/* is_signed *\/ false);\n-  %}\n-\n@@ -2919,0 +2875,1 @@\n+            SHENANDOAHGC_ONLY(!BarrierSet::barrier_set()->is_a(BarrierSet::ShenandoahBarrierSet) &&)\n@@ -3060,0 +3017,21 @@\n+\/\/ Half Float Immediate\n+operand immH()\n+%{\n+  match(ConH);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Half Float Immediate: +0.0f.\n+operand immH0()\n+%{\n+  predicate(jint_cast(n->geth()) == 0);\n+  match(ConH);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -4100,1 +4078,1 @@\n-pipe_class fp_sqrt_s(fRegF dst, fRegF src1, fRegF src2)\n+pipe_class fp_sqrt_s(fRegF dst, fRegF src)\n@@ -4103,2 +4081,1 @@\n-  src1   : S1(read);\n-  src2   : S2(read);\n+  src    : S1(read);\n@@ -4110,1 +4087,1 @@\n-pipe_class fp_sqrt_d(fRegD dst, fRegD src1, fRegD src2)\n+pipe_class fp_sqrt_d(fRegD dst, fRegD src)\n@@ -4113,2 +4090,1 @@\n-  src1   : S1(read);\n-  src2   : S2(read);\n+  src    : S1(read);\n@@ -4914,0 +4890,36 @@\n+\/\/ Load Half Float Constant\n+instruct loadConH(fRegF dst, immH con) %{\n+  match(Set dst con);\n+\n+  ins_cost(LOAD_COST);\n+  format %{\n+    \"flh $dst, [$constantaddress]\\t# load from constant table: float=$con, #@loadConH\"\n+  %}\n+\n+  ins_encode %{\n+    assert(UseZfh || UseZfhmin, \"must\");\n+    if (MacroAssembler::can_hf_imm_load($con$$constant)) {\n+      __ fli_h(as_FloatRegister($dst$$reg), $con$$constant);\n+    } else {\n+      __ flh(as_FloatRegister($dst$$reg), $constantaddress($con));\n+    }\n+  %}\n+\n+  ins_pipe(fp_load_constant_s);\n+%}\n+\n+instruct loadConH0(fRegF dst, immH0 con) %{\n+  match(Set dst con);\n+\n+  ins_cost(XFER_COST);\n+\n+  format %{ \"fmv.h.x $dst, zr\\t# float, #@loadConH0\" %}\n+\n+  ins_encode %{\n+    assert(UseZfh || UseZfhmin, \"must\");\n+    __ fmv_h_x(as_FloatRegister($dst$$reg), zr);\n+  %}\n+\n+  ins_pipe(fp_load_constant_s);\n+%}\n+\n@@ -4924,5 +4936,5 @@\n-      if (MacroAssembler::can_fp_imm_load($con$$constant)) {\n-        __ fli_s(as_FloatRegister($dst$$reg), $con$$constant);\n-      } else {\n-        __ flw(as_FloatRegister($dst$$reg), $constantaddress($con));\n-      }\n+    if (MacroAssembler::can_fp_imm_load($con$$constant)) {\n+      __ fli_s(as_FloatRegister($dst$$reg), $con$$constant);\n+    } else {\n+      __ flw(as_FloatRegister($dst$$reg), $constantaddress($con));\n+    }\n@@ -4958,5 +4970,5 @@\n-      if (MacroAssembler::can_dp_imm_load($con$$constant)) {\n-        __ fli_d(as_FloatRegister($dst$$reg), $con$$constant);\n-      } else {\n-        __ fld(as_FloatRegister($dst$$reg), $constantaddress($con));\n-      }\n+    if (MacroAssembler::can_dp_imm_load($con$$constant)) {\n+      __ fli_d(as_FloatRegister($dst$$reg), $con$$constant);\n+    } else {\n+      __ fld(as_FloatRegister($dst$$reg), $constantaddress($con));\n+    }\n@@ -6700,1 +6712,3 @@\n-  ins_encode(riscv_enc_divw(dst, src1, src2));\n+  ins_encode %{\n+    __ divw(as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg));\n+  %}\n@@ -6709,1 +6723,3 @@\n-  ins_encode(riscv_enc_divuw(dst, src1, src2));\n+  ins_encode %{\n+    __ divuw(as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg));\n+  %}\n@@ -6731,1 +6747,3 @@\n-  ins_encode(riscv_enc_div(dst, src1, src2));\n+  ins_encode %{\n+    __ div(as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg));\n+  %}\n@@ -6741,1 +6759,3 @@\n-  ins_encode(riscv_enc_divu(dst, src1, src2));\n+  ins_encode %{\n+    __ divu(as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg));\n+  %}\n@@ -6763,1 +6783,3 @@\n-  ins_encode(riscv_enc_modw(dst, src1, src2));\n+  ins_encode %{\n+    __ remw(as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg));\n+  %}\n@@ -6772,1 +6794,3 @@\n-  ins_encode(riscv_enc_moduw(dst, src1, src2));\n+  ins_encode %{\n+    __ remuw(as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg));\n+  %}\n@@ -6783,1 +6807,3 @@\n-  ins_encode(riscv_enc_mod(dst, src1, src2));\n+  ins_encode %{\n+    __ rem(as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg));\n+  %}\n@@ -6792,1 +6818,3 @@\n-  ins_encode(riscv_enc_modu(dst, src1, src2));\n+  ins_encode %{\n+    __ remu(as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg));\n+  %}\n@@ -7290,0 +7318,1 @@\n+  predicate(!UseZfa);\n@@ -7291,1 +7320,1 @@\n-  effect(TEMP_DEF dst, KILL cr);\n+  effect(KILL cr);\n@@ -7298,1 +7327,15 @@\n-                 false \/* is_double *\/, false \/* is_min *\/);\n+                 __ FLOAT_TYPE::single_precision, false \/* is_min *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct maxF_reg_reg_zfa(fRegF dst, fRegF src1, fRegF src2) %{\n+  predicate(UseZfa);\n+  match(Set dst (MaxF src1 src2));\n+\n+  format %{ \"maxF $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ fmaxm_s(as_FloatRegister($dst$$reg),\n+               as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n@@ -7306,0 +7349,1 @@\n+  predicate(!UseZfa);\n@@ -7307,1 +7351,1 @@\n-  effect(TEMP_DEF dst, KILL cr);\n+  effect(KILL cr);\n@@ -7314,1 +7358,15 @@\n-                 false \/* is_double *\/, true \/* is_min *\/);\n+                 __ FLOAT_TYPE::single_precision, true \/* is_min *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct minF_reg_reg_zfa(fRegF dst, fRegF src1, fRegF src2) %{\n+  predicate(UseZfa);\n+  match(Set dst (MinF src1 src2));\n+\n+  format %{ \"minF $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ fminm_s(as_FloatRegister($dst$$reg),\n+               as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n@@ -7322,0 +7380,1 @@\n+  predicate(!UseZfa);\n@@ -7323,1 +7382,1 @@\n-  effect(TEMP_DEF dst, KILL cr);\n+  effect(KILL cr);\n@@ -7330,1 +7389,15 @@\n-                 true \/* is_double *\/, false \/* is_min *\/);\n+                 __ FLOAT_TYPE::double_precision, false \/* is_min *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct maxD_reg_reg_zfa(fRegD dst, fRegD src1, fRegD src2) %{\n+  predicate(UseZfa);\n+  match(Set dst (MaxD src1 src2));\n+\n+  format %{ \"maxD $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ fmaxm_d(as_FloatRegister($dst$$reg),\n+               as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n@@ -7338,0 +7411,1 @@\n+  predicate(!UseZfa);\n@@ -7339,1 +7413,1 @@\n-  effect(TEMP_DEF dst, KILL cr);\n+  effect(KILL cr);\n@@ -7346,1 +7420,15 @@\n-                 true \/* is_double *\/, true \/* is_min *\/);\n+                 __ FLOAT_TYPE::double_precision, true \/* is_min *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct minD_reg_reg_zfa(fRegD dst, fRegD src1, fRegD src2) %{\n+  predicate(UseZfa);\n+  match(Set dst (MinD src1 src2));\n+\n+  format %{ \"minD $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ fminm_d(as_FloatRegister($dst$$reg),\n+               as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n@@ -8016,0 +8104,11 @@\n+instruct castHH(fRegF dst)\n+%{\n+  match(Set dst (CastHH dst));\n+\n+  size(0);\n+  format %{ \"# castHH of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n@@ -8178,0 +8277,142 @@\n+\/\/ half precision operations\n+\n+instruct reinterpretS2HF(fRegF dst, iRegI src)\n+%{\n+  match(Set dst (ReinterpretS2HF src));\n+  format %{ \"fmv.h.x $dst, $src\" %}\n+  ins_encode %{\n+    __ fmv_h_x($dst$$FloatRegister, $src$$Register);\n+  %}\n+  ins_pipe(fp_i2f);\n+%}\n+\n+instruct convF2HFAndS2HF(fRegF dst, fRegF src)\n+%{\n+  match(Set dst (ReinterpretS2HF (ConvF2HF src)));\n+  format %{ \"convF2HFAndS2HF $dst, $src\" %}\n+  ins_encode %{\n+    __ fcvt_h_s($dst$$FloatRegister, $src$$FloatRegister);\n+  %}\n+  ins_pipe(fp_uop_s);\n+%}\n+\n+instruct reinterpretHF2S(iRegINoSp dst, fRegF src)\n+%{\n+  match(Set dst (ReinterpretHF2S src));\n+  format %{ \"fmv.x.h $dst, $src\" %}\n+  ins_encode %{\n+    __ fmv_x_h($dst$$Register, $src$$FloatRegister);\n+  %}\n+  ins_pipe(fp_f2i);\n+%}\n+\n+instruct convHF2SAndHF2F(fRegF dst, fRegF src)\n+%{\n+  match(Set dst (ConvHF2F (ReinterpretHF2S src)));\n+  format %{ \"convHF2SAndHF2F $dst, $src\" %}\n+  ins_encode %{\n+    __ fcvt_s_h($dst$$FloatRegister, $src$$FloatRegister);\n+  %}\n+  ins_pipe(fp_uop_s);\n+%}\n+\n+instruct sqrt_HF_reg(fRegF dst, fRegF src)\n+%{\n+  match(Set dst (SqrtHF src));\n+  format %{ \"fsqrt.h $dst, $src\" %}\n+  ins_encode %{\n+    __ fsqrt_h($dst$$FloatRegister, $src$$FloatRegister);\n+  %}\n+  ins_pipe(fp_sqrt_s);\n+%}\n+\n+instruct binOps_HF_reg(fRegF dst, fRegF src1, fRegF src2)\n+%{\n+  match(Set dst (AddHF src1 src2));\n+  match(Set dst (SubHF src1 src2));\n+  match(Set dst (MulHF src1 src2));\n+  match(Set dst (DivHF src1 src2));\n+  format %{ \"binop_hf $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    switch(opcode) {\n+      case Op_AddHF: __ fadd_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;\n+      case Op_SubHF: __ fsub_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;\n+      case Op_MulHF: __ fmul_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;\n+      case Op_DivHF: __ fdiv_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;\n+      default: assert(false, \"%s is not supported here\", NodeClassNames[opcode]); break;\n+    }\n+  %}\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n+instruct min_HF_reg(fRegF dst, fRegF src1, fRegF src2, rFlagsReg cr)\n+%{\n+  predicate(!UseZfa);\n+  match(Set dst (MinHF src1 src2));\n+  effect(KILL cr);\n+\n+  format %{ \"min_hf $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ minmax_fp($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,\n+                 __ FLOAT_TYPE::half_precision, true \/* is_min *\/);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct min_HF_reg_zfa(fRegF dst, fRegF src1, fRegF src2)\n+%{\n+  predicate(UseZfa);\n+  match(Set dst (MinHF src1 src2));\n+\n+  format %{ \"min_hf $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ fminm_h(as_FloatRegister($dst$$reg),\n+               as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n+  %}\n+\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct max_HF_reg(fRegF dst, fRegF src1, fRegF src2, rFlagsReg cr)\n+%{\n+  predicate(!UseZfa);\n+  match(Set dst (MaxHF src1 src2));\n+  effect(KILL cr);\n+\n+  format %{ \"max_hf $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ minmax_fp($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,\n+                 __ FLOAT_TYPE::half_precision, false \/* is_min *\/);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct max_HF_reg_zfa(fRegF dst, fRegF src1, fRegF src2)\n+%{\n+  predicate(UseZfa);\n+  match(Set dst (MaxHF src1 src2));\n+\n+  format %{ \"max_hf $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ fmaxm_h(as_FloatRegister($dst$$reg),\n+               as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n+  %}\n+\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct fma_HF_reg(fRegF dst, fRegF src1, fRegF src2, fRegF src3)\n+%{\n+  match(Set dst (FmaHF src3 (Binary src1 src2)));\n+  format %{ \"fmadd.h $dst, $src1, $src2, $src3\\t# $dst = $src1 * $src2 + $src3 fma packedH\" %}\n+  ins_encode %{\n+    __ fmadd_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n@@ -8799,5 +9040,1 @@\n-  format %{\n-    \"ble $dst, $src, skip\\t#@minI_reg_reg\\n\\t\"\n-    \"mv  $dst, $src\\n\\t\"\n-    \"skip:\"\n-  %}\n+  format %{\"minI_reg_reg $dst, $dst, $src\\t#@minI_reg_reg\\n\\t\"%}\n@@ -8806,4 +9043,2 @@\n-    Label Lskip;\n-    __ ble(as_Register($dst$$reg), as_Register($src$$reg), Lskip);\n-    __ mv(as_Register($dst$$reg), as_Register($src$$reg));\n-    __ bind(Lskip);\n+    __ cmov_gt(as_Register($dst$$reg), as_Register($src$$reg),\n+               as_Register($dst$$reg), as_Register($src$$reg));\n@@ -8820,5 +9055,1 @@\n-  format %{\n-    \"bge $dst, $src, skip\\t#@maxI_reg_reg\\n\\t\"\n-    \"mv  $dst, $src\\n\\t\"\n-    \"skip:\"\n-  %}\n+  format %{\"maxI_reg_reg $dst, $dst, $src\\t#@maxI_reg_reg\\n\\t\"%}\n@@ -8827,4 +9058,2 @@\n-    Label Lskip;\n-    __ bge(as_Register($dst$$reg), as_Register($src$$reg), Lskip);\n-    __ mv(as_Register($dst$$reg), as_Register($src$$reg));\n-    __ bind(Lskip);\n+    __ cmov_lt(as_Register($dst$$reg), as_Register($src$$reg),\n+               as_Register($dst$$reg), as_Register($src$$reg));\n@@ -8846,5 +9075,1 @@\n-  format %{\n-    \"blez $dst, skip\\t#@minI_reg_zero\\n\\t\"\n-    \"mv   $dst, zr\\n\\t\"\n-    \"skip:\"\n-  %}\n+  format %{\"minI_reg_zero $dst, $dst, zr\\t#@minI_reg_zero\\n\\t\"%}\n@@ -8853,4 +9078,2 @@\n-    Label Lskip;\n-    __ blez(as_Register($dst$$reg), Lskip);\n-    __ mv(as_Register($dst$$reg), zr);\n-    __ bind(Lskip);\n+    __ cmov_gt(as_Register($dst$$reg), zr,\n+               as_Register($dst$$reg), zr);\n@@ -8868,5 +9091,1 @@\n-  format %{\n-    \"bgez $dst, skip\\t#@maxI_reg_zero\\n\\t\"\n-    \"mv   $dst, zr\\n\\t\"\n-    \"skip:\"\n-  %}\n+  format %{\"maxI_reg_zero $dst, $dst, zr\\t#@maxI_reg_zero\\n\\t\"%}\n@@ -8875,4 +9094,2 @@\n-    Label Lskip;\n-    __ bgez(as_Register($dst$$reg), Lskip);\n-    __ mv(as_Register($dst$$reg), zr);\n-    __ bind(Lskip);\n+    __ cmov_lt(as_Register($dst$$reg), zr,\n+               as_Register($dst$$reg), zr);\n@@ -8891,8 +9108,1 @@\n-  format %{\n-    \"ble $src1, $src2, Lsrc1\\t#@minI_rReg\\n\\t\"\n-    \"mv $dst, $src2\\n\\t\"\n-    \"j Ldone\\n\\t\"\n-    \"Lsrc1:\\n\\t\"\n-    \"mv $dst, $src1\\n\\t\"\n-    \"Ldone:\"\n-  %}\n+  format %{\"minI_rReg $dst, $src1, $src2\\t#@minI_rReg\\n\\t\"%}\n@@ -8901,6 +9111,2 @@\n-    Label Lsrc1, Ldone;\n-    __ ble(as_Register($src1$$reg), as_Register($src2$$reg), Lsrc1);\n-    __ mv(as_Register($dst$$reg), as_Register($src2$$reg));\n-    __ j(Ldone);\n-    __ bind(Lsrc1);\n-    __ bind(Ldone);\n+    __ cmov_gt(as_Register($src1$$reg), as_Register($src2$$reg),\n+               as_Register($dst$$reg), as_Register($src2$$reg));\n@@ -8920,8 +9126,1 @@\n-  format %{\n-    \"bge $src1, $src2, Lsrc1\\t#@maxI_rReg\\n\\t\"\n-    \"mv $dst, $src2\\n\\t\"\n-    \"j Ldone\\n\\t\"\n-    \"Lsrc1:\\n\\t\"\n-    \"mv $dst, $src1\\n\\t\"\n-    \"Ldone:\"\n-  %}\n+  format %{\"maxI_rReg $dst, $src1, $src2\\t#@maxI_rReg\\n\\t\"%}\n@@ -8930,7 +9129,2 @@\n-    Label Lsrc1, Ldone;\n-    __ bge(as_Register($src1$$reg), as_Register($src2$$reg), Lsrc1);\n-    __ mv(as_Register($dst$$reg), as_Register($src2$$reg));\n-    __ j(Ldone);\n-    __ bind(Lsrc1);\n-    __ bind(Ldone);\n-\n+    __ cmov_lt(as_Register($src1$$reg), as_Register($src2$$reg),\n+               as_Register($dst$$reg), as_Register($src2$$reg));\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":368,"deletions":174,"binary":false,"changes":542,"status":"modified"},{"patch":"@@ -781,0 +781,4 @@\n+#ifdef _WIN64\n+  \/\/ Windows always allocates space for its register args\n+  subq(rsp,  frame::arg_reg_save_area_bytes);\n+#endif\n@@ -784,0 +788,4 @@\n+#ifdef _WIN64\n+  \/\/ restore stack pointer\n+  addq(rsp, frame::arg_reg_save_area_bytes);\n+#endif\n@@ -2382,0 +2390,16 @@\n+void MacroAssembler::cmp32_mxcsr_std(Address mxcsr_save, Register tmp, Register rscratch) {\n+  ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n+  assert(rscratch != noreg || always_reachable(mxcsr_std), \"missing\");\n+\n+  stmxcsr(mxcsr_save);\n+  movl(tmp, mxcsr_save);\n+  if (EnableX86ECoreOpts) {\n+    \/\/ The mxcsr_std has status bits set for performance on ECore\n+    orl(tmp, 0x003f);\n+  } else {\n+    \/\/ Mask out status bits (only check control and mask bits)\n+    andl(tmp, 0xFFC0);\n+  }\n+  cmp32(tmp, mxcsr_std, rscratch);\n+}\n+\n@@ -2699,0 +2723,54 @@\n+void MacroAssembler::vmovdqu(XMMRegister dst, XMMRegister src, int vector_len) {\n+  if (vector_len == AVX_512bit) {\n+    evmovdquq(dst, src, AVX_512bit);\n+  } else if (vector_len == AVX_256bit) {\n+    vmovdqu(dst, src);\n+  } else {\n+    movdqu(dst, src);\n+  }\n+}\n+\n+void MacroAssembler::vmovdqu(Address dst, XMMRegister src, int vector_len) {\n+  if (vector_len == AVX_512bit) {\n+    evmovdquq(dst, src, AVX_512bit);\n+  } else if (vector_len == AVX_256bit) {\n+    vmovdqu(dst, src);\n+  } else {\n+    movdqu(dst, src);\n+  }\n+}\n+\n+void MacroAssembler::vmovdqu(XMMRegister dst, Address src, int vector_len) {\n+  if (vector_len == AVX_512bit) {\n+    evmovdquq(dst, src, AVX_512bit);\n+  } else if (vector_len == AVX_256bit) {\n+    vmovdqu(dst, src);\n+  } else {\n+    movdqu(dst, src);\n+  }\n+}\n+\n+void MacroAssembler::vmovdqa(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    vmovdqa(dst, as_Address(src));\n+  }\n+  else {\n+    lea(rscratch, src);\n+    vmovdqa(dst, Address(rscratch, 0));\n+  }\n+}\n+\n+void MacroAssembler::vmovdqa(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (vector_len == AVX_512bit) {\n+    evmovdqaq(dst, src, AVX_512bit, rscratch);\n+  } else if (vector_len == AVX_256bit) {\n+    vmovdqa(dst, src, rscratch);\n+  } else {\n+    movdqa(dst, src, rscratch);\n+  }\n+}\n+\n@@ -2823,0 +2901,23 @@\n+void MacroAssembler::evmovdqaq(XMMRegister dst, KRegister mask, AddressLiteral src, bool merge, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    Assembler::evmovdqaq(dst, mask, as_Address(src), merge, vector_len);\n+  } else {\n+    lea(rscratch, src);\n+    Assembler::evmovdqaq(dst, mask, Address(rscratch, 0), merge, vector_len);\n+  }\n+}\n+\n+void MacroAssembler::evmovdqaq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    Assembler::evmovdqaq(dst, as_Address(src), vector_len);\n+  } else {\n+    lea(rscratch, src);\n+    Assembler::evmovdqaq(dst, Address(rscratch, 0), vector_len);\n+  }\n+}\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":101,"deletions":0,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-static const Register rbcp     = LP64_ONLY(r13) NOT_LP64(rsi);\n-static const Register rlocals  = LP64_ONLY(r14) NOT_LP64(rdi);\n+static const Register rbcp     = r13;\n+static const Register rlocals  = r14;\n@@ -66,6 +66,0 @@\n-#ifndef _LP64\n-static inline Address haddress(int n) {\n-  return iaddress(n + 0);\n-}\n-#endif\n-\n@@ -92,6 +86,0 @@\n-#ifndef _LP64\n-static inline Address haddress(Register r)       {\n-  return Address(rlocals, r, Interpreter::stackElementScale(), Interpreter::local_offset_in_bytes(0));\n-}\n-#endif\n-\n@@ -159,4 +147,1 @@\n-  __ store_heap_oop(dst, val,\n-                    NOT_LP64(rdx) LP64_ONLY(rscratch2),\n-                    NOT_LP64(rbx) LP64_ONLY(r9),\n-                    NOT_LP64(rsi) LP64_ONLY(r8), decorators);\n+  __ store_heap_oop(dst, val, rscratch2, r9, r8, decorators);\n@@ -288,4 +273,0 @@\n-#ifndef _LP64\n-  assert(value >= 0, \"check this code\");\n-  __ xorptr(rdx, rdx);\n-#endif\n@@ -315,8 +296,0 @@\n-#ifdef _LP64\n-#else\n-           if (value == 0) { __ fldz();\n-    } else if (value == 1) { __ fld1();\n-    } else if (value == 2) { __ fld1(); __ fld1(); __ faddp(); \/\/ should do a better solution here\n-    } else                 { ShouldNotReachHere();\n-    }\n-#endif \/\/ _LP64\n@@ -343,7 +316,0 @@\n-#ifdef _LP64\n-#else\n-           if (value == 0) { __ fldz();\n-    } else if (value == 1) { __ fld1();\n-    } else                 { ShouldNotReachHere();\n-    }\n-#endif\n@@ -368,1 +334,1 @@\n-  Register rarg = NOT_LP64(rcx) LP64_ONLY(c_rarg1);\n+  Register rarg = c_rarg1;\n@@ -436,1 +402,1 @@\n-  Register rarg = NOT_LP64(rcx) LP64_ONLY(c_rarg1);\n+  Register rarg = c_rarg1;\n@@ -499,1 +465,0 @@\n-  NOT_LP64(__ movptr(rdx, Address(rcx, rbx, Address::times_ptr, base_offset + 1 * wordSize)));\n@@ -513,1 +478,1 @@\n-  const Register rarg = NOT_LP64(rcx) LP64_ONLY(c_rarg1);\n+  const Register rarg = c_rarg1;\n@@ -516,7 +481,0 @@\n-#ifndef _LP64\n-  \/\/ borrow rdi from locals\n-  __ get_thread(rdi);\n-  __ get_vm_result_2(flags, rdi);\n-  __ restore_locals();\n-#else\n-#endif\n@@ -598,1 +556,0 @@\n-      NOT_LP64(__ movptr(rdx, field.plus_disp(4)));\n@@ -639,2 +596,2 @@\n-    const Register bc = LP64_ONLY(c_rarg3) NOT_LP64(rcx);\n-    LP64_ONLY(assert(rbx != bc, \"register damaged\"));\n+    const Register bc = c_rarg3;\n+    assert(rbx != bc, \"register damaged\");\n@@ -696,1 +653,0 @@\n-  NOT_LP64(__ movl(rdx, haddress(rbx)));\n@@ -734,1 +690,0 @@\n-  NOT_LP64(__ movl(rdx, haddress(rbx)));\n@@ -775,1 +730,1 @@\n-  __ mov(NOT_LP64(rax) LP64_ONLY(c_rarg1), array);\n+  __ mov(c_rarg1, array);\n@@ -796,1 +751,0 @@\n-  NOT_LP64(__ mov(rbx, rax));\n@@ -897,1 +851,0 @@\n-  NOT_LP64(__ movptr(rdx, haddress(n)));\n@@ -949,2 +902,2 @@\n-    const Register bc = LP64_ONLY(c_rarg3) NOT_LP64(rcx);\n-    LP64_ONLY(assert(rbx != bc, \"register damaged\"));\n+    const Register bc = c_rarg3;\n+    assert(rbx != bc, \"register damaged\");\n@@ -1004,1 +957,0 @@\n-  NOT_LP64(__ movptr(haddress(rbx), rdx));\n@@ -1035,2 +987,1 @@\n-  NOT_LP64(__ pop_l(rax, rdx));\n-  LP64_ONLY(__ pop_l());\n+  __ pop_l();\n@@ -1039,1 +990,0 @@\n-  NOT_LP64(__ movl(haddress(rbx), rdx));\n@@ -1043,1 +993,0 @@\n-#ifdef _LP64\n@@ -1048,3 +997,0 @@\n-#else\n-  wide_istore();\n-#endif\n@@ -1054,1 +1000,0 @@\n-#ifdef _LP64\n@@ -1059,3 +1004,0 @@\n-#else\n-  wide_lstore();\n-#endif\n@@ -1227,1 +1169,0 @@\n-  NOT_LP64(__ movptr(haddress(n), rdx));\n@@ -1366,1 +1307,0 @@\n-#ifdef _LP64\n@@ -1375,12 +1315,0 @@\n-#else\n-  __ pop_l(rbx, rcx);\n-  switch (op) {\n-    case add  : __ addl(rax, rbx); __ adcl(rdx, rcx); break;\n-    case sub  : __ subl(rbx, rax); __ sbbl(rcx, rdx);\n-                __ mov (rax, rbx); __ mov (rdx, rcx); break;\n-    case _and : __ andl(rax, rbx); __ andl(rdx, rcx); break;\n-    case _or  : __ orl (rax, rbx); __ orl (rdx, rcx); break;\n-    case _xor : __ xorl(rax, rbx); __ xorl(rdx, rcx); break;\n-    default   : ShouldNotReachHere();\n-  }\n-#endif\n@@ -1414,1 +1342,0 @@\n-#ifdef _LP64\n@@ -1417,7 +1344,0 @@\n-#else\n-  __ pop_l(rbx, rcx);\n-  __ push(rcx); __ push(rbx);\n-  __ push(rdx); __ push(rax);\n-  __ lmul(2 * wordSize, 0);\n-  __ addptr(rsp, 4 * wordSize);  \/\/ take off temporaries\n-#endif\n@@ -1428,1 +1348,0 @@\n-#ifdef _LP64\n@@ -1440,11 +1359,0 @@\n-#else\n-  __ pop_l(rbx, rcx);\n-  __ push(rcx); __ push(rbx);\n-  __ push(rdx); __ push(rax);\n-  \/\/ check if y = 0\n-  __ orl(rax, rdx);\n-  __ jump_cc(Assembler::zero,\n-             RuntimeAddress(Interpreter::_throw_ArithmeticException_entry));\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::ldiv));\n-  __ addptr(rsp, 4 * wordSize);  \/\/ take off temporaries\n-#endif\n@@ -1455,1 +1363,0 @@\n-#ifdef _LP64\n@@ -1467,11 +1374,0 @@\n-#else\n-  __ pop_l(rbx, rcx);\n-  __ push(rcx); __ push(rbx);\n-  __ push(rdx); __ push(rax);\n-  \/\/ check if y = 0\n-  __ orl(rax, rdx);\n-  __ jump_cc(Assembler::zero,\n-             RuntimeAddress(Interpreter::_throw_ArithmeticException_entry));\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::lrem));\n-  __ addptr(rsp, 4 * wordSize);\n-#endif\n@@ -1483,1 +1379,0 @@\n-  #ifdef _LP64\n@@ -1486,4 +1381,0 @@\n-#else\n-  __ pop_l(rax, rdx);                            \/\/ get shift value\n-  __ lshl(rdx, rax);\n-#endif\n@@ -1493,1 +1384,0 @@\n-#ifdef _LP64\n@@ -1498,6 +1388,0 @@\n-#else\n-  transition(itos, ltos);\n-  __ mov(rcx, rax);                              \/\/ get shift count\n-  __ pop_l(rax, rdx);                            \/\/ get shift value\n-  __ lshr(rdx, rax, true);\n-#endif\n@@ -1508,1 +1392,0 @@\n-#ifdef _LP64\n@@ -1512,5 +1395,0 @@\n-#else\n-  __ mov(rcx, rax);                              \/\/ get shift count\n-  __ pop_l(rax, rdx);                            \/\/ get shift value\n-  __ lshr(rdx, rax);\n-#endif\n@@ -1548,7 +1426,0 @@\n-      \/\/\n-      \/\/ On x86_32 platforms the FPU is used to perform the modulo operation. The\n-      \/\/ reason is that on 32-bit Windows the sign of modulo operations diverges from\n-      \/\/ what is considered the standard (e.g., -0.0f % -3.14f is 0.0f (and not -0.0f).\n-      \/\/ The fprem instruction used on x86_32 is functionally equivalent to\n-      \/\/ SharedRuntime::frem in that it returns a NaN.\n-#ifdef _LP64\n@@ -1558,10 +1429,0 @@\n-#else \/\/ !_LP64\n-      __ push_f(xmm0);\n-      __ pop_f();\n-      __ fld_s(at_rsp());\n-      __ fremr(rax);\n-      __ f2ieee();\n-      __ pop(rax);  \/\/ pop second operand off the stack\n-      __ push_f();\n-      __ pop_f(xmm0);\n-#endif \/\/ _LP64\n@@ -1574,13 +1435,0 @@\n-#ifdef _LP64\n-#else \/\/ !_LP64\n-    switch (op) {\n-    case add: __ fadd_s (at_rsp());                break;\n-    case sub: __ fsubr_s(at_rsp());                break;\n-    case mul: __ fmul_s (at_rsp());                break;\n-    case div: __ fdivr_s(at_rsp());                break;\n-    case rem: __ fld_s  (at_rsp()); __ fremr(rax); break;\n-    default : ShouldNotReachHere();\n-    }\n-    __ f2ieee();\n-    __ pop(rax);  \/\/ pop second operand off the stack\n-#endif \/\/ _LP64\n@@ -1615,3 +1463,2 @@\n-      \/\/ SharedRuntime::drem method (on x86_64 platforms) or using the\n-      \/\/ FPU (on x86_32 platforms) for the same reasons as mentioned in fop2().\n-#ifdef _LP64\n+      \/\/ SharedRuntime::drem method on x86_64 platforms for the same reasons\n+      \/\/ as mentioned in fop2().\n@@ -1621,11 +1468,0 @@\n-#else \/\/ !_LP64\n-      __ push_d(xmm0);\n-      __ pop_d();\n-      __ fld_d(at_rsp());\n-      __ fremr(rax);\n-      __ d2ieee();\n-      __ pop(rax);\n-      __ pop(rdx);\n-      __ push_d();\n-      __ pop_d(xmm0);\n-#endif \/\/ _LP64\n@@ -1638,31 +1474,0 @@\n-#ifdef _LP64\n-#else \/\/ !_LP64\n-    switch (op) {\n-    case add: __ fadd_d (at_rsp());                break;\n-    case sub: __ fsubr_d(at_rsp());                break;\n-    case mul: {\n-      \/\/ strict semantics\n-      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias1()));\n-      __ fmulp();\n-      __ fmul_d (at_rsp());\n-      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias2()));\n-      __ fmulp();\n-      break;\n-    }\n-    case div: {\n-      \/\/ strict semantics\n-      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias1()));\n-      __ fmul_d (at_rsp());\n-      __ fdivrp();\n-      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias2()));\n-      __ fmulp();\n-      break;\n-    }\n-    case rem: __ fld_d  (at_rsp()); __ fremr(rax); break;\n-    default : ShouldNotReachHere();\n-    }\n-    __ d2ieee();\n-    \/\/ Pop double precision number from rsp.\n-    __ pop(rax);\n-    __ pop(rdx);\n-#endif \/\/ _LP64\n@@ -1680,2 +1485,1 @@\n-  LP64_ONLY(__ negq(rax));\n-  NOT_LP64(__ lneg(rdx, rax));\n+  __ negq(rax);\n@@ -1705,2 +1509,1 @@\n-    LP64_ONLY(ShouldNotReachHere());\n-    NOT_LP64(__ fchs());\n+    ShouldNotReachHere();\n@@ -1717,4 +1520,0 @@\n-#ifdef _LP64\n-#else\n-    __ fchs();\n-#endif\n@@ -1744,1 +1543,0 @@\n-#ifdef _LP64\n@@ -1872,192 +1670,0 @@\n-#else \/\/ !_LP64\n-  \/\/ Checking\n-#ifdef ASSERT\n-  { TosState tos_in  = ilgl;\n-    TosState tos_out = ilgl;\n-    switch (bytecode()) {\n-      case Bytecodes::_i2l: \/\/ fall through\n-      case Bytecodes::_i2f: \/\/ fall through\n-      case Bytecodes::_i2d: \/\/ fall through\n-      case Bytecodes::_i2b: \/\/ fall through\n-      case Bytecodes::_i2c: \/\/ fall through\n-      case Bytecodes::_i2s: tos_in = itos; break;\n-      case Bytecodes::_l2i: \/\/ fall through\n-      case Bytecodes::_l2f: \/\/ fall through\n-      case Bytecodes::_l2d: tos_in = ltos; break;\n-      case Bytecodes::_f2i: \/\/ fall through\n-      case Bytecodes::_f2l: \/\/ fall through\n-      case Bytecodes::_f2d: tos_in = ftos; break;\n-      case Bytecodes::_d2i: \/\/ fall through\n-      case Bytecodes::_d2l: \/\/ fall through\n-      case Bytecodes::_d2f: tos_in = dtos; break;\n-      default             : ShouldNotReachHere();\n-    }\n-    switch (bytecode()) {\n-      case Bytecodes::_l2i: \/\/ fall through\n-      case Bytecodes::_f2i: \/\/ fall through\n-      case Bytecodes::_d2i: \/\/ fall through\n-      case Bytecodes::_i2b: \/\/ fall through\n-      case Bytecodes::_i2c: \/\/ fall through\n-      case Bytecodes::_i2s: tos_out = itos; break;\n-      case Bytecodes::_i2l: \/\/ fall through\n-      case Bytecodes::_f2l: \/\/ fall through\n-      case Bytecodes::_d2l: tos_out = ltos; break;\n-      case Bytecodes::_i2f: \/\/ fall through\n-      case Bytecodes::_l2f: \/\/ fall through\n-      case Bytecodes::_d2f: tos_out = ftos; break;\n-      case Bytecodes::_i2d: \/\/ fall through\n-      case Bytecodes::_l2d: \/\/ fall through\n-      case Bytecodes::_f2d: tos_out = dtos; break;\n-      default             : ShouldNotReachHere();\n-    }\n-    transition(tos_in, tos_out);\n-  }\n-#endif \/\/ ASSERT\n-\n-  \/\/ Conversion\n-  \/\/ (Note: use push(rcx)\/pop(rcx) for 1\/2-word stack-ptr manipulation)\n-  switch (bytecode()) {\n-    case Bytecodes::_i2l:\n-      __ extend_sign(rdx, rax);\n-      break;\n-    case Bytecodes::_i2f:\n-      if (UseSSE >= 1) {\n-        __ cvtsi2ssl(xmm0, rax);\n-      } else {\n-        __ push(rax);          \/\/ store int on tos\n-        __ fild_s(at_rsp());   \/\/ load int to ST0\n-        __ f2ieee();           \/\/ truncate to float size\n-        __ pop(rcx);           \/\/ adjust rsp\n-      }\n-      break;\n-    case Bytecodes::_i2d:\n-      if (UseSSE >= 2) {\n-        __ cvtsi2sdl(xmm0, rax);\n-      } else {\n-      __ push(rax);          \/\/ add one slot for d2ieee()\n-      __ push(rax);          \/\/ store int on tos\n-      __ fild_s(at_rsp());   \/\/ load int to ST0\n-      __ d2ieee();           \/\/ truncate to double size\n-      __ pop(rcx);           \/\/ adjust rsp\n-      __ pop(rcx);\n-      }\n-      break;\n-    case Bytecodes::_i2b:\n-      __ shll(rax, 24);      \/\/ truncate upper 24 bits\n-      __ sarl(rax, 24);      \/\/ and sign-extend byte\n-      LP64_ONLY(__ movsbl(rax, rax));\n-      break;\n-    case Bytecodes::_i2c:\n-      __ andl(rax, 0xFFFF);  \/\/ truncate upper 16 bits\n-      LP64_ONLY(__ movzwl(rax, rax));\n-      break;\n-    case Bytecodes::_i2s:\n-      __ shll(rax, 16);      \/\/ truncate upper 16 bits\n-      __ sarl(rax, 16);      \/\/ and sign-extend short\n-      LP64_ONLY(__ movswl(rax, rax));\n-      break;\n-    case Bytecodes::_l2i:\n-      \/* nothing to do *\/\n-      break;\n-    case Bytecodes::_l2f:\n-      \/\/ On 64-bit platforms, the cvtsi2ssq instruction is used to convert\n-      \/\/ 64-bit long values to floats. On 32-bit platforms it is not possible\n-      \/\/ to use that instruction with 64-bit operands, therefore the FPU is\n-      \/\/ used to perform the conversion.\n-      __ push(rdx);          \/\/ store long on tos\n-      __ push(rax);\n-      __ fild_d(at_rsp());   \/\/ load long to ST0\n-      __ f2ieee();           \/\/ truncate to float size\n-      __ pop(rcx);           \/\/ adjust rsp\n-      __ pop(rcx);\n-      if (UseSSE >= 1) {\n-        __ push_f();\n-        __ pop_f(xmm0);\n-      }\n-      break;\n-    case Bytecodes::_l2d:\n-      \/\/ On 32-bit platforms the FPU is used for conversion because on\n-      \/\/ 32-bit platforms it is not not possible to use the cvtsi2sdq\n-      \/\/ instruction with 64-bit operands.\n-      __ push(rdx);          \/\/ store long on tos\n-      __ push(rax);\n-      __ fild_d(at_rsp());   \/\/ load long to ST0\n-      __ d2ieee();           \/\/ truncate to double size\n-      __ pop(rcx);           \/\/ adjust rsp\n-      __ pop(rcx);\n-      if (UseSSE >= 2) {\n-        __ push_d();\n-        __ pop_d(xmm0);\n-      }\n-      break;\n-    case Bytecodes::_f2i:\n-      \/\/ SharedRuntime::f2i does not differentiate between sNaNs and qNaNs\n-      \/\/ as it returns 0 for any NaN.\n-      if (UseSSE >= 1) {\n-        __ push_f(xmm0);\n-      } else {\n-        __ push(rcx);          \/\/ reserve space for argument\n-        __ fstp_s(at_rsp());   \/\/ pass float argument on stack\n-      }\n-      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2i), 1);\n-      break;\n-    case Bytecodes::_f2l:\n-      \/\/ SharedRuntime::f2l does not differentiate between sNaNs and qNaNs\n-      \/\/ as it returns 0 for any NaN.\n-      if (UseSSE >= 1) {\n-       __ push_f(xmm0);\n-      } else {\n-        __ push(rcx);          \/\/ reserve space for argument\n-        __ fstp_s(at_rsp());   \/\/ pass float argument on stack\n-      }\n-      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2l), 1);\n-      break;\n-    case Bytecodes::_f2d:\n-      if (UseSSE < 1) {\n-        \/* nothing to do *\/\n-      } else if (UseSSE == 1) {\n-        __ push_f(xmm0);\n-        __ pop_f();\n-      } else { \/\/ UseSSE >= 2\n-        __ cvtss2sd(xmm0, xmm0);\n-      }\n-      break;\n-    case Bytecodes::_d2i:\n-      if (UseSSE >= 2) {\n-        __ push_d(xmm0);\n-      } else {\n-        __ push(rcx);          \/\/ reserve space for argument\n-        __ push(rcx);\n-        __ fstp_d(at_rsp());   \/\/ pass double argument on stack\n-      }\n-      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2i), 2);\n-      break;\n-    case Bytecodes::_d2l:\n-      if (UseSSE >= 2) {\n-        __ push_d(xmm0);\n-      } else {\n-        __ push(rcx);          \/\/ reserve space for argument\n-        __ push(rcx);\n-        __ fstp_d(at_rsp());   \/\/ pass double argument on stack\n-      }\n-      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2l), 2);\n-      break;\n-    case Bytecodes::_d2f:\n-      if (UseSSE <= 1) {\n-        __ push(rcx);          \/\/ reserve space for f2ieee()\n-        __ f2ieee();           \/\/ truncate to float size\n-        __ pop(rcx);           \/\/ adjust rsp\n-        if (UseSSE == 1) {\n-          \/\/ The cvtsd2ss instruction is not available if UseSSE==1, therefore\n-          \/\/ the conversion is performed using the FPU in this case.\n-          __ push_f();\n-          __ pop_f(xmm0);\n-        }\n-      } else { \/\/ UseSSE >= 2\n-        __ cvtsd2ss(xmm0, xmm0);\n-      }\n-      break;\n-    default             :\n-      ShouldNotReachHere();\n-  }\n-#endif \/\/ _LP64\n@@ -2068,1 +1674,0 @@\n-#ifdef _LP64\n@@ -2077,7 +1682,0 @@\n-#else\n-\n-  \/\/ y = rdx:rax\n-  __ pop_l(rbx, rcx);             \/\/ get x = rcx:rbx\n-  __ lcmp2int(rcx, rbx, rdx, rax);\/\/ rcx := cmp(x, y)\n-  __ mov(rax, rcx);\n-#endif\n@@ -2115,11 +1713,0 @@\n-#ifdef _LP64\n-#else \/\/ !_LP64\n-    if (is_float) {\n-      __ fld_s(at_rsp());\n-    } else {\n-      __ fld_d(at_rsp());\n-      __ pop(rdx);\n-    }\n-    __ pop(rcx);\n-    __ fcmp2int(rax, unordered_result < 0);\n-#endif \/\/ _LP64\n@@ -2151,1 +1738,1 @@\n-  LP64_ONLY(__ movl2ptr(rdx, rdx));\n+  __ movl2ptr(rdx, rdx);\n@@ -2270,2 +1857,0 @@\n-      NOT_LP64(__ get_thread(rcx));\n-\n@@ -2275,2 +1860,1 @@\n-      LP64_ONLY(__ mov(j_rarg0, rax));\n-      NOT_LP64(__ mov(rcx, rax));\n+      __ mov(j_rarg0, rax);\n@@ -2281,2 +1865,2 @@\n-      const Register retaddr   = LP64_ONLY(j_rarg2) NOT_LP64(rdi);\n-      const Register sender_sp = LP64_ONLY(j_rarg1) NOT_LP64(rdx);\n+      const Register retaddr   = j_rarg2;\n+      const Register sender_sp = j_rarg1;\n@@ -2353,2 +1937,1 @@\n-  LP64_ONLY(__ movslq(rbx, iaddress(rbx))); \/\/ get return bci, compute return bcp\n-  NOT_LP64(__ movptr(rbx, iaddress(rbx)));\n+  __ movslq(rbx, iaddress(rbx)); \/\/ get return bci, compute return bcp\n@@ -2398,1 +1981,1 @@\n-  LP64_ONLY(__ movl2ptr(rdx, rdx));\n+  __ movl2ptr(rdx, rdx);\n@@ -2488,2 +2071,0 @@\n-  NOT_LP64(__ save_bcp());\n-\n@@ -2546,4 +2127,1 @@\n-  LP64_ONLY(__ movslq(j, j));\n-\n-  NOT_LP64(__ restore_bcp());\n-  NOT_LP64(__ restore_locals());                           \/\/ restore rdi\n+  __ movslq(j, j);\n@@ -2560,4 +2138,1 @@\n-  LP64_ONLY(__ movslq(j, j));\n-\n-  NOT_LP64(__ restore_bcp());\n-  NOT_LP64(__ restore_locals());\n+  __ movslq(j, j);\n@@ -2578,1 +2153,1 @@\n-    Register robj = LP64_ONLY(c_rarg1) NOT_LP64(rax);\n+    Register robj = c_rarg1;\n@@ -2593,6 +2168,0 @@\n-#ifdef _LP64\n-#else\n-    const Register thread = rdi;\n-    __ get_thread(thread);\n-    __ testb(Address(thread, JavaThread::polling_word_offset()), SafepointMechanism::poll_bit());\n-#endif\n@@ -2697,1 +2266,1 @@\n-    const Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);\n+    const Register thread = r15_thread;\n@@ -2824,1 +2393,0 @@\n-#ifdef _LP64\n@@ -2827,3 +2395,0 @@\n-#else\n-    __ movptr(index, ArrayAddress(table, Address(noreg, index, Address::times_ptr)));\n-#endif \/\/ _LP64\n@@ -2982,1 +2547,1 @@\n-  const Register obj   = LP64_ONLY(c_rarg3) NOT_LP64(rcx);\n+  const Register obj   = c_rarg3;\n@@ -2988,1 +2553,1 @@\n-  const Register bc    = LP64_ONLY(c_rarg3) NOT_LP64(rcx); \/\/ uses same reg as obj, so don't mix them\n+  const Register bc    = c_rarg3; \/\/ uses same reg as obj, so don't mix them\n@@ -3084,1 +2649,1 @@\n-  LP64_ONLY(if (!is_static && rc == may_rewrite) patch_bytecode(Bytecodes::_fast_lgetfield, bc, rbx));\n+  if (!is_static && rc == may_rewrite) patch_bytecode(Bytecodes::_fast_lgetfield, bc, rbx);\n@@ -3144,3 +2709,3 @@\n-  const Register entry = LP64_ONLY(c_rarg2) NOT_LP64(rax); \/\/ ResolvedFieldEntry\n-  const Register obj = LP64_ONLY(c_rarg1) NOT_LP64(rbx);   \/\/ Object pointer\n-  const Register value = LP64_ONLY(c_rarg3) NOT_LP64(rcx); \/\/ JValue object\n+  const Register entry = c_rarg2; \/\/ ResolvedFieldEntry\n+  const Register obj = c_rarg1;   \/\/ Object pointer\n+  const Register value = c_rarg3; \/\/ JValue object\n@@ -3168,4 +2733,0 @@\n-#ifndef _LP64\n-      Label two_word, valsize_known;\n-#endif\n-#ifdef _LP64\n@@ -3180,16 +2741,0 @@\n-#else\n-      __ mov(obj, rsp);\n-      __ cmpl(value, ltos);\n-      __ jccb(Assembler::equal, two_word);\n-      __ cmpl(value, dtos);\n-      __ jccb(Assembler::equal, two_word);\n-      __ addptr(obj, Interpreter::expr_offset_in_bytes(1)); \/\/ one word jvalue (not ltos, dtos)\n-      __ jmpb(valsize_known);\n-\n-      __ bind(two_word);\n-      __ addptr(obj, Interpreter::expr_offset_in_bytes(2)); \/\/ two words jvalue\n-\n-      __ bind(valsize_known);\n-      \/\/ setup object pointer\n-      __ movptr(obj, Address(obj, 0));\n-#endif\n@@ -3254,1 +2799,0 @@\n-  NOT_LP64( const Address hi(obj, off, Address::times_1, 1*wordSize);)\n@@ -3260,1 +2804,1 @@\n-  const Register bc    = LP64_ONLY(c_rarg3) NOT_LP64(rcx);\n+  const Register bc    = c_rarg3;\n@@ -3363,1 +2907,0 @@\n-#ifdef _LP64\n@@ -3367,1 +2910,0 @@\n-#endif \/\/ _LP64\n@@ -3428,1 +2970,1 @@\n-  const Register scratch = LP64_ONLY(c_rarg3) NOT_LP64(rcx);\n+  const Register scratch = c_rarg3;\n@@ -3459,2 +3001,1 @@\n-    LP64_ONLY(__ load_field_entry(c_rarg2, rax));\n-    NOT_LP64(__ load_field_entry(rax, rdx));\n+    __ load_field_entry(c_rarg2, rax);\n@@ -3465,2 +3006,1 @@\n-    LP64_ONLY(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification), rbx, c_rarg2, c_rarg3));\n-    NOT_LP64(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification), rbx, rax, rcx));\n+    __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification), rbx, c_rarg2, c_rarg3);\n@@ -3529,4 +3069,0 @@\n-#ifdef _LP64\n-#else\n-  __ stop(\"should not be rewritten\");\n-#endif\n@@ -3573,2 +3109,1 @@\n-    LP64_ONLY(__ load_field_entry(c_rarg2, rcx));\n-    NOT_LP64(__ load_field_entry(rcx, rdx));\n+    __ load_field_entry(c_rarg2, rcx);\n@@ -3577,1 +3112,1 @@\n-    LP64_ONLY(__ mov(c_rarg1, rax));\n+    __ mov(c_rarg1, rax);\n@@ -3580,2 +3115,1 @@\n-    LP64_ONLY(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access), c_rarg1, c_rarg2));\n-    NOT_LP64(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access), rax, rcx));\n+    __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access), c_rarg1, c_rarg2);\n@@ -3602,4 +3136,0 @@\n-#ifdef _LP64\n-#else\n-  __ stop(\"should not be rewritten\");\n-#endif\n@@ -3711,1 +3241,0 @@\n-#ifdef _LP64\n@@ -3714,3 +3243,0 @@\n-#else\n-    __ movptr(flags, ArrayAddress(table, Address(noreg, flags, Address::times_ptr)));\n-#endif \/\/ _LP64\n@@ -3948,1 +3474,0 @@\n-#ifdef _LP64\n@@ -3953,4 +3478,0 @@\n-#else\n-  recvKlass = rdx;\n-  Register method    = rcx;\n-#endif\n@@ -3968,1 +3489,3 @@\n-  LP64_ONLY( if (recvKlass != rdx) { __ movq(recvKlass, rdx); } )\n+  if (recvKlass != rdx) {\n+    __ movq(recvKlass, rdx);\n+  }\n@@ -4051,1 +3574,0 @@\n-#ifdef _LP64\n@@ -4054,4 +3576,0 @@\n-#else\n-  __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);\n-  __ jcc(Assembler::notEqual, slow_case);\n-#endif\n@@ -4074,4 +3592,1 @@\n-  const Register thread = LP64_ONLY(r15_thread) NOT_LP64(rcx);\n-\n-    NOT_LP64(__ get_thread(thread);)\n-    __ tlab_allocate(thread, rax, rdx, 0, rcx, rbx, slow_case);\n+    __ tlab_allocate(r15_thread, rax, rdx, 0, rcx, rbx, slow_case);\n@@ -4115,1 +3630,0 @@\n-    NOT_LP64(__ movptr(Address(rax, rdx, Address::times_8, header_size_bytes - 2*oopSize), rcx));\n@@ -4130,1 +3644,0 @@\n-#ifdef _LP64\n@@ -4133,1 +3646,0 @@\n-#endif\n@@ -4153,6 +3665,3 @@\n-  Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rax);\n-  Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);\n-\n-  __ get_constant_pool(rarg1);\n-  __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);\n-  call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), rarg1, rarg2);\n+  __ get_constant_pool(c_rarg1);\n+  __ get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);\n+  call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);\n@@ -4167,2 +3676,1 @@\n-  Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rdx);\n-  __ load_unsigned_byte(rarg1, at_bcp(1));\n+  __ load_unsigned_byte(c_rarg1, at_bcp(1));\n@@ -4170,1 +3678,1 @@\n-          rarg1, rax);\n+          c_rarg1, rax);\n@@ -4176,5 +3684,2 @@\n-  Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rcx);\n-  Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);\n-\n-  __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);\n-  __ get_constant_pool(rarg1);\n+  __ get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);\n+  __ get_constant_pool(c_rarg1);\n@@ -4182,1 +3687,1 @@\n-          rarg1, rarg2, rax);\n+          c_rarg1, c_rarg2, rax);\n@@ -4209,7 +3714,0 @@\n-#ifndef _LP64\n-  \/\/ borrow rdi from locals\n-  __ get_thread(rdi);\n-  __ get_vm_result_2(rax, rdi);\n-  __ restore_locals();\n-#else\n-#endif\n@@ -4273,7 +3771,0 @@\n-#ifndef _LP64\n-  \/\/ borrow rdi from locals\n-  __ get_thread(rdi);\n-  __ get_vm_result_2(rax, rdi);\n-  __ restore_locals();\n-#else\n-#endif\n@@ -4328,3 +3819,1 @@\n-  Register rarg = LP64_ONLY(c_rarg1) NOT_LP64(rcx);\n-\n-  __ get_method(rarg);\n+  __ get_method(c_rarg1);\n@@ -4335,1 +3824,1 @@\n-             rarg, rbcp);\n+             c_rarg1, rbcp);\n@@ -4339,1 +3828,1 @@\n-  __ get_method(rarg);\n+  __ get_method(c_rarg1);\n@@ -4342,1 +3831,1 @@\n-             rarg, rbcp);\n+             c_rarg1, rbcp);\n@@ -4388,3 +3877,3 @@\n-  Register rtop = LP64_ONLY(c_rarg3) NOT_LP64(rcx);\n-  Register rbot = LP64_ONLY(c_rarg2) NOT_LP64(rbx);\n-  Register rmon = LP64_ONLY(c_rarg1) NOT_LP64(rdx);\n+  Register rtop = c_rarg3;\n+  Register rbot = c_rarg2;\n+  Register rmon = c_rarg1;\n@@ -4486,2 +3975,2 @@\n-  Register rtop = LP64_ONLY(c_rarg1) NOT_LP64(rdx);\n-  Register rbot = LP64_ONLY(c_rarg2) NOT_LP64(rbx);\n+  Register rtop = c_rarg1;\n+  Register rbot = c_rarg2;\n@@ -4541,1 +4030,0 @@\n-  Register rarg = LP64_ONLY(c_rarg1) NOT_LP64(rax);\n@@ -4546,2 +4034,2 @@\n-  __ lea(rarg, Address(rsp, rax, Interpreter::stackElementScale(), -wordSize));\n-  call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::multianewarray), rarg);\n+  __ lea(c_rarg1, Address(rsp, rax, Interpreter::stackElementScale(), -wordSize));\n+  call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::multianewarray), c_rarg1);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":62,"deletions":574,"binary":false,"changes":636,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -821,1 +821,1 @@\n-  if (C->stub_function() != nullptr && BarrierSet::barrier_set()->barrier_set_nmethod() != nullptr) {\n+  if (C->stub_function() != nullptr) {\n@@ -1550,1 +1550,5 @@\n-  return (offset < 0x80) ? 5 : 8; \/\/ REX\n+  if (ra_->get_encode(this) > 15) {\n+    return (offset < 0x80) ? 6 : 9; \/\/ REX2\n+  } else {\n+    return (offset < 0x80) ? 5 : 8; \/\/ REX\n+  }\n@@ -2385,0 +2389,10 @@\n+\/\/ Half Float Immediate\n+operand immH()\n+%{\n+  match(ConH);\n+\n+  op_cost(15);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -4370,1 +4384,1 @@\n-  ins_cost(125); \/\/ XXX\n+  ins_cost(125);\n@@ -4376,3 +4390,2 @@\n-    \/\/ The incoming address is pointing into obj-start + klass_offset_in_bytes. We need to extract\n-    \/\/ obj-start, so that we can load from the object's mark-word instead. Usually the address\n-    \/\/ comes as obj-start in obj and klass_offset_in_bytes in disp.\n+    \/\/ The incoming address is pointing into obj-start + Type::klass_offset(). We need to extract\n+    \/\/ obj-start, so that we can load from the object's mark-word instead.\n@@ -4380,3 +4393,7 @@\n-    Address  s = $mem$$Address;\n-    __ movl(d, s.plus_disp(-Type::klass_offset()));\n-    __ shrl(d, markWord::klass_shift);\n+    Address  s = ($mem$$Address).plus_disp(-Type::klass_offset());\n+    if (UseAPX) {\n+      __ eshrl(d, s, markWord::klass_shift, false);\n+    } else {\n+      __ movl(d, s);\n+      __ shrl(d, markWord::klass_shift);\n+    }\n@@ -4384,1 +4401,1 @@\n-  ins_pipe(ialu_reg_mem); \/\/ XXX\n+  ins_pipe(ialu_reg_mem);\n@@ -4848,0 +4865,10 @@\n+instruct loadConH(regF dst, immH con) %{\n+  match(Set dst con);\n+  ins_cost(125);\n+  format %{ \"movss   $dst, [$constantaddress]\\t# load from constant table: halffloat=$con\" %}\n+  ins_encode %{\n+    __ movflt($dst$$XMMRegister, $constantaddress($con));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -6124,0 +6151,1 @@\n+  predicate(!UseAPX);\n@@ -6134,0 +6162,13 @@\n+instruct cmovI_reg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr, cmpOp cop)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# signed, int ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6149,0 +6190,1 @@\n+  predicate(!UseAPX);\n@@ -6159,0 +6201,12 @@\n+instruct cmovI_regU_ndd(rRegI dst, cmpOpU cop, rFlagsRegU cr, rRegI src1, rRegI src2) %{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, int ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6174,0 +6228,1 @@\n+  predicate(!UseAPX);\n@@ -6181,0 +6236,11 @@\n+instruct cmovI_regUCF_ndd(rRegI dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegI src1, rRegI src2) %{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src1 src2)));\n+  ins_cost(200);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, int ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6182,1 +6248,1 @@\n-  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n@@ -6195,0 +6261,14 @@\n+instruct cmovI_regUCF2_ne_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegI dst, rRegI src1, rRegI src2) %{\n+  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovpl  $dst, $src1, $src2\\n\\t\"\n+            \"ecmovnel $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ ecmovl(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n+    __ ecmovl(Assembler::notEqual, $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6198,1 +6278,1 @@\n-  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n@@ -6211,0 +6291,16 @@\n+\/\/ We need this special handling for only eq \/ neq comparison since NaN == NaN is false,\n+\/\/ and parity flag bit is set if any of the operand is a NaN.\n+instruct cmovI_regUCF2_eq_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegI dst, rRegI src1, rRegI src2) %{\n+  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovpl  $dst, $src1, $src2\\n\\t\"\n+            \"ecmovnel $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ ecmovl(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n+    __ ecmovl(Assembler::notEqual, $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6213,0 +6309,1 @@\n+  predicate(!UseAPX);\n@@ -6223,0 +6320,14 @@\n+\/\/ Conditional move\n+instruct cmovI_rReg_rReg_mem_ndd(rRegI dst, cmpOp cop, rFlagsReg cr, rRegI src1, memory src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src1 (LoadI src2))));\n+\n+  ins_cost(250);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# signed, int ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n+  %}\n+  ins_pipe(pipe_cmov_mem);\n+%}\n+\n@@ -6226,0 +6337,1 @@\n+  predicate(!UseAPX);\n@@ -6237,0 +6349,1 @@\n+  predicate(!UseAPX);\n@@ -6244,0 +6357,25 @@\n+instruct cmovI_rReg_rReg_memU_ndd(rRegI dst, cmpOpU cop, rFlagsRegU cr, rRegI src1, memory src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src1 (LoadI src2))));\n+\n+  ins_cost(250);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, int ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n+  %}\n+  ins_pipe(pipe_cmov_mem);\n+%}\n+\n+instruct cmovI_rReg_rReg_memUCF_ndd(rRegI dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegI src1, memory src2) \n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src1 (LoadI src2))));\n+  ins_cost(250);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, int ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n+  %}\n+  ins_pipe(pipe_cmov_mem);\n+%}\n+\n@@ -6247,0 +6385,1 @@\n+  predicate(!UseAPX);\n@@ -6257,0 +6396,14 @@\n+\/\/ Conditional move ndd\n+instruct cmovN_reg_ndd(rRegN dst, rRegN src1, rRegN src2, rFlagsReg cr, cmpOp cop)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveN (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# signed, compressed ptr ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6260,0 +6413,1 @@\n+  predicate(!UseAPX);\n@@ -6271,0 +6425,1 @@\n+  predicate(!UseAPX);\n@@ -6278,0 +6433,25 @@\n+\/\/ Conditional move ndd\n+instruct cmovN_regU_ndd(rRegN dst, cmpOpU cop, rFlagsRegU cr, rRegN src1, rRegN src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveN (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, compressed ptr ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovN_regUCF_ndd(rRegN dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegN src1, rRegN src2) %{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveN (Binary cop cr) (Binary src1 src2)));\n+  ins_cost(200);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, compressed ptr ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6311,0 +6491,1 @@\n+  predicate(!UseAPX);\n@@ -6321,0 +6502,14 @@\n+\/\/ Conditional move ndd\n+instruct cmovP_reg_ndd(rRegP dst, rRegP src1, rRegP src2, rFlagsReg cr, cmpOp cop)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveP (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# signed, ptr ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6324,0 +6519,1 @@\n+  predicate(!UseAPX);\n@@ -6334,0 +6530,14 @@\n+\/\/ Conditional move ndd\n+instruct cmovP_regU_ndd(rRegP dst, cmpOpU cop, rFlagsRegU cr, rRegP src1, rRegP src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveP (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, ptr ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6342,0 +6552,10 @@\n+instruct cmovP_regUCF_ndd(rRegP dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegP src1, rRegP src2) %{\n+  match(Set dst (CMoveP (Binary cop cr) (Binary src1 src2)));\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, ptr ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6343,1 +6563,1 @@\n-  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n@@ -6356,0 +6576,14 @@\n+instruct cmovP_regUCF2_ne_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegP dst, rRegP src1, rRegP src2) %{\n+  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  match(Set dst (CMoveP (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovpq  $dst, $src1, $src2\\n\\t\"\n+            \"ecmovneq $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ ecmovq(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n+    __ ecmovq(Assembler::notEqual, $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6359,1 +6593,1 @@\n-  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n@@ -6372,0 +6606,14 @@\n+instruct cmovP_regUCF2_eq_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegP dst, rRegP src1, rRegP src2) %{\n+  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  match(Set dst (CMoveP (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovpq  $dst, $src1, $src2\\n\\t\"\n+            \"ecmovneq $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ ecmovq(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n+    __ ecmovq(Assembler::notEqual, $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6388,0 +6636,1 @@\n+  predicate(!UseAPX);\n@@ -6398,0 +6647,13 @@\n+instruct cmovL_reg_ndd(rRegL dst, cmpOp cop, rFlagsReg cr, rRegL src1, rRegL src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# signed, long ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6400,0 +6662,1 @@\n+  predicate(!UseAPX);\n@@ -6410,0 +6673,13 @@\n+instruct cmovL_rReg_rReg_mem_ndd(rRegL dst, cmpOp cop, rFlagsReg cr, rRegL src1, memory src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src1 (LoadL src2))));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# signed, long ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n+  %}\n+  ins_pipe(pipe_cmov_mem);\n+%}\n+\n@@ -6426,0 +6702,1 @@\n+  predicate(!UseAPX);\n@@ -6436,0 +6713,13 @@\n+instruct cmovL_regU_ndd(rRegL dst, cmpOpU cop, rFlagsRegU cr, rRegL src1, rRegL src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, long ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6451,0 +6741,1 @@\n+  predicate(!UseAPX);\n@@ -6458,0 +6749,12 @@\n+instruct cmovL_regUCF_ndd(rRegL dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegL src1, rRegL src2) \n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src1 src2)));\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, long ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6459,1 +6762,1 @@\n-  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n@@ -6472,0 +6775,14 @@\n+instruct cmovL_regUCF2_ne_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegL dst, rRegL src1, rRegL src2) %{\n+  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovpq  $dst, $src1, $src2\\n\\t\"\n+            \"ecmovneq $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ ecmovq(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n+    __ ecmovq(Assembler::notEqual, $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6475,1 +6792,1 @@\n-  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n@@ -6488,0 +6805,14 @@\n+instruct cmovL_regUCF2_eq_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegL dst, rRegL src1, rRegL src2) %{\n+  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovpq  $dst, $src1, $src2\\n\\t\"\n+            \"ecmovneq $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ ecmovq(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n+    __ ecmovq(Assembler::notEqual, $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6490,0 +6821,1 @@\n+  predicate(!UseAPX);\n@@ -6501,0 +6833,1 @@\n+  predicate(!UseAPX);\n@@ -6508,0 +6841,25 @@\n+instruct cmovL_rReg_rReg_memU_ndd(rRegL dst, cmpOpU cop, rFlagsRegU cr, rRegL src1, memory src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src1 (LoadL src2))));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, long ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n+  %}\n+  ins_pipe(pipe_cmov_mem);\n+%}\n+\n+instruct cmovL_rReg_rReg_memUCF_ndd(rRegL dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegL src1, memory src2) \n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src1 (LoadL src2))));\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, long ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n+  %}\n+  ins_pipe(pipe_cmov_mem);\n+%}\n+\n@@ -6601,0 +6959,1 @@\n+  predicate(!UseAPX);\n@@ -6611,0 +6970,14 @@\n+instruct addI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"eaddl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eaddl($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -6613,0 +6986,1 @@\n+  predicate(!UseAPX);\n@@ -6624,0 +6998,28 @@\n+instruct addI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"eaddl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eaddl($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+instruct addI_rReg_mem_imm_ndd(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddI (LoadI src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"eaddl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eaddl($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n@@ -6626,0 +7028,1 @@\n+  predicate(!UseAPX);\n@@ -6638,0 +7041,30 @@\n+instruct addI_rReg_mem_rReg_ndd(rRegI dst, memory src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddI (LoadI src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eaddl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eaddl($dst$$Register, $src1$$Address, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct addI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddI src1 (LoadI src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eaddl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eaddl($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -6669,1 +7102,1 @@\n-  predicate(UseIncDec);\n+  predicate(!UseAPX && UseIncDec);\n@@ -6680,1 +7113,1 @@\n-instruct incI_mem(memory dst, immI_1 src, rFlagsReg cr)\n+instruct incI_rReg_ndd(rRegI dst, rRegI src, immI_1 val, rFlagsReg cr)\n@@ -6682,1 +7115,27 @@\n-  predicate(UseIncDec);\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddI src val));\n+  effect(KILL cr);\n+\n+  format %{ \"eincl    $dst, $src\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eincl($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct incI_rReg_mem_ndd(rRegI dst, memory src, immI_1 val, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddI (LoadI src) val));\n+  effect(KILL cr);\n+\n+  format %{ \"eincl    $dst, $src\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eincl($dst$$Register, $src$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct incI_mem(memory dst, immI_1 src, rFlagsReg cr)\n+%{\n+  predicate(UseIncDec);\n@@ -6697,1 +7156,1 @@\n-  predicate(UseIncDec);\n+  predicate(!UseAPX && UseIncDec);\n@@ -6708,0 +7167,26 @@\n+instruct decI_rReg_ndd(rRegI dst, rRegI src, immI_M1 val, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddI src val));\n+  effect(KILL cr);\n+\n+  format %{ \"edecl    $dst, $src\\t# int ndd\" %}\n+  ins_encode %{\n+    __ edecl($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct decI_rReg_mem_ndd(rRegI dst, memory src, immI_M1 val, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddI (LoadI src) val));\n+  effect(KILL cr);\n+\n+  format %{ \"edecl    $dst, $src\\t# int ndd\" %}\n+  ins_encode %{\n+    __ edecl($dst$$Register, $src$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -6776,0 +7261,1 @@\n+  predicate(!UseAPX);\n@@ -6787,0 +7273,14 @@\n+instruct addL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"eaddq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eaddq($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -6789,0 +7289,1 @@\n+  predicate(!UseAPX);\n@@ -6800,0 +7301,28 @@\n+instruct addL_rReg_rReg_imm_ndd(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"eaddq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eaddq($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+instruct addL_rReg_mem_imm_ndd(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"eaddq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eaddq($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n@@ -6802,0 +7331,1 @@\n+  predicate(!UseAPX);\n@@ -6814,0 +7344,30 @@\n+instruct addL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddL src1 (LoadL src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eaddq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eaddq($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct addL_rReg_mem_rReg_ndd(rRegL dst, memory src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eaddq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eaddq($dst$$Register, $src1$$Address, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -6844,1 +7404,1 @@\n-  predicate(UseIncDec);\n+  predicate(!UseAPX && UseIncDec);\n@@ -6855,0 +7415,26 @@\n+instruct incL_rReg_ndd(rRegI dst, rRegI src, immL1 val, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddL src val));\n+  effect(KILL cr);\n+\n+  format %{ \"eincq    $dst, $src\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eincq($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct incL_rReg_mem_ndd(rRegI dst, memory src, immL1 val, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddL (LoadL src) val));\n+  effect(KILL cr);\n+\n+  format %{ \"eincq    $dst, $src\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eincq($dst$$Register, $src$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -6872,1 +7458,1 @@\n-  predicate(UseIncDec);\n+  predicate(!UseAPX && UseIncDec);\n@@ -6883,0 +7469,26 @@\n+instruct decL_rReg_ndd(rRegL dst, rRegL src, immL_M1 val, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddL src val));\n+  effect(KILL cr);\n+\n+  format %{ \"edecq    $dst, $src\\t# long ndd\" %}\n+  ins_encode %{\n+    __ edecq($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct decL_rReg_mem_ndd(rRegL dst, memory src, immL_M1 val, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddL (LoadL src) val));\n+  effect(KILL cr);\n+\n+  format %{ \"edecq    $dst, $src\\t# long ndd\" %}\n+  ins_encode %{\n+    __ edecq($dst$$Register, $src$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -7030,0 +7642,11 @@\n+instruct castHH(regF dst)\n+%{\n+  match(Set dst (CastHH dst));\n+\n+  size(0);\n+  format %{ \"# castHH of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(empty);\n+%}\n+\n@@ -7507,0 +8130,1 @@\n+  predicate(!UseAPX);\n@@ -7518,0 +8142,42 @@\n+instruct subI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"esubl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ esubl($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct subI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"esubl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ esubl($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct subI_rReg_mem_imm_ndd(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubI (LoadI src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"esubl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ esubl($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -7520,0 +8186,1 @@\n+  predicate(!UseAPX);\n@@ -7532,0 +8199,30 @@\n+instruct subI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubI src1 (LoadI src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"esubl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ esubl($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct subI_rReg_mem_rReg_ndd(rRegI dst, memory src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubI (LoadI src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"esubl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ esubl($dst$$Register, $src1$$Address, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -7548,0 +8245,1 @@\n+  predicate(!UseAPX);\n@@ -7559,0 +8257,42 @@\n+instruct subL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"esubq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ esubq($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct subL_rReg_rReg_imm_ndd(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"esubq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ esubq($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct subL_rReg_mem_imm_ndd(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"esubq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ esubq($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -7561,0 +8301,1 @@\n+  predicate(!UseAPX);\n@@ -7573,0 +8314,30 @@\n+instruct subL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubL src1 (LoadL src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"esubq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ esubq($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct subL_rReg_mem_rReg_ndd(rRegL dst, memory src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"esubq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ esubq($dst$$Register, $src1$$Address, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -7603,0 +8374,1 @@\n+  predicate(!UseAPX);\n@@ -7614,0 +8386,14 @@\n+instruct negI_rReg_ndd(rRegI dst, rRegI src, immI_0 zero, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubI zero src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"enegl    $dst, $src\\t# int ndd\" %}\n+  ins_encode %{\n+    __ enegl($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -7616,0 +8402,1 @@\n+  predicate(!UseAPX);\n@@ -7627,0 +8414,14 @@\n+instruct negI_rReg_2_ndd(rRegI dst, rRegI src, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (NegI src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"enegl    $dst, $src\\t# int ndd\" %}\n+  ins_encode %{\n+    __ enegl($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -7642,0 +8443,1 @@\n+  predicate(!UseAPX);\n@@ -7653,0 +8455,14 @@\n+instruct negL_rReg_ndd(rRegL dst, rRegL src, immL0 zero, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubL zero src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"enegq    $dst, $src\\t# long ndd\" %}\n+  ins_encode %{\n+    __ enegq($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -7655,0 +8471,1 @@\n+  predicate(!UseAPX);\n@@ -7666,0 +8483,14 @@\n+instruct negL_rReg_2_ndd(rRegL dst, rRegL src, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (NegL src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"enegq    $dst, $src\\t# long ndd\" %}\n+  ins_encode %{\n+    __ enegq($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -7685,0 +8516,1 @@\n+  predicate(!UseAPX);\n@@ -7696,0 +8528,14 @@\n+instruct mulI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MulI src1 src2));\n+  effect(KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"eimull   $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eimull($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n@@ -7698,0 +8544,1 @@\n+  predicate(!UseAPX);\n@@ -7709,0 +8556,14 @@\n+instruct mulI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MulI src1 src2));\n+  effect(KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"eimull   $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eimull($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n@@ -7711,0 +8572,1 @@\n+  predicate(!UseAPX);\n@@ -7722,0 +8584,14 @@\n+instruct mulI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MulI src1 (LoadI src2)));\n+  effect(KILL cr);\n+\n+  ins_cost(350);\n+  format %{ \"eimull   $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eimull($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem_alu0);\n+%}\n+\n@@ -7724,0 +8600,1 @@\n+  predicate(!UseAPX);\n@@ -7735,0 +8612,14 @@\n+instruct mulI_rReg_mem_imm(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MulI (LoadI src1) src2));\n+  effect(KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"eimull   $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eimull($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg_mem_alu0);\n+%}\n+\n@@ -7747,0 +8638,1 @@\n+  predicate(!UseAPX);\n@@ -7758,0 +8650,14 @@\n+instruct mulL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MulL src1 src2));\n+  effect(KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"eimulq   $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eimulq($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n@@ -7760,0 +8666,1 @@\n+  predicate(!UseAPX);\n@@ -7771,0 +8678,14 @@\n+instruct mulL_rReg_rReg_imm_ndd(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MulL src1 src2));\n+  effect(KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"eimulq   $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eimulq($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n@@ -7773,0 +8694,1 @@\n+  predicate(!UseAPX);\n@@ -7784,0 +8706,14 @@\n+instruct mulL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MulL src1 (LoadL src2)));\n+  effect(KILL cr);\n+\n+  ins_cost(350);\n+  format %{ \"eimulq   $dst, $src1, $src2 \\t# long\" %}\n+  ins_encode %{\n+    __ eimulq($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem_alu0);\n+%}\n+\n@@ -7786,0 +8722,1 @@\n+  predicate(!UseAPX);\n@@ -7790,1 +8727,15 @@\n-  format %{ \"imulq   $dst, $src, $imm\\t# long\" %}\n+  format %{ \"imulq   $dst, $src, $imm\\t# long\" %}\n+  ins_encode %{\n+    __ imulq($dst$$Register, $src$$Address, $imm$$constant);\n+  %}\n+  ins_pipe(ialu_reg_mem_alu0);\n+%}\n+\n+instruct mulL_rReg_mem_imm_ndd(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MulL (LoadL src1) src2));\n+  effect(KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"eimulq   $dst, $src1, $src2\\t# long ndd\" %}\n@@ -7792,1 +8743,1 @@\n-    __ imulq($dst$$Register, $src$$Address, $imm$$constant);\n+    __ eimulq($dst$$Register, $src1$$Address, $src2$$constant, false);\n@@ -8032,0 +8983,1 @@\n+  predicate(!UseAPX);\n@@ -8042,0 +8994,14 @@\n+\/\/ Shift Left by one, two, three\n+instruct salI_rReg_immI2_ndd(rRegI dst, rRegI src, immI2 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (LShiftI src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esall    $dst, $src, $shift\\t# int(ndd)\" %}\n+  ins_encode %{\n+    __ esall($dst$$Register, $src$$Register, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -8045,0 +9011,1 @@\n+  predicate(!UseAPX);\n@@ -8055,0 +9022,27 @@\n+\/\/ Shift Left by 8-bit immediate\n+instruct salI_rReg_imm_ndd(rRegI dst, rRegI src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (LShiftI src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esall    $dst, $src, $shift\\t# int (ndd)\" %}\n+  ins_encode %{\n+    __ esall($dst$$Register, $src$$Register, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct salI_rReg_mem_imm_ndd(rRegI dst, memory src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (LShiftI (LoadI src) shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esall    $dst, $src, $shift\\t# int (ndd)\" %}\n+  ins_encode %{\n+    __ esall($dst$$Register, $src$$Address, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -8123,0 +9117,1 @@\n+  predicate(!UseAPX);\n@@ -8133,0 +9128,27 @@\n+\/\/ Arithmetic Shift Right by 8-bit immediate\n+instruct sarI_rReg_imm_ndd(rRegI dst, rRegI src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (RShiftI src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esarl    $dst, $src, $shift\\t# int (ndd)\" %}\n+  ins_encode %{\n+    __ esarl($dst$$Register, $src$$Register, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+instruct sarI_rReg_mem_imm_ndd(rRegI dst, memory src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (RShiftI (LoadI src) shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esarl    $dst, $src, $shift\\t# int (ndd)\" %}\n+  ins_encode %{\n+    __ esarl($dst$$Register, $src$$Address, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n@@ -8201,0 +9223,1 @@\n+  predicate(!UseAPX);\n@@ -8211,0 +9234,27 @@\n+\/\/ Logical Shift Right by 8-bit immediate\n+instruct shrI_rReg_imm_ndd(rRegI dst, rRegI src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (URShiftI src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"eshrl    $dst, $src, $shift\\t # int (ndd)\" %}\n+  ins_encode %{\n+    __ eshrl($dst$$Register, $src$$Register, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct shrI_rReg_mem_imm_ndd(rRegI dst, memory src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (URShiftI (LoadI src) shift));\n+  effect(KILL cr);\n+\n+  format %{ \"eshrl    $dst, $src, $shift\\t # int (ndd)\" %}\n+  ins_encode %{\n+    __ eshrl($dst$$Register, $src$$Address, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -8280,0 +9330,1 @@\n+  predicate(!UseAPX);\n@@ -8290,0 +9341,14 @@\n+\/\/ Shift Left by one, two, three\n+instruct salL_rReg_immI2_ndd(rRegL dst, rRegL src, immI2 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (LShiftL src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esalq    $dst, $src, $shift\\t# long (ndd)\" %}\n+  ins_encode %{\n+    __ esalq($dst$$Register, $src$$Register, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -8293,0 +9358,1 @@\n+  predicate(!UseAPX);\n@@ -8303,0 +9369,27 @@\n+\/\/ Shift Left by 8-bit immediate\n+instruct salL_rReg_imm_ndd(rRegL dst, rRegL src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (LShiftL src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esalq    $dst, $src, $shift\\t# long (ndd)\" %}\n+  ins_encode %{\n+    __ esalq($dst$$Register, $src$$Register, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct salL_rReg_mem_imm_ndd(rRegL dst, memory src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (LShiftL (LoadL src) shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esalq    $dst, $src, $shift\\t# long (ndd)\" %}\n+  ins_encode %{\n+    __ esalq($dst$$Register, $src$$Address, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -8371,0 +9464,1 @@\n+  predicate(!UseAPX);\n@@ -8381,0 +9475,27 @@\n+\/\/ Arithmetic Shift Right by 8-bit immediate\n+instruct sarL_rReg_imm_ndd(rRegL dst, rRegL src, immI shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (RShiftL src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esarq    $dst, $src, $shift\\t# long (ndd)\" %}\n+  ins_encode %{\n+    __ esarq($dst$$Register, $src$$Register, (unsigned char)($shift$$constant & 0x3F), false);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+instruct sarL_rReg_mem_imm_ndd(rRegL dst, memory src, immI shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (RShiftL (LoadL src) shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esarq    $dst, $src, $shift\\t# long (ndd)\" %}\n+  ins_encode %{\n+    __ esarq($dst$$Register, $src$$Address, (unsigned char)($shift$$constant & 0x3F), false);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n@@ -8449,0 +9570,1 @@\n+  predicate(!UseAPX);\n@@ -8459,0 +9581,27 @@\n+\/\/ Logical Shift Right by 8-bit immediate\n+instruct shrL_rReg_imm_ndd(rRegL dst, rRegL src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (URShiftL src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"eshrq    $dst, $src, $shift\\t# long (ndd)\" %}\n+  ins_encode %{\n+    __ eshrq($dst$$Register, $src$$Register, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct shrL_rReg_mem_imm_ndd(rRegL dst, memory src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (URShiftL (LoadL src) shift));\n+  effect(KILL cr);\n+\n+  format %{ \"eshrq    $dst, $src, $shift\\t# long (ndd)\" %}\n+  ins_encode %{\n+    __ eshrq($dst$$Register, $src$$Address, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -8567,1 +9716,1 @@\n-  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n+  predicate(!UseAPX && VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n@@ -8593,1 +9742,1 @@\n-  predicate(n->bottom_type()->basic_type() == T_INT);\n+  predicate(!UseAPX && n->bottom_type()->basic_type() == T_INT);\n@@ -8603,0 +9752,14 @@\n+\/\/ Rotate Left by variable\n+instruct rolI_rReg_Var_ndd(rRegI dst, rRegI src, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && n->bottom_type()->basic_type() == T_INT);\n+  match(Set dst (RotateLeft src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"eroll    $dst, $src, $shift\\t# rotate left (int ndd)\" %}\n+  ins_encode %{\n+    __ eroll($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -8619,1 +9782,1 @@\n-  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n+  predicate(!UseAPX && VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n@@ -8643,1 +9806,1 @@\n-  predicate(n->bottom_type()->basic_type() == T_INT);\n+  predicate(!UseAPX && n->bottom_type()->basic_type() == T_INT);\n@@ -8653,0 +9816,14 @@\n+\/\/ Rotate Right by variable\n+instruct rorI_rReg_Var_ndd(rRegI dst, rRegI src, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && n->bottom_type()->basic_type() == T_INT);\n+  match(Set dst (RotateRight src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"erorl    $dst, $src, $shift\\t# rotate right(int ndd)\" %}\n+  ins_encode %{\n+    __ erorl($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -8668,1 +9845,1 @@\n-  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_LONG);\n+  predicate(!UseAPX && VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_LONG);\n@@ -8694,1 +9871,1 @@\n-  predicate(n->bottom_type()->basic_type() == T_LONG);\n+  predicate(!UseAPX && n->bottom_type()->basic_type() == T_LONG);\n@@ -8704,0 +9881,14 @@\n+\/\/ Rotate Left by variable\n+instruct rolL_rReg_Var_ndd(rRegL dst, rRegL src, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && n->bottom_type()->basic_type() == T_LONG);\n+  match(Set dst (RotateLeft src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"erolq    $dst, $src, $shift\\t# rotate left(long ndd)\" %}\n+  ins_encode %{\n+    __ erolq($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -8744,1 +9935,1 @@\n-  predicate(n->bottom_type()->basic_type() == T_LONG);\n+  predicate(!UseAPX && n->bottom_type()->basic_type() == T_LONG);\n@@ -8754,0 +9945,14 @@\n+\/\/ Rotate Right by variable\n+instruct rorL_rReg_Var_ndd(rRegL dst, rRegL src, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && n->bottom_type()->basic_type() == T_LONG);\n+  match(Set dst (RotateRight src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"erorq    $dst, $src, $shift\\t# rotate right(long ndd)\" %}\n+  ins_encode %{\n+    __ erorq($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -8805,0 +10010,1 @@\n+  predicate(!UseAPX);\n@@ -8816,0 +10022,16 @@\n+\/\/ And Register with Register using New Data Destination (NDD)\n+instruct andI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eandl     $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eandl($dst$$Register, $src1$$Register, $src2$$Register, false);\n+\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -8882,0 +10104,1 @@\n+  predicate(!UseAPX);\n@@ -8893,0 +10116,28 @@\n+instruct andI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eandl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eandl($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct andI_rReg_mem_imm_ndd(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndI (LoadI src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eandl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eandl($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -8896,0 +10147,1 @@\n+  predicate(!UseAPX);\n@@ -8908,0 +10160,15 @@\n+instruct andI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndI src1 (LoadI src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eandl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eandl($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -9080,0 +10347,1 @@\n+  predicate(!UseAPX);\n@@ -9091,0 +10359,15 @@\n+\/\/ Or Register with Register using New Data Destination (NDD)\n+instruct orI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorl     $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eorl($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -9094,1 +10377,44 @@\n-  match(Set dst (OrI dst src));\n+  predicate(!UseAPX);\n+  match(Set dst (OrI dst src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"orl     $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ orl($dst$$Register, $src$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct orI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorl     $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eorl($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct orI_rReg_imm_rReg_ndd(rRegI dst, immI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorl     $dst, $src2, $src1\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eorl($dst$$Register, $src2$$Register, $src1$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct orI_rReg_mem_imm_ndd(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrI (LoadI src1) src2));\n@@ -9098,1 +10424,1 @@\n-  format %{ \"orl     $dst, $src\\t# int\" %}\n+  format %{ \"eorl     $dst, $src1, $src2\\t# int ndd\" %}\n@@ -9100,1 +10426,1 @@\n-    __ orl($dst$$Register, $src$$constant);\n+    __ eorl($dst$$Register, $src1$$Address, $src2$$constant, false);\n@@ -9108,0 +10434,1 @@\n+  predicate(!UseAPX);\n@@ -9120,0 +10447,15 @@\n+instruct orI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrI src1 (LoadI src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eorl     $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eorl($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -9168,0 +10510,1 @@\n+  predicate(!UseAPX);\n@@ -9179,0 +10522,15 @@\n+\/\/ Xor Register with Register using New Data Destination (NDD)\n+instruct xorI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"exorl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ exorl($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -9180,1 +10538,3 @@\n-instruct xorI_rReg_im1(rRegI dst, immI_M1 imm) %{\n+instruct xorI_rReg_im1(rRegI dst, immI_M1 imm)\n+%{\n+  predicate(!UseAPX);\n@@ -9183,1 +10543,1 @@\n-  format %{ \"not    $dst\" %}\n+  format %{ \"notl    $dst\" %}\n@@ -9190,0 +10550,12 @@\n+instruct xorI_rReg_im1_ndd(rRegI dst, rRegI src, immI_M1 imm)\n+%{\n+  match(Set dst (XorI src imm));\n+  predicate(UseAPX);\n+\n+  format %{ \"enotl    $dst, $src\" %}\n+  ins_encode %{\n+     __ enotl($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -9193,0 +10565,1 @@\n+  predicate(!UseAPX);\n@@ -9204,0 +10577,29 @@\n+instruct xorI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"exorl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ exorl($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Xor Memory with Immediate\n+instruct xorI_rReg_mem_imm_ndd(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorI (LoadI src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"exorl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ exorl($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -9207,0 +10609,1 @@\n+  predicate(!UseAPX);\n@@ -9219,0 +10622,30 @@\n+instruct xorI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorI src1 (LoadI src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"exorl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ exorl($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct xorI_rReg_mem_rReg_ndd(rRegI dst, memory src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorI (LoadI src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"exorl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ exorl($dst$$Register, $src1$$Address, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -9270,0 +10703,1 @@\n+  predicate(!UseAPX);\n@@ -9281,0 +10715,16 @@\n+\/\/ And Register with Register using New Data Destination (NDD)\n+instruct andL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eandq     $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eandq($dst$$Register, $src1$$Register, $src2$$Register, false);\n+\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -9310,0 +10760,1 @@\n+  predicate(!UseAPX);\n@@ -9321,0 +10772,28 @@\n+instruct andL_rReg_rReg_imm_ndd(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eandq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eandq($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct andL_rReg_mem_imm_ndd(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eandq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eandq($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -9324,0 +10803,1 @@\n+  predicate(!UseAPX);\n@@ -9336,0 +10816,30 @@\n+instruct andL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndL src1 (LoadL src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eandq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eandq($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct andL_rReg_mem_rReg_ndd(rRegL dst, memory src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eandq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eandq($dst$$Register, $src1$$Address, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -9511,0 +11021,1 @@\n+  predicate(!UseAPX);\n@@ -9522,0 +11033,16 @@\n+\/\/ Or Register with Register using New Data Destination (NDD)\n+instruct orL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorq     $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eorq($dst$$Register, $src1$$Register, $src2$$Register, false);\n+\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -9535,0 +11062,11 @@\n+instruct orL_rReg_castP2X_ndd(rRegL dst, any_RegP src1, any_RegP src2, rFlagsReg cr) %{\n+  match(Set dst (OrL src1 (CastP2X src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorq     $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eorq($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -9539,0 +11077,1 @@\n+  predicate(!UseAPX);\n@@ -9550,0 +11089,43 @@\n+instruct orL_rReg_rReg_imm_ndd(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorq     $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eorq($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct orL_rReg_imm_rReg_ndd(rRegL dst, immL32 src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorq     $dst, $src2, $src1\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eorq($dst$$Register, $src2$$Register, $src1$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Or Memory with Immediate\n+instruct orL_rReg_mem_imm_ndd(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorq     $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eorq($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -9553,0 +11135,1 @@\n+  predicate(!UseAPX);\n@@ -9565,0 +11148,15 @@\n+instruct orL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrL src1 (LoadL src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eorq     $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eorq($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -9616,0 +11214,1 @@\n+  predicate(!UseAPX);\n@@ -9627,0 +11226,15 @@\n+\/\/ Xor Register with Register using New Data Destination (NDD)\n+instruct xorL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"exorq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ exorq($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -9628,1 +11242,3 @@\n-instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{\n+instruct xorL_rReg_im1(rRegL dst, immL_M1 imm)\n+%{\n+  predicate(!UseAPX);\n@@ -9638,0 +11254,12 @@\n+instruct xorL_rReg_im1_ndd(rRegL dst,rRegL src, immL_M1 imm)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorL src imm));\n+\n+  format %{ \"enotq   $dst, $src\" %}\n+  ins_encode %{\n+    __ enotq($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -9641,0 +11269,1 @@\n+  predicate(!UseAPX);\n@@ -9652,0 +11281,29 @@\n+instruct xorL_rReg_rReg_imm(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"exorq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ exorq($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Xor Memory with Immediate\n+instruct xorL_rReg_mem_imm(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"exorq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ exorq($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -9655,0 +11313,1 @@\n+  predicate(!UseAPX);\n@@ -9667,0 +11326,30 @@\n+instruct xorL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorL src1 (LoadL src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"exorq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ exorq($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct xorL_rReg_mem_rReg_ndd(rRegL dst, memory src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"exorq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ exorq($dst$$Register, $src1$$Address, $src1$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -11980,0 +13669,1 @@\n+  predicate(!UseAPX);\n@@ -11989,0 +13679,11 @@\n+instruct cmovI_reg_g_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  effect(DEF dst, USE src1, USE src2, USE cr);\n+\n+  format %{ \"ecmovlgt $dst, $src1, $src2\\t# min ndd\" %}\n+  ins_encode %{\n+    __ ecmovl(Assembler::greater, $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n@@ -11992,0 +13693,1 @@\n+  predicate(!UseAPX);\n@@ -12002,0 +13704,14 @@\n+instruct minI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MinI src1 src2));\n+  effect(DEF dst, USE src1, USE src2);\n+\n+  ins_cost(200);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_rReg(cr, src1, src2);\n+    cmovI_reg_g_ndd(dst, src1, src2, cr);\n+  %}\n+%}\n+\n@@ -12004,0 +13720,1 @@\n+  predicate(!UseAPX);\n@@ -12013,0 +13730,11 @@\n+instruct cmovI_reg_l_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  effect(DEF dst, USE src1, USE src2, USE cr);\n+\n+  format %{ \"ecmovllt $dst, $src1, $src2\\t# max ndd\" %}\n+  ins_encode %{\n+    __ ecmovl(Assembler::less, $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n@@ -12016,0 +13744,1 @@\n+  predicate(!UseAPX);\n@@ -12026,0 +13755,14 @@\n+instruct maxI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MaxI src1 src2));\n+  effect(DEF dst, USE src1, USE src2);\n+\n+  ins_cost(200);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_rReg(cr, src1, src2);\n+    cmovI_reg_l_ndd(dst, src1, src2, cr);\n+  %}\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":1781,"deletions":38,"binary":false,"changes":1819,"status":"modified"},{"patch":"@@ -156,1 +156,0 @@\n-  _num_dump_regions_used(0),\n@@ -164,0 +163,1 @@\n+  _pz_region(\"pz\", MAX_SHARED_DELTA), \/\/ protection zone -- used only during dumping; does NOT exist in cds archive.\n@@ -326,2 +326,6 @@\n-  _current_dump_region = &_rw_region;\n-  _num_dump_regions_used = 1;\n+\n+  if (CDSConfig::is_dumping_static_archive()) {\n+    _current_dump_region = &_pz_region;\n+  } else {\n+    _current_dump_region = &_rw_region;\n+  }\n@@ -369,1 +373,2 @@\n-    rw_region()->allocate(16);\n+    _pz_region.allocate(MetaspaceShared::protection_zone_size());\n+    start_dump_region(&_rw_region);\n@@ -510,1 +515,1 @@\n-    if (MetaspaceShared::is_shared_static(bottom)) {\n+    if (CDSConfig::is_dumping_dynamic_archive() && MetaspaceShared::is_shared_static(bottom)) {\n@@ -512,1 +517,0 @@\n-      assert(CDSConfig::is_dumping_dynamic_archive(), \"sanity\");\n@@ -524,1 +528,1 @@\n-  if (MetaspaceShared::is_in_shared_metaspace(obj)) {\n+  if (CDSConfig::is_dumping_dynamic_archive() && MetaspaceShared::is_in_shared_metaspace(obj)) {\n@@ -548,1 +552,0 @@\n-  _num_dump_regions_used ++;\n@@ -790,0 +793,1 @@\n+    bool inited = false;\n@@ -814,1 +818,1 @@\n-      bool inited = ik->has_aot_initialized_mirror();\n+      inited = ik->has_aot_initialized_mirror();\n@@ -837,1 +841,1 @@\n-        if (CDSConfig::is_dumping_invokedynamic()) {\n+        if (CDSConfig::is_dumping_method_handles()) {\n@@ -895,1 +899,5 @@\n-        inited_msg = \" inited\";\n+        if (InstanceKlass::cast(k)->static_field_size() == 0) {\n+          inited_msg = \" inited (no static fields)\";\n+        } else {\n+          inited_msg = \" inited\";\n+        }\n@@ -1541,0 +1549,1 @@\n+    log_info(cds)(\"Full module graph = %s\", CDSConfig::is_dumping_full_module_graph() ? \"enabled\" : \"disabled\");\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":20,"deletions":11,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/aotClassLocation.hpp\"\n@@ -140,1 +141,1 @@\n-GrowableArrayCHeap<OopHandle, mtClassShared>* HeapShared::_root_segments;\n+GrowableArrayCHeap<OopHandle, mtClassShared>* HeapShared::_root_segments = nullptr;\n@@ -143,2 +144,1 @@\n-MetaspaceObjToOopHandleTable* HeapShared::_scratch_java_mirror_table = nullptr;\n-MetaspaceObjToOopHandleTable* HeapShared::_scratch_references_table = nullptr;\n+MetaspaceObjToOopHandleTable* HeapShared::_scratch_objects_table = nullptr;\n@@ -228,4 +228,0 @@\n-  if (_pending_roots == nullptr) {\n-    _pending_roots = new GrowableArrayCHeap<oop, mtClassShared>(500);\n-  }\n-\n@@ -291,1 +287,1 @@\n-bool HeapShared::archive_object(oop obj, KlassSubGraphInfo* subgraph_info) {\n+bool HeapShared::archive_object(oop obj, oop referrer, KlassSubGraphInfo* subgraph_info) {\n@@ -307,1 +303,1 @@\n-    CachedOopInfo info = make_cached_oop_info(obj);\n+    CachedOopInfo info = make_cached_oop_info(obj, referrer);\n@@ -339,0 +335,6 @@\n+      } else if (java_lang_invoke_ResolvedMethodName::is_instance(obj)) {\n+        Method* m = java_lang_invoke_ResolvedMethodName::vmtarget(obj);\n+        if (m != nullptr) {\n+          InstanceKlass* method_holder = m->method_holder();\n+          AOTArtifactFinder::add_cached_class(method_holder);\n+        }\n@@ -395,1 +397,1 @@\n-    _scratch_references_table->set_oop(src, dest);\n+    _scratch_objects_table->set_oop(src, dest);\n@@ -400,1 +402,1 @@\n-  return (objArrayOop)_scratch_references_table->get_oop(src);\n+  return (objArrayOop)_scratch_objects_table->get_oop(src);\n@@ -403,1 +405,6 @@\n-void HeapShared::init_scratch_objects(TRAPS) {\n+void HeapShared::init_dumping() {\n+  _scratch_objects_table = new (mtClass)MetaspaceObjToOopHandleTable();\n+  _pending_roots = new GrowableArrayCHeap<oop, mtClassShared>(500);\n+}\n+\n+void HeapShared::init_scratch_objects_for_basic_type_mirrors(TRAPS) {\n@@ -411,2 +418,0 @@\n-  _scratch_java_mirror_table = new (mtClass)MetaspaceObjToOopHandleTable();\n-  _scratch_references_table = new (mtClass)MetaspaceObjToOopHandleTable();\n@@ -447,1 +452,1 @@\n-  return _scratch_java_mirror_table->get_oop(k);\n+  return _scratch_objects_table->get_oop(k);\n@@ -451,1 +456,1 @@\n-  _scratch_java_mirror_table->set_oop(k, mirror);\n+  _scratch_objects_table->set_oop(k, mirror);\n@@ -458,1 +463,1 @@\n-  oop mirror = _scratch_java_mirror_table->get_oop(k);\n+  oop mirror = _scratch_objects_table->get_oop(k);\n@@ -462,1 +467,1 @@\n-  _scratch_java_mirror_table->remove_oop(k);\n+  _scratch_objects_table->remove_oop(k);\n@@ -464,1 +469,1 @@\n-    _scratch_references_table->remove(InstanceKlass::cast(k)->constants());\n+    _scratch_objects_table->remove(InstanceKlass::cast(k)->constants());\n@@ -491,1 +496,1 @@\n-  return CDSConfig::is_dumping_invokedynamic() &&\n+  return CDSConfig::is_dumping_method_handles() &&\n@@ -566,1 +571,1 @@\n-  if (log_is_enabled(Info, cds, init)) {\n+  if (log_is_enabled(Debug, cds, init)) {\n@@ -797,1 +802,3 @@\n-    if (CDSConfig::is_dumping_invokedynamic()) {\n+    if (CDSConfig::is_dumping_method_handles()) {\n+      \/\/ -XX:AOTInitTestClass must be used carefully in regression tests to\n+      \/\/ include only classes that are safe to aot-initialize.\n@@ -799,1 +806,2 @@\n-             HeapShared::is_lambda_proxy_klass(ik),\n+             HeapShared::is_lambda_proxy_klass(ik) ||\n+             AOTClassInitializer::has_test_class(),\n@@ -844,0 +852,7 @@\n+#ifndef PRODUCT\n+  if (AOTClassInitializer::has_test_class()) {\n+    \/\/ The tests can cache arbitrary types of objects.\n+    return;\n+  }\n+#endif\n+\n@@ -850,1 +865,1 @@\n-  if (CDSConfig::is_dumping_invokedynamic()) {\n+  if (CDSConfig::is_dumping_method_handles()) {\n@@ -1123,1 +1138,1 @@\n-  if (CDSConfig::is_loading_invokedynamic() || CDSConfig::is_dumping_invokedynamic()) {\n+  if (CDSConfig::is_using_aot_linked_classes() || CDSConfig::is_dumping_method_handles()) {\n@@ -1190,1 +1205,1 @@\n-      ClassLoaderExt::num_module_paths() > 0) {\n+      AOTClassLocationConfig::runtime()->num_module_paths() > 0) {\n@@ -1194,1 +1209,2 @@\n-                        BOOL_TO_STR(CDSConfig::is_using_optimized_module_handling()), ClassLoaderExt::num_module_paths());\n+                        BOOL_TO_STR(CDSConfig::is_using_optimized_module_handling()),\n+                        AOTClassLocationConfig::runtime()->num_module_paths());\n@@ -1366,1 +1382,4 @@\n-class WalkOopAndArchiveClosure: public BasicOopIterateClosure {\n+\/\/ Push all oops that are referenced by _referencing_obj onto the _stack.\n+class HeapShared::ReferentPusher: public BasicOopIterateClosure {\n+  PendingOopStack* _stack;\n+  GrowableArray<oop> _found_oop_fields;\n@@ -1371,6 +1390,2 @@\n-\n-  \/\/ The following are for maintaining a stack for determining\n-  \/\/ CachedOopInfo::_referrer\n-  static WalkOopAndArchiveClosure* _current;\n-  WalkOopAndArchiveClosure* _last;\n-  WalkOopAndArchiveClosure(int level,\n+  ReferentPusher(PendingOopStack* stack,\n+                           int level,\n@@ -1381,0 +1396,2 @@\n+    _stack(stack),\n+    _found_oop_fields(),\n@@ -1385,4 +1402,11 @@\n-    _last = _current;\n-    _current = this;\n-  ~WalkOopAndArchiveClosure() {\n-    _current = _last;\n+  void do_oop(narrowOop *p) { ReferentPusher::do_oop_work(p); }\n+  void do_oop(      oop *p) { ReferentPusher::do_oop_work(p); }\n+\n+  ~ReferentPusher() {\n+    while (_found_oop_fields.length() > 0) {\n+      \/\/ This produces the exact same traversal order as the previous version\n+      \/\/ of ReferentPusher that recurses on the C stack -- a depth-first search,\n+      \/\/ walking the oop fields in _referencing_obj by ascending field offsets.\n+      oop obj = _found_oop_fields.pop();\n+      _stack->push(PendingOop(obj, _referencing_obj, _level + 1));\n+    }\n@@ -1391,2 +1415,0 @@\n-  void do_oop(narrowOop *p) { WalkOopAndArchiveClosure::do_oop_work(p); }\n-  void do_oop(      oop *p) { WalkOopAndArchiveClosure::do_oop_work(p); }\n@@ -1412,3 +1434,1 @@\n-      bool success = HeapShared::archive_reachable_objects_from(\n-          _level + 1, _subgraph_info, obj);\n-      assert(success, \"VM should have exited with unarchivable objects for _level > 1\");\n+      _found_oop_fields.push(obj);\n@@ -1419,1 +1439,0 @@\n-  static WalkOopAndArchiveClosure* current()  { return _current;              }\n@@ -1424,2 +1443,0 @@\n-WalkOopAndArchiveClosure* WalkOopAndArchiveClosure::_current = nullptr;\n-\n@@ -1441,3 +1458,1 @@\n-HeapShared::CachedOopInfo HeapShared::make_cached_oop_info(oop obj) {\n-  WalkOopAndArchiveClosure* walker = WalkOopAndArchiveClosure::current();\n-  oop referrer = (walker == nullptr) ? nullptr : walker->referencing_obj();\n+HeapShared::CachedOopInfo HeapShared::make_cached_oop_info(oop obj, oop referrer) {\n@@ -1466,1 +1481,2 @@\n-\/\/ (3) Record the klasses of all orig_obj and all reachable objects.\n+\/\/ (3) Record the klasses of all objects that are reachable from orig_obj (including those that\n+\/\/     were already archived when this function is called)\n@@ -1471,0 +1487,19 @@\n+  PendingOopStack stack;\n+  stack.push(PendingOop(orig_obj, nullptr, level));\n+\n+  while (stack.length() > 0) {\n+    PendingOop po = stack.pop();\n+    _object_being_archived = po;\n+    bool status = walk_one_object(&stack, po.level(), subgraph_info, po.obj(), po.referrer());\n+    _object_being_archived = PendingOop();\n+\n+    if (!status) {\n+      \/\/ Don't archive a subgraph root that's too big. For archives static fields, that's OK\n+      \/\/ as the Java code will take care of initializing this field dynamically.\n+      assert(level == 1, \"VM should have exited with unarchivable objects for _level > 1\");\n+      return false;\n+    }\n+  }\n+\n+  return true;\n+}\n@@ -1472,0 +1507,3 @@\n+bool HeapShared::walk_one_object(PendingOopStack* stack, int level, KlassSubGraphInfo* subgraph_info,\n+                                 oop orig_obj, oop referrer) {\n+  assert(orig_obj != nullptr, \"must be\");\n@@ -1540,1 +1578,1 @@\n-    if (!archive_object(orig_obj, subgraph_info)) {\n+    if (!archive_object(orig_obj, referrer, subgraph_info)) {\n@@ -1563,2 +1601,7 @@\n-  WalkOopAndArchiveClosure walker(level, record_klasses_only, subgraph_info, orig_obj);\n-  orig_obj->oop_iterate(&walker);\n+  {\n+    \/\/ Find all the oops that are referenced by orig_obj, push them onto the stack\n+    \/\/ so we can work on them next.\n+    ResourceMark rm;\n+    ReferentPusher pusher(stack, level, record_klasses_only, subgraph_info, orig_obj);\n+    orig_obj->oop_iterate(&pusher);\n+  }\n@@ -1589,2 +1632,1 @@\n-\/\/ The Java heap object sub-graph archiving process (see\n-\/\/ WalkOopAndArchiveClosure):\n+\/\/ The Java heap object sub-graph archiving process (see ReferentPusher):\n@@ -1738,0 +1780,1 @@\n+HeapShared::PendingOop HeapShared::_object_being_archived;\n@@ -2059,2 +2102,2 @@\n-  WalkOopAndArchiveClosure* walker = WalkOopAndArchiveClosure::current();\n-  if (walker != nullptr) {\n+  oop referrer = _object_being_archived.referrer();\n+  if (referrer != nullptr) {\n@@ -2062,1 +2105,2 @@\n-    CDSHeapVerifier::trace_to_root(&ls, walker->referencing_obj());\n+    ls.print_cr(\"Reference trace\");\n+    CDSHeapVerifier::trace_to_root(&ls, referrer);\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":102,"deletions":58,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyrigt (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n-  jobject                _protection_domain;\n@@ -71,1 +70,1 @@\n-  GrowableArray<ciField*>* _nonstatic_fields;\n+  GrowableArray<ciField*>* _nonstatic_fields;  \/\/ ordered by JavaFieldStream\n@@ -87,1 +86,1 @@\n-  ciInstanceKlass(ciSymbol* name, jobject loader, jobject protection_domain);\n+  ciInstanceKlass(ciSymbol* name, jobject loader);\n@@ -96,3 +95,0 @@\n-  oop protection_domain();\n-  jobject protection_domain_handle();\n-\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,3 +68,0 @@\n-  virtual oop protection_domain()             { return nullptr; }\n-  virtual jobject protection_domain_handle()  { return nullptr; }\n-\n@@ -128,1 +125,1 @@\n-  \/\/ Fetch Klass::modifier_flags.\n+  \/\/ Fetch modifier flags.\n","filename":"src\/hotspot\/share\/ci\/ciKlass.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3750,5 +3750,0 @@\n-  \/\/ Initialize cached modifier_flags to support Class.getModifiers().\n-  \/\/ This must follow setting inner_class attributes.\n-  u2 computed_modifiers = this_klass->compute_modifier_flags();\n-  this_klass->set_modifier_flags(computed_modifiers);\n-\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -870,0 +870,2 @@\n+int java_lang_Class::_modifiers_offset;\n+int java_lang_Class::_is_primitive_offset;\n@@ -1063,0 +1065,4 @@\n+  \/\/ Set the modifiers flag.\n+  u2 computed_modifiers = k->compute_modifier_flags();\n+  set_modifiers(mirror(), computed_modifiers);\n+\n@@ -1270,2 +1276,5 @@\n-    java_class->obj_field_put(_component_mirror_offset, comp_mirror);\n-  }\n+  assert(java_lang_Class::as_Klass(java_class) != nullptr &&\n+         java_lang_Class::as_Klass(java_class)->is_array_klass(), \"must be\");\n+  java_class->obj_field_put(_component_mirror_offset, comp_mirror);\n+}\n+\n@@ -1345,0 +1354,6 @@\n+void java_lang_Class::set_is_primitive(oop java_class) {\n+  assert(_is_primitive_offset != 0, \"must be set\");\n+  java_class->bool_field_put(_is_primitive_offset, true);\n+}\n+\n+\n@@ -1346,2 +1361,1 @@\n-  \/\/ This should be improved by adding a field at the Java level or by\n-  \/\/ introducing a new VM klass (see comment in ClassFileParser)\n+  \/\/ Mirrors for basic types have a null klass field, which makes them special.\n@@ -1358,0 +1372,2 @@\n+  set_modifiers(java_class, JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);\n+  set_is_primitive(java_class);\n@@ -1496,1 +1512,4 @@\n-  macro(_signers_offset,             k, \"signers\",             object_array_signature, false);\n+  macro(_signers_offset,             k, \"signers\",             object_array_signature, false); \\\n+  macro(_modifiers_offset,           k, vmSymbols::modifiers_name(), char_signature,    false); \\\n+  macro(_protection_domain_offset,   k, \"protectionDomain\",    java_security_ProtectionDomain_signature,  false); \\\n+  macro(_is_primitive_offset,        k, \"primitive\",           bool_signature,         false);\n@@ -1530,0 +1549,10 @@\n+int java_lang_Class::modifiers(oop the_class_mirror) {\n+  assert(_modifiers_offset != 0, \"offsets should have been initialized\");\n+  return the_class_mirror->char_field(_modifiers_offset);\n+}\n+\n+void java_lang_Class::set_modifiers(oop the_class_mirror, u2 value) {\n+  assert(_modifiers_offset != 0, \"offsets should have been initialized\");\n+  the_class_mirror->char_field_put(_modifiers_offset, value);\n+}\n+\n@@ -5426,2 +5455,2 @@\n-  if (!CDSConfig::is_dumping_invokedynamic()) {\n-    \/\/ These are supported by CDS only when CDSConfig::is_dumping_invokedynamic() is enabled.\n+  if (!CDSConfig::is_dumping_method_handles()) {\n+    \/\/ These are supported by CDS only when CDSConfig::is_dumping_method_handles() is enabled.\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":36,"deletions":7,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -231,1 +231,0 @@\n-  macro(java_lang_Class, protection_domain,      object_signature,  false) \\\n@@ -260,0 +259,2 @@\n+  static int _modifiers_offset;\n+  static int _is_primitive_offset;\n@@ -305,0 +306,1 @@\n+  static void set_is_primitive(oop java_class);\n@@ -340,0 +342,3 @@\n+  static int modifiers(oop java_class);\n+  static void set_modifiers(oop java_class, u2 value);\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -296,1 +296,1 @@\n-  \/\/assert(java_lang_Class::is_instance(java_class), \"must be a Class object\");\n+  \/\/ assert(java_lang_Class::is_instance(java_class), \"must be a Class object\");\n@@ -300,1 +300,3 @@\n-  if (is_primitive) {\n+  \/\/ The heapwalker walks through Classes that have had their Klass pointers removed, so can't assert this.\n+  \/\/ assert(is_primitive == java_class->bool_field(_is_primitive_offset), \"must match what we told Java\");\n+  if (java_class->bool_field(_is_primitive_offset)) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -253,1 +253,1 @@\n-  _heap->young_regions_cardset()->clear();\n+  _heap->young_regions_cset_group()->clear();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-    _max_num_optional_regions(collection_set->optional_region_length()),\n+    _max_num_optional_regions(collection_set->num_optional_regions()),\n@@ -620,0 +620,6 @@\n+void G1ParScanThreadState::record_evacuation_failed_region(G1HeapRegion* r, uint worker_id, bool cause_pinned) {\n+  if (_evac_failure_regions->record(worker_id, r->hrm_index(), cause_pinned)) {\n+    G1HeapRegionPrinter::evac_failure(r);\n+  }\n+}\n+\n@@ -629,3 +635,1 @@\n-    if (_evac_failure_regions->record(_worker_id, r->hrm_index(), cause_pinned)) {\n-      G1HeapRegionPrinter::evac_failure(r);\n-    }\n+    record_evacuation_failed_region(r, _worker_id, cause_pinned);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -202,0 +202,1 @@\n+  GCLocker::initialize();\n@@ -302,1 +303,0 @@\n-  uint gclocker_stalled_count = 0;\n@@ -332,27 +332,0 @@\n-\n-      if (gclocker_stalled_count > GCLockerRetryAllocationCount) {\n-        return nullptr;\n-      }\n-\n-      \/\/ Failed to allocate without a gc.\n-      if (GCLocker::is_active_and_needs_gc()) {\n-        \/\/ If this thread is not in a jni critical section, we stall\n-        \/\/ the requestor until the critical section has cleared and\n-        \/\/ GC allowed. When the critical section clears, a GC is\n-        \/\/ initiated by the last thread exiting the critical section; so\n-        \/\/ we retry the allocation sequence from the beginning of the loop,\n-        \/\/ rather than causing more, now probably unnecessary, GC attempts.\n-        JavaThread* jthr = JavaThread::current();\n-        if (!jthr->in_critical()) {\n-          MutexUnlocker mul(Heap_lock);\n-          GCLocker::stall_until_clear();\n-          gclocker_stalled_count += 1;\n-          continue;\n-        } else {\n-          if (CheckJNICalls) {\n-            fatal(\"Possible deadlock due to allocating while\"\n-                  \" in jni critical section\");\n-          }\n-          return nullptr;\n-        }\n-      }\n@@ -361,2 +334,2 @@\n-    if (result == nullptr) {\n-      \/\/ Generate a VM operation\n+    assert(result == nullptr, \"inv\");\n+    {\n@@ -372,7 +345,0 @@\n-        \/\/ If GC was locked out during VM operation then retry allocation\n-        \/\/ and\/or stall as necessary.\n-        if (op.gc_locked()) {\n-          assert(op.result() == nullptr, \"must be null if gc_locked() is true\");\n-          continue;  \/\/ retry and\/or stall as necessary\n-        }\n-\n@@ -430,2 +396,2 @@\n-  if (!should_alloc_in_eden(size) || GCLocker::is_active_and_needs_gc()) {\n-    \/\/ Size is too big for eden, or gc is locked out.\n+  if (!should_alloc_in_eden(size)) {\n+    \/\/ Size is too big for eden.\n@@ -439,3 +405,0 @@\n-  if (GCLocker::check_active_before_gc()) {\n-    return;\n-  }\n@@ -464,5 +427,0 @@\n-  GCLocker::check_active_before_gc();\n-  if (GCLocker::is_active_and_needs_gc()) {\n-    return expand_heap_and_allocate(size, is_tlab);\n-  }\n-\n@@ -575,4 +533,0 @@\n-  if (GCLocker::should_discard(cause, gc_count)) {\n-    return;\n-  }\n-\n@@ -593,13 +547,0 @@\n-\n-    if (GCLocker::is_active_and_needs_gc()) {\n-      \/\/ If GCLocker is active, wait until clear before retrying.\n-      GCLocker::stall_until_clear();\n-    }\n-  }\n-}\n-\n-void ParallelScavengeHeap::try_collect_at_safepoint(bool full) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"precondition\");\n-  if (GCLocker::check_active_before_gc()) {\n-    return;\n-  collect_at_safepoint(full);\n@@ -932,1 +873,1 @@\n-  GCLocker::lock_critical(thread);\n+  GCLocker::enter(thread);\n@@ -936,1 +877,1 @@\n-  GCLocker::unlock_critical(thread);\n+  GCLocker::exit(thread);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":7,"deletions":66,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -259,1 +259,1 @@\n-  MemTracker::record_virtual_memory_tag((address)rs.base(), mtGC);\n+  MemTracker::record_virtual_memory_tag(rs, mtGC);\n@@ -996,4 +996,0 @@\n-  if (GCLocker::check_active_before_gc()) {\n-    return false;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -503,4 +503,0 @@\n-  if (GCLocker::check_active_before_gc()) {\n-    return false;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompactNew.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -253,1 +253,1 @@\n-      min_size, max_size, &_virtual_space);\n+      min_size, max_size, _virtual_space.committed_size());\n@@ -370,12 +370,0 @@\n-  \/\/ Do not attempt an expand-to-the reserve size.  The\n-  \/\/ request should properly observe the maximum size of\n-  \/\/ the generation so an expand-to-reserve should be\n-  \/\/ unnecessary.  Also a second call to expand-to-reserve\n-  \/\/ value potentially can cause an undue expansion.\n-  \/\/ For example if the first expand fail for unknown reasons,\n-  \/\/ but the second succeeds and expands the heap to its maximum\n-  \/\/ value.\n-  if (GCLocker::is_active()) {\n-    log_debug(gc)(\"Garbage collection disabled, expanded heap instead\");\n-  }\n-\n@@ -827,1 +815,1 @@\n-    _gen_counters->update_all();\n+    _gen_counters->update_all(_virtual_space.committed_size());\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -103,3 +103,0 @@\n-  if (success && GCLocker::is_active_and_needs_gc()) {\n-    log_trace(gc, heap)(\"Garbage collection disabled, expanded heap instead\");\n-  }\n@@ -332,1 +329,1 @@\n-      min_byte_size, max_byte_size, &_virtual_space);\n+      min_byte_size, max_byte_size, _virtual_space.committed_size());\n@@ -374,1 +371,1 @@\n-    _gen_counters->update_all();\n+    _gen_counters->update_all(_virtual_space.committed_size());\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -152,5 +152,0 @@\n-    if (bt == T_DOUBLE) {\n-      Node* new_val = kit->dprecision_rounding(val.node());\n-      val.set_node(new_val);\n-    }\n-\n@@ -903,0 +898,256 @@\n+static bool block_has_safepoint(const Block* block, uint from, uint to) {\n+  for (uint i = from; i < to; i++) {\n+    if (block->get_node(i)->is_MachSafePoint()) {\n+      \/\/ Safepoint found\n+      return true;\n+    }\n+  }\n+\n+  \/\/ Safepoint not found\n+  return false;\n+}\n+\n+static bool block_has_safepoint(const Block* block) {\n+  return block_has_safepoint(block, 0, block->number_of_nodes());\n+}\n+\n+static uint block_index(const Block* block, const Node* node) {\n+  for (uint j = 0; j < block->number_of_nodes(); ++j) {\n+    if (block->get_node(j) == node) {\n+      return j;\n+    }\n+  }\n+  ShouldNotReachHere();\n+  return 0;\n+}\n+\n+\/\/ Look through various node aliases\n+static const Node* look_through_node(const Node* node) {\n+  while (node != nullptr) {\n+    const Node* new_node = node;\n+    if (node->is_Mach()) {\n+      const MachNode* const node_mach = node->as_Mach();\n+      if (node_mach->ideal_Opcode() == Op_CheckCastPP) {\n+        new_node = node->in(1);\n+      }\n+      if (node_mach->is_SpillCopy()) {\n+        new_node = node->in(1);\n+      }\n+    }\n+    if (new_node == node || new_node == nullptr) {\n+      break;\n+    } else {\n+      node = new_node;\n+    }\n+  }\n+\n+  return node;\n+}\n+\n+\/\/ Whether the given offset is undefined.\n+static bool is_undefined(intptr_t offset) {\n+  return offset == Type::OffsetTop;\n+}\n+\n+\/\/ Whether the given offset is unknown.\n+static bool is_unknown(intptr_t offset) {\n+  return offset == Type::OffsetBot;\n+}\n+\n+\/\/ Whether the given offset is concrete (defined and compile-time known).\n+static bool is_concrete(intptr_t offset) {\n+  return !is_undefined(offset) && !is_unknown(offset);\n+}\n+\n+\/\/ Compute base + offset components of the memory address accessed by mach.\n+\/\/ Return a node representing the base address, or null if the base cannot be\n+\/\/ found or the offset is undefined or a concrete negative value. If a non-null\n+\/\/ base is returned, the offset is a concrete, nonnegative value or unknown.\n+static const Node* get_base_and_offset(const MachNode* mach, intptr_t& offset) {\n+  const TypePtr* adr_type = nullptr;\n+  offset = 0;\n+  const Node* base = mach->get_base_and_disp(offset, adr_type);\n+\n+  if (base == nullptr || base == NodeSentinel) {\n+    return nullptr;\n+  }\n+\n+  if (offset == 0 && base->is_Mach() && base->as_Mach()->ideal_Opcode() == Op_AddP) {\n+    \/\/ The memory address is computed by 'base' and fed to 'mach' via an\n+    \/\/ indirect memory operand (indicated by offset == 0). The ultimate base and\n+    \/\/ offset can be fetched directly from the inputs and Ideal type of 'base'.\n+    const TypeOopPtr* oopptr = base->bottom_type()->isa_oopptr();\n+    if (oopptr == nullptr) return nullptr;\n+    offset = oopptr->offset();\n+    \/\/ Even if 'base' is not an Ideal AddP node anymore, Matcher::ReduceInst()\n+    \/\/ guarantees that the base address is still available at the same slot.\n+    base = base->in(AddPNode::Base);\n+    assert(base != nullptr, \"\");\n+  }\n+\n+  if (is_undefined(offset) || (is_concrete(offset) && offset < 0)) {\n+    return nullptr;\n+  }\n+\n+  return look_through_node(base);\n+}\n+\n+\/\/ Whether a phi node corresponds to an array allocation.\n+\/\/ This test is incomplete: in some edge cases, it might return false even\n+\/\/ though the node does correspond to an array allocation.\n+static bool is_array_allocation(const Node* phi) {\n+  precond(phi->is_Phi());\n+  \/\/ Check whether phi has a successor cast (CheckCastPP) to Java array pointer,\n+  \/\/ possibly below spill copies and other cast nodes. Limit the exploration to\n+  \/\/ a single path from the phi node consisting of these node types.\n+  const Node* current = phi;\n+  while (true) {\n+    const Node* next = nullptr;\n+    for (DUIterator_Fast imax, i = current->fast_outs(imax); i < imax; i++) {\n+      if (!current->fast_out(i)->isa_Mach()) {\n+        continue;\n+      }\n+      const MachNode* succ = current->fast_out(i)->as_Mach();\n+      if (succ->ideal_Opcode() == Op_CheckCastPP) {\n+        if (succ->get_ptr_type()->isa_aryptr()) {\n+          \/\/ Cast to Java array pointer: phi corresponds to an array allocation.\n+          return true;\n+        }\n+        \/\/ Other cast: record as candidate for further exploration.\n+        next = succ;\n+      } else if (succ->is_SpillCopy() && next == nullptr) {\n+        \/\/ Spill copy, and no better candidate found: record as candidate.\n+        next = succ;\n+      }\n+    }\n+    if (next == nullptr) {\n+      \/\/ No evidence found that phi corresponds to an array allocation, and no\n+      \/\/ candidates available to continue exploring.\n+      return false;\n+    }\n+    \/\/ Continue exploring from the best candidate found.\n+    current = next;\n+  }\n+  ShouldNotReachHere();\n+}\n+\n+bool BarrierSetC2::is_allocation(const Node* node) {\n+  assert(node->is_Phi(), \"expected phi node\");\n+  if (node->req() != 3) {\n+    return false;\n+  }\n+  const Node* const fast_node = node->in(2);\n+  if (!fast_node->is_Mach()) {\n+    return false;\n+  }\n+  const MachNode* const fast_mach = fast_node->as_Mach();\n+  if (fast_mach->ideal_Opcode() != Op_LoadP) {\n+    return false;\n+  }\n+  intptr_t offset;\n+  const Node* const base = get_base_and_offset(fast_mach, offset);\n+  if (base == nullptr || !base->is_Mach() || !is_concrete(offset)) {\n+    return false;\n+  }\n+  const MachNode* const base_mach = base->as_Mach();\n+  if (base_mach->ideal_Opcode() != Op_ThreadLocal) {\n+    return false;\n+  }\n+  return offset == in_bytes(Thread::tlab_top_offset());\n+}\n+\n+void BarrierSetC2::elide_dominated_barriers(Node_List& accesses, Node_List& access_dominators) const {\n+  Compile* const C = Compile::current();\n+  PhaseCFG* const cfg = C->cfg();\n+\n+  for (uint i = 0; i < accesses.size(); i++) {\n+    MachNode* const access = accesses.at(i)->as_Mach();\n+    intptr_t access_offset;\n+    const Node* const access_obj = get_base_and_offset(access, access_offset);\n+    Block* const access_block = cfg->get_block_for_node(access);\n+    const uint access_index = block_index(access_block, access);\n+\n+    if (access_obj == nullptr) {\n+      \/\/ No information available\n+      continue;\n+    }\n+\n+    for (uint j = 0; j < access_dominators.size(); j++) {\n+     const  Node* const mem = access_dominators.at(j);\n+      if (mem->is_Phi()) {\n+        assert(is_allocation(mem), \"expected allocation phi node\");\n+        if (mem != access_obj) {\n+          continue;\n+        }\n+        if (is_unknown(access_offset) && !is_array_allocation(mem)) {\n+          \/\/ The accessed address has an unknown offset, but the allocated\n+          \/\/ object cannot be determined to be an array. Avoid eliding in this\n+          \/\/ case, to be on the safe side.\n+          continue;\n+        }\n+        assert((is_concrete(access_offset) && access_offset >= 0) || (is_unknown(access_offset) && is_array_allocation(mem)),\n+               \"candidate allocation-dominated access offsets must be either concrete and nonnegative, or unknown (for array allocations only)\");\n+      } else {\n+        \/\/ Access node\n+        const MachNode* const mem_mach = mem->as_Mach();\n+        intptr_t mem_offset;\n+        const Node* const mem_obj = get_base_and_offset(mem_mach, mem_offset);\n+\n+        if (mem_obj == nullptr ||\n+            !is_concrete(access_offset) ||\n+            !is_concrete(mem_offset)) {\n+          \/\/ No information available\n+          continue;\n+        }\n+\n+        if (mem_obj != access_obj || mem_offset != access_offset) {\n+          \/\/ Not the same addresses, not a candidate\n+          continue;\n+        }\n+        assert(is_concrete(access_offset) && access_offset >= 0,\n+               \"candidate non-allocation-dominated access offsets must be concrete and nonnegative\");\n+      }\n+\n+      Block* mem_block = cfg->get_block_for_node(mem);\n+      const uint mem_index = block_index(mem_block, mem);\n+\n+      if (access_block == mem_block) {\n+        \/\/ Earlier accesses in the same block\n+        if (mem_index < access_index && !block_has_safepoint(mem_block, mem_index + 1, access_index)) {\n+          elide_dominated_barrier(access);\n+        }\n+      } else if (mem_block->dominates(access_block)) {\n+        \/\/ Dominating block? Look around for safepoints\n+        ResourceMark rm;\n+        Block_List stack;\n+        VectorSet visited;\n+        stack.push(access_block);\n+        bool safepoint_found = block_has_safepoint(access_block);\n+        while (!safepoint_found && stack.size() > 0) {\n+          const Block* const block = stack.pop();\n+          if (visited.test_set(block->_pre_order)) {\n+            continue;\n+          }\n+          if (block_has_safepoint(block)) {\n+            safepoint_found = true;\n+            break;\n+          }\n+          if (block == mem_block) {\n+            continue;\n+          }\n+\n+          \/\/ Push predecessor blocks\n+          for (uint p = 1; p < block->num_preds(); ++p) {\n+            Block* const pred = cfg->get_block_for_node(block->pred(p));\n+            stack.push(pred);\n+          }\n+        }\n+\n+        if (!safepoint_found) {\n+          elide_dominated_barrier(access);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":256,"deletions":5,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahCardTable.hpp\"\n@@ -188,0 +189,5 @@\n+\n+  if (GCCardSizeInBytes < ShenandoahMinCardSizeInBytes) {\n+    vm_exit_during_initialization(\n+      err_msg(\"GCCardSizeInBytes ( %u ) must be >= %u\\n\", GCCardSizeInBytes, (unsigned int) ShenandoahMinCardSizeInBytes));\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-  if (metrics.is_good_progress()) {\n+  if (metrics.is_good_progress(heap->global_generation())) {\n@@ -133,0 +133,5 @@\n+\n+  {\n+    ShenandoahTimingsTracker timing(ShenandoahPhaseTimings::full_gc_propagate_gc_state);\n+    heap->propagate_gc_state_to_all_threads();\n+  }\n@@ -195,6 +200,1 @@\n-    \/\/ d. Reset the bitmaps for new marking\n-    heap->global_generation()->reset_mark_bitmap();\n-    assert(heap->marking_context()->is_bitmap_clear(), \"sanity\");\n-    assert(!heap->global_generation()->is_mark_complete(), \"sanity\");\n-\n-    \/\/ e. Abandon reference discovery and clear all discovered references.\n+    \/\/ d. Abandon reference discovery and clear all discovered references.\n@@ -204,1 +204,1 @@\n-    \/\/ f. Sync pinned region status from the CP marks\n+    \/\/ e. Sync pinned region status from the CP marks\n@@ -289,15 +289,0 @@\n-class ShenandoahPrepareForMarkClosure: public ShenandoahHeapRegionClosure {\n-private:\n-  ShenandoahMarkingContext* const _ctx;\n-\n-public:\n-  ShenandoahPrepareForMarkClosure() : _ctx(ShenandoahHeap::heap()->marking_context()) {}\n-\n-  void heap_region_do(ShenandoahHeapRegion *r) override {\n-    _ctx->capture_top_at_mark_start(r);\n-    r->clear_live_data();\n-  }\n-\n-  bool is_thread_safe() override { return true; }\n-};\n-\n@@ -310,3 +295,3 @@\n-  ShenandoahPrepareForMarkClosure prepare_for_mark;\n-  ShenandoahExcludeRegionClosure<FREE> cl(&prepare_for_mark);\n-  heap->parallel_heap_region_iterate(&cl);\n+  heap->global_generation()->reset_mark_bitmap<true, true>();\n+  assert(heap->marking_context()->is_bitmap_clear(), \"sanity\");\n+  assert(!heap->global_generation()->is_mark_complete(), \"sanity\");\n@@ -1183,0 +1168,3 @@\n+    \/\/ Set mark incomplete because the marking bitmaps have been reset except pinned regions.\n+    heap->global_generation()->set_mark_incomplete();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":14,"deletions":26,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -92,0 +92,5 @@\n+\n+  ShenandoahScanRemembered* scanner = heap->old_generation()->card_scan();\n+  scanner->mark_read_table_as_clean();\n+  scanner->swap_card_tables();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -306,1 +306,1 @@\n-  MemTracker::record_virtual_memory_tag(bitmap.base(), mtGC);\n+  MemTracker::record_virtual_memory_tag(bitmap, mtGC);\n@@ -330,1 +330,1 @@\n-    MemTracker::record_virtual_memory_tag(verify_bitmap.base(), mtGC);\n+    MemTracker::record_virtual_memory_tag(verify_bitmap, mtGC);\n@@ -344,1 +344,1 @@\n-  MemTracker::record_virtual_memory_tag(aux_bitmap.base(), mtGC);\n+  MemTracker::record_virtual_memory_tag(aux_bitmap, mtGC);\n@@ -362,1 +362,1 @@\n-  MemTracker::record_virtual_memory_tag(region_storage.base(), mtGC);\n+  MemTracker::record_virtual_memory_tag(region_storage, mtGC);\n@@ -586,0 +586,1 @@\n+  _cancelled_gc.set(GCCause::_no_gc);\n@@ -820,10 +821,13 @@\n-  if (is_in_reserved(p)) {\n-    if (is_full_gc_move_in_progress()) {\n-      \/\/ Full GC move is running, we do not have a consistent region\n-      \/\/ information yet. But we know the pointer is in heap.\n-      return true;\n-    }\n-    \/\/ Now check if we point to a live section in active region.\n-    ShenandoahHeapRegion* r = heap_region_containing(p);\n-    return (r->is_active() && p < r->top());\n-  } else {\n+  if (!is_in_reserved(p)) {\n+    return false;\n+  }\n+\n+  if (is_full_gc_move_in_progress()) {\n+    \/\/ Full GC move is running, we do not have a consistent region\n+    \/\/ information yet. But we know the pointer is in heap.\n+    return true;\n+  }\n+\n+  \/\/ Now check if we point to a live section in active region.\n+  const ShenandoahHeapRegion* r = heap_region_containing(p);\n+  if (p >= r->top()) {\n@@ -832,0 +836,10 @@\n+\n+  if (r->is_active()) {\n+    return true;\n+  }\n+\n+  \/\/ The region is trash, but won't be recycled until after concurrent weak\n+  \/\/ roots. We also don't allow mutators to allocate from trash regions\n+  \/\/ during weak roots. Concurrent class unloading may access unmarked oops\n+  \/\/ in trash regions.\n+  return r->is_trash() && is_concurrent_weak_root_in_progress();\n@@ -996,2 +1010,2 @@\n-      size_t original_count = shenandoah_policy()->full_gc_count();\n-      while ((result == nullptr) && (original_count == shenandoah_policy()->full_gc_count())) {\n+      const size_t original_count = shenandoah_policy()->full_gc_count();\n+      while (result == nullptr && should_retry_allocation(original_count)) {\n@@ -1002,1 +1016,1 @@\n-        \/\/ If our allocation request has been satisifed after it initially failed, we count this as good gc progress\n+        \/\/ If our allocation request has been satisfied after it initially failed, we count this as good gc progress\n@@ -1053,0 +1067,5 @@\n+inline bool ShenandoahHeap::should_retry_allocation(size_t original_full_gc_count) const {\n+  return shenandoah_policy()->full_gc_count() == original_full_gc_count\n+      && !shenandoah_policy()->is_at_shutdown();\n+}\n+\n@@ -1231,1 +1250,1 @@\n-class ShenandoahGCStatePropagator : public ThreadClosure {\n+class ShenandoahGCStatePropagator : public HandshakeClosure {\n@@ -1233,1 +1252,3 @@\n-  explicit ShenandoahGCStatePropagator(char gc_state) : _gc_state(gc_state) {}\n+  explicit ShenandoahGCStatePropagator(char gc_state) :\n+    HandshakeClosure(\"Shenandoah GC State Change\"),\n+    _gc_state(gc_state) {}\n@@ -1265,5 +1286,12 @@\n-  \/\/ It's possible that evacuation succeeded, but we could still be cancelled when we get here.\n-  \/\/ A cancellation at this point means the degenerated cycle must resume from update-refs.\n-  set_gc_state_concurrent(EVACUATION, false);\n-  set_gc_state_concurrent(WEAK_ROOTS, false);\n-  set_gc_state_concurrent(UPDATE_REFS, true);\n+  {\n+    \/\/ Java threads take this lock while they are being attached and added to the list of thread.\n+    \/\/ If another thread holds this lock before we update the gc state, it will receive a stale\n+    \/\/ gc state, but they will have been added to the list of java threads and so will be corrected\n+    \/\/ by the following handshake.\n+    MutexLocker lock(Threads_lock);\n+\n+    \/\/ A cancellation at this point means the degenerated cycle must resume from update-refs.\n+    set_gc_state_concurrent(EVACUATION, false);\n+    set_gc_state_concurrent(WEAK_ROOTS, false);\n+    set_gc_state_concurrent(UPDATE_REFS, true);\n+  }\n@@ -1283,0 +1311,31 @@\n+class ShenandoahCompositeHandshakeClosure : public HandshakeClosure {\n+  HandshakeClosure* _handshake_1;\n+  HandshakeClosure* _handshake_2;\n+  public:\n+    ShenandoahCompositeHandshakeClosure(HandshakeClosure* handshake_1, HandshakeClosure* handshake_2) :\n+      HandshakeClosure(handshake_2->name()),\n+      _handshake_1(handshake_1), _handshake_2(handshake_2) {}\n+\n+  void do_thread(Thread* thread) override {\n+      _handshake_1->do_thread(thread);\n+      _handshake_2->do_thread(thread);\n+    }\n+};\n+\n+void ShenandoahHeap::concurrent_final_roots(HandshakeClosure* handshake_closure) {\n+  {\n+    assert(!is_evacuation_in_progress(), \"Should not evacuate for abbreviated or old cycles\");\n+    MutexLocker lock(Threads_lock);\n+    set_gc_state_concurrent(WEAK_ROOTS, false);\n+  }\n+\n+  ShenandoahGCStatePropagator propagator(_gc_state.raw_value());\n+  Threads::non_java_threads_do(&propagator);\n+  if (handshake_closure == nullptr) {\n+    Handshake::execute(&propagator);\n+  } else {\n+    ShenandoahCompositeHandshakeClosure composite(&propagator, handshake_closure);\n+    Handshake::execute(&composite);\n+  }\n+}\n+\n@@ -2003,1 +2062,1 @@\n-void ShenandoahHeap::prepare_update_heap_references(bool concurrent) {\n+void ShenandoahHeap::prepare_update_heap_references() {\n@@ -2010,3 +2069,1 @@\n-    ShenandoahGCPhase phase(concurrent ?\n-                            ShenandoahPhaseTimings::init_update_refs_manage_gclabs :\n-                            ShenandoahPhaseTimings::degen_gc_init_update_refs_manage_gclabs);\n+    ShenandoahGCPhase phase(ShenandoahPhaseTimings::degen_gc_init_update_refs_manage_gclabs);\n@@ -2035,0 +2092,6 @@\n+  \/\/ Holding the thread lock here assures that any thread created after we change the gc\n+  \/\/ state will have the correct state. It also prevents attaching threads from seeing\n+  \/\/ an inconsistent state. See ShenandoahBarrierSet::on_thread_attach for reference. Established\n+  \/\/ threads will use their thread local copy of the gc state (changed by a handshake, or on a\n+  \/\/ safepoint).\n+  assert(Threads_lock->is_locked(), \"Must hold thread lock for concurrent gc state change\");\n@@ -2117,3 +2180,3 @@\n-bool ShenandoahHeap::try_cancel_gc() {\n-  jbyte prev = _cancelled_gc.cmpxchg(CANCELLED, CANCELLABLE);\n-  return prev == CANCELLABLE;\n+bool ShenandoahHeap::try_cancel_gc(GCCause::Cause cause) {\n+  const GCCause::Cause prev = _cancelled_gc.xchg(cause);\n+  return prev == GCCause::_no_gc || prev == GCCause::_shenandoah_concurrent_gc;\n@@ -2133,2 +2196,2 @@\n-void ShenandoahHeap::cancel_gc(GCCause::Cause cause) {\n-  if (try_cancel_gc()) {\n+bool ShenandoahHeap::cancel_gc(GCCause::Cause cause) {\n+  if (try_cancel_gc(cause)) {\n@@ -2136,1 +2199,1 @@\n-    log_info(gc)(\"%s\", msg.buffer());\n+    log_info(gc,thread)(\"%s\", msg.buffer());\n@@ -2139,0 +2202,1 @@\n+    return true;\n@@ -2140,0 +2204,1 @@\n+  return false;\n@@ -2152,1 +2217,1 @@\n-  \/\/ Step 0a. Stop reporting on gc thread cpu utilization\n+  \/\/ Step 1. Stop reporting on gc thread cpu utilization\n@@ -2155,9 +2220,1 @@\n-  \/\/ Step 1. Notify control thread that we are in shutdown.\n-  \/\/ Note that we cannot do that with stop(), because stop() is blocking and waits for the actual shutdown.\n-  \/\/ Doing stop() here would wait for the normal GC cycle to complete, never falling through to cancel below.\n-  control_thread()->prepare_for_graceful_shutdown();\n-\n-  \/\/ Step 2. Notify GC workers that we are cancelling GC.\n-  cancel_gc(GCCause::_shenandoah_stop_vm);\n-\n-  \/\/ Step 3. Wait until GC worker exits normally.\n+  \/\/ Step 2. Wait until GC worker exits normally (this will cancel any ongoing GC).\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":101,"deletions":44,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -682,1 +682,1 @@\n-    \/\/ relocating, then the first cycle will have consume the the old remset,\n+    \/\/ relocating, then the first cycle will have consumed the old remset,\n@@ -684,1 +684,1 @@\n-    \/\/ could find either the the two bitmaps. So, either it will find the original\n+    \/\/ could find either of the two bitmaps. So, either it will find the original\n@@ -879,1 +879,1 @@\n-      \/\/ Register the the promotion\n+      \/\/ Register the promotion\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1372,1 +1372,1 @@\n-    code->make_not_entrant();\n+    code->make_not_entrant(\"JVMCI reprofile\");\n@@ -1812,1 +1812,1 @@\n-    fst.current()->cb()->as_nmethod()->make_not_entrant();\n+    fst.current()->cb()->as_nmethod()->make_not_entrant(\"JVMCI materialize virtual objects\");\n@@ -2727,1 +2727,1 @@\n-      JVMCI_event_1(\"attached to JavaVM[%d] for JVMCI runtime %d\", runtime->get_shared_library_javavm_id(), runtime->id());\n+      JVMCI_event_1(\"attached to JavaVM[\" JLONG_FORMAT \"] for JVMCI runtime %d\", runtime->get_shared_library_javavm_id(), runtime->id());\n@@ -2760,1 +2760,1 @@\n-    JVMCI_event_1(\"detached from JavaVM[%d] for JVMCI runtime %d\",\n+    JVMCI_event_1(\"detached from JavaVM[\" JLONG_FORMAT \"] for JVMCI runtime %d\",\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -168,7 +168,5 @@\n-  if (bs_nm != nullptr) {\n-    thread_disarmed_guard_value_offset = in_bytes(bs_nm->thread_disarmed_guard_value_offset());\n-    nmethod_entry_barrier = StubRoutines::method_entry_barrier();\n-    BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n-    AARCH64_ONLY(BarrierSetAssembler_nmethod_patching_type = (int) bs_asm->nmethod_patching_type());\n-    AARCH64_ONLY(BarrierSetAssembler_patching_epoch_addr = bs_asm->patching_epoch_addr());\n-  }\n+  thread_disarmed_guard_value_offset = in_bytes(bs_nm->thread_disarmed_guard_value_offset());\n+  nmethod_entry_barrier = StubRoutines::method_entry_barrier();\n+  BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n+  AARCH64_ONLY(BarrierSetAssembler_nmethod_patching_type = (int) bs_asm->nmethod_patching_type());\n+  AARCH64_ONLY(BarrierSetAssembler_patching_epoch_addr = bs_asm->patching_epoch_addr());\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+  DEBUG_ONLY(LOG_TAG(deathtest)) \/* Log Internal death test tag *\/ \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -575,1 +575,1 @@\n-      HeapShared::init_scratch_objects(CHECK);\n+      HeapShared::init_scratch_objects_for_basic_type_mirrors(CHECK);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+size_t CompressedKlassPointers::_protection_zone_size = 0;\n@@ -169,5 +170,0 @@\n-  \/\/ Note: While it would be technically valid for the encoding base to precede the start of the Klass range,\n-  \/\/ we never do this here. This is used at CDS runtime to re-instate the scheme used to precompute the\n-  \/\/ narrow Klass IDs in the archive, and the requested base should point to the start of the Klass range.\n-  assert(requested_base == addr, \"Invalid requested base\");\n-\n@@ -316,0 +312,5 @@\n+    if (_protection_zone_size > 0) {\n+      st->print_cr(\"Protection zone: \" RANGEFMT, RANGEFMTARGS(_base, _protection_zone_size));\n+    } else {\n+      st->print_cr(\"No protection zone.\");\n+    }\n@@ -321,0 +322,26 @@\n+\/\/ On AIX, we cannot mprotect archive space or class space since they are reserved with SystemV shm.\n+static constexpr bool can_mprotect_archive_space = NOT_AIX(true) AIX_ONLY(false);\n+\n+\/\/ Protect a zone a the start of the encoding range\n+void CompressedKlassPointers::establish_protection_zone(address addr, size_t size) {\n+  assert(_protection_zone_size == 0, \"just once\");\n+  assert(addr == base(), \"Protection zone not at start of encoding range?\");\n+  assert(size > 0 && is_aligned(size, os::vm_page_size()), \"Protection zone not page sized\");\n+  const bool rc = can_mprotect_archive_space && os::protect_memory((char*)addr, size, os::MEM_PROT_NONE, false);\n+  log_info(metaspace)(\"%s Narrow Klass Protection zone \" RANGEFMT,\n+      (rc ? \"Established\" : \"FAILED to establish \"),\n+      RANGEFMTARGS(addr, size));\n+  if (!rc) {\n+    \/\/ If we fail to establish the protection zone, we fill it with a clear pattern to make it\n+    \/\/ stick out in register values (0x50 aka 'P', repeated)\n+    os::commit_memory((char*)addr, size, false);\n+    memset(addr, 'P', size);\n+  }\n+  _protection_zone_size = size;\n+}\n+\n+bool CompressedKlassPointers::is_in_protection_zone(address addr) {\n+  return _protection_zone_size > 0 ?\n+      (addr >= base() && addr < base() + _protection_zone_size) : false;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":32,"deletions":5,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,0 +137,2 @@\n+  \/\/ Protection zone size (0 if not set up)\n+  static size_t _protection_zone_size;\n@@ -234,0 +236,1 @@\n+  static inline Klass* decode_not_null_without_asserts(narrowKlass v);\n@@ -261,0 +264,6 @@\n+  \/\/ Protect a zone a the start of the encoding range\n+  static void establish_protection_zone(address addr, size_t size);\n+\n+  \/\/ Returns true if address points into protection zone (for error reporting)\n+  static bool is_in_protection_zone(address addr);\n+\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2703,1 +2703,1 @@\n-  if (CDSConfig::is_dumping_invokedynamic() && HeapShared::is_lambda_proxy_klass(this)) {\n+  if (CDSConfig::is_dumping_method_handles() && HeapShared::is_lambda_proxy_klass(this)) {\n@@ -2711,0 +2711,1 @@\n+  DEBUG_ONLY(_shared_class_load_count = 0);\n@@ -3506,1 +3507,1 @@\n-      inv->make_not_entrant();\n+      inv->make_not_entrant(\"OSR invalidation of lower levels\");\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -332,0 +332,6 @@\n+int Klass::modifier_flags() const {\n+  int mods = java_lang_Class::modifiers(java_mirror());\n+  assert(mods == compute_modifier_flags(), \"should be same\");\n+  return mods;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -126,3 +126,0 @@\n-  \/\/ Processed access flags, for use by Class.getModifiers.\n-  u2          _modifier_flags;\n-\n@@ -172,3 +169,3 @@\n-  \/\/ This is an index into FileMapHeader::_shared_path_table[], to\n-  \/\/ associate this class with the JAR file where it's loaded from during\n-  \/\/ dump time. If a class is not loaded from the shared archive, this field is\n+  \/\/ This is an index into AOTClassLocationConfig::class_locations(), to\n+  \/\/ indicate the AOTClassLocation where this class is loaded from during\n+  \/\/ dump time. If a class is not loaded from the AOT cache, this field is\n@@ -295,4 +292,0 @@\n-  \/\/ modifier flags\n-  u2 modifier_flags() const          { return _modifier_flags; }\n-  void set_modifier_flags(u2 flags)  { _modifier_flags = flags; }\n-\n@@ -451,1 +444,0 @@\n-  static ByteSize modifier_flags_offset()        { return byte_offset_of(Klass, _modifier_flags); }\n@@ -761,0 +753,6 @@\n+  \/\/ Get modifier flags from Java mirror cache.\n+  int modifier_flags() const;\n+\n+  \/\/ Compute modifier flags from the original data. This also allows\n+  \/\/ accessing flags when Java mirror is already dead, e.g. during class\n+  \/\/ unloading.\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -142,3 +142,0 @@\n-\n-  \/\/ Compute modifier flags after bottom_klass and element_klass are initialized.\n-  set_modifier_flags(compute_modifier_flags());\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -90,3 +90,0 @@\n-\n-  \/\/ Compute modifier flags.\n-  set_modifier_flags(compute_modifier_flags());\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+  u2 compute_modifier_flags() const;\n+\n@@ -76,2 +78,0 @@\n-  u2 compute_modifier_flags() const;\n-\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"memory\/arena.hpp\"\n@@ -69,0 +70,1 @@\n+#include \"opto\/opaquenode.hpp\"\n@@ -396,1 +398,1 @@\n-    remove_template_assertion_predicate_opaq(dead);\n+    remove_template_assertion_predicate_opaque(dead->as_OpaqueTemplateAssertionPredicate());\n@@ -404,0 +406,3 @@\n+  if (dead->for_merge_stores_igvn()) {\n+    remove_from_merge_stores_igvn(dead);\n+  }\n@@ -419,1 +424,1 @@\n-void Compile::disconnect_useless_nodes(Unique_Node_List& useful, Unique_Node_List& worklist) {\n+void Compile::disconnect_useless_nodes(Unique_Node_List& useful, Unique_Node_List& worklist, const Unique_Node_List* root_and_safepoints) {\n@@ -439,0 +444,3 @@\n+        if (child->is_data_proj_of_pure_function(n)) {\n+          worklist.push(n);\n+        }\n@@ -449,1 +457,2 @@\n-  remove_useless_nodes(_template_assertion_predicate_opaqs, useful); \/\/ remove useless Assertion Predicate opaque nodes\n+  \/\/ Remove useless Template Assertion Predicate opaque nodes\n+  remove_useless_nodes(_template_assertion_predicate_opaques, useful);\n@@ -452,0 +461,1 @@\n+  remove_useless_nodes(_for_merge_stores_igvn, useful); \/\/ remove useless node recorded for merge stores IGVN pass\n@@ -467,1 +477,1 @@\n-  debug_only(verify_graph_edges(true\/*check for no_dead_code*\/);)\n+  debug_only(verify_graph_edges(true \/*check for no_dead_code*\/, root_and_safepoints);)\n@@ -626,0 +636,1 @@\n+      _merge_stores_phase(false),\n@@ -638,1 +649,1 @@\n-      _comp_arena(mtCompiler),\n+      _comp_arena(mtCompiler, Arena::Tag::tag_comp),\n@@ -647,1 +658,1 @@\n-      _template_assertion_predicate_opaqs(comp_arena(), 8, 0, nullptr),\n+      _template_assertion_predicate_opaques(comp_arena(), 8, 0, nullptr),\n@@ -650,0 +661,1 @@\n+      _for_merge_stores_igvn(comp_arena(), 8, 0, nullptr),\n@@ -661,1 +673,1 @@\n-      _Compile_types(mtCompiler),\n+      _Compile_types(mtCompiler, Arena::Tag::tag_type),\n@@ -904,0 +916,1 @@\n+      _merge_stores_phase(false),\n@@ -915,1 +928,1 @@\n-      _comp_arena(mtCompiler),\n+      _comp_arena(mtCompiler, Arena::Tag::tag_comp),\n@@ -922,0 +935,1 @@\n+      _for_merge_stores_igvn(comp_arena(), 8, 0, nullptr),\n@@ -927,2 +941,2 @@\n-      _node_arena_one(mtCompiler),\n-      _node_arena_two(mtCompiler),\n+      _node_arena_one(mtCompiler, Arena::Tag::tag_node),\n+      _node_arena_two(mtCompiler, Arena::Tag::tag_node),\n@@ -931,1 +945,1 @@\n-      _Compile_types(mtCompiler),\n+      _Compile_types(mtCompiler, Arena::Tag::tag_type),\n@@ -1702,2 +1716,0 @@\n-      if (flat->offset() == in_bytes(Klass::modifier_flags_offset()))\n-        alias_type(idx)->set_rewritable(false);\n@@ -1825,2 +1837,1 @@\n-    parse_predicate->mark_useless();\n-    igvn._worklist.push(parse_predicate);\n+    parse_predicate->mark_useless(igvn);\n@@ -1871,0 +1882,43 @@\n+void Compile::record_for_merge_stores_igvn(Node* n) {\n+  if (!n->for_merge_stores_igvn()) {\n+    assert(!_for_merge_stores_igvn.contains(n), \"duplicate\");\n+    n->add_flag(Node::NodeFlags::Flag_for_merge_stores_igvn);\n+    _for_merge_stores_igvn.append(n);\n+  }\n+}\n+\n+void Compile::remove_from_merge_stores_igvn(Node* n) {\n+  n->remove_flag(Node::NodeFlags::Flag_for_merge_stores_igvn);\n+  _for_merge_stores_igvn.remove(n);\n+}\n+\n+\/\/ We need to wait with merging stores until RangeCheck smearing has removed the RangeChecks during\n+\/\/ the post loops IGVN phase. If we do it earlier, then there may still be some RangeChecks between\n+\/\/ the stores, and we merge the wrong sequence of stores.\n+\/\/ Example:\n+\/\/   StoreI RangeCheck StoreI StoreI RangeCheck StoreI\n+\/\/ Apply MergeStores:\n+\/\/   StoreI RangeCheck [   StoreL  ] RangeCheck StoreI\n+\/\/ Remove more RangeChecks:\n+\/\/   StoreI            [   StoreL  ]            StoreI\n+\/\/ But now it would have been better to do this instead:\n+\/\/   [         StoreL       ] [       StoreL         ]\n+\/\/\n+\/\/ Note: we allow stores to merge in this dedicated IGVN round, and any later IGVN round,\n+\/\/       since we never unset _merge_stores_phase.\n+void Compile::process_for_merge_stores_igvn(PhaseIterGVN& igvn) {\n+  C->set_merge_stores_phase();\n+\n+  if (_for_merge_stores_igvn.length() > 0) {\n+    while (_for_merge_stores_igvn.length() > 0) {\n+      Node* n = _for_merge_stores_igvn.pop();\n+      n->remove_flag(Node::NodeFlags::Flag_for_merge_stores_igvn);\n+      igvn._worklist.push(n);\n+    }\n+    igvn.optimize();\n+    if (failing()) return;\n+    assert(_for_merge_stores_igvn.length() == 0, \"no more delayed nodes allowed\");\n+    print_method(PHASE_AFTER_MERGE_STORES, 3);\n+  }\n+}\n+\n@@ -2430,0 +2484,2 @@\n+  process_for_merge_stores_igvn(igvn);\n+\n@@ -3015,0 +3071,7 @@\n+#ifdef ASSERT\n+  {\n+    CompilationMemoryStatistic::do_test_allocations();\n+    if (failing()) return;\n+  }\n+#endif\n+\n@@ -4193,1 +4256,1 @@\n-void Compile::verify_bidirectional_edges(Unique_Node_List &visited) {\n+void Compile::verify_bidirectional_edges(Unique_Node_List& visited, const Unique_Node_List* root_and_safepoints) const {\n@@ -4196,2 +4259,16 @@\n-  Node_List nstack(MAX2(stack_size, (uint)OptoNodeListSize));\n-  nstack.push(_root);\n+  Node_List nstack(MAX2(stack_size, (uint) OptoNodeListSize));\n+  if (root_and_safepoints != nullptr) {\n+    assert(root_and_safepoints->member(_root), \"root is not in root_and_safepoints\");\n+    for (uint i = 0, limit = root_and_safepoints->size(); i < limit; i++) {\n+      Node* root_or_safepoint = root_and_safepoints->at(i);\n+      \/\/ If the node is a safepoint, let's check if it still has a control input\n+      \/\/ Lack of control input signifies that this node was killed by CCP or\n+      \/\/ recursively by remove_globally_dead_node and it shouldn't be a starting\n+      \/\/ point.\n+      if (!root_or_safepoint->is_SafePoint() || root_or_safepoint->in(0) != nullptr) {\n+        nstack.push(root_or_safepoint);\n+      }\n+    }\n+  } else {\n+    nstack.push(_root);\n+  }\n@@ -4247,1 +4324,1 @@\n-void Compile::verify_graph_edges(bool no_dead_code) {\n+void Compile::verify_graph_edges(bool no_dead_code, const Unique_Node_List* root_and_safepoints) const {\n@@ -4252,1 +4329,1 @@\n-    verify_bidirectional_edges(visited);\n+    verify_bidirectional_edges(visited, root_and_safepoints);\n@@ -4315,0 +4392,1 @@\n+  assert(id != PhaseTraceId::_t_none, \"Don't use none\");\n@@ -4323,0 +4401,5 @@\n+\n+  \/\/ Inform memory statistic, if enabled\n+  if (CompilationMemoryStatistic::enabled()) {\n+    CompilationMemoryStatistic::on_phase_start((int)id, name);\n+  }\n@@ -4329,0 +4412,6 @@\n+\n+  \/\/ Inform memory statistic, if enabled\n+  if (CompilationMemoryStatistic::enabled()) {\n+    CompilationMemoryStatistic::on_phase_end();\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":109,"deletions":20,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -651,2 +651,0 @@\n-  \/\/ Round double arguments before call\n-  round_double_arguments(cg->method());\n@@ -950,1 +948,1 @@\n-    ex_klass_node = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+    ex_klass_node = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n@@ -968,1 +966,1 @@\n-        Node* k = _gvn.transform( LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+        Node* k = _gvn.transform( LoadKlassNode::make(_gvn, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2195,0 +2195,5 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"dilithiumAlmostNtt\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"dilithiumAlmostInverseNtt\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"dilithiumNttMult\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"dilithiumMontMulByConstant\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"dilithiumDecomposePoly\") == 0 ||\n@@ -2206,0 +2211,1 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"double_keccak\") == 0 ||\n@@ -4475,1 +4481,1 @@\n-        \/\/ This AddP will go away when we reduce the the Phi\n+        \/\/ This AddP will go away when we reduce the Phi\n@@ -4614,0 +4620,1 @@\n+              op == Op_ReinterpretS2HF ||\n@@ -4708,0 +4715,3 @@\n+    } else if (n->Opcode() == Op_StrInflatedCopy) {\n+      \/\/ Check direct uses of StrInflatedCopy.\n+      \/\/ It is memory type Node - no special SCMemProj node.\n@@ -4714,0 +4724,4 @@\n+#ifdef ASSERT\n+      if (!n->is_Mem()) {\n+        n->dump();\n+      }\n@@ -4715,0 +4729,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -590,1 +590,1 @@\n-    if (failing()) { stop(); return; }  \/\/ exception allocation might fail\n+    \/\/ If we have a preconstructed exception object, use it.\n@@ -1203,1 +1203,1 @@\n-  return _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), k_adr, TypeInstPtr::KLASS));\n+  return _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), k_adr, TypeInstPtr::KLASS));\n@@ -2367,45 +2367,0 @@\n-void GraphKit::round_double_arguments(ciMethod* dest_method) {\n-  if (Matcher::strict_fp_requires_explicit_rounding) {\n-    \/\/ (Note:  TypeFunc::make has a cache that makes this fast.)\n-    const TypeFunc* tf    = TypeFunc::make(dest_method);\n-    int             nargs = tf->domain()->cnt() - TypeFunc::Parms;\n-    for (int j = 0; j < nargs; j++) {\n-      const Type *targ = tf->domain()->field_at(j + TypeFunc::Parms);\n-      if (targ->basic_type() == T_DOUBLE) {\n-        \/\/ If any parameters are doubles, they must be rounded before\n-        \/\/ the call, dprecision_rounding does gvn.transform\n-        Node *arg = argument(j);\n-        arg = dprecision_rounding(arg);\n-        set_argument(j, arg);\n-      }\n-    }\n-  }\n-}\n-\n-\/\/ rounding for strict float precision conformance\n-Node* GraphKit::precision_rounding(Node* n) {\n-  if (Matcher::strict_fp_requires_explicit_rounding) {\n-#ifdef IA32\n-    if (UseSSE == 0) {\n-      return _gvn.transform(new RoundFloatNode(nullptr, n));\n-    }\n-#else\n-    Unimplemented();\n-#endif \/\/ IA32\n-  }\n-  return n;\n-}\n-\n-\/\/ rounding for strict double precision conformance\n-Node* GraphKit::dprecision_rounding(Node *n) {\n-  if (Matcher::strict_fp_requires_explicit_rounding) {\n-#ifdef IA32\n-    if (UseSSE < 2) {\n-      return _gvn.transform(new RoundDoubleNode(nullptr, n));\n-    }\n-#else\n-    Unimplemented();\n-#endif \/\/ IA32\n-  }\n-  return n;\n-}\n@@ -2782,1 +2737,1 @@\n-  Node *nkls = gvn.transform(LoadKlassNode::make(gvn, nullptr, kmem, p2, gvn.type(p2)->is_ptr(), TypeInstKlassPtr::OBJECT_OR_NULL));\n+  Node* nkls = gvn.transform(LoadKlassNode::make(gvn, kmem, p2, gvn.type(p2)->is_ptr(), TypeInstKlassPtr::OBJECT_OR_NULL));\n@@ -4085,0 +4040,3 @@\n+    if (UseProfiledLoopPredicate) {\n+      add_parse_predicate(Deoptimization::Reason_profile_predicate, nargs);\n+    }\n@@ -4086,3 +4044,1 @@\n-  if (UseProfiledLoopPredicate) {\n-    add_parse_predicate(Deoptimization::Reason_profile_predicate, nargs);\n-  }\n+  add_parse_predicate(Deoptimization::Reason_auto_vectorization_check, nargs);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":7,"deletions":51,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"ci\/ciSymbols.hpp\"\n@@ -518,4 +519,0 @@\n-  case vmIntrinsics::_getModifiers:\n-  case vmIntrinsics::_isInterface:\n-  case vmIntrinsics::_isArray:\n-  case vmIntrinsics::_isPrimitive:\n@@ -534,1 +531,2 @@\n-\n+  case vmIntrinsics::_sqrt_float16:             return inline_fp16_operations(intrinsic_id(), 1);\n+  case vmIntrinsics::_fma_float16:              return inline_fp16_operations(intrinsic_id(), 3);\n@@ -599,0 +597,2 @@\n+  case vmIntrinsics::_double_keccak:\n+    return inline_double_keccak();\n@@ -629,0 +629,10 @@\n+  case vmIntrinsics::_dilithiumAlmostNtt:\n+    return inline_dilithiumAlmostNtt();\n+  case vmIntrinsics::_dilithiumAlmostInverseNtt:\n+    return inline_dilithiumAlmostInverseNtt();\n+  case vmIntrinsics::_dilithiumNttMult:\n+    return inline_dilithiumNttMult();\n+  case vmIntrinsics::_dilithiumMontMulByConstant:\n+    return inline_dilithiumMontMulByConstant();\n+  case vmIntrinsics::_dilithiumDecomposePoly:\n+    return inline_dilithiumDecomposePoly();\n@@ -684,3 +694,2 @@\n-    return inline_min_max(intrinsic_id());\n-\n-  case vmIntrinsics::_maxF:\n+  case vmIntrinsics::_minL:\n+  case vmIntrinsics::_maxL:\n@@ -688,1 +697,1 @@\n-  case vmIntrinsics::_maxD:\n+  case vmIntrinsics::_maxF:\n@@ -690,1 +699,1 @@\n-  case vmIntrinsics::_maxF_strict:\n+  case vmIntrinsics::_maxD:\n@@ -692,1 +701,1 @@\n-  case vmIntrinsics::_maxD_strict:\n+  case vmIntrinsics::_maxF_strict:\n@@ -694,1 +703,2 @@\n-      return inline_fp_min_max(intrinsic_id());\n+  case vmIntrinsics::_maxD_strict:\n+    return inline_min_max(intrinsic_id());\n@@ -1714,14 +1724,0 @@\n-\/\/--------------------------round_double_node--------------------------------\n-\/\/ Round a double node if necessary.\n-Node* LibraryCallKit::round_double_node(Node* n) {\n-  if (Matcher::strict_fp_requires_explicit_rounding) {\n-#ifdef IA32\n-    if (UseSSE < 2) {\n-      n = _gvn.transform(new RoundDoubleNode(nullptr, n));\n-    }\n-#else\n-    Unimplemented();\n-#endif \/\/ IA32\n-  }\n-  return n;\n-}\n@@ -1736,1 +1732,1 @@\n-  Node* arg = round_double_node(argument(0));\n+  Node* arg = argument(0);\n@@ -1747,1 +1743,1 @@\n-  case vmIntrinsics::_dcopySign: n = CopySignDNode::make(_gvn, arg, round_double_node(argument(2))); break;\n+  case vmIntrinsics::_dcopySign: n = CopySignDNode::make(_gvn, arg, argument(2)); break;\n@@ -1781,2 +1777,2 @@\n-  Node* a = round_double_node(argument(0));\n-  Node* b = (call_type == OptoRuntime::Math_DD_D_Type()) ? round_double_node(argument(2)) : nullptr;\n+  Node* a = argument(0);\n+  Node* b = (call_type == OptoRuntime::Math_DD_D_Type()) ? argument(2) : nullptr;\n@@ -1800,1 +1796,1 @@\n-  Node* exp = round_double_node(argument(2));\n+  Node* exp = argument(2);\n@@ -1805,1 +1801,1 @@\n-      Node* base = round_double_node(argument(0));\n+      Node* base = argument(0);\n@@ -1810,1 +1806,1 @@\n-      Node* base = round_double_node(argument(0));\n+      Node* base = argument(0);\n@@ -1935,1 +1931,72 @@\n-  set_result(generate_min_max(id, argument(0), argument(1)));\n+  Node* a = nullptr;\n+  Node* b = nullptr;\n+  Node* n = nullptr;\n+  switch (id) {\n+    case vmIntrinsics::_min:\n+    case vmIntrinsics::_max:\n+    case vmIntrinsics::_minF:\n+    case vmIntrinsics::_maxF:\n+    case vmIntrinsics::_minF_strict:\n+    case vmIntrinsics::_maxF_strict:\n+    case vmIntrinsics::_min_strict:\n+    case vmIntrinsics::_max_strict:\n+      assert(callee()->signature()->size() == 2, \"minF\/maxF has 2 parameters of size 1 each.\");\n+      a = argument(0);\n+      b = argument(1);\n+      break;\n+    case vmIntrinsics::_minD:\n+    case vmIntrinsics::_maxD:\n+    case vmIntrinsics::_minD_strict:\n+    case vmIntrinsics::_maxD_strict:\n+      assert(callee()->signature()->size() == 4, \"minD\/maxD has 2 parameters of size 2 each.\");\n+      a = argument(0);\n+      b = argument(2);\n+      break;\n+    case vmIntrinsics::_minL:\n+    case vmIntrinsics::_maxL:\n+      assert(callee()->signature()->size() == 4, \"minL\/maxL has 2 parameters of size 2 each.\");\n+      a = argument(0);\n+      b = argument(2);\n+      break;\n+    default:\n+      fatal_unexpected_iid(id);\n+      break;\n+  }\n+\n+  switch (id) {\n+    case vmIntrinsics::_min:\n+    case vmIntrinsics::_min_strict:\n+      n = new MinINode(a, b);\n+      break;\n+    case vmIntrinsics::_max:\n+    case vmIntrinsics::_max_strict:\n+      n = new MaxINode(a, b);\n+      break;\n+    case vmIntrinsics::_minF:\n+    case vmIntrinsics::_minF_strict:\n+      n = new MinFNode(a, b);\n+      break;\n+    case vmIntrinsics::_maxF:\n+    case vmIntrinsics::_maxF_strict:\n+      n = new MaxFNode(a, b);\n+      break;\n+    case vmIntrinsics::_minD:\n+    case vmIntrinsics::_minD_strict:\n+      n = new MinDNode(a, b);\n+      break;\n+    case vmIntrinsics::_maxD:\n+    case vmIntrinsics::_maxD_strict:\n+      n = new MaxDNode(a, b);\n+      break;\n+    case vmIntrinsics::_minL:\n+      n = new MinLNode(_gvn.C, a, b);\n+      break;\n+    case vmIntrinsics::_maxL:\n+      n = new MaxLNode(_gvn.C, a, b);\n+      break;\n+    default:\n+      fatal_unexpected_iid(id);\n+      break;\n+  }\n+\n+  set_result(_gvn.transform(n));\n@@ -2014,19 +2081,0 @@\n-Node*\n-LibraryCallKit::generate_min_max(vmIntrinsics::ID id, Node* x0, Node* y0) {\n-  Node* result_val = nullptr;\n-  switch (id) {\n-  case vmIntrinsics::_min:\n-  case vmIntrinsics::_min_strict:\n-    result_val = _gvn.transform(new MinINode(x0, y0));\n-    break;\n-  case vmIntrinsics::_max:\n-  case vmIntrinsics::_max_strict:\n-    result_val = _gvn.transform(new MaxINode(x0, y0));\n-    break;\n-  default:\n-    fatal_unexpected_iid(id);\n-    break;\n-  }\n-  return result_val;\n-}\n-\n@@ -3009,1 +3057,1 @@\n-  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(),\n+  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(),\n@@ -3039,1 +3087,1 @@\n-    Node* array_kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(),\n+    Node* array_kls = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(),\n@@ -3095,1 +3143,2 @@\n-  Node* notified_reset_memory = store_to_memory(control(), notified_offset, _gvn.intcon(0), T_BOOLEAN, MemNode::unordered);\n+  store_to_memory(control(), notified_offset, _gvn.intcon(0), T_BOOLEAN, MemNode::unordered);\n+  Node* notified_reset_memory = reset_memory();\n@@ -3113,6 +3162,4 @@\n-  Node* commit_memory;\n-#ifdef _LP64\n-  commit_memory = store_to_memory(control(), java_buffer_pos_offset, next_pos_X, T_LONG, MemNode::release);\n-#else\n-  commit_memory = store_to_memory(control(), java_buffer_pos_offset, next_pos_X, T_INT, MemNode::release);\n-#endif\n+  store_to_memory(control(), java_buffer_pos_offset, next_pos_X, LP64_ONLY(T_LONG) NOT_LP64(T_INT), MemNode::release);\n+\n+  Node* commit_memory = reset_memory();\n+  set_all_memory(commit_memory);\n@@ -3833,1 +3880,1 @@\n-  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeRawPtr::BOTTOM, kls_type));\n+  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p, TypeRawPtr::BOTTOM, kls_type));\n@@ -3894,15 +3941,0 @@\n-  case vmIntrinsics::_getModifiers:\n-    prim_return_value = intcon(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);\n-    return_type = TypeInt::CHAR;\n-    break;\n-  case vmIntrinsics::_isInterface:\n-    prim_return_value = intcon(0);\n-    break;\n-  case vmIntrinsics::_isArray:\n-    prim_return_value = intcon(0);\n-    expect_prim = true;  \/\/ cf. ObjectStreamClass.getClassSignature\n-    break;\n-  case vmIntrinsics::_isPrimitive:\n-    prim_return_value = intcon(1);\n-    expect_prim = true;  \/\/ obviously\n-    break;\n@@ -3977,27 +4009,0 @@\n-  case vmIntrinsics::_getModifiers:\n-    p = basic_plus_adr(kls, in_bytes(Klass::modifier_flags_offset()));\n-    query_value = make_load(nullptr, p, TypeInt::CHAR, T_CHAR, MemNode::unordered);\n-    break;\n-\n-  case vmIntrinsics::_isInterface:\n-    \/\/ (To verify this code sequence, check the asserts in JVM_IsInterface.)\n-    if (generate_interface_guard(kls, region) != nullptr)\n-      \/\/ A guard was added.  If the guard is taken, it was an interface.\n-      phi->add_req(intcon(1));\n-    \/\/ If we fall through, it's a plain class.\n-    query_value = intcon(0);\n-    break;\n-\n-  case vmIntrinsics::_isArray:\n-    \/\/ (To verify this code sequence, check the asserts in JVM_IsArrayClass.)\n-    if (generate_array_guard(kls, region) != nullptr)\n-      \/\/ A guard was added.  If the guard is taken, it was an array.\n-      phi->add_req(intcon(1));\n-    \/\/ If we fall through, it's a plain class.\n-    query_value = intcon(0);\n-    break;\n-\n-  case vmIntrinsics::_isPrimitive:\n-    query_value = intcon(0); \/\/ \"normal\" path produces false\n-    break;\n-\n@@ -4029,1 +4034,1 @@\n-    kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeInstKlassPtr::OBJECT_OR_NULL));\n+    kls = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeInstKlassPtr::OBJECT_OR_NULL));\n@@ -4183,1 +4188,1 @@\n-    Node* kls = LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, adr_type, kls_type);\n+    Node* kls = LoadKlassNode::make(_gvn, immutable_memory(), p, adr_type, kls_type);\n@@ -4491,1 +4496,1 @@\n-      Node* moved = generate_min_max(vmIntrinsics::_min, orig_tail, length);\n+      Node* moved = _gvn.transform(new MinINode(orig_tail, length));\n@@ -6745,1 +6750,1 @@\n-  assert(UseCRC32Intrinsics, \"need AVX and LCMUL instructions support\");\n+  assert(UseCRC32Intrinsics, \"need AVX and CLMUL instructions support\");\n@@ -6780,1 +6785,1 @@\n-  assert(UseCRC32Intrinsics, \"need AVX and LCMUL instructions support\");\n+  assert(UseCRC32Intrinsics, \"need AVX and CLMUL instructions support\");\n@@ -6824,1 +6829,1 @@\n-  assert(UseCRC32Intrinsics, \"need AVX and LCMUL instructions support\");\n+  assert(UseCRC32Intrinsics, \"need AVX and CLMUL instructions support\");\n@@ -7781,0 +7786,170 @@\n+\/\/------------------------------inline_dilithiumAlmostNtt\n+bool LibraryCallKit::inline_dilithiumAlmostNtt() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseDilithiumIntrinsics, \"need Dilithium intrinsics support\");\n+  assert(callee()->signature()->size() == 2, \"dilithiumAlmostNtt has 2 parameters\");\n+\n+  stubAddr = StubRoutines::dilithiumAlmostNtt();\n+  stubName = \"dilithiumAlmostNtt\";\n+  if (!stubAddr) return false;\n+\n+  Node* coeffs          = argument(0);\n+  Node* ntt_zetas        = argument(1);\n+\n+  coeffs = must_be_not_null(coeffs, true);\n+  ntt_zetas = must_be_not_null(ntt_zetas, true);\n+\n+  Node* coeffs_start  = array_element_address(coeffs, intcon(0), T_INT);\n+  assert(coeffs_start, \"coeffs is null\");\n+  Node* ntt_zetas_start  = array_element_address(ntt_zetas, intcon(0), T_INT);\n+  assert(ntt_zetas_start, \"ntt_zetas is null\");\n+  Node* dilithiumAlmostNtt = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                  OptoRuntime::dilithiumAlmostNtt_Type(),\n+                                  stubAddr, stubName, TypePtr::BOTTOM,\n+                                  coeffs_start, ntt_zetas_start);\n+  \/\/ return an int\n+  Node* retvalue = _gvn.transform(new ProjNode(dilithiumAlmostNtt, TypeFunc::Parms));\n+  set_result(retvalue);\n+  return true;\n+}\n+\n+\/\/------------------------------inline_dilithiumAlmostInverseNtt\n+bool LibraryCallKit::inline_dilithiumAlmostInverseNtt() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseDilithiumIntrinsics, \"need Dilithium intrinsics support\");\n+  assert(callee()->signature()->size() == 2, \"dilithiumAlmostInverseNtt has 2 parameters\");\n+\n+  stubAddr = StubRoutines::dilithiumAlmostInverseNtt();\n+  stubName = \"dilithiumAlmostInverseNtt\";\n+  if (!stubAddr) return false;\n+\n+  Node* coeffs          = argument(0);\n+  Node* zetas           = argument(1);\n+\n+  coeffs = must_be_not_null(coeffs, true);\n+  zetas = must_be_not_null(zetas, true);\n+\n+  Node* coeffs_start  = array_element_address(coeffs, intcon(0), T_INT);\n+  assert(coeffs_start, \"coeffs is null\");\n+  Node* zetas_start  = array_element_address(zetas, intcon(0), T_INT);\n+  assert(zetas_start, \"inverseNtt_zetas is null\");\n+  Node* dilithiumAlmostInverseNtt = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                  OptoRuntime::dilithiumAlmostInverseNtt_Type(),\n+                                  stubAddr, stubName, TypePtr::BOTTOM,\n+                                  coeffs_start, zetas_start);\n+\n+  \/\/ return an int\n+  Node* retvalue = _gvn.transform(new ProjNode(dilithiumAlmostInverseNtt, TypeFunc::Parms));\n+  set_result(retvalue);\n+  return true;\n+}\n+\n+\/\/------------------------------inline_dilithiumNttMult\n+bool LibraryCallKit::inline_dilithiumNttMult() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseDilithiumIntrinsics, \"need Dilithium intrinsics support\");\n+  assert(callee()->signature()->size() == 3, \"dilithiumNttMult has 3 parameters\");\n+\n+  stubAddr = StubRoutines::dilithiumNttMult();\n+  stubName = \"dilithiumNttMult\";\n+  if (!stubAddr) return false;\n+\n+  Node* result          = argument(0);\n+  Node* ntta            = argument(1);\n+  Node* nttb            = argument(2);\n+\n+  result = must_be_not_null(result, true);\n+  ntta = must_be_not_null(ntta, true);\n+  nttb = must_be_not_null(nttb, true);\n+\n+  Node* result_start  = array_element_address(result, intcon(0), T_INT);\n+  assert(result_start, \"result is null\");\n+  Node* ntta_start  = array_element_address(ntta, intcon(0), T_INT);\n+  assert(ntta_start, \"ntta is null\");\n+  Node* nttb_start  = array_element_address(nttb, intcon(0), T_INT);\n+  assert(nttb_start, \"nttb is null\");\n+  Node* dilithiumNttMult = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                  OptoRuntime::dilithiumNttMult_Type(),\n+                                  stubAddr, stubName, TypePtr::BOTTOM,\n+                                  result_start, ntta_start, nttb_start);\n+\n+  \/\/ return an int\n+  Node* retvalue = _gvn.transform(new ProjNode(dilithiumNttMult, TypeFunc::Parms));\n+  set_result(retvalue);\n+\n+  return true;\n+}\n+\n+\/\/------------------------------inline_dilithiumMontMulByConstant\n+bool LibraryCallKit::inline_dilithiumMontMulByConstant() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseDilithiumIntrinsics, \"need Dilithium intrinsics support\");\n+  assert(callee()->signature()->size() == 2, \"dilithiumMontMulByConstant has 2 parameters\");\n+\n+  stubAddr = StubRoutines::dilithiumMontMulByConstant();\n+  stubName = \"dilithiumMontMulByConstant\";\n+  if (!stubAddr) return false;\n+\n+  Node* coeffs          = argument(0);\n+  Node* constant        = argument(1);\n+\n+  coeffs = must_be_not_null(coeffs, true);\n+\n+  Node* coeffs_start  = array_element_address(coeffs, intcon(0), T_INT);\n+  assert(coeffs_start, \"coeffs is null\");\n+  Node* dilithiumMontMulByConstant = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                  OptoRuntime::dilithiumMontMulByConstant_Type(),\n+                                  stubAddr, stubName, TypePtr::BOTTOM,\n+                                  coeffs_start, constant);\n+\n+  \/\/ return an int\n+  Node* retvalue = _gvn.transform(new ProjNode(dilithiumMontMulByConstant, TypeFunc::Parms));\n+  set_result(retvalue);\n+  return true;\n+}\n+\n+\n+\/\/------------------------------inline_dilithiumDecomposePoly\n+bool LibraryCallKit::inline_dilithiumDecomposePoly() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseDilithiumIntrinsics, \"need Dilithium intrinsics support\");\n+  assert(callee()->signature()->size() == 5, \"dilithiumDecomposePoly has 5 parameters\");\n+\n+  stubAddr = StubRoutines::dilithiumDecomposePoly();\n+  stubName = \"dilithiumDecomposePoly\";\n+  if (!stubAddr) return false;\n+\n+  Node* input          = argument(0);\n+  Node* lowPart        = argument(1);\n+  Node* highPart       = argument(2);\n+  Node* twoGamma2      = argument(3);\n+  Node* multiplier     = argument(4);\n+\n+  input = must_be_not_null(input, true);\n+  lowPart = must_be_not_null(lowPart, true);\n+  highPart = must_be_not_null(highPart, true);\n+\n+  Node* input_start  = array_element_address(input, intcon(0), T_INT);\n+  assert(input_start, \"input is null\");\n+  Node* lowPart_start  = array_element_address(lowPart, intcon(0), T_INT);\n+  assert(lowPart_start, \"lowPart is null\");\n+  Node* highPart_start  = array_element_address(highPart, intcon(0), T_INT);\n+  assert(highPart_start, \"highPart is null\");\n+\n+  Node* dilithiumDecomposePoly = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                  OptoRuntime::dilithiumDecomposePoly_Type(),\n+                                  stubAddr, stubName, TypePtr::BOTTOM,\n+                                  input_start, lowPart_start, highPart_start,\n+                                  twoGamma2, multiplier);\n+\n+  \/\/ return an int\n+  Node* retvalue = _gvn.transform(new ProjNode(dilithiumDecomposePoly, TypeFunc::Parms));\n+  set_result(retvalue);\n+  return true;\n+}\n+\n@@ -8044,0 +8219,32 @@\n+\/\/------------------------------inline_double_keccak\n+bool LibraryCallKit::inline_double_keccak() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseSHA3Intrinsics, \"need SHA3 intrinsics support\");\n+  assert(callee()->signature()->size() == 2, \"double_keccak has 2 parameters\");\n+\n+  stubAddr = StubRoutines::double_keccak();\n+  stubName = \"double_keccak\";\n+  if (!stubAddr) return false;\n+\n+  Node* status0        = argument(0);\n+  Node* status1        = argument(1);\n+\n+  status0 = must_be_not_null(status0, true);\n+  status1 = must_be_not_null(status1, true);\n+\n+  Node* status0_start  = array_element_address(status0, intcon(0), T_LONG);\n+  assert(status0_start, \"status0 is null\");\n+  Node* status1_start  = array_element_address(status1, intcon(0), T_LONG);\n+  assert(status1_start, \"status1 is null\");\n+  Node* double_keccak = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                  OptoRuntime::double_keccak_Type(),\n+                                  stubAddr, stubName, TypePtr::BOTTOM,\n+                                  status0_start, status1_start);\n+  \/\/ return an int\n+  Node* retvalue = _gvn.transform(new ProjNode(double_keccak, TypeFunc::Parms));\n+  set_result(retvalue);\n+  return true;\n+}\n+\n+\n@@ -8411,3 +8618,3 @@\n-    a = round_double_node(argument(0));\n-    b = round_double_node(argument(2));\n-    c = round_double_node(argument(4));\n+    a = argument(0);\n+    b = argument(2);\n+    c = argument(4);\n@@ -8456,85 +8663,0 @@\n-\/\/------------------------------inline_fp_min_max------------------------------\n-bool LibraryCallKit::inline_fp_min_max(vmIntrinsics::ID id) {\n-\/* DISABLED BECAUSE METHOD DATA ISN'T COLLECTED PER CALL-SITE, SEE JDK-8015416.\n-\n-  \/\/ The intrinsic should be used only when the API branches aren't predictable,\n-  \/\/ the last one performing the most important comparison. The following heuristic\n-  \/\/ uses the branch statistics to eventually bail out if necessary.\n-\n-  ciMethodData *md = callee()->method_data();\n-\n-  if ( md != nullptr && md->is_mature() && md->invocation_count() > 0 ) {\n-    ciCallProfile cp = caller()->call_profile_at_bci(bci());\n-\n-    if ( ((double)cp.count()) \/ ((double)md->invocation_count()) < 0.8 ) {\n-      \/\/ Bail out if the call-site didn't contribute enough to the statistics.\n-      return false;\n-    }\n-\n-    uint taken = 0, not_taken = 0;\n-\n-    for (ciProfileData *p = md->first_data(); md->is_valid(p); p = md->next_data(p)) {\n-      if (p->is_BranchData()) {\n-        taken = ((ciBranchData*)p)->taken();\n-        not_taken = ((ciBranchData*)p)->not_taken();\n-      }\n-    }\n-\n-    double balance = (((double)taken) - ((double)not_taken)) \/ ((double)md->invocation_count());\n-    balance = balance < 0 ? -balance : balance;\n-    if ( balance > 0.2 ) {\n-      \/\/ Bail out if the most important branch is predictable enough.\n-      return false;\n-    }\n-  }\n-*\/\n-\n-  Node *a = nullptr;\n-  Node *b = nullptr;\n-  Node *n = nullptr;\n-  switch (id) {\n-  case vmIntrinsics::_maxF:\n-  case vmIntrinsics::_minF:\n-  case vmIntrinsics::_maxF_strict:\n-  case vmIntrinsics::_minF_strict:\n-    assert(callee()->signature()->size() == 2, \"minF\/maxF has 2 parameters of size 1 each.\");\n-    a = argument(0);\n-    b = argument(1);\n-    break;\n-  case vmIntrinsics::_maxD:\n-  case vmIntrinsics::_minD:\n-  case vmIntrinsics::_maxD_strict:\n-  case vmIntrinsics::_minD_strict:\n-    assert(callee()->signature()->size() == 4, \"minD\/maxD has 2 parameters of size 2 each.\");\n-    a = round_double_node(argument(0));\n-    b = round_double_node(argument(2));\n-    break;\n-  default:\n-    fatal_unexpected_iid(id);\n-    break;\n-  }\n-  switch (id) {\n-  case vmIntrinsics::_maxF:\n-  case vmIntrinsics::_maxF_strict:\n-    n = new MaxFNode(a, b);\n-    break;\n-  case vmIntrinsics::_minF:\n-  case vmIntrinsics::_minF_strict:\n-    n = new MinFNode(a, b);\n-    break;\n-  case vmIntrinsics::_maxD:\n-  case vmIntrinsics::_maxD_strict:\n-    n = new MaxDNode(a, b);\n-    break;\n-  case vmIntrinsics::_minD:\n-  case vmIntrinsics::_minD_strict:\n-    n = new MinDNode(a, b);\n-    break;\n-  default:\n-    fatal_unexpected_iid(id);\n-    break;\n-  }\n-  set_result(_gvn.transform(n));\n-  return true;\n-}\n-\n@@ -8765,0 +8887,109 @@\n+\n+Node* LibraryCallKit::unbox_fp16_value(const TypeInstPtr* float16_box_type, ciField* field, Node* box) {\n+  const TypeInstPtr* box_type = _gvn.type(box)->isa_instptr();\n+  if (box_type == nullptr || box_type->instance_klass() != float16_box_type->instance_klass()) {\n+    return nullptr; \/\/ box klass is not Float16\n+  }\n+\n+  \/\/ Null check; get notnull casted pointer\n+  Node* null_ctl = top();\n+  Node* not_null_box = null_check_oop(box, &null_ctl, true);\n+  \/\/ If not_null_box is dead, only null-path is taken\n+  if (stopped()) {\n+    set_control(null_ctl);\n+    return nullptr;\n+  }\n+  assert(not_null_box->bottom_type()->is_instptr()->maybe_null() == false, \"\");\n+  const TypePtr* adr_type = C->alias_type(field)->adr_type();\n+  Node* adr = basic_plus_adr(not_null_box, field->offset_in_bytes());\n+  return access_load_at(not_null_box, adr, adr_type, TypeInt::SHORT, T_SHORT, IN_HEAP);\n+}\n+\n+Node* LibraryCallKit::box_fp16_value(const TypeInstPtr* float16_box_type, ciField* field, Node* value) {\n+  PreserveReexecuteState preexecs(this);\n+  jvms()->set_should_reexecute(true);\n+\n+  const TypeKlassPtr* klass_type = float16_box_type->as_klass_type();\n+  Node* klass_node = makecon(klass_type);\n+  Node* box = new_instance(klass_node);\n+\n+  Node* value_field = basic_plus_adr(box, field->offset_in_bytes());\n+  const TypePtr* value_adr_type = value_field->bottom_type()->is_ptr();\n+\n+  Node* field_store = _gvn.transform(access_store_at(box,\n+                                                     value_field,\n+                                                     value_adr_type,\n+                                                     value,\n+                                                     TypeInt::SHORT,\n+                                                     T_SHORT,\n+                                                     IN_HEAP));\n+  set_memory(field_store, value_adr_type);\n+  return box;\n+}\n+\n+bool LibraryCallKit::inline_fp16_operations(vmIntrinsics::ID id, int num_args) {\n+  if (!Matcher::match_rule_supported(Op_ReinterpretS2HF) ||\n+      !Matcher::match_rule_supported(Op_ReinterpretHF2S)) {\n+    return false;\n+  }\n+\n+  const TypeInstPtr* box_type = _gvn.type(argument(0))->isa_instptr();\n+  if (box_type == nullptr || box_type->const_oop() == nullptr) {\n+    return false;\n+  }\n+\n+  ciInstanceKlass* float16_klass = box_type->const_oop()->as_instance()->java_lang_Class_klass()->as_instance_klass();\n+  const TypeInstPtr* float16_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, float16_klass);\n+  ciField* field = float16_klass->get_field_by_name(ciSymbols::value_name(),\n+                                                    ciSymbols::short_signature(),\n+                                                    false);\n+  assert(field != nullptr, \"\");\n+\n+  \/\/ Transformed nodes\n+  Node* fld1 = nullptr;\n+  Node* fld2 = nullptr;\n+  Node* fld3 = nullptr;\n+  switch(num_args) {\n+    case 3:\n+      fld3 = unbox_fp16_value(float16_box_type, field, argument(3));\n+      if (fld3 == nullptr) {\n+        return false;\n+      }\n+      fld3 = _gvn.transform(new ReinterpretS2HFNode(fld3));\n+    \/\/ fall-through\n+    case 2:\n+      fld2 = unbox_fp16_value(float16_box_type, field, argument(2));\n+      if (fld2 == nullptr) {\n+        return false;\n+      }\n+      fld2 = _gvn.transform(new ReinterpretS2HFNode(fld2));\n+    \/\/ fall-through\n+    case 1:\n+      fld1 = unbox_fp16_value(float16_box_type, field, argument(1));\n+      if (fld1 == nullptr) {\n+        return false;\n+      }\n+      fld1 = _gvn.transform(new ReinterpretS2HFNode(fld1));\n+      break;\n+    default: fatal(\"Unsupported number of arguments %d\", num_args);\n+  }\n+\n+  Node* result = nullptr;\n+  switch (id) {\n+    \/\/ Unary operations\n+    case vmIntrinsics::_sqrt_float16:\n+      result = _gvn.transform(new SqrtHFNode(C, control(), fld1));\n+      break;\n+    \/\/ Ternary operations\n+    case vmIntrinsics::_fma_float16:\n+      result = _gvn.transform(new FmaHFNode(fld1, fld2, fld3));\n+      break;\n+    default:\n+      fatal_unexpected_iid(id);\n+      break;\n+  }\n+  result = _gvn.transform(new ReinterpretHF2SNode(result));\n+  set_result(box_fp16_value(float16_box_type, field, result));\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":430,"deletions":199,"binary":false,"changes":629,"status":"modified"},{"patch":"@@ -2341,1 +2341,1 @@\n-      subklass = _igvn.transform(LoadKlassNode::make(_igvn, nullptr, C->immutable_memory(), k_adr, TypeInstPtr::KLASS));\n+      subklass = _igvn.transform(LoadKlassNode::make(_igvn, C->immutable_memory(), k_adr, TypeInstPtr::KLASS));\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1975,6 +1975,0 @@\n-  if (tkls->offset() == in_bytes(Klass::modifier_flags_offset())) {\n-    \/\/ The field is Klass::_modifier_flags.  Return its (constant) value.\n-    \/\/ (Folds up the 2nd indirection in aClassConstant.getModifiers().)\n-    assert(Opcode() == Op_LoadUS, \"must load an unsigned short from _modifier_flags\");\n-    return TypeInt::make(klass->modifier_flags());\n-  }\n@@ -2401,1 +2395,1 @@\n-Node* LoadKlassNode::make(PhaseGVN& gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* at, const TypeKlassPtr* tk) {\n+Node* LoadKlassNode::make(PhaseGVN& gvn, Node* mem, Node* adr, const TypePtr* at, const TypeKlassPtr* tk) {\n@@ -2403,1 +2397,1 @@\n-  const TypePtr *adr_type = adr->bottom_type()->isa_ptr();\n+  const TypePtr* adr_type = adr->bottom_type()->isa_ptr();\n@@ -2408,1 +2402,1 @@\n-    Node* load_klass = gvn.transform(new LoadNKlassNode(ctl, mem, adr, at, tk->make_narrowklass(), MemNode::unordered));\n+    Node* load_klass = gvn.transform(new LoadNKlassNode(mem, adr, at, tk->make_narrowklass(), MemNode::unordered));\n@@ -2413,1 +2407,1 @@\n-  return new LoadKlassNode(ctl, mem, adr, at, tk, MemNode::unordered);\n+  return new LoadKlassNode(mem, adr, at, tk, MemNode::unordered);\n@@ -2421,6 +2415,0 @@\n-\/\/ In most cases, LoadKlassNode does not have the control input set. If the control\n-\/\/ input is set, it must not be removed (by LoadNode::Ideal()).\n-bool LoadKlassNode::can_remove_control() const {\n-  return false;\n-}\n-\n@@ -2464,1 +2452,1 @@\n-        \/\/ (Folds up the 1st indirection in aClassConstant.getModifiers().)\n+        \/\/ Fold up the load of the hidden field\n@@ -2789,0 +2777,21 @@\n+  \/\/ State machine with initial state Unknown\n+  \/\/ Allowed transitions:\n+  \/\/   Unknown     -> Const\n+  \/\/   Unknown     -> Platform\n+  \/\/   Unknown     -> Reverse\n+  \/\/   Unknown     -> NotAdjacent\n+  \/\/   Const       -> Const\n+  \/\/   Const       -> NotAdjacent\n+  \/\/   Platform    -> Platform\n+  \/\/   Platform    -> NotAdjacent\n+  \/\/   Reverse     -> Reverse\n+  \/\/   Reverse     -> NotAdjacent\n+  \/\/   NotAdjacent -> NotAdjacent\n+  enum ValueOrder : uint8_t {\n+    Unknown,     \/\/ Initial state\n+    Const,       \/\/ Input values are const\n+    Platform,    \/\/ Platform order\n+    Reverse,     \/\/ Reverse platform order\n+    NotAdjacent  \/\/ Not adjacent\n+  };\n+  ValueOrder  _value_order;\n@@ -2794,1 +2803,1 @@\n-    _phase(phase), _store(store)\n+    _phase(phase), _store(store), _value_order(ValueOrder::Unknown)\n@@ -2804,1 +2813,1 @@\n-  static bool is_con_RShift(const Node* n, Node const*& base_out, jint& shift_out);\n+  static bool is_con_RShift(const Node* n, Node const*& base_out, jint& shift_out, PhaseGVN* phase);\n@@ -2840,0 +2849,1 @@\n+  enum ValueOrder find_adjacent_input_value_order(const Node* n1, const Node* n2, const int memory_size) const;\n@@ -2901,1 +2911,2 @@\n-  if (status_def.found_store() == nullptr) {\n+  Node* def_store = status_def.found_store();\n+  if (def_store == nullptr) {\n@@ -2905,0 +2916,6 @@\n+  \/\/ Initialize value order\n+  _value_order = find_adjacent_input_value_order(def_store->in(MemNode::ValueIn),\n+                                                 _store->in(MemNode::ValueIn),\n+                                                 _store->memory_size());\n+  assert(_value_order != ValueOrder::NotAdjacent && _value_order != ValueOrder::Unknown, \"Order should be checked\");\n+\n@@ -2951,1 +2968,3 @@\n-bool MergePrimitiveStores::is_adjacent_input_pair(const Node* n1, const Node* n2, const int memory_size) const {\n+\/\/ Check input values n1 and n2 can be merged and return the value order\n+MergePrimitiveStores::ValueOrder MergePrimitiveStores::find_adjacent_input_value_order(const Node* n1, const Node* n2,\n+                                                                                       const int memory_size) const {\n@@ -2953,2 +2972,2 @@\n-  if (n1->Opcode() == Op_ConI) {\n-    return n2->Opcode() == Op_ConI;\n+  if (n1->Opcode() == Op_ConI && n2->Opcode() == Op_ConI) {\n+    return ValueOrder::Const;\n@@ -2957,7 +2976,1 @@\n-  \/\/ Pattern: [n1 = base >> shift, n2 = base >> (shift + memory_size)]\n-#ifndef VM_LITTLE_ENDIAN\n-  \/\/ Pattern: [n1 = base >> (shift + memory_size), n2 = base >> shift]\n-  \/\/ Swapping n1 with n2 gives same pattern as on little endian platforms.\n-  swap(n1, n2);\n-#endif \/\/ !VM_LITTLE_ENDIAN\n-  Node const* base_n2;\n+  Node const *base_n2;\n@@ -2965,6 +2978,2 @@\n-  if (!is_con_RShift(n2, base_n2, shift_n2)) {\n-    return false;\n-  }\n-  if (n1->Opcode() == Op_ConvL2I) {\n-    \/\/ look through\n-    n1 = n1->in(1);\n+  if (!is_con_RShift(n2, base_n2, shift_n2, _phase)) {\n+    return ValueOrder::NotAdjacent;\n@@ -2972,1 +2981,1 @@\n-  Node const* base_n1;\n+  Node const *base_n1;\n@@ -2974,6 +2983,2 @@\n-  if (n1 == base_n2) {\n-    \/\/ n1 = base = base >> 0\n-    base_n1 = n1;\n-    shift_n1 = 0;\n-  } else if (!is_con_RShift(n1, base_n1, shift_n1)) {\n-    return false;\n+  if (!is_con_RShift(n1, base_n1, shift_n1, _phase)) {\n+    return ValueOrder::NotAdjacent;\n@@ -2981,0 +2986,1 @@\n+\n@@ -2983,1 +2989,1 @@\n-      shift_n1 + bits_per_store != shift_n2 ||\n+      abs(shift_n1 - shift_n2) != bits_per_store ||\n@@ -2985,1 +2991,2 @@\n-    return false;\n+    \/\/ Values are not adjacent\n+    return ValueOrder::NotAdjacent;\n@@ -2988,2 +2995,38 @@\n-  \/\/ both load from same value with correct shift\n-  return true;\n+  \/\/ Detect value order\n+#ifdef VM_LITTLE_ENDIAN\n+  return shift_n1 < shift_n2 ? ValueOrder::Platform     \/\/ Pattern: [n1 = base >> shift, n2 = base >> (shift + memory_size)]\n+                             : ValueOrder::Reverse;     \/\/ Pattern: [n1 = base >> (shift + memory_size), n2 = base >> shift]\n+#else\n+  return shift_n1 > shift_n2 ? ValueOrder::Platform     \/\/ Pattern: [n1 = base >> (shift + memory_size), n2 = base >> shift]\n+                             : ValueOrder::Reverse;     \/\/ Pattern: [n1 = base >> shift, n2 = base >> (shift + memory_size)]\n+#endif\n+}\n+\n+bool MergePrimitiveStores::is_adjacent_input_pair(const Node* n1, const Node* n2, const int memory_size) const {\n+  ValueOrder input_value_order = find_adjacent_input_value_order(n1, n2, memory_size);\n+\n+  switch (input_value_order) {\n+    case ValueOrder::NotAdjacent:\n+      return false;\n+    case ValueOrder::Reverse:\n+      if (memory_size != 1 ||\n+          !Matcher::match_rule_supported(Op_ReverseBytesS) ||\n+          !Matcher::match_rule_supported(Op_ReverseBytesI) ||\n+          !Matcher::match_rule_supported(Op_ReverseBytesL)) {\n+        \/\/ ReverseBytes are not supported by platform\n+        return false;\n+      }\n+      \/\/ fall-through.\n+    case ValueOrder::Const:\n+    case ValueOrder::Platform:\n+      if (_value_order == ValueOrder::Unknown) {\n+        \/\/ Initial state is Unknown, and we find a valid input value order\n+        return true;\n+      }\n+      \/\/ The value order can not be changed\n+      return _value_order == input_value_order;\n+    case ValueOrder::Unknown:\n+    default:\n+      ShouldNotReachHere();\n+  }\n+  return false;\n@@ -2993,1 +3036,1 @@\n-bool MergePrimitiveStores::is_con_RShift(const Node* n, Node const*& base_out, jint& shift_out) {\n+bool MergePrimitiveStores::is_con_RShift(const Node* n, Node const*& base_out, jint& shift_out, PhaseGVN* phase) {\n@@ -3012,0 +3055,8 @@\n+\n+  if (phase->type(n)->isa_int()  != nullptr ||\n+      phase->type(n)->isa_long() != nullptr) {\n+    \/\/ (base >> 0)\n+    base_out = n;\n+    shift_out = 0;\n+    return true;\n+  }\n@@ -3178,0 +3229,1 @@\n+    assert(_value_order == ValueOrder::Const, \"must match\");\n@@ -3194,0 +3246,1 @@\n+    assert(_value_order == ValueOrder::Platform || _value_order == ValueOrder::Reverse, \"must match\");\n@@ -3204,0 +3257,3 @@\n+    if (_value_order == ValueOrder::Reverse) {\n+      swap(hi, lo);\n+    }\n@@ -3207,1 +3263,1 @@\n-    bool is_true = is_con_RShift(hi, hi_base, hi_shift);\n+    bool is_true = is_con_RShift(hi, hi_base, hi_shift, _phase);\n@@ -3233,0 +3289,11 @@\n+  if (_value_order == ValueOrder::Reverse) {\n+    assert(_store->memory_size() == 1, \"only implemented for bytes\");\n+    if (new_memory_size == 8) {\n+      merged_input_value = _phase->transform(new ReverseBytesLNode(merged_input_value));\n+    } else if (new_memory_size == 4) {\n+      merged_input_value = _phase->transform(new ReverseBytesINode(merged_input_value));\n+    } else {\n+      assert(new_memory_size == 2, \"sanity check\");\n+      merged_input_value = _phase->transform(new ReverseBytesSNode(merged_input_value));\n+    }\n+  }\n@@ -3386,1 +3453,1 @@\n-    if (phase->C->post_loop_opts_phase()) {\n+    if (phase->C->merge_stores_phase()) {\n@@ -3391,1 +3458,12 @@\n-      phase->C->record_for_post_loop_opts_igvn(this);\n+      \/\/ We need to wait with merging stores until RangeCheck smearing has removed the RangeChecks during\n+      \/\/ the post loops IGVN phase. If we do it earlier, then there may still be some RangeChecks between\n+      \/\/ the stores, and we merge the wrong sequence of stores.\n+      \/\/ Example:\n+      \/\/   StoreI RangeCheck StoreI StoreI RangeCheck StoreI\n+      \/\/ Apply MergeStores:\n+      \/\/   StoreI RangeCheck [   StoreL  ] RangeCheck StoreI\n+      \/\/ Remove more RangeChecks:\n+      \/\/   StoreI            [   StoreL  ]            StoreI\n+      \/\/ But now it would have been better to do this instead:\n+      \/\/   [         StoreL       ] [       StoreL         ]\n+      phase->C->record_for_merge_stores_igvn(this);\n@@ -3531,14 +3609,202 @@\n-\/\/ (StoreB ... (RShiftI _ (LShiftI _ valIn conIL ) conIR) )\n-\/\/ If (conIL == conIR && conIR <= num_bits)  this simplifies to\n-\/\/ (StoreB ... (valIn) )\n-Node *StoreNode::Ideal_sign_extended_input(PhaseGVN *phase, int num_bits) {\n-  Node *val = in(MemNode::ValueIn);\n-  if( val->Opcode() == Op_RShiftI ) {\n-    const TypeInt *t = phase->type( val->in(2) )->isa_int();\n-    if( t && t->is_con() && (t->get_con() <= num_bits) ) {\n-      Node *shl = val->in(1);\n-      if( shl->Opcode() == Op_LShiftI ) {\n-        const TypeInt *t2 = phase->type( shl->in(2) )->isa_int();\n-        if( t2 && t2->is_con() && (t2->get_con() == t->get_con()) ) {\n-          set_req_X(MemNode::ValueIn, shl->in(1), phase);\n-          return this;\n+\/\/ (StoreB ... (RShiftI _ (LShiftI _ v conIL) conIR))\n+\/\/ If (conIL == conIR && conIR <= num_rejected_bits) this simplifies to\n+\/\/ (StoreB ... (v))\n+\/\/ If (conIL > conIR) under some conditions, it can be simplified into\n+\/\/ (StoreB ... (LShiftI _ v (conIL - conIR)))\n+\/\/ This case happens when the value of the store was itself a left shift, that\n+\/\/ gets merged into the inner left shift of the sign-extension. For instance,\n+\/\/ if we have\n+\/\/ array_of_shorts[0] = (short)(v << 2)\n+\/\/ We get a structure such as:\n+\/\/ (StoreB ... (RShiftI _ (LShiftI _ (LShiftI _ v 2) 16) 16))\n+\/\/ that is simplified into\n+\/\/ (StoreB ... (RShiftI _ (LShiftI _ v 18) 16)).\n+\/\/ It is thus useful to handle cases where conIL > conIR. But this simplification\n+\/\/ does not always hold. Let's see in which cases it's valid.\n+\/\/\n+\/\/ Let's assume we have the following 32 bits integer v:\n+\/\/ +----------------------------------+\n+\/\/ |             v[0..31]             |\n+\/\/ +----------------------------------+\n+\/\/  31                               0\n+\/\/ that will be stuffed in 8 bits byte after a shift left and a shift right of\n+\/\/ potentially different magnitudes.\n+\/\/ We denote num_rejected_bits the number of bits of the discarded part. In this\n+\/\/ case, num_rejected_bits == 24.\n+\/\/\n+\/\/ Statement (proved further below in case analysis):\n+\/\/   Given:\n+\/\/   - 0 <= conIL < BitsPerJavaInteger   (no wrap in shift, enforced by maskShiftAmount)\n+\/\/   - 0 <= conIR < BitsPerJavaInteger   (no wrap in shift, enforced by maskShiftAmount)\n+\/\/   - conIL >= conIR\n+\/\/   - num_rejected_bits >= conIR\n+\/\/   Then this form:\n+\/\/      (RShiftI _ (LShiftI _ v conIL) conIR)\n+\/\/   can be replaced with this form:\n+\/\/      (LShiftI _ v (conIL-conIR))\n+\/\/\n+\/\/ Note: We only have to show that the non-rejected lowest bits (8 bits for byte)\n+\/\/       have to be correct, as the higher bits are rejected \/ truncated by the store.\n+\/\/\n+\/\/ The hypotheses\n+\/\/   0 <= conIL < BitsPerJavaInteger\n+\/\/   0 <= conIR < BitsPerJavaInteger\n+\/\/ are ensured by maskShiftAmount (called from ::Ideal of shift nodes). Indeed,\n+\/\/ (v << 31) << 2 must be simplified into 0, not into v << 33 (which is equivalent\n+\/\/ to v << 1).\n+\/\/\n+\/\/\n+\/\/ If you don't like case analysis, jump after the conclusion.\n+\/\/ ### Case 1 : conIL == conIR\n+\/\/ ###### Case 1.1: conIL == conIR == num_rejected_bits\n+\/\/ If we do the shift left then right by 24 bits, we get:\n+\/\/ after: v << 24\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..7] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     24 23                      0\n+\/\/ after: (v << 24) >> 24\n+\/\/ +------------------------+---------+\n+\/\/ |        sign bit        | v[0..7] |\n+\/\/ +------------------------+---------+\n+\/\/  31                     8 7        0\n+\/\/ The non-rejected bits (bits kept by the store, that is the 8 lower bits of the\n+\/\/ result) are the same before and after, so, indeed, simplifying is correct.\n+\n+\/\/ ###### Case 1.2: conIL == conIR < num_rejected_bits\n+\/\/ If we do the shift left then right by 22 bits, we get:\n+\/\/ after: v << 22\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..9] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     22 21                      0\n+\/\/ after: (v << 22) >> 22\n+\/\/ +------------------------+---------+\n+\/\/ |        sign bit        | v[0..9] |\n+\/\/ +------------------------+---------+\n+\/\/  31                    10 9        0\n+\/\/ The non-rejected bits are the 8 lower bits of v. The bits 8 and 9 of v are still\n+\/\/ present in (v << 22) >> 22 but will be dropped by the store. The simplification is\n+\/\/ still correct.\n+\n+\/\/ ###### But! Case 1.3: conIL == conIR > num_rejected_bits\n+\/\/ If we do the shift left then right by 26 bits, we get:\n+\/\/ after: v << 26\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..5] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     26 25                      0\n+\/\/ after: (v << 26) >> 26\n+\/\/ +------------------------+---------+\n+\/\/ |        sign bit        | v[0..5] |\n+\/\/ +------------------------+---------+\n+\/\/  31                     6 5        0\n+\/\/ The non-rejected bits are made of\n+\/\/ - 0-5 => the bits 0 to 5 of v\n+\/\/ - 6-7 => the sign bit of v[0..5] (that is v[5])\n+\/\/ Simplifying this as v is not correct.\n+\/\/ The condition conIR <= num_rejected_bits is indeed necessary in Case 1\n+\/\/\n+\/\/ ### Case 2: conIL > conIR\n+\/\/ ###### Case 2.1: num_rejected_bits == conIR\n+\/\/ We take conIL == 26 for this example.\n+\/\/ after: v << 26\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..5] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     26 25                      0\n+\/\/ after: (v << 26) >> 24\n+\/\/ +------------------+---------+-----+\n+\/\/ |     sign bit     | v[0..5] |  0  |\n+\/\/ +------------------+---------+-----+\n+\/\/  31               8 7       2 1   0\n+\/\/ The non-rejected bits are the 8 lower ones of (v << conIL - conIR).\n+\/\/ The bits 6 and 7 of v have been thrown away after the shift left.\n+\/\/ The simplification is still correct.\n+\/\/\n+\/\/ ###### Case 2.2: num_rejected_bits > conIR.\n+\/\/ Let's say conIL == 26 and conIR == 22.\n+\/\/ after: v << 26\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..5] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     26 25                      0\n+\/\/ after: (v << 26) >> 22\n+\/\/ +------------------+---------+-----+\n+\/\/ |     sign bit     | v[0..5] |  0  |\n+\/\/ +------------------+---------+-----+\n+\/\/  31              10 9       4 3   0\n+\/\/ The bits non-rejected by the store are exactly the 8 lower ones of (v << (conIL - conIR)):\n+\/\/ - 0-3 => 0\n+\/\/ - 4-7 => bits 0 to 3 of v\n+\/\/ The simplification is still correct.\n+\/\/ The bits 4 and 5 of v are still present in (v << (conIL - conIR)) but they don't\n+\/\/ matter as they are not in the 8 lower bits: they will be cut out by the store.\n+\/\/\n+\/\/ ###### But! Case 2.3: num_rejected_bits < conIR.\n+\/\/ Let's see that this case is not as easy to simplify.\n+\/\/ Let's say conIL == 28 and conIR == 26.\n+\/\/ after: v << 28\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..3] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     28 27                      0\n+\/\/ after: (v << 28) >> 26\n+\/\/ +------------------+---------+-----+\n+\/\/ |     sign bit     | v[0..3] |  0  |\n+\/\/ +------------------+---------+-----+\n+\/\/  31               6 5       2 1   0\n+\/\/ The non-rejected bits are made of\n+\/\/ - 0-1 => 0\n+\/\/ - 2-5 => the bits 0 to 3 of v\n+\/\/ - 6-7 => the sign bit of v[0..3] (that is v[3])\n+\/\/ Simplifying this as (v << 2) is not correct.\n+\/\/ The condition conIR <= num_rejected_bits is indeed necessary in Case 2.\n+\/\/\n+\/\/ ### Conclusion:\n+\/\/ Our hypotheses are indeed sufficient:\n+\/\/   - 0 <= conIL < BitsPerJavaInteger\n+\/\/   - 0 <= conIR < BitsPerJavaInteger\n+\/\/   - conIL >= conIR\n+\/\/   - num_rejected_bits >= conIR\n+\/\/\n+\/\/ ### A rationale without case analysis:\n+\/\/ After the shift left, conIL upper  bits of v are discarded and conIL lower bit\n+\/\/ zeroes are added. After the shift right, conIR lower bits of the previous result\n+\/\/ are discarded. If conIL >= conIR, we discard only the zeroes we made up during\n+\/\/ the shift left, but if conIL < conIR, then we discard also lower bits of v. But\n+\/\/ the point of the simplification is to get an expression of the form\n+\/\/ (v << (conIL - conIR)). This expression discard only higher bits of v, thus the\n+\/\/ simplification is not correct if conIL < conIR.\n+\/\/\n+\/\/ Moreover, after the shift right, the higher bit of (v << conIL) is repeated on the\n+\/\/ conIR higher bits of ((v << conIL) >> conIR), it's the sign-extension. If\n+\/\/ conIR > num_rejected_bits, then at least one artificial copy of this sign bit will\n+\/\/ be in the window of the store. Thus ((v << conIL) >> conIR) is not equivalent to\n+\/\/ (v << (conIL-conIR)) if conIR > num_rejected_bits.\n+\/\/\n+\/\/ We do not treat the case conIL < conIR here since the point of this function is\n+\/\/ to skip sign-extensions (that is conIL == conIR == num_rejected_bits). The need\n+\/\/ of treating conIL > conIR comes from the cases where the sign-extended value is\n+\/\/ also left-shift expression. Computing the sign-extension of a right-shift expression\n+\/\/ doesn't yield a situation such as\n+\/\/ (StoreB ... (RShiftI _ (LShiftI _ v conIL) conIR))\n+\/\/ where conIL < conIR.\n+Node* StoreNode::Ideal_sign_extended_input(PhaseGVN* phase, int num_rejected_bits) {\n+  Node* shr = in(MemNode::ValueIn);\n+  if (shr->Opcode() == Op_RShiftI) {\n+    const TypeInt* conIR = phase->type(shr->in(2))->isa_int();\n+    if (conIR != nullptr && conIR->is_con() && conIR->get_con() >= 0 && conIR->get_con() < BitsPerJavaInteger && conIR->get_con() <= num_rejected_bits) {\n+      Node* shl = shr->in(1);\n+      if (shl->Opcode() == Op_LShiftI) {\n+        const TypeInt* conIL = phase->type(shl->in(2))->isa_int();\n+        if (conIL != nullptr && conIL->is_con() && conIL->get_con() >= 0 && conIL->get_con() < BitsPerJavaInteger) {\n+          if (conIL->get_con() == conIR->get_con()) {\n+            set_req_X(MemNode::ValueIn, shl->in(1), phase);\n+            return this;\n+          }\n+          if (conIL->get_con() > conIR->get_con()) {\n+            Node* new_shl = phase->transform(new LShiftINode(shl->in(1), phase->intcon(conIL->get_con() - conIR->get_con())));\n+            set_req_X(MemNode::ValueIn, new_shl, phase);\n+            return this;\n+          }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":331,"deletions":65,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -2123,1 +2123,1 @@\n-  Node* klass = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), klass_addr, TypeInstPtr::KLASS));\n+  Node* klass = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), klass_addr, TypeInstPtr::KLASS));\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2065,1 +2065,1 @@\n-    set_pair_local( 0, dprecision_rounding(pop_pair()) );\n+    set_pair_local( 0, pop_pair() );\n@@ -2068,1 +2068,1 @@\n-    set_pair_local( 1, dprecision_rounding(pop_pair()) );\n+    set_pair_local( 1, pop_pair() );\n@@ -2071,1 +2071,1 @@\n-    set_pair_local( 2, dprecision_rounding(pop_pair()) );\n+    set_pair_local( 2, pop_pair() );\n@@ -2074,1 +2074,1 @@\n-    set_pair_local( 3, dprecision_rounding(pop_pair()) );\n+    set_pair_local( 3, pop_pair() );\n@@ -2077,1 +2077,1 @@\n-    set_pair_local( iter().get_index(), dprecision_rounding(pop_pair()) );\n+    set_pair_local( iter().get_index(), pop_pair() );\n@@ -2259,2 +2259,1 @@\n-    d = precision_rounding(c);\n-    push( d );\n+    push(c);\n@@ -2267,2 +2266,1 @@\n-    d = precision_rounding(c);\n-    push( d );\n+    push(c);\n@@ -2275,2 +2273,1 @@\n-    d = precision_rounding(c);\n-    push( d );\n+    push(c);\n@@ -2283,2 +2280,1 @@\n-    d = precision_rounding(c);\n-    push( d );\n+    push(c);\n@@ -2334,2 +2330,0 @@\n-    \/\/ This breaks _227_mtrt (speed & correctness) and _222_mpegaudio (speed)\n-    \/\/b = _gvn.transform(new RoundFloatNode(nullptr, b) );\n@@ -2343,5 +2337,0 @@\n-      \/\/ For x86_32.ad, FILD doesn't restrict precision to 24 or 53 bits.\n-      \/\/ Rather than storing the result into an FP register then pushing\n-      \/\/ out to memory to round, the machine instruction that implements\n-      \/\/ ConvL2D is responsible for rounding.\n-      \/\/ c = precision_rounding(b);\n@@ -2357,2 +2346,0 @@\n-    \/\/ For x86_32.ad, rounding is always necessary (see _l2f above).\n-    \/\/ c = dprecision_rounding(b);\n@@ -2378,2 +2365,1 @@\n-    d = dprecision_rounding(c);\n-    push_pair( d );\n+    push_pair(c);\n@@ -2386,2 +2372,1 @@\n-    d = dprecision_rounding(c);\n-    push_pair( d );\n+    push_pair(c);\n@@ -2394,2 +2379,1 @@\n-    d = dprecision_rounding(c);\n-    push_pair( d );\n+    push_pair(c);\n@@ -2402,2 +2386,1 @@\n-    d = dprecision_rounding(c);\n-    push_pair( d );\n+    push_pair(c);\n@@ -2588,2 +2571,1 @@\n-    c = precision_rounding(b);\n-    push (b);\n+    push(b);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":14,"deletions":32,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-  Node* array_klass = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeInstPtr::KLASS));\n+  Node* array_klass = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p, TypeInstPtr::KLASS));\n@@ -167,5 +167,4 @@\n-  bool always_see_exact_class = false;\n-  if (MonomorphicArrayCheck\n-      && !too_many_traps(Deoptimization::Reason_array_check)\n-      && !tak->klass_is_exact()\n-      && tak != TypeInstKlassPtr::OBJECT) {\n+  if (MonomorphicArrayCheck &&\n+      !too_many_traps(Deoptimization::Reason_array_check) &&\n+      !tak->klass_is_exact() &&\n+      tak->isa_aryklassptr()) {\n@@ -193,6 +192,2 @@\n-    always_see_exact_class = true;\n-    \/\/ (If no MDO at all, hope for the best, until a trap actually occurs.)\n-\n-    \/\/ Make a constant out of the inexact array klass\n-    const TypeKlassPtr *extak = tak->cast_to_exactness(true);\n-\n+    \/\/ Make a constant out of the exact array klass\n+    const TypeAryKlassPtr* extak = tak->cast_to_exactness(true)->is_aryklassptr();\n@@ -201,2 +196,2 @@\n-      Node* cmp = _gvn.transform(new CmpPNode( array_klass, con ));\n-      Node* bol = _gvn.transform(new BoolNode( cmp, BoolTest::eq ));\n+      Node* cmp = _gvn.transform(new CmpPNode(array_klass, con));\n+      Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::eq));\n@@ -213,1 +208,1 @@\n-        replace_in_map(array_klass,con);\n+        replace_in_map(array_klass, con);\n@@ -228,6 +223,3 @@\n-  Node *p2 = basic_plus_adr(array_klass, array_klass, element_klass_offset);\n-  \/\/ We are allowed to use the constant type only if cast succeeded. If always_see_exact_class is true,\n-  \/\/ we must set a control edge from the IfTrue node created by the uncommon_trap above to the\n-  \/\/ LoadKlassNode.\n-  Node* a_e_klass = _gvn.transform(LoadKlassNode::make(_gvn, always_see_exact_class ? control() : nullptr,\n-                                                       immutable_memory(), p2, tak));\n+  Node* p2 = basic_plus_adr(array_klass, array_klass, element_klass_offset);\n+  Node* a_e_klass = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p2, tak));\n+  assert(array_klass->is_Con() == a_e_klass->is_Con() || StressReflectiveCode, \"a constant array type must come with a constant element type\");\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":13,"deletions":21,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -134,1 +135,3 @@\n-  generate_ ## name ## _blob();\n+  BLOB_FIELD_NAME(name) =                       \\\n+    generate_ ## name ## _blob();                  \\\n+  if (BLOB_FIELD_NAME(name) == nullptr) { return false; }\n@@ -232,0 +235,1 @@\n+const TypeFunc* OptoRuntime::_double_keccak_Type                  = nullptr;\n@@ -241,0 +245,7 @@\n+\n+const TypeFunc* OptoRuntime::_dilithiumAlmostNtt_Type             = nullptr;\n+const TypeFunc* OptoRuntime::_dilithiumAlmostInverseNtt_Type      = nullptr;\n+const TypeFunc* OptoRuntime::_dilithiumNttMult_Type               = nullptr;\n+const TypeFunc* OptoRuntime::_dilithiumMontMulByConstant_Type     = nullptr;\n+const TypeFunc* OptoRuntime::_dilithiumDecomposePoly_Type         = nullptr;\n+\n@@ -270,0 +281,1 @@\n+  CompilationMemoryStatisticMark cmsm(directive);\n@@ -1172,0 +1184,3 @@\n+\/*\n+ * int implCompressMultiBlock(byte[] b, int ofs, int limit)\n+ *\/\n@@ -1193,0 +1208,19 @@\n+\/\/ SHAKE128Parallel doubleKeccak function\n+static const TypeFunc* make_double_keccak_Type() {\n+    int argcnt = 2;\n+\n+    const Type** fields = TypeTuple::fields(argcnt);\n+    int argp = TypeFunc::Parms;\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ status0\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ status1\n+\n+    assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+\n+    \/\/ result type needed\n+    fields = TypeTuple::fields(1);\n+    fields[TypeFunc::Parms + 0] = TypeInt::INT;\n+    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+    return TypeFunc::make(domain, range);\n+}\n+\n@@ -1378,0 +1412,99 @@\n+\/\/ Dilithium NTT function except for the final \"normalization\" to |coeff| < Q\n+static const TypeFunc* make_dilithiumAlmostNtt_Type() {\n+    int argcnt = 2;\n+\n+    const Type** fields = TypeTuple::fields(argcnt);\n+    int argp = TypeFunc::Parms;\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ coeffs\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ NTT zetas\n+\n+    assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+\n+    \/\/ result type needed\n+    fields = TypeTuple::fields(1);\n+    fields[TypeFunc::Parms + 0] = TypeInt::INT;\n+    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+    return TypeFunc::make(domain, range);\n+}\n+\n+\/\/ Dilithium inverse NTT function except the final mod Q division by 2^256\n+static const TypeFunc* make_dilithiumAlmostInverseNtt_Type() {\n+    int argcnt = 2;\n+\n+    const Type** fields = TypeTuple::fields(argcnt);\n+    int argp = TypeFunc::Parms;\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ coeffs\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ inverse NTT zetas\n+\n+    assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+\n+    \/\/ result type needed\n+    fields = TypeTuple::fields(1);\n+    fields[TypeFunc::Parms + 0] = TypeInt::INT;\n+    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+    return TypeFunc::make(domain, range);\n+}\n+\n+\/\/ Dilithium NTT multiply function\n+static const TypeFunc* make_dilithiumNttMult_Type() {\n+    int argcnt = 3;\n+\n+    const Type** fields = TypeTuple::fields(argcnt);\n+    int argp = TypeFunc::Parms;\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ result\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ ntta\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ nttb\n+\n+    assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+\n+    \/\/ result type needed\n+    fields = TypeTuple::fields(1);\n+    fields[TypeFunc::Parms + 0] = TypeInt::INT;\n+    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+    return TypeFunc::make(domain, range);\n+}\n+\n+\/\/ Dilithium Montgomery multiply a polynome coefficient array by a constant\n+static const TypeFunc* make_dilithiumMontMulByConstant_Type() {\n+    int argcnt = 2;\n+\n+    const Type** fields = TypeTuple::fields(argcnt);\n+    int argp = TypeFunc::Parms;\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ coeffs\n+    fields[argp++] = TypeInt::INT;          \/\/ constant multiplier\n+\n+    assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+\n+    \/\/ result type needed\n+    fields = TypeTuple::fields(1);\n+    fields[TypeFunc::Parms + 0] = TypeInt::INT;\n+    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+    return TypeFunc::make(domain, range);\n+}\n+\n+\/\/ Dilithium decompose polynomial\n+static const TypeFunc* make_dilithiumDecomposePoly_Type() {\n+    int argcnt = 5;\n+\n+    const Type** fields = TypeTuple::fields(argcnt);\n+    int argp = TypeFunc::Parms;\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ input\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ lowPart\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ highPart\n+    fields[argp++] = TypeInt::INT;          \/\/ 2 * gamma2\n+    fields[argp++] = TypeInt::INT;          \/\/ multiplier\n+\n+    assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+\n+    \/\/ result type needed\n+    fields = TypeTuple::fields(1);\n+    fields[TypeFunc::Parms + 0] = TypeInt::INT;\n+    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+    return TypeFunc::make(domain, range);\n+}\n+\n@@ -1559,1 +1692,0 @@\n-    ResourceMark rm;\n@@ -1981,0 +2113,1 @@\n+  _double_keccak_Type                 = make_double_keccak_Type();\n@@ -1990,0 +2123,7 @@\n+\n+  _dilithiumAlmostNtt_Type            = make_dilithiumAlmostNtt_Type();\n+  _dilithiumAlmostInverseNtt_Type     = make_dilithiumAlmostInverseNtt_Type();\n+  _dilithiumNttMult_Type              = make_dilithiumNttMult_Type();\n+  _dilithiumMontMulByConstant_Type    = make_dilithiumMontMulByConstant_Type();\n+  _dilithiumDecomposePoly_Type        = make_dilithiumDecomposePoly_Type();\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":142,"deletions":2,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -56,3 +56,7 @@\n-  \/\/ Remove double negation\n-  const Type *zero = add_id();\n-  if( phase->type( in(1) )->higher_equal( zero ) &&\n+  const Type* zero = add_id();\n+\n+  \/\/ Remove double negation if it is not a floating point number since negation\n+  \/\/ is not the same as subtraction for floating point numbers\n+  \/\/ (cf. JLS § 15.15.4). `0-(0-(-0.0))` must be equal to positive 0.0 according to\n+  \/\/ JLS § 15.8.2, but would result in -0.0 if this folding would be applied.\n+  if (phase->type(in(1))->higher_equal(zero) &&\n@@ -60,1 +64,2 @@\n-      phase->type( in(2)->in(1) )->higher_equal( zero ) ) {\n+      phase->type(in(2)->in(1))->higher_equal(zero) &&\n+      !phase->type(in(2)->in(2))->is_floatingpoint()) {\n@@ -555,0 +560,18 @@\n+\/\/------------------------------sub--------------------------------------------\n+\/\/ A subtract node differences its two inputs.\n+const Type* SubHFNode::sub(const Type* t1, const Type* t2) const {\n+  \/\/ no folding if one of operands is infinity or NaN, do not do constant folding\n+  if(g_isfinite(t1->getf()) && g_isfinite(t2->getf())) {\n+    return TypeH::make(t1->getf() - t2->getf());\n+  }\n+  else if(g_isnan(t1->getf())) {\n+    return t1;\n+  }\n+  else if(g_isnan(t2->getf())) {\n+    return t2;\n+  }\n+  else {\n+    return Type::HALF_FLOAT;\n+  }\n+}\n+\n@@ -1992,0 +2015,9 @@\n+const Type* SqrtHFNode::Value(PhaseGVN* phase) const {\n+  const Type* t1 = phase->type(in(1));\n+  if (t1 == Type::TOP) { return Type::TOP; }\n+  if (t1->base() != Type::HalfFloatCon) { return Type::HALF_FLOAT; }\n+  float f = t1->getf();\n+  if (f < 0.0f) return Type::HALF_FLOAT;\n+  return TypeH::make((float)sqrt((double)f));\n+}\n+\n@@ -2018,9 +2050,3 @@\n-Node* ReverseINode::Identity(PhaseGVN* phase) {\n-  if (in(1)->Opcode() == Op_ReverseI) {\n-    return in(1)->in(1);\n-  }\n-  return this;\n-}\n-\n-Node* ReverseLNode::Identity(PhaseGVN* phase) {\n-  if (in(1)->Opcode() == Op_ReverseL) {\n+Node* InvolutionNode::Identity(PhaseGVN* phase) {\n+  \/\/ Op ( Op x ) => x\n+  if (in(1)->Opcode() == Opcode()) {\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":39,"deletions":13,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-          Node* nkls = phase->transform(LoadKlassNode::make(*phase, nullptr, C->immutable_memory(), p2, phase->type(p2)->is_ptr(), TypeInstKlassPtr::OBJECT_OR_NULL));\n+          Node* nkls = phase->transform(LoadKlassNode::make(*phase, C->immutable_memory(), p2, phase->type(p2)->is_ptr(), TypeInstKlassPtr::OBJECT_OR_NULL));\n@@ -221,1 +221,1 @@\n-    subklass  = phase->transform(LoadKlassNode::make(*phase, nullptr, phase->C->immutable_memory(), adr, TypeInstPtr::KLASS));\n+    subklass  = phase->transform(LoadKlassNode::make(*phase, phase->C->immutable_memory(), adr, TypeInstPtr::KLASS));\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -47,0 +48,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -107,0 +109,3 @@\n+  { HalfFloatBot,    T_SHORT,      \"halffloat_top\", false, Op_RegF,              relocInfo::none          },  \/\/ HalfFloatTop\n+  { HalfFloatCon,    T_SHORT,      \"hfcon:\",        false, Op_RegF,              relocInfo::none          },  \/\/ HalfFloatCon\n+  { HalfFloatTop,    T_SHORT,      \"short\",         false, Op_RegF,              relocInfo::none          },  \/\/ HalfFloatBot\n@@ -136,0 +141,1 @@\n+const Type *Type::HALF_FLOAT;   \/\/ All half floats\n@@ -437,1 +443,1 @@\n-  Arena* shared_type_arena = new (mtCompiler)Arena(mtCompiler);\n+  Arena* shared_type_arena = new (mtCompiler)Arena(mtCompiler, Arena::Tag::tag_type);\n@@ -456,0 +462,1 @@\n+  HALF_FLOAT = make(HalfFloatBot); \/\/ All half floats\n@@ -467,0 +474,7 @@\n+  TypeH::MAX = TypeH::make(max_jfloat16); \/\/ HalfFloat MAX\n+  TypeH::MIN = TypeH::make(min_jfloat16); \/\/ HalfFloat MIN\n+  TypeH::ZERO = TypeH::make((jshort)0); \/\/ HalfFloat 0 (positive zero)\n+  TypeH::ONE  = TypeH::make(one_jfloat16); \/\/ HalfFloat 1\n+  TypeH::POS_INF = TypeH::make(pos_inf_jfloat16);\n+  TypeH::NEG_INF = TypeH::make(neg_inf_jfloat16);\n+\n@@ -1042,0 +1056,1 @@\n+  case HalfFloatCon:\n@@ -1077,0 +1092,9 @@\n+  case HalfFloatTop:\n+    if (_base == HalfFloatTop) { return this; }\n+  case HalfFloatBot:            \/\/ Half Float\n+    if (_base == HalfFloatBot || _base == HalfFloatTop) { return HALF_FLOAT; }\n+    if (_base == FloatBot || _base == FloatTop) { return Type::BOTTOM; }\n+    if (_base == DoubleTop || _base == DoubleBot) { return Type::BOTTOM; }\n+    typerr(t);\n+    return Type::BOTTOM;\n+\n@@ -1078,1 +1102,1 @@\n-    if( _base == FloatTop ) return this;\n+    if (_base == FloatTop ) { return this; }\n@@ -1080,2 +1104,3 @@\n-    if( _base == FloatBot || _base == FloatTop ) return FLOAT;\n-    if( _base == DoubleTop || _base == DoubleBot ) return Type::BOTTOM;\n+    if (_base == FloatBot || _base == FloatTop) { return FLOAT; }\n+    if (_base == HalfFloatTop || _base == HalfFloatBot) { return Type::BOTTOM; }\n+    if (_base == DoubleTop || _base == DoubleBot) { return Type::BOTTOM; }\n@@ -1086,1 +1111,1 @@\n-    if( _base == DoubleTop ) return this;\n+    if (_base == DoubleTop) { return this; }\n@@ -1088,2 +1113,3 @@\n-    if( _base == DoubleBot || _base == DoubleTop ) return DOUBLE;\n-    if( _base == FloatTop || _base == FloatBot ) return Type::BOTTOM;\n+    if (_base == DoubleBot || _base == DoubleTop) { return DOUBLE; }\n+    if (_base == HalfFloatTop || _base == HalfFloatBot) { return Type::BOTTOM; }\n+    if (_base == FloatTop || _base == FloatBot) { return Type::BOTTOM; }\n@@ -1097,1 +1123,1 @@\n-    if( _base == t->_base )  return this;\n+    if (_base == t->_base)  { return this; }\n@@ -1177,0 +1203,1 @@\n+  case HalfFloatTop:\n@@ -1185,0 +1212,1 @@\n+  case HalfFloatBot:\n@@ -1232,0 +1260,3 @@\n+    case Type::HalfFloatTop:\n+    case Type::HalfFloatCon:\n+    case Type::HalfFloatBot:\n@@ -1337,0 +1368,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -1415,0 +1449,132 @@\n+\/\/=============================================================================\n+\/\/ Convenience common pre-built types.\n+const TypeH* TypeH::MAX;        \/\/ Half float max\n+const TypeH* TypeH::MIN;        \/\/ Half float min\n+const TypeH* TypeH::ZERO;       \/\/ Half float zero\n+const TypeH* TypeH::ONE;        \/\/ Half float one\n+const TypeH* TypeH::POS_INF;    \/\/ Half float positive infinity\n+const TypeH* TypeH::NEG_INF;    \/\/ Half float negative infinity\n+\n+\/\/------------------------------make-------------------------------------------\n+\/\/ Create a halffloat constant\n+const TypeH* TypeH::make(short f) {\n+  return (TypeH*)(new TypeH(f))->hashcons();\n+}\n+\n+const TypeH* TypeH::make(float f) {\n+  assert(StubRoutines::f2hf_adr() != nullptr, \"\");\n+  short hf = StubRoutines::f2hf(f);\n+  return (TypeH*)(new TypeH(hf))->hashcons();\n+}\n+\n+\/\/------------------------------xmeet-------------------------------------------\n+\/\/ Compute the MEET of two types.  It returns a new Type object.\n+const Type* TypeH::xmeet(const Type* t) const {\n+  \/\/ Perform a fast test for common case; meeting the same types together.\n+  if (this == t) return this;  \/\/ Meeting same type-rep?\n+\n+  \/\/ Current \"this->_base\" is FloatCon\n+  switch (t->base()) {          \/\/ Switch on original type\n+  case AnyPtr:                  \/\/ Mixing with oops happens when javac\n+  case RawPtr:                  \/\/ reuses local variables\n+  case OopPtr:\n+  case InstPtr:\n+  case AryPtr:\n+  case MetadataPtr:\n+  case KlassPtr:\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n+  case NarrowOop:\n+  case NarrowKlass:\n+  case Int:\n+  case Long:\n+  case FloatTop:\n+  case FloatCon:\n+  case FloatBot:\n+  case DoubleTop:\n+  case DoubleCon:\n+  case DoubleBot:\n+  case Bottom:                  \/\/ Ye Olde Default\n+    return Type::BOTTOM;\n+\n+  case HalfFloatBot:\n+    return t;\n+\n+  default:                      \/\/ All else is a mistake\n+    typerr(t);\n+\n+  case HalfFloatCon:            \/\/ Half float-constant vs Half float-constant?\n+    if (_f != t->geth()) {      \/\/ unequal constants?\n+                                \/\/ must compare bitwise as positive zero, negative zero and NaN have\n+                                \/\/ all the same representation in C++\n+      return HALF_FLOAT;        \/\/ Return generic float\n+    }                           \/\/ Equal constants\n+  case Top:\n+  case HalfFloatTop:\n+    break;                      \/\/ Return the Half float constant\n+  }\n+  return this;                  \/\/ Return the Half float constant\n+}\n+\n+\/\/------------------------------xdual------------------------------------------\n+\/\/ Dual: symmetric\n+const Type* TypeH::xdual() const {\n+  return this;\n+}\n+\n+\/\/------------------------------eq---------------------------------------------\n+\/\/ Structural equality check for Type representations\n+bool TypeH::eq(const Type* t) const {\n+  \/\/ Bitwise comparison to distinguish between +\/-0. These values must be treated\n+  \/\/ as different to be consistent with C1 and the interpreter.\n+  return (_f == t->geth());\n+}\n+\n+\/\/------------------------------hash-------------------------------------------\n+\/\/ Type-specific hashing function.\n+uint TypeH::hash(void) const {\n+  return *(jshort*)(&_f);\n+}\n+\n+\/\/------------------------------is_finite--------------------------------------\n+\/\/ Has a finite value\n+bool TypeH::is_finite() const {\n+  assert(StubRoutines::hf2f_adr() != nullptr, \"\");\n+  float f = StubRoutines::hf2f(geth());\n+  return g_isfinite(f) != 0;\n+}\n+\n+float TypeH::getf() const {\n+  assert(StubRoutines::hf2f_adr() != nullptr, \"\");\n+  return StubRoutines::hf2f(geth());\n+}\n+\n+\/\/------------------------------is_nan-----------------------------------------\n+\/\/ Is not a number (NaN)\n+bool TypeH::is_nan() const {\n+  assert(StubRoutines::hf2f_adr() != nullptr, \"\");\n+  float f = StubRoutines::hf2f(geth());\n+  return g_isnan(f) != 0;\n+}\n+\n+\/\/------------------------------dump2------------------------------------------\n+\/\/ Dump float constant Type\n+#ifndef PRODUCT\n+void TypeH::dump2(Dict &d, uint depth, outputStream* st) const {\n+  Type::dump2(d,depth, st);\n+  st->print(\"%f\", getf());\n+}\n+#endif\n+\n+\/\/------------------------------singleton--------------------------------------\n+\/\/ TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple\n+\/\/ constants (Ldi nodes).  Singletons are integer, half float, float or double constants\n+\/\/ or a single symbol.\n+bool TypeH::singleton(void) const {\n+  return true;                  \/\/ Always a singleton\n+}\n+\n+bool TypeH::empty(void) const {\n+  return false;                 \/\/ always exactly a singleton\n+}\n+\n@@ -1450,0 +1616,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -1533,0 +1702,4 @@\n+const TypeInteger* TypeInteger::make(jlong con, BasicType bt) {\n+  return make(con, con, WidenMin, bt);\n+}\n+\n@@ -1646,0 +1819,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -1909,0 +2085,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -2703,0 +2882,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -3642,0 +3824,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -3841,2 +4026,0 @@\n-  const TypeInstPtr* ftip = ft->isa_instptr();\n-  const TypeInstPtr* ktip = kills->isa_instptr();\n@@ -4210,0 +4393,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -4887,0 +5073,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -5316,0 +5505,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -5471,0 +5663,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -5663,2 +5858,0 @@\n-  const TypeKlassPtr* ftkp = ft->isa_instklassptr();\n-  const TypeKlassPtr* ktkp = kills->isa_instklassptr();\n@@ -5845,0 +6038,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -6269,0 +6465,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":211,"deletions":12,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+class   TypeH;\n@@ -81,1 +82,0 @@\n-  friend class VMStructs;\n@@ -123,0 +123,3 @@\n+    HalfFloatTop,               \/\/ No float value\n+    HalfFloatCon,               \/\/ Floating point constant\n+    HalfFloatBot,               \/\/ Any float value\n@@ -291,1 +294,2 @@\n-  float getf() const;\n+  short geth() const;\n+  virtual float getf() const;\n@@ -303,0 +307,3 @@\n+  const TypeH      *isa_half_float() const;          \/\/ Returns null if not a Float{Top,Con,Bot}\n+  const TypeH      *is_half_float_constant() const;  \/\/ Asserts it is a FloatCon\n+  const TypeH      *isa_half_float_constant() const; \/\/ Returns null if not a FloatCon\n@@ -445,0 +452,1 @@\n+  static const Type *HALF_FLOAT;\n@@ -535,0 +543,32 @@\n+\/\/ Class of Half Float-Constant Types.\n+class TypeH : public Type {\n+  TypeH(short f) : Type(HalfFloatCon), _f(f) {};\n+public:\n+  virtual bool eq(const Type* t) const;\n+  virtual uint hash() const;             \/\/ Type specific hashing\n+  virtual bool singleton(void) const;    \/\/ TRUE if type is a singleton\n+  virtual bool empty(void) const;        \/\/ TRUE if type is vacuous\n+public:\n+  const short _f;                        \/\/ Half Float constant\n+\n+  static const TypeH* make(float f);\n+  static const TypeH* make(short f);\n+\n+  virtual bool is_finite() const;  \/\/ Has a finite value\n+  virtual bool is_nan() const;     \/\/ Is not a number (NaN)\n+\n+  virtual float getf() const;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  \/\/ Convenience common pre-built types.\n+  static const TypeH* MAX;\n+  static const TypeH* MIN;\n+  static const TypeH* ZERO; \/\/ positive zero only\n+  static const TypeH* ONE;\n+  static const TypeH* POS_INF;\n+  static const TypeH* NEG_INF;\n+#ifndef PRODUCT\n+  virtual void dump2(Dict &d, uint depth, outputStream* st) const;\n+#endif\n+};\n+\n@@ -580,0 +620,1 @@\n+  static const TypeInteger* make(jlong con, BasicType bt);\n@@ -1957,0 +1998,5 @@\n+inline short Type::geth() const {\n+  assert(_base == HalfFloatCon, \"Not a HalfFloatCon\");\n+  return ((TypeH*)this)->_f;\n+}\n+\n@@ -1989,0 +2035,15 @@\n+inline const TypeH* Type::isa_half_float() const {\n+  return ((_base == HalfFloatTop ||\n+           _base == HalfFloatCon ||\n+           _base == HalfFloatBot) ? (TypeH*)this : nullptr);\n+}\n+\n+inline const TypeH* Type::is_half_float_constant() const {\n+  assert( _base == HalfFloatCon, \"Not a HalfFloat\" );\n+  return (TypeH*)this;\n+}\n+\n+inline const TypeH* Type::isa_half_float_constant() const {\n+  return (_base == HalfFloatCon ? (TypeH*)this : nullptr);\n+}\n+\n@@ -2178,1 +2239,2 @@\n-  if( (_base == FloatCon)  || (_base == FloatBot) ||\n+  if( (_base == HalfFloatCon)  || (_base == HalfFloatBot) ||\n+      (_base == FloatCon)  || (_base == FloatBot) ||\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":65,"deletions":3,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"cds\/filemap.hpp\"\n@@ -335,2 +334,1 @@\n-    if (matches_property_suffix(property_suffix, ADDEXPORTS, ADDEXPORTS_LEN) ||\n-        matches_property_suffix(property_suffix, ADDREADS, ADDREADS_LEN) ||\n+    if (matches_property_suffix(property_suffix, ADDREADS, ADDREADS_LEN) ||\n@@ -347,1 +345,2 @@\n-      if (matches_property_suffix(property_suffix, PATH, PATH_LEN) ||\n+      if (matches_property_suffix(property_suffix, ADDEXPORTS, ADDEXPORTS_LEN) ||\n+          matches_property_suffix(property_suffix, PATH, PATH_LEN) ||\n@@ -537,0 +536,1 @@\n+  { \"ZMarkStackSpaceLimit\",         JDK_Version::undefined(), JDK_Version::jdk(25), JDK_Version::undefined() },\n@@ -1368,3 +1368,7 @@\n-    jio_fprintf(defaultStream::error_stream(),\n-      \"Class data sharing is inconsistent with other specified options.\\n\");\n-    vm_exit_during_initialization(\"Unable to use shared archive\", message);\n+    log_error(cds)(\"%s is incompatible with other specified options.\",\n+                   CDSConfig::new_aot_flags_used() ? \"AOT cache\" : \"CDS\");\n+    if (CDSConfig::new_aot_flags_used()) {\n+      vm_exit_during_initialization(\"Unable to use AOT cache\", message);\n+    } else {\n+      vm_exit_during_initialization(\"Unable to use shared archive\", message);\n+    }\n@@ -1372,1 +1376,5 @@\n-    log_info(cds)(\"Unable to use shared archive: %s\", message);\n+    if (CDSConfig::new_aot_flags_used()) {\n+      log_warning(cds)(\"Unable to use AOT cache: %s\", message);\n+    } else {\n+      log_info(cds)(\"Unable to use shared archive: %s\", message);\n+    }\n@@ -2600,3 +2608,3 @@\n-      } else if (strcmp(tail, \":async\") == 0) {\n-        LogConfiguration::set_async_mode(true);\n-        ret = true;\n+      } else if (strncmp(tail, \":async\", strlen(\":async\")) == 0) {\n+        const char* async_tail = tail + strlen(\":async\");\n+        ret = LogConfiguration::parse_async_argument(async_tail);\n@@ -3795,0 +3803,7 @@\n+#ifdef COMPILER2\n+  if (!FLAG_IS_DEFAULT(UseLoopPredicate) && !UseLoopPredicate && UseProfiledLoopPredicate) {\n+    warning(\"Disabling UseProfiledLoopPredicate since UseLoopPredicate is turned off.\");\n+    FLAG_SET_ERGO(UseProfiledLoopPredicate, false);\n+  }\n+#endif \/\/ COMPILER2\n+\n@@ -3798,1 +3813,2 @@\n-      LogConfiguration::configure_stdout(LogLevel::Off, false, LOG_TAGS(perf, class, link));\n+      LogConfiguration::disable_tags(false, LOG_TAGS(perf, class, link));\n+      assert(!log_is_enabled(Info, perf, class, link), \"sanity\");\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":28,"deletions":12,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -328,0 +328,3 @@\n+  product(bool, UseDilithiumIntrinsics, false, DIAGNOSTIC,                  \\\n+          \"Use intrinsics for the vectorized version of Dilithium\")         \\\n+                                                                            \\\n@@ -484,0 +487,4 @@\n+  develop(bool, TestingAsyncLoggingDeathTest, false,                        \\\n+          \"Recursive logging death test\")                                   \\\n+  develop(bool, TestingAsyncLoggingDeathTestNoCrash, false,                 \\\n+          \"Recursive logging death test (no crash)\")                        \\\n@@ -1402,0 +1409,3 @@\n+  product(bool, PrintCompilerMemoryStatisticsAtExit, false, DIAGNOSTIC,     \\\n+          \"Print compiler memory statistics upon VM exit.\")                 \\\n+                                                                            \\\n@@ -1423,1 +1433,1 @@\n-          range(0, max_uintx)                                               \\\n+          range(0, max_uintx \/ 2 + 1)                                       \\\n@@ -1559,1 +1569,1 @@\n-  develop(intx, StopInterpreterAt, 0,                                       \\\n+  develop(uintx, StopInterpreterAt, 0,                                      \\\n@@ -1562,1 +1572,1 @@\n-  develop(intx, TraceBytecodesAt, 0,                                        \\\n+  develop(uintx, TraceBytecodesAt, 0,                                       \\\n@@ -1565,1 +1575,1 @@\n-  develop(intx, TraceBytecodesStopAt, 0,                                    \\\n+  develop(uintx, TraceBytecodesStopAt, 0,                                   \\\n@@ -1604,1 +1614,1 @@\n-          range(-1, 127)                                                    \\\n+          range(min_jint, max_jint)                                         \\\n@@ -1608,1 +1618,1 @@\n-          range(-1, 127)                                                    \\\n+          range(min_jint, max_jint)                                         \\\n@@ -1612,1 +1622,1 @@\n-          range(-1, 127)                                                    \\\n+          range(min_jint, max_jint)                                         \\\n@@ -1616,1 +1626,1 @@\n-          range(-1, 127)                                                    \\\n+          range(min_jint, max_jint)                                         \\\n@@ -1620,1 +1630,1 @@\n-          range(-1, 127)                                                    \\\n+          range(min_jint, max_jint)                                         \\\n@@ -1624,1 +1634,1 @@\n-          range(-1, 127)                                                    \\\n+          range(min_jint, max_jint)                                         \\\n@@ -1628,1 +1638,1 @@\n-          range(-1, 127)                                                    \\\n+          range(min_jint, max_jint)                                         \\\n@@ -1632,1 +1642,1 @@\n-          range(-1, 127)                                                    \\\n+          range(min_jint, max_jint)                                         \\\n@@ -1636,1 +1646,1 @@\n-          range(-1, 127)                                                    \\\n+          range(min_jint, max_jint)                                         \\\n@@ -1640,1 +1650,1 @@\n-          range(-1, 127)                                                    \\\n+          range(min_jint, max_jint)                                         \\\n@@ -1644,1 +1654,1 @@\n-          range(-1, 127)                                                    \\\n+          range(min_jint, max_jint)                                         \\\n@@ -1870,1 +1880,1 @@\n-          range(100*K, 50*M)                                                \\\n+          range(DEBUG_ONLY(192) NOT_DEBUG(100*K), 50*M)                     \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#include \"runtime\/perfData.inline.hpp\"\n@@ -383,1 +382,5 @@\n-  event->set_monitorClass(obj->klass());\n+  const Klass* monitor_klass = obj->klass();\n+  if (ObjectMonitor::is_jfr_excluded(monitor_klass)) {\n+    return;\n+  }\n+  event->set_monitorClass(monitor_klass);\n@@ -398,3 +401,0 @@\n-    \/\/ Hopefully the performance counters are allocated on distinct\n-    \/\/ cache lines to avoid false sharing on MP systems ...\n-    OM_PERFDATA_OP(Inflations, inc());\n@@ -888,3 +888,0 @@\n-        \/\/ Hopefully the performance counters are allocated on distinct\n-        \/\/ cache lines to avoid false sharing on MP systems ...\n-        OM_PERFDATA_OP(Inflations, inc());\n@@ -929,3 +926,0 @@\n-    \/\/ Hopefully the performance counters are allocated on distinct\n-    \/\/ cache lines to avoid false sharing on MP systems ...\n-    OM_PERFDATA_OP(Inflations, inc());\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-#include \"runtime\/perfData.hpp\"\n@@ -80,4 +79,8 @@\n-  size_t count = Atomic::add(&_count, 1u);\n-  if (count > max()) {\n-    Atomic::inc(&_max);\n-  }\n+  size_t count = Atomic::add(&_count, 1u, memory_order_relaxed);\n+  size_t old_max;\n+  do {\n+    old_max = Atomic::load(&_max);\n+    if (count <= old_max) {\n+      break;\n+    }\n+  } while (Atomic::cmpxchg(&_max, old_max, count, memory_order_relaxed) != old_max);\n@@ -370,1 +373,1 @@\n-      \/\/ to the entrylist here and now, avoiding the slow-path.\n+      \/\/ to the entry_list here and now, avoiding the slow-path.\n@@ -376,3 +379,1 @@\n-      int free_count = 0;\n-        mon->INotify(current);\n-        ++free_count;\n+        mon->notify_internal(current);\n@@ -381,1 +382,0 @@\n-      OM_PERFDATA_OP(Notifications, inc(free_count));\n@@ -411,4 +411,0 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    return LightweightSynchronizer::quick_enter(obj, lock, current);\n-  }\n-\n@@ -1346,0 +1342,8 @@\n+size_t ObjectSynchronizer::in_use_list_count() {\n+  return _in_use_list.count();\n+}\n+\n+size_t ObjectSynchronizer::in_use_list_max() {\n+  return _in_use_list.max();\n+}\n+\n@@ -1453,1 +1457,5 @@\n-  event->set_monitorClass(obj->klass());\n+  const Klass* monitor_klass = obj->klass();\n+  if (ObjectMonitor::is_jfr_excluded(monitor_klass)) {\n+    return;\n+  }\n+  event->set_monitorClass(monitor_klass);\n@@ -1617,3 +1625,0 @@\n-      \/\/ Hopefully the performance counters are allocated on distinct cache lines\n-      \/\/ to avoid false sharing on MP systems ...\n-      OM_PERFDATA_OP(Inflations, inc());\n@@ -1659,3 +1664,0 @@\n-    \/\/ Hopefully the performance counters are allocated on distinct\n-    \/\/ cache lines to avoid false sharing on MP systems ...\n-    OM_PERFDATA_OP(Inflations, inc());\n@@ -1744,2 +1746,2 @@\n-  size_t count() const   { return ObjectSynchronizer::_in_use_list.count(); }\n-  size_t max() const     { return ObjectSynchronizer::_in_use_list.max(); }\n+  size_t count() const   { return ObjectSynchronizer::in_use_list_count(); }\n+  size_t max() const     { return ObjectSynchronizer::in_use_list_max(); }\n@@ -1889,3 +1891,0 @@\n-  OM_PERFDATA_OP(MonExtant, set_value(_in_use_list.count()));\n-  OM_PERFDATA_OP(Deflations, inc(deflated_count));\n-\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":25,"deletions":26,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+  MonitorList() : _head(nullptr), _count(0), _max(0) {};\n@@ -190,0 +191,2 @@\n+  static size_t in_use_list_count();\n+  static size_t in_use_list_max();\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,6 +26,0 @@\n-#include \"ci\/ciField.hpp\"\n-#include \"ci\/ciInstance.hpp\"\n-#include \"ci\/ciMethodData.hpp\"\n-#include \"ci\/ciObjArrayKlass.hpp\"\n-#include \"ci\/ciSymbol.hpp\"\n-#include \"classfile\/dictionary.hpp\"\n@@ -35,3 +29,0 @@\n-#include \"classfile\/stringTable.hpp\"\n-#include \"classfile\/symbolTable.hpp\"\n-#include \"classfile\/systemDictionary.hpp\"\n@@ -106,1 +97,0 @@\n-#include \"runtime\/sharedRuntime.hpp\"\n@@ -109,1 +99,0 @@\n-#include \"runtime\/threadSMR.hpp\"\n@@ -118,24 +107,0 @@\n-#include \"opto\/addnode.hpp\"\n-#include \"opto\/block.hpp\"\n-#include \"opto\/callnode.hpp\"\n-#include \"opto\/castnode.hpp\"\n-#include \"opto\/cfgnode.hpp\"\n-#include \"opto\/chaitin.hpp\"\n-#include \"opto\/convertnode.hpp\"\n-#include \"opto\/divnode.hpp\"\n-#include \"opto\/intrinsicnode.hpp\"\n-#include \"opto\/locknode.hpp\"\n-#include \"opto\/loopnode.hpp\"\n-#include \"opto\/machnode.hpp\"\n-#include \"opto\/matcher.hpp\"\n-#include \"opto\/mathexactnode.hpp\"\n-#include \"opto\/movenode.hpp\"\n-#include \"opto\/mulnode.hpp\"\n-#include \"opto\/narrowptrnode.hpp\"\n-#include \"opto\/opaquenode.hpp\"\n-#include \"opto\/parse.hpp\"\n-#include \"opto\/phaseX.hpp\"\n-#include \"opto\/regalloc.hpp\"\n-#include \"opto\/rootnode.hpp\"\n-#include \"opto\/subnode.hpp\"\n-#include \"opto\/vectornode.hpp\"\n@@ -147,1 +112,0 @@\n-#include OS_CPU_HEADER(vmStructs)\n@@ -186,5 +150,1 @@\n-                   nonproduct_nonstatic_field,                                                                                       \\\n-                   c1_nonstatic_field,                                                                                               \\\n-                   c2_nonstatic_field,                                                                                               \\\n-                   unchecked_c1_static_field,                                                                                        \\\n-                   unchecked_c2_static_field)                                                                                        \\\n+                   nonproduct_nonstatic_field)                                                                                       \\\n@@ -266,1 +226,0 @@\n-  nonstatic_field(Klass,                       _modifier_flags,                               u2)                                    \\\n@@ -445,1 +404,1 @@\n-  \/* SystemDictionary *\/                                                                                                             \\\n+  \/* VM Classes       *\/                                                                                                             \\\n@@ -554,0 +513,1 @@\n+  nonstatic_field(CodeBlob,                    _kind,                                         CodeBlobKind)                          \\\n@@ -563,0 +523,2 @@\n+  nonstatic_field(CodeBlob,                    _mutable_data,                                 address)                               \\\n+  nonstatic_field(CodeBlob,                    _mutable_data_size,                            int)                                   \\\n@@ -585,2 +547,1 @@\n-  nonstatic_field(nmethod,                     _metadata_offset,                              u2)                                    \\\n-  nonstatic_field(nmethod,                     _scopes_pcs_offset,                            int)                                    \\\n+  nonstatic_field(nmethod,                     _scopes_pcs_offset,                            int)                                   \\\n@@ -599,2 +560,0 @@\n-  unchecked_c2_static_field(Deoptimization,    _trap_reason_name,                             void*)                                 \\\n-                                                                                                                                     \\\n@@ -670,2 +629,0 @@\n-  nonstatic_field(Thread,                      _resource_area,                                ResourceArea*)                         \\\n-  nonstatic_field(CompilerThread,              _env,                                          ciEnv*)                                \\\n@@ -714,69 +671,0 @@\n-  \/*******************************\/                                                                                                  \\\n-  \/* Runtime1 (NOTE: incomplete) *\/                                                                                                  \\\n-  \/*******************************\/                                                                                                  \\\n-                                                                                                                                     \\\n-  unchecked_c1_static_field(Runtime1,          _blobs,                                 sizeof(Runtime1::_blobs)) \/* NOTE: no type *\/ \\\n-                                                                                                                                     \\\n-  \/**************\/                                                                                                                   \\\n-  \/* CI *\/                                                                                                                           \\\n-  \/************\/                                                                                                                     \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciEnv,                       _compiler_data,                                void*)                                 \\\n-  nonstatic_field(ciEnv,                       _factory,                                      ciObjectFactory*)                      \\\n-  nonstatic_field(ciEnv,                       _dependencies,                                 Dependencies*)                         \\\n-  nonstatic_field(ciEnv,                       _task,                                         CompileTask*)                          \\\n-  nonstatic_field(ciEnv,                       _arena,                                        Arena*)                                \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciBaseObject,                _ident,                                        uint)                                  \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciObject,                    _handle,                                       jobject)                               \\\n-  nonstatic_field(ciObject,                    _klass,                                        ciKlass*)                              \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciMetadata,                  _metadata,                                     Metadata*)                             \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciSymbol,                    _symbol,                                       Symbol*)                               \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciType,                      _basic_type,                                   BasicType)                             \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciKlass,                     _name,                                         ciSymbol*)                             \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciArrayKlass,                _dimension,                                    jint)                                  \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciObjArrayKlass,             _element_klass,                                ciKlass*)                              \\\n-  nonstatic_field(ciObjArrayKlass,             _base_element_klass,                           ciKlass*)                              \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciInstanceKlass,             _init_state,                                   InstanceKlass::ClassState)             \\\n-  nonstatic_field(ciInstanceKlass,             _is_shared,                                    bool)                                  \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciMethod,                    _interpreter_invocation_count,                 int)                                   \\\n-  nonstatic_field(ciMethod,                    _interpreter_throwout_count,                   int)                                   \\\n-  nonstatic_field(ciMethod,                    _inline_instructions_size,                     int)                                   \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciMethodData,                _data_size,                                    int)                                   \\\n-  nonstatic_field(ciMethodData,                _state,                                        u_char)                                \\\n-  nonstatic_field(ciMethodData,                _extra_data_size,                              int)                                   \\\n-  nonstatic_field(ciMethodData,                _data,                                         intptr_t*)                             \\\n-  nonstatic_field(ciMethodData,                _hint_di,                                      int)                                   \\\n-  nonstatic_field(ciMethodData,                _eflags,                                       intx)                                  \\\n-  nonstatic_field(ciMethodData,                _arg_local,                                    intx)                                  \\\n-  nonstatic_field(ciMethodData,                _arg_stack,                                    intx)                                  \\\n-  nonstatic_field(ciMethodData,                _arg_returned,                                 intx)                                  \\\n-  nonstatic_field(ciMethodData,                _orig,                                         MethodData::CompilerCounters)          \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciField,                     _holder,                                       ciInstanceKlass*)                      \\\n-  nonstatic_field(ciField,                     _name,                                         ciSymbol*)                             \\\n-  nonstatic_field(ciField,                     _signature,                                    ciSymbol*)                             \\\n-  nonstatic_field(ciField,                     _offset,                                       int)                                   \\\n-  nonstatic_field(ciField,                     _is_constant,                                  bool)                                  \\\n-  nonstatic_field(ciField,                     _constant_value,                               ciConstant)                            \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciObjectFactory,             _ci_metadata,                                  GrowableArray<ciMetadata*>)            \\\n-  nonstatic_field(ciObjectFactory,             _symbols,                                      GrowableArray<ciSymbol*>)              \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciConstant,                  _type,                                         BasicType)                             \\\n-  nonstatic_field(ciConstant,                  _value._int,                                   jint)                                  \\\n-  nonstatic_field(ciConstant,                  _value._long,                                  jlong)                                 \\\n-  nonstatic_field(ciConstant,                  _value._float,                                 jfloat)                                \\\n-  nonstatic_field(ciConstant,                  _value._double,                                jdouble)                               \\\n-  nonstatic_field(ciConstant,                  _value._object,                                ciObject*)                             \\\n-                                                                                                                                     \\\n@@ -802,117 +690,0 @@\n-  \/* Matcher (C2 only) *\/                                                                                                            \\\n-  \/*********************\/                                                                                                            \\\n-                                                                                                                                     \\\n-  unchecked_c2_static_field(Matcher,           _regEncode,                          sizeof(Matcher::_regEncode)) \/* NOTE: no type *\/ \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(Node,                     _in,                                           Node**)                                \\\n-  c2_nonstatic_field(Node,                     _out,                                          Node**)                                \\\n-  c2_nonstatic_field(Node,                     _cnt,                                          node_idx_t)                            \\\n-  c2_nonstatic_field(Node,                     _max,                                          node_idx_t)                            \\\n-  c2_nonstatic_field(Node,                     _outcnt,                                       node_idx_t)                            \\\n-  c2_nonstatic_field(Node,                     _outmax,                                       node_idx_t)                            \\\n-  c2_nonstatic_field(Node,                     _idx,                                          const node_idx_t)                      \\\n-  c2_nonstatic_field(Node,                     _class_id,                                     juint)                                 \\\n-  c2_nonstatic_field(Node,                     _flags,                                        juint)                                 \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(Compile,                  _root,                                         RootNode*)                             \\\n-  c2_nonstatic_field(Compile,                  _unique,                                       uint)                                  \\\n-  c2_nonstatic_field(Compile,                  _entry_bci,                                    int)                                   \\\n-  c2_nonstatic_field(Compile,                  _top,                                          Node*)                                 \\\n-  c2_nonstatic_field(Compile,                  _cfg,                                          PhaseCFG*)                             \\\n-  c2_nonstatic_field(Compile,                  _regalloc,                                     PhaseRegAlloc*)                        \\\n-  c2_nonstatic_field(Compile,                  _method,                                       ciMethod*)                             \\\n-  c2_nonstatic_field(Compile,                  _compile_id,                                   const int)                             \\\n-  c2_nonstatic_field(Compile,                  _options,                                      const Options)                         \\\n-  c2_nonstatic_field(Compile,                  _ilt,                                          InlineTree*)                           \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(Options,                  _subsume_loads,                                const bool)                            \\\n-  c2_nonstatic_field(Options,                  _do_escape_analysis,                           const bool)                            \\\n-  c2_nonstatic_field(Options,                  _eliminate_boxing,                             const bool)                            \\\n-  c2_nonstatic_field(Options,                  _do_locks_coarsening,                          const bool)                            \\\n-  c2_nonstatic_field(Options,                  _install_code,                                 const bool)                            \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(InlineTree,               _caller_jvms,                                  JVMState*)                             \\\n-  c2_nonstatic_field(InlineTree,               _method,                                       ciMethod*)                             \\\n-  c2_nonstatic_field(InlineTree,               _caller_tree,                                  InlineTree*)                           \\\n-  c2_nonstatic_field(InlineTree,               _subtrees,                                     GrowableArray<InlineTree*>)            \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(OptoRegPair,              _first,                                        short)                                 \\\n-  c2_nonstatic_field(OptoRegPair,              _second,                                       short)                                 \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(JVMState,                 _caller,                                       JVMState*)                             \\\n-  c2_nonstatic_field(JVMState,                 _depth,                                        uint)                                  \\\n-  c2_nonstatic_field(JVMState,                 _locoff,                                       uint)                                  \\\n-  c2_nonstatic_field(JVMState,                 _stkoff,                                       uint)                                  \\\n-  c2_nonstatic_field(JVMState,                 _monoff,                                       uint)                                  \\\n-  c2_nonstatic_field(JVMState,                 _scloff,                                       uint)                                  \\\n-  c2_nonstatic_field(JVMState,                 _endoff,                                       uint)                                  \\\n-  c2_nonstatic_field(JVMState,                 _sp,                                           uint)                                  \\\n-  c2_nonstatic_field(JVMState,                 _bci,                                          int)                                   \\\n-  c2_nonstatic_field(JVMState,                 _method,                                       ciMethod*)                             \\\n-  c2_nonstatic_field(JVMState,                 _map,                                          SafePointNode*)                        \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(SafePointNode,            _jvms,                                         JVMState* const)                       \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(MachSafePointNode,        _jvms,                                         JVMState*)                             \\\n-  c2_nonstatic_field(MachSafePointNode,        _jvmadj,                                       uint)                                  \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(MachIfNode,               _prob,                                         jfloat)                                \\\n-  c2_nonstatic_field(MachIfNode,               _fcnt,                                         jfloat)                                \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(MachJumpNode,             _probs,                                        jfloat*)                               \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(CallNode,                 _entry_point,                                  address)                               \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(CallJavaNode,             _method,                                       ciMethod*)                             \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(CallRuntimeNode,          _name,                                         const char*)                           \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(CallStaticJavaNode,       _name,                                         const char*)                           \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(MachCallJavaNode,         _method,                                       ciMethod*)                             \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(MachCallStaticJavaNode,   _name,                                         const char*)                           \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(MachCallRuntimeNode,      _name,                                         const char*)                           \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(PhaseCFG,                 _number_of_blocks,                             uint)                                  \\\n-  c2_nonstatic_field(PhaseCFG,                 _blocks,                                       Block_List)                            \\\n-  c2_nonstatic_field(PhaseCFG,                 _node_to_block_mapping,                        Block_Array)                           \\\n-  c2_nonstatic_field(PhaseCFG,                 _root_block,                                   Block*)                                \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(PhaseRegAlloc,            _node_regs,                                    OptoRegPair*)                          \\\n-  c2_nonstatic_field(PhaseRegAlloc,            _node_regs_max_index,                          uint)                                  \\\n-  c2_nonstatic_field(PhaseRegAlloc,            _framesize,                                    uint)                                  \\\n-  c2_nonstatic_field(PhaseRegAlloc,            _max_reg,                                      OptoReg::Name)                         \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(PhaseChaitin,             _trip_cnt,                                     int)                                   \\\n-  c2_nonstatic_field(PhaseChaitin,             _alternate,                                    int)                                   \\\n-  c2_nonstatic_field(PhaseChaitin,             _lo_degree,                                    uint)                                  \\\n-  c2_nonstatic_field(PhaseChaitin,             _lo_stk_degree,                                uint)                                  \\\n-  c2_nonstatic_field(PhaseChaitin,             _hi_degree,                                    uint)                                  \\\n-  c2_nonstatic_field(PhaseChaitin,             _simplified,                                   uint)                                  \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(Block,                    _nodes,                                        Node_List)                             \\\n-  c2_nonstatic_field(Block,                    _succs,                                        Block_Array)                           \\\n-  c2_nonstatic_field(Block,                    _num_succs,                                    uint)                                  \\\n-  c2_nonstatic_field(Block,                    _pre_order,                                    uint)                                  \\\n-  c2_nonstatic_field(Block,                    _dom_depth,                                    uint)                                  \\\n-  c2_nonstatic_field(Block,                    _idom,                                         Block*)                                \\\n-  c2_nonstatic_field(Block,                    _freq,                                         jdouble)                               \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(CFGElement,               _freq,                                         jdouble)                               \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(Block_List,               _cnt,                                          uint)                                  \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(Block_Array,              _size,                                         uint)                                  \\\n-  c2_nonstatic_field(Block_Array,              _blocks,                                       Block**)                               \\\n-  c2_nonstatic_field(Block_Array,              _arena,                                        Arena*)                                \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(Node_List,                _cnt,                                          uint)                                  \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(Node_Array,               _max,                                          uint)                                  \\\n-  c2_nonstatic_field(Node_Array,               _nodes,                                        Node**)                                \\\n-  c2_nonstatic_field(Node_Array,               _a,                                            Arena*)                                \\\n-                                                                                                                                     \\\n-                                                                                                                                     \\\n-  \/*********************\/                                                                                                            \\\n@@ -1067,4 +838,1 @@\n-                 declare_unsigned_integer_type,                           \\\n-                 declare_c1_toplevel_type,                                \\\n-                 declare_c2_type,                                         \\\n-                 declare_c2_toplevel_type)                                \\\n+                 declare_unsigned_integer_type)                           \\\n@@ -1234,1 +1002,1 @@\n-  \/* SystemDictionary *\/                                                  \\\n+  \/* VM Classes       *\/                                                  \\\n@@ -1237,1 +1005,0 @@\n-  declare_toplevel_type(SystemDictionary)                                 \\\n@@ -1243,2 +1010,0 @@\n-  declare_toplevel_type(Arena)                                            \\\n-    declare_type(ResourceArea, Arena)                                     \\\n@@ -1315,2 +1080,0 @@\n-  declare_toplevel_type(SharedRuntime)                                    \\\n-                                                                          \\\n@@ -1329,2 +1092,2 @@\n-  declare_c2_type(ExceptionBlob,         SingletonBlob)                   \\\n-  declare_c2_type(UncommonTrapBlob,      RuntimeBlob)                     \\\n+  COMPILER2_PRESENT(declare_type(ExceptionBlob,    SingletonBlob))        \\\n+  COMPILER2_PRESENT(declare_type(UncommonTrapBlob, RuntimeBlob))          \\\n@@ -1378,6 +1141,0 @@\n-  \/**********************\/                                                \\\n-  \/* Runtime1 (C1 only) *\/                                                \\\n-  \/**********************\/                                                \\\n-                                                                          \\\n-  declare_c1_toplevel_type(Runtime1)                                      \\\n-                                                                          \\\n@@ -1394,460 +1151,0 @@\n-  \/*********************\/                                                 \\\n-  \/* Matcher (C2 only) *\/                                                 \\\n-  \/*********************\/                                                 \\\n-                                                                          \\\n-  declare_c2_toplevel_type(Matcher)                                       \\\n-  declare_c2_toplevel_type(Compile)                                       \\\n-  declare_c2_toplevel_type(Options)                                       \\\n-  declare_c2_toplevel_type(InlineTree)                                    \\\n-  declare_c2_toplevel_type(OptoRegPair)                                   \\\n-  declare_c2_toplevel_type(JVMState)                                      \\\n-  declare_c2_toplevel_type(Phase)                                         \\\n-    declare_c2_type(PhaseCFG, Phase)                                      \\\n-    declare_c2_type(PhaseRegAlloc, Phase)                                 \\\n-    declare_c2_type(PhaseChaitin, PhaseRegAlloc)                          \\\n-  declare_c2_toplevel_type(CFGElement)                                    \\\n-    declare_c2_type(Block, CFGElement)                                    \\\n-  declare_c2_toplevel_type(Block_Array)                                   \\\n-    declare_c2_type(Block_List, Block_Array)                              \\\n-  declare_c2_toplevel_type(Node_Array)                                    \\\n-  declare_c2_type(Node_List, Node_Array)                                  \\\n-  declare_c2_type(Unique_Node_List, Node_List)                            \\\n-  declare_c2_toplevel_type(Node)                                          \\\n-  declare_c2_type(AddNode, Node)                                          \\\n-  declare_c2_type(AddINode, AddNode)                                      \\\n-  declare_c2_type(AddLNode, AddNode)                                      \\\n-  declare_c2_type(AddFNode, AddNode)                                      \\\n-  declare_c2_type(AddDNode, AddNode)                                      \\\n-  declare_c2_type(AddPNode, Node)                                         \\\n-  declare_c2_type(OrINode, AddNode)                                       \\\n-  declare_c2_type(OrLNode, AddNode)                                       \\\n-  declare_c2_type(XorINode, AddNode)                                      \\\n-  declare_c2_type(XorLNode, AddNode)                                      \\\n-  declare_c2_type(MaxNode, AddNode)                                       \\\n-  declare_c2_type(MaxINode, MaxNode)                                      \\\n-  declare_c2_type(MinINode, MaxNode)                                      \\\n-  declare_c2_type(MaxLNode, MaxNode)                                      \\\n-  declare_c2_type(MinLNode, MaxNode)                                      \\\n-  declare_c2_type(MaxFNode, MaxNode)                                      \\\n-  declare_c2_type(MinFNode, MaxNode)                                      \\\n-  declare_c2_type(MaxDNode, MaxNode)                                      \\\n-  declare_c2_type(MinDNode, MaxNode)                                      \\\n-  declare_c2_type(StartNode, MultiNode)                                   \\\n-  declare_c2_type(StartOSRNode, StartNode)                                \\\n-  declare_c2_type(ParmNode, ProjNode)                                     \\\n-  declare_c2_type(ReturnNode, Node)                                       \\\n-  declare_c2_type(RethrowNode, Node)                                      \\\n-  declare_c2_type(TailCallNode, ReturnNode)                               \\\n-  declare_c2_type(TailJumpNode, ReturnNode)                               \\\n-  declare_c2_type(ForwardExceptionNode, ReturnNode)                       \\\n-  declare_c2_type(SafePointNode, MultiNode)                               \\\n-  declare_c2_type(CallNode, SafePointNode)                                \\\n-  declare_c2_type(CallJavaNode, CallNode)                                 \\\n-  declare_c2_type(CallStaticJavaNode, CallJavaNode)                       \\\n-  declare_c2_type(CallDynamicJavaNode, CallJavaNode)                      \\\n-  declare_c2_type(CallRuntimeNode, CallNode)                              \\\n-  declare_c2_type(CallLeafNode, CallRuntimeNode)                          \\\n-  declare_c2_type(CallLeafNoFPNode, CallLeafNode)                         \\\n-  declare_c2_type(CallLeafVectorNode, CallLeafNode)                       \\\n-  declare_c2_type(AllocateNode, CallNode)                                 \\\n-  declare_c2_type(AllocateArrayNode, AllocateNode)                        \\\n-  declare_c2_type(LockNode, AbstractLockNode)                             \\\n-  declare_c2_type(UnlockNode, AbstractLockNode)                           \\\n-  declare_c2_type(FastLockNode, CmpNode)                                  \\\n-  declare_c2_type(FastUnlockNode, CmpNode)                                \\\n-  declare_c2_type(RegionNode, Node)                                       \\\n-  declare_c2_type(JProjNode, ProjNode)                                    \\\n-  declare_c2_type(PhiNode, TypeNode)                                      \\\n-  declare_c2_type(GotoNode, Node)                                         \\\n-  declare_c2_type(CProjNode, ProjNode)                                    \\\n-  declare_c2_type(MultiBranchNode, MultiNode)                             \\\n-  declare_c2_type(IfNode, MultiBranchNode)                                \\\n-  declare_c2_type(IfTrueNode, CProjNode)                                  \\\n-  declare_c2_type(IfFalseNode, CProjNode)                                 \\\n-  declare_c2_type(PCTableNode, MultiBranchNode)                           \\\n-  declare_c2_type(JumpNode, PCTableNode)                                  \\\n-  declare_c2_type(JumpProjNode, JProjNode)                                \\\n-  declare_c2_type(CatchNode, PCTableNode)                                 \\\n-  declare_c2_type(CatchProjNode, CProjNode)                               \\\n-  declare_c2_type(CreateExNode, TypeNode)                                 \\\n-  declare_c2_type(ClearArrayNode, Node)                                   \\\n-  declare_c2_type(NeverBranchNode, MultiBranchNode)                       \\\n-  declare_c2_type(ConNode, TypeNode)                                      \\\n-  declare_c2_type(ConINode, ConNode)                                      \\\n-  declare_c2_type(ConPNode, ConNode)                                      \\\n-  declare_c2_type(ConNNode, ConNode)                                      \\\n-  declare_c2_type(ConLNode, ConNode)                                      \\\n-  declare_c2_type(ConFNode, ConNode)                                      \\\n-  declare_c2_type(ConDNode, ConNode)                                      \\\n-  declare_c2_type(BinaryNode, Node)                                       \\\n-  declare_c2_type(CMoveNode, TypeNode)                                    \\\n-  declare_c2_type(CMoveDNode, CMoveNode)                                  \\\n-  declare_c2_type(CMoveFNode, CMoveNode)                                  \\\n-  declare_c2_type(CMoveINode, CMoveNode)                                  \\\n-  declare_c2_type(CMoveLNode, CMoveNode)                                  \\\n-  declare_c2_type(CMovePNode, CMoveNode)                                  \\\n-  declare_c2_type(CMoveNNode, CMoveNode)                                  \\\n-  declare_c2_type(EncodePNode, TypeNode)                                  \\\n-  declare_c2_type(DecodeNNode, TypeNode)                                  \\\n-  declare_c2_type(EncodePKlassNode, TypeNode)                             \\\n-  declare_c2_type(DecodeNKlassNode, TypeNode)                             \\\n-  declare_c2_type(ConstraintCastNode, TypeNode)                           \\\n-  declare_c2_type(CastIINode, ConstraintCastNode)                         \\\n-  declare_c2_type(CastPPNode, ConstraintCastNode)                         \\\n-  declare_c2_type(CheckCastPPNode, TypeNode)                              \\\n-  declare_c2_type(Conv2BNode, Node)                                       \\\n-  declare_c2_type(ConvertNode, TypeNode)                                  \\\n-  declare_c2_type(ConvD2FNode, Node)                                      \\\n-  declare_c2_type(ConvD2INode, Node)                                      \\\n-  declare_c2_type(ConvD2LNode, Node)                                      \\\n-  declare_c2_type(ConvF2DNode, Node)                                      \\\n-  declare_c2_type(ConvF2INode, Node)                                      \\\n-  declare_c2_type(ConvF2LNode, Node)                                      \\\n-  declare_c2_type(ConvI2DNode, Node)                                      \\\n-  declare_c2_type(ConvI2FNode, Node)                                      \\\n-  declare_c2_type(ConvI2LNode, TypeNode)                                  \\\n-  declare_c2_type(ConvL2DNode, Node)                                      \\\n-  declare_c2_type(ConvL2FNode, Node)                                      \\\n-  declare_c2_type(ConvL2INode, Node)                                      \\\n-  declare_c2_type(CastX2PNode, Node)                                      \\\n-  declare_c2_type(CastP2XNode, Node)                                      \\\n-  declare_c2_type(MemBarNode, MultiNode)                                  \\\n-  declare_c2_type(MemBarAcquireNode, MemBarNode)                          \\\n-  declare_c2_type(MemBarReleaseNode, MemBarNode)                          \\\n-  declare_c2_type(LoadFenceNode, MemBarNode)                              \\\n-  declare_c2_type(StoreFenceNode, MemBarNode)                             \\\n-  declare_c2_type(MemBarVolatileNode, MemBarNode)                         \\\n-  declare_c2_type(MemBarCPUOrderNode, MemBarNode)                         \\\n-  declare_c2_type(OnSpinWaitNode, MemBarNode)                             \\\n-  declare_c2_type(BlackholeNode, MultiNode)                               \\\n-  declare_c2_type(InitializeNode, MemBarNode)                             \\\n-  declare_c2_type(ThreadLocalNode, Node)                                  \\\n-  declare_c2_type(Opaque1Node, Node)                                      \\\n-  declare_c2_type(PartialSubtypeCheckNode, Node)                          \\\n-  declare_c2_type(MoveI2FNode, Node)                                      \\\n-  declare_c2_type(MoveL2DNode, Node)                                      \\\n-  declare_c2_type(MoveF2INode, Node)                                      \\\n-  declare_c2_type(MoveD2LNode, Node)                                      \\\n-  declare_c2_type(DivINode, Node)                                         \\\n-  declare_c2_type(DivLNode, Node)                                         \\\n-  declare_c2_type(DivFNode, Node)                                         \\\n-  declare_c2_type(DivDNode, Node)                                         \\\n-  declare_c2_type(UDivINode, Node)                                        \\\n-  declare_c2_type(UDivLNode, Node)                                        \\\n-  declare_c2_type(ModINode, Node)                                         \\\n-  declare_c2_type(ModLNode, Node)                                         \\\n-  declare_c2_type(ModFNode, Node)                                         \\\n-  declare_c2_type(ModDNode, Node)                                         \\\n-  declare_c2_type(UModINode, Node)                                        \\\n-  declare_c2_type(UModLNode, Node)                                        \\\n-  declare_c2_type(DivModNode, MultiNode)                                  \\\n-  declare_c2_type(DivModINode, DivModNode)                                \\\n-  declare_c2_type(DivModLNode, DivModNode)                                \\\n-  declare_c2_type(UDivModINode, DivModNode)                               \\\n-  declare_c2_type(UDivModLNode, DivModNode)                               \\\n-  declare_c2_type(BoxLockNode, Node)                                      \\\n-  declare_c2_type(LoopNode, RegionNode)                                   \\\n-  declare_c2_type(CountedLoopNode, LoopNode)                              \\\n-  declare_c2_type(CountedLoopEndNode, IfNode)                             \\\n-  declare_c2_type(MachNode, Node)                                         \\\n-  declare_c2_type(MachIdealNode, MachNode)                                \\\n-  declare_c2_type(MachTypeNode, MachNode)                                 \\\n-  declare_c2_type(MachBreakpointNode, MachIdealNode)                      \\\n-  declare_c2_type(MachUEPNode, MachIdealNode)                             \\\n-  declare_c2_type(MachPrologNode, MachIdealNode)                          \\\n-  declare_c2_type(MachEpilogNode, MachIdealNode)                          \\\n-  declare_c2_type(MachNopNode, MachIdealNode)                             \\\n-  declare_c2_type(MachSpillCopyNode, MachIdealNode)                       \\\n-  declare_c2_type(MachNullCheckNode, MachIdealNode)                       \\\n-  declare_c2_type(MachProjNode, ProjNode)                                 \\\n-  declare_c2_type(MachIfNode, MachNode)                                   \\\n-  declare_c2_type(MachJumpNode, MachNode)                                 \\\n-  declare_c2_type(MachFastLockNode, MachNode)                             \\\n-  declare_c2_type(MachReturnNode, MachNode)                               \\\n-  declare_c2_type(MachSafePointNode, MachReturnNode)                      \\\n-  declare_c2_type(MachCallNode, MachSafePointNode)                        \\\n-  declare_c2_type(MachCallJavaNode, MachCallNode)                         \\\n-  declare_c2_type(MachCallStaticJavaNode, MachCallJavaNode)               \\\n-  declare_c2_type(MachCallDynamicJavaNode, MachCallJavaNode)              \\\n-  declare_c2_type(MachCallRuntimeNode, MachCallNode)                      \\\n-  declare_c2_type(MachHaltNode, MachReturnNode)                           \\\n-  declare_c2_type(MachTempNode, MachNode)                                 \\\n-  declare_c2_type(MemNode, Node)                                          \\\n-  declare_c2_type(MergeMemNode, Node)                                     \\\n-  declare_c2_type(LoadNode, MemNode)                                      \\\n-  declare_c2_type(LoadBNode, LoadNode)                                    \\\n-  declare_c2_type(LoadUSNode, LoadNode)                                   \\\n-  declare_c2_type(LoadINode, LoadNode)                                    \\\n-  declare_c2_type(LoadRangeNode, LoadINode)                               \\\n-  declare_c2_type(LoadLNode, LoadNode)                                    \\\n-  declare_c2_type(LoadL_unalignedNode, LoadLNode)                         \\\n-  declare_c2_type(LoadFNode, LoadNode)                                    \\\n-  declare_c2_type(LoadDNode, LoadNode)                                    \\\n-  declare_c2_type(LoadD_unalignedNode, LoadDNode)                         \\\n-  declare_c2_type(LoadPNode, LoadNode)                                    \\\n-  declare_c2_type(LoadNNode, LoadNode)                                    \\\n-  declare_c2_type(LoadKlassNode, LoadPNode)                               \\\n-  declare_c2_type(LoadNKlassNode, LoadNNode)                              \\\n-  declare_c2_type(LoadSNode, LoadNode)                                    \\\n-  declare_c2_type(StoreNode, MemNode)                                     \\\n-  declare_c2_type(StoreBNode, StoreNode)                                  \\\n-  declare_c2_type(StoreCNode, StoreNode)                                  \\\n-  declare_c2_type(StoreINode, StoreNode)                                  \\\n-  declare_c2_type(StoreLNode, StoreNode)                                  \\\n-  declare_c2_type(StoreFNode, StoreNode)                                  \\\n-  declare_c2_type(StoreDNode, StoreNode)                                  \\\n-  declare_c2_type(StorePNode, StoreNode)                                  \\\n-  declare_c2_type(StoreNNode, StoreNode)                                  \\\n-  declare_c2_type(StoreNKlassNode, StoreNode)                             \\\n-  declare_c2_type(SCMemProjNode, ProjNode)                                \\\n-  declare_c2_type(LoadStoreNode, Node)                                    \\\n-  declare_c2_type(CompareAndSwapNode, LoadStoreConditionalNode)           \\\n-  declare_c2_type(CompareAndSwapBNode, CompareAndSwapNode)                \\\n-  declare_c2_type(CompareAndSwapSNode, CompareAndSwapNode)                \\\n-  declare_c2_type(CompareAndSwapLNode, CompareAndSwapNode)                \\\n-  declare_c2_type(CompareAndSwapINode, CompareAndSwapNode)                \\\n-  declare_c2_type(CompareAndSwapPNode, CompareAndSwapNode)                \\\n-  declare_c2_type(CompareAndSwapNNode, CompareAndSwapNode)                \\\n-  declare_c2_type(WeakCompareAndSwapBNode, CompareAndSwapNode)            \\\n-  declare_c2_type(WeakCompareAndSwapSNode, CompareAndSwapNode)            \\\n-  declare_c2_type(WeakCompareAndSwapLNode, CompareAndSwapNode)            \\\n-  declare_c2_type(WeakCompareAndSwapINode, CompareAndSwapNode)            \\\n-  declare_c2_type(WeakCompareAndSwapPNode, CompareAndSwapNode)            \\\n-  declare_c2_type(WeakCompareAndSwapNNode, CompareAndSwapNode)            \\\n-  declare_c2_type(CompareAndExchangeNode, LoadStoreNode)                  \\\n-  declare_c2_type(CompareAndExchangeBNode, CompareAndExchangeNode)        \\\n-  declare_c2_type(CompareAndExchangeSNode, CompareAndExchangeNode)        \\\n-  declare_c2_type(CompareAndExchangeLNode, CompareAndExchangeNode)        \\\n-  declare_c2_type(CompareAndExchangeINode, CompareAndExchangeNode)        \\\n-  declare_c2_type(CompareAndExchangePNode, CompareAndExchangeNode)        \\\n-  declare_c2_type(CompareAndExchangeNNode, CompareAndExchangeNode)        \\\n-  declare_c2_type(MulNode, Node)                                          \\\n-  declare_c2_type(MulINode, MulNode)                                      \\\n-  declare_c2_type(MulLNode, MulNode)                                      \\\n-  declare_c2_type(MulFNode, MulNode)                                      \\\n-  declare_c2_type(MulDNode, MulNode)                                      \\\n-  declare_c2_type(MulHiLNode, Node)                                       \\\n-  declare_c2_type(UMulHiLNode, Node)                                      \\\n-  declare_c2_type(AndINode, MulINode)                                     \\\n-  declare_c2_type(AndLNode, MulLNode)                                     \\\n-  declare_c2_type(LShiftINode, Node)                                      \\\n-  declare_c2_type(LShiftLNode, Node)                                      \\\n-  declare_c2_type(RShiftINode, Node)                                      \\\n-  declare_c2_type(RShiftLNode, Node)                                      \\\n-  declare_c2_type(URShiftINode, Node)                                     \\\n-  declare_c2_type(URShiftLNode, Node)                                     \\\n-  declare_c2_type(MultiNode, Node)                                        \\\n-  declare_c2_type(ProjNode, Node)                                         \\\n-  declare_c2_type(TypeNode, Node)                                         \\\n-  declare_c2_type(RootNode, LoopNode)                                     \\\n-  declare_c2_type(HaltNode, Node)                                         \\\n-  declare_c2_type(SubNode, Node)                                          \\\n-  declare_c2_type(SubINode, SubNode)                                      \\\n-  declare_c2_type(SubLNode, SubNode)                                      \\\n-  declare_c2_type(SubFPNode, SubNode)                                     \\\n-  declare_c2_type(SubFNode, SubFPNode)                                    \\\n-  declare_c2_type(SubDNode, SubFPNode)                                    \\\n-  declare_c2_type(CmpNode, SubNode)                                       \\\n-  declare_c2_type(CmpINode, CmpNode)                                      \\\n-  declare_c2_type(CmpUNode, CmpNode)                                      \\\n-  declare_c2_type(CmpU3Node, CmpUNode)                                    \\\n-  declare_c2_type(CmpPNode, CmpNode)                                      \\\n-  declare_c2_type(CmpNNode, CmpNode)                                      \\\n-  declare_c2_type(CmpLNode, CmpNode)                                      \\\n-  declare_c2_type(CmpULNode, CmpNode)                                     \\\n-  declare_c2_type(CmpL3Node, CmpLNode)                                    \\\n-  declare_c2_type(CmpUL3Node, CmpULNode)                                  \\\n-  declare_c2_type(CmpFNode, CmpNode)                                      \\\n-  declare_c2_type(CmpF3Node, CmpFNode)                                    \\\n-  declare_c2_type(CmpDNode, CmpNode)                                      \\\n-  declare_c2_type(CmpD3Node, CmpDNode)                                    \\\n-  declare_c2_type(BoolNode, Node)                                         \\\n-  declare_c2_type(AbsNode, Node)                                          \\\n-  declare_c2_type(AbsINode, AbsNode)                                      \\\n-  declare_c2_type(AbsFNode, AbsNode)                                      \\\n-  declare_c2_type(AbsDNode, AbsNode)                                      \\\n-  declare_c2_type(CmpLTMaskNode, Node)                                    \\\n-  declare_c2_type(NegNode, Node)                                          \\\n-  declare_c2_type(NegINode, NegNode)                                      \\\n-  declare_c2_type(NegLNode, NegNode)                                      \\\n-  declare_c2_type(NegFNode, NegNode)                                      \\\n-  declare_c2_type(NegDNode, NegNode)                                      \\\n-  declare_c2_type(AtanDNode, Node)                                        \\\n-  declare_c2_type(SqrtFNode, Node)                                        \\\n-  declare_c2_type(SqrtDNode, Node)                                        \\\n-  declare_c2_type(ReverseBytesINode, Node)                                \\\n-  declare_c2_type(ReverseBytesLNode, Node)                                \\\n-  declare_c2_type(ReductionNode, Node)                                    \\\n-  declare_c2_type(VectorNode, Node)                                       \\\n-  declare_c2_type(AbsVFNode, VectorNode)                                  \\\n-  declare_c2_type(AbsVDNode, VectorNode)                                  \\\n-  declare_c2_type(AbsVBNode, VectorNode)                                  \\\n-  declare_c2_type(AbsVSNode, VectorNode)                                  \\\n-  declare_c2_type(AbsVINode, VectorNode)                                  \\\n-  declare_c2_type(AbsVLNode, VectorNode)                                  \\\n-  declare_c2_type(AddVBNode, VectorNode)                                  \\\n-  declare_c2_type(AddVSNode, VectorNode)                                  \\\n-  declare_c2_type(AddVINode, VectorNode)                                  \\\n-  declare_c2_type(AddReductionVINode, ReductionNode)                      \\\n-  declare_c2_type(AddVLNode, VectorNode)                                  \\\n-  declare_c2_type(AddReductionVLNode, ReductionNode)                      \\\n-  declare_c2_type(AddVFNode, VectorNode)                                  \\\n-  declare_c2_type(AddReductionVFNode, ReductionNode)                      \\\n-  declare_c2_type(AddVDNode, VectorNode)                                  \\\n-  declare_c2_type(AddReductionVDNode, ReductionNode)                      \\\n-  declare_c2_type(SubVBNode, VectorNode)                                  \\\n-  declare_c2_type(SubVSNode, VectorNode)                                  \\\n-  declare_c2_type(SubVINode, VectorNode)                                  \\\n-  declare_c2_type(SubVLNode, VectorNode)                                  \\\n-  declare_c2_type(SubVFNode, VectorNode)                                  \\\n-  declare_c2_type(SubVDNode, VectorNode)                                  \\\n-  declare_c2_type(MulVBNode, VectorNode)                                  \\\n-  declare_c2_type(MulVSNode, VectorNode)                                  \\\n-  declare_c2_type(MulVLNode, VectorNode)                                  \\\n-  declare_c2_type(MulReductionVLNode, ReductionNode)                      \\\n-  declare_c2_type(MulVINode, VectorNode)                                  \\\n-  declare_c2_type(MulReductionVINode, ReductionNode)                      \\\n-  declare_c2_type(MulVFNode, VectorNode)                                  \\\n-  declare_c2_type(MulReductionVFNode, ReductionNode)                      \\\n-  declare_c2_type(MulVDNode, VectorNode)                                  \\\n-  declare_c2_type(NegVNode, VectorNode)                                   \\\n-  declare_c2_type(NegVINode, NegVNode)                                    \\\n-  declare_c2_type(NegVLNode, NegVNode)                                    \\\n-  declare_c2_type(NegVFNode, NegVNode)                                    \\\n-  declare_c2_type(NegVDNode, NegVNode)                                    \\\n-  declare_c2_type(FmaVDNode, VectorNode)                                  \\\n-  declare_c2_type(FmaVFNode, VectorNode)                                  \\\n-  declare_c2_type(CompressVNode, VectorNode)                              \\\n-  declare_c2_type(CompressMNode, VectorNode)                              \\\n-  declare_c2_type(ExpandVNode, VectorNode)                                \\\n-  declare_c2_type(CompressBitsVNode, VectorNode)                          \\\n-  declare_c2_type(ExpandBitsVNode, VectorNode)                            \\\n-  declare_c2_type(MulReductionVDNode, ReductionNode)                      \\\n-  declare_c2_type(DivVFNode, VectorNode)                                  \\\n-  declare_c2_type(DivVDNode, VectorNode)                                  \\\n-  declare_c2_type(PopCountVINode, VectorNode)                             \\\n-  declare_c2_type(PopCountVLNode, VectorNode)                             \\\n-  declare_c2_type(LShiftVBNode, VectorNode)                               \\\n-  declare_c2_type(LShiftVSNode, VectorNode)                               \\\n-  declare_c2_type(LShiftVINode, VectorNode)                               \\\n-  declare_c2_type(LShiftVLNode, VectorNode)                               \\\n-  declare_c2_type(RShiftVBNode, VectorNode)                               \\\n-  declare_c2_type(RShiftVSNode, VectorNode)                               \\\n-  declare_c2_type(RShiftVINode, VectorNode)                               \\\n-  declare_c2_type(RShiftVLNode, VectorNode)                               \\\n-  declare_c2_type(URShiftVBNode, VectorNode)                              \\\n-  declare_c2_type(URShiftVSNode, VectorNode)                              \\\n-  declare_c2_type(URShiftVINode, VectorNode)                              \\\n-  declare_c2_type(URShiftVLNode, VectorNode)                              \\\n-  declare_c2_type(MinReductionVNode, ReductionNode)                       \\\n-  declare_c2_type(MaxReductionVNode, ReductionNode)                       \\\n-  declare_c2_type(AndVNode, VectorNode)                                   \\\n-  declare_c2_type(AndReductionVNode, ReductionNode)                       \\\n-  declare_c2_type(OrVNode, VectorNode)                                    \\\n-  declare_c2_type(OrReductionVNode, ReductionNode)                        \\\n-  declare_c2_type(XorVNode, VectorNode)                                   \\\n-  declare_c2_type(XorReductionVNode, ReductionNode)                       \\\n-  declare_c2_type(MaxVNode, VectorNode)                                   \\\n-  declare_c2_type(MinVNode, VectorNode)                                   \\\n-  declare_c2_type(LoadVectorNode, LoadNode)                               \\\n-  declare_c2_type(StoreVectorNode, StoreNode)                             \\\n-  declare_c2_type(ReplicateNode, VectorNode)                              \\\n-  declare_c2_type(PopulateIndexNode, VectorNode)                          \\\n-  declare_c2_type(PackNode, VectorNode)                                   \\\n-  declare_c2_type(PackBNode, PackNode)                                    \\\n-  declare_c2_type(PackSNode, PackNode)                                    \\\n-  declare_c2_type(PackINode, PackNode)                                    \\\n-  declare_c2_type(PackLNode, PackNode)                                    \\\n-  declare_c2_type(PackFNode, PackNode)                                    \\\n-  declare_c2_type(PackDNode, PackNode)                                    \\\n-  declare_c2_type(Pack2LNode, PackNode)                                   \\\n-  declare_c2_type(Pack2DNode, PackNode)                                   \\\n-  declare_c2_type(ExtractNode, Node)                                      \\\n-  declare_c2_type(ExtractBNode, ExtractNode)                              \\\n-  declare_c2_type(ExtractUBNode, ExtractNode)                             \\\n-  declare_c2_type(ExtractCNode, ExtractNode)                              \\\n-  declare_c2_type(ExtractSNode, ExtractNode)                              \\\n-  declare_c2_type(ExtractINode, ExtractNode)                              \\\n-  declare_c2_type(ExtractLNode, ExtractNode)                              \\\n-  declare_c2_type(ExtractFNode, ExtractNode)                              \\\n-  declare_c2_type(ExtractDNode, ExtractNode)                              \\\n-  declare_c2_type(OverflowNode, CmpNode)                                  \\\n-  declare_c2_type(OverflowINode, OverflowNode)                            \\\n-  declare_c2_type(OverflowAddINode, OverflowINode)                        \\\n-  declare_c2_type(OverflowSubINode, OverflowINode)                        \\\n-  declare_c2_type(OverflowMulINode, OverflowINode)                        \\\n-  declare_c2_type(OverflowLNode, OverflowNode)                            \\\n-  declare_c2_type(OverflowAddLNode, OverflowLNode)                        \\\n-  declare_c2_type(OverflowSubLNode, OverflowLNode)                        \\\n-  declare_c2_type(OverflowMulLNode, OverflowLNode)                        \\\n-  declare_c2_type(FmaDNode, Node)                                         \\\n-  declare_c2_type(FmaFNode, Node)                                         \\\n-  declare_c2_type(CopySignDNode, Node)                                    \\\n-  declare_c2_type(CopySignFNode, Node)                                    \\\n-  declare_c2_type(SignumDNode, Node)                                      \\\n-  declare_c2_type(SignumFNode, Node)                                      \\\n-  declare_c2_type(IsInfiniteFNode, Node)                                  \\\n-  declare_c2_type(IsInfiniteDNode, Node)                                  \\\n-  declare_c2_type(IsFiniteFNode, Node)                                    \\\n-  declare_c2_type(IsFiniteDNode, Node)                                    \\\n-  declare_c2_type(LoadVectorGatherNode, LoadVectorNode)                   \\\n-  declare_c2_type(StoreVectorScatterNode, StoreVectorNode)                \\\n-  declare_c2_type(VectorLoadMaskNode, VectorNode)                         \\\n-  declare_c2_type(VectorLoadShuffleNode, VectorNode)                      \\\n-  declare_c2_type(VectorStoreMaskNode, VectorNode)                        \\\n-  declare_c2_type(VectorBlendNode, VectorNode)                            \\\n-  declare_c2_type(VectorRearrangeNode, VectorNode)                        \\\n-  declare_c2_type(VectorMaskWrapperNode, VectorNode)                      \\\n-  declare_c2_type(VectorMaskCmpNode, VectorNode)                          \\\n-  declare_c2_type(VectorCastB2XNode, VectorNode)                          \\\n-  declare_c2_type(VectorCastS2XNode, VectorNode)                          \\\n-  declare_c2_type(VectorCastI2XNode, VectorNode)                          \\\n-  declare_c2_type(VectorCastL2XNode, VectorNode)                          \\\n-  declare_c2_type(VectorCastF2XNode, VectorNode)                          \\\n-  declare_c2_type(VectorCastD2XNode, VectorNode)                          \\\n-  declare_c2_type(VectorUCastB2XNode, VectorNode)                         \\\n-  declare_c2_type(VectorUCastS2XNode, VectorNode)                         \\\n-  declare_c2_type(VectorUCastI2XNode, VectorNode)                         \\\n-  declare_c2_type(VectorInsertNode, VectorNode)                           \\\n-  declare_c2_type(VectorUnboxNode, VectorNode)                            \\\n-  declare_c2_type(VectorReinterpretNode, VectorNode)                      \\\n-  declare_c2_type(VectorMaskCastNode, VectorNode)                         \\\n-  declare_c2_type(CountLeadingZerosVNode, VectorNode)                     \\\n-  declare_c2_type(CountTrailingZerosVNode, VectorNode)                    \\\n-  declare_c2_type(ReverseBytesVNode, VectorNode)                          \\\n-  declare_c2_type(ReverseVNode, VectorNode)                               \\\n-  declare_c2_type(MaskAllNode, VectorNode)                                \\\n-  declare_c2_type(AndVMaskNode, VectorNode)                               \\\n-  declare_c2_type(OrVMaskNode, VectorNode)                                \\\n-  declare_c2_type(XorVMaskNode, VectorNode)                               \\\n-  declare_c2_type(VectorBoxNode, Node)                                    \\\n-  declare_c2_type(VectorBoxAllocateNode, CallStaticJavaNode)              \\\n-  declare_c2_type(VectorTestNode, CmpNode)                                \\\n-                                                                          \\\n-  \/*********************\/                                                 \\\n-  \/* Adapter Blob Entries *\/                                              \\\n-  \/*********************\/                                                 \\\n-  declare_toplevel_type(AdapterHandlerEntry)                              \\\n-  declare_toplevel_type(AdapterHandlerEntry*)                             \\\n-                                                                          \\\n-  \/*********************\/                                                 \\\n-  \/* CI *\/                                                                \\\n-  \/*********************\/                                                 \\\n-  declare_toplevel_type(ciEnv)                                            \\\n-  declare_toplevel_type(ciObjectFactory)                                  \\\n-  declare_toplevel_type(ciConstant)                                       \\\n-  declare_toplevel_type(ciField)                                          \\\n-  declare_toplevel_type(ciSymbol)                                         \\\n-  declare_toplevel_type(ciBaseObject)                                     \\\n-  declare_type(ciObject, ciBaseObject)                                    \\\n-  declare_type(ciInstance, ciObject)                                      \\\n-  declare_type(ciMetadata, ciBaseObject)                                  \\\n-  declare_type(ciMethod, ciMetadata)                                      \\\n-  declare_type(ciMethodData, ciMetadata)                                  \\\n-  declare_type(ciType, ciMetadata)                                        \\\n-  declare_type(ciKlass, ciType)                                           \\\n-  declare_type(ciInstanceKlass, ciKlass)                                  \\\n-  declare_type(ciArrayKlass, ciKlass)                                     \\\n-  declare_type(ciTypeArrayKlass, ciArrayKlass)                            \\\n-  declare_type(ciObjArrayKlass, ciArrayKlass)                             \\\n-                                                                          \\\n@@ -1898,1 +1195,0 @@\n-   COMPILER2_PRESENT(declare_integer_type(OptoReg::Name))                 \\\n@@ -1921,0 +1217,1 @@\n+  declare_integer_type(CodeBlobKind)                                      \\\n@@ -1949,1 +1246,0 @@\n-  COMPILER2_PRESENT(declare_unsigned_integer_type(node_idx_t))            \\\n@@ -1989,4 +1285,1 @@\n-                         declare_preprocessor_constant,                   \\\n-                         declare_c1_constant,                             \\\n-                         declare_c2_constant,                             \\\n-                         declare_c2_preprocessor_constant)                \\\n+                         declare_preprocessor_constant)                   \\\n@@ -2006,0 +1299,1 @@\n+  declare_preprocessor_constant(\"COMPILER2\", COMPILER2_PRESENT(1) NOT_COMPILER2(0)) \\\n@@ -2272,0 +1566,1 @@\n+  declare_constant(Deoptimization::Reason_auto_vectorization_check)       \\\n@@ -2354,6 +1649,0 @@\n-  \/*********************\/                                                 \\\n-  \/* Matcher (C2 only) *\/                                                 \\\n-  \/*********************\/                                                 \\\n-                                                                          \\\n-  declare_c2_preprocessor_constant(\"Matcher::interpreter_frame_pointer_reg\", Matcher::interpreter_frame_pointer_reg()) \\\n-                                                                          \\\n@@ -2378,0 +1667,17 @@\n+  \/****************\/                                                      \\\n+  \/* CodeBlobKind *\/                                                      \\\n+  \/****************\/                                                      \\\n+                                                                          \\\n+  declare_constant(CodeBlobKind::Nmethod)                                 \\\n+  declare_constant(CodeBlobKind::Buffer)                                  \\\n+  declare_constant(CodeBlobKind::Adapter)                                 \\\n+  declare_constant(CodeBlobKind::Vtable)                                  \\\n+  declare_constant(CodeBlobKind::MHAdapter)                               \\\n+  declare_constant(CodeBlobKind::RuntimeStub)                             \\\n+  declare_constant(CodeBlobKind::Deoptimization)                          \\\n+  declare_constant(CodeBlobKind::Safepoint)                               \\\n+  COMPILER2_PRESENT(declare_constant(CodeBlobKind::Exception))            \\\n+  COMPILER2_PRESENT(declare_constant(CodeBlobKind::UncommonTrap))         \\\n+  declare_constant(CodeBlobKind::Upcall)                                  \\\n+  declare_constant(CodeBlobKind::Number_Of_Kinds)                         \\\n+                                                                          \\\n@@ -2442,2 +1748,2 @@\n-  declare_c2_preprocessor_constant(\"SAVED_ON_ENTRY_REG_COUNT\", SAVED_ON_ENTRY_REG_COUNT) \\\n-  declare_c2_preprocessor_constant(\"C_SAVED_ON_ENTRY_REG_COUNT\", C_SAVED_ON_ENTRY_REG_COUNT) \\\n+  COMPILER2_PRESENT(declare_preprocessor_constant(\"SAVED_ON_ENTRY_REG_COUNT\", SAVED_ON_ENTRY_REG_COUNT)) \\\n+  COMPILER2_PRESENT(declare_preprocessor_constant(\"C_SAVED_ON_ENTRY_REG_COUNT\", C_SAVED_ON_ENTRY_REG_COUNT)) \\\n@@ -2494,1 +1800,1 @@\n-#define VM_LONG_CONSTANTS(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant) \\\n+#define VM_LONG_CONSTANTS(declare_constant, declare_preprocessor_constant) \\\n@@ -2566,102 +1872,0 @@\n-\/\/ Generate and check a nonstatic field in C1 builds\n-#ifdef COMPILER1\n-# define GENERATE_C1_NONSTATIC_VM_STRUCT_ENTRY(a, b, c) GENERATE_NONSTATIC_VM_STRUCT_ENTRY(a, b, c)\n-# define CHECK_C1_NONSTATIC_VM_STRUCT_ENTRY(a, b, c)    CHECK_NONSTATIC_VM_STRUCT_ENTRY(a, b, c)\n-# define ENSURE_C1_FIELD_TYPE_PRESENT(a, b, c)          ENSURE_FIELD_TYPE_PRESENT(a, b, c)\n-#else\n-# define GENERATE_C1_NONSTATIC_VM_STRUCT_ENTRY(a, b, c)\n-# define CHECK_C1_NONSTATIC_VM_STRUCT_ENTRY(a, b, c)\n-# define ENSURE_C1_FIELD_TYPE_PRESENT(a, b, c)\n-#endif \/* COMPILER1 *\/\n-\/\/ Generate and check a nonstatic field in C2 builds\n-#ifdef COMPILER2\n-# define GENERATE_C2_NONSTATIC_VM_STRUCT_ENTRY(a, b, c) GENERATE_NONSTATIC_VM_STRUCT_ENTRY(a, b, c)\n-# define CHECK_C2_NONSTATIC_VM_STRUCT_ENTRY(a, b, c)    CHECK_NONSTATIC_VM_STRUCT_ENTRY(a, b, c)\n-# define ENSURE_C2_FIELD_TYPE_PRESENT(a, b, c)          ENSURE_FIELD_TYPE_PRESENT(a, b, c)\n-#else\n-# define GENERATE_C2_NONSTATIC_VM_STRUCT_ENTRY(a, b, c)\n-# define CHECK_C2_NONSTATIC_VM_STRUCT_ENTRY(a, b, c)\n-# define ENSURE_C2_FIELD_TYPE_PRESENT(a, b, c)\n-#endif \/* COMPILER2 *\/\n-\n-\/\/ Generate but do not check a static field in C1 builds\n-#ifdef COMPILER1\n-# define GENERATE_C1_UNCHECKED_STATIC_VM_STRUCT_ENTRY(a, b, c) GENERATE_UNCHECKED_STATIC_VM_STRUCT_ENTRY(a, b, c)\n-#else\n-# define GENERATE_C1_UNCHECKED_STATIC_VM_STRUCT_ENTRY(a, b, c)\n-#endif \/* COMPILER1 *\/\n-\n-\/\/ Generate but do not check a static field in C2 builds\n-#ifdef COMPILER2\n-# define GENERATE_C2_UNCHECKED_STATIC_VM_STRUCT_ENTRY(a, b, c) GENERATE_UNCHECKED_STATIC_VM_STRUCT_ENTRY(a, b, c)\n-#else\n-# define GENERATE_C2_UNCHECKED_STATIC_VM_STRUCT_ENTRY(a, b, c)\n-#endif \/* COMPILER2 *\/\n-\n-\/\/--------------------------------------------------------------------------------\n-\/\/ VMTypeEntry build-specific macros\n-\/\/\n-\n-#ifdef COMPILER1\n-# define GENERATE_C1_TOPLEVEL_VM_TYPE_ENTRY(a)               GENERATE_TOPLEVEL_VM_TYPE_ENTRY(a)\n-# define CHECK_C1_TOPLEVEL_VM_TYPE_ENTRY(a)\n-#else\n-# define GENERATE_C1_TOPLEVEL_VM_TYPE_ENTRY(a)\n-# define CHECK_C1_TOPLEVEL_VM_TYPE_ENTRY(a)\n-#endif \/* COMPILER1 *\/\n-\n-#ifdef COMPILER2\n-# define GENERATE_C2_VM_TYPE_ENTRY(a, b)                     GENERATE_VM_TYPE_ENTRY(a, b)\n-# define CHECK_C2_VM_TYPE_ENTRY(a, b)                        CHECK_VM_TYPE_ENTRY(a, b)\n-# define GENERATE_C2_TOPLEVEL_VM_TYPE_ENTRY(a)               GENERATE_TOPLEVEL_VM_TYPE_ENTRY(a)\n-# define CHECK_C2_TOPLEVEL_VM_TYPE_ENTRY(a)\n-#else\n-# define GENERATE_C2_VM_TYPE_ENTRY(a, b)\n-# define CHECK_C2_VM_TYPE_ENTRY(a, b)\n-# define GENERATE_C2_TOPLEVEL_VM_TYPE_ENTRY(a)\n-# define CHECK_C2_TOPLEVEL_VM_TYPE_ENTRY(a)\n-#endif \/* COMPILER2 *\/\n-\n-\n-\/\/--------------------------------------------------------------------------------\n-\/\/ VMIntConstantEntry build-specific macros\n-\/\/\n-\n-\/\/ Generate an int constant for a C1 build\n-#ifdef COMPILER1\n-# define GENERATE_C1_VM_INT_CONSTANT_ENTRY(name)  GENERATE_VM_INT_CONSTANT_ENTRY(name)\n-#else\n-# define GENERATE_C1_VM_INT_CONSTANT_ENTRY(name)\n-#endif \/* COMPILER1 *\/\n-\n-\/\/ Generate an int constant for a C2 build\n-#ifdef COMPILER2\n-# define GENERATE_C2_VM_INT_CONSTANT_ENTRY(name)                      GENERATE_VM_INT_CONSTANT_ENTRY(name)\n-# define GENERATE_C2_PREPROCESSOR_VM_INT_CONSTANT_ENTRY(name, value)  GENERATE_PREPROCESSOR_VM_INT_CONSTANT_ENTRY(name, value)\n-#else\n-# define GENERATE_C2_VM_INT_CONSTANT_ENTRY(name)\n-# define GENERATE_C2_PREPROCESSOR_VM_INT_CONSTANT_ENTRY(name, value)\n-#endif \/* COMPILER1 *\/\n-\n-\n-\/\/--------------------------------------------------------------------------------\n-\/\/ VMLongConstantEntry build-specific macros\n-\/\/\n-\n-\/\/ Generate a long constant for a C1 build\n-#ifdef COMPILER1\n-# define GENERATE_C1_VM_LONG_CONSTANT_ENTRY(name)  GENERATE_VM_LONG_CONSTANT_ENTRY(name)\n-#else\n-# define GENERATE_C1_VM_LONG_CONSTANT_ENTRY(name)\n-#endif \/* COMPILER1 *\/\n-\n-\/\/ Generate a long constant for a C2 build\n-#ifdef COMPILER2\n-# define GENERATE_C2_VM_LONG_CONSTANT_ENTRY(name)                     GENERATE_VM_LONG_CONSTANT_ENTRY(name)\n-# define GENERATE_C2_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY(name, value) GENERATE_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY(name, value)\n-#else\n-# define GENERATE_C2_VM_LONG_CONSTANT_ENTRY(name)\n-# define GENERATE_C2_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY(name, value)\n-#endif \/* COMPILER1 *\/\n-\n-\n@@ -2681,5 +1885,1 @@\n-             GENERATE_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY,\n-             GENERATE_C1_NONSTATIC_VM_STRUCT_ENTRY,\n-             GENERATE_C2_NONSTATIC_VM_STRUCT_ENTRY,\n-             GENERATE_C1_UNCHECKED_STATIC_VM_STRUCT_ENTRY,\n-             GENERATE_C2_UNCHECKED_STATIC_VM_STRUCT_ENTRY)\n+             GENERATE_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY)\n@@ -2692,4 +1892,1 @@\n-                GENERATE_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY,\n-                GENERATE_C2_NONSTATIC_VM_STRUCT_ENTRY,\n-                GENERATE_C1_UNCHECKED_STATIC_VM_STRUCT_ENTRY,\n-                GENERATE_C2_UNCHECKED_STATIC_VM_STRUCT_ENTRY)\n+                GENERATE_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY)\n@@ -2701,13 +1898,1 @@\n-                 GENERATE_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY,\n-                 GENERATE_C2_NONSTATIC_VM_STRUCT_ENTRY,\n-                 GENERATE_C1_UNCHECKED_STATIC_VM_STRUCT_ENTRY,\n-                 GENERATE_C2_UNCHECKED_STATIC_VM_STRUCT_ENTRY)\n-\n-  VM_STRUCTS_OS_CPU(GENERATE_NONSTATIC_VM_STRUCT_ENTRY,\n-                    GENERATE_STATIC_VM_STRUCT_ENTRY,\n-                    GENERATE_UNCHECKED_NONSTATIC_VM_STRUCT_ENTRY,\n-                    GENERATE_NONSTATIC_VM_STRUCT_ENTRY,\n-                    GENERATE_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY,\n-                    GENERATE_C2_NONSTATIC_VM_STRUCT_ENTRY,\n-                    GENERATE_C1_UNCHECKED_STATIC_VM_STRUCT_ENTRY,\n-                    GENERATE_C2_UNCHECKED_STATIC_VM_STRUCT_ENTRY)\n+                 GENERATE_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY)\n@@ -2728,5 +1913,1 @@\n-           GENERATE_UNSIGNED_INTEGER_VM_TYPE_ENTRY,\n-           GENERATE_C1_TOPLEVEL_VM_TYPE_ENTRY,\n-           GENERATE_C2_VM_TYPE_ENTRY,\n-           GENERATE_C2_TOPLEVEL_VM_TYPE_ENTRY)\n-\n+           GENERATE_UNSIGNED_INTEGER_VM_TYPE_ENTRY)\n@@ -2738,4 +1919,1 @@\n-              GENERATE_UNSIGNED_INTEGER_VM_TYPE_ENTRY,\n-              GENERATE_C1_TOPLEVEL_VM_TYPE_ENTRY,\n-              GENERATE_C2_VM_TYPE_ENTRY,\n-              GENERATE_C2_TOPLEVEL_VM_TYPE_ENTRY)\n+              GENERATE_UNSIGNED_INTEGER_VM_TYPE_ENTRY)\n@@ -2747,13 +1925,1 @@\n-               GENERATE_UNSIGNED_INTEGER_VM_TYPE_ENTRY,\n-               GENERATE_C1_TOPLEVEL_VM_TYPE_ENTRY,\n-               GENERATE_C2_VM_TYPE_ENTRY,\n-               GENERATE_C2_TOPLEVEL_VM_TYPE_ENTRY)\n-\n-  VM_TYPES_OS_CPU(GENERATE_VM_TYPE_ENTRY,\n-                  GENERATE_TOPLEVEL_VM_TYPE_ENTRY,\n-                  GENERATE_OOP_VM_TYPE_ENTRY,\n-                  GENERATE_INTEGER_VM_TYPE_ENTRY,\n-                  GENERATE_UNSIGNED_INTEGER_VM_TYPE_ENTRY,\n-                  GENERATE_C1_TOPLEVEL_VM_TYPE_ENTRY,\n-                  GENERATE_C2_VM_TYPE_ENTRY,\n-                  GENERATE_C2_TOPLEVEL_VM_TYPE_ENTRY)\n+               GENERATE_UNSIGNED_INTEGER_VM_TYPE_ENTRY)\n@@ -2772,4 +1938,1 @@\n-                   GENERATE_PREPROCESSOR_VM_INT_CONSTANT_ENTRY,\n-                   GENERATE_C1_VM_INT_CONSTANT_ENTRY,\n-                   GENERATE_C2_VM_INT_CONSTANT_ENTRY,\n-                   GENERATE_C2_PREPROCESSOR_VM_INT_CONSTANT_ENTRY)\n+                   GENERATE_PREPROCESSOR_VM_INT_CONSTANT_ENTRY)\n@@ -2778,4 +1941,1 @@\n-                      GENERATE_PREPROCESSOR_VM_INT_CONSTANT_ENTRY,\n-                      GENERATE_C1_VM_INT_CONSTANT_ENTRY,\n-                      GENERATE_C2_VM_INT_CONSTANT_ENTRY,\n-                      GENERATE_C2_PREPROCESSOR_VM_INT_CONSTANT_ENTRY)\n+                      GENERATE_PREPROCESSOR_VM_INT_CONSTANT_ENTRY)\n@@ -2784,4 +1944,1 @@\n-                       GENERATE_PREPROCESSOR_VM_INT_CONSTANT_ENTRY,\n-                       GENERATE_C1_VM_INT_CONSTANT_ENTRY,\n-                       GENERATE_C2_VM_INT_CONSTANT_ENTRY,\n-                       GENERATE_C2_PREPROCESSOR_VM_INT_CONSTANT_ENTRY)\n+                       GENERATE_PREPROCESSOR_VM_INT_CONSTANT_ENTRY)\n@@ -2789,5 +1946,0 @@\n-  VM_INT_CONSTANTS_OS_CPU(GENERATE_VM_INT_CONSTANT_ENTRY,\n-                          GENERATE_PREPROCESSOR_VM_INT_CONSTANT_ENTRY,\n-                          GENERATE_C1_VM_INT_CONSTANT_ENTRY,\n-                          GENERATE_C2_VM_INT_CONSTANT_ENTRY,\n-                          GENERATE_C2_PREPROCESSOR_VM_INT_CONSTANT_ENTRY)\n@@ -2808,4 +1960,1 @@\n-                    GENERATE_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY,\n-                    GENERATE_C1_VM_LONG_CONSTANT_ENTRY,\n-                    GENERATE_C2_VM_LONG_CONSTANT_ENTRY,\n-                    GENERATE_C2_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY)\n+                    GENERATE_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY)\n@@ -2814,4 +1963,1 @@\n-                       GENERATE_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY,\n-                       GENERATE_C1_VM_LONG_CONSTANT_ENTRY,\n-                       GENERATE_C2_VM_LONG_CONSTANT_ENTRY,\n-                       GENERATE_C2_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY)\n+                       GENERATE_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY)\n@@ -2820,4 +1966,1 @@\n-                        GENERATE_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY,\n-                        GENERATE_C1_VM_LONG_CONSTANT_ENTRY,\n-                        GENERATE_C2_VM_LONG_CONSTANT_ENTRY,\n-                        GENERATE_C2_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY)\n+                        GENERATE_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY)\n@@ -2825,5 +1968,0 @@\n-  VM_LONG_CONSTANTS_OS_CPU(GENERATE_VM_LONG_CONSTANT_ENTRY,\n-                           GENERATE_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY,\n-                           GENERATE_C1_VM_LONG_CONSTANT_ENTRY,\n-                           GENERATE_C2_VM_LONG_CONSTANT_ENTRY,\n-                           GENERATE_C2_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY)\n@@ -2883,6 +2021,1 @@\n-             CHECK_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY,\n-             CHECK_C1_NONSTATIC_VM_STRUCT_ENTRY,\n-             CHECK_C2_NONSTATIC_VM_STRUCT_ENTRY,\n-             CHECK_NO_OP,\n-             CHECK_NO_OP);\n-\n+             CHECK_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY)\n@@ -2894,13 +2027,1 @@\n-                 CHECK_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY,\n-                 CHECK_C2_NONSTATIC_VM_STRUCT_ENTRY,\n-                 CHECK_NO_OP,\n-                 CHECK_NO_OP);\n-\n-  VM_STRUCTS_OS_CPU(CHECK_NONSTATIC_VM_STRUCT_ENTRY,\n-                    CHECK_STATIC_VM_STRUCT_ENTRY,\n-                    CHECK_NO_OP,\n-                    CHECK_VOLATILE_NONSTATIC_VM_STRUCT_ENTRY,\n-                    CHECK_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY,\n-                    CHECK_C2_NONSTATIC_VM_STRUCT_ENTRY,\n-                    CHECK_NO_OP,\n-                    CHECK_NO_OP);\n+                 CHECK_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY)\n@@ -2912,4 +2033,1 @@\n-           CHECK_SINGLE_ARG_VM_TYPE_NO_OP,\n-           CHECK_C1_TOPLEVEL_VM_TYPE_ENTRY,\n-           CHECK_C2_VM_TYPE_ENTRY,\n-           CHECK_C2_TOPLEVEL_VM_TYPE_ENTRY);\n+           CHECK_SINGLE_ARG_VM_TYPE_NO_OP)\n@@ -2922,13 +2040,1 @@\n-               CHECK_SINGLE_ARG_VM_TYPE_NO_OP,\n-               CHECK_C1_TOPLEVEL_VM_TYPE_ENTRY,\n-               CHECK_C2_VM_TYPE_ENTRY,\n-               CHECK_C2_TOPLEVEL_VM_TYPE_ENTRY);\n-\n-  VM_TYPES_OS_CPU(CHECK_VM_TYPE_ENTRY,\n-                  CHECK_SINGLE_ARG_VM_TYPE_NO_OP,\n-                  CHECK_SINGLE_ARG_VM_TYPE_NO_OP,\n-                  CHECK_SINGLE_ARG_VM_TYPE_NO_OP,\n-                  CHECK_SINGLE_ARG_VM_TYPE_NO_OP,\n-                  CHECK_C1_TOPLEVEL_VM_TYPE_ENTRY,\n-                  CHECK_C2_VM_TYPE_ENTRY,\n-                  CHECK_C2_TOPLEVEL_VM_TYPE_ENTRY);\n+               CHECK_SINGLE_ARG_VM_TYPE_NO_OP)\n@@ -2958,5 +2064,1 @@\n-             CHECK_NO_OP,\n-             CHECK_NO_OP,\n-             CHECK_NO_OP,\n-             CHECK_NO_OP,\n-             CHECK_NO_OP);\n+             CHECK_NO_OP)\n@@ -2969,5 +2071,1 @@\n-             ENSURE_NONPRODUCT_FIELD_TYPE_PRESENT,\n-             ENSURE_C1_FIELD_TYPE_PRESENT,\n-             ENSURE_C2_FIELD_TYPE_PRESENT,\n-             CHECK_NO_OP,\n-             CHECK_NO_OP);\n+             ENSURE_NONPRODUCT_FIELD_TYPE_PRESENT)\n@@ -2979,12 +2077,1 @@\n-                 ENSURE_NONPRODUCT_FIELD_TYPE_PRESENT,\n-                 ENSURE_C2_FIELD_TYPE_PRESENT,\n-                 CHECK_NO_OP,\n-                 CHECK_NO_OP);\n-  VM_STRUCTS_OS_CPU(ENSURE_FIELD_TYPE_PRESENT,\n-                    ENSURE_FIELD_TYPE_PRESENT,\n-                    CHECK_NO_OP,\n-                    ENSURE_FIELD_TYPE_PRESENT,\n-                    ENSURE_NONPRODUCT_FIELD_TYPE_PRESENT,\n-                    ENSURE_C2_FIELD_TYPE_PRESENT,\n-                    CHECK_NO_OP,\n-                    CHECK_NO_OP);\n+                 ENSURE_NONPRODUCT_FIELD_TYPE_PRESENT)\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":53,"deletions":966,"binary":false,"changes":1019,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -979,80 +979,0 @@\n-\n-  public void dumpReplayData(PrintStream out) {\n-    ConstantPool cp = getConstants();\n-\n-    \/\/ Try to record related loaded classes\n-    Klass sub = getSubklassKlass();\n-    while (sub != null) {\n-        if (sub instanceof InstanceKlass) {\n-            out.println(\"instanceKlass \" + sub.getName().asString());\n-        }\n-        sub = sub.getNextSiblingKlass();\n-    }\n-\n-    final int length = cp.getLength();\n-    out.print(\"ciInstanceKlass \" + getName().asString() + \" \" + (isLinked() ? 1 : 0) + \" \" + (isInitialized() ? 1 : 0) + \" \" + length);\n-    for (int index = 1; index < length; index++) {\n-      out.print(\" \" + cp.getTags().at(index));\n-    }\n-    out.println();\n-    if (isInitialized()) {\n-      Field[] staticFields = getStaticFields();\n-      for (int i = 0; i < staticFields.length; i++) {\n-        Field f = staticFields[i];\n-        Oop mirror = getJavaMirror();\n-        if (f.isFinal() && !f.hasInitialValue()) {\n-          out.print(\"staticfield \" + getName().asString() + \" \" +\n-                    OopUtilities.escapeString(f.getID().getName()) + \" \" +\n-                    f.getFieldType().getSignature().asString() + \" \");\n-          if (f instanceof ByteField) {\n-            ByteField bf = (ByteField)f;\n-            out.println(bf.getValue(mirror));\n-          } else if (f instanceof BooleanField) {\n-            BooleanField bf = (BooleanField)f;\n-            out.println(bf.getValue(mirror) ? 1 : 0);\n-          } else if (f instanceof ShortField) {\n-            ShortField bf = (ShortField)f;\n-            out.println(bf.getValue(mirror));\n-          } else if (f instanceof CharField) {\n-            CharField bf = (CharField)f;\n-            out.println(bf.getValue(mirror) & 0xffff);\n-          } else if (f instanceof IntField) {\n-            IntField bf = (IntField)f;\n-            out.println(bf.getValue(mirror));\n-          } else  if (f instanceof LongField) {\n-            LongField bf = (LongField)f;\n-            out.println(bf.getValue(mirror));\n-          } else if (f instanceof FloatField) {\n-            FloatField bf = (FloatField)f;\n-            out.println(Float.floatToRawIntBits(bf.getValue(mirror)));\n-          } else if (f instanceof DoubleField) {\n-            DoubleField bf = (DoubleField)f;\n-            out.println(Double.doubleToRawLongBits(bf.getValue(mirror)));\n-          } else if (f instanceof OopField) {\n-            OopField bf = (OopField)f;\n-\n-            Oop value = bf.getValue(mirror);\n-            if (value == null) {\n-              out.println(\"null\");\n-            } else if (value.isInstance()) {\n-              Instance inst = (Instance)value;\n-              if (inst.isA(SystemDictionary.getStringKlass())) {\n-                out.println(\"\\\"\" + OopUtilities.stringOopToEscapedString(inst) + \"\\\"\");\n-              } else {\n-                out.println(inst.getKlass().getName().asString());\n-              }\n-            } else if (value.isObjArray()) {\n-              ObjArray oa = (ObjArray)value;\n-              Klass ek = (ObjArrayKlass)oa.getKlass();\n-              out.println(oa.getLength() + \" \" + ek.getName().asString());\n-            } else if (value.isTypeArray()) {\n-              TypeArray ta = (TypeArray)value;\n-              out.println(ta.getLength());\n-            } else {\n-              out.println(value);\n-            }\n-          }\n-        }\n-      }\n-    }\n-  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/InstanceKlass.java","additions":1,"deletions":81,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\"})\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"ppc\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestCastX2NotProcessedIGVN.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -180,1 +180,1 @@\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -191,1 +191,1 @@\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -201,1 +201,1 @@\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -221,1 +221,1 @@\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -233,1 +233,1 @@\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -250,1 +250,1 @@\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -262,1 +262,1 @@\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -279,1 +279,1 @@\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -293,1 +293,1 @@\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -313,1 +313,1 @@\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -325,1 +325,1 @@\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -343,1 +343,1 @@\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -355,1 +355,1 @@\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -372,1 +372,1 @@\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -384,1 +384,1 @@\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizationMismatchedAccess.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizationNotRun.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -411,1 +411,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -427,1 +427,1 @@\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -449,1 +449,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -453,1 +453,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -473,1 +473,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -477,1 +477,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -501,1 +501,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -509,1 +509,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -538,1 +538,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -542,1 +542,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -564,1 +564,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -568,1 +568,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -590,1 +590,1 @@\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -594,1 +594,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -616,1 +616,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -620,1 +620,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -642,1 +642,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -660,1 +660,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -666,1 +666,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -684,1 +684,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -690,1 +690,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -709,1 +709,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -715,1 +715,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -736,1 +736,1 @@\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -753,1 +753,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -767,1 +767,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -781,1 +781,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -795,1 +795,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -809,1 +809,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -823,1 +823,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -837,1 +837,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -851,1 +851,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -864,1 +864,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -870,1 +870,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -885,1 +885,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -891,1 +891,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -906,1 +906,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -912,1 +912,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -928,1 +928,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -942,1 +942,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -955,1 +955,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -968,1 +968,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -981,1 +981,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -995,1 +995,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -1014,1 +1014,1 @@\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"rvv\", \"true\"})\n@@ -1030,1 +1030,1 @@\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -1046,1 +1046,1 @@\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -1066,1 +1066,1 @@\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -1085,1 +1085,1 @@\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"rvv\", \"true\"})\n@@ -1101,1 +1101,1 @@\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -1117,1 +1117,1 @@\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -1137,1 +1137,1 @@\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -1153,1 +1153,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -1159,1 +1159,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -1192,1 +1192,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -1198,1 +1198,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -1231,1 +1231,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -1237,1 +1237,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -1270,1 +1270,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -1276,1 +1276,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -1298,1 +1298,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -1304,1 +1304,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -1326,1 +1326,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -1332,1 +1332,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -1481,1 +1481,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -1510,1 +1510,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -1527,1 +1527,1 @@\n-        applyIfCPUFeatureOr = {\"avx512\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx512\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n@@ -1538,1 +1538,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAlignVector.java","additions":68,"deletions":68,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -158,1 +158,1 @@\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -182,1 +182,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -207,1 +207,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -284,1 +284,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestIndependentPacksWithCyclicDependency.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -283,1 +283,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -318,1 +318,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -341,1 +341,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -364,1 +364,1 @@\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -387,1 +387,1 @@\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -410,1 +410,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -447,1 +447,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -484,1 +484,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -521,1 +521,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -555,1 +555,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -626,1 +626,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -640,1 +640,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -654,1 +654,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -668,1 +668,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -682,1 +682,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -745,1 +745,1 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -768,1 +768,1 @@\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\", \"rvv\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestSplitPacks.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"rvv\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestUnorderedReductionPartialVectorization.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"},\n@@ -202,1 +202,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"},\n@@ -213,1 +213,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx512dq\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx512dq\", \"true\", \"rvv\", \"true\"},\n@@ -224,1 +224,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx512dq\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx512dq\", \"true\", \"rvv\", \"true\"},\n@@ -236,1 +236,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"},\n@@ -247,1 +247,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"},\n@@ -286,1 +286,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"},\n@@ -297,1 +297,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx512dq\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx512dq\", \"true\", \"rvv\", \"true\"},\n@@ -308,1 +308,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"},\n@@ -319,1 +319,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx512dq\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx512dq\", \"true\", \"rvv\", \"true\"},\n@@ -331,1 +331,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"},\n@@ -342,1 +342,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"},\n@@ -353,1 +353,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"},\n@@ -365,1 +365,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"},\n@@ -378,1 +378,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"},\n@@ -389,1 +389,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayTypeConvertTest.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\", \"rvv\", \"true\"},\n@@ -126,1 +126,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\", \"rvv\", \"true\"},\n@@ -138,1 +138,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\", \"rvv\", \"true\"},\n@@ -150,1 +150,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\", \"rvv\", \"true\"},\n@@ -162,1 +162,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\", \"rvv\", \"true\"},\n@@ -174,1 +174,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\", \"rvv\", \"true\"},\n@@ -193,1 +193,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\", \"rvv\", \"true\"},\n@@ -209,1 +209,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\", \"rvv\", \"true\"},\n@@ -224,1 +224,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\", \"rvv\", \"true\"},\n@@ -241,1 +241,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\", \"rvv\", \"true\"},\n@@ -256,1 +256,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\", \"rvv\", \"true\"},\n@@ -271,1 +271,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\", \"rvv\", \"true\"},\n@@ -286,1 +286,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\", \"rvv\", \"true\"},\n@@ -301,1 +301,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse3\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse3\", \"true\", \"rvv\", \"true\"},\n@@ -357,1 +357,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\", \"rvv\", \"true\"},\n@@ -369,1 +369,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\", \"rvv\", \"true\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopCombinedOpTest.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,7 +151,0 @@\n-                    String pattern = \"((Too small maximum heap)\" +\n-                                     \"|(GC triggered before VM initialization completed)\" +\n-                                     \"|(CDS archive has aot-linked classes but the archived heap objects cannot be loaded)\" +\n-                                     \"|(Initial heap size set to a larger value than the maximum heap size)\" +\n-                                     \"|(java.lang.OutOfMemoryError)\" +\n-                                     \"|(Error: A JNI error has occurred, please check your installation and try again))\";\n-                    out.shouldMatch(pattern);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestParallelGCWithCDS.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"}]}