{"files":[{"patch":"@@ -1999,4 +1999,0 @@\n-  product(bool, OMDeflateAfterWait, false, \"Currently broken due to deflation changes\") \\\n-                                                                            \\\n-  product(bool, OMDeflateBeforeExit, false, \"Currently broken due to deflation changes\")\\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1170,3 +1170,0 @@\n-  size_t _wait_deflation = 0;\n-  size_t _exit_deflation = 0;\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -292,10 +292,0 @@\n-  if (_wait_deflation != 0 ||\n-      _exit_deflation != 0) {\n-    lt.print(\"Wait: %8zu Exit: %8zu Thread: %s\",\n-             _wait_deflation,\n-             _exit_deflation,\n-             name());\n-  }\n-  _wait_deflation = 0;\n-  _exit_deflation = 0;\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.inline.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -636,2 +636,0 @@\n-  bool first_try = true;\n-\n@@ -655,1 +653,0 @@\n-retry:\n@@ -679,11 +676,0 @@\n-  if (OMDeflateBeforeExit && first_try && monitor->recursions() == 0) {\n-    \/\/ Only deflate if recursions are 0 or the lock stack may become\n-    \/\/ imbalanced.\n-    first_try = false;\n-    if (monitor->deflate_anon_monitor(current)) {\n-      mark = object->mark();\n-      current->_exit_deflation++;\n-      goto retry;\n-    }\n-  }\n-\n@@ -782,1 +768,0 @@\n-    locking_thread->lock_stack().set_wait_was_inflated();\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  bool _wait_was_inflated;\n@@ -131,4 +130,0 @@\n-  bool wait_was_inflated() const { return _wait_was_inflated; };\n-  void set_wait_was_inflated() { _wait_was_inflated = true; };\n-  void clear_wait_was_inflated() { _wait_was_inflated = false; };\n-\n","filename":"src\/hotspot\/share\/runtime\/lockStack.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -587,8 +587,0 @@\n-  if (LockingMode == LM_LIGHTWEIGHT && is_being_async_deflated()) {\n-    \/\/ TODO[OMWorld]: Batched deflation exiting early breaks this.\n-    \/\/ This happens when a locked monitor is deflated by a java thread\n-    \/\/ returning itself to fast_locked\n-    assert(is_owner_anonymous(), \"must stay anonymous when the java thread deflates\");\n-    return true;\n-  }\n-\n@@ -676,71 +668,0 @@\n-bool ObjectMonitor::deflate_anon_monitor(JavaThread* current) {\n-  assert(owner_raw() == current, \"must be\");\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-\n-  LockStack& lock_stack = current->lock_stack();\n-\n-  if (!lock_stack.can_push(1 + _recursions)) {\n-    \/\/ Will not be able to push the oop on the lock stack.\n-    return false;\n-  }\n-\n-  if (is_contended()) {\n-    \/\/ Easy checks are first - the ObjectMonitor is busy so no deflation.\n-    return false;\n-  }\n-\n-  \/\/ Make sure if a thread sees contentions() < 0 they also see owner == ANONYMOUS_OWNER\n-  set_owner_from(current, reinterpret_cast<void*>(ANONYMOUS_OWNER));\n-\n-    \/\/ Recheck after setting owner\n-  bool cleanup = is_contended();\n-\n-\n-  if (!cleanup) {\n-    \/\/ Make a zero contentions field negative to force any contending threads\n-    \/\/ to retry. Because this is only called while holding the lock, the owner\n-    \/\/ is anonymous and contentions is held over enter in inflate_and_enter\n-    \/\/ it means that if the cas succeeds then we can have no other thread\n-    \/\/ racily inserting themselves on the _waiters or _cxq lists, the\n-    \/\/ entry list is protected by the lock (_waiter technically too, only\n-    \/\/ removals are done outside the lock)\n-    \/\/ TODO: Double check _succ and _responsible invariants\n-    if (Atomic::cmpxchg(&_contentions, 0, INT_MIN) != 0) {\n-      \/\/ Contentions was no longer 0 so we lost the race.\n-      cleanup = true;\n-    }\n-  }\n-\n-  if (cleanup) {\n-    \/\/ Could not deflate\n-    set_owner_from_anonymous(current);\n-    return false;\n-  }\n-\n-  \/\/ Sanity checks for the races:\n-  guarantee(is_owner_anonymous(), \"must be\");\n-  guarantee(contentions() < 0, \"must be negative: contentions=%d\",\n-            contentions());\n-  guarantee(_waiters == 0, \"must be 0: waiters=%d\", _waiters);\n-  guarantee(_cxq == nullptr, \"must be no contending threads: cxq=\"\n-            INTPTR_FORMAT, p2i(_cxq));\n-  guarantee(_EntryList == nullptr,\n-            \"must be no entering threads: EntryList=\" INTPTR_FORMAT,\n-            p2i(_EntryList));\n-\n-  oop obj = object();\n-\n-  LightweightSynchronizer::deflate_anon_monitor(current, obj, this);\n-\n-  \/\/ We are deflated, restore the correct lock_stack\n-  lock_stack.push(obj);\n-  for (int i = 0; i < _recursions; i++) {\n-    bool entered = lock_stack.try_recursive_enter(obj);\n-    assert(entered, \"must have entered here\");\n-  }\n-\n-  \/\/ We leave owner == ANONYMOUS_OWNER and contentions < 0\n-  \/\/ to force any racing threads to retry.\n-  return true;  \/\/ Success, ObjectMonitor has been deflated.\n-}\n-\n@@ -1770,9 +1691,0 @@\n-  bool deflated = false;\n-\n-  if (LockingMode == LM_LIGHTWEIGHT && OMDeflateAfterWait && current->lock_stack().wait_was_inflated()) {\n-    if (deflate_anon_monitor(current)) {\n-      current->_wait_deflation++;\n-      deflated = true;\n-    }\n-  }\n-\n@@ -1780,1 +1692,1 @@\n-  assert(deflated || owner_raw() == current, \"invariant\");\n+  assert(owner_raw() == current, \"invariant\");\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":89,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -384,2 +384,0 @@\n-public:\n-  bool      deflate_anon_monitor(JavaThread* current);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -864,1 +864,0 @@\n-    current->lock_stack().clear_wait_was_inflated();\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}