{"files":[{"patch":"@@ -251,1 +251,2 @@\n-  assert(this == current(), \"only set own thread locals\");\n+  assert(this == current() || monitor->owner_raw() == this, \"only add owned monitors for other threads\");\n+  assert(this == current() || is_obj_deopt_suspend(), \"thread must not run concurrently\");\n","filename":"src\/hotspot\/share\/runtime\/javaThread.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -496,2 +496,3 @@\n-void LightweightSynchronizer::ensure_lock_stack_space(JavaThread* locking_thread, JavaThread* current) {\n-  LockStack& lock_stack = locking_thread->lock_stack();\n+void LightweightSynchronizer::ensure_lock_stack_space(JavaThread* current) {\n+  assert(current == JavaThread::current(), \"must be\");\n+  LockStack& lock_stack = current->lock_stack();\n@@ -502,1 +503,1 @@\n-    LockStackInflateContendedLocks().inflate(locking_thread, current);\n+    LockStackInflateContendedLocks().inflate(current, current);\n@@ -505,1 +506,1 @@\n-      inflate_fast_locked_object(lock_stack.bottom(), locking_thread, current, ObjectSynchronizer::inflate_cause_vm_internal);\n+      inflate_fast_locked_object(lock_stack.bottom(), current, current, ObjectSynchronizer::inflate_cause_vm_internal);\n@@ -533,4 +534,0 @@\n-  enter(obj, lock, locking_thread, JavaThread::current());\n-}\n-\n-void LightweightSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* locking_thread, JavaThread* current) {\n@@ -538,0 +535,1 @@\n+  JavaThread* current = JavaThread::current();\n@@ -540,0 +538,1 @@\n+  \/\/ TODO[OMWorld]: Is this necessary?\n@@ -541,1 +540,1 @@\n-    ObjectSynchronizer::handle_sync_on_value_based_class(obj, locking_thread);\n+    ObjectSynchronizer::handle_sync_on_value_based_class(obj, current);\n@@ -546,0 +545,31 @@\n+  lock->clear_displaced_header();\n+\n+  LockStack& lock_stack = locking_thread->lock_stack();\n+\n+  bool entered = false;\n+  if (lock_stack.contains(obj())) {\n+    ObjectMonitor* mon = inflate_fast_locked_object(obj(), locking_thread, current, ObjectSynchronizer::inflate_cause_monitor_enter);\n+    entered = mon->enter_for(locking_thread);\n+    locking_thread->om_set_monitor_cache(mon);\n+    lock->set_displaced_header(mon);\n+  } else {\n+    \/\/ It is assumed that enter_for must enter on an object without contention.\n+    \/\/ TODO[OMWorld]: We also assume that this re-lock is on either a new never\n+    \/\/                inflated monitor, or one that is already locked by the\n+    \/\/                locking_thread. Should we have this stricter restriction?\n+    entered = inflate_and_enter(obj(), lock, locking_thread, current, ObjectSynchronizer::inflate_cause_monitor_enter);\n+  }\n+\n+  assert(entered, \"LightweightSynchronizer::enter_for must succeed\");\n+}\n+\n+void LightweightSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  assert(current == JavaThread::current(), \"must be\");\n+\n+  if (obj->klass()->is_value_based()) {\n+    ObjectSynchronizer::handle_sync_on_value_based_class(obj, current);\n+  }\n+\n+  current->inc_held_monitor_count();\n+\n@@ -560,3 +590,1 @@\n-  LockStack& lock_stack = locking_thread->lock_stack();\n-\n-  \/\/ TODO[OMWorld]: Cleanup locking_thread != current\n+  LockStack& lock_stack = current->lock_stack();\n@@ -575,2 +603,1 @@\n-    ObjectMonitor* mon = inflate_fast_locked_object(obj(), locking_thread, current, ObjectSynchronizer::inflate_cause_monitor_enter);\n-    \/\/ TODO[OMWorld]: Cleanup enter_for\n+    ObjectMonitor* mon = inflate_fast_locked_object(obj(), current, current, ObjectSynchronizer::inflate_cause_monitor_enter);\n@@ -578,6 +605,2 @@\n-    if (locking_thread == current) {\n-      entered = mon->enter(locking_thread);\n-      locking_thread->om_set_monitor_cache(mon);\n-    } else {\n-      entered = mon->enter_for(locking_thread);\n-    }\n+    entered = mon->enter(current);\n+    current->om_set_monitor_cache(mon);\n@@ -602,1 +625,1 @@\n-        ensure_lock_stack_space(locking_thread, current);\n+        ensure_lock_stack_space(current);\n@@ -624,1 +647,1 @@\n-    if (inflate_and_enter(obj(), lock, locking_thread, current, ObjectSynchronizer::inflate_cause_monitor_enter)) {\n+    if (inflate_and_enter(obj(), lock, current, current, ObjectSynchronizer::inflate_cause_monitor_enter)) {\n@@ -818,2 +841,2 @@\n-  if (current == locking_thread && monitor->try_enter(locking_thread)) {\n-    current->om_set_monitor_cache(monitor);\n+  if (monitor->try_enter(locking_thread)) {\n+    locking_thread->om_set_monitor_cache(monitor);\n@@ -827,1 +850,1 @@\n-  ObjectMonitorContentionMark mark(monitor);\n+  ObjectMonitorContentionMark contention_mark(monitor);\n@@ -919,3 +942,3 @@\n-    if (current == locking_thread) {\n-      current->om_set_monitor_cache(monitor);\n-      current->_unlocked_inflation++;\n+    locking_thread->om_set_monitor_cache(monitor);\n+    if (lock != nullptr) {\n+      lock->set_displaced_header(monitor);\n@@ -923,0 +946,1 @@\n+    locking_thread->_unlocked_inflation++;\n@@ -927,2 +951,13 @@\n-  if (current == locking_thread && monitor->has_owner() && monitor->owner_raw() != locking_thread) {\n-    \/\/ Someone else owns the lock, take the time befor entering to fix the lock stack\n+  if (current == locking_thread) {\n+    \/\/ One round of spinning\n+    if (monitor->spin_enter(locking_thread)) {\n+      \/\/ Update the thread-local cache\n+      locking_thread->om_set_monitor_cache(monitor);\n+      if (lock != nullptr) {\n+        lock->set_displaced_header(monitor);\n+      }\n+\n+      return true;\n+    }\n+\n+    \/\/ Monitor is contended, take the time befor entering to fix the lock stack.\n@@ -936,9 +971,5 @@\n-  \/\/ TODO[OMWorld]: Fix this enter_for\n-  if ((current == locking_thread && monitor->enter(locking_thread)) || monitor->enter_for(locking_thread)) {\n-    \/\/ Update the thread-local cache\n-    if (current == locking_thread) {\n-      current->om_set_monitor_cache(monitor);\n-    }\n-    if (lock != nullptr) {\n-      lock->set_displaced_header(monitor);\n-    }\n+  if (current == locking_thread) {\n+    monitor->enter_with_contention_mark(locking_thread, contention_mark);\n+  } else {\n+    monitor->enter_for_with_contention_mark(locking_thread, contention_mark);\n+  }\n@@ -946,1 +977,4 @@\n-    return true;\n+  \/\/ Update the thread-local cache\n+  locking_thread->om_set_monitor_cache(monitor);\n+  if (lock != nullptr) {\n+    lock->set_displaced_header(monitor);\n@@ -949,1 +983,1 @@\n-  return false;\n+  return true;\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":75,"deletions":41,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  static void ensure_lock_stack_space(JavaThread* locking_thread, JavaThread* current);\n+  static void ensure_lock_stack_space(JavaThread* current);\n@@ -57,1 +57,1 @@\n-  static void enter(Handle obj, BasicLock* lock,  JavaThread* locking_thread, JavaThread* current);\n+  static void enter(Handle obj, BasicLock* lock, JavaThread* current);\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -320,6 +320,0 @@\n-bool ObjectMonitor::try_enter(JavaThread* current) {\n-  void* cur = try_set_owner_from(nullptr, current);\n-  if (cur == nullptr) {\n-    assert(_recursions == 0, \"invariant\");\n-    return true;\n-  }\n@@ -327,2 +321,10 @@\n-  if (cur == current) {\n-    _recursions++;\n+bool ObjectMonitor::enter_is_async_deflating() {\n+  if (is_being_async_deflated()) {\n+    if (LockingMode != LM_LIGHTWEIGHT) {\n+      const oop l_object = object();\n+      if (l_object != nullptr) {\n+        \/\/ Attempt to restore the header\/dmw to the object's header so that\n+        \/\/ we only retry once if the deflater thread happens to be slow.\n+        install_displaced_markword_in_object(l_object);\n+      }\n+    }\n@@ -335,1 +337,1 @@\n-bool ObjectMonitor::enter_for(JavaThread* locking_thread) {\n+void ObjectMonitor::enter_for_with_contention_mark(JavaThread* locking_thread, ObjectMonitorContentionMark& contention_mark) {\n@@ -340,0 +342,2 @@\n+  assert(contention_mark._monitor == this, \"must be\");\n+  assert(!is_being_async_deflated(), \"must be\");\n@@ -341,2 +345,2 @@\n-  \/\/ Block out deflation as soon as possible.\n-  add_to_contentions(1);\n+\n+  void* prev_owner = try_set_owner_from(nullptr, locking_thread);\n@@ -345,2 +349,0 @@\n-  if (!is_being_async_deflated()) {\n-    void* prev_owner = try_set_owner_from(nullptr, locking_thread);\n@@ -348,25 +350,12 @@\n-    if (prev_owner == nullptr) {\n-      assert(_recursions == 0, \"invariant\");\n-      success = true;\n-    } else if (prev_owner == locking_thread) {\n-      _recursions++;\n-      success = true;\n-    } else if (prev_owner == DEFLATER_MARKER) {\n-      \/\/ Racing with deflation.\n-      prev_owner = try_set_owner_from(DEFLATER_MARKER, locking_thread);\n-      if (prev_owner == DEFLATER_MARKER) {\n-        \/\/ Cancelled deflation. Increment contentions as part of the deflation protocol.\n-        add_to_contentions(1);\n-        success = true;\n-      } else if (prev_owner == nullptr) {\n-        \/\/ At this point we cannot race with deflation as we have both incremented\n-        \/\/ contentions, seen contention > 0 and seen a DEFLATER_MARKER.\n-        \/\/ success will only be false if this races with something other than\n-        \/\/ deflation.\n-        prev_owner = try_set_owner_from(nullptr, locking_thread);\n-        success = prev_owner == nullptr;\n-      }\n-    } else if (LockingMode == LM_LEGACY && locking_thread->is_lock_owned((address)prev_owner)) {\n-      assert(_recursions == 0, \"must be\");\n-      _recursions = 1;\n-      set_owner_from_BasicLock(prev_owner, locking_thread);\n+  if (prev_owner == nullptr) {\n+    assert(_recursions == 0, \"invariant\");\n+    success = true;\n+  } else if (prev_owner == locking_thread) {\n+    _recursions++;\n+    success = true;\n+  } else if (prev_owner == DEFLATER_MARKER) {\n+    \/\/ Racing with deflation.\n+    prev_owner = try_set_owner_from(DEFLATER_MARKER, locking_thread);\n+    if (prev_owner == DEFLATER_MARKER) {\n+      \/\/ Cancelled deflation. Increment contentions as part of the deflation protocol.\n+      add_to_contentions(1);\n@@ -374,0 +363,7 @@\n+    } else if (prev_owner == nullptr) {\n+      \/\/ At this point we cannot race with deflation as we have both incremented\n+      \/\/ contentions, seen contention > 0 and seen a DEFLATER_MARKER.\n+      \/\/ success will only be false if this races with something other than\n+      \/\/ deflation.\n+      prev_owner = try_set_owner_from(nullptr, locking_thread);\n+      success = prev_owner == nullptr;\n@@ -375,13 +371,5 @@\n-    assert(success, \"Failed to enter_for: locking_thread=\" INTPTR_FORMAT\n-           \", this=\" INTPTR_FORMAT \"{owner=\" INTPTR_FORMAT \"}, observed owner: \" INTPTR_FORMAT,\n-           p2i(locking_thread), p2i(this), p2i(owner_raw()), p2i(prev_owner));\n-  } else {\n-    \/\/ Async deflation is in progress and our contentions increment\n-    \/\/ above lost the race to async deflation. Undo the work and\n-    \/\/ force the caller to retry.\n-    const oop l_object = object();\n-    if (l_object != nullptr) {\n-      \/\/ Attempt to restore the header\/dmw to the object's header so that\n-      \/\/ we only retry once if the deflater thread happens to be slow.\n-      install_displaced_markword_in_object(l_object);\n-    }\n+  } else if (LockingMode == LM_LEGACY && locking_thread->is_lock_owned((address)prev_owner)) {\n+    assert(_recursions == 0, \"must be\");\n+    _recursions = 1;\n+    set_owner_from_BasicLock(prev_owner, locking_thread);\n+    success = true;\n@@ -389,0 +377,4 @@\n+  assert(success, \"Failed to enter_for: locking_thread=\" INTPTR_FORMAT\n+          \", this=\" INTPTR_FORMAT \"{owner=\" INTPTR_FORMAT \"}, observed owner: \" INTPTR_FORMAT,\n+          p2i(locking_thread), p2i(this), p2i(owner_raw()), p2i(prev_owner));\n+}\n@@ -390,1 +382,1 @@\n-  add_to_contentions(-1);\n+bool ObjectMonitor::enter_for(JavaThread* locking_thread) {\n@@ -392,1 +384,2 @@\n-  assert(!success || owner_raw() == locking_thread, \"must be\");\n+  \/\/ Block out deflation as soon as possible.\n+  ObjectMonitorContentionMark contention_mark(this);\n@@ -394,2 +387,4 @@\n-  return success;\n-}\n+  \/\/ Check for deflation.\n+  if (enter_is_async_deflating()) {\n+    return false;\n+  }\n@@ -397,4 +392,4 @@\n-bool ObjectMonitor::enter(JavaThread* current) {\n-  assert(current == JavaThread::current(), \"must be\");\n-  \/\/ The following code is ordered to check the most common cases first\n-  \/\/ and to reduce RTS->RTO cache line upgrades on SPARC and IA32 processors.\n+  enter_for_with_contention_mark(locking_thread, contention_mark);\n+  assert(owner_raw() == locking_thread, \"must be\");\n+  return true;\n+}\n@@ -402,0 +397,1 @@\n+bool ObjectMonitor::try_enter(JavaThread* current) {\n@@ -409,1 +405,0 @@\n-    \/\/ TODO-FIXME: check for integer overflow!  BUGID 6557169.\n@@ -421,0 +416,16 @@\n+  return false;\n+}\n+\n+bool ObjectMonitor::spin_enter(JavaThread* current) {\n+  assert(current == JavaThread::current(), \"must be\");\n+\n+  \/\/ Check for recursion.\n+  if (try_enter(current)) {\n+    return true;\n+  }\n+\n+  \/\/ Check for deflation.\n+  if (enter_is_async_deflating()) {\n+    return false;\n+  }\n+\n@@ -423,3 +434,1 @@\n-  \/\/ Try one round of spinning *before* enqueueing current\n-  \/\/ and before going through the awkward and expensive state\n-  \/\/ transitions.  The following spin is strictly optional ...\n+  \/\/ Do one round of spinning.\n@@ -435,0 +444,10 @@\n+  return false;\n+}\n+\n+bool ObjectMonitor::enter(JavaThread* current) {\n+  assert(current == JavaThread::current(), \"must be\");\n+\n+  if (spin_enter(current)) {\n+    return true;\n+  }\n+\n@@ -440,13 +459,5 @@\n-  \/\/ Keep track of contention for JVM\/TI and M&M queries.\n-  add_to_contentions(1);\n-  if (is_being_async_deflated()) {\n-    \/\/ Async deflation is in progress and our contentions increment\n-    \/\/ above lost the race to async deflation. Undo the work and\n-    \/\/ force the caller to retry.\n-    const oop l_object = object();\n-    if (LockingMode != LM_LIGHTWEIGHT && l_object != nullptr) {\n-      \/\/ Attempt to restore the header\/dmw to the object's header so that\n-      \/\/ we only retry once if the deflater thread happens to be slow.\n-      install_displaced_markword_in_object(l_object);\n-    }\n-    add_to_contentions(-1);\n+  \/\/ Keep is_being_async_deflated stable across the rest of enter\n+  ObjectMonitorContentionMark contention_mark(this);\n+\n+  \/\/ Check for deflation.\n+  if (enter_is_async_deflating()) {\n@@ -456,0 +467,11 @@\n+  \/\/ At this point this ObjectMonitor cannot be deflated, finish contended enter\n+  enter_with_contention_mark(current, contention_mark);\n+  return true;\n+}\n+\n+void ObjectMonitor::enter_with_contention_mark(JavaThread *current, ObjectMonitorContentionMark &cm) {\n+  assert(current == JavaThread::current(), \"must be\");\n+  assert(owner_raw() != current, \"must be\");\n+  assert(cm._monitor == this, \"must be\");\n+  assert(!is_being_async_deflated(), \"must be\");\n+\n@@ -512,1 +534,0 @@\n-  add_to_contentions(-1);\n@@ -548,1 +569,0 @@\n-  return true;\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":98,"deletions":78,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+class ObjectMonitorContentionMark;\n@@ -352,0 +353,2 @@\n+\n+  bool      enter_is_async_deflating();\n@@ -353,1 +356,1 @@\n-  bool      try_enter(JavaThread* current);\n+  void      enter_for_with_contention_mark(JavaThread* locking_thread, ObjectMonitorContentionMark& contention_mark);\n@@ -356,0 +359,3 @@\n+  bool      try_enter(JavaThread* current);\n+  bool      spin_enter(JavaThread* current);\n+  void      enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark& contention_mark);\n@@ -392,1 +398,3 @@\n-class ObjectMonitorContentionMark {\n+class ObjectMonitorContentionMark : StackObj {\n+  DEBUG_ONLY(friend class ObjectMonitor;)\n+\n@@ -395,0 +403,2 @@\n+  NONCOPYABLE(ObjectMonitorContentionMark);\n+\n@@ -396,1 +406,1 @@\n-  ObjectMonitorContentionMark(ObjectMonitor* monitor);\n+  explicit ObjectMonitorContentionMark(ObjectMonitor* monitor);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -577,1 +577,1 @@\n-    return LightweightSynchronizer::enter(obj, lock, current, current);\n+    return LightweightSynchronizer::enter(obj, lock, current);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}