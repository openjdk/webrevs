{"files":[{"patch":"@@ -2518,4 +2518,1 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tagged_monitor = mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-    const Register owner_addr = tmp2;\n+    \/\/ OMCache lookup not supported yet. Take slowpath.\n@@ -2523,21 +2520,3 @@\n-    \/\/ Compute owner address.\n-    addi(owner_addr, tagged_monitor, in_bytes(ObjectMonitor::owner_offset()) - monitor_tag);\n-\n-    \/\/ CAS owner (null => current thread).\n-    cmpxchgd(\/*flag=*\/flag,\n-            \/*current_value=*\/t,\n-            \/*compare_value=*\/(intptr_t)0,\n-            \/*exchange_value=*\/R16_thread,\n-            \/*where=*\/owner_addr,\n-            MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-            MacroAssembler::cmpxchgx_hint_acquire_lock());\n-    beq(flag, locked);\n-\n-    \/\/ Check if recursive.\n-    cmpd(flag, t, R16_thread);\n-    bne(flag, slow_path);\n-\n-    \/\/ Recursive.\n-    ld(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n-    addi(tmp1, tmp1, 1);\n-    std(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n+    \/\/ Set flag to NE.\n+    crxor(flag, Assembler::equal, flag, Assembler::equal);\n+    b(slow_path);\n@@ -2657,9 +2636,1 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register monitor = mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-\n-    \/\/ Untag the monitor.\n-    subi(monitor, mark, monitor_tag);\n-\n-    const Register recursions = tmp2;\n-    Label not_recursive;\n+    \/\/ OMCache lookup not supported yet. Take slowpath.\n@@ -2667,26 +2638,2 @@\n-    \/\/ Check if recursive.\n-    ld(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n-    addic_(recursions, recursions, -1);\n-    blt(CCR0, not_recursive);\n-\n-    \/\/ Recursive unlock.\n-    std(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n-    crorc(CCR0, Assembler::equal, CCR0, Assembler::equal);\n-    b(unlocked);\n-\n-    bind(not_recursive);\n-\n-    Label release_;\n-    const Register t2 = tmp2;\n-\n-    \/\/ Check if the entry lists are empty.\n-    ld(t, in_bytes(ObjectMonitor::EntryList_offset()), monitor);\n-    ld(t2, in_bytes(ObjectMonitor::cxq_offset()), monitor);\n-    orr(t, t, t2);\n-    cmpdi(flag, t, 0);\n-    beq(flag, release_);\n-\n-    \/\/ The owner may be anonymous and we removed the last obj entry in\n-    \/\/ the lock-stack. This loses the information about the owner.\n-    \/\/ Write the thread to the owner field so the runtime knows the owner.\n-    std(R16_thread, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+    \/\/ Set flag to NE.\n+    crxor(flag, Assembler::equal, flag, Assembler::equal);\n@@ -2694,6 +2641,0 @@\n-\n-    bind(release_);\n-    \/\/ Set owner to null.\n-    release();\n-    \/\/ t contains 0\n-    std(t, in_bytes(ObjectMonitor::owner_offset()), monitor);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":7,"deletions":66,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -325,20 +325,2 @@\n-\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tmp1_tagged_monitor = tmp1_mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-    const Register tmp2_owner_addr = tmp2;\n-    const Register tmp3_owner = tmp3;\n-\n-    \/\/ Compute owner address.\n-    la(tmp2_owner_addr, Address(tmp1_tagged_monitor, (in_bytes(ObjectMonitor::owner_offset()) - monitor_tag)));\n-\n-    \/\/ CAS owner (null => current thread).\n-    cmpxchg(\/*addr*\/ tmp2_owner_addr, \/*expected*\/ zr, \/*new*\/ xthread, Assembler::int64,\n-            \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::relaxed, \/*result*\/ tmp3_owner);\n-    beqz(tmp3_owner, locked);\n-\n-    \/\/ Check if recursive.\n-    bne(tmp3_owner, xthread, slow_path);\n-\n-    \/\/ Recursive.\n-    increment(Address(tmp1_tagged_monitor, in_bytes(ObjectMonitor::recursions_offset()) - monitor_tag), 1, tmp2, tmp3);\n+    \/\/ OMCache lookup not supported yet. Take slowpath.\n+    j(slow_path);\n@@ -456,37 +438,1 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tmp1_monitor = tmp1_mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-\n-    \/\/ Untag the monitor.\n-    sub(tmp1_monitor, tmp1_mark, monitor_tag);\n-\n-    const Register tmp2_recursions = tmp2;\n-    Label not_recursive;\n-\n-    \/\/ Check if recursive.\n-    ld(tmp2_recursions, Address(tmp1_monitor, ObjectMonitor::recursions_offset()));\n-    beqz(tmp2_recursions, not_recursive);\n-\n-    \/\/ Recursive unlock.\n-    addi(tmp2_recursions, tmp2_recursions, -1);\n-    sd(tmp2_recursions, Address(tmp1_monitor, ObjectMonitor::recursions_offset()));\n-    j(unlocked);\n-\n-    bind(not_recursive);\n-\n-    Label release;\n-    const Register tmp2_owner_addr = tmp2;\n-\n-    \/\/ Compute owner address.\n-    la(tmp2_owner_addr, Address(tmp1_monitor, ObjectMonitor::owner_offset()));\n-\n-    \/\/ Check if the entry lists are empty.\n-    ld(t0, Address(tmp1_monitor, ObjectMonitor::EntryList_offset()));\n-    ld(tmp3_t, Address(tmp1_monitor, ObjectMonitor::cxq_offset()));\n-    orr(t0, t0, tmp3_t);\n-    beqz(t0, release);\n-\n-    \/\/ The owner may be anonymous and we removed the last obj entry in\n-    \/\/ the lock-stack. This loses the information about the owner.\n-    \/\/ Write the thread to the owner field so the runtime knows the owner.\n-    sd(xthread, Address(tmp2_owner_addr));\n+    \/\/ OMCache lookup not supported yet. Take slowpath.\n@@ -494,5 +440,0 @@\n-\n-    bind(release);\n-    \/\/ Set owner to null.\n-    membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n-    sd(zr, Address(tmp2_owner_addr));\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":3,"deletions":62,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -3265,26 +3265,34 @@\n-  Register zero = temp;\n-  Register monitor_tagged = displacedHeader; \/\/ Tagged with markWord::monitor_value.\n-  \/\/ The object's monitor m is unlocked iff m->owner is null,\n-  \/\/ otherwise m->owner may contain a thread or a stack address.\n-\n-  \/\/ Try to CAS m->owner from null to current thread.\n-  \/\/ If m->owner is null, then csg succeeds and sets m->owner=THREAD and CR=EQ.\n-  \/\/ Otherwise, register zero is filled with the current owner.\n-  z_lghi(zero, 0);\n-  z_csg(zero, Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor_tagged);\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ Store a non-null value into the box.\n-    z_stg(box, BasicLock::displaced_header_offset_in_bytes(), box);\n-  }\n-\n-  z_bre(done); \/\/ acquired the lock for the first time.\n-\n-  BLOCK_COMMENT(\"fast_path_recursive_lock {\");\n-  \/\/ Check if we are already the owner (recursive lock)\n-  z_cgr(Z_thread, zero); \/\/ owner is stored in zero by \"z_csg\" above\n-  z_brne(done); \/\/ not a recursive lock\n-\n-  \/\/ Current thread already owns the lock. Just increment recursion count.\n-  z_agsi(Address(monitor_tagged, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n-  z_cgr(zero, zero); \/\/ set the CC to EQUAL\n-  BLOCK_COMMENT(\"} fast_path_recursive_lock\");\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    \/\/ OMCache lookup not supported yet. Take slowpath.\n+\n+    \/\/ Set flag to NE.\n+    z_ltgr(oop, oop);\n+    z_bru(done);\n+  } else {\n+    Register zero = temp;\n+    Register monitor_tagged = displacedHeader; \/\/ Tagged with markWord::monitor_value.\n+    \/\/ The object's monitor m is unlocked iff m->owner is null,\n+    \/\/ otherwise m->owner may contain a thread or a stack address.\n+\n+    \/\/ Try to CAS m->owner from null to current thread.\n+    \/\/ If m->owner is null, then csg succeeds and sets m->owner=THREAD and CR=EQ.\n+    \/\/ Otherwise, register zero is filled with the current owner.\n+    z_lghi(zero, 0);\n+    z_csg(zero, Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor_tagged);\n+    if (LockingMode != LM_LIGHTWEIGHT) {\n+      \/\/ Store a non-null value into the box.\n+      z_stg(box, BasicLock::displaced_header_offset_in_bytes(), box);\n+    }\n+\n+    z_bre(done); \/\/ acquired the lock for the first time.\n+\n+    BLOCK_COMMENT(\"fast_path_recursive_lock {\");\n+    \/\/ Check if we are already the owner (recursive lock)\n+    z_cgr(Z_thread, zero); \/\/ owner is stored in zero by \"z_csg\" above\n+    z_brne(done); \/\/ not a recursive lock\n+\n+    \/\/ Current thread already owns the lock. Just increment recursion count.\n+    z_agsi(Address(monitor_tagged, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n+    z_cgr(zero, zero); \/\/ set the CC to EQUAL\n+    BLOCK_COMMENT(\"} fast_path_recursive_lock\");\n+  }\n@@ -3351,2 +3359,2 @@\n-  z_cg(Z_thread, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n-  z_brne(done);\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    \/\/ OMCache lookup not supported yet. Take slowpath.\n@@ -3354,3 +3362,6 @@\n-  BLOCK_COMMENT(\"fast_path_recursive_unlock {\");\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-  z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n+    \/\/ Set flag to NE.\n+    z_ltgr(oop, oop);\n+    z_bru(done);\n+  } else {\n+    z_cg(Z_thread, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n+    z_brne(done);\n@@ -3358,5 +3369,3 @@\n-  \/\/ Recursive inflated unlock\n-  z_agsi(Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n-  z_cgr(currentHeader, currentHeader); \/\/ set the CC to EQUAL\n-  BLOCK_COMMENT(\"} fast_path_recursive_unlock\");\n-  z_bru(done);\n+    BLOCK_COMMENT(\"fast_path_recursive_unlock {\");\n+    load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+    z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n@@ -3364,1 +3373,5 @@\n-  bind(not_recursive);\n+    \/\/ Recursive inflated unlock\n+    z_agsi(Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n+    z_cgr(currentHeader, currentHeader); \/\/ set the CC to EQUAL\n+    BLOCK_COMMENT(\"} fast_path_recursive_unlock\");\n+    z_bru(done);\n@@ -3366,6 +3379,1 @@\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n-  z_brne(done);\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n-  z_brne(done);\n-  z_release();\n-  z_stg(temp\/*=0*\/, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), currentHeader);\n+    bind(not_recursive);\n@@ -3373,0 +3381,7 @@\n+    load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n+    z_brne(done);\n+    load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n+    z_brne(done);\n+    z_release();\n+    z_stg(temp\/*=0*\/, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), currentHeader);\n+  }\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":58,"deletions":43,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -1827,1 +1827,1 @@\n-#if !defined(X86) && !defined(AARCH64)\n+#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM) && !defined(PPC64) && !defined(S390)\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1045,0 +1045,10 @@\n+  if (mark.is_unlocked()) {\n+    markWord locked_mark = mark.set_fast_locked();\n+    if (obj->cas_set_mark(locked_mark, mark) == mark) {\n+      \/\/ Successfully fast-locked, push object to lock-stack and return.\n+      lock_stack.push(obj);\n+      current->inc_held_monitor_count();\n+      return true;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}