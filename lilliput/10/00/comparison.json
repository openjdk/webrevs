{"files":[{"patch":"@@ -113,1 +113,1 @@\n-    if ((cast_from_oop<uintptr_t>(object->forwardee()) & 0x00000000ffffffff) != 0) {\n+    if ((reinterpret_cast<uintptr_t>(object->mark().decode_pointer()) & 0x00000000ffffffff) != 0) {\n@@ -126,1 +126,1 @@\n-    assert((cast_from_oop<uintptr_t>(object->forwardee()) & 0x00000000ffffffff) == 0, \"should be forwarded to NULL\");\n+    assert((reinterpret_cast<uintptr_t>(object->mark().decode_pointer()) & 0x00000000ffffffff) == 0, \"should be forwarded to NULL\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -171,3 +171,6 @@\n-  oop forwarded_to = obj->forwardee();\n-  if (obj->is_forwarded() && !_current->is_in(forwarded_to)) {\n-    return obj->size();\n+  if (obj->is_forwarded()) {\n+    oop forwarded_to = obj->forwardee();\n+\n+    if (!_current->is_in(forwarded_to)) {\n+      return obj->size();\n+    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -237,1 +237,1 @@\n-      forwardee = cast_to_oop(m.decode_pointer());\n+      forwardee = obj->forwardee(m);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-    obj = cast_to_oop(m.decode_pointer());\n+    obj = obj->forwardee(m);\n@@ -603,1 +603,1 @@\n-  oop forward_ptr = old->forward_to_atomic(old, m, memory_order_relaxed);\n+  oop forward_ptr = old->forward_to_self_atomic(m, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -355,1 +355,1 @@\n-  if (obj->cas_forward_to(obj, obj_mark)) {\n+  if (obj->forward_to_self_atomic(obj_mark) == NULL) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-    return cast_to_oop(m.decode_pointer());\n+    return o->forwardee(m);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -683,1 +683,1 @@\n-  old->forward_to(old);\n+  old->forward_to_self();\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-      oop new_obj = cast_to_oop(header.decode_pointer());\n+      oop new_obj = obj->forwardee(header);\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,2 +101,2 @@\n-  static const int first_unused_gap_bits          = 1;\n-  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - first_unused_gap_bits;\n+  static const int self_forwarded_bits            = 1;\n+  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - self_forwarded_bits;\n@@ -104,1 +104,0 @@\n-  static const int second_unused_gap_bits         = LP64_ONLY(1) NOT_LP64(0);\n@@ -110,1 +109,2 @@\n-  static const int age_shift                      = lock_bits + first_unused_gap_bits;\n+  static const int self_forwarded_shift           = lock_shift + lock_bits;\n+  static const int age_shift                      = self_forwarded_shift + self_forwarded_bits;\n@@ -118,0 +118,2 @@\n+  static const uintptr_t self_forwarded_mask      = right_n_bits(self_forwarded_bits);\n+  static const uintptr_t self_forwarded_mask_in_place = self_forwarded_mask << self_forwarded_shift;\n@@ -133,0 +135,1 @@\n+  static const uintptr_t self_forwarded_value     = 1 << self_forwarded_shift;\n@@ -268,0 +271,10 @@\n+\n+  inline bool self_forwarded() const {\n+    return mask_bits(value(), self_forwarded_mask_in_place) != 0;\n+  }\n+\n+  inline markWord set_self_forwarded() const {\n+    intptr_t bits = (intptr_t)value();\n+    set_bits(bits, self_forwarded_value | marked_value);\n+    return markWord((uintptr_t)bits);\n+  }\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -250,1 +250,1 @@\n-  inline bool cas_forward_to(oop p, markWord compare, atomic_memory_order order = memory_order_conservative);\n+  inline void forward_to_self();\n@@ -257,0 +257,1 @@\n+  inline oop forward_to_self_atomic(markWord compare, atomic_memory_order order = memory_order_conservative);\n@@ -259,0 +260,1 @@\n+  inline oop forwardee(markWord header) const;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-  assert(m.decode_pointer() == p, \"encoding must be reversable\");\n+  assert(forwardee(m) == p, \"encoding must be reversable\");\n@@ -284,6 +284,5 @@\n-\/\/ Used by parallel scavengers\n-bool oopDesc::cas_forward_to(oop p, markWord compare, atomic_memory_order order) {\n-  verify_forwardee(p);\n-  markWord m = markWord::encode_pointer_as_mark(p);\n-  assert(m.decode_pointer() == p, \"encoding must be reversable\");\n-  return cas_set_mark(m, compare, order) == compare;\n+void oopDesc::forward_to_self() {\n+  verify_forwardee(this);\n+  markWord m = mark().set_self_forwarded();\n+  assert(forwardee(m) == cast_to_oop(this), \"encoding must be reversable\");\n+  set_mark(m);\n@@ -295,1 +294,1 @@\n-  assert(m.decode_pointer() == p, \"encoding must be reversable\");\n+  assert(forwardee(m) == p, \"encoding must be reversable\");\n@@ -300,1 +299,17 @@\n-    return cast_to_oop(old_mark.decode_pointer());\n+    return forwardee(old_mark);\n+  }\n+}\n+\n+oop oopDesc::forward_to_self_atomic(markWord compare, atomic_memory_order order) {\n+  verify_forwardee(this);\n+  while (true) {\n+    markWord m = compare.set_self_forwarded();\n+    assert(forwardee(m) == cast_to_oop(this), \"encoding must be reversable\");\n+    markWord old_mark = cas_set_mark(m, compare, order);\n+    if (old_mark == compare) {\n+      return NULL;\n+    } else if (old_mark.is_marked()) {\n+      return forwardee(old_mark);\n+    } else {\n+      compare = old_mark;\n+    }\n@@ -308,1 +323,10 @@\n-  return cast_to_oop(mark().decode_pointer());\n+  return forwardee(mark());\n+}\n+\n+oop oopDesc::forwardee(markWord header) const {\n+  assert(header.is_marked(), \"must be forwarded\");\n+  if (header.self_forwarded()) {\n+    return cast_to_oop(this);\n+  } else {\n+    return cast_to_oop(header.decode_pointer());\n+  }\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":34,"deletions":10,"binary":false,"changes":44,"status":"modified"}]}