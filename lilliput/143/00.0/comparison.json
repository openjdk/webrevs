{"files":[{"patch":"@@ -201,0 +201,6 @@\n+    int base_offset = arrayOopDesc::length_offset_in_bytes() + BytesPerInt;\n+    if (!is_aligned(base_offset, BytesPerWord)) {\n+      assert(is_aligned(base_offset, BytesPerInt), \"must be 4-byte aligned\");\n+      \/\/ Clear gap\/first 4 bytes following the length field.\n+      strw(zr, Address(obj, base_offset));\n+    }\n@@ -279,1 +285,1 @@\n-void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int header_size, int f, Register klass, Label& slow_case) {\n+void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, int f, Register klass, Label& slow_case) {\n@@ -292,1 +298,1 @@\n-  mov(arr_size, (int32_t)header_size * BytesPerWord + MinObjAlignmentInBytesMask);\n+  mov(arr_size, (int32_t)base_offset_in_bytes + MinObjAlignmentInBytesMask);\n@@ -300,0 +306,3 @@\n+  \/\/ Align-up to word boundary, because we clear the 4 bytes potentially\n+  \/\/ following the length field in initialize_header().\n+  int base_offset = align_up(base_offset_in_bytes, BytesPerWord);\n@@ -301,1 +310,1 @@\n-  initialize_body(obj, arr_size, header_size * BytesPerWord, t1, t2);\n+  initialize_body(obj, arr_size, base_offset, t1, t2);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1623,1 +1623,1 @@\n-                      arrayOopDesc::header_size(op->type()),\n+                      arrayOopDesc::base_offset_in_bytes(op->type()),\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -211,0 +211,9 @@\n+#ifdef _LP64\n+    int base_offset = arrayOopDesc::length_offset_in_bytes() + BytesPerInt;\n+    if (!is_aligned(base_offset, BytesPerWord)) {\n+      assert(is_aligned(base_offset, BytesPerInt), \"must be 4-byte aligned\");\n+      \/\/ Clear gap\/first 4 bytes following the length field.\n+      xorl(t1, t1);\n+      movl(Address(obj, base_offset), t1);\n+    }\n+#endif\n@@ -294,1 +303,1 @@\n-void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int header_size, Address::ScaleFactor f, Register klass, Label& slow_case) {\n+void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, Address::ScaleFactor f, Register klass, Label& slow_case) {\n@@ -307,1 +316,1 @@\n-  movptr(arr_size, header_size * BytesPerWord + MinObjAlignmentInBytesMask);\n+  movptr(arr_size, base_offset_in_bytes + MinObjAlignmentInBytesMask);\n@@ -317,1 +326,4 @@\n-  initialize_body(obj, arr_size, header_size * BytesPerWord, len_zero);\n+  \/\/ Align-up to word boundary, because we clear the 4 bytes potentially\n+  \/\/ following the length field in initialize_header().\n+  int base_offset = align_up(base_offset_in_bytes, BytesPerWord);\n+  initialize_body(obj, arr_size, base_offset, len_zero);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -4462,1 +4462,1 @@\n-  predicate(UseAVX > 0 && !SuperWord::is_reduction(n));\n+  predicate(UseAVX > 0 && !VLoopReductions::is_reduction(n));\n@@ -4473,1 +4473,1 @@\n-  predicate(UseAVX > 0 && SuperWord::is_reduction(n));\n+  predicate(UseAVX > 0 && VLoopReductions::is_reduction(n));\n@@ -4487,1 +4487,1 @@\n-  predicate(UseAVX > 0 && !SuperWord::is_reduction(n));\n+  predicate(UseAVX > 0 && !VLoopReductions::is_reduction(n));\n@@ -4498,1 +4498,1 @@\n-  predicate(UseAVX > 0 && SuperWord::is_reduction(n));\n+  predicate(UseAVX > 0 && VLoopReductions::is_reduction(n));\n@@ -4512,1 +4512,1 @@\n-  predicate(UseAVX > 0 && !SuperWord::is_reduction(n));\n+  predicate(UseAVX > 0 && !VLoopReductions::is_reduction(n));\n@@ -4523,1 +4523,1 @@\n-  predicate(UseAVX > 0 && SuperWord::is_reduction(n));\n+  predicate(UseAVX > 0 && VLoopReductions::is_reduction(n));\n@@ -4537,1 +4537,1 @@\n-  predicate(UseAVX > 0 && !SuperWord::is_reduction(n));\n+  predicate(UseAVX > 0 && !VLoopReductions::is_reduction(n));\n@@ -4548,1 +4548,1 @@\n-  predicate(UseAVX > 0 && SuperWord::is_reduction(n));\n+  predicate(UseAVX > 0 && VLoopReductions::is_reduction(n));\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-  } else if (*((juint*)this) == badMetaWordVal) {\n-    st->print_cr(\"BAD META WORD\");\n@@ -61,2 +59,0 @@\n-  } else if (*((juint*)this) == badMetaWordVal) {\n-    st->print_cr(\"BAD META WORD\");\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2015,1 +2015,1 @@\n-  product(uint, TrimNativeHeapInterval, 0, EXPERIMENTAL,                    \\\n+  product(uint, TrimNativeHeapInterval, 0,                                  \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1552,1 +1552,1 @@\n-  JFR_ONLY(return vmSymbols::jfr_chunk_rotation_monitor() == monitor_klass->name());\n+  JFR_ONLY(return vmSymbols::jfr_chunk_rotation_monitor() == monitor_klass->name();)\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -584,0 +584,2 @@\n+#include CPU_HEADER(globalDefinitions)\n+\n@@ -585,0 +587,1 @@\n+#ifndef CODE_CACHE_SIZE_LIMIT\n@@ -586,0 +589,2 @@\n+#endif\n+\n@@ -589,2 +594,0 @@\n-#include CPU_HEADER(globalDefinitions)\n-\n@@ -1030,13 +1033,13 @@\n-const jint     badInt           = -3;                       \/\/ generic \"bad int\" value\n-const intptr_t badAddressVal    = -2;                       \/\/ generic \"bad address\" value\n-const intptr_t badOopVal        = -1;                       \/\/ generic \"bad oop\" value\n-const intptr_t badHeapOopVal    = (intptr_t) CONST64(0x2BAD4B0BBAADBABE); \/\/ value used to zap heap after GC\n-const int      badStackSegVal   = 0xCA;                     \/\/ value used to zap stack segments\n-const int      badHandleValue   = 0xBC;                     \/\/ value used to zap vm handle area\n-const int      badResourceValue = 0xAB;                     \/\/ value used to zap resource area\n-const int      freeBlockPad     = 0xBA;                     \/\/ value used to pad freed blocks.\n-const int      uninitBlockPad   = 0xF1;                     \/\/ value used to zap newly malloc'd blocks.\n-const juint    uninitMetaWordVal= 0xf7f7f7f7;               \/\/ value used to zap newly allocated metachunk\n-const juint    badHeapWordVal   = 0xBAADBABE;               \/\/ value used to zap heap after GC\n-const juint    badMetaWordVal   = 0xBAADFADE;               \/\/ value used to zap metadata heap after GC\n-const int      badCodeHeapNewVal= 0xCC;                     \/\/ value used to zap Code heap at allocation\n+const jint     badInt             = -3;                     \/\/ generic \"bad int\" value\n+const intptr_t badAddressVal      = -2;                     \/\/ generic \"bad address\" value\n+const intptr_t badOopVal          = -1;                     \/\/ generic \"bad oop\" value\n+const intptr_t badHeapOopVal      = (intptr_t) CONST64(0x2BAD4B0BBAADBABE); \/\/ value used to zap heap after GC\n+const int      badStackSegVal     = 0xCA;                   \/\/ value used to zap stack segments\n+const int      badHandleValue     = 0xBC;                   \/\/ value used to zap vm handle area\n+const int      badResourceValue   = 0xAB;                   \/\/ value used to zap resource area\n+const int      freeBlockPad       = 0xBA;                   \/\/ value used to pad freed blocks.\n+const int      uninitBlockPad     = 0xF1;                   \/\/ value used to zap newly malloc'd blocks.\n+const juint    uninitMetaWordVal  = 0xf7f7f7f7;             \/\/ value used to zap newly allocated metachunk\n+const jubyte   heapPaddingByteVal = 0xBD;                   \/\/ value used to zap object padding in the heap\n+const juint    badHeapWordVal     = 0xBAADBABE;             \/\/ value used to zap heap after GC\n+const int      badCodeHeapNewVal  = 0xCC;                   \/\/ value used to zap Code heap at allocation\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":19,"deletions":16,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -492,0 +492,4 @@\n+#ifdef LINUX\n+  st->print_cr(\"#   This process has exceeded the maximum number of memory mappings (check below\");\n+  st->print_cr(\"#     for `\/proc\/sys\/vm\/max_map_count` and `Total number of mappings`)\");\n+#endif\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}