{"files":[{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -39,0 +40,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -81,0 +83,3 @@\n+  } else if (LockingMode == LM_PLACEHOLDER) {\n+    \/\/ null check obj. load_klass performs load if DiagnoseSyncOnValueBasedClasses != 0.\n+    ldr(hdr, Address(obj));\n@@ -83,1 +88,4 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n+  if (LockingMode == LM_PLACEHOLDER) {\n+    str(zr, Address(disp_hdr, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::displaced_header_offset_in_bytes()))));\n+    placeholder_lock(obj, hdr, temp, rscratch2, slow_case);\n+  } else if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -134,1 +142,1 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n+  if (LockingMode != LM_LIGHTWEIGHT && LockingMode != LM_PLACEHOLDER) {\n@@ -146,1 +154,3 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n+  if (LockingMode == LM_PLACEHOLDER) {\n+    placeholder_unlock(obj, hdr, temp, rscratch2, slow_case);\n+  } else if (LockingMode == LM_LIGHTWEIGHT) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -45,0 +46,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -3488,1 +3490,1 @@\n-    Register tmp = LockingMode == LM_LIGHTWEIGHT ? op->scratch_opr()->as_register() : noreg;\n+    Register tmp = LockingMode == LM_LIGHTWEIGHT || LockingMode == LM_PLACEHOLDER ? op->scratch_opr()->as_register() : noreg;\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,0 +64,3 @@\n+  } else if (LockingMode == LM_PLACEHOLDER) {\n+    \/\/ null check obj. load_klass performs load if DiagnoseSyncOnValueBasedClasses != 0.\n+    testptr(hdr, Address(obj));\n@@ -66,1 +69,10 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n+  if (LockingMode == LM_PLACEHOLDER) {\n+    movptr(Address(disp_hdr), 0);\n+#ifdef _LP64\n+    const Register thread = r15_thread;\n+#else\n+    const Register thread = disp_hdr;\n+    get_thread(thread);\n+#endif\n+    placeholder_lock(obj, hdr, thread, tmp, slow_case);\n+  } else if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -121,0 +133,1 @@\n+  assert(LockingMode != LM_MONITOR, \"not handled\");\n@@ -125,1 +138,1 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n+  if (LockingMode == LM_LEGACY) {\n@@ -138,1 +151,10 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n+  if (LockingMode == LM_PLACEHOLDER) {\n+#ifdef _LP64\n+    placeholder_unlock(obj, disp_hdr, r15_thread, hdr, slow_case);\n+#else\n+    \/\/ This relies on the implementation of paceholder_unlock knowing that it\n+    \/\/ will clobber its thread when using EAX.\n+    get_thread(disp_hdr);\n+    placeholder_unlock(obj, disp_hdr, disp_hdr, hdr, slow_case);\n+#endif\n+  } else if (LockingMode == LM_LIGHTWEIGHT) {\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -12386,1 +12386,1 @@\n-  predicate(LockingMode != LM_LIGHTWEIGHT && !Compile::current()->use_rtm());\n+  predicate(LockingMode != LM_LIGHTWEIGHT && LockingMode != LM_PLACEHOLDER && !Compile::current()->use_rtm());\n@@ -12399,1 +12399,1 @@\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n+  predicate(LockingMode != LM_LIGHTWEIGHT && LockingMode != LM_PLACEHOLDER);\n@@ -12434,0 +12434,24 @@\n+instruct cmpFastLockPlaceholder(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr) %{\n+  predicate(LockingMode == LM_PLACEHOLDER);\n+  match(Set cr (FastLock object box));\n+  effect(TEMP tmp, TEMP scr, USE_KILL box);\n+  ins_cost(300);\n+  format %{ \"fastlock $object,$box\\t! kills $box,$tmp,$scr\" %}\n+  ins_encode %{\n+    __ fast_lock_placeholder($object$$Register, $box$$Register, $tmp$$Register, $scr$$Register, r15_thread);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct cmpFastUnlockPlaceholder(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{\n+  predicate(LockingMode == LM_PLACEHOLDER);\n+  match(Set cr (FastUnlock object box));\n+  effect(TEMP tmp, USE_KILL box);\n+  ins_cost(300);\n+  format %{ \"fastunlock $object,$box\\t! kills $box,$tmp\" %}\n+  ins_encode %{\n+    __ fast_unlock_placeholder($object$$Register, $box$$Register, $tmp$$Register, r15_thread);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-  return LockingMode == LM_LIGHTWEIGHT || !SafepointSynchronize::is_at_safepoint();\n+  return LockingMode == LM_LIGHTWEIGHT || LockingMode == LM_PLACEHOLDER || !SafepointSynchronize::is_at_safepoint();\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1983,1 +1983,1 @@\n-  product(int, LockingMode, LM_LEGACY,                                      \\\n+  product(int, LockingMode, LM_PLACEHOLDER,                                 \\\n@@ -1987,2 +1987,27 @@\n-          \"2: monitors & new lightweight locking (LM_LIGHTWEIGHT)\")         \\\n-          range(0, 2)                                                       \\\n+          \"2: monitors & new lightweight locking (LM_LIGHTWEIGHT), \"        \\\n+          \"3: placeholder (LM_PLACEHOLDER)\")                                \\\n+          range(0, 3)                                                       \\\n+                                                                            \\\n+  product(bool, OMUseC2Cache, true, \"\")                                     \\\n+                                                                            \\\n+  product(bool, OMC2UnrollCacheLookupLoopTail, true, \"\")                    \\\n+                                                                            \\\n+  product(int, OMC2UnrollCacheEntries, 0, \"\")                               \\\n+          range(0, OMCache::CAPACITY)                                       \\\n+                                                                            \\\n+  product(int, OMCacheSize, 8, \"\")                                          \\\n+          range(0, OMCache::CAPACITY)                                       \\\n+                                                                            \\\n+  product(bool, OMShrinkCHT, false, \"\")                                     \\\n+                                                                            \\\n+  product(int, OMSpins, 20, \"\")                                             \\\n+                                                                            \\\n+  product(int, OMYields, 5, \"\")                                             \\\n+                                                                            \\\n+  product(bool, OMDeflateAfterWait, false, \"\")                              \\\n+                                                                            \\\n+  product(bool, OMDeflateBeforeExit, false, \"\")                             \\\n+                                                                            \\\n+  product(bool, OMCacheHitRate, false, \"\")                                  \\\n+                                                                            \\\n+  product(bool, OMRecursiveFastPath, true, \"Inflated recursion check first\")\\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"runtime\/placeholderSynchronizer.hpp\"\n@@ -55,0 +56,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -56,0 +58,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -289,4 +292,0 @@\n-oop ObjectMonitor::object_peek() const {\n-  return _object.peek();\n-}\n-\n@@ -314,0 +313,6 @@\n+#define assert_mark_word_concistency()                                                 \\\n+  assert(LockingMode == LM_PLACEHOLDER || object()->mark() == markWord::encode(this),  \\\n+         \"object mark must match encoded this: mark=\" INTPTR_FORMAT                    \\\n+         \", encoded this=\" INTPTR_FORMAT, object()->mark().value(),                    \\\n+         markWord::encode(this).value());\n+\n@@ -316,0 +321,14 @@\n+bool ObjectMonitor::try_enter(JavaThread* current) {\n+  void* cur = try_set_owner_from(nullptr, current);\n+  if (cur == nullptr) {\n+    assert(_recursions == 0, \"invariant\");\n+    return true;\n+  }\n+\n+  if (cur == current) {\n+    _recursions++;\n+    return true;\n+  }\n+\n+  return false;\n+}\n@@ -396,1 +415,1 @@\n-  if (LockingMode != LM_LIGHTWEIGHT && current->is_lock_owned((address)cur)) {\n+  if (LockingMode != LM_LIGHTWEIGHT && LockingMode != LM_PLACEHOLDER && current->is_lock_owned((address)cur)) {\n@@ -415,4 +434,1 @@\n-    assert(object()->mark() == markWord::encode(this),\n-           \"object mark must match encoded this: mark=\" INTPTR_FORMAT\n-           \", encoded this=\" INTPTR_FORMAT, object()->mark().value(),\n-           markWord::encode(this).value());\n+    assert_mark_word_concistency();\n@@ -435,1 +451,1 @@\n-    if (l_object != nullptr) {\n+    if (LockingMode != LM_PLACEHOLDER && l_object != nullptr) {\n@@ -509,1 +525,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n+  assert_mark_word_concistency();\n@@ -571,1 +587,1 @@\n-bool ObjectMonitor::deflate_monitor() {\n+bool ObjectMonitor::deflate_monitor(Thread* current) {\n@@ -577,0 +593,7 @@\n+  if (LockingMode == LM_PLACEHOLDER && is_being_async_deflated()) {\n+    \/\/ This happens when a locked monitor is deflated by a java thread\n+    \/\/ returning itself to fast_locked\n+    assert(is_owner_anonymous(), \"must stay anonymous when the java thread deflates\");\n+    return true;\n+  }\n+\n@@ -642,0 +665,1 @@\n+  }\n@@ -643,2 +667,7 @@\n-    \/\/ Install the old mark word if nobody else has already done it.\n-    install_displaced_markword_in_object(obj);\n+  if (LockingMode == LM_PLACEHOLDER) {\n+    PlaceholderSynchronizer::deflate_monitor(current, obj, this);\n+  } else {\n+    if (obj != nullptr) {\n+      \/\/ Install the old mark word if nobody else has already done it.\n+      install_displaced_markword_in_object(obj);\n+    }\n@@ -652,0 +681,71 @@\n+bool ObjectMonitor::deflate_anon_monitor(JavaThread* current) {\n+  assert(owner_raw() == current, \"must be\");\n+  assert(LockingMode == LM_PLACEHOLDER, \"must be\");\n+\n+  LockStack& lock_stack = current->lock_stack();\n+\n+  if (!lock_stack.can_push(1 + _recursions)) {\n+    \/\/ Will not be able to push the oop on the lock stack.\n+    return false;\n+  }\n+\n+  if (is_contended()) {\n+    \/\/ Easy checks are first - the ObjectMonitor is busy so no deflation.\n+    return false;\n+  }\n+\n+  \/\/ Make sure if a thread sees contentions() < 0 they also see owner == ANONYMOUS_OWNER\n+  set_owner_from(current, reinterpret_cast<void*>(ANONYMOUS_OWNER));\n+\n+    \/\/ Recheck after setting owner\n+  bool cleanup = is_contended();\n+\n+\n+  if (!cleanup) {\n+    \/\/ Make a zero contentions field negative to force any contending threads\n+    \/\/ to retry. Because this is only called while holding the lock, the owner\n+    \/\/ is anonymous and contentions is held over enter in inflate_and_enter\n+    \/\/ it means that if the cas succeeds then we can have no other thread\n+    \/\/ racily inserting themselves on the _waiters or _cxq lists, the\n+    \/\/ entry list is protected by the lock (_waiter technically too, only\n+    \/\/ removals are done outside the lock)\n+    \/\/ TODO: Double check _succ and _responsible invariants\n+    if (Atomic::cmpxchg(&_contentions, 0, INT_MIN) != 0) {\n+      \/\/ Contentions was no longer 0 so we lost the race.\n+      cleanup = true;\n+    }\n+  }\n+\n+  if (cleanup) {\n+    \/\/ Could not deflate\n+    set_owner_from_anonymous(current);\n+    return false;\n+  }\n+\n+  \/\/ Sanity checks for the races:\n+  guarantee(is_owner_anonymous(), \"must be\");\n+  guarantee(contentions() < 0, \"must be negative: contentions=%d\",\n+            contentions());\n+  guarantee(_waiters == 0, \"must be 0: waiters=%d\", _waiters);\n+  guarantee(_cxq == nullptr, \"must be no contending threads: cxq=\"\n+            INTPTR_FORMAT, p2i(_cxq));\n+  guarantee(_EntryList == nullptr,\n+            \"must be no entering threads: EntryList=\" INTPTR_FORMAT,\n+            p2i(_EntryList));\n+\n+  oop obj = object();\n+\n+  PlaceholderSynchronizer::deflate_anon_monitor(current, obj, this);\n+\n+  \/\/ We are deflated, restore the correct lock_stack\n+  lock_stack.push(obj);\n+  for (int i = 0; i < _recursions; i++) {\n+    bool entered = lock_stack.try_recursive_enter(obj);\n+    assert(entered, \"must have entered here\");\n+  }\n+\n+  \/\/ We leave owner == ANONYMOUS_OWNER and contentions < 0\n+  \/\/ to force any racing threads to retry.\n+  return true;  \/\/ Success, ObjectMonitor has been deflated.\n+}\n+\n@@ -658,0 +758,1 @@\n+  assert(LockingMode != LM_PLACEHOLDER, \"Placeholder has no dmw\");\n@@ -990,0 +1091,1 @@\n+  assert(current->thread_state() != _thread_blocked, \"invariant\");\n@@ -993,3 +1095,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n-\n-  assert(current->thread_state() != _thread_blocked, \"invariant\");\n+  assert_mark_word_concistency();\n@@ -1052,1 +1152,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n+  assert_mark_word_concistency();\n@@ -1186,1 +1286,1 @@\n-    if (LockingMode != LM_LIGHTWEIGHT && current->is_lock_owned((address)cur)) {\n+    if (LockingMode != LM_LIGHTWEIGHT && LockingMode != LM_PLACEHOLDER && current->is_lock_owned((address)cur)) {\n@@ -1401,1 +1501,1 @@\n-    if (LockingMode != LM_LIGHTWEIGHT && current->is_lock_owned((address)cur)) {\n+    if (LockingMode != LM_LIGHTWEIGHT && LockingMode != LM_PLACEHOLDER && current->is_lock_owned((address)cur)) {\n@@ -1440,1 +1540,1 @@\n-  if (LockingMode != LM_LIGHTWEIGHT && current->is_lock_owned((address)cur)) {\n+  if (LockingMode != LM_LIGHTWEIGHT && LockingMode != LM_PLACEHOLDER && current->is_lock_owned((address)cur)) {\n@@ -1680,0 +1780,9 @@\n+  bool deflated = false;\n+\n+  if (LockingMode == LM_PLACEHOLDER && OMDeflateAfterWait && current->lock_stack().wait_was_inflated()) {\n+    if (deflate_anon_monitor(current)) {\n+      current->_wait_deflation++;\n+      deflated = true;\n+    }\n+  }\n+\n@@ -1681,1 +1790,1 @@\n-  assert(owner_raw() == current, \"invariant\");\n+  assert(deflated || owner_raw() == current, \"invariant\");\n@@ -1683,1 +1792,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n+  assert_mark_word_concistency();\n@@ -2203,1 +2312,1 @@\n-  st->print_cr(\"  _header = \" INTPTR_FORMAT, header().value());\n+  st->print_cr(\"  _header = \" INTPTR_FORMAT, header_value());\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":133,"deletions":24,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -1025,1 +1025,3 @@\n-  LM_LIGHTWEIGHT = 2\n+  LM_LIGHTWEIGHT = 2,\n+  \/\/ New PLACEHOLDER locking based on lightweigh, with monitors as 2nd tier using OMWorld\n+  LM_PLACEHOLDER = 3\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -578,1 +578,1 @@\n-   st->print_cr(\"# Java VM: %s%s%s (%s%s, %s%s%s%s%s%s, %s, %s)\",\n+   st->print_cr(\"# Java VM: %s%s%s (%s%s, %s%s%s%s%s%s%s, %s, %s)\",\n@@ -593,0 +593,4 @@\n+                 LockingMode == LM_MONITOR ? \", lm_monitors\" :\n+                 LockingMode == LM_LEGACY ? \", lm_legacy\" :\n+                 LockingMode == LM_LIGHTWEIGHT ? \", lm_lightweight\" :\n+                 LockingMode == LM_PLACEHOLDER ? \", lm_placeholder\" : \"\",\n@@ -1119,1 +1123,1 @@\n-  STEP_IF(\"printing lock stack\", _verbose && _thread != nullptr && _thread->is_Java_thread() && LockingMode == LM_LIGHTWEIGHT);\n+  STEP_IF(\"printing lock stack\", _verbose && _thread != nullptr && _thread->is_Java_thread() && (LockingMode == LM_LIGHTWEIGHT || LockingMode == LM_PLACEHOLDER));\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"}]}