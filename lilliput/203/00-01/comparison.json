{"files":[{"patch":"@@ -50,6 +50,13 @@\n-  \/\/ We disallow klass range sizes larger than 4GB even if the encoding\n-  \/\/ range would allow for a larger Klass range (e.g. Base=zero, shift=3 -> 32GB).\n-  \/\/ That is because many CPU-specific compiler decodings do not want the\n-  \/\/ shifted narrow Klass to spill over into the third quadrant of the 64-bit target\n-  \/\/ address, e.g. to use a 16-bit move for a simplified base addition.\n-  return MIN2(4 * G, max_encoding_range_size());\n+ #ifdef _LP64\n+   const size_t encoding_allows = nth_bit(narrow_klass_pointer_bits() + max_shift());\n+   assert(!UseCompactObjectHeaders || max_klass_range_size_coh == encoding_allows, \"Sanity\");\n+   constexpr size_t cap = 4 * G;\n+   return MIN2(encoding_allows, cap);\n+ #else\n+  \/\/ 32-bit: only 32-bit \"narrow\" Klass pointers allowed. If we ever support smaller narrow\n+  \/\/ Klass pointers here, coding needs to be revised.\n+  \/\/ We keep one page safety zone free to guard against size_t overflows on 32-bit. In practice\n+  \/\/ this is irrelevant because these upper address space parts are not user-addressable on\n+  \/\/ any of our 32-bit platforms.\n+  return align_down(UINT_MAX, os::vm_page_size());\n+#endif\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -193,0 +193,3 @@\n+  \/\/ For use before pre-initialization\n+  static constexpr size_t max_klass_range_size_coh = nth_bit(narrow_klass_pointer_bits_coh + max_shift_coh);\n+\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3772,1 +3772,1 @@\n-    FLAG_SET_DEFAULT(CompressedClassSpaceSize, 512 * M);\n+    FLAG_SET_DEFAULT(CompressedClassSpaceSize, CompressedKlassPointers::max_klass_range_size_coh);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}