{"files":[{"patch":"@@ -564,53 +564,3 @@\n-  if (!OMUseC2Cache) {\n-    \/\/ Set Flags == NE\n-    cmp(zr, obj);\n-    b(slow_path);\n-  } else {\n-\n-    if (OMCacheHitRate) increment(Address(rthread, JavaThread::lock_lookup_offset()));\n-\n-    Label monitor_found, loop;\n-    \/\/ Load cache address\n-    lea(t, Address(rthread, JavaThread::om_cache_oops_offset()));\n-\n-    \/\/ Search for obj in cache.\n-    bind(loop);\n-\n-    \/\/ Check for match.\n-    ldr(t1, Address(t));\n-    cmp(obj, t1);\n-    br(Assembler::EQ, monitor_found);\n-\n-    \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n-    increment(t, oopSize);\n-    cbnz(t1, loop);\n-    \/\/ Cache Miss, NE set from cmp above, cbnz does not set flags\n-    b(slow_path);\n-\n-    bind(monitor_found);\n-    ldr(t1, Address(t, OMCache::oop_to_monitor_difference()));\n-    if (OMCacheHitRate) increment(Address(rthread, JavaThread::lock_hit_offset()));\n-\n-    \/\/ ObjectMonitor* is in t1\n-    const Register monitor = t1;\n-    const Register owner_addr = t2;\n-    const Register owner = t3;\n-\n-    Label recursive;\n-    Label monitor_locked;\n-\n-    \/\/ Compute owner address.\n-    lea(owner_addr, Address(monitor, ObjectMonitor::owner_offset()));\n-\n-    if (OMRecursiveFastPath) {\n-      ldr(owner, Address(owner_addr));\n-      cmp(owner, rthread);\n-      br(Assembler::EQ, recursive);\n-    }\n-\n-    \/\/ CAS owner (null => current thread).\n-    cmpxchg(owner_addr, zr, rthread, Assembler::xword, \/*acquire*\/ true,\n-            \/*release*\/ false, \/*weak*\/ false, owner);\n-    br(Assembler::EQ, monitor_locked);\n-\n-    if (OMRecursiveFastPath) {\n+    if (!OMUseC2Cache) {\n+      \/\/ Set Flags == NE\n+      cmp(zr, obj);\n@@ -619,8 +569,0 @@\n-      \/\/ Check if recursive.\n-      cmp(owner, rthread);\n-      br(Assembler::NE, slow_path);\n-    }\n-\n-    \/\/ Recursive.\n-    bind(recursive);\n-    increment(Address(monitor, ObjectMonitor::recursions_offset()), 1);\n@@ -628,3 +570,84 @@\n-    bind(monitor_locked);\n-    str(monitor, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-  }\n+      if (OMCacheHitRate) increment(Address(rthread, JavaThread::lock_lookup_offset()));\n+\n+      Label monitor_found;\n+\n+      \/\/ Load cache address\n+      lea(t, Address(rthread, JavaThread::om_cache_oops_offset()));\n+\n+      const int num_unrolled = OMC2UnrollCacheLookup ? MIN2(OMC2UnrollCacheEntires, OMCacheSize) : 0;\n+      if (OMC2UnrollCacheLookup) {\n+        for (int i = 0; i < num_unrolled; i++) {\n+          ldr(t1, Address(t));\n+          cmp(obj, t1);\n+          br(Assembler::EQ, monitor_found);\n+          if (i + 1 != num_unrolled) {\n+            increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+          }\n+        }\n+      }\n+      if (!OMC2UnrollCacheLookup || (OMC2UnrollCacheLookupLoopTail && num_unrolled != OMCacheSize)) {\n+        if (num_unrolled != 0) {\n+          \/\/ Loop after unrolling, advance iterator.\n+          increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+        }\n+\n+        Label loop;\n+\n+        \/\/ Search for obj in cache.\n+        bind(loop);\n+\n+        \/\/ Check for match.\n+        ldr(t1, Address(t));\n+        cmp(obj, t1);\n+        br(Assembler::EQ, monitor_found);\n+\n+        \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n+        increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+        cbnz(t1, loop);\n+        \/\/ Cache Miss, NE set from cmp above, cbnz does not set flags\n+        b(slow_path);\n+      } else {\n+        b(slow_path);\n+      }\n+\n+      bind(monitor_found);\n+      ldr(t1, Address(t, OMCache::oop_to_monitor_difference()));\n+      if (OMCacheHitRate) increment(Address(rthread, JavaThread::lock_hit_offset()));\n+\n+      \/\/ ObjectMonitor* is in t1\n+      const Register monitor = t1;\n+      const Register owner_addr = t2;\n+      const Register owner = t3;\n+\n+      Label recursive;\n+      Label monitor_locked;\n+\n+      \/\/ Compute owner address.\n+      lea(owner_addr, Address(monitor, ObjectMonitor::owner_offset()));\n+\n+      if (OMRecursiveFastPath) {\n+        ldr(owner, Address(owner_addr));\n+        cmp(owner, rthread);\n+        br(Assembler::EQ, recursive);\n+      }\n+\n+      \/\/ CAS owner (null => current thread).\n+      cmpxchg(owner_addr, zr, rthread, Assembler::xword, \/*acquire*\/ true,\n+              \/*release*\/ false, \/*weak*\/ false, owner);\n+      br(Assembler::EQ, monitor_locked);\n+\n+      if (OMRecursiveFastPath) {\n+        b(slow_path);\n+      } else {\n+        \/\/ Check if recursive.\n+        cmp(owner, rthread);\n+        br(Assembler::NE, slow_path);\n+      }\n+\n+      \/\/ Recursive.\n+      bind(recursive);\n+      increment(Address(monitor, ObjectMonitor::recursions_offset()), 1);\n+\n+      bind(monitor_locked);\n+      str(monitor, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":87,"deletions":64,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -1261,1 +1261,2 @@\n-      Label monitor_found, loop;\n+      Label monitor_found;\n+\n@@ -1265,12 +1266,33 @@\n-      \/\/ Search for obj in cache.\n-      bind(loop);\n-\n-      \/\/ Check for match.\n-      cmpptr(obj, Address(t));\n-      jccb(Assembler::equal, monitor_found);\n-\n-      \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n-      cmpptr(Address(t), 1);\n-      jcc(Assembler::below, slow_path); \/\/ 0 check, but with ZF=0 when *t == 0\n-      increment(t, oopSize);\n-      jmpb(loop);\n+      const int num_unrolled = OMC2UnrollCacheLookup ? MIN2(OMC2UnrollCacheEntires, OMCacheSize) : 0;\n+      if (OMC2UnrollCacheLookup) {\n+        for (int i = 0; i < num_unrolled; i++) {\n+          cmpptr(obj, Address(t));\n+          jccb(Assembler::equal, monitor_found);\n+          if (i + 1 != num_unrolled) {\n+            increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+          }\n+        }\n+      }\n+      if (!OMC2UnrollCacheLookup || (OMC2UnrollCacheLookupLoopTail && num_unrolled != OMCacheSize)) {\n+        if (num_unrolled != 0) {\n+          \/\/ Loop after unrolling, advance iterator.\n+          increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+        }\n+\n+        Label loop;\n+\n+        \/\/ Search for obj in cache.\n+        bind(loop);\n+\n+        \/\/ Check for match.\n+        cmpptr(obj, Address(t));\n+        jccb(Assembler::equal, monitor_found);\n+\n+        \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n+        cmpptr(Address(t), 1);\n+        jcc(Assembler::below, slow_path); \/\/ 0 check, but with ZF=0 when *t == 0\n+        increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+        jmpb(loop);\n+      } else {\n+        jmp(slow_path);\n+      }\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":35,"deletions":13,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1993,0 +1993,7 @@\n+  product(bool, OMC2UnrollCacheLookup, false, \"\")                           \\\n+                                                                            \\\n+  product(bool, OMC2UnrollCacheLookupLoopTail, true, \"\")                    \\\n+                                                                            \\\n+  product(int, OMC2UnrollCacheEntires, 8, \"\")                               \\\n+          range(0, OMCache::CAPACITY)                                       \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1189,1 +1189,1 @@\n-  static ByteSize om_cache_oops_offset()   { return om_cache_offset() + OMCache::oops_offset(); }\n+  static ByteSize om_cache_oops_offset()   { return om_cache_offset() + OMCache::entries(); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"utilities\/sizes.hpp\"\n@@ -113,0 +114,8 @@\n+\n+OMCache::OMCache(JavaThread* jt) : _entries() {\n+  STATIC_ASSERT(std::is_standard_layout<OMCache>::value);\n+  STATIC_ASSERT(std::is_standard_layout<OMCache::OMCacheEntry>::value);\n+  STATIC_ASSERT(offsetof(OMCache, _null_sentinel) == offsetof(OMCache, _entries) +\n+                offsetof(OMCache::OMCacheEntry, _oop) +\n+                OMCache::CAPACITY * in_bytes(oop_to_oop_difference()));\n+}\n","filename":"src\/hotspot\/share\/runtime\/lockStack.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -143,3 +143,5 @@\n-  oop _oops[CAPACITY];\n-  const oop _null_sentinel;\n-  ObjectMonitor* _monitors[CAPACITY];\n+  struct OMCacheEntry {\n+    oop _oop = nullptr;\n+    ObjectMonitor* _monitor = nullptr;\n+  } _entries[CAPACITY];\n+  const oop _null_sentinel = nullptr;\n@@ -148,3 +150,3 @@\n-  static ByteSize oops_offset() { return byte_offset_of(OMCache, _oops); }\n-  static ByteSize monitors_offset() { return byte_offset_of(OMCache, _monitors); }\n-  static ByteSize oop_to_monitor_difference() { return monitors_offset() - oops_offset(); }\n+  static ByteSize entries() { return byte_offset_of(OMCache, _entries); }\n+  static constexpr ByteSize oop_to_oop_difference() { return in_ByteSize(sizeof(OMCacheEntry)); }\n+  static constexpr ByteSize oop_to_monitor_difference() { return in_ByteSize(sizeof(oop)); }\n@@ -152,1 +154,1 @@\n-  explicit OMCache(JavaThread* jt) : _oops(), _null_sentinel(nullptr), _monitors() {};\n+  explicit OMCache(JavaThread* jt);\n","filename":"src\/hotspot\/share\/runtime\/lockStack.hpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -250,1 +250,2 @@\n-  oop cmp_obj = obj;\n+  OMCacheEntry to_insert = {obj, monitor};\n+\n@@ -252,5 +253,5 @@\n-    if (_oops[i] == cmp_obj ||\n-        _monitors[i] == nullptr ||\n-        _monitors[i]->is_being_async_deflated()) {\n-      _oops[i] = obj;\n-      _monitors[i] = monitor;\n+    if (_entries[i]._oop == obj ||\n+        _entries[i]._monitor == nullptr ||\n+        _entries[i]._monitor->is_being_async_deflated()) {\n+      \/\/ Use stale slot.\n+      _entries[i] = to_insert;\n@@ -259,9 +260,2 @@\n-    \/\/ Remember Most Recent Values\n-    oop tmp_oop = obj;\n-    ObjectMonitor* tmp_mon = monitor;\n-    \/\/ Set next pair to the next most recent\n-    obj = _oops[i];\n-    monitor = _monitors[i];\n-    \/\/ Store most recent values\n-    _oops[i] = tmp_oop;\n-    _monitors[i] = tmp_mon;\n+    \/\/ Swap with the most recent value.\n+    ::swap(to_insert, _entries[i]);\n@@ -269,2 +263,1 @@\n-  _oops[end] = obj;\n-  _monitors[end] = monitor;\n+  _entries[end] = to_insert;\n@@ -275,3 +268,3 @@\n-    if (_oops[i] == o) {\n-      assert(_monitors[i] != nullptr, \"monitor must exist\");\n-      if (_monitors[i]->is_being_async_deflated()) {\n+    if (_entries[i]._oop == o) {\n+      assert(_entries[i]._monitor != nullptr, \"monitor must exist\");\n+      if (_entries[i]._monitor->is_being_async_deflated()) {\n@@ -281,2 +274,1 @@\n-          _oops[i] = _oops[i + 1];\n-          _monitors[i] =  _monitors[i + 1];\n+          _entries[i] = _entries[i + 1];\n@@ -284,3 +276,2 @@\n-        \/\/ i == CAPACITY - 1\n-        _oops[i] = nullptr;\n-        _monitors[i] = nullptr;\n+        \/\/ Clear end\n+        _entries[i] = {};\n@@ -289,1 +280,1 @@\n-      return _monitors[i];\n+      return _entries[i]._monitor;\n@@ -297,2 +288,2 @@\n-    _oops[i] = nullptr;\n-    _monitors[i] = nullptr;\n+    \/\/ Clear\n+    _entries[i] = {};\n","filename":"src\/hotspot\/share\/runtime\/lockStack.inline.hpp","additions":19,"deletions":28,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+    public volatile Object lockObject4Inflated;\n@@ -67,0 +68,1 @@\n+        lockObject4Inflated = new Object();\n@@ -73,0 +75,3 @@\n+          synchronized (lockObject4Inflated) {\n+            lockObject4Inflated.wait(1);\n+          }\n@@ -208,0 +213,26 @@\n+    \/** Perform two synchronized after each other on the same object. *\/\n+    @Benchmark\n+    public void testInflatedMultipleSerialLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                dummyInt1++;\n+            }\n+            synchronized (lockObject4Inflated) {\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform two synchronized after each other on the same object. *\/\n+    @Benchmark\n+    public void testInflatedMultipleRecursiveLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                dummyInt1++;\n+                synchronized (lockObject4Inflated) {\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lang\/LockUnlock.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"}]}