{"files":[{"patch":"@@ -183,0 +183,1 @@\n+          --with-jvm-features=-shenandoahgc,-zgc\n@@ -548,0 +549,1 @@\n+          --with-jvm-features=-shenandoahgc,-zgc\n@@ -647,0 +649,1 @@\n+          --with-jvm-features=-shenandoahgc,-zgc\n@@ -923,0 +926,1 @@\n+          --with-jvm-features=-shenandoahgc,-zgc\n@@ -1036,0 +1040,1 @@\n+          --with-jvm-features=-shenandoahgc,-zgc\n@@ -1343,0 +1348,1 @@\n+          --with-jvm-features=-shenandoahgc,-zgc\n@@ -1445,0 +1451,1 @@\n+          --with-jvm-features=-shenandoahgc,-zgc\n","filename":".github\/workflows\/submit.yml","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -119,0 +119,3 @@\n+\n+      PreservedMarks::init_forwarded_mark(obj);\n+\n@@ -141,1 +144,0 @@\n-      PreservedMarks::init_forwarded_mark(obj);\n@@ -161,0 +163,8 @@\n+#ifdef _LP64\n+    else if (obj->is_forwarded()) {\n+      \/\/ Restore klass so that we can safely iterate.\n+      \/\/ TODO: This could probably be built more efficiently into the iterator.\n+      Klass* klass = obj->forwardee()->klass();\n+      obj->set_mark(markWord::prototype().set_klass(klass));\n+    }\n+#endif\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -221,1 +221,0 @@\n-  assert(from_obj->is_objArray(), \"must be obj array\");\n@@ -251,1 +250,0 @@\n-  assert(from_obj->is_objArray(), \"precondition\");\n@@ -431,0 +429,4 @@\n+  if (old_mark.is_marked()) {\n+    \/\/ Already forwarded by somebody else, return forwardee.\n+    return old->forwardee(old_mark);\n+  }\n@@ -433,0 +435,3 @@\n+#ifdef _LP64\n+  Klass* klass = old_mark.safe_klass();\n+#else\n@@ -434,0 +439,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  filler_oop->set_mark(markWord::prototype());\n+  filler_oop->set_mark(Universe::intArrayKlassObj()->prototype_header());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionLAB.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -317,1 +317,0 @@\n-  assert(old->is_objArray(), \"invariant\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -163,1 +163,6 @@\n-  size_t new_obj_size = o->size();\n+#ifdef _LP64\n+  Klass* klass = test_mark.safe_klass();\n+#else\n+  Klass* klass = o->klass();\n+#endif\n+  size_t new_obj_size = o->size_given_klass(klass);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  obj->set_mark(markWord::prototype().set_marked());\n+  obj->set_mark(obj->klass()->prototype_header().set_marked());\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -211,4 +211,0 @@\n-  if (is_in(object->klass_or_null())) {\n-    return false;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,1 +51,14 @@\n-  obj->init_mark();\n+  assert(obj->is_forwarded(), \"only forwarded here\");\n+#ifdef _LP64\n+  oop forwardee = obj->forwardee();\n+  markWord header = forwardee->mark();\n+  if (header.has_displaced_mark_helper()) {\n+    header = header.displaced_mark_helper();\n+  }\n+  assert(UseCompressedClassPointers, \"assume +UseCompressedClassPointers\");\n+  narrowKlass nklass = header.narrow_klass();\n+  assert(nklass == obj->narrow_klass_legacy(), \"narrow klass must match: header: \" PTR_FORMAT \", nklass: \" PTR_FORMAT, forwardee->mark().value(), uintptr_t(nklass));\n+  obj->set_mark(markWord::prototype().set_narrow_klass(nklass));\n+#else\n+  obj->set_mark(markWord::prototype());\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.inline.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -90,0 +90,3 @@\n+  if (header.has_displaced_mark_helper()) {\n+    header = header.displaced_mark_helper();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-  static void trace_reference_gc(const char *s, oop obj) NOT_DEBUG_RETURN;\n+  void trace_reference_gc(const char *s, oop obj) NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/oops\/instanceRefKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-  if (java_lang_ref_Reference::is_phantom(obj)) {\n+  if (reference_type() == REF_PHANTOM) {\n","filename":"src\/hotspot\/share\/oops\/instanceRefKlass.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,21 +97,0 @@\n-\n-#ifdef _LP64\n-narrowKlass markWord::narrow_klass() const {\n-  return narrowKlass(value() >> klass_shift);\n-}\n-\n-Klass* markWord::klass() const {\n-  return CompressedKlassPointers::decode(narrow_klass());\n-}\n-\n-markWord markWord::set_narrow_klass(const narrowKlass nklass) const {\n-  return markWord((value() & ~klass_mask_in_place) | ((uintptr_t) nklass << klass_shift));\n-}\n-\n-markWord markWord::set_klass(const Klass* klass) const {\n-  assert(UseCompressedClassPointers, \"expect compressed klass pointers\");\n-  \/\/ TODO: Don't cast to non-const, change CKP::encode() to accept const Klass* instead.\n-  narrowKlass nklass = CompressedKlassPointers::encode(const_cast<Klass*>(klass));\n-  return set_narrow_klass(nklass);\n-}\n-#endif\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -251,4 +251,6 @@\n-  narrowKlass narrow_klass() const;\n-  Klass* klass() const;\n-  markWord set_klass(const Klass* klass) const;\n-  markWord set_narrow_klass(const narrowKlass klass) const;\n+  inline Klass* klass() const;\n+  inline Klass* klass_or_null() const;\n+  inline Klass* safe_klass() const;\n+  inline markWord set_klass(const Klass* klass) const;\n+  inline narrowKlass narrow_klass() const;\n+  inline markWord set_narrow_klass(const narrowKlass klass) const;\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_MARKWORD_INLINE_HPP\n+#define SHARE_OOPS_MARKWORD_INLINE_HPP\n+\n+#include \"oops\/compressedOops.inline.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+\n+#ifdef _LP64\n+narrowKlass markWord::narrow_klass() const {\n+  return narrowKlass(value() >> klass_shift);\n+}\n+\n+Klass* markWord::klass() const {\n+  return CompressedKlassPointers::decode_not_null(narrow_klass());\n+}\n+\n+Klass* markWord::klass_or_null() const {\n+  return CompressedKlassPointers::decode(narrow_klass());\n+}\n+\n+markWord markWord::set_narrow_klass(const narrowKlass nklass) const {\n+  return markWord((value() & ~klass_mask_in_place) | ((uintptr_t) nklass << klass_shift));\n+}\n+\n+Klass* markWord::safe_klass() const {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"only call at safepoint\");\n+  markWord m = *this;\n+  if (m.has_displaced_mark_helper()) {\n+    m = m.displaced_mark_helper();\n+  }\n+  return CompressedKlassPointers::decode_not_null(m.narrow_klass());\n+}\n+\n+markWord markWord::set_klass(const Klass* klass) const {\n+  assert(UseCompressedClassPointers, \"expect compressed klass pointers\");\n+  \/\/ TODO: Don't cast to non-const, change CKP::encode() to accept const Klass* instead.\n+  narrowKlass nklass = CompressedKlassPointers::encode(const_cast<Klass*>(klass));\n+  return set_narrow_klass(nklass);\n+}\n+#endif\n+\n+#endif \/\/ SHARE_OOPS_MARKWORD_INLINE_HPP\n","filename":"src\/hotspot\/share\/oops\/markWord.inline.hpp","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -159,1 +159,0 @@\n-  assert(obj->is_objArray(), \"must be object array\");\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-  assert (obj->is_array(), \"obj must be array\");\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  narrowKlass narrow_klass_legacy() const { return _metadata._compressed_klass; }\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"oops\/markWord.hpp\"\n+#include \"oops\/markWord.inline.hpp\"\n@@ -39,0 +39,2 @@\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/synchronizer.hpp\"\n@@ -83,1 +85,0 @@\n-  markWord header = markWord::prototype();\n@@ -85,0 +86,2 @@\n+  markWord header = ObjectSynchronizer::stable_mark(cast_to_oop(this));\n+  assert(_metadata._compressed_klass == header.narrow_klass(), \"klass must match: \" PTR_FORMAT, header.value());\n@@ -86,3 +89,3 @@\n-  narrowKlass nklass = _metadata._compressed_klass;\n-  assert(nklass != 0, \"expect klass\");\n-  header = header.set_narrow_klass(nklass);\n+  header = markWord((header.value() & markWord::klass_mask_in_place) | markWord::prototype().value());\n+#else\n+  markWord header = markWord::prototype();\n@@ -94,4 +97,5 @@\n-  if (UseCompressedClassPointers) {\n-    return CompressedKlassPointers::decode_not_null(_metadata._compressed_klass);\n-  } else {\n-    return _metadata._klass;\n+#ifdef _LP64\n+  assert(UseCompressedClassPointers, \"only with compressed class pointers\");\n+  markWord header = mark();\n+  if (!header.is_neutral()) {\n+    header = ObjectSynchronizer::stable_mark(cast_to_oop(this));\n@@ -99,0 +103,7 @@\n+  assert(_metadata._compressed_klass == header.narrow_klass(), \"narrow klass must be equal, header: \" INTPTR_FORMAT \", nklass: \" INTPTR_FORMAT, header.value(), intptr_t(_metadata._compressed_klass));\n+  Klass* klass = header.klass();\n+  assert(klass == CompressedKlassPointers::decode_not_null(_metadata._compressed_klass), \"klass must match: header: \" INTPTR_FORMAT \", nklass: \" INTPTR_FORMAT, header.value(), intptr_t(_metadata._compressed_klass));\n+  return klass;\n+#else\n+  return _metadata._klass;\n+#endif\n@@ -102,4 +113,5 @@\n-  if (UseCompressedClassPointers) {\n-    return CompressedKlassPointers::decode(_metadata._compressed_klass);\n-  } else {\n-    return _metadata._klass;\n+#ifdef _LP64\n+  assert(UseCompressedClassPointers, \"only with compressed class pointers\");\n+  markWord header = mark();\n+  if (!header.is_neutral()) {\n+    header = ObjectSynchronizer::stable_mark(cast_to_oop(this));\n@@ -107,0 +119,7 @@\n+  assert(_metadata._compressed_klass == header.narrow_klass(), \"narrow klass must be equal, header: \" INTPTR_FORMAT \", nklass: \" INTPTR_FORMAT, header.value(), intptr_t(_metadata._compressed_klass));\n+  Klass* klass = header.klass_or_null();\n+  assert(klass == CompressedKlassPointers::decode(_metadata._compressed_klass), \"klass must match: header: \" INTPTR_FORMAT \", nklass: \" INTPTR_FORMAT, header.value(), intptr_t(_metadata._compressed_klass));\n+  return klass;\n+#else\n+  return _metadata._klass;\n+#endif\n@@ -110,5 +129,5 @@\n-  if (UseCompressedClassPointers) {\n-    narrowKlass nklass = Atomic::load_acquire(&_metadata._compressed_klass);\n-    return CompressedKlassPointers::decode(nklass);\n-  } else {\n-    return Atomic::load_acquire(&_metadata._klass);\n+#ifdef _LP64\n+  assert(UseCompressedClassPointers, \"only with compressed class pointers\");\n+  markWord header = mark_acquire();\n+  if (!header.is_neutral()) {\n+    header = ObjectSynchronizer::stable_mark(cast_to_oop(this));\n@@ -116,0 +135,7 @@\n+  assert(_metadata._compressed_klass == header.narrow_klass(), \"narrow klass must be equal, header: \" INTPTR_FORMAT \", nklass: \" INTPTR_FORMAT, header.value(), intptr_t(_metadata._compressed_klass));\n+  Klass* klass = header.klass_or_null();\n+  assert(klass == CompressedKlassPointers::decode(_metadata._compressed_klass), \"klass must match: header: \" INTPTR_FORMAT \", nklass: \" INTPTR_FORMAT, header.value(), intptr_t(_metadata._compressed_klass));\n+  return klass;\n+#else\n+  return Atomic::load_acquire(&_metadata._klass);\n+#endif\n@@ -291,1 +317,7 @@\n-  markWord m = mark().set_self_forwarded();\n+  markWord m = mark();\n+  \/\/ If mark is displaced, we need to preserve the Klass* from real header.\n+  assert(SafepointSynchronize::is_at_safepoint(), \"we can only safely fetch the displaced header at safepoint\");\n+  if (m.has_displaced_mark_helper()) {\n+    m = m.displaced_mark_helper();\n+  }\n+  m = m.set_self_forwarded();\n@@ -310,1 +342,7 @@\n-  markWord m = compare.set_self_forwarded();\n+  markWord m = compare;\n+  \/\/ If mark is displaced, we need to preserve the Klass* from real header.\n+  assert(SafepointSynchronize::is_at_safepoint(), \"we can only safely fetch the displaced header at safepoint\");\n+  if (m.has_displaced_mark_helper()) {\n+    m = m.displaced_mark_helper();\n+  }\n+  m = m.set_self_forwarded();\n@@ -389,1 +427,0 @@\n-  assert(k == klass(), \"wrong klass\");\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":58,"deletions":21,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -231,1 +231,0 @@\n-  assert(obj->is_typeArray(),\"must be a type array\");\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-  assert(obj->is_typeArray(),\"must be a type array\");\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1441,1 +1441,1 @@\n-  o->set_mark(markWord::prototype().set_marked());\n+  o->set_mark(o->klass()->prototype_header().set_marked());\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -743,0 +743,23 @@\n+markWord ObjectSynchronizer::stable_mark(const oop obj) {\n+  markWord mark = read_stable_mark(obj);\n+  if (!mark.is_neutral() && !mark.is_marked()) {\n+    if (mark.has_monitor()) {\n+      ObjectMonitor* monitor = mark.monitor();\n+      mark = monitor->header();\n+      assert(mark.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+    } else if (SafepointSynchronize::is_at_safepoint() || Thread::current()->is_lock_owned((address) mark.locker())) {\n+      \/\/ This is a stack lock owned by the calling thread so fetch the\n+      \/\/ displaced markWord from the BasicLock on the stack.\n+      assert(mark.has_displaced_mark_helper(), \"must be displaced header here\");\n+      mark = mark.displaced_mark_helper();\n+      assert(mark.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+    } else {\n+      ObjectMonitor* monitor = inflate(Thread::current(), obj, inflate_cause_vm_internal);\n+      mark = monitor->header();\n+      assert(mark.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+      assert(!mark.is_marked(), \"no forwarded objects here\");\n+    }\n+  }\n+  return mark;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -129,0 +129,2 @@\n+  static markWord stable_mark(const oop obj);\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}