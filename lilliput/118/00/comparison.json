{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import java.nio.ByteBuffer;\n@@ -52,0 +53,13 @@\n+    \/\/ NOTE: We allocate a byte-array that can hold {@code size} number of longs. In the case\n+    \/\/ when the base element would be unaligned for longs, we need to allocate a corresponding\n+    \/\/ head and tail. The head and tail combined must be 8 bytes long (if they are necessary).\n+\n+    \/\/ The index of the first long-aligned array element in a byte array.\n+    private static final int ALIGNED_BASE_INDEX = UNSAFE.ARRAY_BYTE_BASE_OFFSET % Long.BYTES;\n+\n+    \/\/ The unsafe offset of the first long-aligned array element in a byte array.\n+    private static final int ALIGNED_BASE_OFFSET = UNSAFE.ARRAY_BYTE_BASE_OFFSET + ALIGNED_BASE_INDEX;\n+\n+    \/\/ The number of bytes in the alignment 'tail'.\n+    private static final int ALIGNED_END_OFFSET = (Long.BYTES - ALIGNED_BASE_INDEX) % Long.BYTES;\n+\n@@ -63,1 +77,4 @@\n-    static byte[] byteArray = new byte[size * 8];\n+    \/\/ Array length in bytes. If base is unaligned, add space for leading and trailing bytes.\n+    static int arrayLengthBytes = (size + (ALIGNED_BASE_INDEX == 0 ? 0 : 1)) * 8;\n+\n+    static byte[] byteArray = new byte[arrayLengthBytes];\n@@ -65,1 +82,1 @@\n-    static byte[] verifyByteArray = new byte[size * 8];\n+    static byte[] verifyByteArray = new byte[arrayLengthBytes];\n@@ -78,1 +95,1 @@\n-                verifyLongArray[i] = verifyLongArray[i] | (((long)verifyByteArray[8 * i + j]) << 8 * j);\n+                verifyLongArray[i] = verifyLongArray[i] | (((long)verifyByteArray[8 * i + j + ALIGNED_BASE_INDEX]) << 8 * j);\n@@ -88,1 +105,2 @@\n-        for (i = 0; i < Math.max(offset, 0); i++) {\n+        \/\/ Check head (including possibly unaligned part). Those elements must be zero.\n+        for (i = 0; i < Math.max(offset, 0) + ALIGNED_BASE_INDEX; i++) {\n@@ -93,1 +111,3 @@\n-        for (; i < Math.min(byteArray.length + offset, byteArray.length); i++) {\n+        \/\/ Check the copied body bytes.\n+        int alignedArrayEnd = byteArray.length - ALIGNED_END_OFFSET;\n+        for (; i < Math.min(alignedArrayEnd + offset, alignedArrayEnd); i++) {\n@@ -98,0 +118,1 @@\n+        \/\/ Check the tail (including possibly unaligned part). Those elements must be zero.\n@@ -109,1 +130,2 @@\n-        for (i = 0; i < Math.max(offset, 0); i++) {\n+        \/\/ Check head (including possibly unaligned part). Those elements must be equal.\n+        for (i = 0; i < Math.max(offset, 0) + ALIGNED_BASE_INDEX; i++) {\n@@ -114,2 +136,16 @@\n-        for (; i < Math.min(byteArray.length + offset, byteArray.length); i++) {\n-            int val = offset > 0 ? verifyByteArray[(i-offset) % 8] : verifyByteArray[i-offset];\n+        \/\/ Check the copied body bytes.\n+        \/\/\n+        \/\/ When the offset is negative (i.e. backwarts-copy within the array),\n+        \/\/ the elements at i in byteArray must match the elements at i + offset\n+        \/\/ in the verifyByteArray.\n+        \/\/\n+        \/\/ When the offset is positive (i.e. forward-copy within the array),\n+        \/\/ the same 8 elements would have been copied over and over again, and\n+        \/\/ thus every 8-bytes-block must match the first 8 bytes.\n+        int alignedArrayEnd = byteArray.length - ALIGNED_END_OFFSET;\n+        for (; i < Math.min(alignedArrayEnd + offset, alignedArrayEnd); i++) {\n+            int idx = i - offset;\n+            if (offset > 0) {\n+                idx = (idx - ALIGNED_BASE_INDEX) % 8 + ALIGNED_BASE_INDEX;\n+            }\n+            int val = verifyByteArray[idx];\n@@ -120,0 +156,1 @@\n+        \/\/ Check the tail (including possibly unaligned part). Those elements must be equal.\n@@ -130,1 +167,1 @@\n-        for (int i = 0; i < size * 8; i++) {\n+        for (int i = 0; i < arrayLengthBytes; i++) {\n@@ -141,2 +178,2 @@\n-            if (UNSAFE.getByte(null, baseOffHeap + i) != verifyByteArray[i - offset]) {\n-                throw new RuntimeException(\"Incorrect result at \" + i + \" \" + byteArray[i] + \" != \" + verifyByteArray[i-offset]);\n+            if (UNSAFE.getByte(null, baseOffHeap + i) != verifyByteArray[i - offset + ALIGNED_BASE_INDEX]) {\n+                throw new RuntimeException(\"Incorrect result at \" + i + \" \" + byteArray[i] + \" != \" + verifyByteArray[i-offset + ALIGNED_BASE_INDEX]);\n@@ -156,1 +193,1 @@\n-            UNSAFE.putLongUnaligned(dest, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8 * i, src[i]);\n+            UNSAFE.putLongUnaligned(dest, ALIGNED_BASE_OFFSET + 8 * i, src[i]);\n@@ -169,1 +206,1 @@\n-            UNSAFE.putLongUnaligned(dest, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8 * (i - 1), src[i]);\n+            UNSAFE.putLongUnaligned(dest, ALIGNED_BASE_OFFSET + 8 * (i - 1), src[i]);\n@@ -182,1 +219,1 @@\n-            UNSAFE.putLongUnaligned(dest, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8 * (i + 1), src[i]);\n+            UNSAFE.putLongUnaligned(dest, ALIGNED_BASE_OFFSET + 8 * (i + 1), src[i]);\n@@ -201,1 +238,1 @@\n-        baseOffset = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+        baseOffset = ALIGNED_BASE_OFFSET;\n@@ -209,1 +246,1 @@\n-            UNSAFE.putLongUnaligned(dest, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8 * (i + baseOffset), src[i]);\n+            UNSAFE.putLongUnaligned(dest, ALIGNED_BASE_OFFSET + 8 * (i + baseOffset), src[i]);\n@@ -219,0 +256,10 @@\n+    static int alignedStartOffset() {\n+        int unitSize = 8;\n+        return UNSAFE.ARRAY_BYTE_BASE_OFFSET % unitSize;\n+    }\n+\n+    static int alignedEndOffset() {\n+        int unitSize = 8;\n+        return (unitSize - alignedStartOffset()) % unitSize;\n+    }\n+\n@@ -222,2 +269,3 @@\n-        for (int i = 0; i < src.length \/ 8; i++) {\n-            UNSAFE.putLongUnaligned(dest, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8 * i, UNSAFE.getLongUnaligned(src, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8 * i));\n+        int offset = ALIGNED_BASE_OFFSET;\n+        for (int i = 0; i < size; i++) {\n+            UNSAFE.putLongUnaligned(dest, offset + 8 * i, UNSAFE.getLongUnaligned(src, offset + 8 * i));\n@@ -235,2 +283,3 @@\n-        for (int i = 1; i < src.length \/ 8; i++) {\n-            UNSAFE.putLongUnaligned(dest, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8 * (i - 1), UNSAFE.getLongUnaligned(src, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8 * i));\n+        int offset = ALIGNED_BASE_OFFSET;\n+        for (int i = 1; i < size; i++) {\n+            UNSAFE.putLongUnaligned(dest, offset + 8 * (i - 1), UNSAFE.getLongUnaligned(src, offset + 8 * i));\n@@ -248,2 +297,3 @@\n-        for (int i = 0; i < src.length \/ 8 - 1; i++) {\n-            UNSAFE.putLongUnaligned(dest, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8 * (i + 1), UNSAFE.getLongUnaligned(src, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8 * i));\n+        int offset = ALIGNED_BASE_OFFSET;\n+        for (int i = 0; i < size - 1; i++) {\n+            UNSAFE.putLongUnaligned(dest, offset + 8 * (i + 1), UNSAFE.getLongUnaligned(src, offset + 8 * i));\n@@ -262,1 +312,1 @@\n-            UNSAFE.putLongUnaligned(dest, 8 * i + baseOffset, UNSAFE.getLongUnaligned(src, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8 * i));\n+            UNSAFE.putLongUnaligned(dest, 8 * i + baseOffset, UNSAFE.getLongUnaligned(src, ALIGNED_BASE_OFFSET + 8 * i));\n@@ -268,1 +318,1 @@\n-        baseOffset = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+        baseOffset = ALIGNED_BASE_OFFSET;\n@@ -276,1 +326,1 @@\n-            UNSAFE.putLongUnaligned(dest, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8 * (i + baseOffset), UNSAFE.getLongUnaligned(src, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8 * i));\n+            UNSAFE.putLongUnaligned(dest, ALIGNED_BASE_OFFSET + 8 * (i + baseOffset), UNSAFE.getLongUnaligned(src, ALIGNED_BASE_OFFSET + 8 * i));\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizationMismatchedAccess.java","additions":75,"deletions":25,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -44,0 +44,3 @@\n+    \/\/ The unsafe offset of the first long-aligned array element in a byte array.\n+    private static final int ALIGNED_BASE_OFFSET = UNSAFE.ARRAY_BYTE_BASE_OFFSET + UNSAFE.ARRAY_BYTE_BASE_OFFSET % Long.BYTES;\n+\n@@ -49,1 +52,1 @@\n-    static int sizeBytes = 8 * size;\n+    static int sizeBytes = 8 * size + 8;\n@@ -60,1 +63,1 @@\n-            UNSAFE.putLongUnaligned(dest, UNSAFE.ARRAY_BYTE_BASE_OFFSET + i * 8, src[i]);\n+            UNSAFE.putLongUnaligned(dest, ALIGNED_BASE_OFFSET + i * 8, src[i]);\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizationNotRun.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -144,1 +144,2 @@\n-                    \"LogCompilation\"\n+                    \"LogCompilation\",\n+                    \"UseCompactObjectHeaders\"\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -256,0 +256,3 @@\n+    private static final int ALIGNED_INT_BASE_OFFSET   = unsafe.ARRAY_INT_BASE_OFFSET   + unsafe.ARRAY_INT_BASE_OFFSET   % Long.BYTES;\n+    private static final int ALIGNED_FLOAT_BASE_OFFSET = unsafe.ARRAY_FLOAT_BASE_OFFSET + unsafe.ARRAY_FLOAT_BASE_OFFSET % Long.BYTES;\n+\n@@ -258,2 +261,2 @@\n-        int[]   dataI = new int[RANGE];\n-        float[] dataF = new float[RANGE];\n+        int[]   dataI = new int[RANGE + Long.BYTES];\n+        float[] dataF = new float[RANGE + Long.BYTES];\n@@ -275,6 +278,6 @@\n-            int v00 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0) + 3;\n-            int v01 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4) + 3;\n-            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0, v00);\n-            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4, v01);\n-            int v10 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0) * 45;\n-            int v11 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4) * 45;\n+            int v00 = unsafe.getInt(dataIa, ALIGNED_INT_BASE_OFFSET + 4 * i + 0) + 3;\n+            int v01 = unsafe.getInt(dataIa, ALIGNED_INT_BASE_OFFSET + 4 * i + 4) + 3;\n+            unsafe.putInt(dataFa, ALIGNED_FLOAT_BASE_OFFSET + 4 * i + 0, v00);\n+            unsafe.putInt(dataFa, ALIGNED_FLOAT_BASE_OFFSET + 4 * i + 4, v01);\n+            int v10 = unsafe.getInt(dataFb, ALIGNED_FLOAT_BASE_OFFSET + 4 * i + 0) * 45;\n+            int v11 = unsafe.getInt(dataFb, ALIGNED_FLOAT_BASE_OFFSET + 4 * i + 4) * 45;\n@@ -285,2 +288,2 @@\n-            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0, v20);\n-            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4, v21);\n+            unsafe.putFloat(dataIb, ALIGNED_INT_BASE_OFFSET + 4 * i + 0, v20);\n+            unsafe.putFloat(dataIb, ALIGNED_INT_BASE_OFFSET + 4 * i + 4, v21);\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestIndependentPacksWithCyclicDependency.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"}]}