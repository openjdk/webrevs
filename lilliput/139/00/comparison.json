{"files":[{"patch":"@@ -564,53 +564,3 @@\n-  if (!OMUseC2Cache) {\n-    \/\/ Set Flags == NE\n-    cmp(zr, obj);\n-    b(slow_path);\n-  } else {\n-\n-    if (OMCacheHitRate) increment(Address(rthread, JavaThread::lock_lookup_offset()));\n-\n-    Label monitor_found, loop;\n-    \/\/ Load cache address\n-    lea(t, Address(rthread, JavaThread::om_cache_oops_offset()));\n-\n-    \/\/ Search for obj in cache.\n-    bind(loop);\n-\n-    \/\/ Check for match.\n-    ldr(t1, Address(t));\n-    cmp(obj, t1);\n-    br(Assembler::EQ, monitor_found);\n-\n-    \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n-    increment(t, oopSize);\n-    cbnz(t1, loop);\n-    \/\/ Cache Miss, NE set from cmp above, cbnz does not set flags\n-    b(slow_path);\n-\n-    bind(monitor_found);\n-    ldr(t1, Address(t, OMCache::oop_to_monitor_difference()));\n-    if (OMCacheHitRate) increment(Address(rthread, JavaThread::lock_hit_offset()));\n-\n-    \/\/ ObjectMonitor* is in t1\n-    const Register monitor = t1;\n-    const Register owner_addr = t2;\n-    const Register owner = t3;\n-\n-    Label recursive;\n-    Label monitor_locked;\n-\n-    \/\/ Compute owner address.\n-    lea(owner_addr, Address(monitor, ObjectMonitor::owner_offset()));\n-\n-    if (OMRecursiveFastPath) {\n-      ldr(owner, Address(owner_addr));\n-      cmp(owner, rthread);\n-      br(Assembler::EQ, recursive);\n-    }\n-\n-    \/\/ CAS owner (null => current thread).\n-    cmpxchg(owner_addr, zr, rthread, Assembler::xword, \/*acquire*\/ true,\n-            \/*release*\/ false, \/*weak*\/ false, owner);\n-    br(Assembler::EQ, monitor_locked);\n-\n-    if (OMRecursiveFastPath) {\n+    if (!OMUseC2Cache) {\n+      \/\/ Set Flags == NE\n+      cmp(zr, obj);\n@@ -619,8 +569,0 @@\n-      \/\/ Check if recursive.\n-      cmp(owner, rthread);\n-      br(Assembler::NE, slow_path);\n-    }\n-\n-    \/\/ Recursive.\n-    bind(recursive);\n-    increment(Address(monitor, ObjectMonitor::recursions_offset()), 1);\n@@ -628,3 +570,84 @@\n-    bind(monitor_locked);\n-    str(monitor, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-  }\n+      if (OMCacheHitRate) increment(Address(rthread, JavaThread::lock_lookup_offset()));\n+\n+      Label monitor_found;\n+\n+      \/\/ Load cache address\n+      lea(t, Address(rthread, JavaThread::om_cache_oops_offset()));\n+\n+      const int num_unrolled = OMC2UnrollCacheLookup ? MIN2(OMC2UnrollCacheEntires, OMCacheSize) : 0;\n+      if (OMC2UnrollCacheLookup) {\n+        for (int i = 0; i < num_unrolled; i++) {\n+          ldr(t1, Address(t));\n+          cmp(obj, t1);\n+          br(Assembler::EQ, monitor_found);\n+          if (i + 1 != num_unrolled) {\n+            increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+          }\n+        }\n+      }\n+      if (!OMC2UnrollCacheLookup || (OMC2UnrollCacheLookupLoopTail && num_unrolled != OMCacheSize)) {\n+        if (num_unrolled != 0) {\n+          \/\/ Loop after unrolling, advance iterator.\n+          increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+        }\n+\n+        Label loop;\n+\n+        \/\/ Search for obj in cache.\n+        bind(loop);\n+\n+        \/\/ Check for match.\n+        ldr(t1, Address(t));\n+        cmp(obj, t1);\n+        br(Assembler::EQ, monitor_found);\n+\n+        \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n+        increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+        cbnz(t1, loop);\n+        \/\/ Cache Miss, NE set from cmp above, cbnz does not set flags\n+        b(slow_path);\n+      } else {\n+        b(slow_path);\n+      }\n+\n+      bind(monitor_found);\n+      ldr(t1, Address(t, OMCache::oop_to_monitor_difference()));\n+      if (OMCacheHitRate) increment(Address(rthread, JavaThread::lock_hit_offset()));\n+\n+      \/\/ ObjectMonitor* is in t1\n+      const Register monitor = t1;\n+      const Register owner_addr = t2;\n+      const Register owner = t3;\n+\n+      Label recursive;\n+      Label monitor_locked;\n+\n+      \/\/ Compute owner address.\n+      lea(owner_addr, Address(monitor, ObjectMonitor::owner_offset()));\n+\n+      if (OMRecursiveFastPath) {\n+        ldr(owner, Address(owner_addr));\n+        cmp(owner, rthread);\n+        br(Assembler::EQ, recursive);\n+      }\n+\n+      \/\/ CAS owner (null => current thread).\n+      cmpxchg(owner_addr, zr, rthread, Assembler::xword, \/*acquire*\/ true,\n+              \/*release*\/ false, \/*weak*\/ false, owner);\n+      br(Assembler::EQ, monitor_locked);\n+\n+      if (OMRecursiveFastPath) {\n+        b(slow_path);\n+      } else {\n+        \/\/ Check if recursive.\n+        cmp(owner, rthread);\n+        br(Assembler::NE, slow_path);\n+      }\n+\n+      \/\/ Recursive.\n+      bind(recursive);\n+      increment(Address(monitor, ObjectMonitor::recursions_offset()), 1);\n+\n+      bind(monitor_locked);\n+      str(monitor, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":87,"deletions":64,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -1261,1 +1261,2 @@\n-      Label monitor_found, loop;\n+      Label monitor_found;\n+\n@@ -1265,12 +1266,33 @@\n-      \/\/ Search for obj in cache.\n-      bind(loop);\n-\n-      \/\/ Check for match.\n-      cmpptr(obj, Address(t));\n-      jccb(Assembler::equal, monitor_found);\n-\n-      \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n-      cmpptr(Address(t), 1);\n-      jcc(Assembler::below, slow_path); \/\/ 0 check, but with ZF=0 when *t == 0\n-      increment(t, oopSize);\n-      jmpb(loop);\n+      const int num_unrolled = OMC2UnrollCacheLookup ? MIN2(OMC2UnrollCacheEntires, OMCacheSize) : 0;\n+      if (OMC2UnrollCacheLookup) {\n+        for (int i = 0; i < num_unrolled; i++) {\n+          cmpptr(obj, Address(t));\n+          jccb(Assembler::equal, monitor_found);\n+          if (i + 1 != num_unrolled) {\n+            increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+          }\n+        }\n+      }\n+      if (!OMC2UnrollCacheLookup || (OMC2UnrollCacheLookupLoopTail && num_unrolled != OMCacheSize)) {\n+        if (num_unrolled != 0) {\n+          \/\/ Loop after unrolling, advance iterator.\n+          increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+        }\n+\n+        Label loop;\n+\n+        \/\/ Search for obj in cache.\n+        bind(loop);\n+\n+        \/\/ Check for match.\n+        cmpptr(obj, Address(t));\n+        jccb(Assembler::equal, monitor_found);\n+\n+        \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n+        cmpptr(Address(t), 1);\n+        jcc(Assembler::below, slow_path); \/\/ 0 check, but with ZF=0 when *t == 0\n+        increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+        jmpb(loop);\n+      } else {\n+        jmp(slow_path);\n+      }\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":35,"deletions":13,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1993,0 +1993,7 @@\n+  product(bool, OMC2UnrollCacheLookup, false, \"\")                           \\\n+                                                                            \\\n+  product(bool, OMC2UnrollCacheLookupLoopTail, true, \"\")                    \\\n+                                                                            \\\n+  product(int, OMC2UnrollCacheEntires, 8, \"\")                               \\\n+          range(0, OMCache::CAPACITY)                                       \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -150,0 +150,1 @@\n+  static ByteSize oop_to_oop_difference() { return in_ByteSize(sizeof(oop)); }\n","filename":"src\/hotspot\/share\/runtime\/lockStack.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+    public volatile Object lockObject4Inflated;\n@@ -67,0 +68,1 @@\n+        lockObject4Inflated = new Object();\n@@ -73,0 +75,3 @@\n+          synchronized (lockObject4Inflated) {\n+            lockObject4Inflated.wait(1);\n+          }\n@@ -208,0 +213,26 @@\n+    \/** Perform two synchronized after each other on the same object. *\/\n+    @Benchmark\n+    public void testInflatedMultipleSerialLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                dummyInt1++;\n+            }\n+            synchronized (lockObject4Inflated) {\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform two synchronized after each other on the same object. *\/\n+    @Benchmark\n+    public void testInflatedMultipleRecursiveLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                dummyInt1++;\n+                synchronized (lockObject4Inflated) {\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lang\/LockUnlock.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"}]}