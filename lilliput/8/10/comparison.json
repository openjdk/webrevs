{"files":[{"patch":"@@ -86,0 +86,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -1609,0 +1610,2 @@\n+  _forwarding = new SlidingForwarding<5>(heap_rs.region(), HeapRegion::LogOfHRGrainBytes - LogHeapWordSize);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -105,0 +105,2 @@\n+template <int N>\n+class SlidingForwarding;\n@@ -250,0 +252,2 @@\n+  SlidingForwarding<5>* _forwarding;\n+\n@@ -282,0 +286,4 @@\n+  SlidingForwarding<5>* forwarding() const {\n+    return _forwarding;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -304,0 +304,1 @@\n+  _heap->forwarding()->clear();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -98,1 +98,2 @@\n-  marker->preserved_stack()->adjust_during_full_gc();\n+  const SlidingForwarding<5>* const forwarding = G1CollectedHeap::heap()->forwarding();\n+  marker->preserved_stack()->adjust_during_full_gc(forwarding);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -67,1 +68,1 @@\n-  HeapWord* destination = cast_from_oop<HeapWord*>(obj->forwardee());\n+  HeapWord* destination = cast_from_oop<HeapWord*>(_forwarding->forwardee(obj));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+template <int N>\n+class SlidingForwarding;\n@@ -53,1 +55,1 @@\n-\n+    const SlidingForwarding<5>* const _forwarding;\n@@ -55,1 +57,3 @@\n-    G1CompactRegionClosure(G1CMBitMap* bitmap) : _bitmap(bitmap) { }\n+    G1CompactRegionClosure(G1CMBitMap* bitmap) :\n+      _bitmap(bitmap),\n+      _forwarding(G1CollectedHeap::heap()->forwarding()) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -96,1 +97,1 @@\n-void G1FullGCCompactionPoint::forward(oop object, size_t size) {\n+void G1FullGCCompactionPoint::forward(SlidingForwarding<5>* const forwarding, oop object, size_t size) {\n@@ -106,1 +107,1 @@\n-    object->forward_to(cast_to_oop(_compaction_top));\n+    forwarding->forward_to(object, cast_to_oop(_compaction_top));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+template <int N>\n+class SlidingForwarding;\n@@ -54,1 +56,1 @@\n-  void forward(oop object, size_t size);\n+  void forward(SlidingForwarding<5>* const forwarding, oop object, size_t size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n@@ -31,1 +32,0 @@\n-class G1CollectedHeap;\n@@ -35,0 +35,2 @@\n+template <int N>\n+class SlidingForwarding;\n@@ -82,1 +84,1 @@\n-\n+  const SlidingForwarding<5>* const _forwarding;\n@@ -85,1 +87,3 @@\n-  G1AdjustClosure(G1FullCollector* collector) : _collector(collector) { }\n+  G1AdjustClosure(G1FullCollector* collector) :\n+    _collector(collector),\n+    _forwarding(G1CollectedHeap::heap()->forwarding()) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -90,2 +91,2 @@\n-  oop forwardee = obj->forwardee();\n-  assert(G1CollectedHeap::heap()->is_in_reserved(forwardee), \"should be in object space\");\n+  oop forwardee = _forwarding->forwardee(obj);\n+  assert(G1CollectedHeap::heap()->is_in_reserved(forwardee), \"should be in object space: \" PTR_FORMAT \"(\" PTR_FORMAT \", \" PTR_FORMAT \") \" INTPTR_FORMAT, p2i(forwardee), p2i(G1CollectedHeap::heap()->reserved().start()), p2i(G1CollectedHeap::heap()->reserved().end()), obj->mark().value());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -160,1 +161,1 @@\n-    _cp(cp) { }\n+    _cp(cp), _forwarding(G1CollectedHeap::heap()->forwarding()) { }\n@@ -164,1 +165,1 @@\n-  _cp->forward(object, size);\n+  _cp->forward(_forwarding, object, size);\n@@ -171,3 +172,5 @@\n-  oop forwarded_to = obj->forwardee();\n-  if (obj->is_forwarded() && !_current->is_in(forwarded_to)) {\n-    return obj->size();\n+  if (obj->is_forwarded()) {\n+    oop forwarded_to = _forwarding->forwardee(obj);\n+    if (!_current->is_in(forwarded_to)) {\n+      return obj->size();\n+    }\n@@ -178,1 +181,1 @@\n-  _cp->forward(obj, size);\n+  _cp->forward(_forwarding, obj, size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+template <int N>\n+class SlidingForwarding;\n@@ -79,1 +81,1 @@\n-\n+    SlidingForwarding<5>* const _forwarding;\n@@ -88,1 +90,1 @@\n-\n+    SlidingForwarding<5>* const _forwarding;\n@@ -93,1 +95,2 @@\n-        _current(hr) { }\n+        _current(hr),\n+        _forwarding(G1CollectedHeap::heap()->forwarding()) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -274,0 +274,2 @@\n+  AdjustPointerClosure adjust_pointer_closure(gch->forwarding());\n+  CLDToOopClosure adjust_cld_closure(&adjust_pointer_closure, ClassLoaderData::_claim_strong);\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/genCollectedHeap.hpp\"\n@@ -65,1 +66,0 @@\n-CLDToOopClosure    MarkSweep::adjust_cld_closure(&adjust_pointer_closure, ClassLoaderData::_claim_strong);\n@@ -147,2 +147,2 @@\n-void PreservedMark::adjust_pointer() {\n-  MarkSweep::adjust_pointer(&_obj);\n+void PreservedMark::adjust_pointer(const SlidingForwarding<1>* const forwarding) {\n+  MarkSweep::adjust_pointer(forwarding, &_obj);\n@@ -176,2 +176,0 @@\n-AdjustPointerClosure MarkSweep::adjust_pointer_closure;\n-\n@@ -182,0 +180,2 @@\n+  const SlidingForwarding<1>* const forwarding = GenCollectedHeap::heap()->forwarding();\n+\n@@ -184,1 +184,1 @@\n-    _preserved_marks[i].adjust_pointer();\n+    _preserved_marks[i].adjust_pointer(forwarding);\n@@ -191,1 +191,1 @@\n-    adjust_pointer(p);\n+    adjust_pointer(forwarding, p);\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+template <int N>\n+class SlidingForwarding;\n@@ -127,2 +129,0 @@\n-  static AdjustPointerClosure adjust_pointer_closure;\n-  static CLDToOopClosure      adjust_cld_closure;\n@@ -145,1 +145,1 @@\n-  static int adjust_pointers(oop obj);\n+  static int adjust_pointers(const SlidingForwarding<1>* const forwarding, oop obj);\n@@ -153,1 +153,1 @@\n-  template <class T> static inline void adjust_pointer(T* p);\n+  template <class T> static inline void adjust_pointer(const SlidingForwarding<1>* const forwarding, T* p);\n@@ -189,0 +189,2 @@\n+private:\n+  const SlidingForwarding<1>* const _forwarding;\n@@ -190,0 +192,1 @@\n+  AdjustPointerClosure(const SlidingForwarding<1>* forwarding) : _forwarding(forwarding) {}\n@@ -207,1 +210,1 @@\n-  void adjust_pointer();\n+  void adjust_pointer(const SlidingForwarding<1>* const forwarding);\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -77,1 +78,1 @@\n-template <class T> inline void MarkSweep::adjust_pointer(T* p) {\n+template <class T> inline void MarkSweep::adjust_pointer(const SlidingForwarding<1>* const forwarding, T* p) {\n@@ -85,1 +86,1 @@\n-      oop new_obj = cast_to_oop(header.decode_pointer());\n+      oop new_obj = forwarding->forwardee(obj);\n@@ -94,1 +95,1 @@\n-void AdjustPointerClosure::do_oop_work(T* p)           { MarkSweep::adjust_pointer(p); }\n+void AdjustPointerClosure::do_oop_work(T* p)           { MarkSweep::adjust_pointer(_forwarding, p); }\n@@ -99,2 +100,3 @@\n-inline int MarkSweep::adjust_pointers(oop obj) {\n-  return obj->oop_iterate_size(&MarkSweep::adjust_pointer_closure);\n+inline int MarkSweep::adjust_pointers(const SlidingForwarding<1>* const forwarding, oop obj) {\n+  AdjustPointerClosure cl(forwarding);\n+  return obj->oop_iterate_size(&cl);\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -123,0 +124,1 @@\n+  _forwarding = new SlidingForwarding<1>(_reserved);\n@@ -1101,0 +1103,1 @@\n+  _forwarding->clear();\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+template <int N>\n+class SlidingForwarding;\n@@ -91,0 +93,2 @@\n+  SlidingForwarding<1>* _forwarding;\n+\n@@ -333,0 +337,4 @@\n+  SlidingForwarding<1>* forwarding() const {\n+    return _forwarding;\n+  }\n+\n@@ -435,0 +443,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/slidingForwarding.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+template <int N>\n+class SlidingForwarding;\n@@ -68,0 +70,3 @@\n+  template<int NUM_REGION_BITS>\n+  void adjust_during_full_gc(const SlidingForwarding<NUM_REGION_BITS>* const forwarding);\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -66,0 +66,13 @@\n+template <int NUM_REGION_BITS>\n+void PreservedMarks::adjust_during_full_gc(const SlidingForwarding<NUM_REGION_BITS>* const forwarding) {\n+  StackIterator<OopAndMarkWord, mtGC> iter(_stack);\n+  while (!iter.is_empty()) {\n+    OopAndMarkWord* elem = iter.next_addr();\n+\n+    oop obj = elem->get_oop();\n+    if (obj->is_forwarded()) {\n+      elem->set_oop(forwarding->forwardee(obj));\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.inline.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_SLIDINGFORWARDING_HPP\n+#define SHARE_GC_SHARED_SLIDINGFORWARDING_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/memRegion.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+\/**\n+ * SlidingForwarding is a method to store forwarding information in a compressed form into the object header,\n+ * that has been specifically designed for sliding compaction GCs.\n+ * It avoids overriding the compressed class pointer in the upper bits of the header, which would otherwise\n+ * be lost. SlidingForwarding requires only small side tables and guarantees constant-time access and modification.\n+ *\n+ * The idea is to use a pointer compression scheme very similar to the one that is used for compressed oops.\n+ * We divide the heap into number of logical regions. Each region spans maximum of 2^NUM_BITS words.\n+ * We take advantage of the fact that sliding compaction can forward objects from ore region to a maximum of\n+ * two regions (including itself, but that does not really matter). We need 1 bit to indicate which region is forwarded\n+ * into. We also currently require the two lowest header bits to indicate that the object is forwarded.\n+ *\n+ * For addressing, we need a table with N*2 entries, for N logical regions. For each region, it gives the base\n+ * address of the two target regions, or a special placeholder if not used.\n+ *\n+ * Adding a forwarding then works as follows:\n+ * Given an original address 'orig', and a 'target' address:\n+ * - Look-up first target base of region of orig. If not yet used,\n+ *   establish it to be the base of region of target address. Use that base in step 3.\n+ * - Else, if first target base is already used, check second target base. This must either be unused, or the\n+ *   base of the region of our target address. If unused, establish it to be the base of the region of our target\n+ *   address. Use that base for next step.\n+ * - Now we found a base address. Encode the target address with that base into lowest NUM_BITS bits, and shift\n+ *   that up by 3 bits. Set the 3rd bit if we used the secondary target base, otherwise leave it at 0. Set the\n+ *   lowest two bits to indicate that the object has been forwarded. Store that in the lowest NUM_BITS+3 bits of the\n+ *   original object's header.\n+ *\n+ * Similarily, looking up the target address, given an original object address works as follows:\n+ * - Load lowest NUM_BITS + 3 from original object header. Extract target region bit and compressed address bits.\n+ * - Depending on target region bit, load base address from the target base table by looking up the corresponding entry\n+ *   for the region of the original object.\n+ * - Decode the target address by using the target base address and the compressed address bits.\n+ *\/\n+\n+template <int NUM_REGION_BITS>\n+class SlidingForwarding : public CHeapObj<mtGC> {\n+#ifdef _LP64\n+private:\n+\n+  static const uintptr_t ONE = 1ULL;\n+\n+  \/\/ We need the lowest two bits to indicate a forwarded object.\n+  static const int BASE_SHIFT = 2;\n+\n+  \/\/ The compressed address bits start here.\n+  static const int COMPRESSED_BITS_SHIFT = BASE_SHIFT + NUM_REGION_BITS;\n+\n+  \/\/ How many bits we use for the compressed pointer (we are going to need one more bit to indicate target region, and\n+  \/\/ two lowest bits to mark objects as forwarded)\n+  static const int NUM_COMPRESSED_BITS = 32 - BASE_SHIFT - NUM_REGION_BITS;\n+\n+  \/\/ Indicates an usused base address in the target base table. We cannot use 0, because that may already be\n+  \/\/ a valid base address in zero-based heaps. 0x1 is safe because heap base addresses must be aligned by 2^X.\n+  static HeapWord* const UNUSED_BASE;\n+\n+  HeapWord*  const _heap_start;\n+  size_t     const _num_regions;\n+  size_t     const _region_size_words_shift;\n+  HeapWord** const _target_base_table;\n+\n+  size_t region_index_containing(HeapWord* addr) const;\n+  bool region_contains(HeapWord* region_base, HeapWord* addr) const;\n+\n+  uintptr_t encode_forwarding(HeapWord* original, HeapWord* target);\n+  HeapWord* decode_forwarding(HeapWord* original, uintptr_t encoded) const;\n+\n+#endif\n+\n+public:\n+  SlidingForwarding(MemRegion heap);\n+  SlidingForwarding(MemRegion heap, size_t num_regions);\n+  ~SlidingForwarding();\n+\n+  void clear();\n+  void forward_to(oop original, oop target);\n+  oop forwardee(oop original) const;\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_SLIDINGFORWARDING_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.hpp","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_SLIDINGFORWARDING_INLINE_HPP\n+#define SHARE_GC_SHARED_SLIDINGFORWARDING_INLINE_HPP\n+\n+#include \"gc\/shared\/slidingForwarding.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+\n+#ifdef _LP64\n+template <int NUM_REGION_BITS>\n+HeapWord* const SlidingForwarding<NUM_REGION_BITS>::UNUSED_BASE = reinterpret_cast<HeapWord*>(0x1);\n+#endif\n+\n+template <int NUM_REGION_BITS>\n+SlidingForwarding<NUM_REGION_BITS>::SlidingForwarding(MemRegion heap)\n+#ifdef _LP64\n+: _heap_start(heap.start()),\n+  _num_regions(((heap.end() - heap.start()) >> NUM_COMPRESSED_BITS) + 1),\n+  _region_size_words_shift(NUM_COMPRESSED_BITS),\n+  _target_base_table(NEW_C_HEAP_ARRAY(HeapWord*, _num_regions * 2, mtGC)) {\n+  assert(_region_size_words_shift <= NUM_COMPRESSED_BITS, \"regions must not be larger than maximum addressing bits allow\");\n+#else\n+{\n+#endif\n+}\n+\n+template <int NUM_REGION_BITS>\n+SlidingForwarding<NUM_REGION_BITS>::SlidingForwarding(MemRegion heap, size_t region_size_words_shift)\n+#ifdef _LP64\n+: _heap_start(heap.start()),\n+  _num_regions(((heap.end() - heap.start()) >> region_size_words_shift) + 1),\n+  _region_size_words_shift(region_size_words_shift),\n+  _target_base_table(NEW_C_HEAP_ARRAY(HeapWord*, _num_regions * (ONE << NUM_REGION_BITS), mtGC)) {\n+  assert(region_size_words_shift <= NUM_COMPRESSED_BITS, \"regions must not be larger than maximum addressing bits allow\");\n+#else\n+{\n+#endif\n+}\n+\n+template <int NUM_REGION_BITS>\n+SlidingForwarding<NUM_REGION_BITS>::~SlidingForwarding() {\n+#ifdef _LP64\n+  FREE_C_HEAP_ARRAY(HeapWord*, _target_base_table);\n+#endif\n+}\n+\n+template <int NUM_REGION_BITS>\n+void SlidingForwarding<NUM_REGION_BITS>::clear() {\n+#ifdef _LP64\n+  size_t max = _num_regions * (ONE << NUM_REGION_BITS);\n+  for (size_t i = 0; i < max; i++) {\n+    _target_base_table[i] = UNUSED_BASE;\n+  }\n+#endif\n+}\n+\n+#ifdef _LP64\n+template <int NUM_REGION_BITS>\n+size_t SlidingForwarding<NUM_REGION_BITS>::region_index_containing(HeapWord* addr) const {\n+  assert(addr >= _heap_start, \"sanity: addr: \" PTR_FORMAT \" heap base: \" PTR_FORMAT, p2i(addr), p2i(_heap_start));\n+  size_t index = ((size_t) (addr - _heap_start)) >> _region_size_words_shift;\n+  assert(index < _num_regions, \"Region index is in bounds: \" PTR_FORMAT, p2i(addr));\n+  return index;\n+}\n+\n+template <int NUM_REGION_BITS>\n+bool SlidingForwarding<NUM_REGION_BITS>::region_contains(HeapWord* region_base, HeapWord* addr) const {\n+  return uintptr_t(addr - region_base) < (ONE << _region_size_words_shift);\n+}\n+\n+template <int NUM_REGION_BITS>\n+uintptr_t SlidingForwarding<NUM_REGION_BITS>::encode_forwarding(HeapWord* original, HeapWord* target) {\n+  size_t orig_idx = region_index_containing(original);\n+  size_t base_table_idx = orig_idx * 2;\n+  size_t target_idx = region_index_containing(target);\n+  HeapWord* encode_base;\n+  uintptr_t region_idx;\n+  for (region_idx = 0; region_idx < (ONE << NUM_REGION_BITS); region_idx++) {\n+    encode_base = _target_base_table[base_table_idx + region_idx];\n+    if (encode_base == UNUSED_BASE) {\n+      encode_base = _heap_start + target_idx * (ONE << _region_size_words_shift);\n+      _target_base_table[base_table_idx + region_idx] = encode_base;\n+      break;\n+    } else if (region_contains(encode_base, target)) {\n+      break;\n+    }\n+  }\n+  if (region_idx >= (ONE << NUM_REGION_BITS)) {\n+    tty->print_cr(\"target: \" PTR_FORMAT, p2i(target));\n+    for (region_idx = 0; region_idx < (ONE << NUM_REGION_BITS); region_idx++) {\n+      tty->print_cr(\"region_idx: \" INTPTR_FORMAT \", encode_base: \" PTR_FORMAT, region_idx, p2i(_target_base_table[base_table_idx + region_idx]));\n+    }\n+  }\n+  assert(region_idx < (ONE << NUM_REGION_BITS), \"need to have found an encoding base\");\n+  assert(target >= encode_base, \"target must be above encode base, target:\" PTR_FORMAT \", encoded_base: \" PTR_FORMAT \",  target_idx: \" SIZE_FORMAT \", heap start: \" PTR_FORMAT \", region_idx: \" INTPTR_FORMAT,\n+         p2i(target), p2i(encode_base), target_idx, p2i(_heap_start), region_idx);\n+  assert(region_contains(encode_base, target), \"region must contain target: original: \" PTR_FORMAT \", target: \" PTR_FORMAT \", encode_base: \" PTR_FORMAT \", region_idx: \" INTPTR_FORMAT, p2i(original), p2i(target), p2i(encode_base), region_idx);\n+  uintptr_t encoded = (((uintptr_t)(target - encode_base)) << COMPRESSED_BITS_SHIFT) |\n+                      (region_idx << BASE_SHIFT) | markWord::marked_value;\n+  assert(target == decode_forwarding(original, encoded), \"must be reversible\");\n+  return encoded;\n+}\n+\n+template <int NUM_REGION_BITS>\n+HeapWord* SlidingForwarding<NUM_REGION_BITS>::decode_forwarding(HeapWord* original, uintptr_t encoded) const {\n+  assert((encoded & markWord::marked_value) == markWord::marked_value, \"must be marked as forwarded\");\n+  size_t orig_idx = region_index_containing(original);\n+  size_t region_idx = (encoded >> BASE_SHIFT) & right_n_bits(NUM_REGION_BITS);\n+  size_t base_table_idx = orig_idx * 2 + region_idx;\n+  HeapWord* decoded = _target_base_table[base_table_idx] + (encoded >> COMPRESSED_BITS_SHIFT);\n+  assert(decoded >= _heap_start, \"must be above heap start, encoded: \" INTPTR_FORMAT \", region_idx: \" SIZE_FORMAT \", base: \" PTR_FORMAT, encoded, region_idx, p2i(_target_base_table[base_table_idx]));\n+  return decoded;\n+}\n+#endif\n+\n+template <int NUM_REGION_BITS>\n+void SlidingForwarding<NUM_REGION_BITS>::forward_to(oop original, oop target) {\n+#ifdef _LP64\n+  markWord header = original->mark();\n+  uintptr_t encoded = encode_forwarding(cast_from_oop<HeapWord*>(original), cast_from_oop<HeapWord*>(target));\n+  assert((encoded & markWord::klass_mask_in_place) == 0, \"encoded forwardee must not overlap with Klass*: \" PTR_FORMAT, encoded);\n+  header = markWord((header.value() & markWord::klass_mask_in_place) | encoded);\n+  original->set_mark(header);\n+#else\n+  original->forward_to(target);\n+#endif\n+}\n+\n+template <int NUM_REGION_BITS>\n+oop SlidingForwarding<NUM_REGION_BITS>::forwardee(oop original) const {\n+#ifdef _LP64\n+  markWord header = original->mark();\n+  uintptr_t encoded = header.value() & ~markWord::klass_mask_in_place;\n+  HeapWord* forwardee = decode_forwarding(cast_from_oop<HeapWord*>(original), encoded);\n+  return cast_to_oop(forwardee);\n+#else\n+  return original->forwardee();\n+#endif\n+}\n+\n+#endif \/\/ SHARE_GC_SHARED_SLIDINGFORWARDING_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.inline.hpp","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -350,1 +351,1 @@\n-                                    CompactPoint* cp, HeapWord* compact_top) {\n+                                    CompactPoint* cp, HeapWord* compact_top, SlidingForwarding<1>* const forwarding) {\n@@ -373,1 +374,1 @@\n-    q->forward_to(cast_to_oop(compact_top));\n+    forwarding->forward_to(q, cast_to_oop(compact_top));\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+template <int N>\n+class SlidingForwarding;\n@@ -435,1 +437,1 @@\n-                    HeapWord* compact_top);\n+                    HeapWord* compact_top, SlidingForwarding<1>* const forwarding);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shared\/genCollectedHeap.hpp\"\n@@ -166,0 +167,1 @@\n+  SlidingForwarding<1>* const forwarding = GenCollectedHeap::heap()->forwarding();\n@@ -171,1 +173,1 @@\n-      compact_top = cp->space->forward(cast_to_oop(cur_obj), size, cp, compact_top);\n+      compact_top = cp->space->forward(cast_to_oop(cur_obj), size, cp, compact_top, forwarding);\n@@ -187,1 +189,1 @@\n-        compact_top = cp->space->forward(obj, obj->size(), cp, compact_top);\n+        compact_top = cp->space->forward(obj, obj->size(), cp, compact_top, forwarding);\n@@ -226,0 +228,1 @@\n+  const SlidingForwarding<1>* const forwarding = GenCollectedHeap::heap()->forwarding();\n@@ -237,1 +240,1 @@\n-      size_t size = MarkSweep::adjust_pointers(cast_to_oop(cur_obj));\n+      size_t size = MarkSweep::adjust_pointers(forwarding, cast_to_oop(cur_obj));\n@@ -319,0 +322,2 @@\n+  const SlidingForwarding<1>* const forwarding = GenCollectedHeap::heap()->forwarding();\n+\n@@ -332,1 +337,1 @@\n-      HeapWord* compaction_top = cast_from_oop<HeapWord*>(cast_to_oop(cur_obj)->forwardee());\n+      HeapWord* compaction_top = cast_from_oop<HeapWord*>(forwarding->forwardee(cast_to_oop(cur_obj)));\n","filename":"src\/hotspot\/share\/gc\/shared\/space.inline.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -185,0 +186,1 @@\n+    heap->forwarding()->clear();\n@@ -296,0 +298,1 @@\n+  SlidingForwarding<1>*    const _forwarding;\n@@ -308,0 +311,1 @@\n+    _forwarding(ShenandoahHeap::heap()->forwarding()),\n@@ -361,1 +365,1 @@\n-    p->forward_to(cast_to_oop(_compact_point));\n+    _forwarding->forward_to(p, cast_to_oop(_compact_point));\n@@ -373,1 +377,1 @@\n-  ShenandoahPrepareForCompactionTask(PreservedMarksSet *preserved_marks, ShenandoahHeapRegionSet **worker_slices) :\n+  ShenandoahPrepareForCompactionTask(PreservedMarksSet* preserved_marks, ShenandoahHeapRegionSet **worker_slices) :\n@@ -435,0 +439,1 @@\n+  SlidingForwarding<1>* forwarding = heap->forwarding();\n@@ -469,1 +474,1 @@\n-        old_obj->forward_to(cast_to_oop(heap->get_region(start)->bottom()));\n+        forwarding->forward_to(old_obj, cast_to_oop(heap->get_region(start)->bottom()));\n@@ -720,2 +725,3 @@\n-  ShenandoahHeap* const _heap;\n-  ShenandoahMarkingContext* const _ctx;\n+  ShenandoahHeap*             const _heap;\n+  const SlidingForwarding<1>* const _forwarding;\n+  ShenandoahMarkingContext*   const _ctx;\n@@ -730,1 +736,1 @@\n-        oop forw = obj->forwardee();\n+        oop forw = _forwarding->forwardee(obj);\n@@ -739,0 +745,1 @@\n+    _forwarding(_heap->forwarding()),\n@@ -798,1 +805,2 @@\n-    _preserved_marks->get(worker_id)->adjust_during_full_gc();\n+    const SlidingForwarding<1>* const forwarding = ShenandoahHeap::heap()->forwarding();\n+    _preserved_marks->get(worker_id)->adjust_during_full_gc(forwarding);\n@@ -828,2 +836,3 @@\n-  ShenandoahHeap* const _heap;\n-  uint            const _worker_id;\n+  ShenandoahHeap*             const _heap;\n+  const SlidingForwarding<1>* const _forwarding;\n+  uint                        const _worker_id;\n@@ -833,1 +842,1 @@\n-    _heap(ShenandoahHeap::heap()), _worker_id(worker_id) {}\n+    _heap(ShenandoahHeap::heap()), _forwarding(_heap->forwarding()), _worker_id(worker_id) {}\n@@ -840,1 +849,1 @@\n-      HeapWord* compact_to = cast_from_oop<HeapWord*>(p->forwardee());\n+      HeapWord* compact_to = cast_from_oop<HeapWord*>(_forwarding->forwardee(p));\n@@ -935,0 +944,1 @@\n+  const SlidingForwarding<1>* const forwarding = heap->forwarding();\n@@ -949,1 +959,1 @@\n-      size_t new_start = heap->heap_region_index_containing(old_obj->forwardee());\n+      size_t new_start = heap->heap_region_index_containing(forwarding->forwardee(old_obj));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":22,"deletions":12,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -194,0 +195,2 @@\n+  _forwarding = new SlidingForwarding<1>(_heap_region, ShenandoahHeapRegion::region_size_words_shift());\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+template<int N>\n+class SlidingForwarding;\n@@ -230,0 +232,1 @@\n+  SlidingForwarding<1>* _forwarding;\n@@ -246,0 +249,2 @@\n+  SlidingForwarding<1>* forwarding() const { return _forwarding; }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}