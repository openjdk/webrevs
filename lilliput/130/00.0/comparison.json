{"files":[{"patch":"@@ -105,1 +105,1 @@\n-        uses: actions\/cache@v3\n+        uses: actions\/cache@v4\n","filename":".github\/workflows\/build-cross-compile.yml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2380,1 +2380,1 @@\n-int Matcher::superword_max_vector_size(const BasicType bt) {\n+int Matcher::max_vector_size_auto_vectorization(const BasicType bt) {\n@@ -8306,1 +8306,1 @@\n-            \"dmb ish\" %}\n+            \"dmb ishld\" %}\n@@ -8360,1 +8360,1 @@\n-            \"dmb ish\" %}\n+            \"dmb ishst\\n\\tdmb ishld\" %}\n@@ -8364,1 +8364,2 @@\n-    __ membar(Assembler::LoadStore|Assembler::StoreStore);\n+    __ membar(Assembler::StoreStore);\n+    __ membar(Assembler::LoadStore);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2069,7 +2069,12 @@\n-    \/\/ We are merging two memory barrier instructions.  On AArch64 we\n-    \/\/ can do this simply by ORing them together.\n-    bar->set_kind(bar->get_kind() | order_constraint);\n-    BLOCK_COMMENT(\"merged membar\");\n-  } else {\n-    code()->set_last_insn(pc());\n-    dmb(Assembler::barrier(order_constraint));\n+    \/\/ Don't promote DMB ST|DMB LD to DMB (a full barrier) because\n+    \/\/ doing so would introduce a StoreLoad which the caller did not\n+    \/\/ intend\n+    if (AlwaysMergeDMB || bar->get_kind() == order_constraint\n+        || bar->get_kind() == AnyAny\n+        || order_constraint == AnyAny) {\n+      \/\/ We are merging two memory barrier instructions.  On AArch64 we\n+      \/\/ can do this simply by ORing them together.\n+      bar->set_kind(bar->get_kind() | order_constraint);\n+      BLOCK_COMMENT(\"merged membar\");\n+      return;\n+    }\n@@ -2077,0 +2082,2 @@\n+  code()->set_last_insn(pc());\n+  dmb(Assembler::barrier(order_constraint));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1430,5 +1430,0 @@\n-  void fast_log(FloatRegister vtmp0, FloatRegister vtmp1, FloatRegister vtmp2,\n-                FloatRegister vtmp3, FloatRegister vtmp4, FloatRegister vtmp5,\n-                FloatRegister tmpC1, FloatRegister tmpC2, FloatRegister tmpC3,\n-                FloatRegister tmpC4, Register tmp1, Register tmp2,\n-                Register tmp3, Register tmp4, Register tmp5);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2571,1 +2571,3 @@\n-  if (is_simm32(src)) {\n+  if (is_uimm32(src)) {\n+    movl(dst, checked_cast<uint32_t>(src));\n+  } else if (is_simm32(src)) {\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,1 @@\n+#include \"gc\/g1\/g1RegionPinCache.inline.hpp\"\n@@ -2477,0 +2478,6 @@\n+void G1CollectedHeap::flush_region_pin_cache() {\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {\n+    G1ThreadLocalData::pin_count_cache(thread).flush();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -195,0 +195,1 @@\n+  _heap->flush_region_pin_cache();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -652,0 +652,6 @@\n+bool DefNewGeneration::is_in(const void* p) const {\n+  return eden()->is_in(p)\n+      || from()->is_in(p)\n+      || to()  ->is_in(p);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -930,0 +930,1 @@\n+\n@@ -931,1 +932,3 @@\n-    return _young_gen->block_is_obj(addr);\n+    return _young_gen->eden()->is_in(addr)\n+        || _young_gen->from()->is_in(addr)\n+        || _young_gen->to()  ->is_in(addr);\n@@ -934,2 +937,2 @@\n-  assert(_old_gen->is_in_reserved(addr), \"Some generation should contain the address\");\n-  return _old_gen->block_is_obj(addr);\n+  assert(_old_gen->is_in_reserved(addr), \"must be in old-gen\");\n+  return addr < _old_gen->space()->top();\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -312,17 +312,0 @@\n-  product(uintx, MaxRAMFraction, 4,                                         \\\n-          \"Maximum fraction (1\/n) of real memory used for maximum heap \"    \\\n-          \"size. \"                                                          \\\n-          \"Deprecated, use MaxRAMPercentage instead\")                       \\\n-          range(1, max_uintx)                                               \\\n-                                                                            \\\n-  product(uintx, MinRAMFraction, 2,                                         \\\n-          \"Minimum fraction (1\/n) of real memory used for maximum heap \"    \\\n-          \"size on systems with small physical memory size. \"               \\\n-          \"Deprecated, use MinRAMPercentage instead\")                       \\\n-          range(1, max_uintx)                                               \\\n-                                                                            \\\n-  product(uintx, InitialRAMFraction, 64,                                    \\\n-          \"Fraction (1\/n) of real memory used for initial heap size. \"      \\\n-          \"Deprecated, use InitialRAMPercentage instead\")                   \\\n-          range(1, max_uintx)                                               \\\n-                                                                            \\\n@@ -445,5 +428,0 @@\n-  product(uintx, MaxGCMinorPauseMillis, max_uintx,                          \\\n-          \"Adaptive size policy maximum GC minor pause time goal \"          \\\n-          \"in millisecond\")                                                 \\\n-          range(0, max_uintx)                                               \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":1,"deletions":23,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -760,0 +760,27 @@\n+void ShenandoahHeap::maybe_uncommit(double shrink_before, size_t shrink_until) {\n+  assert (ShenandoahUncommit, \"should be enabled\");\n+\n+  \/\/ Determine if there is work to do. This avoids taking heap lock if there is\n+  \/\/ no work available, avoids spamming logs with superfluous logging messages,\n+  \/\/ and minimises the amount of work while locks are taken.\n+\n+  if (committed() <= shrink_until) return;\n+\n+  bool has_work = false;\n+  for (size_t i = 0; i < num_regions(); i++) {\n+    ShenandoahHeapRegion* r = get_region(i);\n+    if (r->is_empty_committed() && (r->empty_time() < shrink_before)) {\n+      has_work = true;\n+      break;\n+    }\n+  }\n+\n+  if (has_work) {\n+    static const char* msg = \"Concurrent uncommit\";\n+    ShenandoahConcurrentPhase gcPhase(msg, ShenandoahPhaseTimings::conc_uncommit, true \/* log_heap_usage *\/);\n+    EventMark em(\"%s\", msg);\n+\n+    op_uncommit(shrink_before, shrink_until);\n+  }\n+}\n+\n@@ -790,0 +817,18 @@\n+bool ShenandoahHeap::check_soft_max_changed() {\n+  size_t new_soft_max = Atomic::load(&SoftMaxHeapSize);\n+  size_t old_soft_max = soft_max_capacity();\n+  if (new_soft_max != old_soft_max) {\n+    new_soft_max = MAX2(min_capacity(), new_soft_max);\n+    new_soft_max = MIN2(max_capacity(), new_soft_max);\n+    if (new_soft_max != old_soft_max) {\n+      log_info(gc)(\"Soft Max Heap Size: \" SIZE_FORMAT \"%s -> \" SIZE_FORMAT \"%s\",\n+                   byte_size_in_proper_unit(old_soft_max), proper_unit_for_byte_size(old_soft_max),\n+                   byte_size_in_proper_unit(new_soft_max), proper_unit_for_byte_size(new_soft_max)\n+      );\n+      set_soft_max_capacity(new_soft_max);\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -2265,8 +2310,0 @@\n-void ShenandoahHeap::entry_uncommit(double shrink_before, size_t shrink_until) {\n-  static const char *msg = \"Concurrent uncommit\";\n-  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_uncommit, true \/* log_heap_usage *\/);\n-  EventMark em(\"%s\", msg);\n-\n-  op_uncommit(shrink_before, shrink_until);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":45,"deletions":8,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1896,1 +1896,4 @@\n-  MutexLocker mu(mdo->extra_data_lock());\n+\n+  \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+  MutexLocker mu(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -497,4 +497,0 @@\n-  { \"MaxGCMinorPauseMillis\",        JDK_Version::jdk(8), JDK_Version::undefined(), JDK_Version::undefined() },\n-  { \"MaxRAMFraction\",               JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },\n-  { \"MinRAMFraction\",               JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },\n-  { \"InitialRAMFraction\",           JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },\n@@ -510,1 +506,0 @@\n-  { \"DefaultMaxRAMFraction\",        JDK_Version::jdk(8),  JDK_Version::undefined(), JDK_Version::undefined() },\n@@ -529,0 +524,5 @@\n+  { \"MaxGCMinorPauseMillis\",        JDK_Version::jdk(8), JDK_Version::jdk(23), JDK_Version::jdk(24) },\n+  { \"MaxRAMFraction\",               JDK_Version::jdk(10),  JDK_Version::jdk(23), JDK_Version::jdk(24) },\n+  { \"MinRAMFraction\",               JDK_Version::jdk(10),  JDK_Version::jdk(23), JDK_Version::jdk(24) },\n+  { \"InitialRAMFraction\",           JDK_Version::jdk(10),  JDK_Version::jdk(23), JDK_Version::jdk(24) },\n+  { \"DefaultMaxRAMFraction\",        JDK_Version::jdk(8),  JDK_Version::jdk(23), JDK_Version::jdk(24) },\n@@ -554,1 +554,0 @@\n-  { \"DefaultMaxRAMFraction\",    \"MaxRAMFraction\"    },\n@@ -1482,3 +1481,0 @@\n-                           !FLAG_IS_DEFAULT(MaxRAMFraction) ||\n-                           !FLAG_IS_DEFAULT(MinRAMFraction) ||\n-                           !FLAG_IS_DEFAULT(InitialRAMFraction) ||\n@@ -1500,14 +1496,0 @@\n-\n-  \/\/ Convert deprecated flags\n-  if (FLAG_IS_DEFAULT(MaxRAMPercentage) &&\n-      !FLAG_IS_DEFAULT(MaxRAMFraction))\n-    MaxRAMPercentage = 100.0 \/ (double)MaxRAMFraction;\n-\n-  if (FLAG_IS_DEFAULT(MinRAMPercentage) &&\n-      !FLAG_IS_DEFAULT(MinRAMFraction))\n-    MinRAMPercentage = 100.0 \/ (double)MinRAMFraction;\n-\n-  if (FLAG_IS_DEFAULT(InitialRAMPercentage) &&\n-      !FLAG_IS_DEFAULT(InitialRAMFraction))\n-    InitialRAMPercentage = 100.0 \/ (double)InitialRAMFraction;\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":6,"deletions":24,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2016,0 +2016,5 @@\n+                                                                            \\\n+  product(bool, AlwaysRecordEvolDependencies, true, EXPERIMENTAL,           \\\n+                \"Unconditionally record nmethod dependencies on class \"     \\\n+                \"rewriting\/transformation independently of the JVMTI \"      \\\n+                \"can_{retransform\/redefine}_classes capabilities.\")         \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}