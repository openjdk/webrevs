{"files":[{"patch":"@@ -2001,1 +2001,5 @@\n-  product(int, OMSpins, 13, \"\")                                             \\\n+  product(int, OMSpins, 13,                                                 \\\n+          \"Specifies the number of time lightweight fast locking will \"     \\\n+          \"attempt to CAS the markWord before inflating. Between each \"     \\\n+          \"CAS it will spin for exponentially more time, resulting in \"     \\\n+          \"a total number of spins on the order of O(2^OMSpins)\")           \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -573,1 +573,12 @@\n-  const auto try_spin = [&]() { return observed_deflation || !mark.has_monitor(); };\n+  const auto try_spin = [&]() {\n+    if (!mark.has_monitor()) {\n+      \/\/ Spin while not inflated.\n+      return true;\n+    } else if (observed_deflation) {\n+      \/\/ Spin while monitor is being deflated.\n+      ObjectMonitor* monitor = LightweightSynchronizer::read_monitor(current, obj);\n+      return monitor == nullptr || monitor->is_being_async_deflated();\n+    }\n+    \/\/ Else stop spinning.\n+    return false;\n+  };\n@@ -698,0 +709,4 @@\n+    \/\/ If inflate_and_enter returns nullptr it is because a deflated monitor\n+    \/\/ was encountered. Fallback to fast locking. The deflater is responisble\n+    \/\/ for clearing out the monitor and transitioning the markWord back to\n+    \/\/ fast locking.\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"}]}