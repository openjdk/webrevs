{"files":[{"patch":"@@ -2001,3 +2001,2 @@\n-  product(int, OMSpins, 20, \"\")                                             \\\n-                                                                            \\\n-  product(int, OMYields, 5, \"\")                                             \\\n+  product(int, OMSpins, 13, \"\")                                             \\\n+          range(1, 30)                                                      \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -42,0 +43,1 @@\n+#include \"runtime\/safepointMechanism.inline.hpp\"\n@@ -563,0 +565,46 @@\n+bool LightweightSynchronizer::fast_lock_spin_enter(oop obj, JavaThread* current, bool observed_deflation) {\n+  \/\/ Will spin with exponential backoff with an accumulative O(2^spin_limit) spins.\n+  const int log_spin_limit = os::is_MP() ? OMSpins : 1;\n+  const int log_min_safepoint_check_interval = 10;\n+\n+  LockStack& lock_stack = current->lock_stack();\n+\n+  markWord mark = obj->mark();\n+  const auto try_spin = [&]() { return observed_deflation || !mark.has_monitor(); };\n+  \/\/ Always attempt to lock once even when safepoint synchronizing.\n+  bool should_process = false;\n+  for (int i = 0; try_spin() && !should_process && i < log_spin_limit; i++) {\n+    \/\/ Spin with exponential backoff.\n+    const int total_spin_count = 1 << i;\n+    const int inner_spin_count = MIN2(1 << log_min_safepoint_check_interval, total_spin_count);\n+    const int outer_spin_count = total_spin_count \/ inner_spin_count;\n+    for (int outer = 0; outer < outer_spin_count; outer++) {\n+      should_process = SafepointMechanism::should_process(current);\n+      if (should_process) {\n+        \/\/ Stop spinning for safepoint.\n+        break;\n+      }\n+      for (int inner = 1; inner < inner_spin_count; inner++) {\n+        SpinPause();\n+      }\n+    }\n+\n+    mark = obj->mark();\n+    while (mark.is_unlocked()) {\n+      ensure_lock_stack_space(current);\n+      assert(!lock_stack.is_full(), \"must have made room on the lock stack\");\n+      assert(!lock_stack.contains(obj), \"thread must not already hold the lock\");\n+      \/\/ Try to swing into 'fast-locked' state.\n+      markWord locked_mark = mark.set_fast_locked();\n+      markWord old_mark = mark;\n+      mark = obj->cas_set_mark(locked_mark, old_mark);\n+      if (old_mark == mark) {\n+        \/\/ Successfully fast-locked, push object to lock-stack and return.\n+        lock_stack.push(obj);\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -608,0 +656,3 @@\n+  \/\/ Used when deflation is observed. Progress here requires progress\n+  \/\/ from the deflator. After observing the that the deflator is not\n+  \/\/ making progress (after two yields), switch to sleeping.\n@@ -609,1 +660,1 @@\n-  bool first_time = true;\n+  bool observed_deflation = false;\n@@ -631,3 +682,0 @@\n-  const int spins = OMSpins;\n-  const int yields = OMYields;\n-\n@@ -635,2 +683,0 @@\n-\n-    SpinYield fast_lock_spin_yield(spins, yields);\n@@ -638,20 +684,2 @@\n-    markWord mark = obj()->mark_acquire();\n-    const bool try_spin = !first_time || !mark.has_monitor();\n-    for (int attempts = spins + yields; try_spin && attempts > 0; attempts--) {\n-      while (mark.is_unlocked()) {\n-        ensure_lock_stack_space(current);\n-        assert(!lock_stack.is_full(), \"must have made room on the lock stack\");\n-        assert(!lock_stack.contains(obj()), \"thread must not already hold the lock\");\n-        \/\/ Try to swing into 'fast-locked' state.\n-        markWord locked_mark = mark.set_fast_locked();\n-        markWord old_mark = mark;\n-        mark = obj()->cas_set_mark(locked_mark, old_mark);\n-        if (old_mark == mark) {\n-          \/\/ Successfully fast-locked, push object to lock-stack and return.\n-          lock_stack.push(obj());\n-          return;\n-        }\n-      }\n-\n-      fast_lock_spin_yield.wait();\n-      mark = obj()->mark_acquire();\n+    if (fast_lock_spin_enter(obj(), current, observed_deflation)) {\n+      return;\n@@ -660,1 +688,1 @@\n-    if (!first_time) {\n+    if (observed_deflation) {\n@@ -670,1 +698,1 @@\n-    first_time = false;\n+    observed_deflation = true;\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":56,"deletions":28,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -58,0 +58,4 @@\n+private:\n+  static bool fast_lock_spin_enter(oop obj, JavaThread* current, bool observed_deflation);\n+\n+public:\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}