{"files":[{"patch":"@@ -2001,3 +2001,6 @@\n-  product(int, OMSpins, 20, \"\")                                             \\\n-                                                                            \\\n-  product(int, OMYields, 5, \"\")                                             \\\n+  product(int, OMSpins, 13,                                                 \\\n+          \"Specifies the number of time lightweight fast locking will \"     \\\n+          \"attempt to CAS the markWord before inflating. Between each \"     \\\n+          \"CAS it will spin for exponentially more time, resulting in \"     \\\n+          \"a total number of spins on the order of O(2^OMSpins)\")           \\\n+          range(1, 30)                                                      \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -42,0 +43,1 @@\n+#include \"runtime\/safepointMechanism.inline.hpp\"\n@@ -563,0 +565,57 @@\n+bool LightweightSynchronizer::fast_lock_spin_enter(oop obj, JavaThread* current, bool observed_deflation) {\n+  \/\/ Will spin with exponential backoff with an accumulative O(2^spin_limit) spins.\n+  const int log_spin_limit = os::is_MP() ? OMSpins : 1;\n+  const int log_min_safepoint_check_interval = 10;\n+\n+  LockStack& lock_stack = current->lock_stack();\n+\n+  markWord mark = obj->mark();\n+  const auto should_spin = [&]() {\n+    if (!mark.has_monitor()) {\n+      \/\/ Spin while not inflated.\n+      return true;\n+    } else if (observed_deflation) {\n+      \/\/ Spin while monitor is being deflated.\n+      ObjectMonitor* monitor = LightweightSynchronizer::read_monitor(current, obj);\n+      return monitor == nullptr || monitor->is_being_async_deflated();\n+    }\n+    \/\/ Else stop spinning.\n+    return false;\n+  };\n+  \/\/ Always attempt to lock once even when safepoint synchronizing.\n+  bool should_process = false;\n+  for (int i = 0; should_spin() && !should_process && i < log_spin_limit; i++) {\n+    \/\/ Spin with exponential backoff.\n+    const int total_spin_count = 1 << i;\n+    const int inner_spin_count = MIN2(1 << log_min_safepoint_check_interval, total_spin_count);\n+    const int outer_spin_count = total_spin_count \/ inner_spin_count;\n+    for (int outer = 0; outer < outer_spin_count; outer++) {\n+      should_process = SafepointMechanism::should_process(current);\n+      if (should_process) {\n+        \/\/ Stop spinning for safepoint.\n+        break;\n+      }\n+      for (int inner = 1; inner < inner_spin_count; inner++) {\n+        SpinPause();\n+      }\n+    }\n+\n+    mark = obj->mark();\n+    while (mark.is_unlocked()) {\n+      ensure_lock_stack_space(current);\n+      assert(!lock_stack.is_full(), \"must have made room on the lock stack\");\n+      assert(!lock_stack.contains(obj), \"thread must not already hold the lock\");\n+      \/\/ Try to swing into 'fast-locked' state.\n+      markWord locked_mark = mark.set_fast_locked();\n+      markWord old_mark = mark;\n+      mark = obj->cas_set_mark(locked_mark, old_mark);\n+      if (old_mark == mark) {\n+        \/\/ Successfully fast-locked, push object to lock-stack and return.\n+        lock_stack.push(obj);\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -608,0 +667,3 @@\n+  \/\/ Used when deflation is observed. Progress here requires progress\n+  \/\/ from the deflator. After observing the that the deflator is not\n+  \/\/ making progress (after two yields), switch to sleeping.\n@@ -609,1 +671,1 @@\n-  bool first_time = true;\n+  bool observed_deflation = false;\n@@ -631,3 +693,0 @@\n-  const int spins = OMSpins;\n-  const int yields = OMYields;\n-\n@@ -635,2 +694,0 @@\n-\n-    SpinYield fast_lock_spin_yield(spins, yields);\n@@ -638,20 +695,6 @@\n-    markWord mark = obj()->mark_acquire();\n-    const bool try_spin = !first_time || !mark.has_monitor();\n-    for (int attempts = spins + yields; try_spin && attempts > 0; attempts--) {\n-      while (mark.is_unlocked()) {\n-        ensure_lock_stack_space(current);\n-        assert(!lock_stack.is_full(), \"must have made room on the lock stack\");\n-        assert(!lock_stack.contains(obj()), \"thread must not already hold the lock\");\n-        \/\/ Try to swing into 'fast-locked' state.\n-        markWord locked_mark = mark.set_fast_locked();\n-        markWord old_mark = mark;\n-        mark = obj()->cas_set_mark(locked_mark, old_mark);\n-        if (old_mark == mark) {\n-          \/\/ Successfully fast-locked, push object to lock-stack and return.\n-          lock_stack.push(obj());\n-          return;\n-        }\n-      }\n-\n-      fast_lock_spin_yield.wait();\n-      mark = obj()->mark_acquire();\n+    \/\/ Fast-lock spinning to avoid inflating for short critical sections.\n+    \/\/ The goal is to only inflate when the extra cost of using ObjectMonitors\n+    \/\/ is worth it.\n+    \/\/ If deflation has been observed we also spin while deflation is onging.\n+    if (fast_lock_spin_enter(obj(), current, observed_deflation)) {\n+      return;\n@@ -660,1 +703,1 @@\n-    if (!first_time) {\n+    if (observed_deflation) {\n@@ -670,1 +713,5 @@\n-    first_time = false;\n+    \/\/ If inflate_and_enter returns nullptr it is because a deflated monitor\n+    \/\/ was encountered. Fallback to fast locking. The deflater is responsible\n+    \/\/ for clearing out the monitor and transitioning the markWord back to\n+    \/\/ fast locking.\n+    observed_deflation = true;\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":75,"deletions":28,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -58,0 +58,4 @@\n+private:\n+  static bool fast_lock_spin_enter(oop obj, JavaThread* current, bool observed_deflation);\n+\n+public:\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}