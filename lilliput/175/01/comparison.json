{"files":[{"patch":"@@ -141,0 +141,1 @@\n+  LOG_TAG(omworld) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1999,2 +1999,0 @@\n-  product(bool, OMShrinkCHT, false, \"\")                                     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -36,0 +37,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -40,0 +42,1 @@\n+#include \"runtime\/objectMonitor.hpp\"\n@@ -46,0 +49,2 @@\n+#include \"runtime\/timerTrace.hpp\"\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -47,0 +52,1 @@\n+#include \"utilities\/concurrentHashTableTasks.inline.hpp\"\n@@ -67,0 +73,1 @@\n+      reinterpret_cast<ObjectMonitorWorld*>(context)->inc_table_count();\n@@ -70,0 +77,1 @@\n+      reinterpret_cast<ObjectMonitorWorld*>(context)->dec_table_count();\n@@ -76,0 +84,2 @@\n+  volatile size_t _table_count;\n+  size_t _table_size;\n@@ -77,1 +87,0 @@\n-  uint32_t _shrink_count;\n@@ -123,0 +132,16 @@\n+  void inc_table_count() {\n+    Atomic::inc(&_table_count);\n+  }\n+\n+  void dec_table_count() {\n+    Atomic::inc(&_table_count);\n+  }\n+\n+  double get_load_factor() {\n+    return (double)_table_count\/(double)_table_size;\n+  }\n+\n+  size_t table_size(Thread* current = Thread::current()) {\n+    return ((size_t)1) << _table->get_size_log2(current);\n+  }\n+\n@@ -137,1 +162,1 @@\n-    \/\/ TODO[OMWorld]: Evaluate the min size, currently ~= log(AvgMonitorsPerThreadEstimate default)\n+    \/\/ ~= log(AvgMonitorsPerThreadEstimate default)\n@@ -152,6 +177,0 @@\n-    \/\/ TODO[OMWorld]: Evaluate why 4 is a good grow hint.\n-    \/\/                Have seen grow hint hits when lower with a\n-    \/\/                load factor as low as 0.1. (Grow Hint = 3)\n-    \/\/ TODO[OMWorld]: Evaluate the hash code used, are large buckets\n-    \/\/                expected even with a low load factor. Or is it\n-    \/\/                something with the hashing used.\n@@ -161,7 +180,0 @@\n-  static size_t log_shrink_difference() {\n-    \/\/ TODO[OMWorld]: Evaluate shrink heuristics, currently disabled by\n-    \/\/                default, and only really shrinks if AvgMonitorsPerThreadEstimate\n-    \/\/                is also set to a none default value\n-    return 2;\n-  }\n-\n@@ -170,3 +182,9 @@\n-  : _table(new ConcurrentTable(initial_log_size(), max_log_size(), grow_hint())),\n-    _resize(false),\n-    _shrink_count(0) {}\n+  : _table(new ConcurrentTable(initial_log_size(),\n+                               max_log_size(),\n+                               grow_hint(),\n+                               ConcurrentTable::DEFAULT_ENABLE_STATISTICS,\n+                               ConcurrentTable::DEFAULT_MUTEX_RANK,\n+                               this)),\n+    _table_count(0),\n+    _table_size(table_size()),\n+    _resize(false) {}\n@@ -200,3 +218,3 @@\n-      if (MonitorDeflation_lock->try_lock()) {\n-        MonitorDeflation_lock->notify();\n-        MonitorDeflation_lock->unlock();\n+      if (Service_lock->try_lock()) {\n+        Service_lock->notify();\n+        Service_lock->unlock();\n@@ -207,4 +225,3 @@\n-  void set_table_max(JavaThread* current) {\n-    while (!_table->is_max_size_reached()) {\n-      _table->grow(current);\n-    }\n+  bool should_shrink() {\n+    \/\/ No implemented;\n+    return false;\n@@ -213,3 +230,1 @@\n-  bool needs_shrink(size_t log_target, size_t log_size) {\n-    return OMShrinkCHT && log_target + log_shrink_difference() <= log_size;\n-  }\n+  static constexpr double GROW_LOAD_FACTOR = 0.75;\n@@ -217,2 +232,2 @@\n-  bool needs_grow(size_t log_target, size_t log_size) {\n-    return log_size < log_target;\n+  bool should_grow() {\n+    return get_load_factor() > GROW_LOAD_FACTOR && !_table->is_max_size_reached();\n@@ -221,6 +236,3 @@\n-  bool needs_resize(JavaThread* current, size_t ceiling, size_t count, size_t max) {\n-    const size_t log_size = _table->get_size_log2(current);\n-    const int log_ceiling = log2i_graceful(ceiling);\n-    const int log_max = log2i_graceful(max);\n-    const size_t log_count = log2i(MAX2(count, size_t(1)));\n-    const size_t log_target = clamp_log_size(MAX2(log_ceiling, log_max) + 2);\n+  bool should_resize() {\n+    return should_grow() || should_shrink() || Atomic::load(&_resize);\n+  }\n@@ -228,1 +240,16 @@\n-    return needs_grow(log_target, log_size) || needs_shrink(log_target, log_size) || Atomic::load(&_resize);\n+  template<typename Task, typename... Args>\n+  bool run_task(JavaThread* current, Task& task, const char* task_name, Args&... args) {\n+    if (task.prepare(current)) {\n+      log_trace(omworld)(\"Started to %s\", task_name);\n+      TraceTime timer(task_name, TRACETIME_LOG(Debug, omworld, perf));\n+      while (task.do_task(current, args...)) {\n+        task.pause(current);\n+        {\n+          ThreadBlockInVM tbivm(current);\n+        }\n+        task.cont(current);\n+      }\n+      task.done(current);\n+      return true;\n+    }\n+    return false;\n@@ -231,7 +258,9 @@\n-  bool resize(JavaThread* current, size_t ceiling, size_t count, size_t max) {\n-    const size_t log_size = _table->get_size_log2(current);\n-    const int log_ceiling = log2i_graceful(ceiling);\n-    const int log_max = log2i_graceful(max);\n-    const size_t log_count = log2i(MAX2(count, size_t(1)));\n-    const size_t log_target = clamp_log_size(MAX2(log_ceiling, log_max) + 2);\n-    LogTarget(Info, monitorinflation) lt;\n+  bool grow(JavaThread* current) {\n+    ConcurrentTable::GrowTask grow_task(_table);\n+    if (run_task(current, grow_task, \"Grow\")) {\n+      _table_size = table_size(current);\n+      log_info(omworld)(\"Grown to size: %zu\", _table_size);\n+      return true;\n+    }\n+    return false;\n+  }\n@@ -239,5 +268,4 @@\n-    auto print_table_stats = [&]() {\n-      ResourceMark rm;\n-      LogStream ls(lt);\n-      auto vs_f = [](Config::Value* v) { return sizeof(Config::Value); };\n-      _table->statistics_to(current, vs_f, &ls, \"ObjectMonitorWorld\");\n+  bool clean(JavaThread* current) {\n+    ConcurrentTable::BulkDeleteTask clean_task(_table);\n+    auto is_dead = [&](ObjectMonitor** monitor) {\n+      return (*monitor)->object_is_dead();\n@@ -245,0 +273,4 @@\n+    auto do_nothing = [&](ObjectMonitor** monitor) {};\n+    NativeHeapTrimmer::SuspendMark sm(\"omworld\");\n+    return run_task(current, clean_task, \"Clean\", is_dead, do_nothing);\n+  }\n@@ -246,12 +278,3 @@\n-    bool success = true;\n-\n-    if (needs_grow(log_target, log_size)) {\n-      \/\/ Grow\n-      lt.print(\"Growing to %02zu->%02zu\", log_size, log_target);\n-      success = _table->grow(current, log_target);\n-      print_table_stats();\n-    } else if (!_table->is_max_size_reached() && Atomic::load(&_resize)) {\n-      lt.print(\"WARNING: Getting resize hints with Size: %02zu Ceiling: %2i Target: %02zu\", log_size, log_ceiling, log_target);\n-      print_table_stats();\n-      success = false;\n-    }\n+  bool resize(JavaThread* current) {\n+    LogTarget(Info, omworld) lt;\n+    bool success = false;\n@@ -259,6 +282,9 @@\n-    if (needs_shrink(log_target, log_size)) {\n-      _shrink_count++;\n-      \/\/ Shrink\n-      lt.print(\"Shrinking to %02zu->%02zu\", log_size, log_target);\n-      success = _table->shrink(current, log_target);\n-      print_table_stats();\n+    if (should_grow()) {\n+      lt.print(\"Start growing with load factor %f\", get_load_factor());\n+      success = grow(current);\n+    } else {\n+      if (!_table->is_max_size_reached() && Atomic::load(&_resize)) {\n+        lt.print(\"WARNING: Getting resize hints with load factor %f\", get_load_factor());\n+      }\n+      lt.print(\"Start cleaning with load factor %f\", get_load_factor());\n+      success = clean(current);\n@@ -267,3 +293,1 @@\n-    if (success) {\n-      Atomic::store(&_resize, _table->is_max_size_reached());\n-    }\n+    Atomic::store(&_resize, false);\n@@ -428,14 +452,0 @@\n-\n-  if (!FLAG_IS_CMDLINE(AvgMonitorsPerThreadEstimate)) {\n-    \/\/ This is updated after ceiling is set and ObjectMonitorWorld is created;\n-    \/\/ TODO[OMWorld]: Clean this up and find a good initial ceiling,\n-    \/\/                and initial HashTable size\n-    FLAG_SET_ERGO(AvgMonitorsPerThreadEstimate, 0);\n-  }\n-}\n-\n-void LightweightSynchronizer::set_table_max(JavaThread* current) {\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    return;\n-  }\n-  _omworld->set_table_max(current);\n@@ -444,1 +454,1 @@\n-bool LightweightSynchronizer::needs_resize(JavaThread *current) {\n+bool LightweightSynchronizer::needs_resize() {\n@@ -448,4 +458,1 @@\n-  return _omworld->needs_resize(current,\n-                                  ObjectSynchronizer::in_use_list_ceiling(),\n-                                  ObjectSynchronizer::_in_use_list.count(),\n-                                  ObjectSynchronizer::_in_use_list.max());\n+  return _omworld->should_resize();\n@@ -458,4 +465,1 @@\n-  return _omworld->resize(current,\n-                          ObjectSynchronizer::in_use_list_ceiling(),\n-                          ObjectSynchronizer::_in_use_list.count(),\n-                          ObjectSynchronizer::_in_use_list.max());\n+  return _omworld->resize(current);\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":97,"deletions":93,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  static bool needs_resize(JavaThread* current);\n+  static bool needs_resize();\n@@ -58,1 +58,0 @@\n-  static void set_table_max(JavaThread* current);\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -39,1 +38,0 @@\n-#include \"utilities\/checkedCast.hpp\"\n@@ -67,1 +65,1 @@\n-  intx deflation_interval = max_intx;\n+  intx wait_time = max_intx;\n@@ -69,1 +67,1 @@\n-    deflation_interval = MIN2(deflation_interval, GuaranteedSafepointInterval);\n+    wait_time = MIN2(wait_time, GuaranteedSafepointInterval);\n@@ -72,1 +70,1 @@\n-    deflation_interval = MIN2(deflation_interval, AsyncDeflationInterval);\n+    wait_time = MIN2(wait_time, AsyncDeflationInterval);\n@@ -75,1 +73,1 @@\n-    deflation_interval = MIN2(deflation_interval, GuaranteedAsyncDeflationInterval);\n+    wait_time = MIN2(wait_time, GuaranteedAsyncDeflationInterval);\n@@ -81,1 +79,1 @@\n-  if (deflation_interval == max_intx) {\n+  if (wait_time == max_intx) {\n@@ -83,1 +81,0 @@\n-    LightweightSynchronizer::set_table_max(jt);\n@@ -87,1 +84,0 @@\n-    intx time_to_wait = deflation_interval;\n@@ -89,1 +85,0 @@\n-    bool resize = false;\n@@ -91,1 +86,0 @@\n-      \/\/ TODO[OMWorld]: This is all being rewritten.\n@@ -101,28 +95,1 @@\n-        ml.wait(time_to_wait);\n-\n-        \/\/ Handle LightweightSynchronizer Hash Table Resizing\n-        if (LightweightSynchronizer::needs_resize(jt)) {\n-          resize = true;\n-          break;\n-        }\n-      }\n-    }\n-\n-    if (resize) {\n-      \/\/ TODO[OMWorld]: Recheck this logic, especially !resize_successful and LightweightSynchronizer::needs_resize when is_max_size_reached == true\n-      const intx time_since_last_deflation = checked_cast<intx>(ObjectSynchronizer::time_since_last_async_deflation_ms());\n-      const bool resize_successful = LightweightSynchronizer::resize_table(jt);\n-      const bool deflation_interval_passed = time_since_last_deflation >= deflation_interval;\n-      const bool deflation_needed = deflation_interval_passed && ObjectSynchronizer::is_async_deflation_needed();\n-\n-      if (!resize_successful) {\n-        \/\/ Resize failed, try again in 250 ms\n-        time_to_wait = 250;\n-      } else if (deflation_interval_passed) {\n-        time_to_wait = deflation_interval;\n-      } else {\n-        time_to_wait = deflation_interval - time_since_last_deflation;\n-      }\n-\n-      if (!deflation_needed) {\n-        continue;\n+        ml.wait(wait_time);\n@@ -130,2 +97,0 @@\n-    } else {\n-      time_to_wait = deflation_interval;\n@@ -134,1 +99,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/monitorDeflationThread.cpp","additions":6,"deletions":42,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -98,0 +99,1 @@\n+    bool omworldtable_work = false;\n@@ -127,1 +129,2 @@\n-              (jvmti_tagmap_work = JvmtiTagMap::has_object_free_events_and_reset())\n+              (jvmti_tagmap_work = JvmtiTagMap::has_object_free_events_and_reset()) |\n+              (omworldtable_work = LightweightSynchronizer::needs_resize())\n@@ -199,0 +202,4 @@\n+\n+    if (omworldtable_work) {\n+      LightweightSynchronizer::resize_table(jt);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -406,0 +406,1 @@\n+  static const Mutex::Rank DEFAULT_MUTEX_RANK = static_cast<Mutex::Rank>(static_cast<int>(Mutex::nosafepoint) - 2);\n@@ -410,1 +411,1 @@\n-                      Mutex::Rank rank = Mutex::nosafepoint-2,\n+                      Mutex::Rank rank = DEFAULT_MUTEX_RANK,\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}