{"files":[{"patch":"@@ -7235,1 +7235,14 @@\n-instruct loadNKlass(iRegNNoSp dst, memory4 mem, rFlagsReg cr)\n+instruct loadNKlass(iRegNNoSp dst, memory4 mem)\n+%{\n+  match(Set dst (LoadNKlass mem));\n+  predicate(!needs_acquiring_load(n) && !UseCompactObjectHeaders);\n+\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"ldrw  $dst, $mem\\t# compressed class ptr\" %}\n+\n+  ins_encode(aarch64_enc_ldrw(dst, mem));\n+\n+  ins_pipe(iload_reg_mem);\n+%}\n+\n+instruct loadNKlassLilliput(iRegNNoSp dst, memory4 mem, rFlagsReg cr)\n@@ -7239,1 +7252,1 @@\n-  predicate(!needs_acquiring_load(n));\n+  predicate(!needs_acquiring_load(n) && UseCompactObjectHeaders);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -238,0 +238,1 @@\n+  assert(UseCompactObjectHeaders, \"Only use with compact object headers\");\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"oops\/compressedKlass.hpp\"\n@@ -2290,0 +2291,2 @@\n+  Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());\n+  Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());\n@@ -2350,4 +2353,9 @@\n-      assert(UseCompressedClassPointers, \"Lilliput\");\n-      __ load_nklass(tmp, src);\n-      __ load_nklass(rscratch1, dst);\n-      __ cmpw(tmp, rscratch1);\n+      if (UseCompressedClassPointers) {\n+        __ load_nklass(tmp, src);\n+        __ load_nklass(rscratch1, dst);\n+        __ cmpw(tmp, rscratch1);\n+      } else {\n+        __ ldr(tmp, Address(src, oopDesc::klass_offset_in_bytes()));\n+        __ ldr(rscratch1, Address(dst, oopDesc::klass_offset_in_bytes()));\n+        __ cmp(tmp, rscratch1);\n+      }\n@@ -2475,3 +2483,0 @@\n-    if (UseCompressedClassPointers) {\n-      __ encode_klass_not_null(tmp);\n-    }\n@@ -2479,1 +2484,0 @@\n-    assert(UseCompressedClassPointers, \"Lilliput\");\n@@ -2481,2 +2485,1 @@\n-      __ load_nklass(rscratch1, dst);\n-      __ cmpw(tmp, rscratch1);\n+      __ cmp_klass(dst, tmp, rscratch1);\n@@ -2484,2 +2487,1 @@\n-      __ load_nklass(rscratch1, src);\n-      __ cmpw(tmp, rscratch1);\n+      __ cmp_klass(src, tmp, rscratch1);\n@@ -2488,2 +2490,1 @@\n-      __ load_nklass(rscratch1, dst);\n-      __ cmpw(tmp, rscratch1);\n+      __ cmp_klass(dst, tmp, rscratch1);\n@@ -2569,7 +2570,7 @@\n-  assert(UseCompressedClassPointers, \"expects UseCompressedClassPointers\");\n-\n-  \/\/ Check if we can take the (common) fast path, if obj is unlocked.\n-  __ ldr(result, Address(obj, oopDesc::mark_offset_in_bytes()));\n-  __ tst(result, markWord::monitor_value);\n-  __ br(Assembler::NE, *op->stub()->entry());\n-  __ bind(*op->stub()->continuation());\n+  if (UseCompressedClassPointers) {\n+    if (UseCompactObjectHeaders) {\n+      \/\/ Check if we can take the (common) fast path, if obj is unlocked.\n+      __ ldr(result, Address(obj, oopDesc::mark_offset_in_bytes()));\n+      __ tst(result, markWord::monitor_value);\n+      __ br(Assembler::NE, *op->stub()->entry());\n+      __ bind(*op->stub()->continuation());\n@@ -2577,3 +2578,9 @@\n-  \/\/ Shift and decode Klass*.\n-  __ lsr(result, result, markWord::klass_shift);\n-  __ decode_klass_not_null(result);\n+      \/\/ Shift to get proper narrow Klass*.\n+      __ lsr(result, result, markWord::klass_shift);\n+    } else {\n+      __ ldrw(result, Address (obj, oopDesc::klass_offset_in_bytes()));\n+    }\n+    __ decode_klass_not_null(result);\n+  } else {\n+    __ ldr(result, Address (obj, oopDesc::klass_offset_in_bytes()));\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":31,"deletions":24,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -179,2 +179,15 @@\n-  ldr(t1, Address(klass, Klass::prototype_header_offset()));\n-  str(t1, Address(obj, oopDesc::mark_offset_in_bytes()));\n+  if (UseCompactObjectHeaders) {\n+    ldr(t1, Address(klass, Klass::prototype_header_offset()));\n+    str(t1, Address(obj, oopDesc::mark_offset_in_bytes()));\n+  } else {\n+    \/\/ This assumes that all prototype bits fit in an int32_t\n+    mov(t1, (int32_t)(intptr_t)markWord::prototype().value());\n+    str(t1, Address(obj, oopDesc::mark_offset_in_bytes()));\n+\n+    if (UseCompressedClassPointers) { \/\/ Take care not to kill klass\n+      encode_klass_not_null(t1, klass);\n+      strw(t1, Address(obj, oopDesc::klass_offset_in_bytes()));\n+    } else {\n+      str(klass, Address(obj, oopDesc::klass_offset_in_bytes()));\n+    }\n+  }\n@@ -184,0 +197,2 @@\n+  } else if (UseCompressedClassPointers && !UseCompactObjectHeaders) {\n+    store_klass_gap(obj, zr);\n@@ -308,1 +323,5 @@\n-  assert(!MacroAssembler::needs_explicit_null_check(oopDesc::mark_offset_in_bytes()), \"must add explicit null check\");\n+  if (UseCompactObjectHeaders) {\n+    assert(!MacroAssembler::needs_explicit_null_check(oopDesc::mark_offset_in_bytes()), \"must add explicit null check\");\n+  } else {\n+    assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()), \"must add explicit null check\");\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-void CompressedKlassPointers::print_mode(outputStream* st) {\n+void CompressedKlassPointers::print_mode_pd(outputStream* st) {\n","filename":"src\/hotspot\/cpu\/aarch64\/compressedKlass_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4262,0 +4262,5 @@\n+  if (!UseCompactObjectHeaders) {\n+    ldrw(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+    return;\n+  }\n+\n@@ -4266,2 +4271,1 @@\n-  tst(dst, markWord::monitor_value);\n-  br(Assembler::EQ, fast);\n+  tbz(dst, exact_log2(markWord::monitor_value), fast);\n@@ -4278,2 +4282,10 @@\n-  load_nklass(dst, src);\n-  decode_klass_not_null(dst);\n+  if (UseCompressedClassPointers) {\n+    if (UseCompactObjectHeaders) {\n+      load_nklass(dst, src);\n+    } else {\n+      ldrw(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+    }\n+    decode_klass_not_null(dst);\n+  } else {\n+    ldr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+  }\n@@ -4318,10 +4330,19 @@\n-  assert(UseCompressedClassPointers, \"Lilliput\");\n-  load_nklass(tmp, oop);\n-  if (CompressedKlassPointers::base() == NULL) {\n-    cmp(trial_klass, tmp, LSL, CompressedKlassPointers::shift());\n-    return;\n-  } else if (((uint64_t)CompressedKlassPointers::base() & 0xffffffff) == 0\n-             && CompressedKlassPointers::shift() == 0) {\n-    \/\/ Only the bottom 32 bits matter\n-    cmpw(trial_klass, tmp);\n-    return;\n+  assert_different_registers(oop, trial_klass, tmp);\n+  if (UseCompressedClassPointers) {\n+    if (UseCompactObjectHeaders) {\n+      load_nklass(tmp, oop);\n+    } else {\n+      ldrw(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));\n+    }\n+    if (CompressedKlassPointers::base() == NULL) {\n+      cmp(trial_klass, tmp, LSL, CompressedKlassPointers::shift());\n+      return;\n+    } else if (((uint64_t)CompressedKlassPointers::base() & 0xffffffff) == 0\n+               && CompressedKlassPointers::shift() == 0) {\n+      \/\/ Only the bottom 32 bits matter\n+      cmpw(trial_klass, tmp);\n+      return;\n+    }\n+    decode_klass_not_null(tmp);\n+  } else {\n+    ldr(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));\n@@ -4329,1 +4350,0 @@\n-  decode_klass_not_null(tmp);\n@@ -4333,0 +4353,18 @@\n+void MacroAssembler::store_klass(Register dst, Register src) {\n+  \/\/ FIXME: Should this be a store release?  concurrent gcs assumes\n+  \/\/ klass length is valid if klass field is not null.\n+  if (UseCompressedClassPointers) {\n+    encode_klass_not_null(src);\n+    strw(src, Address(dst, oopDesc::klass_offset_in_bytes()));\n+  } else {\n+    str(src, Address(dst, oopDesc::klass_offset_in_bytes()));\n+  }\n+}\n+\n+void MacroAssembler::store_klass_gap(Register dst, Register src) {\n+  if (UseCompressedClassPointers) {\n+    \/\/ Store to klass gap in destination\n+    strw(src, Address(dst, oopDesc::klass_gap_offset_in_bytes()));\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":53,"deletions":15,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -858,0 +858,1 @@\n+  void store_klass(Register dst, Register src);\n@@ -883,0 +884,2 @@\n+  void store_klass_gap(Register dst, Register src);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3516,1 +3516,1 @@\n-    __ sub(r3, r3, sizeof(oopDesc));\n+    __ sub(r3, r3, oopDesc::base_offset_in_bytes());\n@@ -3521,1 +3521,6 @@\n-      __ add(r2, r0, sizeof(oopDesc));\n+      __ add(r2, r0, oopDesc::base_offset_in_bytes());\n+      if (!is_aligned(oopDesc::base_offset_in_bytes(), BytesPerLong)) {\n+        __ strw(zr, Address(__ post(r2, BytesPerInt)));\n+        __ sub(r3, r3, BytesPerInt);\n+        __ cbz(r3, initialize_header);\n+      }\n@@ -3531,3 +3536,8 @@\n-    __ ldr(rscratch1, Address(r4, Klass::prototype_header_offset()));\n-    __ str(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));\n-\n+    if (UseCompactObjectHeaders) {\n+      __ ldr(rscratch1, Address(r4, Klass::prototype_header_offset()));\n+      __ str(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));\n+    } else {\n+      __ mov(rscratch1, (intptr_t)markWord::prototype().value());\n+      __ str(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));\n+      __ store_klass(r0, r4);      \/\/ store klass last\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-void CompressedKlassPointers::print_mode(outputStream* st) {\n+void CompressedKlassPointers::print_mode_pd(outputStream* st) {\n","filename":"src\/hotspot\/cpu\/ppc\/compressedKlass_ppc64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-void CompressedKlassPointers::print_mode(outputStream* st) {\n+void CompressedKlassPointers::print_mode_pd(outputStream* st) {\n","filename":"src\/hotspot\/cpu\/s390\/compressedKlass_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -283,0 +283,1 @@\n+  assert(UseCompactObjectHeaders, \"only with compact headers\");\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3069,1 +3069,1 @@\n-  Register tmp2 = LP64_ONLY(rscratch2) NOT_LP64(noreg);\n+  Register tmp2 = UseCompactObjectHeaders ? rscratch2 : noreg;\n@@ -3194,1 +3194,0 @@\n-#ifndef _LP64\n@@ -3197,1 +3196,1 @@\n-#endif\n+\n@@ -3262,8 +3261,1 @@\n-#ifdef _LP64\n-      __ load_nklass(tmp, src);\n-      __ load_nklass(tmp2, dst);\n-      __ cmpl(tmp, tmp2);\n-#else\n-      __ movptr(tmp, src_klass_addr);\n-      __ cmpptr(tmp, dst_klass_addr);\n-#endif\n+      __ cmp_klass(src, dst, tmp, tmp2);\n@@ -3425,13 +3417,4 @@\n-    assert(UseCompressedClassPointers, \"Lilliput\");\n-    __ encode_klass_not_null(tmp, rscratch1);\n-    if (basic_type != T_OBJECT) {\n-      __ load_nklass(tmp2, dst);\n-      __ cmpl(tmp, tmp2);\n-      __ jcc(Assembler::notEqual, halt);\n-      __ load_nklass(tmp2, src);\n-      __ cmpl(tmp, tmp2);\n-      __ jcc(Assembler::equal, known_ok);\n-    } else {\n-      __ load_nklass(tmp2, dst);\n-      __ cmpl(tmp, tmp2);\n-#else\n+    if (UseCompressedClassPointers) {\n+      __ encode_klass_not_null(tmp, rscratch1);\n+    }\n+#endif\n@@ -3439,1 +3422,1 @@\n-      __ cmpptr(tmp, dst_klass_addr);\n+      __ cmp_klass(tmp, dst, tmp2);\n@@ -3441,1 +3424,1 @@\n-      __ cmpptr(tmp, src_klass_addr);\n+      __ cmp_klass(tmp, src, tmp2);\n@@ -3444,2 +3427,1 @@\n-      __ cmpptr(tmp, dst_klass_addr);\n-#endif\n+      __ cmp_klass(tmp, dst, tmp2);\n@@ -3539,0 +3521,1 @@\n+\n@@ -3540,16 +3523,18 @@\n-  Register tmp = rscratch1;\n-  assert_different_registers(tmp, obj);\n-  assert_different_registers(tmp, result);\n-\n-  \/\/ Check if we can take the (common) fast path, if obj is unlocked.\n-  __ movq(result, Address(obj, oopDesc::mark_offset_in_bytes()));\n-  __ testb(result, markWord::monitor_value);\n-  __ jcc(Assembler::notZero, *op->stub()->entry());\n-  __ bind(*op->stub()->continuation());\n-  \/\/ Fast-path: shift and decode Klass*.\n-  __ shrq(result, markWord::klass_shift);\n-  __ decode_klass_not_null(result, tmp);\n-#else\n-  __ movptr(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n-  \/\/ Not really needed, but bind the label anyway to make compiler happy.\n-  __ bind(*op->stub()->continuation());\n+  if (UseCompactObjectHeaders) {\n+    Register tmp = rscratch1;\n+    assert_different_registers(tmp, obj);\n+    assert_different_registers(tmp, result);\n+\n+    \/\/ Check if we can take the (common) fast path, if obj is unlocked.\n+    __ movq(result, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    __ testb(result, markWord::monitor_value);\n+    __ jcc(Assembler::notZero, *op->stub()->entry());\n+    __ bind(*op->stub()->continuation());\n+    \/\/ Fast-path: shift and decode Klass*.\n+    __ shrq(result, markWord::klass_shift);\n+    __ decode_klass_not_null(result, tmp);\n+  } else\n+  if (UseCompressedClassPointers) {\n+    __ movl(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n+    __ decode_klass_not_null(result, rscratch1);\n+  } else\n@@ -3557,0 +3542,1 @@\n+    __ movptr(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":30,"deletions":44,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -166,4 +166,11 @@\n-  movptr(t1, Address(klass, Klass::prototype_header_offset()));\n-  movptr(Address(obj, oopDesc::mark_offset_in_bytes()), t1);\n-#ifndef _LP64\n-  movptr(Address(obj, oopDesc::klass_offset_in_bytes()), klass);\n+  if (UseCompactObjectHeaders) {\n+    movptr(t1, Address(klass, Klass::prototype_header_offset()));\n+    movptr(Address(obj, oopDesc::mark_offset_in_bytes()), t1);\n+  } else {\n+    movptr(Address(obj, oopDesc::mark_offset_in_bytes()), checked_cast<int32_t>(markWord::prototype().value()));\n+#ifdef _LP64\n+    if (UseCompressedClassPointers) { \/\/ Take care not to kill klass\n+      movptr(t1, klass);\n+      encode_klass_not_null(t1, rscratch1);\n+      movl(Address(obj, oopDesc::klass_offset_in_bytes()), t1);\n+    } else\n@@ -171,1 +178,4 @@\n-\n+    {\n+      movptr(Address(obj, oopDesc::klass_offset_in_bytes()), klass);\n+    }\n+  }\n@@ -175,0 +185,6 @@\n+#ifdef _LP64\n+  else if (UseCompressedClassPointers && !UseCompactObjectHeaders) {\n+    xorptr(t1, t1);\n+    store_klass_gap(obj, t1);\n+  }\n+#endif\n@@ -212,0 +228,1 @@\n+    int hdr_size_aligned = align_up(hdr_size_in_bytes, BytesPerWord); \/\/ klass gap is already cleared by init_header().\n@@ -214,1 +231,1 @@\n-      initialize_body(obj, index, hdr_size_in_bytes, t1_zero);\n+      initialize_body(obj, index, hdr_size_aligned, t1_zero);\n@@ -219,1 +236,1 @@\n-      for (int i = hdr_size_in_bytes; i < con_size_in_bytes; i += BytesPerWord)\n+      for (int i = hdr_size_aligned; i < con_size_in_bytes; i += BytesPerWord)\n@@ -221,1 +238,1 @@\n-    } else if (con_size_in_bytes > hdr_size_in_bytes) {\n+    } else if (con_size_in_bytes > hdr_size_aligned) {\n@@ -226,1 +243,1 @@\n-      movptr(index, (con_size_in_bytes - hdr_size_in_bytes) >> 3);\n+      movptr(index, (con_size_in_bytes - hdr_size_aligned) >> 3);\n@@ -228,1 +245,1 @@\n-      if (((con_size_in_bytes - hdr_size_in_bytes) & 4) != 0)\n+      if (((con_size_in_bytes - hdr_size_aligned) & 4) != 0)\n@@ -233,1 +250,1 @@\n-        movptr(Address(obj, index, Address::times_8, hdr_size_in_bytes - (1*BytesPerWord)),\n+        movptr(Address(obj, index, Address::times_8, hdr_size_aligned - (1*BytesPerWord)),\n@@ -235,1 +252,1 @@\n-        NOT_LP64(movptr(Address(obj, index, Address::times_8, hdr_size_in_bytes - (2*BytesPerWord)),\n+        NOT_LP64(movptr(Address(obj, index, Address::times_8, hdr_size_aligned - (2*BytesPerWord)),\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":29,"deletions":12,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-void CompressedKlassPointers::print_mode(outputStream* st) {\n+void CompressedKlassPointers::print_mode_pd(outputStream* st) {\n","filename":"src\/hotspot\/cpu\/x86\/compressedKlass_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5140,0 +5140,5 @@\n+  if (!UseCompactObjectHeaders) {\n+    movl(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+    return;\n+  }\n+\n@@ -5157,5 +5162,4 @@\n-  assert(UseCompressedClassPointers, \"expect compressed class pointers\");\n-  load_nklass(dst, src);\n-  decode_klass_not_null(dst, tmp);\n-#else\n-  movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+  if (UseCompressedClassPointers) {\n+    load_nklass(dst, src);\n+    decode_klass_not_null(dst, tmp);\n+  } else\n@@ -5163,0 +5167,1 @@\n+    movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n@@ -5166,0 +5171,12 @@\n+  if (UseCompactObjectHeaders) {\n+    null_check(src, oopDesc::mark_offset_in_bytes());\n+  } else {\n+    null_check(src, oopDesc::klass_offset_in_bytes());\n+  }\n+  load_klass(dst, src, tmp);\n+}\n+\n+void MacroAssembler::store_klass(Register dst, Register src, Register tmp) {\n+  assert(!UseCompactObjectHeaders, \"not with compact headers\");\n+  assert_different_registers(src, tmp);\n+  assert_different_registers(dst, tmp);\n@@ -5167,3 +5184,4 @@\n-  null_check(src, oopDesc::mark_offset_in_bytes());\n-#else\n-  null_check(src, oopDesc::klass_offset_in_bytes());\n+  if (UseCompressedClassPointers) {\n+    encode_klass_not_null(src, tmp);\n+    movl(Address(dst, oopDesc::klass_offset_in_bytes()), src);\n+  } else\n@@ -5171,1 +5189,1 @@\n-  load_klass(dst, src, tmp);\n+   movptr(Address(dst, oopDesc::klass_offset_in_bytes()), src);\n@@ -5174,3 +5192,15 @@\n-#ifndef _LP64\n-void MacroAssembler::store_klass(Register dst, Register src) {\n-  movptr(Address(dst, oopDesc::klass_offset_in_bytes()), src);\n+void MacroAssembler::cmp_klass(Register klass, Register obj, Register tmp) {\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    \/\/ NOTE: We need to deal with possible ObjectMonitor in object header.\n+    \/\/ Eventually we might be able to do simple movl & cmpl like in\n+    \/\/ the CCP path below.\n+    load_nklass(tmp, obj);\n+    cmpl(klass, tmp);\n+  } else if (UseCompressedClassPointers) {\n+    cmpl(klass, Address(obj, oopDesc::klass_offset_in_bytes()));\n+  } else\n+#endif\n+  {\n+    cmpptr(klass, Address(obj, oopDesc::klass_offset_in_bytes()));\n+  }\n@@ -5178,0 +5208,16 @@\n+\n+void MacroAssembler::cmp_klass(Register src, Register dst, Register tmp1, Register tmp2) {\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    \/\/ NOTE: We need to deal with possible ObjectMonitor in object header.\n+    \/\/ Eventually we might be able to do simple movl & cmpl like in\n+    \/\/ the CCP path below.\n+    assert(tmp2 != noreg, \"need tmp2\");\n+    assert_different_registers(src, dst, tmp1, tmp2);\n+    load_nklass(tmp1, src);\n+    load_nklass(tmp2, dst);\n+    cmpl(tmp1, tmp2);\n+  } else if (UseCompressedClassPointers) {\n+    movl(tmp1, Address(src, oopDesc::klass_offset_in_bytes()));\n+    cmpl(tmp1, Address(dst, oopDesc::klass_offset_in_bytes()));\n+  } else\n@@ -5179,0 +5225,5 @@\n+  {\n+    movptr(tmp1, Address(src, oopDesc::klass_offset_in_bytes()));\n+    cmpptr(tmp1, Address(dst, oopDesc::klass_offset_in_bytes()));\n+  }\n+}\n@@ -5226,0 +5277,7 @@\n+void MacroAssembler::store_klass_gap(Register dst, Register src) {\n+  if (UseCompressedClassPointers) {\n+    \/\/ Store to klass gap in destination\n+    movl(Address(dst, oopDesc::klass_gap_offset_in_bytes()), src);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":70,"deletions":12,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -375,2 +375,0 @@\n-#else\n-  void store_klass(Register dst, Register src);\n@@ -380,0 +378,9 @@\n+  void store_klass(Register dst, Register src, Register tmp);\n+\n+  \/\/ Compares the Klass pointer of an object to a given Klass (which might be narrow,\n+  \/\/ depending on UseCompressedClassPointers).\n+  void cmp_klass(Register klass, Register dst, Register tmp);\n+\n+  \/\/ Compares the Klass pointer of two objects o1 and o2. Result is in the condition flags.\n+  \/\/ Uses t1 and t2 as temporary registers.\n+  void cmp_klass(Register src, Register dst, Register tmp1, Register tmp2);\n@@ -398,0 +405,2 @@\n+  void store_klass_gap(Register dst, Register src);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3969,1 +3969,2 @@\n-    __ decrement(rdx, sizeof(oopDesc));\n+    int header_size = align_up(oopDesc::base_offset_in_bytes(), BytesPerLong);\n+    __ decrement(rdx, header_size);\n@@ -3991,2 +3992,2 @@\n-    __ movptr(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - 1*oopSize), rcx);\n-    NOT_LP64(__ movptr(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - 2*oopSize), rcx));\n+    __ movptr(Address(rax, rdx, Address::times_8, header_size - 1*oopSize), rcx);\n+    NOT_LP64(__ movptr(Address(rax, rdx, Address::times_8, header_size - 2*oopSize), rcx));\n@@ -3999,5 +4000,11 @@\n-    __ pop(rcx);   \/\/ get saved klass back in the register.\n-    __ movptr(rbx, Address(rcx, Klass::prototype_header_offset()));\n-    __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()), rbx);\n-#ifndef _LP64\n-    __ store_klass(rax, rcx);  \/\/ klass\n+    if (UseCompactObjectHeaders) {\n+      __ pop(rcx);   \/\/ get saved klass back in the register.\n+      __ movptr(rbx, Address(rcx, Klass::prototype_header_offset()));\n+      __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()), rbx);\n+    } else {\n+      __ movptr(Address(rax, oopDesc::mark_offset_in_bytes()),\n+                (intptr_t)markWord::prototype().value()); \/\/ header\n+      __ pop(rcx);   \/\/ get saved klass back in the register.\n+#ifdef _LP64\n+      __ xorl(rsi, rsi); \/\/ use zero reg to clear memory (shorter code)\n+      __ store_klass_gap(rax, rsi);  \/\/ zero klass gap for compressed oops\n@@ -4005,0 +4012,2 @@\n+      __ store_klass(rax, rcx, rscratch1);  \/\/ klass\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -5316,1 +5316,1 @@\n-instruct loadNKlass(rRegN dst, indOffset8 mem, rFlagsReg cr)\n+instruct loadNKlass(rRegN dst, memory mem)\n@@ -5318,0 +5318,14 @@\n+  predicate(!UseCompactObjectHeaders);\n+  match(Set dst (LoadNKlass mem));\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movl    $dst, $mem\\t# compressed klass ptr\" %}\n+  ins_encode %{\n+    __ movl($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem); \/\/ XXX\n+%}\n+\n+instruct loadNKlassLilliput(rRegN dst, indOffset8 mem, rFlagsReg cr)\n+%{\n+  predicate(UseCompactObjectHeaders);\n@@ -12687,3 +12701,0 @@\n-\/\/ Disabled because the compressed Klass* in header cannot be safely\n-\/\/ accessed. TODO: Re-enable it as soon as synchronization does not\n-\/\/ overload the upper header bits anymore.\n@@ -12692,1 +12703,1 @@\n-  predicate(false);\n+  predicate(!UseCompactObjectHeaders);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-void CompressedKlassPointers::print_mode(outputStream* st) {\n+void CompressedKlassPointers::print_mode_pd(outputStream* st) {\n","filename":"src\/hotspot\/cpu\/zero\/compressedKlass_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -891,1 +891,1 @@\n-      do_stub(opLoadKlass->_stub);\n+      if (opLoadKlass->_stub) do_stub(opLoadKlass->_stub);\n@@ -1072,1 +1072,3 @@\n-  masm->append_code_stub(stub());\n+  if (stub()) {\n+    masm->append_code_stub(stub());\n+  }\n@@ -2041,1 +2043,3 @@\n-  out->print(\"[lbl:\" INTPTR_FORMAT \"]\", p2i(stub()->entry()));\n+  if (stub()) {\n+    out->print(\"[lbl:\" INTPTR_FORMAT \"]\", p2i(stub()->entry()));\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1244,1 +1244,1 @@\n-  CodeStub* slow_path = new LoadKlassStub(klass);\n+  CodeStub* slow_path = UseCompactObjectHeaders ? new LoadKlassStub(klass) : nullptr;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -760,1 +760,0 @@\n-    Klass* requested_k = to_requested(k);\n@@ -762,5 +761,6 @@\n-    narrowKlass nk = CompressedKlassPointers::encode_not_null(requested_k, _requested_static_archive_bottom);\n-    k->set_prototype_header(markWord::prototype().set_narrow_klass(nk));\n-#else\n-    k->set_prototype_header(markWord::prototype());\n-#endif\n+    if (UseCompactObjectHeaders) {\n+      Klass* requested_k = to_requested(k);\n+      narrowKlass nk = CompressedKlassPointers::encode_not_null(requested_k, _requested_static_archive_bottom);\n+      k->set_prototype_header(markWord::prototype().set_narrow_klass(nk));\n+    }\n+#endif \/\/_LP64\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -223,2 +223,7 @@\n-    narrowKlass nk = ArchiveBuilder::current()->get_requested_narrow_klass(k);\n-    oopDesc::release_set_mark(mem, markWord::prototype().set_narrow_klass(nk));\n+    if (UseCompactObjectHeaders) {\n+      narrowKlass nk = ArchiveBuilder::current()->get_requested_narrow_klass(k);\n+      oopDesc::release_set_mark(mem, markWord::prototype().set_narrow_klass(nk));\n+    } else {\n+      oopDesc::set_mark(mem, markWord::prototype());\n+      oopDesc::release_set_klass(mem, k);\n+    }\n@@ -304,1 +309,6 @@\n-  oopDesc::set_mark(mem, markWord::prototype().set_narrow_klass(nk));\n+  if (UseCompactObjectHeaders) {\n+    oopDesc::release_set_mark(mem, markWord::prototype().set_narrow_klass(nk));\n+  } else {\n+    oopDesc::set_mark(mem, markWord::prototype());\n+    cast_to_oop(mem)->set_narrow_klass(nk);\n+  }\n@@ -486,0 +496,1 @@\n+  fake_oop->set_narrow_klass(nk);\n@@ -493,1 +504,5 @@\n-    fake_oop->set_mark(markWord::prototype().set_narrow_klass(nk).copy_set_hash(src_hash));\n+    if (UseCompactObjectHeaders) {\n+      fake_oop->set_mark(markWord::prototype().set_narrow_klass(nk).copy_set_hash(src_hash));\n+    } else {\n+      fake_oop->set_mark(markWord::prototype().copy_set_hash(src_hash));\n+    }\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -458,0 +458,1 @@\n+  Klass* klass;\n@@ -459,3 +460,3 @@\n-  Klass* klass = old_mark.safe_klass();\n-#else\n-  Klass* klass = old->klass();\n+  if (UseCompactObjectHeaders) {\n+    klass = old_mark.safe_klass();\n+  } else\n@@ -463,0 +464,3 @@\n+  {\n+    klass = old->klass();\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -166,0 +166,1 @@\n+  Klass* klass;\n@@ -167,3 +168,3 @@\n-  Klass* klass = test_mark.safe_klass();\n-#else\n-  Klass* klass = o->klass();\n+  if (UseCompactObjectHeaders) {\n+    klass = test_mark.safe_klass();\n+  } else\n@@ -171,0 +172,3 @@\n+  {\n+    klass = o->klass();\n+  }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -874,10 +874,10 @@\n-        oop forwardee = obj->forwardee();\n-        markWord header = forwardee->mark();\n-        if (header.has_displaced_mark_helper()) {\n-          header = header.displaced_mark_helper();\n-        }\n-        assert(UseCompressedClassPointers, \"assume +UseCompressedClassPointers\");\n-        narrowKlass nklass = header.narrow_klass();\n-        obj->set_mark(markWord::prototype().set_narrow_klass(nklass));\n-#else\n-        obj->init_mark();\n+        if (UseCompactObjectHeaders) {\n+          oop forwardee = obj->forwardee();\n+          markWord header = forwardee->mark();\n+          if (header.has_displaced_mark_helper()) {\n+            header = header.displaced_mark_helper();\n+          }\n+          assert(UseCompressedClassPointers, \"assume +UseCompressedClassPointers\");\n+          narrowKlass nklass = header.narrow_klass();\n+          obj->set_mark(markWord::prototype().set_narrow_klass(nklass));\n+        } else\n@@ -885,0 +885,3 @@\n+        {\n+          obj->init_mark();\n+        }\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -189,8 +189,8 @@\n-  markWord real_mark = mark;\n-  if (real_mark.has_displaced_mark_helper()) {\n-    real_mark = real_mark.displaced_mark_helper();\n-  }\n-  Klass* klass = real_mark.klass();\n-  obj->set_mark(klass->prototype_header().set_marked());\n-#else\n-  obj->set_mark(markWord::prototype().set_marked());\n+  if (UseCompactObjectHeaders) {\n+    markWord real_mark = mark;\n+    if (real_mark.has_displaced_mark_helper()) {\n+      real_mark = real_mark.displaced_mark_helper();\n+    }\n+    Klass* klass = real_mark.klass();\n+    obj->set_mark(klass->prototype_header().set_marked());\n+  } else\n@@ -198,0 +198,3 @@\n+  {\n+    obj->set_mark(markWord::prototype().set_marked());\n+  }\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.cpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -311,1 +311,1 @@\n-  static constexpr size_t min_dummy_object_size() {\n+  static size_t min_dummy_object_size() {\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -402,0 +402,3 @@\n+  if (!UseCompactObjectHeaders) {\n+    oopDesc::set_klass_gap(mem, 0);\n+  }\n@@ -410,6 +413,6 @@\n-#ifdef _LP64\n-  oopDesc::release_set_mark(mem, _klass->prototype_header());\n-#else\n-  oopDesc::set_mark(mem, _klass->prototype_header());\n-  oopDesc::release_set_klass(mem, _klass);\n-#endif\n+  if (UseCompactObjectHeaders) {\n+    oopDesc::release_set_mark(mem, _klass->prototype_header());\n+  } else {\n+    oopDesc::set_mark(mem, markWord::prototype());\n+    oopDesc::release_set_klass(mem, _klass);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+  assert(UseCompactObjectHeaders, \"only used with compact object headers\");\n@@ -127,0 +128,3 @@\n+  if (!UseCompactObjectHeaders) {\n+    return obj->klass();\n+  }\n@@ -137,0 +141,3 @@\n+  if (!UseCompactObjectHeaders) {\n+    return obj->size();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahObjectUtils.inline.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -75,1 +75,6 @@\n-  oopDesc::release_set_mark(mem, _klass->prototype_header());\n+  if (UseCompactObjectHeaders) {\n+    oopDesc::release_set_mark(mem, _klass->prototype_header());\n+  } else {\n+    arrayOopDesc::set_mark(mem, markWord::prototype());\n+    arrayOopDesc::release_set_klass(mem, _klass);\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -592,0 +592,7 @@\n+  \/\/ Note: code below is broken and needs rethinking since it confuses encoding base\n+  \/\/ with compressed class space attach address; both don't have be the same.\n+  \/\/ That is also the reason why we atm don't get zero-based encoding for aarch.\n+  \/\/ Comment is also wrong, at least for 9-bit shift.\n+\n+  \/\/ Will be fixed. For now it works well enough.\n+\n@@ -621,7 +628,9 @@\n-    assert(CompressedKlassPointers::is_valid_base(a), \"Sanity\");\n-    while (a < search_ranges[i].to) {\n-      ReservedSpace rs(size, Metaspace::reserve_alignment(),\n-                       os::vm_page_size(), (char*)a);\n-      if (rs.is_reserved()) {\n-        assert(a == (address)rs.base(), \"Sanity\");\n-        return rs;\n+    if (CompressedKlassPointers::is_valid_base(a)) {\n+      while (a < search_ranges[i].to) {\n+        ReservedSpace rs(size, Metaspace::reserve_alignment(),\n+                         os::vm_page_size(), (char*)a);\n+        if (rs.is_reserved()) {\n+          assert(a == (address)rs.base(), \"Sanity\");\n+          return rs;\n+        }\n+        a +=  search_ranges[i].increment;\n@@ -629,1 +638,0 @@\n-      a +=  search_ranges[i].increment;\n@@ -874,0 +882,1 @@\n+  assert(KlassEncodingMetaspaceMax > 0, \"too early.\");\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -112,0 +112,2 @@\n+#ifdef _LP64\n+    \/\/ TODO: This currently doesn't compile on 32bit because of size_t overflow.\n@@ -114,0 +116,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceReporter.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    return sizeof(arrayOopDesc);\n+    return oopDesc::base_offset_in_bytes();\n","filename":"src\/hotspot\/share\/oops\/arrayOop.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,8 @@\n+#ifdef _LP64\n+int LogKlassAlignmentInBytes = -1;\n+int KlassAlignmentInBytes    = -1;\n+int MaxNarrowKlassPointerBits = -1;\n+uint64_t  NarrowKlassPointerBitMask = 0;\n+uint64_t KlassEncodingMetaspaceMax = 0;\n+#endif\n+\n@@ -89,0 +97,13 @@\n+void CompressedKlassPointers::print_mode(outputStream* st) {\n+  st->print_cr(\"UseCompressedClassPointers: %d\", UseCompressedClassPointers);\n+  st->print_cr(\"UseCompactObjectHeaders: %d\", UseCompactObjectHeaders);\n+  st->print_cr(\"LogKlassAlignmentInBytes: %d\", LogKlassAlignmentInBytes);\n+  st->print_cr(\"KlassAlignmentInBytes: %d\", KlassAlignmentInBytes);\n+  st->print_cr(\"MaxNarrowKlassPointerBits: %d\", MaxNarrowKlassPointerBits);\n+#ifdef _LP64\n+  st->print_cr(\"NarrowKlassPointerBitMask: \" UINT64_FORMAT, NarrowKlassPointerBitMask);\n+  st->print_cr(\"KlassEncodingMetaspaceMax: \" UINT64_FORMAT \" (\" UINT64_FORMAT_X \")\", KlassEncodingMetaspaceMax, KlassEncodingMetaspaceMax);\n+  print_mode_pd(st);\n+#endif\n+}\n+\n@@ -99,3 +120,0 @@\n-\n-void CompressedKlassPointers::print_mode(outputStream* st) {\n-}\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -38,6 +38,3 @@\n-const int LogKlassAlignmentInBytes = 9; \/\/ 512 byte alignment (Lilliput)\n-#else\n-const int LogKlassAlignmentInBytes = 3; \/\/ traditional 64-bit alignment\n-#endif\n-\n-const int KlassAlignmentInBytes    = 1 << LogKlassAlignmentInBytes;\n+\/\/ All these depend on UseCompactObjectHeaders\n+extern int LogKlassAlignmentInBytes;\n+extern int KlassAlignmentInBytes;\n@@ -46,1 +43,1 @@\n-const  int      MaxNarrowKlassPointerBits = 22;\n+extern int MaxNarrowKlassPointerBits;\n@@ -49,1 +46,1 @@\n-const uint64_t  NarrowKlassPointerBitMask = ((((uint64_t)1) << MaxNarrowKlassPointerBits) - 1);\n+extern uint64_t NarrowKlassPointerBitMask;\n@@ -51,2 +48,11 @@\n-\/\/ Maximal size of compressed class pointer encoding range (2G with 22bit class ptr and 9 bit alignment).\n-const  uint64_t KlassEncodingMetaspaceMax = UCONST64(1) << (MaxNarrowKlassPointerBits + LogKlassAlignmentInBytes);\n+\/\/ Maximal size of compressed class pointer encoding range\n+extern uint64_t KlassEncodingMetaspaceMax;\n+\n+#else\n+\/\/ Why is this even needed in 32-bit? Todo: fix.\n+const int LogKlassAlignmentInBytes = 3; \/\/ traditional 64-bit alignment\n+const int KlassAlignmentInBytes    = 1 << LogKlassAlignmentInBytes;\n+const int MaxNarrowKlassPointerBits = 22; \/\/ should never be used.\n+const uint64_t  NarrowKlassPointerBitMask = ((((uint64_t)1) << MaxNarrowKlassPointerBits) - 1);\n+const uint64_t KlassEncodingMetaspaceMax = (uint64_t(max_juint) + 1) << LogKlassAlignmentInBytes;\n+#endif\n@@ -61,0 +67,1 @@\n+  \/\/ Encoding base\n@@ -74,0 +81,2 @@\n+  static void print_mode_pd(outputStream* st);\n+\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -36,3 +36,0 @@\n-  \/\/ aligned header size.\n-  static int header_size() { return sizeof(instanceOopDesc)\/HeapWordSize; }\n-\n@@ -41,1 +38,1 @@\n-    return sizeof(instanceOopDesc);\n+    return oopDesc::base_offset_in_bytes();\n","filename":"src\/hotspot\/share\/oops\/instanceOop.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -202,0 +202,10 @@\n+static markWord make_prototype(Klass* kls) {\n+  markWord prototype = markWord::prototype();\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    prototype = prototype.set_klass(kls);\n+  }\n+#endif\n+  return prototype;\n+}\n+\n@@ -207,1 +217,1 @@\n-                           _prototype_header(markWord::prototype() LP64_ONLY(.set_klass(this))),\n+                           _prototype_header(make_prototype(this)),\n@@ -752,2 +762,4 @@\n-     st->print(BULLET\"prototype_header: \" INTPTR_FORMAT, _prototype_header.value());\n-     st->cr();\n+     if (UseCompactObjectHeaders) {\n+       st->print(BULLET\"prototype_header: \" INTPTR_FORMAT, _prototype_header.value());\n+       st->cr();\n+     }\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -673,1 +673,4 @@\n-  markWord prototype_header() const      { return _prototype_header; }\n+  markWord prototype_header() const      {\n+    assert(UseCompactObjectHeaders, \"only use with compact object headers\");\n+    return _prototype_header;\n+  }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+  assert(UseCompactObjectHeaders, \"only with compact headers\");\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+  assert(UseCompactObjectHeaders, \"only used with compact object headers\");\n@@ -44,0 +45,1 @@\n+  assert(UseCompactObjectHeaders, \"only used with compact object headers\");\n@@ -48,0 +50,1 @@\n+  assert(UseCompactObjectHeaders, \"only used with compact object headers\");\n@@ -52,0 +55,1 @@\n+  assert(UseCompactObjectHeaders, \"only used with compact object headers\");\n@@ -61,0 +65,1 @@\n+  assert(UseCompactObjectHeaders, \"only used with compact object headers\");\n","filename":"src\/hotspot\/share\/oops\/markWord.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -159,0 +159,18 @@\n+bool oopDesc::has_klass_gap() {\n+  \/\/ Only has a klass gap when compressed class pointers are used, but\n+  \/\/ only if not using compact headers..\n+  return UseCompressedClassPointers && !UseCompactObjectHeaders;\n+}\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+void oopDesc::set_narrow_klass(narrowKlass nk) {\n+  assert(DumpSharedSpaces, \"Used by CDS only. Do not abuse!\");\n+  assert(UseCompressedClassPointers, \"must be\");\n+  if (UseCompactObjectHeaders) {\n+    set_mark(mark().set_narrow_klass(nk));\n+  } else {\n+    _metadata._compressed_klass = nk;\n+  }\n+}\n+#endif\n+\n@@ -166,1 +184,1 @@\n-  return obj->_klass;\n+  return obj->_metadata._klass;\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -58,3 +58,4 @@\n-#ifndef _LP64\n-  Klass*            _klass;\n-#endif\n+  union _metadata {\n+    Klass*      _klass;\n+    narrowKlass _compressed_klass;\n+  } _metadata;\n@@ -94,1 +95,1 @@\n-#ifndef _LP64\n+  void set_narrow_klass(narrowKlass nk) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -97,1 +98,3 @@\n-#endif\n+\n+  \/\/ For klass field compression\n+  static inline void set_klass_gap(HeapWord* mem, int z);\n@@ -100,1 +103,8 @@\n-  static constexpr int header_size() { return sizeof(oopDesc)\/HeapWordSize; }\n+  static int header_size() {\n+#ifdef _LP64\n+    if (UseCompactObjectHeaders) {\n+      return sizeof(markWord) \/ HeapWordSize;\n+    } else\n+#endif\n+    return sizeof(oopDesc)\/HeapWordSize;\n+  }\n@@ -314,0 +324,2 @@\n+  static bool has_klass_gap();\n+\n@@ -316,0 +328,6 @@\n+  static int klass_gap_offset_in_bytes() {\n+    assert(has_klass_gap(), \"only applicable to compressed klass pointers\");\n+    assert(!UseCompactObjectHeaders, \"don't use klass_offset_in_bytes() with compact headers\");\n+    return klass_offset_in_bytes() + sizeof(narrowKlass);\n+  }\n+\n@@ -318,4 +336,18 @@\n-    STATIC_ASSERT(markWord::klass_shift % 8 == 0);\n-    return mark_offset_in_bytes() + markWord::klass_shift \/ 8;\n-#else\n-    return offset_of(oopDesc, _klass);\n+    if (UseCompactObjectHeaders) {\n+      STATIC_ASSERT(markWord::klass_shift % 8 == 0);\n+      return mark_offset_in_bytes() + markWord::klass_shift \/ 8;\n+    } else\n+#endif\n+    return offset_of(oopDesc, _metadata._klass);\n+  }\n+\n+  static int base_offset_in_bytes() {\n+#ifdef _LP64\n+    if (UseCompactObjectHeaders) {\n+      \/\/ With compact headers, the Klass* field is not used for the Klass*\n+      \/\/ and is used for the object fields instead.\n+      assert(sizeof(markWord) == 8, \"sanity\");\n+      return sizeof(markWord);\n+    } else if (UseCompressedClassPointers) {\n+      return sizeof(markWord) + sizeof(narrowKlass);\n+    } else\n@@ -323,0 +355,1 @@\n+    return sizeof(oopDesc);\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":43,"deletions":10,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+  assert(UseFastLocking, \"Only safe with fast-locking\");\n@@ -100,5 +101,5 @@\n-  markWord header = resolve_mark();\n-  assert(UseCompressedClassPointers, \"expect compressed klass pointers\");\n-  header = markWord((header.value() & markWord::klass_mask_in_place) | markWord::prototype().value());\n-#else\n-  markWord header = markWord::prototype();\n+  if (UseCompactObjectHeaders) {\n+    markWord header = resolve_mark();\n+    assert(UseCompressedClassPointers, \"expect compressed klass pointers\");\n+    set_mark(markWord((header.value() & markWord::klass_mask_in_place) | markWord::prototype().value()));\n+  } else\n@@ -106,1 +107,1 @@\n-  set_mark(header);\n+  set_mark(markWord::prototype());\n@@ -111,5 +112,7 @@\n-  assert(UseCompressedClassPointers, \"only with compressed class pointers\");\n-  markWord header = resolve_mark();\n-  return header.klass();\n-#else\n-  return _klass;\n+  if (UseCompactObjectHeaders) {\n+    assert(UseCompressedClassPointers, \"only with compressed class pointers\");\n+    markWord header = resolve_mark();\n+    return header.klass();\n+  } else if (UseCompressedClassPointers) {\n+    return CompressedKlassPointers::decode_not_null(_metadata._compressed_klass);\n+  } else\n@@ -117,0 +120,1 @@\n+  return _metadata._klass;\n@@ -121,5 +125,7 @@\n-  assert(UseCompressedClassPointers, \"only with compressed class pointers\");\n-  markWord header = resolve_mark();\n-  return header.klass_or_null();\n-#else\n-  return _klass;\n+  if (UseCompactObjectHeaders) {\n+    assert(UseCompressedClassPointers, \"only with compressed class pointers\");\n+    markWord header = resolve_mark();\n+    return header.klass_or_null();\n+  } else if (UseCompressedClassPointers) {\n+    return CompressedKlassPointers::decode(_metadata._compressed_klass);\n+  } else\n@@ -127,0 +133,1 @@\n+  return _metadata._klass;\n@@ -131,8 +138,11 @@\n-  assert(UseCompressedClassPointers, \"only with compressed class pointers\");\n-  markWord header = mark_acquire();\n-  if (header.has_monitor()) {\n-    header = header.monitor()->header();\n-  }\n-  return header.klass_or_null();\n-#else\n-  return Atomic::load_acquire(&_klass);\n+  if (UseCompactObjectHeaders) {\n+    assert(UseCompressedClassPointers, \"only with compressed class pointers\");\n+    markWord header = mark_acquire();\n+    if (header.has_monitor()) {\n+      header = header.monitor()->header();\n+    }\n+    return header.klass_or_null();\n+  } else if (UseCompressedClassPointers) {\n+     narrowKlass nklass = Atomic::load_acquire(&_metadata._compressed_klass);\n+     return CompressedKlassPointers::decode(nklass);\n+  } else\n@@ -140,0 +150,1 @@\n+  return Atomic::load_acquire(&_metadata._klass);\n@@ -146,1 +157,0 @@\n-#ifndef _LP64\n@@ -148,2 +158,7 @@\n-  assert(Universe::is_bootstrapping() || (k != nullptr && k->is_klass()), \"incorrect Klass\");\n-  _klass = k;\n+  assert(Universe::is_bootstrapping() || (k != NULL && k->is_klass()), \"incorrect Klass\");\n+  assert(!UseCompactObjectHeaders, \"don't set Klass* with compact headers\");\n+  if (UseCompressedClassPointers) {\n+    _metadata._compressed_klass = CompressedKlassPointers::encode_not_null(k);\n+  } else {\n+    _metadata._klass = k;\n+  }\n@@ -153,1 +168,2 @@\n-  assert(Universe::is_bootstrapping() || (k != nullptr && k->is_klass()), \"incorrect Klass\");\n+  assert(Universe::is_bootstrapping() || (k != NULL && k->is_klass()), \"incorrect Klass\");\n+  assert(!UseCompactObjectHeaders, \"don't set Klass* with compact headers\");\n@@ -162,1 +178,7 @@\n-#endif\n+\n+void oopDesc::set_klass_gap(HeapWord* mem, int v) {\n+  assert(!UseCompactObjectHeaders, \"don't set Klass* gap with compact headers\");\n+  if (UseCompressedClassPointers) {\n+    *(int*)(((char*)mem) + klass_gap_offset_in_bytes()) = v;\n+  }\n+}\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":51,"deletions":29,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -1664,3 +1664,4 @@\n-#ifndef _LP64\n-  rawmem = make_store(control, rawmem, object, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);\n-#endif\n+  if (!UseCompactObjectHeaders) {\n+    rawmem = make_store(control, rawmem, object, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1507,0 +1507,3 @@\n+      if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS) {\n+        FLAG_SET_DEFAULT(UseCompressedClassPointers, false);\n+      }\n@@ -1512,0 +1515,1 @@\n+\n@@ -1516,7 +1520,39 @@\n-  if (!UseCompressedClassPointers) {\n-    \/\/ Lilliput requires compressed class pointers. Default shall reflect that.\n-    \/\/ If user specifies -UseCompressedClassPointers, it should be reverted with\n-    \/\/ a warning.\n-    assert(!FLAG_IS_DEFAULT(UseCompressedClassPointers), \"Wrong default for UseCompressedClassPointers\");\n-    warning(\"Lilliput reqires compressed class pointers.\");\n-    FLAG_SET_ERGO(UseCompressedClassPointers, true);\n+\n+  if (UseCompactObjectHeaders) {\n+    \/\/ 512 byte alignment, 22-bit values (Lilliput)\n+    LogKlassAlignmentInBytes = 9;\n+    MaxNarrowKlassPointerBits = 22;\n+  } else {\n+    \/\/ Traditional: 8 byte alignment, 32-bit values\n+    LogKlassAlignmentInBytes = 3;\n+    MaxNarrowKlassPointerBits = 32;\n+  }\n+\n+  KlassAlignmentInBytes = 1 << LogKlassAlignmentInBytes;\n+  NarrowKlassPointerBitMask = ((((uint64_t)1) << MaxNarrowKlassPointerBits) - 1);\n+  KlassEncodingMetaspaceMax = UCONST64(1) << (MaxNarrowKlassPointerBits + LogKlassAlignmentInBytes);\n+\n+  \/\/ On some architectures, the use of UseCompressedClassPointers implies the use of\n+  \/\/ UseCompressedOops. The reason is that the rheap_base register of said platforms\n+  \/\/ is reused to perform some optimized spilling, in order to use rheap_base as a\n+  \/\/ temp register. But by treating it as any other temp register, spilling can typically\n+  \/\/ be completely avoided instead. So it is better not to perform this trick. And by\n+  \/\/ not having that reliance, large heaps, or heaps not supporting compressed oops,\n+  \/\/ can still use compressed class pointers.\n+  if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS && !UseCompressedOops) {\n+    if (UseCompressedClassPointers) {\n+      warning(\"UseCompressedClassPointers requires UseCompressedOops\");\n+    }\n+    FLAG_SET_DEFAULT(UseCompressedClassPointers, false);\n+  } else {\n+    \/\/ Turn on UseCompressedClassPointers too\n+    if (FLAG_IS_DEFAULT(UseCompressedClassPointers)) {\n+      FLAG_SET_ERGO(UseCompressedClassPointers, true);\n+    }\n+    \/\/ Check the CompressedClassSpaceSize to make sure we use compressed klass ptrs.\n+    if (UseCompressedClassPointers) {\n+      if (CompressedClassSpaceSize > KlassEncodingMetaspaceMax) {\n+        warning(\"CompressedClassSpaceSize is too large for UseCompressedClassPointers\");\n+        FLAG_SET_DEFAULT(UseCompressedClassPointers, false);\n+      }\n+    }\n@@ -1524,0 +1560,1 @@\n+\n@@ -1527,4 +1564,6 @@\n-  assert(CompressedClassSpaceSize <= Metaspace::max_class_space_size(),\n-         \"CompressedClassSpaceSize \" SIZE_FORMAT \" too large (max: \" SIZE_FORMAT \")\",\n-         CompressedClassSpaceSize, Metaspace::max_class_space_size());\n-#endif \/\/ _LP64\n+  \/\/ TODO: This is placed wrong. The CompressedClassSpaceSizeFunc is done after ergo, but this\n+  \/\/ assert is during ergo.\n+  \/\/ assert(CompressedClassSpaceSize <= Metaspace::max_class_space_size(),\n+  \/\/        \"CompressedClassSpaceSize \" SIZE_FORMAT \" too large (max: \" SIZE_FORMAT \")\",\n+  \/\/        CompressedClassSpaceSize, Metaspace::max_class_space_size());\n+#endif\n@@ -1692,0 +1731,3 @@\n+          if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS) {\n+            FLAG_SET_ERGO(UseCompressedClassPointers, false);\n+          }\n@@ -3110,2 +3152,15 @@\n-  \/\/ Lilliput requires fast-locking.\n-  FLAG_SET_DEFAULT(UseFastLocking, true);\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders && FLAG_IS_CMDLINE(UseCompressedClassPointers) && !UseCompressedClassPointers) {\n+    \/\/ If user specifies -UseCompressedClassPointers, disable compact headers with a warning.\n+    warning(\"Compact object headers require compressed class pointers. Disabling compact object headers.\");\n+    FLAG_SET_DEFAULT(UseCompactObjectHeaders, false);\n+  }\n+\n+  if (UseCompactObjectHeaders && !UseFastLocking) {\n+    FLAG_SET_DEFAULT(UseFastLocking, true);\n+  }\n+\n+  if (!UseCompactObjectHeaders) {\n+    FLAG_SET_DEFAULT(UseSharedSpaces, false);\n+  }\n+#endif\n@@ -4086,1 +4141,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":68,"deletions":14,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -132,0 +132,3 @@\n+  product(bool, UseCompactObjectHeaders, true, EXPERIMENTAL,                \\\n+                \"Use 64-bit object headers instead of 96-bit headers\")      \\\n+                                                                            \\\n@@ -149,0 +152,1 @@\n+const bool UseCompactObjectHeaders = false;\n@@ -1416,1 +1420,1 @@\n-          constraint(CompressedClassSpaceSizeConstraintFunc,AtParse)        \\\n+          constraint(CompressedClassSpaceSizeConstraintFunc, AfterErgo)     \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -201,1 +201,2 @@\n-  NOT_LP64(volatile_nonstatic_field(oopDesc,   _klass,                                        Klass*))                               \\\n+  volatile_nonstatic_field(oopDesc,            _metadata._klass,                              Klass*)                                \\\n+  volatile_nonstatic_field(oopDesc,            _metadata._compressed_klass,                   narrowKlass)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import sun.jvm.hotspot.runtime.VM;\n@@ -399,5 +400,9 @@\n-    \/\/ On 64 bit systems, the compressed Klass* is currently read from the mark\n-    \/\/ word. We need to load the whole mark, and shift the upper parts.\n-    long value = readCInteger(address, machDesc.getAddressSize(), true);\n-    value = value >>> Mark.getKlassShift();\n-\n+    long value;\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n+      \/\/ On 64 bit systems, the compressed Klass* is currently read from the mark\n+      \/\/ word. We need to load the whole mark, and shift the upper parts.\n+      value = readCInteger(address, machDesc.getAddressSize(), true);\n+      value = value >>> Mark.getKlassShift();\n+    } else {\n+      value = readCInteger(address, getKlassPtrSize(), true);\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/DebuggerBase.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -64,1 +64,10 @@\n-    headerSize = lengthOffsetInBytes() + VM.getVM().getIntSize();\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n+      headerSize = lengthOffsetInBytes() + VM.getVM().getIntSize();\n+    } else {\n+      if (VM.getVM().isCompressedKlassPointersEnabled()) {\n+         headerSize = typeSize;\n+      } else {\n+        headerSize = VM.getVM().alignUp(typeSize + VM.getVM().getIntSize(),\n+                                        VM.getVM().getHeapWordSize());\n+      }\n+    }\n@@ -68,0 +77,8 @@\n+   private static long headerSize(BasicType type) {\n+     if (Universe.elementTypeShouldBeAligned(type)) {\n+        return alignObjectSize(headerSizeInBytes())\/VM.getVM().getHeapWordSize();\n+     } else {\n+       return headerSizeInBytes()\/VM.getVM().getHeapWordSize();\n+     }\n+   }\n+\n@@ -72,1 +89,9 @@\n-    lengthOffsetInBytes = typeSize;\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n+      lengthOffsetInBytes = Oop.getHeaderSize();\n+    } else {\n+      if (VM.getVM().isCompressedKlassPointersEnabled()) {\n+        lengthOffsetInBytes = typeSize - VM.getVM().getIntSize();\n+      } else {\n+        lengthOffsetInBytes = typeSize;\n+      }\n+    }\n@@ -94,4 +119,8 @@\n-    long typeSizeInBytes = headerSizeInBytes();\n-    if (Universe.elementTypeShouldBeAligned(type)) {\n-      VM vm = VM.getVM();\n-      return vm.alignUp(typeSizeInBytes, vm.getVM().getHeapWordSize());\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n+      long typeSizeInBytes = headerSizeInBytes();\n+      if (Universe.elementTypeShouldBeAligned(type)) {\n+        VM vm = VM.getVM();\n+        return vm.alignUp(typeSizeInBytes, vm.getVM().getHeapWordSize());\n+      } else {\n+        return typeSizeInBytes;\n+      }\n@@ -99,1 +128,1 @@\n-      return typeSizeInBytes;\n+      return headerSize(type) * VM.getVM().getHeapWordSize();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Array.java","additions":36,"deletions":7,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -58,0 +58,3 @@\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n+      return Oop.getHeaderSize();\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Instance.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -198,0 +198,1 @@\n+    assert(VM.getVM().isCompactObjectHeadersEnabled());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Mark.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,2 +49,7 @@\n-    if (!VM.getVM().isLP64()) {\n-      klass      = new MetadataField(type.getAddressField(\"_klass\"), 0);\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n+      Type markType = db.lookupType(\"markWord\");\n+      headerSize = markType.getSize();\n+    } else {\n+      headerSize = type.getSize();\n+      klass      = new MetadataField(type.getAddressField(\"_metadata._klass\"), 0);\n+      compressedKlass  = new NarrowKlassField(type.getAddressField(\"_metadata._compressed_klass\"), 0);\n@@ -52,1 +57,0 @@\n-    headerSize = type.getSize();\n@@ -81,0 +85,1 @@\n+    assert(VM.getVM().isCompactObjectHeadersEnabled());\n@@ -89,3 +94,5 @@\n-    if (VM.getVM().isLP64()) {\n-      assert(VM.getVM().isCompressedKlassPointersEnabled());\n-      return getKlass(getMark());\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n+        assert(VM.getVM().isCompressedKlassPointersEnabled());\n+        return getKlass(getMark());\n+    } else if (VM.getVM().isCompressedKlassPointersEnabled()) {\n+      return (Klass)compressedKlass.getValue(getHandle());\n@@ -161,2 +168,6 @@\n-      if (!VM.getVM().isLP64()) {\n-        visitor.doMetadata(klass, true);\n+      if (!VM.getVM().isCompactObjectHeadersEnabled()) {\n+        if (VM.getVM().isCompressedKlassPointersEnabled()) {\n+          visitor.doMetadata(compressedKlass, true);\n+        } else {\n+          visitor.doMetadata(klass, true);\n+        }\n@@ -218,1 +229,1 @@\n-    if (VM.getVM().isLP64()) {\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n@@ -221,0 +232,2 @@\n+    } else if (VM.getVM().isCompressedKlassPointersEnabled()) {\n+      return (Klass)Metadata.instantiateWrapperFor(handle.getCompKlassAddressAt(compressedKlass.getOffset()));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Oop.java","additions":22,"deletions":9,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -151,0 +151,1 @@\n+  private Boolean compactObjectHeadersEnabled;\n@@ -973,0 +974,9 @@\n+  public boolean isCompactObjectHeadersEnabled() {\n+    if (compactObjectHeadersEnabled == null) {\n+        Flag flag = getCommandLineFlag(\"UseCompactObjectHeaders\");\n+        compactObjectHeadersEnabled = (flag == null) ? Boolean.FALSE:\n+             (flag.getBool()? Boolean.TRUE: Boolean.FALSE);\n+    }\n+    return compactObjectHeadersEnabled.booleanValue();\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/VM.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -182,0 +182,1 @@\n+runtime\/CompressedOops\/CompressedClassSpaceSize.java 8302094 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-        return Platform.is64bit();\n+        return Platform.is64bit() && !InputArguments.contains(\"-XX:-UseCompressedClassPointers\") && !InputArguments.contains(\"-XX:-UseCompactObjectHeaders\");\n","filename":"test\/hotspot\/jtreg\/gc\/metaspace\/TestMetaspacePerfCounters.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,0 +93,34 @@\n+\n+\n+\/* @test id=ccs-on-compact-headers-on\n+ * @summary Run with +UseCCS and +UseCompactObjectHeaders\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @requires vm.bits == 64\n+ * @requires vm.flagless\n+ * @run main\/native GTestWrapper --gtest_filter=metaspace* -Xlog:metaspace* -XX:+UnlockExperimentalVMOptions -XX:+UseCompactObjectHeaders -XX:+UseCompressedClassPointers -XX:VerifyMetaspaceInterval=3\n+ *\/\n+\n+\/* @test id=ccs-on-compact-headers-off\n+ * @summary Run with +UseCCS and -UseCompactObjectHeaders\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @requires vm.bits == 64\n+ * @requires vm.flagless\n+ * @run main\/native GTestWrapper --gtest_filter=metaspace* -Xlog:metaspace* -XX:+UnlockExperimentalVMOptions -XX:-UseCompactObjectHeaders -XX:+UseCompressedClassPointers -XX:VerifyMetaspaceInterval=3\n+ *\/\n+\n+\/* @test id=ccs-off\n+ * @summary Run with -UseCCS\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @requires vm.bits == 64\n+ * @requires vm.flagless\n+ * @run main\/native GTestWrapper --gtest_filter=metaspace* -Xlog:metaspace* -XX:-UseCompressedClassPointers -XX:VerifyMetaspaceInterval=3\n+ *\/\n+\n+\n+\n","filename":"test\/hotspot\/jtreg\/gtest\/MetaspaceGtests.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/\n@@ -29,1 +29,3 @@\n- * @run main\/othervm BaseOffsets\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI BaseOffsets\n@@ -33,1 +35,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/\n@@ -37,1 +39,3 @@\n- * @run main\/othervm -XX:-UseCompressedOops BaseOffsets\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-UseCompressedOops BaseOffsets\n@@ -47,0 +51,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -54,2 +59,21 @@\n-    \/\/ @0:  8 byte header,  @8: int field\n-    static final long INT_OFFSET  = 8L;\n+    public static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+  \/\/ @0:  8 byte header,  @8: int field\n+    static final long INT_OFFSET;\n+    static final int  INT_ARRAY_OFFSET;\n+    static final int  LONG_ARRAY_OFFSET;\n+    static {\n+        if (!Platform.is64bit() || WB.getBooleanVMFlag(\"UseCompactObjectHeaders\")) {\n+            INT_OFFSET = 8;\n+            INT_ARRAY_OFFSET = 12;\n+            LONG_ARRAY_OFFSET = 16;\n+        } else if (WB.getBooleanVMFlag(\"UseCompressedClassPointers\")) {\n+            INT_OFFSET = 12;\n+            INT_ARRAY_OFFSET = 16;\n+            LONG_ARRAY_OFFSET = 16;\n+        } else {\n+            INT_OFFSET = 16;\n+            INT_ARRAY_OFFSET = 20;\n+            LONG_ARRAY_OFFSET = 24;\n+        }\n+    }\n@@ -70,8 +94,8 @@\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(boolean[].class), 12, \"Misplaced boolean array base\");\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(byte[].class),    12, \"Misplaced byte    array base\");\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(char[].class),    12, \"Misplaced char    array base\");\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(short[].class),   12, \"Misplaced short   array base\");\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(int[].class),     12, \"Misplaced int     array base\");\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(long[].class),    16, \"Misplaced long    array base\");\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(float[].class),   12, \"Misplaced float   array base\");\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(double[].class),  16, \"Misplaced double  array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(boolean[].class), INT_ARRAY_OFFSET,  \"Misplaced boolean array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(byte[].class),    INT_ARRAY_OFFSET,  \"Misplaced byte    array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(char[].class),    INT_ARRAY_OFFSET,  \"Misplaced char    array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(short[].class),   INT_ARRAY_OFFSET,  \"Misplaced short   array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(int[].class),     INT_ARRAY_OFFSET,  \"Misplaced int     array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(long[].class),    LONG_ARRAY_OFFSET, \"Misplaced long    array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(float[].class),   INT_ARRAY_OFFSET,  \"Misplaced float   array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(double[].class),  LONG_ARRAY_OFFSET, \"Misplaced double  array base\");\n@@ -80,1 +104,1 @@\n-        int expected_objary_offset = narrowOops ? 12 : 16;\n+        int expected_objary_offset = narrowOops ? INT_ARRAY_OFFSET : LONG_ARRAY_OFFSET;\n","filename":"test\/hotspot\/jtreg\/runtime\/FieldLayout\/BaseOffsets.java","additions":39,"deletions":15,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/\n@@ -32,1 +32,3 @@\n- * @run main\/othervm -XX:+UseCompressedClassPointers -XX:-UseEmptySlotsInSupers OldLayoutCheck\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseCompressedClassPointers -XX:-UseEmptySlotsInSupers OldLayoutCheck\n@@ -38,1 +40,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/\n@@ -41,1 +43,3 @@\n- * @run main\/othervm -XX:-UseEmptySlotsInSupers OldLayoutCheck\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-UseEmptySlotsInSupers OldLayoutCheck\n@@ -51,0 +55,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -59,4 +64,15 @@\n-    \/\/ 32-bit VMs: @0:  8 byte header,  @8: long field, @16:  int field\n-    \/\/ 64-bit VMs: @0: 12 byte header, @12:  int field, @16: long field\n-    static final long INT_OFFSET  = 16L;\n-    static final long LONG_OFFSET = 8L;\n+    public static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    \/\/ 32-bit VMs\/compact headers: @0:  8 byte header,  @8: long field, @16:  int field\n+    \/\/ 64-bit VMs:                 @0: 12 byte header, @12:  int field, @16: long field\n+    static final long INT_OFFSET;\n+    static final long LONG_OFFSET;\n+    static {\n+      if (!Platform.is64bit() || WB.getBooleanVMFlag(\"UseCompactObjectHeaders\")) {\n+        INT_OFFSET = 16L;\n+        LONG_OFFSET = 8L;\n+      } else {\n+        INT_OFFSET = 12L;\n+        LONG_OFFSET = 16L;\n+      }\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/FieldLayout\/OldLayoutCheck.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -58,0 +58,11 @@\n+ *\/\n+\n+\/*\n+ * @test id=test-64bit-compact-headers\n+ * @summary Test the VM.metaspace command\n+ * @requires vm.bits == \"64\"\n+ * @requires vm.debug == true\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/othervm -Dwith-compressed-class-space -XX:+UnlockExperimentalVMOptions -XX:+UseCompactObjectHeaders -XX:MaxMetaspaceSize=201M -Xmx100M -XX:+UseCompressedOops -XX:+UseCompressedClassPointers -XX:+UnlockDiagnosticVMOptions -XX:+MetaspaceGuardAllocations PrintMetaspaceDcmd\n","filename":"test\/hotspot\/jtreg\/runtime\/Metaspace\/PrintMetaspaceDcmd.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"}]}