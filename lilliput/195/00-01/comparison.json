{"files":[{"patch":"@@ -90,1 +90,1 @@\n-PSRegionData* PSParallelCompactNew::_region_data_array;\n+PCRegionData* PSParallelCompactNew::_region_data_array;\n@@ -92,2 +92,2 @@\n-PSRegionData* PSParallelCompactNew::_region_data_array_serial;\n-PSRegionData** PSParallelCompactNew::_per_worker_region_data;\n+PCRegionData* PSParallelCompactNew::_region_data_array_serial;\n+PCRegionData** PSParallelCompactNew::_per_worker_region_data;\n@@ -125,0 +125,6 @@\n+class IsAliveClosure: public BoolObjectClosure {\n+public:\n+  bool do_object_b(oop p) final;\n+};\n+\n+\n@@ -230,1 +236,1 @@\n-    PSRegionData* last_live[last_space_id];\n+    PCRegionData* last_live[last_space_id];\n@@ -239,1 +245,1 @@\n-    PSRegionData* region_data_array = get_region_data_array();\n+    PCRegionData* region_data_array = get_region_data_array();\n@@ -242,1 +248,1 @@\n-      PSRegionData* rd = region_data_array + idx;\n+      PCRegionData* rd = region_data_array + idx;\n@@ -259,1 +265,1 @@\n-      PSRegionData* rd = last_live[i];\n+      PCRegionData* rd = last_live[i];\n@@ -272,2 +278,2 @@\n-      PSRegionData* rd = &region_data_array[idx];\n-      PSRegionData* last_live_in_space = last_live[space_id];\n+      PCRegionData* rd = &region_data_array[idx];\n+      PCRegionData* last_live_in_space = last_live[space_id];\n@@ -317,3 +323,3 @@\n-    FREE_C_HEAP_ARRAY(PSRegionData*, _per_worker_region_data);\n-    FREE_C_HEAP_ARRAY(PSRegionData, _region_data_array);\n-    FREE_C_HEAP_ARRAY(PSRegionData, _region_data_array_serial);\n+    FREE_C_HEAP_ARRAY(PCRegionData*, _per_worker_region_data);\n+    FREE_C_HEAP_ARRAY(PCRegionData, _region_data_array);\n+    FREE_C_HEAP_ARRAY(PCRegionData, _region_data_array_serial);\n@@ -379,1 +385,1 @@\n-  _region_data_array = NEW_C_HEAP_ARRAY(PSRegionData, num_regions, mtGC);\n+  _region_data_array = NEW_C_HEAP_ARRAY(PCRegionData, num_regions, mtGC);\n@@ -409,1 +415,1 @@\n-      new (_region_data_array + region_idx) PSRegionData(region_idx, addr, top, end);\n+      new (_region_data_array + region_idx) PCRegionData(region_idx, addr, top, end);\n@@ -420,5 +426,5 @@\n-  _region_data_array_serial = NEW_C_HEAP_ARRAY(PSRegionData, _num_regions_serial, mtGC);\n-  new (_region_data_array_serial + old_space_id)  PSRegionData(old_space_id,  space(old_space_id)->bottom(),  space(old_space_id)->top(),  space(old_space_id)->end());\n-  new (_region_data_array_serial + eden_space_id) PSRegionData(eden_space_id, space(eden_space_id)->bottom(), space(eden_space_id)->top(), space(eden_space_id)->end());\n-  new (_region_data_array_serial + from_space_id) PSRegionData(from_space_id, space(from_space_id)->bottom(), space(from_space_id)->top(), space(from_space_id)->end());\n-  new (_region_data_array_serial + to_space_id)   PSRegionData(to_space_id,   space(to_space_id)->bottom(),   space(to_space_id)->top(), space(to_space_id)->end());\n+  _region_data_array_serial = NEW_C_HEAP_ARRAY(PCRegionData, _num_regions_serial, mtGC);\n+  new (_region_data_array_serial + old_space_id)  PCRegionData(old_space_id, space(old_space_id)->bottom(), space(old_space_id)->top(), space(old_space_id)->end());\n+  new (_region_data_array_serial + eden_space_id) PCRegionData(eden_space_id, space(eden_space_id)->bottom(), space(eden_space_id)->top(), space(eden_space_id)->end());\n+  new (_region_data_array_serial + from_space_id) PCRegionData(from_space_id, space(from_space_id)->bottom(), space(from_space_id)->top(), space(from_space_id)->end());\n+  new (_region_data_array_serial + to_space_id)   PCRegionData(to_space_id, space(to_space_id)->bottom(), space(to_space_id)->top(), space(to_space_id)->end());\n@@ -457,1 +463,1 @@\n-    PSRegionData* rd = &_region_data_array[idx];\n+    PCRegionData* rd = &_region_data_array[idx];\n@@ -887,1 +893,1 @@\n-    PSRegionData* region = &_region_data_array[i];\n+    PCRegionData* region = &_region_data_array[i];\n@@ -973,1 +979,1 @@\n-  _per_worker_region_data = NEW_C_HEAP_ARRAY(PSRegionData*, num_workers, mtGC);\n+  _per_worker_region_data = NEW_C_HEAP_ARRAY(PCRegionData*, num_workers, mtGC);\n@@ -980,1 +986,1 @@\n-    PSRegionData* _compaction_region;\n+    PCRegionData* _compaction_region;\n@@ -1002,1 +1008,1 @@\n-    void forward_objs_in_region(ParCompactionManagerNew* cm, PSRegionData* region) {\n+    void forward_objs_in_region(ParCompactionManagerNew* cm, PCRegionData* region) {\n@@ -1045,1 +1051,1 @@\n-      PSRegionData** last_link = &_per_worker_region_data[worker_id];\n+      PCRegionData** last_link = &_per_worker_region_data[worker_id];\n@@ -1049,1 +1055,1 @@\n-      PSRegionData* region_data_array = get_region_data_array();\n+      PCRegionData* region_data_array = get_region_data_array();\n@@ -1051,1 +1057,1 @@\n-        PSRegionData* region = region_data_array + idx;\n+        PCRegionData* region = region_data_array + idx;\n@@ -1068,1 +1074,1 @@\n-    for (PSRegionData* rd = _per_worker_region_data[wid]; rd != nullptr; rd = rd->local_next()) {\n+    for (PCRegionData* rd = _per_worker_region_data[wid]; rd != nullptr; rd = rd->local_next()) {\n@@ -1079,1 +1085,1 @@\n-    static void compact_region(PSRegionData* region) {\n+    static void compact_region(PCRegionData* region) {\n@@ -1115,1 +1121,1 @@\n-      PSRegionData* region = _per_worker_region_data[worker_id];\n+      PCRegionData* region = _per_worker_region_data[worker_id];\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompactNew.cpp","additions":36,"deletions":30,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -67,13 +67,1 @@\n-\/\/ Abstract closure for use with ParMarkBitMap::iterate(), which will invoke the\n-\/\/ do_addr() method.\n-\/\/\n-\/\/ The closure is initialized with the number of heap words to process\n-\/\/ (words_remaining()), and becomes 'full' when it reaches 0.  The do_addr()\n-\/\/ methods in subclasses should update the total as words are processed.  Since\n-\/\/ only one subclass actually uses this mechanism to terminate iteration, the\n-\/\/ default initial value is > 0.  The implementation is here and not in the\n-\/\/ single subclass that uses it to avoid making is_full() virtual, and thus\n-\/\/ adding a virtual call per live object.\n-\n-\n-\/\/ The Parallel collector is a stop-the-world garbage collector that\n+\/\/ The Parallel compaction collector is a stop-the-world garbage collector that\n@@ -95,1 +83,1 @@\n-\/\/      - calculating destination-region for each region for better parallellism in following phases\n+\/\/      - set-up temporary regions to enable parallelism in following phases\n@@ -102,6 +90,3 @@\n-\/\/ is associated an object of type ParallelCompactData.  Each region is of a\n-\/\/ fixed size and typically will contain more than 1 object and may have parts\n-\/\/ of objects at the front and back of the region.\n-\/\/\n-\/\/ region            -----+---------------------+----------\n-\/\/ objects covered   [ AAA  )[ BBB )[ CCC   )[ DDD     )\n+\/\/ is associated an object of type PCRegionData. Regions are targeted to be of\n+\/\/ a mostly uniform size, but if an object would cross a region boundary, then\n+\/\/ the boundary is adjusted to be after the end of that object.\n@@ -110,9 +95,2 @@\n-\/\/ The marking also compiles the size of the data for all live objects covered\n-\/\/ by the region.  This size includes the part of any live object spanning onto\n-\/\/ the region (part of AAA if it is live) from the front, all live objects\n-\/\/ contained in the region (BBB and\/or CCC if they are live), and the part of\n-\/\/ any live objects covered by the region that extends off the region (part of\n-\/\/ DDD if it is live).  The marking phase uses multiple GC threads and marking\n-\/\/ is done in a bit array of type ParMarkBitMap.  The marking of the bit map is\n-\/\/ done atomically as is the accumulation of the size of the live objects\n-\/\/ covered by a region.\n+\/\/ The marking phase uses multiple GC threads and marking is done in a bit\n+\/\/ array of type ParMarkBitMap.  The marking of the bit map is done atomically.\n@@ -120,4 +98,11 @@\n-\/\/ The summary phase calculates the total live data to the left of each region\n-\/\/ XXX.  Based on that total and the bottom of the space, it can calculate the\n-\/\/ starting location of the live data in XXX.  The summary phase calculates for\n-\/\/ each region XXX quantities such as\n+\/\/ The summary phase sets up the regions, such that region covers roughly\n+\/\/ uniform memory regions (currently same size as SpaceAlignment). However,\n+\/\/ if that would result in an object crossing a region boundary, then\n+\/\/ the upper bounds is adjusted such that the region ends after that object.\n+\/\/ This way we can ensure that a GC worker thread can fully 'own' a region\n+\/\/ during the forwarding, adjustment and compaction phases, without worrying\n+\/\/ about other threads messing with parts of the object. The summary phase\n+\/\/ also sets up an alternative set of regions, where each region covers\n+\/\/ a single space. This is used for a serial compaction mode which achieves\n+\/\/ maximum compaction at the expense of parallelism during the forwarding\n+\/\/ compaction phases.\n@@ -125,4 +110,14 @@\n-\/\/      - the amount of live data at the beginning of a region from an object\n-\/\/        entering the region.\n-\/\/      - the location of the first live data on the region\n-\/\/      - a count of the number of regions receiving live data from XXX.\n+\/\/ The forwarding phase calculates the new address of each live\n+\/\/ object and records old-addr-to-new-addr association. It does this using\n+\/\/ multiple GC threads. Each thread 'claims' a source region and appends it to a\n+\/\/ local work-list. The region is also set as the current compaction region\n+\/\/ for that thread. All live objects in the region are then visited and its\n+\/\/ new location calculated by tracking the compaction point in the compaction\n+\/\/ region. Once the source region is exhausted, the next source region is\n+\/\/ claimed from the global pool and appended to the end of the local work-list.\n+\/\/ Once the compaction region is exhausted, the top of the old compaction region\n+\/\/ is recorded, and the next compaction region is fetched from the front of the\n+\/\/ local work-list (which is guaranteed to already have finished processing, or\n+\/\/ is the same as the source region). This way, each worker forms a local\n+\/\/ list of regions in which the worker can compact as if it were a serial\n+\/\/ compaction.\n@@ -130,5 +125,5 @@\n-\/\/ See ParallelCompactData for precise details.  The summary phase also\n-\/\/ calculates the dense prefix for the compaction.  The dense prefix is a\n-\/\/ portion at the beginning of the space that is not moved.  The objects in the\n-\/\/ dense prefix do need to have their object references updated.  See method\n-\/\/ summarize_dense_prefix().\n+\/\/ The adjust pointers phase remaps all pointers to reflect the new address of each\n+\/\/ object. Again, this uses multiple GC worker threads. Each thread claims\n+\/\/ a region, processes all references in all live objects of that region. Then\n+\/\/ the thread proceeds to claim the next region from the global pool, until\n+\/\/ all regions have been processed.\n@@ -136,2 +131,6 @@\n-\/\/ The forward (to new address) phase calculates the new address of each\n-\/\/ objects and records old-addr-to-new-addr asssociation.\n+\/\/ The compaction phase moves objects to their new location. Again, this uses\n+\/\/ multiple GC worker threads. Each worker processes the local work-list that\n+\/\/ has been set-up during the forwarding phase and processes it from bottom\n+\/\/ to top, copying each live object to its new location (which is guaranteed\n+\/\/ to be lower in that threads parts of the heap, and thus would never overwrite\n+\/\/ other objects).\n@@ -139,1 +138,4 @@\n-\/\/ The adjust pointers phase remap all pointers to reflect the new address of each object.\n+\/\/ This algorithm will usually leave gaps of non-fillable memory at the end\n+\/\/ of regions, and potentially whole empty regions at the end of compaction.\n+\/\/ The post-compaction phase fills those gaps with filler objects to ensure\n+\/\/ that the heap remains parsable.\n@@ -141,1 +143,10 @@\n-\/\/ The compaction phase moves objects to their new location.\n+\/\/ In some situations, this inefficiency of leaving gaps can lead to a\n+\/\/ situation where after a full GC, it is still not possible to satisfy an\n+\/\/ allocation, even though there should be enough memory available. When\n+\/\/ that happens, the collector switches to a serial mode, where we only\n+\/\/ have 4 regions which correspond exaxtly to the 4 spaces, and the forwarding\n+\/\/ and compaction phases are executed using only a single thread. This\n+\/\/ achieves maximum compaction. This serial mode is also invoked when\n+\/\/ System.gc() is called *and* UseMaximumCompactionOnSystemGC is set to\n+\/\/ true (which is the default), or when the number of full GCs exceeds\n+\/\/ the HeapMaximumCompactionInterval.\n@@ -143,30 +154,15 @@\n-\/\/ Compaction is done on a region basis.  A region that is ready to be filled is\n-\/\/ put on a ready list and GC threads take region off the list and fill them.  A\n-\/\/ region is ready to be filled if it empty of live objects.  Such a region may\n-\/\/ have been initially empty (only contained dead objects) or may have had all\n-\/\/ its live objects copied out already.  A region that compacts into itself is\n-\/\/ also ready for filling.  The ready list is initially filled with empty\n-\/\/ regions and regions compacting into themselves.  There is always at least 1\n-\/\/ region that can be put on the ready list.  The regions are atomically added\n-\/\/ and removed from the ready list.\n-\/\/\n-\/\/ During compaction, there is a natural task dependency among regions because\n-\/\/ destination regions may also be source regions themselves.  Consequently, the\n-\/\/ destination regions are not available for processing until all live objects\n-\/\/ within them are evacuated to their destinations.  These dependencies lead to\n-\/\/ limited thread utilization as threads spin waiting on regions to be ready.\n-\/\/ Shadow regions are utilized to address these region dependencies.  The basic\n-\/\/ idea is that, if a region is unavailable because it still contains live\n-\/\/ objects and thus cannot serve as a destination momentarily, the GC thread\n-\/\/ may allocate a shadow region as a substitute destination and directly copy\n-\/\/ live objects into this shadow region.  Live objects in the shadow region will\n-\/\/ be copied into the target destination region when it becomes available.\n-\/\/\n-\/\/ For more details on shadow regions, please refer to §4.2 of the VEE'19 paper:\n-\/\/ Haoyu Li, Mingyu Wu, Binyu Zang, and Haibo Chen.  2019.  ScissorGC: scalable\n-\/\/ and efficient compaction for Java full garbage collection.  In Proceedings of\n-\/\/ the 15th ACM SIGPLAN\/SIGOPS International Conference on Virtual Execution\n-\/\/ Environments (VEE 2019).  ACM, New York, NY, USA, 108-121.  DOI:\n-\/\/ https:\/\/doi.org\/10.1145\/3313808.3313820\n-\n-class PSRegionData \/*: public CHeapObj<mtGC> *\/ {\n+\/\/ Possible improvements to the algorithm include:\n+\/\/ - Identify and ignore a 'dense prefix'. This requires that we collect\n+\/\/   liveness data during marking, or that we scan the prefix object-by-object\n+\/\/   during the summary phase.\n+\/\/ - When an object does not fit into a remaining gap of a region, and the\n+\/\/   object is rather large, we could attempt to forward\/compact subsequent\n+\/\/   objects 'around' that large object in an attempt to minimize the\n+\/\/   resulting gap. This could be achieved by reconfiguring the regions\n+\/\/   to exclude the large object.\n+\/\/ - Instead of finding out *after* the whole compaction that an allocation\n+\/\/   can still not be satisfied, and then re-running the whole compaction\n+\/\/   serially, we could determine that after the forwarding phase, and\n+\/\/   re-do only forwarding serially, thus avoiding running marking,\n+\/\/   adjusting references and compaction twice.\n+class PCRegionData \/*: public CHeapObj<mtGC> *\/ {\n@@ -187,1 +183,1 @@\n-  PSRegionData* _local_next;\n+  PCRegionData* _local_next;\n@@ -194,1 +190,1 @@\n-  PSRegionData(size_t idx, HeapWord* bottom, HeapWord* top, HeapWord* end) :\n+  PCRegionData(size_t idx, HeapWord* bottom, HeapWord* top, HeapWord* end) :\n@@ -204,2 +200,2 @@\n-  PSRegionData*  local_next() const { return _local_next; }\n-  PSRegionData** local_next_addr() { return &_local_next; }\n+  PCRegionData*  local_next() const { return _local_next; }\n+  PCRegionData** local_next_addr() { return &_local_next; }\n@@ -237,2 +233,0 @@\n-  \/\/ Inline closure decls\n-  \/\/\n@@ -256,2 +250,2 @@\n-  static PSRegionData*        _region_data_array;\n-  static PSRegionData**       _per_worker_region_data;\n+  static PCRegionData*        _region_data_array;\n+  static PCRegionData**       _per_worker_region_data;\n@@ -260,1 +254,1 @@\n-  static PSRegionData*        _region_data_array_serial;\n+  static PCRegionData*        _region_data_array_serial;\n@@ -269,1 +263,1 @@\n-  static PSRegionData* get_region_data_array() { return _serial ? _region_data_array_serial : _region_data_array; }\n+  static PCRegionData* get_region_data_array() { return _serial ? _region_data_array_serial : _region_data_array; }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompactNew.hpp","additions":80,"deletions":86,"binary":false,"changes":166,"status":"modified"}]}