{"files":[{"patch":"@@ -1787,12 +1787,0 @@\n-  int max_monitors = C->method() != NULL ? C->max_monitors() : 0;\n-  if (UseFastLocking && max_monitors > 0) {\n-    C2CheckLockStackStub* stub = new (C->comp_arena()) C2CheckLockStackStub();\n-    C->output()->add_stub(stub);\n-    __ ldr(r9, Address(rthread, JavaThread::lock_stack_current_offset()));\n-    __ ldr(r10, Address(rthread, JavaThread::lock_stack_limit_offset()));\n-    __ add(r9, r9, max_monitors * oopSize);\n-    __ cmp(r9, r10);\n-    __ br(Assembler::GE, stub->entry());\n-    __ bind(stub->continuation());\n-  }\n-\n@@ -3804,1 +3792,2 @@\n-        __ fast_lock(oop, disp_hdr, tmp, rscratch1, no_count, false);\n+        Label slow;\n+        __ fast_lock(oop, disp_hdr, tmp, rscratch1, slow);\n@@ -3806,2 +3795,2 @@\n-        \/\/ Indicate success at cont.\n-        __ cmp(oop, oop);\n+        \/\/ Indicate success on completion.\n+        __ cmp(oop, oop); \/\/ Force ZF=1 to indicate success.\n@@ -3809,0 +3798,3 @@\n+        __ bind(slow);\n+        __ tst(oop, oop); \/\/ Force ZF=0 to indicate failure and take slow-path. We know that oop != null.\n+        __ b(no_count);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":7,"deletions":15,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -246,1 +246,1 @@\n-  __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes(), compilation()->max_monitors());\n+  __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-    fast_lock(obj, hdr, rscratch1, rscratch2, slow_case, false);\n+    fast_lock(obj, hdr, rscratch1, rscratch2, slow_case);\n@@ -333,1 +333,1 @@\n-void C1_MacroAssembler::build_frame(int framesize, int bang_size_in_bytes, int max_monitors) {\n+void C1_MacroAssembler::build_frame(int framesize, int bang_size_in_bytes) {\n@@ -340,12 +340,0 @@\n-  if (UseFastLocking && max_monitors > 0) {\n-    Label ok;\n-    ldr(r9, Address(rthread, JavaThread::lock_stack_current_offset()));\n-    ldr(r10, Address(rthread, JavaThread::lock_stack_limit_offset()));\n-    add(r9, r9, max_monitors * oopSize);\n-    cmp(r9, r10);\n-    br(Assembler::LT, ok);\n-    assert(StubRoutines::aarch64::check_lock_stack() != NULL, \"need runtime call stub\");\n-    far_call(StubRoutines::aarch64::check_lock_stack());\n-    bind(ok);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -67,11 +67,0 @@\n-int C2CheckLockStackStub::max_size() const {\n-  return 20;\n-}\n-\n-void C2CheckLockStackStub::emit(C2_MacroAssembler& masm) {\n-  __ bind(entry());\n-  assert(StubRoutines::aarch64::check_lock_stack() != NULL, \"need runtime call stub\");\n-  __ far_call(StubRoutines::aarch64::check_lock_stack());\n-  __ b(continuation());\n-}\n-\n@@ -92,3 +81,3 @@\n-  __ ldr(t, Address(rthread, JavaThread::lock_stack_current_offset()));\n-  __ sub(t, t, oopSize);\n-  __ str(t, Address(rthread, JavaThread::lock_stack_current_offset()));\n+  __ ldrw(t, Address(rthread, JavaThread::lock_stack_offset_offset()));\n+  __ subw(t, t, oopSize);\n+  __ strw(t, Address(rthread, JavaThread::lock_stack_offset_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_CodeStubs_aarch64.cpp","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -876,2 +876,3 @@\n-      ldr(tmp, Address(rthread, JavaThread::lock_stack_current_offset()));\n-      ldr(tmp, Address(tmp, -oopSize));\n+      ldrw(tmp, Address(rthread, JavaThread::lock_stack_offset_offset()));\n+      subw(tmp, tmp, oopSize);\n+      ldr(tmp, Address(rthread, tmp));\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -6197,1 +6197,1 @@\n-void MacroAssembler::fast_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow, bool rt_check_stack) {\n+void MacroAssembler::fast_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n@@ -6201,7 +6201,4 @@\n-  if (rt_check_stack) {\n-    \/\/ Check if we would have space on lock-stack for the object.\n-    ldr(t1, Address(rthread, JavaThread::lock_stack_current_offset()));\n-    ldr(t2, Address(rthread, JavaThread::lock_stack_limit_offset()));\n-    cmp(t1, t2);\n-    br(Assembler::GE, slow);\n-  }\n+  \/\/ Check if we would have space on lock-stack for the object.\n+  ldrw(t1, Address(rthread, JavaThread::lock_stack_offset_offset()));\n+  cmpw(t1, (unsigned)LockStack::end_offset());\n+  br(Assembler::GE, slow);\n@@ -6219,4 +6216,4 @@\n-  ldr(t1, Address(rthread, JavaThread::lock_stack_current_offset()));\n-  str(obj, Address(t1, 0));\n-  add(t1, t1, oopSize);\n-  str(t1, Address(rthread, JavaThread::lock_stack_current_offset()));\n+  ldrw(t1, Address(rthread, JavaThread::lock_stack_offset_offset()));\n+  str(obj, Address(rthread, t1));\n+  addw(t1, t1, oopSize);\n+  strw(t1, Address(rthread, JavaThread::lock_stack_offset_offset()));\n@@ -6241,3 +6238,3 @@\n-  ldr(t1, Address(rthread, JavaThread::lock_stack_current_offset()));\n-  sub(t1, t1, oopSize);\n-  str(t1, Address(rthread, JavaThread::lock_stack_current_offset()));\n+  ldrw(t1, Address(rthread, JavaThread::lock_stack_offset_offset()));\n+  subw(t1, t1, oopSize);\n+  strw(t1, Address(rthread, JavaThread::lock_stack_offset_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1585,1 +1585,1 @@\n-  void fast_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow, bool rt_check_stack = true);\n+  void fast_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5360,23 +5360,0 @@\n-  address generate_check_lock_stack() {\n-    __ align(CodeEntryAlignment);\n-    StubCodeMark mark(this, \"StubRoutines\", \"check_lock_stack\");\n-\n-    address start = __ pc();\n-\n-    __ set_last_Java_frame(sp, rfp, lr, rscratch1);\n-    __ enter();\n-    __ push_call_clobbered_registers();\n-\n-    __ mov(c_rarg0, r9);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, LockStack::ensure_lock_stack_size), 1);\n-\n-\n-    __ pop_call_clobbered_registers();\n-    __ leave();\n-    __ reset_last_Java_frame(true);\n-\n-    __ ret(lr);\n-\n-    return start;\n-  }\n-\n@@ -8015,3 +7992,0 @@\n-    if (UseFastLocking) {\n-      StubRoutines::aarch64::_check_lock_stack = generate_check_lock_stack();\n-    }\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-address StubRoutines::aarch64::_check_lock_stack = NULL;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -73,2 +73,0 @@\n-  static address _check_lock_stack;\n-\n@@ -185,4 +183,0 @@\n-  static address check_lock_stack() {\n-    return _check_lock_stack;\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -288,1 +288,1 @@\n-  __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes(), compilation()->max_monitors());\n+  __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    fast_lock_impl(obj, hdr, thread, tmp, slow_case, LP64_ONLY(false) NOT_LP64(true));\n+    fast_lock_impl(obj, hdr, thread, tmp, slow_case);\n@@ -325,1 +325,1 @@\n-void C1_MacroAssembler::build_frame(int frame_size_in_bytes, int bang_size_in_bytes, int max_monitors) {\n+void C1_MacroAssembler::build_frame(int frame_size_in_bytes, int bang_size_in_bytes) {\n@@ -346,13 +346,0 @@\n-#ifdef _LP64\n-  if (UseFastLocking && max_monitors > 0) {\n-    Label ok;\n-    movptr(rax, Address(r15_thread, JavaThread::lock_stack_current_offset()));\n-    addptr(rax, max_monitors * wordSize);\n-    cmpptr(rax, Address(r15_thread, JavaThread::lock_stack_limit_offset()));\n-    jcc(Assembler::less, ok);\n-    assert(StubRoutines::x86::check_lock_stack() != NULL, \"need runtime call stub\");\n-    call(RuntimeAddress(StubRoutines::x86::check_lock_stack()));\n-    bind(ok);\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -76,11 +76,0 @@\n-int C2CheckLockStackStub::max_size() const {\n-  return 10;\n-}\n-\n-void C2CheckLockStackStub::emit(C2_MacroAssembler& masm) {\n-  __ bind(entry());\n-  assert(StubRoutines::x86::check_lock_stack() != NULL, \"need runtime call stub\");\n-  __ call(RuntimeAddress(StubRoutines::x86::check_lock_stack()));\n-  __ jmp(continuation(), false \/* maybe_short *\/);\n-}\n-\n@@ -96,1 +85,1 @@\n-  __ subptr(Address(r15_thread, JavaThread::lock_stack_current_offset()), oopSize);\n+  __ subl(Address(r15_thread, JavaThread::lock_stack_offset_offset()), oopSize);\n","filename":"src\/hotspot\/cpu\/x86\/c2_CodeStubs_x86.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-void C2_MacroAssembler::verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub, int max_monitors) {\n+void C2_MacroAssembler::verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub) {\n@@ -130,14 +130,0 @@\n-#ifdef _LP64\n-  if (UseFastLocking && max_monitors > 0) {\n-    C2CheckLockStackStub* stub = new (Compile::current()->comp_arena()) C2CheckLockStackStub();\n-    Compile::current()->output()->add_stub(stub);\n-    assert(!is_stub, \"only methods have monitors\");\n-    Register thread = r15_thread;\n-    movptr(rax, Address(thread, JavaThread::lock_stack_current_offset()));\n-    addptr(rax, max_monitors * oopSize);\n-    cmpptr(rax, Address(thread, JavaThread::lock_stack_limit_offset()));\n-    jcc(Assembler::greaterEqual, stub->entry());\n-    bind(stub->continuation());\n-  }\n-#endif\n-\n@@ -620,8 +606,0 @@\n-#ifdef _LP64\n-      fast_lock_impl(objReg, tmpReg, thread, scrReg, NO_COUNT, false);\n-      jmp(COUNT);\n-#else\n-      \/\/ We can not emit the lock-stack-check in verified_entry() because we don't have enough\n-      \/\/ registers (for thread ptr). Therefore we have to emit the lock-stack-check in\n-      \/\/ fast_lock_impl(). However, that check can take a slow-path with ZF=1, therefore\n-      \/\/ we need to handle it specially and force ZF=0 before taking the actual slow-path.\n@@ -634,1 +612,0 @@\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-  void verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub, int max_monitors);\n+  void verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1354,2 +1354,2 @@\n-      movptr(tmp, Address(thread, JavaThread::lock_stack_current_offset()));\n-      cmpptr(obj_reg, Address(tmp, -oopSize));\n+      movl(tmp, Address(thread, JavaThread::lock_stack_offset_offset()));\n+      cmpptr(obj_reg, Address(thread, tmp, Address::times_1, -oopSize));\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -9862,1 +9862,1 @@\n-void MacroAssembler::fast_lock_impl(Register obj, Register hdr, Register thread, Register tmp, Label& slow, bool rt_check_stack) {\n+void MacroAssembler::fast_lock_impl(Register obj, Register hdr, Register thread, Register tmp, Label& slow) {\n@@ -9867,15 +9867,2 @@\n-  if (rt_check_stack) {\n-    movptr(tmp, Address(thread, JavaThread::lock_stack_current_offset()));\n-    cmpptr(tmp, Address(thread, JavaThread::lock_stack_limit_offset()));\n-    jcc(Assembler::greaterEqual, slow);\n-  }\n-#ifdef ASSERT\n-  else {\n-    Label ok;\n-    movptr(tmp, Address(thread, JavaThread::lock_stack_current_offset()));\n-    cmpptr(tmp, Address(thread, JavaThread::lock_stack_limit_offset()));\n-    jcc(Assembler::less, ok);\n-    stop(\"Not enough room in lock stack; should have been checked in the method prologue\");\n-    bind(ok);\n-  }\n-#endif\n+  cmpl(Address(thread, JavaThread::lock_stack_offset_offset()), LockStack::end_offset());\n+  jcc(Assembler::greaterEqual, slow);\n@@ -9894,4 +9881,4 @@\n-  movptr(tmp, Address(thread, JavaThread::lock_stack_current_offset()));\n-  movptr(Address(tmp, 0), obj);\n-  increment(tmp, oopSize);\n-  movptr(Address(thread, JavaThread::lock_stack_current_offset()), tmp);\n+  movl(tmp, Address(thread, JavaThread::lock_stack_offset_offset()));\n+  movptr(Address(thread, tmp, Address::times_1), obj);\n+  incrementl(tmp, oopSize);\n+  movl(Address(thread, JavaThread::lock_stack_offset_offset()), tmp);\n@@ -9917,1 +9904,1 @@\n-  subptr(Address(thread, JavaThread::lock_stack_current_offset()), oopSize);\n+  subl(Address(thread, JavaThread::lock_stack_offset_offset()), oopSize);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":8,"deletions":21,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2031,1 +2031,1 @@\n-  void fast_lock_impl(Register obj, Register hdr, Register thread, Register tmp, Label& slow, bool rt_check_stack = true);\n+  void fast_lock_impl(Register obj, Register hdr, Register thread, Register tmp, Label& slow);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3186,49 +3186,0 @@\n-\/\/ Call runtime to ensure lock-stack size.\n-\/\/ Arguments:\n-\/\/ - c_rarg0: the required _limit pointer\n-address StubGenerator::generate_check_lock_stack() {\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark mark(this, \"StubRoutines\", \"check_lock_stack\");\n-  address start = __ pc();\n-\n-  BLOCK_COMMENT(\"Entry:\");\n-  __ enter(); \/\/ save rbp\n-\n-  __ pusha();\n-\n-  \/\/ The method may have floats as arguments, and we must spill them before calling\n-  \/\/ the VM runtime.\n-  assert(Argument::n_float_register_parameters_j == 8, \"Assumption\");\n-  const int xmm_size = wordSize * 2;\n-  const int xmm_spill_size = xmm_size * Argument::n_float_register_parameters_j;\n-  __ subptr(rsp, xmm_spill_size);\n-  __ movdqu(Address(rsp, xmm_size * 7), xmm7);\n-  __ movdqu(Address(rsp, xmm_size * 6), xmm6);\n-  __ movdqu(Address(rsp, xmm_size * 5), xmm5);\n-  __ movdqu(Address(rsp, xmm_size * 4), xmm4);\n-  __ movdqu(Address(rsp, xmm_size * 3), xmm3);\n-  __ movdqu(Address(rsp, xmm_size * 2), xmm2);\n-  __ movdqu(Address(rsp, xmm_size * 1), xmm1);\n-  __ movdqu(Address(rsp, xmm_size * 0), xmm0);\n-\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, static_cast<void (*)(oop*)>(LockStack::ensure_lock_stack_size)), rax);\n-\n-  __ movdqu(xmm0, Address(rsp, xmm_size * 0));\n-  __ movdqu(xmm1, Address(rsp, xmm_size * 1));\n-  __ movdqu(xmm2, Address(rsp, xmm_size * 2));\n-  __ movdqu(xmm3, Address(rsp, xmm_size * 3));\n-  __ movdqu(xmm4, Address(rsp, xmm_size * 4));\n-  __ movdqu(xmm5, Address(rsp, xmm_size * 5));\n-  __ movdqu(xmm6, Address(rsp, xmm_size * 6));\n-  __ movdqu(xmm7, Address(rsp, xmm_size * 7));\n-  __ addptr(rsp, xmm_spill_size);\n-\n-  __ popa();\n-\n-  __ leave();\n-\n-  __ ret(0);\n-\n-  return start;\n-}\n-\n@@ -4072,3 +4023,0 @@\n-  if (UseFastLocking) {\n-    StubRoutines::x86::_check_lock_stack = generate_check_lock_stack();\n-  }\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":0,"deletions":52,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -468,2 +468,0 @@\n-  address generate_check_lock_stack();\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,1 +87,0 @@\n-address StubRoutines::x86::_check_lock_stack = NULL;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -129,2 +129,0 @@\n-  static address _check_lock_stack;\n-\n@@ -220,2 +218,0 @@\n-  static address check_lock_stack() { return _check_lock_stack; }\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -617,2 +617,1 @@\n-  int max_monitors = C->method() != NULL ? C->max_monitors() : 0;\n-  __ verified_entry(framesize, C->output()->need_stack_bang(bangsize)?bangsize:0, C->in_24_bit_fp_mode(), C->stub_function() != NULL, max_monitors);\n+  __ verified_entry(framesize, C->output()->need_stack_bang(bangsize)?bangsize:0, C->in_24_bit_fp_mode(), C->stub_function() != NULL);\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -925,2 +925,1 @@\n-  int max_monitors = C->method() != NULL ? C->max_monitors() : 0;\n-  __ verified_entry(framesize, C->output()->need_stack_bang(bangsize)?bangsize:0, false, C->stub_function() != NULL, max_monitors);\n+  __ verified_entry(framesize, C->output()->need_stack_bang(bangsize)?bangsize:0, false, C->stub_function() != NULL);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -387,1 +387,0 @@\n-    push_monitor();\n@@ -575,1 +574,0 @@\n-, _max_monitors(0)\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,1 +86,0 @@\n-  int                _max_monitors; \/\/ Max number of active monitors, for fast-locking\n@@ -144,1 +143,0 @@\n-  int max_monitors() const                       { return _max_monitors; }\n@@ -177,2 +175,0 @@\n-  void push_monitor()                            { _max_monitors++; }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2318,1 +2318,0 @@\n-  compilation()->push_monitor();\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -774,1 +774,1 @@\n-  _masm->build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes(), compilation()->max_monitors());\n+  _masm->build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  void build_frame(int frame_size_in_bytes, int bang_size_in_bytes, int max_monitors);\n+  void build_frame(int frame_size_in_bytes, int bang_size_in_bytes);\n","filename":"src\/hotspot\/share\/c1\/c1_MacroAssembler.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,8 +89,0 @@\n-class C2CheckLockStackStub : public C2CodeStub {\n-public:\n-  C2CheckLockStackStub() : C2CodeStub() {}\n-\n-  int max_size() const;\n-  void emit(C2_MacroAssembler& masm);\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/c2_CodeStubs.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1024,1 +1024,0 @@\n-  reset_max_monitors();\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -340,1 +340,0 @@\n-  uint                  _max_monitors;          \/\/ Keep track of maximum number of active monitors in this compilation\n@@ -635,4 +634,0 @@\n-  void          push_monitor() { _max_monitors++; }\n-  void          reset_max_monitors() { _max_monitors = 0; }\n-  uint          max_monitors() { return _max_monitors; }\n-\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -183,1 +183,0 @@\n-  C->push_monitor();\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -426,1 +426,0 @@\n-    C->push_monitor();\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1150,2 +1150,2 @@\n-  static ByteSize lock_stack_current_offset()    { return byte_offset_of(JavaThread, _lock_stack) + LockStack::current_offset(); }\n-  static ByteSize lock_stack_limit_offset()    { return byte_offset_of(JavaThread, _lock_stack) + LockStack::limit_offset(); }\n+  static ByteSize lock_stack_offset_offset()    { return byte_offset_of(JavaThread, _lock_stack) + LockStack::offset_offset(); }\n+  static ByteSize lock_stack_base_offset()      { return byte_offset_of(JavaThread, _lock_stack) + LockStack::base_offset(); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/lockStack.hpp\"\n+#include \"runtime\/lockStack.inline.hpp\"\n@@ -34,3 +34,1 @@\n-  _base(UseFastLocking && !UseHeavyMonitors ? _initial : NULL),\n-  _limit(_base + INITIAL_CAPACITY),\n-  _current(_base) {\n+  _offset(in_bytes(JavaThread::lock_stack_base_offset())) {\n@@ -39,6 +37,2 @@\n-LockStack::~LockStack() {\n-  if (UseFastLocking && !UseHeavyMonitors) {\n-    if (_base != _initial) {\n-      FREE_C_HEAP_ARRAY(oop, _base);\n-    }\n-  }\n+int LockStack::end_offset() {\n+  return in_bytes(JavaThread::lock_stack_base_offset()) + CAPACITY * oopSize;\n@@ -50,3 +44,4 @@\n-  for (oop* loc1 = _base; loc1 < _current - 1; loc1++) {\n-    for (oop* loc2 = loc1 + 1; loc2 < _current; loc2++) {\n-      assert(*loc1 != *loc2, \"entries must be unique: %s\", msg);\n+  int end = to_index(_offset);\n+  for (int i = 0; i < end; i++) {\n+    for (int j = i + 1; j < end; j++) {\n+      assert(_base[i] != _base[j], \"entries must be unique: %s\", msg);\n@@ -57,27 +52,0 @@\n-\n-void LockStack::grow(size_t min_capacity) {\n-  \/\/ Grow stack.\n-  assert(_limit > _base, \"invariant\");\n-  size_t capacity = _limit - _base;\n-  size_t index = _current - _base;\n-  size_t new_capacity = MAX2(min_capacity, capacity * 2);\n-  if (_base == _initial) {\n-    oop* new_stack = NEW_C_HEAP_ARRAY(oop, new_capacity, mtSynchronizer);\n-    for (size_t i = 0; i < index; i++) {\n-      *(new_stack + i) = *(_base + i);\n-    }\n-    _base = new_stack;\n-  } else {\n-    _base = REALLOC_C_HEAP_ARRAY(oop, _base, new_capacity, mtSynchronizer);\n-  }\n-  _limit = _base + new_capacity;\n-  _current = _base + index;\n-  assert(_current < _limit, \"must fit after growing\");\n-  assert((_limit - _base) >= (ptrdiff_t) min_capacity, \"must grow enough\");\n-}\n-\n-void LockStack::ensure_lock_stack_size(oop* required_limit) {\n-  JavaThread* jt = JavaThread::current();\n-  LockStack& lock_stack = jt->lock_stack();\n-  lock_stack.grow(required_limit - lock_stack._base);\n-}\n","filename":"src\/hotspot\/share\/runtime\/lockStack.cpp","additions":8,"deletions":40,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -38,7 +38,6 @@\n-  static const size_t INITIAL_CAPACITY = 4;\n-  oop* _base;\n-  oop* _limit;\n-  oop* _current;\n-  oop _initial[INITIAL_CAPACITY];\n-\n-  void grow(size_t min_capacity);\n+  static const int CAPACITY = 8;\n+  \/\/ The offset of the next element, in bytes, relative to the JavaThread structure.\n+  \/\/ We do this instead of a simple index into the array because this allows for\n+  \/\/ efficient addressing in generated code.\n+  int _offset;\n+  oop _base[CAPACITY];\n@@ -47,4 +46,0 @@\n-public:\n-  static ByteSize current_offset()    { return byte_offset_of(LockStack, _current); }\n-  static ByteSize base_offset()       { return byte_offset_of(LockStack, _base); }\n-  static ByteSize limit_offset()      { return byte_offset_of(LockStack, _limit); }\n@@ -52,1 +47,5 @@\n-  static void ensure_lock_stack_size(oop* _required_limit);\n+  static inline int to_index(int offset);\n+\n+public:\n+  static ByteSize offset_offset()    { return byte_offset_of(LockStack, _offset); }\n+  static ByteSize base_offset()      { return byte_offset_of(LockStack, _base); }\n@@ -55,1 +54,0 @@\n-  ~LockStack();\n@@ -57,0 +55,2 @@\n+  static int end_offset();\n+  inline bool can_push() const;\n","filename":"src\/hotspot\/share\/runtime\/lockStack.hpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -31,0 +32,8 @@\n+inline int LockStack::to_index(int offset) {\n+  return (offset - in_bytes(JavaThread::lock_stack_base_offset())) \/ oopSize;\n+}\n+\n+inline bool LockStack::can_push() const {\n+  return to_index(_offset) < CAPACITY;\n+}\n+\n@@ -35,5 +44,3 @@\n-  if (_current >= _limit) {\n-    grow((_limit - _base) + 1);\n-  }\n-  *_current = o;\n-  _current++;\n+  assert(can_push(), \"must have room\");\n+  _base[to_index(_offset)] = o;\n+  _offset += oopSize;\n@@ -45,4 +52,3 @@\n-  oop* new_loc = _current - 1;\n-  assert(new_loc < _current, \"underflow, probably unbalanced push\/pop\");\n-  _current = new_loc;\n-  oop o = *_current;\n+  assert(to_index(_offset) > 0, \"underflow, probably unbalanced push\/pop\");\n+  _offset -= oopSize;\n+  oop o = _base[to_index(_offset)];\n@@ -57,5 +63,6 @@\n-  for (oop* loc = _base; loc < _current; loc++) {\n-    if (*loc == o) {\n-      oop* last = _current - 1;\n-      for (; loc < last; loc++) {\n-        *loc = *(loc + 1);\n+  int end = to_index(_offset);\n+  for (int i = 0; i < end; i++) {\n+    if (_base[i] == o) {\n+      int last = end - 1;\n+      for (; i < last; i++) {\n+        _base[i] = _base[i + 1];\n@@ -63,1 +70,1 @@\n-      _current--;\n+      _offset -= oopSize;\n@@ -73,5 +80,4 @@\n-  bool found = false;\n-  size_t i = 0;\n-  size_t found_i = 0;\n-  for (oop* loc = _current - 1; loc >= _base; loc--) {\n-    if (*loc == o) {\n+  int end = to_index(_offset);\n+  for (int i = end - 1; i >= 0; i--) {\n+    if (_base[i] == o) {\n+      validate(\"post-contains\");\n@@ -87,2 +93,3 @@\n-  for (oop* loc = _base; loc < _current; loc++) {\n-    cl->do_oop(loc);\n+  int end = to_index(_offset);\n+  for (int i = 0; i < end; i++) {\n+    cl->do_oop(&_base[i]);\n","filename":"src\/hotspot\/share\/runtime\/lockStack.inline.hpp","additions":29,"deletions":22,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -492,0 +492,1 @@\n+      \/\/ fast-locking does not use the 'lock' parameter.\n@@ -493,12 +494,18 @@\n-\n-      markWord header = obj()->mark_acquire();\n-      while (true) {\n-        if (header.is_neutral()) {\n-          assert(!lock_stack.contains(obj()), \"thread must not already hold the lock\");\n-          \/\/ Try to swing into 'fast-locked' state without inflating.\n-          markWord locked_header = header.set_fast_locked();\n-          markWord witness = obj()->cas_set_mark(locked_header, header);\n-          if (witness == header) {\n-            \/\/ Successfully fast-locked, push object to lock-stack and return.\n-            lock_stack.push(obj());\n-            return;\n+      if (lock_stack.can_push()) {\n+        markWord header = obj()->mark_acquire();\n+        while (true) {\n+          if (header.is_neutral()) {\n+            assert(!lock_stack.contains(obj()), \"thread must not already hold the lock\");\n+            \/\/ Try to swing into 'fast-locked' state without inflating.\n+            markWord locked_header = header.set_fast_locked();\n+            markWord witness = obj()->cas_set_mark(locked_header, header);\n+            if (witness == header) {\n+              \/\/ Successfully fast-locked, push object to lock-stack and return.\n+              lock_stack.push(obj());\n+              return;\n+            }\n+            \/\/ Otherwise retry.\n+            header = witness;\n+          } else {\n+            \/\/ Fall-through to inflate-enter.\n+            break;\n@@ -506,5 +513,0 @@\n-          \/\/ Otherwise retry.\n-          header = witness;\n-        } else {\n-          \/\/ Fall-through to inflate-enter.\n-          break;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":19,"deletions":17,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -703,2 +703,2 @@\n-  nonstatic_field(LockStack,                   _current,                                      oop*)                                  \\\n-  nonstatic_field(LockStack,                   _base,                                         oop*)                                  \\\n+  nonstatic_field(LockStack,                   _offset,                                       int)                                   \\\n+  nonstatic_field(LockStack,                   _base[0],                                      oop)                                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  private static long          lockStackCurrentOffset;\n+  private static long          lockStackOffsetOffset;\n@@ -105,2 +105,2 @@\n-    lockStackCurrentOffset = type.getField(\"_lock_stack\").getOffset() + typeLockStack.getField(\"_current\").getOffset();\n-    lockStackBaseOffset = type.getField(\"_lock_stack\").getOffset() + typeLockStack.getField(\"_base\").getOffset();\n+    lockStackOffsetOffset = type.getField(\"_lock_stack\").getOffset() + typeLockStack.getField(\"_offset\").getOffset();\n+    lockStackBaseOffset = type.getField(\"_lock_stack\").getOffset() + typeLockStack.getField(\"_base[0]\").getOffset();\n@@ -406,8 +406,12 @@\n-    Address current = addr.getAddressAt(lockStackCurrentOffset);\n-    Address base = addr.getAddressAt(lockStackBaseOffset);\n-    while (base.lessThan(current)) {\n-        Address oop = base.getAddressAt(0);\n-        if (oop.equals(obj)) {\n-            return true;\n-        }\n-        base = base.addOffsetTo(oopPtrSize);\n+    long current = lockStackBaseOffset;\n+    long end = addr.getJIntAt(lockStackOffsetOffset);\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(current <= end, \"current stack offset must be above base offset\");\n+    }\n+\n+    while (current < end) {\n+      Address oop = addr.getAddressAt(current);\n+      if (oop.equals(obj)) {\n+        return true;\n+      }\n+      current += oopPtrSize;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/JavaThread.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"}]}