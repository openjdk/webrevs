{"files":[{"patch":"@@ -239,1 +239,1 @@\n-  \/\/ Clear box. TODO[OMWorld]: Is this necessary? May also defer this to not write twice.\n+  \/\/ Clear cache in case fast locking succeeds.\n@@ -501,3 +501,2 @@\n-      \/\/ TODO: Cleanup these constants (with an enum and asserts)\n-      cmp(t1_monitor, (uint8_t)2);\n-      \/\/ Non symmetrical, take slow path monitor == 0 or 1, 0 and 1 < 2, both LS and NE\n+      \/\/ null check with Flags == NE, no valid pointer below alignof(ObjectMonitor*)\n+      cmp(t1_monitor, checked_cast<uint8_t>(alignof(ObjectMonitor*)));\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -802,1 +802,0 @@\n-      \/\/ TODO[OMWorld]: Cleanup lock_reg usage for placeholder\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -6459,0 +6459,1 @@\n+  \/\/ Clear cache in case fast locking succeeds.\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -145,4 +145,2 @@\n-    \/\/ This relies on the implementation of lightweight_unlock being able to handle\n-    \/\/ that the reg_rax and thread Register parameters may alias each other.\n-    get_thread(disp_hdr);\n-    lightweight_unlock(obj, disp_hdr, disp_hdr, hdr, slow_case);\n+    \/\/ Lacking registers and thread on x86_32. Always take slow path.\n+    jmp(slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -952,1 +952,1 @@\n-  \/\/ Clear box. TODO[OMWorld]: Is this necessary? May also defer this to not write twice.\n+  \/\/ Clear cache in case fast locking succeeds.\n@@ -997,1 +997,0 @@\n-    \/\/ TODO[OMWorld]: Was prepush better?\n@@ -1204,4 +1203,2 @@\n-      \/\/ TODO[OMWorld]: Figure out the correctness surrounding the owner field here. Obj is not on the lock stack\n-      \/\/                but this means this thread must have locked on the inflated monitor at some point. So it\n-      \/\/                should not be anonymous.\n-      cmpptr(monitor, 2);\n+      \/\/ null check with ZF == 0, no valid pointer below alignof(ObjectMonitor*)\n+      cmpptr(monitor, alignof(ObjectMonitor*));\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1308,4 +1308,2 @@\n-      \/\/ This relies on the implementation of lightweight_unlock being able to handle\n-      \/\/ that the reg_rax and thread Register parameters may alias each other.\n-      get_thread(swap_reg);\n-      lightweight_unlock(obj_reg, swap_reg, swap_reg, header_reg, slow_case);\n+      \/\/ Lacking registers and thread on x86_32. Always take slow path.\n+      jmp(slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -9996,3 +9996,0 @@\n-\/\/\n-\/\/ x86_32 Note: basic_lock and thread may alias each other due to limited register\n-\/\/              availiability.\n@@ -10001,1 +9998,1 @@\n-  assert_different_registers(obj, reg_rax, thread, tmp);\n+  assert_different_registers(basic_lock, obj, reg_rax, thread, tmp);\n@@ -10010,0 +10007,1 @@\n+  \/\/ Clear cache in case fast locking succeeds.\n@@ -10012,5 +10010,0 @@\n-#ifndef _LP64\n-  if (thread == basic_lock) {\n-    get_thread(thread);\n-  }\n-#endif \/\/ !_LP64\n@@ -10060,2 +10053,1 @@\n-  assert_different_registers(obj, reg_rax, tmp);\n-  LP64_ONLY(assert_different_registers(obj, reg_rax, thread, tmp);)\n+  assert_different_registers(obj, reg_rax, thread, tmp);\n@@ -10101,4 +10093,0 @@\n-  if (thread == reg_rax) {\n-    \/\/ On x86_32 we may lose the thread.\n-    get_thread(thread);\n-  }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1698,1 +1698,2 @@\n-      __ lightweight_lock(lock_reg, obj_reg, swap_reg, thread, lock_reg, slow_path_lock);\n+      \/\/ Lacking registers and thread on x86_32. Always take slow path.\n+      __ jmp(slow_path_lock);\n@@ -1937,5 +1938,0 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ Reload the lock addr. Clobbered by lightweight_lock.\n-      __ lea(lock_reg, Address(rbp, lock_slot_rbp_offset));\n-    }\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-      \/\/ TODO[OMWorld]: Cleanup, even if the monitor read is racy, something should be printed.\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -352,1 +352,1 @@\n-    log_info(monitorinflation)(\"inflate(has_locker): object=\" INTPTR_FORMAT \", mark=\"\n+    log_info(monitorinflation)(\"inflate: object=\" INTPTR_FORMAT \", mark=\"\n@@ -462,1 +462,1 @@\n-class LockStackInflateContendedLocks : private OopClosure {\n+class LightweightSynchronizer::LockStackInflateContendedLocks : private OopClosure {\n@@ -488,2 +488,3 @@\n-  void inflate(JavaThread* locking_thread, JavaThread* current) {\n-    locking_thread->lock_stack().oops_do(this);\n+  void inflate(JavaThread* current) {\n+    assert(current == JavaThread::current(), \"must be\");\n+    current->lock_stack().oops_do(this);\n@@ -492,1 +493,1 @@\n-        inflate_fast_locked_object(_contended_oops[i], locking_thread, current, ObjectSynchronizer::inflate_cause_vm_internal);\n+        inflate_fast_locked_object(_contended_oops[i], current, current, ObjectSynchronizer::inflate_cause_vm_internal);\n@@ -504,1 +505,1 @@\n-    LockStackInflateContendedLocks().inflate(current, current);\n+    LockStackInflateContendedLocks().inflate(current);\n@@ -541,1 +542,1 @@\n-class VerifyThreadState {\n+class LightweightSynchronizer::VerifyThreadState {\n@@ -568,1 +569,0 @@\n-  \/\/ TODO[OMWorld]: Is this necessary?\n@@ -586,3 +586,0 @@\n-    \/\/ TODO[OMWorld]: We also assume that this re-lock is on either a new never\n-    \/\/                inflated monitor, or one that is already locked by the\n-    \/\/                locking_thread. Should we have this stricter restriction?\n@@ -614,5 +611,0 @@\n-    \/\/ TODO[OMWorld]: Maybe guard this by the value in the markWord (only is fast locked)\n-    \/\/                Currently this is done when exiting. Doing it early could remove,\n-    \/\/                LockStack::CAPACITY - 1 slow paths in the best case. But need to fix\n-    \/\/                some of the inflation counters for this change.\n-\n@@ -721,1 +713,0 @@\n-\/\/ TODO[OMWorld]: Rename this. No idea what to call it, used by notify\/notifyall\/wait and jni exit\n@@ -953,1 +944,1 @@\n-    LockStackInflateContendedLocks().inflate(locking_thread, current);\n+    LockStackInflateContendedLocks().inflate(current);\n@@ -979,13 +970,0 @@\n-void LightweightSynchronizer::deflate_anon_monitor(Thread* current, oop obj, ObjectMonitor* monitor) {\n-  markWord mark = obj->mark_acquire();\n-  assert(!mark.has_no_hash(), \"obj with inflated monitor must have had a hash\");\n-\n-  while (mark.has_monitor()) {\n-    const markWord new_mark = mark.set_fast_locked();\n-    mark = obj->cas_set_mark(new_mark, mark);\n-  }\n-\n-  bool removed = remove_monitor(current, obj, monitor);\n-  assert(removed, \"Should have removed the entry\");\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":9,"deletions":31,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+  class LockStackInflateContendedLocks;\n+  class VerifyThreadState;\n@@ -67,1 +69,0 @@\n-  static void deflate_anon_monitor(Thread* current, oop obj, ObjectMonitor* monitor);\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -162,1 +162,0 @@\n-  static const uintptr_t ANONYMOUS_OWNER_OR_DEFLATER_MARKER = ANONYMOUS_OWNER | DEFLATER_MARKER_VALUE;\n@@ -269,8 +268,0 @@\n-  bool is_contended() const {\n-    intptr_t ret_code = intptr_t(_waiters) | intptr_t(_cxq) | intptr_t(_EntryList);\n-    int cnts = contentions();\n-    if (cnts > 0) {\n-      ret_code |= intptr_t(cnts);\n-    }\n-    return ret_code != 0;\n-  }\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -942,1 +942,1 @@\n-static inline intptr_t get_next_hash(Thread* current, oop obj) {\n+intptr_t ObjectSynchronizer::get_next_hash(Thread* current, oop obj) {\n@@ -982,5 +982,0 @@\n-intptr_t ObjectSynchronizer::get_next_hash(Thread* current, oop obj) {\n-  \/\/ CLEANUP[Axel]: hack for LightweightSynchronizer being in different translation unit\n-  return ::get_next_hash(current, obj);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-        output.shouldContain(\"inflate(has_locker):\");\n+        output.shouldContain(\"inflate:\");\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/MonitorInflationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}