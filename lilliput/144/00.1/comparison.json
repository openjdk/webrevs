{"files":[{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -39,0 +40,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -81,0 +83,3 @@\n+  } else if (LockingMode == LM_PLACEHOLDER) {\n+    \/\/ null check obj. load_klass performs load if DiagnoseSyncOnValueBasedClasses != 0.\n+    ldr(hdr, Address(obj));\n@@ -83,1 +88,4 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n+  if (LockingMode == LM_PLACEHOLDER) {\n+    str(zr, Address(disp_hdr, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::displaced_header_offset_in_bytes()))));\n+    placeholder_lock(obj, hdr, temp, rscratch2, slow_case);\n+  } else if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -134,1 +142,1 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n+  if (LockingMode != LM_LIGHTWEIGHT && LockingMode != LM_PLACEHOLDER) {\n@@ -146,1 +154,3 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n+  if (LockingMode == LM_PLACEHOLDER) {\n+    placeholder_unlock(obj, hdr, temp, rscratch2, slow_case);\n+  } else if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -178,7 +188,3 @@\n-  \/\/ This assumes that all prototype bits fit in an int32_t\n-  mov(t1, (int32_t)(intptr_t)markWord::prototype().value());\n-  str(t1, Address(obj, oopDesc::mark_offset_in_bytes()));\n-\n-  if (UseCompressedClassPointers) { \/\/ Take care not to kill klass\n-    encode_klass_not_null(t1, klass);\n-    strw(t1, Address(obj, oopDesc::klass_offset_in_bytes()));\n+  if (UseCompactObjectHeaders) {\n+    ldr(t1, Address(klass, Klass::prototype_header_offset()));\n+    str(t1, Address(obj, oopDesc::mark_offset_in_bytes()));\n@@ -186,1 +192,10 @@\n-    str(klass, Address(obj, oopDesc::klass_offset_in_bytes()));\n+    \/\/ This assumes that all prototype bits fit in an int32_t\n+    mov(t1, (int32_t)(intptr_t)markWord::prototype().value());\n+    str(t1, Address(obj, oopDesc::mark_offset_in_bytes()));\n+\n+    if (UseCompressedClassPointers) { \/\/ Take care not to kill klass\n+      encode_klass_not_null(t1, klass);\n+      strw(t1, Address(obj, oopDesc::klass_offset_in_bytes()));\n+    } else {\n+      str(klass, Address(obj, oopDesc::klass_offset_in_bytes()));\n+    }\n@@ -197,1 +212,1 @@\n-  } else if (UseCompressedClassPointers) {\n+  } else if (UseCompressedClassPointers && !UseCompactObjectHeaders) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":27,"deletions":12,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -301,0 +301,4 @@\n+void LoadKlassStub::emit_code(LIR_Assembler* ce) {\n+  \/\/ Currently not needed.\n+  Unimplemented();\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/c1_CodeStubs_ppc.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -256,0 +256,5 @@\n+void LoadKlassStub::emit_code(LIR_Assembler* ce) {\n+  \/\/ Currently not needed.\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/c1_CodeStubs_s390.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -45,0 +46,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -3050,0 +3052,1 @@\n+  Register tmp2 = UseCompactObjectHeaders ? rscratch2 : noreg;\n@@ -3174,2 +3177,0 @@\n-  Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());\n-  Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());\n@@ -3241,7 +3242,1 @@\n-      if (UseCompressedClassPointers) {\n-        __ movl(tmp, src_klass_addr);\n-        __ cmpl(tmp, dst_klass_addr);\n-      } else {\n-        __ movptr(tmp, src_klass_addr);\n-        __ cmpptr(tmp, dst_klass_addr);\n-      }\n+      __ cmp_klass(src, dst, tmp, tmp2);\n@@ -3306,0 +3301,1 @@\n+        Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());\n@@ -3407,4 +3403,1 @@\n-\n-\n-      if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);\n-      else                   __ cmpptr(tmp, dst_klass_addr);\n+      __ cmp_klass(tmp, dst, tmp2);\n@@ -3413,2 +3406,1 @@\n-      if (UseCompressedClassPointers)          __ cmpl(tmp, src_klass_addr);\n-      else                   __ cmpptr(tmp, src_klass_addr);\n+      __ cmp_klass(tmp, src, tmp2);\n@@ -3417,2 +3409,1 @@\n-      if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);\n-      else                   __ cmpptr(tmp, dst_klass_addr);\n+      __ cmp_klass(tmp, dst, tmp2);\n@@ -3488,1 +3479,1 @@\n-    Register tmp = LockingMode == LM_LIGHTWEIGHT ? op->scratch_opr()->as_register() : noreg;\n+    Register tmp = LockingMode == LM_LIGHTWEIGHT || LockingMode == LM_PLACEHOLDER ? op->scratch_opr()->as_register() : noreg;\n@@ -3514,1 +3505,16 @@\n-  if (UseCompressedClassPointers) {\n+  if (UseCompactObjectHeaders) {\n+    Register tmp = rscratch1;\n+    assert_different_registers(tmp, obj);\n+    assert_different_registers(tmp, result);\n+\n+    \/\/ Check if we can take the (common) fast path, if obj is unlocked.\n+    __ movq(result, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    if (LockingMode != LM_PLACEHOLDER) {\n+      __ testb(result, markWord::monitor_value);\n+      __ jcc(Assembler::notZero, *op->stub()->entry());\n+      __ bind(*op->stub()->continuation());\n+    }\n+    \/\/ Fast-path: shift and decode Klass*.\n+    __ shrq(result, markWord::klass_shift);\n+    __ decode_klass_not_null(result, tmp);\n+  } else if (UseCompressedClassPointers) {\n@@ -3519,0 +3525,1 @@\n+  {\n@@ -3520,0 +3527,1 @@\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":27,"deletions":19,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -64,0 +64,3 @@\n+  } else if (LockingMode == LM_PLACEHOLDER) {\n+    \/\/ null check obj. load_klass performs load if DiagnoseSyncOnValueBasedClasses != 0.\n+    testptr(hdr, Address(obj));\n@@ -66,1 +69,10 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n+  if (LockingMode == LM_PLACEHOLDER) {\n+    movptr(Address(disp_hdr), 0);\n+#ifdef _LP64\n+    const Register thread = r15_thread;\n+#else\n+    const Register thread = disp_hdr;\n+    get_thread(thread);\n+#endif\n+    placeholder_lock(obj, hdr, thread, tmp, slow_case);\n+  } else if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -121,0 +133,1 @@\n+  assert(LockingMode != LM_MONITOR, \"not handled\");\n@@ -125,1 +138,1 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n+  if (LockingMode == LM_LEGACY) {\n@@ -138,1 +151,10 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n+  if (LockingMode == LM_PLACEHOLDER) {\n+#ifdef _LP64\n+    placeholder_unlock(obj, disp_hdr, r15_thread, hdr, slow_case);\n+#else\n+    \/\/ This relies on the implementation of paceholder_unlock knowing that it\n+    \/\/ will clobber its thread when using EAX.\n+    get_thread(disp_hdr);\n+    placeholder_unlock(obj, disp_hdr, disp_hdr, hdr, slow_case);\n+#endif\n+  } else if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -174,2 +196,1 @@\n-  assert_different_registers(obj, klass, len);\n-  movptr(Address(obj, oopDesc::mark_offset_in_bytes()), checked_cast<int32_t>(markWord::prototype().value()));\n+  assert_different_registers(obj, klass, len, t1, t2);\n@@ -177,1 +198,5 @@\n-  if (UseCompressedClassPointers) { \/\/ Take care not to kill klass\n+  if (UseCompactObjectHeaders) {\n+    movptr(t1, Address(klass, Klass::prototype_header_offset()));\n+    movptr(Address(obj, oopDesc::mark_offset_in_bytes()), t1);\n+  } else if (UseCompressedClassPointers) { \/\/ Take care not to kill klass\n+    movptr(Address(obj, oopDesc::mark_offset_in_bytes()), checked_cast<int32_t>(markWord::prototype().value()));\n@@ -184,0 +209,1 @@\n+    movptr(Address(obj, oopDesc::mark_offset_in_bytes()), checked_cast<int32_t>(markWord::prototype().value()));\n@@ -186,1 +212,0 @@\n-\n@@ -200,1 +225,1 @@\n-  else if (UseCompressedClassPointers) {\n+  else if (UseCompressedClassPointers && !UseCompactObjectHeaders) {\n@@ -234,1 +259,3 @@\n-\n+  if (UseCompactObjectHeaders) {\n+    assert(hdr_size_in_bytes == 8, \"check object headers size\");\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":36,"deletions":9,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -4410,0 +4410,1 @@\n+  predicate(!UseCompactObjectHeaders);\n@@ -4420,0 +4421,15 @@\n+instruct loadNKlassCompactHeaders(rRegN dst, memory mem, rFlagsReg cr)\n+%{\n+  predicate(UseCompactObjectHeaders);\n+  match(Set dst (LoadNKlass mem));\n+  effect(KILL cr);\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movl    $dst, $mem\\t# compressed klass ptr\" %}\n+  ins_encode %{\n+    Register index = $mem$$index != 4 ? $mem$$index$$Register : noreg;\n+    Address::ScaleFactor sf = (index != noreg) ? static_cast<Address::ScaleFactor>($mem$$scale) : Address::no_scale;\n+    __ load_nklass_compact_c2($dst$$Register, $mem$$base$$Register, index, sf, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n@@ -11740,0 +11756,1 @@\n+  predicate(!UseCompactObjectHeaders);\n@@ -12386,1 +12403,1 @@\n-  predicate(LockingMode != LM_LIGHTWEIGHT && !Compile::current()->use_rtm());\n+  predicate(LockingMode != LM_LIGHTWEIGHT && LockingMode != LM_PLACEHOLDER && !Compile::current()->use_rtm());\n@@ -12399,1 +12416,1 @@\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n+  predicate(LockingMode != LM_LIGHTWEIGHT && LockingMode != LM_PLACEHOLDER);\n@@ -12434,0 +12451,24 @@\n+instruct cmpFastLockPlaceholder(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr) %{\n+  predicate(LockingMode == LM_PLACEHOLDER);\n+  match(Set cr (FastLock object box));\n+  effect(TEMP tmp, TEMP scr, USE_KILL box);\n+  ins_cost(300);\n+  format %{ \"fastlock $object,$box\\t! kills $box,$tmp,$scr\" %}\n+  ins_encode %{\n+    __ fast_lock_placeholder($object$$Register, $box$$Register, $tmp$$Register, $scr$$Register, r15_thread);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct cmpFastUnlockPlaceholder(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{\n+  predicate(LockingMode == LM_PLACEHOLDER);\n+  match(Set cr (FastUnlock object box));\n+  effect(TEMP tmp, USE_KILL box);\n+  ins_cost(300);\n+  format %{ \"fastunlock $object,$box\\t! kills $box,$tmp\" %}\n+  ins_encode %{\n+    __ fast_unlock_placeholder($object$$Register, $box$$Register, $tmp$$Register, r15_thread);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":43,"deletions":2,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -205,2 +205,7 @@\n-    oopDesc::set_mark(mem, markWord::prototype());\n-    oopDesc::release_set_klass(mem, k);\n+    if (UseCompactObjectHeaders) {\n+      narrowKlass nk = ArchiveBuilder::current()->get_requested_narrow_klass(k);\n+      oopDesc::release_set_mark(mem, markWord::prototype().set_narrow_klass(nk));\n+    } else {\n+      oopDesc::set_mark(mem, markWord::prototype());\n+      oopDesc::release_set_klass(mem, k);\n+    }\n@@ -272,2 +277,6 @@\n-  oopDesc::set_mark(mem, markWord::prototype());\n-  cast_to_oop(mem)->set_narrow_klass(nk);\n+  if (UseCompactObjectHeaders) {\n+    oopDesc::release_set_mark(mem, markWord::prototype().set_narrow_klass(nk));\n+  } else {\n+    oopDesc::set_mark(mem, markWord::prototype());\n+    cast_to_oop(mem)->set_narrow_klass(nk);\n+  }\n@@ -474,1 +483,3 @@\n-  fake_oop->set_narrow_klass(nk);\n+  if (!UseCompactObjectHeaders) {\n+    fake_oop->set_narrow_klass(nk);\n+  }\n@@ -482,1 +493,5 @@\n-    fake_oop->set_mark(markWord::prototype().copy_set_hash(src_hash));\n+    if (UseCompactObjectHeaders) {\n+      fake_oop->set_mark(markWord::prototype().set_narrow_klass(nk).copy_set_hash(src_hash));\n+    } else {\n+      fake_oop->set_mark(markWord::prototype().copy_set_hash(src_hash));\n+    }\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -207,0 +207,1 @@\n+  _compact_headers = UseCompactObjectHeaders;\n@@ -273,0 +274,1 @@\n+  st->print_cr(\"- compact_headers:                %d\", _compact_headers);\n@@ -2002,1 +2004,1 @@\n-  \/\/ ArchiveHeapWriter::precomputed_narrow_klass_shift. We enforce this encoding at runtime (see\n+  \/\/ ArchiveBuilder::precomputed_narrow_klass_shift. We enforce this encoding at runtime (see\n@@ -2006,1 +2008,1 @@\n-  const int archive_narrow_klass_shift = ArchiveHeapWriter::precomputed_narrow_klass_shift;\n+  const int archive_narrow_klass_shift = ArchiveBuilder::precomputed_narrow_klass_shift;\n@@ -2395,0 +2397,8 @@\n+  if (compact_headers() != UseCompactObjectHeaders) {\n+    log_info(cds)(\"The shared archive file's UseCompactObjectHeaders setting (%s)\"\n+                  \" does not equal the current UseCompactObjectHeaders setting (%s).\",\n+                  _compact_headers          ? \"enabled\" : \"disabled\",\n+                  UseCompactObjectHeaders   ? \"enabled\" : \"disabled\");\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1161,11 +1161,12 @@\n-#if INCLUDE_CDS_JAVA_HEAP\n-          \/\/ We archived objects with pre-computed narrow Klass id. Set up encoding such that these Ids stay valid.\n-          address precomputed_narrow_klass_base = cds_base;\n-          const int precomputed_narrow_klass_shift = ArchiveHeapWriter::precomputed_narrow_klass_shift;\n-          CompressedKlassPointers::initialize_for_given_encoding(\n-            cds_base, ccs_end - cds_base, \/\/ Klass range\n-            precomputed_narrow_klass_base, precomputed_narrow_klass_shift \/\/ precomputed encoding, see ArchiveHeapWriter\n-            );\n-#else\n-          CompressedKlassPointers::initialize (\n-            cds_base, ccs_end - cds_base \/\/ Klass range\n+          if (INCLUDE_CDS_JAVA_HEAP || UseCompactObjectHeaders) {\n+            \/\/ The CDS archive may contain narrow Klass IDs that were precomputed at archive generation time:\n+            \/\/ - every archived java object header (only if INCLUDE_CDS_JAVA_HEAP)\n+            \/\/ - every archived Klass' prototype   (only if +UseCompactObjectHeaders)\n+            \/\/\n+            \/\/ In order for those IDs to still be valid, we need to dictate base and shift: base should be the\n+            \/\/ mapping start, shift the shift used at archive generation time.\n+            address precomputed_narrow_klass_base = cds_base;\n+            const int precomputed_narrow_klass_shift = ArchiveBuilder::precomputed_narrow_klass_shift;\n+            CompressedKlassPointers::initialize_for_given_encoding(\n+              cds_base, ccs_end - cds_base, \/\/ Klass range\n+              precomputed_narrow_klass_base, precomputed_narrow_klass_shift \/\/ precomputed encoding, see ArchiveBuilder\n@@ -1173,1 +1174,6 @@\n-#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n+          } else {\n+            \/\/ Let JVM freely chose encoding base and shift\n+            CompressedKlassPointers::initialize (\n+              cds_base, ccs_end - cds_base \/\/ Klass range\n+              );\n+          }\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+#include \"gc\/shared\/slidingForwarding.hpp\"\n@@ -1443,0 +1444,2 @@\n+  SlidingForwarding::initialize(heap_rs.region(), HeapRegion::GrainWords);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"gc\/shared\/slidingForwarding.hpp\"\n@@ -215,0 +216,2 @@\n+  SlidingForwarding::begin();\n+\n@@ -227,0 +230,2 @@\n+  SlidingForwarding::end();\n+\n@@ -402,1 +407,2 @@\n-void G1FullCollector::phase2c_prepare_serial_compaction() {\n+template <bool ALT_FWD>\n+void G1FullCollector::phase2c_prepare_serial_compaction_impl() {\n@@ -427,1 +433,1 @@\n-  G1SerialRePrepareClosure re_prepare(serial_cp, dense_prefix_top);\n+  G1SerialRePrepareClosure<ALT_FWD> re_prepare(serial_cp, dense_prefix_top);\n@@ -440,1 +446,10 @@\n-void G1FullCollector::phase2d_prepare_humongous_compaction() {\n+void G1FullCollector::phase2c_prepare_serial_compaction() {\n+  if (UseAltGCForwarding) {\n+    phase2c_prepare_serial_compaction_impl<true>();\n+  } else {\n+    phase2c_prepare_serial_compaction_impl<false>();\n+  }\n+}\n+\n+template <bool ALT_FWD>\n+void G1FullCollector::phase2d_prepare_humongous_compaction_impl() {\n@@ -462,1 +477,1 @@\n-        humongous_cp->forward_humongous(hr);\n+        humongous_cp->forward_humongous<ALT_FWD>(hr);\n@@ -475,0 +490,8 @@\n+void G1FullCollector::phase2d_prepare_humongous_compaction() {\n+  if (UseAltGCForwarding) {\n+    phase2d_prepare_humongous_compaction_impl<true>();\n+  } else {\n+    phase2d_prepare_humongous_compaction_impl<false>();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+template <bool ALT_FWD>\n@@ -44,1 +45,1 @@\n-  G1AdjustClosure* _adjust_closure;\n+  G1AdjustClosure<ALT_FWD>* _adjust_closure;\n@@ -46,1 +47,1 @@\n-  G1AdjustLiveClosure(G1AdjustClosure* cl) :\n+  G1AdjustLiveClosure(G1AdjustClosure<ALT_FWD>* cl) :\n@@ -65,1 +66,11 @@\n-    G1AdjustClosure cl(_collector);\n+    if (UseAltGCForwarding) {\n+      return do_heap_region_impl<true>(r);\n+    } else {\n+      return do_heap_region_impl<false>(r);\n+    }\n+  }\n+\n+private:\n+  template <bool ALT_FWD>\n+  bool do_heap_region_impl(HeapRegion* r) {\n+    G1AdjustClosure<ALT_FWD> cl(_collector);\n@@ -73,1 +84,1 @@\n-      G1AdjustLiveClosure adjust(&cl);\n+      G1AdjustLiveClosure<ALT_FWD> adjust(&cl);\n@@ -84,2 +95,1 @@\n-    _hrclaimer(collector->workers()),\n-    _adjust(collector) {\n+    _hrclaimer(collector->workers()) {\n@@ -89,1 +99,2 @@\n-void G1FullGCAdjustTask::work(uint worker_id) {\n+template <bool ALT_FWD>\n+void G1FullGCAdjustTask::work_impl(uint worker_id) {\n@@ -97,0 +108,1 @@\n+  G1AdjustClosure<ALT_FWD> adjust(collector());\n@@ -100,1 +112,1 @@\n-    _weak_proc_task.work(worker_id, &always_alive, &_adjust);\n+    _weak_proc_task.work(worker_id, &always_alive, &adjust);\n@@ -103,3 +115,3 @@\n-  CLDToOopClosure adjust_cld(&_adjust, ClassLoaderData::_claim_stw_fullgc_adjust);\n-  CodeBlobToOopClosure adjust_code(&_adjust, CodeBlobToOopClosure::FixRelocations);\n-  _root_processor.process_all_roots(&_adjust, &adjust_cld, &adjust_code);\n+  CLDToOopClosure adjust_cld(&adjust, ClassLoaderData::_claim_stw_fullgc_adjust);\n+  CodeBlobToOopClosure adjust_code(&adjust, CodeBlobToOopClosure::FixRelocations);\n+  _root_processor.process_all_roots(&adjust, &adjust_cld, &adjust_code);\n@@ -112,0 +124,8 @@\n+\n+void G1FullGCAdjustTask::work(uint worker_id) {\n+  if (UseAltGCForwarding) {\n+    work_impl<true>(worker_id);\n+  } else {\n+    work_impl<false>(worker_id);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.cpp","additions":31,"deletions":11,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -41,1 +41,2 @@\n-  G1AdjustClosure          _adjust;\n+  template <bool ALT_FWD>\n+  void work_impl(uint worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -37,1 +38,2 @@\n-void G1FullGCCompactTask::G1CompactRegionClosure::clear_in_bitmap(oop obj) {\n+template <bool ALT_FWD>\n+void G1FullGCCompactTask::G1CompactRegionClosure<ALT_FWD>::clear_in_bitmap(oop obj) {\n@@ -42,1 +44,2 @@\n-size_t G1FullGCCompactTask::G1CompactRegionClosure::apply(oop obj) {\n+template <bool ALT_FWD>\n+size_t G1FullGCCompactTask::G1CompactRegionClosure<ALT_FWD>::apply(oop obj) {\n@@ -44,2 +47,2 @@\n-  if (obj->is_forwarded()) {\n-    G1FullGCCompactTask::copy_object_to_new_location(obj);\n+  if (SlidingForwarding::is_forwarded(obj)) {\n+    G1FullGCCompactTask::copy_object_to_new_location<ALT_FWD>(obj);\n@@ -54,0 +57,1 @@\n+template <bool ALT_FWD>\n@@ -55,2 +59,2 @@\n-  assert(obj->is_forwarded(), \"Sanity!\");\n-  assert(obj->forwardee() != obj, \"Object must have a new location\");\n+  assert(SlidingForwarding::is_forwarded(obj), \"Sanity!\");\n+  assert(SlidingForwarding::forwardee<ALT_FWD>(obj) != obj, \"Object must have a new location\");\n@@ -61,1 +65,1 @@\n-  HeapWord* destination = cast_from_oop<HeapWord*>(obj->forwardee());\n+  HeapWord* destination = cast_from_oop<HeapWord*>(SlidingForwarding::forwardee<ALT_FWD>(obj));\n@@ -81,2 +85,7 @@\n-    G1CompactRegionClosure compact(collector()->mark_bitmap());\n-    hr->apply_to_marked_objects(collector()->mark_bitmap(), &compact);\n+    if (UseAltGCForwarding) {\n+      G1CompactRegionClosure<true> compact(collector()->mark_bitmap());\n+      hr->apply_to_marked_objects(collector()->mark_bitmap(), &compact);\n+    } else {\n+      G1CompactRegionClosure<false> compact(collector()->mark_bitmap());\n+      hr->apply_to_marked_objects(collector()->mark_bitmap(), &compact);\n+    }\n@@ -108,3 +117,2 @@\n-void G1FullGCCompactTask::humongous_compaction() {\n-  GCTraceTime(Debug, gc, phases) tm(\"Phase 4: Humonguous Compaction\", collector()->scope()->timer());\n-\n+template <bool ALT_FWD>\n+void G1FullGCCompactTask::humongous_compaction_impl() {\n@@ -113,1 +121,10 @@\n-    compact_humongous_obj(hr);\n+    compact_humongous_obj<ALT_FWD>(hr);\n+  }\n+}\n+\n+void G1FullGCCompactTask::humongous_compaction() {\n+  GCTraceTime(Debug, gc, phases) tm(\"Phase 4: Humonguous Compaction\", collector()->scope()->timer());\n+  if (UseAltGCForwarding) {\n+    humongous_compaction_impl<true>();\n+  } else {\n+    humongous_compaction_impl<false>();\n@@ -117,0 +134,1 @@\n+template <bool ALT_FWD>\n@@ -124,1 +142,1 @@\n-  HeapWord* destination = cast_from_oop<HeapWord*>(obj->forwardee());\n+  HeapWord* destination = cast_from_oop<HeapWord*>(SlidingForwarding::forwardee<ALT_FWD>(obj));\n@@ -129,1 +147,1 @@\n-  copy_object_to_new_location(obj);\n+  copy_object_to_new_location<ALT_FWD>(obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":33,"deletions":15,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  template <bool ALT_FWD>\n@@ -47,0 +48,1 @@\n+  template <bool ALT_FWD>\n@@ -49,0 +51,3 @@\n+  template <bool ALT_FWD>\n+  void humongous_compaction_impl();\n+\n@@ -60,0 +65,1 @@\n+  template <bool ALT_FWD>\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -96,0 +97,1 @@\n+template <bool ALT_FWD>\n@@ -109,2 +111,2 @@\n-    object->forward_to(cast_to_oop(_compaction_top));\n-    assert(object->is_forwarded(), \"must be forwarded\");\n+    SlidingForwarding::forward_to<ALT_FWD>(object, cast_to_oop(_compaction_top));\n+    assert(SlidingForwarding::is_forwarded(object), \"must be forwarded\");\n@@ -112,1 +114,1 @@\n-    assert(!object->is_forwarded(), \"must not be forwarded\");\n+    assert(SlidingForwarding::is_not_forwarded(object), \"must not be forwarded\");\n@@ -120,0 +122,3 @@\n+template void G1FullGCCompactionPoint::forward<true>(oop object, size_t size);\n+template void G1FullGCCompactionPoint::forward<false>(oop object, size_t size);\n+\n@@ -152,0 +157,1 @@\n+template <bool ALT_FWD>\n@@ -175,2 +181,2 @@\n-  obj->forward_to(cast_to_oop(dest_hr->bottom()));\n-  assert(obj->is_forwarded(), \"Object must be forwarded!\");\n+  SlidingForwarding::forward_to<ALT_FWD>(obj, cast_to_oop(dest_hr->bottom()));\n+  assert(SlidingForwarding::is_forwarded(obj), \"Object must be forwarded!\");\n@@ -187,0 +193,3 @@\n+template void G1FullGCCompactionPoint::forward_humongous<true>(HeapRegion* hr);\n+template void G1FullGCCompactionPoint::forward_humongous<false>(HeapRegion* hr);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -54,1 +55,2 @@\n-template <class T> inline void G1AdjustClosure::adjust_pointer(T* p) {\n+template <bool ALT_FWD>\n+template <class T> inline void G1AdjustClosure<ALT_FWD>::adjust_pointer(T* p) {\n@@ -68,2 +70,2 @@\n-  if (obj->is_forwarded()) {\n-    oop forwardee = obj->forwardee();\n+  if (SlidingForwarding::is_forwarded(obj)) {\n+    oop forwardee = SlidingForwarding::forwardee<ALT_FWD>(obj);\n@@ -77,2 +79,4 @@\n-inline void G1AdjustClosure::do_oop(oop* p)       { do_oop_work(p); }\n-inline void G1AdjustClosure::do_oop(narrowOop* p) { do_oop_work(p); }\n+template <bool ALT_FWD>\n+inline void G1AdjustClosure<ALT_FWD>::do_oop(oop* p)       { do_oop_work(p); }\n+template <bool ALT_FWD>\n+inline void G1AdjustClosure<ALT_FWD>::do_oop(narrowOop* p) { do_oop_work(p); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -107,1 +107,2 @@\n-G1FullGCPrepareTask::G1PrepareCompactLiveClosure::G1PrepareCompactLiveClosure(G1FullGCCompactionPoint* cp) :\n+template <bool ALT_FWD>\n+G1FullGCPrepareTask::G1PrepareCompactLiveClosure<ALT_FWD>::G1PrepareCompactLiveClosure(G1FullGCCompactionPoint* cp) :\n@@ -110,1 +111,2 @@\n-size_t G1FullGCPrepareTask::G1PrepareCompactLiveClosure::apply(oop object) {\n+template <bool ALT_FWD>\n+size_t G1FullGCPrepareTask::G1PrepareCompactLiveClosure<ALT_FWD>::apply(oop object) {\n@@ -112,1 +114,1 @@\n-  _cp->forward(object, size);\n+  _cp->forward<ALT_FWD>(object, size);\n@@ -118,2 +120,7 @@\n-    G1PrepareCompactLiveClosure prepare_compact(_cp);\n-    hr->apply_to_marked_objects(_bitmap, &prepare_compact);\n+    if (UseAltGCForwarding) {\n+      G1PrepareCompactLiveClosure<true> prepare_compact(_cp);\n+      hr->apply_to_marked_objects(_bitmap, &prepare_compact);\n+    } else {\n+      G1PrepareCompactLiveClosure<false> prepare_compact(_cp);\n+      hr->apply_to_marked_objects(_bitmap, &prepare_compact);\n+    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+  template <bool ALT_FWD>\n@@ -103,0 +104,1 @@\n+template <bool ALT_FWD>\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -116,2 +117,3 @@\n-inline size_t G1SerialRePrepareClosure::apply(oop obj) {\n-  if (obj->is_forwarded()) {\n+template <bool ALT_FWD>\n+inline size_t G1SerialRePrepareClosure<ALT_FWD>::apply(oop obj) {\n+  if (SlidingForwarding::is_forwarded(obj)) {\n@@ -120,1 +122,1 @@\n-    if (cast_from_oop<HeapWord*>(obj->forwardee()) < _dense_prefix_top) {\n+    if (cast_from_oop<HeapWord*>(SlidingForwarding::forwardee<ALT_FWD>(obj)) < _dense_prefix_top) {\n@@ -127,1 +129,1 @@\n-  _cp->forward(obj, size);\n+  _cp->forward<ALT_FWD>(obj, size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.inline.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-      forwardee = cast_to_oop(m.decode_pointer());\n+      forwardee = obj->forwardee(m);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+#include \"gc\/shared\/slidingForwarding.hpp\"\n@@ -206,0 +207,2 @@\n+  SlidingForwarding::initialize(_reserved, SpaceAlignment \/ HeapWordSize);\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -232,1 +232,3 @@\n-  if (!Metaspace::contains(object->klass_raw())) {\n+  \/\/ With compact headers, we can't safely access the class, due\n+  \/\/ to possibly forwarded objects.\n+  if (!UseCompactObjectHeaders && !Metaspace::contains(object->klass_raw())) {\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -311,1 +311,1 @@\n-  static constexpr size_t min_dummy_object_size() {\n+  static size_t min_dummy_object_size() {\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -660,2 +660,6 @@\n-          constraint(GCCardSizeInBytesConstraintFunc,AtParse)\n-  \/\/ end of GC_FLAGS\n+          constraint(GCCardSizeInBytesConstraintFunc,AtParse)               \\\n+                                                                            \\\n+  product(bool, UseAltGCForwarding, false, EXPERIMENTAL,                    \\\n+          \"Use alternative GC forwarding that preserves object headers\")    \\\n+\n+\/\/ end of GC_FLAGS\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -385,1 +385,3 @@\n-  oopDesc::set_klass_gap(mem, 0);\n+  if (!UseCompactObjectHeaders) {\n+    oopDesc::set_klass_gap(mem, 0);\n+  }\n@@ -391,2 +393,0 @@\n-  \/\/ May be bootstrapping\n-  oopDesc::set_mark(mem, markWord::prototype());\n@@ -396,1 +396,6 @@\n-  oopDesc::release_set_klass(mem, _klass);\n+  if (UseCompactObjectHeaders) {\n+    oopDesc::release_set_mark(mem, _klass->prototype_header());\n+  } else {\n+    oopDesc::set_mark(mem, markWord::prototype());\n+    oopDesc::release_set_klass(mem, _klass);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -231,0 +232,2 @@\n+    SlidingForwarding::begin();\n+\n@@ -239,0 +242,1 @@\n+    SlidingForwarding::end();\n@@ -303,0 +307,1 @@\n+template <bool ALT_FWD>\n@@ -371,1 +376,1 @@\n-    p->forward_to(cast_to_oop(_compact_point));\n+    SlidingForwarding::forward_to<ALT_FWD>(p, cast_to_oop(_compact_point));\n@@ -401,1 +406,8 @@\n-  void work(uint worker_id) override;\n+  void work(uint worker_id) override {\n+    if (UseAltGCForwarding) {\n+      work_impl<true>(worker_id);\n+    } else {\n+      work_impl<false>(worker_id);\n+    }\n+  }\n+\n@@ -403,0 +415,3 @@\n+  template<bool ALT_FWD>\n+  void work_impl(uint worker_id);\n+\n@@ -410,1 +425,2 @@\n-void ShenandoahPrepareForCompactionTask::work(uint worker_id) {\n+template<bool ALT_FWD>\n+void ShenandoahPrepareForCompactionTask::work_impl(uint worker_id) {\n@@ -426,1 +442,1 @@\n-  ShenandoahPrepareForCompactionObjectClosure cl(_preserved_marks->get(worker_id), empty_regions, from_region);\n+  ShenandoahPrepareForCompactionObjectClosure<ALT_FWD> cl(_preserved_marks->get(worker_id), empty_regions, from_region);\n@@ -457,1 +473,2 @@\n-void ShenandoahFullGC::calculate_target_humongous_objects() {\n+template<bool ALT_FWD>\n+void ShenandoahFullGC::calculate_target_humongous_objects_impl() {\n@@ -493,1 +510,1 @@\n-        old_obj->forward_to(cast_to_oop(heap->get_region(start)->bottom()));\n+        SlidingForwarding::forward_to<ALT_FWD>(old_obj, cast_to_oop(heap->get_region(start)->bottom()));\n@@ -505,0 +522,8 @@\n+void ShenandoahFullGC::calculate_target_humongous_objects() {\n+  if (UseAltGCForwarding) {\n+    calculate_target_humongous_objects_impl<true>();\n+  } else {\n+    calculate_target_humongous_objects_impl<false>();\n+  }\n+}\n+\n@@ -742,0 +767,1 @@\n+template <bool ALT_FWD>\n@@ -753,2 +779,2 @@\n-      if (obj->is_forwarded()) {\n-        oop forw = obj->forwardee();\n+      if (SlidingForwarding::is_forwarded(obj)) {\n+        oop forw = SlidingForwarding::forwardee<ALT_FWD>(obj);\n@@ -771,0 +797,1 @@\n+template <bool ALT_FWD>\n@@ -774,1 +801,1 @@\n-  ShenandoahAdjustPointersClosure _cl;\n+  ShenandoahAdjustPointersClosure<ALT_FWD> _cl;\n@@ -797,1 +824,3 @@\n-  void work(uint worker_id) {\n+private:\n+  template <bool ALT_FWD>\n+  void work_impl(uint worker_id) {\n@@ -799,1 +828,1 @@\n-    ShenandoahAdjustPointersObjectClosure obj_cl;\n+    ShenandoahAdjustPointersObjectClosure<ALT_FWD> obj_cl;\n@@ -808,0 +837,9 @@\n+\n+public:\n+  void work(uint worker_id) {\n+    if (UseAltGCForwarding) {\n+      work_impl<true>(worker_id);\n+    } else {\n+      work_impl<false>(worker_id);\n+    }\n+  }\n@@ -814,0 +852,1 @@\n+\n@@ -820,1 +859,3 @@\n-  void work(uint worker_id) {\n+private:\n+  template <bool ALT_FWD>\n+  void work_impl(uint worker_id) {\n@@ -822,1 +863,1 @@\n-    ShenandoahAdjustPointersClosure cl;\n+    ShenandoahAdjustPointersClosure<ALT_FWD> cl;\n@@ -826,0 +867,9 @@\n+\n+public:\n+  void work(uint worker_id) {\n+    if (UseAltGCForwarding) {\n+      work_impl<true>(worker_id);\n+    } else {\n+      work_impl<false>(worker_id);\n+    }\n+  }\n@@ -852,0 +902,1 @@\n+template <bool ALT_FWD>\n@@ -864,1 +915,1 @@\n-    if (p->is_forwarded()) {\n+    if (SlidingForwarding::is_forwarded(p)) {\n@@ -866,1 +917,1 @@\n-      HeapWord* compact_to = cast_from_oop<HeapWord*>(p->forwardee());\n+      HeapWord* compact_to = cast_from_oop<HeapWord*>(SlidingForwarding::forwardee<ALT_FWD>(p));\n@@ -888,1 +939,3 @@\n-  void work(uint worker_id) {\n+private:\n+  template <bool ALT_FWD>\n+  void work_impl(uint worker_id) {\n@@ -892,1 +945,1 @@\n-    ShenandoahCompactObjectsClosure cl(worker_id);\n+    ShenandoahCompactObjectsClosure<ALT_FWD> cl(worker_id);\n@@ -903,0 +956,9 @@\n+\n+public:\n+  void work(uint worker_id) {\n+    if (UseAltGCForwarding) {\n+      work_impl<true>(worker_id);\n+    } else {\n+      work_impl<false>(worker_id);\n+    }\n+  }\n@@ -958,1 +1020,2 @@\n-void ShenandoahFullGC::compact_humongous_objects() {\n+template <bool ALT_FWD>\n+void ShenandoahFullGC::compact_humongous_objects_impl() {\n@@ -971,1 +1034,1 @@\n-      if (!old_obj->is_forwarded()) {\n+      if (SlidingForwarding::is_not_forwarded(old_obj)) {\n@@ -980,1 +1043,1 @@\n-      size_t new_start = heap->heap_region_index_containing(old_obj->forwardee());\n+      size_t new_start = heap->heap_region_index_containing(SlidingForwarding::forwardee<ALT_FWD>(old_obj));\n@@ -1021,0 +1084,8 @@\n+void ShenandoahFullGC::compact_humongous_objects() {\n+  if (UseAltGCForwarding) {\n+    compact_humongous_objects_impl<true>();\n+  } else {\n+    compact_humongous_objects_impl<false>();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":91,"deletions":20,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+  template <bool ALT_FWD>\n@@ -86,0 +87,2 @@\n+  template <bool ALT_FWD>\n+  void calculate_target_humongous_objects_impl();\n@@ -88,0 +91,2 @@\n+  template <bool ALT_FWD>\n+  void compact_humongous_objects_impl();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shared\/slidingForwarding.hpp\"\n@@ -441,0 +442,2 @@\n+  SlidingForwarding::initialize(_heap_region, ShenandoahHeapRegion::region_size_words());\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -76,2 +76,6 @@\n-  arrayOopDesc::set_mark(mem, markWord::prototype());\n-  arrayOopDesc::release_set_klass(mem, _klass);\n+  if (UseCompactObjectHeaders) {\n+    oopDesc::release_set_mark(mem, _klass->prototype_header());\n+  } else {\n+    arrayOopDesc::set_mark(mem, markWord::prototype());\n+    arrayOopDesc::release_set_klass(mem, _klass);\n+  }\n","filename":"src\/hotspot\/share\/gc\/x\/xObjArrayAllocator.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -79,2 +79,6 @@\n-  arrayOopDesc::set_mark(mem, markWord::prototype().set_marked());\n-  arrayOopDesc::release_set_klass(mem, _klass);\n+  if (UseCompactObjectHeaders) {\n+    oopDesc::release_set_mark(mem, _klass->prototype_header().set_marked());\n+  } else {\n+    arrayOopDesc::set_mark(mem, markWord::prototype().set_marked());\n+    arrayOopDesc::release_set_klass(mem, _klass);\n+  }\n@@ -150,1 +154,5 @@\n-  oopDesc::release_set_mark(mem, markWord::prototype());\n+  if (UseCompactObjectHeaders) {\n+    oopDesc::release_set_mark(mem, _klass->prototype_header());\n+  } else {\n+    oopDesc::release_set_mark(mem, markWord::prototype());\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -440,1 +440,5 @@\n-  if (offset == oopDesc::klass_offset_in_bytes()) {\n+\n+  \/\/ With compact object headers, we can test for the explicit offset within\n+  \/\/ the header to figure out if compiler code is accessing the class.\n+  int klass_offset = UseCompactObjectHeaders ? 4 : oopDesc::klass_offset_in_bytes();\n+  if (offset == klass_offset) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -85,2 +85,7 @@\n-    return UseCompressedClassPointers ? klass_gap_offset_in_bytes() :\n-                               sizeof(arrayOopDesc);\n+    if (UseCompactObjectHeaders) {\n+      return oopDesc::base_offset_in_bytes();\n+    } else if (UseCompressedClassPointers) {\n+      return klass_gap_offset_in_bytes();\n+    } else {\n+      return sizeof(arrayOopDesc);\n+    }\n","filename":"src\/hotspot\/share\/oops\/arrayOop.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-  return LockingMode == LM_LIGHTWEIGHT || !SafepointSynchronize::is_at_safepoint();\n+  return LockingMode == LM_LIGHTWEIGHT || LockingMode == LM_PLACEHOLDER || !SafepointSynchronize::is_at_safepoint();\n@@ -157,1 +157,2 @@\n-  return UseCompressedClassPointers;\n+  \/\/ Except when using compact headers.\n+  return UseCompressedClassPointers && !UseCompactObjectHeaders;\n@@ -169,1 +170,3 @@\n-  if (UseCompressedClassPointers) {\n+  if (UseCompactObjectHeaders) {\n+    return obj->klass();\n+  } else if (UseCompressedClassPointers) {\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1620,2 +1620,8 @@\n-  \/\/ For now only enable fast locking for non-array types\n-  mark_node = phase->MakeConX(markWord::prototype().value());\n+  if (UseCompactObjectHeaders) {\n+    Node* klass_node = in(AllocateNode::KlassNode);\n+    Node* proto_adr = phase->transform(new AddPNode(klass_node, klass_node, phase->MakeConX(in_bytes(Klass::prototype_header_offset()))));\n+    mark_node = LoadNode::make(*phase, control, mem, proto_adr, TypeRawPtr::BOTTOM, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n+  } else {\n+    \/\/ For now only enable fast locking for non-array types\n+    mark_node = phase->MakeConX(markWord::prototype().value());\n+  }\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1718,0 +1718,4 @@\n+      if (UseCompactObjectHeaders) {\n+        if (flat->offset() == in_bytes(Klass::prototype_header_offset()))\n+          alias_type(idx)->set_rewritable(false);\n+      }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1704,1 +1704,4 @@\n-  rawmem = make_store(control, rawmem, object, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);\n+  if (!UseCompactObjectHeaders) {\n+    rawmem = make_store(control, rawmem, object, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1931,0 +1931,7 @@\n+  if (UseCompactObjectHeaders) {\n+    if (tkls->offset() == in_bytes(Klass::prototype_header_offset())) {\n+      \/\/ The field is Klass::_prototype_header.  Return its (constant) value.\n+      assert(this->Opcode() == Op_LoadX, \"must load a proper type from _prototype_header\");\n+      return TypeX::make(klass->prototype_header());\n+    }\n+  }\n@@ -2103,0 +2110,7 @@\n+      if (UseCompactObjectHeaders) {\n+        if (tkls->offset() == in_bytes(Klass::prototype_header_offset())) {\n+          \/\/ The field is Klass::_prototype_header. Return its (constant) value.\n+          assert(this->Opcode() == Op_LoadX, \"must load a proper type from _prototype_header\");\n+          return TypeX::make(klass->prototype_header());\n+        }\n+      }\n@@ -2193,1 +2207,1 @@\n-  if (alloc != nullptr) {\n+  if (!UseCompactObjectHeaders && alloc != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -133,0 +133,3 @@\n+  product(bool, UseCompactObjectHeaders, false, EXPERIMENTAL,               \\\n+          \"Use compact 64-bit object headers in 64-bit VM\")                 \\\n+                                                                            \\\n@@ -150,0 +153,1 @@\n+const bool UseCompactObjectHeaders = false;\n@@ -1983,1 +1987,1 @@\n-  product(int, LockingMode, LM_LEGACY,                                      \\\n+  product(int, LockingMode, LM_PLACEHOLDER,                                 \\\n@@ -1987,2 +1991,22 @@\n-          \"2: monitors & new lightweight locking (LM_LIGHTWEIGHT)\")         \\\n-          range(0, 2)                                                       \\\n+          \"2: monitors & new lightweight locking (LM_LIGHTWEIGHT), \"        \\\n+          \"3: placeholder (LM_PLACEHOLDER)\")                                \\\n+          range(0, 3)                                                       \\\n+                                                                            \\\n+  product(bool, OMUseC2Cache, true, \"\")                                     \\\n+                                                                            \\\n+  product(int, OMCacheSize, 8, \"\")                                          \\\n+          range(0, OMCache::CAPACITY)                                       \\\n+                                                                            \\\n+  product(bool, OMShrinkCHT, false, \"\")                                     \\\n+                                                                            \\\n+  product(int, OMSpins, 20, \"\")                                             \\\n+                                                                            \\\n+  product(int, OMYields, 5, \"\")                                             \\\n+                                                                            \\\n+  product(bool, OMDeflateAfterWait, false, \"\")                              \\\n+                                                                            \\\n+  product(bool, OMDeflateBeforeExit, false, \"\")                             \\\n+                                                                            \\\n+  product(bool, OMCacheHitRate, false, \"\")                                  \\\n+                                                                            \\\n+  product(bool, OMRecursiveFastPath, true, \"Inflated recursion check first\")\\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"runtime\/placeholderSynchronizer.hpp\"\n@@ -55,0 +56,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -56,0 +58,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -289,4 +292,0 @@\n-oop ObjectMonitor::object_peek() const {\n-  return _object.peek();\n-}\n-\n@@ -314,0 +313,6 @@\n+#define assert_mark_word_concistency()                                                 \\\n+  assert(LockingMode == LM_PLACEHOLDER || object()->mark() == markWord::encode(this),  \\\n+         \"object mark must match encoded this: mark=\" INTPTR_FORMAT                    \\\n+         \", encoded this=\" INTPTR_FORMAT, object()->mark().value(),                    \\\n+         markWord::encode(this).value());\n+\n@@ -316,0 +321,14 @@\n+bool ObjectMonitor::try_enter(JavaThread* current) {\n+  void* cur = try_set_owner_from(nullptr, current);\n+  if (cur == nullptr) {\n+    assert(_recursions == 0, \"invariant\");\n+    return true;\n+  }\n+\n+  if (cur == current) {\n+    _recursions++;\n+    return true;\n+  }\n+\n+  return false;\n+}\n@@ -396,1 +415,1 @@\n-  if (LockingMode != LM_LIGHTWEIGHT && current->is_lock_owned((address)cur)) {\n+  if (LockingMode != LM_LIGHTWEIGHT && LockingMode != LM_PLACEHOLDER && current->is_lock_owned((address)cur)) {\n@@ -415,4 +434,1 @@\n-    assert(object()->mark() == markWord::encode(this),\n-           \"object mark must match encoded this: mark=\" INTPTR_FORMAT\n-           \", encoded this=\" INTPTR_FORMAT, object()->mark().value(),\n-           markWord::encode(this).value());\n+    assert_mark_word_concistency();\n@@ -435,1 +451,1 @@\n-    if (l_object != nullptr) {\n+    if (LockingMode != LM_PLACEHOLDER && l_object != nullptr) {\n@@ -509,1 +525,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n+  assert_mark_word_concistency();\n@@ -571,1 +587,1 @@\n-bool ObjectMonitor::deflate_monitor() {\n+bool ObjectMonitor::deflate_monitor(Thread* current) {\n@@ -577,0 +593,7 @@\n+  if (LockingMode == LM_PLACEHOLDER && is_being_async_deflated()) {\n+    \/\/ This happens when a locked monitor is deflated by a java thread\n+    \/\/ returning itself to fast_locked\n+    assert(is_owner_anonymous(), \"must stay anonymous when the java thread deflates\");\n+    return true;\n+  }\n+\n@@ -642,0 +665,1 @@\n+  }\n@@ -643,2 +667,7 @@\n-    \/\/ Install the old mark word if nobody else has already done it.\n-    install_displaced_markword_in_object(obj);\n+  if (LockingMode == LM_PLACEHOLDER) {\n+    PlaceholderSynchronizer::deflate_monitor(current, obj, this);\n+  } else {\n+    if (obj != nullptr) {\n+      \/\/ Install the old mark word if nobody else has already done it.\n+      install_displaced_markword_in_object(obj);\n+    }\n@@ -652,0 +681,71 @@\n+bool ObjectMonitor::deflate_anon_monitor(JavaThread* current) {\n+  assert(owner_raw() == current, \"must be\");\n+  assert(LockingMode == LM_PLACEHOLDER, \"must be\");\n+\n+  LockStack& lock_stack = current->lock_stack();\n+\n+  if (!lock_stack.can_push(1 + _recursions)) {\n+    \/\/ Will not be able to push the oop on the lock stack.\n+    return false;\n+  }\n+\n+  if (is_contended()) {\n+    \/\/ Easy checks are first - the ObjectMonitor is busy so no deflation.\n+    return false;\n+  }\n+\n+  \/\/ Make sure if a thread sees contentions() < 0 they also see owner == ANONYMOUS_OWNER\n+  set_owner_from(current, reinterpret_cast<void*>(ANONYMOUS_OWNER));\n+\n+    \/\/ Recheck after setting owner\n+  bool cleanup = is_contended();\n+\n+\n+  if (!cleanup) {\n+    \/\/ Make a zero contentions field negative to force any contending threads\n+    \/\/ to retry. Because this is only called while holding the lock, the owner\n+    \/\/ is anonymous and contentions is held over enter in inflate_and_enter\n+    \/\/ it means that if the cas succeeds then we can have no other thread\n+    \/\/ racily inserting themselves on the _waiters or _cxq lists, the\n+    \/\/ entry list is protected by the lock (_waiter technically too, only\n+    \/\/ removals are done outside the lock)\n+    \/\/ TODO: Double check _succ and _responsible invariants\n+    if (Atomic::cmpxchg(&_contentions, 0, INT_MIN) != 0) {\n+      \/\/ Contentions was no longer 0 so we lost the race.\n+      cleanup = true;\n+    }\n+  }\n+\n+  if (cleanup) {\n+    \/\/ Could not deflate\n+    set_owner_from_anonymous(current);\n+    return false;\n+  }\n+\n+  \/\/ Sanity checks for the races:\n+  guarantee(is_owner_anonymous(), \"must be\");\n+  guarantee(contentions() < 0, \"must be negative: contentions=%d\",\n+            contentions());\n+  guarantee(_waiters == 0, \"must be 0: waiters=%d\", _waiters);\n+  guarantee(_cxq == nullptr, \"must be no contending threads: cxq=\"\n+            INTPTR_FORMAT, p2i(_cxq));\n+  guarantee(_EntryList == nullptr,\n+            \"must be no entering threads: EntryList=\" INTPTR_FORMAT,\n+            p2i(_EntryList));\n+\n+  oop obj = object();\n+\n+  PlaceholderSynchronizer::deflate_anon_monitor(current, obj, this);\n+\n+  \/\/ We are deflated, restore the correct lock_stack\n+  lock_stack.push(obj);\n+  for (int i = 0; i < _recursions; i++) {\n+    bool entered = lock_stack.try_recursive_enter(obj);\n+    assert(entered, \"must have entered here\");\n+  }\n+\n+  \/\/ We leave owner == ANONYMOUS_OWNER and contentions < 0\n+  \/\/ to force any racing threads to retry.\n+  return true;  \/\/ Success, ObjectMonitor has been deflated.\n+}\n+\n@@ -658,0 +758,1 @@\n+  assert(LockingMode != LM_PLACEHOLDER, \"Placeholder has no dmw\");\n@@ -990,0 +1091,1 @@\n+  assert(current->thread_state() != _thread_blocked, \"invariant\");\n@@ -993,3 +1095,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n-\n-  assert(current->thread_state() != _thread_blocked, \"invariant\");\n+  assert_mark_word_concistency();\n@@ -1052,1 +1152,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n+  assert_mark_word_concistency();\n@@ -1186,1 +1286,1 @@\n-    if (LockingMode != LM_LIGHTWEIGHT && current->is_lock_owned((address)cur)) {\n+    if (LockingMode != LM_LIGHTWEIGHT && LockingMode != LM_PLACEHOLDER && current->is_lock_owned((address)cur)) {\n@@ -1401,1 +1501,1 @@\n-    if (LockingMode != LM_LIGHTWEIGHT && current->is_lock_owned((address)cur)) {\n+    if (LockingMode != LM_LIGHTWEIGHT && LockingMode != LM_PLACEHOLDER && current->is_lock_owned((address)cur)) {\n@@ -1440,1 +1540,1 @@\n-  if (LockingMode != LM_LIGHTWEIGHT && current->is_lock_owned((address)cur)) {\n+  if (LockingMode != LM_LIGHTWEIGHT && LockingMode != LM_PLACEHOLDER && current->is_lock_owned((address)cur)) {\n@@ -1680,0 +1780,9 @@\n+  bool deflated = false;\n+\n+  if (LockingMode == LM_PLACEHOLDER && OMDeflateAfterWait && current->lock_stack().wait_was_inflated()) {\n+    if (deflate_anon_monitor(current)) {\n+      current->_wait_deflation++;\n+      deflated = true;\n+    }\n+  }\n+\n@@ -1681,1 +1790,1 @@\n-  assert(owner_raw() == current, \"invariant\");\n+  assert(deflated || owner_raw() == current, \"invariant\");\n@@ -1683,1 +1792,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n+  assert_mark_word_concistency();\n@@ -2203,1 +2312,1 @@\n-  st->print_cr(\"  _header = \" INTPTR_FORMAT, header().value());\n+  st->print_cr(\"  _header = \" INTPTR_FORMAT, header_value());\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":133,"deletions":24,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -1025,1 +1025,3 @@\n-  LM_LIGHTWEIGHT = 2\n+  LM_LIGHTWEIGHT = 2,\n+  \/\/ New PLACEHOLDER locking based on lightweigh, with monitors as 2nd tier using OMWorld\n+  LM_PLACEHOLDER = 3\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -578,1 +578,1 @@\n-   st->print_cr(\"# Java VM: %s%s%s (%s%s, %s%s%s%s%s%s, %s, %s)\",\n+   st->print_cr(\"# Java VM: %s%s%s (%s%s, %s%s%s%s%s%s%s, %s, %s)\",\n@@ -593,0 +593,4 @@\n+                 LockingMode == LM_MONITOR ? \", lm_monitors\" :\n+                 LockingMode == LM_LEGACY ? \", lm_legacy\" :\n+                 LockingMode == LM_LIGHTWEIGHT ? \", lm_lightweight\" :\n+                 LockingMode == LM_PLACEHOLDER ? \", lm_placeholder\" : \"\",\n@@ -1119,1 +1123,1 @@\n-  STEP_IF(\"printing lock stack\", _verbose && _thread != nullptr && _thread->is_Java_thread() && LockingMode == LM_LIGHTWEIGHT);\n+  STEP_IF(\"printing lock stack\", _verbose && _thread != nullptr && _thread->is_Java_thread() && (LockingMode == LM_LIGHTWEIGHT || LockingMode == LM_PLACEHOLDER));\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -84,1 +84,3 @@\n-    if (VM.getVM().isCompressedKlassPointersEnabled()) {\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n+      lengthOffsetInBytes = Oop.getHeaderSize();\n+    } else if (VM.getVM().isCompressedKlassPointersEnabled()) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Array.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,1 +85,12 @@\n-  if (UseCompressedClassPointers) {\n+  if (UseCompactObjectHeaders) {\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_BOOLEAN), 12);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_BYTE),    12);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_SHORT),   12);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_CHAR),    12);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_INT),     12);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_FLOAT),   12);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_LONG),    16);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_DOUBLE),  16);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_OBJECT),  12);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_ARRAY),   12);\n+  } else if (UseCompressedClassPointers) {\n","filename":"test\/hotspot\/gtest\/oops\/test_arrayOop.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run main\/timeout=240 gc.g1.plab.TestPLABPromotion\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.g1.plab.TestPLABPromotion\n@@ -51,0 +51,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -57,0 +58,2 @@\n+    private static final boolean COMPACT_HEADERS = Platform.is64bit() && WhiteBox.getWhiteBox().getBooleanVMFlag(\"UseCompactObjectHeaders\");\n+\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/plab\/TestPLABPromotion.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n- * @test id=with-coops-no-ccp\n- * @library \/test\/lib\n+ * @test id=with-coops-no-ccp-no-ucoh\n+ * @library \/test\/lib \/\n@@ -29,1 +29,3 @@\n- * @run main\/othervm -XX:+UseCompressedOops -XX:-UseCompressedClassPointers ArrayBaseOffsets\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseCompressedOops -XX:-UseCompressedClassPointers -XX:+UnlockExperimentalVMOptions -XX:-UseCompactObjectHeaders ArrayBaseOffsets\n@@ -32,2 +34,2 @@\n- * @test id=with-coops-with-ccp\n- * @library \/test\/lib\n+ * @test id=with-coops-with-ccp-no-ucoh\n+ * @library \/test\/lib \/\n@@ -37,1 +39,3 @@\n- * @run main\/othervm -XX:+UseCompressedOops -XX:+UseCompressedClassPointers ArrayBaseOffsets\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseCompressedOops -XX:+UseCompressedClassPointers -XX:+UnlockExperimentalVMOptions -XX:-UseCompactObjectHeaders ArrayBaseOffsets\n@@ -40,2 +44,2 @@\n- * @test id=no-coops-no-ccp\n- * @library \/test\/lib\n+ * @test id=no-coops-no-ccp-no-ucoh\n+ * @library \/test\/lib \/\n@@ -44,1 +48,3 @@\n- * @run main\/othervm -XX:-UseCompressedOops -XX:-UseCompressedClassPointers ArrayBaseOffsets\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-UseCompressedOops -XX:-UseCompressedClassPointers -XX:+UnlockExperimentalVMOptions -XX:-UseCompactObjectHeaders ArrayBaseOffsets\n@@ -47,2 +53,2 @@\n- * @test id=no-coops-with-ccp\n- * @library \/test\/lib\n+ * @test id=no-coops-with-ccp-no-ucoh\n+ * @library \/test\/lib \/\n@@ -52,1 +58,41 @@\n- * @run main\/othervm -XX:-UseCompressedOops -XX:+UseCompressedClassPointers ArrayBaseOffsets\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-UseCompressedOops -XX:+UseCompressedClassPointers -XX:+UnlockExperimentalVMOptions -XX:-UseCompactObjectHeaders ArrayBaseOffsets\n+ *\/\n+\/*\n+ * @test id=with-coops-no-ccp-with-ucoh\n+ * @library \/test\/lib \/\n+ * @requires vm.bits == \"64\"\n+ * @modules java.base\/jdk.internal.misc\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseCompressedOops -XX:-UseCompressedClassPointers -XX:+UnlockExperimentalVMOptions -XX:+UseCompactObjectHeaders ArrayBaseOffsets\n+ *\/\n+\/*\n+ * @test id=with-coops-with-ccp-with-ucoh\n+ * @library \/test\/lib \/\n+ * @requires vm.bits == \"64\"\n+ * @requires vm.opt.UseCompressedClassPointers != false\n+ * @modules java.base\/jdk.internal.misc\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseCompressedOops -XX:+UseCompressedClassPointers -XX:+UnlockExperimentalVMOptions -XX:+UseCompactObjectHeaders ArrayBaseOffsets\n+ *\/\n+\/*\n+ * @test id=no-coops-no-ccp-with-ucoh\n+ * @library \/test\/lib \/\n+ * @requires vm.bits == \"64\"\n+ * @modules java.base\/jdk.internal.misc\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-UseCompressedOops -XX:-UseCompressedClassPointers -XX:+UnlockExperimentalVMOptions -XX:+UseCompactObjectHeaders ArrayBaseOffsets\n+ *\/\n+\/*\n+ * @test id=no-coops-with-ccp-with-ucoh\n+ * @library \/test\/lib \/\n+ * @requires vm.bits == \"64\"\n+ * @requires vm.opt.UseCompressedClassPointers != false\n+ * @modules java.base\/jdk.internal.misc\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-UseCompressedOops -XX:+UseCompressedClassPointers -XX:+UnlockExperimentalVMOptions -XX:+UseCompactObjectHeaders ArrayBaseOffsets\n@@ -56,1 +102,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/\n@@ -59,1 +105,3 @@\n- * @run main\/othervm ArrayBaseOffsets\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI ArrayBaseOffsets\n@@ -70,0 +118,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -73,3 +122,3 @@\n-    private static final boolean COOP;\n-    private static final boolean CCP;\n-\n+    static final long INT_OFFSET;\n+    static final int  INT_ARRAY_OFFSET;\n+    static final int  LONG_ARRAY_OFFSET;\n@@ -77,5 +126,9 @@\n-        if (Platform.is64bit()) {\n-            RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean();\n-            List<String> vmargs = runtime.getInputArguments();\n-            CCP = !vmargs.contains(\"-XX:-UseCompressedClassPointers\");\n-            COOP = System.getProperty(\"java.vm.compressedOopsMode\") != null;\n+        WhiteBox WB = WhiteBox.getWhiteBox();\n+        if (!Platform.is64bit() || WB.getBooleanVMFlag(\"UseCompactObjectHeaders\")) {\n+            INT_OFFSET = 8;\n+            INT_ARRAY_OFFSET = 12;\n+            LONG_ARRAY_OFFSET = 16;\n+        } else if (WB.getBooleanVMFlag(\"UseCompressedClassPointers\")) {\n+            INT_OFFSET = 12;\n+            INT_ARRAY_OFFSET = 16;\n+            LONG_ARRAY_OFFSET = 16;\n@@ -83,1 +136,3 @@\n-            COOP = CCP = false;\n+            INT_OFFSET = 16;\n+            INT_ARRAY_OFFSET = 20;\n+            LONG_ARRAY_OFFSET = 24;\n@@ -89,22 +144,11 @@\n-        int intOffset, longOffset;\n-        if (Platform.is64bit()) {\n-            if (CCP) {\n-                intOffset = 16;\n-                longOffset = 16;\n-            } else {\n-                intOffset = 20;\n-                longOffset = 24;\n-            }\n-        } else {\n-            intOffset = 12;\n-            longOffset = 16;\n-        }\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(boolean[].class), intOffset,  \"Misplaced boolean array base\");\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(byte[].class),    intOffset,  \"Misplaced byte    array base\");\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(char[].class),    intOffset,  \"Misplaced char    array base\");\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(short[].class),   intOffset,  \"Misplaced short   array base\");\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(int[].class),     intOffset,  \"Misplaced int     array base\");\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(long[].class),    longOffset, \"Misplaced long    array base\");\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(float[].class),   intOffset,  \"Misplaced float   array base\");\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(double[].class),  longOffset, \"Misplaced double  array base\");\n-        int expectedObjArrayOffset = (COOP || !Platform.is64bit()) ? intOffset : longOffset;\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(boolean[].class), INT_ARRAY_OFFSET,  \"Misplaced boolean array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(byte[].class),    INT_ARRAY_OFFSET,  \"Misplaced byte    array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(char[].class),    INT_ARRAY_OFFSET,  \"Misplaced char    array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(short[].class),   INT_ARRAY_OFFSET,  \"Misplaced short   array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(int[].class),     INT_ARRAY_OFFSET,  \"Misplaced int     array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(long[].class),    LONG_ARRAY_OFFSET, \"Misplaced long    array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(float[].class),   INT_ARRAY_OFFSET,  \"Misplaced float   array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(double[].class),  LONG_ARRAY_OFFSET, \"Misplaced double  array base\");\n+        boolean narrowOops = System.getProperty(\"java.vm.compressedOopsMode\") != null ||\n+                             !Platform.is64bit();\n+        int expectedObjArrayOffset = narrowOops ? INT_ARRAY_OFFSET : LONG_ARRAY_OFFSET;\n","filename":"test\/hotspot\/jtreg\/runtime\/FieldLayout\/ArrayBaseOffsets.java","additions":89,"deletions":45,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -304,0 +304,1 @@\n+    private static final boolean COMPACT_HEADERS = Platform.is64bit() && WhiteBox.getWhiteBox().getBooleanVMFlag(\"UseCompactObjectHeaders\");\n@@ -377,0 +378,10 @@\n+    private static long expectedSmallObjSize() {\n+        long size;\n+        if (!Platform.is64bit() || COMPACT_HEADERS) {\n+            size = 8;\n+        } else {\n+            size = 16;\n+        }\n+        return roundUp(size, OBJ_ALIGN);\n+    }\n+\n@@ -378,1 +389,1 @@\n-        long expected = roundUp(Platform.is64bit() ? 16 : 8, OBJ_ALIGN);\n+        long expected = expectedSmallObjSize();\n@@ -385,1 +396,1 @@\n-        long expected = roundUp(Platform.is64bit() ? 16 : 8, OBJ_ALIGN);\n+        long expected = expectedSmallObjSize();\n@@ -395,1 +406,1 @@\n-        long expected = roundUp(Platform.is64bit() ? 16 : 8, OBJ_ALIGN);\n+        long expected = expectedSmallObjSize();\n","filename":"test\/jdk\/java\/lang\/instrument\/GetObjectSizeIntrinsicsTest.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -673,1 +673,5 @@\n-                \"CreateCoredumpOnCrash\"\n+                \"CreateCoredumpOnCrash\",\n+                \/\/ experimental features unlocking flag does not affect behavior\n+                \"UnlockExperimentalVMOptions\",\n+                \/\/ all compact headers settings should run flagless tests\n+                \"UseCompactObjectHeaders\"\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}