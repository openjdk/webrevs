{"files":[{"patch":"@@ -239,2 +239,4 @@\n-  \/\/ Clear cache in case fast locking succeeds.\n-  str(zr, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    str(zr, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+  }\n@@ -295,5 +297,1 @@\n-    if (!OMUseC2Cache) {\n-      \/\/ Set Flags == NE\n-      cmp(zr, obj);\n-      b(slow_path);\n-    } else {\n+    const Register t1_monitor = t1;\n@@ -301,0 +299,3 @@\n+    if (!UseObjectMonitorTable) {\n+      assert(t1_monitor == t1_mark, \"should be the same here\");\n+    } else {\n@@ -344,1 +345,1 @@\n-      ldr(t1, Address(t3_t, OMCache::oop_to_monitor_difference()));\n+      ldr(t1_monitor, Address(t3_t, OMCache::oop_to_monitor_difference()));\n@@ -346,0 +347,1 @@\n+    }\n@@ -347,4 +349,5 @@\n-      \/\/ ObjectMonitor* is in t1\n-      const Register t1_monitor = t1;\n-      const Register t2_owner_addr = t2;\n-      const Register t3_owner = t3;\n+    const Register t2_owner_addr = t2;\n+    const Register t3_owner = t3;\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address owner_address{t1_monitor, ObjectMonitor::owner_offset() - monitor_tag};\n+    const Address recursions_address{t1_monitor, ObjectMonitor::recursions_offset() - monitor_tag};\n@@ -352,1 +355,1 @@\n-      Label monitor_locked;\n+    Label monitor_locked;\n@@ -354,2 +357,2 @@\n-      \/\/ Compute owner address.\n-      lea(t2_owner_addr, Address(t1_monitor, ObjectMonitor::owner_offset()));\n+    \/\/ Compute owner address.\n+    lea(t2_owner_addr, owner_address);\n@@ -357,4 +360,4 @@\n-      \/\/ CAS owner (null => current thread).\n-      cmpxchg(t2_owner_addr, zr, rthread, Assembler::xword, \/*acquire*\/ true,\n-              \/*release*\/ false, \/*weak*\/ false, t3_owner);\n-      br(Assembler::EQ, monitor_locked);\n+    \/\/ CAS owner (null => current thread).\n+    cmpxchg(t2_owner_addr, zr, rthread, Assembler::xword, \/*acquire*\/ true,\n+            \/*release*\/ false, \/*weak*\/ false, t3_owner);\n+    br(Assembler::EQ, monitor_locked);\n@@ -362,3 +365,3 @@\n-      \/\/ Check if recursive.\n-      cmp(t3_owner, rthread);\n-      br(Assembler::NE, slow_path);\n+    \/\/ Check if recursive.\n+    cmp(t3_owner, rthread);\n+    br(Assembler::NE, slow_path);\n@@ -366,2 +369,2 @@\n-      \/\/ Recursive.\n-      increment(Address(t1_monitor, ObjectMonitor::recursions_offset()), 1);\n+    \/\/ Recursive.\n+    increment(recursions_address, 1);\n@@ -369,1 +372,2 @@\n-      bind(monitor_locked);\n+    bind(monitor_locked);\n+    if (UseObjectMonitorTable) {\n@@ -372,1 +376,0 @@\n-\n@@ -482,4 +485,1 @@\n-    if (!OMUseC2Cache) {\n-      b(slow_path);\n-    } else {\n-      const Register t1_monitor = t1;\n+    const Register t1_monitor = t1;\n@@ -487,0 +487,6 @@\n+    if (!UseObjectMonitorTable) {\n+      assert(t1_monitor == t1_mark, \"should be the same here\");\n+\n+      \/\/ Untag the monitor.\n+      add(t1_monitor, t1_mark, -(int)markWord::monitor_value);\n+    } else {\n@@ -493,40 +499,0 @@\n-\n-      const Register t2_recursions = t2;\n-      Label not_recursive;\n-\n-      \/\/ Check if recursive.\n-      ldr(t2_recursions, Address(t1_monitor, ObjectMonitor::recursions_offset()));\n-      cbz(t2_recursions, not_recursive);\n-\n-      \/\/ Recursive unlock.\n-      sub(t2_recursions, t2_recursions, 1u);\n-      str(t2_recursions, Address(t1_monitor, ObjectMonitor::recursions_offset()));\n-      \/\/ Set flag == EQ\n-      cmp(t2_recursions, t2_recursions);\n-      b(unlocked);\n-\n-      bind(not_recursive);\n-\n-      Label release;\n-      const Register t2_owner_addr = t2;\n-\n-      \/\/ Compute owner address.\n-      lea(t2_owner_addr, Address(t1_monitor, ObjectMonitor::owner_offset()));\n-\n-      \/\/ Check if the entry lists are empty.\n-      ldr(rscratch1, Address(t1_monitor, ObjectMonitor::EntryList_offset()));\n-      ldr(t3_t, Address(t1_monitor, ObjectMonitor::cxq_offset()));\n-      orr(rscratch1, rscratch1, t3_t);\n-      cmp(rscratch1, zr);\n-      br(Assembler::EQ, release);\n-\n-      \/\/ The owner may be anonymous and we removed the last obj entry in\n-      \/\/ the lock-stack. This loses the information about the owner.\n-      \/\/ Write the thread to the owner field so the runtime knows the owner.\n-      str(rthread, Address(t2_owner_addr));\n-      b(slow_path);\n-\n-      bind(release);\n-      \/\/ Set owner to null.\n-      \/\/ Release to satisfy the JMM\n-      stlr(zr, t2_owner_addr);\n@@ -534,0 +500,40 @@\n+\n+    const Register t2_recursions = t2;\n+    Label not_recursive;\n+\n+    \/\/ Check if recursive.\n+    ldr(t2_recursions, Address(t1_monitor, ObjectMonitor::recursions_offset()));\n+    cbz(t2_recursions, not_recursive);\n+\n+    \/\/ Recursive unlock.\n+    sub(t2_recursions, t2_recursions, 1u);\n+    str(t2_recursions, Address(t1_monitor, ObjectMonitor::recursions_offset()));\n+    \/\/ Set flag == EQ\n+    cmp(t2_recursions, t2_recursions);\n+    b(unlocked);\n+\n+    bind(not_recursive);\n+\n+    Label release;\n+    const Register t2_owner_addr = t2;\n+\n+    \/\/ Compute owner address.\n+    lea(t2_owner_addr, Address(t1_monitor, ObjectMonitor::owner_offset()));\n+\n+    \/\/ Check if the entry lists are empty.\n+    ldr(rscratch1, Address(t1_monitor, ObjectMonitor::EntryList_offset()));\n+    ldr(t3_t, Address(t1_monitor, ObjectMonitor::cxq_offset()));\n+    orr(rscratch1, rscratch1, t3_t);\n+    cmp(rscratch1, zr);\n+    br(Assembler::EQ, release);\n+\n+    \/\/ The owner may be anonymous and we removed the last obj entry in\n+    \/\/ the lock-stack. This loses the information about the owner.\n+    \/\/ Write the thread to the owner field so the runtime knows the owner.\n+    str(rthread, Address(t2_owner_addr));\n+    b(slow_path);\n+\n+    bind(release);\n+    \/\/ Set owner to null.\n+    \/\/ Release to satisfy the JMM\n+    stlr(zr, t2_owner_addr);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":76,"deletions":70,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -6783,2 +6783,4 @@\n-  \/\/ Clear cache in case fast locking succeeds.\n-  str(zr, Address(basic_lock, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::object_monitor_cache_offset_in_bytes()))));\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    str(zr, Address(basic_lock, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::object_monitor_cache_offset_in_bytes()))));\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2518,26 +2518,33 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tagged_monitor = mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-    const Register owner_addr = tmp2;\n-\n-    \/\/ Compute owner address.\n-    addi(owner_addr, tagged_monitor, in_bytes(ObjectMonitor::owner_offset()) - monitor_tag);\n-\n-    \/\/ CAS owner (null => current thread).\n-    cmpxchgd(\/*flag=*\/flag,\n-            \/*current_value=*\/t,\n-            \/*compare_value=*\/(intptr_t)0,\n-            \/*exchange_value=*\/R16_thread,\n-            \/*where=*\/owner_addr,\n-            MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-            MacroAssembler::cmpxchgx_hint_acquire_lock());\n-    beq(flag, locked);\n-\n-    \/\/ Check if recursive.\n-    cmpd(flag, t, R16_thread);\n-    bne(flag, slow_path);\n-\n-    \/\/ Recursive.\n-    ld(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n-    addi(tmp1, tmp1, 1);\n-    std(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register tagged_monitor = mark;\n+      const uintptr_t monitor_tag = markWord::monitor_value;\n+      const Register owner_addr = tmp2;\n+\n+      \/\/ Compute owner address.\n+      addi(owner_addr, tagged_monitor, in_bytes(ObjectMonitor::owner_offset()) - monitor_tag);\n+\n+      \/\/ CAS owner (null => current thread).\n+      cmpxchgd(\/*flag=*\/flag,\n+              \/*current_value=*\/t,\n+              \/*compare_value=*\/(intptr_t)0,\n+              \/*exchange_value=*\/R16_thread,\n+              \/*where=*\/owner_addr,\n+              MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n+              MacroAssembler::cmpxchgx_hint_acquire_lock());\n+      beq(flag, locked);\n+\n+      \/\/ Check if recursive.\n+      cmpd(flag, t, R16_thread);\n+      bne(flag, slow_path);\n+\n+      \/\/ Recursive.\n+      ld(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n+      addi(tmp1, tmp1, 1);\n+      std(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      \/\/ Set flag to NE\n+      crxor(flag, Assembler::equal, flag, Assembler::equal);\n+      b(slow_path);\n+    }\n@@ -2657,43 +2664,50 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register monitor = mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-\n-    \/\/ Untag the monitor.\n-    subi(monitor, mark, monitor_tag);\n-\n-    const Register recursions = tmp2;\n-    Label not_recursive;\n-\n-    \/\/ Check if recursive.\n-    ld(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n-    addic_(recursions, recursions, -1);\n-    blt(CCR0, not_recursive);\n-\n-    \/\/ Recursive unlock.\n-    std(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n-    crorc(CCR0, Assembler::equal, CCR0, Assembler::equal);\n-    b(unlocked);\n-\n-    bind(not_recursive);\n-\n-    Label release_;\n-    const Register t2 = tmp2;\n-\n-    \/\/ Check if the entry lists are empty.\n-    ld(t, in_bytes(ObjectMonitor::EntryList_offset()), monitor);\n-    ld(t2, in_bytes(ObjectMonitor::cxq_offset()), monitor);\n-    orr(t, t, t2);\n-    cmpdi(flag, t, 0);\n-    beq(flag, release_);\n-\n-    \/\/ The owner may be anonymous and we removed the last obj entry in\n-    \/\/ the lock-stack. This loses the information about the owner.\n-    \/\/ Write the thread to the owner field so the runtime knows the owner.\n-    std(R16_thread, in_bytes(ObjectMonitor::owner_offset()), monitor);\n-    b(slow_path);\n-\n-    bind(release_);\n-    \/\/ Set owner to null.\n-    release();\n-    \/\/ t contains 0\n-    std(t, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register monitor = mark;\n+      const uintptr_t monitor_tag = markWord::monitor_value;\n+\n+      \/\/ Untag the monitor.\n+      subi(monitor, mark, monitor_tag);\n+\n+      const Register recursions = tmp2;\n+      Label not_recursive;\n+\n+      \/\/ Check if recursive.\n+      ld(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n+      addic_(recursions, recursions, -1);\n+      blt(CCR0, not_recursive);\n+\n+      \/\/ Recursive unlock.\n+      std(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n+      crorc(CCR0, Assembler::equal, CCR0, Assembler::equal);\n+      b(unlocked);\n+\n+      bind(not_recursive);\n+\n+      Label release_;\n+      const Register t2 = tmp2;\n+\n+      \/\/ Check if the entry lists are empty.\n+      ld(t, in_bytes(ObjectMonitor::EntryList_offset()), monitor);\n+      ld(t2, in_bytes(ObjectMonitor::cxq_offset()), monitor);\n+      orr(t, t, t2);\n+      cmpdi(flag, t, 0);\n+      beq(flag, release_);\n+\n+      \/\/ The owner may be anonymous and we removed the last obj entry in\n+      \/\/ the lock-stack. This loses the information about the owner.\n+      \/\/ Write the thread to the owner field so the runtime knows the owner.\n+      std(R16_thread, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+      b(slow_path);\n+\n+      bind(release_);\n+      \/\/ Set owner to null.\n+      release();\n+      \/\/ t contains 0\n+      std(t, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      \/\/ Set flag to NE\n+      crxor(flag, Assembler::equal, flag, Assembler::equal);\n+      b(slow_path);\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":84,"deletions":70,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -326,19 +326,24 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tmp1_tagged_monitor = tmp1_mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-    const Register tmp2_owner_addr = tmp2;\n-    const Register tmp3_owner = tmp3;\n-\n-    \/\/ Compute owner address.\n-    la(tmp2_owner_addr, Address(tmp1_tagged_monitor, (in_bytes(ObjectMonitor::owner_offset()) - monitor_tag)));\n-\n-    \/\/ CAS owner (null => current thread).\n-    cmpxchg(\/*addr*\/ tmp2_owner_addr, \/*expected*\/ zr, \/*new*\/ xthread, Assembler::int64,\n-            \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::relaxed, \/*result*\/ tmp3_owner);\n-    beqz(tmp3_owner, locked);\n-\n-    \/\/ Check if recursive.\n-    bne(tmp3_owner, xthread, slow_path);\n-\n-    \/\/ Recursive.\n-    increment(Address(tmp1_tagged_monitor, in_bytes(ObjectMonitor::recursions_offset()) - monitor_tag), 1, tmp2, tmp3);\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register tmp1_tagged_monitor = tmp1_mark;\n+      const uintptr_t monitor_tag = markWord::monitor_value;\n+      const Register tmp2_owner_addr = tmp2;\n+      const Register tmp3_owner = tmp3;\n+\n+      \/\/ Compute owner address.\n+      la(tmp2_owner_addr, Address(tmp1_tagged_monitor, (in_bytes(ObjectMonitor::owner_offset()) - monitor_tag)));\n+\n+      \/\/ CAS owner (null => current thread).\n+      cmpxchg(\/*addr*\/ tmp2_owner_addr, \/*expected*\/ zr, \/*new*\/ xthread, Assembler::int64,\n+              \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::relaxed, \/*result*\/ tmp3_owner);\n+      beqz(tmp3_owner, locked);\n+\n+      \/\/ Check if recursive.\n+      bne(tmp3_owner, xthread, slow_path);\n+\n+      \/\/ Recursive.\n+      increment(Address(tmp1_tagged_monitor, in_bytes(ObjectMonitor::recursions_offset()) - monitor_tag), 1, tmp2, tmp3);\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      j(slow_path);\n+    }\n@@ -456,43 +461,48 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tmp1_monitor = tmp1_mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-\n-    \/\/ Untag the monitor.\n-    sub(tmp1_monitor, tmp1_mark, monitor_tag);\n-\n-    const Register tmp2_recursions = tmp2;\n-    Label not_recursive;\n-\n-    \/\/ Check if recursive.\n-    ld(tmp2_recursions, Address(tmp1_monitor, ObjectMonitor::recursions_offset()));\n-    beqz(tmp2_recursions, not_recursive);\n-\n-    \/\/ Recursive unlock.\n-    addi(tmp2_recursions, tmp2_recursions, -1);\n-    sd(tmp2_recursions, Address(tmp1_monitor, ObjectMonitor::recursions_offset()));\n-    j(unlocked);\n-\n-    bind(not_recursive);\n-\n-    Label release;\n-    const Register tmp2_owner_addr = tmp2;\n-\n-    \/\/ Compute owner address.\n-    la(tmp2_owner_addr, Address(tmp1_monitor, ObjectMonitor::owner_offset()));\n-\n-    \/\/ Check if the entry lists are empty.\n-    ld(t0, Address(tmp1_monitor, ObjectMonitor::EntryList_offset()));\n-    ld(tmp3_t, Address(tmp1_monitor, ObjectMonitor::cxq_offset()));\n-    orr(t0, t0, tmp3_t);\n-    beqz(t0, release);\n-\n-    \/\/ The owner may be anonymous and we removed the last obj entry in\n-    \/\/ the lock-stack. This loses the information about the owner.\n-    \/\/ Write the thread to the owner field so the runtime knows the owner.\n-    sd(xthread, Address(tmp2_owner_addr));\n-    j(slow_path);\n-\n-    bind(release);\n-    \/\/ Set owner to null.\n-    membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n-    sd(zr, Address(tmp2_owner_addr));\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register tmp1_monitor = tmp1_mark;\n+      const uintptr_t monitor_tag = markWord::monitor_value;\n+\n+      \/\/ Untag the monitor.\n+      sub(tmp1_monitor, tmp1_mark, monitor_tag);\n+\n+      const Register tmp2_recursions = tmp2;\n+      Label not_recursive;\n+\n+      \/\/ Check if recursive.\n+      ld(tmp2_recursions, Address(tmp1_monitor, ObjectMonitor::recursions_offset()));\n+      beqz(tmp2_recursions, not_recursive);\n+\n+      \/\/ Recursive unlock.\n+      addi(tmp2_recursions, tmp2_recursions, -1);\n+      sd(tmp2_recursions, Address(tmp1_monitor, ObjectMonitor::recursions_offset()));\n+      j(unlocked);\n+\n+      bind(not_recursive);\n+\n+      Label release;\n+      const Register tmp2_owner_addr = tmp2;\n+\n+      \/\/ Compute owner address.\n+      la(tmp2_owner_addr, Address(tmp1_monitor, ObjectMonitor::owner_offset()));\n+\n+      \/\/ Check if the entry lists are empty.\n+      ld(t0, Address(tmp1_monitor, ObjectMonitor::EntryList_offset()));\n+      ld(tmp3_t, Address(tmp1_monitor, ObjectMonitor::cxq_offset()));\n+      orr(t0, t0, tmp3_t);\n+      beqz(t0, release);\n+\n+      \/\/ The owner may be anonymous and we removed the last obj entry in\n+      \/\/ the lock-stack. This loses the information about the owner.\n+      \/\/ Write the thread to the owner field so the runtime knows the owner.\n+      sd(xthread, Address(tmp2_owner_addr));\n+      j(slow_path);\n+\n+      bind(release);\n+      \/\/ Set owner to null.\n+      membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n+      sd(zr, Address(tmp2_owner_addr));\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      j(slow_path);\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":72,"deletions":62,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -3263,26 +3263,33 @@\n-  Register zero = temp;\n-  Register monitor_tagged = displacedHeader; \/\/ Tagged with markWord::monitor_value.\n-  \/\/ The object's monitor m is unlocked iff m->owner is null,\n-  \/\/ otherwise m->owner may contain a thread or a stack address.\n-\n-  \/\/ Try to CAS m->owner from null to current thread.\n-  \/\/ If m->owner is null, then csg succeeds and sets m->owner=THREAD and CR=EQ.\n-  \/\/ Otherwise, register zero is filled with the current owner.\n-  z_lghi(zero, 0);\n-  z_csg(zero, Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor_tagged);\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ Store a non-null value into the box.\n-    z_stg(box, BasicLock::displaced_header_offset_in_bytes(), box);\n-  }\n-\n-  z_bre(done); \/\/ acquired the lock for the first time.\n-\n-  BLOCK_COMMENT(\"fast_path_recursive_lock {\");\n-  \/\/ Check if we are already the owner (recursive lock)\n-  z_cgr(Z_thread, zero); \/\/ owner is stored in zero by \"z_csg\" above\n-  z_brne(done); \/\/ not a recursive lock\n-\n-  \/\/ Current thread already owns the lock. Just increment recursion count.\n-  z_agsi(Address(monitor_tagged, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n-  z_cgr(zero, zero); \/\/ set the CC to EQUAL\n-  BLOCK_COMMENT(\"} fast_path_recursive_lock\");\n+  if (!UseObjectMonitorTable) {\n+    Register zero = temp;\n+    Register monitor_tagged = displacedHeader; \/\/ Tagged with markWord::monitor_value.\n+    \/\/ The object's monitor m is unlocked iff m->owner is null,\n+    \/\/ otherwise m->owner may contain a thread or a stack address.\n+\n+    \/\/ Try to CAS m->owner from null to current thread.\n+    \/\/ If m->owner is null, then csg succeeds and sets m->owner=THREAD and CR=EQ.\n+    \/\/ Otherwise, register zero is filled with the current owner.\n+    z_lghi(zero, 0);\n+    z_csg(zero, Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor_tagged);\n+    if (LockingMode != LM_LIGHTWEIGHT) {\n+      \/\/ Store a non-null value into the box.\n+      z_stg(box, BasicLock::displaced_header_offset_in_bytes(), box);\n+    }\n+\n+    z_bre(done); \/\/ acquired the lock for the first time.\n+\n+    BLOCK_COMMENT(\"fast_path_recursive_lock {\");\n+    \/\/ Check if we are already the owner (recursive lock)\n+    z_cgr(Z_thread, zero); \/\/ owner is stored in zero by \"z_csg\" above\n+    z_brne(done); \/\/ not a recursive lock\n+\n+    \/\/ Current thread already owns the lock. Just increment recursion count.\n+    z_agsi(Address(monitor_tagged, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n+    z_cgr(zero, zero); \/\/ set the CC to EQUAL\n+    BLOCK_COMMENT(\"} fast_path_recursive_lock\");\n+  } else {\n+    \/\/ OMCache lookup not supported yet. Take the slowpath.\n+    \/\/ Set flag to NE\n+    z_ltgr(oop, oop);\n+    z_bru(done);\n+  }\n@@ -3349,2 +3356,3 @@\n-  z_cg(Z_thread, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n-  z_brne(done);\n+  if (!UseObjectMonitorTable) {\n+    z_cg(Z_thread, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n+    z_brne(done);\n@@ -3352,3 +3360,3 @@\n-  BLOCK_COMMENT(\"fast_path_recursive_unlock {\");\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-  z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n+    BLOCK_COMMENT(\"fast_path_recursive_unlock {\");\n+    load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+    z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n@@ -3356,5 +3364,5 @@\n-  \/\/ Recursive inflated unlock\n-  z_agsi(Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n-  z_cgr(currentHeader, currentHeader); \/\/ set the CC to EQUAL\n-  BLOCK_COMMENT(\"} fast_path_recursive_unlock\");\n-  z_bru(done);\n+    \/\/ Recursive inflated unlock\n+    z_agsi(Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n+    z_cgr(currentHeader, currentHeader); \/\/ set the CC to EQUAL\n+    BLOCK_COMMENT(\"} fast_path_recursive_unlock\");\n+    z_bru(done);\n@@ -3362,1 +3370,1 @@\n-  bind(not_recursive);\n+    bind(not_recursive);\n@@ -3364,6 +3372,12 @@\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n-  z_brne(done);\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n-  z_brne(done);\n-  z_release();\n-  z_stg(temp\/*=0*\/, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), currentHeader);\n+    load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n+    z_brne(done);\n+    load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n+    z_brne(done);\n+    z_release();\n+    z_stg(temp\/*=0*\/, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), currentHeader);\n+  } else {\n+    \/\/ OMCache lookup not supported yet. Take the slowpath.\n+    \/\/ Set flag to NE\n+    z_ltgr(oop, oop);\n+    z_bru(done);\n+  }\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":57,"deletions":43,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -116,0 +116,4 @@\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address succ_address{monitor, ObjectMonitor::succ_offset() - monitor_tag};\n+    const Address owner_address{monitor, ObjectMonitor::owner_offset() - monitor_tag};\n+\n@@ -117,1 +121,1 @@\n-    __ cmpptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), NULL_WORD);\n+    __ cmpptr(succ_address, NULL_WORD);\n@@ -121,1 +125,1 @@\n-    __ movptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n+    __ movptr(owner_address, NULL_WORD);\n@@ -128,1 +132,1 @@\n-    __ cmpptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), NULL_WORD);\n+    __ cmpptr(succ_address, NULL_WORD);\n@@ -137,1 +141,1 @@\n-    __ lock(); __ cmpxchgptr(_thread, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n+    __ lock(); __ cmpxchgptr(_thread, owner_address);\n","filename":"src\/hotspot\/cpu\/x86\/c2_CodeStubs_x86.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -952,2 +952,4 @@\n-  \/\/ Clear cache in case fast locking succeeds.\n-  movptr(Address(box, BasicLock::object_monitor_cache_offset_in_bytes()), 0);\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    movptr(Address(box, BasicLock::object_monitor_cache_offset_in_bytes()), 0);\n+  }\n@@ -968,1 +970,1 @@\n-    const Register top = rax_reg;\n+    const Register top = UseObjectMonitorTable ? rax_reg : box;\n@@ -995,0 +997,4 @@\n+    if (UseObjectMonitorTable) {\n+      \/\/ Need to reload top, clobbered by CAS.\n+      movl(top, Address(thread, JavaThread::lock_stack_top_offset()));\n+    }\n@@ -997,1 +1003,0 @@\n-    movl(top, Address(thread, JavaThread::lock_stack_top_offset()));\n@@ -1008,2 +1013,2 @@\n-    if (!OMUseC2Cache) {\n-      jmp(slow_path);\n+    if (!UseObjectMonitorTable) {\n+      assert(mark == monitor, \"should be the same here\");\n@@ -1011,0 +1016,1 @@\n+      \/\/ Uses ObjectMonitorTable.  Look for the monitor in the om_cache.\n@@ -1056,0 +1062,4 @@\n+    }\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address recursions_address{monitor, ObjectMonitor::recursions_offset() - monitor_tag};\n+    const Address owner_address{monitor, ObjectMonitor::owner_offset() - monitor_tag};\n@@ -1057,2 +1067,2 @@\n-      Label monitor_locked;\n-      \/\/ Lock the monitor.\n+    Label monitor_locked;\n+    \/\/ Lock the monitor.\n@@ -1060,4 +1070,4 @@\n-      \/\/ CAS owner (null => current thread).\n-      xorptr(rax, rax);\n-      lock(); cmpxchgptr(thread, Address(monitor, ObjectMonitor::owner_offset()));\n-      jccb(Assembler::equal, monitor_locked);\n+    \/\/ CAS owner (null => current thread).\n+    xorptr(rax_reg, rax_reg);\n+    lock(); cmpxchgptr(thread, owner_address);\n+    jccb(Assembler::equal, monitor_locked);\n@@ -1065,3 +1075,3 @@\n-      \/\/ Check if recursive.\n-      cmpptr(thread, rax);\n-      jccb(Assembler::notEqual, slow_path);\n+    \/\/ Check if recursive.\n+    cmpptr(thread, rax_reg);\n+    jccb(Assembler::notEqual, slow_path);\n@@ -1069,2 +1079,2 @@\n-      \/\/ Recursive.\n-      increment(Address(monitor, ObjectMonitor::recursions_offset()));\n+    \/\/ Recursive.\n+    increment(recursions_address);\n@@ -1072,1 +1082,2 @@\n-      bind(monitor_locked);\n+    bind(monitor_locked);\n+    if (UseObjectMonitorTable) {\n@@ -1118,1 +1129,1 @@\n-  const Register top = t;\n+  const Register top = UseObjectMonitorTable ? t : reg_rax;\n@@ -1138,0 +1149,5 @@\n+    if (!UseObjectMonitorTable) {\n+      \/\/ Prefetch mark.\n+      movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    }\n+\n@@ -1153,2 +1169,4 @@\n-    \/\/ Load mark.\n-    movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    if (UseObjectMonitorTable) {\n+      \/\/ Load mark.\n+      movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    }\n@@ -1177,2 +1195,3 @@\n-    const Register mark = t;\n-    movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    if (UseObjectMonitorTable) {\n+      movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    }\n@@ -1186,2 +1205,2 @@\n-    if (!OMUseC2Cache) {\n-      jmp(slow_path);\n+    if (!UseObjectMonitorTable) {\n+      assert(mark == monitor, \"should be the same here\");\n@@ -1189,0 +1208,1 @@\n+      \/\/ Uses ObjectMonitorTable.  Look for the monitor in our BasicLock on the stack.\n@@ -1196,0 +1216,6 @@\n+    }\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address recursions_address{monitor, ObjectMonitor::recursions_offset() - monitor_tag};\n+    const Address cxq_address{monitor, ObjectMonitor::cxq_offset() - monitor_tag};\n+    const Address EntryList_address{monitor, ObjectMonitor::EntryList_offset() - monitor_tag};\n+    const Address owner_address{monitor, ObjectMonitor::owner_offset() - monitor_tag};\n@@ -1197,14 +1223,1 @@\n-      Label recursive;\n-\n-      \/\/ Check if recursive.\n-      cmpptr(Address(monitor,ObjectMonitor::recursions_offset()), 0);\n-      jccb(Assembler::notEqual, recursive);\n-\n-      \/\/ Check if the entry lists are empty.\n-      movptr(reg_rax, Address(monitor, ObjectMonitor::cxq_offset()));\n-      orptr(reg_rax, Address(monitor, ObjectMonitor::EntryList_offset()));\n-      jcc(Assembler::notZero, check_successor);\n-\n-      \/\/ Release lock.\n-      movptr(Address(monitor, ObjectMonitor::owner_offset()), NULL_WORD);\n-      jmpb(unlocked);\n+    Label recursive;\n@@ -1212,5 +1225,17 @@\n-      \/\/ Recursive unlock.\n-      bind(recursive);\n-      decrement(Address(monitor, ObjectMonitor::recursions_offset()));\n-      xorl(t, t);\n-    }\n+    \/\/ Check if recursive.\n+    cmpptr(recursions_address, 0);\n+    jccb(Assembler::notEqual, recursive);\n+\n+    \/\/ Check if the entry lists are empty.\n+    movptr(reg_rax, cxq_address);\n+    orptr(reg_rax, EntryList_address);\n+    jcc(Assembler::notZero, check_successor);\n+\n+    \/\/ Release lock.\n+    movptr(owner_address, NULL_WORD);\n+    jmpb(unlocked);\n+\n+    \/\/ Recursive unlock.\n+    bind(recursive);\n+    decrement(recursions_address);\n+    xorl(t, t);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":69,"deletions":44,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -10351,2 +10351,4 @@\n-  \/\/ Clear cache in case fast locking succeeds.\n-  movptr(Address(basic_lock, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::object_monitor_cache_offset_in_bytes()))), 0);\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    movptr(Address(basic_lock, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::object_monitor_cache_offset_in_bytes()))), 0);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-    if (print_monitor_info && LockingMode != LM_LIGHTWEIGHT) {\n+    if (print_monitor_info && !UseObjectMonitorTable) {\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -237,1 +237,1 @@\n-    assert(LockingMode != LM_LIGHTWEIGHT, \"Lightweight locking does not use markWord for monitors\");\n+    assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use markWord for monitors\");\n@@ -243,2 +243,5 @@\n-    return LockingMode == LM_LIGHTWEIGHT ? false                             \/\/ no displaced mark\n-                                         : (lockbits & unlocked_value) == 0; \/\/ monitor | stack-locked?\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      return !UseObjectMonitorTable && lockbits == monitor_value;\n+    }\n+    \/\/ monitor (0b10) | stack-locked (0b00)?\n+    return (lockbits & unlocked_value) == 0;\n@@ -270,1 +273,1 @@\n-    assert(LockingMode != LM_LIGHTWEIGHT, \"Lightweight locking does not use markWord for monitors\");\n+    assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use markWord for monitors\");\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -4581,13 +4581,14 @@\n-  \/\/ Test the header to see if it is safe to read w.r.t. locking.\n-  Node *lock_mask      = _gvn.MakeConX(markWord::lock_mask_in_place);\n-  Node *lmasked_header = _gvn.transform(new AndXNode(header, lock_mask));\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    Node *monitor_val   = _gvn.MakeConX(markWord::monitor_value);\n-    Node *chk_monitor   = _gvn.transform(new CmpXNode(lmasked_header, monitor_val));\n-    Node *test_monitor  = _gvn.transform(new BoolNode(chk_monitor, BoolTest::eq));\n-\n-    generate_slow_guard(test_monitor, slow_region);\n-  } else {\n-    Node *unlocked_val      = _gvn.MakeConX(markWord::unlocked_value);\n-    Node *chk_unlocked      = _gvn.transform(new CmpXNode(lmasked_header, unlocked_val));\n-    Node *test_not_unlocked = _gvn.transform(new BoolNode(chk_unlocked, BoolTest::ne));\n+  if (!UseObjectMonitorTable) {\n+    \/\/ Test the header to see if it is safe to read w.r.t. locking.\n+    Node *lock_mask      = _gvn.MakeConX(markWord::lock_mask_in_place);\n+    Node *lmasked_header = _gvn.transform(new AndXNode(header, lock_mask));\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      Node *monitor_val   = _gvn.MakeConX(markWord::monitor_value);\n+      Node *chk_monitor   = _gvn.transform(new CmpXNode(lmasked_header, monitor_val));\n+      Node *test_monitor  = _gvn.transform(new BoolNode(chk_monitor, BoolTest::eq));\n+\n+      generate_slow_guard(test_monitor, slow_region);\n+    } else {\n+      Node *unlocked_val      = _gvn.MakeConX(markWord::unlocked_value);\n+      Node *chk_unlocked      = _gvn.transform(new CmpXNode(lmasked_header, unlocked_val));\n+      Node *test_not_unlocked = _gvn.transform(new BoolNode(chk_unlocked, BoolTest::ne));\n@@ -4595,1 +4596,2 @@\n-    generate_slow_guard(test_not_unlocked, slow_region);\n+      generate_slow_guard(test_not_unlocked, slow_region);\n+    }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"runtime\/synchronizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1829,1 +1829,1 @@\n-#if !defined(X86) && !defined(AARCH64)\n+#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM) && !defined(PPC64) && !defined(S390)\n@@ -2952,0 +2952,5 @@\n+  if (UseObjectMonitorTable && LockingMode != LM_LIGHTWEIGHT) {\n+    \/\/ ObjectMonitorTable requires lightweight locking.\n+    FLAG_SET_DEFAULT(LockingMode, LM_LIGHTWEIGHT);\n+  }\n+\n@@ -2960,0 +2965,13 @@\n+  if (UseCompactObjectHeaders && !UseObjectMonitorTable) {\n+    \/\/ If UseCompactObjectHeaders is on the command line, turn on UseObjectMonitorTable.\n+    if (FLAG_IS_CMDLINE(UseCompactObjectHeaders)) {\n+      FLAG_SET_DEFAULT(UseObjectMonitorTable, true);\n+\n+    \/\/ If UseObjectMonitorTable is on the command line, turn off UseCompactObjectHeaders.\n+    } else if (FLAG_IS_CMDLINE(UseObjectMonitorTable)) {\n+      FLAG_SET_DEFAULT(UseCompactObjectHeaders, false);\n+    \/\/ If neither on the command line, the defaults are incompatible, but turn on UseObjectMonitorTable.\n+    } else {\n+      FLAG_SET_DEFAULT(UseObjectMonitorTable, true);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -1676,1 +1676,1 @@\n-          assert(LightweightSynchronizer::read_monitor(thread, obj())->owner() == deoptee_thread, \"must be\");\n+          assert(ObjectSynchronizer::read_monitor(thread, obj(), obj->mark())->owner() == deoptee_thread, \"must be\");\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1978,1 +1978,3 @@\n-  product(bool, OMUseC2Cache, true, \"\")                                     \\\n+  product(bool, UseObjectMonitorTable, false, DIAGNOSTIC,                   \\\n+          \"With Lightweight Locking mode, use a table to record inflated \"  \\\n+          \"monitors rather than the first word of the object.\")             \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -354,1 +354,1 @@\n-    ObjectMonitor* monitor = read_monitor(current, object);\n+    ObjectMonitor* monitor = get_monitor_from_table(current, object);\n@@ -395,0 +395,1 @@\n+\n@@ -421,1 +422,1 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  assert(UseObjectMonitorTable, \"must be\");\n@@ -432,1 +433,1 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  assert(UseObjectMonitorTable, \"must be\");\n@@ -439,1 +440,1 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must use lightweight locking\");\n+  assert(UseObjectMonitorTable, \"must be\");\n@@ -451,0 +452,3 @@\n+  if (!UseObjectMonitorTable) {\n+    return;\n+  }\n@@ -455,1 +459,1 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n+  if (!UseObjectMonitorTable) {\n@@ -462,1 +466,1 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n+  if (!UseObjectMonitorTable) {\n@@ -533,5 +537,8 @@\n-    if (_monitor != nullptr) {\n-      _thread->om_set_monitor_cache(_monitor);\n-      _lock->set_object_monitor_cache(_monitor);\n-    } else {\n-      _lock->clear_object_monitor_cache();\n+    \/\/ Only use the cache if using the table.\n+    if (UseObjectMonitorTable) {\n+      if (_monitor != nullptr) {\n+        _thread->om_set_monitor_cache(_monitor);\n+        _lock->set_object_monitor_cache(_monitor);\n+      } else {\n+        _lock->clear_object_monitor_cache();\n+      }\n@@ -572,1 +579,1 @@\n-  const int log_spin_limit = os::is_MP() ? OMSpins : 1;\n+  const int log_spin_limit = os::is_MP() || !UseObjectMonitorTable ? OMSpins : 1;\n@@ -584,1 +591,1 @@\n-      ObjectMonitor* monitor = LightweightSynchronizer::read_monitor(current, obj);\n+      ObjectMonitor* monitor = ObjectSynchronizer::read_monitor(current, obj, mark);\n@@ -752,2 +759,2 @@\n-  \/\/ The monitor is\n-  ObjectMonitor* monitor = read_monitor(current, object);\n+  \/\/ The monitor exists\n+  ObjectMonitor* monitor = ObjectSynchronizer::read_monitor(current, object, mark);\n@@ -788,1 +795,1 @@\n-    ObjectMonitor* monitor = read_monitor(current, obj);\n+    ObjectMonitor* monitor = ObjectSynchronizer::read_monitor(current, obj, mark);\n@@ -809,0 +816,124 @@\n+ObjectMonitor* LightweightSynchronizer::inflate_into_object_header(Thread* current, JavaThread* inflating_thread, oop object, const ObjectSynchronizer::InflateCause cause) {\n+\n+  \/\/ The JavaThread* inflating_thread parameter is only used by LM_LIGHTWEIGHT and requires\n+  \/\/ that the inflating_thread == Thread::current() or is suspended throughout the call by\n+  \/\/ some other mechanism.\n+  \/\/ Even with LM_LIGHTWEIGHT the thread might be nullptr when called from a non\n+  \/\/ JavaThread. (As may still be the case from FastHashCode). However it is only\n+  \/\/ important for the correctness of the LM_LIGHTWEIGHT algorithm that the thread\n+  \/\/ is set when called from ObjectSynchronizer::enter from the owning thread,\n+  \/\/ ObjectSynchronizer::enter_for from any thread, or ObjectSynchronizer::exit.\n+  EventJavaMonitorInflate event;\n+\n+  for (;;) {\n+    const markWord mark = object->mark_acquire();\n+\n+    \/\/ The mark can be in one of the following states:\n+    \/\/ *  inflated     - Just return if using stack-locking.\n+    \/\/                   If using fast-locking and the ObjectMonitor owner\n+    \/\/                   is anonymous and the inflating_thread owns the\n+    \/\/                   object lock, then we make the inflating_thread\n+    \/\/                   the ObjectMonitor owner and remove the lock from\n+    \/\/                   the inflating_thread's lock stack.\n+    \/\/ *  fast-locked  - Coerce it to inflated from fast-locked.\n+    \/\/ *  unlocked     - Aggressively inflate the object.\n+\n+    \/\/ CASE: inflated\n+    if (mark.has_monitor()) {\n+      ObjectMonitor* inf = mark.monitor();\n+      markWord dmw = inf->header();\n+      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n+      if (inf->is_owner_anonymous() &&\n+          inflating_thread != nullptr && inflating_thread->lock_stack().contains(object)) {\n+        inf->set_owner_from_anonymous(inflating_thread);\n+        size_t removed = inflating_thread->lock_stack().remove(object);\n+        inf->set_recursions(removed - 1);\n+      }\n+      return inf;\n+    }\n+\n+    \/\/ CASE: fast-locked\n+    \/\/ Could be fast-locked either by the inflating_thread or by some other thread.\n+    \/\/\n+    \/\/ Note that we allocate the ObjectMonitor speculatively, _before_\n+    \/\/ attempting to set the object's mark to the new ObjectMonitor. If\n+    \/\/ the inflating_thread owns the monitor, then we set the ObjectMonitor's\n+    \/\/ owner to the inflating_thread. Otherwise, we set the ObjectMonitor's owner\n+    \/\/ to anonymous. If we lose the race to set the object's mark to the\n+    \/\/ new ObjectMonitor, then we just delete it and loop around again.\n+    \/\/\n+    if (mark.is_fast_locked()) {\n+      ObjectMonitor* monitor = new ObjectMonitor(object);\n+      monitor->set_header(mark.set_unlocked());\n+      bool own = inflating_thread != nullptr && inflating_thread->lock_stack().contains(object);\n+      if (own) {\n+        \/\/ Owned by inflating_thread.\n+        monitor->set_owner_from(nullptr, inflating_thread);\n+      } else {\n+        \/\/ Owned by somebody else.\n+        monitor->set_owner_anonymous();\n+      }\n+      markWord monitor_mark = markWord::encode(monitor);\n+      markWord old_mark = object->cas_set_mark(monitor_mark, mark);\n+      if (old_mark == mark) {\n+        \/\/ Success! Return inflated monitor.\n+        if (own) {\n+          size_t removed = inflating_thread->lock_stack().remove(object);\n+          monitor->set_recursions(removed - 1);\n+        }\n+        \/\/ Once the ObjectMonitor is configured and object is associated\n+        \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n+        ObjectSynchronizer::_in_use_list.add(monitor);\n+\n+        \/\/ Hopefully the performance counters are allocated on distinct\n+        \/\/ cache lines to avoid false sharing on MP systems ...\n+        OM_PERFDATA_OP(Inflations, inc());\n+        log_inflate(current, object, cause);\n+        if (event.should_commit()) {\n+          post_monitor_inflate_event(&event, object, cause);\n+        }\n+        return monitor;\n+      } else {\n+        delete monitor;\n+        continue;  \/\/ Interference -- just retry\n+      }\n+    }\n+\n+    \/\/ CASE: unlocked\n+    \/\/ TODO-FIXME: for entry we currently inflate and then try to CAS _owner.\n+    \/\/ If we know we're inflating for entry it's better to inflate by swinging a\n+    \/\/ pre-locked ObjectMonitor pointer into the object header.   A successful\n+    \/\/ CAS inflates the object *and* confers ownership to the inflating thread.\n+    \/\/ In the current implementation we use a 2-step mechanism where we CAS()\n+    \/\/ to inflate and then CAS() again to try to swing _owner from null to current.\n+    \/\/ An inflateTry() method that we could call from enter() would be useful.\n+\n+    assert(mark.is_unlocked(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+    ObjectMonitor* m = new ObjectMonitor(object);\n+    \/\/ prepare m for installation - set monitor to initial state\n+    m->set_header(mark);\n+\n+    if (object->cas_set_mark(markWord::encode(m), mark) != mark) {\n+      delete m;\n+      m = nullptr;\n+      continue;\n+      \/\/ interference - the markword changed - just retry.\n+      \/\/ The state-transitions are one-way, so there's no chance of\n+      \/\/ live-lock -- \"Inflated\" is an absorbing state.\n+    }\n+\n+    \/\/ Once the ObjectMonitor is configured and object is associated\n+    \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n+    ObjectSynchronizer::_in_use_list.add(m);\n+\n+    \/\/ Hopefully the performance counters are allocated on distinct\n+    \/\/ cache lines to avoid false sharing on MP systems ...\n+    OM_PERFDATA_OP(Inflations, inc());\n+    log_inflate(current, object, cause);\n+    if (event.should_commit()) {\n+      post_monitor_inflate_event(&event, object, cause);\n+    }\n+    return m;\n+  }\n+}\n+\n@@ -814,0 +945,15 @@\n+  \/\/ Do stats first\n+  if (cause == ObjectSynchronizer::inflate_cause_wait) {\n+    locking_thread->_wait_inflation++;\n+  } else if (cause == ObjectSynchronizer::inflate_cause_monitor_enter) {\n+    locking_thread->_recursive_inflation++;\n+  } else if (cause == ObjectSynchronizer::inflate_cause_vm_internal) {\n+    locking_thread->_lock_stack_inflation++;\n+  }\n+\n+  ObjectMonitor* monitor;\n+\n+  if (!UseObjectMonitorTable) {\n+    return inflate_into_object_header(current, locking_thread, object, cause);\n+  }\n+\n@@ -815,1 +961,1 @@\n-  FastHashCode(current, object);\n+  ObjectSynchronizer::FastHashCode(current, object);\n@@ -820,2 +966,0 @@\n-  ObjectMonitor* monitor;\n-\n@@ -827,1 +971,1 @@\n-      assert(monitor == read_monitor(current, object), \"The monitor must be in the table\");\n+      assert(monitor == get_monitor_from_table(current, object), \"The monitor must be found\");\n@@ -851,8 +995,0 @@\n-  if (cause == ObjectSynchronizer::inflate_cause_wait) {\n-    locking_thread->_wait_inflation++;\n-  } else if (cause == ObjectSynchronizer::inflate_cause_monitor_enter) {\n-    locking_thread->_recursive_inflation++;\n-  } else if (cause == ObjectSynchronizer::inflate_cause_vm_internal) {\n-    locking_thread->_lock_stack_inflation++;\n-  }\n-\n@@ -865,1 +1001,0 @@\n-  NoSafepointVerifier nsv;\n@@ -870,3 +1005,0 @@\n-  \/\/ Lightweight monitors require that hash codes are installed first\n-  FastHashCode(locking_thread, object);\n-\n@@ -875,0 +1007,20 @@\n+  if (!UseObjectMonitorTable) {\n+    \/\/ Do the old inflate and enter.\n+    monitor = inflate_into_object_header(current, locking_thread, object, cause);\n+\n+    bool entered;\n+    if (locking_thread == current) {\n+      entered = monitor->enter(locking_thread);\n+    } else {\n+      entered = monitor->enter_for(locking_thread);\n+    }\n+\n+    \/\/ enter returns false for deflation found.\n+    return entered ? monitor : nullptr;\n+  }\n+\n+  NoSafepointVerifier nsv;\n+\n+  \/\/ Lightweight monitors require that hash codes are installed first\n+  ObjectSynchronizer::FastHashCode(locking_thread, object);\n+\n@@ -1021,2 +1173,2 @@\n-ObjectMonitor* LightweightSynchronizer::read_monitor(Thread* current, oop obj) {\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+ObjectMonitor* LightweightSynchronizer::get_monitor_from_table(Thread* current, oop obj) {\n+  assert(UseObjectMonitorTable, \"must be\");\n@@ -1027,1 +1179,1 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  assert(UseObjectMonitorTable, \"must be\");\n@@ -1031,21 +1183,0 @@\n-intptr_t LightweightSynchronizer::FastHashCode(Thread* current, oop obj) {\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-\n-  markWord mark = obj->mark_acquire();\n-  for(;;) {\n-    intptr_t hash = mark.hash();\n-    if (hash != 0) {\n-      return hash;\n-    }\n-\n-    hash = ObjectSynchronizer::get_next_hash(current, obj);\n-    const markWord old_mark = mark;\n-    const markWord new_mark = old_mark.copy_set_hash(hash);\n-\n-    mark = obj->cas_set_mark(new_mark, old_mark);\n-    if (old_mark == mark) {\n-      return hash;\n-    }\n-  }\n-}\n-\n@@ -1053,1 +1184,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n@@ -1069,0 +1199,1 @@\n+    \/\/ Clears object monitor cache, because ?\n@@ -1074,0 +1205,10 @@\n+  if (mark.is_unlocked()) {\n+    markWord locked_mark = mark.set_fast_locked();\n+    if (obj->cas_set_mark(locked_mark, mark) == mark) {\n+      \/\/ Successfully fast-locked, push object to lock-stack and return.\n+      lock_stack.push(obj);\n+      current->inc_held_monitor_count();\n+      return true;\n+    }\n+  }\n+\n@@ -1075,1 +1216,2 @@\n-    ObjectMonitor* const monitor = current->om_get_from_monitor_cache(obj);\n+    ObjectMonitor* const monitor = UseObjectMonitorTable ? current->om_get_from_monitor_cache(obj) :\n+                                                           ObjectSynchronizer::read_monitor(mark);\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":201,"deletions":59,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+  static ObjectMonitor* inflate_into_object_header(Thread* current, JavaThread* inflating_thread, oop object, const ObjectSynchronizer::InflateCause cause);\n@@ -73,1 +74,1 @@\n-  static ObjectMonitor* read_monitor(Thread* current, oop obj);\n+  static ObjectMonitor* get_monitor_from_table(Thread* current, oop obj);\n@@ -77,3 +78,0 @@\n-  \/\/ NOTE: May not cause monitor inflation\n-  static intptr_t FastHashCode(Thread* current, oop obj);\n-\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/synchronizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/lockStack.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-  assert(monitor == LightweightSynchronizer::read_monitor(JavaThread::current(), obj), \"must be exist in table\");\n+  assert(monitor == LightweightSynchronizer::get_monitor_from_table(JavaThread::current(), obj), \"must be exist in table\");\n","filename":"src\/hotspot\/share\/runtime\/lockStack.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT || object()->mark() == markWord::encode(this),  \\\n+  assert(UseObjectMonitorTable || object()->mark() == markWord::encode(this),  \\\n@@ -310,1 +310,1 @@\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n+    if (!UseObjectMonitorTable) {\n@@ -661,1 +661,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n+  if (UseObjectMonitorTable) {\n@@ -681,1 +681,1 @@\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"Lightweight has no dmw\");\n+  assert(!UseObjectMonitorTable, \"Lightweight has no dmw\");\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-  \/\/ * LM_LIGHTWEIGHT\n+  \/\/ * LM_LIGHTWEIGHT with UseObjectMonitorTable:\n@@ -139,1 +139,1 @@\n-  \/\/ * LM_LEGACY, LM_MONITOR\n+  \/\/ * LM_LEGACY, LM_MONITOR:\n@@ -240,3 +240,0 @@\n-  \/\/ Lightweight locking fetches ObjectMonitor references from a cache\n-  \/\/ instead of the markWord and doesn't work with tagged values.\n-  \/\/\n@@ -244,1 +241,1 @@\n-    ((in_bytes(ObjectMonitor::f ## _offset())) - (LockingMode == LM_LIGHTWEIGHT ? 0 : checked_cast<int>(markWord::monitor_value)))\n+    ((in_bytes(ObjectMonitor::f ## _offset())) - checked_cast<int>(markWord::monitor_value))\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"Lightweight locking does not use header\");\n+  assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use header\");\n@@ -76,1 +76,1 @@\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"Lightweight locking does not use header\");\n+  assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use header\");\n@@ -81,1 +81,1 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"Only used by lightweight locking\");\n+  assert(UseObjectMonitorTable, \"Only used by lightweight locking with OM table\");\n@@ -86,1 +86,1 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"Only used by lightweight locking\");\n+  assert(UseObjectMonitorTable, \"Only used by lightweight locking with OM table\");\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -72,12 +72,0 @@\n-ObjectMonitor* ObjectSynchronizer::read_monitor(markWord mark) {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"lightweight locking uses table\");\n-  return mark.monitor();\n-}\n-\n-ObjectMonitor* ObjectSynchronizer::read_monitor(Thread* current, oop obj, markWord mark) {\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    return read_monitor(mark);\n-  }\n-  return LightweightSynchronizer::read_monitor(current, obj);\n-}\n-\n@@ -401,0 +389,7 @@\n+static bool useHeavyMonitors() {\n+#if defined(X86) || defined(AARCH64) || defined(PPC64) || defined(RISCV64) || defined(S390)\n+  return LockingMode == LM_MONITOR;\n+#else\n+  return false;\n+#endif\n+}\n@@ -418,0 +413,4 @@\n+  if (useHeavyMonitors()) {\n+    return false;  \/\/ Slow path\n+  }\n+\n@@ -422,0 +421,2 @@\n+  assert(LockingMode == LM_LEGACY, \"legacy mode below\");\n+\n@@ -425,1 +426,2 @@\n-    ObjectMonitor* const m = ObjectSynchronizer::read_monitor(mark);\n+\n+    ObjectMonitor* const m = read_monitor(mark);\n@@ -445,12 +447,10 @@\n-    if (LockingMode == LM_LEGACY) {\n-      \/\/ This Java Monitor is inflated so obj's header will never be\n-      \/\/ displaced to this thread's BasicLock. Make the displaced header\n-      \/\/ non-null so this BasicLock is not seen as recursive nor as\n-      \/\/ being locked. We do this unconditionally so that this thread's\n-      \/\/ BasicLock cannot be mis-interpreted by any stack walkers. For\n-      \/\/ performance reasons, stack walkers generally first check for\n-      \/\/ stack-locking in the object's header, the second check is for\n-      \/\/ recursive stack-locking in the displaced header in the BasicLock,\n-      \/\/ and last are the inflated Java Monitor (ObjectMonitor) checks.\n-      lock->set_displaced_header(markWord::unused_mark());\n-    }\n+    \/\/ This Java Monitor is inflated so obj's header will never be\n+    \/\/ displaced to this thread's BasicLock. Make the displaced header\n+    \/\/ non-null so this BasicLock is not seen as recursive nor as\n+    \/\/ being locked. We do this unconditionally so that this thread's\n+    \/\/ BasicLock cannot be mis-interpreted by any stack walkers. For\n+    \/\/ performance reasons, stack walkers generally first check for\n+    \/\/ stack-locking in the object's header, the second check is for\n+    \/\/ recursive stack-locking in the displaced header in the BasicLock,\n+    \/\/ and last are the inflated Java Monitor (ObjectMonitor) checks.\n+    lock->set_displaced_header(markWord::unused_mark());\n@@ -524,8 +524,0 @@\n-static bool useHeavyMonitors() {\n-#if defined(X86) || defined(AARCH64) || defined(PPC64) || defined(RISCV64) || defined(S390)\n-  return LockingMode == LM_MONITOR;\n-#else\n-  return false;\n-#endif\n-}\n-\n@@ -942,1 +934,1 @@\n-intptr_t ObjectSynchronizer::get_next_hash(Thread* current, oop obj) {\n+static intptr_t get_next_hash(Thread* current, oop obj) {\n@@ -982,0 +974,21 @@\n+static intptr_t install_hash_code(Thread* current, oop obj) {\n+  assert(UseObjectMonitorTable && LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+\n+  markWord mark = obj->mark_acquire();\n+  for(;;) {\n+    intptr_t hash = mark.hash();\n+    if (hash != 0) {\n+      return hash;\n+    }\n+\n+    hash = get_next_hash(current, obj);\n+    const markWord old_mark = mark;\n+    const markWord new_mark = old_mark.copy_set_hash(hash);\n+\n+    mark = obj->cas_set_mark(new_mark, old_mark);\n+    if (old_mark == mark) {\n+      return hash;\n+    }\n+  }\n+}\n+\n@@ -983,2 +996,3 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    return LightweightSynchronizer::FastHashCode(current, obj);\n+  \/\/ Since the monitor isn't in the object header, it can simply be installed.\n+  if (UseObjectMonitorTable && LockingMode == LM_LIGHTWEIGHT) {\n+    return install_hash_code(current, obj);\n@@ -996,1 +1010,1 @@\n-    if (mark.is_unlocked()) {\n+    if (mark.is_unlocked() || (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked())) {\n@@ -1008,1 +1022,4 @@\n-\n+      if (LockingMode == LM_LIGHTWEIGHT) {\n+        \/\/ CAS failed, retry\n+        continue;\n+      }\n@@ -1088,1 +1105,1 @@\n-      if (monitor->is_being_async_deflated()) {\n+      if (monitor->is_being_async_deflated() && !UseObjectMonitorTable) {\n@@ -1120,1 +1137,1 @@\n-    ObjectMonitor* monitor = LightweightSynchronizer::read_monitor(current, obj);\n+    ObjectMonitor* monitor = read_monitor(current, obj, mark);\n@@ -1162,1 +1179,1 @@\n-    ObjectMonitor* monitor = LightweightSynchronizer::read_monitor(Thread::current(), obj);\n+    ObjectMonitor* monitor = read_monitor(Thread::current(), obj, mark);\n@@ -1406,2 +1423,5 @@\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"LM_LIGHTWEIGHT cannot use inflate\");\n-  return inflate_impl(obj, cause);\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    return LightweightSynchronizer::inflate_into_object_header(current, nullptr, obj, cause);\n+  } else {\n+    return inflate_impl(obj, cause);\n+  }\n@@ -1770,1 +1790,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n+    if (UseObjectMonitorTable) {\n@@ -2036,1 +2056,1 @@\n-        const intptr_t hash = LockingMode == LM_LIGHTWEIGHT ? monitor->hash() : monitor->header().hash();\n+        const intptr_t hash = UseObjectMonitorTable ? monitor->hash() : monitor->header().hash();\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":66,"deletions":46,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -137,2 +137,2 @@\n-  static ObjectMonitor* read_monitor(markWord mark);\n-  static ObjectMonitor* read_monitor(Thread* current, oop obj, markWord mark);\n+  inline static ObjectMonitor* read_monitor(markWord mark);\n+  inline static ObjectMonitor* read_monitor(Thread* current, oop obj, markWord mark);\n@@ -203,2 +203,0 @@\n-  static intptr_t get_next_hash(Thread* current, oop obj);\n-\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"runtime\/synchronizer.hpp\"\n+\n+ObjectMonitor* ObjectSynchronizer::read_monitor(markWord mark) {\n+  return mark.monitor();\n+}\n+\n+ObjectMonitor* ObjectSynchronizer::read_monitor(Thread* current, oop obj, markWord mark) {\n+  if (!UseObjectMonitorTable) {\n+    return read_monitor(mark);\n+  } else {\n+    return LightweightSynchronizer::get_monitor_from_table(current, obj);\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.inline.hpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -53,1 +53,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-    if (VM.getVM().getCommandLineFlag(\"LockingMode\").getInt() == LockingMode.getLightweight()) {\n+    if (VM.getVM().getCommandLineFlag(\"UseObjectMonitorTable\").getBool()) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Mark.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-      if (VM.getVM().getCommandLineFlag(\"LockingMode\").getInt() == LockingMode.getLightweight()) {\n+      if (VM.getVM().getCommandLineFlag(\"UseObjectMonitorTable\").getBool()) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ObjectSynchronizer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,1 @@\n+                \"-XX:\" + (COH ? \"+\" : \"-\") + \"UseObjectMonitorTable\",\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedClassPointersEncodingScheme.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}