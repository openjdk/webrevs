{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2518,26 +2518,33 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tagged_monitor = mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-    const Register owner_addr = tmp2;\n-\n-    \/\/ Compute owner address.\n-    addi(owner_addr, tagged_monitor, in_bytes(ObjectMonitor::owner_offset()) - monitor_tag);\n-\n-    \/\/ CAS owner (null => current thread).\n-    cmpxchgd(\/*flag=*\/flag,\n-            \/*current_value=*\/t,\n-            \/*compare_value=*\/(intptr_t)0,\n-            \/*exchange_value=*\/R16_thread,\n-            \/*where=*\/owner_addr,\n-            MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-            MacroAssembler::cmpxchgx_hint_acquire_lock());\n-    beq(flag, locked);\n-\n-    \/\/ Check if recursive.\n-    cmpd(flag, t, R16_thread);\n-    bne(flag, slow_path);\n-\n-    \/\/ Recursive.\n-    ld(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n-    addi(tmp1, tmp1, 1);\n-    std(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register tagged_monitor = mark;\n+      const uintptr_t monitor_tag = markWord::monitor_value;\n+      const Register owner_addr = tmp2;\n+\n+      \/\/ Compute owner address.\n+      addi(owner_addr, tagged_monitor, in_bytes(ObjectMonitor::owner_offset()) - monitor_tag);\n+\n+      \/\/ CAS owner (null => current thread).\n+      cmpxchgd(\/*flag=*\/flag,\n+              \/*current_value=*\/t,\n+              \/*compare_value=*\/(intptr_t)0,\n+              \/*exchange_value=*\/R16_thread,\n+              \/*where=*\/owner_addr,\n+              MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n+              MacroAssembler::cmpxchgx_hint_acquire_lock());\n+      beq(flag, locked);\n+\n+      \/\/ Check if recursive.\n+      cmpd(flag, t, R16_thread);\n+      bne(flag, slow_path);\n+\n+      \/\/ Recursive.\n+      ld(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n+      addi(tmp1, tmp1, 1);\n+      std(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      \/\/ Set flag to NE\n+      crxor(flag, Assembler::equal, flag, Assembler::equal);\n+      b(slow_path);\n+    }\n@@ -2657,43 +2664,50 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register monitor = mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-\n-    \/\/ Untag the monitor.\n-    subi(monitor, mark, monitor_tag);\n-\n-    const Register recursions = tmp2;\n-    Label not_recursive;\n-\n-    \/\/ Check if recursive.\n-    ld(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n-    addic_(recursions, recursions, -1);\n-    blt(CCR0, not_recursive);\n-\n-    \/\/ Recursive unlock.\n-    std(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n-    crorc(CCR0, Assembler::equal, CCR0, Assembler::equal);\n-    b(unlocked);\n-\n-    bind(not_recursive);\n-\n-    Label release_;\n-    const Register t2 = tmp2;\n-\n-    \/\/ Check if the entry lists are empty.\n-    ld(t, in_bytes(ObjectMonitor::EntryList_offset()), monitor);\n-    ld(t2, in_bytes(ObjectMonitor::cxq_offset()), monitor);\n-    orr(t, t, t2);\n-    cmpdi(flag, t, 0);\n-    beq(flag, release_);\n-\n-    \/\/ The owner may be anonymous and we removed the last obj entry in\n-    \/\/ the lock-stack. This loses the information about the owner.\n-    \/\/ Write the thread to the owner field so the runtime knows the owner.\n-    std(R16_thread, in_bytes(ObjectMonitor::owner_offset()), monitor);\n-    b(slow_path);\n-\n-    bind(release_);\n-    \/\/ Set owner to null.\n-    release();\n-    \/\/ t contains 0\n-    std(t, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register monitor = mark;\n+      const uintptr_t monitor_tag = markWord::monitor_value;\n+\n+      \/\/ Untag the monitor.\n+      subi(monitor, mark, monitor_tag);\n+\n+      const Register recursions = tmp2;\n+      Label not_recursive;\n+\n+      \/\/ Check if recursive.\n+      ld(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n+      addic_(recursions, recursions, -1);\n+      blt(CCR0, not_recursive);\n+\n+      \/\/ Recursive unlock.\n+      std(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n+      crorc(CCR0, Assembler::equal, CCR0, Assembler::equal);\n+      b(unlocked);\n+\n+      bind(not_recursive);\n+\n+      Label release_;\n+      const Register t2 = tmp2;\n+\n+      \/\/ Check if the entry lists are empty.\n+      ld(t, in_bytes(ObjectMonitor::EntryList_offset()), monitor);\n+      ld(t2, in_bytes(ObjectMonitor::cxq_offset()), monitor);\n+      orr(t, t, t2);\n+      cmpdi(flag, t, 0);\n+      beq(flag, release_);\n+\n+      \/\/ The owner may be anonymous and we removed the last obj entry in\n+      \/\/ the lock-stack. This loses the information about the owner.\n+      \/\/ Write the thread to the owner field so the runtime knows the owner.\n+      std(R16_thread, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+      b(slow_path);\n+\n+      bind(release_);\n+      \/\/ Set owner to null.\n+      release();\n+      \/\/ t contains 0\n+      std(t, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      \/\/ Set flag to NE\n+      crxor(flag, Assembler::equal, flag, Assembler::equal);\n+      b(slow_path);\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":84,"deletions":70,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -326,19 +326,24 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tmp1_tagged_monitor = tmp1_mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-    const Register tmp2_owner_addr = tmp2;\n-    const Register tmp3_owner = tmp3;\n-\n-    \/\/ Compute owner address.\n-    la(tmp2_owner_addr, Address(tmp1_tagged_monitor, (in_bytes(ObjectMonitor::owner_offset()) - monitor_tag)));\n-\n-    \/\/ CAS owner (null => current thread).\n-    cmpxchg(\/*addr*\/ tmp2_owner_addr, \/*expected*\/ zr, \/*new*\/ xthread, Assembler::int64,\n-            \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::relaxed, \/*result*\/ tmp3_owner);\n-    beqz(tmp3_owner, locked);\n-\n-    \/\/ Check if recursive.\n-    bne(tmp3_owner, xthread, slow_path);\n-\n-    \/\/ Recursive.\n-    increment(Address(tmp1_tagged_monitor, in_bytes(ObjectMonitor::recursions_offset()) - monitor_tag), 1, tmp2, tmp3);\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register tmp1_tagged_monitor = tmp1_mark;\n+      const uintptr_t monitor_tag = markWord::monitor_value;\n+      const Register tmp2_owner_addr = tmp2;\n+      const Register tmp3_owner = tmp3;\n+\n+      \/\/ Compute owner address.\n+      la(tmp2_owner_addr, Address(tmp1_tagged_monitor, (in_bytes(ObjectMonitor::owner_offset()) - monitor_tag)));\n+\n+      \/\/ CAS owner (null => current thread).\n+      cmpxchg(\/*addr*\/ tmp2_owner_addr, \/*expected*\/ zr, \/*new*\/ xthread, Assembler::int64,\n+              \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::relaxed, \/*result*\/ tmp3_owner);\n+      beqz(tmp3_owner, locked);\n+\n+      \/\/ Check if recursive.\n+      bne(tmp3_owner, xthread, slow_path);\n+\n+      \/\/ Recursive.\n+      increment(Address(tmp1_tagged_monitor, in_bytes(ObjectMonitor::recursions_offset()) - monitor_tag), 1, tmp2, tmp3);\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      j(slow_path);\n+    }\n@@ -456,43 +461,48 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tmp1_monitor = tmp1_mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-\n-    \/\/ Untag the monitor.\n-    sub(tmp1_monitor, tmp1_mark, monitor_tag);\n-\n-    const Register tmp2_recursions = tmp2;\n-    Label not_recursive;\n-\n-    \/\/ Check if recursive.\n-    ld(tmp2_recursions, Address(tmp1_monitor, ObjectMonitor::recursions_offset()));\n-    beqz(tmp2_recursions, not_recursive);\n-\n-    \/\/ Recursive unlock.\n-    addi(tmp2_recursions, tmp2_recursions, -1);\n-    sd(tmp2_recursions, Address(tmp1_monitor, ObjectMonitor::recursions_offset()));\n-    j(unlocked);\n-\n-    bind(not_recursive);\n-\n-    Label release;\n-    const Register tmp2_owner_addr = tmp2;\n-\n-    \/\/ Compute owner address.\n-    la(tmp2_owner_addr, Address(tmp1_monitor, ObjectMonitor::owner_offset()));\n-\n-    \/\/ Check if the entry lists are empty.\n-    ld(t0, Address(tmp1_monitor, ObjectMonitor::EntryList_offset()));\n-    ld(tmp3_t, Address(tmp1_monitor, ObjectMonitor::cxq_offset()));\n-    orr(t0, t0, tmp3_t);\n-    beqz(t0, release);\n-\n-    \/\/ The owner may be anonymous and we removed the last obj entry in\n-    \/\/ the lock-stack. This loses the information about the owner.\n-    \/\/ Write the thread to the owner field so the runtime knows the owner.\n-    sd(xthread, Address(tmp2_owner_addr));\n-    j(slow_path);\n-\n-    bind(release);\n-    \/\/ Set owner to null.\n-    membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n-    sd(zr, Address(tmp2_owner_addr));\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register tmp1_monitor = tmp1_mark;\n+      const uintptr_t monitor_tag = markWord::monitor_value;\n+\n+      \/\/ Untag the monitor.\n+      sub(tmp1_monitor, tmp1_mark, monitor_tag);\n+\n+      const Register tmp2_recursions = tmp2;\n+      Label not_recursive;\n+\n+      \/\/ Check if recursive.\n+      ld(tmp2_recursions, Address(tmp1_monitor, ObjectMonitor::recursions_offset()));\n+      beqz(tmp2_recursions, not_recursive);\n+\n+      \/\/ Recursive unlock.\n+      addi(tmp2_recursions, tmp2_recursions, -1);\n+      sd(tmp2_recursions, Address(tmp1_monitor, ObjectMonitor::recursions_offset()));\n+      j(unlocked);\n+\n+      bind(not_recursive);\n+\n+      Label release;\n+      const Register tmp2_owner_addr = tmp2;\n+\n+      \/\/ Compute owner address.\n+      la(tmp2_owner_addr, Address(tmp1_monitor, ObjectMonitor::owner_offset()));\n+\n+      \/\/ Check if the entry lists are empty.\n+      ld(t0, Address(tmp1_monitor, ObjectMonitor::EntryList_offset()));\n+      ld(tmp3_t, Address(tmp1_monitor, ObjectMonitor::cxq_offset()));\n+      orr(t0, t0, tmp3_t);\n+      beqz(t0, release);\n+\n+      \/\/ The owner may be anonymous and we removed the last obj entry in\n+      \/\/ the lock-stack. This loses the information about the owner.\n+      \/\/ Write the thread to the owner field so the runtime knows the owner.\n+      sd(xthread, Address(tmp2_owner_addr));\n+      j(slow_path);\n+\n+      bind(release);\n+      \/\/ Set owner to null.\n+      membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n+      sd(zr, Address(tmp2_owner_addr));\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      j(slow_path);\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":72,"deletions":62,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -3263,26 +3263,33 @@\n-  Register zero = temp;\n-  Register monitor_tagged = displacedHeader; \/\/ Tagged with markWord::monitor_value.\n-  \/\/ The object's monitor m is unlocked iff m->owner is null,\n-  \/\/ otherwise m->owner may contain a thread or a stack address.\n-\n-  \/\/ Try to CAS m->owner from null to current thread.\n-  \/\/ If m->owner is null, then csg succeeds and sets m->owner=THREAD and CR=EQ.\n-  \/\/ Otherwise, register zero is filled with the current owner.\n-  z_lghi(zero, 0);\n-  z_csg(zero, Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor_tagged);\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ Store a non-null value into the box.\n-    z_stg(box, BasicLock::displaced_header_offset_in_bytes(), box);\n-  }\n-\n-  z_bre(done); \/\/ acquired the lock for the first time.\n-\n-  BLOCK_COMMENT(\"fast_path_recursive_lock {\");\n-  \/\/ Check if we are already the owner (recursive lock)\n-  z_cgr(Z_thread, zero); \/\/ owner is stored in zero by \"z_csg\" above\n-  z_brne(done); \/\/ not a recursive lock\n-\n-  \/\/ Current thread already owns the lock. Just increment recursion count.\n-  z_agsi(Address(monitor_tagged, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n-  z_cgr(zero, zero); \/\/ set the CC to EQUAL\n-  BLOCK_COMMENT(\"} fast_path_recursive_lock\");\n+  if (!UseObjectMonitorTable) {\n+    Register zero = temp;\n+    Register monitor_tagged = displacedHeader; \/\/ Tagged with markWord::monitor_value.\n+    \/\/ The object's monitor m is unlocked iff m->owner is null,\n+    \/\/ otherwise m->owner may contain a thread or a stack address.\n+\n+    \/\/ Try to CAS m->owner from null to current thread.\n+    \/\/ If m->owner is null, then csg succeeds and sets m->owner=THREAD and CR=EQ.\n+    \/\/ Otherwise, register zero is filled with the current owner.\n+    z_lghi(zero, 0);\n+    z_csg(zero, Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor_tagged);\n+    if (LockingMode != LM_LIGHTWEIGHT) {\n+      \/\/ Store a non-null value into the box.\n+      z_stg(box, BasicLock::displaced_header_offset_in_bytes(), box);\n+    }\n+\n+    z_bre(done); \/\/ acquired the lock for the first time.\n+\n+    BLOCK_COMMENT(\"fast_path_recursive_lock {\");\n+    \/\/ Check if we are already the owner (recursive lock)\n+    z_cgr(Z_thread, zero); \/\/ owner is stored in zero by \"z_csg\" above\n+    z_brne(done); \/\/ not a recursive lock\n+\n+    \/\/ Current thread already owns the lock. Just increment recursion count.\n+    z_agsi(Address(monitor_tagged, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n+    z_cgr(zero, zero); \/\/ set the CC to EQUAL\n+    BLOCK_COMMENT(\"} fast_path_recursive_lock\");\n+  } else {\n+    \/\/ OMCache lookup not supported yet. Take the slowpath.\n+    \/\/ Set flag to NE\n+    z_ltgr(oop, oop);\n+    z_bru(done);\n+  }\n@@ -3349,2 +3356,3 @@\n-  z_cg(Z_thread, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n-  z_brne(done);\n+  if (!UseObjectMonitorTable) {\n+    z_cg(Z_thread, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n+    z_brne(done);\n@@ -3352,3 +3360,3 @@\n-  BLOCK_COMMENT(\"fast_path_recursive_unlock {\");\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-  z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n+    BLOCK_COMMENT(\"fast_path_recursive_unlock {\");\n+    load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+    z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n@@ -3356,5 +3364,5 @@\n-  \/\/ Recursive inflated unlock\n-  z_agsi(Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n-  z_cgr(currentHeader, currentHeader); \/\/ set the CC to EQUAL\n-  BLOCK_COMMENT(\"} fast_path_recursive_unlock\");\n-  z_bru(done);\n+    \/\/ Recursive inflated unlock\n+    z_agsi(Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n+    z_cgr(currentHeader, currentHeader); \/\/ set the CC to EQUAL\n+    BLOCK_COMMENT(\"} fast_path_recursive_unlock\");\n+    z_bru(done);\n@@ -3362,1 +3370,1 @@\n-  bind(not_recursive);\n+    bind(not_recursive);\n@@ -3364,6 +3372,12 @@\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n-  z_brne(done);\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n-  z_brne(done);\n-  z_release();\n-  z_stg(temp\/*=0*\/, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), currentHeader);\n+    load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n+    z_brne(done);\n+    load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n+    z_brne(done);\n+    z_release();\n+    z_stg(temp\/*=0*\/, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), currentHeader);\n+  } else {\n+    \/\/ OMCache lookup not supported yet. Take the slowpath.\n+    \/\/ Set flag to NE\n+    z_ltgr(oop, oop);\n+    z_bru(done);\n+  }\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":57,"deletions":43,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -1008,2 +1008,5 @@\n-    if (!OMUseC2Cache) {\n-      jmp(slow_path);\n+    if (!UseObjectMonitorTable) {\n+      \/\/ Untag the monitor.\n+      assert(mark == monitor, \"should be same\");\n+      subptr(monitor, markWord::monitor_value);\n+\n@@ -1011,1 +1014,5 @@\n-      if (OMCacheHitRate) increment(Address(thread, JavaThread::lock_lookup_offset()));\n+      \/\/ Uses ObjectMonitorTable.  Look for the monitor in the om_cache.\n+      if (!OMUseC2Cache) {\n+        jmp(slow_path);\n+      } else {\n+        if (OMCacheHitRate) increment(Address(thread, JavaThread::lock_lookup_offset()));\n@@ -1013,2 +1020,2 @@\n-      \/\/ Fetch ObjectMonitor* from the cache or take the slow-path.\n-      Label monitor_found;\n+        \/\/ Fetch ObjectMonitor* from the cache or take the slow-path.\n+        Label monitor_found;\n@@ -1016,2 +1023,2 @@\n-      \/\/ Load cache address\n-      lea(t, Address(thread, JavaThread::om_cache_oops_offset()));\n+        \/\/ Load cache address\n+        lea(t, Address(thread, JavaThread::om_cache_oops_offset()));\n@@ -1019,6 +1026,7 @@\n-      const int num_unrolled = MIN2(OMC2UnrollCacheEntries, OMCacheSize);\n-      for (int i = 0; i < num_unrolled; i++) {\n-        cmpptr(obj, Address(t));\n-        jccb(Assembler::equal, monitor_found);\n-        if (i + 1 != num_unrolled) {\n-          increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+        const int num_unrolled = MIN2(OMC2UnrollCacheEntries, OMCacheSize);\n+        for (int i = 0; i < num_unrolled; i++) {\n+          cmpptr(obj, Address(t));\n+          jccb(Assembler::equal, monitor_found);\n+          if (i + 1 != num_unrolled) {\n+            increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+          }\n@@ -1026,1 +1034,0 @@\n-      }\n@@ -1028,5 +1035,5 @@\n-      if (num_unrolled == 0 || (OMC2UnrollCacheLookupLoopTail && num_unrolled != OMCacheSize)) {\n-        if (num_unrolled != 0) {\n-          \/\/ Loop after unrolling, advance iterator.\n-          increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n-        }\n+        if (num_unrolled == 0 || (OMC2UnrollCacheLookupLoopTail && num_unrolled != OMCacheSize)) {\n+          if (num_unrolled != 0) {\n+            \/\/ Loop after unrolling, advance iterator.\n+            increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+          }\n@@ -1034,1 +1041,1 @@\n-        Label loop;\n+          Label loop;\n@@ -1036,2 +1043,2 @@\n-        \/\/ Search for obj in cache.\n-        bind(loop);\n+          \/\/ Search for obj in cache.\n+          bind(loop);\n@@ -1039,3 +1046,3 @@\n-        \/\/ Check for match.\n-        cmpptr(obj, Address(t));\n-        jccb(Assembler::equal, monitor_found);\n+          \/\/ Check for match.\n+          cmpptr(obj, Address(t));\n+          jccb(Assembler::equal, monitor_found);\n@@ -1043,8 +1050,8 @@\n-        \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n-        cmpptr(Address(t), 1);\n-        jcc(Assembler::below, slow_path); \/\/ 0 check, but with ZF=0 when *t == 0\n-        increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n-        jmpb(loop);\n-      } else {\n-        jmp(slow_path);\n-      }\n+          \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n+          cmpptr(Address(t), 1);\n+          jcc(Assembler::below, slow_path); \/\/ 0 check, but with ZF=0 when *t == 0\n+          increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+          jmpb(loop);\n+        } else {\n+          jmp(slow_path);\n+        }\n@@ -1052,4 +1059,6 @@\n-      \/\/ Cache hit.\n-      bind(monitor_found);\n-      movptr(monitor, Address(t, OMCache::oop_to_monitor_difference()));\n-      if (OMCacheHitRate) increment(Address(thread, JavaThread::lock_hit_offset()));\n+        \/\/ Cache hit.\n+        bind(monitor_found);\n+        movptr(monitor, Address(t, OMCache::oop_to_monitor_difference()));\n+        if (OMCacheHitRate) increment(Address(thread, JavaThread::lock_hit_offset()));\n+      }\n+    }\n@@ -1057,2 +1066,2 @@\n-      Label monitor_locked;\n-      \/\/ Lock the monitor.\n+    Label monitor_locked;\n+    \/\/ Lock the monitor.\n@@ -1060,4 +1069,4 @@\n-      \/\/ CAS owner (null => current thread).\n-      xorptr(rax, rax);\n-      lock(); cmpxchgptr(thread, Address(monitor, ObjectMonitor::owner_offset()));\n-      jccb(Assembler::equal, monitor_locked);\n+    \/\/ CAS owner (null => current thread).\n+    xorptr(rax, rax);\n+    lock(); cmpxchgptr(thread, Address(monitor, ObjectMonitor::owner_offset()));\n+    jccb(Assembler::equal, monitor_locked);\n@@ -1065,3 +1074,3 @@\n-      \/\/ Check if recursive.\n-      cmpptr(thread, rax);\n-      jccb(Assembler::notEqual, slow_path);\n+    \/\/ Check if recursive.\n+    cmpptr(thread, rax);\n+    jccb(Assembler::notEqual, slow_path);\n@@ -1069,2 +1078,2 @@\n-      \/\/ Recursive.\n-      increment(Address(monitor, ObjectMonitor::recursions_offset()));\n+    \/\/ Recursive.\n+    increment(Address(monitor, ObjectMonitor::recursions_offset()));\n@@ -1072,1 +1081,2 @@\n-      bind(monitor_locked);\n+    bind(monitor_locked);\n+    if (UseObjectMonitorTable) {\n@@ -1186,2 +1196,5 @@\n-    if (!OMUseC2Cache) {\n-      jmp(slow_path);\n+    if (!UseObjectMonitorTable) {\n+      \/\/ Untag the monitor.\n+      assert(mark == monitor, \"should be the same here\");\n+      movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+      subptr(monitor, markWord::monitor_value);\n@@ -1189,5 +1202,0 @@\n-      if (OMCacheHitRate) increment(Address(thread, JavaThread::unlock_lookup_offset()));\n-      movptr(monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n-      \/\/ null check with ZF == 0, no valid pointer below alignof(ObjectMonitor*)\n-      cmpptr(monitor, alignof(ObjectMonitor*));\n-      jcc(Assembler::below, slow_path);\n@@ -1195,7 +1203,9 @@\n-      if (OMCacheHitRate) increment(Address(thread, JavaThread::unlock_hit_offset()));\n-\n-      Label recursive;\n-\n-      \/\/ Check if recursive.\n-      cmpptr(Address(monitor,ObjectMonitor::recursions_offset()), 0);\n-      jccb(Assembler::notEqual, recursive);\n+      \/\/ Uses ObjectMonitorTable.  Look for the monitor in our BasicLock on the stack.\n+      if (!OMUseC2Cache) {\n+        jmp(slow_path);\n+      } else {\n+        if (OMCacheHitRate) increment(Address(thread, JavaThread::unlock_lookup_offset()));\n+        movptr(monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+        \/\/ null check with ZF == 0, no valid pointer below alignof(ObjectMonitor*)\n+        cmpptr(monitor, alignof(ObjectMonitor*));\n+        jcc(Assembler::below, slow_path);\n@@ -1203,4 +1213,3 @@\n-      \/\/ Check if the entry lists are empty.\n-      movptr(reg_rax, Address(monitor, ObjectMonitor::cxq_offset()));\n-      orptr(reg_rax, Address(monitor, ObjectMonitor::EntryList_offset()));\n-      jcc(Assembler::notZero, check_successor);\n+        if (OMCacheHitRate) increment(Address(thread, JavaThread::unlock_hit_offset()));\n+      }\n+    }\n@@ -1208,3 +1217,1 @@\n-      \/\/ Release lock.\n-      movptr(Address(monitor, ObjectMonitor::owner_offset()), NULL_WORD);\n-      jmpb(unlocked);\n+    Label recursive;\n@@ -1212,5 +1219,17 @@\n-      \/\/ Recursive unlock.\n-      bind(recursive);\n-      decrement(Address(monitor, ObjectMonitor::recursions_offset()));\n-      xorl(t, t);\n-    }\n+    \/\/ Check if recursive.\n+    cmpptr(Address(monitor, ObjectMonitor::recursions_offset()), 0);\n+    jccb(Assembler::notEqual, recursive);\n+\n+    \/\/ Check if the entry lists are empty.\n+    movptr(reg_rax, Address(monitor, ObjectMonitor::cxq_offset()));\n+    orptr(reg_rax, Address(monitor, ObjectMonitor::EntryList_offset()));\n+    jcc(Assembler::notZero, check_successor);\n+\n+    \/\/ Release lock.\n+    movptr(Address(monitor, ObjectMonitor::owner_offset()), NULL_WORD);\n+    jmpb(unlocked);\n+\n+    \/\/ Recursive unlock.\n+    bind(recursive);\n+    decrement(Address(monitor, ObjectMonitor::recursions_offset()));\n+    xorl(t, t);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":94,"deletions":75,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -237,1 +237,1 @@\n-    assert(LockingMode != LM_LIGHTWEIGHT, \"Lightweight locking does not use markWord for monitors\");\n+    assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use markWord for monitors\");\n@@ -243,1 +243,1 @@\n-    return LockingMode == LM_LIGHTWEIGHT ? false                             \/\/ no displaced mark\n+    return LockingMode == LM_LIGHTWEIGHT  ? UseObjectMonitorTable ? false : lockbits == monitor_value   \/\/ no displace mark or monitor?\n@@ -270,1 +270,1 @@\n-    assert(LockingMode != LM_LIGHTWEIGHT, \"Lightweight locking does not use markWord for monitors\");\n+    assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use markWord for monitors\");\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"runtime\/synchronizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1829,1 +1829,1 @@\n-#if !defined(X86) && !defined(AARCH64)\n+#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM) && !defined(PPC64) && !defined(S390)\n@@ -2953,0 +2953,5 @@\n+  if (UseObjectMonitorTable && LockingMode != LM_LIGHTWEIGHT) {\n+    \/\/ ObjectMonitorTable requires lightweight locking.\n+    FLAG_SET_DEFAULT(LockingMode, LM_LIGHTWEIGHT);\n+  }\n+\n@@ -2960,0 +2965,6 @@\n+  if (UseCompactObjectHeaders && !UseObjectMonitorTable) {\n+    if (FLAG_IS_CMDLINE(UseObjectMonitorTable)) {\n+      warning(\"Compact object headers requires ObjectMonitorTable. Disabling compact object headers.\");\n+    }\n+    FLAG_SET_DEFAULT(UseCompactObjectHeaders, false);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -1676,1 +1676,1 @@\n-          assert(LightweightSynchronizer::read_monitor(thread, obj())->owner() == deoptee_thread, \"must be\");\n+          assert(ObjectSynchronizer::read_monitor(thread, obj(), obj->mark())->owner() == deoptee_thread, \"must be\");\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1978,0 +1978,4 @@\n+  product(bool, UseObjectMonitorTable, false, DIAGNOSTIC,                   \\\n+          \"With Lightweight Locking mode, use a table to record inflated \"  \\\n+          \"monitors rather than the first word of the object.\")             \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -330,1 +330,1 @@\n-    ObjectMonitor* monitor = read_monitor(current, object);\n+    ObjectMonitor* monitor = get_monitor_from_table(current, object);\n@@ -371,0 +371,1 @@\n+\n@@ -397,1 +398,1 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  assert(UseObjectMonitorTable, \"must be\");\n@@ -408,1 +409,1 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  assert(UseObjectMonitorTable, \"must be\");\n@@ -415,1 +416,1 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must use lightweight locking\");\n+  assert(UseObjectMonitorTable, \"must be\");\n@@ -427,0 +428,3 @@\n+  if (!UseObjectMonitorTable) {\n+    return;\n+  }\n@@ -438,1 +442,1 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n+  if (!UseObjectMonitorTable) {\n@@ -445,1 +449,1 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n+  if (!UseObjectMonitorTable) {\n@@ -455,1 +459,1 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n+  if (!UseObjectMonitorTable) {\n@@ -529,5 +533,8 @@\n-    if (_monitor != nullptr) {\n-      _thread->om_set_monitor_cache(_monitor);\n-      _lock->set_object_monitor_cache(_monitor);\n-    } else {\n-      _lock->clear_object_monitor_cache();\n+    \/\/ Only use the cache if using the table.\n+    if (UseObjectMonitorTable) {\n+      if (_monitor != nullptr) {\n+        _thread->om_set_monitor_cache(_monitor);\n+        _lock->set_object_monitor_cache(_monitor);\n+      } else {\n+        _lock->clear_object_monitor_cache();\n+      }\n@@ -568,1 +575,1 @@\n-  const int log_spin_limit = os::is_MP() ? OMSpins : 1;\n+  const int log_spin_limit = os::is_MP() || !UseObjectMonitorTable ? OMSpins : 1;\n@@ -580,1 +587,1 @@\n-      ObjectMonitor* monitor = LightweightSynchronizer::read_monitor(current, obj);\n+      ObjectMonitor* monitor = ObjectSynchronizer::read_monitor(current, obj, mark);\n@@ -748,2 +755,2 @@\n-  \/\/ The monitor is\n-  ObjectMonitor* monitor = read_monitor(current, object);\n+  \/\/ The monitor exists\n+  ObjectMonitor* monitor = ObjectSynchronizer::read_monitor(current, object, mark);\n@@ -784,1 +791,1 @@\n-    ObjectMonitor* monitor = read_monitor(current, obj);\n+    ObjectMonitor* monitor = ObjectSynchronizer::read_monitor(current, obj, mark);\n@@ -805,0 +812,124 @@\n+ObjectMonitor* LightweightSynchronizer::inflate_into_object_header(Thread* current, JavaThread* inflating_thread, oop object, const ObjectSynchronizer::InflateCause cause) {\n+\n+  \/\/ The JavaThread* inflating_thread parameter is only used by LM_LIGHTWEIGHT and requires\n+  \/\/ that the inflating_thread == Thread::current() or is suspended throughout the call by\n+  \/\/ some other mechanism.\n+  \/\/ Even with LM_LIGHTWEIGHT the thread might be nullptr when called from a non\n+  \/\/ JavaThread. (As may still be the case from FastHashCode). However it is only\n+  \/\/ important for the correctness of the LM_LIGHTWEIGHT algorithm that the thread\n+  \/\/ is set when called from ObjectSynchronizer::enter from the owning thread,\n+  \/\/ ObjectSynchronizer::enter_for from any thread, or ObjectSynchronizer::exit.\n+  EventJavaMonitorInflate event;\n+\n+  for (;;) {\n+    const markWord mark = object->mark_acquire();\n+\n+    \/\/ The mark can be in one of the following states:\n+    \/\/ *  inflated     - Just return if using stack-locking.\n+    \/\/                   If using fast-locking and the ObjectMonitor owner\n+    \/\/                   is anonymous and the inflating_thread owns the\n+    \/\/                   object lock, then we make the inflating_thread\n+    \/\/                   the ObjectMonitor owner and remove the lock from\n+    \/\/                   the inflating_thread's lock stack.\n+    \/\/ *  fast-locked  - Coerce it to inflated from fast-locked.\n+    \/\/ *  unlocked     - Aggressively inflate the object.\n+\n+    \/\/ CASE: inflated\n+    if (mark.has_monitor()) {\n+      ObjectMonitor* inf = mark.monitor();\n+      markWord dmw = inf->header();\n+      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n+      if (inf->is_owner_anonymous() &&\n+          inflating_thread != nullptr && inflating_thread->lock_stack().contains(object)) {\n+        inf->set_owner_from_anonymous(inflating_thread);\n+        size_t removed = inflating_thread->lock_stack().remove(object);\n+        inf->set_recursions(removed - 1);\n+      }\n+      return inf;\n+    }\n+\n+    \/\/ CASE: fast-locked\n+    \/\/ Could be fast-locked either by the inflating_thread or by some other thread.\n+    \/\/\n+    \/\/ Note that we allocate the ObjectMonitor speculatively, _before_\n+    \/\/ attempting to set the object's mark to the new ObjectMonitor. If\n+    \/\/ the inflating_thread owns the monitor, then we set the ObjectMonitor's\n+    \/\/ owner to the inflating_thread. Otherwise, we set the ObjectMonitor's owner\n+    \/\/ to anonymous. If we lose the race to set the object's mark to the\n+    \/\/ new ObjectMonitor, then we just delete it and loop around again.\n+    \/\/\n+    if (mark.is_fast_locked()) {\n+      ObjectMonitor* monitor = new ObjectMonitor(object);\n+      monitor->set_header(mark.set_unlocked());\n+      bool own = inflating_thread != nullptr && inflating_thread->lock_stack().contains(object);\n+      if (own) {\n+        \/\/ Owned by inflating_thread.\n+        monitor->set_owner_from(nullptr, inflating_thread);\n+      } else {\n+        \/\/ Owned by somebody else.\n+        monitor->set_owner_anonymous();\n+      }\n+      markWord monitor_mark = markWord::encode(monitor);\n+      markWord old_mark = object->cas_set_mark(monitor_mark, mark);\n+      if (old_mark == mark) {\n+        \/\/ Success! Return inflated monitor.\n+        if (own) {\n+          size_t removed = inflating_thread->lock_stack().remove(object);\n+          monitor->set_recursions(removed - 1);\n+        }\n+        \/\/ Once the ObjectMonitor is configured and object is associated\n+        \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n+        ObjectSynchronizer::_in_use_list.add(monitor);\n+\n+        \/\/ Hopefully the performance counters are allocated on distinct\n+        \/\/ cache lines to avoid false sharing on MP systems ...\n+        OM_PERFDATA_OP(Inflations, inc());\n+        log_inflate(current, object, cause);\n+        if (event.should_commit()) {\n+          post_monitor_inflate_event(&event, object, cause);\n+        }\n+        return monitor;\n+      } else {\n+        delete monitor;\n+        continue;  \/\/ Interference -- just retry\n+      }\n+    }\n+\n+    \/\/ CASE: unlocked\n+    \/\/ TODO-FIXME: for entry we currently inflate and then try to CAS _owner.\n+    \/\/ If we know we're inflating for entry it's better to inflate by swinging a\n+    \/\/ pre-locked ObjectMonitor pointer into the object header.   A successful\n+    \/\/ CAS inflates the object *and* confers ownership to the inflating thread.\n+    \/\/ In the current implementation we use a 2-step mechanism where we CAS()\n+    \/\/ to inflate and then CAS() again to try to swing _owner from null to current.\n+    \/\/ An inflateTry() method that we could call from enter() would be useful.\n+\n+    assert(mark.is_unlocked(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+    ObjectMonitor* m = new ObjectMonitor(object);\n+    \/\/ prepare m for installation - set monitor to initial state\n+    m->set_header(mark);\n+\n+    if (object->cas_set_mark(markWord::encode(m), mark) != mark) {\n+      delete m;\n+      m = nullptr;\n+      continue;\n+      \/\/ interference - the markword changed - just retry.\n+      \/\/ The state-transitions are one-way, so there's no chance of\n+      \/\/ live-lock -- \"Inflated\" is an absorbing state.\n+    }\n+\n+    \/\/ Once the ObjectMonitor is configured and object is associated\n+    \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n+    ObjectSynchronizer::_in_use_list.add(m);\n+\n+    \/\/ Hopefully the performance counters are allocated on distinct\n+    \/\/ cache lines to avoid false sharing on MP systems ...\n+    OM_PERFDATA_OP(Inflations, inc());\n+    log_inflate(current, object, cause);\n+    if (event.should_commit()) {\n+      post_monitor_inflate_event(&event, object, cause);\n+    }\n+    return m;\n+  }\n+}\n+\n@@ -810,0 +941,15 @@\n+  \/\/ Do stats first\n+  if (cause == ObjectSynchronizer::inflate_cause_wait) {\n+    locking_thread->_wait_inflation++;\n+  } else if (cause == ObjectSynchronizer::inflate_cause_monitor_enter) {\n+    locking_thread->_recursive_inflation++;\n+  } else if (cause == ObjectSynchronizer::inflate_cause_vm_internal) {\n+    locking_thread->_lock_stack_inflation++;\n+  }\n+\n+  ObjectMonitor* monitor;\n+\n+  if (!UseObjectMonitorTable) {\n+    return inflate_into_object_header(current, locking_thread, object, cause);\n+  }\n+\n@@ -811,1 +957,1 @@\n-  FastHashCode(current, object);\n+  ObjectSynchronizer::FastHashCode(current, object);\n@@ -816,2 +962,0 @@\n-  ObjectMonitor* monitor;\n-\n@@ -823,1 +967,1 @@\n-      assert(monitor == read_monitor(current, object), \"The monitor must be in the table\");\n+      assert(monitor == get_monitor_from_table(current, object), \"The monitor must be found\");\n@@ -847,8 +991,0 @@\n-  if (cause == ObjectSynchronizer::inflate_cause_wait) {\n-    locking_thread->_wait_inflation++;\n-  } else if (cause == ObjectSynchronizer::inflate_cause_monitor_enter) {\n-    locking_thread->_recursive_inflation++;\n-  } else if (cause == ObjectSynchronizer::inflate_cause_vm_internal) {\n-    locking_thread->_lock_stack_inflation++;\n-  }\n-\n@@ -861,1 +997,0 @@\n-  NoSafepointVerifier nsv;\n@@ -866,3 +1001,0 @@\n-  \/\/ Lightweight monitors require that hash codes are installed first\n-  FastHashCode(locking_thread, object);\n-\n@@ -871,0 +1003,20 @@\n+  if (!UseObjectMonitorTable) {\n+    \/\/ Do the old inflate and enter.\n+    monitor = inflate_into_object_header(current, locking_thread, object, cause);\n+\n+    bool entered;\n+    if (locking_thread == current) {\n+      entered = monitor->enter(locking_thread);\n+    } else {\n+      entered = monitor->enter_for(locking_thread);\n+    }\n+\n+    \/\/ enter returns false for deflation found.\n+    return entered ? monitor : nullptr;\n+  }\n+\n+  NoSafepointVerifier nsv;\n+\n+  \/\/ Lightweight monitors require that hash codes are installed first\n+  ObjectSynchronizer::FastHashCode(locking_thread, object);\n+\n@@ -1017,2 +1169,2 @@\n-ObjectMonitor* LightweightSynchronizer::read_monitor(Thread* current, oop obj) {\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+ObjectMonitor* LightweightSynchronizer::get_monitor_from_table(Thread* current, oop obj) {\n+  assert(UseObjectMonitorTable, \"must be\");\n@@ -1023,1 +1175,1 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  assert(UseObjectMonitorTable, \"must be\");\n@@ -1027,21 +1179,0 @@\n-intptr_t LightweightSynchronizer::FastHashCode(Thread* current, oop obj) {\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-\n-  markWord mark = obj->mark_acquire();\n-  for(;;) {\n-    intptr_t hash = mark.hash();\n-    if (hash != 0) {\n-      return hash;\n-    }\n-\n-    hash = ObjectSynchronizer::get_next_hash(current, obj);\n-    const markWord old_mark = mark;\n-    const markWord new_mark = old_mark.copy_set_hash(hash);\n-\n-    mark = obj->cas_set_mark(new_mark, old_mark);\n-    if (old_mark == mark) {\n-      return hash;\n-    }\n-  }\n-}\n-\n@@ -1049,1 +1180,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n@@ -1065,0 +1195,1 @@\n+    \/\/ Clears object monitor cache, because ?\n@@ -1070,0 +1201,10 @@\n+  if (mark.is_unlocked()) {\n+    markWord locked_mark = mark.set_fast_locked();\n+    if (obj->cas_set_mark(locked_mark, mark) == mark) {\n+      \/\/ Successfully fast-locked, push object to lock-stack and return.\n+      lock_stack.push(obj);\n+      current->inc_held_monitor_count();\n+      return true;\n+    }\n+  }\n+\n@@ -1071,1 +1212,2 @@\n-    ObjectMonitor* const monitor = current->om_get_from_monitor_cache(obj);\n+    ObjectMonitor* const monitor = UseObjectMonitorTable ? current->om_get_from_monitor_cache(obj) :\n+                                                           ObjectSynchronizer::read_monitor(mark);\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":202,"deletions":60,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+  static ObjectMonitor* inflate_into_object_header(Thread* current, JavaThread* inflating_thread, oop object, const ObjectSynchronizer::InflateCause cause);\n@@ -74,1 +75,1 @@\n-  static ObjectMonitor* read_monitor(Thread* current, oop obj);\n+  static ObjectMonitor* get_monitor_from_table(Thread* current, oop obj);\n@@ -78,3 +79,0 @@\n-  \/\/ NOTE: May not cause monitor inflation\n-  static intptr_t FastHashCode(Thread* current, oop obj);\n-\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/synchronizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/lockStack.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-  assert(monitor == LightweightSynchronizer::read_monitor(JavaThread::current(), obj), \"must be exist in table\");\n+  assert(monitor == LightweightSynchronizer::get_monitor_from_table(JavaThread::current(), obj), \"must be exist in table\");\n","filename":"src\/hotspot\/share\/runtime\/lockStack.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT || object()->mark() == markWord::encode(this),  \\\n+  assert(UseObjectMonitorTable || object()->mark() == markWord::encode(this),  \\\n@@ -310,1 +310,1 @@\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n+    if (!UseObjectMonitorTable) {\n@@ -661,1 +661,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n+  if (UseObjectMonitorTable) {\n@@ -681,1 +681,1 @@\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"Lightweight has no dmw\");\n+  assert(!UseObjectMonitorTable, \"Lightweight has no dmw\");\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-  \/\/ * LM_LIGHTWEIGHT\n+  \/\/ * LM_LIGHTWEIGHT with UseObjectMonitorTable:\n@@ -139,1 +139,1 @@\n-  \/\/ * LM_LEGACY, LM_MONITOR\n+  \/\/ * LM_LEGACY, LM_MONITOR:\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"Lightweight locking does not use header\");\n+  assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use header\");\n@@ -76,1 +76,1 @@\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"Lightweight locking does not use header\");\n+  assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use header\");\n@@ -81,1 +81,1 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"Only used by lightweight locking\");\n+  assert(UseObjectMonitorTable, \"Only used by lightweight locking with OM table\");\n@@ -86,1 +86,1 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"Only used by lightweight locking\");\n+  assert(UseObjectMonitorTable, \"Only used by lightweight locking with OM table\");\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -72,12 +72,0 @@\n-ObjectMonitor* ObjectSynchronizer::read_monitor(markWord mark) {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"lightweight locking uses table\");\n-  return mark.monitor();\n-}\n-\n-ObjectMonitor* ObjectSynchronizer::read_monitor(Thread* current, oop obj, markWord mark) {\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    return read_monitor(mark);\n-  }\n-  return LightweightSynchronizer::read_monitor(current, obj);\n-}\n-\n@@ -401,0 +389,7 @@\n+static bool useHeavyMonitors() {\n+#if defined(X86) || defined(AARCH64) || defined(PPC64) || defined(RISCV64) || defined(S390)\n+  return LockingMode == LM_MONITOR;\n+#else\n+  return false;\n+#endif\n+}\n@@ -418,0 +413,4 @@\n+  if (useHeavyMonitors()) {\n+    return false;  \/\/ Slow path\n+  }\n+\n@@ -422,0 +421,2 @@\n+  assert(LockingMode == LM_LEGACY, \"legacy mode below\");\n+\n@@ -425,1 +426,2 @@\n-    ObjectMonitor* const m = ObjectSynchronizer::read_monitor(mark);\n+\n+    ObjectMonitor* const m = read_monitor(mark);\n@@ -445,12 +447,10 @@\n-    if (LockingMode == LM_LEGACY) {\n-      \/\/ This Java Monitor is inflated so obj's header will never be\n-      \/\/ displaced to this thread's BasicLock. Make the displaced header\n-      \/\/ non-null so this BasicLock is not seen as recursive nor as\n-      \/\/ being locked. We do this unconditionally so that this thread's\n-      \/\/ BasicLock cannot be mis-interpreted by any stack walkers. For\n-      \/\/ performance reasons, stack walkers generally first check for\n-      \/\/ stack-locking in the object's header, the second check is for\n-      \/\/ recursive stack-locking in the displaced header in the BasicLock,\n-      \/\/ and last are the inflated Java Monitor (ObjectMonitor) checks.\n-      lock->set_displaced_header(markWord::unused_mark());\n-    }\n+    \/\/ This Java Monitor is inflated so obj's header will never be\n+    \/\/ displaced to this thread's BasicLock. Make the displaced header\n+    \/\/ non-null so this BasicLock is not seen as recursive nor as\n+    \/\/ being locked. We do this unconditionally so that this thread's\n+    \/\/ BasicLock cannot be mis-interpreted by any stack walkers. For\n+    \/\/ performance reasons, stack walkers generally first check for\n+    \/\/ stack-locking in the object's header, the second check is for\n+    \/\/ recursive stack-locking in the displaced header in the BasicLock,\n+    \/\/ and last are the inflated Java Monitor (ObjectMonitor) checks.\n+    lock->set_displaced_header(markWord::unused_mark());\n@@ -524,8 +524,0 @@\n-static bool useHeavyMonitors() {\n-#if defined(X86) || defined(AARCH64) || defined(PPC64) || defined(RISCV64) || defined(S390)\n-  return LockingMode == LM_MONITOR;\n-#else\n-  return false;\n-#endif\n-}\n-\n@@ -942,1 +934,1 @@\n-intptr_t ObjectSynchronizer::get_next_hash(Thread* current, oop obj) {\n+static intptr_t get_next_hash(Thread* current, oop obj) {\n@@ -982,0 +974,21 @@\n+static intptr_t install_hash_code(Thread* current, oop obj) {\n+  assert(UseObjectMonitorTable && LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+\n+  markWord mark = obj->mark_acquire();\n+  for(;;) {\n+    intptr_t hash = mark.hash();\n+    if (hash != 0) {\n+      return hash;\n+    }\n+\n+    hash = get_next_hash(current, obj);\n+    const markWord old_mark = mark;\n+    const markWord new_mark = old_mark.copy_set_hash(hash);\n+\n+    mark = obj->cas_set_mark(new_mark, old_mark);\n+    if (old_mark == mark) {\n+      return hash;\n+    }\n+  }\n+}\n+\n@@ -983,2 +996,3 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    return LightweightSynchronizer::FastHashCode(current, obj);\n+  \/\/ Since the monitor isn't in the object header, it can simply be installed.\n+  if (UseObjectMonitorTable && LockingMode == LM_LIGHTWEIGHT) {\n+    return install_hash_code(current, obj);\n@@ -996,1 +1010,1 @@\n-    if (mark.is_unlocked()) {\n+    if (mark.is_unlocked() || (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked())) {\n@@ -1008,1 +1022,4 @@\n-\n+      if (LockingMode == LM_LIGHTWEIGHT) {\n+        \/\/ CAS failed, retry\n+        continue;\n+      }\n@@ -1088,1 +1105,1 @@\n-      if (monitor->is_being_async_deflated()) {\n+      if (monitor->is_being_async_deflated() && !UseObjectMonitorTable) {\n@@ -1120,1 +1137,1 @@\n-    ObjectMonitor* monitor = LightweightSynchronizer::read_monitor(current, obj);\n+    ObjectMonitor* monitor = read_monitor(current, obj, mark);\n@@ -1162,1 +1179,1 @@\n-    ObjectMonitor* monitor = LightweightSynchronizer::read_monitor(Thread::current(), obj);\n+    ObjectMonitor* monitor = read_monitor(Thread::current(), obj, mark);\n@@ -1406,2 +1423,5 @@\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"LM_LIGHTWEIGHT cannot use inflate\");\n-  return inflate_impl(obj, cause);\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    return LightweightSynchronizer::inflate_into_object_header(current, nullptr, obj, cause);\n+  } else {\n+    return inflate_impl(obj, cause);\n+  }\n@@ -1770,1 +1790,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n+    if (UseObjectMonitorTable) {\n@@ -2036,1 +2056,1 @@\n-        const intptr_t hash = LockingMode == LM_LIGHTWEIGHT ? monitor->hash() : monitor->header().hash();\n+        const intptr_t hash = UseObjectMonitorTable ? monitor->hash() : monitor->header().hash();\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":66,"deletions":46,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -137,2 +137,2 @@\n-  static ObjectMonitor* read_monitor(markWord mark);\n-  static ObjectMonitor* read_monitor(Thread* current, oop obj, markWord mark);\n+  inline static ObjectMonitor* read_monitor(markWord mark);\n+  inline static ObjectMonitor* read_monitor(Thread* current, oop obj, markWord mark);\n@@ -203,2 +203,0 @@\n-  static intptr_t get_next_hash(Thread* current, oop obj);\n-\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"runtime\/synchronizer.hpp\"\n+\n+ObjectMonitor* ObjectSynchronizer::read_monitor(markWord mark) {\n+  return mark.monitor();\n+}\n+\n+ObjectMonitor* ObjectSynchronizer::read_monitor(Thread* current, oop obj, markWord mark) {\n+  if (!UseObjectMonitorTable) {\n+    return read_monitor(mark);\n+  } else {\n+    return LightweightSynchronizer::get_monitor_from_table(current, obj);\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.inline.hpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -53,1 +53,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,1 @@\n+                \"-XX:\" + (COH ? \"+\" : \"-\") + \"UseObjectMonitorTable\",\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedClassPointersEncodingScheme.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}