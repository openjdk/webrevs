{"files":[{"patch":"@@ -239,2 +239,4 @@\n-  \/\/ Clear cache in case fast locking succeeds.\n-  str(zr, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    str(zr, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+  }\n@@ -295,5 +297,1 @@\n-    if (!OMUseC2Cache) {\n-      \/\/ Set Flags == NE\n-      cmp(zr, obj);\n-      b(slow_path);\n-    } else {\n+    const Register t1_monitor = t1;\n@@ -301,0 +299,3 @@\n+    if (!UseObjectMonitorTable) {\n+      assert(t1_monitor == t1_mark, \"should be the same here\");\n+    } else {\n@@ -344,1 +345,1 @@\n-      ldr(t1, Address(t3_t, OMCache::oop_to_monitor_difference()));\n+      ldr(t1_monitor, Address(t3_t, OMCache::oop_to_monitor_difference()));\n@@ -346,0 +347,1 @@\n+    }\n@@ -347,4 +349,5 @@\n-      \/\/ ObjectMonitor* is in t1\n-      const Register t1_monitor = t1;\n-      const Register t2_owner_addr = t2;\n-      const Register t3_owner = t3;\n+    const Register t2_owner_addr = t2;\n+    const Register t3_owner = t3;\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address owner_address{t1_monitor, ObjectMonitor::owner_offset() - monitor_tag};\n+    const Address recursions_address{t1_monitor, ObjectMonitor::recursions_offset() - monitor_tag};\n@@ -352,1 +355,1 @@\n-      Label monitor_locked;\n+    Label monitor_locked;\n@@ -354,2 +357,2 @@\n-      \/\/ Compute owner address.\n-      lea(t2_owner_addr, Address(t1_monitor, ObjectMonitor::owner_offset()));\n+    \/\/ Compute owner address.\n+    lea(t2_owner_addr, owner_address);\n@@ -357,4 +360,4 @@\n-      \/\/ CAS owner (null => current thread).\n-      cmpxchg(t2_owner_addr, zr, rthread, Assembler::xword, \/*acquire*\/ true,\n-              \/*release*\/ false, \/*weak*\/ false, t3_owner);\n-      br(Assembler::EQ, monitor_locked);\n+    \/\/ CAS owner (null => current thread).\n+    cmpxchg(t2_owner_addr, zr, rthread, Assembler::xword, \/*acquire*\/ true,\n+            \/*release*\/ false, \/*weak*\/ false, t3_owner);\n+    br(Assembler::EQ, monitor_locked);\n@@ -362,3 +365,3 @@\n-      \/\/ Check if recursive.\n-      cmp(t3_owner, rthread);\n-      br(Assembler::NE, slow_path);\n+    \/\/ Check if recursive.\n+    cmp(t3_owner, rthread);\n+    br(Assembler::NE, slow_path);\n@@ -366,2 +369,2 @@\n-      \/\/ Recursive.\n-      increment(Address(t1_monitor, ObjectMonitor::recursions_offset()), 1);\n+    \/\/ Recursive.\n+    increment(recursions_address, 1);\n@@ -369,1 +372,2 @@\n-      bind(monitor_locked);\n+    bind(monitor_locked);\n+    if (UseObjectMonitorTable) {\n@@ -372,1 +376,0 @@\n-\n@@ -482,4 +485,1 @@\n-    if (!OMUseC2Cache) {\n-      b(slow_path);\n-    } else {\n-      const Register t1_monitor = t1;\n+    const Register t1_monitor = t1;\n@@ -487,0 +487,6 @@\n+    if (!UseObjectMonitorTable) {\n+      assert(t1_monitor == t1_mark, \"should be the same here\");\n+\n+      \/\/ Untag the monitor.\n+      add(t1_monitor, t1_mark, -(int)markWord::monitor_value);\n+    } else {\n@@ -493,40 +499,0 @@\n-\n-      const Register t2_recursions = t2;\n-      Label not_recursive;\n-\n-      \/\/ Check if recursive.\n-      ldr(t2_recursions, Address(t1_monitor, ObjectMonitor::recursions_offset()));\n-      cbz(t2_recursions, not_recursive);\n-\n-      \/\/ Recursive unlock.\n-      sub(t2_recursions, t2_recursions, 1u);\n-      str(t2_recursions, Address(t1_monitor, ObjectMonitor::recursions_offset()));\n-      \/\/ Set flag == EQ\n-      cmp(t2_recursions, t2_recursions);\n-      b(unlocked);\n-\n-      bind(not_recursive);\n-\n-      Label release;\n-      const Register t2_owner_addr = t2;\n-\n-      \/\/ Compute owner address.\n-      lea(t2_owner_addr, Address(t1_monitor, ObjectMonitor::owner_offset()));\n-\n-      \/\/ Check if the entry lists are empty.\n-      ldr(rscratch1, Address(t1_monitor, ObjectMonitor::EntryList_offset()));\n-      ldr(t3_t, Address(t1_monitor, ObjectMonitor::cxq_offset()));\n-      orr(rscratch1, rscratch1, t3_t);\n-      cmp(rscratch1, zr);\n-      br(Assembler::EQ, release);\n-\n-      \/\/ The owner may be anonymous and we removed the last obj entry in\n-      \/\/ the lock-stack. This loses the information about the owner.\n-      \/\/ Write the thread to the owner field so the runtime knows the owner.\n-      str(rthread, Address(t2_owner_addr));\n-      b(slow_path);\n-\n-      bind(release);\n-      \/\/ Set owner to null.\n-      \/\/ Release to satisfy the JMM\n-      stlr(zr, t2_owner_addr);\n@@ -534,0 +500,40 @@\n+\n+    const Register t2_recursions = t2;\n+    Label not_recursive;\n+\n+    \/\/ Check if recursive.\n+    ldr(t2_recursions, Address(t1_monitor, ObjectMonitor::recursions_offset()));\n+    cbz(t2_recursions, not_recursive);\n+\n+    \/\/ Recursive unlock.\n+    sub(t2_recursions, t2_recursions, 1u);\n+    str(t2_recursions, Address(t1_monitor, ObjectMonitor::recursions_offset()));\n+    \/\/ Set flag == EQ\n+    cmp(t2_recursions, t2_recursions);\n+    b(unlocked);\n+\n+    bind(not_recursive);\n+\n+    Label release;\n+    const Register t2_owner_addr = t2;\n+\n+    \/\/ Compute owner address.\n+    lea(t2_owner_addr, Address(t1_monitor, ObjectMonitor::owner_offset()));\n+\n+    \/\/ Check if the entry lists are empty.\n+    ldr(rscratch1, Address(t1_monitor, ObjectMonitor::EntryList_offset()));\n+    ldr(t3_t, Address(t1_monitor, ObjectMonitor::cxq_offset()));\n+    orr(rscratch1, rscratch1, t3_t);\n+    cmp(rscratch1, zr);\n+    br(Assembler::EQ, release);\n+\n+    \/\/ The owner may be anonymous and we removed the last obj entry in\n+    \/\/ the lock-stack. This loses the information about the owner.\n+    \/\/ Write the thread to the owner field so the runtime knows the owner.\n+    str(rthread, Address(t2_owner_addr));\n+    b(slow_path);\n+\n+    bind(release);\n+    \/\/ Set owner to null.\n+    \/\/ Release to satisfy the JMM\n+    stlr(zr, t2_owner_addr);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":76,"deletions":70,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -6783,2 +6783,4 @@\n-  \/\/ Clear cache in case fast locking succeeds.\n-  str(zr, Address(basic_lock, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::object_monitor_cache_offset_in_bytes()))));\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    str(zr, Address(basic_lock, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::object_monitor_cache_offset_in_bytes()))));\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -116,0 +116,4 @@\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address succ_address{monitor, ObjectMonitor::succ_offset() - monitor_tag};\n+    const Address owner_address{monitor, ObjectMonitor::owner_offset() - monitor_tag};\n+\n@@ -117,1 +121,1 @@\n-    __ cmpptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), NULL_WORD);\n+    __ cmpptr(succ_address, NULL_WORD);\n@@ -121,1 +125,1 @@\n-    __ movptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n+    __ movptr(owner_address, NULL_WORD);\n@@ -128,1 +132,1 @@\n-    __ cmpptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), NULL_WORD);\n+    __ cmpptr(succ_address, NULL_WORD);\n@@ -137,1 +141,1 @@\n-    __ lock(); __ cmpxchgptr(_thread, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n+    __ lock(); __ cmpxchgptr(_thread, owner_address);\n","filename":"src\/hotspot\/cpu\/x86\/c2_CodeStubs_x86.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -952,2 +952,4 @@\n-  \/\/ Clear cache in case fast locking succeeds.\n-  movptr(Address(box, BasicLock::object_monitor_cache_offset_in_bytes()), 0);\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    movptr(Address(box, BasicLock::object_monitor_cache_offset_in_bytes()), 0);\n+  }\n@@ -968,1 +970,1 @@\n-    const Register top = rax_reg;\n+    const Register top = UseObjectMonitorTable ? rax_reg : box;\n@@ -995,0 +997,4 @@\n+    if (UseObjectMonitorTable) {\n+      \/\/ Need to reload top, clobbered by CAS.\n+      movl(top, Address(thread, JavaThread::lock_stack_top_offset()));\n+    }\n@@ -997,1 +1003,0 @@\n-    movl(top, Address(thread, JavaThread::lock_stack_top_offset()));\n@@ -1009,4 +1014,1 @@\n-      \/\/ Untag the monitor.\n-      assert(mark == monitor, \"should be same\");\n-      subptr(monitor, markWord::monitor_value);\n-\n+      assert(mark == monitor, \"should be the same here\");\n@@ -1015,4 +1017,1 @@\n-      if (!OMUseC2Cache) {\n-        jmp(slow_path);\n-      } else {\n-        if (OMCacheHitRate) increment(Address(thread, JavaThread::lock_lookup_offset()));\n+      if (OMCacheHitRate) increment(Address(thread, JavaThread::lock_lookup_offset()));\n@@ -1020,2 +1019,2 @@\n-        \/\/ Fetch ObjectMonitor* from the cache or take the slow-path.\n-        Label monitor_found;\n+      \/\/ Fetch ObjectMonitor* from the cache or take the slow-path.\n+      Label monitor_found;\n@@ -1023,2 +1022,2 @@\n-        \/\/ Load cache address\n-        lea(t, Address(thread, JavaThread::om_cache_oops_offset()));\n+      \/\/ Load cache address\n+      lea(t, Address(thread, JavaThread::om_cache_oops_offset()));\n@@ -1026,7 +1025,6 @@\n-        const int num_unrolled = MIN2(OMC2UnrollCacheEntries, OMCacheSize);\n-        for (int i = 0; i < num_unrolled; i++) {\n-          cmpptr(obj, Address(t));\n-          jccb(Assembler::equal, monitor_found);\n-          if (i + 1 != num_unrolled) {\n-            increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n-          }\n+      const int num_unrolled = MIN2(OMC2UnrollCacheEntries, OMCacheSize);\n+      for (int i = 0; i < num_unrolled; i++) {\n+        cmpptr(obj, Address(t));\n+        jccb(Assembler::equal, monitor_found);\n+        if (i + 1 != num_unrolled) {\n+          increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n@@ -1034,0 +1032,1 @@\n+      }\n@@ -1035,5 +1034,5 @@\n-        if (num_unrolled == 0 || (OMC2UnrollCacheLookupLoopTail && num_unrolled != OMCacheSize)) {\n-          if (num_unrolled != 0) {\n-            \/\/ Loop after unrolling, advance iterator.\n-            increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n-          }\n+      if (num_unrolled == 0 || (OMC2UnrollCacheLookupLoopTail && num_unrolled != OMCacheSize)) {\n+        if (num_unrolled != 0) {\n+          \/\/ Loop after unrolling, advance iterator.\n+          increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+        }\n@@ -1041,1 +1040,1 @@\n-          Label loop;\n+        Label loop;\n@@ -1043,2 +1042,2 @@\n-          \/\/ Search for obj in cache.\n-          bind(loop);\n+        \/\/ Search for obj in cache.\n+        bind(loop);\n@@ -1046,3 +1045,3 @@\n-          \/\/ Check for match.\n-          cmpptr(obj, Address(t));\n-          jccb(Assembler::equal, monitor_found);\n+        \/\/ Check for match.\n+        cmpptr(obj, Address(t));\n+        jccb(Assembler::equal, monitor_found);\n@@ -1050,13 +1049,7 @@\n-          \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n-          cmpptr(Address(t), 1);\n-          jcc(Assembler::below, slow_path); \/\/ 0 check, but with ZF=0 when *t == 0\n-          increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n-          jmpb(loop);\n-        } else {\n-          jmp(slow_path);\n-        }\n-\n-        \/\/ Cache hit.\n-        bind(monitor_found);\n-        movptr(monitor, Address(t, OMCache::oop_to_monitor_difference()));\n-        if (OMCacheHitRate) increment(Address(thread, JavaThread::lock_hit_offset()));\n+        \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n+        cmpptr(Address(t), 1);\n+        jcc(Assembler::below, slow_path); \/\/ 0 check, but with ZF=0 when *t == 0\n+        increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+        jmpb(loop);\n+      } else {\n+        jmp(slow_path);\n@@ -1064,0 +1057,5 @@\n+\n+      \/\/ Cache hit.\n+      bind(monitor_found);\n+      movptr(monitor, Address(t, OMCache::oop_to_monitor_difference()));\n+      if (OMCacheHitRate) increment(Address(thread, JavaThread::lock_hit_offset()));\n@@ -1065,0 +1063,3 @@\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address recursions_address{monitor, ObjectMonitor::recursions_offset() - monitor_tag};\n+    const Address owner_address{monitor, ObjectMonitor::owner_offset() - monitor_tag};\n@@ -1070,2 +1071,2 @@\n-    xorptr(rax, rax);\n-    lock(); cmpxchgptr(thread, Address(monitor, ObjectMonitor::owner_offset()));\n+    xorptr(rax_reg, rax_reg);\n+    lock(); cmpxchgptr(thread, owner_address);\n@@ -1075,1 +1076,1 @@\n-    cmpptr(thread, rax);\n+    cmpptr(thread, rax_reg);\n@@ -1079,1 +1080,1 @@\n-    increment(Address(monitor, ObjectMonitor::recursions_offset()));\n+    increment(recursions_address);\n@@ -1128,1 +1129,1 @@\n-  const Register top = t;\n+  const Register top = UseObjectMonitorTable ? t : reg_rax;\n@@ -1148,0 +1149,5 @@\n+    if (!UseObjectMonitorTable) {\n+      \/\/ Prefetch mark.\n+      movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    }\n+\n@@ -1163,2 +1169,4 @@\n-    \/\/ Load mark.\n-    movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    if (UseObjectMonitorTable) {\n+      \/\/ Load mark.\n+      movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    }\n@@ -1187,2 +1195,3 @@\n-    const Register mark = t;\n-    movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    if (UseObjectMonitorTable) {\n+      movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    }\n@@ -1197,1 +1206,0 @@\n-      \/\/ Untag the monitor.\n@@ -1199,2 +1207,0 @@\n-      movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n-      subptr(monitor, markWord::monitor_value);\n@@ -1202,1 +1208,0 @@\n-\n@@ -1204,8 +1209,5 @@\n-      if (!OMUseC2Cache) {\n-        jmp(slow_path);\n-      } else {\n-        if (OMCacheHitRate) increment(Address(thread, JavaThread::unlock_lookup_offset()));\n-        movptr(monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n-        \/\/ null check with ZF == 0, no valid pointer below alignof(ObjectMonitor*)\n-        cmpptr(monitor, alignof(ObjectMonitor*));\n-        jcc(Assembler::below, slow_path);\n+      if (OMCacheHitRate) increment(Address(thread, JavaThread::unlock_lookup_offset()));\n+      movptr(monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+      \/\/ null check with ZF == 0, no valid pointer below alignof(ObjectMonitor*)\n+      cmpptr(monitor, alignof(ObjectMonitor*));\n+      jcc(Assembler::below, slow_path);\n@@ -1213,2 +1215,1 @@\n-        if (OMCacheHitRate) increment(Address(thread, JavaThread::unlock_hit_offset()));\n-      }\n+      if (OMCacheHitRate) increment(Address(thread, JavaThread::unlock_hit_offset()));\n@@ -1216,0 +1217,5 @@\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address recursions_address{monitor, ObjectMonitor::recursions_offset() - monitor_tag};\n+    const Address cxq_address{monitor, ObjectMonitor::cxq_offset() - monitor_tag};\n+    const Address EntryList_address{monitor, ObjectMonitor::EntryList_offset() - monitor_tag};\n+    const Address owner_address{monitor, ObjectMonitor::owner_offset() - monitor_tag};\n@@ -1220,1 +1226,1 @@\n-    cmpptr(Address(monitor, ObjectMonitor::recursions_offset()), 0);\n+    cmpptr(recursions_address, 0);\n@@ -1224,2 +1230,2 @@\n-    movptr(reg_rax, Address(monitor, ObjectMonitor::cxq_offset()));\n-    orptr(reg_rax, Address(monitor, ObjectMonitor::EntryList_offset()));\n+    movptr(reg_rax, cxq_address);\n+    orptr(reg_rax, EntryList_address);\n@@ -1229,1 +1235,1 @@\n-    movptr(Address(monitor, ObjectMonitor::owner_offset()), NULL_WORD);\n+    movptr(owner_address, NULL_WORD);\n@@ -1234,1 +1240,1 @@\n-    decrement(Address(monitor, ObjectMonitor::recursions_offset()));\n+    decrement(recursions_address);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":81,"deletions":75,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -10351,2 +10351,4 @@\n-  \/\/ Clear cache in case fast locking succeeds.\n-  movptr(Address(basic_lock, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::object_monitor_cache_offset_in_bytes()))), 0);\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    movptr(Address(basic_lock, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::object_monitor_cache_offset_in_bytes()))), 0);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-    if (print_monitor_info && LockingMode != LM_LIGHTWEIGHT) {\n+    if (print_monitor_info && !UseObjectMonitorTable) {\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -243,2 +243,5 @@\n-    return LockingMode == LM_LIGHTWEIGHT  ? UseObjectMonitorTable ? false : lockbits == monitor_value   \/\/ no displace mark or monitor?\n-                                         : (lockbits & unlocked_value) == 0; \/\/ monitor | stack-locked?\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      return !UseObjectMonitorTable && lockbits == monitor_value;\n+    }\n+    \/\/ monitor (0b10) | stack-locked (0b00)?\n+    return (lockbits & unlocked_value) == 0;\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4581,13 +4581,14 @@\n-  \/\/ Test the header to see if it is safe to read w.r.t. locking.\n-  Node *lock_mask      = _gvn.MakeConX(markWord::lock_mask_in_place);\n-  Node *lmasked_header = _gvn.transform(new AndXNode(header, lock_mask));\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    Node *monitor_val   = _gvn.MakeConX(markWord::monitor_value);\n-    Node *chk_monitor   = _gvn.transform(new CmpXNode(lmasked_header, monitor_val));\n-    Node *test_monitor  = _gvn.transform(new BoolNode(chk_monitor, BoolTest::eq));\n-\n-    generate_slow_guard(test_monitor, slow_region);\n-  } else {\n-    Node *unlocked_val      = _gvn.MakeConX(markWord::unlocked_value);\n-    Node *chk_unlocked      = _gvn.transform(new CmpXNode(lmasked_header, unlocked_val));\n-    Node *test_not_unlocked = _gvn.transform(new BoolNode(chk_unlocked, BoolTest::ne));\n+  if (!UseObjectMonitorTable) {\n+    \/\/ Test the header to see if it is safe to read w.r.t. locking.\n+    Node *lock_mask      = _gvn.MakeConX(markWord::lock_mask_in_place);\n+    Node *lmasked_header = _gvn.transform(new AndXNode(header, lock_mask));\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      Node *monitor_val   = _gvn.MakeConX(markWord::monitor_value);\n+      Node *chk_monitor   = _gvn.transform(new CmpXNode(lmasked_header, monitor_val));\n+      Node *test_monitor  = _gvn.transform(new BoolNode(chk_monitor, BoolTest::eq));\n+\n+      generate_slow_guard(test_monitor, slow_region);\n+    } else {\n+      Node *unlocked_val      = _gvn.MakeConX(markWord::unlocked_value);\n+      Node *chk_unlocked      = _gvn.transform(new CmpXNode(lmasked_header, unlocked_val));\n+      Node *test_not_unlocked = _gvn.transform(new BoolNode(chk_unlocked, BoolTest::ne));\n@@ -4595,1 +4596,2 @@\n-    generate_slow_guard(test_not_unlocked, slow_region);\n+      generate_slow_guard(test_not_unlocked, slow_region);\n+    }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2952,1 +2952,0 @@\n-#ifdef _LP64\n@@ -2958,0 +2957,1 @@\n+#ifdef _LP64\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1982,2 +1982,0 @@\n-  product(bool, OMUseC2Cache, true, \"\")                                     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -240,3 +240,0 @@\n-  \/\/ Lightweight locking fetches ObjectMonitor references from a cache\n-  \/\/ instead of the markWord and doesn't work with tagged values.\n-  \/\/\n@@ -244,1 +241,1 @@\n-    ((in_bytes(ObjectMonitor::f ## _offset())) - (LockingMode == LM_LIGHTWEIGHT ? 0 : checked_cast<int>(markWord::monitor_value)))\n+    ((in_bytes(ObjectMonitor::f ## _offset())) - checked_cast<int>(markWord::monitor_value))\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-    if (VM.getVM().getCommandLineFlag(\"LockingMode\").getInt() == LockingMode.getLightweight()) {\n+    if (VM.getVM().getCommandLineFlag(\"UseObjectMonitorTable\").getBool()) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Mark.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-      if (VM.getVM().getCommandLineFlag(\"LockingMode\").getInt() == LockingMode.getLightweight()) {\n+      if (VM.getVM().getCommandLineFlag(\"UseObjectMonitorTable\").getBool()) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ObjectSynchronizer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}