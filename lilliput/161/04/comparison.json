{"files":[{"patch":"@@ -61,1 +61,1 @@\n-      return (uintx)value->hash_lightweight_locking();\n+      return (uintx)value->hash();\n@@ -107,1 +107,1 @@\n-      return _monitor->hash_lightweight_locking();\n+      return _monitor->hash();\n@@ -309,1 +309,1 @@\n-       assert(obj->mark().hash() == om->hash_lightweight_locking(), \"hash must match\");\n+       assert(obj->mark().hash() == om->hash(), \"hash must match\");\n@@ -399,1 +399,1 @@\n-  monitor->set_hash_lightweight_locking(hash);\n+  monitor->set_hash(hash);\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-  _header(markWord::zero()),\n+  _metadata(0),\n@@ -2204,1 +2204,1 @@\n-\/\/   _header = 0x0000000000000001\n+\/\/   _metadata = 0x0000000000000001\n@@ -2233,1 +2233,1 @@\n-  st->print_cr(\"  _header = \" INTPTR_FORMAT, header_value());\n+  st->print_cr(\"  _metadata = \" INTPTR_FORMAT, _metadata);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-\/\/ - The _header field must be at offset 0 because the displaced header\n+\/\/ - The _metadata field must be at offset 0 because the displaced header\n@@ -79,1 +79,1 @@\n-\/\/ - The _header and _owner fields should be separated by enough space\n+\/\/ - The _metadata and _owner fields should be separated by enough space\n@@ -83,1 +83,1 @@\n-\/\/     _header\n+\/\/     _metadata\n@@ -87,0 +87,1 @@\n+\/\/     <optional padding>\n@@ -110,10 +111,9 @@\n-\/\/   - Separating _owner from the <remaining_fields> by enough space to\n-\/\/     avoid false sharing might be profitable. Given\n-\/\/     http:\/\/blogs.oracle.com\/dave\/entry\/cas_and_cache_trivia_invalidate\n-\/\/     we know that the CAS in monitorenter will invalidate the line\n-\/\/     underlying _owner. We want to avoid an L1 data cache miss on that\n-\/\/     same line for monitorexit. Putting these <remaining_fields>:\n-\/\/     _recursions, _EntryList, _cxq, and _succ, all of which may be\n-\/\/     fetched in the inflated unlock path, on a different cache line\n-\/\/     would make them immune to CAS-based invalidation from the _owner\n-\/\/     field.\n+\/\/ - Separating _owner from the <remaining_fields> by enough space to\n+\/\/   avoid false sharing might be profitable. Given that the CAS in\n+\/\/   monitorenter will invalidate the line underlying _owner. We want\n+\/\/   to avoid an L1 data cache miss on that same line for monitorexit.\n+\/\/   Putting these <remaining_fields>:\n+\/\/   _recursions, _EntryList, _cxq, and _succ, all of which may be\n+\/\/   fetched in the inflated unlock path, on a different cache line\n+\/\/   would make them immune to CAS-based invalidation from the _owner\n+\/\/   field.\n@@ -121,3 +121,3 @@\n-\/\/   - The _recursions field should be of type int, or int32_t but not\n-\/\/     intptr_t. There's no reason to use a 64-bit type for this field\n-\/\/     in a 64-bit JVM.\n+\/\/ - The _recursions field should be of type int, or int32_t but not\n+\/\/   intptr_t. There's no reason to use a 64-bit type for this field\n+\/\/   in a 64-bit JVM.\n@@ -135,3 +135,7 @@\n-  \/\/ The sync code expects the header field to be at offset zero (0).\n-  \/\/ Enforced by the assert() in header_addr().\n-  volatile markWord _header;        \/\/ displaced object header word - mark\n+  \/\/ The sync code expects the metadata field to be at offset zero (0).\n+  \/\/ Enforced by the assert() in metadata_addr().\n+  \/\/ * LM_LIGHTWEIGHT\n+  \/\/ Contains the _object's hashCode.\n+  \/\/ * LM_LEGACY, LM_MONITOR\n+  \/\/ Contains the displaced object header word - mark\n+  volatile uintptr_t _metadata;     \/\/ metadata\n@@ -139,2 +143,2 @@\n-  \/\/ Separate _header and _owner on different cache lines since both can\n-  \/\/ have busy multi-threaded access. _header and _object are set at initial\n+  \/\/ Separate _metadata and _owner on different cache lines since both can\n+  \/\/ have busy multi-threaded access. _metadata and _object are set at initial\n@@ -142,2 +146,2 @@\n-  \/\/ its cache line with _header.\n-  DEFINE_PAD_MINUS_SIZE(0, OM_CACHE_LINE_SIZE, sizeof(volatile markWord) +\n+  \/\/ its cache line with _metadata.\n+  DEFINE_PAD_MINUS_SIZE(0, OM_CACHE_LINE_SIZE, sizeof(_metadata) +\n@@ -187,1 +191,1 @@\n- protected:\n+\n@@ -219,1 +223,1 @@\n-  static ByteSize header_offset()      { return byte_offset_of(ObjectMonitor, _header); }\n+  static ByteSize metadata_offset()    { return byte_offset_of(ObjectMonitor, _metadata); }\n@@ -243,4 +247,6 @@\n-  markWord           header() const;\n-  uintptr_t          header_value() const;\n-  volatile markWord* header_addr();\n-  void               set_header(markWord hdr);\n+  uintptr_t           metadata() const;\n+  void                set_metadata(uintptr_t value);\n+  volatile uintptr_t* metadata_addr();\n+\n+  markWord            header() const;\n+  void                set_header(markWord hdr);\n@@ -248,3 +254,2 @@\n-  \/\/ TODO[OMWorld]: Cleanup these names, the storage `_header` usage depends on the locking mode.\n-  intptr_t           hash_lightweight_locking() const;\n-  void               set_hash_lightweight_locking(intptr_t hash);\n+  intptr_t            hash() const;\n+  void                set_hash(intptr_t hash);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":37,"deletions":32,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -56,3 +56,6 @@\n-inline markWord ObjectMonitor::header() const {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"Lightweight locking does not use header\");\n-  return Atomic::load(&_header);\n+inline uintptr_t ObjectMonitor::metadata() const {\n+  return Atomic::load(&_metadata);\n+}\n+\n+inline void ObjectMonitor::set_metadata(uintptr_t value) {\n+  Atomic::store(&_metadata, value);\n@@ -61,2 +64,4 @@\n-inline uintptr_t ObjectMonitor::header_value() const {\n-  return Atomic::load(&_header).value();\n+inline volatile uintptr_t* ObjectMonitor::metadata_addr() {\n+  STATIC_ASSERT(std::is_standard_layout<ObjectMonitor>::value);\n+  STATIC_ASSERT(offsetof(ObjectMonitor, _metadata) == 0);\n+  return &_metadata;\n@@ -65,2 +70,3 @@\n-inline volatile markWord* ObjectMonitor::header_addr() {\n-  return &_header;\n+inline markWord ObjectMonitor::header() const {\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"Lightweight locking does not use header\");\n+  return markWord(metadata());\n@@ -71,1 +77,1 @@\n-  Atomic::store(&_header, hdr);\n+  set_metadata(hdr.value());\n@@ -74,1 +80,1 @@\n-inline intptr_t ObjectMonitor::hash_lightweight_locking() const {\n+inline intptr_t ObjectMonitor::hash() const {\n@@ -76,1 +82,1 @@\n-  return Atomic::load(&_header).hash();\n+  return metadata();\n@@ -79,1 +85,1 @@\n-inline void ObjectMonitor::set_hash_lightweight_locking(intptr_t hash) {\n+inline void ObjectMonitor::set_hash(intptr_t hash) {\n@@ -81,1 +87,1 @@\n-  Atomic::store(&_header, markWord::zero().copy_set_hash(hash));\n+  set_metadata(hash);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1077,1 +1077,1 @@\n-      uintptr_t v = Atomic::cmpxchg((volatile uintptr_t*)monitor->header_addr(), mark.value(), temp.value());\n+      uintptr_t v = Atomic::cmpxchg(monitor->metadata_addr(), mark.value(), temp.value());\n@@ -1987,1 +1987,1 @@\n-  if (n->header_value() == 0) {\n+  if (n->metadata() == 0) {\n@@ -1989,1 +1989,1 @@\n-                  \"have non-null _header field.\", p2i(n));\n+                  \"have non-null _metadata (header\/hash) field.\", p2i(n));\n@@ -2037,1 +2037,1 @@\n-        const intptr_t hash = LockingMode == LM_LIGHTWEIGHT ? monitor->hash_lightweight_locking() : monitor->header().hash();\n+        const intptr_t hash = LockingMode == LM_LIGHTWEIGHT ? monitor->hash() : monitor->header().hash();\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -781,1 +781,1 @@\n-  volatile_nonstatic_field(ObjectMonitor,      _header,                                       markWord)                              \\\n+  volatile_nonstatic_field(ObjectMonitor,      _metadata,                                     uintptr_t)                             \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-    sun.jvm.hotspot.types.Field f = type.getField(\"_header\");\n-    headerFieldOffset = f.getOffset();\n+    sun.jvm.hotspot.types.Field f = type.getField(\"_metadata\");\n+    metadataFieldOffset = f.getOffset();\n@@ -68,1 +68,1 @@\n-    return new Mark(addr.addOffsetTo(headerFieldOffset));\n+    return new Mark(addr.addOffsetTo(metadataFieldOffset));\n@@ -117,1 +117,1 @@\n-  private static long          headerFieldOffset;\n+  private static long          metadataFieldOffset;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ObjectMonitor.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- uint cache_line_size = VM_Version::L1_data_cache_line_size();\n+  uint cache_line_size = VM_Version::L1_data_cache_line_size();\n@@ -32,9 +32,1 @@\n- if (cache_line_size != 0) {\n-   \/\/ We were able to determine the L1 data cache line size so\n-   \/\/ do some cache line specific sanity checks\n-   EXPECT_EQ((size_t) 0, sizeof (PaddedEnd<ObjectMonitor>) % cache_line_size)\n-        << \"PaddedEnd<ObjectMonitor> size is not a \"\n-        << \"multiple of a cache line which permits false sharing. \"\n-        << \"sizeof(PaddedEnd<ObjectMonitor>) = \"\n-        << sizeof (PaddedEnd<ObjectMonitor>)\n-        << \"; cache_line_size = \" << cache_line_size;\n+  if (cache_line_size != 0) {\n@@ -42,3 +34,11 @@\n-   EXPECT_GE((size_t) in_bytes(ObjectMonitor::owner_offset()), cache_line_size)\n-        << \"the _header and _owner fields are closer \"\n-        << \"than a cache line which permits false sharing.\";\n+    EXPECT_EQ(in_bytes(ObjectMonitor::metadata_offset()), 0)\n+         << \"_metadata at a non 0 offset. metadata_offset = \"\n+         << in_bytes(ObjectMonitor::metadata_offset());\n+\n+    EXPECT_GE((size_t) in_bytes(ObjectMonitor::owner_offset()), cache_line_size)\n+         << \"the _metadata and _owner fields are closer \"\n+         << \"than a cache line which permits false sharing.\";\n+\n+    EXPECT_GE((size_t) in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), cache_line_size)\n+         << \"the _owner and _recursions fields are closer \"\n+         << \"than a cache line which permits false sharing.\";\n","filename":"test\/hotspot\/gtest\/runtime\/test_objectMonitor.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"}]}