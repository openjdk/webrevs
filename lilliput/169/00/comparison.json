{"files":[{"patch":"@@ -1021,0 +1021,42 @@\n+\n+bool LightweightSynchronizer::quick_enter(oop obj, JavaThread* current, BasicLock * lock) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  assert(current->thread_state() == _thread_in_Java, \"must be\");\n+  assert(obj != nullptr, \"must be\");\n+  NoSafepointVerifier nsv;\n+\n+  CacheSetter cache_setter(current, lock);\n+\n+  LockStack& lock_stack = current->lock_stack();\n+  if (lock_stack.is_full()) {\n+    \/\/ Always go into runtime if the lock stack is full.\n+    return false;\n+  }\n+\n+  if (lock_stack.try_recursive_enter(obj)) {\n+    \/\/ Recursive lock successful.\n+    current->inc_held_monitor_count();\n+    return true;\n+  }\n+\n+  const markWord mark = obj->mark();\n+\n+  if (mark.has_monitor()) {\n+    ObjectMonitor* const monitor = current->om_get_from_monitor_cache(obj);\n+\n+    if (monitor == nullptr) {\n+      \/\/ Take the slow-path on a cache miss.\n+      return false;\n+    }\n+\n+    if (monitor->try_enter(current)) {\n+      \/\/ ObjectMonitor enter successful.\n+      cache_setter.set_monitor(monitor);\n+      current->inc_held_monitor_count();\n+      return true;\n+    }\n+  }\n+\n+  \/\/ Slow-path.\n+  return false;\n+}\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+\n+  static bool quick_enter(oop obj, JavaThread* current, BasicLock* Lock);\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -411,0 +411,1 @@\n+\n@@ -418,10 +419,1 @@\n-    LockStack& lock_stack = current->lock_stack();\n-    if (lock_stack.is_full()) {\n-      \/\/ Always go into runtime if the lock stack is full.\n-      return false;\n-    }\n-    if (lock_stack.try_recursive_enter(obj)) {\n-      \/\/ Recursive lock successful.\n-      current->inc_held_monitor_count();\n-      return true;\n-    }\n+    return LightweightSynchronizer::quick_enter(obj, current, lock);\n@@ -433,10 +425,1 @@\n-    ObjectMonitor* m = nullptr;\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      m = current->om_get_from_monitor_cache(obj);\n-      if (m == nullptr) {\n-        \/\/ Take the slow-path on a cache miss.\n-        return false;\n-      }\n-    } else {\n-      m = ObjectSynchronizer::read_monitor(mark);\n-    }\n+    ObjectMonitor* const m = ObjectSynchronizer::read_monitor(mark);\n@@ -462,12 +445,10 @@\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ This Java Monitor is inflated so obj's header will never be\n-      \/\/ displaced to this thread's BasicLock. Make the displaced header\n-      \/\/ non-null so this BasicLock is not seen as recursive nor as\n-      \/\/ being locked. We do this unconditionally so that this thread's\n-      \/\/ BasicLock cannot be mis-interpreted by any stack walkers. For\n-      \/\/ performance reasons, stack walkers generally first check for\n-      \/\/ stack-locking in the object's header, the second check is for\n-      \/\/ recursive stack-locking in the displaced header in the BasicLock,\n-      \/\/ and last are the inflated Java Monitor (ObjectMonitor) checks.\n-      lock->set_displaced_header(markWord::unused_mark());\n-    }\n+    \/\/ This Java Monitor is inflated so obj's header will never be\n+    \/\/ displaced to this thread's BasicLock. Make the displaced header\n+    \/\/ non-null so this BasicLock is not seen as recursive nor as\n+    \/\/ being locked. We do this unconditionally so that this thread's\n+    \/\/ BasicLock cannot be mis-interpreted by any stack walkers. For\n+    \/\/ performance reasons, stack walkers generally first check for\n+    \/\/ stack-locking in the object's header, the second check is for\n+    \/\/ recursive stack-locking in the displaced header in the BasicLock,\n+    \/\/ and last are the inflated Java Monitor (ObjectMonitor) checks.\n+    lock->set_displaced_header(markWord::unused_mark());\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":13,"deletions":32,"binary":false,"changes":45,"status":"modified"}]}