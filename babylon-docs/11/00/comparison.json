{"files":[{"patch":"@@ -2,0 +2,1 @@\n+\n@@ -3,1 +4,2 @@\n-#### February 2024 {.date}\n+\n+#### February 2024, Updated Dec 2025 {.date}\n@@ -9,1 +11,1 @@\n-Code Reflection is a Java platform feature being researched and developed under \n+Code Reflection is a Java platform feature being researched and developed under\n@@ -66,2 +68,2 @@\n-method, `f` say, we need to write a Java program, `D` say, that implements the\n-rules of differentiation and applies those rules to a *symbolic representation*\n+method, `f` say, we need to write a Java library that implements the rules of\n+differentiation and applies those rules to a *symbolic representation*\n@@ -70,2 +72,2 @@\n-Program `D` can use *Code Reflection* to obtain a symbolic representation of\n-method `f`, called a *code model*. `D` can then traverse symbolic information\n+The library can use *Code Reflection* to obtain a symbolic representation of\n+method `f`, called a *code model*, which can then traverse symbolic information\n@@ -78,3 +80,3 @@\n-`D` will produce a new code model, representing `f`', containing operations that\n-compute the differential, which can then be compiled to bytecode and invoked as\n-a Java program.\n+The library will produce a new code model, representing `f`', containing\n+operations that compute the differential, which can then be compiled to bytecode\n+and invoked as a Java program.\n@@ -89,2 +91,1 @@\n-Program `D` could be encapsulated in a Java library. We might ideally use it\n-like this:\n+Ideally a user might use the library like this:\n@@ -94,1 +95,1 @@\n-@CodeReflection\n+@Reflect\n@@ -99,1 +100,2 @@\n-Function<double[], double[]> g_f = AD.gradientFunction(this::f);\n+Method fm = T.class.getDeclaredMethod(\"f\", double.class, double.class);\n+Function<double[], double[]> g_f = AD.gradientFunction(fm);\n@@ -103,6 +105,5 @@\n-We annotate our function to be differentiated, method `f`,\n-with `@CodeReflection`. This ensures there is a code model available for `f`,\n-and that it is accessible under similar access control rules as for its\n-invocation . Then we call the method `AD.gradientFunction` passing `f` as a\n-method reference. The method reference is targeted to a code reflection type\n-whose instance gives access to `f`'s code model.\n+We annotate our function to be differentiated, method `f`, with `@Reflect`. This\n+ensures there is a code model available for `f`, and that it is accessible under\n+similar access control rules as for its invocation. Using the reflection API we\n+find the `java.lang.reflect.Method` instance of `f`, `fm`, and then call the\n+method `AD.gradientFunction` passing `fm` as an argument.\n@@ -110,2 +111,2 @@\n-How can the library author of method `gradientFunction` differentiate\n-method `f`?\n+How can the library author of method `gradientFunction` differentiate method\n+`f`?\n@@ -134,1 +135,1 @@\n-@CodeReflection\n+@Reflect\n@@ -140,1 +141,1 @@\n-It is annotated it with `@CodeReflection`. When it is compiled a code model will\n+It is annotated it with `@Reflect`. When it is compiled a code model will\n@@ -158,6 +159,6 @@\n-Fundamentally, we need to implement a method that accepts a code model and a\n-reference to an independent variable to differentiate against, and produces a\n-new code model that is the partial derivative of the input. We will focus on\n-this aspect, although it is not as user-friendly as the prior example (\n-using program `D`, where we can observe the author only minimally used the Code\n-Reflection API to annotate their method).\n+We need to implement a method that accepts a code model and a reference to an\n+independent variable to differentiate against, and produces a new code model\n+that is the partial derivative of the input. We will focus on this aspect,\n+although it is not as user-friendly as the prior example (using program `D`,\n+where we can observe the author only minimally used the Code Reflection API to\n+annotate their method).\n@@ -166,1 +167,1 @@\n-obtain its code model using reflection we would do this.\n+obtain its code model using reflection we do this.\n@@ -170,1 +171,1 @@\n-Optional<CoreOps.FuncOp> o = fm.getCodeModel();\n+Optional<CoreOps.FuncOp> o = Op.ofMethod(fm);\n@@ -175,2 +176,2 @@\n-and then ask it for its code model by invoking the method `getCodeModel`. Only\n-methods annotated with `@CodeReflection` will have code models, hence this\n+and then obtain its code model by invoking the method `Op.ofMethod`. Only\n+methods annotated with `@Reflect` will have code models, hence this\n@@ -198,2 +199,2 @@\n-model a Java lambda expression (instances of `CoreOps.LambdaOp`), or model a\n-Java `try` statement (instances of `ExtendedOps.JavaTryOp`).\n+model a Java lambda expression (instances of `JavaOp.LambdaOp`), or model a\n+Java `try` statement (instances of `JavaOp.TryOp`).\n@@ -201,2 +202,2 @@\n-What does the code model of `f` look like? We can serialize its in-memory form (\n-the instance of `CoreOps.FuncOp`) to a textual form.\n+What does the code model of `f` look like? We can serialize its in-memory form\n+(the instance of `CoreOps.FuncOp`) to a textual form.\n@@ -211,15 +212,16 @@\n-func @\"f\" (%0 : double, %1 : double)double -> {\n-    %2 : Var<double> = var %0 @\"x\";\n-    %3 : Var<double> = var %1 @\"y\";\n-    %4 : double = var.load %2;\n-    %5 : double = var.load %2;\n-    %6 : double = var.load %3;\n-    %7 : double = mul %5 %6;\n-    %8 : double = invoke %7 @\"java.lang.Math::sin(double)double\";\n-    %9 : double = neg %8;\n-    %10 : double = var.load %3;\n-    %11 : double = add %9 %10;\n-    %12 : double = mul %4 %11;\n-    %13 : double = constant @\"4.0\";\n-    %14 : double = mul %12 %13;\n-    return %14;\n+func @loc=\"79:5:file:\/\/\/...\/TestForwardAutoDiff.java\" @\"f\"\n+(%0 : java.type:\"double\", %1 : java.type:\"double\")java.type:\"double\" -> {\n+    %2 : Var<java.type:\"double\"> = var %0 @loc=\"79:5\" @\"x\";\n+    %3 : Var<java.type:\"double\"> = var %1 @loc=\"79:5\" @\"y\";\n+    %4 : java.type:\"double\" = var.load %2 @loc=\"81:16\";\n+    %5 : java.type:\"double\" = var.load %2 @loc=\"81:31\";\n+    %6 : java.type:\"double\" = var.load %3 @loc=\"81:35\";\n+    %7 : java.type:\"double\" = mul %5 %6 @loc=\"81:31\";\n+    %8 : java.type:\"double\" = invoke %7 @loc=\"81:22\" @java.ref:\"java.lang.Math::sin(double):double\";\n+    %9 : java.type:\"double\" = neg %8 @loc=\"81:21\";\n+    %10 : java.type:\"double\" = var.load %3 @loc=\"81:40\";\n+    %11 : java.type:\"double\" = add %9 %10 @loc=\"81:21\";\n+    %12 : java.type:\"double\" = mul %4 %11 @loc=\"81:16\";\n+    %13 : java.type:\"double\" = constant @loc=\"81:45\" @4.0d;\n+    %14 : java.type:\"double\" = mul %12 %13 @loc=\"81:16\";\n+    return %14 @loc=\"81:9\";\n@@ -238,1 +240,1 @@\n-form, all of which extend from the abstract class `java.lang.reflect.code.Op`.\n+form, all of which extend from the abstract class `jdk.incubator.code.Op`.\n@@ -241,6 +243,6 @@\n-and `y`), each described by a type of `double`, which model `f`'s method\n-parameters. These parameters are used as operands of various operations. Many\n-operations produce operation results, e.g., `%12` the result of a multiplication\n-operation, that are used as operands of subsequent operations, and so on.\n-The `return` operation has a result, again like all other operations, but since\n-that result cannot be meaningfully used we don't present it.\n+and `y`), each described by a type of `java.type:\"double\"`, which model `f`'s\n+method parameters. These parameters are used as operands of various operations.\n+Many operations produce operation results, e.g., `%12` the result of a\n+multiplication operation, that are used as operands of subsequent operations,\n+and so on. The `return` operation has a result, again like all other operations,\n+but since that result cannot be meaningfully used we don't present it.\n@@ -259,2 +261,2 @@\n-variables, binary and unary mathematical operations, or method invocations (\n-e.g., to method `java.lang.Math::sin`).\n+variables, binary and unary mathematical operations, or method invocations\n+(e.g., to method `java.lang.Math::sin`).\n@@ -274,9 +276,10 @@\n-func @\"f\" (%0 : double, %1 : double)double -> {\n-    %2 : double = mul %0 %1;\n-    %3 : double = invoke %2 @\"java.lang.Math::sin(double)double\";\n-    %4 : double = neg %3;\n-    %5 : double = add %4 %1;\n-    %6 : double = mul %0 %5;\n-    %7 : double = constant @\"4.0\";\n-    %8 : double = mul %6 %7;\n-    return %8;\n+func @loc=\"79:5:file:\/\/\/...\/TestForwardAutoDiff.java\" @\"f\" \n+(%0 : java.type:\"double\", %1 : java.type:\"double\")java.type:\"double\" -> {\n+    %2 : java.type:\"double\" = mul %0 %1 @loc=\"81:31\";\n+    %3 : java.type:\"double\" = invoke %2 @loc=\"81:22\" @java.ref:\"java.lang.Math::sin(double):double\";\n+    %4 : java.type:\"double\" = neg %3 @loc=\"81:21\";\n+    %5 : java.type:\"double\" = add %4 %1 @loc=\"81:21\";\n+    %6 : java.type:\"double\" = mul %0 %5 @loc=\"81:16\";\n+    %7 : java.type:\"double\" = constant @loc=\"81:45\" @4.0d;\n+    %8 : java.type:\"double\" = mul %6 %7 @loc=\"81:16\";\n+    return %8 @loc=\"81:9\";\n@@ -295,2 +298,2 @@\n-is used as an operand by the operation that produces the operation result `%2` (\n-the result of a multiplication), and so on.\n+is used as an operand by the operation that produces the operation result `%2`\n+(the result of a multiplication), and so on.\n@@ -370,2 +373,0 @@\n-import static java.lang.reflect.code.op.CoreOps.*;\n-\n@@ -399,0 +400,1 @@\n+    ...\n@@ -402,2 +404,2 @@\n-A map from input operation results to (output) differentiated\n-values, `diffValueMapping` is also constructed. This will be used to keep track\n+A map from input operation results to (output) differentiated values,\n+`diffValueMapping` is also constructed. This will be used to keep track\n@@ -424,1 +426,0 @@\n-    \/\/ Transform f to f' w.r.t ind\n@@ -426,1 +427,1 @@\n-    FuncOp dfcm = fcm.transform(STR.\"d\\{fcm.funcName()}_darg\\{indI}\",\n+    FuncOp dfcm = fcm.transform(String.format(\"d%s_darg%d\", fcm.funcName(), indI),\n@@ -428,1 +429,0 @@\n-                \/\/ Initialization\n@@ -430,7 +430,2 @@\n-                    \/\/ Declare the zero value constant\n-                    zero = block.op(constant(ind.type(), 0.0d));\n-                    \/\/ Declare the one value constant\n-                    Value one = block.op(constant(ind.type(), 1.0d));\n-                    \/\/ The differential of ind is one\n-                    \/\/ For all other parameters it is zero (absence from the map)\n-                    diffValueMapping.put(ind, one);\n+                    \/\/ Initialize\n+                    processBlocks(block);\n@@ -447,1 +442,0 @@\n-                    \/\/ Block is not part of the active set, just copy it\n@@ -455,0 +449,10 @@\n+\n+void processBlocks(Block.Builder block) {\n+    \/\/ Declare constants at start\n+    zero = block.op(constant(ind.type(), 0.0d));\n+    \/\/ The differential of ind is 1\n+    Value one = block.op(constant(ind.type(), 1.0d));\n+    diffValueMapping.put(ind, one);\n+\n+    ...\n+}\n@@ -463,4 +467,5 @@\n-On first encounter we declare a few constant values in the output model by\n-adding constant operations, instances of `ConstantOp`, to the output model.\n-Specifically, we declare the zero constant value of `0.0d`, which will be used\n-as an operand of subsequent operations we add to output model.\n+On first encounter we call `processBlock` that declares a few constant values in\n+the output model by adding constant operations, instances of `ConstantOp`, to\n+the output model. Specifically, we declare the zero constant value of `0.0d`,\n+which will be used as an operand of subsequent operations we add to output\n+model.\n@@ -481,3 +486,2 @@\n-        case ... -> {\n-        }\n-        case CoreOps.MulOp _ -> {\n+        ...\n+        case JavaOp.MulOp _ -> {\n@@ -495,3 +499,3 @@\n-            yield block.op(add(\n-                    block.op(mul(dlhs, outputRhs)),\n-                    block.op(mul(outputLhs, drhs))));\n+            yield block.op(JavaOp.add(\n+                    block.op(JavaOp.mul(dlhs, outputRhs)),\n+                    block.op(JavaOp.mul(outputLhs, drhs))));\n@@ -499,2 +503,3 @@\n-        case CoreOps.InvokeOp c -> {\n-            MethodDesc md = c.invokeDescriptor();\n+        ...\n+        case JavaOp.InvokeOp c -> {\n+            MethodRef md = c.invokeDescriptor();\n@@ -515,2 +520,2 @@\n-                Op.Result cosx = block.op(invoke(J_L_MATH_COS, outputA));\n-                yield block.op(mul(cosx, da));\n+                Result cosx = block.op(JavaOp.invoke(J_L_MATH_COS, outputA));\n+                yield block.op(JavaOp.mul(cosx, da));\n@@ -518,1 +523,1 @@\n-                throw new UnsupportedOperationException(\"Operation not supported: \" + op.opName());\n+                throw new UnsupportedOperationException(\"Operation not supported: \" + op);\n@@ -521,0 +526,1 @@\n+        ...\n@@ -550,2 +556,2 @@\n-which will enable more sophisticated tree-based matching of operations (\n-including on their uses or their operands).\n+which will enable more sophisticated tree-based matching of operations\n+(including on their uses or their operands).\n@@ -560,1 +566,1 @@\n-Optional<CoreOps.FuncOp> o = fm.getCodeModel();\n+Optional<CoreOps.FuncOp> o = Op.ofMethodfm);\n@@ -568,23 +574,24 @@\n-func @\"df_darg0\" (%0 : double, %1 : double)double -> {\n-    %2 : double = constant @\"0.0\";\n-    %3 : double = constant @\"1.0\";\n-    %4 : double = mul %0 %1;\n-    %5 : double = mul %3 %1;\n-    %6 : double = mul %0 %2;\n-    %7 : double = add %5 %6;\n-    %8 : double = invoke %4 @\"java.lang.Math::sin(double)double\";\n-    %9 : double = invoke %4 @\"java.lang.Math::cos(double)double\";\n-    %10 : double = mul %9 %7;\n-    %11 : double = neg %8;\n-    %12 : double = neg %10;\n-    %13 : double = add %11 %1;\n-    %14 : double = add %12 %2;\n-    %15 : double = mul %0 %13;\n-    %16 : double = mul %3 %13;\n-    %17 : double = mul %0 %14;\n-    %18 : double = add %16 %17;\n-    %19 : double = constant @\"4.0\";\n-    %20 : double = mul %15 %19;\n-    %21 : double = mul %18 %19;\n-    %22 : double = mul %15 %2;\n-    %23 : double = add %21 %22;\n+func @loc=\"84:5:file:\/\/\/...\/TestForwardAutoDiff.java\" @\"df_darg0\"\n+(%0 : java.type:\"double\", %1 : java.type:\"double\")java.type:\"double\" -> {\n+    %2 : java.type:\"double\" = constant @0.0d;\n+    %3 : java.type:\"double\" = constant @1.0d;\n+    %4 : java.type:\"double\" = mul %0 %1 @loc=\"86:31\";\n+    %5 : java.type:\"double\" = mul %3 %1;\n+    %6 : java.type:\"double\" = mul %0 %2;\n+    %7 : java.type:\"double\" = add %5 %6;\n+    %8 : java.type:\"double\" = invoke %4 @loc=\"86:22\" @java.ref:\"java.lang.Math::sin(double):double\";\n+    %9 : java.type:\"double\" = invoke %4 @java.ref:\"java.lang.Math::cos(double):double\";\n+    %10 : java.type:\"double\" = mul %9 %7;\n+    %11 : java.type:\"double\" = neg %8 @loc=\"86:21\";\n+    %12 : java.type:\"double\" = neg %10;\n+    %13 : java.type:\"double\" = add %11 %1 @loc=\"86:21\";\n+    %14 : java.type:\"double\" = add %12 %2;\n+    %15 : java.type:\"double\" = mul %0 %13 @loc=\"86:16\";\n+    %16 : java.type:\"double\" = mul %3 %13;\n+    %17 : java.type:\"double\" = mul %0 %14;\n+    %18 : java.type:\"double\" = add %16 %17;\n+    %19 : java.type:\"double\" = constant @loc=\"86:45\" @4.0d;\n+    %20 : java.type:\"double\" = mul %15 %19 @loc=\"86:16\";\n+    %21 : java.type:\"double\" = mul %18 %19;\n+    %22 : java.type:\"double\" = mul %15 %2;\n+    %23 : java.type:\"double\" = add %21 %22;\n@@ -607,2 +614,2 @@\n-We need to transform the code model further to remove redundant operations (\n-commonly referred to as expression elimination). The resulting code model with\n+We need to transform the code model further to remove redundant operations\n+(commonly referred to as expression elimination). The resulting code model with\n@@ -617,14 +624,15 @@\n-func @\"df_darg0\" (%0 : double, %1 : double)double -> {\n-    %2 : double = constant @\"0.0\";\n-    %3 : double = mul %0 %1;\n-    %4 : double = add %1 %2;\n-    %5 : double = invoke %3 @\"java.lang.Math::sin(double)double\";\n-    %6 : double = invoke %3 @\"java.lang.Math::cos(double)double\";\n-    %7 : double = mul %6 %4;\n-    %8 : double = sub %1 %5;\n-    %9 : double = sub %2 %7;\n-    %10 : double = mul %0 %9;\n-    %11 : double = add %8 %10;\n-    %12 : double = constant @\"4.0\";\n-    %13 : double = mul %11 %12;\n-    %14 : double = add %13 %2;\n+func @loc=\"84:5:file:\/\/\/...\/TestForwardAutoDiff.java\" @\"df_darg0\"\n+(%0 : java.type:\"double\", %1 : java.type:\"double\")java.type:\"double\" -> {\n+    %2 : java.type:\"double\" = constant @0.0d;\n+    %3 : java.type:\"double\" = mul %0 %1 @loc=\"86:31\";\n+    %4 : java.type:\"double\" = add %1 %2;\n+    %5 : java.type:\"double\" = invoke %3 @loc=\"86:22\" @java.ref:\"java.lang.Math::sin(double):double\";\n+    %6 : java.type:\"double\" = invoke %3 @java.ref:\"java.lang.Math::cos(double):double\";\n+    %7 : java.type:\"double\" = mul %6 %4;\n+    %8 : java.type:\"double\" = sub %1 %5;\n+    %9 : java.type:\"double\" = sub %2 %7;\n+    %10 : java.type:\"double\" = mul %0 %9;\n+    %11 : java.type:\"double\" = add %8 %10;\n+    %12 : java.type:\"double\" = constant @loc=\"86:45\" @4.0d;\n+    %13 : java.type:\"double\" = mul %11 %12;\n+    %14 : java.type:\"double\" = add %13 %2;\n@@ -655,1 +663,1 @@\n-@CodeReflection\n+@Reflect\n@@ -705,10 +713,11 @@\n-func @\"f\" (%0 : double, %1 : int)double -> {\n-    %2 : Var<double> = var %0 @\"x\";\n-    %3 : Var<int> = var %1 @\"y\";\n-    %4 : double = constant @\"1.0\";\n-    %5 : Var<double> = var %4 @\"o\";\n-    java.for\n-        ()Var<int> -> {\n-            %6 : int = constant @\"0\";\n-            %7 : Var<int> = var %6 @\"i\";\n-            yield %7;\n+func @loc=\"123:5:file:\/\/\/...\/TestForwardAutoDiff.java\" @\"fcf\"\n+(%0 : java.type:\"double\", %1 : java.type:\"int\")java.type:\"double\" -> {\n+    %2 : Var<java.type:\"double\"> = var %0 @loc=\"123:5\" @\"x\";\n+    %3 : Var<java.type:\"int\"> = var %1 @loc=\"123:5\" @\"y\";\n+    %4 : java.type:\"double\" = constant @loc=\"126:20\" @1.0d;\n+    %5 : Var<java.type:\"double\"> = var %4 @loc=\"126:9\" @\"o\";\n+    java.for @loc=\"127:9\"\n+        ()Var<java.type:\"int\"> -> {\n+            %6 : java.type:\"int\" = constant @loc=\"127:22\" @0;\n+            %7 : Var<java.type:\"int\"> = var %6 @loc=\"127:14\" @\"i\";\n+            yield %7 @loc=\"127:9\";\n@@ -716,5 +725,5 @@\n-        (%8 : Var<int>)boolean -> {\n-            %9 : int = var.load %8;\n-            %10 : int = var.load %3;\n-            %11 : boolean = lt %9 %10;\n-            yield %11;\n+        (%8 : Var<java.type:\"int\">)java.type:\"boolean\" -> {\n+            %9 : java.type:\"int\" = var.load %8 @loc=\"127:25\";\n+            %10 : java.type:\"int\" = var.load %3 @loc=\"127:29\";\n+            %11 : java.type:\"boolean\" = lt %9 %10 @loc=\"127:25\";\n+            yield %11 @loc=\"127:9\";\n@@ -722,6 +731,6 @@\n-        (%12 : Var<int>)void -> {\n-            %13 : int = var.load %12;\n-            %14 : int = constant @\"1\";\n-            %15 : int = add %13 %14;\n-            var.store %12 %15;\n-            yield;\n+        (%12 : Var<java.type:\"int\">)java.type:\"void\" -> {\n+            %13 : java.type:\"int\" = var.load %12 @loc=\"127:36\";\n+            %14 : java.type:\"int\" = constant @loc=\"127:40\" @1;\n+            %15 : java.type:\"int\" = add %13 %14 @loc=\"127:36\";\n+            var.store %12 %15 @loc=\"127:32\";\n+            yield @loc=\"127:9\";\n@@ -729,7 +738,7 @@\n-        (%16 : Var<int>)void -> {\n-            java.if\n-                ()boolean -> {\n-                    %17 : int = var.load %16;\n-                    %18 : int = constant @\"1\";\n-                    %19 : boolean = gt %17 %18;\n-                    yield %19;\n+        (%16 : Var<java.type:\"int\">)java.type:\"void\" -> {\n+            java.if @loc=\"128:13\"\n+                ()java.type:\"boolean\" -> {\n+                    %17 : java.type:\"int\" = var.load %16 @loc=\"128:17\";\n+                    %18 : java.type:\"int\" = constant @loc=\"128:21\" @1;\n+                    %19 : java.type:\"boolean\" = gt %17 %18 @loc=\"128:17\";\n+                    yield %19 @loc=\"128:13\";\n@@ -737,7 +746,7 @@\n-                ()void -> {\n-                    java.if\n-                        ()boolean -> {\n-                            %20 : int = var.load %16;\n-                            %21 : int = constant @\"5\";\n-                            %22 : boolean = lt %20 %21;\n-                            yield %22;\n+                ()java.type:\"void\" -> {\n+                    java.if @loc=\"129:17\"\n+                        ()java.type:\"boolean\" -> {\n+                            %20 : java.type:\"int\" = var.load %16 @loc=\"129:21\";\n+                            %21 : java.type:\"int\" = constant @loc=\"129:25\" @5;\n+                            %22 : java.type:\"boolean\" = lt %20 %21 @loc=\"129:21\";\n+                            yield %22 @loc=\"129:17\";\n@@ -745,6 +754,6 @@\n-                        ()void -> {\n-                            %23 : double = var.load %5;\n-                            %24 : double = var.load %2;\n-                            %25 : double = mul %23 %24;\n-                            var.store %5 %25;\n-                            yield;\n+                        ()java.type:\"void\" -> {\n+                            %23 : java.type:\"double\" = var.load %5 @loc=\"130:25\";\n+                            %24 : java.type:\"double\" = var.load %2 @loc=\"130:29\";\n+                            %25 : java.type:\"double\" = mul %23 %24 @loc=\"130:25\";\n+                            var.store %5 %25 @loc=\"130:21\";\n+                            yield @loc=\"129:17\";\n@@ -752,1 +761,1 @@\n-                        ()void -> {\n+                        ()java.type:\"void\" -> {\n@@ -755,1 +764,1 @@\n-                    yield;\n+                    yield @loc=\"128:13\";\n@@ -757,1 +766,1 @@\n-                ()void -> {\n+                ()java.type:\"void\" -> {\n@@ -760,1 +769,1 @@\n-            java.continue;\n+            java.continue @loc=\"127:9\";\n@@ -762,2 +771,2 @@\n-    %26 : double = var.load %5;\n-    return %26;\n+    %26 : java.type:\"double\" = var.load %5 @loc=\"134:16\";\n+    return %26 @loc=\"134:9\";\n@@ -785,8 +794,1 @@\n-fcm = fcm.transform((block, op) -> {\n-    if (op instanceof Op.Lowerable lop) {\n-        return lop.lower(block);\n-    } else {\n-        block.op(op);\n-        return block;\n-    }\n-});\n+fcm = fcm.transform(CodeTransformer.LOWERING_TRANSFORMER);\n@@ -797,4 +799,5 @@\n-func @\"fcf\" (%0 : double, %1 : int)double -> {\n-    %2 : double = constant @\"1.0\";\n-    %3 : int = constant @\"0\";\n-    branch ^block_0(%2, %3);\n+func @loc=\"125:5:file:\/\/\/...\/TestForwardAutoDiff.java\" @\"fcf\"\n+(%0 : java.type:\"double\", %1 : java.type:\"int\")java.type:\"double\" -> {\n+    %2 : java.type:\"double\" = constant @loc=\"128:20\" @1.0d;\n+    %3 : java.type:\"int\" = constant @loc=\"129:22\" @0;\n+    branch ^block_1(%3, %2);\n@@ -802,3 +805,3 @@\n-  ^block_0(%4 : double, %5 : int):\n-    %6 : boolean = lt %5 %1;\n-    cbranch %6 ^block_1 ^block_2;\n+  ^block_1(%4 : java.type:\"int\", %5 : java.type:\"double\"):\n+    %6 : java.type:\"boolean\" = lt %4 %1 @loc=\"129:25\";\n+    cbranch %6 ^block_2 ^block_9;\n@@ -806,4 +809,4 @@\n-  ^block_1:\n-    %7 : int = constant @\"1\";\n-    %8 : boolean = gt %5 %7;\n-    cbranch %8 ^block_3 ^block_4;\n+  ^block_2:\n+    %7 : java.type:\"int\" = constant @loc=\"130:21\" @1;\n+    %8 : java.type:\"boolean\" = gt %4 %7 @loc=\"130:17\";\n+    cbranch %8 ^block_3 ^block_7;\n@@ -812,3 +815,3 @@\n-    %9 : int = constant @\"5\";\n-    %10 : boolean = lt %5 %9;\n-    cbranch %10 ^block_5 ^block_6;\n+    %9 : java.type:\"int\" = constant @loc=\"131:25\" @5;\n+    %10 : java.type:\"boolean\" = lt %4 %9 @loc=\"131:21\";\n+    cbranch %10 ^block_4 ^block_5;\n@@ -816,3 +819,3 @@\n-  ^block_5:\n-    %11 : double = mul %4 %0;\n-    branch ^block_7(%11);\n+  ^block_4:\n+    %11 : java.type:\"double\" = mul %5 %0 @loc=\"132:25\";\n+    branch ^block_6(%11);\n@@ -820,2 +823,2 @@\n-  ^block_6:\n-    branch ^block_7(%4);\n+  ^block_5:\n+    branch ^block_6(%5);\n@@ -823,1 +826,1 @@\n-  ^block_7(%12 : double):\n+  ^block_6(%12 : java.type:\"double\"):\n@@ -826,2 +829,2 @@\n-  ^block_4:\n-    branch ^block_8(%4);\n+  ^block_7:\n+    branch ^block_8(%5);\n@@ -829,2 +832,4 @@\n-  ^block_8(%13 : double):\n-    branch ^block_9;\n+  ^block_8(%13 : java.type:\"double\"):\n+    %14 : java.type:\"int\" = constant @loc=\"129:40\" @1;\n+    %15 : java.type:\"int\" = add %4 %14 @loc=\"129:36\";\n+    branch ^block_1(%15, %13);\n@@ -833,6 +838,1 @@\n-    %14 : int = constant @\"1\";\n-    %15 : int = add %5 %14;\n-    branch ^block_0(%13, %15);\n-  \n-  ^block_2:\n-    return %4;\n+    return %5 @loc=\"136:9\";\n@@ -847,2 +847,2 @@\n-together to form a *control flow graph*. In `block_9` we can observe a branch\n-back to `block_0` which passes values of `o` and `i` as block arguments for the\n+together to form a *control flow graph*. In `block_8` we can observe a branch\n+back to `block_1` which passes values of `i` and `o` as block arguments for the\n@@ -857,1 +857,1 @@\n-members, such as parameter `%4`, which represents the value `o` for the current\n+members, such as parameter `%5`, which represents the value `o` for the current\n@@ -862,6 +862,7 @@\n-func @\"dfcf_darg0\" (%0 : double, %1 : int)double -> {\n-    %2 : double = constant @\"0.0\";\n-    %3 : double = constant @\"1.0\";\n-    %4 : double = constant @\"1.0\";\n-    %5 : int = constant @\"0\";\n-    branch ^block_0(%4, %5, %2);\n+func @loc=\"124:5:file:\/\/\/...\/TestForwardAutoDiff.java\" @\"dfcf_darg0\"\n+(%0 : java.type:\"double\", %1 : java.type:\"int\")java.type:\"double\" -> {\n+    %2 : java.type:\"double\" = constant @0.0d;\n+    %3 : java.type:\"double\" = constant @1.0d;\n+    %4 : java.type:\"double\" = constant @loc=\"127:20\" @1.0d;\n+    %5 : java.type:\"int\" = constant @loc=\"128:22\" @0;\n+    branch ^block_1(%5, %4, %2);\n@@ -869,3 +870,3 @@\n-  ^block_0(%6 : double, %7 : int, %8 : double):\n-    %9 : boolean = lt %7 %1;\n-    cbranch %9 ^block_1 ^block_2;\n+  ^block_1(%6 : java.type:\"int\", %7 : java.type:\"double\", %8 : java.type:\"double\"):\n+    %9 : java.type:\"boolean\" = lt %6 %1 @loc=\"128:25\";\n+    cbranch %9 ^block_2 ^block_9;\n@@ -873,4 +874,4 @@\n-  ^block_1:\n-    %10 : int = constant @\"1\";\n-    %11 : boolean = gt %7 %10;\n-    cbranch %11 ^block_3 ^block_4;\n+  ^block_2:\n+    %10 : java.type:\"int\" = constant @loc=\"129:21\" @1;\n+    %11 : java.type:\"boolean\" = gt %6 %10 @loc=\"129:17\";\n+    cbranch %11 ^block_3 ^block_7;\n@@ -879,3 +880,3 @@\n-    %12 : int = constant @\"5\";\n-    %13 : boolean = lt %7 %12;\n-    cbranch %13 ^block_5 ^block_6;\n+    %12 : java.type:\"int\" = constant @loc=\"130:25\" @5;\n+    %13 : java.type:\"boolean\" = lt %6 %12 @loc=\"130:21\";\n+    cbranch %13 ^block_4 ^block_5;\n@@ -883,6 +884,6 @@\n-  ^block_5:\n-    %14 : double = mul %6 %0;\n-    %15 : double = mul %8 %0;\n-    %16 : double = mul %6 %3;\n-    %17 : double = add %15 %16;\n-    branch ^block_7(%14, %17);\n+  ^block_4:\n+    %14 : java.type:\"double\" = mul %7 %0 @loc=\"131:25\";\n+    %15 : java.type:\"double\" = mul %8 %0;\n+    %16 : java.type:\"double\" = mul %7 %3;\n+    %17 : java.type:\"double\" = add %15 %16;\n+    branch ^block_6(%14, %17);\n@@ -890,2 +891,2 @@\n-  ^block_6:\n-    branch ^block_7(%6, %8);\n+  ^block_5:\n+    branch ^block_6(%7, %8);\n@@ -893,1 +894,1 @@\n-  ^block_7(%18 : double, %19 : double):\n+  ^block_6(%18 : java.type:\"double\", %19 : java.type:\"double\"):\n@@ -896,2 +897,2 @@\n-  ^block_4:\n-    branch ^block_8(%6, %8);\n+  ^block_7:\n+    branch ^block_8(%7, %8);\n@@ -899,2 +900,4 @@\n-  ^block_8(%20 : double, %21 : double):\n-    branch ^block_9;\n+  ^block_8(%20 : java.type:\"double\", %21 : java.type:\"double\"):\n+    %22 : java.type:\"int\" = constant @loc=\"128:40\" @1;\n+    %23 : java.type:\"int\" = add %6 %22 @loc=\"128:36\";\n+    branch ^block_1(%23, %20, %21);\n@@ -903,5 +906,0 @@\n-    %22 : int = constant @\"1\";\n-    %23 : int = add %7 %22;\n-    branch ^block_0(%20, %23, %21);\n-  \n-  ^block_2:\n@@ -912,1 +910,1 @@\n-We can observe in `block_5` the application of the product rule. Further we can\n+We can observe in `block_4` the application of the product rule. Further we can\n@@ -914,1 +912,1 @@\n-differential of `o`, `d_o`. In `block_9` there is a branch with an additional\n+differential of `o`, `d_o`. In `block_8` there is a branch with an additional\n@@ -916,1 +914,1 @@\n-in `block_0`, parameter `%8`\n+in `block_1`, parameter `%8`\n","filename":"site\/articles\/auto-diff.md","additions":268,"deletions":270,"binary":false,"changes":538,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+\n@@ -3,1 +4,2 @@\n-#### February 2024 {.date}\n+\n+#### February 2024, Updated Dec 2025 {.date}\n@@ -98,2 +100,3 @@\n-\/\/ Find all customers based in London, and return their names\n-QueryResult<Stream<String>> results = qp.newQuery(Customer.class)\n+\/\/ Query all customers based in London, and return their names\n+@Reflect\n+QueryResult<Stream<String>> results = qp.query(Customer.class)\n@@ -122,0 +125,1 @@\n+@Reflect\n@@ -123,0 +127,1 @@\n+@Reflect\n@@ -144,1 +149,1 @@\n-default Queryable<T> where(QuotablePredicate<T> f) { \/* ... *\/ }\n+default Queryable<T> where(Predicate<T> f) { \/* ... *\/ }\n@@ -146,1 +151,1 @@\n-default <R> Queryable<R> select(QuotableFunction<T, R> f) { \/* ... *\/ }\n+default <R> Queryable<R> select(Function<T, R> f) { \/* ... *\/ }\n@@ -149,19 +154,3 @@\n-`QuotablePredicate` and `QuotableFunction` are functional interfaces that extend\n-from `Predicate` and `Function` and the Code Reflection\n-interface `java.lang.reflect.code.Quotable`.\n-\n-Here is the declaration of `Quotable`.\n-\n-```java\n-\n-@FunctionalInterface\n-public interface QuotablePredicate<T> extends Quotable, Predicate<T> {\n-}\n-```\n-\n-When a lambda expression is targeted to a quotable functional interface a code\n-model for the lambda expression will be built by the source compiler and made\n-accessible at runtime via the quotable instance. In a similar manner to how we\n-can obtain serializable lambda expressions (using `Serializable`) that can be\n-serialized, we can obtain *quotable* lambda expressions whose code model can be\n-obtained.\n+The `@Reflect` annotation declared on the local variable assignment statements\n+ensures code models for the lambda expressions, present in the assignment's\n+initializer expression, will be built by `javac` and made accessible at runtime.\n@@ -175,1 +164,1 @@\n-We can obtain the code model of the `QuotablePredicate` instance, checking if a\n+We can obtain the code model of the `Predicate` instance, checking if a\n@@ -178,0 +167,1 @@\n+[\/\/]: # (@formatter:off)\n@@ -179,4 +169,5 @@\n-QuotablePredicate<Customer> qp = c -> c.city.equals(\"London\");\n-Quoted q = qp.quoted();\n-Op op = q.op();\n-CoreOps.LambdaOp qpcm = (CoreOps.LambdaOp) op;\n+@Reflect\n+Predicate<Customer> p = c -> c.city.equals(\"London\");\n+Optional<Quoted> q = Op.ofQuotable(p);\n+Op op = q.orElseThrow().op();\n+JavaOp.LambdaOp pcm = (JavaOp.LambdaOp) op;\n@@ -184,0 +175,1 @@\n+[\/\/]: # (@formatter:on)\n@@ -185,3 +177,3 @@\n-We call the `Quotable::quoted` method to obtain an instance of `Quoted` from\n-which we obtain the code model with a call to `Quoted::op`. In this case the\n-lambda expression does not capture any values, but if it did we could obtain\n+We call the `Op::ofQuotable` method to obtain an optional instance of `Quoted`\n+from which we obtain the code model with a call to `Quoted::op`. In this case\n+the lambda expression does not capture any values, but if it did we could obtain\n@@ -190,1 +182,1 @@\n-The code model of `qp` is represented as an instance of `CoreOps.LambdaOp`\n+The code model of `p` is represented as an instance of `CoreOps.LambdaOp`\n@@ -194,1 +186,1 @@\n-of `java.lang.reflect.code.Op`, the top-level type for all operations, from\n+of `java.incubator.code.Op`, the top-level type for all operations, from\n@@ -212,2 +204,2 @@\n-model a Java lambda expression (instances of `CoreOps.LambdaOp`), or model a\n-Java `try` statement (instances of `ExtendedOps.JavaTryOp`).\n+model a Java lambda expression (instances of `JavaOp.LambdaOp`), or model a\n+Java `try` statement (instances of `JavaOp.TryOp`).\n@@ -215,2 +207,2 @@\n-What does the code model of `qp` look like? We can serialize its in-memory\n-form (the instance of `CoreOps.LambdaOp`) to a textual form.\n+What does the code model of `p` look like? We can serialize its in-memory\n+form (the instance of `JavaOp.LambdaOp`) to a textual form.\n@@ -219,1 +211,1 @@\n-System.out.println(qpcm.toText());\n+System.out.println(pcm.toText());\n@@ -225,7 +217,8 @@\n-lambda (%0 : linq.TestLinq$Customer)boolean -> {\n-    %1 : Var<linq.TestLinq$Customer> = var %0 @\"c\";\n-    %2 : linq.TestLinq$Customer = var.load %1;\n-    %3 : java.lang.String = field.load %2 @\"linq.TestLinq$Customer::city()java.lang.String\";\n-    %4 : java.lang.String = constant @\"London\";\n-    %5 : boolean = invoke %3 %4 @\"java.lang.String::equals(java.lang.Object)boolean\";\n-    return %5;\n+%0 : java.type:\"java.util.function.Predicate<linq.TestLinq$Customer>\" = lambda @lambda.isQuotable=true\n+(%1 : java.type:\"linq.TestLinq$Customer\")java.type:\"boolean\" -> {\n+    %2 : Var<java.type:\"linq.TestLinq$Customer\"> = var %1 @\"c\";\n+    %3 : java.type:\"linq.TestLinq$Customer\" = var.load %2;\n+    %4 : java.type:\"java.lang.String\" = field.load %3 @java.ref:\"linq.TestLinq$Customer::city:java.lang.String\";\n+    %5 : java.type:\"java.lang.String\" = constant @\"London\";\n+    %6 : java.type:\"boolean\" = invoke %4 %5 @java.ref:\"java.lang.String::equals(java.lang.Object):boolean\";\n+    return %6;\n@@ -244,1 +237,1 @@\n-form, all of which extend from the abstract class `java.lang.reflect.code.Op`.\n+form, all of which extend from the abstract class `java.incubator.code.Op`.\n@@ -246,2 +239,2 @@\n-The entry block has one block parameters, `%0` (corresponding to `c`), described\n-by a type of `linq.TestLinq$Customer`, which models `qp`'s parameter. This\n+The entry block has one block parameters, `%1` (corresponding to `c`), described\n+by a type of `linq.TestLinq$Customer`, which models `p`'s parameter. This\n@@ -249,1 +242,1 @@\n-operation results, e.g., `%3` the result of a field load operation, that are\n+operation results, e.g., `%4` the result of a field load operation, that are\n@@ -256,1 +249,1 @@\n-variables in Java) .e.g., value `%3` can never be modified. A variable\n+variables in Java) .e.g., value `%4` can never be modified. A variable\n@@ -269,1 +262,1 @@\n-They declare *descriptors* (an operation attribute prefixed with `@`) that can\n+They declare *references* (an operation attribute prefixed with `@`) that can\n@@ -286,1 +279,1 @@\n-func @\"query\" (%0 : linq.Queryable<linq.TestLinq$Customer>)linq.Queryable<linq.TestLinq$Customer> -> {\n+func @\"query\" (%0 : java.type:\"linq.Queryable<linq.TestLinq$Customer>\")java.type:\"linq.Queryable<linq.TestLinq$Customer>\" -> {\n@@ -295,2 +288,4 @@\n-type description is `linq.Queryable<linq.TestLinq$Customer>` that encapsulates\n-the `Customer` type, so we know what table we are querying.\n+type is `linq.Queryable<linq.TestLinq$Customer>` that encapsulates the\n+`Customer` type, so we know what table we are querying.\n+\n+The second queryable is as follows.\n@@ -299,0 +294,1 @@\n+@Reflect\n@@ -303,2 +299,0 @@\n-The second queryable is as follows.\n-\n@@ -306,7 +300,7 @@\n-func @\"query\" (%0 : linq.Queryable<linq.TestLinq$Customer>)linq.Queryable<linq.TestLinq$Customer> -> {\n-    %1 : linq.QuotablePredicate<linq.TestLinq$Customer> = lambda (%2 : linq.TestLinq$Customer)boolean -> {\n-        %3 : Var<linq.TestLinq$Customer> = var %2 @\"c\";\n-        %4 : linq.TestLinq$Customer = var.load %3;\n-        %5 : java.lang.String = field.load %4 @\"linq.TestLinq$Customer::city()java.lang.String\";\n-        %6 : java.lang.String = constant @\"London\";\n-        %7 : boolean = invoke %5 %6 @\"java.lang.String::equals(java.lang.Object)boolean\";\n+func @\"query\" (%0 : java.type:\"linq.Queryable<linq.TestLinq$Customer>\")java.type:\"linq.Queryable<linq.TestLinq$Customer>\" -> {\n+    %1 : java.type:\"java.util.function.Predicate<linq.TestLinq$Customer>\" = lambda @lambda.isQuotable=true (%2 : java.type:\"linq.TestLinq$Customer\")java.type:\"boolean\" -> {\n+        %3 : Var<java.type:\"linq.TestLinq$Customer\"> = var %2 @\"c\";\n+        %4 : java.type:\"linq.TestLinq$Customer\" = var.load %3;\n+        %5 : java.type:\"java.lang.String\" = field.load %4 @java.ref:\"linq.TestLinq$Customer::city:java.lang.String\";\n+        %6 : java.type:\"java.lang.String\" = constant @\"London\";\n+        %7 : java.type:\"boolean\" = invoke %5 %6 @java.ref:\"java.lang.String::equals(java.lang.Object):boolean\";\n@@ -315,1 +309,1 @@\n-    %8 : linq.Queryable<linq.TestLinq$Customer> = invoke %0 %1 @\"linq.Queryable::where(linq.QuotablePredicate)linq.Queryable\";\n+    %8 : java.type:\"linq.Queryable<linq.TestLinq$Customer>\" = invoke %0 %1 @java.ref:\"linq.Queryable::where(java.util.function.Predicate):linq.Queryable\";\n@@ -327,0 +321,1 @@\n+@Reflect\n@@ -332,7 +327,7 @@\n-func @\"query\" (%0 : linq.Queryable<linq.TestLinq$Customer>)linq.Queryable<java.lang.String> -> {\n-    %1 : linq.QuotablePredicate<linq.TestLinq$Customer> = lambda (%2 : linq.TestLinq$Customer)boolean -> {\n-        %3 : Var<linq.TestLinq$Customer> = var %2 @\"c\";\n-        %4 : linq.TestLinq$Customer = var.load %3;\n-        %5 : java.lang.String = field.load %4 @\"linq.TestLinq$Customer::city()java.lang.String\";\n-        %6 : java.lang.String = constant @\"London\";\n-        %7 : boolean = invoke %5 %6 @\"java.lang.String::equals(java.lang.Object)boolean\";\n+func @\"query\" (%0 : java.type:\"linq.Queryable<linq.TestLinq$Customer>\")java.type:\"linq.Queryable<java.lang.String>\" -> {\n+    %1 : java.type:\"java.util.function.Predicate<linq.TestLinq$Customer>\" = lambda @lambda.isQuotable=true (%2 : java.type:\"linq.TestLinq$Customer\")java.type:\"boolean\" -> {\n+        %3 : Var<java.type:\"linq.TestLinq$Customer\"> = var %2 @\"c\";\n+        %4 : java.type:\"linq.TestLinq$Customer\" = var.load %3;\n+        %5 : java.type:\"java.lang.String\" = field.load %4 @java.ref:\"linq.TestLinq$Customer::city:java.lang.String\";\n+        %6 : java.type:\"java.lang.String\" = constant @\"London\";\n+        %7 : java.type:\"boolean\" = invoke %5 %6 @java.ref:\"java.lang.String::equals(java.lang.Object):boolean\";\n@@ -341,5 +336,5 @@\n-    %8 : linq.Queryable<linq.TestLinq$Customer> = invoke %0 %1 @\"linq.Queryable::where(linq.QuotablePredicate)linq.Queryable\";\n-    %9 : linq.QuotableFunction<linq.TestLinq$Customer, java.lang.String> = lambda (%10 : linq.TestLinq$Customer)java.lang.String -> {\n-        %11 : Var<linq.TestLinq$Customer> = var %10 @\"c\";\n-        %12 : linq.TestLinq$Customer = var.load %11;\n-        %13 : java.lang.String = field.load %12 @\"linq.TestLinq$Customer::contactName()java.lang.String\";\n+    %8 : java.type:\"linq.Queryable<linq.TestLinq$Customer>\" = invoke %0 %1 @java.ref:\"linq.Queryable::where(java.util.function.Predicate):linq.Queryable\";\n+    %9 : java.type:\"java.util.function.Function<linq.TestLinq$Customer, java.lang.String>\" = lambda @lambda.isQuotable=true (%10 : java.type:\"linq.TestLinq$Customer\")java.type:\"java.lang.String\" -> {\n+        %11 : Var<java.type:\"linq.TestLinq$Customer\"> = var %10 @\"c\";\n+        %12 : java.type:\"linq.TestLinq$Customer\" = var.load %11;\n+        %13 : java.type:\"java.lang.String\" = field.load %12 @java.ref:\"linq.TestLinq$Customer::contactName:java.lang.String\";\n@@ -348,1 +343,1 @@\n-    %14 : linq.Queryable<java.lang.String> = invoke %8 %9 @\"linq.Queryable::select(linq.QuotableFunction)linq.Queryable\";\n+    %14 : java.type:\"linq.Queryable<java.lang.String>\" = invoke %8 %9 @java.ref:\"linq.Queryable::select(java.util.function.Function):linq.Queryable\";\n@@ -368,7 +363,7 @@\n-func @\"queryResult\" (%0 : linq.Queryable<linq.TestLinq$Customer>)linq.QueryResult<java.util.stream.Stream<java.lang.String>> -> {\n-    %1 : linq.QuotablePredicate<linq.TestLinq$Customer> = lambda (%2 : linq.TestLinq$Customer)boolean -> {\n-        %3 : Var<linq.TestLinq$Customer> = var %2 @\"c\";\n-        %4 : linq.TestLinq$Customer = var.load %3;\n-        %5 : java.lang.String = field.load %4 @\"linq.TestLinq$Customer::city()java.lang.String\";\n-        %6 : java.lang.String = constant @\"London\";\n-        %7 : boolean = invoke %5 %6 @\"java.lang.String::equals(java.lang.Object)boolean\";\n+func @\"queryResult\" (%0 : java.type:\"linq.Queryable<linq.TestLinq$Customer>\")java.type:\"linq.QueryResult<java.util.stream.Stream<java.lang.String>>\" -> {\n+    %1 : java.type:\"java.util.function.Predicate<linq.TestLinq$Customer>\" = lambda @lambda.isQuotable=true (%2 : java.type:\"linq.TestLinq$Customer\")java.type:\"boolean\" -> {\n+        %3 : Var<java.type:\"linq.TestLinq$Customer\"> = var %2 @\"c\";\n+        %4 : java.type:\"linq.TestLinq$Customer\" = var.load %3;\n+        %5 : java.type:\"java.lang.String\" = field.load %4 @java.ref:\"linq.TestLinq$Customer::city:java.lang.String\";\n+        %6 : java.type:\"java.lang.String\" = constant @\"London\";\n+        %7 : java.type:\"boolean\" = invoke %5 %6 @java.ref:\"java.lang.String::equals(java.lang.Object):boolean\";\n@@ -377,5 +372,5 @@\n-    %8 : linq.Queryable<linq.TestLinq$Customer> = invoke %0 %1 @\"linq.Queryable::where(linq.QuotablePredicate)linq.Queryable\";\n-    %9 : linq.QuotableFunction<linq.TestLinq$Customer, java.lang.String> = lambda (%10 : linq.TestLinq$Customer)java.lang.String -> {\n-        %11 : Var<linq.TestLinq$Customer> = var %10 @\"c\";\n-        %12 : linq.TestLinq$Customer = var.load %11;\n-        %13 : java.lang.String = field.load %12 @\"linq.TestLinq$Customer::contactName()java.lang.String\";\n+    %8 : java.type:\"linq.Queryable<linq.TestLinq$Customer>\" = invoke %0 %1 @java.ref:\"linq.Queryable::where(java.util.function.Predicate):linq.Queryable\";\n+    %9 : java.type:\"java.util.function.Function<linq.TestLinq$Customer, java.lang.String>\" = lambda @lambda.isQuotable=true (%10 : java.type:\"linq.TestLinq$Customer\")java.type:\"java.lang.String\" -> {\n+        %11 : Var<java.type:\"linq.TestLinq$Customer\"> = var %10 @\"c\";\n+        %12 : java.type:\"linq.TestLinq$Customer\" = var.load %11;\n+        %13 : java.type:\"java.lang.String\" = field.load %12 @java.ref:\"linq.TestLinq$Customer::contactName:java.lang.String\";\n@@ -384,2 +379,2 @@\n-    %14 : linq.Queryable<java.lang.String> = invoke %8 %9 @\"linq.Queryable::select(linq.QuotableFunction)linq.Queryable\";\n-    %15 : linq.QueryResult<java.util.stream.Stream<java.lang.String>> = invoke %14 @\"linq.Queryable::elements()linq.QueryResult\";\n+    %14 : java.type:\"linq.Queryable<java.lang.String>\" = invoke %8 %9 @java.ref:\"linq.Queryable::select(java.util.function.Function):linq.Queryable\";\n+    %15 : java.type:\"linq.QueryResult<java.util.stream.Stream<java.lang.String>>\" = invoke %14 @java.ref:\"linq.Queryable::elements():linq.QueryResult\";\n@@ -398,1 +393,1 @@\n-@CodeReflection\n+@Reflect\n@@ -438,2 +433,2 @@\n-default Queryable<T> where(QuotablePredicate<T> f) {\n-    CoreOps.LambdaOp l = (CoreOps.LambdaOp) f.quoted().op();\n+default Queryable<T> where(Predicate<T> f) {\n+    JavaOp.LambdaOp l = (JavaOp.LambdaOp) Op.ofQuotable(f).get().op();\n@@ -451,1 +446,1 @@\n-private Queryable<?> insertQuery(JavaType elementType, String methodName, LambdaOp lambdaOp) {\n+private Queryable<?> insertQuery(JavaType elementType, String methodName, JavaOp.LambdaOp lambdaOp) {\n@@ -454,1 +449,1 @@\n-    JavaType queryableType = type(Queryable.TYPE, elementType);\n+    JavaType queryableType = parameterized(Queryable.TYPE, elementType);\n@@ -456,3 +451,3 @@\n-            methodType(queryableType, queryExpression.funcDescriptor().parameters()))\n-            .body(b -> b.inline(queryExpression, b.parameters(), (block, query) -> {\n-                Op.Result fi = block.op(lambdaOp);\n+            functionType(queryableType, queryExpression.invokableType().parameterTypes()))\n+            .body(b -> Inliner.inline(b, queryExpression, b.parameters(), (block, query) -> {\n+                Result fi = block.op(lambdaOp);\n@@ -460,3 +455,3 @@\n-                MethodDesc md = method(Queryable.TYPE, methodName,\n-                        methodType(Queryable.TYPE, ((JavaType) lambdaOp.functionalInterface()).rawType()));\n-                Op.Result queryable = block.op(invoke(queryableType, md, query, fi));\n+                MethodRef md = method(Queryable.TYPE, methodName,\n+                        functionType(Queryable.TYPE, ((ClassType) lambdaOp.functionalInterface()).rawType()));\n+                Result queryable = block.op(JavaOp.invoke(queryableType, md, query, fi));\n@@ -464,1 +459,1 @@\n-                block.op(_return(queryable));\n+                block.op(return_(queryable));\n@@ -471,6 +466,5 @@\n-We start by building a new function declaration operation with the static\n-factory method `CoreOps.func`. A method description is constructed that\n-describes the function's parameters and return type. Then we call the `body`\n-method to build the function declaration operation's body. The implementation\n-of `body` calls the lambda expression with function body's *entry block\n-builder*, from which we can add operations.\n+We start by building a new function operation with the static factory method\n+`CoreOps.func`. A method reference is constructed that describes the function's\n+parameters and return type. Then we call the `body` method to build the function\n+operation's body. The implementation of `body` calls the lambda expression with\n+function body's *entry block builder*, from which we can add operations.\n@@ -490,4 +484,4 @@\n-Because we are inlining we also need to map the input function's parameters to\n-the output functions parameters (specifically in both cases the block parameters\n-of the entry block of the body of the function declaration operation), so we\n-also pass the latter to the `inline` method which takes care of the mapping.\n+Because we are inlining we also need to map the queryExpression function's\n+parameters to the output functions parameters (specifically in both cases the\n+block parameters of the entry block of the body of the function operation), so\n+we also pass the latter to the `inline` method which takes care of the mapping.\n","filename":"site\/articles\/linq.md","additions":108,"deletions":114,"binary":false,"changes":222,"status":"modified"}]}