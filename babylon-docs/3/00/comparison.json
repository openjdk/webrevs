{"files":[{"patch":"@@ -48,0 +48,1 @@\n+\n@@ -50,0 +51,1 @@\n+    - [Emulating C# LINQ in Java using Code Reflection](articles\/linq) (February 2024)\n","filename":"site\/_index.md","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -481,1 +481,1 @@\n-        case ... ->{\n+        case ... -> {\n","filename":"site\/articles\/auto-diff.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,495 @@\n+# Emulating C# LINQ in Java using Code Reflection\n+#### Paul Sandoz {.author}\n+#### February 2024 {.date}\n+\n+In this article we will explain how to emulate aspects of C#'s Language\n+Integrated Query ([LINQ](https:\/\/learn.microsoft.com\/en-us\/dotnet\/csharp\/linq\/))\n+in Java using Code Reflection. Specifically, LINQ's capability to enable\n+translation of LINQ queries (C# expressions) to SQL statements.\n+\n+Code Reflection is a Java platform feature being researched and developed under\n+OpenJDK Project [Babylon](https:\/\/openjdk.org\/projects\/babylon\/).\n+\n+We will introduce Code Reflection concepts and APIs as we go. The explanations\n+are neither exhaustive nor very detailed, they are designed to give the reader\n+an intuitive sense and understanding of Code Reflection and its capabilities.\n+\n+## C# LINQ\n+\n+C#'s guide to [LINQ](https:\/\/learn.microsoft.com\/en-us\/dotnet\/csharp\/linq\/)\n+states:\n+\n+> Language-Integrated Query (LINQ) is the name for a set of technologies based\n+> on the integration of query capabilities directly into the C# language.\n+> Traditionally, queries against data are expressed as simple strings without\n+> type checking at compile time or IntelliSense support. Furthermore, you have\n+> to learn a different query language for each type of data source: SQL\n+> databases, XML documents, various Web services, and so on. With LINQ, a query\n+> is a first-class language construct, just like classes, methods, and events.\n+\n+Here's a simple example of a LINQ query to a database using the query syntax:\n+\n+```\n+DB db = ...;\n+\n+\/\/ Query for customers in London.\n+IQueryable<String> custQuery =\n+    from cust in db.Customers\n+    where cust.City == \"London\"\n+    select cust.ContactName;\n+```\n+\n+The query syntax is syntactical sugar for ease of reading and writing LINQ\n+queries, but its really just a shortcut to method calls.\n+\n+The class `DB` contains enclosed classes that model SQL tables, such\n+as `Customers` whose properties, `City` and `ContactName`, model rows in the\n+table.\n+\n+We can write the same LINQ query using the method syntax.\n+\n+```\n+DB db = ...;\n+\n+\/\/ Query for customers in London.\n+IQueryable<String> custQuery =\n+    db.Customers\n+    .Where(cust => cust.City == \"London\")\n+    .Select(cust => cust.ContactName);\n+```\n+\n+A LINQ query, an instance of `IQuerable`, has a C#\n+property [Expression][Q-Expr], whose value is a *symbolic representation* of the\n+LINQ query. In C# such symbolic representations are referred to as\n+*expression trees*. In the code above the expression tree for the\n+query `custQuery` is composed of the expression trees of the lambda expressions\n+passed to the `Where` and `Select` methods **and** the expression trees for the\n+invocation expressions to those methods.\n+\n+[Q-Expr]: https:\/\/learn.microsoft.com\/en-us\/dotnet\/api\/system.linq.iqueryable.expression?view=net-8.0#system-linq-iqueryable-expression\n+\n+A LINQ query's `Expression` property, an [*expression tree*][Expr-Tree], has a\n+pleasing characteristic. Evaluating the expression tree produces a new LINQ\n+query whose expression tree is equal to the one that was evaluated i.e., for the\n+mathematically inclined, let `Q` be the query, `Q.e` the query's expression,\n+and `E` the evaluation function (from an expression to a query),\n+then `E(Q. e) = Q`. However pleasing that is, it is not of much practical use.\n+Such expression trees are designed to be processed symbolically and\n+*transformed*. For example, transforming to a different programming domain such\n+as SQL, where expression trees of queries are translated to SQL statements.\n+\n+[Expr-Tree]: https:\/\/learn.microsoft.com\/en-us\/dotnet\/csharp\/advanced-topics\/expression-trees\/\n+\n+We will focus on this aspect in Java, building a query whose equivalent\n+expression property is a *code model*, a symbolic representation of Java code,\n+that is produced by using features of Code Reflection.\n+\n+## Emulating LINQ-like query expressions in Java\n+\n+For the purposes of emulation we can express the same query in Java as follows.\n+\n+```java\n+\/\/ A record modeling a table with three columns, one for each component\n+record Customer(String contactName, String phone, String city) {\n+}\n+\n+QueryProvider qp = new linq.TestQueryProvider();\n+\n+\/\/ Find all customers based in London, and return their names\n+QueryResult<Stream<String>> results = qp.newQuery(Customer.class)\n+        .where(c -> c.city.equals(\"London\"))\n+        .select(c -> c.contactName)\n+        .elements();\n+```\n+\n+We use a `record`, `Customer`, to model an SQL table, where the record's\n+components corresponds to rows in that table. We can see that the Java code\n+looks very similar to the C# LINQ query using the method syntax.\n+\n+In the following sections we will explain how this is implemented using Code\n+Reflection.\n+\n+A proof of concept implementation is available as a [test][linq-test] located in\n+the Babylon repository. The implementation is far from complete.\n+\n+[linq-test]:https:\/\/github.com\/openjdk\/babylon\/tree\/code-reflection\/test\/jdk\/java\/lang\/reflect\/code\/linq\n+\n+Let's expand the fluent query into individual statements, so we can see the\n+types.\n+\n+```java\n+Queryable<Customer> allCustomers = qp.query(Customer.class);\n+Queryable<Customer> londonCustomers = allCustomers.where(c -> c.city.equals(\"London\"));\n+Queryable<String> londonCustomerNames = londonCustomers.select(c -> c.contactName);\n+QueryResult<Stream<String>> results = londonCustomerNames.elements();\n+```\n+\n+The first three method calls produce instances of `Queryable`, and the final\n+call produces an instance of `QueryResult`. Each instance will have a symbolic\n+representation, a code model, of the query. We shall see that later on.\n+\n+First, we create a new query, which returns an instance\n+of `Queryable<Customer>`. From that we \"filter\" for customers located with in\n+the city of London with a call to `where`, accepting a lambda expression that\n+returns true if the customer's `city` component is equal to the string \"London\".\n+Then we \"map\" customers to their contact names with a call to `select`,\n+accepting a lambda expression that returns the customer's `contactName`\n+component. Finally, we produce a query result with a call to `elements`, which\n+informs how we consume the result, in this case as a stream of customer contact\n+names.\n+\n+The signatures of the `where` and `select` methods are as follows.\n+\n+```java\n+default Queryable<T> where(QuotablePredicate<T> f) { \/* ... *\/ }\n+\n+default <R> Queryable<R> select(QuotableFunction<T, R> f) { \/* ... *\/ }\n+```\n+\n+`QuotablePredicate` and `QuotableFunction` are functional interfaces that extend\n+from `Predicate` and `Function` and the Code Reflection\n+interface `java.lang.reflect.code.Quotable`.\n+\n+Here is the declaration of `Quotable`.\n+\n+```java\n+\n+@FunctionalInterface\n+public interface QuotablePredicate<T> extends Quotable, Predicate<T> {\n+}\n+```\n+\n+When a lambda expression is targeted to a quotable functional interface a code\n+model for the lambda expression will be built by the source compiler and made\n+accessible at runtime via the quotable instance. In a similar manner to how we\n+can obtain serializable lambda expressions (using `Serializable`) that can be\n+serialized, we can obtain *quotable* lambda expressions whose code model can be\n+obtained.\n+\n+### Obtaining a code model\n+\n+Let's first focus on obtaining the code model of a quotable lambda expression.\n+We shall return to how code models for queries are composed and built in later\n+sections.\n+\n+We can obtain the code model of the `QuotablePredicate` instance, checking if a\n+customer is located in the city of London, as follows.\n+\n+```java\n+QuotablePredicate<Customer> qp = c -> c.city.equals(\"London\");\n+Quoted q = qp.quoted();\n+Op op = q.op();\n+CoreOps.LambdaOp qpcm = (CoreOps.LambdaOp) op;\n+```\n+\n+We call the `Quotable::quoted` method to obtain an instance of `Quoted` from\n+which we obtain the code model with a call to `Quoted::op`. In this case the\n+lambda expression does not capture any values, but if it did we could obtain\n+those values from the quoted instance.\n+\n+The code model of `qp` is represented as an instance of `CoreOps.LambdaOp`\n+corresponding to a *lambda expression* operation that models a lambda\n+expression. Since quoting is potentially not limited to just the quoting of\n+lambda expressions we first obtain the code model as an instance\n+of `java.lang.reflect.code.Op`, the top-level type for all operations, from\n+which we then down cast.\n+\n+### Explaining the code model\n+\n+A code model is a tree containing operations, bodies, and blocks. An operation\n+contains zero or more bodies. A body contains one or more blocks. A block\n+contains a sequence of one or more operations. A block can declare zero or more\n+block parameters, values. An operation declares an operation result, a value. An\n+operation may use values as operands, but only after they have been declared.\n+\n+Using this simple tree structure we can define operations that model many Java\n+language constructs, and therefore we can build code models that model many Java\n+programs. This may appear surprising at first. Readers may be more familiar with\n+term \"operation\" in a more conventional sense, such as arithmetic operations.\n+However, given the structure described above, there is no need to limit\n+ourselves to this conventional sense. We are free to define an operation whose\n+operational semantics *declare* a function (instances of `CoreOps.FuncOp`),\n+model a Java lambda expression (instances of `CoreOps.LambdaOp`), or model a\n+Java `try` statement (instances of `ExtendedOps.JavaTryOp`).\n+\n+What does the code model of `qp` look like? We can serialize its in-memory\n+form (the instance of `CoreOps.LambdaOp`) to a textual form.\n+\n+```java\n+System.out.println(qpcm.toText());\n+```\n+\n+Which prints the following text.\n+\n+```text\n+lambda (%0 : linq.TestLinq$Customer)boolean -> {\n+    %1 : Var<linq.TestLinq$Customer> = var %0 @\"c\";\n+    %2 : linq.TestLinq$Customer = var.load %1;\n+    %3 : java.lang.String = field.load %2 @\"linq.TestLinq$Customer::city()java.lang.String\";\n+    %4 : java.lang.String = constant @\"London\";\n+    %5 : boolean = invoke %3 %4 @\"java.lang.String::equals(java.lang.Object)boolean\";\n+    return %5;\n+};\n+```\n+\n+The textual form shows the code model's root is a lambda expression (`lambda`)\n+operation. The lambda expression operation has an operation result, like all\n+other operations, but since it's the root of the tree there is no need to\n+present it.\n+\n+The lambda-like expression represents the fusion of the lambda expression\n+operation's single body and the body's first and only block, called the entry\n+block. Then there is a sequence of operations in the entry block. For each\n+operation there is an instance of a corresponding class present in the in-memory\n+form, all of which extend from the abstract class `java.lang.reflect.code.Op`.\n+\n+The entry block has one block parameters, `%0` (corresponding to `c`), described\n+by a type of `linq.TestLinq$Customer`, which models `qp`'s parameter. This\n+parameter is used as an operand of another operation. Many operations produce\n+operation results, e.g., `%3` the result of a field load operation, that are\n+used as operands of subsequent operations, and so on. The `return`\n+operation has a result, again like all other operations, but since that result\n+cannot be meaningfully used we don't present it.\n+\n+Code models have the property of Static Single-Assignment (SSA). We refer to\n+variables that can only be assigned once as values (they are a bit like final\n+variables in Java) .e.g., value `%3` can never be modified. A variable\n+declaration is modeled as an operation that produces a value that holds a\n+value (a box), and access operations load or store to that box.\n+\n+(Some readers may be thinking this looks very similar\n+to [MLIR](https:\/\/mlir.llvm.org\/) and that is by design.)\n+\n+We can see how the operations model Java language constructs like lambda\n+expressions, variables (method parameters or local variables) and access of\n+variables, field access, or method invocations (e.g., to\n+method `String::equals`).\n+\n+The field load and invoke operations are referred to as reflective operations.\n+They declare *descriptors* (an operation attribute prefixed with `@`) that can\n+be used to construct method handles, or to generate bytecode instructions and\n+their constant pool entries.\n+\n+## Code models of queries\n+\n+For each queryable and query result instance we can obtain its code model and\n+print out the textual form.\n+\n+The initial queryable is as follows.\n+\n+```\n+Queryable<Customer> allCustomers = qp.query(Customer.class);\n+System.out.println(allCustomers.expression().toText());\n+```\n+\n+```text\n+func @\"query\" (%0 : linq.Queryable<linq.TestLinq$Customer>)linq.Queryable<linq.TestLinq$Customer> -> {\n+    return %0;\n+};\n+```\n+\n+The initial queryable instance has a code model whose root is a *function\n+declaration* operation. A function declaration operation is similarly structured\n+as a lambda expression operation we have previously described. This code model\n+represents an identity function, returning the parameter `%0`. The parameter's\n+type description is `linq.Queryable<linq.TestLinq$Customer>` that encapsulates\n+the `Customer` type, so we know what table we are querying.\n+\n+```\n+Queryable<Customer> londonCustomers = allCustomers.where(c -> c.city.equals(\"London\"));\n+System.out.println(londonCustomers.expression().toText());\n+```\n+\n+The second queryable is as follows.\n+\n+```text\n+func @\"query\" (%0 : linq.Queryable<linq.TestLinq$Customer>)linq.Queryable<linq.TestLinq$Customer> -> {\n+    %1 : linq.QuotablePredicate<linq.TestLinq$Customer> = lambda (%2 : linq.TestLinq$Customer)boolean -> {\n+        %3 : Var<linq.TestLinq$Customer> = var %2 @\"c\";\n+        %4 : linq.TestLinq$Customer = var.load %3;\n+        %5 : java.lang.String = field.load %4 @\"linq.TestLinq$Customer::city()java.lang.String\";\n+        %6 : java.lang.String = constant @\"London\";\n+        %7 : boolean = invoke %5 %6 @\"java.lang.String::equals(java.lang.Object)boolean\";\n+        return %7;\n+    };\n+    %8 : linq.Queryable<linq.TestLinq$Customer> = invoke %0 %1 @\"linq.Queryable::where(linq.QuotablePredicate)linq.Queryable\";\n+    return %8;\n+};\n+```\n+\n+The code model of the second queryable contains the lambda expression whose\n+result is passed to an invocation of the `where` method, whose result is\n+returned.\n+\n+The third queryable is as follows.\n+\n+```\n+Queryable<String> londonCustomerNames = londonCustomers.select(c -> c.contactName);\n+System.out.println(londonCustomerNames.expression().toText());\n+```\n+\n+```text\n+func @\"query\" (%0 : linq.Queryable<linq.TestLinq$Customer>)linq.Queryable<java.lang.String> -> {\n+    %1 : linq.QuotablePredicate<linq.TestLinq$Customer> = lambda (%2 : linq.TestLinq$Customer)boolean -> {\n+        %3 : Var<linq.TestLinq$Customer> = var %2 @\"c\";\n+        %4 : linq.TestLinq$Customer = var.load %3;\n+        %5 : java.lang.String = field.load %4 @\"linq.TestLinq$Customer::city()java.lang.String\";\n+        %6 : java.lang.String = constant @\"London\";\n+        %7 : boolean = invoke %5 %6 @\"java.lang.String::equals(java.lang.Object)boolean\";\n+        return %7;\n+    };\n+    %8 : linq.Queryable<linq.TestLinq$Customer> = invoke %0 %1 @\"linq.Queryable::where(linq.QuotablePredicate)linq.Queryable\";\n+    %9 : linq.QuotableFunction<linq.TestLinq$Customer, java.lang.String> = lambda (%10 : linq.TestLinq$Customer)java.lang.String -> {\n+        %11 : Var<linq.TestLinq$Customer> = var %10 @\"c\";\n+        %12 : linq.TestLinq$Customer = var.load %11;\n+        %13 : java.lang.String = field.load %12 @\"linq.TestLinq$Customer::contactName()java.lang.String\";\n+        return %13;\n+    };\n+    %14 : linq.Queryable<java.lang.String> = invoke %8 %9 @\"linq.Queryable::select(linq.QuotableFunction)linq.Queryable\";\n+    return %14;\n+};\n+```\n+\n+The code model of the third queryable contains the lambda expression whose\n+result is passed to an invocation of the `select` method, whose result is\n+returned.\n+\n+We can now see a pattern emerge, a queryable code model *reifies* the steps\n+taken to build the query.\n+\n+The query result is as follows.\n+\n+```\n+QueryResult<Stream<String>> results = londonCustomerNames.elements();\n+System.out.println(results.expression().toText());\n+```\n+\n+```text\n+func @\"queryResult\" (%0 : linq.Queryable<linq.TestLinq$Customer>)linq.QueryResult<java.util.stream.Stream<java.lang.String>> -> {\n+    %1 : linq.QuotablePredicate<linq.TestLinq$Customer> = lambda (%2 : linq.TestLinq$Customer)boolean -> {\n+        %3 : Var<linq.TestLinq$Customer> = var %2 @\"c\";\n+        %4 : linq.TestLinq$Customer = var.load %3;\n+        %5 : java.lang.String = field.load %4 @\"linq.TestLinq$Customer::city()java.lang.String\";\n+        %6 : java.lang.String = constant @\"London\";\n+        %7 : boolean = invoke %5 %6 @\"java.lang.String::equals(java.lang.Object)boolean\";\n+        return %7;\n+    };\n+    %8 : linq.Queryable<linq.TestLinq$Customer> = invoke %0 %1 @\"linq.Queryable::where(linq.QuotablePredicate)linq.Queryable\";\n+    %9 : linq.QuotableFunction<linq.TestLinq$Customer, java.lang.String> = lambda (%10 : linq.TestLinq$Customer)java.lang.String -> {\n+        %11 : Var<linq.TestLinq$Customer> = var %10 @\"c\";\n+        %12 : linq.TestLinq$Customer = var.load %11;\n+        %13 : java.lang.String = field.load %12 @\"linq.TestLinq$Customer::contactName()java.lang.String\";\n+        return %13;\n+    };\n+    %14 : linq.Queryable<java.lang.String> = invoke %8 %9 @\"linq.Queryable::select(linq.QuotableFunction)linq.Queryable\";\n+    %15 : linq.QueryResult<java.util.stream.Stream<java.lang.String>> = invoke %14 @\"linq.Queryable::elements()linq.QueryResult\";\n+    return %15;\n+};\n+```\n+\n+Finally, the code model of the query result contains the invocation of\n+the `elements` method, whose result is returned.\n+\n+The prior code model will be equivalent (in terms of program meaning) to the\n+code model of the following method.\n+\n+```java\n+\n+@CodeReflection\n+static QueryResult<Stream<String>> queryResult(Queryable<Customer> q) {\n+    return q.where(c -> c.city.equals(\"London\"))\n+            .select(c -> c.contactName)\n+            .elements();\n+}\n+```\n+\n+If we interpret `results`'s code model, passing in an initial queryable\n+instance, then it will naturally produce a queryable instance that has the same\n+code model. (Alternatively we could compile the code model and execute it.)\n+\n+```\n+QueryResult<Stream<String>> resultsIterpreted = (QueryResult<Stream<String>>) Interpreter.invoke(MethodHandles.lookup(),\n+        results.expression(), qp.query(Customer.class));\n+System.out.println(resultsIterpreted.expression().toText());\n+\n+assert results.expression().toText().equals(resultsIterpreted.expression().toText());\n+```\n+\n+Clearly that is not of much practical use. The code model is designed to be\n+*transformed*. This code model contains sufficient symbolic information for it\n+to be transformed to an SQL query.\n+\n+## Building code models for queries\n+\n+Code models are immutable. Code models can be produced by building, or by\n+transforming an existing code model. Transforming takes an input code model and\n+builds an output code model. For each input operation encountered in the input\n+code model we have the choice to add that operation to the builder of the output\n+code model (copying), to not add it (removal), or add new output operations\n+(replacement or addition).\n+\n+The implementations of `Queryable` methods, `where`, `select`, and `elements`,\n+transform a prior code model to a new code model with the additional operations.\n+\n+Here is the implementation of the `where` method.\n+\n+```text\n+@SuppressWarnings(\"unchecked\")\n+default Queryable<T> where(QuotablePredicate<T> f) {\n+    CoreOps.LambdaOp l = (CoreOps.LambdaOp) f.quoted().op();\n+    return (Queryable<T>) insertQuery(elementType(), \"where\", l);\n+}\n+```\n+\n+We obtain the code model for the lambda expression, as previously shown, and\n+pass that along with element type, the name of the method to the\n+method `insertQuery`, whose result is returned.\n+\n+The method `insertQuery` performs the transformation.\n+\n+```java\n+private Queryable<?> insertQuery(JavaType elementType, String methodName, LambdaOp lambdaOp) {\n+    \/\/ Copy function expression, replacing return operation\n+    FuncOp queryExpression = expression();\n+    JavaType queryableType = type(Queryable.TYPE, elementType);\n+    FuncOp nextQueryExpression = func(\"query\",\n+            methodType(queryableType, queryExpression.funcDescriptor().parameters()))\n+            .body(b -> b.inline(queryExpression, b.parameters(), (block, query) -> {\n+                Op.Result fi = block.op(lambdaOp);\n+\n+                MethodDesc md = method(Queryable.TYPE, methodName,\n+                        methodType(Queryable.TYPE, ((JavaType) lambdaOp.functionalInterface()).rawType()));\n+                Op.Result queryable = block.op(invoke(queryableType, md, query, fi));\n+\n+                block.op(_return(queryable));\n+            }));\n+\n+    return provider().createQuery(elementType, nextQueryExpression);\n+}\n+```\n+\n+We start by building a new function declaration operation with the static\n+factory method `CoreOps.func`. A method description is constructed that\n+describes the function's parameters and return type. Then we call the `body`\n+method to build the function declaration operation's body. The implementation\n+of `body` calls the lambda expression with function body's *entry block\n+builder*, from which we can add operations.\n+\n+In this case we are going to *inline* the prior input code model (a previously\n+generated function declaration operation) into the output code model we are\n+building. Inlining transforms `queryExpression` by copying the contents of the\n+input function declaration operation's body *and* replacing the input return\n+operation with what is built by the lambda expression passed to the `inline`\n+method.\n+\n+We replace the input return operation with a copy of the lambda expression\n+operation, an invocation to the queryable method, and a return the invocation's\n+result. We can freely copy the lambda expression operation as long as it does\n+not capture.\n+\n+Because we are inlining we also need to map the input function's parameters to\n+the output functions parameters (specifically in both cases the block parameters\n+of the entry block of the body of the function declaration operation), so we\n+also pass the latter to the `inline` method which takes care of the mapping.\n+\n+Finally, we create a new instance of `Queryable` with the output code model.\n\\ No newline at end of file\n","filename":"site\/articles\/linq.md","additions":495,"deletions":0,"binary":false,"changes":495,"status":"added"}]}