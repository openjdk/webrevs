{"files":[{"patch":"@@ -2,1 +2,1 @@\n-project=jdk\n+project=jdk-updates\n@@ -4,1 +4,1 @@\n-version=23\n+version=23.0.1\n","filename":".jcheck\/conf","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-DEFAULT_VERSION_UPDATE=0\n+DEFAULT_VERSION_UPDATE=1\n@@ -36,1 +36,1 @@\n-DEFAULT_VERSION_DATE=2024-09-17\n+DEFAULT_VERSION_DATE=2024-10-15\n","filename":"make\/conf\/version-numbers.conf","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1831,0 +1831,1 @@\n+  INSN(vluxei64_v, 0b0000111, 0b111, 0b01, 0b0);\n@@ -1835,0 +1836,1 @@\n+  INSN(vsuxei64_v, 0b0100111, 0b111, 0b01, 0b0);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4798,3 +4798,2 @@\n-instruct gather_load(vReg dst, indirect mem, vReg idx) %{\n-  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) == 4 ||\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) == 8);\n+instruct gather_loadS(vReg dst, indirect mem, vReg idx) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) == 4);\n@@ -4803,1 +4802,1 @@\n-  format %{ \"gather_load $dst, $mem, $idx\" %}\n+  format %{ \"gather_loadS $dst, $mem, $idx\" %}\n@@ -4816,3 +4815,19 @@\n-instruct gather_load_masked(vReg dst, indirect mem, vReg idx, vRegMask_V0 v0, vReg tmp) %{\n-  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) == 4 ||\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) == 8);\n+instruct gather_loadD(vReg dst, indirect mem, vReg idx) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) == 8);\n+  match(Set dst (LoadVectorGather mem idx));\n+  effect(TEMP_DEF dst);\n+  format %{ \"gather_loadD $dst, $mem, $idx\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SEW sew = Assembler::elemtype_to_sew(bt);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vzext_vf2(as_VectorRegister($dst$$reg), as_VectorRegister($idx$$reg));\n+    __ vsll_vi(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg), (int)sew);\n+    __ vluxei64_v(as_VectorRegister($dst$$reg), as_Register($mem$$base),\n+                  as_VectorRegister($dst$$reg));\n+ %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gather_loadS_masked(vReg dst, indirect mem, vReg idx, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) == 4);\n@@ -4821,1 +4836,1 @@\n-  format %{ \"gather_load_masked $dst, $mem, $idx, $v0\\t# KILL $tmp\" %}\n+  format %{ \"gather_loadS_masked $dst, $mem, $idx, $v0\\t# KILL $tmp\" %}\n@@ -4836,0 +4851,19 @@\n+instruct gather_loadD_masked(vReg dst, indirect mem, vReg idx, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) == 8);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx v0)));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"gather_loadD_masked $dst, $mem, $idx, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SEW sew = Assembler::elemtype_to_sew(bt);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vzext_vf2(as_VectorRegister($tmp$$reg), as_VectorRegister($idx$$reg));\n+    __ vsll_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($tmp$$reg), (int)sew);\n+    __ vxor_vv(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg),\n+               as_VectorRegister($dst$$reg));\n+    __ vluxei64_v(as_VectorRegister($dst$$reg), as_Register($mem$$base),\n+                  as_VectorRegister($tmp$$reg), Assembler::v0_t);\n+ %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -4838,3 +4872,2 @@\n-instruct scatter_store(indirect mem, vReg src, vReg idx, vReg tmp) %{\n-  predicate(type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 4 ||\n-            type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 8);\n+instruct scatter_storeS(indirect mem, vReg src, vReg idx, vReg tmp) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 4);\n@@ -4843,1 +4876,1 @@\n-  format %{ \"scatter_store $mem, $idx, $src\\t# KILL $tmp\" %}\n+  format %{ \"scatter_storeS $mem, $idx, $src\\t# KILL $tmp\" %}\n@@ -4856,3 +4889,19 @@\n-instruct scatter_store_masked(indirect mem, vReg src, vReg idx, vRegMask_V0 v0, vReg tmp) %{\n-  predicate(type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 4 ||\n-            type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 8);\n+instruct scatter_storeD(indirect mem, vReg src, vReg idx, vReg tmp) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 8);\n+  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n+  effect(TEMP tmp);\n+  format %{ \"scatter_storeD $mem, $idx, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SEW sew = Assembler::elemtype_to_sew(bt);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this, $src));\n+    __ vzext_vf2(as_VectorRegister($tmp$$reg), as_VectorRegister($idx$$reg));\n+    __ vsll_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($tmp$$reg), (int)sew);\n+    __ vsuxei64_v(as_VectorRegister($src$$reg), as_Register($mem$$base),\n+                  as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scatter_storeS_masked(indirect mem, vReg src, vReg idx, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 4);\n@@ -4861,1 +4910,1 @@\n-  format %{ \"scatter_store_masked $mem, $idx, $src, $v0\\t# KILL $tmp\" %}\n+  format %{ \"scatter_storeS_masked $mem, $idx, $src, $v0\\t# KILL $tmp\" %}\n@@ -4874,0 +4923,17 @@\n+instruct scatter_storeD_masked(indirect mem, vReg src, vReg idx, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 8);\n+  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx v0))));\n+  effect(TEMP tmp);\n+  format %{ \"scatter_storeD_masked $mem, $idx, $src, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SEW sew = Assembler::elemtype_to_sew(bt);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this, $src));\n+    __ vzext_vf2(as_VectorRegister($tmp$$reg), as_VectorRegister($idx$$reg));\n+    __ vsll_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($tmp$$reg), (int)sew);\n+    __ vsuxei64_v(as_VectorRegister($src$$reg), as_Register($mem$$base),\n+                  as_VectorRegister($tmp$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":82,"deletions":16,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -906,2 +906,2 @@\n-                \" are not accepted by server preferences \" +\n-                context.activeProtocols);\n+                \" are not accepted by server preferences \" + Arrays.toString(\n+                ProtocolVersion.toStringArray(context.activeProtocols)));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ClientHello.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1320,7 +1320,0 @@\n-        \/\/ TAB\/SHIFT-TAB should transfer focus and ENTER should select an item.\n-        \/\/ We don't want them to navigate within the table\n-        ActionMap am = SwingUtilities.getUIActionMap(detailsTable);\n-        am.remove(\"selectNextRowCell\");\n-        am.remove(\"selectPreviousRowCell\");\n-        am.remove(\"selectNextColumnCell\");\n-        am.remove(\"selectPreviousColumnCell\");\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/FilePane.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.Point;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+\n+import javax.swing.AbstractButton;\n+import javax.swing.JFileChooser;\n+import javax.swing.JFrame;\n+import javax.swing.JTable;\n+import javax.swing.JToggleButton;\n+import javax.swing.SwingUtilities;\n+import javax.swing.WindowConstants;\n+import javax.swing.UIManager;\n+import javax.swing.table.DefaultTableModel;\n+\n+import java.util.function.Predicate;\n+\n+\/*\n+ * @test\n+ * @bug 6967482\n+ * @key headful\n+ * @summary Test to check if TAB is working on JTable after JFileChooser is\n+ *          closed\n+ * @run main TABTestONFCExit\n+ *\/\n+\n+public class TABTestONFCExit {\n+    private static JTable table;\n+    private static JFileChooser fc;\n+    private static JFrame frame;\n+    private static Robot robot;\n+    private static volatile Point loc;\n+    private static volatile Rectangle rect;\n+    private static volatile int selectedColumnBeforeTabPress;\n+    private static volatile int selectedColumnAfterTabPress;\n+\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+        robot.setAutoDelay(50);\n+        UIManager.setLookAndFeel(\"javax.swing.plaf.metal.MetalLookAndFeel\");\n+        try {\n+            SwingUtilities.invokeAndWait(TABTestONFCExit::initialize);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            SwingUtilities.invokeAndWait(TABTestONFCExit::clickDetails);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            SwingUtilities.invokeAndWait(() -> {\n+                loc = table.getLocationOnScreen();\n+                rect = table.getCellRect(0, 0, true);\n+            });\n+\n+            onClick(loc, rect);\n+\n+            SwingUtilities.invokeAndWait(() ->\n+                    selectedColumnBeforeTabPress = table.getSelectedColumn());\n+\n+            robot.keyPress(KeyEvent.VK_TAB);\n+            robot.keyRelease(KeyEvent.VK_TAB);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            SwingUtilities.invokeAndWait(() ->\n+                    selectedColumnAfterTabPress = table.getSelectedColumn());\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            if (selectedColumnAfterTabPress == selectedColumnBeforeTabPress) {\n+                throw new RuntimeException(\"TAB failed to move cell!\");\n+            }\n+            System.out.println(\"Test Passed\" );\n+\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void onClick(Point loc, Rectangle cellRect) {\n+        robot.mouseMove(loc.x + cellRect.x + cellRect.width \/ 2,\n+                loc.y + cellRect.y + cellRect.height \/ 2);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.waitForIdle();\n+        robot.delay(100);\n+    }\n+\n+    private static void initialize() {\n+        frame = new JFrame(\"Tab Test\");\n+        fc = new JFileChooser();\n+        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n+        frame.add(getJTable(), BorderLayout.NORTH);\n+        frame.add(fc, BorderLayout.SOUTH);\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    private static JTable getJTable() {\n+        if (table == null) {\n+            table = new JTable();\n+            table.setModel(new DefaultTableModel(5, 5));\n+        }\n+        return table;\n+    }\n+    private static void clickDetails() {\n+        AbstractButton details = findDetailsButton(fc);\n+        if (details == null) {\n+            throw new Error(\"Couldn't find 'Details' button in JFileChooser\");\n+        }\n+        details.doClick();\n+    }\n+\n+    private static AbstractButton findDetailsButton(final Container container) {\n+        Component result = findComponent(container,\n+                c -> c instanceof JToggleButton button\n+                        && \"Details\".equals(button.getToolTipText()));\n+        return (AbstractButton) result;\n+    }\n+\n+    private static Component findComponent(final Container container,\n+                                           final Predicate<Component> predicate) {\n+        for (Component child : container.getComponents()) {\n+            if (predicate.test(child)) {\n+                return child;\n+            }\n+            if (child instanceof Container cont && cont.getComponentCount() > 0) {\n+                Component result = findComponent(cont, predicate);\n+                if (result != null) {\n+                    return result;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/TABTestONFCExit.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"}]}