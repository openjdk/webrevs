{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2177,1 +2177,1 @@\n-                Assert.check(requestingOwner.owner.kind == MDL);\n+                Assert.check(requestingOwner.owner instanceof ModuleSymbol);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8159602 8170549 8171255 8171322 8254023\n+ * @bug 8159602 8170549 8171255 8171322 8254023 8341966\n@@ -38,0 +38,1 @@\n+import java.io.OutputStream;\n@@ -40,0 +41,1 @@\n+import java.util.ArrayList;\n@@ -58,0 +60,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -729,0 +732,87 @@\n+    @Test\n+    public void testBrokenModuleInfoClassWithAnnotation(Path base) throws Exception {\n+        Path lib = base.resolve(\"lib\");\n+        tb.writeJavaFiles(lib,\n+                          \"\"\"\n+                          @Deprecated\n+                          module m{}\n+                          \"\"\");\n+\n+        Path libClasses = base.resolve(\"lib-classes\");\n+        Files.createDirectories(libClasses);\n+\n+        new JavacTask(tb)\n+            .options(\"--release\", \"21\")\n+            .outdir(libClasses)\n+            .files(findJavaFiles(lib))\n+            .run()\n+            .writeAll();\n+\n+        Path modifiedModuleInfo = libClasses.resolve(\"module-info.class\");\n+        ClassModel cm1 = ClassFile.of().parse(modifiedModuleInfo);\n+        byte[] newBytes = ClassFile.of().transformClass(cm1, (builder, element) -> {\n+            if (element instanceof ModuleAttribute attr) {\n+                List<ModuleRequireInfo> requires = new ArrayList<>();\n+\n+                for (ModuleRequireInfo mri : attr.requires()) {\n+                    if (mri.requires().name().equalsString(\"java.base\")) {\n+                        requires.add(ModuleRequireInfo.of(mri.requires(),\n+                                                          List.of(AccessFlag.TRANSITIVE),\n+                                                          mri.requiresVersion()\n+                                                             .orElse(null)));\n+                    } else {\n+                        requires.add(mri);\n+                    }\n+                }\n+\n+                builder.accept(ModuleAttribute.of(attr.moduleName(),\n+                                                  attr.moduleFlagsMask(),\n+                                                  attr.moduleVersion()\n+                                                      .orElseGet(() -> null),\n+                                                  requires,\n+                                                  attr.exports(),\n+                                                  attr.opens(),\n+                                                  attr.uses(),\n+                                                  attr.provides()));\n+            } else {\n+                builder.accept(element);\n+            }\n+        });\n+\n+        try (OutputStream out = Files.newOutputStream(modifiedModuleInfo)) {\n+            out.write(newBytes);\n+        }\n+\n+        Path src = base.resolve(\"src\");\n+        Path classes = base.resolve(\"classes\");\n+\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          public class C {}\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> actualErrors =\n+            new JavacTask(tb)\n+                .options(\"--module-path\", libClasses.toString(),\n+                         \"--add-modules\", \"m\",\n+                         \"-XDshould-stop.at=FLOW\",\n+                         \"-XDdev\",\n+                         \"-XDrawDiagnostics\")\n+                .outdir(classes)\n+                .files(findJavaFiles(src))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+        List<String> expectedErrors = List.of(\n+            \"- compiler.err.cant.access: m.module-info, (compiler.misc.bad.class.file.header: module-info.class, (compiler.misc.bad.requires.flag: ACC_TRANSITIVE (0x0020))\",\n+            \"1 error\"\n+        );\n+\n+        if (!expectedErrors.equals(actualErrors)) {\n+            throw new AssertionError(\"Unexpected errors, expected: \" + expectedErrors +\n+                                     \", but got: \" + actualErrors);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/modules\/AnnotationsOnModules.java","additions":92,"deletions":2,"binary":false,"changes":94,"status":"modified"}]}