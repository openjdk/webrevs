{"files":[{"patch":"@@ -612,1 +612,0 @@\n-com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Default.java 8039280 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -627,1 +627,0 @@\n-    com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Default.java \\\n","filename":"test\/jdk\/TEST.groups","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib \/java\/security\/testlibrary\n@@ -28,1 +29,1 @@\n- * @run main\/manual Default\n+ * @run main\/othervm Default\n@@ -32,0 +33,2 @@\n+import jdk.test.lib.Asserts;\n+\n@@ -33,0 +36,1 @@\n+import java.io.*;\n@@ -35,16 +39,25 @@\n-   public static void main(String args[]) throws Exception {\n-        TextCallbackHandler h = new TextCallbackHandler();\n-        NameCallback nc = new NameCallback(\"Name: \", \"charlie\");\n-        ConfirmationCallback cc = new ConfirmationCallback\n-                        (\"Correct?\",\n-                        ConfirmationCallback.INFORMATION,\n-                        ConfirmationCallback.YES_NO_OPTION,\n-                        ConfirmationCallback.NO);\n-\n-        Callback[] callbacks = { nc, cc };\n-        h.handle(callbacks);\n-\n-        if (cc.getSelectedIndex() == ConfirmationCallback.YES) {\n-            System.out.println(\"yes\");\n-        } else {\n-            System.out.println(\"no\");\n+    public static void main(String args[]) throws Exception {\n+        InputStream in = System.in;\n+        PrintStream err = System.err;\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        final String defaultName = \"charlie\";\n+        final String simulatedInput = \"-1\\n-1\\n\";\n+        HumanInputStream humanInputStream = new HumanInputStream(simulatedInput);\n+\n+        try (PrintStream prints = new PrintStream(baos)) {\n+            System.setIn(humanInputStream);\n+            System.setErr(prints);\n+            NameCallback nameCallback = new NameCallback(\"Name: \", defaultName);\n+            ConfirmationCallback confirmationCallback = new ConfirmationCallback(\n+                    \"Correct?\",\n+                    ConfirmationCallback.INFORMATION,\n+                    ConfirmationCallback.YES_NO_OPTION,\n+                    ConfirmationCallback.NO);\n+            new TextCallbackHandler().handle(new Callback[]{nameCallback, confirmationCallback});\n+\n+            Asserts.assertEquals(nameCallback.getDefaultName(), defaultName);\n+            Asserts.assertEquals(confirmationCallback.getSelectedIndex(), ConfirmationCallback.NO);\n+\n+        } finally {\n+            System.setIn(in);\n+            System.setErr(err);\n@@ -52,1 +65,5 @@\n-   }\n+\n+        \/\/ check that the default name and confirmation were visible in the output\n+        Asserts.assertTrue(baos.toString().contains(String.format(\"Name:  [%s]\", defaultName)));\n+        Asserts.assertTrue(baos.toString().contains(\"1. No [default]\"));\n+    }\n","filename":"test\/jdk\/com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Default.java","additions":36,"deletions":19,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+\n+\/**\n+ * HumanInputStream tries to act like a human sitting in front of a computer\n+ * terminal typing on the keyboard while a program is running.\n+ * <p>\n+ * The program may call InputStream.read() and BufferedReader.readLine() in\n+ * various places. a call to B.readLine() will try to buffer as much input as\n+ * possible. Thus, a trivial InputStream will find it impossible to feed\n+ * anything to I.read() after a B.readLine() call.\n+ * <p>\n+ * This is why HumanInputStream was created, which will only send a single line\n+ * to B.readLine(), no more, no less, and the next I.read() can have a chance\n+ * to read the exact character right after \"\\n\".\n+ *\n+ *\/\n+\n+public class HumanInputStream extends InputStream {\n+    byte[] src;\n+    int pos;\n+    int length;\n+    boolean inLine;\n+    int stopIt;\n+\n+    public HumanInputStream(String input) {\n+        src = input.getBytes();\n+        pos = 0;\n+        length = src.length;\n+        stopIt = 0;\n+        inLine = false;\n+    }\n+\n+    \/\/ the trick: when called through read(byte[], int, int),\n+    \/\/ return -1 twice after \"\\n\"\n+\n+    @Override public int read() throws IOException {\n+        int re;\n+        if(pos < length) {\n+            re = src[pos];\n+            if(inLine) {\n+                if(stopIt > 0) {\n+                    stopIt--;\n+                    re = -1;\n+                } else {\n+                    if(re == '\\n') {\n+                        stopIt = 2;\n+                    }\n+                    pos++;\n+                }\n+            } else {\n+                pos++;\n+            }\n+        } else {\n+            re = -1; \/\/throws new IOException(\"NO MORE TO READ\");\n+        }\n+        return re;\n+    }\n+    @Override public int read(byte[] buffer, int offset, int len) {\n+        inLine = true;\n+        try {\n+            return super.read(buffer, offset, len);\n+        } catch(Exception e) {\n+            throw new RuntimeException(\"HumanInputStream error\");\n+        } finally {\n+            inLine = false;\n+        }\n+    }\n+    @Override public int available() {\n+        if (pos < length) return 1;\n+        return 0;\n+    }\n+\n+    \/\/ test part\n+    static void assertTrue(boolean bool) {\n+        if (!bool)\n+            throw new RuntimeException();\n+    }\n+\n+    public static void test() throws Exception {\n+        class Tester {\n+            HumanInputStream is;\n+            BufferedReader reader;\n+            Tester(String s) {\n+                is = new HumanInputStream(s);\n+                reader = new BufferedReader(new InputStreamReader(is));\n+            }\n+\n+            \/\/ three kinds of test method\n+            \/\/ 1. read byte by byte from InputStream\n+            void testStreamReadOnce(int expection) throws Exception {\n+                assertTrue(is.read() == expection);\n+            }\n+            void testStreamReadMany(String expectation) throws Exception {\n+                char[] keys = expectation.toCharArray();\n+                for (char key : keys) {\n+                    assertTrue(is.read() == key);\n+                }\n+            }\n+            \/\/ 2. read a line with a newly created Reader\n+            void testReaderReadline(String expectation) throws Exception {\n+                String s = new BufferedReader(new InputStreamReader(is)).readLine();\n+                if(s == null) assertTrue(expectation == null);\n+                else assertTrue(s.equals(expectation));\n+            }\n+            \/\/ 3. read a line with the old Reader\n+            void testReaderReadline2(String expectation) throws Exception  {\n+                String s = reader.readLine();\n+                if(s == null) assertTrue(expectation == null);\n+                else assertTrue(s.equals(expectation));\n+            }\n+        }\n+\n+        Tester test;\n+\n+        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n+        test.testReaderReadline(\"111\");\n+        test.testReaderReadline(\"222\");\n+        test.testReaderReadline(\"\");\n+        test.testReaderReadline(\"444\");\n+        test.testReaderReadline(\"\");\n+        test.testReaderReadline(null);\n+\n+        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n+        test.testReaderReadline2(\"111\");\n+        test.testReaderReadline2(\"222\");\n+        test.testReaderReadline2(\"\");\n+        test.testReaderReadline2(\"444\");\n+        test.testReaderReadline2(\"\");\n+        test.testReaderReadline2(null);\n+\n+        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n+        test.testReaderReadline2(\"111\");\n+        test.testReaderReadline(\"222\");\n+        test.testReaderReadline2(\"\");\n+        test.testReaderReadline2(\"444\");\n+        test.testReaderReadline(\"\");\n+        test.testReaderReadline2(null);\n+\n+        test = new Tester(\"1\\n2\");\n+        test.testStreamReadMany(\"1\\n2\");\n+        test.testStreamReadOnce(-1);\n+\n+        test = new Tester(\"12\\n234\");\n+        test.testStreamReadOnce('1');\n+        test.testReaderReadline(\"2\");\n+        test.testStreamReadOnce('2');\n+        test.testReaderReadline2(\"34\");\n+        test.testReaderReadline2(null);\n+\n+        test = new Tester(\"changeit\\n\");\n+        test.testStreamReadMany(\"changeit\\n\");\n+        test.testReaderReadline(null);\n+\n+        test = new Tester(\"changeit\\nName\\nCountry\\nYes\\n\");\n+        test.testStreamReadMany(\"changeit\\n\");\n+        test.testReaderReadline(\"Name\");\n+        test.testReaderReadline(\"Country\");\n+        test.testReaderReadline(\"Yes\");\n+        test.testReaderReadline(null);\n+\n+        test = new Tester(\"Me\\nHere\\n\");\n+        test.testReaderReadline2(\"Me\");\n+        test.testReaderReadline2(\"Here\");\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/testlibrary\/HumanInputStream.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/java\/security\/testlibrary\n@@ -1868,169 +1869,1 @@\n-}\n-\n-\/**\n- * HumanInputStream tries to act like a human sitting in front of a computer\n- * terminal typing on the keyboard while the keytool program is running.\n- *\n- * keytool has called InputStream.read() and BufferedReader.readLine() in\n- * various places. a call to B.readLine() will try to buffer as much input as\n- * possible. Thus, a trivial InputStream will find it impossible to feed\n- * anything to I.read() after a B.readLine() call.\n- *\n- * This is why i create HumanInputStream, which will only send a single line\n- * to B.readLine(), no more, no less, and the next I.read() can have a chance\n- * to read the exact character right after \"\\n\".\n- *\n- * I don't know why HumanInputStream works.\n- *\/\n-class HumanInputStream extends InputStream {\n-    byte[] src;\n-    int pos;\n-    int length;\n-    boolean inLine;\n-    int stopIt;\n-\n-    public HumanInputStream(String input) {\n-        src = input.getBytes();\n-        pos = 0;\n-        length = src.length;\n-        stopIt = 0;\n-        inLine = false;\n-    }\n-\n-    \/\/ the trick: when called through read(byte[], int, int),\n-    \/\/ return -1 twice after \"\\n\"\n-\n-    @Override public int read() throws IOException {\n-        int re;\n-        if(pos < length) {\n-            re = src[pos];\n-            if(inLine) {\n-                if(stopIt > 0) {\n-                    stopIt--;\n-                    re = -1;\n-                } else {\n-                    if(re == '\\n') {\n-                        stopIt = 2;\n-                    }\n-                    pos++;\n-                }\n-            } else {\n-                pos++;\n-            }\n-        } else {\n-            re = -1;\/\/throw new IOException(\"NO MORE TO READ\");\n-        }\n-        \/\/if (re < 32) System.err.printf(\"[%02d]\", re);\n-        \/\/else System.err.printf(\"[%c]\", (char)re);\n-        return re;\n-    }\n-    @Override public int read(byte[] buffer, int offset, int len) {\n-        inLine = true;\n-        try {\n-            int re = super.read(buffer, offset, len);\n-            return re;\n-        } catch(Exception e) {\n-            throw new RuntimeException(\"HumanInputStream error\");\n-        } finally {\n-            inLine = false;\n-        }\n-    }\n-    @Override public int available() {\n-        if(pos < length) return 1;\n-        return 0;\n-    }\n-\n-    \/\/ test part\n-    static void assertTrue(boolean bool) {\n-        if(!bool)\n-            throw new RuntimeException();\n-    }\n-\n-    public static void test() throws Exception {\n-\n-        class Tester {\n-            HumanInputStream is;\n-            BufferedReader reader;\n-            Tester(String s) {\n-                is = new HumanInputStream(s);\n-                reader = new BufferedReader(new InputStreamReader(is));\n-            }\n-\n-            \/\/ three kinds of test method\n-            \/\/ 1. read byte by byte from InputStream\n-            void testStreamReadOnce(int expection) throws Exception {\n-                assertTrue(is.read() == expection);\n-            }\n-            void testStreamReadMany(String expection) throws Exception {\n-                char[] keys = expection.toCharArray();\n-                for(int i=0; i<keys.length; i++) {\n-                    assertTrue(is.read() == keys[i]);\n-                }\n-            }\n-            \/\/ 2. read a line with a newly created Reader\n-            void testReaderReadline(String expection) throws Exception {\n-                String s = new BufferedReader(new InputStreamReader(is)).readLine();\n-                if(s == null) assertTrue(expection == null);\n-                else assertTrue(s.equals(expection));\n-            }\n-            \/\/ 3. read a line with the old Reader\n-            void testReaderReadline2(String expection) throws Exception  {\n-                String s = reader.readLine();\n-                if(s == null) assertTrue(expection == null);\n-                else assertTrue(s.equals(expection));\n-            }\n-        }\n-\n-        Tester test;\n-\n-        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n-        test.testReaderReadline(\"111\");\n-        test.testReaderReadline(\"222\");\n-        test.testReaderReadline(\"\");\n-        test.testReaderReadline(\"444\");\n-        test.testReaderReadline(\"\");\n-        test.testReaderReadline(null);\n-\n-        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n-        test.testReaderReadline2(\"111\");\n-        test.testReaderReadline2(\"222\");\n-        test.testReaderReadline2(\"\");\n-        test.testReaderReadline2(\"444\");\n-        test.testReaderReadline2(\"\");\n-        test.testReaderReadline2(null);\n-\n-        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n-        test.testReaderReadline2(\"111\");\n-        test.testReaderReadline(\"222\");\n-        test.testReaderReadline2(\"\");\n-        test.testReaderReadline2(\"444\");\n-        test.testReaderReadline(\"\");\n-        test.testReaderReadline2(null);\n-\n-        test = new Tester(\"1\\n2\");\n-        test.testStreamReadMany(\"1\\n2\");\n-        test.testStreamReadOnce(-1);\n-\n-        test = new Tester(\"12\\n234\");\n-        test.testStreamReadOnce('1');\n-        test.testReaderReadline(\"2\");\n-        test.testStreamReadOnce('2');\n-        test.testReaderReadline2(\"34\");\n-        test.testReaderReadline2(null);\n-\n-        test = new Tester(\"changeit\\n\");\n-        test.testStreamReadMany(\"changeit\\n\");\n-        test.testReaderReadline(null);\n-\n-        test = new Tester(\"changeit\\nName\\nCountry\\nYes\\n\");\n-        test.testStreamReadMany(\"changeit\\n\");\n-        test.testReaderReadline(\"Name\");\n-        test.testReaderReadline(\"Country\");\n-        test.testReaderReadline(\"Yes\");\n-        test.testReaderReadline(null);\n-\n-        test = new Tester(\"Me\\nHere\\n\");\n-        test.testReaderReadline2(\"Me\");\n-        test.testReaderReadline2(\"Here\");\n-    }\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/KeyToolTest.java","additions":3,"deletions":170,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @library \/test\/lib \/test\/jdk\/sun\/security\/pkcs11\n+ * @library \/test\/lib \/test\/jdk\/sun\/security\/pkcs11 \/java\/security\/testlibrary\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/NssTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}