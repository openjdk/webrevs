{"files":[{"patch":"@@ -1117,0 +1117,4 @@\n+size_t WhiteBox::get_in_use_monitor_count() {\n+  return ObjectSynchronizer::_in_use_list.count();\n+}\n+\n@@ -1852,0 +1856,4 @@\n+WB_ENTRY(jlong, WB_getInUseMonitorCount(JNIEnv* env, jobject wb))\n+  return (jlong) WhiteBox::get_in_use_monitor_count();\n+WB_END\n+\n@@ -2838,0 +2846,1 @@\n+  {CC\"getInUseMonitorCount\", CC\"()J\", (void*)&WB_getInUseMonitorCount  },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+  static size_t get_in_use_monitor_count();\n","filename":"src\/hotspot\/share\/prims\/whitebox.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+  friend class WhiteBox;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -24,7 +24,0 @@\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-import java.io.IOException;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n@@ -35,1 +28,6 @@\n- * @run driver TestRecursiveMonitorChurn\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xmx100M -XX:AsyncDeflationInterval=0 -XX:GuaranteedAsyncDeflationInterval=0\n+ *                   -Xlog:monitorinflation=trace\n+ *                   TestRecursiveMonitorChurn\n@@ -37,0 +35,4 @@\n+\n+import jdk.test.whitebox.WhiteBox;\n+import jtreg.SkippedException;\n+\n@@ -49,0 +51,4 @@\n+    static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    static final int LM_MONITOR = 0;\n+    static final int COUNT = 100000;\n+\n@@ -50,17 +56,13 @@\n-    public static void main(String[] args) throws IOException {\n-        if (args.length == 1 && args[0].equals(\"test\")) {\n-            \/\/ The actual test, in a forked JVM.\n-            for (int i = 0; i < 100000; i++) {\n-                monitor = new Monitor();\n-                monitor.doSomething();\n-            }\n-            System.out.println(\"i + j = \" + (Monitor.i + Monitor.j));\n-        } else {\n-            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n-                    \"-XX:+UnlockDiagnosticVMOptions\",\n-                    \"-Xmx100M\", \"-XX:AsyncDeflationInterval=0\", \"-XX:GuaranteedAsyncDeflationInterval=0\",\n-                    \"-XX:NativeMemoryTracking=summary\", \"-XX:+PrintNMTStatistics\",\n-                    \"TestRecursiveMonitorChurn\",\n-                    \"test\");\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-            output.reportDiagnosticSummary();\n+    public static void main(String[] args) {\n+        if (WB.getIntVMFlag(\"LockingMode\") == LM_MONITOR) {\n+            throw new SkippedException(\"LM_MONITOR always inflates. Invalid test.\");\n+        }\n+        final long pre_monitor_count = WB.getInUseMonitorCount();\n+        System.out.println(\" Precount = \" + pre_monitor_count);\n+        for (int i = 0; i < COUNT; i++) {\n+            monitor = new Monitor();\n+            monitor.doSomething();\n+        }\n+        System.out.println(\"i + j = \" + (Monitor.i + Monitor.j));\n+        final long post_monitor_count = WB.getInUseMonitorCount();\n+        System.out.println(\"Postcount = \" + post_monitor_count);\n@@ -68,1 +70,3 @@\n-            output.shouldHaveExitValue(0);\n+        if (pre_monitor_count != post_monitor_count) {\n+            final long monitor_count_change = post_monitor_count - pre_monitor_count;\n+            System.out.println(\"Unexpected change in monitor count: \" + monitor_count_change);\n@@ -70,8 +74,10 @@\n-            \/\/ We want to see, in the final NMT printout, a committed object monitor size that is reasonably low.\n-            \/\/ Like this:\n-            \/\/ -           Object Monitors (reserved=208, committed=208)\n-            \/\/                             (malloc=208 #1) (at peak)\n-            \/\/\n-            \/\/ Without recursive locking support, this would look more like this:\n-            \/\/ -           Object Monitors (reserved=20800624, committed=20800624)\n-            \/\/                             (malloc=20800624 #100003) (at peak)\n+            \/\/ Intermittent deflation and inflation may occur due to running the test\n+            \/\/ with stress flags (like DeoptimizeALot) or with added instrumentation\n+            \/\/ which runs in the same VM.\n+            \/\/ An arbitrary fuzzy max difference of 10 (= 0.01% of COUNT) is chosen to\n+            \/\/ allow for these occurrences to be skipped while still catching regressions.\n+            final long fuzzy_max_difference = 10;\n+            if (Math.abs(monitor_count_change) < fuzzy_max_difference) {\n+                final String type = monitor_count_change < 0 ? \"deflation\" : \"inflation\";\n+                throw new SkippedException(\"Intermittent \" + type + \" detected. Invalid test.\");\n+            }\n@@ -79,12 +85,2 @@\n-            Pattern pat = Pattern.compile(\"- *Object Monitors.*reserved=(\\\\d+), committed=(\\\\d+).*\");\n-            for (String line : output.asLines()) {\n-                Matcher m = pat.matcher(line);\n-                if (m.matches()) {\n-                    long reserved = Long.parseLong(m.group(1));\n-                    long committed = Long.parseLong(m.group(2));\n-                    System.out.println(\">>>>> \" + line + \": \" + reserved + \" - \" + committed);\n-                    if (committed > 1000) {\n-                        throw new RuntimeException(\"Allocated too many monitors\");\n-                    }\n-                    return;\n-                }\n+            if (monitor_count_change < 0) {\n+                throw new RuntimeException(\"Unexpected Deflation\");\n@@ -92,1 +88,1 @@\n-            throw new RuntimeException(\"Did not find expected NMT output\");\n+            throw new RuntimeException(\"Unexpected Inflation\");\n","filename":"test\/hotspot\/jtreg\/runtime\/locking\/TestRecursiveMonitorChurn.java","additions":43,"deletions":47,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -122,0 +122,2 @@\n+  public native long getInUseMonitorCount();\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}