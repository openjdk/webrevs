{"files":[{"patch":"@@ -106,5 +106,0 @@\n-    _iterator.nmethods_do_begin();\n-  }\n-\n-  ~ShenandoahDisarmNMethodsTask() {\n-    _iterator.nmethods_do_end();\n@@ -178,7 +173,1 @@\n-    _iterator(ShenandoahCodeRoots::table()) {\n-    _iterator.nmethods_do_begin();\n-  }\n-\n-  ~ShenandoahUnlinkTask() {\n-    _iterator.nmethods_do_end();\n-  }\n+    _iterator(ShenandoahCodeRoots::table()) {}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -773,5 +773,1 @@\n-    _phase(phase) {\n-    if (ShenandoahHeap::heap()->unload_classes()) {\n-      _nmethod_itr.nmethods_do_begin();\n-    }\n-  }\n+    _phase(phase) {}\n@@ -780,3 +776,0 @@\n-    if (ShenandoahHeap::heap()->unload_classes()) {\n-      _nmethod_itr.nmethods_do_end();\n-    }\n@@ -884,11 +877,1 @@\n-    _nmethod_itr(ShenandoahCodeRoots::table()) {\n-    if (!ShenandoahHeap::heap()->unload_classes()) {\n-      _nmethod_itr.nmethods_do_begin();\n-    }\n-  }\n-\n-  ~ShenandoahConcurrentRootsEvacUpdateTask() {\n-    if (!ShenandoahHeap::heap()->unload_classes()) {\n-      _nmethod_itr.nmethods_do_end();\n-    }\n-  }\n+    _nmethod_itr(ShenandoahCodeRoots::table()) {}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/safepointVerifiers.hpp\"\n@@ -478,7 +479,4 @@\n-  _table(table), _table_snapshot(nullptr) {\n-}\n-\n-void ShenandoahConcurrentNMethodIterator::nmethods_do_begin() {\n-  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-  _table_snapshot = _table->snapshot_for_iteration();\n-}\n+  _table(table),\n+  _table_snapshot(nullptr),\n+  _started_workers(0),\n+  _finished_workers(0) {}\n@@ -487,3 +485,3 @@\n-  assert(_table_snapshot != nullptr, \"Must first call nmethod_do_begin()\");\n-  _table_snapshot->concurrent_nmethods_do(cl);\n-}\n+  \/\/ Cannot safepoint when iteration is running, because this can cause deadlocks\n+  \/\/ with other threads waiting on iteration to be over.\n+  NoSafepointVerifier nsv;\n@@ -491,4 +489,26 @@\n-void ShenandoahConcurrentNMethodIterator::nmethods_do_end() {\n-  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-  _table->finish_iteration(_table_snapshot);\n-  CodeCache_lock->notify_all();\n+  MutexLocker ml(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+\n+  if (_finished_workers > 0) {\n+    \/\/ Some threads have already finished. We are now in rampdown: we are now\n+    \/\/ waiting for all currently recorded workers to finish. No new workers\n+    \/\/ should start.\n+    return;\n+  }\n+\n+  \/\/ Record a new worker and initialize the snapshot if it is a first visitor.\n+  if (_started_workers++ == 0) {\n+    _table_snapshot = _table->snapshot_for_iteration();\n+  }\n+\n+  \/\/ All set, relinquish the lock and go concurrent.\n+  {\n+    MutexUnlocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    _table_snapshot->concurrent_nmethods_do(cl);\n+  }\n+\n+  \/\/ Record completion. Last worker shuts down the iterator and notifies any waiters.\n+  uint count = ++_finished_workers;\n+  if (count == _started_workers) {\n+    _table->finish_iteration(_table_snapshot);\n+    CodeCache_lock->notify_all();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.cpp","additions":34,"deletions":14,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -184,0 +184,2 @@\n+  uint                                  _started_workers;\n+  uint                                  _finished_workers;\n@@ -188,1 +190,0 @@\n-  void nmethods_do_begin();\n@@ -190,1 +191,0 @@\n-  void nmethods_do_end();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}