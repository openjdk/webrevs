{"files":[{"patch":"@@ -1,228 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package gc.stress.gclocker;\n-\n-\/\/ Stress the GC locker by calling GetPrimitiveArrayCritical while\n-\/\/ concurrently filling up old gen.\n-\n-import java.lang.management.MemoryPoolMXBean;\n-import java.lang.management.ManagementFactory;\n-import java.lang.management.MemoryUsage;\n-import java.util.ArrayDeque;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Queue;\n-\n-final class ThreadUtils {\n-    public static void sleep(long durationMS) {\n-        try {\n-            Thread.sleep(durationMS);\n-        } catch (Exception e) {\n-        }\n-    }\n-}\n-\n-class Filler {\n-    private static final int SIZE = 250000;\n-\n-    private int[] i1 = new int[SIZE];\n-    private int[] i2 = new int[SIZE];\n-    private short[] s1 = new short[SIZE];\n-    private short[] s2 = new short[SIZE];\n-\n-    private Map<Object, Object> map = new HashMap<>();\n-\n-    public Filler() {\n-        for (int i = 0; i < 10000; i++) {\n-            map.put(new Object(), new Object());\n-        }\n-    }\n-}\n-\n-class Exitable {\n-    private volatile boolean shouldExit = false;\n-\n-    protected boolean shouldExit() {\n-        return shouldExit;\n-    }\n-\n-    public void exit() {\n-        shouldExit = true;\n-    }\n-}\n-\n-class MemoryWatcher {\n-    private MemoryPoolMXBean bean;\n-    private final int thresholdPromille = 750;\n-    private final int criticalThresholdPromille = 800;\n-    private final long minGCWaitNanos = 1_000_000_000L;\n-    private final long minFreeWaitElapsedNanos = 30L * 1_000_000_000L;\n-    private final long minFreeCriticalWaitNanos;\n-\n-    private int lastUsage = 0;\n-    private long lastGCDetectedNanos = System.nanoTime();\n-    private long lastFreeNanos = System.nanoTime();\n-\n-    public MemoryWatcher(String mxBeanName, long minFreeCriticalWaitNanos) {\n-        this.minFreeCriticalWaitNanos = minFreeCriticalWaitNanos;\n-        List<MemoryPoolMXBean> memoryBeans = ManagementFactory.getMemoryPoolMXBeans();\n-        for (MemoryPoolMXBean bean : memoryBeans) {\n-            if (bean.getName().equals(mxBeanName)) {\n-                this.bean = bean;\n-                break;\n-            }\n-        }\n-    }\n-\n-    private int getMemoryUsage() {\n-        if (bean == null) {\n-            Runtime r = Runtime.getRuntime();\n-            float free = (float) r.freeMemory() \/ r.maxMemory();\n-            return Math.round((1 - free) * 1000);\n-        } else {\n-            MemoryUsage usage = bean.getUsage();\n-            float used = (float) usage.getUsed() \/ usage.getCommitted();\n-            return Math.round(used * 1000);\n-        }\n-    }\n-\n-    public synchronized boolean shouldFreeUpSpace() {\n-        int usage = getMemoryUsage();\n-        long nowNanos = System.nanoTime();\n-\n-        boolean detectedGC = false;\n-        if (usage < lastUsage) {\n-            lastGCDetectedNanos = nowNanos;\n-            detectedGC = true;\n-        }\n-\n-        lastUsage = usage;\n-\n-        long elapsedNanos = nowNanos - lastFreeNanos;\n-        long timeSinceLastGCNanos = nowNanos - lastGCDetectedNanos;\n-\n-        if (usage > criticalThresholdPromille && elapsedNanos > minFreeCriticalWaitNanos) {\n-            lastFreeNanos = nowNanos;\n-            return true;\n-        } else if (usage > thresholdPromille && !detectedGC) {\n-            if (elapsedNanos > minFreeWaitElapsedNanos || timeSinceLastGCNanos > minGCWaitNanos) {\n-                lastFreeNanos = nowNanos;\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-}\n-\n-class MemoryUser extends Exitable implements Runnable {\n-    private final Queue<Filler> cache = new ArrayDeque<Filler>();\n-    private final MemoryWatcher watcher;\n-\n-    private void load() {\n-        if (watcher.shouldFreeUpSpace()) {\n-            int toRemove = cache.size() \/ 5;\n-            for (int i = 0; i < toRemove; i++) {\n-                cache.remove();\n-            }\n-        }\n-        cache.add(new Filler());\n-    }\n-\n-    public MemoryUser(String mxBeanName, long minFreeCriticalWaitNanos) {\n-        watcher = new MemoryWatcher(mxBeanName, minFreeCriticalWaitNanos);\n-    }\n-\n-    @Override\n-    public void run() {\n-        for (int i = 0; i < 200; i++) {\n-            load();\n-        }\n-\n-        while (!shouldExit()) {\n-            load();\n-        }\n-    }\n-}\n-\n-class GCLockerStresser extends Exitable implements Runnable {\n-    static native void fillWithRandomValues(byte[] array);\n-\n-    @Override\n-    public void run() {\n-        byte[] array = new byte[1024 * 1024];\n-        while (!shouldExit()) {\n-            fillWithRandomValues(array);\n-        }\n-    }\n-}\n-\n-public class TestGCLocker {\n-    private static Exitable startGCLockerStresser(String name) {\n-        GCLockerStresser task = new GCLockerStresser();\n-\n-        Thread thread = new Thread(task);\n-        thread.setName(name);\n-        thread.setPriority(Thread.MIN_PRIORITY);\n-        thread.start();\n-\n-        return task;\n-    }\n-\n-    private static Exitable startMemoryUser(String mxBeanName, long minFreeCriticalWaitNanos) {\n-        MemoryUser task = new MemoryUser(mxBeanName, minFreeCriticalWaitNanos);\n-\n-        Thread thread = new Thread(task);\n-        thread.setName(\"Memory User\");\n-        thread.start();\n-\n-        return task;\n-    }\n-\n-    public static void main(String[] args) {\n-        System.loadLibrary(\"TestGCLocker\");\n-\n-        long durationMinutes = args.length > 0 ? Long.parseLong(args[0]) : 5;\n-        String mxBeanName = args.length > 1 ? args[1] : null;\n-        long minFreeCriticalWaitNanos = args.length > 2\n-            ? Integer.parseInt(args[2]) * 1_000_000L\n-            : 500_000_000L;\n-\n-        Exitable stresser1 = startGCLockerStresser(\"GCLockerStresser1\");\n-        Exitable stresser2 = startGCLockerStresser(\"GCLockerStresser2\");\n-        Exitable memoryUser = startMemoryUser(mxBeanName, minFreeCriticalWaitNanos);\n-\n-        try {\n-            Thread.sleep(durationMinutes * 60_000L);\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(\"Test Failure, did not except an InterruptedException\", e);\n-        }\n-\n-        stresser1.exit();\n-        stresser2.exit();\n-        memoryUser.exit();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gclocker\/TestGCLocker.java","additions":0,"deletions":228,"binary":false,"changes":228,"status":"deleted"}]}