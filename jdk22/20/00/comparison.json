{"files":[{"patch":"@@ -155,0 +155,13 @@\n+void ZBarrierSet::clone_obj_array(objArrayOop src_obj, objArrayOop dst_obj, size_t size) {\n+  volatile zpointer* src = (volatile zpointer*)src_obj->base();\n+  volatile zpointer* dst = (volatile zpointer*)dst_obj->base();\n+\n+  for (const zpointer* const end = cast_from_oop<const zpointer*>(src_obj) + size; src < end; src++, dst++) {\n+    zaddress elem = ZBarrier::load_barrier_on_oop_field(src);\n+    \/\/ We avoid healing here because the store below colors the pointer store good,\n+    \/\/ hence avoiding the cost of a CAS.\n+    ZBarrier::store_barrier_on_heap_oop_field(dst, false \/* heal *\/);\n+    Atomic::store(dst, ZAddress::store_good(elem));\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+  static void clone_obj_array(objArrayOop src, objArrayOop dst, size_t size);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -406,1 +406,1 @@\n-class ZStoreBarrierOopClosure : public BasicOopIterateClosure {\n+class ZColorStoreGoodOopClosure : public BasicOopIterateClosure {\n@@ -412,2 +412,1 @@\n-    ZBarrier::store_barrier_on_heap_oop_field(p, false \/* heal *\/);\n-    *p = ZAddress::store_good(addr);\n+    Atomic::store(p, ZAddress::store_good(addr));\n@@ -436,0 +435,11 @@\n+  if (dst->is_objArray()) {\n+    \/\/ Cloning an object array is similar to performing array copy.\n+    \/\/ If an array is large enough to have its allocation segmented,\n+    \/\/ this operation might require GC barriers. However, the intrinsics\n+    \/\/ for cloning arrays transform the clone to an optimized allocation\n+    \/\/ and arraycopy sequence, so the performance of this runtime call\n+    \/\/ does not matter for object arrays.\n+    clone_obj_array(objArrayOop(src), objArrayOop(dst), size);\n+    return;\n+  }\n+\n@@ -443,1 +453,1 @@\n-  assert(ZHeap::heap()->is_young(to_zaddress(dst)), \"ZColorStoreGoodOopClosure is only valid for young objects\");\n+  assert(dst->is_typeArray() || ZHeap::heap()->is_young(to_zaddress(dst)), \"ZColorStoreGoodOopClosure is only valid for young objects\");\n@@ -446,1 +456,1 @@\n-  ZStoreBarrierOopClosure cl_sg;\n+  ZColorStoreGoodOopClosure cl_sg;\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.inline.hpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"}]}