{"files":[{"patch":"@@ -788,0 +788,1 @@\n+  # The minidumps are disabled by default on client Windows, so enable them\n@@ -790,0 +791,1 @@\n+    $1_JTREG_BASIC_OPTIONS += -vmoption:-XX:+CreateCoredumpOnCrash\n@@ -854,1 +856,1 @@\n-      $$(JAVA) $$($1_JTREG_LAUNCHER_OPTIONS) \\\n+      $$(JTREG_JAVA) $$($1_JTREG_LAUNCHER_OPTIONS) \\\n","filename":"make\/RunTests.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -285,1 +285,2 @@\n-      __ ldp(r19, r20, Address(OSR_buf, slot_offset));\n+      __ ldr(r19, Address(OSR_buf, slot_offset));\n+      __ ldr(r20, Address(OSR_buf, slot_offset + BytesPerWord));\n@@ -2721,0 +2722,1 @@\n+    assert_different_registers(obj, tmp, rscratch1, rscratch2, mdo_addr.base(), mdo_addr.index());\n@@ -2722,0 +2724,2 @@\n+  } else {\n+    assert_different_registers(obj, rscratch1, rscratch2, mdo_addr.base(), mdo_addr.index());\n@@ -2778,2 +2782,2 @@\n-          \/\/ There is a chance that the checks above (re-reading profiling\n-          \/\/ data from memory) fail if another thread has just set the\n+          \/\/ There is a chance that the checks above\n+          \/\/ fail if another thread has just set the\n@@ -2782,0 +2786,1 @@\n+          __ eor(tmp, tmp, rscratch2); \/\/ get back original value before XOR\n@@ -2806,0 +2811,4 @@\n+#ifdef ASSERT\n+        __ andr(tmp, tmp, TypeEntries::type_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n@@ -2837,0 +2846,4 @@\n+#ifdef ASSERT\n+        __ andr(tmp, tmp, TypeEntries::type_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1676,1 +1676,1 @@\n-  assert_different_registers(obj, rscratch1);\n+  assert_different_registers(obj, rscratch1, mdo_addr.base(), mdo_addr.index());\n@@ -1698,1 +1698,0 @@\n-  ldr(rscratch1, mdo_addr);\n@@ -1702,2 +1701,2 @@\n-  \/\/ There is a chance that the checks above (re-reading profiling\n-  \/\/ data from memory) fail if another thread has just set the\n+  \/\/ There is a chance that the checks above\n+  \/\/ fail if another thread has just set the\n@@ -1705,0 +1704,1 @@\n+  eor(obj, obj, rscratch1); \/\/ get back original value before XOR\n@@ -1717,0 +1717,4 @@\n+#ifdef ASSERT\n+  andr(obj, obj, TypeEntries::type_mask);\n+  verify_klass_ptr(obj);\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3638,2 +3638,13 @@\n-  if (tmp != obj) {\n-    __ mov(tmp, obj);\n+#ifdef ASSERT\n+  if (obj == tmp) {\n+#ifdef _LP64\n+    assert_different_registers(obj, rscratch1, mdo_addr.base(), mdo_addr.index());\n+#else\n+    assert_different_registers(obj, mdo_addr.base(), mdo_addr.index());\n+#endif\n+  } else {\n+#ifdef _LP64\n+    assert_different_registers(obj, tmp, rscratch1, mdo_addr.base(), mdo_addr.index());\n+#else\n+    assert_different_registers(obj, tmp, mdo_addr.base(), mdo_addr.index());\n+#endif\n@@ -3641,0 +3652,1 @@\n+#endif\n@@ -3642,1 +3654,1 @@\n-    __ testptr(tmp, tmp);\n+    __ testptr(obj, obj);\n@@ -3645,0 +3657,8 @@\n+      __ testptr(mdo_addr, TypeEntries::null_seen);\n+#ifndef ASSERT\n+      __ jccb(Assembler::notZero, next); \/\/ already set\n+#else\n+      __ jcc(Assembler::notZero, next); \/\/ already set\n+#endif\n+      \/\/ atomic update to prevent overwriting Klass* with 0\n+      __ lock();\n@@ -3652,1 +3672,1 @@\n-    __ testptr(tmp, tmp);\n+    __ testptr(obj, obj);\n@@ -3664,1 +3684,1 @@\n-      __ load_klass(tmp, tmp, tmp_load_klass);\n+      __ load_klass(tmp, obj, tmp_load_klass);\n@@ -3679,1 +3699,1 @@\n-          __ load_klass(tmp, tmp, tmp_load_klass);\n+          __ load_klass(tmp, obj, tmp_load_klass);\n@@ -3681,1 +3701,3 @@\n-\n+#ifdef _LP64\n+        __ mov(rscratch1, tmp); \/\/ save original value before XOR\n+#endif\n@@ -3692,4 +3714,3 @@\n-          __ cmpptr(mdo_addr, 0);\n-          __ jccb(Assembler::equal, none);\n-          __ cmpptr(mdo_addr, TypeEntries::null_seen);\n-          __ jccb(Assembler::equal, none);\n+          __ testptr(mdo_addr, TypeEntries::type_mask);\n+          __ jccb(Assembler::zero, none);\n+#ifdef _LP64\n@@ -3699,0 +3720,1 @@\n+          __ mov(tmp, rscratch1); \/\/ get back original value before XOR\n@@ -3702,0 +3724,1 @@\n+#endif\n@@ -3707,2 +3730,1 @@\n-        __ movptr(tmp, mdo_addr);\n-        __ testptr(tmp, TypeEntries::type_unknown);\n+        __ testptr(mdo_addr, TypeEntries::type_unknown);\n@@ -3721,0 +3743,4 @@\n+#ifdef ASSERT\n+        __ andptr(tmp, TypeEntries::type_klass_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n@@ -3735,4 +3761,2 @@\n-          __ cmpptr(mdo_addr, 0);\n-          __ jcc(Assembler::equal, ok);\n-          __ cmpptr(mdo_addr, TypeEntries::null_seen);\n-          __ jcc(Assembler::equal, ok);\n+          __ testptr(mdo_addr, TypeEntries::type_mask);\n+          __ jcc(Assembler::zero, ok);\n@@ -3754,0 +3778,4 @@\n+#ifdef ASSERT\n+        __ andptr(tmp, TypeEntries::type_klass_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n@@ -3758,2 +3786,1 @@\n-        __ movptr(tmp, mdo_addr);\n-        __ testptr(tmp, TypeEntries::type_unknown);\n+        __ testptr(mdo_addr, TypeEntries::type_unknown);\n@@ -3765,2 +3792,1 @@\n-\n-    __ bind(next);\n+  __ bind(next);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":47,"deletions":21,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -55,0 +55,6 @@\n+#ifdef _LP64\n+  assert_different_registers(obj, rscratch1, mdo_addr.base(), mdo_addr.index());\n+#else\n+  assert_different_registers(obj, mdo_addr.base(), mdo_addr.index());\n+#endif\n+\n@@ -59,0 +65,4 @@\n+  testptr(mdo_addr, TypeEntries::null_seen);\n+  jccb(Assembler::notZero, next); \/\/ null already seen. Nothing to do anymore.\n+  \/\/ atomic update to prevent overwriting Klass* with 0\n+  lock();\n@@ -65,0 +75,3 @@\n+#ifdef _LP64\n+  mov(rscratch1, obj);\n+#endif\n@@ -79,0 +92,1 @@\n+#ifdef _LP64\n@@ -82,0 +96,1 @@\n+  mov(obj, rscratch1);\n@@ -85,0 +100,1 @@\n+#endif\n@@ -93,0 +109,4 @@\n+#ifdef ASSERT\n+  andptr(obj, TypeEntries::type_klass_mask);\n+  verify_klass_ptr(obj);\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -839,0 +839,1 @@\n+  void testptr(Address src, int32_t imm32) {  LP64_ONLY(testq(src, imm32)) NOT_LP64(testl(src, imm32)); }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -370,1 +370,1 @@\n-  if (ent->is_jar() && !ent->is_signed() && ent->manifest() != NULL) {\n+  if (ent->is_jar() && ent->manifest() != NULL) {\n@@ -637,23 +637,0 @@\n-\n-  \/\/ The return value indicates if the JAR is signed or not\n-  bool check_is_signed() {\n-    u1* attr = _current;\n-    bool isSigned = false;\n-    while (_current < _buffer_end) {\n-      if (*_current == '\\n') {\n-        *_current = '\\0';\n-        u1* value = (u1*)strchr((char*)attr, ':');\n-        if (value != NULL) {\n-          assert(*(value+1) == ' ', \"Unrecognized format\" );\n-          if (strstr((char*)attr, \"-Digest\") != NULL) {\n-            isSigned = true;\n-            break;\n-          }\n-        }\n-        *_current = '\\n'; \/\/ restore\n-        attr = _current + 1;\n-      }\n-      _current ++;\n-    }\n-    return isSigned;\n-  }\n@@ -672,12 +649,8 @@\n-    if (stream->check_is_signed()) {\n-      ent->set_is_signed();\n-    } else {\n-      \/\/ Copy the manifest into the shared archive\n-      manifest = ClassLoaderExt::read_raw_manifest(THREAD, cpe, &manifest_size);\n-      Array<u1>* buf = MetadataFactory::new_array<u1>(loader_data,\n-                                                      manifest_size,\n-                                                      CHECK);\n-      char* p = (char*)(buf->data());\n-      memcpy(p, manifest, manifest_size);\n-      ent->set_manifest(buf);\n-    }\n+    \/\/ Copy the manifest into the shared archive\n+    manifest = ClassLoaderExt::read_raw_manifest(THREAD, cpe, &manifest_size);\n+    Array<u1>* buf = MetadataFactory::new_array<u1>(loader_data,\n+                                                    manifest_size,\n+                                                    CHECK);\n+    char* p = (char*)(buf->data());\n+    memcpy(p, manifest, manifest_size);\n+    ent->set_manifest(buf);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":9,"deletions":36,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-    signed_jar_entry,\n@@ -81,4 +80,0 @@\n-  bool is_signed()        const { return _type == signed_jar_entry; }\n-  void set_is_signed() {\n-    _type = signed_jar_entry;\n-  }\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -848,3 +848,0 @@\n-      assert(gch->gc_cause() == GCCause::_scavenge_alot ||\n-             !gch->incremental_collection_failed(),\n-             \"Twice in a row\");\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -972,0 +972,3 @@\n+      if (ZapUnusedHeapArea) {\n+        SpaceMangler::mangle_region(MemRegion(r->top(), r->end()));\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -471,0 +471,1 @@\n+  _gc_state_changed(false),\n@@ -1708,3 +1709,8 @@\n-void ShenandoahHeap::set_gc_state_all_threads(char state) {\n-  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {\n-    ShenandoahThreadLocalData::set_gc_state(t, state);\n+void ShenandoahHeap::set_gc_state_all_threads() {\n+  assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"Must be at Shenandoah safepoint\");\n+  if (_gc_state_changed) {\n+    _gc_state_changed = false;\n+    char state = gc_state();\n+    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {\n+      ShenandoahThreadLocalData::set_gc_state(t, state);\n+    }\n@@ -1715,1 +1721,1 @@\n-  assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"Should really be Shenandoah safepoint\");\n+  assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"Must be at Shenandoah safepoint\");\n@@ -1717,1 +1723,1 @@\n-  set_gc_state_all_threads(_gc_state.raw_value());\n+  _gc_state_changed = true;\n@@ -1879,4 +1885,0 @@\n-address ShenandoahHeap::gc_state_addr() {\n-  return (address) ShenandoahHeap::heap()->_gc_state.addr_of();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -623,0 +623,2 @@\n+  ShenandoahHeap::heap()->set_gc_state_all_threads();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3965,0 +3965,17 @@\n+\/\/ This nulls out jmethodIDs for all methods in 'klass'\n+\/\/ It needs to be called explicitly for all previous versions of a class because these may not be cleaned up\n+\/\/ during class unloading.\n+\/\/ We can not use the jmethodID cache associated with klass directly because the 'previous' versions\n+\/\/ do not have the jmethodID cache filled in. Instead, we need to lookup jmethodID for each method and this\n+\/\/ is expensive - O(n) for one jmethodID lookup. For all contained methods it is O(n^2).\n+\/\/ The reason for expensive jmethodID lookup for each method is that there is no direct link between method and jmethodID.\n+void InstanceKlass::clear_jmethod_ids(InstanceKlass* klass) {\n+  Array<Method*>* method_refs = klass->methods();\n+  for (int k = 0; k < method_refs->length(); k++) {\n+    Method* method = method_refs->at(k);\n+    if (method != nullptr && method->is_obsolete()) {\n+      method->clear_jmethod_id();\n+    }\n+  }\n+}\n+\n@@ -4008,0 +4025,1 @@\n+      clear_jmethod_ids(pv_node); \/\/ jmethodID maintenance for the unloaded class\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2114,0 +2114,2 @@\n+    if (failing())  return;\n+\n@@ -2129,0 +2131,2 @@\n+  if (failing())  return;\n+\n@@ -2133,0 +2137,2 @@\n+  if (failing())  return;\n+\n@@ -2138,1 +2144,1 @@\n-\n+    if (failing())  return;\n@@ -2163,0 +2169,2 @@\n+  if (failing())  return;\n+\n@@ -2262,0 +2270,2 @@\n+  if (failing())  return;\n+\n@@ -2300,0 +2310,1 @@\n+    if (failing())  return;\n@@ -4626,0 +4637,1 @@\n+      if (failing())  return;\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -4217,1 +4217,1 @@\n-  jint max_hi = max_array_length(elem()->basic_type());\n+  jint max_hi = max_array_length(elem()->array_element_basic_type());\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -210,1 +210,2 @@\n-  memset(&_event_callbacks,0,sizeof(jvmtiEventCallbacks));\n+  memset(&_event_callbacks, 0, sizeof(jvmtiEventCallbacks));\n+  memset(&_ext_event_callbacks, 0, sizeof(jvmtiExtEventCallbacks));\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -801,1 +801,0 @@\n-  assert(event->should_commit(), \"invariant\");\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -299,0 +299,3 @@\n+  product(size_t, InlineCacheBufferSize, 10*K, EXPERIMENTAL,                \\\n+          \"InlineCacheBuffer size\")                                         \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1331,1 +1331,0 @@\n-  assert(event->should_commit(), \"invariant\");\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,0 +71,2 @@\n+volatile jlong ThreadService::_exited_allocated_bytes = 0;\n+\n@@ -158,0 +160,3 @@\n+  \/\/ Include hidden thread allcations in exited_allocated_bytes\n+  ThreadService::incr_exited_allocated_bytes(thread->cooked_allocated_bytes());\n+\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -510,3 +510,4 @@\n-        ProcessBuilder pb = new ProcessBuilder(Container.ENGINE_COMMAND, \"ps\");\n-        Map<String, String> logFileNames = redirectOutputToLogFile(\"checkDockerSupport(): <container> ps\",\n-                                                      pb, \"container-ps\");\n+        ProcessBuilder pb = new ProcessBuilder(\"which\", Container.ENGINE_COMMAND);\n+        Map<String, String> logFileNames =\n+            redirectOutputToLogFile(\"checkDockerSupport(): which <container-engine>\",\n+                                                      pb, \"which-container\");\n@@ -601,1 +602,3 @@\n-                \"mixed\"\n+                \"mixed\",\n+                \/\/ -XmxmNNNm added by run-test framework for non-hotspot tests\n+                \"mx\"\n@@ -606,4 +609,6 @@\n-                              \/\/ remove -X\n-                              .map(s -> s.substring(2))\n-                              \/\/ remove :.* from flags with values\n-                              .map(s -> s.contains(\":\") ? s.substring(0, s.indexOf(':')) : s)\n+                          \/\/ remove -X\n+                          .map(s -> s.substring(2))\n+                          \/\/ remove :.* from flags with values\n+                          .map(s -> s.contains(\":\") ? s.substring(0, s.indexOf(':')) : s)\n+                          \/\/ remove size like 4G, 768m which might be set for non-hotspot tests\n+                          .map(s -> s.replaceAll(\"(\\\\d+)[mMgGkK]\", \"\"))\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"}]}