{"files":[{"patch":"@@ -16539,1 +16539,1 @@\n-instruct cmpFastLock(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2)\n+instruct cmpFastLock(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2, iRegPNoSp tmp3)\n@@ -16542,1 +16542,1 @@\n-  effect(TEMP tmp, TEMP tmp2);\n+  effect(TEMP tmp, TEMP tmp2, TEMP tmp3);\n@@ -16550,1 +16550,1 @@\n-    __ fast_lock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register);\n+    __ fast_lock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -441,1 +441,1 @@\n-    __ unlock_object(r5, r4, r0, *stub->entry());\n+    __ unlock_object(r5, r4, r0, r6, *stub->entry());\n@@ -2543,0 +2543,1 @@\n+  Register temp = op->scratch_opr()->as_register();\n@@ -2550,4 +2551,0 @@\n-    Register scratch = noreg;\n-    if (UseBiasedLocking) {\n-      scratch = op->scratch_opr()->as_register();\n-    }\n@@ -2556,1 +2553,1 @@\n-    int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op->stub()->entry());\n+    int null_check_offset = __ lock_object(hdr, obj, lock, temp, *op->stub()->entry());\n@@ -2563,1 +2560,1 @@\n-    __ unlock_object(hdr, obj, lock, *op->stub()->entry());\n+    __ unlock_object(hdr, obj, lock, temp, *op->stub()->entry());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -317,5 +317,1 @@\n-  \/\/ Need a scratch register for biased locking\n-  LIR_Opr scratch = LIR_OprFact::illegalOpr;\n-  if (UseBiasedLocking) {\n-    scratch = new_register(T_INT);\n-  }\n+  LIR_Opr scratch = new_register(T_INT);\n@@ -343,0 +339,1 @@\n+  LIR_Opr scratch = new_register(T_INT);\n@@ -344,1 +341,1 @@\n-  monitor_exit(obj_temp, lock, syncTempOpr(), LIR_OprFact::illegalOpr, x->monitor_no());\n+  monitor_exit(obj_temp, lock, syncTempOpr(), scratch, x->monitor_no());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Register scratch, Label& slow_case) {\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Register temp, Label& slow_case) {\n@@ -67,1 +67,1 @@\n-  assert(hdr != obj && hdr != disp_hdr && obj != disp_hdr, \"registers must be different\");\n+  assert_different_registers(hdr, obj, disp_hdr, temp, rscratch2);\n@@ -86,2 +86,2 @@\n-    assert(scratch != noreg, \"should have scratch register at this point\");\n-    biased_locking_enter(disp_hdr, obj, hdr, scratch, false, done, &slow_case);\n+    assert(temp != noreg, \"should have temp register at this point\");\n+    biased_locking_enter(disp_hdr, obj, hdr, temp, false, done, &slow_case);\n@@ -93,1 +93,1 @@\n-    lightweight_lock(obj, hdr, rscratch1, rscratch2, slow_case);\n+    lightweight_lock(obj, hdr, temp, rscratch2, slow_case);\n@@ -137,1 +137,1 @@\n-void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n+void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Register temp, Label& slow_case) {\n@@ -140,1 +140,1 @@\n-  assert(hdr != obj && hdr != disp_hdr && obj != disp_hdr, \"registers must be different\");\n+  assert_different_registers(hdr, obj, disp_hdr, temp, rscratch2);\n@@ -169,1 +169,1 @@\n-    lightweight_unlock(obj, hdr, rscratch1, rscratch2, slow_case);\n+    lightweight_unlock(obj, hdr, temp, rscratch2, slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  \/\/ scratch : scratch register, contents destroyed\n+  \/\/ temp    : temporary register, must not be rscratch1 or rscratch2\n@@ -63,1 +63,1 @@\n-  int lock_object  (Register swap, Register obj, Register disp_hdr, Register scratch, Label& slow_case);\n+  int lock_object  (Register swap, Register obj, Register disp_hdr, Register temp, Label& slow_case);\n@@ -69,1 +69,2 @@\n-  void unlock_object(Register swap, Register obj, Register lock, Label& slow_case);\n+  \/\/ temp    : temporary register, must not be rscratch1 or rscratch2\n+  void unlock_object(Register swap, Register obj, Register lock, Register temp, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-                                  Register tmp2Reg) {\n+                                  Register tmp2Reg, Register tmp3Reg) {\n@@ -114,1 +114,1 @@\n-    lightweight_lock(oop, disp_hdr, tmp, rscratch1, cont);\n+    lightweight_lock(oop, disp_hdr, tmp, tmp3Reg, cont);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-  void fast_lock(Register object, Register box, Register tmp, Register tmp2);\n+  void fast_lock(Register object, Register box, Register tmp, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -724,1 +724,1 @@\n-\/\/      c_rarg0, c_rarg1, c_rarg2, c_rarg3, .. (param regs)\n+\/\/      c_rarg0, c_rarg1, c_rarg2, c_rarg3, c_rarg4, .. (param regs)\n@@ -739,0 +739,2 @@\n+    const Register tmp2 = c_rarg4;\n+    const Register tmp3 = c_rarg5;\n@@ -759,1 +761,1 @@\n-      lightweight_lock(obj_reg, tmp, rscratch1, rscratch2, slow_case);\n+      lightweight_lock(obj_reg, tmp, tmp2, tmp3, slow_case);\n@@ -873,0 +875,1 @@\n+    const Register tmp_reg    = c_rarg4;  \/\/ Temporary used by lightweight_unlock\n@@ -906,1 +909,1 @@\n-      lightweight_unlock(obj_reg, header_reg, swap_reg, rscratch1, slow_case);\n+      lightweight_unlock(obj_reg, header_reg, swap_reg, tmp_reg, slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2493,0 +2493,4 @@\n+#ifdef ASSERT\n+    \/\/ Poison rscratch1 which is written on !UseLSE branch\n+    mov(rscratch1, 0x1f1f1f1f1f1f1f1f);\n+#endif\n@@ -5435,1 +5439,1 @@\n-  assert_different_registers(obj, hdr, t1, t2);\n+  assert_different_registers(obj, hdr, t1, t2, rscratch1);\n@@ -5447,0 +5451,1 @@\n+  \/\/ Clobbers rscratch1 when UseLSE is false\n@@ -5467,1 +5472,1 @@\n-  assert_different_registers(obj, hdr, t1, t2);\n+  assert_different_registers(obj, hdr, t1, t2, rscratch1);\n@@ -5507,0 +5512,1 @@\n+  \/\/ Clobbers rscratch1 when UseLSE is false\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1755,0 +1755,1 @@\n+  const Register lock_tmp = r14;  \/\/ Temporary used by lightweight_lock\/unlock\n@@ -1815,1 +1816,1 @@\n-      __ lightweight_lock(obj_reg, swap_reg, tmp, rscratch1, slow_path_lock);\n+      __ lightweight_lock(obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n@@ -1966,1 +1967,1 @@\n-      __ lightweight_unlock(obj_reg, old_hdr, swap_reg, rscratch1, slow_path_unlock);\n+      __ lightweight_unlock(obj_reg, old_hdr, swap_reg, lock_tmp, slow_path_unlock);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}