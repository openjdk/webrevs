{"files":[{"patch":"@@ -3870,1 +3870,1 @@\n-      __ fast_lock(oop, disp_hdr, tmp, rscratch1, cont);\n+      __ lightweight_lock(oop, disp_hdr, tmp, rscratch1, cont);\n@@ -3948,1 +3948,1 @@\n-      __ fast_unlock(oop, tmp, box, disp_hdr, cont);\n+      __ lightweight_unlock(oop, tmp, box, disp_hdr, cont);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,2 +93,2 @@\n-    fast_lock(obj, hdr, rscratch1, rscratch2, slow_case);\n-  } else {\n+    lightweight_lock(obj, hdr, rscratch1, rscratch2, slow_case);\n+  } else if (LockingMode == LM_LEGACY) {\n@@ -169,2 +169,2 @@\n-    fast_unlock(obj, hdr, rscratch1, rscratch2, slow_case);\n-  } else {\n+    lightweight_unlock(obj, hdr, rscratch1, rscratch2, slow_case);\n+  } else if (LockingMode == LM_LEGACY) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -759,1 +759,1 @@\n-      fast_lock(obj_reg, tmp, rscratch1, rscratch2, slow_case);\n+      lightweight_lock(obj_reg, tmp, rscratch1, rscratch2, slow_case);\n@@ -761,1 +761,1 @@\n-    } else {\n+    } else if (LockingMode == LM_LEGACY) {\n@@ -765,1 +765,0 @@\n-\n@@ -906,1 +905,1 @@\n-      fast_unlock(obj_reg, header_reg, swap_reg, rscratch1, slow_case);\n+      lightweight_unlock(obj_reg, header_reg, swap_reg, rscratch1, slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -5426,1 +5426,1 @@\n-\/\/ Implements fast-locking.\n+\/\/ Implements lightweight-locking.\n@@ -5433,1 +5433,1 @@\n-void MacroAssembler::fast_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n@@ -5458,1 +5458,1 @@\n-\/\/ Implements fast-unlocking.\n+\/\/ Implements lightweight-unlocking.\n@@ -5465,1 +5465,1 @@\n-void MacroAssembler::fast_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n+void MacroAssembler::lightweight_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1427,2 +1427,2 @@\n-  void fast_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n-  void fast_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n+  void lightweight_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n+  void lightweight_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1815,1 +1815,1 @@\n-      __ fast_lock(obj_reg, swap_reg, tmp, rscratch1, slow_path_lock);\n+      __ lightweight_lock(obj_reg, swap_reg, tmp, rscratch1, slow_path_lock);\n@@ -1966,1 +1966,1 @@\n-      __ fast_unlock(obj_reg, old_hdr, swap_reg, rscratch1, slow_path_unlock);\n+      __ lightweight_unlock(obj_reg, old_hdr, swap_reg, rscratch1, slow_path_unlock);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1905,1 +1905,0 @@\n-\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1076,12 +1076,34 @@\n-    \/\/ We have the displaced header in displaced_header. If the lock is still\n-    \/\/ lightweight, it will contain the monitor address and we'll store the\n-    \/\/ displaced header back into the object's mark word.\n-    \/\/ CmpxchgX sets CCR0 to cmpX(current, monitor).\n-    cmpxchgd(\/*flag=*\/CCR0,\n-             \/*current_value=*\/current_header,\n-             \/*compare_value=*\/monitor, \/*exchange_value=*\/displaced_header,\n-             \/*where=*\/object_mark_addr,\n-             MacroAssembler::MemBarRel,\n-             MacroAssembler::cmpxchgx_hint_release_lock(),\n-             noreg,\n-             &slow_case);\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      \/\/ Check for non-symmetric locking. This is allowed by the spec and the interpreter\n+      \/\/ must handle it.\n+      Register tmp = current_header;\n+      \/\/ First check for lock-stack underflow.\n+      lwz(tmp, in_bytes(JavaThread::lock_stack_top_offset()), R16_thread);\n+      cmplwi(CCR0, tmp, (unsigned)LockStack::start_offset());\n+      ble(CCR0, slow_case);\n+      \/\/ Then check if the top of the lock-stack matches the unlocked object.\n+      addi(tmp, tmp, -oopSize);\n+      ldx(tmp, tmp, R16_thread);\n+      cmpd(CCR0, tmp, object);\n+      bne(CCR0, slow_case);\n+\n+      ld(header, oopDesc::mark_offset_in_bytes(), object);\n+      andi_(R0, header, markWord::monitor_value);\n+      bne(CCR0, slow_case);\n+      lightweight_unlock(object, header, slow_case);\n+    } else {\n+      addi(object_mark_addr, object, oopDesc::mark_offset_in_bytes());\n+\n+      \/\/ We have the displaced header in displaced_header. If the lock is still\n+      \/\/ lightweight, it will contain the monitor address and we'll store the\n+      \/\/ displaced header back into the object's mark word.\n+      \/\/ CmpxchgX sets CCR0 to cmpX(current, monitor).\n+      cmpxchgd(\/*flag=*\/CCR0,\n+               \/*current_value=*\/current_header,\n+               \/*compare_value=*\/monitor, \/*exchange_value=*\/header,\n+               \/*where=*\/object_mark_addr,\n+               MacroAssembler::MemBarRel,\n+               MacroAssembler::cmpxchgx_hint_release_lock(),\n+               noreg,\n+               &slow_case);\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":34,"deletions":12,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    fast_lock_impl(obj, hdr, thread, scratch, slow_case);\n-  } else {\n+    lightweight_lock(obj, hdr, thread, scratch, slow_case);\n+  } else  if (LockingMode == LM_LEGACY) {\n@@ -137,2 +137,2 @@\n-    fast_unlock_impl(obj, disp_hdr, hdr, slow_case);\n-  } else {\n+    lightweight_unlock(obj, disp_hdr, hdr, slow_case);\n+  } else if (LockingMode == LM_LEGACY) {\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -548,1 +548,1 @@\n-    fast_lock_impl(objReg, tmpReg, thread, scrReg, DONE_LABEL);\n+    lightweight_lock(objReg, tmpReg, thread, scrReg, DONE_LABEL);\n@@ -862,1 +862,1 @@\n-      fast_unlock_impl(objReg, boxReg, tmpReg, DONE_LABEL);\n+      lightweight_unlock(objReg, boxReg, tmpReg, DONE_LABEL);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1243,1 +1243,1 @@\n-      fast_lock_impl(obj_reg, swap_reg, thread, tmp_reg, slow_case);\n+      lightweight_lock(obj_reg, swap_reg, thread, tmp_reg, slow_case);\n@@ -1378,1 +1378,1 @@\n-      fast_unlock_impl(obj_reg, swap_reg, header_reg, slow_case);\n+      lightweight_unlock(obj_reg, swap_reg, header_reg, slow_case);\n@@ -1380,1 +1380,1 @@\n-    } else {\n+    } else if (LockingMode == LM_LEGACY) {\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -8785,1 +8785,1 @@\n-void MacroAssembler::fast_lock_impl(Register obj, Register hdr, Register thread, Register tmp, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register obj, Register hdr, Register thread, Register tmp, Label& slow) {\n@@ -8813,1 +8813,1 @@\n-\/\/ Implements fast-unlocking.\n+\/\/ Implements lightweight-unlocking.\n@@ -8820,1 +8820,1 @@\n-void MacroAssembler::fast_unlock_impl(Register obj, Register hdr, Register tmp, Label& slow) {\n+void MacroAssembler::lightweight_unlock(Register obj, Register hdr, Register tmp, Label& slow) {\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1927,2 +1927,2 @@\n-  void fast_lock_impl(Register obj, Register hdr, Register thread, Register tmp, Label& slow);\n-  void fast_unlock_impl(Register obj, Register hdr, Register tmp, Label& slow);\n+  void lightweight_lock(Register obj, Register hdr, Register thread, Register tmp, Label& slow);\n+  void lightweight_unlock(Register obj, Register hdr, Register tmp, Label& slow);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1865,3 +1865,3 @@\n-     \/\/ Load object header\n-     __ movptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-     __ fast_lock_impl(obj_reg, swap_reg, thread, lock_reg, slow_path_lock);\n+      \/\/ Load object header\n+      __ movptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ lightweight_lock(obj_reg, swap_reg, thread, lock_reg, slow_path_lock);\n@@ -2039,1 +2039,1 @@\n-      __ fast_unlock_impl(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n+      __ lightweight_unlock(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2116,1 +2116,1 @@\n-      __ fast_lock_impl(obj_reg, swap_reg, r15_thread, rscratch1, slow_path_lock);\n+      __ lightweight_lock(obj_reg, swap_reg, r15_thread, rscratch1, slow_path_lock);\n@@ -2270,1 +2270,1 @@\n-      __ fast_unlock_impl(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n+      __ lightweight_unlock(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}