{"files":[{"patch":"@@ -94,1 +94,1 @@\n-  } else if (LockingMode == LM_LEGACY) {\n+  } else {\n@@ -170,1 +170,1 @@\n-  } else if (LockingMode == LM_LEGACY) {\n+  } else {\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -761,1 +761,1 @@\n-    } else if (LockingMode == LM_LEGACY) {\n+    } else {\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1905,0 +1905,1 @@\n+\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1076,34 +1076,12 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ Check for non-symmetric locking. This is allowed by the spec and the interpreter\n-      \/\/ must handle it.\n-      Register tmp = current_header;\n-      \/\/ First check for lock-stack underflow.\n-      lwz(tmp, in_bytes(JavaThread::lock_stack_top_offset()), R16_thread);\n-      cmplwi(CCR0, tmp, (unsigned)LockStack::start_offset());\n-      ble(CCR0, slow_case);\n-      \/\/ Then check if the top of the lock-stack matches the unlocked object.\n-      addi(tmp, tmp, -oopSize);\n-      ldx(tmp, tmp, R16_thread);\n-      cmpd(CCR0, tmp, object);\n-      bne(CCR0, slow_case);\n-\n-      ld(header, oopDesc::mark_offset_in_bytes(), object);\n-      andi_(R0, header, markWord::monitor_value);\n-      bne(CCR0, slow_case);\n-      lightweight_unlock(object, header, slow_case);\n-    } else {\n-      addi(object_mark_addr, object, oopDesc::mark_offset_in_bytes());\n-\n-      \/\/ We have the displaced header in displaced_header. If the lock is still\n-      \/\/ lightweight, it will contain the monitor address and we'll store the\n-      \/\/ displaced header back into the object's mark word.\n-      \/\/ CmpxchgX sets CCR0 to cmpX(current, monitor).\n-      cmpxchgd(\/*flag=*\/CCR0,\n-               \/*current_value=*\/current_header,\n-               \/*compare_value=*\/monitor, \/*exchange_value=*\/header,\n-               \/*where=*\/object_mark_addr,\n-               MacroAssembler::MemBarRel,\n-               MacroAssembler::cmpxchgx_hint_release_lock(),\n-               noreg,\n-               &slow_case);\n-    }\n+    \/\/ We have the displaced header in displaced_header. If the lock is still\n+    \/\/ lightweight, it will contain the monitor address and we'll store the\n+    \/\/ displaced header back into the object's mark word.\n+    \/\/ CmpxchgX sets CCR0 to cmpX(current, monitor).\n+    cmpxchgd(\/*flag=*\/CCR0,\n+             \/*current_value=*\/current_header,\n+             \/*compare_value=*\/monitor, \/*exchange_value=*\/displaced_header,\n+             \/*where=*\/object_mark_addr,\n+             MacroAssembler::MemBarRel,\n+             MacroAssembler::cmpxchgx_hint_release_lock(),\n+             noreg,\n+             &slow_case);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":12,"deletions":34,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-  } else  if (LockingMode == LM_LEGACY) {\n+  } else {\n@@ -138,1 +138,1 @@\n-  } else if (LockingMode == LM_LEGACY) {\n+  } else {\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1380,1 +1380,1 @@\n-    } else if (LockingMode == LM_LEGACY) {\n+    } else {\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}