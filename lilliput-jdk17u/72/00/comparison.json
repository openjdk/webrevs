{"files":[{"patch":"@@ -3804,194 +3804,0 @@\n-  enc_class aarch64_enc_fast_lock(iRegP object, iRegP box, iRegP tmp, iRegP tmp2) %{\n-    C2_MacroAssembler _masm(&cbuf);\n-    Register oop = as_Register($object$$reg);\n-    Register box = as_Register($box$$reg);\n-    Register disp_hdr = as_Register($tmp$$reg);\n-    Register tmp = as_Register($tmp2$$reg);\n-    Label cont;\n-    Label object_has_monitor;\n-    Label cas_failed;\n-\n-    assert_different_registers(oop, box, tmp, disp_hdr);\n-\n-    \/\/ Load markWord from object into displaced_header.\n-    __ ldr(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      __ load_klass(tmp, oop);\n-      __ ldrw(tmp, Address(tmp, Klass::access_flags_offset()));\n-      __ tstw(tmp, JVM_ACC_IS_VALUE_BASED_CLASS);\n-      __ br(Assembler::NE, cont);\n-    }\n-\n-    if (UseBiasedLocking && !UseOptoBiasInlining) {\n-      __ biased_locking_enter(box, oop, disp_hdr, tmp, true, cont);\n-    }\n-\n-    \/\/ Check for existing monitor\n-    __ tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);\n-\n-    if (LockingMode == LM_MONITOR) {\n-      __ tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n-      __ b(cont);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n-      __ orr(tmp, disp_hdr, markWord::unlocked_value);\n-\n-      \/\/ Initialize the box. (Must happen before we update the object mark!)\n-      __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-      \/\/ Compare object markWord with an unlocked value (tmp) and if\n-      \/\/ equal exchange the stack address of our box with object markWord.\n-      \/\/ On failure disp_hdr contains the possibly locked markWord.\n-      __ cmpxchg(oop, tmp, box, Assembler::xword, \/*acquire*\/ true,\n-                 \/*release*\/ true, \/*weak*\/ false, disp_hdr);\n-      __ br(Assembler::EQ, cont);\n-\n-      assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-      \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-      \/\/ object, will have now locked it will continue at label cont\n-\n-      __ bind(cas_failed);\n-      \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n-      \/\/ Check if the owner is self by comparing the value in the\n-      \/\/ markWord of object (disp_hdr) with the stack pointer.\n-      __ mov(rscratch1, sp);\n-      __ sub(disp_hdr, disp_hdr, rscratch1);\n-      __ mov(tmp, (address) (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n-      \/\/ If condition is true we are cont and hence we can store 0 as the\n-      \/\/ displaced header in the box, which indicates that it is a recursive lock.\n-      __ ands(tmp\/*==0?*\/, disp_hdr, tmp);   \/\/ Sets flags for result\n-      __ str(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-      __ b(cont);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-      __ lightweight_lock(oop, disp_hdr, tmp, rscratch1, cont);\n-      __ b(cont);\n-    }\n-\n-    \/\/ Handle existing monitor.\n-    __ bind(object_has_monitor);\n-\n-    \/\/ The object's monitor m is unlocked iff m->owner == NULL,\n-    \/\/ otherwise m->owner may contain a thread or a stack address.\n-    \/\/\n-    \/\/ Try to CAS m->owner from NULL to current thread.\n-    __ add(tmp, disp_hdr, (ObjectMonitor::owner_offset_in_bytes()-markWord::monitor_value));\n-    __ cmpxchg(tmp, zr, rthread, Assembler::xword, \/*acquire*\/ true,\n-               \/*release*\/ true, \/*weak*\/ false, rscratch1); \/\/ Sets flags for result\n-\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ Store a non-null value into the box to avoid looking like a re-entrant\n-      \/\/ lock. The fast-path monitor unlock code checks for\n-      \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n-      \/\/ relevant bit set, and also matches ObjectSynchronizer::enter.\n-      __ mov(tmp, (address)markWord::unused_mark().value());\n-      __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-    }\n-    __ br(Assembler::EQ, cont); \/\/ CAS success means locking succeeded\n-\n-    __ cmp(rscratch1, rthread);\n-    __ br(Assembler::NE, cont); \/\/ Check for recursive locking\n-\n-    \/\/ Recursive lock case\n-    __ increment(Address(disp_hdr, ObjectMonitor::recursions_offset_in_bytes() - markWord::monitor_value), 1);\n-    \/\/ flag == EQ still from the cmp above, checking if this is a reentrant lock\n-\n-    __ bind(cont);\n-    \/\/ flag == EQ indicates success\n-    \/\/ flag == NE indicates failure\n-  %}\n-\n-  enc_class aarch64_enc_fast_unlock(iRegP object, iRegP box, iRegP tmp, iRegP tmp2) %{\n-    C2_MacroAssembler _masm(&cbuf);\n-    Register oop = as_Register($object$$reg);\n-    Register box = as_Register($box$$reg);\n-    Register disp_hdr = as_Register($tmp$$reg);\n-    Register tmp = as_Register($tmp2$$reg);\n-    Label cont;\n-    Label object_has_monitor;\n-\n-    assert_different_registers(oop, box, tmp, disp_hdr);\n-\n-    if (UseBiasedLocking && !UseOptoBiasInlining) {\n-      __ biased_locking_exit(oop, tmp, cont);\n-    }\n-\n-    if (LockingMode == LM_LEGACY) {\n-      \/\/ Find the lock address and load the displaced header from the stack.\n-      __ ldr(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-      \/\/ If the displaced header is 0, we have a recursive unlock.\n-      __ cmp(disp_hdr, zr);\n-      __ br(Assembler::EQ, cont);\n-    }\n-\n-    \/\/ Handle existing monitor.\n-    __ ldr(tmp, Address(oop, oopDesc::mark_offset_in_bytes()));\n-    __ tbnz(tmp, exact_log2(markWord::monitor_value), object_has_monitor);\n-\n-    if (LockingMode == LM_MONITOR) {\n-      __ tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n-      __ b(cont);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Check if it is still a light weight lock, this is is true if we\n-      \/\/ see the stack address of the basicLock in the markWord of the\n-      \/\/ object.\n-\n-      __ cmpxchg(oop, box, disp_hdr, Assembler::xword, \/*acquire*\/ false,\n-                 \/*release*\/ true, \/*weak*\/ false, tmp);\n-      __ b(cont);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-      __ lightweight_unlock(oop, tmp, box, disp_hdr, cont);\n-      __ b(cont);\n-    }\n-\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-    \/\/ Handle existing monitor.\n-    __ bind(object_has_monitor);\n-    STATIC_ASSERT(markWord::monitor_value <= INT_MAX);\n-    __ add(tmp, tmp, -(int)markWord::monitor_value); \/\/ monitor\n-\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ If the owner is anonymous, we need to fix it -- in an outline stub.\n-      Register tmp2 = disp_hdr;\n-      __ ldr(tmp2, Address(tmp, ObjectMonitor::owner_offset_in_bytes()));\n-      \/\/ We cannot use tbnz here, the target might be too far away and cannot\n-      \/\/ be encoded.\n-      __ tst(tmp2, (uint64_t)ObjectMonitor::ANONYMOUS_OWNER);\n-      C2HandleAnonOMOwnerStub* stub = new (Compile::current()->comp_arena()) C2HandleAnonOMOwnerStub(tmp, tmp2);\n-      Compile::current()->output()->add_stub(stub);\n-      __ br(Assembler::NE, stub->entry());\n-      __ bind(stub->continuation());\n-    }\n-\n-    __ ldr(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset_in_bytes()));\n-\n-    Label notRecursive;\n-    __ cbz(disp_hdr, notRecursive);\n-\n-    \/\/ Recursive lock\n-    __ sub(disp_hdr, disp_hdr, 1u);\n-    __ str(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset_in_bytes()));\n-    __ cmp(disp_hdr, disp_hdr); \/\/ Sets flags for result\n-    __ b(cont);\n-\n-    __ bind(notRecursive);\n-    __ ldr(rscratch1, Address(tmp, ObjectMonitor::EntryList_offset_in_bytes()));\n-    __ ldr(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset_in_bytes()));\n-    __ orr(rscratch1, rscratch1, disp_hdr); \/\/ Will be 0 if both are 0.\n-    __ cmp(rscratch1, zr); \/\/ Sets flags for result\n-    __ cbnz(rscratch1, cont);\n-    \/\/ need a release store here\n-    __ lea(tmp, Address(tmp, ObjectMonitor::owner_offset_in_bytes()));\n-    __ stlr(zr, tmp); \/\/ set unowned\n-\n-    __ bind(cont);\n-    \/\/ flag == EQ indicates success\n-    \/\/ flag == NE indicates failure\n-  %}\n-\n@@ -16743,1 +16549,3 @@\n-  ins_encode(aarch64_enc_fast_lock(object, box, tmp, tmp2));\n+  ins_encode %{\n+    __ fast_lock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register);\n+  %}\n@@ -16756,1 +16564,3 @@\n-  ins_encode(aarch64_enc_fast_unlock(object, box, tmp, tmp2));\n+  ins_encode %{\n+    __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register);\n+  %}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":6,"deletions":196,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -48,0 +48,194 @@\n+void C2_MacroAssembler::fast_lock(Register objectReg, Register boxReg, Register tmpReg,\n+                                  Register tmp2Reg) {\n+  Register oop = objectReg;\n+  Register box = boxReg;\n+  Register disp_hdr = tmpReg;\n+  Register tmp = tmp2Reg;\n+  Label cont;\n+  Label object_has_monitor;\n+  Label cas_failed;\n+\n+  assert_different_registers(oop, box, tmp, disp_hdr);\n+\n+  \/\/ Load markWord from object into displaced_header.\n+  ldr(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));\n+\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n+    load_klass(tmp, oop);\n+    ldrw(tmp, Address(tmp, Klass::access_flags_offset()));\n+    tstw(tmp, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    br(Assembler::NE, cont);\n+  }\n+\n+  if (UseBiasedLocking && !UseOptoBiasInlining) {\n+    biased_locking_enter(box, oop, disp_hdr, tmp, true, cont);\n+  }\n+\n+  \/\/ Check for existing monitor\n+  tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);\n+\n+  if (LockingMode == LM_MONITOR) {\n+    tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n+    b(cont);\n+  } else if (LockingMode == LM_LEGACY) {\n+    \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n+    orr(tmp, disp_hdr, markWord::unlocked_value);\n+\n+    \/\/ Initialize the box. (Must happen before we update the object mark!)\n+    str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+\n+    \/\/ Compare object markWord with an unlocked value (tmp) and if\n+    \/\/ equal exchange the stack address of our box with object markWord.\n+    \/\/ On failure disp_hdr contains the possibly locked markWord.\n+    cmpxchg(oop, tmp, box, Assembler::xword, \/*acquire*\/ true,\n+            \/*release*\/ true, \/*weak*\/ false, disp_hdr);\n+    br(Assembler::EQ, cont);\n+\n+    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+\n+    \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n+    \/\/ object, will have now locked it will continue at label cont\n+\n+    bind(cas_failed);\n+    \/\/ We did not see an unlocked object so try the fast recursive case.\n+\n+    \/\/ Check if the owner is self by comparing the value in the\n+    \/\/ markWord of object (disp_hdr) with the stack pointer.\n+    mov(rscratch1, sp);\n+    sub(disp_hdr, disp_hdr, rscratch1);\n+    mov(tmp, (address) (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n+    \/\/ If condition is true we are cont and hence we can store 0 as the\n+    \/\/ displaced header in the box, which indicates that it is a recursive lock.\n+    ands(tmp\/*==0?*\/, disp_hdr, tmp);   \/\/ Sets flags for result\n+    str(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+    b(cont);\n+  } else {\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+    lightweight_lock(oop, disp_hdr, tmp, rscratch1, cont);\n+    b(cont);\n+  }\n+\n+  \/\/ Handle existing monitor.\n+  bind(object_has_monitor);\n+\n+  \/\/ The object's monitor m is unlocked iff m->owner == NULL,\n+  \/\/ otherwise m->owner may contain a thread or a stack address.\n+  \/\/\n+  \/\/ Try to CAS m->owner from NULL to current thread.\n+  add(tmp, disp_hdr, (ObjectMonitor::owner_offset_in_bytes()-markWord::monitor_value));\n+  cmpxchg(tmp, zr, rthread, Assembler::xword, \/*acquire*\/ true,\n+          \/*release*\/ true, \/*weak*\/ false, rscratch1); \/\/ Sets flags for result\n+\n+  if (LockingMode != LM_LIGHTWEIGHT) {\n+    \/\/ Store a non-null value into the box to avoid looking like a re-entrant\n+    \/\/ lock. The fast-path monitor unlock code checks for\n+    \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n+    \/\/ relevant bit set, and also matches ObjectSynchronizer::enter.\n+    mov(tmp, (address)markWord::unused_mark().value());\n+    str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+  }\n+  br(Assembler::EQ, cont); \/\/ CAS success means locking succeeded\n+\n+  cmp(rscratch1, rthread);\n+  br(Assembler::NE, cont); \/\/ Check for recursive locking\n+\n+  \/\/ Recursive lock case\n+  increment(Address(disp_hdr, ObjectMonitor::recursions_offset_in_bytes() - markWord::monitor_value), 1);\n+  \/\/ flag == EQ still from the cmp above, checking if this is a reentrant lock\n+\n+  bind(cont);\n+  \/\/ flag == EQ indicates success\n+  \/\/ flag == NE indicates failure\n+}\n+\n+void C2_MacroAssembler::fast_unlock(Register objectReg, Register boxReg, Register tmpReg,\n+                                    Register tmp2Reg) {\n+  Register oop = objectReg;\n+  Register box = boxReg;\n+  Register disp_hdr = tmpReg;\n+  Register tmp = tmp2Reg;\n+  Label cont;\n+  Label object_has_monitor;\n+\n+  assert_different_registers(oop, box, tmp, disp_hdr);\n+\n+  if (UseBiasedLocking && !UseOptoBiasInlining) {\n+    biased_locking_exit(oop, tmp, cont);\n+  }\n+\n+  if (LockingMode == LM_LEGACY) {\n+    \/\/ Find the lock address and load the displaced header from the stack.\n+    ldr(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+\n+    \/\/ If the displaced header is 0, we have a recursive unlock.\n+    cmp(disp_hdr, zr);\n+    br(Assembler::EQ, cont);\n+  }\n+\n+  \/\/ Handle existing monitor.\n+  ldr(tmp, Address(oop, oopDesc::mark_offset_in_bytes()));\n+  tbnz(tmp, exact_log2(markWord::monitor_value), object_has_monitor);\n+\n+  if (LockingMode == LM_MONITOR) {\n+    tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n+    b(cont);\n+  } else if (LockingMode == LM_LEGACY) {\n+    \/\/ Check if it is still a light weight lock, this is is true if we\n+    \/\/ see the stack address of the basicLock in the markWord of the\n+    \/\/ object.\n+\n+    cmpxchg(oop, box, disp_hdr, Assembler::xword, \/*acquire*\/ false,\n+            \/*release*\/ true, \/*weak*\/ false, tmp);\n+    b(cont);\n+  } else {\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+    lightweight_unlock(oop, tmp, box, disp_hdr, cont);\n+    b(cont);\n+  }\n+\n+  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+\n+  \/\/ Handle existing monitor.\n+  bind(object_has_monitor);\n+  STATIC_ASSERT(markWord::monitor_value <= INT_MAX);\n+  add(tmp, tmp, -(int)markWord::monitor_value); \/\/ monitor\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    \/\/ If the owner is anonymous, we need to fix it -- in an outline stub.\n+    Register tmp2 = disp_hdr;\n+    ldr(tmp2, Address(tmp, ObjectMonitor::owner_offset_in_bytes()));\n+    \/\/ We cannot use tbnz here, the target might be too far away and cannot\n+    \/\/ be encoded.\n+    tst(tmp2, (uint64_t)ObjectMonitor::ANONYMOUS_OWNER);\n+    C2HandleAnonOMOwnerStub* stub = new (Compile::current()->comp_arena()) C2HandleAnonOMOwnerStub(tmp, tmp2);\n+    Compile::current()->output()->add_stub(stub);\n+    br(Assembler::NE, stub->entry());\n+    bind(stub->continuation());\n+  }\n+\n+  ldr(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset_in_bytes()));\n+\n+  Label notRecursive;\n+  cbz(disp_hdr, notRecursive);\n+\n+  \/\/ Recursive lock\n+  sub(disp_hdr, disp_hdr, 1u);\n+  str(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset_in_bytes()));\n+  cmp(disp_hdr, disp_hdr); \/\/ Sets flags for result\n+  b(cont);\n+\n+  bind(notRecursive);\n+  ldr(rscratch1, Address(tmp, ObjectMonitor::EntryList_offset_in_bytes()));\n+  ldr(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset_in_bytes()));\n+  orr(rscratch1, rscratch1, disp_hdr); \/\/ Will be 0 if both are 0.\n+  cmp(rscratch1, zr); \/\/ Sets flags for result\n+  cbnz(rscratch1, cont);\n+  \/\/ need a release store here\n+  lea(tmp, Address(tmp, ObjectMonitor::owner_offset_in_bytes()));\n+  stlr(zr, tmp); \/\/ set unowned\n+\n+  bind(cont);\n+  \/\/ flag == EQ indicates success\n+  \/\/ flag == NE indicates failure\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":194,"deletions":0,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+  \/\/ Code used by cmpFastLock and cmpFastUnlock mach instructions in .ad file.\n+  \/\/ See full description in macroAssembler_aarch64.cpp.\n+  void fast_lock(Register object, Register box, Register tmp, Register tmp2);\n+  void fast_unlock(Register object, Register box, Register tmp, Register tmp2);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}