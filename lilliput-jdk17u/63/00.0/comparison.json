{"files":[{"patch":"@@ -526,1 +526,1 @@\n-\t      test cases? ran\/ { print $$$$2 }' $$($1_RESULT_FILE))) \\\n+\t      test (cases?|suites?) ran\/ { print $$$$2 }' $$($1_RESULT_FILE))) \\\n@@ -849,1 +849,1 @@\n-  clean-workdir-$1:\n+  clean-outputdirs-$1:\n@@ -851,0 +851,1 @@\n+\t$$(RM) -r $$($1_TEST_RESULTS_DIR)\n@@ -895,1 +896,1 @@\n-  run-test-$1: pre-run-test clean-workdir-$1\n+  run-test-$1: pre-run-test clean-outputdirs-$1\n@@ -932,1 +933,1 @@\n-  $1: run-test-$1 parse-test-$1 clean-workdir-$1\n+  $1: run-test-$1 parse-test-$1 clean-outputdirs-$1\n@@ -934,1 +935,1 @@\n-  TARGETS += $1 run-test-$1 parse-test-$1 clean-workdir-$1\n+  TARGETS += $1 run-test-$1 parse-test-$1 clean-outputdirs-$1\n","filename":"make\/RunTests.gmk","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+ , _loop(nullptr)\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -675,1 +675,1 @@\n-  if (VerifyArchivedFields) {\n+  if (VerifyArchivedFields > 0) {\n@@ -683,9 +683,14 @@\n-    if (!FLAG_IS_DEFAULT(VerifyArchivedFields)) {\n-      \/\/ If VerifyArchivedFields has a non-default value (e.g., specified on the command-line), do\n-      \/\/ more expensive checks.\n-      if (is_init_completed()) {\n-        FlagSetting fs1(VerifyBeforeGC, true);\n-        FlagSetting fs2(VerifyDuringGC, true);\n-        FlagSetting fs3(VerifyAfterGC,  true);\n-        Universe::heap()->collect(GCCause::_java_lang_system_gc);\n-      }\n+    if (VerifyArchivedFields > 1 && is_init_completed()) {\n+      \/\/ At this time, the oop->klass() of some archived objects in the heap may not\n+      \/\/ have been loaded into the system dictionary yet. Nevertheless, oop->klass() should\n+      \/\/ have enough information (object size, oop maps, etc) so that a GC can be safely\n+      \/\/ performed.\n+      \/\/\n+      \/\/ -XX:VerifyArchivedFields=2 force a GC to happen in such an early stage\n+      \/\/ to check for GC safety.\n+      log_info(cds, heap)(\"Trigger GC %s initializing static field(s) in %s\",\n+                          which, k->external_name());\n+      FlagSetting fs1(VerifyBeforeGC, true);\n+      FlagSetting fs2(VerifyDuringGC, true);\n+      FlagSetting fs3(VerifyAfterGC,  true);\n+      Universe::heap()->collect(GCCause::_java_lang_system_gc);\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -363,1 +363,4 @@\n-    _preserved_marks->push_if_necessary(obj, obj_mark);\n+    \/\/ Save the markWord of promotion-failed objs in _preserved_marks for later\n+    \/\/ restoration. This way we don't have to walk the young-gen to locate\n+    \/\/ these promotion-failed objs.\n+    _preserved_marks->push_always(obj, obj_mark);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -527,2 +527,6 @@\n-  product(bool, VerifyArchivedFields, trueInDebug, DIAGNOSTIC,              \\\n-          \"Verify memory when archived oop fields are loaded from CDS)\")    \\\n+  product(int, VerifyArchivedFields, 0, DIAGNOSTIC,                         \\\n+          \"Verify memory when archived oop fields are loaded from CDS; \"    \\\n+          \"0: No check; \"                                                   \\\n+          \"1: Basic verification with VM_Verify (no side effects); \"        \\\n+          \"2: Detailed verification by forcing a GC (with side effects)\")   \\\n+          range(0, 2)                                                       \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -137,2 +137,4 @@\n-\n-    log_trace(gc)(\"Restored %zu marks\", _total_size);\n+    size_t mem_size = _total_size * (sizeof(oop) + sizeof(markWord));\n+    log_trace(gc)(\"Restored %zu marks, occupying %zu %s\", _total_size,\n+                                                          byte_size_in_proper_unit(mem_size),\n+                                                          proper_unit_for_byte_size(mem_size));\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+  inline void push_always(oop obj, markWord m);\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,0 +50,6 @@\n+inline void PreservedMarks::push_always(oop obj, markWord m) {\n+  assert(!m.is_marked(), \"precondition\");\n+  OopAndMarkWord elem(obj, m);\n+  _stack.push(elem);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -582,2 +582,7 @@\n-          const TypeX *ld_offs_t = phase->type(ld_offs)->isa_intptr_t();\n-          if (ac->modifies(ld_offs_t->_lo, ld_offs_t->_hi, phase, can_see_stored_value)) {\n+          const TypeX* ld_offs_t = phase->type(ld_offs)->isa_intptr_t();\n+          assert(!ld_offs_t->empty(), \"dead reference should be checked already\");\n+          \/\/ Take into account vector or unsafe access size\n+          jlong ld_size_in_bytes = (jlong)memory_size();\n+          jlong offset_hi = ld_offs_t->_hi + ld_size_in_bytes - 1;\n+          offset_hi = MIN2(offset_hi, (jlong)(TypeX::MAX->_hi)); \/\/ Take care for overflow in 32-bit VM\n+          if (ac->modifies(ld_offs_t->_lo, (intptr_t)offset_hi, phase, can_see_stored_value)) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1369,0 +1369,3 @@\n+  if (java_thread->is_exiting()) {\n+    return; \/* JVMTI_ERROR_THREAD_NOT_ALIVE (default) *\/\n+  }\n@@ -1499,0 +1502,4 @@\n+\n+  if (java_thread->is_exiting()) {\n+    return; \/* JVMTI_ERROR_THREAD_NOT_ALIVE (default) *\/\n+  }\n@@ -1575,8 +1582,6 @@\n-  if (!java_thread->is_exiting() && java_thread->threadObj() != NULL) {\n-    _state->update_for_pop_top_frame();\n-    java_thread->set_popframe_condition(JavaThread::popframe_pending_bit);\n-    \/\/ Set pending step flag for this popframe and it is cleared when next\n-    \/\/ step event is posted.\n-    _state->set_pending_step_for_popframe();\n-    _result = JVMTI_ERROR_NONE;\n-  }\n+  _state->update_for_pop_top_frame();\n+  java_thread->set_popframe_condition(JavaThread::popframe_pending_bit);\n+  \/\/ Set pending step flag for this popframe and it is cleared when next\n+  \/\/ step event is posted.\n+  _state->set_pending_step_for_popframe();\n+  _result = JVMTI_ERROR_NONE;\n@@ -1590,0 +1595,3 @@\n+  if (java_thread->is_exiting()) {\n+    return; \/* JVMTI_ERROR_THREAD_NOT_ALIVE (default) *\/\n+  }\n@@ -1609,3 +1617,0 @@\n-  if (java_thread->is_exiting() || java_thread->threadObj() == NULL) {\n-    return; \/* JVMTI_ERROR_THREAD_NOT_ALIVE (default) *\/\n-  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -147,4 +147,5 @@\n-  ttyLocker ttyl;\n-  tty->print_cr(\"UnrollBlock\");\n-  tty->print_cr(\"  size_of_deoptimized_frame = %d\", _size_of_deoptimized_frame);\n-  tty->print(   \"  frame_sizes: \");\n+  ResourceMark rm;\n+  stringStream st;\n+  st.print_cr(\"UnrollBlock\");\n+  st.print_cr(\"  size_of_deoptimized_frame = %d\", _size_of_deoptimized_frame);\n+  st.print(   \"  frame_sizes: \");\n@@ -152,1 +153,1 @@\n-    tty->print(INTX_FORMAT \" \", frame_sizes()[index]);\n+    st.print(INTX_FORMAT \" \", frame_sizes()[index]);\n@@ -154,1 +155,2 @@\n-  tty->cr();\n+  st.cr();\n+  tty->print_raw(st.as_string());\n@@ -183,0 +185,32 @@\n+#ifndef PRODUCT\n+\/\/ print information about reallocated objects\n+static void print_objects(JavaThread* deoptee_thread,\n+                          GrowableArray<ScopeValue*>* objects, bool realloc_failures) {\n+  ResourceMark rm;\n+  stringStream st;  \/\/ change to logStream with logging\n+  st.print_cr(\"REALLOC OBJECTS in thread \" INTPTR_FORMAT, p2i(deoptee_thread));\n+  fieldDescriptor fd;\n+\n+  for (int i = 0; i < objects->length(); i++) {\n+    ObjectValue* sv = (ObjectValue*) objects->at(i);\n+    Klass* k = java_lang_Class::as_Klass(sv->klass()->as_ConstantOopReadValue()->value()());\n+    Handle obj = sv->value();\n+\n+    st.print(\"     object <\" INTPTR_FORMAT \"> of type \", p2i(sv->value()()));\n+    k->print_value_on(&st);\n+    assert(obj.not_null() || realloc_failures, \"reallocation was missed\");\n+    if (obj.is_null()) {\n+      st.print(\" allocation failed\");\n+    } else {\n+      st.print(\" allocated (%d bytes)\", obj->size() * HeapWordSize);\n+    }\n+    st.cr();\n+\n+    if (Verbose && !obj.is_null()) {\n+      k->oop_print_on(obj(), &st);\n+    }\n+  }\n+  tty->print_raw(st.as_string());\n+}\n+#endif\n+\n@@ -214,1 +248,0 @@\n-      ttyLocker ttyl;\n@@ -235,3 +268,1 @@\n-      ttyLocker ttyl;\n-      tty->print_cr(\"REALLOC OBJECTS in thread \" INTPTR_FORMAT, p2i(deoptee_thread));\n-      Deoptimization::print_objects(objects, realloc_failures);\n+      print_objects(deoptee_thread, objects, realloc_failures);\n@@ -267,1 +298,2 @@\n-        ttyLocker ttyl;\n+        ResourceMark rm;\n+        stringStream st;\n@@ -273,1 +305,1 @@\n-              tty->print_cr(\"RELOCK OBJECTS in thread \" INTPTR_FORMAT, p2i(thread));\n+              st.print_cr(\"RELOCK OBJECTS in thread \" INTPTR_FORMAT, p2i(thread));\n@@ -278,1 +310,1 @@\n-                tty->print_cr(\"     object <\" INTPTR_FORMAT \"> DEFERRED relocking after wait\", p2i(mi->owner()));\n+                st.print_cr(\"     object <\" INTPTR_FORMAT \"> DEFERRED relocking after wait\", p2i(mi->owner()));\n@@ -284,1 +316,1 @@\n-              tty->print_cr(\"     failed reallocation for klass %s\", k->external_name());\n+              st.print_cr(\"     failed reallocation for klass %s\", k->external_name());\n@@ -286,1 +318,1 @@\n-              tty->print_cr(\"     object <\" INTPTR_FORMAT \"> locked\", p2i(mi->owner()));\n+              st.print_cr(\"     object <\" INTPTR_FORMAT \"> locked\", p2i(mi->owner()));\n@@ -290,0 +322,1 @@\n+        tty->print_raw(st.as_string());\n@@ -615,1 +648,0 @@\n-      ttyLocker ttyl;\n@@ -724,1 +756,0 @@\n-    ttyLocker ttyl;\n@@ -847,2 +878,0 @@\n-          ttyLocker ttyl;\n-\n@@ -873,1 +902,1 @@\n-        } \/\/ release tty lock before calling guarantee\n+        }\n@@ -1502,28 +1531,0 @@\n-\n-\n-#ifndef PRODUCT\n-\/\/ print information about reallocated objects\n-void Deoptimization::print_objects(GrowableArray<ScopeValue*>* objects, bool realloc_failures) {\n-  fieldDescriptor fd;\n-\n-  for (int i = 0; i < objects->length(); i++) {\n-    ObjectValue* sv = (ObjectValue*) objects->at(i);\n-    Klass* k = java_lang_Class::as_Klass(sv->klass()->as_ConstantOopReadValue()->value()());\n-    Handle obj = sv->value();\n-\n-    tty->print(\"     object <\" INTPTR_FORMAT \"> of type \", p2i(sv->value()()));\n-    k->print_value();\n-    assert(obj.not_null() || realloc_failures, \"reallocation was missed\");\n-    if (obj.is_null()) {\n-      tty->print(\" allocation failed\");\n-    } else {\n-      tty->print(\" allocated (%d bytes)\", obj->size() * HeapWordSize);\n-    }\n-    tty->cr();\n-\n-    if (Verbose && !obj.is_null()) {\n-      k->oop_print_on(obj(), tty);\n-    }\n-  }\n-}\n-#endif\n@@ -1537,4 +1538,5 @@\n-    ttyLocker ttyl;\n-    tty->print(\"DEOPT PACKING thread \" INTPTR_FORMAT \" \", p2i(thread));\n-    fr.print_on(tty);\n-    tty->print_cr(\"     Virtual frames (innermost first):\");\n+    ResourceMark rm;\n+    stringStream st;\n+    st.print(\"DEOPT PACKING thread \" INTPTR_FORMAT \" \", p2i(thread));\n+    fr.print_on(&st);\n+    st.print_cr(\"     Virtual frames (innermost first):\");\n@@ -1543,2 +1545,2 @@\n-      tty->print(\"       %2d - \", index);\n-      vf->print_value();\n+      st.print(\"       %2d - \", index);\n+      vf->print_value_on(&st);\n@@ -1553,2 +1555,2 @@\n-      tty->print(\" - %s\", code_name);\n-      tty->print_cr(\" @ bci %d \", bci);\n+      st.print(\" - %s\", code_name);\n+      st.print_cr(\" @ bci %d \", bci);\n@@ -1556,2 +1558,2 @@\n-        vf->print();\n-        tty->cr();\n+        vf->print_on(&st);\n+        st.cr();\n@@ -1560,0 +1562,1 @@\n+    tty->print_raw(st.as_string());\n@@ -1582,1 +1585,0 @@\n-    ttyLocker ttyl;\n@@ -1983,1 +1985,0 @@\n-      ttyLocker ttyl;\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":61,"deletions":60,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+#define SSIZE_PLUS_FORMAT        \"%+\"  PRIdPTR\n@@ -360,0 +361,3 @@\n+#define EXACTFMT            SIZE_FORMAT \"%s\"\n+#define EXACTFMTARGS(s)     byte_size_in_exact_unit(s), exact_unit_for_byte_size(s)\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -281,1 +281,1 @@\n- * @run main\/othervm -Xmx8g\n+ * @run main\/othervm\/timeout=300 -Xmx8g\n@@ -286,1 +286,1 @@\n- * @run main\/othervm -Xmx8g\n+ * @run main\/othervm\/timeout=240 -Xmx8g\n@@ -291,1 +291,1 @@\n- * @run main\/othervm -Xmx8g\n+ * @run main\/othervm\/timeout=180 -Xmx8g\n","filename":"test\/jdk\/java\/lang\/instrument\/GetObjectSizeIntrinsicsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import java.io.File;\n+import java.nio.charset.Charset;\n@@ -34,0 +36,1 @@\n+import java.time.Instant;\n@@ -90,0 +93,1 @@\n+        log(\"Entering call()\");\n@@ -114,1 +118,1 @@\n-        map.put(\"vm.cds.archived.java.heap\", this::vmCDSForArchivedJavaHeap);\n+        map.put(\"vm.cds.write.archived.java.heap\", this::vmCDSCanWriteArchivedJavaHeap);\n@@ -128,0 +132,1 @@\n+        log(\"Leaving call()\");\n@@ -389,3 +394,1 @@\n-     * Check for CDS support for archived Java heap regions.\n-     *\n-     * @return true if CDS provides support for archive Java heap regions in the VM to be tested.\n+     * @return true if this VM can write Java heap objects into the CDS archive\n@@ -393,2 +396,2 @@\n-    protected String vmCDSForArchivedJavaHeap() {\n-        return \"\" + (\"true\".equals(vmCDS()) && WB.isJavaHeapArchiveSupported());\n+    protected String vmCDSCanWriteArchivedJavaHeap() {\n+        return \"\" + (\"true\".equals(vmCDS()) && WB.canWriteJavaHeapArchive());\n@@ -437,0 +440,2 @@\n+        log(\"Entering dockerSupport()\");\n+\n@@ -455,0 +460,2 @@\n+        log(\"dockerSupport(): platform check: isSupported = \" + isSupported);\n+\n@@ -463,0 +470,1 @@\n+        log(\"dockerSupport(): returning isSupported = \" + isSupported);\n@@ -466,0 +474,34 @@\n+    \/\/ Configures process builder to redirect process stdout and stderr to a file.\n+    \/\/ Returns file names for stdout and stderr.\n+    private Map<String, String> redirectOutputToLogFile(String msg, ProcessBuilder pb, String fileNameBase) {\n+        Map<String, String> result = new HashMap<>();\n+        String timeStamp = Instant.now().toString().replace(\":\", \"-\").replace(\".\", \"-\");\n+\n+        String stdoutFileName = String.format(\".\/%s-stdout--%s.log\", fileNameBase, timeStamp);\n+        pb.redirectOutput(new File(stdoutFileName));\n+        log(msg + \": child process stdout redirected to \" + stdoutFileName);\n+        result.put(\"stdout\", stdoutFileName);\n+\n+        String stderrFileName = String.format(\".\/%s-stderr--%s.log\", fileNameBase, timeStamp);\n+        pb.redirectError(new File(stderrFileName));\n+        log(msg + \": child process stderr redirected to \" + stderrFileName);\n+        result.put(\"stderr\", stderrFileName);\n+\n+        return result;\n+    }\n+\n+    private void printLogfileContent(Map<String, String> logFileNames) {\n+        logFileNames.entrySet().stream()\n+            .forEach(entry ->\n+                {\n+                    log(\"------------- \" + entry.getKey());\n+                    try {\n+                        Files.lines(Path.of(entry.getValue()))\n+                            .forEach(line -> log(line));\n+                    } catch (IOException ie) {\n+                        log(\"Exception while reading file: \" + ie);\n+                    }\n+                    log(\"-------------\");\n+                });\n+    }\n+\n@@ -467,0 +509,1 @@\n+        log(\"checkDockerSupport(): entering\");\n@@ -468,0 +511,2 @@\n+        Map<String, String> logFileNames = redirectOutputToLogFile(\"checkDockerSupport(): <container> ps\",\n+                                                      pb, \"container-ps\");\n@@ -470,0 +515,1 @@\n+        int exitValue = p.exitValue();\n@@ -471,1 +517,6 @@\n-        return (p.exitValue() == 0);\n+        log(String.format(\"checkDockerSupport(): exitValue = %s, pid = %s\", exitValue, p.pid()));\n+        if (exitValue != 0) {\n+            printLogfileContent(logFileNames);\n+        }\n+\n+        return (exitValue == 0);\n@@ -590,0 +641,34 @@\n+    \/**\n+     * Log diagnostic message.\n+     *\n+     * @param msg\n+     *\/\n+    protected static void log(String msg) {\n+        \/\/ Always log to a file.\n+        logToFile(msg);\n+\n+        \/\/ Also log to stderr; guarded by property to avoid excessive verbosity.\n+        \/\/ By jtreg design stderr produced here will be visible\n+        \/\/ in the output of a parent process. Note: stdout should not be used\n+        \/\/ for logging as jtreg parses that output directly and only echoes it\n+        \/\/ in the event of a failure.\n+        if (Boolean.getBoolean(\"jtreg.log.vmprops\")) {\n+            System.err.println(\"VMProps: \" + msg);\n+        }\n+    }\n+\n+    \/**\n+     * Log diagnostic message to a file.\n+     *\n+     * @param msg\n+     *\/\n+    protected static void logToFile(String msg) {\n+        String fileName = \".\/vmprops.log\";\n+        try {\n+            Files.writeString(Paths.get(fileName), msg + \"\\n\", Charset.forName(\"ISO-8859-1\"),\n+                    StandardOpenOption.APPEND, StandardOpenOption.CREATE);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Failed to log into '\" + fileName + \"'\", e);\n+        }\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":93,"deletions":8,"binary":false,"changes":101,"status":"modified"}]}