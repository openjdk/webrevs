{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"jfr\/leakprofiler\/sampling\/objectSample.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -39,9 +41,0 @@\n-EdgeStore::EdgeStore() : _edges(NULL) {\n-  _edges = new EdgeHashTable(this);\n-}\n-\n-EdgeStore::~EdgeStore() {\n-  assert(_edges != NULL, \"invariant\");\n-  delete _edges;\n-}\n-\n@@ -227,1 +220,69 @@\n-\/\/ Install the immediate edge into the mark word of the leak candidate object\n+static GrowableArray<const StoredEdge*>* _leak_context_edges = nullptr;\n+\n+EdgeStore::EdgeStore() : _edges(new EdgeHashTable(this)) {}\n+\n+EdgeStore::~EdgeStore() {\n+  assert(_edges != NULL, \"invariant\");\n+  delete _edges;\n+  delete _leak_context_edges;\n+  _leak_context_edges = nullptr;\n+}\n+\n+static int leak_context_edge_idx(const ObjectSample* sample) {\n+  assert(sample != nullptr, \"invariant\");\n+  return static_cast<int>(sample->object()->mark().value()) >> markWord::lock_bits;\n+}\n+\n+bool EdgeStore::has_leak_context(const ObjectSample* sample) const {\n+  return leak_context_edge_idx(sample) != 0;\n+}\n+\n+const StoredEdge* EdgeStore::get(const ObjectSample* sample) const {\n+  assert(sample != nullptr, \"invariant\");\n+  if (_leak_context_edges != nullptr) {\n+    assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n+    const int idx = leak_context_edge_idx(sample);\n+    if (idx > 0) {\n+      return _leak_context_edges->at(idx);\n+    }\n+  }\n+  return get(UnifiedOopRef::encode_in_native(sample->object_addr()));\n+}\n+\n+#ifdef ASSERT\n+\/\/ max_idx to ensure idx fit in lower 32-bits of markword together with lock bits.\n+static constexpr const int max_idx =  right_n_bits(32 - markWord::lock_bits);\n+\n+static void store_idx_precondition(oop sample_object, int idx) {\n+  assert(sample_object != NULL, \"invariant\");\n+  assert(sample_object->mark().is_marked(), \"invariant\");\n+  assert(idx > 0, \"invariant\");\n+  assert(idx <= max_idx, \"invariant\");\n+}\n+#endif\n+\n+static void store_idx_in_markword(oop sample_object, int idx) {\n+  DEBUG_ONLY(store_idx_precondition(sample_object, idx);)\n+  const markWord idx_mark_word(sample_object->mark().value() | idx << markWord::lock_bits);\n+  sample_object->set_mark(idx_mark_word);\n+  assert(sample_object->mark().is_marked(), \"must still be marked\");\n+}\n+\n+static const int initial_size = 64;\n+\n+static int save(const StoredEdge* edge) {\n+  assert(edge != nullptr, \"invariant\");\n+  if (_leak_context_edges == nullptr) {\n+    _leak_context_edges = new (ResourceObj::C_HEAP, mtTracing)GrowableArray<const StoredEdge*>(initial_size, mtTracing);\n+    _leak_context_edges->append(nullptr); \/\/ next idx now at 1, for disambiguation in markword.\n+  }\n+  return _leak_context_edges->append(edge);\n+}\n+\n+\/\/ We associate the leak context edge with the leak candidate object by saving the\n+\/\/ edge in an array and storing the array idx (shifted) into the markword of the candidate object.\n+static void associate_with_candidate(const StoredEdge* leak_context_edge) {\n+  assert(leak_context_edge != nullptr, \"invariant\");\n+  store_idx_in_markword(leak_context_edge->pointee(), save(leak_context_edge));\n+}\n+\n@@ -232,4 +293,1 @@\n-  oop sample_object = edge->pointee();\n-  assert(sample_object != NULL, \"invariant\");\n-  assert(sample_object->mark().is_marked(), \"invariant\");\n-  sample_object->set_mark(markWord::from_pointer(leak_context_edge));\n+  associate_with_candidate(leak_context_edge);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeStore.cpp","additions":73,"deletions":15,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+class ObjectSample;\n@@ -82,0 +83,1 @@\n+  const StoredEdge* get(const ObjectSample* sample) const;\n@@ -93,0 +95,1 @@\n+  bool has_leak_context(const ObjectSample* sample) const;\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeStore.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,1 +123,1 @@\n-    if (!sample->object()->mark().is_marked()) {\n+    if (edge_store->has_leak_context(sample)) {\n@@ -140,12 +140,1 @@\n-  traceid gc_root_id = 0;\n-  const Edge* edge = NULL;\n-  if (SafepointSynchronize::is_at_safepoint()) {\n-    if (!sample->object()->mark().is_marked()) {\n-      edge = (const Edge*)(sample->object())->mark().to_pointer();\n-    }\n-  }\n-  if (edge == NULL) {\n-    edge = edge_store->get(UnifiedOopRef::encode_in_native(sample->object_addr()));\n-  } else {\n-    gc_root_id = edge_store->gc_root_id(edge);\n-  }\n+  const StoredEdge* const edge = edge_store->get(sample);\n@@ -153,0 +142,1 @@\n+  assert(edge->pointee() == sample->object(), \"invariant\");\n@@ -155,0 +145,1 @@\n+  const traceid gc_root_id = edge->gc_root_id();\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/eventEmitter.cpp","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"}]}