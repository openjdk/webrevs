{"files":[{"patch":"@@ -7481,1 +7481,14 @@\n-instruct loadNKlass(iRegNNoSp dst, memory4 mem, rFlagsReg cr)\n+instruct loadNKlass(iRegNNoSp dst, memory4 mem)\n+%{\n+  match(Set dst (LoadNKlass mem));\n+  predicate(!needs_acquiring_load(n) && !UseCompactObjectHeaders);\n+\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"ldrw  $dst, $mem\\t# compressed class ptr\" %}\n+\n+  ins_encode(aarch64_enc_ldrw(dst, mem));\n+\n+  ins_pipe(iload_reg_mem);\n+%}\n+\n+instruct loadNKlassLilliput(iRegNNoSp dst, memory4 mem, rFlagsReg cr)\n@@ -7485,1 +7498,1 @@\n-  predicate(!needs_acquiring_load(n));\n+  predicate(!needs_acquiring_load(n) && UseCompactObjectHeaders);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -258,0 +258,1 @@\n+  assert(UseCompactObjectHeaders, \"Only use with compact object headers\");\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2295,0 +2295,2 @@\n+  Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());\n+  Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());\n@@ -2355,4 +2357,9 @@\n-      assert(UseCompressedClassPointers, \"Lilliput\");\n-      __ load_nklass(tmp, src);\n-      __ load_nklass(rscratch1, dst);\n-      __ cmpw(tmp, rscratch1);\n+      if (UseCompressedClassPointers) {\n+        __ load_nklass(tmp, src);\n+        __ load_nklass(rscratch1, dst);\n+        __ cmpw(tmp, rscratch1);\n+      } else {\n+        __ ldr(tmp, Address(src, oopDesc::klass_offset_in_bytes()));\n+        __ ldr(rscratch1, Address(dst, oopDesc::klass_offset_in_bytes()));\n+        __ cmp(tmp, rscratch1);\n+      }\n@@ -2480,3 +2487,0 @@\n-    if (UseCompressedClassPointers) {\n-      __ encode_klass_not_null(tmp);\n-    }\n@@ -2484,1 +2488,0 @@\n-    assert(UseCompressedClassPointers, \"Lilliput\");\n@@ -2486,2 +2489,1 @@\n-      __ load_nklass(rscratch1, dst);\n-      __ cmpw(tmp, rscratch1);\n+      __ cmp_klass(dst, tmp, rscratch1);\n@@ -2489,2 +2491,1 @@\n-      __ load_nklass(rscratch1, src);\n-      __ cmpw(tmp, rscratch1);\n+      __ cmp_klass(src, tmp, rscratch1);\n@@ -2493,2 +2494,1 @@\n-      __ load_nklass(rscratch1, dst);\n-      __ cmpw(tmp, rscratch1);\n+      __ cmp_klass(dst, tmp, rscratch1);\n@@ -2542,1 +2542,5 @@\n-  if (!UseFastLocking) {\n+  if (UseHeavyMonitors) {\n+    if (op->info() != NULL) {\n+      add_debug_info_for_null_check_here(op->info());\n+      __ null_check(obj, -1);\n+    }\n@@ -2574,1 +2578,7 @@\n-  assert(UseCompressedClassPointers, \"expects UseCompressedClassPointers\");\n+  if (UseCompressedClassPointers) {\n+    if (UseCompactObjectHeaders) {\n+      \/\/ Check if we can take the (common) fast path, if obj is unlocked.\n+      __ ldr(result, Address(obj, oopDesc::mark_offset_in_bytes()));\n+      __ tst(result, markWord::monitor_value);\n+      __ br(Assembler::NE, *op->stub()->entry());\n+      __ bind(*op->stub()->continuation());\n@@ -2576,9 +2586,9 @@\n-  \/\/ Check if we can take the (common) fast path, if obj is unlocked.\n-  __ ldr(result, Address(obj, oopDesc::mark_offset_in_bytes()));\n-  __ tst(result, markWord::monitor_value);\n-  __ br(Assembler::NE, *op->stub()->entry());\n-  __ bind(*op->stub()->continuation());\n-\n-  \/\/ Shift and decode Klass*.\n-  __ lsr(result, result, markWord::klass_shift);\n-  __ decode_klass_not_null(result);\n+      \/\/ Shift to get proper narrow Klass*.\n+      __ lsr(result, result, markWord::klass_shift);\n+    } else {\n+      __ ldrw(result, Address (obj, oopDesc::klass_offset_in_bytes()));\n+    }\n+    __ decode_klass_not_null(result);\n+  } else {\n+    __ ldr(result, Address (obj, oopDesc::klass_offset_in_bytes()));\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":35,"deletions":25,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-  if (UseBiasedLocking && !len->is_valid()) {\n+  if (UseCompactObjectHeaders || (UseBiasedLocking && !len->is_valid())) {\n@@ -198,1 +198,2 @@\n-    ldr(t1, Address(klass, Klass::prototype_header_offset()));\n+    \/\/ This assumes that all prototype bits fit in an int32_t\n+    mov(t1, (int32_t)(intptr_t)markWord::prototype().value());\n@@ -202,0 +203,9 @@\n+  if (!UseCompactObjectHeaders) {\n+    if (UseCompressedClassPointers) { \/\/ Take care not to kill klass\n+      encode_klass_not_null(t1, klass);\n+      strw(t1, Address(obj, oopDesc::klass_offset_in_bytes()));\n+    } else {\n+      str(klass, Address(obj, oopDesc::klass_offset_in_bytes()));\n+    }\n+  }\n+\n@@ -204,0 +214,2 @@\n+  } else if (UseCompressedClassPointers && !UseCompactObjectHeaders) {\n+    store_klass_gap(obj, zr);\n@@ -315,2 +327,5 @@\n-  assert(!MacroAssembler::needs_explicit_null_check(oopDesc::mark_offset_in_bytes()), \"must add explicit null check\");\n-\n+  if (UseCompactObjectHeaders) {\n+    assert(!MacroAssembler::needs_explicit_null_check(oopDesc::mark_offset_in_bytes()), \"must add explicit null check\");\n+  } else {\n+    assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()), \"must add explicit null check\");\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -3815,0 +3815,5 @@\n+  if (!UseCompactObjectHeaders) {\n+    ldrw(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+    return;\n+  }\n+\n@@ -3829,3 +3834,19 @@\n-void MacroAssembler::load_klass(Register dst, Register src) {\n-  load_nklass(dst, src);\n-  decode_klass_not_null(dst);\n+void MacroAssembler::load_klass(Register dst, Register src, bool null_check_src) {\n+  if (null_check_src) {\n+    if (UseCompactObjectHeaders) {\n+      null_check(src, oopDesc::mark_offset_in_bytes());\n+    } else {\n+      null_check(src, oopDesc::klass_offset_in_bytes());\n+    }\n+  }\n+\n+  if (UseCompressedClassPointers) {\n+    if (UseCompactObjectHeaders) {\n+      load_nklass(dst, src);\n+    } else {\n+      ldrw(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+    }\n+    decode_klass_not_null(dst);\n+  } else {\n+    ldr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+  }\n@@ -3866,10 +3887,19 @@\n-  assert(UseCompressedClassPointers, \"Lilliput\");\n-  load_nklass(tmp, oop);\n-  if (CompressedKlassPointers::base() == NULL) {\n-    cmp(trial_klass, tmp, LSL, CompressedKlassPointers::shift());\n-    return;\n-  } else if (((uint64_t)CompressedKlassPointers::base() & 0xffffffff) == 0\n-             && CompressedKlassPointers::shift() == 0) {\n-    \/\/ Only the bottom 32 bits matter\n-    cmpw(trial_klass, tmp);\n-    return;\n+  assert_different_registers(oop, trial_klass, tmp);\n+  if (UseCompressedClassPointers) {\n+    if (UseCompactObjectHeaders) {\n+      load_nklass(tmp, oop);\n+    } else {\n+      ldrw(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));\n+    }\n+    if (CompressedKlassPointers::base() == NULL) {\n+      cmp(trial_klass, tmp, LSL, CompressedKlassPointers::shift());\n+      return;\n+    } else if (((uint64_t)CompressedKlassPointers::base() & 0xffffffff) == 0\n+               && CompressedKlassPointers::shift() == 0) {\n+      \/\/ Only the bottom 32 bits matter\n+      cmpw(trial_klass, tmp);\n+      return;\n+    }\n+    decode_klass_not_null(tmp);\n+  } else {\n+    ldr(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));\n@@ -3877,1 +3907,0 @@\n-  decode_klass_not_null(tmp);\n@@ -3881,0 +3910,18 @@\n+void MacroAssembler::store_klass(Register dst, Register src) {\n+  \/\/ FIXME: Should this be a store release?  concurrent gcs assumes\n+  \/\/ klass length is valid if klass field is not null.\n+  if (UseCompressedClassPointers) {\n+    encode_klass_not_null(src);\n+    strw(src, Address(dst, oopDesc::klass_offset_in_bytes()));\n+  } else {\n+    str(src, Address(dst, oopDesc::klass_offset_in_bytes()));\n+  }\n+}\n+\n+void MacroAssembler::store_klass_gap(Register dst, Register src) {\n+  if (UseCompressedClassPointers) {\n+    \/\/ Store to klass gap in destination\n+    strw(src, Address(dst, oopDesc::klass_gap_offset_in_bytes()));\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":61,"deletions":14,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -827,1 +827,2 @@\n-  void load_klass(Register dst, Register src);\n+  void load_klass(Register dst, Register src, bool null_check = false);\n+  void store_klass(Register dst, Register src);\n@@ -853,0 +854,2 @@\n+  void store_klass_gap(Register dst, Register src);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -310,2 +310,1 @@\n-        __ null_check(receiver_reg, oopDesc::mark_offset_in_bytes());\n-        __ load_klass(temp1_recv_klass, receiver_reg);\n+        __ load_klass(temp1_recv_klass, receiver_reg, true);\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -587,12 +587,2 @@\n-    \/\/ NOTE: We used to load the Klass* here, and compare that to zero.\n-    \/\/ However, with current Lilliput implementation, that would require\n-    \/\/ checking the locking bits and calling into the runtime, which\n-    \/\/ clobbers the condition flags, which may be live around this call.\n-    \/\/ OTOH, this is a simple NULL-check, and we can simply load the upper\n-    \/\/ 32bit of the header as narrowKlass, and compare that to 0. The\n-    \/\/ worst that can happen (rarely) is that the object is locked and\n-    \/\/ we have lock pointer bits in the upper 32bits. We can't get a false\n-    \/\/ negative.\n-    assert(oopDesc::klass_offset_in_bytes() % 4 == 0, \"must be 4 byte aligned\");\n-    __ ldrw(r0, Address(r0, oopDesc::klass_offset_in_bytes()));  \/\/ get klass\n-    __ cbzw(r0, error);      \/\/ if klass is NULL it is broken\n+    __ load_klass(r0, r0);  \/\/ get klass\n+    __ cbz(r0, error);      \/\/ if klass is NULL it is broken\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3238,2 +3238,1 @@\n-  __ null_check(recv, oopDesc::mark_offset_in_bytes());\n-  __ load_klass(r0, recv);\n+  __ load_klass(r0, recv, true);\n@@ -3328,2 +3327,1 @@\n-  __ null_check(r2, oopDesc::mark_offset_in_bytes());\n-  __ load_klass(r3, r2);\n+  __ load_klass(r3, r2, true);\n@@ -3345,2 +3343,1 @@\n-  __ null_check(r2, oopDesc::mark_offset_in_bytes());\n-  __ load_klass(r3, r2);\n+  __ load_klass(r3, r2, true);\n@@ -3541,1 +3538,1 @@\n-    __ sub(r3, r3, sizeof(oopDesc));\n+    __ sub(r3, r3, oopDesc::base_offset_in_bytes());\n@@ -3546,1 +3543,6 @@\n-      __ add(r2, r0, sizeof(oopDesc));\n+      __ add(r2, r0, oopDesc::base_offset_in_bytes());\n+      if (!is_aligned(oopDesc::base_offset_in_bytes(), BytesPerLong)) {\n+        __ strw(zr, Address(__ post(r2, BytesPerInt)));\n+        __ sub(r3, r3, BytesPerInt);\n+        __ cbz(r3, initialize_header);\n+      }\n@@ -3556,1 +3558,5 @@\n-    __ ldr(rscratch1, Address(r4, Klass::prototype_header_offset()));\n+    if (UseBiasedLocking || UseCompactObjectHeaders) {\n+      __ ldr(rscratch1, Address(r4, Klass::prototype_header_offset()));\n+    } else {\n+      __ mov(rscratch1, (intptr_t)markWord::prototype().value());\n+    }\n@@ -3558,1 +3564,4 @@\n-\n+    if (!UseCompactObjectHeaders) {\n+      __ store_klass_gap(r0, zr);  \/\/ zero klass gap for compressed oops\n+      __ store_klass(r0, r4);      \/\/ store klass last\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -305,0 +305,1 @@\n+  assert(UseCompactObjectHeaders, \"only with compact headers\");\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3071,1 +3071,1 @@\n-  Register tmp2 = LP64_ONLY(rscratch2) NOT_LP64(noreg);\n+  Register tmp2 = UseCompactObjectHeaders ? rscratch2 : noreg;\n@@ -3196,1 +3196,0 @@\n-#ifndef _LP64\n@@ -3199,1 +3198,1 @@\n-#endif\n+\n@@ -3264,8 +3263,1 @@\n-#ifdef _LP64\n-      __ load_nklass(tmp, src);\n-      __ load_nklass(tmp2, dst);\n-      __ cmpl(tmp, tmp2);\n-#else\n-      __ movptr(tmp, src_klass_addr);\n-      __ cmpptr(tmp, dst_klass_addr);\n-#endif\n+      __ cmp_klass(src, dst, tmp, tmp2);\n@@ -3427,13 +3419,4 @@\n-    assert(UseCompressedClassPointers, \"Lilliput\");\n-    __ encode_klass_not_null(tmp, rscratch1);\n-    if (basic_type != T_OBJECT) {\n-      __ load_nklass(tmp2, dst);\n-      __ cmpl(tmp, tmp2);\n-      __ jcc(Assembler::notEqual, halt);\n-      __ load_nklass(tmp2, src);\n-      __ cmpl(tmp, tmp2);\n-      __ jcc(Assembler::equal, known_ok);\n-    } else {\n-      __ load_nklass(tmp2, dst);\n-      __ cmpl(tmp, tmp2);\n-#else\n+    if (UseCompressedClassPointers) {\n+      __ encode_klass_not_null(tmp, rscratch1);\n+    }\n+#endif\n@@ -3441,1 +3424,1 @@\n-      __ cmpptr(tmp, dst_klass_addr);\n+      __ cmp_klass(tmp, dst, tmp2);\n@@ -3443,1 +3426,1 @@\n-      __ cmpptr(tmp, src_klass_addr);\n+      __ cmp_klass(tmp, src, tmp2);\n@@ -3446,2 +3429,1 @@\n-      __ cmpptr(tmp, dst_klass_addr);\n-#endif\n+      __ cmp_klass(tmp, dst, tmp2);\n@@ -3509,1 +3491,1 @@\n-  if (!UseFastLocking) {\n+  if (UseHeavyMonitors) {\n@@ -3540,0 +3522,1 @@\n+\n@@ -3541,16 +3524,17 @@\n-  Register tmp = rscratch1;\n-  assert_different_registers(tmp, obj);\n-  assert_different_registers(tmp, result);\n-\n-  \/\/ Check if we can take the (common) fast path, if obj is unlocked.\n-  __ movq(result, Address(obj, oopDesc::mark_offset_in_bytes()));\n-  __ testb(result, markWord::monitor_value);\n-  __ jcc(Assembler::notZero, *op->stub()->entry());\n-  __ bind(*op->stub()->continuation());\n-  \/\/ Fast-path: shift and decode Klass*.\n-  __ shrq(result, markWord::klass_shift);\n-  __ decode_klass_not_null(result, tmp);\n-#else\n-  __ movptr(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n-  \/\/ Not really needed, but bind the label anyway to make compiler happy.\n-  __ bind(*op->stub()->continuation());\n+  if (UseCompactObjectHeaders) {\n+    Register tmp = rscratch1;\n+    assert_different_registers(tmp, obj);\n+    assert_different_registers(tmp, result);\n+\n+    \/\/ Check if we can take the (common) fast path, if obj is unlocked.\n+    __ movq(result, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    __ testb(result, markWord::monitor_value);\n+    __ jcc(Assembler::notZero, *op->stub()->entry());\n+    __ bind(*op->stub()->continuation());\n+    \/\/ Fast-path: shift and decode Klass*.\n+    __ shrq(result, markWord::klass_shift);\n+    __ decode_klass_not_null(result, tmp);\n+  } else if (UseCompressedClassPointers) {\n+    __ movl(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n+    __ decode_klass_not_null(result, rscratch1);\n+  } else\n@@ -3558,0 +3542,1 @@\n+  __ movptr(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":30,"deletions":45,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -183,4 +183,11 @@\n-  movptr(t1, Address(klass, Klass::prototype_header_offset()));\n-  movptr(Address(obj, oopDesc::mark_offset_in_bytes()), t1);\n-#ifndef _LP64\n-  movptr(Address(obj, oopDesc::klass_offset_in_bytes()), klass);\n+  if (UseCompactObjectHeaders) {\n+    movptr(t1, Address(klass, Klass::prototype_header_offset()));\n+    movptr(Address(obj, oopDesc::mark_offset_in_bytes()), t1);\n+  } else {\n+    movptr(Address(obj, oopDesc::mark_offset_in_bytes()), checked_cast<int32_t>(markWord::prototype().value()));\n+#ifdef _LP64\n+    if (UseCompressedClassPointers) { \/\/ Take care not to kill klass\n+      movptr(t1, klass);\n+      encode_klass_not_null(t1, rscratch1);\n+      movl(Address(obj, oopDesc::klass_offset_in_bytes()), t1);\n+    } else\n@@ -188,1 +195,4 @@\n-\n+    {\n+      movptr(Address(obj, oopDesc::klass_offset_in_bytes()), klass);\n+    }\n+  }\n@@ -192,0 +202,6 @@\n+#ifdef _LP64\n+  else if (UseCompressedClassPointers && !UseCompactObjectHeaders) {\n+    xorptr(t1, t1);\n+    store_klass_gap(obj, t1);\n+  }\n+#endif\n@@ -230,0 +246,1 @@\n+    int hdr_size_aligned = align_up(hdr_size_in_bytes, BytesPerWord); \/\/ klass gap is already cleared by init_header().\n@@ -232,1 +249,1 @@\n-      initialize_body(obj, index, hdr_size_in_bytes, t1_zero);\n+      initialize_body(obj, index, hdr_size_aligned, t1_zero);\n@@ -237,1 +254,1 @@\n-      for (int i = hdr_size_in_bytes; i < con_size_in_bytes; i += BytesPerWord)\n+      for (int i = hdr_size_aligned; i < con_size_in_bytes; i += BytesPerWord)\n@@ -239,1 +256,1 @@\n-    } else if (con_size_in_bytes > hdr_size_in_bytes) {\n+    } else if (con_size_in_bytes > hdr_size_aligned) {\n@@ -246,1 +263,1 @@\n-      if (((con_size_in_bytes - hdr_size_in_bytes) & 4) != 0)\n+      if (((con_size_in_bytes - hdr_size_aligned) & 4) != 0)\n@@ -251,1 +268,1 @@\n-        movptr(Address(obj, index, Address::times_8, hdr_size_in_bytes - (1*BytesPerWord)),\n+        movptr(Address(obj, index, Address::times_8, hdr_size_aligned - (1*BytesPerWord)),\n@@ -253,1 +270,1 @@\n-        NOT_LP64(movptr(Address(obj, index, Address::times_8, hdr_size_in_bytes - (2*BytesPerWord)),\n+        NOT_LP64(movptr(Address(obj, index, Address::times_8, hdr_size_aligned - (2*BytesPerWord)),\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":28,"deletions":11,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -4758,1 +4758,6 @@\n-  Label fast;\n+  if (!UseCompactObjectHeaders) {\n+    movl(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+    return;\n+  }\n+\n+ Label fast;\n@@ -4774,8 +4779,0 @@\n-#ifdef _LP64\n-  assert(UseCompressedClassPointers, \"expect compressed class pointers\");\n-  if (null_check_src) {\n-    null_check(src, oopDesc::mark_offset_in_bytes());\n-  }\n-  load_nklass(dst, src);\n-  decode_klass_not_null(dst, tmp);\n-#else\n@@ -4783,1 +4780,5 @@\n-    null_check(src, oopDesc::klass_offset_in_bytes());\n+    if (UseCompactObjectHeaders) {\n+      null_check(src, oopDesc::mark_offset_in_bytes());\n+    } else {\n+      null_check(src, oopDesc::klass_offset_in_bytes());\n+    }\n@@ -4785,1 +4786,5 @@\n-  movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+#ifdef _LP64\n+  if (UseCompressedClassPointers) {\n+    load_nklass(dst, src);\n+    decode_klass_not_null(dst, tmp);\n+  } else\n@@ -4787,0 +4792,1 @@\n+    movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n@@ -4794,3 +4800,11 @@\n-#ifndef _LP64\n-void MacroAssembler::store_klass(Register dst, Register src) {\n-  movptr(Address(dst, oopDesc::klass_offset_in_bytes()), src);\n+void MacroAssembler::store_klass(Register dst, Register src, Register tmp) {\n+  assert(!UseCompactObjectHeaders, \"not with compact headers\");\n+  assert_different_registers(src, tmp);\n+  assert_different_registers(dst, tmp);\n+#ifdef _LP64\n+  if (UseCompressedClassPointers) {\n+    encode_klass_not_null(src, tmp);\n+    movl(Address(dst, oopDesc::klass_offset_in_bytes()), src);\n+  } else\n+#endif\n+   movptr(Address(dst, oopDesc::klass_offset_in_bytes()), src);\n@@ -4798,0 +4812,12 @@\n+\n+void MacroAssembler::cmp_klass(Register klass, Register obj, Register tmp) {\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    \/\/ NOTE: We need to deal with possible ObjectMonitor in object header.\n+    \/\/ Eventually we might be able to do simple movl & cmpl like in\n+    \/\/ the CCP path below.\n+    load_nklass(tmp, obj);\n+    cmpl(klass, tmp);\n+  } else if (UseCompressedClassPointers) {\n+    cmpl(klass, Address(obj, oopDesc::klass_offset_in_bytes()));\n+  } else\n@@ -4799,0 +4825,26 @@\n+  {\n+    cmpptr(klass, Address(obj, oopDesc::klass_offset_in_bytes()));\n+  }\n+}\n+\n+void MacroAssembler::cmp_klass(Register src, Register dst, Register tmp1, Register tmp2) {\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    \/\/ NOTE: We need to deal with possible ObjectMonitor in object header.\n+    \/\/ Eventually we might be able to do simple movl & cmpl like in\n+    \/\/ the CCP path below.\n+    assert(tmp2 != noreg, \"need tmp2\");\n+    assert_different_registers(src, dst, tmp1, tmp2);\n+    load_nklass(tmp1, src);\n+    load_nklass(tmp2, dst);\n+    cmpl(tmp1, tmp2);\n+  } else if (UseCompressedClassPointers) {\n+    movl(tmp1, Address(src, oopDesc::klass_offset_in_bytes()));\n+    cmpl(tmp1, Address(dst, oopDesc::klass_offset_in_bytes()));\n+  } else\n+#endif\n+  {\n+    movptr(tmp1, Address(src, oopDesc::klass_offset_in_bytes()));\n+    cmpptr(tmp1, Address(dst, oopDesc::klass_offset_in_bytes()));\n+  }\n+}\n@@ -4846,0 +4898,7 @@\n+void MacroAssembler::store_klass_gap(Register dst, Register src) {\n+  if (UseCompressedClassPointers) {\n+    \/\/ Store to klass gap in destination\n+    movl(Address(dst, oopDesc::klass_gap_offset_in_bytes()), src);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":73,"deletions":14,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -345,2 +345,0 @@\n-#else\n-  void store_klass(Register dst, Register src);\n@@ -348,0 +346,9 @@\n+  void store_klass(Register dst, Register src, Register tmp);\n+\n+  \/\/ Compares the Klass pointer of an object to a given Klass (which might be narrow,\n+  \/\/ depending on UseCompressedClassPointers).\n+  void cmp_klass(Register klass, Register dst, Register tmp);\n+\n+  \/\/ Compares the Klass pointer of two objects o1 and o2. Result is in the condition flags.\n+  \/\/ Uses t1 and t2 as temporary registers.\n+  void cmp_klass(Register src, Register dst, Register tmp1, Register tmp2);\n@@ -368,0 +375,2 @@\n+  void store_klass_gap(Register dst, Register src);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3993,1 +3993,2 @@\n-    __ decrement(rdx, sizeof(oopDesc));\n+    int header_size = align_up(oopDesc::base_offset_in_bytes(), BytesPerLong);\n+    __ decrement(rdx, header_size);\n@@ -4015,2 +4016,2 @@\n-    __ movptr(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - 1*oopSize), rcx);\n-    NOT_LP64(__ movptr(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - 2*oopSize), rcx));\n+    __ movptr(Address(rax, rdx, Address::times_8, header_size - 1*oopSize), rcx);\n+    NOT_LP64(__ movptr(Address(rax, rdx, Address::times_8, header_size - 2*oopSize), rcx));\n@@ -4023,5 +4024,11 @@\n-    __ pop(rcx);   \/\/ get saved klass back in the register.\n-    __ movptr(rbx, Address(rcx, Klass::prototype_header_offset()));\n-    __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()), rbx);\n-#ifndef _LP64\n-    __ store_klass(rax, rcx);  \/\/ klass\n+    if (UseCompactObjectHeaders) {\n+      __ pop(rcx);   \/\/ get saved klass back in the register.\n+      __ movptr(rbx, Address(rcx, Klass::prototype_header_offset()));\n+      __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()), rbx);\n+    } else {\n+      __ movptr(Address(rax, oopDesc::mark_offset_in_bytes()),\n+                (intptr_t)markWord::prototype().value()); \/\/ header\n+      __ pop(rcx);   \/\/ get saved klass back in the register.\n+#ifdef _LP64\n+      __ xorl(rsi, rsi); \/\/ use zero reg to clear memory (shorter code)\n+      __ store_klass_gap(rax, rsi);  \/\/ zero klass gap for compressed oops\n@@ -4029,0 +4036,2 @@\n+      __ store_klass(rax, rcx, rscratch1);  \/\/ klass\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -5194,1 +5194,1 @@\n-instruct loadNKlass(rRegN dst, indOffset8 mem, rFlagsReg cr)\n+instruct loadNKlass(rRegN dst, memory mem)\n@@ -5196,0 +5196,14 @@\n+  predicate(!UseCompactObjectHeaders);\n+  match(Set dst (LoadNKlass mem));\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movl    $dst, $mem\\t# compressed klass ptr\" %}\n+  ins_encode %{\n+    __ movl($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem); \/\/ XXX\n+%}\n+\n+instruct loadNKlassLilliput(rRegN dst, indOffset8 mem, rFlagsReg cr)\n+%{\n+  predicate(UseCompactObjectHeaders);\n@@ -12238,3 +12252,0 @@\n-\/\/ Disabled because the compressed Klass* in header cannot be safely\n-\/\/ accessed. TODO: Re-enable it as soon as synchronization does not\n-\/\/ overload the upper header bits anymore.\n@@ -12243,1 +12254,1 @@\n-  predicate(false);\n+  predicate(!UseCompactObjectHeaders);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -566,1 +566,0 @@\n-  LIR_Opr          _obj;\n@@ -570,2 +569,2 @@\n-  LoadKlassStub(LIR_Opr obj, LIR_Opr result) :\n-    CodeStub(), _obj(obj), _result(result) {};\n+  LoadKlassStub(LIR_Opr result) :\n+    CodeStub(), _result(result) {};\n@@ -575,1 +574,1 @@\n-    visitor->do_input(_obj);\n+    visitor->do_temp(_result);\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -891,1 +891,1 @@\n-      do_stub(opLoadKlass->_stub);\n+      if (opLoadKlass->_stub) do_stub(opLoadKlass->_stub);\n@@ -1068,1 +1068,3 @@\n-  masm->append_code_stub(stub());\n+  if (stub()) {\n+    masm->append_code_stub(stub());\n+  }\n@@ -1998,1 +2000,3 @@\n-  out->print(\"[lbl:\" INTPTR_FORMAT \"]\", p2i(stub()->entry()));\n+  if (stub()) {\n+    out->print(\"[lbl:\" INTPTR_FORMAT \"]\", p2i(stub()->entry()));\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1259,1 +1259,1 @@\n-  CodeStub* slow_path = new LoadKlassStub(obj, klass);\n+  CodeStub* slow_path = UseCompactObjectHeaders ? new LoadKlassStub(klass) : NULL;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -735,1 +735,0 @@\n-    Klass* requested_k = to_requested(k);\n@@ -737,5 +736,6 @@\n-    narrowKlass nk = CompressedKlassPointers::encode_not_null(requested_k, _requested_static_archive_bottom);\n-    k->set_prototype_header(markWord::prototype().set_narrow_klass(nk));\n-#else\n-    k->set_prototype_header(markWord::prototype());\n-#endif\n+    if (UseCompactObjectHeaders) {\n+      Klass* requested_k = to_requested(k);\n+      narrowKlass nk = CompressedKlassPointers::encode_not_null(requested_k, _requested_static_archive_bottom);\n+      k->set_prototype_header(markWord::prototype().set_narrow_klass(nk));\n+    }\n+#endif \/\/_LP64\n@@ -783,0 +783,1 @@\n+#ifdef _LP64\n@@ -787,3 +788,6 @@\n-#ifdef _LP64\n-  o->set_mark(o->mark().set_narrow_klass(nk));\n-#endif\n+  if (UseCompactObjectHeaders) {\n+    o->set_mark(o->mark().set_narrow_klass(nk));\n+  } else {\n+    o->set_narrow_klass(nk);\n+  }\n+#endif \/\/ _LP64\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -279,5 +279,9 @@\n-\n-    assert(SafepointSynchronize::is_at_safepoint(), \"resolving displaced headers only at safepoint\");\n-    markWord mark = obj->mark();\n-    if (mark.has_displaced_mark_helper()) {\n-      mark = mark.displaced_mark_helper();\n+    if (UseCompactObjectHeaders) {\n+      markWord mark = obj->mark();\n+      if (mark.has_displaced_mark_helper()) {\n+        mark = mark.displaced_mark_helper();\n+      }\n+      narrowKlass nklass = mark.narrow_klass();\n+      archived_oop->set_mark(markWord::prototype().copy_set_hash(hash_original) LP64_ONLY(.set_narrow_klass(nklass)));\n+    } else {\n+      archived_oop->set_mark(markWord::prototype().copy_set_hash(hash_original));\n@@ -285,2 +289,0 @@\n-    narrowKlass nklass = mark.narrow_klass();\n-    archived_oop->set_mark(markWord::prototype().copy_set_hash(hash_original) LP64_ONLY(.set_narrow_klass(nklass)));\n@@ -427,4 +429,6 @@\n-    oopDesc::set_mark(mem, k->prototype_header());\n-#ifndef _LP64\n-    oopDesc::release_set_klass(mem, k);\n-#endif\n+    if (UseCompactObjectHeaders) {\n+      oopDesc::set_mark(mem, k->prototype_header());\n+    } else {\n+      oopDesc::set_mark(mem, markWord::prototype());\n+      oopDesc::release_set_klass(mem, k);\n+    }\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -436,0 +436,1 @@\n+  Klass* klass;\n@@ -437,3 +438,3 @@\n-  Klass* klass = old_mark.safe_klass();\n-#else\n-  Klass* klass = old->klass();\n+  if (UseCompactObjectHeaders) {\n+    klass = old_mark.safe_klass();\n+  } else\n@@ -441,0 +442,3 @@\n+  {\n+    klass = old->klass();\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -86,11 +86,10 @@\n-#ifdef _LP64\n-  filler_oop->set_mark(Universe::intArrayKlassObj()->prototype_header());\n-#else\n-  filler_oop->set_mark(markWord::prototype());\n-  filler_oop->set_klass(Universe::intArrayKlassObj());\n-#endif\n-  int header_size = (arrayOopDesc::base_offset_in_bytes(T_INT) + BytesPerWord) \/ BytesPerWord;\n-  const size_t array_length =\n-    pointer_delta(tlab_end, top()) - header_size;\n-  assert( (array_length * (HeapWordSize\/sizeof(jint))) < (size_t)max_jint, \"array too big in PSPromotionLAB\");\n-  filler_oop->set_length((int)(array_length * (HeapWordSize\/sizeof(jint))));\n+  if (UseCompactObjectHeaders) {\n+    filler_oop->set_mark(Universe::intArrayKlassObj()->prototype_header());\n+  } else {\n+    filler_oop->set_mark(markWord::prototype());\n+    filler_oop->set_klass(Universe::intArrayKlassObj());\n+  }\n+  int header_size = arrayOopDesc::base_offset_in_bytes(T_INT);\n+  const size_t array_length_bytes = pointer_delta(tlab_end, top(), 1) - header_size;\n+  assert((array_length_bytes \/ sizeof(jint)) < (size_t)max_jint, \"array too big in PSPromotionLAB\");\n+  filler_oop->set_length((int)(array_length_bytes \/ sizeof(jint)));\n@@ -100,2 +99,3 @@\n-  HeapWord* elt_words = cast_from_oop<HeapWord*>(filler_oop) + header_size;\n-  Copy::fill_to_words(elt_words, array_length, 0xDEAABABE);\n+  const size_t array_length_words = pointer_delta(tlab_end, top()) - heap_word_size(header_size);\n+  HeapWord* elt_words = cast_from_oop<HeapWord*>(filler_oop) + heap_word_size(header_size);\n+  Copy::fill_to_words(elt_words, array_length_words, 0xDEAABABE);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionLAB.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -163,0 +163,1 @@\n+  Klass* klass;\n@@ -164,3 +165,3 @@\n-  Klass* klass = test_mark.safe_klass();\n-#else\n-  Klass* klass = o->klass();\n+  if (UseCompactObjectHeaders) {\n+    klass = test_mark.safe_klass();\n+  } else\n@@ -168,0 +169,3 @@\n+  {\n+    klass = o->klass();\n+  }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -44,1 +44,13 @@\n-  obj->set_mark(obj->klass()->prototype_header().set_marked());\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    markWord real_mark = mark;\n+    if (real_mark.has_displaced_mark_helper()) {\n+      real_mark = real_mark.displaced_mark_helper();\n+    }\n+    Klass* klass = real_mark.klass();\n+    obj->set_mark(klass->prototype_header().set_marked());\n+  } else\n+#endif\n+  {\n+    obj->set_mark(markWord::prototype().set_marked());\n+  }\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -379,0 +379,3 @@\n+  if (!UseCompactObjectHeaders) {\n+    oopDesc::set_klass_gap(mem, 0);\n+  }\n@@ -387,6 +390,6 @@\n-#ifdef _LP64\n-  oopDesc::release_set_mark(mem, _klass->prototype_header());\n-#else\n-  oopDesc::set_mark(mem, _klass->prototype_header());\n-  oopDesc::release_set_klass(mem, _klass);\n-#endif\n+  if (UseCompactObjectHeaders) {\n+    oopDesc::release_set_mark(mem, _klass->prototype_header());\n+  } else {\n+    oopDesc::set_mark(mem, markWord::prototype());\n+    oopDesc::release_set_klass(mem, _klass);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -91,10 +91,10 @@\n-    oop forwardee = obj->forwardee();\n-    markWord header = forwardee->mark();\n-    if (header.has_displaced_mark_helper()) {\n-      header = header.displaced_mark_helper();\n-    }\n-    assert(UseCompressedClassPointers, \"assume +UseCompressedClassPointers\");\n-    narrowKlass nklass = header.narrow_klass();\n-    obj->set_mark(markWord::prototype().set_narrow_klass(nklass));\n-#else\n-    PreservedMarks::init_forwarded_mark(obj);\n+    if (UseCompactObjectHeaders) {\n+      oop forwardee = obj->forwardee();\n+      markWord header = forwardee->mark();\n+      if (header.has_displaced_mark_helper()) {\n+        header = header.displaced_mark_helper();\n+      }\n+      assert(UseCompressedClassPointers, \"assume +UseCompressedClassPointers\");\n+      narrowKlass nklass = header.narrow_klass();\n+      obj->set_mark(markWord::prototype().set_narrow_klass(nklass));\n+    } else\n@@ -102,0 +102,3 @@\n+    {\n+      PreservedMarks::init_forwarded_mark(obj);\n+    }\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.cpp","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+  assert(UseCompactObjectHeaders, \"only used with compact object headers\");\n@@ -81,0 +82,3 @@\n+  if (!UseCompactObjectHeaders) {\n+    return obj->klass();\n+  }\n@@ -91,1 +95,4 @@\n-  Klass* kls = klass(obj);\n+  if (!UseCompactObjectHeaders) {\n+    return obj->size();\n+  }\n+ Klass* kls = klass(obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahObjectUtils.inline.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    return sizeof(arrayOopDesc);\n+    return oopDesc::base_offset_in_bytes();\n","filename":"src\/hotspot\/share\/oops\/arrayOop.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2591,1 +2591,7 @@\n-    set_prototype_header(markWord::prototype() LP64_ONLY(.set_klass(this)));\n+    markWord prototype = markWord::prototype();\n+#ifdef _LP64\n+    if (UseCompactObjectHeaders) {\n+      prototype = prototype.set_klass(this);\n+    }\n+#endif\n+    set_prototype_header(prototype);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,3 +35,0 @@\n-  \/\/ aligned header size.\n-  static int header_size() { return sizeof(instanceOopDesc)\/HeapWordSize; }\n-\n@@ -40,1 +37,1 @@\n-    return sizeof(instanceOopDesc);\n+    return oopDesc::base_offset_in_bytes();\n","filename":"src\/hotspot\/share\/oops\/instanceOop.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -200,0 +200,10 @@\n+static markWord make_prototype(Klass* kls) {\n+  markWord prototype = markWord::prototype();\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    prototype = prototype.set_klass(kls);\n+  }\n+#endif\n+  return prototype;\n+}\n+\n@@ -205,1 +215,1 @@\n-                           _prototype_header(markWord::prototype() LP64_ONLY(.set_klass(this))),\n+                           _prototype_header(make_prototype(this)),\n@@ -747,2 +757,4 @@\n-     st->print(BULLET\"prototype_header: \" INTPTR_FORMAT, _prototype_header.value());\n-     st->cr();\n+     if (UseCompactObjectHeaders) {\n+       st->print(BULLET\"prototype_header: \" INTPTR_FORMAT, _prototype_header.value());\n+       st->cr();\n+     }\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -655,1 +655,4 @@\n-  markWord prototype_header() const      { return _prototype_header; }\n+  markWord prototype_header() const      {\n+    assert(UseCompactObjectHeaders, \"only use with compact object headers\");\n+    return _prototype_header;\n+  }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+  assert(UseCompactObjectHeaders, \"only used with compact object headers\");\n@@ -85,0 +86,1 @@\n+  assert(UseCompactObjectHeaders, \"only used with compact object headers\");\n@@ -90,0 +92,1 @@\n+  assert(UseCompactObjectHeaders, \"only used with compact object headers\");\n@@ -94,0 +97,1 @@\n+  assert(UseCompactObjectHeaders, \"only used with compact object headers\");\n@@ -98,0 +102,1 @@\n+  assert(UseCompactObjectHeaders, \"only used with compact object headers\");\n@@ -107,0 +112,1 @@\n+  assert(UseCompactObjectHeaders, \"only used with compact object headers\");\n","filename":"src\/hotspot\/share\/oops\/markWord.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -141,0 +141,15 @@\n+bool oopDesc::has_klass_gap() {\n+  \/\/ Only has a klass gap when compressed class pointers are used, but\n+  \/\/ only if not using compact headers..\n+  return UseCompressedClassPointers && !UseCompactObjectHeaders;\n+}\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+void oopDesc::set_narrow_klass(narrowKlass nk) {\n+  assert(DumpSharedSpaces, \"Used by CDS only. Do not abuse!\");\n+  assert(UseCompressedClassPointers, \"must be\");\n+  assert(!UseCompactObjectHeaders, \"not with compact headers\");\n+  _metadata._compressed_klass = nk;\n+}\n+#endif\n+\n@@ -148,1 +163,1 @@\n-  return obj->_klass;\n+  return obj->_metadata._klass;\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -55,3 +55,4 @@\n-#ifndef _LP64\n-  Klass*            _klass;\n-#endif\n+  union _metadata {\n+    Klass*      _klass;\n+    narrowKlass _compressed_klass;\n+  } _metadata;\n@@ -59,1 +60,1 @@\n- public:\n+public:\n@@ -82,1 +83,1 @@\n-#ifndef _LP64\n+  void set_narrow_klass(narrowKlass nk) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -85,1 +86,3 @@\n-#endif\n+\n+  \/\/ For klass field compression\n+  static inline void set_klass_gap(HeapWord* mem, int z);\n@@ -88,1 +91,8 @@\n-  static int header_size() { return sizeof(oopDesc)\/HeapWordSize; }\n+  static int header_size() {\n+#ifdef _LP64\n+    if (UseCompactObjectHeaders) {\n+      return sizeof(markWord) \/ HeapWordSize;\n+    } else\n+#endif\n+    return sizeof(oopDesc)\/HeapWordSize;\n+  }\n@@ -303,0 +313,2 @@\n+  static bool has_klass_gap();\n+\n@@ -305,0 +317,6 @@\n+  static int klass_gap_offset_in_bytes() {\n+    assert(has_klass_gap(), \"only applicable to compressed klass pointers\");\n+    assert(!UseCompactObjectHeaders, \"don't use klass_offset_in_bytes() with compact headers\");\n+    return klass_offset_in_bytes() + sizeof(narrowKlass);\n+  }\n+\n@@ -307,4 +325,18 @@\n-    STATIC_ASSERT(markWord::klass_shift % 8 == 0);\n-    return mark_offset_in_bytes() + markWord::klass_shift \/ 8;\n-#else\n-    return offset_of(oopDesc, _klass);\n+    if (UseCompactObjectHeaders) {\n+      STATIC_ASSERT(markWord::klass_shift % 8 == 0);\n+      return mark_offset_in_bytes() + markWord::klass_shift \/ 8;\n+    } else\n+#endif\n+    return offset_of(oopDesc, _metadata._klass);\n+  }\n+\n+  static int base_offset_in_bytes() {\n+#ifdef _LP64\n+    if (UseCompactObjectHeaders) {\n+      \/\/ With compact headers, the Klass* field is not used for the Klass*\n+      \/\/ and is used for the object fields instead.\n+      assert(sizeof(markWord) == 8, \"sanity\");\n+      return sizeof(markWord);\n+    } else if (UseCompressedClassPointers) {\n+      return sizeof(markWord) + sizeof(narrowKlass);\n+    } else\n@@ -312,0 +344,1 @@\n+    return sizeof(oopDesc);\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":44,"deletions":11,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/objectMonitor.inline.hpp\"\n@@ -85,0 +86,1 @@\n+  assert(UseFastLocking, \"Only safe with fast-locking\");\n@@ -94,5 +96,5 @@\n-  markWord header = resolve_mark();\n-  assert(UseCompressedClassPointers, \"expect compressed klass pointers\");\n-  header = markWord((header.value() & markWord::klass_mask_in_place) | markWord::prototype().value());\n-#else\n-  markWord header = markWord::prototype();\n+  if (UseCompactObjectHeaders) {\n+    markWord header = resolve_mark();\n+    assert(UseCompressedClassPointers, \"expect compressed klass pointers\");\n+    set_mark(markWord((header.value() & markWord::klass_mask_in_place) | markWord::prototype().value()));\n+  } else\n@@ -100,1 +102,1 @@\n-  set_mark(header);\n+  set_mark(markWord::prototype());\n@@ -105,5 +107,7 @@\n-  assert(UseCompressedClassPointers, \"only with compressed class pointers\");\n-  markWord header = resolve_mark();\n-  return header.klass();\n-#else\n-  return _klass;\n+  if (UseCompactObjectHeaders) {\n+    assert(UseCompressedClassPointers, \"only with compressed class pointers\");\n+    markWord header = resolve_mark();\n+    return header.klass();\n+  } else if (UseCompressedClassPointers) {\n+    return CompressedKlassPointers::decode_not_null(_metadata._compressed_klass);\n+  } else\n@@ -111,0 +115,1 @@\n+  return _metadata._klass;\n@@ -115,5 +120,7 @@\n-  assert(UseCompressedClassPointers, \"only with compressed class pointers\");\n-  markWord header = resolve_mark();\n-  return header.klass_or_null();\n-#else\n-  return _klass;\n+  if (UseCompactObjectHeaders) {\n+    assert(UseCompressedClassPointers, \"only with compressed class pointers\");\n+    markWord header = resolve_mark();\n+    return header.klass_or_null();\n+  } else if (UseCompressedClassPointers) {\n+    return CompressedKlassPointers::decode(_metadata._compressed_klass);\n+  } else\n@@ -121,0 +128,1 @@\n+  return _metadata._klass;\n@@ -125,8 +133,11 @@\n-  assert(UseCompressedClassPointers, \"only with compressed class pointers\");\n-  markWord header = mark_acquire();\n-  if (header.has_displaced_mark_helper()) {\n-    header = header.displaced_mark_helper();\n-   }\n-  return header.klass_or_null();\n-#else\n-  return Atomic::load_acquire(&_klass);\n+  if (UseCompactObjectHeaders) {\n+    assert(UseCompressedClassPointers, \"only with compressed class pointers\");\n+    markWord header = mark_acquire();\n+    if (header.has_monitor()) {\n+      header = header.monitor()->header();\n+    }\n+    return header.klass_or_null();\n+  } else if (UseCompressedClassPointers) {\n+     narrowKlass nklass = Atomic::load_acquire(&_metadata._compressed_klass);\n+     return CompressedKlassPointers::decode(nklass);\n+  } else\n@@ -134,0 +145,1 @@\n+  return Atomic::load_acquire(&_metadata._klass);\n@@ -136,1 +148,0 @@\n-#ifndef _LP64\n@@ -139,1 +150,6 @@\n-  _klass = k;\n+  assert(!UseCompactObjectHeaders, \"don't set Klass* with compact headers\");\n+  if (UseCompressedClassPointers) {\n+    _metadata._compressed_klass = CompressedKlassPointers::encode_not_null(k);\n+  } else {\n+    _metadata._klass = k;\n+  }\n@@ -144,0 +160,1 @@\n+  assert(!UseCompactObjectHeaders, \"don't set Klass* with compact headers\");\n@@ -152,1 +169,7 @@\n-#endif\n+\n+void oopDesc::set_klass_gap(HeapWord* mem, int v) {\n+  assert(!UseCompactObjectHeaders, \"don't set Klass* gap with compact headers\");\n+  if (UseCompressedClassPointers) {\n+    *(int*)(((char*)mem) + klass_gap_offset_in_bytes()) = v;\n+  }\n+}\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":50,"deletions":27,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -1673,3 +1673,4 @@\n-#ifndef _LP64\n-  rawmem = make_store(control, rawmem, object, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);\n-#endif\n+  if (!UseCompactObjectHeaders) {\n+    rawmem = make_store(control, rawmem, object, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3156,3 +3156,0 @@\n-  \/\/ Lilliput requires fast-locking.\n-  FLAG_SET_DEFAULT(UseFastLocking, true);\n-  FLAG_SET_DEFAULT(UseBiasedLocking, false);\n@@ -3160,1 +3157,17 @@\n-  FLAG_SET_DEFAULT(UseCompressedClassPointers, true);\n+  if (UseCompactObjectHeaders && FLAG_IS_CMDLINE(UseCompressedClassPointers) && !UseCompressedClassPointers) {\n+    \/\/ If user specifies -UseCompressedClassPointers, disable compact headers with a warning.\n+    warning(\"Compact object headers require compressed class pointers. Disabling compact object headers.\");\n+    FLAG_SET_DEFAULT(UseCompactObjectHeaders, false);\n+  }\n+  if (UseCompactObjectHeaders) {\n+    if (!UseFastLocking) {\n+      \/\/ Lilliput requires fast-locking.\n+      FLAG_SET_DEFAULT(UseFastLocking, true);\n+    }\n+    if (UseBiasedLocking) {\n+      FLAG_SET_DEFAULT(UseBiasedLocking, false);\n+    }\n+  }\n+  if (!UseCompactObjectHeaders) {\n+    FLAG_SET_DEFAULT(UseSharedSpaces, false);\n+  }\n@@ -3162,0 +3175,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -132,0 +132,3 @@\n+  product(bool, UseCompactObjectHeaders, true, EXPERIMENTAL,                \\\n+                \"Use 64-bit object headers instead of 96-bit headers\")      \\\n+                                                                            \\\n@@ -149,0 +152,1 @@\n+const bool UseCompactObjectHeaders = false;\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1435,1 +1435,1 @@\n-        lsh.print_cr(\"inflate(has_locker): object=\" INTPTR_FORMAT \", mark=\"\n+        lsh.print_cr(\"inflate(locked): object=\" INTPTR_FORMAT \", mark=\"\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -207,1 +207,2 @@\n-  NOT_LP64(volatile_nonstatic_field(oopDesc,   _klass,                                        Klass*))                               \\\n+  volatile_nonstatic_field(oopDesc,            _metadata._klass,                              Klass*)                                \\\n+  volatile_nonstatic_field(oopDesc,            _metadata._compressed_klass,                   narrowKlass)                           \\\n@@ -2644,0 +2645,1 @@\n+  LP64_ONLY(declare_constant(markWord::klass_shift))                      \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import sun.jvm.hotspot.oops.Mark;\n+import sun.jvm.hotspot.runtime.VM;\n+\n@@ -477,1 +480,9 @@\n-    long value = readCInteger(address, getKlassPtrSize(), true);\n+    long value;\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n+      \/\/ On 64 bit systems, the compressed Klass* is currently read from the mark\n+      \/\/ word. We need to load the whole mark, and shift the upper parts.\n+      value = readCInteger(address, machDesc.getAddressSize(), true);\n+      value = value >>> Mark.getKlassShift();\n+    } else {\n+      value = readCInteger(address, getKlassPtrSize(), true);\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/DebuggerBase.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -64,2 +64,10 @@\n-    assert(VM.getVM().isCompressedKlassPointersEnabled());\n-    headerSize = typeSize;\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n+      headerSize = lengthOffsetInBytes() + VM.getVM().getIntSize();\n+    } else {\n+      if (VM.getVM().isCompressedKlassPointersEnabled()) {\n+        headerSize = typeSize;\n+      } else {\n+        headerSize = VM.getVM().alignUp(typeSize + VM.getVM().getIntSize(),\n+                                        VM.getVM().getHeapWordSize());\n+      }\n+    }\n@@ -69,1 +77,9 @@\n-  private long lengthOffsetInBytes() {\n+  private static long headerSize(BasicType type) {\n+     if (Universe.elementTypeShouldBeAligned(type)) {\n+        return alignObjectSize(headerSizeInBytes())\/VM.getVM().getHeapWordSize();\n+     } else {\n+       return headerSizeInBytes()\/VM.getVM().getHeapWordSize();\n+     }\n+   }\n+\n+  private static long lengthOffsetInBytes() {\n@@ -73,2 +89,9 @@\n-    assert(VM.getVM().isCompressedKlassPointersEnabled());\n-    lengthOffsetInBytes = typeSize;\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n+      lengthOffsetInBytes = Oop.getHeaderSize();\n+    } else {\n+      if (VM.getVM().isCompressedKlassPointersEnabled()) {\n+        lengthOffsetInBytes = typeSize - VM.getVM().getIntSize();\n+      } else {\n+        lengthOffsetInBytes = typeSize;\n+      }\n+    }\n@@ -96,4 +119,10 @@\n-    long base = lengthOffsetInBytes + VM.getVM().getIntSize();\n-    if (Universe.elementTypeShouldBeAligned(type)) {\n-      VM vm = VM.getVM();\n-      base = vm.alignUp(base, vm.getBytesPerWord());\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n+      long typeSizeInBytes = headerSizeInBytes();\n+      if (Universe.elementTypeShouldBeAligned(type)) {\n+        VM vm = VM.getVM();\n+        return vm.alignUp(typeSizeInBytes, vm.getVM().getHeapWordSize());\n+      } else {\n+        return typeSizeInBytes;\n+      }\n+    } else {\n+      return headerSize(type) * VM.getVM().getHeapWordSize();\n@@ -101,1 +130,0 @@\n-    return base;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Array.java","additions":38,"deletions":10,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -58,0 +58,3 @@\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n+      return Oop.getHeaderSize();\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Instance.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -59,0 +59,3 @@\n+    if (VM.getVM().isLP64()) {\n+      klassShift          = db.lookupLongConstant(\"markWord::klass_shift\").longValue();\n+    }\n@@ -94,0 +97,1 @@\n+  private static long klassShift;\n@@ -124,0 +128,4 @@\n+  public static long getKlassShift() {\n+    return klassShift;\n+  }\n+\n@@ -226,1 +234,3 @@\n-    return (Klass)Metadata.instantiateWrapperFor(addr.getCompKlassAddressAt(4));\n+    assert(VM.getVM().isCompactObjectHeadersEnabled());\n+    assert(!hasMonitor());\n+    return (Klass)Metadata.instantiateWrapperFor(addr.getCompKlassAddressAt(0));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Mark.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -51,2 +51,7 @@\n-    if (!VM.getVM().isLP64()) {\n-      klass      = new MetadataField(type.getAddressField(\"_klass\"), 0);\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n+      Type markType = db.lookupType(\"markWord\");\n+      headerSize = markType.getSize();\n+    } else {\n+      headerSize = type.getSize();\n+      klass      = new MetadataField(type.getAddressField(\"_metadata._klass\"), 0);\n+      compressedKlass  = new NarrowKlassField(type.getAddressField(\"_metadata._compressed_klass\"), 0);\n@@ -54,1 +59,0 @@\n-    headerSize = type.getSize();\n@@ -77,0 +81,1 @@\n+  private static NarrowKlassField compressedKlass;\n@@ -82,0 +87,1 @@\n+    assert(VM.getVM().isCompactObjectHeadersEnabled());\n@@ -90,1 +96,1 @@\n-    if (VM.getVM().isLP64()) {\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n@@ -93,0 +99,2 @@\n+    } else if (VM.getVM().isCompressedKlassPointersEnabled()) {\n+      return (Klass)compressedKlass.getValue(getHandle());\n@@ -162,0 +170,7 @@\n+      if (!VM.getVM().isCompactObjectHeadersEnabled()) {\n+        if (VM.getVM().isCompressedKlassPointersEnabled()) {\n+          visitor.doMetadata(compressedKlass, true);\n+        } else {\n+          visitor.doMetadata(klass, true);\n+        }\n+      }\n@@ -216,1 +231,1 @@\n-    if (VM.getVM().isLP64()) {\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n@@ -219,0 +234,2 @@\n+    } else if (VM.getVM().isCompressedKlassPointersEnabled()) {\n+      return (Klass)Metadata.instantiateWrapperFor(handle.getCompKlassAddressAt(compressedKlass.getOffset()));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Oop.java","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -150,0 +150,1 @@\n+  private Boolean compactObjectHeadersEnabled;\n@@ -965,0 +966,9 @@\n+  public boolean isCompactObjectHeadersEnabled() {\n+    if (compactObjectHeadersEnabled == null) {\n+      Flag flag = getCommandLineFlag(\"UseCompactObjectHeaders\");\n+      compactObjectHeadersEnabled = (flag == null) ? Boolean.FALSE:\n+                     (flag.getBool()? Boolean.TRUE: Boolean.FALSE);\n+    }\n+    return compactObjectHeadersEnabled.booleanValue();\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/VM.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-        return Platform.is64bit();\n+        return Platform.is64bit() && !InputArguments.contains(\"-XX:-UseCompressedClassPointers\") \/*&& !InputArguments.contains(\"-XX:-UseCompactObjectHeaders\") *\/;\n","filename":"test\/hotspot\/jtreg\/gc\/metaspace\/TestMetaspacePerfCounters.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/\n@@ -29,1 +29,3 @@\n- * @run main\/othervm BaseOffsets\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI BaseOffsets\n@@ -33,1 +35,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/\n@@ -37,1 +39,3 @@\n- * @run main\/othervm -XX:-UseCompressedOops BaseOffsets\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-UseCompressedOops BaseOffsets\n@@ -47,0 +51,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -54,2 +59,19 @@\n-    \/\/ @0:  8 byte header,  @8: int field\n-    static final long INT_OFFSET  = 8L;\n+    static final long INT_OFFSET;\n+    static final int  INT_ARRAY_OFFSET;\n+    static final int  LONG_ARRAY_OFFSET;\n+    static {\n+        WhiteBox WB = WhiteBox.getWhiteBox();\n+        if (!Platform.is64bit() || WB.getBooleanVMFlag(\"UseCompactObjectHeaders\")) {\n+            INT_OFFSET = 8;\n+            INT_ARRAY_OFFSET = 12;\n+            LONG_ARRAY_OFFSET = 16;\n+        } else if (WB.getBooleanVMFlag(\"UseCompressedClassPointers\")) {\n+            INT_OFFSET = 12;\n+            INT_ARRAY_OFFSET = 16;\n+            LONG_ARRAY_OFFSET = 16;\n+        } else {\n+            INT_OFFSET = 16;\n+            INT_ARRAY_OFFSET = 20;\n+            LONG_ARRAY_OFFSET = 24;\n+        }\n+    }\n@@ -70,8 +92,8 @@\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(boolean[].class), 12, \"Misplaced boolean array base\");\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(byte[].class),    12, \"Misplaced byte    array base\");\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(char[].class),    12, \"Misplaced char    array base\");\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(short[].class),   12, \"Misplaced short   array base\");\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(int[].class),     12, \"Misplaced int     array base\");\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(long[].class),    16, \"Misplaced long    array base\");\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(float[].class),   12, \"Misplaced float   array base\");\n-        Asserts.assertEquals(unsafe.arrayBaseOffset(double[].class),  16, \"Misplaced double  array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(boolean[].class), INT_ARRAY_OFFSET,  \"Misplaced boolean array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(byte[].class),    INT_ARRAY_OFFSET,  \"Misplaced byte    array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(char[].class),    INT_ARRAY_OFFSET,  \"Misplaced char    array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(short[].class),   INT_ARRAY_OFFSET,  \"Misplaced short   array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(int[].class),     INT_ARRAY_OFFSET,  \"Misplaced int     array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(long[].class),    LONG_ARRAY_OFFSET, \"Misplaced long    array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(float[].class),   INT_ARRAY_OFFSET,  \"Misplaced float   array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(double[].class),  LONG_ARRAY_OFFSET, \"Misplaced double  array base\");\n@@ -80,1 +102,1 @@\n-        int expected_objary_offset = narrowOops ? 12 : 16;\n+        int expected_objary_offset = narrowOops ? INT_ARRAY_OFFSET : LONG_ARRAY_OFFSET;\n","filename":"test\/hotspot\/jtreg\/runtime\/FieldLayout\/BaseOffsets.java","additions":37,"deletions":15,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/\n@@ -32,1 +32,3 @@\n- * @run main\/othervm -XX:+UseCompressedClassPointers -XX:-UseEmptySlotsInSupers OldLayoutCheck\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseCompressedClassPointers -XX:-UseEmptySlotsInSupers OldLayoutCheck\n@@ -38,1 +40,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/\n@@ -41,1 +43,3 @@\n- * @run main\/othervm -XX:-UseEmptySlotsInSupers OldLayoutCheck\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-UseEmptySlotsInSupers OldLayoutCheck\n@@ -51,0 +55,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -59,5 +64,12 @@\n-    \/\/ 32-bit VMs: @0:  8 byte header,  @8: long field, @16:  int field\n-    \/\/ 64-bit VMs: @0: 12 byte header, @12:  int field, @16: long field\n-    static final long INT_OFFSET  = 16L;\n-    static final long LONG_OFFSET = 8L;\n-\n+    private static final long INT_OFFSET;\n+    private static final long LONG_OFFSET;\n+    static {\n+      WhiteBox WB = WhiteBox.getWhiteBox();\n+      if (!Platform.is64bit() || WB.getBooleanVMFlag(\"UseCompactObjectHeaders\")) {\n+        INT_OFFSET = 16L;\n+        LONG_OFFSET = 8L;\n+      } else {\n+        INT_OFFSET = 12L;\n+        LONG_OFFSET = 16L;\n+      }\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/FieldLayout\/OldLayoutCheck.java","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"}]}