{"files":[{"patch":"@@ -50,4 +50,8 @@\n-  JavaThread* thread = JavaThread::current();\n-  bool is_owning = &thread->lock_stack() == this;\n-  assert(is_owning == (get_thread() == thread), \"is_owning sanity\");\n-  return is_owning;\n+  Thread* current = Thread::current();\n+  if (current->is_Java_thread()) {\n+    JavaThread* thread = current->as_Java_thread();\n+    bool is_owning = &thread->lock_stack() == this;\n+    assert(is_owning == (get_thread() == thread), \"is_owning sanity\");\n+    return is_owning;\n+  }\n+  return false;\n","filename":"src\/hotspot\/share\/runtime\/lockStack.inline.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8317262\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+HandshakeALot -XX:GuaranteedSafepointInterval=1 TestStackWalk\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+import java.util.concurrent.CountDownLatch;\n+\n+public class TestStackWalk {\n+    static Thread worker1;\n+    static Thread worker2;\n+    static volatile boolean done;\n+    static volatile int counter = 0;\n+    static Object lock = new Object();\n+\n+    public static void main(String... args) throws Exception {\n+        worker1 = new Thread(() -> syncedWorker());\n+        worker1.start();\n+        worker2 = new Thread(() -> syncedWorker());\n+        worker2.start();\n+        Thread worker3 = new Thread(() -> stackWalker());\n+        worker3.start();\n+\n+        worker1.join();\n+        worker2.join();\n+        worker3.join();\n+    }\n+\n+    public static void syncedWorker() {\n+        synchronized (lock) {\n+            while (!done) {\n+                counter++;\n+            }\n+        }\n+    }\n+\n+    public static void stackWalker() {\n+        \/\/ Suspend workers so the one looping waiting for \"done\"\n+        \/\/ doesn't execute the handshake below, increasing the\n+        \/\/ chances the VMThread will do it.\n+        suspendWorkers();\n+\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        long end = System.currentTimeMillis() + 20000;\n+        while (end > System.currentTimeMillis()) {\n+            wb.handshakeWalkStack(worker1, false \/* all_threads *\/);\n+            wb.handshakeWalkStack(worker2, false \/* all_threads *\/);\n+        }\n+\n+        resumeWorkers();\n+        done = true;\n+    }\n+\n+    static void suspendWorkers() {\n+        worker1.suspend();\n+        worker2.suspend();\n+    }\n+\n+    static void resumeWorkers() {\n+        worker1.resume();\n+        worker2.resume();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/lockStack\/TestStackWalk.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"}]}