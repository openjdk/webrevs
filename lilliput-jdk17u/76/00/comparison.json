{"files":[{"patch":"@@ -69,13 +69,16 @@\n-  if (displaced_header().is_neutral()) {\n-    \/\/ The object is locked and the resulting ObjectMonitor* will also be\n-    \/\/ locked so it can't be async deflated until ownership is dropped.\n-    ObjectSynchronizer::inflate_helper(obj);\n-    \/\/ WARNING: We cannot put a check here, because the inflation\n-    \/\/ will not update the displaced header. Once BasicLock is inflated,\n-    \/\/ no one should ever look at its content.\n-  } else {\n-    \/\/ Typically the displaced header will be 0 (recursive stack lock) or\n-    \/\/ unused_mark.  Naively we'd like to assert that the displaced mark\n-    \/\/ value is either 0, neutral, or 3.  But with the advent of the\n-    \/\/ store-before-CAS avoidance in fast_lock\/compiler_lock_object\n-    \/\/ we can find any flavor mark in the displaced mark.\n+  if (LockingMode == LM_LEGACY) {\n+    if (displaced_header().is_neutral()) {\n+      \/\/ The object is locked and the resulting ObjectMonitor* will also be\n+      \/\/ locked so it can't be async deflated until ownership is dropped.\n+      ObjectSynchronizer::inflate_helper(obj);\n+      \/\/ WARNING: We cannot put a check here, because the inflation\n+      \/\/ will not update the displaced header. Once BasicLock is inflated,\n+      \/\/ no one should ever look at its content.\n+    } else {\n+      \/\/ Typically the displaced header will be 0 (recursive stack lock) or\n+      \/\/ unused_mark.  Naively we'd like to assert that the displaced mark\n+      \/\/ value is either 0, neutral, or 3.  But with the advent of the\n+      \/\/ store-before-CAS avoidance in fast_lock\/compiler_lock_object\n+      \/\/ we can find any flavor mark in the displaced mark.\n+    }\n+    dest->set_displaced_header(displaced_header());\n@@ -83,1 +86,5 @@\n-  dest->set_displaced_header(displaced_header());\n+#ifdef ASSERT\n+  else {\n+    dest->set_displaced_header(markWord(badDispHeaderDeopt));\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/basicLock.cpp","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -3244,6 +3244,11 @@\n-      \/\/ Inflate so the object's header no longer refers to the BasicLock.\n-      if (lock->displaced_header().is_unlocked()) {\n-        \/\/ The object is locked and the resulting ObjectMonitor* will also be\n-        \/\/ locked so it can't be async deflated until ownership is dropped.\n-        \/\/ See the big comment in basicLock.cpp: BasicLock::move_to().\n-        ObjectSynchronizer::inflate_helper(kptr2->obj());\n+      if (LockingMode == LM_LEGACY) {\n+        \/\/ Inflate so the object's header no longer refers to the BasicLock.\n+        if (lock->displaced_header().is_unlocked()) {\n+          \/\/ The object is locked and the resulting ObjectMonitor* will also be\n+          \/\/ locked so it can't be async deflated until ownership is dropped.\n+          \/\/ See the big comment in basicLock.cpp: BasicLock::move_to().\n+          ObjectSynchronizer::inflate_helper(kptr2->obj());\n+        }\n+        \/\/ Now the displaced header is free to move because the\n+        \/\/ object's header no longer refers to it.\n+        buf[i] = (intptr_t)lock->displaced_header().value();\n@@ -3251,3 +3256,6 @@\n-      \/\/ Now the displaced header is free to move because the\n-      \/\/ object's header no longer refers to it.\n-      buf[i++] = (intptr_t)lock->displaced_header().value();\n+#ifdef ASSERT\n+      else {\n+        buf[i] = badDispHeaderOSR;\n+      }\n+#endif\n+      i++;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -993,1 +993,2 @@\n-\n+const intptr_t badDispHeaderDeopt = 0xDE0BD000;             \/\/ value to fill unused displaced header during deoptimization\n+const intptr_t badDispHeaderOSR   = 0xDEAD05A0;             \/\/ value to fill unused displaced header during OSR\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}