{"files":[{"patch":"@@ -85,1 +85,1 @@\n-        COMMAND mig -DMACH_EXC_SERVER_TASKIDTOKEN -sheader MachExceptionsServer.h MachExceptions.defs\n+        COMMAND mig -sheader MachExceptionsServer.h MachExceptions.defs\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WTF\/wtf\/PlatformJSCOnly.cmake","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-#include <mach\/thread_status.h>\n@@ -52,1 +51,0 @@\n-#include <unistd.h>\n@@ -58,1 +56,0 @@\n-#include <wtf\/Scope.h>\n@@ -61,1 +58,0 @@\n-#include <wtf\/TranslatedProcess.h>\n@@ -210,153 +206,0 @@\n-static kern_return_t runSignalHandlers(Signal &signal, PlatformRegisters& registers, bool &didHandle, mach_msg_type_number_t dataCount, mach_exception_data_t exceptionData)\n-{\n-    SigInfo info;\n-    SignalHandlers& handlers = g_wtfConfig.signalHandlers;\n-    if (signal == Signal::AccessFault) {\n-        ASSERT_UNUSED(dataCount, dataCount == 2);\n-        info.faultingAddress = reinterpret_cast<void*>(exceptionData[1]);\n-#if CPU(ADDRESS64)\n-        \/\/ If the faulting address is out of the range of any valid memory, we would\n-        \/\/ not have any reason to handle it. Just let the default handler take care of it.\n-        static constexpr unsigned validAddressBits = OS_CONSTANT(EFFECTIVE_ADDRESS_WIDTH);\n-        static constexpr uintptr_t invalidAddressMask = ~((1ull << validAddressBits) - 1);\n-        if (bitwise_cast<uintptr_t>(info.faultingAddress) & invalidAddressMask)\n-            return KERN_FAILURE;\n-#endif\n-    }\n-\n-    handlers.forEachHandler(signal, [&] (const SignalHandler& handler) {\n-        SignalAction handlerResult = handler(signal, info, registers);\n-        didHandle |= handlerResult == SignalAction::Handled;\n-    });\n-    return KERN_SUCCESS;\n-}\n-\n-#ifdef EXCEPTION_IDENTITY_PROTECTED\n-\n-static thread_act_t threadIDGetThreadPort(uint64_t threadID)\n-{\n-    mach_msg_type_number_t threadCount;\n-    thread_act_array_t threads;\n-    thread_act_t thread = THREAD_NULL;\n-\n-    task_threads(mach_task_self(), &threads, &threadCount);\n-    for (mach_msg_type_number_t i = 0; i < threadCount; i++) {\n-        if (thread != THREAD_NULL) {\n-            \/\/ clean up all the remaining mach thread ports\n-            ASSERT(thread != threads[i]);\n-            mach_port_deallocate(mach_task_self(), threads[i]);\n-            continue;\n-        }\n-\n-        struct thread_identifier_info threadIdentifierInfo;\n-        unsigned infoCount = THREAD_IDENTIFIER_INFO_COUNT;\n-        kern_return_t kr = thread_info(threads[i], THREAD_IDENTIFIER_INFO,\n-            reinterpret_cast<thread_info_t>(&threadIdentifierInfo), &infoCount);\n-\n-        if (kr == MACH_SEND_INVALID_DEST) {\n-            \/\/ ignore threads that have been destroyed\n-            continue;\n-        }\n-        if (kr != KERN_SUCCESS) {\n-            dataLogLn(\"thread_info failed due to \", mach_error_string(kr));\n-            continue;\n-        }\n-\n-        if (threadIdentifierInfo.thread_id == threadID) {\n-            \/\/ we found the thread we are looking for\n-            thread = threads[i];\n-            continue;\n-        }\n-        \/\/ clean up mach thread ports\n-        mach_port_deallocate(mach_task_self(), threads[i]);\n-    }\n-    \/\/ clean up array\n-    vm_deallocate(mach_task_self(), (vm_address_t)threads,\n-        sizeof(threads[0]) * threadCount);\n-    return thread;\n-}\n-\n-kern_return_t catch_mach_exception_raise_identity_protected(\n-    mach_port_t exceptionPort,\n-    uint64_t threadID,\n-    mach_port_t taskIDToken,\n-    exception_type_t exceptionType,\n-    mach_exception_data_t exceptionData,\n-    mach_msg_type_number_t dataCount)\n-{\n-    UNUSED_PARAM(taskIDToken);\n-\n-    SignalHandlers& handlers = g_wtfConfig.signalHandlers;\n-    RELEASE_ASSERT(exceptionPort == handlers.exceptionPort);\n-    \/\/ If we wanted to distinguish between SIGBUS and SIGSEGV for EXC_BAD_ACCESS on Darwin we could do:\n-    \/\/ if (exceptionData[0] == KERN_INVALID_ADDRESS)\n-    \/\/    signal = SIGSEGV;\n-    \/\/ else\n-    \/\/    signal = SIGBUS;\n-    Signal signal = fromMachException(exceptionType);\n-    RELEASE_ASSERT(signal != Signal::Unknown);\n-\n-    thread_act_t thread = threadIDGetThreadPort(threadID);\n-    auto clear = makeScopeExit([&] {\n-        mach_port_deallocate(mach_task_self(), thread);\n-    });\n-\n-\n-    mach_msg_type_number_t stateCount = 0;\n-\n-#if CPU(X86_64) || CPU(X86)\n-    x86_thread_state_t state;\n-    int flavor = x86_THREAD_STATE;\n-    stateCount = x86_THREAD_STATE_COUNT;\n-#elif CPU(ARM64) || CPU(ARM)\n-    arm_unified_thread_state state;\n-    int flavor = ARM_THREAD_STATE;\n-    stateCount = ARM_UNIFIED_THREAD_STATE_COUNT;\n-#endif\n-\n-    kern_return_t kr = thread_get_state(thread, flavor, (thread_state_t)&state, &stateCount);\n-    if (kr != KERN_SUCCESS) {\n-        dataLogLn(\"thread_get_state failed due to \", mach_error_string(kr));\n-        return kr;\n-    }\n-\n-#if CPU(ARM64E) && OS(DARWIN)\n-    ptrauth_generic_signature_t inStateHash = hashThreadState((thread_state_t)&state);\n-#endif\n-\n-#if CPU(X86_64)\n-    PlatformRegisters& registers = state.uts.ts64;\n-    RELEASE_ASSERT(state.tsh.flavor == x86_THREAD_STATE64);\n-#elif CPU(X86)\n-    PlatformRegisters& registers = state.uts.ts32;\n-    RELEASE_ASSERT(state.tsh.flavor == x86_THREAD_STATE32);\n-#elif CPU(ARM64)\n-    PlatformRegisters& registers = state.ts_64;\n-    RELEASE_ASSERT(state.ash.flavor == ARM_THREAD_STATE64);\n-#elif CPU(ARM)\n-    PlatformRegisters& registers = state.ts_32;\n-    RELEASE_ASSERT(state.ash.flavor == ARM_THREAD_STATE32);\n-#endif\n-\n-    bool didHandle = false;\n-    kr = runSignalHandlers(signal, registers, didHandle, dataCount, exceptionData);\n-    if (kr != KERN_SUCCESS)\n-        return kr;\n-\n-    if (didHandle) {\n-#if CPU(ARM64E) && OS(DARWIN)\n-        RELEASE_ASSERT(inStateHash == hashThreadState((thread_state_t)&state));\n-#endif\n-        kr = thread_set_state(thread, flavor, (thread_state_t)&state,\n-            stateCount);\n-\n-        if (kr != KERN_SUCCESS)\n-            dataLogLn(\"thread_set_state failed due to \", mach_error_string(kr));\n-\n-        return kr;\n-    }\n-    return KERN_FAILURE;\n-}\n-\n-#endif \/\/ EXCEPTION_IDENTITY_PROTECTED\n-\n@@ -404,0 +247,14 @@\n+    SigInfo info;\n+    if (signal == Signal::AccessFault) {\n+        ASSERT_UNUSED(dataCount, dataCount == 2);\n+        info.faultingAddress = reinterpret_cast<void*>(exceptionData[1]);\n+#if CPU(ADDRESS64)\n+        \/\/ If the faulting address is out of the range of any valid memory, we would\n+        \/\/ not have any reason to handle it. Just let the default handler take care of it.\n+        static constexpr unsigned validAddressBits = OS_CONSTANT(EFFECTIVE_ADDRESS_WIDTH);\n+        static constexpr uintptr_t invalidAddressMask = ~((1ull << validAddressBits) - 1);\n+        if (bitwise_cast<uintptr_t>(info.faultingAddress) & invalidAddressMask)\n+            return KERN_FAILURE;\n+#endif\n+    }\n+\n@@ -405,3 +262,4 @@\n-    kern_return_t kr = runSignalHandlers(signal, registers, didHandle, dataCount, exceptionData);\n-    if (kr != KERN_SUCCESS)\n-        return kr;\n+    handlers.forEachHandler(signal, [&] (const SignalHandler& handler) {\n+        SignalAction handlerResult = handler(signal, info, registers);\n+        didHandle |= handlerResult == SignalAction::Handled;\n+    });\n@@ -433,15 +291,1 @@\n-\n-#ifdef EXCEPTION_IDENTITY_PROTECTED\n-    exception_behavior_t newBehavior = MACH_EXCEPTION_CODES;\n-    if (WTF::isX86BinaryRunningOnARM()) {\n-        \/\/ If we are a translated process in rosetta, use the old exception style\n-        newBehavior |= EXCEPTION_STATE;\n-    } else {\n-        \/\/ Otherwise use the new style\n-        newBehavior |= EXCEPTION_IDENTITY_PROTECTED;\n-    }\n-#else\n-    exception_behavior_t newBehavior = EXCEPTION_STATE | MACH_EXCEPTION_CODES;\n-#endif \/\/ EXCEPTION_IDENTITY_PROTECTED\n-\n-    kern_return_t result = thread_set_exception_ports(thread.machThread(), handlers.addedExceptions &activeExceptions, handlers.exceptionPort, newBehavior, MACHINE_THREAD_STATE);\n+    kern_return_t result = thread_set_exception_ports(thread.machThread(), handlers.addedExceptions &activeExceptions, handlers.exceptionPort, EXCEPTION_STATE | MACH_EXCEPTION_CODES, MACHINE_THREAD_STATE);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WTF\/wtf\/threads\/Signals.cpp","additions":19,"deletions":175,"binary":false,"changes":194,"status":"modified"}]}